ect( %s )\n",
        pZone->pszZoneName ));

    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList(
            "Update list before checkTempNodesForUpdateEffect",
            pUpdateList );
    }

    //
    //  loop through temp nodes
    //
    //  check each to see if changed from temp node
    //  three possibilities:
    //
    //      - no change
    //      - no data change but aging change
    //      - RR data changed
    //
    //  for zone's with scavenging ON, any aging change
    //      requires DS write
    //  for zone's without scavenging, only change to turn OFF
    //      aging requires write
    //

    for ( pnodeTemp = pUpdateList->pTempNodeList;
          pnodeTemp != NULL;
          pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp) )
    {
        DWORD   writeResult;

        pnodeReal = TNODE_MATCHING_REAL_NODE(pnodeTemp);

        writeResult = RR_ListCheckIfNodeNeedsRefresh(
                            pnodeReal,
                            pnodeTemp->pRRList,
                            pZone->dwRefreshTime
                            );

        TNODE_WRITE_STATE(pnodeTemp) = writeResult;

        if ( writeResult != RRLIST_MATCH )
        {
            if ( writeResult == RRLIST_NO_MATCH )
            {
                fneedUpdate = TRUE;
                fneedWrite = TRUE;
                TNODE_SET_FOR_DS_WRITE(pnodeTemp);

                //  check for changing DNS host data
                //  may tag for DS-peer update

                if ( IS_THIS_HOST_NODE(pnodeReal) )
                {
                    checkDnsServerHostUpdate(
                        pZone,
                        pUpdateList,
                        pnodeReal,
                        pnodeTemp );
                }
            }
            else if ( pZone->bAging ||
                writeResult == RRLIST_AGING_OFF )
            {
                fneedWrite = TRUE;
                TNODE_SET_FOR_DS_WRITE(pnodeTemp);
            }
        }

        DNS_DEBUG( UPDATE, (
            "Temp node %s (%p) real=%p:  write state = %p;  do DS write = %d\n",
            pnodeTemp->szLabel,
            pnodeTemp,
            pnodeReal,
            writeResult,
            TNODE_NEEDS_DS_WRITE(pnodeTemp) ));
    }

    //
    //  complete no-op ?
    //

    if ( !fneedWrite )
    {
        DNS_DEBUG( UPDATE, (
            "Update %p for zone %s is complete no-op\n",
            pUpdateList,
            pZone->pszZoneName ));

        return( FALSE );
    }

    //
    //  set update serial number
    //      - dwNewSerialNo serves as flag, if non-zero, DS writes are done
    //      with it's serial no
    //
    //      - only increment serial number if UPDATE is success and will have
    //      new zone serial;  if only aging refresh, then no increment
    //

    if ( fneedUpdate )
    {
        DWORD   serial = pZone->dwSerialNo + 1;
        if ( serial == 0 )
        {
            serial++;
        }
        pZone->dwNewSerialNo = serial;
    }
    else
    {
        pZone->dwNewSerialNo = pZone->dwSerialNo;
    }

    return( TRUE );
}



VOID
resetAndSuppressTempUpdatesForCompletion(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Suppress updates which amount to no-ops.

Arguments:

    pZone - zone to update

    pUpdateList - list with update

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    PDB_NODE        pnode;
    PDB_NODE        pnodeReal;
    PDB_NODE        pnodeTemp;
    PUPDATE         pupdate;
    PUPDATE         pupdatePrevious;
    PDB_RECORD      poriginalRR;
    DNS_STATUS      status = ERROR_SUCCESS;

    DNS_DEBUG( UPDATE, (
        "resetAndSuppressTempUpdatesForCompletion( %s )\n",
        pZone->pszZoneName ));

    //
    //  non-DS determine if update changed RR data
    //
    //  DS zones already do this check prior to DS write and do not
    //  need to do it again
    //

    if ( !pZone->fDsIntegrated )
    {
        checkTempNodesForUpdateEffect(
            pZone,
            pUpdateList
            );
    }

    IF_DEBUG( UPDATE )
    {
        Dbg_UpdateList(
            "Update list before swap back suppression",
            pUpdateList );
    }

    //
    //  swap executed RR lists back onto real nodes
    //
    //  for DS
    //      - swap in ONLY when wrote back, keeping in ssync with DS
    //
    //  non-DS
    //      - skip swap on full match
    //      (simple and gives best data when convert)
    //
    //      the detailed approach would be
    //      - aging, skip swap on full match
    //      - non-aging, skip swap on anything but NO_MATCH
    //

    for ( pnodeTemp = pUpdateList->pTempNodeList;
          pnodeTemp != NULL;
          pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp) )
    {
#ifndef TEST_UP
        if ( pZone->fDsIntegrated )
        {
            if ( !TNODE_NEEDS_DS_WRITE(pnodeTemp) )
            //if ( TNODE_WRITE_STATE(pnodeTemp) != TNODE_FLAG_DS_WRITTEN )
            //  DS_WRITTEN not currently being set
            {
                DNS_DEBUG( UPDATE2, (
                    "Skipping swap-back for node %s\n"
                    "\tno DS write was done.\n",
                    pnodeTemp->szLabel ));
                continue;
            }
        }
        else
        {
            if ( TNODE_WRITE_STATE(pnodeTemp) == RRLIST_MATCH )
            {
                DNS_DEBUG( UPDATE2, (
                    "Skipping swap-back for node %s\n"
                    "\texactly matches real node.\n",
                    pnodeTemp->szLabel ));
                continue;
            }
        }
#else
        //  in testing treat non-DS like DS
        //  this will allow for some non-swapped nodes and make sure that
        //      cleanup handles all paths
        //
        //  DEVNOTE: aging timestamp only updates (not in DS) kept in memory
        //      only problem is this keeps some AGING timestamp only updates that
        //      did NOT get written to DS
        //

        if ( TNODE_WRITE_STATE(pnodeTemp) == RRLIST_MATCH )
        {
            DNS_DEBUG( UPDATE2, (
                "Skipping swap-back for node %s\n"
                "\texactly matches real node, no DS write was done.\n",
                pnodeTemp->szLabel ));
            continue;
        }
#endif

        //
        //  swap
        //      - get matching real node
        //      - swap RR lists
        //      - reset flags in real node
        //      - reset authority in real node
        //      - temp node will carry and ultimately free original RR list
        //

        pnodeReal = TNODE_MATCHING_REAL_NODE(pnodeTemp);
        ASSERT( pnodeReal );
        IF_DEBUG( UPDATE2 )
        {
            Dbg_DbaseNode( "Real node before swap:", pnodeReal );
        }

        LOCK_RR_LIST( pnodeReal );

        poriginalRR = pnodeReal->pRRList;
        pnodeReal->pRRList = pnodeTemp->pRRList;

        COPY_BACK_NODE_FLAGS( pnodeReal, pnodeTemp );
        pnodeReal->uchAuthority = pnodeTemp->uchAuthority;

        //  make absolutely sure zone root is marked dirty if swap root node's list

        if ( IS_AUTH_ZONE_ROOT(pnodeReal) )
        {
            pZone->fRootDirty = TRUE;
        }

        UNLOCK_RR_LIST( pnodeReal );

        pnodeTemp->pRRList = poriginalRR;

        IF_DEBUG( UPDATE2 )
        {
            Dbg_DbaseNode( "Real node after swap:", pnodeReal );
        }
    }

    IF_DEBUG( UPDATE )
    {
        Dbg_UpdateList(
            "Update list -- before no-op suppression",
            pUpdateList );
    }

    //
    //  loop through all updates in list
    //
    //      - reset node ptrs to real nodes
    //      - suppress net-no-op updates
    //
    //      if update corresponds to a node which did NOT require
    //      an update, then it can be thrown out
    //

    pupdate = (PUPDATE) pUpdateList;

    while ( pupdatePrevious = pupdate,  pupdate=pupdate->pNext )
    {
        pnodeTemp = pupdate->pNode;

        ASSERT( pnodeTemp );
        ASSERT( IS_TNODE(pnodeTemp) );

        if ( !pnodeTemp || !IS_TNODE(pnodeTemp) )
        {
            continue;
        }

        //
        //  reset node ptr to real node
        //      - need to do this BEFORE suppression, as deleting
        //      update does the deref, which MUST be done on real node
        //

        pupdate->pNode = TNODE_MATCHING_REAL_NODE(pnodeTemp);

        //
        //  node NOT changed in update --> delete update
        //
        //  note, "changed" is not a test for whether node written (DS)
        //  or whether new RR list copied (non-DS), but only the
        //  question of whether a real update was made
        //
        //  the theory is that aging changes are no wire protocol
        //  (hence irrelevant for IXFR), nor will we force datafile
        //  write simply for aging (next write picks them up)
        //

        if ( TNODE_WRITE_STATE(pnodeTemp) != RRLIST_NO_MATCH )
        {
            IF_DEBUG( UPDATE )
            {
                Dbg_Update(
                    "Suppressing update at no-op node:",
                    pupdate );
            }

            Up_DetachAndFreeUpdateGivenPrevious(
                    pUpdateList,
                    pupdatePrevious,
                    pupdate );

            //  reset pupdate for next pass

            pupdate = pupdatePrevious;
        }
    }

    VALIDATE_UPDATE_LIST( pUpdateList );

    IF_DEBUG( UPDATE )
    {
        Dbg_UpdateList(
            "Update list after no-op suppression -- read for completion",
            pUpdateList );
    }
}



DNS_STATUS
prepareUpdateListForExecution(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Creates temporary nodes to execute the updates on.
    These are used so we can execute updates and still
        roll back to previous state on failure.

    Temp nodes are created, then updates of existing data made
    from DS (reads).  Then updates can be executed on temp
    nodes.

Arguments:

    pZone - zone to update

    pUpdateList - list with update

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    PUPDATE         pupdate;
    PDB_NODE        pnodeReal;
    PDB_NODE        pnodeTemp;
    DNS_STATUS      status = ERROR_SUCCESS;

    DNS_DEBUG( UPDATE, (
        "prepareUpdateListForExecution( %s )\n",
        pZone->pszZoneName ));


    //
    //  loop through all updates in list
    //
    //      - find or create temporary node for real database node
    //      - if creating, create copy of node's RR list, to "execute" update on
    //      - update reset to point at temporary node
    //
    //  DEVNOTE: shouldn't have to make update list copy
    //      once verify we can do clean substitution after running update on
    //      temp node, THEN we can just do replace to real node and not execute
    //      update on real, THEN we can skip this step
    //

    pupdate = (PUPDATE) pUpdateList;

    while ( pupdate = pupdate->pNext )
    {
        pnodeReal = pupdate->pNode;

        //  for each real node, create temp node
        //      - search list so don't create duplicates

        for ( pnodeTemp = pUpdateList->pTempNodeList;
              pnodeTemp != NULL;
              pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp) )
        {
            if ( TNODE_MATCHING_REAL_NODE(pnodeTemp) == pnodeReal )
            {
                break;
            }
        }

        //  not in temp node list
        //      - read DS data to real node
        //      - create temp node copy, append to temp node list

        if ( !pnodeTemp )
        {
            pnodeTemp = NTree_CopyNode( pnodeReal );
            IF_NOMEM( !pnodeTemp )
            {
                return( DNS_RCODE_SERVER_FAILURE );
            }
            TNODE_MATCHING_REAL_NODE(pnodeTemp) = pnodeReal;
            TNODE_FLAG(pnodeTemp) = TNODE_FLAG_NEW;
            TNODE_WRITE_STATE(pnodeTemp) = (DWORD) -1;

            TNODE_NEXT_TEMP_NODE(pnodeTemp) = pUpdateList->pTempNodeList;
            pUpdateList->pTempNodeList = pnodeTemp;
        }

        //  replace real node with temp node

        pupdate->pNode = pnodeTemp;
    }

    //
    //  read DS data for nodes being updated
    //      - if data is different, update in memory list
    //
    //  DEVNOTE: in the 99% case, this refresh is a no-op
    //      it would be cool if we could use the duplicate
    //      RR list generated as the RR list copy below
    //      we'd have to percolate back the duplicate we no-ops
    //      out;  note pretty small win
    //

    if ( pZone->fDsIntegrated )
    {
        status = Ds_UpdateNodeListFromDs(
                    pZone,
                    pUpdateList->pTempNodeList
                    );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  updating update nodes from DS!\n"
                "\tstatus = %p (%d)\n",
                status, status ));

            //return( status );
        }
    }

    //
    //  copy (now refreshed from DS) data at update nodes
    //      need to refresh the node flags, because DS read may
    //      have picked up records (like CNAME, NS) that weren't
    //      present when copy made, changing flag
    //

    for ( pnodeTemp = pUpdateList->pTempNodeList;
          pnodeTemp != NULL;
          pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp) )
    {
        pnodeReal = TNODE_MATCHING_REAL_NODE(pnodeTemp);

        pnodeTemp->pRRList = RR_ListForNodeCopy(
                                pnodeReal,
                                RRCOPY_EXCLUDE_CACHED_DATA );

        pnodeTemp->wNodeFlags = (pnodeReal->wNodeFlags & NODE_FLAGS_SAVED_ON_COPY);
    }

    DNS_DEBUG( UPDATE, ( "Leaving prepareUpdateListForExecution()\n" ));
    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList(
            "Update list after prepare:",
            pUpdateList );
    }

    return( ERROR_SUCCESS );
}




BOOL
Up_IsDuplicateAdd(
    IN OUT  PUPDATE_LIST    pUpdateList,    OPTIONAL
    IN OUT  PUPDATE         pUpdate,
    IN OUT  PUPDATE         pUpdatePrev     OPTIONAL
    )
/*++

Routine Description:

    Determine if update is duplicate.

    Detect and eliminate duplicate adds.
    Note:  currently only detect and mark, no elimination yet possible.

Arguments:

    pUpdateList - list with update

    pUpdate - ptr to update

    pUpdatePrev - ptr to previous update

Return Value:

    TRUE if duplicate add.
    FALSE if not duplicate.

--*/
{
    PUPDATE     pup = pUpdate;
    PDB_NODE    pnode;
    WORD        addType;
    DWORD       count;


    DNS_DEBUG( UPDATE2, (
        "Up_IsDuplicateAdd( %p )\n",
        pUpdate ));

    //
    //  already marked duplicate
    //

    if ( IS_UPDATE_DUPLICATE_ADD(pup) )
    {
        DNS_DEBUG( UPDATE, (
            "Duplicate update add at %p.\n",
            pup ));
        return( TRUE );
    }

    //  must be add update
    //      - otherwise shouldn't even be called to check

    if ( !pup->wAddType )
    {
        ASSERT( FALSE );
        return( TRUE );
    }

    if ( IS_UPDATE_NON_DUPLICATE_ADD(pup) )
    {
        DNS_DEBUG( UPDATE2, (
            "Non-Duplicate update add at %p.\n",
            pup ));
        return( FALSE );
    }

    //
    //  loop through all remaining updates in list
    //
    //      - if find add update for same RR set, then
    //      original update is duplicate of update further downstream
    //
    //  DEVNOTE: should find a way to save AddType while still marking as duplicate
    //      that way we can stop checking immediately;
    //      problem is that WINS screws up tagging high bits of AddType
    //      and DS updates are replace with delete type ALL, which prohibits
    //          overloading delete type
    //
    //      fortunately this is not a big problem
    //      - usually requests will be for later nodes -- rare to find and existing one
    //      - when we improve this we'll be deleting them anyway (except for DS replace
    //          which also have delete RRs)
    //
    //      - limit to 100 updates so don't get into order n**2
    //      this handles repetitive update case as generally requests will come in
    //      fairly regularly so that updates get marked early
    //
    //  DEVNOTE: should save "last update serial" at node
    //      so know if it is appropriate to look forward;
    //

    pnode = pup->pNode;
    addType = pup->wAddType;
    count = 100;                // sanity limit of 100 updates deep

    while ( pup = pup->pNext )
    {
        //  if checked far enough upstream -- give up
        //  and mark so don't check again

        if ( count-- == 0 )
        {
            pUpdate->wDeleteType = UPDATE_OP_NON_DUPLICATE_ADD;
            break;
        }

        if ( pup->pNode != pnode )
        {
            continue;
        }

        if ( pup->wAddType != addType &&
            pup->wAddType != DNS_TYPE_ALL )
        {
            continue;
        }

        //  pUpdate is duplicate of this update

        pUpdate->wAddType = UPDATE_OP_DUPLICATE_ADD;
#if 0
        //  can NOT free, as context of call (IXFR) is doing
        //  list traversal -- it must free after preserving ptr

        //  if no delete records -- pull it out

        if ( pUpdatePrev && !pUpdate->pDeleteRR )
        {
            pUpdatePrev->pNext = pUpdate->pNext;
            FREE_HEAP( pUpdate );
        }
#endif
        DNS_DEBUG( UPDATE, (
            "Found duplicate for update add at %p (node %s, type %d).\n"
            "\tduplicate is at %p, (type = %d, version %d)\n",
            pUpdate,
            pnode,
            addType,
            pup,
            pup->wAddType,
            pup->dwVersion
            ));

        return( TRUE );
    }

    //  duplicate not found

    return( FALSE );
}



//
//  DS Peer updates
//  When DNS server host A records change, update DS peers
//

DNS_STATUS
Up_DsPeerThread(
    IN      PVOID           pvNode
    )
/*++

Routine Description:

    Updates DS peers when change made to host node.

Arguments:

    pvNode -- this machine's host node

Return Value:

    Status in win32 error space

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_RECORD      prrA;
    PDB_NODE        pnodeLocalHost = (PDB_NODE) pvNode;
    PDNS_RECORD     pupdateRR;
    PDNS_RECORD     pupdateRRSet = NULL;
    PDNS_RECORD     previousRR = NULL;

    DNS_DEBUG( UPDATE, (
        "\n\nEnter:  Update_DsPeerThread()\n"
        "\ttime      = %d\n",
        DNS_TIME() ));

    //
    //  DEVNOTE: multi-update issue?  zone context?
    //      currently we'll take updates from multiple sources,
    //      but updates are executed without any sort of zone context

    //
    //  DEVNOTE: perhaps more robust to lookup name here from SrvCfg_pszServerName
    //      but if want zone context -- essentially the right to fix delegations --
    //      then need to have independent updates, hence get nodes or at least zones
    //

    //
    //  create DNS_RECORD for each ip
    //      - note, using UTF8 name, so call UTF8 interface
    //      - update function handles section setting
    //

    prrA = NULL;

    while ( 1 )
    {
        prrA = RR_FindNextRecord(
                    pnodeLocalHost,
                    DNS_TYPE_A,
                    prrA,
                    0 );
        if ( !prrA )
        {
            break;
        }

        pupdateRR = Dns_AllocateRecord( sizeof(IP_ADDRESS) );
        IF_NOMEM( !pupdateRR )
        {
            goto Cleanup;
        }
        ASSERT( pupdateRR->pNext == NULL );

        pupdateRR->pName = (PWCHAR) SrvCfg_pszServerName;
        pupdateRR->dwTtl = htonl( prrA->dwTtlSeconds );
        pupdateRR->wType = DNS_TYPE_A;
        pupdateRR->Data.A.IpAddress = prrA->Data.A.ipAddress;

        if ( previousRR )
        {
            previousRR->pNext = pupdateRR;
            previousRR = pupdateRR;
        }
        else
        {
            pupdateRRSet = pupdateRR;
            previousRR = pupdateRR;
        }
    }

    //
    //  send updates to all other DS-primaries
    //

    status = DnsReplaceRecordSetUTF8(
                pupdateRRSet,
                DNS_UPDATE_TRY_ALL_MASTER_SERVERS,
                NULL,           // no context handle
                NULL,           // no specific servers to update
                NULL
                );

    if ( status == ERROR_SUCCESS )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_UPDATE_DS_PEERS_SUCCESS,
            0,
            NULL,
            NULL,
            0 );
    }
    else
    {
        DNS_LOG_EVENT(
            DNS_EVENT_UPDATE_DS_PEERS_FAILURE,
            0,
            NULL,
            NULL,
            status );
    }

Cleanup:

    //  free record list
    //      - don't free owner it's our global

    Dns_RecordListFree( pupdateRRSet );

    DNS_DEBUG( UPDATE, (
        "Exit <%lu>: Update_DsPeerThread\n",
        status ));

    //  clear thread from list

    Thread_Close( FALSE );
    return status;
}



DNS_STATUS
initiateDsPeerUpdate(
    IN      PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Initiates update of DS peers, when IP address of this host changes and
    the host entry is in a DS zone.

Arguments:

    pUpdateList -- update list

Return Value:

    Status in win32 error space

--*/
{
    PDB_NODE    pnode = pUpdateList->pNodeFailed;

    DNS_DEBUG( UPDATE, (
        "initiateDsPeerUpdate( %s )\n",
        pnode->szLabel ));

    ASSERT( pnode );
    if ( !pnode )
    {
        return( ERROR_INVALID_PARAMETER );
    }
    ASSERT( pnode->pZone && ((PZONE_INFO)pnode->pZone)->fDsIntegrated );

    //
    //  if not authoritative name -- don't bother
    //      - DS peers will get authoritative data to do update
    //
    //  JENHANCE:  if roll our own peer-update, then can update glue
    //

    if ( ! IS_AUTH_NODE(pnode) )
    {
        DNS_DEBUG( UPDATE, (
            "Skipping DS-peer DNS host update -- not authoritative node in zone %s\n",
            pnode->pZone ? ((PZONE_INFO)pnode->pZone)->pszZoneName : NULL ));
        return( ERROR_SUCCESS );
    }

    //
    //  have a flag to skip this
    //

    if ( SrvCfg_dwUpdateOptions & UPDATE_NO_DS_PEERS )
    {
        DNS_DEBUG( UPDATE, (
            "Skipping DS-peer DNS host update by policy.\n" ));
        return( ERROR_SUCCESS );
    }

    //
    //  create scavenge thread
    //

    if ( ! Thread_Create(
                "UpdateDsPeerThread",
                Up_DsPeerThread,
                pnode,
                0 ) )
    {
        DNS_PRINT(( "ERROR:  Failed to create scavenge thread!\n" ));
        return( GetLastError() );
    }

    DNS_DEBUG( UPDATE, (
        "Dispatched DS-peer update thread.\n" ));

    return( ERROR_SUCCESS );
}



DNS_STATUS
checkDnsServerHostUpdate(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNodeReal,
    IN      PDB_NODE        pNodeTemp
    )
/*++

Routine Description:

    Check on update to DNS server host node.

Arguments:

    pZone -- zone of update

    pUpdateList -- update list

    pNodeReal -- node of host

    pNodeTemp -- temp update node for host, contains new record list

Return Value:

    Status in win32 error space

--*/
{
    DNS_DEBUG( UPDATE, (
        "checkDnsServerHostUpdate()\n",
        "\tzone = %s\n"
        "\thost = %s\n",
        pZone->pszZoneName,
        pNodeReal->szLabel ));


    //
    //  "down to zero" delete?
    //
    //  if no A records
    //      - don't update peers -- useless
    //      - flat out refuse "down to zero" packet updates
    //

    if ( ! RR_FindNextRecord(
                pNodeTemp,
                DNS_TYPE_A,
                NULL,
                0 ) )
    {
        DNS_DEBUG( UPDATE, (
            "WARNING:  No A records on DNS server host update!!!\n" ));

        ASSERT( !(pUpdateList->Flag & DNSUPDATE_PACKET) );
        return( ERROR_SUCCESS );
    }

    //
    //  only need mark DS integrated zones
    //

    if ( !pZone->fDsIntegrated )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  check that change merits forcing update to peers
    //
    //  DEVNOTE: enhanced detection
    //
    //  generally updates that REMOVE an IP (which peers may be
    //  using to replicate with us) AND ADD another IP (which peers
    //  could use) are of interest;  other updates do little
    //

    if ( 0 )
    {
        //  should have intellignent code here
        DNS_DEBUG( UPDATE, (
            "IP change for host adapter not sufficient for peer update!\n" ));
        return( ERROR_SUCCESS );
    }

    //  tag update as needing peer-update
    //  save node, overloading pNodeFailed field in update

    pUpdateList->Flag |= DNSUPDATE_DS_PEERS;
    pUpdateList->pNodeFailed = pNodeReal;

    DNS_DEBUG( UPDATE, (
        "Tagged update for DS-peer update.\n" ));

    return( ERROR_SUCCESS );
}

//
//  End of udpate.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\zone.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    zone.h

Abstract:

    Domain Name System (DNS) Server

    Zone list definitions and declarations.

Author:

    Jim Gilroy (jamesg)     June 22, 1995

Revision History:

--*/


#ifndef _DNS_ZONE_INCLUDED_
#define _DNS_ZONE_INCLUDED_


//
//  DEVNOTE: ideally we'd have primary\secondary union
//      to avoid wasting memory
//

//
//  Zone secondary info
//

typedef struct
{
    PIP_ARRAY       aipMasters;
    PIP_ARRAY       MasterInfoArray;

    LPSTR           pszMasterIpString;

    IP_ADDRESS      ipPrimary;
    IP_ADDRESS      ipLastAxfrMaster;

    DWORD           dwLastSoaCheckTime;
    DWORD           dwNextSoaCheckTime;
    DWORD           dwExpireTime;

    IP_ADDRESS      ipXfrBind;
    IP_ADDRESS      ipNotifier;
    IP_ADDRESS      ipFreshMaster;

    DWORD           dwZoneRecvStartTime;
    DWORD           dwBadMasterCount;

    //  flags

    BOOLEAN         fStale;
    BOOLEAN         fNeedAxfr;
    BOOLEAN         fSkipIxfr;
    CHAR            cIxfrAttempts;
    BOOLEAN         fSlowRetry;

}
ZONE_SECONDARY_INFO, *PZONE_SECONDARY_INFO;


//
//  Zone primary info
//

typedef struct
{
    PWSTR           pwsLogFile;

    //  Scavenging info

    BOOL            bAging;
    DWORD           dwAgingEnabledTime;         //  scavenging enabled on zone time
    DWORD           dwRefreshTime;              //  current refresh time (good during update)
    DWORD           dwNoRefreshInterval;        //  no-refresh interval in hours
    DWORD           dwRefreshInterval;          //  refresh interval in hours
    PIP_ARRAY       aipScavengeServers;

    //  DS info

    PWSTR           pwszZoneDN;

    LONGLONG        llSecureUpdateTime;

    BOOLEAN         fDsReload;
    BOOLEAN         fInDsWrite;

    CHAR            szLastUsn[ MAX_USN_LENGTH ];
}
ZONE_PRIMARY_INFO, *PZONE_PRIMARY_INFO;



//
//  Zone information type
//
//  Win64 -- try to keep ptrs on 64-bit boundaries to save space
//

typedef struct
{
    LIST_ENTRY      ListEntry;
    LPSTR           pszZoneName;
    LPWSTR          pwsZoneName;

    //  Current database

    PCOUNT_NAME     pCountName;
    PDB_NODE        pZoneRoot;
    PDB_NODE        pTreeRoot;
    PDB_NODE        pZoneTreeLink;

    //  Load \ cleanup database

    PDB_NODE        pLoadZoneRoot;
    PDB_NODE        pLoadTreeRoot;
    PDB_NODE        pLoadOrigin;
    PDB_NODE        pOldTree;

    //  Database file

    LPSTR           pszDataFile;
    PWSTR           pwsDataFile;

    //  Self generated updates

    PUPDATE_LIST    pDelayedUpdateList;

    //  Locking table and thread

    PVOID           pLockTable;

    //  Current database records

    PDB_RECORD      pSoaRR;
    PDB_RECORD      pWinsRR;
    PDB_RECORD      pLocalWinsRR;

    //  Security descriptor -- DS only, others use default

    PSECURITY_DESCRIPTOR    pSD;

    //
    //  High usage properties -- put in their own DWORDs for efficiency
    //

    DWORD           fZoneType;
    BOOL            fDsIntegrated;
    DWORD           fAllowUpdate;

    //  RR count

    LONG            iRRCount;

    //
    //  Reverse lookup zone info
    //

    IP_ADDRESS      ipReverse;
    IP_ADDRESS      ipReverseMask;

    //
    //  Zone versions
    //      - current
    //      - loaded version from file, AXFR or DS, may not do incremental
    //          transfer beyond this
    //      - last transfered

    DWORD           dwSerialNo;
    DWORD           dwLoadSerialNo;
    DWORD           dwLastXfrSerialNo;

    //
    //  Adding new RR
    //      - file load, admin tool, zone transfer
    //

    DWORD           dwNewSerialNo;
    DWORD           dwDefaultTtl;
    DWORD           dwDefaultTtlHostOrder;

    //
    //  Master transfer info
    //

    PIP_ARRAY       aipNotify;
    PIP_ARRAY       aipSecondaries;
    PIP_ARRAY       aipNameServers;
    DWORD           dwNextTransferTime;

    //
    //  DS only info
    //

    PWSTR           pwszZoneDN;
    PVOID           pDpInfo;            //  PDNS_DP_INFO - naming context

    //
    //  Primary only info
    //

    DWORD           dwPrimaryMarker;

        PWSTR           pwsLogFile;
        HANDLE          hfileUpdateLog;
        LONG            iUpdateLogCount;

        //  Scavenging info

        BOOL            bAging;
        DWORD           dwRefreshTime;              //  current refresh time (good during update)
        DWORD           dwNoRefreshInterval;        //  no-refresh interval in hours
        DWORD           dwRefreshInterval;          //  refresh interval in hours
        DWORD           dwAgingEnabledTime;         //  scavenging enabled on zone time
        PIP_ARRAY       aipScavengeServers;

        LONGLONG        llSecureUpdateTime;

        DWORD           dwHighDsSerialNo;

        BOOLEAN         fDsReload;
        BOOLEAN         fInDsWrite;
        UCHAR           ucDsRecordVersion;
        BOOLEAN         fLogUpdates;                //  standard primary also

        CHAR            szLastUsn[ MAX_USN_LENGTH ];

        PIP_ARRAY       aipAutoCreateNS;            //  servers who may autocreate

    //  End primary only info

    //
    //  Secondary transfer info
    //

    DWORD           dwSecondaryMarker;

        PIP_ARRAY       aipMasters;
        PIP_ARRAY       aipLocalMasters;
        //  PIP_ARRAY       MasterInfoArray;
        //  JJW: I can't find any use of MasterInfoArray... safe to remove it?

        LPSTR           pszMasterIpString;

        IP_ADDRESS      ipPrimary;
        IP_ADDRESS      ipNotifier;
        IP_ADDRESS      ipFreshMaster;
        IP_ADDRESS      ipXfrBind;
        IP_ADDRESS      ipLastAxfrMaster;

        DWORD           dwLastSoaCheckTime;             //  from DNS_TIME()
        DWORD           dwNextSoaCheckTime;             //  from DNS_TIME()
        DWORD           dwLastSuccessfulSoaCheckTime;   //  from time()
        DWORD           dwLastSuccessfulXfrTime;        //  from time()
        DWORD           dwExpireTime;
        DWORD           dwZoneRecvStartTime;
        DWORD           dwBadMasterCount;
        DWORD           dwFastSoaChecks;

        //  secondary flags

        BOOLEAN         fStale;
        BOOLEAN         fNotified;
        BOOLEAN         fNeedAxfr;
        BOOLEAN         fSkipIxfr;
        CHAR            cIxfrAttempts;
        BOOLEAN         fSlowRetry;

    //  End secondary only info

    //
    //  Forwarder only info - forwarders also use secondary info
    //

    DWORD           dwForwarderMarker;

    DWORD           dwForwarderTimeout;
    BOOLEAN         fForwarderSlave;
    UCHAR           unused1;
    UCHAR           unused2;
    UCHAR           unused3;

    //  End forwarder info

    //
    //  Flags -- static \ properties
    //

    DWORD           dwFlagMarker;

    UCHAR           cZoneNameLabelCount;
    BOOLEAN         fReverse;
    BOOLEAN         fAutoCreated;
    BOOLEAN         fLocalWins;

    BOOLEAN         fSecureSecondaries;
    UCHAR           fNotifyLevel;
    BOOLEAN         bDcPromoConvert;
    BOOLEAN         bContainsDnsSecRecords;

    //
    //  Flags -- dynamic
    //

    DWORD           dwLockingThreadId;
    CHAR            fLocked;
    BOOLEAN         fUpdateLock;
    BOOLEAN         fXfrRecvLock;
    BOOLEAN         fFileWriteLock;

    BOOLEAN         fDirty;
    BOOLEAN         fRootDirty;
    BOOLEAN         bNsDirty;
    UCHAR           cDeleted;

    BOOLEAN         fPaused;
    BOOLEAN         fShutdown;
    BOOLEAN         fEmpty;
    BOOLEAN         fDisableAutoCreateLocalNS;

    DWORD           dwDeleteDetectedCount;  //  # times zone missing from DP
    DWORD           dwLastDpVisitTime;      //  visit time for DP enumeration

    //
    //  Update list, keep permanent in zone block
    //

    UPDATE_LIST     UpdateList;

    //
    //  for deleted zones
    //

    LPWSTR          pwsDeletedFromHost;

    //
    //  Debugging aids
    //

    LPSTR           pszBreakOnUpdateName;

    //
    //  Event control
    //
    
    PDNS_EVENTCTRL  pEventControl;

#if 0
    //
    //  union of primary and secondary info
    //

    union   _TypeUnion
    {
        ZONE_SECONDARY_INFO     Sec;
        ZONE_PRIMARY_INFO       Pri;
    }
    U;
#endif

}
ZONE_INFO, * PZONE_INFO;


//
//  Markers to make it easier to debug zone struct
//

#define ZONE_PRIMARY_MARKER         (0x11111111)
#define ZONE_SECONDARY_MARKER       (0x22222222)
#define ZONE_FORWARDER_MARKER       (0x33333333)
#define ZONE_FLAG_MARKER            (0xf1abf1ab)


//
//  DS Primaries overlay some of the secondary zone fields
//
//  Note the choice of NextSoaCheckTime is REQUIRED to calculate
//  the correct timeout on the Wait in the zone control thread.
//  Do NOT change it to another value.
//

#define ZONE_NEXT_DS_POLL_TIME(pZone)       ((pZone)->dwNextSoaCheckTime)

//
//  Reuse some secondary fields for primary
//

#define LAST_SEND_TIME( pzone )     ((pzone)->dwZoneRecvStartTime)


//
//  Zone type queries
//

#define IS_ZONE_CACHE(pZone)            \
                ((pZone)->fZoneType == DNS_ZONE_TYPE_CACHE)
#define IS_ZONE_PRIMARY(pZone)          \
                ((pZone)->fZoneType == DNS_ZONE_TYPE_PRIMARY)
#define IS_ZONE_SECONDARY(pZone)        \
                ((pZone)->fZoneType == DNS_ZONE_TYPE_SECONDARY  \
              || (pZone)->fZoneType == DNS_ZONE_TYPE_STUB)
#define IS_ZONE_STUB(pZone)             \
                ((pZone)->fZoneType == DNS_ZONE_TYPE_STUB)
#define IS_ZONE_FORWARDER(pZone)        \
                ((pZone)->fZoneType == DNS_ZONE_TYPE_FORWARDER)

#define IS_ZONE_AUTHORITATIVE(pZone)    \
                ((pZone)->fZoneType != DNS_ZONE_TYPE_CACHE              \
                    && (pZone)->fZoneType != DNS_ZONE_TYPE_FORWARDER    \
                    && (pZone)->fZoneType != DNS_ZONE_TYPE_STUB)

//  NOTAUTH zones are special zone types that are not truly authoritative.
//  The cache zone is not a NOTAUTH zone.

#define IS_ZONE_NOTAUTH(pZone)                                      \
                ( (pZone)->fZoneType == DNS_ZONE_TYPE_FORWARDER     \
                    || (pZone)->fZoneType == DNS_ZONE_TYPE_STUB )

#define ZONE_NEEDS_MASTERS(pZone)       \
                ( (pZone)->fZoneType == DNS_ZONE_TYPE_SECONDARY         \
                    || (pZone)->fZoneType == DNS_ZONE_TYPE_STUB         \
                    || (pZone)->fZoneType == DNS_ZONE_TYPE_FORWARDER )

//  ZONE_MASTERS returns a PIP_ARRAY ptr to the zone's master IP list.
//      DS-integrated stub zones may have a local masters list which 
//      overrides the list stored in the DS.
#define ZONE_MASTERS(pZone)                                                 \
                ( ( IS_ZONE_STUB(pZone) && (pZone)->aipLocalMasters ) ?     \
                    (pZone)->aipLocalMasters :                              \
                    (pZone)->aipMasters )

#define IS_ZONE_REVERSE(pZone)      ( (pZone)->fReverse )
#define IS_ZONE_WINS(pZone)         ( !(pZone)->fReverse && (pZone)->pWinsRR )
#define IS_ZONE_NBSTAT(pZone)       ( (pZone)->fReverse && (pZone)->pWinsRR )

#define IS_ROOT_ZONE(pZone)         ( (DATABASE_ROOT_NODE)->pZone == (PVOID)pZone )

#define IS_ZONE_DSINTEGRATED(pZone) ( (pZone)->fDsIntegrated )

#define IS_ZONE_DNSSEC(pZone)       ( (pZone)->bContainsDnsSecRecords )


//
//  Zone status checks
//

#define IS_ZONE_DELETED(pZone)          ( (pZone)->cDeleted )
#define IS_ZONE_PAUSED(pZone)           ( (pZone)->fPaused )
#define IS_ZONE_SHUTDOWN(pZone)         ( (pZone)->fShutdown )
#define IS_ZONE_INACTIVE(pZone)         ( (pZone)->fPaused || (pZone)->fShutdown )

#define IS_ZONE_EMPTY(pZone)            ( (pZone)->fEmpty )
#define IS_ZONE_STALE(pZone)            ( (pZone)->fStale )
#define IS_ZONE_DIRTY(pZone)            ( (pZone)->fDirty )
#define IS_ZONE_ROOT_DIRTY(pZone)       ( (pZone)->fDirty )
#define IS_ZONE_NS_DIRTY(pZone)         ( (pZone)->bNsDirty )
#define IS_ZONE_DSRELOAD(pZone)         ( (pZone)->fDsReload )

#define IS_ZONE_LOADING(pZone)          ( (pZone)->pLoadTreeRoot )

#define IS_ZONE_LOCKED(pZone)           ( (pZone)->fLocked )
#define IS_ZONE_LOCKED_FOR_WRITE(pZone) ( (pZone)->fLocked < 0 )
#define IS_ZONE_LOCKED_FOR_READ(pZone)  ( (pZone)->fLocked > 0 )

#define IS_ZONE_LOCKED_FOR_UPDATE(pZone)    \
            ( IS_ZONE_LOCKED_FOR_WRITE(pZone) && (pZone)->fUpdateLock )

#define IS_ZONE_LOCKED_FOR_WRITE_BY_THREAD(pZone)   \
            ( IS_ZONE_LOCKED_FOR_WRITE(pZone) &&    \
              (pZone)->dwLockingThreadId == GetCurrentThreadId() )

#define HAS_ZONE_VERSION_BEEN_XFRD(pZone) \
            ( (pZone)->dwLastXfrSerialNo == (pZone)->dwSerialNo )


//
//  Zone status set
//

#define RESUME_ZONE(pZone)          ( (pZone)->fPaused = FALSE )
#define PAUSE_ZONE(pZone)           ( (pZone)->fPaused = TRUE )

#define SHUTDOWN_ZONE(pZone)        ( (pZone)->fShutdown = TRUE )
#define STARTUP_ZONE(pZone)         ( (pZone)->fShutdown = FALSE )

#define SET_EMPTY_ZONE(pZone)       ( (pZone)->fEmpty = TRUE )
#define MARK_DIRTY_ZONE(pZone)      ( (pZone)->fDirty = TRUE )
#define MARK_ZONE_NS_DIRTY(pZone)   ( (pZone)->bNsDirty = TRUE )

#define CLEAR_EMPTY_ZONE(pZone)     ( (pZone)->fEmpty = TRUE )
#define CLEAR_DIRTY_ZONE(pZone)     ( (pZone)->fDirty = TRUE )
#define CLEAR_ZONE_NS_DIRTY(pZone)  ( (pZone)->bNsDirty = FALSE )


//
//  Root-Hints uses bNsDirty flag to handle issue of needing DS write
//
//  This is a hack, until RootHints updates are handled as in
//  ordinary zone, rather than written atomically to DS
//

#define IS_ROOTHINTS_DS_DIRTY(pZone)        ( (pZone)->bNsDirty )
#define MARK_ROOTHINTS_DS_DIRTY(pZone)      ( (pZone)->bNsDirty = TRUE )
#define CLEAR_ROOTHINTS_DS_DIRTY(pZone)     ( (pZone)->bNsDirty = FALSE )


//
//  Zone refresh
//

#define REFRESH_ZONE(pZone) \
        {                   \
            (pZone)->fEmpty     = FALSE; \
            (pZone)->fShutdown  = FALSE; \
            (pZone)->fStale     = FALSE; \
            (pZone)->fNotified  = FALSE; \
            (pZone)->ipNotifier = 0;     \
            (pZone)->cIxfrAttempts = 0;  \
        }

#define SET_DSRELOAD_ZONE(pZone)     ( (pZone)->fDsReload = TRUE )
#define CLEAR_DSRELOAD_ZONE(pZone)   ( (pZone)->fDsReload = FALSE )

#define SET_ZONE_VISIT_TIMESTAMP( pZone, dwTimeStamp )      \
        ( pZone )->dwLastDpVisitTime = dwVisitStamp;        \
        ( pZone )->dwDeleteDetectedCount = 0;

//
//  Zone list critical section
//

extern CRITICAL_SECTION    csZoneList;


//
//  New primary zone creation options
//

#define ZONE_CREATE_LOAD_EXISTING   (0x00000001)
#define ZONE_CREATE_DEFAULT_RECORDS (0x00000002)



//
//  Per server Master flags
//

#define MASTER_NO_IXFR          (0x10000000)

#define MASTER_SENT             (0x00000001)
#define MASTER_RESPONDED        (0x00000002)
#define MASTER_NOTIFY           (0x00000004)

#define MASTER_SAME_VERSION     (0x00000010)
#define MASTER_NEW_VERSION      (0x00000020)



//
//  Zone list routines (zonelist.c)
//

BOOL
Zone_ListInitialize(
    VOID
    );

VOID
Zone_ListShutdown(
    VOID
    );

VOID
Zone_ListMigrateZones(
    VOID
    );

VOID
Zone_ListInsertZone(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Zone_ListRemoveZone(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_Rename(
    IN OUT  PZONE_INFO      pZone,
    IN      LPCSTR          pszNewZoneName,
    IN      LPCSTR          pszNewZoneFile
    );

VOID
Zone_ListDelete(
    VOID
    );

PZONE_INFO
Zone_ListGetNextZoneEx(
    IN      PZONE_INFO      pZone,
    IN      BOOL            fAlreadyLocked
    );

#define Zone_ListGetNextZone( pZone )   Zone_ListGetNextZoneEx( pZone, FALSE )

BOOL
Zone_DoesDsIntegratedZoneExist(
    VOID
    );


//
//  Zone filtering and multizone technology (zonelist.c)
//

DWORD
Zone_GetFilterForMultiZoneName(
    IN      LPSTR           pszZoneName
    );

BOOL
FASTCALL
Zone_CheckZoneFilter(
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwFilter
    );

PZONE_INFO
Zone_ListGetNextZoneMatchingFilter(
    IN      PZONE_INFO      pLastZone,
    IN      DWORD           dwFilter
    );


//
//  Special zone type conversion (zonerpc.c)
//

DNS_STATUS
Zone_DcPromoConvert(
    IN OUT  PZONE_INFO      pZone
    );


//
//  Zone routines
//


typedef struct
{
    union
    {
        struct
        {
            DWORD           dwTimeout;
            BOOLEAN         fSlave;
        } Forwarder;
    };
} ZONE_TYPE_SPECIFIC_INFO, * PZONE_TYPE_SPECIFIC_INFO;


DNS_STATUS
Zone_Create(
    OUT     PZONE_INFO *                ppZone,
    IN      DWORD                       dwZoneType,
    IN      PCHAR                       pchZoneName,
    IN      DWORD                       cchZoneNameLen,     OPTIONAL
    IN      PIP_ARRAY                   aipMasters,
    IN      BOOL                        fUseDatabase,
    IN      PDNS_DP_INFO                pDpInfo,            OPTIONAL
    IN      PCHAR                       pchFileName,        OPTIONAL
    IN      DWORD                       cchFileNameLen,     OPTIONAL
    IN      PZONE_TYPE_SPECIFIC_INFO    pTypeSpecificInfo,  OPTIONAL
    OUT     PZONE_INFO *                ppExistingZone      OPTIONAL
    );

DNS_STATUS
Zone_Create_W(
    OUT     PZONE_INFO *    ppZone,
    IN      DWORD           dwZoneType,
    IN      PWSTR           pwsZoneName,
    IN      PIP_ARRAY       aipMasters,
    IN      BOOL            fDsIntegrated,
    IN      PWSTR           pwsFileName
    );

VOID
Zone_DeleteZoneNodes(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Zone_Delete(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Zone_Free(
    IN OUT  PZONE_INFO      pZone
    );

PZONE_INFO
Zone_FindZoneByName(
    IN      LPSTR           pszZoneName
    );

DNS_STATUS
Zone_RootCreate(
    IN OUT  PZONE_INFO      pZone,
    OUT     PZONE_INFO *    ppExistingZone      OPTIONAL
    );

DNS_STATUS
Zone_ResetType(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwZoneType,
    IN      PIP_ARRAY       aipMasters
    );

DNS_STATUS
Zone_ResetRegistryType(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_SetMasters(
    IN OUT  PZONE_INFO      pZone,
    IN      PIP_ARRAY       aipMasters,
    IN      BOOL            fLocalMasters
    );

DNS_STATUS
Zone_DatabaseSetup(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           fDsIntegrated,
    IN      PCHAR           pchFileName,    OPTIONAL
    IN      DWORD           cchFileNameLen  OPTIONAL
    );

DNS_STATUS
Zone_DatabaseSetup_W(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           fDsIntegrated,
    IN      PWSTR           pwsFileName
    );

DNS_STATUS
Zone_SetSecondaries(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           fSecureSecondaries,
    IN      PIP_ARRAY       aipSecondaries,
    IN      DWORD           fNotifyLevel,
    IN      PIP_ARRAY       aipNotify
    );

VOID
Zone_SetAgingDefaults(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_WinsSetup(
    IN OUT  PZONE_INFO      pZone,
    IN      BOOL            fWins,
    IN      DWORD           cWinsServers,
    IN      PIP_ADDRESS     pipWinsServers
    );

DNS_STATUS
Zone_NbstatSetup(
    IN OUT  PZONE_INFO      pZone,
    IN      BOOL            fUseNbstat,
    IN      PCHAR           pchNbstatDomain,    OPTIONAL
    IN      DWORD           cchNbstatDomain     OPTIONAL
    );

DNS_STATUS
Zone_WriteZoneToRegistry(
    PZONE_INFO      pZone
    );


//
//  Utils to keep zone info current
//

DNS_STATUS
Zone_ValidateMasterIpList(
    IN      PIP_ARRAY       aipMasters
    );

INT
Zone_SerialNoCompare(
    IN      DWORD           dwSerial1,
    IN      DWORD           dwSerial2
    );

BOOL
Zone_IsIxfrCapable(
    IN      PZONE_INFO      pZone
    );

VOID
Zone_ResetVersion(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwNewSerial
    );

VOID
Zone_UpdateSoa(
    IN OUT  PZONE_INFO      pZone,
    IN      PDB_RECORD      pSoaRR
    );

VOID
Zone_IncrementVersion(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Zone_UpdateVersionAfterDsRead(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwVersionRead,
    IN      BOOL            fLoad,
    IN      DWORD           dwPreviousLoadSerial
    );

VOID
Zone_UpdateInfoAfterPrimaryTransfer(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwStartTime
    );

#if 0
PDB_NODE
Zone_GetNSInfo(
    IN      PDB_NAME        pName,
    IN      PZONE_INFO      pZone,
    IN      struct _DNS_MSGINFO *   pSuspendMsg     OPTIONAL
    );
#endif

DNS_STATUS
Zone_GetZoneInfoFromResourceRecords(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Zone_WriteBack(
    IN      PZONE_INFO      pZone,
    IN      BOOL            fShutdown
    );

VOID
Zone_WriteBackDirtyZones(
    IN      BOOL            fShutdown
    );


//
//  Auto reverse zone creation
//

DNS_STATUS
Zone_CreateAutomaticReverseZones(
    VOID
    );

DNS_STATUS
Zone_CreateAutomaticReverseZone(
    IN      LPSTR           pszZoneName
    );


//
//  Admin action zone create / delete utils
//

BOOL
Zone_DeleteCacheZone(
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
Zone_CreateNewPrimary(
    OUT     PZONE_INFO *    ppZone,
    IN      LPSTR           pszZoneName,
    IN      LPSTR           pszAdminEmailName,
    IN      LPSTR           pszFileName,
    IN      DWORD           dwDsIntegrated,
    IN      PDNS_DP_INFO    pDpInfo,            OPTIONAL
    IN      DWORD           dwCreateFlag
    );


//
//  Default zone record management
//

BOOLEAN
Zone_SetAutoCreateLocalNS(
    IN      PZONE_INFO      pZone
    );

VOID
Zone_CreateDefaultZoneFileName(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_CreateDefaultSoa(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszAdminEmailName
    );

DNS_STATUS
Zone_CreateDefaultNs(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Zone_UpdateOwnRecords(
    IN      BOOL            fIpAddressChange
    );

VOID
Zone_CreateDelegationInParentZone(
    IN      PZONE_INFO      pZone
    );

//
//  Zone load\unload
//

DNS_STATUS
Zone_ActivateLoadedZone(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_CleanupFailedLoad(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_PrepareForLoad(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_Load(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_DumpData(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
Zone_ClearCache(
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
Zone_LoadRootHints(
    VOID
    );

DNS_STATUS
Zone_WriteBackRootHints(
    IN      BOOL            fForce
    );

BOOL
Zone_VerifyRootHintsBeforeWrite(
    IN      PZONE_INFO      pZone
    );


//
//  Zone locking
//
//  Lock zones during read and write for info that is read or written
//  by threads other than RPC thread.
//
//  If can make read and write access completely unitary then this
//  isn't necessary, but currently have some info, that contains both a
//  count and an array.
//
//  Note:  currently overloading zone list CS, but no particular reason
//          not to as zone list access is rare, and is usually done in
//          RPC thread as is most of this zone update stuff

#define Zone_UpdateLock(pZone)    EnterCriticalSection( &csZoneList );
#define Zone_UpdateUnlock(pZone)  LeaveCriticalSection( &csZoneList );

//
//  Zone lock flags
//

#define LOCK_FLAG_UPDATE            0x00000001

#define LOCK_FLAG_XFR_RECV          0x00000100

#define LOCK_FLAG_FILE_WRITE        0x00001000

#define LOCK_FLAG_IGNORE_THREAD     0x01000000


//
//  Zone locking routines
//
//  Need to avoid simultaneous access to zone records for
//      - zone transfer send
//      - zone transfer recv
//      - admin changes
//
//  Allow multiple transfer sends, which don't change zone, at one time,
//  but avoid any changes during send.
//
//  Implementation:
//      - hold critical section ONLY during test and set of lock bit
//      - lock bit itself indicates zone is locked
//      - individual flags for locking operations
//

BOOL
Zone_LockInitialize(
    VOID
    );

BOOL
Zone_LockForWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      DWORD           dwMaxWait,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Zone_UnlockAfterWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Zone_TransferWriteLockEx(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

BOOL
Zone_AssumeWriteLockEx(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

BOOL
Zone_LockForReadEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      DWORD           dwMaxWait,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Zone_UnlockAfterReadEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

BOOL
Zone_LockForFileWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwMaxWait,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Zone_UnlockAfterFileWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Dbg_ZoneLock(
    IN      LPSTR           pszHeader,
    IN      PZONE_INFO      pZone
    );


//
//  Macros (real functions are Zone_...Ex()
//

#define Zone_TransferWriteLock(pZone) \
        Zone_TransferWriteLockEx( (pZone), __FILE__, __LINE__)

#define Zone_AssumeWriteLock(pZone) \
        Zone_AssumeWriteLockEx( (pZone), __FILE__, __LINE__)

//  Admin updates will get default of 10s wait

#define Zone_LockForAdminUpdate(pZone) \
        Zone_LockForWriteEx( (pZone), LOCK_FLAG_UPDATE, 10000, __FILE__, __LINE__)

#define Zone_UnlockAfterAdminUpdate(pZone) \
        Zone_UnlockAfterWriteEx( (pZone), LOCK_FLAG_UPDATE, __FILE__, __LINE__)

//  Non-admin updates get no wait

#define Zone_LockForUpdate(pZone) \
        Zone_LockForWriteEx( (pZone), LOCK_FLAG_UPDATE, 0, __FILE__, __LINE__)

#define Zone_UnlockAfterUpdate(pZone) \
        Zone_UnlockAfterWriteEx( (pZone), LOCK_FLAG_UPDATE, __FILE__, __LINE__)

//  DS read gets small wait, to give preference for getting it done now

#define Zone_LockForDsUpdate(pZone) \
        Zone_LockForWriteEx( (pZone), LOCK_FLAG_UPDATE, 5000, __FILE__, __LINE__)

#define Zone_UnlockAfterDsUpdate(pZone) \
        Zone_UnlockAfterWriteEx( (pZone), LOCK_FLAG_UPDATE, __FILE__, __LINE__)


//  XFR recv will get default of 1s wait
//      as it may be in worker thread

#define Zone_LockForXfrRecv(pZone) \
        Zone_LockForWriteEx( (pZone), LOCK_FLAG_XFR_RECV, 1000, __FILE__, __LINE__)

#define Zone_UnlockAfterXfrRecv(pZone) \
        Zone_UnlockAfterWriteEx( (pZone), LOCK_FLAG_XFR_RECV, __FILE__, __LINE__)

//  File write gets 3s default wait

#define Zone_LockForFileWrite(pZone) \
        Zone_LockForFileWriteEx( (pZone), 3000 , __FILE__, __LINE__)

#define Zone_UnlockAfterFileWrite(pZone) \
        Zone_UnlockAfterFileWriteEx( (pZone), __FILE__, __LINE__)


//  XFR send gets 50ms read lock
//      this is enough time to clear an existing DS update
//      but allows us to take the wait within recv thread

#define Zone_LockForXfrSend(pZone) \
        Zone_LockForReadEx( (pZone), 0, 50, __FILE__, __LINE__)

#define Zone_UnlockAfterXfrSend(pZone) \
        Zone_UnlockAfterReadEx( (pZone), 0, __FILE__, __LINE__)


//
//  Zone debug macros
//

#if DBG
#define DNS_DEBUG_ZONEFLAGS( dwDbgLevel, pZone, pszContext )                \
    DNS_DEBUG( dwDbgLevel, (                                                \
        "zone flags for %s (%p) - %s\n"                                     \
        "\tpaused=%d shutdown=%d empty=%d dirty=%d locked=%d deleted=%d\n", \
        pZone->pszZoneName,                                                 \
        pZone,                                                              \
        pszContext ? pszContext : "",                                       \
        ( int ) pZone->fPaused,                                             \
        ( int ) pZone->fShutdown,                                           \
        ( int ) pZone->fEmpty,                                              \
        ( int ) pZone->fDirty,                                              \
        ( int ) pZone->fLocked,                                             \
        ( int ) pZone->cDeleted ));
#else
#define DNS_DEBUG_ZONEFLAGS( dwDbgLevel, pZone, pszContext )
#endif


#endif  //  _DNS_ZONE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\update.h ===
/*++

Copyright(c) 1996-1999 Microsoft Corporation

Module Name:

    update.h

Abstract:

    Domain Name System (DNS) Server

    Dynamic update definitions.

Author:

    Jim Gilroy (jamesg)     September 20, 1996

Revision History:

--*/


#ifndef _UPDATE_INCLUDED_
#define _UPDATE_INCLUDED_

//
//  Updates
//
//  For ADDs pRR points to a single record, no context to its next pointer
//  which may be in database, or further along in a delete list.
//
//  For DELETEs pRR is a list of records, since they are unowned in the
//  database, record next pointer is valid (i.e. it points to new record
//  in update/delete RR list).
//

typedef struct _DnsUpdate
{
    struct _DnsUpdate * pNext;          //  next update in list
    PDB_NODE            pNode;          //  node at which update occured
    PDB_RECORD          pAddRR;         //  RR added
    PDB_RECORD          pDeleteRR;      //  RR or RR list deleted
    DWORD               dwVersion;      //  zone version of update
    DWORD               dwFlag;
    WORD                wDeleteType;
    WORD                wAddType;
}
UPDATE, *PUPDATE;

//
//  Update operations
//
//  Standard dynamic updates are determined by interplay of
//  pAddRR, pDeleteRR and wDeleteType.
//
//  Overload wDeleteType to indicate various non-standard
//  update operations.
//

#define  UPDATE_OP_PRECON           (0xf2f2)

//  Scavenge updates

#define  UPDATE_OP_SCAVENGE         (0xf3f3)

//  Force aging updates

#define  UPDATE_OP_FORCE_AGING      (0xf4f4)

//
//  Duplicate update add
//
//  In update list, IXFR will send entire RR set after any add
//  operation.  This means it is unnecessary to send OR to keep
//  any prior add updates for same RR set -- the set is in the
//  database.  Once detected these updates can be marked, so
//  they need not be "redetected" or sent.
//

#define UPDATE_OP_DUPLICATE_ADD     (0xf5f5)

#define IS_UPDATE_DUPLICATE_ADD(pup)   \
        ( (pup)->wAddType == UPDATE_OP_DUPLICATE_ADD )

#define UPDATE_OP_NON_DUPLICATE_ADD (0xf5f6)

#define IS_UPDATE_NON_DUPLICATE_ADD(pup)   \
        ( (pup)->wDeleteType == UPDATE_OP_NON_DUPLICATE_ADD )

//
//  Rejected update
//      - mark rejected updates with opcode,
//      this prevents "empty-update" ASSERT() from firing

#define UPDATE_OP_REJECTED          (0xfcfc)


//
//  Executed update
//
//  Mark individual updates as "Executed" to avoid free
//  of pAddRR if entire update fails.  Overloading version field
//  which is fine since version field is set in zone update list
//  AND pAddRR is cleared anyway.
//

#define MARK_UPDATE_EXECUTED(pUpdate)   \
            ( (pUpdate)->dwFlag |= DNSUPDATE_EXECUTED )

#define IS_UPDATE_EXECUTED(pUpdate)     ( (pUpdate)->dwFlag & DNSUPDATE_EXECUTED )



//
//  Update list
//

typedef struct _DnsUpdateList
{
    PUPDATE     pListHead;
    PUPDATE     pCurrent;
    PDB_NODE    pTempNodeList;
    PDB_NODE    pNodeFailed;
    PVOID       pMsg;
    DWORD       Flag;
    DWORD       dwCount;
    DWORD       dwStartVersion;
    DWORD       dwHighDsVersion;
    INT         iNetRecords;
}
UPDATE_LIST, *PUPDATE_LIST;

//
//  Empty list
//

#define IS_EMPTY_UPDATE_LIST(pList)     ((pList)->pListHead == NULL)


//
//  Types of updates
//

#define DNSUPDATE_PACKET            0x00000001
#define DNSUPDATE_ADMIN             0x00000002
#define DNSUPDATE_DS                0x00000004
#define DNSUPDATE_IXFR              0x00000008
#define DNSUPDATE_AUTO_CONFIG       0x00000010
#define DNSUPDATE_SCAVENGE          0x00000020
#define DNSUPDATE_PRECON            0x00000040

//  Type properties

#define DNSUPDATE_COPY              0x00000100
#define DNSUPDATE_LOCAL_SYSTEM      0x00000200
#define DNSUPDATE_SECURE_PACKET     0x00000400
#define DNSUPDATE_NONSECURE_PACKET  0x00000800

//  Aging info

#define DNSUPDATE_AGING_ON          0x00001000
#define DNSUPDATE_AGING_OFF         0x00002000
#define DNSUPDATE_OPEN_ACL          0x00004000

//
//  Update completion flags
//

#define DNSUPDATE_NO_NOTIFY         0x00010000
#define DNSUPDATE_NO_INCREMENT      0x00020000
#define DNSUPDATE_ROOT_DIRTY        0x00040000
#define DNSUPDATE_NO_UNLOCK         0x00080000
#define DNSUPDATE_DS_PEERS          0x00100000

//  Tell ApplyUpdatesToDatabase to complete update

#define DNSUPDATE_COMPLETE          0x01000000

//  Tell ExecuteUpdate()

#define DNSUPDATE_ALREADY_LOCKED    0x02000000

//  Cleanup properties

#define DNSUPDATE_NO_DEREF          0x10000000

//  Update state

#define DNSUPDATE_EXECUTED          0x80000000

//
//  Stat update - choose correct stat struct based on update type
//

#define UPDATE_STAT_INC( pUpdateList, UpdateStatMember ) \
    ASSERT( pUpdateList ); \
    if ( !pUpdateList || pUpdateList->Flag & DNSUPDATE_PACKET ) \
        { STAT_INC( WireUpdateStats.##UpdateStatMember ); } \
    else \
        { STAT_INC( NonWireUpdateStats.##UpdateStatMember ); }

//
//  Update implementation
//
//  Still messing with best way to do this.  See update.c for detail
//  current implementation defined here, as IXFR code needs to know.

#define UPIMPL3 1


//
//  Update zone lock waits
//
//  For packet updates do not wait for zone locks
//  Admin updates can wait briefly.
//  Scavenging updates can wait quite a while, as if proceed while zone
//  still locked, you just bang into the lock on the next one.
//

#define DEFAULT_ADMIN_ZONE_LOCK_WAIT        (10000)     // 10s
#define DEFAULT_SCAVENGE_ZONE_LOCK_WAIT     (120000)    // 2 minutes


//
//  Temporary nodes used in DS update, need to hold ptr to real node
//  (need to expose for list walking in ds.c)
//

#define TNODE_MATCHING_REAL_NODE(pnodeTemp)     ((pnodeTemp)->pSibUp)

#define TNODE_NEXT_TEMP_NODE(pnodeTemp)         ((pnodeTemp)->pSibRight)

#define TNODE_WRITE_STATE(pnodeTemp)            ((pnodeTemp)->dwCompare)
#define TNODE_RECORD_CHANGE(pnodeTemp)          (TNODE_WRITE_STATE(pnodeTemp)==RRLIST_NO_MATCH)
#define TNODE_AGING_REFRESH(pnodeTemp)          (TNODE_WRITE_STATE(pnodeTemp)==RRLIST_AGING_REFRESH)
#define TNODE_AGING_OFF(pnodeTemp)              (TNODE_WRITE_STATE(pnodeTemp)==RRLIST_AGING_OFF)
#define TNODE_AGING_ON(pnodeTemp)               (TNODE_WRITE_STATE(pnodeTemp)==RRLIST_AGING_ON)

#define TNODE_FLAG(pnodeTemp)           ((pnodeTemp)->cChildren)
#define TNODE_FLAG_MASK                 0x88880000
#define TNODE_FLAG_NEW                  0x88880000
#define TNODE_FLAG_NEEDS_WRITE          0x88880001
#define TNODE_FLAG_DS_WRITTEN           0x88880010
#define TNODE_FLAG_ROLLED_BACK          0x88880100

#define IS_TNODE(pnode)                 ((TNODE_FLAG(pnode) & TNODE_FLAG_MASK) == TNODE_FLAG_MASK)

#define TNODE_NEEDS_DS_WRITE(pnode)     (TNODE_FLAG(pnode) == TNODE_FLAG_NEEDS_WRITE)
#define TNODE_SET_FOR_DS_WRITE(pnode)   (TNODE_FLAG(pnode) = TNODE_FLAG_NEEDS_WRITE)


#define IS_AGING_OPTIONS(dwFlag)        ( 0x30000000 & dwFlag )
#define IS_NO_AGING_OPTIONS(dwFlag)     ( ~IS_AGING_OPTIONS(dwFlag) )


//
//  Aging time \ calculations
//

extern DWORD    g_CurrentTimeHours;

#define AGING_ZONE_REFRESH_TIME(pZone)   \
        ( g_CurrentTimeHours - (pZone)->dwNoRefreshInterval)

#define AGING_ZONE_EXPIRE_TIME(pZone)   \
        ( g_CurrentTimeHours - (pZone)->dwNoRefreshInterval - (pZone)->dwRefreshInterval)

#define AGING_IS_RR_EXPIRED( pRR, ExpireBelowTime ) \
        ( (pRR)->dwTimeStamp < (ExpireBelowTime) && (pRR)->dwTimeStamp != 0 )

#define AGING_DOES_RR_NEED_REFRESH( pRR, RefreshBelowTime ) \
        ( (pRR)->dwTimeStamp < (RefreshBelowTime) && (pRR)->dwTimeStamp != 0 )

//
//  Scavenging
//

extern BOOL     g_bAbortScavenging;

#define Scavenge_Abort()                ( g_bAbortScavenging = TRUE )


//
//  Update type + update list routines (update.c)
//

PUPDATE_LIST
Up_InitUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList
    );

PUPDATE_LIST
Up_CreateUpdateList(
    IN      PUPDATE_LIST    pUpdateList
    );

VOID
Up_AppendUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PUPDATE_LIST    pAppendList,
    IN      DWORD           dwVersion
    );

PUPDATE
Up_CreateUpdate(
    IN      PDB_NODE        pNode,
    IN      PDB_RECORD      pAddRR,
    IN      WORD            wDeleteType,
    IN      PDB_RECORD      pDeleteRR
    );

PUPDATE
Up_CreateAppendUpdate(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNode,
    IN      PDB_RECORD      pAddRR,
    IN      WORD            wDeleteType,
    IN      PDB_RECORD      pDeleteRR
    );

PUPDATE
Up_CreateAppendUpdateMultiRRAdd(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNode,
    IN      PDB_RECORD      pAddRR,
    IN      WORD            wDeleteType,
    IN      PDB_RECORD      pDeleteRR
    );

VOID
Up_DetachAndFreeUpdate(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PUPDATE         pUpdate
    );

VOID
Up_FreeUpdatesInUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList
    );

VOID
Up_FreeUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList
    );

VOID
Up_FreeUpdateStructOnly(
    IN      PUPDATE         pUpdate
    );

PUPDATE
Up_FreeUpdateEx(
    IN      PUPDATE         pUpdate,
    IN      BOOL            fExecuted,
    IN      BOOL            fDeref
    );

BOOL
Up_IsDuplicateAdd(
    IN OUT  PUPDATE_LIST    pUpdateList,    OPTIONAL
    IN OUT  PUPDATE         pUpdate,
    IN OUT  PUPDATE         pUpdatePrev     OPTIONAL
    );

#endif // _UPDATE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\wins.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    wins.c

Abstract:

    Domain Name System (DNS) Server

    Code for initializing WINS lookup and handling WINS requests.

Author:

    Jim Gilroy (jamesg)     August 2, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  WINS globals
//

PPACKET_QUEUE   g_pWinsQueue;

//
//  WINS request packet
//
//  Keep template of standard WINS request and copy it and
//  overwrite name to make actual request.
//

BYTE    achWinsRequestTemplate[ SIZEOF_WINS_REQUEST ];

//
//  NBSTAT request packet
//
//  Keep a copy of NetBIOS node status request and use it
//  each time.  Only the address we send to changes.
//

#define SZ_NBSTAT_REQUEST_NAME ( "CKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" )

BYTE    achNbstatRequestTemplate[ SIZEOF_WINS_REQUEST ];


//
//  WINS target sockaddr
//

struct sockaddr saWinsSockaddrTemplate;



//
//  Private prototypes
//

VOID
createWinsRequestTemplates(
    VOID
    );

UCHAR
createWinsName(
    OUT     PCHAR   pchResult,
    IN      PCHAR   pchLabel,
    IN      UCHAR   cchLabel
    );


BOOL
Wins_Initialize(
    VOID
    )
/*++

Routine Description:

    Initializes DNS to use WINS lookup.

    Currently WINS queue is initialized all the time in dnsdata.c,
    so only issue is starting a WINS thread.  But use this routine
    so no need to hide details, in case this changes.

Arguments:

    None

Globals:

    SrvCfg_fWinsInitialized - set on first initialization

Return Value:

    TRUE, if successful
    FALSE otherwise, unable to create threads

--*/
{
    //
    //  test for previous initialization
    //

    if ( SrvCfg_fWinsInitialized )
    {
        return( TRUE );
    }

    //
    //  create WINS queue
    //

    g_pWinsQueue = PQ_CreatePacketQueue(
                    "WINS",
                    0,          // no queuing flags
                    WINS_DEFAULT_LOOKUP_TIMEOUT
                    );
    if ( !g_pWinsQueue )
    {
        goto WinsInitFailure;
    }

    //
    //  build WINS request
    //      - request packet template
    //      - request sockaddr template
    //

    createWinsRequestTemplates();

    //
    //  indicate successful initialization
    //
    //  no protection is required on setting this as it is done
    //  only during startup database parsing
    //

    SrvCfg_fWinsInitialized = TRUE;
    return( TRUE );

WinsInitFailure:

    DNS_LOG_EVENT(
        DNS_EVENT_WINS_INIT_FAILED,
        0,
        NULL,
        NULL,
        GetLastError() );

    return( FALSE );

}   //  Wins_Initialize



VOID
createWinsRequestTemplates(
    VOID
    )
/*++

Routine Description:

    Create template for WINS request and WINS sockaddr.

    This is done to simplify working code path.

Arguments:

    None

Return Value:

    None

--*/
{
    PCHAR           pch;
    CHAR            ch;
    INT             i;
    PWINS_NAME      pWinsName;
    PWINS_QUESTION  pWinsQuestion;
    PWINS_QUESTION  pNbstatQuestion;

    //
    //  WINS sockaddr template
    //      - set family and port
    //      - address set in call
    //

    RtlZeroMemory(
        &saWinsSockaddrTemplate,
        sizeof( SOCKADDR )
        );

    saWinsSockaddrTemplate.sa_family = AF_INET;
    ((PSOCKADDR_IN) &saWinsSockaddrTemplate)->sin_port
                                        = htons( WINS_REQUEST_PORT );

    //
    //  build WINS request packet template
    //
    //      - zero memory
    //      - set header
    //      - write NetBIOS name
    //      - set question type, class
    //

    RtlZeroMemory(
        achWinsRequestTemplate,
        SIZEOF_WINS_REQUEST );

    //
    //  header
    //      - zero (request, query, no broadcast)
    //      - set recursion desired flag
    //      - set question count
    //      - set XID when packet queued
    //

    ((PDNS_HEADER)achWinsRequestTemplate)->RecursionDesired = 1;
    ((PDNS_HEADER)achWinsRequestTemplate)->QuestionCount = htons(1);

    //
    //  setup name buffer with max size blank name
    //      - size byte at begining (always 32)
    //      - 15 spaces and <00> workstation byte, converted
    //          to netBIOS name
    //      - zero byte to terminate name
    //
    //  actual requests will overwrite their portion of the name only
    //

    pWinsName = (PWINS_NAME) (achWinsRequestTemplate + sizeof(DNS_HEADER) );
    pWinsName->NameLength = NETBIOS_PACKET_NAME_LENGTH;

    pch = pWinsName->Name;

    for ( i=1; i<NETBIOS_ASCII_NAME_LENGTH; i++ )
    {
        ch = ' ';
        *pch++ = 'A' + (ch >> 4);       // write high nibble
        *pch++ = 'A' + (ch & 0x0F );    // write low nibble
    }
    //  workstation <00> byte

    *pch++ = 'A';       // write high nibble
    *pch++ = 'A';       // write low nibble

    ASSERT ( pch == (PCHAR)& pWinsName->NameEndByte && *pch == 0 );

    //
    //  write standard question type and class
    //      - general name service type
    //      - internet class
    //      - write both in with nmenonics in net byte order
    //

    pWinsQuestion = (PWINS_QUESTION) ++pch;
    pWinsQuestion->QuestionType = NETBIOS_TYPE_GENERAL_NAME_SERVICE;
    pWinsQuestion->QuestionClass = DNS_RCLASS_INTERNET;


#if 0
    //
    //  build netBIOS adapter status request packet template
    //
    //      - copy WINS request template
    //      - reset question type to node status
    //      - set first two bytes in question name
    //

    RtlCopyMemory(
        achNbstatRequestTemplate,
        achWinsRequestTemplate,
        SIZEOF_WINS_REQUEST );

    //
    //  set name for NBSTAT query
    //

    pNbstatQuestion = (PWINS_QUESTION) (achNbstatRequestTemplate
                                                    + sizeof( DNS_HEADER ));
    RtlCopyMemory(
        pNbstatQuestion->Name,
        SZ_NBSTAT_REQUEST_NAME,
        NETBIOS_PACKET_NAME_LENGTH );

    //
    //  type is node status request
    //

    pNbstatQuestion->QuestionType = NETBIOS_TYPE_NODE_STATUS;

#endif

}   // createWinsRequestTemplates



VOID
Wins_Shutdown(
    VOID
    )
/*++

Routine Description:

    Shuts down WINS receive thread.

Arguments:

    None

Return Value:

    None.

--*/
{
    DNS_DEBUG( INIT, ( "Wins_Shutdown()\n" ));

    //
    //  only need cleanup if initialized
    //

    if ( SrvCfg_fWinsInitialized )
    {
        SrvCfg_fWinsInitialized = FALSE;

        //  cleanup event in packet queue

        PQ_CleanupPacketQueueHandles( g_pWinsQueue );
    }

    //
    //  clear WINS flag -- for situation when we become dynamic
    //

    SrvCfg_fWinsInitialized = FALSE;

    DNS_DEBUG( INIT, ( "Finished Wins_Shutdown()\n" ));

}   //  Wins_Shutdown




#if 0
//
//  Now as process, memory cleanup unnecesary
//

VOID
Wins_Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleans up queued WINS queries and deletes WINS queue.

    Note, this does NOT protect threads from attempting to
    queue queries to WINS or the WINS recv threads from accessing
    WINS.

    Use this ONLY when all other threads have been shutdown.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    //  cleanup WINS queue
    //

    PQ_DeletePacketQueue( g_pWinsQueue );
}
#endif




BOOL
FASTCALL
Wins_MakeWinsRequest(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      WORD            wOffsetName,    OPTIONAL
    IN      PDB_NODE        pnodeLookup     OPTIONAL
    )
/*++

Routine Description:

    Send request to WINS server.

Arguments:

    pQuery -- request to send to WINS

    pZone -- zone name to lookup is in

    wOffsetName -- offset to name in packet, if NOT lookup up name
        of question in packet

    pnodeLookup -- domain node to lookup, if NOT looking up name
        of question in packet

Return Value:

    TRUE -- if successfully sent request to WINS
    FALSE -- if failed

--*/
{
    PCHAR           pch;            //  ptr to name char in packet
    CHAR            ch;             //  current char being converted
    PDB_RECORD      pWinsRR;        //  WINS RR for zone
    LONG            nSendLength = SIZEOF_WINS_REQUEST;
    SOCKADDR_IN     saWinsSockaddr;
    INT             err;
    PCHAR           pchlabel;
    UCHAR           cchlabel;
    DWORD           nForwarder;
    WORD            wXid;
    BOOLEAN         funicode = FALSE;

    //  allocate space in packet buffer for request including scope

    BYTE    achWinsRequest[ SIZEOF_WINS_REQUEST+DNS_MAX_NAME_LENGTH ];


    DNS_DEBUG( WINS, (
        "Wins_MakeWinsRequest( %p ), z=%p, off=%d, node=%p.\n",
        pQuery,
        pZone,
        wOffsetName,
        pnodeLookup ));

    //  should NOT already be on queue

    MSG_ASSERT( pQuery, !IS_MSG_QUEUED(pQuery) );
    ASSERT( IS_DWORD_ALIGNED(pQuery) );

    //
    //  if already referred
    //      - get relevant required info from packet
    //      - verify another WINS server in list
    //

    if ( pQuery->fQuestionRecursed )
    {
        MSG_ASSERT( pQuery, pQuery->fQuestionCompleted == FALSE );
        MSG_ASSERT( pQuery, pQuery->fWins );
        MSG_ASSERT( pQuery, pQuery->wTypeCurrent == DNS_TYPE_A );
        MSG_ASSERT( pQuery, pQuery->nForwarder );

        pWinsRR = pQuery->U.Wins.pWinsRR;
        pZone = pQuery->pzoneCurrent;
        pnodeLookup = pQuery->pnodeCurrent;
        wOffsetName = pQuery->wOffsetCurrent;
        cchlabel = pQuery->U.Wins.cchWinsName;

        MSG_ASSERT( pQuery, pWinsRR );
        MSG_ASSERT( pQuery, cchlabel );
        ASSERT( pZone );
    }

    //
    //  if first WINS lookup
    //      - clear queuing XID, let queue assign new one
    //      - clear count of WINS server we're on
    //

    else
    {
        pQuery->wQueuingXid = 0;
        pQuery->nForwarder = 0;

        //
        //  verify valid lookup
        //
        //  1) name is immediate child of zone root
        //  do NOT lookup queries for all names in zone as resolvers will
        //  generate queries with client's domain or search suffixes appended
        //  to query name
        //  example:
        //      www.msn.com.microsoft.com.
        //
        //  2) name label, MUST be convertible to netBIOS name
        //  need name label < 15 characters, as we use up one character to
        //  indicate the netBIOS service type;  (we query for workstation name)

        //
        //  lookup given node
        //      - node must be immediate child of zone root
        //      - MUST have set offset

        if ( pnodeLookup )
        {
            if ( pnodeLookup->pParent != pZone->pZoneRoot )
            {
                DNS_DEBUG( WINS, (
                    "Rejecting WINS lookup for query at %p.\n"
                    "\tnode %p (%s) is not parent of zone root.\n",
                    pQuery,
                    pnodeLookup,
                    pnodeLookup->szLabel ));
                return( FALSE );
            }
            pchlabel = pnodeLookup->szLabel;
            cchlabel = pnodeLookup->cchLabelLength;
        }

        //
        //  lookup question name
        //
        //  - verify question name child of zone root, by checking if it has
        //      only one more label in lookupname
        //  - question starts immediately after header
        //  - note, should be NO compression in question
        //

        else
        {
            if ( pQuery->pLooknameQuestion->cLabelCount
                    != pZone->cZoneNameLabelCount + 1 )
            {
                DNS_DEBUG( WINS, (
                    "Rejecting WINS lookup for query at %p.\n"
                    "\t%d labels in question, %d labels in zone.\n",
                    pQuery,
                    pQuery->pLooknameQuestion->cLabelCount,
                    pZone->cZoneNameLabelCount ));
                return( FALSE );
            }
            ASSERT( wOffsetName == DNS_OFFSET_TO_QUESTION_NAME );
            pchlabel = pQuery->MessageBody;
            cchlabel = *pchlabel++;
        }

#if DBG
        ASSERT( cchlabel < 64 && cchlabel >= 0 );
        wXid = cchlabel;
#endif
        cchlabel = createWinsName(
                        pQuery->U.Wins.WinsNameBuffer,
                        pchlabel,
                        cchlabel );
        if ( !cchlabel )
        {
            DNS_DEBUG( WINS, (
                "Label in %*s invalid or too long for WINS lookup\n"
                "\tsending name error.\n",
                wXid,
                pchlabel ));
            return( FALSE );
        }

        //
        //  get WINS info for this zone
        //      - possible WINS turned off for this zone

        pWinsRR = pZone->pWinsRR;

        if ( !pWinsRR )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  WINS lookup for zone %s without WINS RR\n"
                "\tShould only happen if WINS record just removed\n"
                "\tby admin or zone transfer.\n",
                pZone->pszZoneName ));
            return( FALSE );
        }
        ASSERT( pWinsRR->Data.WINS.cWinsServerCount );
        ASSERT( pWinsRR->Data.WINS.dwLookupTimeout );

        //  save WINS lookup info to message info

        pQuery->fQuestionRecursed = TRUE;
        pQuery->fQuestionCompleted = FALSE;
        pQuery->fWins = TRUE;
        pQuery->U.Wins.cchWinsName = cchlabel;
        pQuery->U.Wins.pWinsRR = pWinsRR;
        pQuery->pzoneCurrent = pZone;
        pQuery->pnodeCurrent = pnodeLookup;
        pQuery->wOffsetCurrent = wOffsetName;
        pQuery->wTypeCurrent = DNS_TYPE_A;
    }

    //
    //  verify unvisited WINS servers exist
    //

    nForwarder = pQuery->nForwarder++;

    if ( (DWORD)nForwarder >= pWinsRR->Data.WINS.cWinsServerCount )
    {
        DNS_DEBUG( WINS, (
            "WARNING:  Failed WINS lookup after trying %d servers.\n"
            "\t%d servers in WINS RR list.\n",
            --pQuery->nForwarder,
            pWinsRR->Data.WINS.cWinsServerCount ));

        TEST_ASSERT( pWinsRR->Data.WINS.cWinsServerCount );
        TEST_ASSERT( pQuery->fQuestionRecursed );
        return( FALSE );
    }

    //
    //  copy WINS request template
    //

    RtlCopyMemory(
        achWinsRequest,
        achWinsRequestTemplate,
        SIZEOF_WINS_REQUEST );

    //
    //  write netBIOS name into packet
    //      - as we go check if high bit
    //

    pchlabel = pQuery->U.Wins.WinsNameBuffer;
    pch = (PCHAR) &((PWINS_REQUEST_MSG)achWinsRequest)->Name.Name;

    while( cchlabel-- )
    {
        ch = *pchlabel++;
        *pch++ = 'A' + (ch >> 4);       // write high nibble
        *pch++ = 'A' + (ch & 0x0F );    // write low nibble
    }

    //
    //  Place the request on WINS queue.
    //
    //  MUST do this before send, so packet is guaranteed to be in
    //  queue when server responds.
    //
    //  After we queue DO NOT TOUCH pQuery, a response from a previous
    //  send may come in and dequeue pQuery.
    //
    //  Queuing
    //      - set queuing time and query time, if query time not yet set
    //      - converts expire timeout to actual expire time.
    //      - sets XID
    //

    pQuery->dwExpireTime = pWinsRR->Data.WINS.dwLookupTimeout;

    wXid = PQ_QueuePacketWithXid(
                g_pWinsQueue,
                pQuery );

    //
    //  set WINS XID to net order for send
    //
    //  To operate on the same server as the WINS server, the packets
    //  MUST have XIDs that netBT, which recevies the packets, considers
    //  to be in the WINS range -- the high bit set (in host order).
    //
    //  Flip to net order for send.
    //

    ((PDNS_HEADER)achWinsRequest)->Xid = htons( wXid );

#if 0
    //
    //  DEVNOTE: this bit may be useful to allow B-nodes to directly
    //      response, but stops WINS servers from responding
    //
    //  set for broadcast?
    //

    if ( pZone->aipWinsServers[0] == 0xffffffff )
    {
        ((PDNS_HEADER)achWinsRequest)->Broadcast = 1;
    }
#endif

    //
    //  create WINS target sockaddr
    //

    RtlCopyMemory(
        &saWinsSockaddr,
        &saWinsSockaddrTemplate,
        sizeof( SOCKADDR ) );

    //
    //  send to next WINS server in RR list
    //

    saWinsSockaddr.sin_addr.s_addr
                        = pWinsRR->Data.WINS.aipWinsServers[ nForwarder ];
    DNS_DEBUG( WINS, (
        "Sending request to WINS for original query at %p\n"
        "\tto WINS server (#%d in list) at %s.\n"
        "\tWINS name = %.*s\n",
        pQuery,
        nForwarder,
        inet_ntoa( saWinsSockaddr.sin_addr ),
        pQuery->U.Wins.cchWinsName,
        pQuery->U.Wins.WinsNameBuffer
        ));

    err = sendto(
                g_UdpSendSocket,
                achWinsRequest,
                nSendLength,
                0,
                (struct sockaddr *) &saWinsSockaddr,
                sizeof( struct sockaddr )
                );

    if ( err != nSendLength )
    {
        ASSERT( err == SOCKET_ERROR );
        err = WSAGetLastError();

        //  check for shutdown

        if ( fDnsServiceExit )
        {
            DNS_DEBUG( SHUTDOWN, (
                "\nSHUTDOWN detected during WINS lookup.\n" ));
            return( TRUE );
        }

        //
        //  don't bother to pull packet out of queue
        //
        //  send failures, VERY rare, and with multiple WINS servers
        //      this lets us make the next sends() and possibly get
        //      name resolution -- only benefit to quiting is
        //      speedier NAME_ERROR return
        //
        //  DEVNOTE:  choices on WINS send
        //
        //          - retry send with next server
        //          - return FALSE
        //          - SERVER_FAILURE entire packet
        //          - return TRUE and let timeout, force retry
        //

        DNS_LOG_EVENT(
            DNS_EVENT_SENDTO_CALL_FAILED,
            0,
            NULL,
            NULL,
            WSAGetLastError() );

        DNS_DEBUG( ANY, (
            "ERROR:  WINS UDP sendto() failed, for query at %p.\n"
            "\tGetLastError() = 0x%08lx.\n",
            pQuery,
            WSAGetLastError() ));
        return( TRUE );
    }

    STAT_INC( WinsStats.WinsLookups );
    PERF_INC( pcWinsLookupReceived );        // PerfMon hook

    return( TRUE );
}



VOID
Wins_ProcessResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process WINS response, sending corresponding packet.

    Note:  caller frees WINS response message.

Arguments:

    pMsg -- message info that is WINS response

Return Value:

    None.

--*/
{
    PWINS_NAME              pWinsName;      //  answer netBIOS name
    PWINS_RESOURCE_RECORD   presponseRR;        //  answer RR
    BOOL            fAnswer;
    INT             err;
    PCHAR           pch;            // current position in packet
    PCHAR           pchEnd;         //  end of packet
    WORD            cDataLength;
    INT             irespRR;
    BOOL            fRecordWritten = FALSE;
    DWORD           ttl;
    IP_ADDRESS      ipAddress;
    PDNS_MSGINFO    pQuery;         //  original client query
    PDB_RECORD      prr;            //  new host A RR
    PDB_NODE        pnode;          //  node of WINS query
    DNS_LIST        listRR;

    //
    //  verify doing WINS lookup
    //

    if ( !g_pWinsQueue )
    {
        Dbg_DnsMessage(
            "BOGUS response packet with WINS XID\n",
            pMsg );
        //ASSERT( FALSE );
        return;
    }

    STAT_INC( WinsStats.WinsResponses );
    PERF_INC( pcWinsResponseSent );      // PerfMon hook

    //
    //  locate and dequeue DNS query matching WINS response
    //
    //      - match based on XID of WINS request
    //      - timeout any deadwood
    //

    pQuery = PQ_DequeuePacketWithMatchingXid(
                g_pWinsQueue,
                pMsg->Head.Xid
                );
    if ( !pQuery )
    {
        DNS_DEBUG( WINS, (
            "No matching query for response from WINS server %s.\n",
            inet_ntoa( pMsg->RemoteAddress.sin_addr )
            ));
        return;
    }
    DNS_DEBUG( WINS, (
        "Found query at %p matching WINS response at %p.\n",
        pQuery,
        pMsg ));

    MSG_ASSERT( pQuery, pQuery->fWins );
    MSG_ASSERT( pQuery, pQuery->fQuestionRecursed );
    MSG_ASSERT( pQuery, pQuery->nForwarder );
    MSG_ASSERT( pQuery, pQuery->pzoneCurrent );
    MSG_ASSERT( pQuery, pQuery->wOffsetCurrent );
    MSG_ASSERT( pQuery, pQuery->dwQueryTime );

    //
    //  check if have answer
    //      - response code == success
    //      - have at least one answer RR
    //
    //  no answer or error
    //
    //      => try lookup with next WINS server
    //
    //      => if out of servers, drop to Done section
    //          - return NAME_ERROR if original question
    //          - continue type ALL query
    //          - move on to next lookup if additional record
    //
    //  DEVNOTE: should accept WINS NXDOMAIN response
    //

    if ( pMsg->Head.AnswerCount == 0 || pMsg->Head.ResponseCode != 0 )
    {
#if DBG
        //  shouldn't have error response code, if have answer

        if ( pMsg->Head.AnswerCount > 0 && pMsg->Head.ResponseCode != 0 )
        {
            DNS_PRINT((
                "ERROR:  WINS response %p, with answer count %d, with error =%d\n"
                "\tI think this may happen when query directed to non-WINS server.\n",
                pMsg,
                pMsg->Head.AnswerCount,
                pMsg->Head.ResponseCode ));
        }
#endif
        DNS_DEBUG( WINS, ( "WINS response empty or error.\n" ));
        if ( Wins_MakeWinsRequest(
                pQuery,
                NULL,
                0,
                NULL ) )
        {
            return;
        }
        goto Done;
    }

    //
    //  packet verification
    //
    //      - skip question, if given
    //      - RR within packet
    //      - RR type and class
    //      - RR data within packet
    //

    pchEnd = DNSMSG_END( pMsg );

    pWinsName = (PWINS_NAME) pMsg->MessageBody;

    if ( pMsg->Head.QuestionCount )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Question count %d in WINS packet for query at %p.\n",
            pMsg->Head.QuestionCount,
            pQuery ));

        if ( pMsg->Head.QuestionCount > 1 )
        {
            goto ServerFailure;
        }
        pWinsName = (PWINS_NAME)( (PCHAR)pWinsName + sizeof(WINS_QUESTION) );

        //
        //  DEVNOTE: assuming WINS sends zero question count
        //  DEVNOTE: not testing for name compression in WINS packets
        //

        goto ServerFailure;
    }

    //
    //  verify WINS name
    //      - falls within packet
    //      - matches query name
    //
    //  note:  WINS server queuing is broken and can end up queuing up
    //      queries for a long time;  this allows us to have two queries
    //      with the same XID on the WINS server (one of which we gave up on
    //      long ago) and the WINS server will toss the second and respond
    //      to the first, giving us a resposne with desired XID but NOT
    //      matching name
    //

    if ( (PCHAR)(pWinsName + 1)  >  pchEnd )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Following WINS answer count past end of packet.\n"
            "\tEnd of packet            = %p\n"
            "\tCurrent RR ptr           = %p\n"
            "\tEnd of RR ptr            = %p\n",
            pchEnd,
            pWinsName,
            (PCHAR)(pWinsName+1)
            ));
        goto ServerFailure;
    }
    if ( pWinsName->NameLength != NETBIOS_PACKET_NAME_LENGTH )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  WINS response has incorrect name format.\n" ));
        goto ServerFailure;
    }

#if 0
    if ( !RtlEqualMemory(
            pWinsName->Name,
            pQuery->U.Wins.WinsNameBuffer,
            NETBIOS_PACKET_NAME_LENGTH ) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  WINS response name does not match query name!!!\n"
            "\tresponse name    = %.*s\n"
            "\tquery name       = %.*s\n"
            "\tNote this can result from DNS server reusing XID within short\n"
            "\tenough time interval that WINS (which queues up too long) sent\n"
            "\ta response for the first query\n",
            NETBIOS_PACKET_NAME_LENGTH,
            pWinsName->Name,
            NETBIOS_PACKET_NAME_LENGTH,
            pQuery->U.Wins.WinsNameBuffer ));
        goto ServerFailure;
    }
#endif

    //
    //  skip scope
    //      - unterminated name, indicates scope,
    //          skip through scope to find

    pch = (PCHAR) &pWinsName->NameEndByte;

    while ( *pch != 0 )
    {
        //  have scope, skip through labels in scope

        pch += *pch + 1;

        if ( pch >= pchEnd )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  WINS response has incorrect name termination.\n" ));
            goto ServerFailure;
        }
    }

    //
    //  verify RR parameters
    //

    presponseRR = (PWINS_RESOURCE_RECORD) ++pch;

    if ( (PCHAR)(presponseRR + 1) > pchEnd )
    {
        DNS_DEBUG( ANY, ( "ERROR:  WINS packet error, RR beyond packet end.\n" ));
        goto ServerFailure;
    }

    if ( presponseRR->RecordType != NETBIOS_TYPE_GENERAL_NAME_SERVICE
            ||
        presponseRR->RecordClass != DNS_RCLASS_INTERNET )
    {
        DNS_DEBUG( WINS, (
            "ERROR:  WINS response record type or class error.\n" ));
        goto ServerFailure;
    }

    //
    //  verify proper RR data length
    //
    //      - must be a multiple of RData length
    //      - must be inside packet
    //

    cDataLength = ntohs( presponseRR->ResourceDataLength );

    if ( cDataLength % sizeof(WINS_RR_DATA)
            ||
         (PCHAR) &presponseRR->aRData + cDataLength > pchEnd )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  WINS response bad RR data length = %d.\n",
            cDataLength ));
        goto ServerFailure;
    }

    //
    //  if owner node not given, find or create it
    //      - if fails assume unacceptable as DNS name
    //
    //  DEVNOTE: packet lookup name
    //  DEVNOTE: also best to do lookup relative to zone root
    //

    pnode = pQuery->pnodeCurrent;
    if ( ! pnode )
    {
        pnode = Lookup_ZoneNode(
                    pQuery->pzoneCurrent,
                    NULL,       // using lookup, not packet name
                    NULL,
                    pQuery->pLooknameQuestion,
                    LOOKUP_FQDN,
                    NULL,       // create
                    NULL        // following node ptr
                    );
        if ( ! pnode )
        {
            //ASSERT( FALSE );
            goto ServerFailure;
        }
    }
    IF_DEBUG( WINS )
    {
        Dbg_NodeName(
            "WINS lookup to write RR to node ",
            pnode,
            "\n" );
    }

    //
    //  set TTL for RR
    //
    //  WINS responses are cached, cache data has RR TTL given as
    //      timeout time in host order
    //

    DNS_DEBUG( WINS, (
        "WINS ttl: dwCacheTimeout %lu dwQueryTime %lu\n",
        ((PDB_RECORD)pQuery->U.Wins.pWinsRR)->Data.WINS.dwCacheTimeout,
        pQuery->dwQueryTime ));
    #define WINS_SANE_TTL   ( 24*60*60*7 )  //  one week
    ASSERT( ((PDB_RECORD)pQuery->U.Wins.pWinsRR)->Data.WINS.dwCacheTimeout < WINS_SANE_TTL );
    ASSERT( abs( ( int ) DNS_TIME()  - ( int ) pQuery->dwQueryTime ) < 60 );

    ttl = ((PDB_RECORD)pQuery->U.Wins.pWinsRR)->Data.WINS.dwCacheTimeout
                + pQuery->dwQueryTime;

    //
    //  read all address data from WINS packet -- write to DNS packet
    //

    DNS_LIST_STRUCT_INIT( listRR );

    irespRR = (-1);

    while ( cDataLength )
    {
        BOOL    bcached;

        cDataLength -= sizeof(WINS_RR_DATA);
        irespRR++;

        //
        //  copy address
        //      - not DWORD aligned
        //

        ipAddress = *(UNALIGNED DWORD *) &presponseRR->aRData[ irespRR ].IpAddress;

        //
        //  if group name, ignore
        //      - will often return 255.255.255.255 address
        //

        if ( presponseRR->aRData[ irespRR ].GroupName
                ||
            ipAddress == (IP_ADDRESS)(-1) )
        {
            DNS_DEBUG( WINS, (
                "WINS response for query at %p, "
                "contained group name or broadcase IP.\n"
                "\tFlags    = 0x%x\n"
                "\tIP Addr  = %p\n",
                pQuery,
                * (UNALIGNED WORD *) &presponseRR->aRData[ irespRR ],
                ipAddress ));

            //  shouldn't be getting all ones on anything but group names

            ASSERT( presponseRR->aRData[irespRR].GroupName );
            continue;
        }

        //
        //  build A record
        //      - fill in IP and TTL
        //        (caching function does overwrite TTL, but need it set to
        //          write records to packet)
        //      - rank as AUTHORITATIVE answer
        //

        prr = RR_CreateARecord(
                    ipAddress,
                    ttl,
                    MEMTAG_RECORD_WINS );
        IF_NOMEM( !prr )
        {
            goto ServerFailure;
        }

        SET_RR_RANK( prr, RANK_CACHE_A_ANSWER );

        DNS_LIST_STRUCT_ADD( listRR, prr );

        //
        //  write RR to packet
        //      - always use compressed name
        //

        if ( Wire_AddResourceRecordToMessage(
                    pQuery,
                    NULL,
                    pQuery->wOffsetCurrent,     // offset to name in packet
                    prr,
                    0 ) )
        {
            fRecordWritten = TRUE;
            CURRENT_RR_SECTION_COUNT( pQuery )++;
        }

        //  note, even if out of space and unable to write
        //  continue building records so have a complete RRset to cache

        continue;
    }

    //
    //  cache the A records from response
    //      - caching time from WINS record
    //

    if ( ! IS_DNS_LIST_STRUCT_EMPTY(listRR) )
    {
        DNS_DEBUG( WINS, (
            "WINS ttl: adding to cache with dwCacheTimeout %lu dwQueryTime %lu\n",
            ((PDB_RECORD)pQuery->U.Wins.pWinsRR)->Data.WINS.dwCacheTimeout,
            pQuery->dwQueryTime ));
        ASSERT( ((PDB_RECORD)pQuery->U.Wins.pWinsRR)->Data.WINS.dwCacheTimeout < WINS_SANE_TTL );
        ASSERT( abs( ( int ) DNS_TIME()  - ( int ) pQuery->dwQueryTime ) < 60 );

        RR_CacheSetAtNode(
            pnode,
            listRR.pFirst,
            listRR.pLast,
            ((PDB_RECORD)pQuery->U.Wins.pWinsRR)->Data.WINS.dwCacheTimeout,
            pQuery->dwQueryTime
            );
    }

Done:

    //
    //  no records written?
    //
    //  assume this means we got group name back and hence wrote no records
    //  hence we don't have to wait for other servers to come back
    //
    //  DEVNOTE: wildcard after WINS lookup?
    //
    //  note, type ALL is special case;  if fail to locate records continue
    //  lookup to pick up possible wildcard records
    //  (some mail programs query with type all don't ask me why)
    //

#if DBG
    if ( ! fRecordWritten )
    {
        DNS_DEBUG( WINS, (
            "No records written from WINS repsonse to query at %p\n"
            "\t-- possible group name, handling as NAME_ERROR.\n",
            pQuery ));
    }
    ELSE_IF_DEBUG( WINS2 )
    {
        Dbg_DbaseNode(
            "Domain node with added WINS RR ",
            pnode );
    }
#endif

    //
    //  answer question or continue if additional records
    //

    MSG_ASSERT( pQuery, !IS_MSG_QUEUED(pQuery) );
    Answer_ContinueNextLookupForQuery( pQuery );
    return;


ServerFailure:

    //
    //  DEVNOTE-LOG: log bad responses from WINS server?
    //
    //      that might be a good way to catch parsing problems from setups
    //      in the field that we do not see

    DNS_DEBUG( ANY, (
        "ERROR:  WINS response parsing error "
        "-- sending server failure for query at %p.\n",
        pQuery ));

    //
    //  if exists, use next WINS server
    //

    if ( Wins_MakeWinsRequest(
            pQuery,
            NULL,
            0,
            NULL ) )
    {
        MSG_ASSERT( pQuery, IS_MSG_QUEUED(pQuery) );
        return;
    }

    //
    //  if have some written information, don't SERVER_FAILURE
    //

    MSG_ASSERT( pQuery, !IS_MSG_QUEUED(pQuery) );

    if ( pQuery->Head.AnswerCount )
    {
        Answer_ContinueNextLookupForQuery( pQuery );
        return;
    }

    Reject_Request(
        pQuery,
        DNS_RCODE_SERVER_FAILURE, 0 );

    //TEST_ASSERT( FALSE );
    return;
}



UCHAR
createWinsName(
    OUT     PCHAR   pchResult,
    IN      PCHAR   pchLabel,
    IN      UCHAR   cchLabel
    )
/*++

Routine Description:

    Create valid WINS (netBIOS) name from UTF8.

Arguments:

    pchResult -- resulting netBIOS name

    pchLabel -- ptr to UTF8 label

    cchLabel -- count of bytes in label

Return Value:

    Length in bytes of resulting WINS name.
    Zero on error.

--*/
{
    PUCHAR      pch = pchResult;
    DWORD       i;
    DWORD       count;
    DWORD       unicodeCount;
    UCHAR       ch;
    BOOLEAN     funicode = FALSE;
    WCHAR       wch;
    WCHAR       unicodeBuffer[ MAX_WINS_NAME_LENGTH+1 ];
    DNS_STATUS  status;

    //
    //  if > 45, even best case
    //      (UTF8 multi-byte to single OEM chars) won't fit
    //

    if ( cchLabel > 45 )
    {
        return( 0 );
    }

    //
    //  verify length
    //      - no more than 15 characters so on non-extended name stop at 15
    //      - optimize for non-extended < 15 name (typical case), by
    //          converting in one pass
    //

    for ( i=0; i<cchLabel; i++ )
    {
        ch = pchLabel[i];
        if ( ch > 0x80 )
        {
            funicode = TRUE;
            break;
        }
        if ( i >= 15 )
        {
            return( 0 );
        }
        if ( ch <= 'z' && ch >= 'a' )
        {
            ch -= 0x20;
        }
        *pch++ = ch;
    }

    //  if not extended, we're done

    if ( !funicode )
    {
        DNS_DEBUG( WINS2, (
            "WINS lookup on pure ANSI name convert to %.*s\n",
            cchLabel,
            pchResult ));
        return( cchLabel );
    }

    //
    //  multi-byte UTF8
    //      - bring name to unicode and upcase
    //

    unicodeCount = DnsUtf8ToUnicode(
                        pchLabel,
                        cchLabel,
                        unicodeBuffer,
                        MAX_WINS_NAME_LENGTH+1 );
    if ( unicodeCount == 0 )
    {
        ASSERT( GetLastError() == ERROR_INSUFFICIENT_BUFFER );

        DNS_DEBUG( WINS, (
            "ERROR:  WINS attempted on invalid\too long UTF8 extended name %.*s.\n",
            cchLabel,
            pchLabel ));
        return( 0 );
    }
    if ( unicodeCount > MAX_WINS_NAME_LENGTH )
    {
        ASSERT( unicodeCount <= MAX_WINS_NAME_LENGTH );
        return( 0 );
    }

    //
    //  DEVNOTE: don't need to do this if OEM call handles it
    //

    i = CharUpperBuffW( unicodeBuffer, unicodeCount );
    if ( i != unicodeCount )
    {
        ASSERT( FALSE );
        return( 0 );
    }

    IF_DEBUG( WINS2 )
    {
        DnsDbg_Utf8StringBytes(
            "WINS lookup string:",
            pchLabel,
            cchLabel );

        DnsDbg_UnicodeStringBytes(
            "WINS lookup string",
            unicodeBuffer,
            unicodeCount );
    }

    //
    //  go to OEM -- WINS uses OEM on wire
    //

    status = RtlUpcaseUnicodeToOemN(
                pchResult,
                MAX_WINS_NAME_LENGTH,
                & count,
                unicodeBuffer,
                unicodeCount*2 );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Unable to convert unicode name %.*S to OEM for WINS lookup!\n",
            unicodeCount,
            unicodeBuffer ));
        return( 0 );
    }
    ASSERT( count <= MAX_WINS_NAME_LENGTH );

    IF_DEBUG( WINS2 )
    {
        DnsDbg_Utf8StringBytes(
            "WINS lookup string:",
            pchLabel,
            cchLabel );

        DnsDbg_UnicodeStringBytes(
            "WINS lookup string",
            unicodeBuffer,
            unicodeCount );

        DnsDbg_Utf8StringBytes(
            "WINS OEM lookup string:",
            pchResult,
            count );
    }

    return( (UCHAR)count );
}



//
//  WINS\WINSR installation and removal from zone
//
//  There are probably two reasonable approaches:
//  1) Treat as directive
//      - mimic record for dispatch
//      - but otherwise keep ptr's out of database
//      - requires WINS hook in all RR routines
//      - special case XFR to include WINS to MS
//      - special case IXFR to send WINS when appropriate
//          (MS and WINS change in version interval sent)
//      - RPC WINS at ALL or root
//
//  2) Treat as record
//      - dispatch as record
//      - WINS hook in add routines to protect local WINS adds
//      - get WINS in IXFR list for free
//      - special casing on XFR (MS for WINS, no LOCAL)
//      - special casing in IXFR (WINS for MS only, no LOCAL)
//      - RPC special casing to get correct record for secondary LOCAL
//
//  Pretty much going with #2.
//  On primary treated as just another record, except transfer restrictions.
//

DNS_STATUS
Wins_RecordCheck(
    IN OUT  PZONE_INFO      pZone,
    IN      PDB_NODE        pNodeOwner,
    IN OUT  PDB_RECORD      pRR
    )
/*++

Routine Description:

    Setup WINS / WINS-R records in zone.

Arguments:

    pRR - new WINS record

    pNodeOwner  -- RR owner node

    pZone -- zone to install in

Return Value:

    ERROR_SUCCESS -- if successful adding regular (non-LOCAL) RR
    DNS_INFO_ADDED_LOCAL_WINS -- if successfully added local record
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_RECORD      poldDbase_Wins;

    //
    //  WINS record only supported in authoritative zone, at zone root
    //
    //  hack for SAM server can have us calling this through RPC with no zone;
    //  extract zone from owner node, and if valid zone root proceed
    //

    if ( !pZone || !IS_AUTH_ZONE_ROOT(pNodeOwner) )
    {
        DNS_DEBUG( INIT, (
            "ERROR:  WINS RR not at zone root\n" ));
        return( DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT );
    }

    //
    //  WINS \ WINS-R specific
    //  WINS:
    //      - at least one server
    //      - forward lookup
    //      - init WINS lookup
    //  WINS-R:
    //      - reverse lookup
    //      - init NBSTAT lookup
    //

    if ( pRR->wType == DNS_TYPE_WINS )
    {
        if ( pRR->Data.WINS.cWinsServerCount == 0 )
        {
            return( DNS_ERROR_NEED_WINS_SERVERS );
        }
        if ( pZone->fReverse )
        {
            return( DNS_ERROR_INVALID_ZONE_TYPE  );
        }
        if ( ! Wins_Initialize() )
        {
            return( DNS_ERROR_WINS_INIT_FAILED );
        }
    }
    else
    {
        ASSERT( pRR->wType == DNS_TYPE_WINSR );
        if ( !pZone->fReverse )
        {
            return( DNS_ERROR_INVALID_ZONE_TYPE  );
        }
        if ( ! Nbstat_Initialize() )
        {
            return( DNS_ERROR_NBSTAT_INIT_FAILED );
        }
    }

    //
    //  set defaults if zero timeouts
    //

    if ( pRR->Data.WINS.dwLookupTimeout == 0 )
    {
        pRR->Data.WINS.dwLookupTimeout = WINS_DEFAULT_LOOKUP_TIMEOUT;
    }
    if ( pRR->Data.WINS.dwCacheTimeout == 0 )
    {
        pRR->Data.WINS.dwCacheTimeout = WINS_DEFAULT_TTL;
    }

    IF_DEBUG( INIT )
    {
        Dbg_DbaseRecord(
            "New WINS or WINS-R record",
            pRR );
    }

    //
    //  on file load, verify no existing WINS record
    //
    //  DEVNOTE: note, this doesn't handle case of file load well, really need
    //              a separate zone flag for that
    //

    if ( !SrvCfg_fStarted && pZone->pWinsRR )
    {
        return( DNS_ERROR_RECORD_ALREADY_EXISTS );
    }

    //  set flags
    //      - set zone rank
    //      - set zero TTL to avoid remote caching

    pRR->dwTtlSeconds = 0;
    pRR->dwTimeStamp = 0;
    SET_RANK_ZONE(pRR);

    //
    //  WINS setup in zone:
    //
    //  primary
    //      - handled EXACTLY like SOA, resides in list, ptr kept in zone block
    //
    //  secondary
    //      - database stays in list
    //      - local loaded into pLocalWins in zone block
    //          which is cleared after install
    //      - active WINS is pWinsRR ptr in zone block
    //      - if both exist this is LOCAL record
    //

    DNS_DEBUG( ANY, (
        "WINSTRACK:  check new %s WINS RR (%p) for zone %s\n",
        IS_WINS_RR_LOCAL(pRR) ? "LOCAL" : "",
        pRR,
        pZone->pszZoneName ));

    if ( IS_ZONE_SECONDARY(pZone) )
    {
        if ( IS_WINS_RR_LOCAL(pRR) )
        {
            pZone->pLocalWinsRR = pRR;
            return( DNS_INFO_ADDED_LOCAL_WINS );
        }
    }

    return( ERROR_SUCCESS );
}



VOID
Wins_StopZoneWinsLookup(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Stop WINS or NBSTAT lookup on a zone.

Arguments:

    pZone -- ptr to zone

    fRemote -- stop WINS lookup caused by XFR'd record

Return Value:

    None

--*/
{
    PDB_RECORD  prr;
    BOOL        flocal;

    ASSERT( pZone );
    ASSERT( IS_ZONE_LOCKED(pZone) );

    //
    //  primary -- remove database record if exists
    //
    //  secondary -- eliminate only REFERENCE to any database record
    //
    //  in both cases -- free any LOCAL record
    //
    //
    //  DEVNOTE: primary WINS turnoff should be generate an UPDATE blob
    //

    prr = pZone->pWinsRR;
    pZone->pWinsRR = NULL;
    flocal = pZone->fLocalWins;
    pZone->fLocalWins = FALSE;

    if ( prr )
    {
        DNS_DEBUG( ANY, (
            "WINSTRACK:  stopping WINS lookup (cur RR = %p) on zone %s\n",
            prr,
            pZone->pszZoneName ));

        //
        //  primary
        //      - both LOCAL and standard WINS are currently stored in RR list
        //

        if ( IS_ZONE_PRIMARY(pZone) )
        {
            RR_DeleteMatchingRecordFromNode(
                pZone->pZoneRoot,
                prr );
        }

        //
        //  secondary zone
        //      - even after stopping WINS lookup by deleting LOCAL
        //      WINS, may still have WINS from primary

        else
        {
            if ( flocal )
            {
                RR_Free( prr );
            }
            Wins_ResetZoneWinsLookup( pZone );
        }
    }
}



VOID
Wins_ResetZoneWinsLookup(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Set\reset zone WINS\WINSR lookup.

    Called after load, update, XFR to reset lookup to use proper (new\old)
    WINS record

Arguments:

    pZone -- ptr to zone

Return Value:

    None

--*/
{
    PDB_RECORD  prrNew = NULL;
    PDB_RECORD  prrExisting;
    //PDB_RECORD  prrDelete = NULL;
    WORD        type = pZone->fReverse ? DNS_TYPE_WINSR : DNS_TYPE_WINS;


    DNS_DEBUG( WINS, (
        "Wins_ResetZoneWinsLookup() on zone %s\n"
        "\tpWinsRR      = %p\n"
        "\tpLocalWinsRR = %p\n",
        pZone->pszZoneName,
        pZone->pWinsRR,
        pZone->pLocalWinsRR ));

    prrExisting = pZone->pWinsRR;

    //
    //  primary zone, treat just like SOA
    //      - optimize the no-change scenario
    //
    //  keeping both LOCAL\non in RR list;  this gives us standard update
    //  behavior;  only difference is must screen these records out of XFR
    //
    //  maybe a problem here on zone conversion,
    //  especially worrisome is demoting primary which has local WINS;  if record
    //  is NOT extracted from database
    //
    //  but advantages to keeping this all in the database for primary are clear
    //  no special casing for update deletes, get standard replace semantics
    //

    if ( IS_ZONE_PRIMARY(pZone) )
    {
        prrNew = RR_FindNextRecord(
                    pZone->pZoneRoot,
                    type,
                    NULL,
                    0 );
        if ( prrNew == prrExisting )
        {
            //  this could hit on zone conversion
            //  but should be blocked (zone locked) while this set
            ASSERT( pZone->pLocalWinsRR == NULL );
            return;
        }
    }

    //
    //  Secondary
    //      - new local => set, and delete old if local
    //      - existing local => leave it
    //      - otherwise => read from database
    //          - if found set
    //          - otherwise clear
    //      note, that do NOT clear old database WINS
    //
    //  DEVNOTE: local WINS in database?
    //          if decide that file load (or even RPC) should add to database,
    //          then first read database, and if local cut out record set
    //          it as incoming local and apply steps below
    //

    else if ( !IS_ZONE_FORWARDER( pZone ) )
    {
        BOOL  fexistingLocal;

        ASSERT( IS_ZONE_SECONDARY(pZone) );

        fexistingLocal = ( prrExisting &&
                            (prrExisting->Data.WINS.dwMappingFlag & DNS_WINS_FLAG_LOCAL) );

        ASSERT( pZone->fLocalWins == fexistingLocal );

        //  new local WINS, takes precedence

        if ( pZone->pLocalWinsRR )
        {
            DNS_DEBUG( WINS, (
                "Setting new local WINS RR at %p\n",
                pZone->pLocalWinsRR ));

            prrNew = pZone->pLocalWinsRR;
            if ( fexistingLocal )
            {
                //Timeout_FreeWithFunction( prrExisting, RR_Free );
                RR_Free( prrExisting );
            }
            goto SetWins;
        }

#if 0
        //  if PRIMARY zone's store local WINS in database, then can not
        //  do special casing for existing local UNTIL extract record
        //  and verify it is NOT LOCAL (local would need extraction)

        else if ( fexistingLocal )
        {
            DNS_DEBUG( WINS, (
                "Existing LOCAL WINS at %p -- no changes.\n",
                prrExisting ));
            return;
        }
#endif

        //
        //  if RR list has no record or non-LOCAL
        //      - existing local, takes precedence
        //      - otherwise install database RR, if any
        //

        prrNew = RR_FindNextRecord(
                    pZone->pZoneRoot,
                    type,
                    NULL,
                    0 );

        if ( !prrNew || !IS_WINS_RR_LOCAL(prrNew) )
        {
            if ( fexistingLocal )
            {
                DNS_DEBUG( WINS, (
                    "Existing LOCAL WINS at %p -- no changes.\n",
                    prrExisting ));
                return;
            }
            goto SetWins;
        }

        //
        //  database record is local -- from primary conversion
        //      - hack it from database
        //      - install it (it should usually match existing local)
        //

        ASSERT( prrNew == prrExisting );

        prrNew = RR_UpdateDeleteMatchingRecord(
                        pZone->pZoneRoot,
                        prrNew );
        ASSERT( prrNew );

        DNS_DEBUG( ANY, (
            "WARNING:  cut LOCAL WINS RR from zone %s RR list!\n"
            "\terror if not on zone conversion!\n",
            pZone->pszZoneName ));

        if ( prrNew == prrExisting )
        {
            return;
            //goto SetWins;
        }
        else if ( fexistingLocal )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  LOCAL WINS RR in secondary zone %s RR list,\n"
                "\tdid NOT match existing RR at %p\n",
                pZone->pszZoneName,
                prrExisting ));
            RR_Free( prrExisting );
        }
    }

SetWins:

    //  always clear local load field

    pZone->pLocalWinsRR = NULL;

    //  if no WINS, done

    if ( !prrNew )
    {
        goto Failed;
    }

    //  if not existing, initialize

    if ( !prrExisting && prrNew )
    {
        if ( pZone->fReverse )
        {
            if ( !Nbstat_Initialize() )
            {
                DNS_PRINT((
                    "ERROR:  NBSTAT init failed updating zone NBSTAT record\n"
                    "\tfor zone %s.\n",
                    pZone->pszZoneName ));
                goto Failed;
            }
        }
        else if ( !Wins_Initialize() )
        {
            DNS_PRINT((
                "ERROR:  WINS init failed updating zone WINS record\n"
                "\tfor zone %s.\n",
                pZone->pszZoneName ));
            goto Failed;
        }
    }

    //  installed desired new WINS RR
    //  keep a flag indicating LOCAL WINS
    //      the purpose of this is simply to be able to test "locality"
    //      without holding zone lock and withoug having to get local (stack)
    //      copy of ptr to WINS to do check

    pZone->pWinsRR = prrNew;
    pZone->fLocalWins = IS_WINS_RR_LOCAL(prrNew);

    DNS_DEBUG( ANY, (
        "WINSTRACK:  Installed %s WINS(R) %p in zone %s\n",
        pZone->fLocalWins ? "LOCAL" : "",
        prrNew,
        pZone->pszZoneName ));
    return;

Failed:

    DNS_DEBUG( ANY, (
        "WINSTRACK:  ResetZoneWinsLookup() for zone %s is STOPPING WINS lookup\n"
        "\texisting RR was %p\n",
        pZone->pszZoneName,
        prrExisting ));

    pZone->pWinsRR = NULL;
    pZone->fLocalWins = FALSE;
    return;

#if 0
    //  failed attempt to isolate WINS records from RR list
    //  IXFR send\recv use of update list, made this issue more complicated than
    //      it was worth:  way out might be to always send full root info on
    //      IXFR

    //
    //  DEVNOTE: should have atomic WINS\WINSR start here
    //              use on zone transfer and after load
    //      records should be parsed and held, then "activated" all at
    //      once
    //

    //
    //  DEVNOTE: need to stop WINS lookup on secondary, when recv full
    //      zone transfer (or delete on IXFR) that does NOT contain XFR
    //      record and NO local record is available
    //
#endif
}

//
//  End of wins.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\zonepri.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    zonepri.c

Abstract:

    Domain Name System (DNS) Server

    Routines to handle zone transfer for primary.

Author:

    Jim Gilroy (jamesg)     April 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Max name servers possible in zone
//      - to allocate temporary array

#define MAX_NAME_SERVERS    (400)


//
//  Private protos
//

DWORD
zoneTransferSendThread(
    IN      LPVOID  pvMsg
    );

BOOL
transferZoneRoot(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PDB_NODE        pNode
    );

BOOL
traverseZoneAndTransferRecords(
    IN OUT  PDB_NODE        pNode,
    IN      PDNS_MSGINFO    pMsg
    );

BOOL
writeZoneNodeToMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wRRType,
    IN      WORD            wNameOffset
    );

DNS_STATUS
sendIxfrResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    );

BOOL
checkIfIpIsZoneNameServer(
    IN OUT  PZONE_INFO      pZone,
    IN      IP_ADDRESS      IpAddress
    );

DNS_STATUS
buildZoneNsList(
    IN OUT  PZONE_INFO      pZone
    );



//
//  XFR write utilities
//

DNS_STATUS
writeXfrRecord(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wOffset,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write record for zone transfer.

    This is for IXFR query where it is assumed that zone name
    is the question name of the packet.

    For TCP transfer, this routine sends message when buffer is full,
    then continues writing records for node.

Arguments:

    pMsg - message to write to

Return Value:

    ERROR_SUCCESS if successful.
    DNSSRV_STATUS_NEED_AXFR on overfilling UDP packet.
    ErrorCode on other failure.

--*/
{
    BOOL    fspin = FALSE;

    //  offsets other than to question are unuseable, as they
    //      are broken when wrap to new message

    ASSERT( pNode || wOffset==DNS_OFFSET_TO_QUESTION_NAME );

    DNS_DEBUG( ZONEXFR, (
        "writeXfrRecord( pMsg=%p, pRR=%p )\n",
        pMsg,
        pRR ));

    //
    //  write in loop, so can send and continue if hit truncation
    //
    //  if hit truncation
    //      - if UDP => FAILED -- return
    //      - if TCP
    //          - send and reset packet
    //          - retry write
    //

    while ( ! Wire_AddResourceRecordToMessage(
                    pMsg,
                    pNode,
                    wOffset,
                    pRR,
                    0 ) )
    {
        DNS_DEBUG( ZONEXFR, (
            "XFR transfer msg %p full writing RR at %p.\n",
            pMsg,
            pRR ));

        ASSERT( pMsg->Head.Truncation );
        pMsg->Head.Truncation = FALSE;

        //
        //  packet is full
        //      - if UDP (or spinning), fail
        //      - if TCP, send it, reset for reuse
        //

        if ( !pMsg->fTcp || fspin )
        {
            ASSERT( !pMsg->fTcp );      // shouldn't spin TCP packet
            goto Failed;
        }
        fspin = TRUE;

        if ( Send_ResponseAndReset(pMsg) != ERROR_SUCCESS )
        {
            DNS_DEBUG( ZONEXFR, (
                "ERROR sending zone transfer message at %p.\n",
                pMsg ));
            goto Failed;
        }
    }

    //  wrote RR - inc answer count

    pMsg->Head.AnswerCount++;

    return( ERROR_SUCCESS );

Failed:

    //
    //  most common error will be over-filling UDP packet
    //

    if ( !pMsg->fTcp )
    {
        DNS_DEBUG( ZONEXFR, (
            "Too many IXFR records for UDP packet %p.\n",
            pMsg ));
        return( DNSSRV_STATUS_NEED_TCP_XFR );
    }
    else
    {
        DNS_DEBUG( ZONEXFR, (
            "ERROR:  writeUpdateVersionToIxfrResponse() failed.\n",
            pMsg ));
        return( DNS_RCODE_SERVER_FAILURE );
    }
}



DNS_STATUS
Xfr_WriteZoneSoaWithVersion(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_RECORD      pSoaRR,
    IN      DWORD           dwVersion   OPTIONAL
    )
/*++

Routine Description:

    Write zone SOA with version.

    This is for IXFR query where it is assumed that zone name
    is the question name of the packet.

Arguments:

    pMsg - message to write to

    pZone - info structure for zone

    dwVersion - desired zone version;  OPTIONAL, if zero then ignore
        and use current version

Return Value:

    TRUE if successful.
    FALSE on error (out of space in packet).

--*/
{
    DNS_STATUS  status;

    ASSERT( pSoaRR && pSoaRR->wType == DNS_TYPE_SOA );
    ASSERT( !pMsg->fDoAdditional  &&  pMsg->Head.QuestionCount==1 );

    DNS_DEBUG( ZONEXFR, (
        "Xfr_WriteZoneSoaWithVersion( msg=%p, psoa=%p, v=%d )\n",
        pMsg,
        pSoaRR,
        dwVersion ));

    //
    //  write SOA record, name is always offset to question name
    //
    //  since SOA record is written repeatedly in IXFR, allow it's
    //      names to be compressed
    //

    pMsg->fNoCompressionWrite = FALSE;

    status = writeXfrRecord(
                    pMsg,
                    NULL,
                    DNS_OFFSET_TO_QUESTION_NAME,
                    pSoaRR );

    pMsg->fNoCompressionWrite = TRUE;

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ZONEXFR, (
            "Unable to write SOA to IXFR packet %p\n",
            pMsg ));
        return( status );
    }

    //
    //  backtrack from pCurrent to version and set to desired value
    //

    if ( dwVersion )
    {
        PCHAR pch;
        pch = pMsg->pCurrent - SIZEOF_SOA_FIXED_DATA;
        WRITE_PACKET_HOST_DWORD( pch, dwVersion );
    }
    return( status );
}


//
//  Private utils
//


DNS_STATUS
parseIxfrClientRequest(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Parse IXFR request packet retrieving current client version.

    Note, starting packet state, is normal parsing of query question.
    pCurrent may be assumed to be immediately after question.

Arguments:

    pMsg - IXFR request packet.

Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    register PCHAR      pch;
    PCHAR               pchpacketEnd;
    PDNS_WIRE_RECORD    pwireRR;
    PZONE_INFO          pzone;
    WORD                type;
    WORD                dataLength;
    DWORD               version;


    DNS_DEBUG( XFR2, (
        "parseIxfrClientRequest( %p )\n",
        pMsg ));

    //
    //  packet verification
    //      1 question, 1 authority SOA, no answers, no additional
    //

    if ( pMsg->Head.QuestionCount != 1 ||
        pMsg->Head.NameServerCount != 1 ||
        pMsg->Head.AnswerCount != 0 ||
        pMsg->Head.AdditionalCount != 0 )
    {
        goto FormError;
    }

    //
    //  read authority SOA record
    //      - must be for zone in question
    //      - save current ptr (position after question)
    //      as response is written from this location
    //

    pchpacketEnd = DNSMSG_END(pMsg);
    pch = pMsg->pCurrent;

    if ( pch >= pchpacketEnd )
    {
        goto FormError;
    }
    pzone = Lookup_ZoneForPacketName(
                (PCHAR) pMsg->MessageBody,
                pMsg );
    if ( pzone != pMsg->pzoneCurrent )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  bad IXFR packet %p, zone name mismatch\n", pMsg ));
        goto FormError;
    }

    pch = Wire_SkipPacketName( pMsg, pch );
    if ( !pch )
    {
        goto FormError;
    }
    pwireRR = (PDNS_WIRE_RECORD) pch;
    pch += sizeof(DNS_WIRE_RECORD);
    if ( pch > pchpacketEnd )
    {
        DNS_PRINT(( "ERROR:  bad RR struct out of packet.\n" ));
        goto FormError;
    }
    type = FlipUnalignedWord( &pwireRR->RecordType );
    if ( type != DNS_TYPE_SOA )
    {
        DNS_PRINT(( "ERROR:  non-SOA record in IXFR request.\n" ));
        goto FormError;
    }

    //  get version number from SOA data

    dataLength = FlipUnalignedWord( &pwireRR->DataLength );
    pch += dataLength;
    if ( pch > pchpacketEnd )
    {
        DNS_DEBUG( ANY, ( "ERROR:  bad RR data out of packet.\n" ));
        goto FormError;
    }
    version = FlipUnalignedDword( pch - SIZEOF_SOA_FIXED_DATA );

    //  check for MS tag
    //  BIND flag always false, new IXFR aware servers should AXFR correctly

    XFR_MS_CLIENT(pMsg) = FALSE;
    XFR_BIND_CLIENT(pMsg) = FALSE;

    if ( pch != pchpacketEnd )
    {
        if ( pch+sizeof(WORD) == pchpacketEnd  &&
            *(UNALIGNED WORD *) pch == (WORD)DNS_FAST_AXFR_TAG )
        {
            XFR_MS_CLIENT(pMsg) = TRUE;
        }
        else
        {
            CLIENT_ASSERT( FALSE );
        }
    }

    //  set version

    IXFR_CLIENT_VERSION(pMsg) = version;

    DNS_DEBUG( XFR2, (
        "Leaving parseIxfrClientRequest( %p )\n"
        "\tclient version   = %d\n"
        "\tBIND flag        = %d\n",
        pMsg,
        version,
        XFR_BIND_CLIENT(pMsg) ));

    return( ERROR_SUCCESS );

FormError:

    DNS_DEBUG( ANY, (
        "ERROR:  bogus IXFR request packet %p.\n",
        pMsg ));

    pMsg->pCurrent = DNSMSG_END( pMsg );

    return( DNS_ERROR_RCODE_FORMAT_ERROR );
}



VOID
Xfr_SendNotify(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Send notify message to all slave servers for this zone.

Arguments:

    pZone -- zone being notified

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    PDNS_MSGINFO    pmsg;
    PIP_ARRAY       pnotifyArray;

    //
    //  Ignore forwarder zones and zones that are not active.
    //

    if ( IS_ZONE_FORWARDER( pZone ) || IS_ZONE_SHUTDOWN( pZone ) )
    {
        return;
    }

    ASSERT( pZone );
    ASSERT( IS_ZONE_PRIMARY(pZone) || IS_ZONE_SECONDARY(pZone) ||
            (IS_ZONE_CACHE(pZone) && pZone->fNotifyLevel == ZONE_NOTIFY_OFF) );
    ASSERT( pZone->pZoneRoot );

    DNS_DEBUG( ZONEXFR, (
        "Xfr_SendNotify() for zone %S\n",
        pZone->pwsZoneName
        ));

    //
    //  screen auto-created out here
    //

    if ( pZone->fAutoCreated )
    {
        return;
    }

    //
    //  determine servers (if any) to notify
    //
    //      OFF     -- no notify
    //      LIST    -- only servers explicitly in notify list
    //      ALL     -- all secondaries, either from all zone NS or
    //                  from explicit list
    //

    if ( pZone->fNotifyLevel == ZONE_NOTIFY_OFF )
    {
        DNS_DEBUG( XFR, (
            "NOTIFY OFF on zone %S\n",
            pZone->pwsZoneName ));
        return;
    }

    else if ( pZone->fNotifyLevel == ZONE_NOTIFY_LIST_ONLY )
    {
        pnotifyArray = pZone->aipNotify;
        if ( !pnotifyArray )
        {
            //  DEVNOTE: perhaps should have admin or server reject this state
            //      so only get here if forced into registry
            DNS_DEBUG( XFR, (
                "NOTIFY LIST on zone %S, but no notify list.\n",
                pZone->pwsZoneName ));
            return;
        }
    }

    else    // NOTIFY_ALL secondaries
    {
        //  obviously can hack registry to get here, otherwise should never happen
        ASSERT( pZone->fNotifyLevel == ZONE_NOTIFY_ALL_SECONDARIES );

        if ( pZone->aipSecondaries )
        {
            pnotifyArray = pZone->aipSecondaries;
        }
        else
        {
            if ( IS_ZONE_NS_DIRTY(pZone) || !pZone->aipNameServers )
            {
                buildZoneNsList( pZone );
            }
            pnotifyArray = pZone->aipNameServers;
        }
    }

    if ( !pnotifyArray )
    {
        DNS_DEBUG( XFR, (
            "NOTIFY ALL secondaries, but no secondaries for zone %S\n",
            pZone->pwsZoneName ));
        return;
    }

    //
    //  build SOA-NOTIFY query
    //      - create SOA question
    //      - set Opcode to NOTIFY
    //      - set Authoritative bit
    //

    pmsg = Msg_CreateSendMessage( 0 );
    IF_NOMEM( !pmsg )
    {
        DNS_PRINT(( "ERROR:  unable to allocate memory for NOTIFY.\n" ));
        return;
    }
    if ( ! Msg_WriteQuestion(
                pmsg,
                pZone->pZoneRoot,
                DNS_TYPE_SOA ) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Unable to write NOTIFY for zone %S\n",
            pZone->pwsZoneName ));
        ASSERT( FALSE );
        goto Done;
    }
    pmsg->Head.Opcode = DNS_OPCODE_NOTIFY;
    pmsg->Head.Authoritative = TRUE;

    //  write current SOA to answer section

    pmsg->fDoAdditional = FALSE;

    SET_TO_WRITE_ANSWER_RECORDS(pmsg);

    if ( 1 != Wire_WriteRecordsAtNodeToMessage(
                    pmsg,
                    pZone->pZoneRoot,
                    DNS_TYPE_SOA,
                    DNS_OFFSET_TO_QUESTION_NAME,
                    0 ) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Unable to write SOA to Notify packet %S\n",
            pZone->pwsZoneName ));
        ASSERT( FALSE );
    }

    //
    //  send NOTIFY to secondaries in notify list
    //
    //  note:  all notify lists, are atomic and subject to timeout delete, so
    //      no need to protect
    //

    pmsg->fDelete = FALSE;

    Send_Multiple(
        pmsg,
        pnotifyArray,
        & MasterStats.NotifySent );

    PERF_SET( pcNotifySent, MasterStats.NotifySent );    // PerfMon hook

    //
    //  DEVNOTE: keep some sort of NOTIFY record to record ACKs?
    //      be able to resend
    //

Done:

    Packet_Free( pmsg );
}



VOID
Xfr_TransferZone(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Check zone transfer request, and transfer the zone if valid.

Arguments:

    pMsg -- request for zone transfer

Return Value:

    None.

--*/
{
    PZONE_INFO      pzone;
    PDB_NODE        pnode;
    PDB_NODE        pnodeClosest;
    HANDLE          hThread;
    DNS_STATUS      status;

    ASSERT( pMsg->fDelete );

    STAT_INC( MasterStats.Request );
    PERF_INC( pcZoneTransferRequestReceived );   // PerfMon hook

    //
    //  lookup desired zone name
    //
    //  verify:
    //      - is zone root node
    //      - we are authoritative for it
    //

    pzone = Lookup_ZoneForPacketName(
                pMsg->MessageBody,
                pMsg );
    if ( !pzone )
    {
        PVOID   argArray[2];
        BYTE    typeArray[2];

        typeArray[0] = EVENTARG_IP_ADDRESS;
        typeArray[1] = EVENTARG_LOOKUP_NAME;

        argArray[0] = (PVOID) (ULONG_PTR) pMsg->RemoteAddress.sin_addr.s_addr;
        argArray[1] = (PVOID) pMsg->pLooknameQuestion;

        DNS_LOG_EVENT(
            DNS_EVENT_BAD_ZONE_TRANSFER_REQUEST,
            2,
            argArray,
            typeArray,
            0 );

        DNS_DEBUG( ZONEXFR, (
            "Received zone transfer request at %p for name which\n"
            "\tis not a zone root, or for which we are not authoritative\n",
            pMsg ));

        STAT_INC( MasterStats.NameError );
        Reject_RequestIntact(
            pMsg,
            DNS_RCODE_NAME_ERROR,
            0 );
        return;
    }

    //
    //  check that transfer ok
    //
    //  don't transfer if
    //      - shutdown
    //      - paused
    //      - receiving zone transfer
    //      - sending another transfer
    //      - secondary NOT in secure secondaries list
    //
    //  DEVNOTE: allow multiple transfers at once
    //      - need multi-thread
    //      - need count of outstanding transfers (or semaphore), so don't
    //      start allowing updates too soon
    //

    pMsg->pzoneCurrent = pzone;

    if ( IS_ZONE_SHUTDOWN(pzone) )
    {
        STAT_INC( MasterStats.RefuseShutdown );
        goto Refused;
    }

    //
    //  stub zone - no transfers allowed
    //

    if ( IS_ZONE_STUB( pzone ) )
    {
        goto Refused;
    }

    //
    //  secondary security
    //      - no security   => accept any IP, wide open
    //      - no XFR        => stop
    //      - only zone NS  => check against NS list
    //      - only list     => check against list
    //

    if ( pzone->fSecureSecondaries )
    {
        if ( pzone->fSecureSecondaries == ZONE_SECSECURE_NO_XFR )
        {
            STAT_INC( MasterStats.RefuseSecurity );
            goto Refused;
        }
        else if ( pzone->fSecureSecondaries == ZONE_SECSECURE_NS_ONLY )
        {
            if ( ! checkIfIpIsZoneNameServer(
                        pzone,
                        pMsg->RemoteAddress.sin_addr.s_addr ) )
            {
                STAT_INC( MasterStats.RefuseSecurity );
                goto Refused;
            }
        }
        else    // secondary list
        {
            ASSERT( pzone->fSecureSecondaries == ZONE_SECSECURE_LIST_ONLY );

            if ( ! DnsIsAddressInIpArray(
                        pzone->aipSecondaries,
                        pMsg->RemoteAddress.sin_addr.s_addr ) )
            {
                STAT_INC( MasterStats.RefuseSecurity );
                goto Refused;
            }
        }
    }

    //
    //  AXFR
    //      - must be TCP
    //      - limit full AXFR on update zones
    //      - determine transfer format
    //

    if ( pMsg->wQuestionType == DNS_TYPE_AXFR )
    {
        STAT_INC( MasterStats.AxfrRequest );
        PERF_INC ( pcAxfrRequestReceived );          //Perf hook

        //  full zone transfer MUST be TCP

        if ( ! pMsg->fTcp )
        {
            PVOID   parg = (PVOID) (ULONG_PTR) pMsg->RemoteAddress.sin_addr.s_addr;

            DNS_LOG_EVENT(
                DNS_EVENT_UDP_ZONE_TRANSFER,
                1,
                & parg,
                EVENTARG_ALL_IP_ADDRESS,
                0 );

            DNS_DEBUG( ANY, (
                "Received UDP Zone Transfer request from %s.\n",
                inet_ntoa( pMsg->RemoteAddress.sin_addr )
                ));

            STAT_INC( MasterStats.FormError );
            Reject_RequestIntact( pMsg, DNS_RCODE_FORMAT_ERROR, 0 );
            return;
        }

        //
        //  for update zones, avoid full transfers all the time
        //      - if inside of choke interval
        //      - limit transfers to no more than 1/10 of total time
        //
        //  DEVNOTE: may want to apply this to IXFR also that needs full XFR

        if ( pzone->fAllowUpdate
                &&  IS_ZONE_PRIMARY(pzone)
                &&  DNS_TIME() < pzone->dwNextTransferTime )
        {
            DNS_DEBUG( AXFR, (
                "WARNING:  Refusing AXFR of %S from %s due to AXFR choke interval.\n"
                "\tchoke interval ends  = %d\n",
                pzone->pwsZoneName,
                inet_ntoa( pMsg->RemoteAddress.sin_addr ),
                pzone->dwNextTransferTime ));

            STAT_INC( MasterStats.AxfrLimit );
            goto Refused;
        }

        //
        //  check if MS secondary
        //      - length two bytes longer than necessary
        //      - two bytes are FAST AXFR tag
        //
        //  otherwise, AXFR format from global flag

        if ( (INT)(pMsg->MessageLength - sizeof(WORD)) == DNSMSG_CURRENT_OFFSET(pMsg)
                &&
            *(UNALIGNED WORD *) pMsg->pCurrent == (WORD)DNS_FAST_AXFR_TAG )
        {
            XFR_BIND_CLIENT(pMsg) = FALSE;
            XFR_MS_CLIENT(pMsg) = TRUE;
        }
        else
        {
            XFR_BIND_CLIENT(pMsg) = (BOOLEAN) SrvCfg_fBindSecondaries;
            XFR_MS_CLIENT(pMsg) = FALSE;
        }
    }

    //
    //  IXFR
    //      - allows either TCP or UDP
    //      - pull out secondary's version
    //      - determine if MS secondary

    else
    {
        DNS_STATUS  status;

        ASSERT( pMsg->wQuestionType == DNS_TYPE_IXFR );

        status = parseIxfrClientRequest(pMsg);
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( status == DNS_ERROR_RCODE_FORMAT_ERROR );

            STAT_INC( MasterStats.FormError );

            Reject_RequestIntact(
                pMsg,
                DNS_RCODE_FORMAT_ERROR,
                0 );
            return;
        }
    }

    //
    //  lock for transfer
    //
    //  this locks out admin updates, and additional transfers
    //
    //  note:  if switch to locking with CS held during transfer
    //          then test should move to recv thread
    //

    if ( ! Zone_LockForXfrSend( pzone ) )
    {
        DNS_PRINT((
            "Zone %S, locked -- unable to transfer.\n",
            pzone->pwsZoneName ));
        STAT_INC( MasterStats.RefuseZoneLocked );
        goto Refused;
    }

    //
    //  prepare message for transfer
    //      - do this rather than in transfer thread so can include
    //      UDP zone transfer
    //
    //  leave question in buffer
    //
    //  use offset to zone name to compress records in buffer, do NOT
    //  write offsets of names -- would just fill compression buffer
    //
    //  note default TCP buffer is 16K which is maximum size of compression
    //  so this is the most efficient transfer siz
    //

    ASSERT( pMsg->Head.QuestionCount == 1 );

    pMsg->Head.IsResponse = TRUE;

    pMsg->pNodeQuestion = pzone->pZoneRoot;

    Name_SaveCompressionWithNode( pMsg, pMsg->MessageBody, pzone->pZoneRoot );

    pMsg->fNoCompressionWrite = TRUE;

    //  no additional records processing

    pMsg->fDoAdditional = FALSE;

    //  clear IXFR authority (if any)

    pMsg->Head.AnswerCount = 0;
    pMsg->Head.NameServerCount = 0;
    pMsg->Head.AdditionalCount = 0;
    SET_TO_WRITE_ANSWER_RECORDS(pMsg);

    //
    //  UDP IXFR?
    //      - note must free message, sendIxfrResponse never frees

    if ( !pMsg->fTcp )
    {
        ASSERT( pMsg->wQuestionType == DNS_TYPE_IXFR );
        STAT_INC( MasterStats.IxfrUdpRequest );
        sendIxfrResponse( pMsg );
        Zone_UnlockAfterXfrSend( pzone );
        Packet_FreeUdpMessage( pMsg );
        return;
    }

    //
    //  DEVNOTE: cut AXFR socket from connection list
    //      or need to lengthen timeout substaintially
    //      or make sure it is touched repeatedly

    //
    //  DEVNOTE: someway to reel AXFR thread back in if hangs
    //
    //      one way is connection list timeout
    //      BUT need to be careful
    //          - new messages on connection not a problem
    //
    //          - possiblity that client sends another AXFR???, if takes
    //          a while to get going
    //
    //          - could set some sort of disable flag on connection
    //

    //
    //  spawn zone transfer thread
    //

    hThread = Thread_Create(
                    "Zone Transfer Send",
                    zoneTransferSendThread,
                    (PVOID) pMsg,
                    0 );
    if ( !hThread )
    {
        //  release zone lock

        Zone_UnlockAfterXfrSend( pzone );

        DNS_DEBUG( ZONEXFR, (
            "ERROR:  unable to create thread to send zone %S\n"
            "\tto %s.\n",
            pzone->pwsZoneName,
            inet_ntoa( pMsg->RemoteAddress.sin_addr )
            ));
        STAT_INC( MasterStats.RefuseServerFailure );
        goto Refused;
    }
    return;

Refused:

    STAT_INC( MasterStats.Refused );
    Reject_RequestIntact(
        pMsg,
        DNS_RCODE_REFUSED,
        0 );
    return;
}



DWORD
zoneTransferSendThread(
    IN      LPVOID  pvMsg
    )
/*++

Routine Description:

    Zone transfer reception thread routine.

Arguments:

    pvMsg - ptr to message requesting zone transfer

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    PDNS_MSGINFO    pMsg = (PDNS_MSGINFO) pvMsg;
    PDB_NODE        pnode;
    PZONE_INFO      pzone;
    DWORD           nonBlocking;
    DWORD           startTime;
    PVOID           argArray[2];            // for logging
    BYTE            argTypeArray[2];


    //  recover zone and zone root

    pzone = pMsg->pzoneCurrent;
    pnode = pzone->pZoneRoot;

    ASSERT( IS_ZONE_LOCKED_FOR_READ(pzone) );

    //  set zone transfer logging params
    //      - only log start for debug builds

    argArray[0] = pzone->pwsZoneName;
    argArray[1] = inet_ntoa( pMsg->RemoteAddress.sin_addr );

    argTypeArray[0] = EVENTARG_UNICODE;
    argTypeArray[1] = EVENTARG_UTF8;

    //
    //  set socket BLOCKING
    //
    //  this allows us to send freely, without worrying about
    //  WSAEWOULDBLOCK return
    //

    nonBlocking = FALSE;
    nonBlocking = ioctlsocket( pMsg->Socket, FIONBIO, &nonBlocking );
    if ( nonBlocking != 0 )
    {
        DWORD   err = WSAGetLastError();
        DNS_PRINT((
            "ERROR:  Unable to set socket %d to non-blocking to send"
            " zone transfer.\n"
            "\terr = %d\n",
            pMsg->Socket,
            err ));
        //
        // Failure path:
        // It is possible that the connection blob was timed out & the
        // socket closed if, for instance, it took us long time to
        // lock the zone. Then, this op would fail w/ invalid socket.
        // Thus, we don't need to assert here.
        // NOTE: if we could, the proper solution would be to prevent
        // the connection blob from ever timing out, yet ensuring that
        // any code path will clean it up.
        //
        // ASSERT( FALSE );

        goto TransferFailed;
    }

    //
    //  IXFR
    //      - if requires full AXFR, then fall through to AXFR
    //      - note must free message, sendIxfrResponse never frees
    //

    if ( pMsg->wQuestionType == DNS_TYPE_IXFR )
    {
        DNS_STATUS  status;

        status = sendIxfrResponse( pMsg );
        if ( status != DNSSRV_STATUS_NEED_AXFR )
        {
            goto Cleanup;
        }
        DNS_DEBUG( XFR, (
            "Need full AXFR on IXFR request in packet %p\n",
            pMsg ));
    }

    IF_DEBUG( ANY )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_ZONEXFR_START,
            2,
            argArray,
            argTypeArray,
            0 );
    }
    startTime = DNS_TIME();

    DNS_DEBUG( ZONEXFR, (
        "Initiating zone transfer of zone %S"
        "\tto DNS server at %s.\n"
        "\tstart time   = %d\n"
        "\tBIND flag    = %d\n",
        argArray[0],
        argArray[1],
        startTime,
        XFR_BIND_CLIENT(pMsg)
        ));

    //
    //  send zone root
    //      - SOA record first
    //      - rest of zone root node's records
    //

    if ( ! writeZoneNodeToMessage(
                pMsg,
                pnode,
                DNS_TYPE_SOA,       // SOA record only
                0 ) )               // no excluded type
    {
        goto TransferFailed;
    }

#if 0
    //  failed attempt to separate WINS from RR list
    //  enforce these conditions in BIND\non-BIND write routines below

    //
    //  WINS record?
    //  include if
    //      - to MS server
    //      - WINS exists
    //      - WINS is non-LOCAL
    //
    //  note, no can just write to message without send wrapping, as
    //  message buffer is always big enough for SOA + WINS
    //

    if ( XFR_MS_CLIENT(pMsg)  &&  pzone->pXfrWinsRR )
    {
        if ( ! Wire_AddResourceRecordToMessage(
                        pMsg,
                        pnode,
                        DNSMSG_QUESTION_NAME_OFFSET,
                        pzone->pXfrWinsRR,
                        0 ) )
        {
            goto TransferFailed;
        }
    }
#endif

    if ( ! writeZoneNodeToMessage(
                pMsg,
                pnode,
                DNS_TYPE_ALL,      //  all except
                DNS_TYPE_SOA       //  exclude SOA
                ) )
    {
        goto TransferFailed;
    }

    //
    //  transfer all RR for other nodes in zone
    //
    //      - send offset to question name for zone name
    //      - set flag to indicate this is top of zone
    //

    if ( pnode->pChildren )
    {
        PDB_NODE pchild = NTree_FirstChild( pnode );

        while ( pchild )
        {
            if ( ! traverseZoneAndTransferRecords(
                        pchild,
                        pMsg ) )
            {
                goto TransferFailed;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }

    //
    //  send zone SOA to mark end of transfer
    //

    if ( ! writeZoneNodeToMessage(
                pMsg,
                pnode,
                DNS_TYPE_SOA,       // SOA record only
                0 ) )               // no excluded type
    {
        goto TransferFailed;
    }

    //
    //  send any remaining messages
    //

    if ( pMsg->Head.AnswerCount )
    {
        if ( Send_ResponseAndReset(pMsg) != ERROR_SUCCESS )
        {
            goto TransferFailed;
        }
    }
    STAT_INC( MasterStats.AxfrSuccess );
    PERF_INC( pcAxfrSuccessSent );           // PerfMon hook
    PERF_INC( pcZoneTransferSuccess );       // PerfMon hook

    DNS_LOG_EVENT(
        DNS_EVENT_ZONEXFR_SUCCESSFUL,
        2,
        argArray,
        argTypeArray,
        0 );

    //
    //  reset zone info after transfer
    //      - move new updates to new version
    //      - if dynamic update, choke zone transfers
    //

    if ( IS_ZONE_PRIMARY(pzone) )
    {
        Zone_UpdateInfoAfterPrimaryTransfer( pzone, startTime );
    }
    goto Cleanup;

TransferFailed:

    //
    //  transfer failed, usually because secondary aborted
    //

    STAT_INC( MasterStats.Failure );
    PERF_INC( pcZoneTransferFailure );       // PerfMon hook

    DNS_LOG_EVENT(
        DNS_EVENT_ZONEXFR_ABORTED,
        2,
        argArray,
        argTypeArray,
        0 );

Cleanup:

    //
    //  cleanup
    //      - free message
    //      - release read lock on zone
    //      - if necessary push current serial back to DS
    //      - clear this thread from global array
    //

    Packet_FreeTcpMessage( pMsg );

    pzone->dwLastXfrSerialNo = pzone->dwSerialNo;

    Zone_UnlockAfterXfrSend( pzone );

    if ( pzone->fDsIntegrated )
    {
        Ds_CheckForAndForceSerialWrite(
            pzone,
            ZONE_SERIAL_SYNC_XFR );
    }

    Thread_Close( FALSE );
    return( 0 );
}



BOOL
writeZoneNodeToMessageForBind(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wRRType,
    IN      WORD            wExcludeRRType
    )
/*++

Routine Description:

    Write RR at node to packet and send.

    This implementation is specifically for sending to BIND secondaries.
    BIND chokes when it gets more than one RR in the packet.

    The correct implementation, making full use of the message concept,
    is below.

Arguments:

    pMsg -- ptr to message info for zone transfer

    pNode -- ptr to node to write

    wRRType -- RR type

    wExcludeRRType -- excluded RR type, send all but this type

Return Value:

    TRUE if successful.
    FALSE if error.

--*/
{
    PDB_RECORD      prr;

    DNS_DEBUG( ZONEXFR, (
        "Writing AXFR node with label %s for send to BIND.\n",
        pNode->szLabel ));

    //
    //  write all RR in node to packet
    //
    //  note we do NOT hold lock during send(), in case pipe backs up
    //  (this should not be necessary as this is a non-blocking socket, but
    //  the winsock folks seem to have broken this)
    //  hence we must drop and reacquire lock and always find NEXT record based
    //  on previous
    //

    LOCK_RR_LIST(pNode);
    prr = NULL;

    while( prr = RR_FindNextRecord(
                    pNode,
                    wRRType,
                    prr,
                    0 ) )
    {
        //  do not transfer and cached data or root hints

        if ( IS_CACHE_RR(prr) || IS_ROOT_HINT_RR(prr) )
        {
            continue;
        }

        //  if excluding a type, check here
        //
        //  since WINS\WINSR only at zone root, and we are excluding SOA at root
        //      enforce WINS prohbition right here (to save a few instructions)
        //

        if ( wExcludeRRType )
        {
            if ( prr->wType == wExcludeRRType )
            {
                continue;
            }
            if ( IS_WINS_TYPE( prr->wType ) )
            {
                ASSERT( ! (prr->Data.WINS.dwMappingFlag & DNS_WINS_FLAG_LOCAL) );
                continue;
            }
        }

        //  no WINS record should ever get transferred to BIND

        ASSERT( !IS_WINS_TYPE(prr->wType) );

        //  add RR to packet

        if ( ! Wire_AddResourceRecordToMessage(
                    pMsg,
                    pNode,
                    0,
                    prr,
                    0 ) )
        {
            //
            //  some sort of error writing packet?
            //

            DNS_DEBUG( ANY, ( "ERROR writing RR to AXFR packet.\n" ));
            UNLOCK_RR_LIST(pNode);
            ASSERT( FALSE );
            return( FALSE );
        }

        UNLOCK_RR_LIST(pNode);
        pMsg->Head.AnswerCount++;

        //
        //  send the RR
        //

        if ( Send_ResponseAndReset(pMsg) != ERROR_SUCCESS )
        {
            DNS_DEBUG( ZONEXFR, (
                "ERROR sending zone transfer message at %p.\n",
                pMsg ));
            return( FALSE );
        }
        LOCK_RR_LIST(pNode);
    }

    //
    //  drops here on no more RRs
    //

    UNLOCK_RR_LIST(pNode);
    return( TRUE );
}



BOOL
writeZoneNodeToMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wRRType,
    IN      WORD            wExcludeRRType
    )
/*++

Routine Description:

    Write all RR in zone to packet.
    Send packet if, if full and start writing next packet.

Arguments:

    pMsg -- ptr to message info for zone transfer

    pNode -- ptr to node to write

    wRRType -- RR type

    wExcludeRRType -- excluded RR type, send all but this type

Return Value:

    TRUE if successful.
    FALSE if error.

--*/
{
    PDB_RECORD          prr;
    PDB_RECORD          prrPrevFailure = NULL;

    DNS_DEBUG( ZONEXFR, (
        "Writing AXFR node with label %s.\n"
        "\tpMsg             = %p\n"
        "\tpCurrent         = %p\n"
        "\tRR Type          = 0x%04hx\n"
        "\tExclude RR Type  = 0x%04hx\n",
        pNode->szLabel,
        (WORD) pMsg,
        (WORD) pMsg->pCurrent,
        (WORD) wRRType,
        (WORD) wExcludeRRType ));

    if ( IS_SELECT_NODE(pNode) )
    {
        return( TRUE );
    }

    //
    //  if transfer to old BIND secondary
    //

    if ( XFR_BIND_CLIENT(pMsg) )
    {
        return  writeZoneNodeToMessageForBind(
                    pMsg,
                    pNode,
                    wRRType,
                    wExcludeRRType );
    }

    //
    //  write all RR in node to packet
    //
    //      - start write using pNode and offset to zone name
    //
    //      - save position where node name will be written, so can
    //          use offset to it for rest of records in node
    //
    //  note we do NOT hold lock during send(), in case pipe backs up
    //  (this should not be necessary as this is a non-blocking socket, but
    //  the winsock folks seem to have broken this)
    //  hence we must drop and reacquire lock and always find NEXT record based
    //  on previous
    //

    prr = NULL;

    LOCK_RR_LIST(pNode);

    while( prr = RR_FindNextRecord(
                    pNode,
                    wRRType,
                    prr,
                    0 ) )
    {
        //  do not transfer and cached data or root hints

        if ( IS_CACHE_RR(prr) || IS_ROOT_HINT_RR(prr) )
        {
            continue;
        }

        //  if excluding a type, check here
        //  since WINS are at zone root, can optimize by doing
        //      LOCAL WINS exclusion here

        if ( wExcludeRRType )
        {
            if ( prr->wType == wExcludeRRType )
            {
                continue;
            }
            if ( IS_WINS_RR_AND_LOCAL( prr ) )
            {
                continue;
            }
        }

        //  LOCAL WINS should never hit the wire
        //
        //  note:  non-BIND is not necessarily MS, but assume that these folks
        //      running mixed servers are smart enough to set WINS to LOCAL to
        //      avoid writing to write
        //
        //  DEVNOTE: should have flag to indicate MS transfer OR
        //      fBindTransfer should become state flag
        //          0 -- bind
        //          1 -- fast
        //          2 -- MS
        //

        ASSERT( !IS_WINS_TYPE( prr->wType ) ||
                !(prr->Data.WINS.dwMappingFlag & DNS_WINS_FLAG_LOCAL) );

        //
        //  valid RR -- add to packet
        //
        //  first time through send
        //      - offsetForNodeName offset to zone root name
        //      - pNode to add this node's label
        //
        //  subsequent times through only send
        //      - offsetForNodeName now compressed name for node
        //      - NULL node ptr
        //  this writes ONLY compression bytes for name of RR
        //

        while ( ! Wire_AddResourceRecordToMessage(
                        pMsg,
                        pNode,
                        0,
                        prr,
                        0 ) )
        {
            DNS_DEBUG( ZONEXFR, (
                "Zone transfer msg %p full writing RR at %p.\n",
                pMsg,
                prr ));

            //
            //  packet is full
            //      - if UDP (or spinning), fail
            //      - if TCP, send it, reset for reuse
            //

            UNLOCK_RR_LIST(pNode);

            if ( !pMsg->fTcp )
            {
                DNS_DEBUG( ZONEXFR, (
                    "Filled UDP IXFR packet at %p.\n"
                    "\trequire TCP transfer.\n",
                    pMsg ));
                return( FALSE );
            }

            //  catch spinning on RR, by saving previous RR written

            if ( prr == prrPrevFailure )
            {
                DNS_DEBUG( ZONEXFR, (
                    "ERROR writing pRR at %p to AXFR msg %p.\n",
                    prr,
                    pMsg ));
                ASSERT( FALSE );
                return( FALSE );
            }
            prrPrevFailure = prr;

            //
            //  The wire-write routines probably set the TC bit but for AXFR
            //  we don't want that so clear it before send.
            //

            pMsg->Head.Truncation = FALSE;

            //  send and reset

            if ( Send_ResponseAndReset(pMsg) != ERROR_SUCCESS )
            {
                DNS_DEBUG( ZONEXFR, (
                    "ERROR sending zone transfer message at %p.\n",
                    pMsg ));
                return FALSE;
            }

            LOCK_RR_LIST(pNode);
        }

        //  wrote RR - inc answer count

        pMsg->Head.AnswerCount++;
    }

    //
    //  drops here on no more RRs
    //

    UNLOCK_RR_LIST(pNode);
    return( TRUE );
}



BOOL
traverseZoneAndTransferRecords(
    IN OUT  PDB_NODE        pNode,
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Send all RR in zone.

Arguments:

    pNode -- ptr to zone root node

    pMsg -- ptr to message info for zone transfer

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    DNS_DEBUG( ZONEXFR, (
        "Zone transfer for node with label %s.\n",
        pNode->szLabel ));

    //
    //  entering new zone?
    //
    //      - write NS records to delineate zone
    //      - write glue records so secondary can recurse or refer to
    //          sub-zone NS
    //      - stop recursion
    //

    if ( IS_ZONE_ROOT(pNode) )
    {
        PDB_NODE        pnodeNS;
        PDB_RECORD      prr;

        //
        //  write sub-zone NS records
        //

        if ( ! writeZoneNodeToMessage(
                    pMsg,
                    pNode,
                    DNS_TYPE_NS,
                    0 ) )               // no exclusion
        {
            return( FALSE );
        }

        //
        //  write glue records
        //      - get NS RR
        //      - outside zone, write its A records
        //
        //  lock RR list only while using NS RR
        //

        prr = NULL;
        LOCK_RR_LIST(pNode);

        while( prr = RR_FindNextRecord(
                        pNode,
                        DNS_TYPE_NS,
                        prr,
                        0 ) )
        {
            pnodeNS = Lookup_FindGlueNodeForDbaseName(
                            pMsg->pzoneCurrent,
                            & prr->Data.NS.nameTarget );
            if ( !pnodeNS )
            {
                continue;
            }
            if ( IS_AUTH_NODE(pnodeNS) )
            {
                // NS host within zone, no need for glue
                continue;
            }
            UNLOCK_RR_LIST(pNode);

            if ( ! writeZoneNodeToMessage(
                        pMsg,
                        pnodeNS,
                        DNS_TYPE_A,
                        0 ) )           // no exclusion
            {
                return( FALSE );
            }
            LOCK_RR_LIST(pNode);
        }
        UNLOCK_RR_LIST(pNode);
        return( TRUE );
    }

    //
    //  transfer all authoritative RRs for this node
    //
    //  write all RR in node to message
    //
    //  offsetForNodeName will have offset to name for this node
    //      or be zero causing next write to be FQDN
    //

    if ( ! writeZoneNodeToMessage(
                pMsg,
                pNode,
                DNS_TYPE_ALL,
                0 ) )           // no exclusion
    {
        return( FALSE );
    }

    //
    //  recursion, to handle child nodes
    //

    if ( pNode->pChildren )
    {
        PDB_NODE pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            if ( ! traverseZoneAndTransferRecords(
                        pchild,
                        pMsg ) )
            {
                return( FALSE );
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }
    return( TRUE );
}




//
//  IXFR routines
//

DNS_STATUS
writeStandardIxfrResponse(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PUPDATE         pUpdateStart,
    IN      DWORD           dwVersion
    )
/*++

Routine Description:

    Write version to IXFR response.

Arguments:

    pMsg -- ptr to message info for zone transfer

    pup -- ptr to first update for this version in update list

Return Value:

    Ptr to next update in update list -- if successful.
    NULL if last or error.

--*/
{
    PDB_RECORD  prr;
    PUPDATE     pup;
    BOOL        fadd;
    PDB_RECORD  psoaRR;
    DNS_STATUS  status;

    DNS_DEBUG( ZONEXFR, (
        "writeStandardIxfrResponse()\n"
        "\tpmsg = %p, version = %d, pupdate = %p\n",
        pMsg,
        dwVersion,
        pUpdateStart ));

    ASSERT( pUpdateStart );

    //  caller must free message

    pMsg->fDelete = FALSE;

    //
    //  write SOAs
    //      - current
    //      - client's current
    //
    //  save compression info when writing first SOA;  this saves the primary
    //  and admin data fields, allowing them to be compressed in later SOAs
    //  and we'll end up writing a bunch of them
    //
    //  DEVNOTE: must work out compression RESET on packet write for TCP
    //              then can turn compression back on
    //      - reset compression count back to zone count
    //      - allow compression write around SOA
    //          could do all the time, or just when compression count indicates
    //          it's the first SOA in packet (or explicit flag)
    //

    psoaRR = pMsg->pzoneCurrent->pSoaRR;

    status = Xfr_WriteZoneSoaWithVersion(
                pMsg,
                psoaRR,
                0 );

    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }
    status = Xfr_WriteZoneSoaWithVersion(
                pMsg,
                psoaRR,
                dwVersion );

    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  write all updates up to current version
    //
    //  this is done in two passes
    //      - deletes, followed by version SOA
    //      - adds, followed by version SOA
    //

    pup = pUpdateStart;
    fadd = FALSE;

    while ( 1 )
    {
        //
        //  loop through all updates for both add and delete passes
        //

        do
        {
            //
            //  add pass
            //      - write CURRENT version of record set
            //      - exclude SOA
            //      - attempt to suppress duplicate RR set writes
            //

            if ( fadd )
            {
                if ( !pup->wAddType )
                {
                    continue;
                }
                if ( Up_IsDuplicateAdd( NULL, pup, NULL ) )
                {
                    continue;
                }

                if ( ! writeZoneNodeToMessage(
                            pMsg,
                            pup->pNode,
                            pup->wAddType,      // add RR type
                            DNS_TYPE_SOA        // exclude SOA
                            ) )
                {
                    if ( !pMsg->fTcp )
                    {
                        return( DNSSRV_STATUS_NEED_TCP_XFR );
                    }
                    else
                    {
                        DNS_DEBUG( ANY, (
                            "Failed writing or sending IXFR add!\n"
                            "\tnode %p (%s) type %d\n"
                            "\tpMsg = %p.\n",
                            pup->pNode,
                            pup->pNode->szLabel,
                            pup->wAddType,
                            pMsg ));
                        return( DNS_RCODE_SERVER_FAILURE );
                    }
                }
            }

            //
            //  delete pass, write each deleted record
            //
            //      - do NOT write SOA as this obviously confuses the issue and
            //      latest SOA is always delivered
            //

            else
            {
                prr = pup->pDeleteRR;
                if ( !prr )
                {
                    continue;
                }

                do
                {
                    if ( prr->wType == DNS_TYPE_SOA )
                    {
                        continue;
                    }
                    status = writeXfrRecord(
                                    pMsg,
                                    pup->pNode,
                                    0,
                                    prr );

                    if ( status != ERROR_SUCCESS )
                    {
                        return( status );
                    }
                }
                while( prr = prr->pRRNext );

            }   // end delete pass
        }
        while( pup = pup->pNext );

        //
        //  write SOA to terminate add\delete section
        //      - zero serial to write current version
        //      - note write SOA function increments RR AnswerCount
        //

        status = Xfr_WriteZoneSoaWithVersion(
                    pMsg,
                    psoaRR,
                    0 );

        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }

        //
        //  end of delete pass => setup for add pass
        //  end of add pass => done
        //

        if ( !fadd )
        {
            fadd = TRUE;
            pup = pUpdateStart;
            continue;
        }
        break;
    }

    //
    //  send any remaining records
    //  note for TCP, XFR thread cleanup deletes message and closes connection
    //  note use Send_ResponseAndReset, instead of Send_Msg as
    //      Send_ResponseAndReset has WOULDBLOCK retry code for backed up
    //      connection
    //

    if ( pMsg->Head.AnswerCount )
    {
        Send_ResponseAndReset( pMsg );
    }

    //
    //  successful IXFR
    //

    DNS_DEBUG( ZONEXFR, (
        "Successful standard IXFR resposne to msg = %p.\n",
        pMsg ));

    return( ERROR_SUCCESS );
}



DNS_STATUS
sendIxfrResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Send IXFR response.

Arguments:

    pMsg -- ptr to message info for zone transfer

    Note:  caller must free the message.
           Event UDP sends not freed in this function.

Return Value:

    ERROR_SUCCESS if successful.
    DNSSRV_STATUS_NEED_AXFR if need full zone transfer

--*/
{
    PZONE_INFO  pzone = pMsg->pzoneCurrent;
    DWORD       version = IXFR_CLIENT_VERSION(pMsg);
    PUPDATE     pup;
    DNS_STATUS  status;

    ASSERT( !pMsg->fDoAdditional );
    ASSERT( IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) );

    DNS_DEBUG( ZONEXFR, (
        "Sending IXFR response for zone %s.\n"
        "\tclient version = %d\n",
        pzone->pszZoneName,
        version ));

    STAT_INC( MasterStats.IxfrRequest );
    PERF_INC ( pcIxfrRequestReceived );          //Perf hook

    ( pMsg->fTcp )
        ?   STAT_INC( MasterStats.IxfrTcpRequest )
        :   STAT_INC( MasterStats.IxfrUdpRequest );

    //
    //  caller frees message
    //
    //  because some TCP sends can fail over to AXFR and hence can not
    //  be freed on send, we take a simple approach here and do not
    //  free ANY packets on send;  caller, whether TCP or UDP must free
    //

    pMsg->fDelete = FALSE;

    //
    //  verify that this zone is up and functioning
    //

    if ( !pzone->pSoaRR || IS_ZONE_SHUTDOWN(pzone) )
    {
        Reject_RequestIntact( pMsg, DNS_RCODE_SERVER_FAILURE, 0 );
        return( ERROR_SUCCESS );
    }

    //
    //  verify that IXFR transfer possible
    //
    //  note:  updates contain version that they update the zone to
    //
    //  note can do incremental if first update in list is one more than
    //  client's version -- at a min, every update updates (version-1)
    //  important to include this case as if both primary and secondary
    //  start with a given version, first notify would happen with this case
    //

    pup = pzone->UpdateList.pListHead;

    if ( !pup || pup->dwVersion-1 > version || version >= pzone->dwSerialNo )
    {
        DNS_DEBUG( ZONEXFR, (
            "IXFR not possible for zone %s -- need full AXFR.\n"
            "\tcurrent version %d\n"
            "\tearliest version %d (zero indicates NO update list).\n"
            "\tclient version %d\n",
            pzone->pszZoneName,
            pzone->dwSerialNo,
            pup ? pup->dwVersion : 0,
            version ));
        goto NoVersion;
    }

    //
    //  find starting update
    //

    while ( pup && pup->dwVersion <= version )
    {
        pup = pup->pNext;
    }

    //  no starting update?

    if ( !pup )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  no update to get to requested IXFR version %d!\n"
            "\tand zone version does not match!\n",
            version,
            pzone->dwSerialNo ));
        // ASSERT( FALSE );
        goto NoVersion;
    }

    //
    //  write standard IXFR
    //

    status = writeStandardIxfrResponse(
                pMsg,
                pup,
                version );

    if ( status != ERROR_SUCCESS )
    {
        if ( status == DNSSRV_STATUS_NEED_TCP_XFR )
        {
            ASSERT( !pMsg->fTcp );
            STAT_INC( MasterStats.IxfrUdpForceTcp );
            goto NeedTcp;
        }

        //  can also fail, if pipe backs up

        if ( !pMsg->fTcp )
        {
            RESET_MESSAGE_TO_ORIGINAL_QUERY( pMsg );
            Reject_Request( pMsg, DNS_RCODE_SERVER_FAILURE, 0 );
        }
        return( status );
    }

    //
    //  DEVNOTE-LOG: some sort of success logging
    //      if not to eventlog, at least to log
    //

#if 0
    {
        DNS_LOG_EVENT(
            DNS_EVENT_ZONEXFR_SUCCESSFUL,
            2,
            pszArgs,
            NULL,
            0 );
    }
#endif

    DNS_DEBUG( ZONEXFR, (
        "Completed sendIxfrResponse for msg=%p, zone=%s from version=%d.\n",
        pMsg,
        pzone->pszZoneName,
        version ));

    //  track IXFR success and free UDP response message

    STAT_INC( MasterStats.IxfrUpdateSuccess );
    PERF_INC( pcIxfrSuccessSent );       // PerfMon hook
    PERF_INC( pcZoneTransferSuccess );   // PerfMon hook

    if ( pMsg->fTcp )
    {
        STAT_INC( MasterStats.IxfrTcpSuccess );
    }
    else
    {
        STAT_INC( MasterStats.IxfrUdpSuccess );
    }

    pzone->dwLastXfrSerialNo = pzone->dwSerialNo;

#if 0
    //  NOT forcing DS write here as we're in main worker thread
    //
    //  DEVNOTE: no forced DS write for UDP IXFR
    //
    //  check if need to write serial to DS

    if ( pzone->fDsIntegrated )
    {
        Ds_CheckForAndForceSerialWrite(
            pZone,
            ZONE_SERIAL_SYNC_XFR );
    }
#endif

    return( ERROR_SUCCESS );


NoVersion:

    //
    //  no version to do IXFR
    //      - if client at or above current version, then give single SOA response
    //          same a UDP "NeedTcp" case below
    //      - for UDP send "need full AXFR" packet, single SOA response
    //      - for TCP just return error, and calling function drops into
    //          full AXFR
    //

    STAT_INC( MasterStats.IxfrNoVersion );
    if ( version >= pzone->dwSerialNo )
    {
        goto NeedTcp;
    }
    if ( !pMsg->fTcp )
    {
        STAT_INC( MasterStats.IxfrUdpForceAxfr );
        goto NeedTcp;
    }
    STAT_INC( MasterStats.IxfrAxfr );
    return( DNSSRV_STATUS_NEED_AXFR );


NeedTcp:

    //
    //  send need-full-AXFR packet OR client at or above current version
    //      - reset to immediately after question
    //      - send single answer of current SOA version
    //

    ASSERT( !pMsg->fTcp || version>=pzone->dwSerialNo );

    RESET_MESSAGE_TO_ORIGINAL_QUERY( pMsg );

    status = Xfr_WriteZoneSoaWithVersion(
                pMsg,
                pzone->pSoaRR,
                0 );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ZONEXFR, (
            "ERROR:  unable to write need-AXFR msg %p.\n",
            pMsg ));

        //  unless really have names too big for packet -- can't get here
        ASSERT( FALSE );
        Reject_RequestIntact( pMsg, DNS_RCODE_FORMAT_ERROR, 0 );
        return( ERROR_SUCCESS );
    }
    Send_Msg( pMsg );
    return( ERROR_SUCCESS );
}



//
//  NS list utilities
//

BOOL
checkIfIpIsZoneNameServer(
    IN OUT  PZONE_INFO      pZone,
    IN      IP_ADDRESS      IpAddress
    )
/*++

Routine Description:

    Check if IP is a zone name server.

    Note, this means a remote NS, not a local machine address.

Arguments:

    pZone -- zone ptr, may be updated with new zone NS list

    IpAddress -- IP to check if remote NS

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    BOOL    bresult;

    DNS_DEBUG( XFR, (
        "checkIfIpIsZoneNameServer( %S, %s )\n",
        pZone->pwsZoneName,
        IP_STRING(IpAddress) ));

    //
    //  if have existing NS list, check if IP in it
    //
    //  idea here is save cycles, even if list not current the
    //  worst we do is allow access to some IP that at least used to
    //  be zone NS (since this server's boot)
    //

    if ( pZone->aipNameServers &&
         DnsIsAddressInIpArray(
            pZone->aipNameServers,
            IpAddress ) )
    {
        DNS_DEBUG( XFR, (
            "Found IP %s in existing zone (%S) NS list.\n",
            IP_STRING(IpAddress),
            pZone->pwsZoneName ));
        return( TRUE );
    }

    //
    //  IP not found, try rebuilding zone NS list
    //
    //  DEVNOTE: should have validity flag on NS list to skip rebuild
    //      skip rebuilding when list is relatively current
    //      and not suspected of being stale;
    //      still can live with this as this is NOT default option
    //

    buildZoneNsList( pZone );

    //  check again after rebuild

    if ( pZone->aipNameServers &&
         DnsIsAddressInIpArray(
            pZone->aipNameServers,
            IpAddress ) )
    {
        DNS_DEBUG( XFR, (
            "Found IP %s in zone (%S) NS list -- after rebuild.\n",
            IP_STRING(IpAddress),
            pZone->pwsZoneName ));
        return( TRUE );
    }

    DNS_DEBUG( XFR, (
        "IP %s NOT found in zone (%S) NS list.\n",
        IP_STRING( IpAddress ),
        pZone->pwsZoneName ));

    return( FALSE );
}



DNS_STATUS
buildZoneNsList(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Rebuild NS list for zone.

Arguments:

    pZone -- zone ptr

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_NODE        pnodeNS;
    PDB_NODE        pnodeHost;
    PDB_RECORD      prrNS;
    PDB_RECORD      prrAddress;
    DWORD           countNs = 0;
    DWORD           countNsIp = 0;
    IP_ADDRESS      ipNs;
    IP_ADDRESS      aipNS[ MAX_NAME_SERVERS ];
    PIP_ARRAY       pnameServerArray = NULL;
    DNS_STATUS      status = ERROR_SUCCESS;

    DNS_DEBUG( XFR, (
        "buildZoneNsList( %s ).\n"
        "\tNS Dirty = %d\n"
        "\tNS List  = %p\n",
        pZone->pwsZoneName,
        pZone->bNsDirty,
        pZone->aipNameServers ));

    //
    //  For stub zones we don't need to keep the NS list member current.
    //

    if ( IS_ZONE_STUB( pZone ) )
    {
        return ERROR_SUCCESS;
    }

    ASSERT( IS_ZONE_PRIMARY( pZone ) );
    ASSERT( !pZone->fAutoCreated );
    ASSERT( pZone->fSecureSecondaries == ZONE_SECSECURE_NS_ONLY ||
            pZone->fNotifyLevel == ZONE_NOTIFY_ALL_SECONDARIES );

    //
    //  if primary, we need to build list of all public name server
    //      addresses for sending NOTIFY packets
    //
    //  since just using for NOTIFY, just collect every address, no need
    //  to attempt anything fancy
    //
    //  DEVNOTE: building notify list for DS?
    //      could just limit notify to explicitly configured secondary servers
    //      ideally, save primary server IPs somewhere in DS to recognize
    //      those IPs, then don't build them
    //
    //  DEVNOTE: note:  won't find IPs until other zones loaded, so maybe
    //      on initial boot should just set "notify-not-built-yet" flag, and
    //      rebuild when everyone up
    //      note:  this problem is especially prevalent on reverse lookup zones
    //      which load before forward lookup that contain A records for servers
    //

    //
    //  loop through all name servers
    //

    prrNS = NULL;

    while( countNsIp < MAX_NAME_SERVERS
            &&
        ( prrNS = RR_FindNextRecord(
                        pZone->pZoneRoot,
                        DNS_TYPE_NS,
                        prrNS,
                        0 ) ) )
    {
        countNs++;

#if 0
        //  screen out this server
        //
        //  DEVNOTE: screen local from NS list
        //

        if ( 0 )
        {
            continue;
        }
#endif

        pnodeNS = Lookup_NsHostNode(
                        &prrNS->Data.NS.nameTarget,
                        0,          // take best\any data
                        pZone,      // use OUTSIDE zone glue if necessary
                        NULL        // don't care about delegation
                        );
        if ( !pnodeNS )
        {
            DNS_DEBUG( UPDATE, (
                "No host node found for zone NS\n" ));
            continue;
        }

        //
        //  get all address records for name server
        //  however, don't include addresses for THIS server, as
        //      there is no point in NOTIFYing ourselves
        //

        prrAddress = NULL;

        while( countNsIp < MAX_NAME_SERVERS
                &&
            ( prrAddress = RR_FindNextRecord(
                                pnodeNS,
                                DNS_TYPE_A,
                                prrAddress,
                                0 ) ) )
        {
            ipNs = prrAddress->Data.A.ipAddress;
            if ( DnsIsAddressInIpArray(
                        g_ServerAddrs,
                        ipNs ) )
            {
                break;
            }
            aipNS[ countNsIp++ ] = ipNs;
        }
    }

    //  we goofed if this static array isn't sufficient

    ASSERT( countNsIp < MAX_NAME_SERVERS );

    //
    //  should have some NS records to even be a zone
    //  however the 0, 127 and 255 reverse lookup zones may not
    //      as they are not primary on all servers, and hence aren't
    //      referred to so don't need to give out NS records
    //
    //  note:  may NOT insist on finding NS A records
    //      many zones (e.g. all reverse lookup)
    //      won't contain NS host A records within zone, and
    //      those records may not be loaded when this call made
    //      in fact we may NEVER have those authoritative records
    //      on this server
    //

    if ( !countNs )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Zone %s has no NS records.\n",
            pZone->pszZoneName ));
        status = DNS_ERROR_ZONE_HAS_NO_NS_RECORDS;
    }

    //
    //  create NS address array and attach to zone info
    //

    if ( countNsIp )
    {
        pnameServerArray = DnsBuildIpArray(
                                countNsIp,
                                aipNS );
        IF_NOMEM( ! pnameServerArray )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
    }

    //  DEVNOTE: with delayed free, i'm not sure this level of lock is
    //      required;  obviously two folks shouldn't timeout free
    //      but zone's update lock covering this whole blob should
    //      take care of that

    Zone_UpdateLock( pZone );

    Timeout_Free( pZone->aipNameServers );
    pZone->aipNameServers = pnameServerArray;
    CLEAR_ZONE_NS_DIRTY(pZone);

    Zone_UpdateUnlock( pZone );

Done:

    return( status );
}


//
//  End of zonepri.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\wins.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    wins.h

Abstract:

    Domain Name System (DNS) Server

    Definitions for WINS lookup.

Author:

    Jim Gilroy (jamesg)     August 2, 1995

Revision History:

--*/


#ifndef _DNS_WINS_INCLUDED_
#define _DNS_WINS_INCLUDED_


//
//  WINS definitions
//

#define WINS_REQUEST_PORT           (137)

#define NETBIOS_TYPE_GENERAL_NAME_SERVICE   (0x2000)    // 32
#define NETBIOS_TYPE_NODE_STATUS            (0x2100)    // 33

#define NETBIOS_ASCII_NAME_LENGTH   (16)
#define NETBIOS_PACKET_NAME_LENGTH  (32)

#define NETBIOS_WORKSTATION_BYTE    (0)
#define NETBIOS_SERVER_BYTE         (20)
#define BLANK_CHAR                  (' ')


#include <packon.h>


//
//  NetBIOS / WINS Name
//
//  If using scope, scope will start at NameEnd byte, and proceed in
//  standard length-byte followed by label format, until finally zero
//  termination byte.
//

typedef struct _WINS_NAME
{
    //  Name

    UCHAR   NameLength;
    BYTE    Name[ NETBIOS_PACKET_NAME_LENGTH ];   // 32 byte netBIOS name
    UCHAR   NameEndByte;

} WINS_NAME, *PWINS_NAME;

//
//  NetBIOS / WINS Question
//
//  This is valid for either WINS or NBT reverse adapter status lookup.
//

typedef struct _WINS_QUESTION
{
    WORD    QuestionType;
    WORD    QuestionClass;
}
WINS_QUESTION, *PWINS_QUESTION,
NBSTAT_QUESTION, *PNBSTAT_QUESTION;


//
//  NetBIOS / WINS Request
//
//  Use this as template for WINS lookup.
//

typedef struct _WINS_REQUEST_MESSAGE
{
    DNS_HEADER      Header;
    WINS_NAME       Name;
    WINS_QUESTION   Question;
}
WINS_REQUEST_MSG, *PWINS_REQUEST_MSG,
NBSTAT_REQUEST_MSG, *PNBSTAT_REQUEST_MSG;

#define SIZEOF_WINS_REQUEST     (sizeof(WINS_REQUEST_MSG))


//
//  WINS IP Address Resource Record Data
//
//  Flags presented in byte flipped order, so do NOT flip field
//  when doing compare.  Note our compiler works from low to high
//  bits in byte.
//

typedef struct _WINS_RR_DATA
{
    WORD        Reserved1   : 5;
    WORD        NodeType    : 2;    // bits 2+3 form group name
    WORD        GroupName   : 1;    // high bit set if group name
    WORD        Reserved2   : 8;
    IP_ADDRESS  IpAddress;

} WINS_RR_DATA, *PWINS_RR_DATA;

//
//  WINS IP Address Resource Record
//

typedef struct _WINS_RESOURCE_RECORD
{
    //  Resource record

    WORD    RecordType;
    WORD    RecordClass;
    DWORD   TimeToLive;
    WORD    ResourceDataLength;

    //  Data

    WINS_RR_DATA    aRData[1];

} WINS_RESOURCE_RECORD, *PWINS_RESOURCE_RECORD;


//
//  NetBIOS node status Resource Record Data
//
//  Each name in adapter status response has this format.
//

#include <packon.h>

typedef struct _NBSTAT_RR_DATA
{
    CHAR    achName[ NETBIOS_ASCII_NAME_LENGTH ];

    //  name flags

    WORD    Permanent       : 1;
    WORD    Active          : 1;
    WORD    Conflict        : 1;
    WORD    Deregistering   : 1;
    WORD    NodeType        : 2;
    WORD    Unique          : 1;
    WORD    Reserved        : 9;

} NBSTAT_RR_DATA, *PNBSTAT_RR_DATA;


//
//  NetBIOS node status Resource Record
//
//  Response to adapter status query has this format.
//

typedef struct _NBSTAT_RECORD
{
    //  Resource record

    WORD    RecordType;
    WORD    RecordClass;
    DWORD   TimeToLive;
    WORD    ResourceDataLength;

    //  Data

    UCHAR           NameCount;
    NBSTAT_RR_DATA  aRData[1];

    //  Statistics follow, but are not of interest.

} NBSTAT_RECORD, *PNBSTAT_RECORD;

#include <packoff.h>


//
//  Max name length can lookup in WINS
//

#define MAX_WINS_NAME_LENGTH    (15)

//
//  WINS globals
//

extern  PPACKET_QUEUE   g_pWinsQueue;

#define WINS_DEFAULT_LOOKUP_TIMEOUT     (1)     // move on after 1 second

//
//  NBSTAT globals
//

extern  BOOL            gbNbstatInitialized;
extern  PPACKET_QUEUE   pNbstatQueue;

#define NBSTAT_DEFAULT_LOOKUP_TIMEOUT     (5)   // give up after 5 seconds

//
//  Wins TTL
//
//  Cache lookups for 10 minutes.
//  Although machines can always release / renew more or less instananeously.
//  this is a pretty good estimate of time for a normal activity that would
//  change an address:
//      - replacing a net card
//      - moving machine to another network and rebooting
//

#define WINS_DEFAULT_TTL    (600)   // 10 minutes

//
//  WINS request templates
//
//  Keep template of standard WINS request and copy it and
//  overwrite name to make actual request.
//
//  Keep a copy of NetBIOS node status request and use it
//  each time.  Only the address we send to changes.
//

extern  BYTE    achWinsRequestTemplate[ SIZEOF_WINS_REQUEST ];

extern  BYTE    achNbstatRequestTemplate[ SIZEOF_WINS_REQUEST ];


//
//  WINS target sockaddr
//
//  Keep sockaddr for sending to WINS server.  On sends, copy it
//  and write in desired address.

struct sockaddr saWinsSockaddrTemplate;


//
//  WINS startup / cleanup functions (wins.c)
//

BOOL
Wins_Initialize(
    VOID
    );

VOID
Wins_Shutdown(
    VOID
    );

VOID
Wins_Cleanup(
    VOID
    );


//
//  WINS recv (winsrecv.c)
//


VOID
Wins_ProcessResponse(
    IN OUT  PDNS_MSGINFO    pQuery
    );

//
//  WINS Lookup (winslook.c)
//

BOOL
FASTCALL
Wins_MakeWinsRequest(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PZONE_INFO      pZone,
    IN      WORD            wOffsetName,
    IN      PDB_NODE        pnodeLookup
    );

VOID
Wins_ProcessTimedOutWinsQuery(
    IN OUT  PDNS_MSGINFO    pQuery
    );

//
//  Nbstat functions (nbstat.c)
//

VOID
Nbstat_StartupInitialize(
    VOID
    );

BOOL
Nbstat_Initialize(
    VOID
    );

VOID
Nbstat_Shutdown(
    VOID
    );

BOOL
FASTCALL
Nbstat_MakeRequest(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PZONE_INFO      pZone
    );

VOID
Nbstat_WriteDerivedStats(
    VOID
    );


//
//  WINS\WINSR installation in zone
//

DNS_STATUS
Wins_RecordCheck(
    IN OUT  PZONE_INFO      pZone,
    IN      PDB_NODE        pNodeOwner,
    IN OUT  PDB_RECORD      pRR
    );

VOID
Wins_StopZoneWinsLookup(
    IN OUT  PZONE_INFO      pZone
    );

VOID
Wins_ResetZoneWinsLookup(
    IN OUT  PZONE_INFO      pZone
    );

#endif // _DNS_WINS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\zonelist.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    zonelist.c

Abstract:

    Domain Name System (DNS) Server

    Zone list routines.

Author:

    Jim Gilroy (jamesg)     July 3, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Zone list globals
//
//  Zones kept in sorted (alphabetical) double linked list.
//  Forward through the list corresponds to higher alphabetical
//  entry.
//

LIST_ENTRY  listheadZone;

DWORD   g_ZoneCount;

CRITICAL_SECTION    csZoneList;



BOOL
Zone_ListInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize the DNS zonelist.

Arguments:

    None.

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    g_ZoneCount = 0;

    InitializeListHead( (PLIST_ENTRY)&listheadZone );

    InitializeCriticalSection( &csZoneList );

    return( TRUE );
}



VOID
Zone_ListShutdown(
    VOID
    )
/*++

Routine Description:

    Cleanup zone list for restart.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DeleteCriticalSection( &csZoneList );
}



VOID
Zone_ListInsertZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Insert zone in list

Arguments:

    pZone -- ptr to zone to insert

Return Value:

    None.

--*/
{
    PZONE_INFO  pZoneNext;

    ASSERT( pZone->pszZoneName );

    //
    //  keep zones alphabetized to aid admin tool
    //      - forward through list is higher alpha value
    //      - keeps cache or root at front
    //

    EnterCriticalSection( &csZoneList );
    pZoneNext = NULL;

    while ( 1 )
    {
        pZoneNext = Zone_ListGetNextZoneEx( pZoneNext, TRUE );
        if ( ! pZoneNext )
        {
            pZoneNext = (PZONE_INFO)&listheadZone;
            break;
        }
        if ( 0 > wcsicmp_ThatWorks( pZone->pwsZoneName, pZoneNext->pwsZoneName) )
        {
            break;
        }
    }

    InsertTailList( (PLIST_ENTRY)pZoneNext, (PLIST_ENTRY)pZone );
    g_ZoneCount++;

    LeaveCriticalSection( &csZoneList );

    IF_DEBUG( OFF )
    {
        Dbg_ZoneList( "Zone list after insert.\n" );
    }
}



VOID
Zone_ListRemoveZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Remove zone from zone list

Arguments:

    pZone -- ptr to zone to remove from list

Return Value:

    None.

--*/
{
    PZONE_INFO  pzoneCurrent;

    //
    //  walk zone list, until match zone
    //

    EnterCriticalSection( &csZoneList );
    pzoneCurrent = NULL;

    while ( pzoneCurrent = Zone_ListGetNextZone(pzoneCurrent) )
    {
        if ( pzoneCurrent == pZone )
        {
            RemoveEntryList( (PLIST_ENTRY)pZone );
            g_ZoneCount--;
            ASSERT( (INT)g_ZoneCount >= 0 );
            break;
        }
    }
    ASSERT( pzoneCurrent == pZone );
    LeaveCriticalSection( &csZoneList );
}



PZONE_INFO
Zone_ListGetNextZoneEx(
    IN      PZONE_INFO      pZone,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Get next zone in zone list.

    This function allows simple walk of zone list.

Arguments:

    pZone - current zone in list, or NULL to start at beggining of list

    fAlreadyLocked - pass TRUE if the caller already owns the 
                     csZoneList critical section

Return Value:

    Ptr to next zone in list.
    NULL when reach end of zone list.

--*/
{
    //  if no zone specified, start at begining of list?

    if ( !pZone )
    {
        pZone = (PZONE_INFO) &listheadZone;
    }

    //  get next zone

    if ( !fAlreadyLocked )
    {
        EnterCriticalSection( &csZoneList );
    }

    pZone = (PZONE_INFO) pZone->ListEntry.Flink;

    if ( !fAlreadyLocked )
    {
        LeaveCriticalSection( &csZoneList );
    }

    //  return NULL at end of list

    if ( pZone == (PZONE_INFO)&listheadZone )
    {
        return( NULL );
    }
    return( pZone );
}



BOOL
Zone_DoesDsIntegratedZoneExist(
    VOID
    )
/*++

Routine Description:

    Determine if any DS integrated zones exist.

    Note, this does not include root-hints "zone".
    Since the purpose of the function is to determine if it is
    safe to revert to booting from file, a DS backed root-hints
    zone should not be blocking.  It can be converted separately.

Arguments:

    None

Return Value:

    TRUE is DS integrated zone exists.
    FALSE otherwise.

--*/
{
    PZONE_INFO  pzone;
    BOOL        haveDs = FALSE;

    //
    //  walk zone list, until find DS zone or reach end
    //

    EnterCriticalSection( &csZoneList );
    pzone = NULL;

    while ( pzone = Zone_ListGetNextZone(pzone) )
    {
        if ( pzone->fDsIntegrated && IS_ZONE_PRIMARY(pzone) )
        {
            haveDs = TRUE;
            break;
        }
    }
    LeaveCriticalSection( &csZoneList );
    return( haveDs );
}



VOID
Zone_ListMigrateZones(
    VOID
    )
/*++

Routine Description:

    This function should be called during zone creation to determine
    if the zones should be migrated from the under the CCS regkey to
    the Software regkey.

    This function is located in the zonelist module because it needs
    access to zonelist internals: ie. the current zone count and the
    critsec used to grab access to the zone list.

    Background: originally the DNS server stored all zone information
    under the CCS regkey, but CCS in the system hive, which has a
    hard limit of 16 MB. At 7000 or so zones you will hit this limit and
    render the server unbootable. So as a Service Pack fix, when the
    number of zones reaches an arbitrary number, we automagically
    migrate all zones in the registry from CCS to Software. The migration
    is not controllable by the administrator. It is also not reversible.

    For Whistler:  we take this a step further. If you create a zone 
    after server startup, we immediately migrate all zones to the
    SW key if they are currently in the CCS key. This will take care
    of upgrades from W2K to Whistler. Pure Whistler installs will start
    using the Software key from day one, and so will never migrate.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "Zone_ListMigrateZones" )

    PZONE_INFO  pZone = NULL;
    DNS_STATUS  rc;

    //
    //  Determine if a migration is necessary. Migration is not allowed 
    //  until all zones have been loaded out of the registry.
    //

    if ( g_ServerState != DNS_STATE_RUNNING ||
        Reg_GetZonesSource() == DNS_REGSOURCE_SW )
    {
        goto Done;
    }

    //
    //  Force write-back of all zones to the Software registry key
    //  and then delete zones from the CurrentControlSet key.
    //

    DNS_DEBUG( REGISTRY, (
        "%s: migrating zones from CurrentControlSet to Software\n", fn ));

    EnterCriticalSection( &csZoneList );

    Reg_SetZonesSource( DNS_REGSOURCE_SW );

    while ( pZone = Zone_ListGetNextZone( pZone ) )
    {
        rc = Zone_WriteZoneToRegistry( pZone );
        if ( rc != ERROR_SUCCESS )
        {
            DNS_DEBUG( REGISTRY, (
                "%s: error %d rewriting zone %s - aborting migration\n", fn,
                rc,
                pZone->pszZoneName ));

            //
            //  Clean up any zones copied into Software, and continue using
            //  the zones from CCS.
            //

            Reg_DeleteAllZones();
            Reg_SetZonesSource( DNS_REGSOURCE_CCS );
            goto Unlock;
        }
    }

    Reg_SetZonesSource( DNS_REGSOURCE_CCS );

    Reg_DeleteAllZones();

    Reg_SetZonesSource( DNS_REGSOURCE_SW );

    Reg_WriteZonesMovedMarker();

    //
    //  Cleanup and exit.
    //

    Unlock:

    LeaveCriticalSection( &csZoneList );

    Done:

    return;
}   //  Zone_ListMigrateZones



//
//  Multizone and Zone filtering technology
//
//  To allow multizone admin operations, we allow admin to send
//  dummy zone names:
//      "..AllZones"
//      "..AllPrimaryZones"
//      "..AllSecondaryZones"
//      etc.
//
//  These can then be mapped into a zone request filter, specifying
//  which properties a matching zone must have.


typedef struct _MultizoneEntry
{
    LPSTR       pszName;        // Multizone name (defined in dnsrpc.h)
    DWORD       Filter;
}
MULTIZONE;

MULTIZONE   MultiZoneTable[] =
{
    DNS_ZONE_ALL                        ,   ZONE_REQUEST_ALL_ZONES              ,
    DNS_ZONE_ALL_AND_CACHE              ,   ZONE_REQUEST_ALL_ZONES_AND_CACHE    ,

    DNS_ZONE_ALL_PRIMARY                ,   ZONE_REQUEST_PRIMARY                ,
    DNS_ZONE_ALL_SECONDARY              ,   ZONE_REQUEST_SECONDARY              ,

    DNS_ZONE_ALL_FORWARD                ,   ZONE_REQUEST_FORWARD                ,
    DNS_ZONE_ALL_REVERSE                ,   ZONE_REQUEST_REVERSE                ,

    DNS_ZONE_ALL_DS                     ,   ZONE_REQUEST_DS                     ,
    DNS_ZONE_ALL_NON_DS                 ,   ZONE_REQUEST_NON_DS                 ,

    //  a common combined properties

    DNS_ZONE_ALL_PRIMARY_REVERSE        ,   ZONE_REQUEST_REVERSE | ZONE_REQUEST_PRIMARY ,
    DNS_ZONE_ALL_PRIMARY_FORWARD        ,   ZONE_REQUEST_FORWARD | ZONE_REQUEST_PRIMARY ,

    DNS_ZONE_ALL_SECONDARY_REVERSE      ,   ZONE_REQUEST_REVERSE | ZONE_REQUEST_SECONDARY ,
    DNS_ZONE_ALL_SECONDARY_FORWARD      ,   ZONE_REQUEST_FORWARD | ZONE_REQUEST_SECONDARY ,

    NULL, 0,
};



DWORD
Zone_GetFilterForMultiZoneName(
    IN      LPSTR           pszZoneName
    )
/*++

Routine Description:

    Check and get multizone handle for zone name.

Arguments:

    pszZoneName -- zone name

Return Value:

    Ptr to dummy multizone handle.
    NULL if handle invalid.

--*/
{
    DWORD   nameLength;
    DWORD   i;
    LPSTR   pmultiName;

    //
    //  quickly eliminate non-multizones
    //

    nameLength = strlen( pszZoneName );

    if ( nameLength < 5 )
    {
        return( 0 );
    }
    if ( strncmp( "..All", pszZoneName, 5 ) != 0 )
    {
        return( 0 );
    }

    //
    //  have a multizone name
    //

    i = 0;

    while ( pmultiName = MultiZoneTable[i].pszName )
    {
        if ( strcmp( pmultiName, pszZoneName ) != 0 )
        {
            i++;
            continue;
        }

        DNS_DEBUG( RPC, (
            "Matched multizone %s to zone filter %p\n",
            pszZoneName,
            MultiZoneTable[i].Filter ));

        return( MultiZoneTable[i].Filter );
    }

    DNS_DEBUG( ANY, (
        "ERROR:  Multizone name <%s> was not in multizone table!\n",
        pszZoneName ));

    return( 0 );
}



PZONE_INFO
Zone_ListGetNextZoneMatchingFilter(
    IN      PZONE_INFO      pLastZone,
    IN      DWORD           dwFilter
    )
/*++

Routine Description:

    Get next zone matching filter.

Arguments:

    pLastZone -- previous zone ptr;  NULL to start enum

Return Value:

    Ptr to next zone matching filter.
    NULL when enum complete.

--*/
{
    PZONE_INFO  pzone = pLastZone;

    //
    //  walk zone list, until match zone
    //

    EnterCriticalSection( &csZoneList );

    while ( pzone = Zone_ListGetNextZone(pzone) )
    {

        //  otherwise do full filter match of zone

        if ( Zone_CheckZoneFilter( pzone, dwFilter ) )
        {
            break;
        }
    }

    LeaveCriticalSection( &csZoneList );
    return( pzone );
}



BOOL
FASTCALL
Zone_CheckZoneFilter(
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwFilter
    )
/*++

Routine Description:

    Check if zone passes filter.

Arguments:

    pZone -- zone to check

    dwFilter -- zone property filters from dnsrpc.h

Return Value:

    TRUE if zone passes through filter
    FALSE if zone screened out

--*/
{
    //
    //  optimize check for typical all zone cases
    //

    DNS_DEBUG( RPC, (
        "Zone_CheckZoneFilter: %08X ztype=%d %s\n",
        dwFilter,
        pZone->fZoneType,
        pZone->pszZoneName ));

    if ( dwFilter == ZONE_REQUEST_ALL_ZONES )
    {
        if ( !IS_ZONE_CACHE(pZone) )
        {
            return( TRUE );
        }
        else
        {
            return( FALSE );
        }
    }
    else if ( dwFilter == ZONE_REQUEST_ALL_ZONES_AND_CACHE )
    {
        return( TRUE );
    }

    //  catch bogus "no-filter" condition

    else if ( dwFilter == 0 )
    {
        DNS_DEBUG( RPC, (
            "ERROR:  filtering with no zone filter!\n" ));
        return( FALSE );
    }

    //
    //  note, for all filters, check for "none-selected" condition
    //      and treat this as "don't filter";
    //      this eliminates the need to always set flags for properties
    //      you don't care about AND preserves backward compatibility with
    //      old admin, when add new filter properties
    //

    //
    //  forward \ reverse filter
    //      - note:  Marco doesn't think cache is forward zone

    if ( dwFilter & ZONE_REQUEST_ANY_DIRECTION )
    {
        if ( IS_ZONE_REVERSE(pZone) )
        {
            if ( !(dwFilter & ZONE_REQUEST_REVERSE) )
            {
                return( FALSE );
            }
        }
        else
        {
            //  don't think we need this now with "none-selected" issue above
            //if ( !(dwFilter & ZONE_REQUEST_FORWARD) && !IS_ZONE_CACHE(pZone) )
            if ( !(dwFilter & ZONE_REQUEST_FORWARD) )
            {
                return( FALSE );
            }
        }
    }

    //
    //  type filter
    //

    if ( dwFilter & ZONE_REQUEST_ANY_TYPE )
    {
        if ( IS_ZONE_PRIMARY(pZone) )
        {
            if ( !(dwFilter & ZONE_REQUEST_PRIMARY) )
            {
                return( FALSE );
            }
        }
        else if ( IS_ZONE_STUB(pZone) )
        {
            //
            //  Stub test must go before secondary test because currently
            //  stub zones are also secondary zones.
            //

            if ( !(dwFilter & ZONE_REQUEST_STUB) )
            {
                return( FALSE );
            }
        }
        else if ( IS_ZONE_SECONDARY(pZone) )
        {
            if ( !(dwFilter & ZONE_REQUEST_SECONDARY) )
            {
                return( FALSE );
            }
        }
        else if ( IS_ZONE_FORWARDER(pZone) )
        {
            if ( !(dwFilter & ZONE_REQUEST_FORWARDER) )
            {
                return( FALSE );
            }
        }
        else
        {
            if ( !(dwFilter & ZONE_REQUEST_CACHE) )
            {
                return( FALSE );
            }
        }
    }

    //  auto-created filter

    if ( pZone->fAutoCreated && !(dwFilter & ZONE_REQUEST_AUTO) )
    {
        return( FALSE );
    }

    //
    //  DS \ non-DS filter
    //

    if ( dwFilter & ZONE_REQUEST_ANY_DATABASE )
    {
        if ( pZone->fDsIntegrated )
        {
            if ( !(dwFilter & ZONE_REQUEST_DS) )
            {
                return( FALSE );
            }
        }
        else    // non-DS
        {
            if ( !(dwFilter & ZONE_REQUEST_NON_DS) )
            {
                return( FALSE );
            }
        }
    }

    return( TRUE );
}

//
//  End of zonelist.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\zone.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    zone.c

Abstract:

    Domain Name System (DNS) Server

    Zone routines.

Author:

    Jim Gilroy (jamesg)     July 3, 1995

Revision History:

--*/


#include "dnssrv.h"

#include "ds.h"

//
//  Reverse zone auto-create
//
//  Requires special flag for fDsIntegrated, to indicate creating
//  primary zone which DOES NOT require database file.
//

#define NO_DATABASE_PRIMARY (0xf)

//
//  For zones taking dynamic updates, transfers need to be limited to
//      a reasonable time interval
//

#define AXFR_CHOKE_FACTOR           (10)    // choke so AXFR only 10% of time

#define MAX_AXFR_CHOKE_INTERVAL     (600)   // limit, but not more than 10 minutes


//
//  Private protos
//

VOID
Zone_SetSoaPrimaryToThisServer(
    IN      PZONE_INFO      pZone
    );

VOID
Zone_CheckAndFixDefaultRecordsOnLoad(
    IN      PZONE_INFO      pZone
    );

DNS_STATUS
Zone_CreateLocalHostPtrRecord(
    IN OUT  PZONE_INFO      pZone
    );

DNS_STATUS
setZoneName(
    IN OUT  PZONE_INFO      pZone,
    IN      LPCSTR          pszNewZoneName,
    IN      DWORD           dwNewZoneNameLen
    );



DNS_STATUS
Zone_Create(
    OUT     PZONE_INFO *                ppZone,
    IN      DWORD                       dwZoneType,
    IN      PCHAR                       pchZoneName,
    IN      DWORD                       cchZoneNameLen,     OPTIONAL
    IN      PIP_ARRAY                   aipMasters,
    IN      BOOL                        fDsIntegrated,
    IN      PDNS_DP_INFO                pDpInfo,            OPTIONAL
    IN      PCHAR                       pchFileName,        OPTIONAL
    IN      DWORD                       cchFileNameLen,     OPTIONAL
    IN      PZONE_TYPE_SPECIFIC_INFO    pTypeSpecificInfo,  OPTIONAL
    OUT     PZONE_INFO *                ppExistingZone      OPTIONAL
    )
/*++

Routine Description:

    Create zone information.

    Note:  leaves zone locked.  Caller must unlock after all
    other processing (e.g. Zone_Load()) is completed.

    If the zone cannot be created because it already exists,
    ppExistingZone will be set to a ptr to the existing zone.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    PZONE_INFO  pzone = NULL;
    PIP_ARRAY   masterArray = NULL;

    DNS_DEBUG( INIT, (
        "\n\nZone_Create() %.*s\n"
        "\tZone type %d.\n",
        (cchZoneNameLen ? cchZoneNameLen : DNS_MAX_NAME_LENGTH),
        pchZoneName,
        dwZoneType ));

    *ppZone = NULL;
    if ( ppExistingZone )
    {
        *ppExistingZone = NULL;
    }

    if ( !cchZoneNameLen )
    {
        cchZoneNameLen = strlen( pchZoneName );
    }

    //
    //  validate type
    //

    if ( dwZoneType != DNS_ZONE_TYPE_PRIMARY
        && dwZoneType != DNS_ZONE_TYPE_SECONDARY
        && dwZoneType != DNS_ZONE_TYPE_CACHE
        && dwZoneType != DNS_ZONE_TYPE_STUB
        && dwZoneType != DNS_ZONE_TYPE_FORWARDER )
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto ErrorReturn;
    }

    //
    //  If we are creating the root zone, validate type.
    //

    if ( strncmp( pchZoneName, ".", cchZoneNameLen ) == 0 &&
        ( dwZoneType == DNS_ZONE_TYPE_STUB ||
            dwZoneType == DNS_ZONE_TYPE_FORWARDER ) )
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto ErrorReturn;
    }

    //
    //  If we are creating a forwarder zone, make sure the server is
    //  not authoritative for the name. It is legal to create a
    //  domain forwarder under a delegation, however. Forwarder zones
    //  are not allowed on a root server.
    //

    if ( dwZoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        PDB_NODE    pZoneNode;

        if ( IS_ROOT_AUTHORITATIVE() )
        {
            status = DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER;
            goto ErrorReturn;
        }

        pZoneNode = Lookup_ZoneTreeNodeFromDottedName(
                            pchZoneName,
                            cchZoneNameLen,
                            0 );        // flags

        ASSERT( !pZoneNode || pZoneNode->pZone );

        if ( pZoneNode &&
            !IS_ZONE_FORWARDER( ( PZONE_INFO ) pZoneNode->pZone ) )
        {
            PDB_NODE        pNodeClosest = NULL;
            PDB_NODE        pFwdNode = Lookup_ZoneNodeFromDotted(
                                            pZoneNode->pZone,
                                            pchZoneName,
                                            cchZoneNameLen,
                                            LOOKUP_FIND | LOOKUP_NAME_FQDN,
                                            &pNodeClosest,
                                            NULL );     // status pointer

            //
            //  Forwarder creation is only allowed only at or under a
            //  delegation node.
            //

            if ( !pFwdNode )
            {
                pFwdNode = pNodeClosest;
            }
            if ( pFwdNode && !IS_DELEGATION_NODE( pFwdNode ) )
            {
                status = DNS_ERROR_ZONE_CONFIGURATION_ERROR;
                goto ErrorReturn;
            }
        }
    }

    //
    //  Check and see if the zone registry key needs to be migrated. This
    //  can be removed if we know for certain that no server will ever have
    //  un-migrated zones under CurrentControlSet (leftover from a Win2000
    //  2195 installation).
    //

    Zone_ListMigrateZones();

    //
    //  allocate zone struct
    //

    pzone = ALLOC_TAGHEAP_ZERO( sizeof(ZONE_INFO), MEMTAG_ZONE );
    IF_NOMEM( !pzone )
    {
        DNS_DEBUG( INIT, (
            "Memory alloc failure for database ZONE_INFO struct.\n" ));
        status = DNS_ERROR_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    //  set zone type
    //

    pzone->fZoneType = (CHAR) dwZoneType;

    //
    //  auto-create zone?
    //

    if ( fDsIntegrated == NO_DATABASE_PRIMARY )
    {
        ASSERT( IS_ZONE_PRIMARY(pzone) );
        pzone->fAutoCreated = TRUE;
    }

    //
    //  also set the USN to '0' so we always have something meaningful. setting
    //  szLastUsn[1] to '\0' is not needed because its a ALLOCATE_HEAP_ZERO
    //

    pzone->szLastUsn[0] = '0';

    //
    //  always start zone SHUTDOWN and locked
    //  when load file\DS, create default records or AXFR, then STARTUP zone
    //      and unlock

    SHUTDOWN_ZONE( pzone );
    if ( !Zone_LockForUpdate( pzone ) )
    {
        ASSERT( FALSE );
        goto ErrorReturn;
    }

    //
    //  cache "zone"
    //      - call cache zone ".", as this is label that will be
    //      enumerated and used by admin tool
    //      - use default file name if not DS and no file given
    //
    //  note, set cache zone name and allow name copy to be done, so that
    //      cache zone name is on heap and can be freed if cache zone deleted
    //

    if ( dwZoneType == DNS_ZONE_TYPE_CACHE )
    {
        pchZoneName = ".";
        cchZoneNameLen = 0;
        if ( !pchFileName && !fDsIntegrated )
        {
            pchFileName = (PCHAR) DNS_DEFAULT_CACHE_FILE_NAME_UTF8;
            cchFileNameLen = 0;
        }
    }

    //
    //  Set up the zone's name fields.
    //

    status = setZoneName( pzone, pchZoneName, cchZoneNameLen );
    if ( status != ERROR_SUCCESS )
    {
        goto ErrorReturn;
    }

    //
    //  Initialize zone event control. Do this after setting the zone name
    //  fields because the event control module might need the zone name.
    //

    pzone->pEventControl = Ec_CreateControlObject(
                                MEMTAG_ZONE,
                                pzone,
                                DNS_EC_ZONE_EVENTS );

    //
    //  cache "zone"
    //      -- create cache tree
    //      -- save global ptr
    //

    if ( dwZoneType == DNS_ZONE_TYPE_CACHE )
    {
        PDB_NODE    pnodeCacheRoot;

        pnodeCacheRoot = NTree_Initialize();
        if ( ! pnodeCacheRoot )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto ErrorReturn;
        }
        pzone->pZoneRoot = pnodeCacheRoot;
        pzone->pTreeRoot = pnodeCacheRoot;
        SET_ZONE_ROOT( pnodeCacheRoot );
    }

    //
    //  authoritative zones
    //      - setup zone in database
    //      - write to registry if appropriate
    //          - not autocreated
    //          - not loading from registry
    //

    else
    {
        status = Zone_RootCreate( pzone, ppExistingZone );
        if ( status != ERROR_SUCCESS )
        {
            goto ErrorReturn;
        }

        if ( g_bRegistryWriteBack && !pzone->fAutoCreated )
        {
            Reg_SetDwordValue(
                NULL,
                pzone,
                DNS_REGKEY_ZONE_TYPE,
                dwZoneType );
        }
    }

    //
    //  secondary or stub
    //      - MUST have MASTER IP address
    //      - MUST init for secondary zone transfer
    //  fowarder
    //      - MUST have MASTER IP list, but no transfer
    //

    if ( ZONE_NEEDS_MASTERS( pzone ) )
    {
        status = Zone_SetMasters(
                    pzone,
                    aipMasters,
                    FALSE );        //  set global masters
        if ( status != ERROR_SUCCESS )
        {
            goto ErrorReturn;
        }
    }

    //
    //  Deal with type-specific parameters.
    //

    if ( pTypeSpecificInfo )
    {
        switch( pzone->fZoneType )
        {
            case DNS_ZONE_TYPE_FORWARDER:
                pzone->dwForwarderTimeout =
                    pTypeSpecificInfo->Forwarder.dwTimeout > 0 ?
                        pTypeSpecificInfo->Forwarder.dwTimeout :
                        DNS_DEFAULT_FORWARD_TIMEOUT;
                pzone->fForwarderSlave =
                    pTypeSpecificInfo->Forwarder.fSlave;
                break;

            default:
                break;
        }
    }

    //
    //  create zone database
    //      - if reverse auto-create zone, no need
    //

    if ( !pzone->fAutoCreated )
    {
        status = Zone_DatabaseSetup(
                    pzone,
                    fDsIntegrated,
                    pchFileName,
                    cchFileNameLen );

        if ( status != ERROR_SUCCESS )
        {
            goto ErrorReturn;
        }
    }

    //
    //  Set zone's naming context.
    //

    if ( fDsIntegrated && pDpInfo )
    {
        status = Ds_SetZoneDp( pzone, pDpInfo );
        if ( status != ERROR_SUCCESS )
        {
            goto ErrorReturn;
        }
    }

    //
    //  secondaries zone transfer setup
    //
    //  1) setup for no database (SHUTDOWN)
    //  startup with no file case or admin created secondary
    //
    //  2) start secondary zone control
    //  doing this last so insure we are setup in zone list with proper
    //  database file, before starting thread in case of admin created
    //  zone;   on service start thread thread will block until database
    //  load;
    //

    if ( IS_ZONE_SECONDARY(pzone) )
    {
        Xfr_InitializeSecondaryZoneTimeouts( pzone );
        Xfr_InitializeSecondaryZoneControl();
    }

    //  DS zones need control thread running for polling

    else if ( pzone->fDsIntegrated )
    {
        Xfr_InitializeSecondaryZoneControl();
    }

    //
    //  Debug stuff
    //
    //  DEVNOTE: once bug fixed creating lock history is debug only
    //      - note, since we create after zone locked, we always miss
    //      first lock
    //

    pzone->pLockTable = Lock_CreateLockTable( pzone->pszZoneName, 0 , 0 );

    pzone->dwPrimaryMarker = ZONE_PRIMARY_MARKER;
    pzone->dwSecondaryMarker = ZONE_SECONDARY_MARKER;
    pzone->dwForwarderMarker = ZONE_FORWARDER_MARKER;
    pzone->dwFlagMarker = ZONE_FLAG_MARKER;

    //
    //  save global ptr to "cache" zone
    //
    //  root-hints -- always have default file name available for easy recovery
    //      from DS load failure
    //
    //  DEVNOTE: should "cache" zone get written to registry?
    //  DEVNOTE: does "cache" zone need pszZoneName and pszCountName?
    //      possible skip over a bunch prior test and go here with fain "cache" zone setup
    //

    if ( IS_ZONE_CACHE(pzone) )
    {
        if ( !pzone->pwsDataFile )
        {
            pzone->pwsDataFile = Dns_StringCopyAllocate_W(
                                        DNS_DEFAULT_CACHE_FILE_NAME,
                                        0 );
        }
        g_pCacheZone = pzone;
    }

    //
    //  regular zone - default zone properties
    //
    //  notify
    //      primary - all other NS
    //      DS primary or secondary - only explictly listed secondaries
    //
    //  secondary security
    //      primary - all other NS
    //      DS primary or secondary - only explictly listed secondaries

    else
    {
        pzone->fNotifyLevel = ZONE_NOTIFY_LIST_ONLY;
        if ( IS_ZONE_PRIMARY(pzone) && !pzone->fDsIntegrated )
        {
            pzone->fNotifyLevel = ZONE_NOTIFY_ALL_SECONDARIES;
        }

        pzone->fSecureSecondaries = ZONE_SECSECURE_NO_XFR;
        if ( IS_ZONE_PRIMARY(pzone) && !pzone->fDsIntegrated )
        {
            pzone->fSecureSecondaries = ZONE_SECSECURE_NO_SECURITY;
            // DEVNOTE: temporarily out due to various issues w/ xfr
            // See bug B304613.
            // pzone->fSecureSecondaries = ZONE_SECSECURE_NS_ONLY;
        }

        //  if new zone (i.e. not load), then force registry write
        //  note, there's backward compatibility issue that makes it
        //  imperative not to write;  we use ABSENCE of the SecureSecondaries
        //  key to indicate NT4 upgrade and hence more intelligent
        //  decision about value based on list

        if ( SrvCfg_fStarted )
        {
            ASSERT( !pzone->fAutoCreated );

            Zone_SetSecondaries(
                pzone,
                pzone->fSecureSecondaries,
                NULL,                       // nothing in list
                pzone->fNotifyLevel,
                NULL                        // no notify list
                );
        }
    }

#if 0
    //
    //  regular zone -- dump cached data in zone's space
    //
    //  DEVNOTE: this probably is a waste of time
    //

    else
    {
        Zone_ClearCache( pzone );
    }
#endif

    //
    //  aging init
    //

    if ( IS_ZONE_PRIMARY(pzone) )
    {
        Zone_SetAgingDefaults( pzone );
    }

    //
    //  snap zone into list
    //
    //  DEVNOTE: should "cache" zone even be in zone list?
    //      - already special cased for write back
    //      - doesn't need to be in list for zone control
    //      - RPC is only other issue
    //      - then can elminate for add\delete
    //
    //  currently cache zone is left in the list
    //      this eliminates need for special casing in RPC zone enumeration
    //

    Zone_ListInsertZone( pzone );

    //
    //  link zone into database (link into zone tree)
    //      - zone tree node points at zone
    //      - zone tree node marked as authoritative zone root
    //

    if ( !IS_ZONE_CACHE(pzone) )
    {
        PDB_NODE    pzoneRoot = pzone->pZoneTreeLink;

        Dbase_LockDatabase();
        pzoneRoot->pZone = pzone;

        SET_ZONE_ROOT(pzoneRoot);
        SET_AUTH_ZONE_ROOT(pzoneRoot);
        Dbase_UnlockDatabase();
    }

    IF_DEBUG( INIT )
    {
        Dbg_Zone(
            "Created new ",
            pzone );
    }
    *ppZone = pzone;

    return( ERROR_SUCCESS );

ErrorReturn:

    DNS_DEBUG( INIT, (
        "\nZone_Create() failed.\n"
        "\tstatus = %d (%p).\n\n",
        status, status ));

    if ( pzone )
    {
        if ( pzone == g_pCacheZone )
        {
            g_pCacheZone = NULL;
            ASSERT( FALSE );
        }

        //
        //  If zone creation failed and we have a zone pointer we need
        //  to clean it up. Since this zone struct is bogus, set the
        //  zone deleted count high to circumvent the "smarts" in Zone_Free.
        //  This is not one of the cases where we need the zone to
        //  persist after delete.
        //

        pzone->cDeleted = 255;
        Zone_Free( pzone );
    }
    *ppZone = NULL;
    return( status );
}



DNS_STATUS
Zone_Create_W(
    OUT     PZONE_INFO *    ppZone,
    IN      DWORD           dwZoneType,
    IN      PWSTR           pwsZoneName,
    IN      PIP_ARRAY       aipMasters,
    IN      BOOL            fDsIntegrated,
    IN      PWSTR           pwsFileName
    )
/*++

Routine Description:

    Create zone information.

    Note:  all Zone_Create() info applies.

Arguments:

    (see Zone_Create())

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD   resultLength;
    DWORD   bufLength;
    CHAR    utf8Name[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR    utf8File[ MAX_PATH ];

    DNS_DEBUG( INIT, (
        "\n\nZone_Create_W() %S\n"
        "\ttype %d.\n"
        "\tfile %S.\n",
        pwsZoneName,
        dwZoneType,
        pwsFileName ));

    //
    //  convert zone name
    //

    bufLength = DNS_MAX_NAME_BUFFER_LENGTH;

    resultLength = Dns_StringCopy(
                            utf8Name,
                            & bufLength,
                            (PCHAR) pwsZoneName,
                            0,
                            DnsCharSetUnicode,
                            DnsCharSetUtf8      // convert to UTF8
                            );
    if ( resultLength == 0 )
    {
        return( DNS_ERROR_INVALID_NAME );
    }

    if ( pwsFileName )
    {
        bufLength = MAX_PATH;

        resultLength = Dns_StringCopy(
                                utf8File,
                                & bufLength,
                                (PCHAR) pwsFileName,
                                0,
                                DnsCharSetUnicode,
                                DnsCharSetUtf8      // convert to UTF8
                                );
        if ( resultLength == 0 )
        {
            return( DNS_ERROR_INVALID_DATAFILE_NAME );
        }
    }

    return  Zone_Create(
                ppZone,
                dwZoneType,
                utf8Name,
                0,
                aipMasters,
                fDsIntegrated,
                NULL,                           //  naming context
                pwsFileName ? utf8File : NULL,
                0,
                NULL,
                NULL );     //  existing zone
}



VOID
Zone_Free(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Free zone info structure.

    Note, this does NOT delete zone from list, that must
    be done by Zone_Delete() function.

Arguments:

    pZone -- zone to free

Return Value:

    None

--*/
{
    if ( !pZone )
    {
        return;
    }

    DNS_DEBUG( ANY, (
        "Zone_Free( %s ) -- cycle %d\n",
        pZone->pszZoneName,
        pZone->cDeleted ));

    //
    //  don't free until have gone through several delayed free
    //      cycles;  this prevents longer operations, like some
    //      DS updates from exceeding delay (when under stress)
    //      and being active when zone actually deleted

    if ( pZone->cDeleted < 7 )
    {
        pZone->cDeleted++;
        Timeout_FreeWithFunction( pZone, Zone_Free );
        return;
    }


    //  should never be freeing with outstanding tree cleanup

    if ( pZone->pOldTree )
    {
        DNS_PRINT((
            "ERROR:  zone %s (%p) free with outstanding pOldTree ptr!\n",
            pZone->pszZoneName,
            pZone ));
        ASSERT( FALSE );
        return;
    }

    //  close update log -- if open

    if ( pZone->hfileUpdateLog )
    {
        CloseHandle( pZone->hfileUpdateLog );
    }

    Ec_DeleteControlObject( pZone->pEventControl );

    //  free substructures

    FREE_HEAP( pZone->pwsZoneName );
    FREE_HEAP( pZone->pszZoneName );
    FREE_HEAP( pZone->pCountName );

    FREE_HEAP( pZone->pwsDataFile );
    FREE_HEAP( pZone->pszDataFile );
    FREE_HEAP( pZone->pwsLogFile );
    FREE_HEAP( pZone->pwszZoneDN );

    FREE_HEAP( pZone->aipMasters );
    //  FREE_HEAP( pZone->MasterInfoArray );
    FREE_HEAP( pZone->aipSecondaries );
    FREE_HEAP( pZone->aipAutoCreateNS );
    FREE_HEAP( pZone->aipLocalMasters );

    FREE_HEAP( pZone->pSD );
    FREE_HEAP( pZone->pLockTable );

    FREE_HEAP( pZone->pwsDeletedFromHost );

    FREE_HEAP( pZone->pszBreakOnUpdateName );

    //  deleting DS zone, drop DS zone count

    if ( pZone->fDsIntegrated )
    {
        SrvCfg_cDsZones--;
    }

    //  free zone structure itself

    FREE_HEAP( pZone );
}



VOID
Zone_DeleteZoneNodes(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Timeout free zone node trees.

Arguments:

    pZone -- zone to delete

Return Value:

    None

--*/
{
    if ( pZone->pTreeRoot )
    {
        DNS_DEBUG( INIT, (
            "Deleting zone %s database at %p.\n",
            pZone->pszZoneName,
            pZone->pTreeRoot ));
        Timeout_FreeWithFunction( pZone->pTreeRoot, NTree_DeleteSubtree );
        pZone->pTreeRoot = NULL;
    }
    if ( pZone->pLoadTreeRoot )
    {
        DNS_DEBUG( INIT, (
            "Deleting zone %s loading database at %p.\n",
            pZone->pszZoneName,
            pZone->pLoadTreeRoot ));
        Timeout_FreeWithFunction( pZone->pLoadTreeRoot, NTree_DeleteSubtree );
        pZone->pLoadTreeRoot = NULL;
    }
}   //  Zone_DeleteZoneNodes



VOID
Zone_Delete(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Remove the zone from the zonelist and delete.

Arguments:

    pZone -- zone to delete

Return Value:

    None

--*/
{
    PDB_NODE    pzoneTreeZoneRoot;
    PZONE_INFO  prootZone = NULL;

    DNS_DEBUG( ANY, (
        "Zone_Delete( %s )\n",
        pZone->pszZoneName ));

    //
    //  deleting cache zone -- ignore
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  attempt to delete cache zone!\n" ));
        return;
    }

    //
    //  pause zone to stop lookups for new queries in zone
    //

    pZone->fPaused = TRUE;

    //
    //  lock out any update activity
    //      - wait for a long time to get lock (15m => 900s => 900000ms)
    //
    //  note, delete zone as LOCKED, that way during entire delete process
    //  through final memory timeout, no threads holding pZone ptr will be
    //  able to get through and party on zone
    //

    if ( !Zone_LockForWriteEx(
            pZone,
            DNSUPDATE_ADMIN,
            900000,
            __FILE__,
            __LINE__ ) )
    {
        DNS_PRINT((
            "ERROR:  Failed to lock zone %s before zone delete!\n",
            pZone->pszZoneName ));
        ASSERT( FALSE );
        return;
    }

    //
    //  remove zone from list
    //  mark as deleted
    //

    Zone_ListRemoveZone( pZone );

    pZone->cDeleted = 1;

    //
    //  authoritative zone
    //
    //  => "uproot" zone root
    //  this eliminates pZone from being set in nodes in zone
    //
    //  => delete authoritative zone's registry key
    //      - so don't load zone on reboot
    //
    //  note:  not deleting registry key for cache zone, as cache ONLY
    //  deleted when overwritten by new authoritative zone;
    //  so if delete key, we'll destroy new root zone info
    //

    pzoneTreeZoneRoot = Lookup_ZoneTreeNodeFromDottedName(
                            pZone->pszZoneName,
                            0,
                            LOOKUP_MATCH_ZONE       // exact name match
                            );
    if ( !pzoneTreeZoneRoot )
    {
        DNS_PRINT((
            "ERROR:  Zone_Delete( %s ), does NOT have zone node in zone tree!\n",
            pZone->pszZoneName ));
    }
    else
    {
        //
        //  if deleting root zone, need cache up
        //

        if ( IS_ROOT_ZONE(pZone) )
        {
            prootZone = pZone;
        }

        //
        //  remove zone from zone tree
        //      - clear zone root flag
        //      - for non-root zone, clear zone root flag

        Dbase_LockDatabase();
        CLEAR_AUTH_ZONE_ROOT( pzoneTreeZoneRoot );
        if ( !prootZone )
        {
            CLEAR_ZONE_ROOT(pzoneTreeZoneRoot);
        }
        pzoneTreeZoneRoot->pZone = NULL;
        Dbase_UnlockDatabase();

        //
        //  if root zone deleted, cache "zone" becomes active
        //      - write back cache file before delete all NS and A info in zone
        //
        //  DEVNOTE: should patch in NS\glue info from existing root zone to build
        //      root-hints
        //
        //  DEVNOTE: delete root-zone, don't consider forwarders to be load success
        //      if forwarders and can't load, probably still should try write back;
        //      this may require another flag to Zone_LoadRootHints()
        //

        if ( prootZone )
        {
            DNS_STATUS  status;
            DWORD       zoneType;
            PWSTR       pfileTemp;

            status = Zone_LoadRootHints();
            if ( status == ERROR_SUCCESS )
            {
                goto RegDelete;
            }
            if ( status == DNS_ERROR_ZONE_LOCKED )
            {
                DNS_DEBUG( INIT, (
                    "Deleting root zone, and unable to load root hints.\n"
                    "\tzone is locked.\n" ));
                goto RegDelete;
            }

            DNS_DEBUG( INIT, (
                "Deleting root zone, and unable to load root hints.\n"
                "\tForcing root-hints write back.\n" ));

            //
            //  DEVNOTE: can't plug in at present because of overload of cache zone
            //      once cache zone issue fixed, can plug in to g_pRootHintZone,
            //      write, then force reload and dump
            //

            //
            //  temporarily mimic root-hints zone for write back
            //      - save off file string, for later cleanup
            //      - if DS integrated, we'll write to DS, no action necessary
            //

            pfileTemp = pZone->pwsDataFile;
            pZone->pwsDataFile = L"cache.dns";

            zoneType = pZone->fZoneType;
            pZone->fZoneType = DNS_ZONE_TYPE_CACHE;

            //
            //  write back root-hints
            //      - if successful, then force root-hint reload
            //

            if ( File_WriteZoneToFile( pZone, NULL ) )
            {
                DNS_DEBUG( INIT, (
                    "Successfully wrote root hints, from deleted root zone data.\n" ));

                Zone_LoadRootHints();
            }
            ELSE_IF_DEBUG( ANY )
            {
                DNS_PRINT(( "ERROR:  writing root-hints from deleted root zone!\n" ));
            }

            //  restore root zone for delete

            pZone->pwsDataFile = pfileTemp;
            pZone->fZoneType = zoneType;
        }
    }

RegDelete:

    Reg_DeleteZone( pZone->pwsZoneName );

    //
    //  close update log
    //

    if ( pZone->hfileUpdateLog )
    {
        CloseHandle( pZone->hfileUpdateLog );
        pZone->hfileUpdateLog = NULL;
    }

    //
    //  Set the zone DP to NULL so that we can track zone/DP association.
    //

    Ds_SetZoneDp( pZone, NULL );

    //
    //  delete zone data
    //      - records in zone update list
    //          (delete records, add records are in zone data)
    //      - zone data
    //      - failed zone load (if any)
    //

    ASSERT( pZone->UpdateList.pListHead == NULL ||
            pZone->UpdateList.Flag & DNSUPDATE_EXECUTED );

    pZone->UpdateList.Flag |= DNSUPDATE_NO_DEREF;
    Up_FreeUpdatesInUpdateList( &pZone->UpdateList );

    Zone_DeleteZoneNodes( pZone );

    //
    //  timeout free zone in case query holds ptr to it
    //

    Timeout_FreeWithFunction( pZone, Zone_Free );
}



DNS_STATUS
Zone_Rename(
    IN OUT  PZONE_INFO      pZone,
    IN      LPCSTR          pszNewZoneName,
    IN      LPCSTR          pszNewZoneFile
    )
/*++

Routine Description:

    Rename a zone and optionally rename zone file (if file-backed)

Arguments:

    pZone -- zone to rename

    pszNewZoneName -- new name of the zone

    pszNewZoneFile -- new file name for zone file, may be NULL

Return Value:

    None

--*/
{
    DBG_FN( "Zone_Rename" )

    DNS_STATUS      status = ERROR_SUCCESS;
    PDB_NODE        pZoneNode = NULL;
    BOOLEAN         mustUnlockZone = FALSE;
    BOOLEAN         originalZonePauseValue = FALSE;
    BOOLEAN         zoneFileIsChanging = FALSE;
    BOOLEAN         repairingZone = FALSE;
    WCHAR           wsOriginalZoneFile[ MAX_PATH + 2 ] = L"";
    WCHAR           wsOriginalZoneName[ DNS_MAX_NAME_BUFFER_LENGTH + 2 ] = L"";
    CHAR            szOriginalZoneName[ DNS_MAX_NAME_BUFFER_LENGTH ] = "";

    ASSERT( pszNewZoneName );
    ASSERT( pZone );
    ASSERT( pZone->pszZoneName );
    ASSERT( pZone->pwsZoneName );
    ASSERT( pZone->pZoneRoot );

    DNS_DEBUG( ANY, (
        "%s( %s ) to %s file %s\n", fn,
        pZone->pszZoneName,
        pszNewZoneName,
        pszNewZoneFile ? pszNewZoneFile : "NULL" ));

    //
    //  Setup names and stuff.
    //

    strcpy( szOriginalZoneName, pZone->pszZoneName );
    wcscpy( wsOriginalZoneName, pZone->pwsZoneName );
    if ( pZone->pwsDataFile )
    {
        wcscpy( wsOriginalZoneFile, pZone->pwsDataFile );
    }

    //
    //  Rename cache or root zone is not allowed.
    //

    if ( IS_ZONE_CACHE( pZone ) || IS_ROOT_ZONE( pZone ) )
    {
        DNS_DEBUG( ANY, (
            "%s: ignoring attempt to rename cache or root zone\n", fn ));
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        ASSERT( FALSE );
        goto Failure;
    }

    //
    //  Check if we already have a zone matching the new name.
    //

    pZoneNode = Lookup_ZoneTreeNodeFromDottedName(
                    ( LPSTR ) pszNewZoneName,
                    0,
                    LOOKUP_MATCH_ZONE );
    if ( pZoneNode )
    {
        DNS_PRINT((
            "%s: cannot rename zone %s to %s (zone already exists)\n", fn,
            pZone->pszZoneName,
            pszNewZoneName ));
        status = DNS_ERROR_ZONE_ALREADY_EXISTS;
        goto Failure;
    }

    //
    //  Lock and pause the zone.
    //

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        status = DNS_ERROR_ZONE_LOCKED;
        goto Failure;
    }
    mustUnlockZone = TRUE;
    originalZonePauseValue = pZone->fPaused;
    pZone->fPaused = TRUE;

    //
    //  Remove from zone list. We will rename and add it back later.
    //

    Zone_ListRemoveZone( pZone );

    //
    //  Look up the existing zone in the zone tree.
    //

    pZoneNode = Lookup_ZoneTreeNodeFromDottedName(
                    pZone->pszZoneName,
                    0,
                    LOOKUP_MATCH_ZONE );
    if ( !pZoneNode )
    {
        DNS_PRINT((
            "%s: zone %s does not have zone node in zone tree\n", fn,
            pZone->pszZoneName ));
    }
    else
    {
        //
        //  Remove zone from zone tree.
        //

        Dbase_LockDatabase();
        CLEAR_AUTH_ZONE_ROOT( pZoneNode );
        CLEAR_ZONE_ROOT( pZoneNode );
        pZoneNode->pZone = NULL;
        Dbase_UnlockDatabase();
    }

    //
    //  Delete the zone from the registry. We will add it back later
    //  under it's new name.
    //

    Reg_DeleteZone( pZone->pwsZoneName );

    //
    //  Close the update log. We will want to reopen a new log file with
    //  the new zone name in the file name.
    //

    if ( pZone->hfileUpdateLog )
    {
        CloseHandle( pZone->hfileUpdateLog );
        pZone->hfileUpdateLog = NULL;
    }

    //
    //  Delete the zone from the DS if necessary.
    //

    if ( IS_ZONE_DSINTEGRATED( pZone ) )
    {
        status = Ds_DeleteZone( pZone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "%s: failed to delete zone %s from DS\n", fn,
                pZone->pszZoneName ));
            goto Failure;
        }
    }

    //
    //  We may jump to this label if the rename operation fails to try
    //  and undo all the changes made so far.
    //

    RepairOriginalZone:

    //
    //  Zone has now been removed from all server structures. Rename it.
    //

    status = setZoneName( pZone, pszNewZoneName, 0 );
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  Construct zone DN.
    //

    if ( IS_ZONE_DSINTEGRATED( pZone ) )
    {
        //
        //  WITH NC SUPPORT WE CAN'T JUST RECREATE BLINDLY - NEED TO RECREATE
        //  IN PROPER CONTAINER - FIX THIS BEFORE RENAME GOES LIVE!
        //
        ASSERT( FALSE );

        FREE_HEAP( pZone->pwszZoneDN );
        pZone->pwszZoneDN = DS_CreateZoneDsName( pZone );
        if ( pZone->pwszZoneDN == NULL )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failure;
        }
    }

    //
    //  Fix the zone's tree (pTreeRoot). Right now the tree will look
    //  something like this:
    //      oldzonename2 -> oldzonename1 -> children
    //  so we need to turn it into:
    //      newzonename3 -> newzonename2 -> newzonename2 -> children
    //  Note: the children are unaffected - they just need to get moved.
    //

    pZoneNode = Lookup_ZoneNodeFromDotted(
                    pZone,                  // zone
                    szOriginalZoneName,     // zone name
                    0,                      // name length
                    LOOKUP_NAME_FQDN,       // flags
                    NULL,                   // optional closest node
                    NULL );                 // optional status pointer
    if ( !pZoneNode )
    {
        DNS_PRINT((
            "%s: zone %s cannot be found in it's own tree\n", fn,
            pZone->pszZoneName ));
    }
    else
    {
        PVOID       pChildren;
        ULONG       cChildren;
        PDB_RECORD  pRRList;

        //
        //  Steal the pointer to the children of the zone's own node
        //  and delete the tree from the zone.
        //
        
        pChildren = pZoneNode->pChildren;
        cChildren = pZoneNode->cChildren;
        pRRList = pZoneNode->pRRList;
        pZoneNode->pChildren = NULL;
        pZoneNode->cChildren = 0;
        pZoneNode->pRRList = NULL;

        //
        //  Stick the children into the tree under the proper node.
        //

        pZoneNode = Lookup_ZoneNodeFromDotted(
                        pZone,                      // zone
                        ( LPSTR ) pszNewZoneName,   // zone name
                        0,                          // name length
                        LOOKUP_NAME_FQDN,           // flags
                        NULL,                       // optional closest node
                        NULL );                     // optional status pointer
        ASSERT( pZoneNode );
        ASSERT( pZoneNode->pChildren == NULL );
        SET_ZONE_ROOT( pZoneNode );
        SET_AUTH_ZONE_ROOT( pZoneNode );
        SET_AUTH_NODE( pZoneNode );
        pZoneNode->pChildren = pChildren;
        pZoneNode->cChildren = cChildren;
        pZoneNode->pRRList = pRRList;
        pZone->pZoneRoot = pZoneNode;
    }

    //
    //  Set up zone in database and registry.
    //

    status = Zone_RootCreate( pZone, NULL );
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    if ( g_bRegistryWriteBack )
    {
        Reg_SetDwordValue(
            NULL,
            pZone,
            DNS_REGKEY_ZONE_TYPE,
            pZone->fZoneType );
    }

    //
    //  If this zone has masters update them. This is a bit wasteful
    //  since the ZONE_INFO already has the masters set, but we need
    //  to call Zone_SetMasters() to set the masters in the registry.
    //

    if ( ZONE_NEEDS_MASTERS( pZone ) )
    {
        status = Zone_SetMasters(
                    pZone,
                    pZone->aipMasters,
                    FALSE );        //  set global masters
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }
    }

    //
    //  Create zone database.
    //

    status = Zone_DatabaseSetup(
                pZone,
                pZone->fDsIntegrated,
                ( LPSTR ) pszNewZoneFile,
                0 );    // OPTIONAL: zone file len

    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  Check if zone file changed.
    //

    if ( !repairingZone
        && pZone->pwsDataFile
        && wsOriginalZoneFile[ 0 ] != '\0'
        && wcsicmp_ThatWorks( pZone->pwsDataFile, wsOriginalZoneFile ) != 0 )
    {
        zoneFileIsChanging = TRUE;
    }

    //
    //  Set secondaries. This writes the secondaries into the registry.
    //

    if ( SrvCfg_fStarted )
    {
        Zone_SetSecondaries(
            pZone,
            pZone->fSecureSecondaries,
            NULL,                       // nothing in list
            pZone->fNotifyLevel,
            NULL );                     // no notify list
    }

    //
    //  Insert into zone list.
    //

    Zone_ListInsertZone( pZone );

    //
    //  Link zone into database (ie. link into zone tree).
    //

    pZoneNode = pZone->pZoneTreeLink;
    Dbase_LockDatabase();
    pZoneNode->pZone = pZone;
    SET_ZONE_ROOT( pZoneNode );
    SET_AUTH_ZONE_ROOT( pZoneNode );
    Dbase_UnlockDatabase();

    //
    //  Update zone in persistent storage.
    //

    if ( IS_ZONE_DSINTEGRATED( pZone ) )
    {
        status = Ds_WriteZoneToDs( pZone, 0 );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "%s: failed to write renamed zone %s to DS\n", fn,
                pZone->pszZoneName ));
            goto Failure;
        }
    }
    else
    {
        if ( File_WriteZoneToFile( pZone, NULL )
            && zoneFileIsChanging )
        {
            File_DeleteZoneFileW( wsOriginalZoneFile );
        }
    }

    //
    //  Reload zone from persistent storage. This is only required until
    //  I fix the zones tree (in pZoneRoot).
    //

    //  Zone_Load( pZone );

    //
    //  JJW: must reopen update log (but only if it was open!!)
    //

    status = ERROR_SUCCESS;

    DNS_DEBUG( ANY, (
        "%s: renamed zone to %s\n", fn,
        pZone->pszZoneName ));

    goto Cleanup;

    Failure:

    //
    //  This needs more thought. There could be a lot of work to do if
    //  the rename failed at some stage along the way. I'm not 100%
    //  certain that the logic below will recover us from any
    //  possible error condition.
    // 

    if ( !repairingZone )
    {
        pszNewZoneName = szOriginalZoneName;
        FREE_HEAP( pZone->pwsDataFile );
        pZone->pwsDataFile = Dns_StringCopyAllocate_W( wsOriginalZoneFile, 0 );
        repairingZone = TRUE;
        goto RepairOriginalZone;
    }

    DNS_DEBUG( ANY, (
        "%s: failed to rename zone %s (file %s)\n", fn,
        pszNewZoneName,
        pszNewZoneFile ? pszNewZoneFile : "NULL" ));

    Cleanup:

    //
    //  Unpause and unlock the zone.
    //

    pZone->fPaused = originalZonePauseValue;
    if ( mustUnlockZone )
    {
        Zone_UnlockAfterAdminUpdate( pZone );
    }

    return status;
}



DNS_STATUS
Zone_RootCreate(
    IN OUT  PZONE_INFO      pZone,
    OUT     PZONE_INFO *    ppExistingZone      OPTIONAL
    )
/*++

Routine Description:

    Create zone root, and associate with zone.

Arguments:

    pZone -- zone to create root for

    ppExistingZone -- set to existing zone if the zone already exists

Return Value:

    ERROR_SUCCESS if successful.
    Error code on error.

--*/
{
    PDB_NODE        pzoneRoot;
    DNS_STATUS      status;

    ASSERT( pZone );
    ASSERT( pZone->pszZoneName );

    if ( ppExistingZone )
    {
        *ppExistingZone = NULL;
    }

    //
    //  find / create domain node
    //      - save in zone information
    //

    pzoneRoot = Lookup_CreateZoneTreeNode( pZone->pszZoneName );
    if ( !pzoneRoot )
    {
        DNS_DEBUG( INIT, (
            "ERROR:  unable to create zone for name %s\n",
            pZone->pszZoneName ));
#if 0
        //
        //  should have some way to distinguish various types of zone
        //  create failure -- including name failure, which is only
        //  likely cause (beyond memory) of this event

        DNS_LOG_EVENT(
            DNS_EVENT_DOMAIN_NODE_CREATION_ERROR,
            0,
            NULL,
            NULL,
            0 );
#endif
        return( DNS_ERROR_ZONE_CREATION_FAILED );
    }

    if ( IS_AUTH_ZONE_ROOT(pzoneRoot) )
    {
        DNS_DEBUG( INIT, (
            "ERROR:  zone root creation failed for %s, zone block %p.\n"
            "\tThis node is already an authoritative zone root.\n"
            "\tof zone block at %p\n"
            "\twith zone name %s\n",
            pZone->pszZoneName,
            pZone,
            pzoneRoot->pZone,
            ((PZONE_INFO)pzoneRoot->pZone)->pszZoneName ));

        Dbg_DbaseNode(
            "Node already zone root",
            pzoneRoot );

#if 0
        DNS_LOG_EVENT(
            DNS_EVENT_DOMAIN_NODE_CREATION_ERROR,
            0,
            NULL,
            NULL,
            0 );
#endif

        if ( ppExistingZone )
        {
            *ppExistingZone = pzoneRoot->pZone;
        }

        if ( ((PZONE_INFO)pzoneRoot->pZone)->fAutoCreated )
        {
            return( DNS_ERROR_AUTOZONE_ALREADY_EXISTS );
        }
        else
        {
            return( DNS_ERROR_ZONE_ALREADY_EXISTS );
        }
    }

    //
    //  set flag if reverse lookup zone, allows
    //      - fast filtering for producing admin zone list
    //      - fast determination of whether WINS \ WINSR is appropriate
    //
    //  DEVNOTE: WINSR broken at ARPA zone
    //      - this now includes ARPA as reverse for admin tool, but obviously
    //      WINSR doesn't operate correctly under it
    //
    //  DEVNOTE: should detect valid IP6.INT nodes
    //

    if ( Dbase_IsNodeInSubtree( pzoneRoot, DATABASE_ARPA_NODE ) )
    {
        pZone->fReverse = TRUE;

        if ( ! Name_GetIpAddressForReverseNode(
                pzoneRoot,
                & pZone->ipReverse,
                & pZone->ipReverseMask ) )
        {
            return( DNS_ERROR_ZONE_CREATION_FAILED );
        }
    }

    //  detect IPv6 reverse lookup
    //      - note, do not start at "int" zone as this valid for forward lookup

    else if ( Dbase_IsNodeInSubtree( pzoneRoot, DATABASE_IP6_NODE ) )
    {
        pZone->fReverse = TRUE;
    }

    //
    //  get count of labels of zone root node,
    //  useful for WINS lookup
    //

    pZone->cZoneNameLabelCount = (UCHAR) pzoneRoot->cLabelCount;

    //
    //  save link to zone tree
    //  but DO NOT link zone into zone-tree until
    //      Zone_Create completes
    //

    pZone->pZoneTreeLink = pzoneRoot;

    return( ERROR_SUCCESS );
}



DNS_STATUS
Zone_DatabaseSetup(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           fDsIntegrated,
    IN      PCHAR           pchFileName,    OPTIONAL
    IN      DWORD           cchFileNameLen  OPTIONAL
    )
/*++

Routine Description:

    Setup zone to use zone file or DS.

Arguments:

    pZone -- zone to setup file for

    fDsIntegrated -- use DS, instead of file

    pchFileName -- file name, if NULL use database

    cchFileNameLen -- file name length, if zero, assume pchFileName is
                        NULL terminated string

Return Value:

    ERROR_SUCCESS -- if successful
    Error code -- on failure

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    PSTR        pnewUtf8 = NULL;
    PWSTR       pnewUnicode = NULL;
    BOOL        fupdateLock = FALSE;


    ASSERT( pZone );
    ASSERT( pZone->pwsZoneName );

    DNS_DEBUG( INIT, (
        "Zone_DatabaseSetup( %S )\n"
        "\tfDsIntegrated    = %d\n"
        "\tpchFileName      = %.*s\n",
        pZone->pwsZoneName,
        fDsIntegrated,
        cchFileNameLen ? cchFileNameLen : MAX_PATH,
        pchFileName ));

    //
    //  using DS
    //
    //  DEVNOTE: server global check on use of DS?
    //      at a minimum need to change default
    //
    //  if zone written to DS, then MUST switch to registry boot
    //

    if ( fDsIntegrated )
    {

        //
        //  Normal secondary zones may not be DS-integrated, but
        //  DS-integrated stub zones are supported.
        //

        if ( IS_ZONE_SECONDARY( pZone ) && !IS_ZONE_STUB( pZone ) )
        {
            return( DNS_ERROR_INVALID_ZONE_TYPE );
        }

        if ( SrvCfg_fBootMethod == BOOT_METHOD_FILE ||
             SrvCfg_fBootMethod == BOOT_METHOD_UNINITIALIZED )
        {
            DNS_PROPERTY_VALUE prop = { REG_DWORD, BOOT_METHOD_DIRECTORY };

            Config_ResetProperty(
                DNS_REGKEY_BOOT_METHOD,
                &prop );
        }

        //
        //  if first zone switched to using DS, then must
        //  reset dependency on NTDS service
        //
        //  to do this maintain count of DS zones,
        //  all new DS zones are counted here
        //  zones deleted at counted in Zone_Delete()
        //

        if ( pZone->fDsIntegrated )
        {
            SrvCfg_cDsZones++;      // count new DS zones
        }

        //  start zone control thread, if not already running

        Xfr_InitializeSecondaryZoneControl();
        goto Finish;
    }

    //
    //  no data file specified
    //      - ok for secondary, but NOT primary or cache
    //      - if RPC call, then use default file name
    //

    if ( ! pchFileName )
    {
        if ( IS_ZONE_SECONDARY(pZone) || IS_ZONE_FORWARDER(pZone) )
        {
            goto Finish;
        }
        if ( SrvCfg_fStarted )
        {
            Zone_CreateDefaultZoneFileName( pZone );
        }
        if ( !pZone->pwsDataFile )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  no filename for non-secondary zone %S.\n",
                pZone->pwsZoneName ));
            return( DNS_ERROR_PRIMARY_REQUIRES_DATAFILE );
        }

        //  save ptr to new file name
        //  but NULL zone ptr, so it is not freed below
        //  then create UTF8 version

        pnewUnicode = pZone->pwsDataFile;
        pZone->pwsDataFile = NULL;

        pnewUtf8 = Dns_StringCopyAllocate(
                                (PCHAR) pnewUnicode,
                                0,
                                DnsCharSetUnicode,
                                DnsCharSetUtf8
                                );
        if ( !pnewUtf8 )
        {
            goto InvalidFileName;
        }
    }

    //
    //  file specified
    //      - create unicode and UTF8 filenames
    //

    else
    {
        pnewUtf8 = Dns_StringCopyAllocate(
                                pchFileName,
                                cchFileNameLen,
                                DnsCharSetUtf8,
                                DnsCharSetUtf8
                                );
        if ( !pnewUtf8 )
        {
            goto InvalidFileName;
        }

        //  replace forward slashes in UNIX filename with NT backslashes

        ConvertUnixFilenameToNt( pnewUtf8 );

        pnewUnicode = Dns_StringCopyAllocate(
                                pnewUtf8,
                                0,
                                DnsCharSetUtf8,
                                DnsCharSetUnicode
                                );
        if ( !pnewUnicode )
        {
            goto InvalidFileName;
        }
    }

    //
    //  check directory and path combination for length
    //

    if ( ! File_CheckDatabaseFilePath(
                pnewUnicode,
                0 ) )
    {
        goto InvalidFileName;
    }


Finish:

    //
    //  reset database info
    //

    Zone_UpdateLock( pZone );
    fupdateLock = TRUE;

    Timeout_Free( pZone->pszDataFile );
    Timeout_Free( pZone->pwsDataFile );

    pZone->pszDataFile = pnewUtf8;
    pZone->pwsDataFile = pnewUnicode;

    pZone->fDsIntegrated = (BOOLEAN)fDsIntegrated;

    //
    //  set registry values
    //
    //  for cache, only need file name if NOT default
    //  do NOT need DsIntegrated at all -- if no explicit cache file, we'll attempt
    //      open of DS
    //
    //  DEVNOTE: cache file overriding DS?
    //      this logic is problematic if we ever want to allow cache file to
    //      override DS;  this appears to whack default "cache.dns" name in
    //      registry which will, of course, default to DS
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        if ( !g_bRegistryWriteBack )
        {
            goto Unlock;
        }

        if ( fDsIntegrated ||
             wcsicmp_ThatWorks( pZone->pwsDataFile, DNS_DEFAULT_CACHE_FILE_NAME ) == 0 )
        {
            Reg_DeleteValue(
                NULL,
                NULL,
                DNS_REGKEY_ROOT_HINTS_FILE
                );
        }
        else    // non standard cache file name
        {
            ASSERT( pZone->pwsDataFile && cchFileNameLen );
            DNS_DEBUG( INIT, (
                "Setting non-standard cache-file name %S\n",
                pZone->pwsDataFile ));

            Reg_SetValue(
                NULL,
                NULL,
                DNS_REGKEY_ROOT_HINTS_FILE_PRIVATE,
                DNS_REG_WSZ,
                pZone->pwsDataFile,
                0 );
        }
    }

    //
    //  for zone's, set DSIntegrated or DataFile value
    //

    else if ( g_bRegistryWriteBack )
    {
        if ( fDsIntegrated )
        {
            ASSERT( pZone->fDsIntegrated );

            Reg_SetDwordValue(
                NULL,
                pZone,
                DNS_REGKEY_ZONE_DS_INTEGRATED,
                fDsIntegrated
                );
            Reg_DeleteValue(
                NULL,
                pZone,
                DNS_REGKEY_ZONE_FILE
                );
        }
        else    // zone file
        {
            if ( pZone->pszDataFile )
            {
                Reg_SetValue(
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FILE_PRIVATE,
                    DNS_REG_WSZ,
                    pZone->pwsDataFile,
                    0 );
            }
            else
            {
                ASSERT( IS_ZONE_SECONDARY(pZone) || IS_ZONE_FORWARDER(pZone) );
                Reg_DeleteValue(
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FILE
                    );
            }
            if ( IS_ZONE_FORWARDER( pZone ) )
            {
                Reg_SetDwordValue(
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FWD_TIMEOUT,
                    pZone->dwForwarderTimeout
                    );
                Reg_SetDwordValue(
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FWD_SLAVE,
                    pZone->fForwarderSlave
                    );
            }
            Reg_DeleteValue(
                NULL,
                pZone,
                DNS_REGKEY_ZONE_DS_INTEGRATED
                );
        }

        //  delete obsolete key

        Reg_DeleteValue(
            NULL,
            pZone,
            DNS_REGKEY_ZONE_USE_DBASE );
    }


Unlock:

    if ( fupdateLock )
    {
        Zone_UpdateUnlock( pZone );
    }
    return( status );


InvalidFileName:

    if ( fupdateLock )
    {
        Zone_UpdateUnlock( pZone );
    }

    DNS_DEBUG( ANY, (
        "ERROR:  Invalid file name\n"
        ));

    FREE_HEAP( pnewUnicode );
    FREE_HEAP( pnewUtf8 );

    return( DNS_ERROR_INVALID_DATAFILE_NAME );
}



DNS_STATUS
Zone_DatabaseSetup_W(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           fDsIntegrated,
    IN      PWSTR           pwsFileName
    )
/*++

Routine Description:

    Setup zone to use zone file or DS.

Arguments:

    (see Zone_DatabaseSetup)

Return Value:

    ERROR_SUCCESS -- if successful
    Error code -- on failure

--*/
{
    DWORD   resultLength;
    DWORD   bufLength;
    CHAR    utf8File[ MAX_PATH ];

    DNS_DEBUG( INIT, (
        "\n\nZone_DatabaseSetup_W( %p, %S )\n",
        pZone,
        pwsFileName ));

    if ( pwsFileName )
    {
        bufLength = MAX_PATH;

        resultLength = Dns_StringCopy(
                                utf8File,
                                & bufLength,
                                (PCHAR) pwsFileName,
                                0,
                                DnsCharSetUnicode,
                                DnsCharSetUtf8      // convert to UTF8
                                );
        if ( resultLength == 0 )
        {
            return( DNS_ERROR_INVALID_DATAFILE_NAME );
        }
    }

    return  Zone_DatabaseSetup(
                pZone,
                fDsIntegrated,
                pwsFileName ? utf8File : NULL,
                0 );
}



DNS_STATUS
Zone_SetMasters(
    IN OUT  PZONE_INFO      pZone,
    IN      PIP_ARRAY       aipMasters,
    IN      BOOL            fLocalMasters
    )
/*++

Routine Description:

    Set zone's master servers. Some zone types (currently only stub
    zones) may support local (registry) versus global (DS) master
    server lists.

Arguments:

    pZone -- zone

    aipMasters -- array of master servers IP addresses

    fLocalMasters -- setting local or DS-integrated master list

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PIP_ARRAY       pipNewMasters = NULL;
    PIP_ARRAY *     ppipMasters = NULL;
    //  PIP_ARRAY   infoArray = NULL;

    ASSERT( pZone );
    ASSERT( pZone->pszZoneName );

    //
    //  if primary -- MUST be clearing master info
    //

    if ( IS_ZONE_PRIMARY( pZone ) )
    {
        ASSERT( !aipMasters );
        pipNewMasters = NULL;
        goto Update;
    }

    //
    //  secondary -- MUST have at least one master
    //  forwarding zones may also have master IP lists
    //  stub zones may have a NULL or empty list
    //

    if ( !IS_ZONE_SECONDARY( pZone ) && !IS_ZONE_FORWARDER( pZone ) )
    {
         return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    if ( !aipMasters || !aipMasters->AddrCount || !aipMasters->AddrArray )
    {
        return DNS_ERROR_ZONE_REQUIRES_MASTER_IP;
    }

    status = Zone_ValidateMasterIpList( aipMasters );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    //
    //  copy master addresses
    //

    if ( aipMasters && aipMasters->AddrCount )
    {
        pipNewMasters = Dns_CreateIpArrayCopy( aipMasters );
        IF_NOMEM( !pipNewMasters )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
    }

    //
    //  alloc \ clear master info array
    //  JJW: I think this is leftover code - safe to kill it?
    //

    /*
    infoArray = Dns_CreateIpArrayCopy( aipMasters );
    IF_NOMEM( !infoArray )
    {
        FREE_HEAP( newMasters );
        return( DNS_ERROR_NO_MEMORY );
    }
    Dns_ClearIpArray( infoArray );
    */


Update:

    //
    //  reset master info
    //

    Zone_UpdateLock( pZone );
    ppipMasters = fLocalMasters ?
                    &pZone->aipLocalMasters :
                    &pZone->aipMasters;
    Timeout_Free( *ppipMasters );
    //  Timeout_Free( pZone->MasterInfoArray );
    *ppipMasters = pipNewMasters;
    //  pZone->MasterInfoArray = infoArray;

    //
    //  set registry values
    //

    if ( g_bRegistryWriteBack )
    {
        Reg_SetIpArray(
            NULL,
            pZone,
            fLocalMasters ?
                DNS_REGKEY_ZONE_LOCAL_MASTERS :
                DNS_REGKEY_ZONE_MASTERS,
            pipNewMasters );
    }

    Zone_UpdateUnlock( pZone );
    return( status );
}



DNS_STATUS
Zone_SetSecondaries(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           fSecureSecondaries,
    IN      PIP_ARRAY       aipSecondaries,
    IN      DWORD           fNotifyLevel,
    IN      PIP_ARRAY       aipNotify
    )
/*++

Routine Description:

    Set zone's secondaries.

Arguments:

    pZone -- zone

    fSecureSecondaries -- only transfer to given secondaries

    fNotifyLevel -- level of notifies;  include all NS?

    aipSecondaries -- IP array of secondaries

    aipNotify -- IP array of secondaries to notify

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    PIP_ARRAY   pnewSecondaries = NULL;
    PIP_ARRAY   pnewNotify = NULL;

    ASSERT( pZone );
    ASSERT( pZone->pszZoneName );
    ASSERT( !IS_ZONE_CACHE(pZone) );

    DNS_DEBUG( RPC, (
        "Zone_SetSecondaries( %s )\n",
        pZone->pszZoneName ));
    IF_DEBUG( RPC )
    {
        DnsDbg_IpArray( "Secondaries:\n", NULL, aipSecondaries );
        DnsDbg_IpArray( "Notify list:\n", NULL, aipNotify );
    }

    //
    //  Screen IP addresses
    //

    if ( aipSecondaries &&
        RpcUtil_ScreenIps( 
                aipSecondaries->AddrCount,
                aipSecondaries->AddrArray,
                DNS_IP_ALLOW_SELF,
                NULL ) != ERROR_SUCCESS )
    {
        return DNS_ERROR_INVALID_IP_ADDRESS;
    }
    if ( aipNotify &&
        RpcUtil_ScreenIps( 
                aipNotify->AddrCount,
                aipNotify->AddrArray,
                0,
                NULL ) != ERROR_SUCCESS )
    {
        return DNS_ERROR_INVALID_IP_ADDRESS;
    }

    //
    //  validate \ copy secondary and notify addresses
    //
    //      - secondaries can include local IP
    //      - screen local IP from notify to avoid self-send
    //          (will return error, but continue)
    //

    pnewSecondaries = aipSecondaries;
    if ( pnewSecondaries )
    {
        pnewSecondaries = Dns_CreateIpArrayCopy( aipSecondaries );
        if ( ! pnewSecondaries )
        {
            return DNS_ERROR_INVALID_IP_ADDRESS;
        }
    }
    pnewNotify = aipNotify;
    if ( pnewNotify )
    {
        DWORD   dwOrigAddrCount = pnewNotify->AddrCount;

        pnewNotify = Config_ValidateAndCopyNonLocalIpArray( pnewNotify );
        if ( ! pnewNotify )
        {
            FREE_HEAP( pnewSecondaries );
            return( DNS_ERROR_INVALID_IP_ADDRESS );
        }
        if ( dwOrigAddrCount != pnewNotify->AddrCount )
        {
            DNS_DEBUG( RPC, (
                "notify list had invalid address (probably local)\n" ));
            FREE_HEAP( pnewSecondaries );
            FREE_HEAP( pnewNotify );
            return( DNS_ERROR_INVALID_IP_ADDRESS );
        }
    }

    //
    //  reset secondary info
    //

    Zone_UpdateLock( pZone );

    pZone->fSecureSecondaries = (UCHAR) fSecureSecondaries;
    pZone->fNotifyLevel = (UCHAR) fNotifyLevel;

    Timeout_Free( pZone->aipSecondaries );
    Timeout_Free( pZone->aipNotify );

    pZone->aipSecondaries = pnewSecondaries;
    pZone->aipNotify = pnewNotify;

    //
    //  set registry values
    //

    if ( g_bRegistryWriteBack )
    {
        Reg_SetDwordValue(
            NULL,
            pZone,
            DNS_REGKEY_ZONE_SECURE_SECONDARIES,
            (DWORD) fSecureSecondaries
            );
        Reg_SetDwordValue(
            NULL,
            pZone,
            DNS_REGKEY_ZONE_NOTIFY_LEVEL,
            (DWORD) fNotifyLevel
            );
        Reg_SetIpArray(
            NULL,
            pZone,
            DNS_REGKEY_ZONE_NOTIFY_LIST,
            pnewNotify );
        Reg_SetIpArray(
            NULL,
            pZone,
            DNS_REGKEY_ZONE_SECONDARIES,
            pnewSecondaries );
    }

    Zone_UpdateUnlock( pZone );

    return( status );
}



DNS_STATUS
Zone_ResetType(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwZoneType,
    IN      PIP_ARRAY       aipMasters
    )
/*++

Routine Description:

    Change zone type.

Arguments:

    pZone           --  zone
    dwZoneType      --  new zone type
    cMasters        --  count of master servers
    aipMasters      --  array of IP addresses of zone's masters

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       dwOldZoneType;

    //
    //  save old type -- can't be cache
    //

    dwOldZoneType = pZone->fZoneType;
    if ( dwOldZoneType == DNS_ZONE_TYPE_CACHE ||
         dwZoneType == DNS_ZONE_TYPE_CACHE )
    {
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    //
    //  Implementation note:
    //  for DS we now must make changes and verify they'll work
    //  before calling this routine which writes to registry
    //
    //  hence we may have changed type even though types match, so
    //  do NOT want to special case type change\no-change
    //

    //  lock
    //      -- avoid getting caught in XFR or admin update

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        return( DNS_ERROR_ZONE_LOCKED );
    }

    //
    //  Primary zone -- promoting secondary
    //      => MUST have SOA
    //      => MUST have file or DS
    //

    if ( dwZoneType == DNS_ZONE_TYPE_PRIMARY )
    {
        if ( !pZone->pszDataFile && !pZone->fDsIntegrated )
        {
            status = DNS_ERROR_PRIMARY_REQUIRES_DATAFILE;
            goto Done;
        }
        status = Zone_GetZoneInfoFromResourceRecords( pZone );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }

        //  write new type to registry

        status = Reg_SetDwordValue(
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_TYPE,
                    dwZoneType );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
        pZone->fZoneType = (CHAR) dwZoneType;

        //  clear master list

        status = Zone_SetMasters(
                    pZone,
                    NULL,
                    FALSE );        //  set global masters
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( FALSE );
            goto Done;
        }

        //  update again as primary, then send NOTIFY
        //  point primary field in SOA to this box

        Zone_GetZoneInfoFromResourceRecords( pZone );
        Zone_SetSoaPrimaryToThisServer( pZone );
        Xfr_SendNotify( pZone );
    }

    //
    //  Secondary zone
    //      - reset masters first (secondary must have masters, let
    //      (master reset routine do check)
    //      - reset type
    //      - start secondary thread, if first secondary
    //
    //  secondary MUST have masters;  letting set master routine do checks,
    //  but restore previous zone type on error
    //

    else if ( dwZoneType == DNS_ZONE_TYPE_SECONDARY
                || dwZoneType == DNS_ZONE_TYPE_STUB
                || dwZoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        pZone->fZoneType = (CHAR) dwZoneType;

        status = Zone_SetMasters(
                    pZone,
                    aipMasters,
                    FALSE );        //  set global masters

        if ( status != ERROR_SUCCESS )
        {
            pZone->fZoneType = (CHAR) dwOldZoneType;
            goto Done;
        }

        //  write new type to registry

        status = Reg_SetDwordValue(
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_TYPE,
                    dwZoneType );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }

        //
        //  changing to secondary
        //      - must init secondary for transfer checks
        //      - must make sure secondary zone control running
        //      - if forwarder, do not init secondary zone stuff
        //

        if ( !IS_ZONE_FORWARDER( pZone ) )
        {
            Xfr_InitializeSecondaryZoneTimeouts( pZone );
            Xfr_InitializeSecondaryZoneControl();
        }
    }
    else
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Done;
    }

    //
    //  type change requires boot file update
    //

    Config_UpdateBootInfo();
    status = ERROR_SUCCESS;

Done:

    Zone_UnlockAfterAdminUpdate( pZone );
    return( status );
}



VOID
Zone_SetAgingDefaults(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Set or reset aging defaults for zone.

Arguments:

    pZone --  ptr to zone

Return Value:

    None

--*/
{
    BOOL    bnewAging;

    if ( ! IS_ZONE_PRIMARY(pZone) )
    {
        pZone->bAging = FALSE;
        return;
    }

    //
    //  for primary zones, will always set refresh intervals
    //  set aging based on zone type
    //

    pZone->dwNoRefreshInterval = SrvCfg_dwDefaultNoRefreshInterval;
    pZone->dwRefreshInterval = SrvCfg_dwDefaultRefreshInterval;

    if ( pZone->fDsIntegrated )
    {
        bnewAging = !!(SrvCfg_fDefaultAgingState & DNS_AGING_DS_ZONES);
    }
    else
    {
        bnewAging = !!(SrvCfg_fDefaultAgingState & DNS_AGING_NON_DS_ZONES);
    }

    if ( bnewAging  &&  !pZone->bAging )
    {
        pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();
    }

    pZone->bAging = bnewAging;
}



//
//  Public server zone run-time utilities
//

DNS_STATUS
Zone_ValidateMasterIpList(
    IN      PIP_ARRAY       aipMasters
    )
/*++

Routine Description:

    Validate master IP list.
    This validation is
        -- entries exist
        -- IPs are valid (not broadcast)
        -- not self-send

Arguments:

    pZone -- zone

    aipMasters -- list of zone masters

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PIP_ARRAY   pintersectionAddrs = NULL;
    PIP_ARRAY   pmachineAddrs;
    DNS_STATUS  status = ERROR_SUCCESS;

    //  must have at least one master IP

    if ( !aipMasters )
    {
        return DNS_ERROR_ZONE_REQUIRES_MASTER_IP;
    }

    //
    //  Screen IP addresses
    //

    if ( RpcUtil_ScreenIps( 
                aipMasters->AddrCount,
                aipMasters->AddrArray,
                0,
                NULL ) != ERROR_SUCCESS )
    {
        status = DNS_ERROR_INVALID_IP_ADDRESS;
        goto Done;
    }

    //  must be valid IP (not loopback, broadcast, zero, etc.)

    if ( ! Dns_ValidateIpAddressArray(
                aipMasters->AddrArray,
                aipMasters->AddrCount,
                0 ) )
    {
        status = DNS_ERROR_INVALID_IP_ADDRESS;
        goto Done;
    }

    //  verify that there is NO intersection between master list and
    //  the addresses for this machine
    //  (i.e. do not allow self-send)

    if ( pmachineAddrs = g_ServerAddrs )
    {
        status = Dns_IntersectionOfIpArrays(
                    aipMasters,
                    pmachineAddrs,
                    & pintersectionAddrs );

        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
        if ( pintersectionAddrs->AddrCount != 0 )
        {
            status = DNS_ERROR_INVALID_IP_ADDRESS;
        }
    }

Done:

    FREE_HEAP( pintersectionAddrs );

    return status;
}



INT
Zone_SerialNoCompare(
    IN      DWORD           dwSerial1,
    IN      DWORD           dwSerial2
    )
/*++

Routine Description:

    Determine if Serial1 greater than Serial2.

Arguments:

Return Value:

    Version difference in wrapped DWORD sense:
        > 0 if dwSerial1 is greater than dwSerial2.
        0   if dwSerial1 == dwSerial2
        < 0 if dwSerial2 is greater than dwSerial1.

    A difference > 0x80000000 is considered to negative (serial2 > serial1)

    //  DEVNOTE: serial number compare
    //  The macro below is not correct.  The idea is to DO a DWORD compare inorder
    //  to handle wrapping and switch into high numbers (>0x80000000)
    //  appropriately, but interpret the result as integer to get less\greater
    //  comparison correct.
    //
    //
    // Alternative approch:
    // #define ZONE_SERIALNOCOMPARE(s1, s2) (s2 > s1: -1: s1 == s2: 0: 1 )
    // don't have to deal w/ type truncation & skipping a func call compensate
    // for the extra comparison. post Beta.
    //
--*/
{
    INT   serialDiff;

    serialDiff = (INT)(dwSerial1 - dwSerial2);
    return ( serialDiff );
}



BOOL
Zone_IsIxfrCapable(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Determine if IXFR capable zone.

    This used to determine if necessary to keep around zone update list.

Arguments:

    pZone -- zone to check

Return Value:

    TRUE if zone can do IXFR.
    FALSE otherwise.

--*/
{
    //  no XFR period

    if ( pZone->fSecureSecondaries == ZONE_SECSECURE_NO_XFR )
    {
        return( FALSE );
    }

    //  XFR allowed
    //      - if non-DS, then IXFR always ok
    //      - if DS, then must have done XFR since load before allow IXFR

    if ( !pZone->fDsIntegrated )
    {
        return( TRUE );
    }

    return( pZone->dwLastXfrSerialNo != 0 );
}



VOID
Zone_ResetVersion(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwNewSerial
    )
/*++

Routine Description:

    Reset zone version to given value.

Arguments:

    pZone -- zone to increment version

    dwNewSerial -- new serial number to set

Return Value:

    None

--*/
{
    DWORD   serialNo = pZone->dwSerialNo;

    ASSERT( IS_ZONE_LOCKED_FOR_UPDATE(pZone) );
    ASSERT( pZone->pSoaRR || IS_ZONE_CACHE( pZone ) || IS_ZONE_NOTAUTH( pZone ) );
    ASSERT( Zone_SerialNoCompare(dwNewSerial, pZone->dwSerialNo) >= 0 );

    if ( !pZone->pSoaRR )
    {
        return;
    }

    pZone->fDirty = TRUE;

    if ( pZone->dwSerialNo != dwNewSerial &&
         !IS_ZONE_CACHE ( pZone ) )
    {
        INLINE_DWORD_FLIP( pZone->pSoaRR->Data.SOA.dwSerialNo, dwNewSerial );
        pZone->dwSerialNo = dwNewSerial;
    }
}



VOID
Zone_IncrementVersion(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Update zone version.

    Use when admin adds, changes or deletes records in zone.

Arguments:

    pZone -- zone to increment version

    fForce -- TRUE to force increment even if not required

Return Value:

    None

--*/
{
    DWORD   serialNo = pZone->dwSerialNo;

    DNS_DEBUG( UPDATE2, (
        "Zone_IncrementVersion( %s ) serial %d\n",
        pZone->pszZoneName,
        serialNo ));

    ASSERT( IS_ZONE_PRIMARY(pZone) );
    ASSERT( IS_ZONE_LOCKED_FOR_UPDATE(pZone) );
    ASSERT( pZone->pSoaRR );

    serialNo++;
    if ( serialNo == 0 )
    {
        serialNo = 1;
    }
    Zone_ResetVersion( pZone, serialNo );
}



VOID
Zone_UpdateVersionAfterDsRead(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwVersionRead,
    IN      BOOL            fLoad,
    IN      DWORD           dwPreviousSerial
    )
/*++

Routine Description:

    Update zone version after the zone has been read from the DS.

Arguments:

    pZone -- zone written to file

    dwVersionRead -- highest version read from DS

    fLoad -- TRUE if at initial load, FALSE otherwise

    dwPreviousSerial -- if reload, last serial of previous load

Return Value:

    None

--*/
{
    DWORD   serialNo;
    BOOL    bforcedIncrement = FALSE;
    DWORD   dwsyncLevel = ZONE_SERIAL_SYNC_READ;

    DNS_DEBUG( UPDATE, (
        "Zone_UpdateVersionAfterDsRead( %s )\n"
        "\tdwVersionRead        = %d\n"
        "\tfLoad,               = %d\n"
        "\tdwPreviousSerial     = %d\n",
        pZone->pszZoneName,
        dwVersionRead,
        fLoad,
        dwPreviousSerial ));

    //
    //  if zone load, just use highest serial number read
    //
    //  note:  on serial and secondaries
    //      on reload we have no guarantee that were going to get back to
    //      the previous IN-MEMORY serial number we gave out in XFR, as we
    //      don't know if our IN-MEMORY serial number had been driven above
    //      the max DS serial number;  there is no way to fix this here
    //      (barring stable storage like registry read);  the solution is
    //      to write back last serial number we gave out in XFR PLUS one
    //      to the DS on shutdown or before reload (see ds.c)
    //
    //  however if we do a rebootless reload, we can at least make sure we
    //  get back to something greater than the the previous serial number we
    //

    if ( fLoad )
    {
        serialNo = dwVersionRead;

        //  rebootless reload
        //  if reloading zone, then MUST make sure serial is at least as
        //      large as previous version or secondary can be confused

        if ( dwPreviousSerial &&
            pZone->fSecureSecondaries != ZONE_SECSECURE_NO_XFR &&
            Zone_SerialNoCompare( dwPreviousSerial, serialNo ) >= 0 )
        {
            serialNo = dwPreviousSerial + 1;
            if ( serialNo == 0 )
            {
                serialNo = 1;
            }

            //
            //  Force increment with SHUTDOWN priority so that if the
            //  server is DC is shutdown immediately the serial number
            //  does not walk backwards.
            //

            bforcedIncrement = TRUE;
            dwsyncLevel = ZONE_SERIAL_SYNC_SHUTDOWN;
        }
        else if ( pZone->dwSerialNo != 0 &&
            Zone_SerialNoCompare(pZone->dwSerialNo, serialNo) >= 0 )
        {
            serialNo = pZone->dwSerialNo;
        }
        pZone->dwLoadSerialNo = serialNo;
    }

    //
    //  DS update
    //      -- serial read is larger than current => use it
    //      -- otherwise
    //          -- if supporting secondaries, increment when required
    //          -- otherwise keep at current
    //
    //  "supporting secondaries" then increment if
    //      - XFR NOT disabled
    //      - have sent an XFR on this serial or at load serial
    //
    //  In pure DS installation, there's no need to ever "push" in memory serial
    //  above highest serial in DS.  Serial in DS will be >= highest of last serial read
    //  or written to DS.  Hence serial's on all machines will converge after replication
    //  and poll, and will be preserved across reboot.
    //
    //  Note, even if have secondaries, it is wise to SUPPRESS pushing in memory serial
    //  up when possible.  That way a zone doesn't "walk" away from DS serial very far
    //  and hence the zone will not recover to it's previous in memory value, more
    //  quickly after a reboot, and the secondary will be in ssync faster.
    //

    else
    {
        ASSERT( IS_ZONE_LOCKED_FOR_UPDATE(pZone) );

        serialNo = pZone->dwSerialNo;
        if ( dwVersionRead  &&  Zone_SerialNoCompare(dwVersionRead, serialNo) > 0 )
        {
            serialNo = dwVersionRead;
        }
        else if ( pZone->fSecureSecondaries != ZONE_SECSECURE_NO_XFR &&
                  ( HAS_ZONE_VERSION_BEEN_XFRD( pZone ) ||
                    serialNo == pZone->dwLoadSerialNo ) )
        {
            serialNo++;
            if ( serialNo == 0 )
            {
                serialNo = 1;
            }
            bforcedIncrement = TRUE;
        }
        else
        {
            DNS_DEBUG( DS, (
                "Suppressing version update (no secondaries) on zone %s after DS read.\n"
                "\tnew serial           = %d\n"
                "\tcurrent              = %d\n"
                "\tsent XFR serial      = %d\n",
                pZone->pszZoneName,
                dwVersionRead,
                serialNo,
                pZone->dwLastXfrSerialNo ));
            return;
        }
    }

    DNS_DEBUG( DS, (
        "Updating version to %d after DS read.\n",
        serialNo ));

    Zone_ResetVersion( pZone, serialNo );

    //
    //  if configured, push serial back to DS
    //

    if ( bforcedIncrement )
    {
        Ds_CheckForAndForceSerialWrite( pZone, dwsyncLevel );
    }
}



VOID
updateZoneSoa(
    IN OUT  PZONE_INFO      pZone,
    IN      PDB_RECORD      pSoaRR
    )
/*++

Routine Description:

    Update zone's information for new SOA record.
    Should be called whenever zone SOA record is read in or
    updated.

    Save a ptr to SOA in zone block, and host byte order
    version of serial number to speed access.

Arguments:

    pZone - zone to update

    pSoaRR - new SOA RR

Return Value:

    None.

--*/
{
    DWORD   serialNo;
    BOOL    floading;

    ASSERT( pZone );

    //
    //  save ptr to SOA
    //  get SOA's serial
    //

    pZone->pSoaRR = pSoaRR;

    INLINE_DWORD_FLIP( serialNo, pSoaRR->Data.SOA.dwSerialNo );

    //
    //  refuse to move SOA serial forward
    //
    //  for DS zones, we do not continually advance SOA in DS to avoid
    //  unnecessary replication traffic
    //
    //  however we still keep in-memory serial advancing, to allow XFR to
    //  non-DS zones;
    //  hence, pick up SOA serial only if higher than current serial
    //
    //  will also do this on non-DS zones to handle case where someone
    //  sends in record from admin with non-refreshed SOA, while zone
    //  serial has changed underneath
    //

    //  use zone's current serial, if it is higher than new value

    if ( pZone->dwLoadSerialNo  &&
        Zone_SerialNoCompare(pZone->dwSerialNo, serialNo) > 0 )
    {
        serialNo = pZone->dwSerialNo;
        INLINE_DWORD_FLIP( pSoaRR->Data.SOA.dwSerialNo, serialNo );
    }

    //
    //  save version in host byte order for fast compares
    //

    pZone->dwSerialNo = serialNo;

    //
    //  loading?
    //
    //  if this is first version of zone loaded, then set load version
    //  to this current version;  load version is limit on secondary
    //  versions we can handle with incremental transfer
    //

    floading = FALSE;
    if ( pZone->dwLoadSerialNo == 0 )
    {
        floading = TRUE;
        pZone->dwLoadSerialNo = serialNo;
    }

    //
    //  save default TTL for setting NEW records below
    //

    pZone->dwDefaultTtl = pSoaRR->Data.SOA.dwMinimumTtl;
    pZone->dwDefaultTtlHostOrder = ntohl( pZone->dwDefaultTtl );

    //
    //  for DS, set SOA primary to be THIS server
    //  since every DS-integrated zone is primary, we need to do this
    //  for DS primaries, as SOA in DS may have different server as primary
    //
    //  also do any primary zone on DNS boot, to catch possible name change
    //      messing up server boot
    //

    if ( pZone->fDsIntegrated )
    {
        Zone_SetSoaPrimaryToThisServer( pZone );
    }

    //
    //  on load, check all default records on primary
    //      - server name change
    //      - IP change
    //
    //  DEVNOTE: do we need to be more intelligent here for reloads?
    //

    if ( floading && IS_ZONE_PRIMARY(pZone) )
    {
        Zone_CheckAndFixDefaultRecordsOnLoad( pZone );
    }

    IF_DEBUG( READ2 )
    {
        Dbg_DbaseRecord(
            "SOA RR after read into zone:",
            pZone->pSoaRR );
    }
}



VOID
Zone_UpdateInfoAfterPrimaryTransfer(
    IN OUT  PZONE_INFO  pZone,
    IN      DWORD       dwStartTime
    )
/*++

Routine Description:

    Update next available transfer time after doing AXFR.

Arguments:

    pZone -- zone that was transferred

Return Value:

    None

--*/
{
    DWORD   endTime;
    DWORD   chokeTime;

    ASSERT( pZone );
    ASSERT( IS_ZONE_PRIMARY(pZone) );
    ASSERT( IS_ZONE_LOCKED_FOR_READ(pZone) );
    ASSERT( pZone->pSoaRR );

    //
    //  for updateable zones need to limit AXFRs from holding lock too long
    //
    //  calculate transfer interval and choke AXFR for some time interval based
    //  on length of transfer just completed
    //

    endTime = DNS_TIME();

    chokeTime = (endTime - dwStartTime) * AXFR_CHOKE_FACTOR;
    if ( chokeTime > MAX_AXFR_CHOKE_INTERVAL )
    {
        ASSERT( (INT)chokeTime >= 0 );
        DNS_DEBUG( ANY, ( "WARNING:  choke interval exceeds max choke interval.\n" ));
        chokeTime = MAX_AXFR_CHOKE_INTERVAL;
    }
    pZone->dwNextTransferTime = endTime + chokeTime;

    DNS_DEBUG( AXFR, (
        "Zone transfer of %s completed.\n",
        "\tversion          = %d\n"
        "\tstart            = %d\n"
        "\tend              = %d\n"
        "\tchoke interval   = %d\n"
        "\treopen time      = %d\n"
        "\tRR count         = %d\n",
        pZone->pszZoneName,
        pZone->dwSerialNo,
        dwStartTime,
        endTime,
        chokeTime,
        pZone->dwNextTransferTime,
        pZone->iRRCount ));
}



DNS_STATUS
Zone_GetZoneInfoFromResourceRecords(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Extract info from RR that is used in ZONE_INFO structure.

Arguments:

    pZone -- zone update zone info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_RECORD      prr;

    ASSERT( pZone );

    if ( IS_ZONE_CACHE(pZone) )
    {
        return( ERROR_SUCCESS );
    }
    ASSERT( pZone->pZoneRoot );
    ASSERT( IS_ZONE_PRIMARY(pZone) ||
            IS_ZONE_SECONDARY(pZone) ||
            IS_ZONE_FORWARDER(pZone) );

    //
    //  should already have zone update lock
    //      - either loading zone
    //      - XFR zone
    //      - updating zone
    //
    //  DEVNOTE: temporarily taking lock again;  should
    //      switch to ASSERTing ownership of zone write lock
    //

    ASSERT( IS_ZONE_LOCKED_FOR_WRITE_BY_THREAD(pZone) );

    if ( !Zone_LockForUpdate( pZone ) )
    {
        ASSERT( FALSE );
    }

    DNS_DEBUG( UPDATE, (
        "Zone_GetZoneInfoFromResourceRecords() for zone %s.\n"
        "\tfRootDirty = %d\n",
        pZone->pszZoneName,
        pZone->fRootDirty ));

    //
    //  find SOA
    //      - if not found on primary zone, create one
    //      this can happen if read corrupted SOA from DS
    //

    prr = RR_FindNextRecord(
                pZone->pZoneRoot,
                DNS_TYPE_SOA,
                NULL,
                0 );
    if ( !prr )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Zone %s has no SOA record.\n",
            pZone->pszZoneName ));

        if ( !IS_ZONE_PRIMARY(pZone) )
        {
            status = DNS_ERROR_ZONE_HAS_NO_SOA_RECORD;
            goto ZoneError;
        }

        status = Zone_CreateDefaultSoa(
                    pZone,
                    NULL        // default admin name
                    );
        if ( status != ERROR_SUCCESS )
        {
            status = DNS_ERROR_ZONE_HAS_NO_SOA_RECORD;
            goto ZoneError;
        }
        prr = RR_FindNextRecord(
                    pZone->pZoneRoot,
                    DNS_TYPE_SOA,
                    NULL,
                    0 );
        if ( !prr )
        {
            status = DNS_ERROR_ZONE_HAS_NO_SOA_RECORD;
            ASSERT( FALSE );
            goto ZoneError;
        }
    }

    updateZoneSoa( pZone, prr );

    //
    //  Set\reset zone WINS\WINSR lookup
    //      - load
    //      - admin update
    //      - XFR recv
    //  may all change WINS record to be used
    //

    Wins_ResetZoneWinsLookup( pZone );

    //
    //  NS list for notify \ secure secondaries
    //
    //  DEVNOTE: NS isn't necessarily dirty when root is dirty
    //      should set in update
    //

    MARK_ZONE_NS_DIRTY( pZone );

    //  reset flag indicating zone root has outstanding update

    pZone->fRootDirty = FALSE;

    DNS_DEBUG( UPDATE, (
        "Leaving Zone_GetZoneInfoFromResourceRecords( %s ).\n",
        pZone->pszZoneName ));

    Zone_UnlockAfterAdminUpdate( pZone );
    return( ERROR_SUCCESS );

ZoneError:

    DNS_DEBUG( ANY, (
        "ERROR:  Zone_GetZoneInfoFromResourceRecords( %s ) failed!\n",
        pZone->pszZoneName ));

    Zone_UnlockAfterAdminUpdate( pZone );
    return( status );
}



VOID
Zone_WriteBack(
    IN      PZONE_INFO      pZone,
    IN      BOOL            fShutdown
    )
/*++

Routine Description:

    Write the zone back to DS or file, depending on the zone configuration.

    Write only if:
        - cache zone (because updates not tracked)
        - dirty
        - not locked OR shutdown flag FALSE

Arguments:

    pZone - zone to write back

    fShutdown - TRUE if the server is shutting down, some behavior is
        slightly different (ie. zone locks ignored and DS zones forced)

Return Value:

    None.

--*/
{
    if ( !pZone )
    {
        return;
    }

    DNS_DEBUG( INIT, (
        "Zone_WriteBack( %S, fShutdown=%d )\n"
        "\ttype     = %d\n"
        "\tfile     = %S\n"
        "\tdirty    = %d\n",
        pZone->pwsZoneName,
        ( int ) fShutdown,
        pZone->fZoneType,
        pZone->pwsDataFile,
        pZone->fDirty ));

    IF_DEBUG( OFF )
    {
        Dbg_Zone(
            "Zone_WriteBack",
            pZone );
    }

    //
    //  do NOT have "updates" for cache zone, so (unlike regular zones)
    //      when root-hints dirty must write to DS as well as file
    //
    //  note:  AutoCacheUpdate, currently unsupported, if later
    //      supported then must write shutdown when it's on
    //

    if ( IS_ZONE_CACHE( pZone ) )
    {
        Zone_WriteBackRootHints(
            FALSE );                // don't write if not dirty
    }
    else
    {
        //
        //  DS zones. DS updates are made during update no write needed.
        //

        if ( pZone->fDsIntegrated )
        {
            if ( fShutdown )
            {
                Ds_CheckForAndForceSerialWrite(
                    pZone,
                    ZONE_SERIAL_SYNC_SHUTDOWN );
            }
        }

        //
        //  non-DS authoriative zones
        //      -- write back and notify if dirty
        //
        //  note, write back first, so that zone is NOT LOCKED when
        //  AXFR request comes in in response to NOTIFY
        //

        else if ( pZone->fDirty )
        {
            if ( fShutdown || !IS_ZONE_LOCKED( pZone ) )
            {
                File_WriteZoneToFile(
                    pZone,
                    NULL );
            }
            if ( !fShutdown )
            {
                Xfr_SendNotify(
                    pZone );
            }
        }
    }
}   //  Zone_WriteBack



VOID
Zone_WriteBackDirtyZones(
    IN      BOOL            fShutdown
    )
/*++

Routine Description:

    Write dirty zones back to file.

    Called on shutdown or by timeout thread.

Arguments:

    fShutdown - TRUE if the server is shutting down

Return Value:

    None

--*/
{
    PZONE_INFO pzone = NULL;

    DNS_DEBUG( INIT, (
        "Zone_WriteBackDirtyZones( fShutdown=%d )\n",
        ( int ) fShutdown ));

    while ( pzone = Zone_ListGetNextZone( pzone ) )
    {
        Zone_WriteBack( pzone, fShutdown );
    }
}   //  Zone_WriteBackDirtyZones



DNS_STATUS
Zone_WriteZoneToRegistry(
    PZONE_INFO      pZone
    )
/*++

Routine Description:

    Writes all parameters for the zone to the registry.

Arguments:

    pZone -- zone to rewrite to registry

Return Value:

    ERROR_SUCCESS or error code on error.

--*/
{
    DNS_STATUS      rc = ERROR_SUCCESS;

    #define CHECK_STATUS( rcode ) if ( rcode != ERROR_SUCCESS ) goto Done

    //
    //  Do nothing for auto-created zones.
    //

    if ( pZone->fAutoCreated )
    {
        goto Done;
    }

    DNS_DEBUG( REGISTRY, (
        "Rewriting zone %S (type %d) to registry\n",
        pZone->pwsZoneName,
        pZone->fZoneType ));

    //
    //  Cache zone.
    //

    if ( IS_ZONE_CACHE( pZone ) )
    {
        if ( IS_ZONE_DSINTEGRATED( pZone ) ||
            wcsicmp_ThatWorks( pZone->pwsDataFile,
                DNS_DEFAULT_CACHE_FILE_NAME ) == 0 )
        {
            rc = Reg_DeleteValue(
                    NULL,
                    NULL,
                    DNS_REGKEY_ROOT_HINTS_FILE );
            CHECK_STATUS( rc );
        }
        else
        {
            rc = Reg_SetValue(
                    NULL,
                    NULL,
                    DNS_REGKEY_ROOT_HINTS_FILE_PRIVATE,
                    DNS_REG_WSZ,
                    pZone->pwsDataFile,
                    0 );
            CHECK_STATUS( rc );
        }
        goto Done;
    }
    
    //
    //  Regular zone (not cache zone).
    //

    rc = Reg_SetDwordValue(
            NULL,
            pZone,
            DNS_REGKEY_ZONE_TYPE,
            pZone->fZoneType );
    CHECK_STATUS( rc );

    if ( IS_ZONE_DSINTEGRATED( pZone ) )
    {
        rc = Reg_SetDwordValue(
                NULL,
                pZone,
                DNS_REGKEY_ZONE_DS_INTEGRATED,
                pZone->fDsIntegrated );
        CHECK_STATUS( rc );
        rc = Reg_DeleteValue(
                NULL,
                pZone,
                DNS_REGKEY_ZONE_FILE );
        CHECK_STATUS( rc );
    }
    else
    {
        if ( pZone->pszDataFile )
        {
            rc = Reg_SetValue(
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FILE_PRIVATE,
                    DNS_REG_WSZ,
                    pZone->pwsDataFile,
                    0 );
            CHECK_STATUS( rc );
        }
        else
        {
            rc = Reg_DeleteValue(
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FILE );
            CHECK_STATUS( rc );
        }
        if ( IS_ZONE_FORWARDER( pZone ) )
        {
            rc = Reg_SetDwordValue(
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FWD_TIMEOUT,
                    pZone->dwForwarderTimeout );
            CHECK_STATUS( rc );
            rc = Reg_SetDwordValue(
                    NULL,
                    pZone,
                    DNS_REGKEY_ZONE_FWD_SLAVE,
                    pZone->fForwarderSlave );
            CHECK_STATUS( rc );
        }
        rc = Reg_DeleteValue(
                NULL,
                pZone,
                DNS_REGKEY_ZONE_DS_INTEGRATED );
        CHECK_STATUS( rc );
    }

    //
    //  Secondary parameters.
    //

    rc = Reg_SetDwordValue(
            NULL,
            pZone,
            DNS_REGKEY_ZONE_SECURE_SECONDARIES,
            ( DWORD ) pZone->fSecureSecondaries );
    CHECK_STATUS( rc );
    rc = Reg_SetDwordValue(
            NULL,
            pZone,
            DNS_REGKEY_ZONE_NOTIFY_LEVEL,
            ( DWORD ) pZone->fNotifyLevel );
    CHECK_STATUS( rc );
    rc = Reg_SetIpArray(
            NULL,
            pZone,
            DNS_REGKEY_ZONE_NOTIFY_LIST,
            pZone->aipNotify );
    CHECK_STATUS( rc );
    rc = Reg_SetIpArray(
            NULL,
            pZone,
            DNS_REGKEY_ZONE_SECONDARIES,
            pZone->aipSecondaries );
    CHECK_STATUS( rc );

    //
    //  Master IP array.
    //

    if ( ZONE_NEEDS_MASTERS( pZone ) )
    {
        rc = Reg_SetIpArray(
                NULL,
                pZone,
                DNS_REGKEY_ZONE_MASTERS,
                pZone->aipMasters );
        CHECK_STATUS( rc );
        rc = Reg_SetIpArray(
                NULL,
                pZone,
                DNS_REGKEY_ZONE_LOCAL_MASTERS,
                pZone->aipLocalMasters );
        CHECK_STATUS( rc );
    }

    Done:

    if ( rc != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR: failed registry write of zone %s (rc=%d)\n",
            pZone->pszZoneName,
            rc ));
    }
    return rc;
} // Zone_WriteZoneToRegistry



DNS_STATUS
Zone_CreateNewPrimary(
    OUT     PZONE_INFO *    ppZone,
    IN      LPSTR           pszZoneName,
    IN      LPSTR           pszAdminEmailName,
    IN      LPSTR           pszFileName,
    IN      DWORD           dwDsIntegrated,
    IN      PDNS_DP_INFO    pDpInfo,            OPTIONAL
    IN      DWORD           dwCreateFlag
    )
/*++

Routine Description:

    Create new primary zone, including
        - zone info (optional)
        - SOA (default values)
        - NS (for this server)

    For use by admin tool or auto-create reverse zone.

Arguments:

    ppZone -- addr of zone ptr;  if zone ptr NULL zone is created
        if zone ptr MUST be existing zone
        or

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PZONE_INFO      pzone;

    DNS_DEBUG( INIT, (
        "Zone_CreateNewPrimary()\n"
        "\tpszZoneName      = %s\n"
        "\tpszAdminEmail    = %s\n"
        "\tdwDsIntegrated   = %d\n"
        "\tpszDataFile      = %s\n"
        "\tdwCreateFlag     = %lx\n",
        pszZoneName,
        pszAdminEmailName,
        dwDsIntegrated,
        pszFileName,
        dwCreateFlag ));

    //
    //  DEVNOTE: delete zone, on primary creation failures?
    //      need zone successfully written back to file to reboot
    //      should delete zone to clear structure from registry
    //      (and memory) if can't reboot
    //

    //
    //  create zone info
    //

    status = Zone_Create(
                &pzone,
                DNS_ZONE_TYPE_PRIMARY,
                pszZoneName,
                0,
                NULL,       // no masters
                dwDsIntegrated,
                pDpInfo,
                pszFileName,
                0,
                NULL,
                NULL );     //  existing zone
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR:  Failed create of new primary zone at %s.\n"
            "\tstatus = %d.\n",
            pszZoneName,
            status ));
        return( status );
    }

    ASSERT( pzone && IS_ZONE_SHUTDOWN(pzone) );

    //
    //  try to load zone from given file or DS
    //      - if fail to find it -- fine
    //      - if failure to parse it return error
    //

    if ( dwCreateFlag & ZONE_CREATE_LOAD_EXISTING )
    {
        status = Zone_Load( pzone );
        if ( status == ERROR_SUCCESS )
        {
            DNS_PRINT((
                "Successfully loaded new zone %s from %s.\n",
                pszZoneName,
                dwDsIntegrated ? "directory" : pszFileName ));
            goto Done;
        }

        //
        //  DEVNOTE: add the error for directory not found?
        //      and make sure test the correct one for each case
        //      perhaps make them the return from Zone_Load()
        //

        else if ( pzone->pszDataFile )
        {
            if ( status != ERROR_FILE_NOT_FOUND )
            {
                DNS_PRINT((
                    "ERROR:  Failure parsing file %s for new primary zone %s.\n",
                    pszFileName,
                    pszZoneName
                    ));
                goto Failed;
            }
        }
        else    // DS integrated
        {
            if ( status != LDAP_NO_SUCH_OBJECT )
            {
                DNS_PRINT((
                    "ERROR:  Reading zone %s from DS.\n",
                    pszFileName,
                    pszZoneName
                    ));
                goto Failed;
            }
        }

        //  for NT4 compatibility allow drop down to default create
        //  even after load failure

        if ( ! (dwCreateFlag & ZONE_CREATE_DEFAULT_RECORDS) )
        {
            DNS_PRINT((
                "ERROR:  Failed loading zone %s.  File or directory not found.\n",
                pszZoneName
                ));
            goto Failed;
        }
    }

    //
    //  setup zone for load
    //      - can fail on bogus zone name
    //

    status = Zone_PrepareForLoad( pzone );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    //
    //  Set zone flag to disable auto RR creation before we call any
    //  of the auto RR creation functions.
    //

    Zone_SetAutoCreateLocalNS( pzone );

    //
    //  auto-create zone root records
    //
    //  both SOA and NS, will require server name
    //      - must insure FQDN, or will end up with zone name appended
    //

    status = Zone_CreateDefaultSoa(
                pzone,
                pszAdminEmailName );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    status = Zone_CreateDefaultNs( pzone );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }

    //
    //  for loopback zone, create loopback record
    //      => 127.0.0.1 pointing to "localhost"
    //

    if ( ! _stricmp( pszZoneName, "127.in-addr.arpa" ) )
    {
        status = Zone_CreateLocalHostPtrRecord( pzone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "ERROR:  Failed loopback create!\n" ));
            ASSERT( FALSE );
        }
    }

    //  successful default zone creation
    //  start zone up and unlock

    status = Zone_ActivateLoadedZone( pzone );
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        goto Failed;
    }

    //
    //  if NOT auto-reverse
    //
    //  setup zone info from SOA
    //      - ptr to SOA
    //      - version number
    //
    //  write zone to file or DS
    //      - do this here, so NO matter what, if admin has created
    //      zone we have written a file\DS and can successfully reboot
    //

    //
    //  DEVNOTE: no recovery on file write problem with new primary
    //

    if ( !pzone->fAutoCreated )
    {
        if ( pzone->fDsIntegrated )
        {
            status = Ds_WriteZoneToDs( pzone, 0 );
            if ( status != ERROR_SUCCESS )
            {
                DNS_PRINT((
                    "ERROR:  failed to write zone %s to DS.\n"
                    "\tzone create fails, deleting zone.\n",
                    pzone->pszZoneName ));
                goto Failed;
            }
        }
        else
        {
            if ( !File_WriteZoneToFile( pzone, NULL ) )
            {
                //  should never have problem with auto-created records
                //  filename has been tested during zone create
                //  but possible problem with locked file, full disk, etc.

                TEST_ASSERT( FALSE );

                DNS_PRINT((
                    "ERROR:  Writing new primary zone to datafile %s.\n",
                    pzone->pszDataFile
                    ));
                status = DNS_ERROR_FILE_WRITEBACK_FAILED;
                goto Failed;
            }
        }
    }

Done:


    STARTUP_ZONE( pzone );

    //  unlock lock taken in Zone_Create()

    Zone_UnlockAfterAdminUpdate( pzone );

    *ppZone = pzone;
    return( ERROR_SUCCESS );

Failed:

    //  delete zone unless able to completely create
    //      -> wrote SOA
    //      -> wrote back to file or DS (except for non-auto reverse zones)

    DNS_DEBUG( ALL, (
        "ERROR:  Failed to create new primary zone %s\n"
        "\tstatus = %d (%p)\n",
        pzone->pszZoneName,
        status, status ));

    Zone_Delete( pzone );
    return( status );
}



VOID
Zone_CreateDefaultZoneFileName(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Creates default file name for zone, unless this is a forwarder zone.
    Filename is directly added to zone info block.

Arguments:

    pZone -- zone to create file name for

Return Value:

    None.

--*/
{
    WCHAR  wsfileName[ MAX_PATH+2 ];

    ASSERT( pZone );

    wcscpy( wsfileName, pZone->pwsZoneName );
    wcscat( wsfileName, L".dns" );

    pZone->pwsDataFile = Dns_StringCopyAllocate_W(
                            (PCHAR) wsfileName,
                            0 );
}


//
//  End of zone.c
//

#if 0


DNS_STATUS
Zone_ResetZoneProperty(
    IN OUT    PZONE_INFO    pZone,
    IN        LPSTR         pszProperty,
    IN        DWORD         dwLength,
    IN        PVOID         pData
    )
/*++

Routine Description:

    Reset zone DWORD property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD       value;
    DNS_STATUS  status;
    BOOLEAN     boolValue;

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneDwordProperty( %s ):\n",
        pZone->pszZoneName ));

    //  extract property name and value

    ASSERT( dwTypeId == DNSSRV_TYPEID_NAME_AND_PARAM );
    ASSERT( pData );
    pszOperation = ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName;
    value        = ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam;
    boolValue    = (value != 0);

    //  turn on\off update

    if ( strcmp( pszOperation, DNS_REGKEY_ZONE_ALLOW_UPDATE ) == 0 )
    {
        if ( ! IS_ZONE_PRIMARY(pZone) )
        {
            return( DNS_ERROR_INVALID_ZONE_TYPE );
        }
        pZone->fAllowUpdate = (UCHAR) value;
    }

    //  turn on\off secondary security

    else if ( strcmp( pszOperation, DNS_REGKEY_ZONE_SECURE_SECONDARIES ) == 0 )
    {
        pZone->fSecureSecondaries = boolValue;
    }

    //  turn on\off unicode

    else if ( strcmp( pszOperation, DNS_REGKEY_ZONE_UNICODE ) == 0 )
    {
        value = (value != 0);
        pZone->fUnicode = boolValue;
    }

    //  turn on\off update logging

    else if ( strcmp( pszOperation, DNS_REGKEY_ZONE_LOG_UPDATES ) == 0 )
    {
        value = (value != 0);
        pZone->fLogUpdates = boolValue;
    }

    //
    //  changing all other DWORD properties
    //      - type
    //      - secure secondaries
    //      - DS integration
    //  should all be done in context of specific reset operation
    //

    else
    {
        return( DNS_ERROR_INVALID_PROPERTY );
    }

    //
    //  reset property DWORD in registry
    //

    status = Reg_SetDwordValue(
                NULL,
                pZone,
                pszOperation,
                value );

    ASSERT( status == ERROR_SUCCESS );
    return( status );
}

#endif



//
//  Zone lookup
//

PZONE_INFO
Zone_FindZoneByName(
    IN      LPSTR           pszZoneName
    )
/*++

Routine Description:

    Find zone matching name.

Arguments:

    pszZoneName -- name of desired zone

Return Value:

    Ptr to zone info block, if successful.
    NULL if handle invalid.

--*/
{
    PDB_NODE    pzoneRoot;

    if ( !pszZoneName )
    {
        return( NULL );
    }

    //
    //  find zone name in zone tree
    //      - must have exact match to existing zone
    //

    pzoneRoot = Lookup_ZoneTreeNodeFromDottedName(
                    pszZoneName,
                    0,
                    LOOKUP_MATCH_ZONE
                    );
    if ( !pzoneRoot )
    {
        return( NULL );
    }

    ASSERT( pzoneRoot->pZone );

    return( (PZONE_INFO)pzoneRoot->pZone );
}



//
//  Reverse zone auto-creation routines
//

DNS_STATUS
Zone_CreateAutomaticReverseZones(
    VOID
    )
/*++

Routine Description:

    Create standard reverse zones automatically.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status;

    //
    //  even if no reverse zones desired create reverse lookup nodes
    //

    //(DATABASE_REVERSE_ROOT)->pRRList = REVERSE_COMBINED_DATA;

    if ( SrvCfg_fNoAutoReverseZones )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  three auto-create zones
    //      0     => NAME_ERROR 0.0.0.0 requests
    //      127   => response to 127.0.0.1 requests (as "localhost")
    //      255   => NAME_ERROR 255.255.255.255 requests
    //
    //  these keep any of these (common) requests from being referred
    //      to root name servers
    //

    status = Zone_CreateAutomaticReverseZone( "0.in-addr.arpa" );
    status = Zone_CreateAutomaticReverseZone( "127.in-addr.arpa" );
    status = Zone_CreateAutomaticReverseZone( "255.in-addr.arpa" );
    return( ERROR_SUCCESS );
}



DNS_STATUS
Zone_CreateAutomaticReverseZone(
    IN      LPSTR           pszZoneName
    )
/*++

Routine Description:

    If zone doesn't exist, create automatic zone.

Arguments:


Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PZONE_INFO      pzone;

    //
    //  does desired zone already exist?
    //
    //  if exists, we're done
    //
    //  note:  for reverse lookup node, node should NEVER exist
    //      unless it is in AUTHORITATIVE zone
    //      - no reference to PTR nodes
    //      - no glue PTR
    //      - no caching
    //

    pzone = Zone_FindZoneByName( pszZoneName );
    if ( pzone )
    {
        DNS_DEBUG( INIT, (
            "Zone %s already exists,\n"
            "\tno auto-create of %s zone.\n"
            "%s\n",
            pszZoneName,
            pszZoneName ));
        return( ERROR_SUCCESS );
    }

    //
    //  create zone and default records
    //

    status = Zone_CreateNewPrimary(
                & pzone,
                pszZoneName,
                NULL,
                NULL,
                NO_DATABASE_PRIMARY,
                NULL,                   //  naming context
                FALSE );

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR: creating auto-create zone %s.\n"
            "\tstatus = %d.\n",
            pszZoneName,
            status ));
    }
    return( status );
}



//
//  Zone load\unload
//

DNS_STATUS
Zone_PrepareForLoad(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Prepare for load of zone.

Arguments:

    pZone - zone to load

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure

--*/
{
    PDB_NODE    pnodeTreeRoot;
    PDB_NODE    pnodeZoneRoot;

    DNS_DEBUG( INIT, (
        "Zone_PrepareForLoad( %s ).\n",
        pZone->pszZoneName ));

    //
    //  may NOT load if already loading zone
    //      OR
    //  if have not deleted previous zone load
    //

    if ( pZone->pLoadTreeRoot || pZone->pOldTree )
    {
        DNS_DEBUG( INIT, (
            "WARNING:  Unable to init zone %s for load!\n"
            "\tpOldTree         = %p\n"
            "\tpLoadTreeRoot    = %p\n",
            pZone->pszZoneName,
            pZone->pOldTree,
            pZone->pLoadTreeRoot ));
        return( DNS_ERROR_ZONE_LOCKED );
    }
    ASSERT( !pZone->pLoadZoneRoot );

    //  zone must be locked to bring loaded database on-line

    ASSERT( IS_ZONE_LOCKED_FOR_WRITE(pZone) );


    //  create zone tree

    pnodeTreeRoot = NTree_Initialize();
    pZone->pLoadTreeRoot = pnodeTreeRoot;

    //  cache zone
    //      - ZoneRoot ptr also points at tree root

    if ( IS_ZONE_CACHE(pZone) )
    {
        pZone->pLoadZoneRoot = pnodeTreeRoot;
        pZone->pLoadOrigin   = pnodeTreeRoot;

        SET_ZONE_ROOT( pnodeTreeRoot );
    }

    //  authoritative zone
    //      - start tree root with outside authority (overwritten for root zone)
    //      - seed tree root with zone ptr (inheirited)
    //      - get zone root
    //      - mark as auth zone root
    //      - set zone authority
    //      - load starts with origin at root
    //
    //  note:  NameCheckFlag can cause root creation to fail even when created zone
    //      (bogus but true);  so we bail

    else
    {
        pnodeTreeRoot->pZone = pZone;
        SET_OUTSIDE_ZONE_NODE( pnodeTreeRoot );

        pnodeZoneRoot = Lookup_ZoneNode(
                            pZone,
                            pZone->pCountName->RawName,
                            NULL,                               // no packet
                            NULL,                               // no lookup name
                            LOOKUP_NAME_FQDN | LOOKUP_LOAD,
                            NULL,                               // create
                            NULL                                // following node
                            );
        if ( !pnodeZoneRoot )
        {
            DNS_STATUS status = GetLastError();
            if ( status == ERROR_SUCCESS )
            {
                ASSERT( FALSE );
                status = ERROR_INVALID_NAME;
            }
            return( status );
        }

        SET_ZONE_ROOT( pnodeZoneRoot );
        SET_AUTH_ZONE_ROOT( pnodeZoneRoot );
        SET_AUTH_NODE( pnodeZoneRoot );

        //  should inherit zone from parents
        ASSERT( pnodeZoneRoot->pZone == pZone );

        pZone->pLoadZoneRoot = pnodeZoneRoot;
        pZone->pLoadOrigin = pnodeZoneRoot;
    }

    STAT_INC( PrivateStats.ZoneLoadInit );

    return( ERROR_SUCCESS );
}



VOID
cleanupOldZoneTree(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Cleanup old zone tree.

    This covers direct call to NTree_SubtreeDelete().
    It's purpose is to provide a timeout entry point which will delete
    the old zone tree AND clear a ptr to the old tree in the zone block.
    That pointer then serves to block new load attempts until the memory
    from the previous tree is cleaned up.

Arguments:

    pZone - zone

Return Value:

    None.

--*/
{
    DNS_DEBUG( TIMEOUT, (
        "cleanupOldZoneTree(%s).\n",
        pZone->pszZoneName ));

    //  can't load while old zone tree exists

    ASSERT( !pZone->pLoadTreeRoot && !pZone->pLoadZoneRoot );

    //
    //  delete zone's old tree
    //

    if ( !pZone->pOldTree )
    {
        DNS_PRINT(( "ERROR:  expected old zone tree!!!\n" ));
        ASSERT( FALSE );
        return;
    }
    NTree_DeleteSubtree( pZone->pOldTree );

    //  clearing pointer, re-enables new zone loads

    pZone->pOldTree = NULL;
}



DNS_STATUS
Zone_ActivateLoadedZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Activate a loaded zone.
    Zone may have been loaded through several means:
        - file load
        - DS load
        - zone transfer

    This routine simply brings the loaded zone on-line.

    Note, caller must do any zone locking required.

Arguments:

    pZone - zone to load

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure

--*/
{
    DNS_STATUS      status;
    PDB_NODE        poldZoneTree;
    UPDATE_LIST     oldUpdateList;

    DNS_DEBUG( INIT, (
        "Zone_ActivateLoadedZone( %s ).\n",
        pZone->pszZoneName ));

    IF_DEBUG( INIT )
    {
        Dbg_Zone(
            "Zone being activated: ",
            pZone );
    }

    //  zone must be locked to bring loaded database on-line

    ASSERT( IS_ZONE_LOCKED_FOR_WRITE(pZone) );

    //
    //  must have loaded zone -- or kind of pointless
    //

    if ( !pZone->pLoadTreeRoot )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  ActivateLoadedZone(%s) failed, no load database!!!.\n",
            pZone->pszZoneName ));
        return( DNS_ERROR_ZONE_CREATION_FAILED );
    }

    ASSERT( pZone->pLoadZoneRoot && pZone->pLoadTreeRoot && !pZone->pOldTree );

    //
    //  rebalance zone
    //      - only bother traversing zone section
    //          (not enough data in the rest to matter)
    //      - no locked required, as tree is off-line
    //
    //  DEVNOTE: make sure that this routine doesn't lock on its own
    //

    NTree_RebalanceSubtreeChildLists(
        pZone->pLoadZoneRoot,
        pZone );

    IF_DEBUG( DATABASE2 )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Zone %s tree after load, before activation:\n",
            pZone->pszZoneName ));
        Dbg_DnsTree(
            "New loaded zone tree",
            pZone->pLoadTreeRoot );
        DnsDebugUnlock();
    }

    //
    //  save current data for later delete
    //

    poldZoneTree = pZone->pTreeRoot;

    RtlCopyMemory(
        & oldUpdateList,
        & pZone->UpdateList,
        sizeof(UPDATE_LIST)
        );

    //
    //  reset zone's update list
    //      - EXECUTED flag makes sure any future cleanup is limited to
    //      delete RRs (add RRs being in zone data)

    Up_InitUpdateList( &pZone->UpdateList );
    pZone->UpdateList.Flag |= DNSUPDATE_EXECUTED;

    //
    //  swap in loaded tree as working copy of database
    //
    //      - read zone info from database root
    //      - clear dwLoadedVersion so this treated as fresh load
    //          for serial and doing default record fixup
    //
    //  note:  we get ZoneInfo AFTER swapping in new database -- otherwise
    //      default creations, building NS lists, etc. is more complicated
    //
    //  DEVNOTE: however should have back out, if reading zone info fails
    //

    Dbase_LockDatabase();

    pZone->pOldTree = poldZoneTree;

    pZone->pTreeRoot = pZone->pLoadTreeRoot;
    pZone->pZoneRoot = pZone->pLoadZoneRoot;

    pZone->dwSerialNo = 0;
    pZone->dwLoadSerialNo = 0;
    pZone->dwLastXfrSerialNo = 0;

    pZone->pLoadTreeRoot = NULL;
    pZone->pLoadZoneRoot = NULL;
    pZone->pLoadOrigin = NULL;

    if ( IS_ZONE_CACHE(pZone) )
    {
        g_pCacheLocalNode = Lookup_ZoneNodeFromDotted(
                                NULL,
                                "local",
                                0,                      // no length
                                LOOKUP_NAME_FQDN,
                                NULL,                   // create
                                NULL                    // no status return
                                );
        ASSERT( g_pCacheLocalNode );
    }
    else
    {
        Zone_GetZoneInfoFromResourceRecords( pZone );
    }
    Dbase_UnlockDatabase();

    //
    //  if load detected a required update -- execute it
    //      - updates are required if changed Primary name or IP
    //

    if ( pZone->pDelayedUpdateList )
    {
        ASSERT( IS_ZONE_PRIMARY(pZone) );

        status = Up_ExecuteUpdate(
                        pZone,
                        pZone->pDelayedUpdateList,
                        DNSUPDATE_LOCAL_SYSTEM | DNSUPDATE_AUTO_CONFIG
                        );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "ERROR:  processing self-generated update!!!\n" ));
            ASSERT( FALSE );
        }

        //  free update list -- updates themselves are incorporated in update list

        FREE_TAGHEAP( pZone->pDelayedUpdateList, sizeof(UPDATE_LIST), MEMTAG_UPDATE_LIST );
        pZone->pDelayedUpdateList = NULL;


        //  auto update always suppressed because zone is NEVER IXFR capable on
        //      startup;   this prevents this update from allowing bogus IXFR
        //      with bad serial to secondary

        ASSERT( !pZone->fDsIntegrated || pZone->UpdateList.pListHead == NULL );
    }

    //
    //  if primary zone send NOTIFYs
    //
    //  DEVNOTE: probably should not notify this early on initial load
    //      especially for DS zone
    //

    if ( IS_ZONE_PRIMARY(pZone) )
    {
        Xfr_SendNotify( pZone );
    }

    //
    //  For secondary with file at startup, initialize timeouts
    //  For primary just fire up zone.
    //  If successfully loaded, unlock zone.
    //

    if ( IS_ZONE_SECONDARY(pZone) )
    {
        Xfr_InitializeSecondaryZoneTimeouts( pZone );
    }
    else
    {
        STARTUP_ZONE(pZone);
    }

    //
    //  cleanup old database (if any)
    //      - queue as timeout free, so zone can be brought on-line
    //      and to protect against queries with outstanding zone nodes
    //

    if ( poldZoneTree )
    {
        DNS_DEBUG( INIT, (
            "Queuing zone %s old database at %p for delete.\n",
            pZone->pszZoneName,
            poldZoneTree ));

        //  flush existing update list
        //      executed flag set so only delete pDeleteRR lists,
        //      pAddRR list are in zone and are deleted in tree

        ASSERT( IS_EMPTY_UPDATE_LIST(&oldUpdateList) ||
                oldUpdateList.Flag & DNSUPDATE_EXECUTED );

        oldUpdateList.Flag |= DNSUPDATE_NO_DEREF;

        Up_FreeUpdatesInUpdateList( &oldUpdateList );

        //
        //  queue timeout delete of previous zone tree
        //
        //  - zone delete is queued to specific function which deletes tree
        //      pZone->pOldTree;  this serves as flag to avoid zone reload until
        //      previous memory freed
        //
        //  - directly queue cache delete, as otherwise cache is blocked from
        //      reload during timeout, and several quick zone loads (which first dump cache)
        //      would be blocked
        //      (since root-hint reads are small data, there really is not memory
        //      issue here that merits blocking cache reloads)
        //

        if ( IS_ZONE_CACHE(pZone) )
        {
            pZone->pOldTree = NULL;
            Timeout_FreeWithFunction( poldZoneTree, NTree_DeleteSubtree );
        }
        else
        {
            Timeout_FreeWithFunction( pZone, cleanupOldZoneTree );
        }
    }
    ELSE_ASSERT( oldUpdateList.pListHead == NULL );

    //
    //  zone reload forces scavenging reset
    //

    pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();

    //
    //  verify crosslink to zone tree
    //

    if ( !IS_ZONE_CACHE(pZone) )
    {
        Dbg_DbaseNode( "ZoneTree node for activated zone", pZone->pZoneTreeLink );
        ASSERT( pZone->pZoneTreeLink );
        ASSERT( pZone->pZoneTreeLink->pZone == pZone );
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
Zone_CleanupFailedLoad(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Cleanup database of failed load.
    May be called safely after successful load (once load has been activated!)

Arguments:

    pZone - zone

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure

--*/
{
    PDB_NODE    pfailedTree;

    DNS_DEBUG( INIT, (
        "Zone_CleanupFailedLoad(%s).\n",
        pZone->pszZoneName ));

    //  zone must be locked to bring loaded database on-line

    ASSERT( IS_ZONE_LOCKED_FOR_WRITE(pZone) );
    ASSERT( pZone->pLoadTreeRoot || !pZone->pLoadZoneRoot );

    //
    //  save load tree, delete load info
    //

    pfailedTree = pZone->pLoadTreeRoot;
    pZone->pLoadTreeRoot = NULL;
    pZone->pLoadZoneRoot = NULL;
    pZone->pLoadOrigin   = NULL;

    //
    //  cleanup load tree
    //      - since failure, delete in-line no references outstanding
    //      this eliminates the possiblity of multiple failures queuing
    //      up lots of failed loads
    //

    if ( pfailedTree )
    {
        DNS_DEBUG( INIT, (
            "Deleting failed zone %s load database at %p.\n",
            pZone->pszZoneName,
            pfailedTree ));

        NTree_DeleteSubtree( pfailedTree );
    }
    ELSE_IF_DEBUG( ANY )
    {
        DNS_PRINT((
            "WARNING:  Zone_CleanupFailedLoad( %s ) with no pLoadTreeRoot!\n",
            pZone->pszZoneName ));
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
Zone_Load(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Load a zone file into in memory database.

    This loads either from either DS or file.
    This function exists to do all post-load zone initialization
    for either type of load.

Arguments:

    pZone - zone to load

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;

    //
    //  save zone domain name as orgin
    //      - don't just use pZone lookup name, as may reset with ORIGIN
    //      directive
    //

    DNS_DEBUG( INIT, (
        "\n\nZone_Load(%s).\n",
        pZone->pszZoneName ));

    IF_DEBUG( INIT )
    {
        Dbg_Zone(
            "Loading zone:",
            pZone );
    }

    //
    //  lock zone while loading
    //
    //  note, already locked in Zone_Create(), but for RPC action
    //  generating a reload, best to have consistent lock-unlock in this
    //  function
    //

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Zone_Load() %s lock failure.\n",
            pZone->pszZoneName ));
        return( DNS_ERROR_ZONE_LOCKED );
    }

    //
    //  Initialize zone version control for secondary
    //
    //  For secondaries without database file, we're done.
    //      - mark the zone as shutdown, until first zone transfer
    //        can be completed
    //

    if ( IS_ZONE_SECONDARY(pZone) &&
         !pZone->fDsIntegrated )
    {
        if ( !pZone->pszDataFile )
        {
            ASSERT( IS_ZONE_SHUTDOWN(pZone) );

            DNS_DEBUG( INIT, (
                "No database file for secondary zone %s.\n",
                pZone->pszZoneName ));

            status = ERROR_FILE_NOT_FOUND;
            goto Exit;
        }
        ASSERT ( pZone->fDsIntegrated == FALSE ) ;
    }

    //
    //  init temporary database for file load
    //
    //  DEVNOTE: this function can fail, when have not yet cleaned up old zone dbase
    //      if want admin to always succeed in doing zone reload, then need some
    //      sort of force flag
    //

    status = Zone_PrepareForLoad( pZone );
    if ( status != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    //  Load from DS or file, if necessary.
    //

    if ( pZone->fDsIntegrated )
    {
        status = Ds_LoadZoneFromDs( pZone, 0 );
    }
    else if ( IS_ZONE_FORWARDER( pZone ) )
    {
        //
        //  File-backed forward zones require no additional processing.
        //

        status = ERROR_SUCCESS;
    }
    else
    {

        ASSERT( pZone->pszDataFile );

        status = File_LoadDatabaseFile(
                    pZone,
                    NULL,
                    NULL,       //  no parent parsing context
                    NULL );     //  default to zone origin
    }

    //  load failed, note do NOT unlock zone
    //  if creating from admin then default zone creation may
    //      take place here

    if ( status != ERROR_SUCCESS )
    {
        Zone_CleanupFailedLoad( pZone );
        goto Exit;
    }

    //
    //  bring loaded zone on-line
    //      - note, DS-integrated is brought on-line inside load function
    //      (see function for explanation)
    //

    if ( !pZone->fDsIntegrated &&
        ( IS_ZONE_AUTHORITATIVE( pZone ) ||
            IS_ZONE_STUB( pZone ) ||
            IS_ZONE_FORWARDER( pZone )  ))
    {
        Zone_ActivateLoadedZone( pZone );
    }

    //
    //  transitional zone for DC promo
    //      - switch it to DS secure
    //

    if ( pZone->bDcPromoConvert )
    {
        Zone_DcPromoConvert( pZone );
    }

Exit:

    DNS_DEBUG( INIT, (
        "Exit  Zone_Load( %s ), status = %d (%p)\n\n",
        pZone->pszZoneName,
        status, status ));

    Zone_UnlockAfterAdminUpdate( pZone );
    return( status );
}



DNS_STATUS
Zone_DumpData(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Dump zone's data. The caller must have the zone locked.

Arguments:

    pZone - zone to dump

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure

--*/
{
    DNS_STATUS      status;
    PDB_NODE        poldZoneTree;
    UPDATE_LIST     oldUpdateList;

    DNS_DEBUG( INIT, (
        "Zone_DumpData(%s).\n",
        pZone->pszZoneName ));
    IF_DEBUG( INIT )
    {
        Dbg_Zone(
            "Zone having data dumped",
            pZone );
    }

    SHUTDOWN_ZONE( pZone );

    //
    //  save current data for later delete
    //

    poldZoneTree = pZone->pTreeRoot;

    RtlCopyMemory(
        & oldUpdateList,
        & pZone->UpdateList,
        sizeof(UPDATE_LIST)
        );

    //
    //  reset zone's update list
    //      - EXECUTED flag makes sure any future cleanup is limited to
    //      delete RRs (add RRs being in zone data)

    Up_InitUpdateList( &pZone->UpdateList );
    pZone->UpdateList.Flag |= DNSUPDATE_EXECUTED;

    //
    //  swap in loaded tree as working copy of database
    //  read zone info from database root
    //
    //  note:  we get ZoneInfo AFTER swapping in new database -- otherwise
    //      default creations, building NS lists, etc. is more complicated
    //  DEVNOTE: however should have back out, if reading zone info fails
    //

    Dbase_LockDatabase();

    pZone->pTreeRoot = NULL;
    pZone->pZoneRoot = NULL;

    //  if cache, rebuild functioning cache tree

    if ( pZone == g_pCacheZone )
    {
        PDB_NODE proot = NTree_Initialize();
#if 0
        if ( !proot )
        {
            ASSERT( FALSE );
            Dbase_UnlockDatabase();
            goto ErrorReturn;
        }
#endif
        pZone->pTreeRoot = proot;
        pZone->pZoneRoot = proot;
        STARTUP_ZONE( pZone );
    }

    Dbase_UnlockDatabase();

    //
    //  cleanup old database (if any)
    //      - queue as timeout free, so zone can be brought on-line
    //      and to protect against queries with outstanding zone nodes
    //

    if ( poldZoneTree )
    {
        DNS_DEBUG( INIT, (
            "Queuing zone %s old database at %p for delete.\n",
            pZone->pszZoneName,
            poldZoneTree ));

        //  flush existing update list
        //      executed flag set so only delete pDeleteRR lists,
        //      pAddRR list are in zone and are deleted in tree

        //      set EXECUTED flag -- cache "zone" doesn't have it set
        //ASSERT( oldUpdateList.Flag & DNSUPDATE_EXECUTED );

        oldUpdateList.Flag |= DNSUPDATE_EXECUTED;
        Up_FreeUpdatesInUpdateList( &oldUpdateList );

        Timeout_FreeWithFunction( poldZoneTree, NTree_DeleteSubtree );
    }
    ELSE_ASSERT( oldUpdateList.pListHead == NULL );

    return( ERROR_SUCCESS );
}



DNS_STATUS
Zone_ClearCache(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Dump cache data for new zone.

    Note:  actual cache dump is done by Zone_LoadRootHints().

Arguments:

    pZone -- new zone

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    //
    //  if startup, then no need, as cache empty
    //

    if ( !SrvCfg_fStarted )
    {
        return( ERROR_SUCCESS );
    }

    DNS_DEBUG( RPC, (
        "Zone_ClearCache()\n"
        "\tfor new zone info at %p\n",
        pZone ));

    //
    //  dump cache for new zone
    //      - if root zone, dump whole cache
    //
    //  DEVNOTE: new non-root zone does not require full cache dump,
    //          should be able to limit to subtree
    //

#if 0
    if ( !pZone || IS_ROOT_ZONE(pZone) )
    {
        Zone_LoadRootHints();
    }
    else
    {
        //  DEVNOTE: delete cache sub-tree from zoneroot
    }
#endif

    if ( !Zone_LockForAdminUpdate( g_pCacheZone ) )
    {
        return( DNS_ERROR_ZONE_LOCKED );
    }
    Zone_LoadRootHints();

    return( ERROR_SUCCESS );
}



#if 0

//
// Per new spec root hints RD/WR has changed. These were left for reference &
// should get rm in the future.
//

DNS_STATUS
Zone_LoadRootHints(
    VOID
    )
/*++

Routine Description:

    Read (or reread) root-hints (cache file) into database.

    Note, that this dumps cache.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PZONE_INFO  pzone;
    DNS_STATUS  status;
    BOOL        fdsRead = FALSE;

    DNS_DEBUG( INIT, ( "Zone_LoadRootHints()\n" ));

    //
    //  if not yet created cache zone -- create
    //

    pzone = g_pCacheZone;
    if ( !pzone )
    {
        ASSERT( FALSE );
        status = Zone_Create(
                    & pzone,
                    DNS_ZONE_TYPE_CACHE,
                    ".",
                    0,
                    NULL,       // no masters
                    FALSE,      // file not database
                    NULL,       // default file name
                    0 );
        if ( status != ERROR_SUCCESS )
        {
            return status;
        }
        ASSERT( g_pCacheZone == pzone );
    }

    ASSERT( IS_ZONE_CACHE(pzone) );

    //  zone must be locked to bring loaded database on-line

    ASSERT( IS_ZONE_LOCKED_FOR_WRITE(pzone) );

    //
    //  create cache tree
    //      - need "local" domain to check nodes for no-recursion
    //

    pzone->pLoadTreeRoot = NTree_Initialize();
    pzone->pLoadZoneRoot = pzone->pLoadTreeRoot;

    //
    //  if root authoritative -- don't need root hints
    //      - skip to tree swap\dump
    //

    if ( IS_ROOT_AUTHORITATIVE() )
    {
        DNS_DEBUG( INIT, ( "Root authoritative not loading root hints.\n" ));
        status = ERROR_SUCCESS;
        goto Activate;
    }

    //
    //  load from DS or file -- make every effort
    //
    //  try DS first if DS integrated
    //      cache file first if not
    //  but in either case always try the other method
    //

    //
    //  DEVNOTE: should file open go first when filename specified?
    //      - only makes sense if don't default file name in Zone_Create
    //

    //
    // If the RootHints exist on the DS, (openzone will succeed) then
    // mark the zone as Dsintegrated & do the DS stuff.
    //

    status = Ds_OpenZone( pzone );
    if ( status == ERROR_SUCCESS )
    {
        pzone->fDsIntegrated = TRUE;
    }

    status = ERROR_FILE_NOT_FOUND;

    if ( pzone->fDsIntegrated )
    {
        status = Ds_LoadZoneFromDs( pzone, 0 );
        if ( status == ERROR_SUCCESS )
        {
            fdsRead = TRUE;
            goto Activate;
        }
    }

    //
    //  if explicit cache file -- open it
    //

    if ( pzone->pszDataFile )
    {
        status = File_LoadDatabaseFile(
                    pzone,
                    NULL,       // default file name
                    NULL,       // no parent parsing context
                    NULL        // default to zone origin
                    );
        if ( status == ERROR_SUCCESS )
        {
            goto Activate;
        }

        //
        //  DEVNOTE: cache load error cases!
        //      can continue to try other methods -- then error out
        //

        DNS_LOG_EVENT(
            DNS_EVENT_CACHE_FILE_NOT_FOUND,
            0,
            NULL,
            NULL,
            GetLastError() );
    }

    //
    //  try DS after file open failure
    //      - no need to rewrite registry, either nothing there or it points
    //      to file that we couldn't open, and admin can adjust
    //
    //  DEVNOTE: if DS root-hint read successful, need to either
    //      - avoid logging can't find file event (above)
    //      - or rewrite to registry?
    //      otherwise would keep failing to open default file, but retrying each time
    //
    //  can eliminate tempStatus?  if aren't saving open failure status, no point
    //      to local variable
    //

    if ( !pzone->fDsIntegrated  &&  Ds_IsDsServer() )
    {
        DNS_STATUS  tempStatus;

        tempStatus = Ds_LoadZoneFromDs( pzone, 0 );
        if ( tempStatus == ERROR_SUCCESS )
        {
            fdsRead = TRUE;
            status = ERROR_SUCCESS;
            goto Activate;
        }
    }

    //
    //  if failed DS open, AND no-explicit cache file, try default cache file
    //

    if ( !pzone->pszDataFile )
    {
        pzone->pszDataFile = DNS_DEFAULT_CACHE_FILE_NAME_UTF8;

        status = File_LoadDatabaseFile(
                    pzone,
                    NULL,       //  default file name
                    NULL,       //  no parent parsing context
                    NULL        //  default to zone origin
                    );
        if ( status == ERROR_SUCCESS )
        {
            pzone->pszDataFile = Dns_CreateStringCopy(
                                    DNS_DEFAULT_CACHE_FILE_NAME_UTF8,
                                    0 );
            goto Activate;
        }
        pzone->pszDataFile = NULL;

        //  DEVNOTE: probably do not need this
        //      final failure log should explicitly indicate all places checked

        DNS_LOG_EVENT(
            DNS_EVENT_CACHE_FILE_NOT_FOUND,
            0,
            NULL,
            NULL,
            GetLastError() );
    }

    //
    //  DEVNOTE: on reload failure, could copy root-hints from activate cache tree
    //

Activate:

    //  bring on-line -- even if read failed

    Dbase_LockDatabase();
    Zone_ActivateLoadedZone( pzone );
    Dbase_UnlockDatabase();

    //  unlock cache "zone"

    Zone_UnlockAfterAdminUpdate( pzone );

    //
    //  success?
    //
    //  if DS available and root-hints NOT in DS, then slap them in there
    //
    //  this makes it available for any servers (including this one) that
    //      want to load it in the future
    //

    if ( status == ERROR_SUCCESS )
    {
        if ( !fdsRead  &&  Ds_IsDsServer() &&  !IS_ROOT_AUTHORITATIVE() )
        {
            DNS_STATUS  tempStatus;

            //  open zone
            //      - if failure on startup (as opposed to admin add), log error

            tempStatus = Ds_WriteZoneToDs(
                                g_pCacheZone,
                                0               // fail if zone already exists
                                );

            ASSERT ( tempStatus );
            g_pCacheZone->fDsIntegrated = TRUE;

            DNS_DEBUG( INIT, (
                "Attempted to write root-hints to DS.\n"
                "\tstatus = %p (%d)\n",
                tempStatus, tempStatus ));
        }
    }

    //
    //  failure
    //      - if have forwarders or not recursing OK
    //      - otherwise terminal
    //
    //  DEVNOTE: should distinguish when cache.dns even "suggested" by boot
    //      file or registry;  if not then even error logging can be dropped

    else
    {
        if ( SrvCfg_fNoRecursion ||
            ( SrvCfg_aipForwarders && SrvCfg_aipForwarders->AddrCount ) ||
            SrvCfg_fStarted )
        {
            DNS_DEBUG( INIT, (
                "Skipping load failure on cache.\n"
                "\tEither have forwarders or NOT recursing!\n" ));
            status = ERROR_SUCCESS;
        }
        else
        {
            DNS_PRINT((
                "ERROR:  Not root authoritative and no forwarders and no cache file specified.\n" ));
            DNS_LOG_EVENT(
                DNS_EVENT_NO_CACHE_FILE_SPECIFIED,
                0,
                NULL,
                NULL,
                0 );
        }
    }

    return( status );
}
#endif


DNS_STATUS
Zone_LoadRootHints(
    VOID
    )
/*++

Routine Description:

    Read (or reread) root-hints (cache file) into database.

    Note, that this dumps cache.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PZONE_INFO  pzone;
    DNS_STATUS  status;
    BOOL        fdsRead = FALSE;
    BOOL        fileRead = FALSE;
    BOOL        bTmp;
    DWORD       dsZoneWriteFlags = 0;

    DNS_DEBUG( INIT, ( "Zone_LoadRootHints()\n" ));

    //
    //  if not yet created cache zone -- create
    //

    pzone = g_pRootHintsZone;
    if ( !pzone )
    {
        ASSERT( FALSE );
        status = Zone_Create(
                    & pzone,
                    DNS_ZONE_TYPE_CACHE,
                    ".",
                    0,
                    NULL,       //  no masters
                    FALSE,      //  file not database
                    NULL,       //  naming context
                    NULL,       //  default file name
                    0,
                    NULL,
                    NULL );     //  existing zone
        if ( status != ERROR_SUCCESS )
        {
            return status;
        }
        ASSERT( g_pRootHintsZone == pzone );
    }

    //
    //  if zone already exists
    //      - may be locked by this thread (loading after create case)
    //      - or lock it now
    //

    else if ( ! IS_ZONE_LOCKED_FOR_WRITE_BY_THREAD(pzone) )
    {
        if ( !Zone_LockForAdminUpdate( pzone ) )
        {
            DNS_DEBUG( INIT, (
                "WARNING:  unable to load root hints!\n"
                "\tRoot-hints zone locked by another thread.\n" ));
            return( DNS_ERROR_ZONE_LOCKED );
        }
    }

    ASSERT( IS_ZONE_CACHE(pzone) );

    //  zone must be locked to bring loaded database on-line

    ASSERT( IS_ZONE_LOCKED_FOR_WRITE(pzone) );

    //
    //  create cache tree
    //      - need "local" domain to check nodes for no-recursion
    //

    pzone->pLoadTreeRoot = NTree_Initialize();
    pzone->pLoadZoneRoot = pzone->pLoadTreeRoot;

    //
    //  if root authoritative -- don't need root hints
    //      - skip to tree swap\dump
    //

    if ( IS_ROOT_AUTHORITATIVE() )
    {
        DNS_DEBUG( INIT, ( "Root authoritative not loading root hints.\n" ));
        status = ERROR_SUCCESS;
        goto Activate;
    }

    //
    //  load from DS or file -- make every effort
    //
    //  try DS first if DS integrated
    //      cache file first if not
    //  but in either case always try the other method
    //

    //
    //  DEVNOTE: not complete function
    //      i don't really see what this function has accomplished
    //      versus previous version;  it reorders the attempts (slightly)
    //      based on BootMethod (which can easily be done without case)
    //      but it fails to nail down the specific issues, and makes
    //      a couple of them worse
    //          -- does file override in DIRECTORY mode
    //              (apparently no way to do this now, even with explict file
    //              set in registry)
    //          -- file overrides in REGISTRY mode, do we ever write back
    //              (used to, but not now)
    //          -- on DC file override, push data into EMPTY DS zone,
    //              but do not push into full one
    //


    //
    // Load Root Hints based on current boot method
    //

    switch( SrvCfg_fBootMethod )
    {
        case BOOT_METHOD_UNINITIALIZED:
        case BOOT_METHOD_DIRECTORY:

            //
            // Load DS zone
            // If we loaded 0 records from the DS, that means that it may
            // be that we just created it in our boot sequence (see srvcfgSetBootMethod).
            // Thus, we still want to attempt loading from a file (for the first time).
            //

            status = Ds_LoadZoneFromDs( pzone, 0 );
            if ( status == ERROR_SUCCESS &&
                 pzone->iRRCount != 0 )
            {
                fdsRead = TRUE;
                break;
            }


            //
            //  Fail over to registry, but when we write back to the DS, we
            //  want to force overwrite - the zone may exist in the DS with
            //  no RRs (no children).
            //

            dsZoneWriteFlags = DNS_ZONE_LOAD_OVERWRITE_DS;
  
        case BOOT_METHOD_REGISTRY:
        case BOOT_METHOD_FILE:

            //
            // Fix file name
            //

            bTmp = FALSE;
            if ( !pzone->pszDataFile )
            {
                pzone->pwsDataFile = DNS_DEFAULT_CACHE_FILE_NAME;
                bTmp = TRUE;
            }

            //
            // Attempt file load
            //

            status = File_LoadDatabaseFile(
                        pzone,
                        NULL,       //  default file name
                        NULL,       //  no parent parsing context
                        NULL        //  default to zone origin
                        );
            if ( status == ERROR_SUCCESS )
            {
#if 0
                //
                //  DEVNOTE: you just clobbered the pszDataFile name if it
                //      wasn't the default, (which it's never going to be
                //      until Zone_Create() fixed) you end up with the file
                //      loaded under one name but using another (plus, of
                //      course, the minor mem leak)
                //
                //      the proper way to handle these situations is a local
                //      variable.  just set it to the file, if it doesn't
                //      exist, reset it -- simple
                //

                pzone->pwsDataFile = Dns_StringCopyAllocate_W(
                                        DNS_DEFAULT_CACHE_FILE_NAME,
                                        0 );
#endif
                if ( bTmp )
                {
                    pzone->pwsDataFile = Dns_StringCopyAllocate_W(
                                            DNS_DEFAULT_CACHE_FILE_NAME,
                                            0 );
                }

                fileRead = TRUE;
                break;
            }

            if ( bTmp )
            {
                //
                // Used default name.
                //

                pzone->pwsDataFile = NULL;
            }

            status = GetLastError() ? GetLastError() : status;

            if ( SrvCfg_fBootMethod == BOOT_METHOD_REGISTRY )
            {
                //
                // Not from fail over & not FILE. Thus attempt DS.
                //
                // Load DS zone
                // If we loaded 0 records from the DS, that means that it may
                // be that we just created it in our boot sequence (see srvcfgSetBootMethod).
                // Thus, we still want to attempt loading from a file (for the first time).
                //

                status = Ds_LoadZoneFromDs( pzone, 0 );
                if ( status == ERROR_SUCCESS &&
                     pzone->iRRCount != 0 )
                {
                    //
                    // Successfull load of DS zone w/ more then 0 records
                    //

                    fdsRead = TRUE;
                    break;
                }
            }
            break;

        default:

            DNS_DEBUG( DS, (
               "ERROR: INVALID Boot Method. Logic Error\n" ));
            ASSERT( FALSE );
            status =  ERROR_INVALID_PARAMETER;
            break;
    }

    //
    //  load failure -- log if appropriate
    //

    if ( status != ERROR_SUCCESS )
    {
        if ( SrvCfg_fNoRecursion ||
            ( SrvCfg_aipForwarders && SrvCfg_aipForwarders->AddrCount ) ||
            SrvCfg_fStarted )
        {
            DNS_DEBUG( INIT, (
                "Skipping load failure on cache.\n"
                "\tEither have forwarders or NOT recursing or post-startup.\n"
                "\t(example:  load attempt after root-zone delete.)\n" ));
            status = ERROR_SUCCESS;
        }
        else
        {
            DNS_PRINT((
                "ERROR:  Not root authoritative and no forwarders and no cache file specified.\n" ));
            DNS_LOG_EVENT(
                DNS_EVENT_NO_CACHE_FILE_SPECIFIED,
                0,
                NULL,
                NULL,
                status );
        }

        goto Activate;
    }

    //
    //  DEVNOTE: on reload failure, could copy root-hints from activated cache tree
    //


Activate:

    //
    //  bring on-line
    //

    Dbase_LockDatabase();
    Zone_ActivateLoadedZone( pzone );
    Dbase_UnlockDatabase();

    //
    //  write back to DS?
    //      - booting from directory
    //      - but didn't load from directory
    //      - but did load from file
    //

    //  if DS available and root-hints NOT in DS, then slap them in there
    //
    //  this makes it available for any servers (including this one) that
    //      want to load it in the future
    // Per Stu's design-- write to the DS (be ds integrated) ONLY if boot
    // method is DS
    //

    if ( SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY &&
        ! fdsRead  &&
        fileRead &&
        Ds_IsDsServer() &&
        Zone_VerifyRootHintsBeforeWrite( pzone ) )
    {
        DNS_STATUS tempStatus;

        DNS_DEBUG( INIT, (
            "Attempt to write back root-hints to DS.\n" ));

        //  write is overwrite, since we just failed to load from DS
        //  overwrite causes delete, so isn't necessarily safe

        tempStatus = Ds_WriteZoneToDs(
                        g_pRootHintsZone,
                        dsZoneWriteFlags );

        if ( tempStatus == ERROR_SUCCESS )
        {
            g_pRootHintsZone->fDsIntegrated = TRUE;
            g_pRootHintsZone->fDirty = FALSE;
            CLEAR_ROOTHINTS_DS_DIRTY( g_pRootHintsZone );
        }
        ELSE
        {
            DNS_DEBUG ( DS, (
                "Error <%lu,%lu>: Failed to write RootHints to the DS\n",
                tempStatus, status ));
            ASSERT ( FALSE );
        }
    }

    //  unlock root-hints "zone"

    Zone_UnlockAfterAdminUpdate( pzone );

    return( status );
}



BOOL
Zone_VerifyRootHintsBeforeWrite(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Verify can do cache write back.
    Note this entails:
        1) Cache auto-update supported.
        2) Root name servers with writable A records exist.

Arguments:

    pZone -- ptr to zone;  we have this parameter so may write
        root hints out of a root zone that's being deleted

Return Value:

    TRUE if cache update should proceed.
    FALSE otherwise.

--*/
{
    PDB_NODE    pnodeRoot;  // root node
    PDB_RECORD  prrNS;      // NS resource record
    PDB_NODE    pnodeNS;    // name server node

    //
    //  verify at least one root NS with A available
    //

    pnodeRoot = pZone->pTreeRoot;
    if ( !pnodeRoot )
    {
        return( FALSE );
    }

    Dbase_LockDatabase();
    prrNS = NULL;

    while ( 1 )
    {
        //  get next NS

        prrNS = RR_FindNextRecord(
                    pnodeRoot,
                    DNS_TYPE_NS,
                    prrNS,
                    0 );
        if ( !prrNS )
        {
            DNS_PRINT(( "ERROR:  no root NS with A records available.\n" ));
            Dbase_UnlockDatabase();
            return( FALSE );
        }

        //  find A record for this NS
        //  if no A records, loop back and try next NS

        pnodeNS = Lookup_FindGlueNodeForDbaseName(
                        NULL,       // cache zone
                        & prrNS->Data.NS.nameTarget );
        if ( !pnodeNS )
        {
            continue;
        }

        if ( ! RR_FindNextRecord(
                    pnodeNS,
                    DNS_TYPE_A,
                    NULL,
                    0 ) )
        {
            Dbg_DbaseNode(
                "WARNING:  no A records for root NS node",
                pnodeNS );
            continue;
        }
        break;
    }

    //  found at least one NS, with at least one A record

    DNS_DEBUG( SHUTDOWN, ( "Verified cache update is allowed.\n" ));
    Dbase_UnlockDatabase();
    return( TRUE );
}



DNS_STATUS
Zone_WriteBackRootHints(
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Write back root hints to file or DS.

Arguments:

    fForce -- write even if not dirty

Return Value:

    ERROR_SUCCESS if root-hints written or not dirty.
    ErrorCode on failure.

--*/
{
    PZONE_INFO pzone = NULL;
    DNS_STATUS status = ERROR_SUCCESS;

    DNS_DEBUG( RPC, ( "Zone_WriteBackRootHints( fForce=%d )\n", fForce ));

    //
    //  find zone
    //
    //  could write root hints from authoritative zone
    //  however, DS partners should just host auth root zone
    //

    pzone = g_pRootHintsZone;
    if ( !pzone || IS_ROOT_AUTHORITATIVE() )
    {
        DNS_DEBUG( INIT, (
            "No root-hints to write.\n"
            "\tServer is %s root authoritative.\n",
            IS_ROOT_AUTHORITATIVE() ? "" : "NOT"
            ));
        return( ERROR_CANTWRITE );
    }

    if ( !pzone->fDirty && !fForce )
    {
        DNS_DEBUG( INIT, (
            "Root-hints not dirty, and force-write not set.\n"
            "\tSkipping root-hint write.\n" ));
        return( ERROR_SUCCESS );
    }

    //
    //  never write empty root hints
    //      - always better to live with what we've got
    //      - clear dirty flag so not repetitively making this test
    //

    if ( ! Zone_VerifyRootHintsBeforeWrite( pzone ) )
    {
        DNS_DEBUG( INIT, (
            "No Root-hints to write back!\n"
            "\tSkipping write.\n" ));
        pzone->fDirty = FALSE;
        return( ERROR_SUCCESS );
    }

    //
    //  choose DS or file write based on boot method
    //
    //  DEVNOTE: write root-hints to file even in DS case?
    //      if loaded originally from file and converted, nice
    //      to write back to file
    //
    //  DEVNOTE: some way of introducing whole new root-hints file
    //

    switch ( SrvCfg_fBootMethod )
    {
        case BOOT_METHOD_UNINITIALIZED:
        case BOOT_METHOD_DIRECTORY:

            //  Write to DS
            //      - must be "DS-dirty" as regular dirty flag
            //      can be set by update FROM DS
            //      - take update lock, to lock out DS-poll while write

            if ( !fForce && !IS_ROOTHINTS_DS_DIRTY(pzone) )
            {
                DNS_DEBUG( INIT, (
                    "RootHints not DS dirty, skipping write!\n" ));
                break;
            }
            if ( ! Zone_LockForDsUpdate(pzone) )
            {
                DNS_DEBUG( INIT, (
                    "Unable to lock RootHints for DS write -- skipping write!\n" ));
                break;
            }

            status = Ds_WriteZoneToDs(
                        pzone,
                        DNS_ZONE_LOAD_OVERWRITE_DS      // write current in memory copy
                        );

            if ( status == ERROR_SUCCESS )
            {
                // Succeeded-- we're ds integrated.
                pzone->fDsIntegrated = TRUE;
                pzone->fDirty = FALSE;
                CLEAR_ROOTHINTS_DS_DIRTY( pzone );
                Zone_UnlockAfterDsUpdate(pzone);
                break;
            }

            Zone_UnlockAfterDsUpdate(pzone);

            //
            //  Fail over to file write
            //

        case BOOT_METHOD_REGISTRY:
        case BOOT_METHOD_FILE:

            if ( !pzone->pwsDataFile )
            {
                pzone->pwsDataFile = DNS_DEFAULT_CACHE_FILE_NAME;
            }
            if ( !File_WriteZoneToFile( pzone, NULL ) )
            {
                status = ERROR_CANTWRITE;
            }
            else
            {
                //
                // Commit file name to zone & set error code to success
                //

                status = ERROR_SUCCESS;
                pzone->pwsDataFile = Dns_StringCopyAllocate_W(
                                        DNS_DEFAULT_CACHE_FILE_NAME,
                                        0 );
            }
            break;

        default:
            DNS_DEBUG( DS, (
               "ERROR: INVALID Boot Method. Logic Error\n" ));
            ASSERT ( FALSE );
            status =  ERROR_INVALID_PARAMETER;
            break;
    }

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG ( DS, (
           "Error <%lu>: Failed to write back root hints\n",
           status ));
    }

    return( status );
}



//
//  Create default zone records
//
//  These are used extensively with CreateNewPrimary
//  Shouldn't need special code.
//

PDB_RECORD
buildLocalHostARecords(
    IN      DWORD           dwTtl
    )
/*++

Routine Description:

    Build list of A records for this host.

    Only build records corresponding to listening IPs.

Arguments:

    dwTtl -- default TTL for zone.

Return Value:

    A record list for this DNS server.
    NULL on error.

--*/
{
    PDB_RECORD      prr;
    DWORD           i;
    PIP_ARRAY       parrayIp;
    DNS_LIST        rrList;


    DNS_DEBUG( INIT, (
        "buildLocalHostARecords()\n" ));

    //
    //  if specific publish list use it
    //
    //  DEVNOTE: should we cross check against bound addrs?
    //
    //  note, copy pointer so have list even if list changes
    //      during run time
    //

    parrayIp = SrvCfg_aipPublishAddrs;
    if ( !parrayIp )
    {
        parrayIp = g_BoundAddrs;
        if ( !parrayIp )
        {
            return( NULL );
        }
    }

    //
    //  create host A records
    //
    //  server's IP address is data
    //  if listen addresses use those, otherwise use all server addresses
    //

    DNS_LIST_INIT( &rrList );

    for ( i=0; i<parrayIp->AddrCount; i++ )
    {
        IP_ADDRESS  ip = parrayIp->AddrArray[i];

        if ( !SrvCfg_fPublishAutonet && DNS_IS_AUTONET_IP(ip) )
        {
            continue;
        }

        prr = RR_CreateARecord(
                    ip,
                    dwTtl,
                    MEMTAG_RECORD_AUTO
                    );
        IF_NOMEM( !prr )
        {
            DNS_PRINT((
                "ERROR:  Unable to create A record for local IP %s\n",
                IP_STRING( ip )
                ));
            break;
        }
        SET_ZONE_TTL_RR(prr);

        DNS_LIST_ADD( &rrList, prr );
    }

    return( (PDB_RECORD)rrList.pFirst );
}



DNS_STATUS
createDefaultNsHostARecords(
    IN OUT  PZONE_INFO      pZone,
    IN      PDB_NAME        pHostName
    )
/*++

Routine Description:

    Create default host A records for this machine.

    Note, assumes pHostNode is valid ptr to a domain node, that
    corresponds to this servers host name.  No checking is done.

    This routine exists to service the default SOA and NS creation
    routines.

Arguments:

    pZone -- zone to create NS record for

    pHostNode -- ptr to domain node for this server

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_RPC_RECORD precord;
    PDB_RECORD      prr;
    PDB_NODE        pnodeHost;
    DWORD           i;
    DWORD           lookupFlag;
    PIP_ARRAY       parrayIp;

    DNS_DEBUG( INIT, (
        "createDefaultNsHostARecords()\n"
        "\tzone = %s\n",
        pZone->pszZoneName ));

    IF_DEBUG( INIT )
    {
        Dbg_DbaseName(
            "NsHost name to be created:",
            pHostName,
            "\n" );
    }

    //
    //  find or create if within zone
    //
    //      - if loading, try in load zone, otherwise in current zone
    //

    lookupFlag = LOOKUP_NAME_FQDN | LOOKUP_WITHIN_ZONE;

    if ( IS_ZONE_LOADING(pZone) )
    {
        lookupFlag |= LOOKUP_LOAD;
    }

    pnodeHost = Lookup_ZoneNode(
                    pZone,
                    pHostName->RawName,
                    NULL,               // no message
                    NULL,               // no lookup name
                    lookupFlag,
                    NULL,               // create but only WITHIN zone
                    NULL                // following node ptr
                    );

    if ( !pnodeHost )
    {
        DNS_DEBUG( INIT, (
            "Skipping NS host A record create -- node outside zone.\n" ));
        return( ERROR_SUCCESS );
    }

    //
    //  if the NS host lies WITHIN the zone being created
    //      AND
    //  no A records already exist for the host, then create A
    //
    //  DEVNOTE: do we need to do outside zone, or underneath zone glue?
    //      it is very nice to have default records even if outside zone
    //      underneath is even more useful as if delegated zone on another
    //      server, really does require recursion to reach
    //

#if 0
    //if ( !IS_AUTH_NODE(pnodeHost) )

    //  could restrict to non-outside, but already done in lookup

    if ( IS_OUTSIDE_NODE(pnodeHost) )
    {
        DNS_DEBUG( INIT, (
            "Skipping NS host A record create -- node (%p %s) in subzone.\n",
            pnodeHost,
            pnodeHost->szLabel ));
        return( ERROR_SUCCESS );
    }
#endif

    if ( RR_FindNextRecord(
                pnodeHost,
                DNS_TYPE_A,
                NULL,
                0 ) )
    {
        return( ERROR_SUCCESS );
    }

    parrayIp = g_BoundAddrs;
    if ( !parrayIp )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  create host A records
    //
    //  server's IP address is data
    //  if listen addresses use those, otherwise use all server addresses
    //

    for ( i=0; i<parrayIp->AddrCount; i++ )
    {
        prr = RR_CreateARecord(
                    parrayIp->AddrArray[i],
                    pZone->dwDefaultTtl,
                    MEMTAG_RECORD_AUTO
                    );
        IF_NOMEM( !prr )
        {
            DNS_PRINT((
                "ERROR:  Unable to create A record for %s,\n"
                "\twhile auto-creating records for zone %s.\n",
                IP_STRING( parrayIp->AddrArray[i] ),
                pZone ));
            status = DNS_ERROR_NO_MEMORY;
            break;
        }

        SET_ZONE_TTL_RR(prr);

        status = RR_AddToNode(
                    pZone,
                    pnodeHost,
                    prr
                    );
        if ( status != ERROR_SUCCESS )
        {
            RR_Free( prr );
        }
    }

    return( status );
}



DNS_STATUS
Zone_CreateDefaultSoa(
    OUT     PZONE_INFO      pZone,
    IN      LPSTR           pszAdminEmailName
    )
/*++

Routine Description:

    Create new primary zone, including
        - zone info (optional)
        - SOA (default values)
        - NS (for this server)

    For use by admin tool or auto-create reverse zone.

Arguments:

    ppZone -- addr of zone ptr;  if zone ptr NULL zone is created
        if zone ptr MUST be existing zone
        or

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_RECORD      prr;

    DNS_DEBUG( INIT, (
        "Zone_CreateDefaultSoa()\n"
        "\tpszZoneName      = %s\n"
        "\tpszAdminEmail    = %s\n",
        pZone->pszZoneName,
        pszAdminEmailName ));

    //
    //  create SOA, no existing SOA, so default fixed fields
    //

    prr = RR_CreateSoa(
                NULL,               // no existing SOA
                NULL,               // no admin name in dbase form
                pszAdminEmailName
                );
    if ( !prr )
    {
        ASSERT( FALSE );
        status = DNS_ERROR_INVALID_DATA;
        goto Failed;
    }

    //
    //  save default TTL for setting NEW default records
    //

    pZone->dwDefaultTtl = prr->Data.SOA.dwMinimumTtl;
    pZone->dwDefaultTtlHostOrder = ntohl( pZone->dwDefaultTtl );

    //
    //  enlist SOA
    //

    status = RR_AddToNode(
                pZone,
                pZone->pZoneRoot ? pZone->pZoneRoot : pZone->pLoadZoneRoot,
                prr
                );
    if ( status != ERROR_SUCCESS )
    {
        RR_Free( prr );
    }

    //
    //  make sure have A records at server's hostname
    //

    status = createDefaultNsHostARecords(
                pZone,
                & prr->Data.SOA.namePrimaryServer
                );
Failed:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Failed to create default SOA record (and host A) for zone!\n"
            "\tzone = %s\n",
            pZone->pszZoneName ));
    }
    return( status );
}



DNS_STATUS
Zone_CreateDefaultNs(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Create default NS record and NS host A record for zone.

Arguments:

    pZone -- zone to create NS record for

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PCHAR           pszserverName;
    PDB_RECORD      prr = NULL;
    CHAR            chSrvNameBuf[ DNS_MAX_NAME_LENGTH ];

    DNS_DEBUG( INIT, (
        "Zone_CreateDefaultNs()\n"
        "\tpszZoneName  = %s\n",
        pZone->pszZoneName ));

    //
    //  Do nothing if auto NS creation is turned off for this zone.
    //

    if ( pZone->fDisableAutoCreateLocalNS )
    {
        DNS_DEBUG( INIT, (
            "Zone_CreateDefaultNs: doing nothing for zone %s\n",
            pZone->pszZoneName ));
        return ERROR_SUCCESS;
    }

    //
    //  create NS record for server name
    //

    prr = RR_CreatePtr(
                NULL,                   // no dbase name
                SrvCfg_pszServerName,
                DNS_TYPE_NS,
                pZone->dwDefaultTtl,
                MEMTAG_RECORD_AUTO
                );
    if ( !prr )
    {
        ASSERT( FALSE );
        status = DNS_ERROR_INVALID_DATA;
        goto Failed;
    }

    //
    //  enlist NS
    //

    status = RR_AddToNode(
                pZone,
                pZone->pZoneRoot ? pZone->pZoneRoot : pZone->pLoadZoneRoot,
                prr
                );
    if ( status != ERROR_SUCCESS )
    {
        RR_Free( prr );
        goto Failed;
    }

    //
    //  make sure have A records at server's hostname
    //

    status = createDefaultNsHostARecords(
                pZone,
                & prr->Data.NS.nameTarget );

Failed:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Failed to create default NS record (and host A) for zone!\n"
            "\tzone = %s\n",
            pZone->pszZoneName ));
    }
    return( status );
}



DNS_STATUS
Zone_CreateLocalHostPtrRecord(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Create local host PTR record.
    This is used for default creation of 127.in-addr.arpa zone.

Arguments:

    pZone -- zone to create NS record for

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_NODE        pnodeLoopback;
    PDB_RECORD      prr;

    DNS_DEBUG( INIT, (
        "Zone_CreateLocalHostPtrRecord()\n"
        "\tpszZoneName  = %s\n",
        pZone->pszZoneName ));


    //
    //  for loopback zone, create loopback record
    //      => 127.0.0.1 pointing to "localhost"
    //

    if ( _stricmp( pZone->pszZoneName, "127.in-addr.arpa" ) )
    {
        ASSERT( FALSE );
        status = DNS_ERROR_INVALID_DATA;
        goto Failed;
    }

    //
    //  create loopback name
    //

    pnodeLoopback = Lookup_ZoneNodeFromDotted(
                        pZone,
                        "1.0.0",    // 1.0.0.127.in-addr.arpa, relative to zone name
                        0,
                        LOOKUP_NAME_RELATIVE | LOOKUP_LOAD,
                        NULL,       // create node
                        & status
                        );
    if ( !pnodeLoopback )
    {
        DNS_PRINT((
            "ERROR: failed to create loopback address node.\n"
            "\tstatus = %p.\n",
            status ));
        goto Failed;
    }

    //  create PTR record

    prr = RR_CreatePtr(
                NULL,           // no dbase name
                "localhost.",
                DNS_TYPE_PTR,
                pZone->dwDefaultTtl,
                MEMTAG_RECORD_AUTO
                );
    IF_NOMEM( !prr )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_NO_MEMORY );
    }

    //
    //  enlist PTR
    //

    status = RR_AddToNode(
                pZone,
                pnodeLoopback,
                prr
                );
    if ( status != ERROR_SUCCESS )
    {
        RR_Free( prr );
        ASSERT( FALSE );
        goto Failed;
    }

Failed:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Failed to create default \"localhost\" record!\n"
            "\tzone = %s\n",
            pZone->pszZoneName ));
    }
    return( status );
}



BOOL
isSoaPrimaryGivenServer(
    IN      LPSTR           pszServer,
    IN      PZONE_INFO      pZone,
    IN      PDB_RECORD      pSoaRR
    )
/*++

Routine Description:

    Checks if SOA primary is given name.

Arguments:

    pszServer -- server name to match

    pZone -- zone to check

    pSoaRR -- SOA to check if not (yet) zone SOA

Return Value:

    TRUE if SOA primary name is given name.
    FALSE otherwise.

--*/
{
    PDB_RECORD  prrSoa = pSoaRR;
    DB_NAME     namePrimary;
    DNS_STATUS  status;

    //
    //  zone SOA if not given SOA
    //

    if ( !prrSoa )
    {
        prrSoa = pZone->pSoaRR;
        ASSERT( prrSoa );
    }

    //
    //  read given name into dbase name format
    //

    status = Name_ConvertFileNameToCountName(
                & namePrimary,
                pszServer,
                0 );
    if ( status == DNS_ERROR_INVALID_NAME )
    {
        ASSERT( FALSE );
        return( FALSE );
    }

    //
    //  compare names
    //

    return  Name_IsEqualCountNames(
                & namePrimary,
                & prrSoa->Data.SOA.namePrimaryServer
                );
}



VOID
Zone_SetSoaPrimaryToThisServer(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Sets the primary in SOA to this server.

    Note:  this does NOT do an update, but directly
        munges the database.

Arguments:

    pZone -- zone to make primary on this server

Return Value:

    None.

--*/
{
    PDB_RECORD  prr;
    DNS_STATUS  status;
    UPDATE      update;

    DNS_DEBUG( INIT, (
        "setSoaPrimaryToThisServer( %s )\n",
        pZone->pszZoneName ));

    //
    //  this is only interesting for PRIMARY, non-auto-created zones
    //
    //  DEVNOTE: if allow PnP server name change
    //      then this would be interesting for AutoCreated zones too
    //

    if ( !IS_ZONE_PRIMARY(pZone) || pZone->fAutoCreated )
    {
        DNS_PRINT((
            "ERROR:  setSoaPrimaryToThisServer() for zone (%s)\n",
            pZone->pszZoneName ));
        return;
    }

    //
    //  if SOA primary already pointing at this server -- done
    //

    if ( isSoaPrimaryGivenServer(
            SrvCfg_pszServerName,
            pZone,
            NULL ) )
    {
        return;
    }

    //
    //  create SOA defaulting primary name
    //

    prr = RR_CreateSoa(
                pZone->pSoaRR,
                NULL,       //  default primary
                NULL        //  default admin
                );
    if ( !prr )
    {
        //  log failure?
        ASSERT( FALSE );
        return;
    }

    //
    //  put new SOA in RR list
    //      - note if already exists, record cleanup done in RR_UpdateAdd()
    //
    //  note:  this is NOT done as formal update so that DS primaries
    //  do not repeatedly ping-pong the SOA record data
    //

    update.pDeleteRR = NULL;

    status = RR_UpdateAdd(
                pZone,
                pZone->pZoneRoot,
                prr,        // new SOA
                & update,   // dummy to recv deleted SOA record
                0           // no flag
                );
    if ( status != ERROR_SUCCESS )
    {
        if ( status != DNS_ERROR_RECORD_ALREADY_EXISTS )
        {
            DNS_PRINT((
                "ERROR:  SOA replace at zone %s failed.\n"
                "\tpZone = %p\n"
                "\tpZoneRoot = %p\n",
                pZone->pszZoneName,
                pZone,
                pZone->pZoneRoot ));
            ASSERT( FALSE );
        }
        return;
    }

    //
    //  attach new SOA to zone
    //  free previous SOA -- with timeout
    //

    DNS_DEBUG( UPDATE, (
        "Replacing zone %s SOA with one at %p using local primary.\n",
        pZone->pszZoneName,
        prr ));

    if ( update.pAddRR != prr )
    {
        ASSERT( FALSE );
        return;
    }
    ASSERT( update.pDeleteRR );

    pZone->pSoaRR = prr;

    RR_Free( update.pDeleteRR );

    pZone->fDirty = TRUE;
}



VOID
setDefaultSoaValues(
    IN      PZONE_INFO      pZone,
    IN      PDB_RECORD      pSoaRR      OPTIONAL
    )
/*++

Routine Description:

    Set default SOA values.

Arguments:

    pZone -- zone to check

    pSoaRR -- SOA record;  if NULL use current zone SOA

Return Value:

    None

--*/
{
    DWORD   serialNo = 0;

    DNS_DEBUG( INIT, (
        "setDefaultSoaValues( %s )\n",
        pZone->pszZoneName ));

    ASSERT( IS_ZONE_PRIMARY(pZone) );

    if ( !pSoaRR )
    {
        pSoaRR = pZone->pSoaRR;
        if ( !pSoaRR )
        {
            ASSERT( FALSE );
            return;
        }
    }

    //
    //  check if have default to force
    //

    if ( SrvCfg_dwForceSoaSerial     ||
         SrvCfg_dwForceSoaRefresh    ||
         SrvCfg_dwForceSoaRetry      ||
         SrvCfg_dwForceSoaExpire     ||
         SrvCfg_dwForceSoaMinimumTtl )
    {
        if ( SrvCfg_dwForceSoaSerial )
        {
            serialNo = SrvCfg_dwForceSoaSerial;
            INLINE_DWORD_FLIP( pSoaRR->Data.SOA.dwSerialNo, serialNo );
        }
        if ( SrvCfg_dwForceSoaRefresh )
        {
            INLINE_DWORD_FLIP( pSoaRR->Data.SOA.dwRefresh, SrvCfg_dwForceSoaRefresh );
        }
        if ( SrvCfg_dwForceSoaRetry )
        {
            INLINE_DWORD_FLIP( pSoaRR->Data.SOA.dwRetry, SrvCfg_dwForceSoaRetry );
        }
        if ( SrvCfg_dwForceSoaExpire )
        {
            INLINE_DWORD_FLIP( pSoaRR->Data.SOA.dwExpire, SrvCfg_dwForceSoaExpire );
        }
        if ( SrvCfg_dwForceSoaMinimumTtl )
        {
            INLINE_DWORD_FLIP( pSoaRR->Data.SOA.dwMinimumTtl, SrvCfg_dwForceSoaMinimumTtl );
        }
        pZone->fDirty = TRUE;
        pZone->fRootDirty = TRUE;

        if ( serialNo )
        {
            pZone->dwSerialNo = serialNo;
            pZone->dwLoadSerialNo = serialNo;
        }
    }
}



BOOLEAN
Zone_SetAutoCreateLocalNS(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    This routine decides if the local server name should be automagically 
    added to the NS list for a particular zone.

    The decision is made like this:

    Inputs:
        DisableAutoNS - server level flag disabling auto NS RR creation
        AllowNSList - zone level list of server IPs allowed to auto NS create

    If DisableAutoNS is TRUE, no NS RR will ever be auto created.

    If the zone's AllowNSList is empty, any server can add themselves to
    the NS list, otherwise there must be an intersection between the server's
    IP address list and the AllowNSList for the zone.

Arguments:

    pZone -- zone to check

Return Value:

    TRUE if we desire the local server name to be added as an NS for the zone,
    note that the zone's flag is set as well.

--*/
{
    BOOLEAN     fAddLocalServerAsNS = FALSE;

    ASSERT( pZone );

    if ( !IS_ZONE_DSINTEGRATED( pZone ) ||
        !SrvCfg_fNoAutoNSRecords &&
        ( !pZone->aipAutoCreateNS ||
            pZone->aipAutoCreateNS->AddrCount == 0 ||
            Dns_IsIntersectionOfIpArrays(
                        pZone->aipAutoCreateNS,
                        g_ServerAddrs ) ) )
    {
        fAddLocalServerAsNS = TRUE;
    }
    DNS_DEBUG( INIT, (
        "Zone_SetAutoCreateLocalNS( %s ) = %d\n",
        pZone->pszZoneName,
        fAddLocalServerAsNS ));

    pZone->fDisableAutoCreateLocalNS = !fAddLocalServerAsNS;
    
    return fAddLocalServerAsNS;
}   //  Zone_SetAutoCreateLocalNS



PUPDATE_LIST
checkAndFixDefaultZoneRecords(
    IN      PZONE_INFO      pZone,
    IN      BOOL            fPnP
    )
/*++

Routine Description:

    Check for and fix up default zone records.

Arguments:

    pZone -- zone to check

    fPnP -- called as a result of PnP

Return Value:

    Ptr to update list to execute, if updates exist.
    NULL if no updates necessary, or error.

--*/
{
    PDB_RECORD      prr;
    PDB_NODE        pnodeNewHostname;
    PDB_NODE        pnodeOldHostname;
    UPDATE_LIST     updateList;
    PUPDATE_LIST    pupdateList = NULL;

    DNS_DEBUG( INIT, (
        "checkAndFixDefaultZoneRecords( %s )\n",
        pZone->pszZoneName ));

    //
    //  if bogus server name -- no auto-config desirable
    //

    if ( g_ServerDbaseName.LabelCount <= 1 )
    {
        DNS_DEBUG( INIT, (
            "Skipping auto-config on zone %S -- bogus server name %s\n",
            pZone->pwsZoneName,
            SrvCfg_pszServerName ));
    }

    //
    //  If the zone is file-backed and the AutoConfigFileZones
    //  key allows it, update the SOA with default values.
    //

    if ( !IS_ZONE_PRIMARY( pZone ) )
    {
        ASSERT( FALSE );
        return( NULL );
    }

    if ( !pZone->fDsIntegrated && !pZone->bDcPromoConvert )
    {
        if ( ( pZone->fAllowUpdate ?
                    ZONE_AUTO_CONFIG_UPDATE :
                    ZONE_AUTO_CONFIG_STATIC ) &
                SrvCfg_fAutoConfigFileZones )
        {
            DNS_DEBUG( INIT, (
                "Auto-config zone %S\n",
                pZone->pwsZoneName ));

            //  Drop through and do actual update work below.
        }
        else
        {
            //
            //  Skip auto-config but if this is not a PnP event set SOA 
            //  defaults (numeric fields only) even though update is turned 
            //  off.
            //

            DNS_DEBUG( INIT, (
                "Skip auto-config on zone %s\n",
                pZone->pszZoneName ));

            if ( !fPnP )
            {
                setDefaultSoaValues( pZone, NULL );
            }
            return( NULL );
        }
    }

    //  init update list
    //  will allocate a copy, only if build updates

    pupdateList = &updateList;

    Up_InitUpdateList( pupdateList );

    //
    //  two main call paths
    //      - zone load
    //      - PnP change
    //
    //  three scenarios
    //  on zone load:
    //
    //      1) primary server NAME change
    //          - fix SOA
    //          - fix NS, delete old, add new
    //          - tear down old NS host
    //          - create new NS with current listen IPs
    //
    //      2) replica record creation
    //          - build NS
    //          - create new NS with current listen IPs
    //
    //  on PnP:
    //
    //      3) IP change
    //          - modify A records at host to reflect current listen list
    //

    if ( fPnP )
    {
        goto IpChange;
    }

    //
    //  Create NS record if this server is supposed to publish itself
    //  as an NS for this zone. If not, delete NS record for this server.
    //
    //  DEVNOTE: should optimize by testing that not already there
    //  DEVNOTE: doing for all zones?
    //  DEVNOTE: could have some sort of agressive configuration key
    //

    //  if ( pZone->fDsIntegrated || SrvCfg_pszPreviousServerName )

    prr = RR_CreatePtr(
                NULL,                   // no dbase name
                SrvCfg_pszServerName,
                DNS_TYPE_NS,
                pZone->dwDefaultTtl,
                MEMTAG_RECORD_AUTO );
    if ( !prr )
    {
        goto Failed;
    }

    Up_CreateAppendUpdate(
        pupdateList,
        pZone->pZoneRoot,
        pZone->fDisableAutoCreateLocalNS ? NULL : prr,      //  add RR
        0,                                                  //  delete type
        pZone->fDisableAutoCreateLocalNS ? prr: NULL );     //  delete RR

    //
    //  have old name, clean up any remaining old info
    //

    if ( SrvCfg_pszPreviousServerName )
    {
        //
        //  if SOA primary pointing at previous hostname?
        //      - if not, no SOA edit for this zone
        //      - if yes, change SOA to point at new hostname
        //

        if ( isSoaPrimaryGivenServer(
                    SrvCfg_pszPreviousServerName,
                    pZone,
                    NULL ) )
        {
            //  build new SOA RR
            //      - default primary name to this server

            prr = RR_CreateSoa(
                        pZone->pSoaRR,
                        NULL,       //  default primary
                        NULL        //  default admin
                        );
            if ( !prr )
            {
                goto Failed;
            }

            //  if forcing specific SOA values -- set them up on new record

            setDefaultSoaValues( pZone, prr );

            Up_CreateAppendUpdate(
                pupdateList,
                pZone->pZoneRoot,
                prr,                // add SOA rr
                0,                  // no delete type
                NULL                // no delete RRs
                );
        }

        //
        //  delete old NS record
        //      - note already built new one above
        //

        prr = RR_CreatePtr(
                    NULL,                   // no dbase name
                    SrvCfg_pszPreviousServerName,
                    DNS_TYPE_NS,
                    pZone->dwDefaultTtl,
                    MEMTAG_RECORD_AUTO
                    );
        if ( !prr )
        {
            goto Failed;
        }

        Up_CreateAppendUpdate(
            pupdateList,
            pZone->pZoneRoot,
            NULL,               // no add RR
            0,                  // no delete type
            prr                 // delete NS with old name
            );

        //
        //  build root update
        //
        //  DEVNOTE: should be able to do multi-record update at name
        //          then just build IP list here, rather than updates
        //          but currently not supported
#if 0
        Up_CreateAppendUpdate(
            pupdateList,
            pZone->pZoneRoot,
            rrList.pFirst,      // add RRs
            0,                  // no delete type
            NULL                // no delete RRs
            );
#endif

        //
        //  delete A records at old hostname -- if in zone
        //      AAAA records also?
        //

        pnodeOldHostname = Lookup_FindZoneNodeFromDotted(
                                pZone,
                                SrvCfg_pszPreviousServerName,
                                NULL,       // no closest
                                NULL        // no status
                                );

        if ( !pnodeOldHostname  ||  IS_OUTSIDE_ZONE_NODE(pnodeOldHostname) )
        {
            DNS_DEBUG( INIT, (
                "Old server hostname %s, not within zone %s\n",
                SrvCfg_pszPreviousServerName,
                pZone ));
            goto IpChange;
        }
        Up_CreateAppendUpdate(
            pupdateList,
            pnodeOldHostname,
            NULL,
            DNS_TYPE_A,         // delete all A records
            NULL                // no delete records
            );
    }

    //
    //  even if no name change, if forcing SOA values set them up
    //      - SOA record is current zone SOA

    else
    {
        setDefaultSoaValues( pZone, NULL );
    }


IpChange:

    //
    //  if server's hostname in this zone
    //      => write its A records
    //      - optimize reverse lookup case, skip call
    //
    //  note:  this call does creation in subzone, as for dynamic update having
    //      records for SOA additional data is quite useful
    //

    if ( pZone->fReverse )
    {
        goto Done;
    }
    pnodeNewHostname = Lookup_CreateNodeForDbaseNameIfInZone(
                                pZone,
                                &g_ServerDbaseName );

    if ( !pnodeNewHostname  ||  IS_OUTSIDE_ZONE_NODE(pnodeNewHostname) )
    {
        DNS_DEBUG( INIT, (
            "Server hostname %s, not within zone %s\n",
            SrvCfg_pszServerName,
            pZone ));
        goto Done;
    }

    //
    //  mark this node as server's hostname
    //  this allows us to track updates to this node
    //

    SET_THIS_HOST_NODE( pnodeNewHostname );

    //
    //  build "replace" update of this server's A records
    //
    //  DEVNOTE: optimize so no-update if records already match
    //      currently update is replace and zone ticks forward
    //

    prr = buildLocalHostARecords( pZone->dwDefaultTtl );
    if ( !prr )
    {
        goto Done;
    }

    Up_CreateAppendUpdateMultiRRAdd(
        pupdateList,
        pnodeNewHostname,
        prr,                // add A records for this server
        DNS_TYPE_A,         // signal replace operation
        NULL                // no delete records
        );

Done:

    //
    //  no aging on self registration
    //
    //  DEVNOTE: aging on self-registrations
    //      cool to have this cleaned up as move DNS servers?
    //      however to do that we'd need to get periodic refresh
    //      (server could do it), otherwise have to rely on DNS client
    //

    //  pupdateList->Flag |= DNSUPDATE_AGING_OFF;

    //
    //  if have actual updates, then allocate copy for execution
    //

    if ( IS_EMPTY_UPDATE_LIST( pupdateList ) )
    {
        pupdateList = NULL;
    }
    else
    {
        pupdateList = Up_CreateUpdateList( pupdateList );
    }

    DNS_DEBUG( INIT, (
        "Leaving checkAndFixDefaultZoneRecords( %s )\n"
        "\tupdate list = %p\n",
        pZone->pszZoneName,
        pupdateList ));

    return( pupdateList );


Failed:

    ASSERT( FALSE );
    Up_FreeUpdatesInUpdateList( pupdateList );

    return( NULL );
}



VOID
Zone_CheckAndFixDefaultRecordsOnLoad(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Check for and fix up default records.

    Different from above function in that it is looking to match SOA primary
    with PREVIOUS server name from registry.

Arguments:

    pZone -- zone to check

Return Value:

    None.

--*/
{
    PUPDATE_LIST pupdateList;

    DNS_DEBUG( INIT, (
        "Zone_CheckAndFixDefaultRecordsOnLoad( %s )\n",
        pZone->pszZoneName ));

    //
    //  build update list of zone changes
    //      - server name change
    //      - IP change
    //
    //  if update exists, set for delayed execution
    //

    pupdateList = checkAndFixDefaultZoneRecords(
                    pZone,
                    FALSE               // not PnP
                    );

    DNS_DEBUG( INIT, (
        "Leaving Zone_CheckAndFixDefaultRecordsOnLoad( %s )\n"
        "\tdelayed update list = %p\n",
        pZone->pszZoneName,
        pupdateList ));

    pZone->pDelayedUpdateList = pupdateList;
}



VOID
zoneUpdateOwnRecords(
    IN      PZONE_INFO      pZone,
    IN      BOOL            fIpAddressChange
    )
/*++

Routine Description:

    Guts of Zone_UpdateOwnRecords - build and execute the
    update list required to refresh the server's own records
    in one particular zone.

Arguments:

    pZone -- zone to update records in

    fIpAddressChange -- called as result of an IP address change?

Return Value:

    None

--*/
{
    PUPDATE_LIST    pupdateList = NULL;
    DNS_STATUS      status;

    if ( !pZone )
    {
        goto Done;
    }

    //  Build update.

    pupdateList = checkAndFixDefaultZoneRecords(
                    pZone,
                    fIpAddressChange );
    if ( !pupdateList )
    {
        DNS_DEBUG( UPDATE, (
            "No update list generated by PnP for zone %s\n",
            pZone->pszZoneName ));
        goto Done;
    }

    DNS_DEBUG( PNP, (
        "Update list %p for own records for zone %s\n",
        pupdateList,
        pZone->pszZoneName ));

    //  Attempt to execute update.

    status = Up_ExecuteUpdate(
                pZone,
                pupdateList,
                DNSUPDATE_AUTO_CONFIG | DNSUPDATE_LOCAL_SYSTEM );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( PNP, (
            "ERROR:  PnP update (%p) for zone %s failed!\n"
            "    status = %d (%p)\n",
            pupdateList,
            pZone->pszZoneName,
            status, status ));
    }

    Done:

    FREE_HEAP( pupdateList );

    return;
}   //  zoneUpdateOwnRecords



VOID
Zone_UpdateOwnRecords(
    IN      BOOL            fIpAddressChange
    )
/*++

Routine Description:

    Update default zone records. This function should be called
    periodically and when the server's IP address changes.

    If the server's IP address (or some other net param ) is changing
    then we need to walk the zone list and update all zones. If this
    is just a periodic update we only need to refresh the zone which
    is authoritative for the server's own hostname.

Arguments:

    fIpAddressChange -- called as result of an IP address change?

Return Value:

    None

--*/
{
    PZONE_INFO      pzone = NULL;

    DNS_DEBUG( PNP, ( "Zone_UpdateOwnRecords().\n" ));

    if ( fIpAddressChange )
    {
        //
        //  Refresh all primary non-reverse zones.
        //

        while ( pzone = Zone_ListGetNextZone( pzone ) )
        {
            if ( !IS_ZONE_PRIMARY( pzone ) || IS_ZONE_REVERSE( pzone ) )
            {
                continue;
            }

            zoneUpdateOwnRecords( pzone, fIpAddressChange );
        }
    }
    else
    {
        //
        //  Refresh the zone authoritative for the server's hostname.
        //

        PDB_NODE    pZoneNode;

        pZoneNode = Lookup_ZoneTreeNodeFromDottedName( 
                        SrvCfg_pszServerName,
                        0,      //  name length
                        0 );    //  flags
        if ( pZoneNode )
        {
            zoneUpdateOwnRecords( pZoneNode->pZone, fIpAddressChange );
        }
    }
}   //  Zone_UpdateOwnRecords



VOID
Zone_CreateDelegationInParentZone(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Create delegation in parent zone.

    Call on new zone create. This function respects the value
    of SrvCfg_dwAutoCreateDelegations and may not actually
    create the delegation depending on this value.

Arguments:

    pZone -- zone to check

Return Value:

    None.

--*/
{
    PDB_RECORD      prr;
    PZONE_INFO      pzoneParent = NULL;
    PDB_NODE        pnodeDelegation;
    UPDATE_LIST     updateList;
    DNS_STATUS      status;

    DNS_DEBUG( RPC, (
        "Zone_CreateDelegationInParentZone( %s )\n",
        pZone->pszZoneName ));

    if ( SrvCfg_dwAutoCreateDelegations == DNS_ACD_DONT_CREATE )
    {
        return;
    }

    //
    //  root zone -- no parent
    //

    if ( IS_ROOT_ZONE( pZone ) )
    {
        return;
    }

    //
    //  find\create delegation in parent zone
    //
    //  DEVNOTE: log errors for unupdateable zones
    //      - off machine (no parent)
    //      - secondary
    //      - below another delegation
    //
    //  DEVNOTE: handle these conditions with dynamic update attempt
    //

    pnodeDelegation = Lookup_CreateParentZoneDelegation(
                            pZone,
                            SrvCfg_dwAutoCreateDelegations ==
                                DNS_ACD_ONLY_IF_NO_DELEGATION_IN_PARENT ?
                                LOOKUP_CREATE_DEL_ONLY_IF_NONE :
                                0,
                            &pzoneParent );
    if ( !pzoneParent )
    {
        return;
    }
    if ( IS_ZONE_SECONDARY( pzoneParent ) || IS_ZONE_FORWARDER( pzoneParent ) )
    {
        return;
    }
    if ( !pnodeDelegation )
    {
        return;
    }
    if ( !EMPTY_RR_LIST( pnodeDelegation ) &&
        SrvCfg_dwAutoCreateDelegations ==
            DNS_ACD_ONLY_IF_NO_DELEGATION_IN_PARENT )
    {
        //  The delegation node has RRs so it is not new. We do not want
        //  to add a delegation to the local server in this case.
        return;
    }

    //
    //  delegation on parent primary
    //

    //  init update list
    //  will allocate a copy, only if build updates

    Up_InitUpdateList( &updateList );

    //
    //  build NS pointing at this server
    //

    prr = RR_CreatePtr(
                NULL,                   // no dbase name
                SrvCfg_pszServerName,
                DNS_TYPE_NS,
                pZone->dwDefaultTtl,
                MEMTAG_RECORD_AUTO
                );
    if ( !prr )
    {
        return;
    }
    Up_CreateAppendUpdate(
        & updateList,
        pnodeDelegation,
        prr,                // add NS with new name
        0,                  // no delete type
        NULL                // no delete RRs
        );

    //
    //  execute update on parent zone
    //

    status = Up_ExecuteUpdate(
                pzoneParent,
                & updateList,
                DNSUPDATE_AUTO_CONFIG | DNSUPDATE_LOCAL_SYSTEM
                );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "WARNING:  Failed parent-delegation update in zone %s!\n"
            "\tnew zone %s\n"
            "\tstatus = %d (%p)\n",
            pzoneParent->pszZoneName,
            pZone->pszZoneName,
            status, status ));
    }

    return;
}


//
//  End zone.c
//



//
//  Zone locking routines
//
//  Need to avoid simultaneous access to zone records for
//      - zone transfer send
//      - zone transfer recv
//      - admin changes
//      - dynamic updates
//
//  Allow multiple transfer sends, which don't change zone, at one time,
//  but avoid any changes during send.
//
//  Implementation:
//      - hold critical section ONLY during test and set of lock bit
//      - lock byte itself indicates zone is locked
//      - individual flags for locking operations
//
//  Lock byte indicates lock type
//      == 0    =>      zone is not locked
//      > 0     =>      count of outstanding read locks
//      < 0     =>      count of outstanding write locks (may be recursive)
//

//
//  DEVNOTE: when bug fixed this can be no-op for retail
//

#define ZONE_LOCK_SET_HISTORY( pzone, file, line ) \
        Lock_SetLockHistory(                    \
            (pzone)->pLockTable,                \
            file,                               \
            line,                               \
            (pzone)->fLocked,                   \
            GetCurrentThreadId() );

//
//  Flag to indicate write lock is assumable by XFR thread
//  Use in place of ThreadId
//  This keeps vending thread from reentering lock, before
//      XFR thread starts
//

#define ZONE_LOCK_ASSUMABLE_ID      ((DWORD)0xaaaaaaaa)


//
//  Waitable locks globals.
//  Wait array will contain shutdown event also.
//

HANDLE  g_hZoneUnlockEvent = NULL;

HANDLE  g_hLockWaitArray[ 2 ];

LONG    g_LockWaitCount = 0;


//
//  Wait polling interval
//  See in code comment about inability to handle all zones
//  effectively with one event
//

#define ZONE_LOCK_WAIT_POLL_INTERVAL        (33)        // 33 ms, 30 cycles a second


//
//  DEVNOTE: zone lock implementation
//
//  More globally should switch to independent lock for forward
//  zones (some sort of combined for reverse).  This lock would
//  then be used for database AND for protecting zone lock flags.
//
//  Even more globally, want to use my fast read\write locks to
//  handle all these issues.  Key focus here just to keep
//  interface opaque enough to change implementation later.
//



BOOL
zoneLockForWritePrivate(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Lock zone for write operation, update or zone transfer recv.

Arguments:

    pZone   -- zone to lock

    dwFlag  -- flag for lock

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    TRUE -- if admin update owns zone and may proceed
    FALSE -- zone is locked

--*/
{
    BOOL    retval;
    DWORD   threadId;

    //  handle no zone case, as admin may be deleting cached records

    if ( !pZone )
    {
        return( TRUE );
    }

    threadId = GetCurrentThreadId();

    //
    //  fast failure path
    //

    if ( pZone->fLocked != 0  &&
        pZone->dwLockingThreadId != threadId )
    {
        return( FALSE );
    }

    //
    //  grab lock CS
    //

    retval = FALSE;

    Zone_UpdateLock( pZone );

    DNS_DEBUG ( LOCK2, (
        "ZONE_LOCK: zone %s; thread 0x%X; fLocked=%d\n\t(%s!%ld)\n",
        pZone->pszZoneName,
        threadId,
        pZone->fLocked,
        pszFile,
        dwLine
        ));

    //  if zone unlocked, grab lock
    //  set thread id, so we can do detect when lock held by this thread
    //  this allows us to do file write with either Read or Write lock

    if ( pZone->fLocked == 0 )
    {
        pZone->fLocked--;
        pZone->dwLockingThreadId = threadId;
        retval = TRUE;
    }

    //  allow multiple levels of update lock
    //  simply dec lock count and continue

    else if ( pZone->dwLockingThreadId == threadId )
    {
        ASSERT( pZone->fLocked < 0 );
        pZone->fLocked--;
        retval = TRUE;
    }

    //  update lock table

    if ( retval )
    {
        if ( dwFlag & LOCK_FLAG_UPDATE )
        {
            pZone->fUpdateLock++;
        }
        if ( dwFlag & LOCK_FLAG_XFR_RECV )
        {
            pZone->fXfrRecvLock++;
        }

        ZONE_LOCK_SET_HISTORY(
            pZone,
            pszFile,
            dwLine );
    }
    else
    {
        Lock_FailedLockCheck(
            pZone->pLockTable,
            pszFile,
            dwLine );
    }

    DNS_DEBUG ( LOCK2, (
        "\tZONE_LOCK(2): fLocked=%d\n", pZone->fLocked ));

    Zone_UpdateUnlock( pZone );

    IF_DEBUG( LOCK )
    {
        if ( !retval )
        {
            DnsDebugLock();
            DNS_PRINT((
                "Failure to acquire write lock for thread %d (%p)\n",
                threadId ));
            Dbg_ZoneLock(
                "Failure to acquire write lock\n",
                pZone );
            DnsDebugUnlock();
        }
    }
    return( retval );
}



BOOL
zoneLockForReadPrivate(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Lock zone for read.

Arguments:

    pZone -- zone to lock

    dwFlag -- lock flags
        LOCK_FLAG_FILE_WRITE if locking for file write

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    TRUE -- zone available for read operation (XFR or file write)
    FALSE -- zone is locked

--*/
{
    BOOL breturn = FALSE;

    //
    //  fast failure path
    //

    if ( pZone->fLocked < 0 )
    {
        return( breturn );
    }

    //
    //  attempt to lock
    //

    Zone_UpdateLock( pZone );

    if ( pZone->fLocked >= 0 )
    {
        //  special case file write, limit to one at a time
        //  and if one going no point in having another go at all
        //  (i.e. no point in waiting)

        if ( dwFlag & LOCK_FLAG_FILE_WRITE )
        {
            if ( pZone->fFileWriteLock )
            {
                Lock_FailedLockCheck(
                    pZone->pLockTable,
                    pszFile,
                    dwLine );
                goto Done;
            }
            pZone->fFileWriteLock = TRUE;
        }

        //  have reader lock
        //      - bump lock count
        //      - log lock
        //      - set TRUE return

        pZone->fLocked++;

        ZONE_LOCK_SET_HISTORY(
            pZone,
            pszFile,
            dwLine );

        breturn = TRUE;
        goto Done;
    }

    //  failed to get lock
    //      - if no wait, done

    Lock_FailedLockCheck(
        pZone->pLockTable,
        pszFile,
        dwLine );

Done:

    Zone_UpdateUnlock( pZone );

    return( breturn );
}



BOOL
waitForZoneLock(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      DWORD           dwMaxWait,
    IN      BOOL            bWrite,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Wait on lock.

    Routine avoids duplicate code for read\write lock waits.

Arguments:

    pZone       -- zone to lock

    dwFlags     -- lock flags

    dwMaxWait   -- wait on lock call

    bWrite      -- TRUE if write, FALSE if read

    pszFile     -- source file (for lock tracking)

    dwLine      -- source line (for lock tracking)

Return Value:

    TRUE -- successfully locked zone
    FALSE -- failed lock

--*/
{
    BOOL    breturn = FALSE;
    DWORD   timeout;
    DWORD   endWaitTime;
    DWORD   retry;
    DWORD   status;

    //
    //  init
    //

    endWaitTime = GetCurrentTime() + dwMaxWait;
    timeout = dwMaxWait;
    retry = 0;

    InterlockedIncrement( &g_LockWaitCount );

    DNS_DEBUG( LOCK2, (
        "Starting %dms waiting on zone %s lock.\n"
        "\tEnd time = %d\n",
        dwMaxWait,
        pZone->pszZoneName,
        endWaitTime ));

    //
    //  wait lock
    //      - if already end of wait, done
    //

    while ( 1 )
    {
        if ( (LONG)timeout < 0 )
        {
            DNS_DEBUG( LOCK, (
                "WARNING:  Lock wait on zone %s expired while checking!\n",
                pZone->pszZoneName ));
            break;
        }

        //  wakeup every few ms to protect against missed unlocks
        //      (see note below)

        status = WaitForMultipleObjects(
                    2,
                    g_hLockWaitArray,
                    FALSE,                // either event
                    ZONE_LOCK_WAIT_POLL_INTERVAL
                    // timeout
                    );

        //  check for shutdown or pause

        if ( fDnsServiceExit  &&  ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, (
                "Blowing out of lock-wait for shutdown.\n" ));
            break;
        }

#if 0
        //  do not currently have any decent way to handle the interval
        //  from last test to entering WaitFMO()
        //  as a result can't use PulseEvent and be done
        //  can't use SetEvent, because do not have a good paradigm for Reset
        //  since event is distributed across multiple zones;  natural place
        //  is Reset on lock failure, but that may starve some other Waiting
        //  thread which wants a different zone, which has come free, but
        //  the thread was not woken from the wait or never entered it before
        //  the ResetEvent()
        //
        //  the simple approach we take is to couple the event with polling
        //  every few ms -- see below
        //

        //  exhausted wait -- done

        if ( status == WAIT_TIMEOUT )
        {
            DNS_DEBUG( LOCK, (
                "Lock wait for zone %s, ends with timeout failure after %d tries.\n",
                pZone->pszZoneName,
                tryCount ));
            break;
        }

        //  retry lock

        ASSERT( status == WAIT_OBJECT_0 );
#endif
        ASSERT( status == WAIT_OBJECT_0 || status == WAIT_TIMEOUT );

        //
        //  try desired lock, but ONLY if "potentially" available
        //      write => unlocked
        //      read  => unlocked or read locked
        //
        //  note:  do NOT need to test recursive lock features as we
        //      are only in WAIT, if first lock attempt failed, so
        //      can't already have zone lock
        //

        if ( bWrite )
        {
            if ( pZone->fLocked == 0 )
            {
                breturn = zoneLockForWritePrivate(
                            pZone,
                            dwFlag,
                            pszFile,
                            dwLine );
                retry++;
            }
        }
        else    // read
        {
            if ( pZone->fLocked > 0 )
            {
                breturn = zoneLockForReadPrivate(
                            pZone,
                            dwFlag,
                            pszFile,
                            dwLine );
                retry++;
            }
        }

        if ( breturn )
        {
            break;
        }

        //  reset timeout for another wait

        timeout = endWaitTime - GetCurrentTime();
    }


    InterlockedDecrement( &g_LockWaitCount );

    IF_DEBUG( LOCK )
    {
        if ( breturn )
        {
            DNS_DEBUG( LOCK2, (
                "Succesful %s wait-lock on zone %s, after %d (ms) wait.\n"
                "\tretry = %d\n",
                bWrite ? "write" : "read",
                pZone->pszZoneName,
                dwMaxWait - timeout,
                retry ));
        }
        else
        {
            DNS_DEBUG( LOCK, (
                "FAILED %s wait-lock on zone %s, after %d (ms) wait.\n"
                "\tretry = %d\n",
                bWrite ? "write" : "read",
                pZone->pszZoneName,
                dwMaxWait - timeout,
                retry ));
        }
    }

    return( breturn );
}



VOID
signalZoneUnlocked(
    VOID
    )
/*++

Routine Description:

    Signal that zone may be unlocked.

    Note, we don't currently have zone specific signal.
    This is strictly an alert to recheck.

Arguments:

    None.

Return Value:

    None

--*/
{
    //  set event to wake up waiting threads
    //      but only bother if someone waiting
    //
    //  DEVNOTE: need signal suppression
    //     two approaches
    //      waiting count -- only problem is keeping current
    //      keep last wait time --
    //          folks keep signalling for a while after complete
    //          BUT easier to keep valid, perhaps with interlock
    //          certainly with CS  BUT requires timer op here
    //
    //  DEVNOTE: pulse is incorrect
    //      because it only effects threads in wait, not those
    //      "about" to be in wait
    //
    //      once we have some idea how to handle this issue, can
    //      switch to intelligent Set\Reset
    //      ideally we'd signal when CS comes free and reset when
    //      taken
    //

    if ( g_LockWaitCount )
    {
        PulseEvent( g_hZoneUnlockEvent );
    }
}



//
//  Public zone lock routines
//

BOOL
Zone_LockInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize zone locking.

    Basically this inits the lock-wait stuff.

Arguments:

    None.

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    //  init zone locking

    g_hZoneUnlockEvent = CreateEvent(
                            NULL,       // no security attributes
                            TRUE,       // create Manual-Reset event
                            FALSE,      // start unsignalled
                            NULL        // no event name
                            );
    if ( !g_hZoneUnlockEvent )
    {
        return( FALSE );
    }

    //  setup wait handle array
    //      - saves doing it each time through wait lock

    g_hLockWaitArray[ 0 ] = g_hZoneUnlockEvent;
    g_hLockWaitArray[ 1 ] = hDnsShutdownEvent;

    return( TRUE );
}



BOOL
Zone_LockForWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      DWORD           dwMaxWait,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Lock zone for write operation, update or zone transfer recv.

Arguments:

    pZone       -- zone to lock

    dwFlag      -- flags for lock

    dwMaxWait   -- wait on lock call

    pszFile     -- source file (for lock tracking)

    dwLine      -- source line (for lock tracking)

Return Value:

    TRUE -- if admin update owns zone and may proceed
    FALSE -- zone is locked

--*/
{
    BOOL    breturn;

    //
    //  wait or no wait, try immediately
    //  if successful OR if not waiting -- done
    //

    breturn = zoneLockForWritePrivate( pZone, dwFlag, pszFile, dwLine );

    if ( breturn || dwMaxWait == 0 )
    {
        return( breturn );
    }

    //
    //  failed -- doing wait
    //

    return  waitForZoneLock(
                pZone,
                dwFlag,
                dwMaxWait,
                TRUE,           // write lock
                pszFile,
                dwLine );
}



VOID
Zone_UnlockAfterWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Unlock zone after admin update.

Arguments:

    pZone -- zone to lock

    dwFlag  -- lock flags

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    None

--*/
{
    //  handle no zone case, as admin may be deleting cached records

    if ( !pZone )
    {
        return;
    }

    Zone_UpdateLock( pZone );

    DNS_DEBUG ( LOCK2, (
        "ZONE_UNLOCK: zone %s; thread 0x%X; fLocked=%d\n\t(%s!%ld)\n",
        pZone->pszZoneName,
        GetCurrentThreadId(),
        pZone->fLocked,
        pszFile,
        dwLine
        ));

    //
    //  verify valid write lock
    //

    if ( pZone->fLocked >= 0  ||
            pZone->dwLockingThreadId != GetCurrentThreadId() )
    {
        Dbg_ZoneLock( "ERROR:  bad zone write unlock:", pZone );

        Lock_SetOffenderLock(
            pZone->pLockTable,
            pszFile,
            dwLine,
            pZone->fLocked,
            GetCurrentThreadId() );

#if DBG
        if ( !(dwFlag & LOCK_FLAG_IGNORE_THREAD) )
        {
            ASSERT( pZone->dwLockingThreadId == GetCurrentThreadId() );
        }
#endif
        ASSERT( pZone->fLocked < 0 );
        pZone->fLocked = 0;
        pZone->dwLockingThreadId = 0;
        goto Unlock;
    }

    //  drop writers recursion count

    pZone->fLocked++;

    //  drop update lock -- if set

    if ( dwFlag & LOCK_FLAG_UPDATE )
    {
        ASSERT( pZone->fUpdateLock );
        pZone->fUpdateLock--;
    }

    //  drop XFR flag

    else if ( dwFlag & LOCK_FLAG_XFR_RECV )
    {
        ASSERT( pZone->fXfrRecvLock );
        pZone->fXfrRecvLock--;
    }

    //  final unlock? -- clear locking thread id

    if ( pZone->fLocked == 0 )
    {
        pZone->dwLockingThreadId = 0;
    }

Unlock:

    ZONE_LOCK_SET_HISTORY(
        pZone,
        pszFile,
        dwLine );

    DNS_DEBUG ( LOCK2, (
        "\tZONE_LOCK(2): fLocked=%d\n", pZone->fLocked ));

    Zone_UpdateUnlock( pZone );

    //  if final unlock -- signal that zone may be available

    if ( pZone->fLocked == 0 )
    {
        signalZoneUnlocked();
    }
    return;
}



VOID
Zone_TransferWriteLockEx(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Transfers zone write lock.
    This is to allow zone transfer recv thread to grab lock for secondary
    control thread.

Arguments:

    pZone -- zone to lock

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    None

--*/
{
    IF_DEBUG( XFR )
    {
        Dbg_ZoneLock(
            "Transferring write lock",
            pZone );
    }
    ASSERT( pZone && IS_ZONE_LOCKED_FOR_WRITE(pZone) && pZone->fXfrRecvLock );

    Zone_UpdateLock( pZone );
    pZone->dwLockingThreadId = ZONE_LOCK_ASSUMABLE_ID;

    ZONE_LOCK_SET_HISTORY(
        pZone,
        pszFile,
        dwLine );

    Zone_UpdateUnlock( pZone );
}



BOOL
Zone_AssumeWriteLockEx(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Assumes zone write lock.
    This is to allow zone transfer recv thread to grab lock for secondary
    control thread.

Arguments:

    pZone -- zone to lock

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    TRUE -- if lock successfully assumed, and thread may proceed
    FALSE -- if some other thread owns lock

--*/
{
    BOOL    retBool;

    IF_DEBUG( XFR )
    {
        Dbg_ZoneLock(
            "Assuming zone write lock",
            pZone );
    }
    ASSERT( pZone && IS_ZONE_LOCKED_FOR_WRITE(pZone) && pZone->fXfrRecvLock );

    Zone_UpdateLock( pZone );

    if ( pZone->dwLockingThreadId != ZONE_LOCK_ASSUMABLE_ID )
    {
        DNS_PRINT((
            "ERROR:  unable to assume write lock for zone %s!\n",
            pZone->pszZoneName ));

        retBool = FALSE;
    }
    else
    {
        pZone->dwLockingThreadId = GetCurrentThreadId();
        retBool = TRUE;

        ZONE_LOCK_SET_HISTORY(
            pZone,
            pszFile,
            dwLine );
    }

    Zone_UpdateUnlock( pZone );

    return( retBool );
}



BOOL
Zone_LockForReadEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      DWORD           dwMaxWait,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Lock zone for read.

Arguments:

    pZone -- zone to lock

    dwFlag -- lock flags
        LOCK_FLAG_FILE_WRITE if locking for file write

    dwWaitMs -- max wait in milliseconds

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    TRUE -- zone available for read operation (XFR or file write)
    FALSE -- zone is locked

--*/
{
    BOOL    breturn;

    //
    //  wait or no wait, try immediately
    //  if successful OR if not waiting -- done
    //

    breturn = zoneLockForReadPrivate( pZone, dwFlag, pszFile, dwLine );

    if ( breturn || dwMaxWait == 0 )
    {
        return( breturn );
    }

    //
    //  failed -- doing wait
    //

    return  waitForZoneLock(
                pZone,
                dwFlag,
                dwMaxWait,
                FALSE,      // read lock
                pszFile,
                dwLine );
}



VOID
Zone_UnlockAfterReadEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Unlock zone after complete read operation (zone transfer or file write).

Arguments:

    pZone -- zone to lock

    dwFlag -- lock flags
        LOCK_FLAG_FILE_WRITE if unlocking after a file write

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    None

--*/
{
    ASSERT( pZone  &&  IS_ZONE_LOCKED_FOR_READ(pZone) );

    Zone_UpdateLock( pZone );

    //  verify read lock

    if ( ! IS_ZONE_LOCKED_FOR_READ(pZone) )
    {
        ASSERT( FALSE );
        goto Unlock;
    }

    //  clear file write lock, if file writer

    if ( dwFlag & LOCK_FLAG_FILE_WRITE )
    {
        ASSERT( pZone->fFileWriteLock );
        pZone->fFileWriteLock = FALSE;
    }

    //  decrement readers count

    pZone->fLocked--;
    ASSERT( pZone->fLocked >= 0 );
    ASSERT( pZone->dwLockingThreadId == 0 );

Unlock:

    ZONE_LOCK_SET_HISTORY(
        pZone,
        pszFile,
        dwLine );

    Zone_UpdateUnlock( pZone );

    //  if final unlock -- signal that zone may be available

    if ( pZone->fLocked == 0 )
    {
        signalZoneUnlocked();
    }
    return;
}



BOOL
Zone_LockForFileWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwMaxWait,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Lock zone for file write.

Arguments:

    pZone       -- zone to lock

    dwMaxWait   -- max wait for lock in ms

    pszFile     -- source file (for lock tracking)

    dwLine      -- source line (for lock tracking)

Return Value:

    TRUE -- if zone transfer owns zone and may proceed
    FALSE -- zone is locked

--*/
{
    //  if thread holds write lock, that's good enough

    Zone_UpdateLock( pZone );

    if ( pZone->dwLockingThreadId )
    {
        if ( pZone->dwLockingThreadId == GetCurrentThreadId() )
        {
            pZone->fFileWriteLock = TRUE;

            ZONE_LOCK_SET_HISTORY(
                pZone,
                pszFile,
                dwLine );

            Zone_UpdateUnlock( pZone );
            return( TRUE );
        }
    }

    Zone_UpdateUnlock( pZone );

    //  otherwise get readers lock
    //  always willing to wait up to 5 seconds

    return  Zone_LockForReadEx(
                pZone,
                LOCK_FLAG_FILE_WRITE,
                dwMaxWait,
                pszFile,
                dwLine );
}



VOID
Zone_UnlockAfterFileWriteEx(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Unlock zone after file write.

Arguments:

    pZone -- zone to lock

    pszFile -- source file (for lock tracking)

    dwLine  -- source line (for lock tracking)

Return Value:

    None

--*/
{
    ASSERT( pZone );
    ASSERT( pZone->fLocked && pZone->fFileWriteLock );

    //  if thread holds write lock, just clear file write flag

    if ( pZone->dwLockingThreadId )
    {
        ASSERT( pZone->dwLockingThreadId == GetCurrentThreadId() );
        pZone->fFileWriteLock = FALSE;
        return;
    }

    //  otherwise clear readers lock

    Zone_UnlockAfterReadEx(
        pZone,
        LOCK_FLAG_FILE_WRITE,
        pszFile,
        dwLine );
}



VOID
Dbg_ZoneLock(
    IN      LPSTR           pszHeader,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Debug print zone lock info.

Arguments:

    pszHeader -- header to print

    pZone -- zone to lock

Return Value:

    None

--*/
{
    DWORD   threadId = GetCurrentThreadId();

    ASSERT( pZone );

    //
    //  this function is sometimes called within DebugPrintLock()
    //  to avoid possible deadlock, can't use Thread_DescriptionMatchingId()
    //      as this will wait on Thread list CS, and there are some
    //      debug prints within certain thread list operations
    //

    DnsPrintf(
        "%s"
        "Lock for zone %s:\n"
        "\tLocked           = %d\n"
        "\tLockingThreadId  = %d (%p)\n"
        "\tUpdateLock       = %d\n"
        "\tXfrRecvLock      = %d\n"
        "\tFileWriteLock    = %d\n"
        "CurrentThreadId    = %d (%p)\n",
        pszHeader ? pszHeader : "",
        pZone->pszZoneName,
        pZone->fLocked,
        pZone->dwLockingThreadId, pZone->dwLockingThreadId,
        pZone->fUpdateLock,
        pZone->fXfrRecvLock,
        pZone->fFileWriteLock,
        threadId, threadId
        );

#if 0
    DnsPrintf(
        "%s"
        "Lock for zone %s:\n"
        "\tLocked           = %d\n"
        "\tLockingThreadId  = %d (%p) title = %s\n"
        "\tUpdateLock       = %d\n"
        "\tXfrRecvLock      = %d\n"
        "\tFileWriteLock    = %d\n"
        "CurrentThreadId    = %d (%p) title = %s\n",
        pszHeader ? pszHeader : "",
        pZone->pszZoneName,
        pZone->fLocked,
        pZone->dwLockingThreadId,
            pZone->dwLockingThreadId,
            Thread_DescrpitionMatchingId( pZone->dwLockingThreadId ),
        pZone->fUpdateLock,
        pZone->fXfrRecvLock,
        pZone->fFileWriteLock,
        threadId,
            threadId,
            Thread_DescrpitionMatchingId( threadId )
        );
#endif
}



DNS_STATUS
setZoneName(
    IN OUT  PZONE_INFO      pZone,
    IN      LPCSTR          pszNewZoneName,
    IN      DWORD           dwNewZoneNameLen
    )
/*++

Routine Description:

    Frees existing zone names (if they exist) and sets up the various
    zone name fields with copies of the new zone name.

    Note: currently if one of the name functions fails the zone will
    be in a totally foobared state. We should save the old names and
    restore on failure?

Arguments:

    pZone -- zone to get new name

    pszNewZoneName -- new name

    dwNewZoneNameLen  -- length of pszNewZoneName or zero if
        pszNewZoneName should be assumed to be NULL-terminated

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;

    FREE_HEAP( pZone->pCountName );

    pZone->pCountName = Name_CreateCountNameFromDottedName(
                            ( LPSTR ) pszNewZoneName,
                            dwNewZoneNameLen );
    if ( !pZone->pCountName )
    {
        status = DNS_ERROR_INVALID_NAME;
        goto Failure;
    }

    FREE_HEAP( pZone->pszZoneName );

    pZone->pszZoneName = DnsCreateStandardDnsNameCopy(
                            ( LPSTR ) pszNewZoneName,
                            dwNewZoneNameLen,
                            0 );    // strict flags not yet implemented
    if ( !pZone->pszZoneName )
    {
        status = DNS_ERROR_INVALID_NAME;
        goto Failure;
    }

    FREE_HEAP( pZone->pwsZoneName );

    pZone->pwsZoneName = Dns_StringCopyAllocate(
                            pZone->pszZoneName,
                            0,
                            DnsCharSetUtf8,
                            DnsCharSetUnicode );    // create unicode
    if ( !pZone->pwsZoneName )
    {
        status = DNS_ERROR_INVALID_NAME;
        goto Failure;
    }

    DNS_DEBUG( INIT, (
        "setZoneName: UTF8=%s unicode=%S\n",
        pZone->pszZoneName,
        pZone->pwsZoneName ));
    return ERROR_SUCCESS;

    Failure:

    DNS_DEBUG( INIT, (
        "setZoneName: on zone %p failed to set new name %s (%d)\n",
        pZone,
        pszNewZoneName,
        dwNewZoneNameLen ));
    return status;
} // setZoneName


//
//  End zone.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\zonerpc.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    zonerpc.c

Abstract:

    Domain Name System (DNS) Server

    Zone RPC routines for admin tool.

Author:

    Jim Gilroy (jamesg)     October, 1995

Revision History:

--*/


#include "dnssrv.h"

#include "ds.h"

#include "rpcw2k.h"     //  downlevel Windows 2000 RPC functions

//
//  Initial zone size default
//

#define MAX_RPC_ZONE_COUNT_DEFAULT  (0x10000)



//
//  Zone RPC Utilities
//

VOID
freeZoneList(
    IN OUT  PDNS_RPC_ZONE_LIST  pZoneList
    )
/*++

Routine Description:

    Deep free of list of DNS_RPC_ZONE structures.

Arguments:

    pZoneList -- ptr RPC_ZONE_LIST structure to free

Return Value:

    None

--*/
{
    DWORD           i;
    PDNS_RPC_ZONE   pzone;

    for( i = 0; i < pZoneList->dwZoneCount; ++i )
    {
        pzone = pZoneList->ZoneArray[ i ];
        MIDL_user_free( pzone->pszZoneName );
        MIDL_user_free( pzone->pszDpFqdn );
        MIDL_user_free( pzone );
    }
    MIDL_user_free( pZoneList );
}



PDNS_RPC_ZONE
allocateRpcZone(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Allocate \ create RPC zone struct for zone.

Arguments:

    pZone -- zone to create RPC zone struct for

Return Value:

    RPC zone struct.
    NULL on allocation failure.

--*/
{
    PDNS_RPC_ZONE   prpcZone;

    DNS_DEBUG( RPC2, ("allocateRpcZone( %s )\n", pZone->pszZoneName ));

    //  allocate and attach zone

    prpcZone = (PDNS_RPC_ZONE) MIDL_user_allocate( sizeof(DNS_RPC_ZONE) );
    if ( !prpcZone )
    {
        return( NULL );
    }

    prpcZone->dwRpcStuctureVersion = DNS_RPC_ZONE_VER;

    //  copy zone name

    prpcZone->pszZoneName = Dns_StringCopyAllocate_W(
                                    pZone->pwsZoneName,
                                    0 );
    if ( !prpcZone->pszZoneName )
    {
        MIDL_user_free( prpcZone );
        return( NULL );
    }

    //  set type and flags

    prpcZone->ZoneType = (UCHAR) pZone->fZoneType;
    prpcZone->Version  = DNS_RPC_VERSION;

    *(PDWORD) &prpcZone->Flags = 0;

    if ( pZone->fPaused )
    {
        prpcZone->Flags.Paused = TRUE;
    }
    if ( pZone->fShutdown )
    {
        prpcZone->Flags.Shutdown = TRUE;
    }
    if ( pZone->fReverse )
    {
        prpcZone->Flags.Reverse = TRUE;
    }
    if ( pZone->fAutoCreated )
    {
        prpcZone->Flags.AutoCreated = TRUE;
    }
    if ( pZone->fDsIntegrated )
    {
        prpcZone->Flags.DsIntegrated = TRUE;
    }
    if ( pZone->bAging )
    {
        prpcZone->Flags.Aging = TRUE;
    }

    //  two bits reserved for update

    prpcZone->Flags.Update = pZone->fAllowUpdate;

    //  Directory partition members

    if ( !pZone->pDpInfo )
    {
        prpcZone->dwDpFlags = DNS_DP_LEGACY & DNS_DP_ENLISTED;
        prpcZone->pszDpFqdn = NULL;
    }
    else
    {
        prpcZone->dwDpFlags = ZONE_DP( pZone )->dwFlags;
        prpcZone->pszDpFqdn = Dns_StringCopyAllocate_A(
                                        ZONE_DP( pZone )->pszDpFqdn,
                                        0 );
    }

    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcZone(
            "New zone for RPC: ",
            prpcZone );
    }
    return( prpcZone );
}



VOID
freeRpcZoneInfo(
    IN OUT  PDNS_RPC_ZONE_INFO  pZoneInfo
    )
/*++

Routine Description:

    Deep free of DNS_RPC_ZONE_INFO structure.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( !pZoneInfo )
    {
        return;
    }

    //
    //  free substructures
    //      - name string
    //      - data file string
    //      - secondary IP array
    //      - WINS server array
    //  then zone info itself
    //

    MIDL_user_free( pZoneInfo->pszZoneName );
    MIDL_user_free( pZoneInfo->pszDataFile );
    MIDL_user_free( pZoneInfo->aipMasters );
    MIDL_user_free( pZoneInfo->aipSecondaries );
    MIDL_user_free( pZoneInfo->aipNotify );
    MIDL_user_free( pZoneInfo->aipScavengeServers );
    MIDL_user_free( pZoneInfo->pszDpFqdn );
    MIDL_user_free( pZoneInfo->pwszZoneDn );
    MIDL_user_free( pZoneInfo );
}



PDNS_RPC_ZONE_INFO
allocateRpcZoneInfo(
    IN      PZONE_INFO  pZone
    )
/*++

Routine Description:

    Create RPC zone info to return to admin client.

Arguments:

    pZone -- zone

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_ZONE_INFO  pzoneInfo;

    pzoneInfo = MIDL_user_allocate_zero( sizeof(DNS_RPC_ZONE_INFO) );
    if ( !pzoneInfo )
    {
        goto done_failed;
    }

    //
    //  fill in fixed fields
    //

    pzoneInfo->dwZoneType           = pZone->fZoneType;
    pzoneInfo->fReverse             = pZone->fReverse;
    pzoneInfo->fAutoCreated         = pZone->fAutoCreated;
    pzoneInfo->fAllowUpdate         = pZone->fAllowUpdate;
    pzoneInfo->fUseDatabase         = pZone->fDsIntegrated;
    pzoneInfo->fSecureSecondaries   = pZone->fSecureSecondaries;
    pzoneInfo->fNotifyLevel         = pZone->fNotifyLevel;

    pzoneInfo->fPaused              = IS_ZONE_PAUSED(pZone);
    pzoneInfo->fShutdown            = IS_ZONE_SHUTDOWN(pZone);
    pzoneInfo->fUseWins             = IS_ZONE_WINS(pZone);
    pzoneInfo->fUseNbstat           = IS_ZONE_NBSTAT(pZone);

    pzoneInfo->fAging               = pZone->bAging;
    pzoneInfo->dwNoRefreshInterval  = pZone->dwNoRefreshInterval;
    pzoneInfo->dwRefreshInterval    = pZone->dwRefreshInterval;
    pzoneInfo->dwAvailForScavengeTime =
                    pZone->dwAgingEnabledTime + pZone->dwRefreshInterval;

    if ( IS_ZONE_FORWARDER( pZone ) )
    {
        pzoneInfo->dwForwarderTimeout   = pZone->dwForwarderTimeout;
        pzoneInfo->fForwarderSlave      = pZone->fForwarderSlave;
    }

    //
    //  fill in zone name
    //

    if ( ! RpcUtil_CopyStringToRpcBuffer(
                &pzoneInfo->pszZoneName,
                pZone->pszZoneName ) )
    {
        goto done_failed;
    }

    //
    //  database filename
    //

#ifdef FILE_KEPT_WIDE
    if ( ! RpcUtil_CopyStringToRpcBufferEx(
                &pzoneInfo->pszDataFile,
                pZone->pszDataFile,
                TRUE,       // unicode in
                FALSE       // UTF8 out
                ) )
    {
        goto done_failed;
    }
#else
    if ( ! RpcUtil_CopyStringToRpcBuffer(
                &pzoneInfo->pszDataFile,
                pZone->pszDataFile ) )
    {
        goto done_failed;
    }
#endif

    //
    //  master list
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipMasters,
                pZone->aipMasters ) )
    {
        goto done_failed;
    }

    //
    //  local master list for stub zones
    //

    if ( IS_ZONE_STUB( pZone ) &&
        ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipLocalMasters,
                pZone->aipLocalMasters ) )
    {
        goto done_failed;
    }

    //
    //  secondary and notify lists
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipSecondaries,
                pZone->aipSecondaries ) )
    {
        goto done_failed;
    }
    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipNotify,
                pZone->aipNotify ) )
    {
        goto done_failed;
    }

    //
    //  scavenging servers
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipScavengeServers,
                pZone->aipScavengeServers ) )
    {
        goto done_failed;
    }

    //
    //  Directory partition members.
    //

    if ( pZone->pDpInfo )
    {
        pzoneInfo->dwDpFlags = ( ( PDNS_DP_INFO ) pZone->pDpInfo )->dwFlags;
        if ( ( ( PDNS_DP_INFO ) pZone->pDpInfo )->pszDpFqdn )
        {
            if ( ! RpcUtil_CopyStringToRpcBuffer(
                        &pzoneInfo->pszDpFqdn,
                        ( ( PDNS_DP_INFO ) pZone->pDpInfo )->pszDpFqdn ) )
            {
                goto done_failed;
            }
        }
    }
    else if ( IS_ZONE_DSINTEGRATED( pZone ) )
    {
        pzoneInfo->dwDpFlags = DNS_DP_LEGACY | DNS_DP_ENLISTED;
    }

    if ( pZone->pwszZoneDN )
    {
        pzoneInfo->pwszZoneDn = Dns_StringCopyAllocate_W(
                                        pZone->pwszZoneDN,
                                        0 );
    }

    //
    //  xfr time info
    //

    if ( IS_ZONE_SECONDARY( pZone ) )
    {
        pzoneInfo->dwLastSuccessfulXfr = pZone->dwLastSuccessfulXfrTime;
        pzoneInfo->dwLastSuccessfulSoaCheck = pZone->dwLastSuccessfulSoaCheckTime;
    }


    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneInfo(
            "RPC zone info leaving allocateRpcZoneInfo():\n",
            pzoneInfo );
    }
    return( pzoneInfo );

done_failed:

    //  free newly allocated info block

    freeRpcZoneInfo( pzoneInfo );
    return( NULL );
}



//
//  Zone type conversion
//

DNS_STATUS
zoneResetToDsPrimary(
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwLoadOptions
    )
/*++

Routine Description:

    Reset zone to DS integrated primary.

    Assumes zone is locked for update.

Arguments:

    pZone -- zone to make DS primary

    dwLoadOptions -- load options to\from DS

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DWORD           oldType;

    ASSERT( pZone && pZone->pszZoneName && pZone->fLocked );

    DNS_DEBUG( RPC, (
        "zoneResetToDsPrimary( %s ):\n"
        "\tLoad options = %p\n",
        pZone->pszZoneName,
        dwLoadOptions ));

    //
    //  Not-auth zones cannot be converted to primary because
    //  we don't have a copy of the zone data locally.
    //

    if ( IS_ZONE_NOTAUTH( pZone ) )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //
    //  verify that have data
    //      - may have secondary that has not received a transfer
    //

    if ( !pZone->pSoaRR || IS_ZONE_EMPTY(pZone) )
    {
        ASSERT( IS_ZONE_SECONDARY(pZone) );
        ASSERT( !pZone->pSoaRR );
        ASSERT( IS_ZONE_EMPTY(pZone) );

        return( DNS_ERROR_INVALID_DATA );
    }

    //
    //  if already DS integrated -- done
    //

    if ( pZone->fDsIntegrated )
    {
        if ( !IS_ZONE_PRIMARY(pZone) && !IS_ZONE_CACHE(pZone) )
        {
            ASSERT( FALSE );
            return( DNS_ERROR_INVALID_TYPE );
        }
        return( ERROR_SUCCESS );
    }

    //  verify can use DS -- or don't bother
    //      - don't wait for open
    //      - don't log error if can not open

    status = Ds_OpenServer( 0 );
    if ( status != ERROR_SUCCESS )
    {
        return( DNS_ERROR_DS_UNAVAILABLE );
    }

    //  save old zone type

    oldType = ( DWORD ) pZone->fZoneType;
    pZone->fZoneType = DNS_ZONE_TYPE_PRIMARY;

    //
    //  temporarily convert to DS integrated and attempt load operation
    //  essentially three types of attempts:
    //      default (0 flag)    -- attempt to write back zone, fails if zone exists
    //      overwrite DS        -- write back zone, deleting current DS if exists
    //      overwrite memory    -- load zone from DS, delete memory if successful
    //
    //  note:  can have separate primary\secondary blocks if
    //  want to limit secondary semantics
    //      -- only write if nothing there, otherwise read (exclude DS dump possiblity)
    //      -- read if in DS, otherwise fail
    //

    pZone->fDsIntegrated = TRUE;

    if ( dwLoadOptions & DNS_ZONE_LOAD_OVERWRITE_MEMORY )
    {
        status = Zone_Load( pZone );
    }
    else
    {
        status = Ds_WriteZoneToDs(
                    pZone,
                    dwLoadOptions );
    }
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  on successful conversion move database file to backup directory
    //

    File_MoveToBackupDirectory( pZone->pwsDataFile );

    //
    //  secondary must reset type as well as database
    //

    if ( IS_ZONE_SECONDARY(pZone) )
    {
        status = Zone_ResetType(
                    pZone,
                    DNS_ZONE_TYPE_PRIMARY,
                    NULL );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }
    }

    //
    //  reset zone's database information
    //

    status = Zone_DatabaseSetup(
                pZone,
                TRUE,
                NULL,
                0 );

    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    return( ERROR_SUCCESS );


Failure:

    pZone->fZoneType = (DWORD) oldType;
    pZone->fDsIntegrated = FALSE;
    return( status );
}



DNS_STATUS
zoneResetToPrimary(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile
    )
/*++

Routine Description:

    Reset zone to primary.

    Assumes zone is locked for update.

Arguments:

    pZone -- zone to make regular (non-DS) primary

    pszFile -- data file for zone

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DWORD           oldType;
    BOOL            oldDsIntegrated;

    ASSERT( pZone && pZone->pszZoneName && pZone->fLocked );

    DNS_DEBUG( RPC, (
        "zoneResetToPrimary( %s ):\n"
        "\tFile     = %s\n",
        pZone->pszZoneName,
        pszFile ));

    //
    //  Not-auth zones cannot be converted to primary because
    //  we don't have a copy of the zone data locally.
    //

    if ( IS_ZONE_NOTAUTH( pZone ) )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //
    //  if no datafile -- forget it
    //

    if ( !pszFile )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  verify that have data
    //      - may have secondary that has not received a transfer
    //

    if ( !pZone->pSoaRR || IS_ZONE_EMPTY( pZone ) )
    {
        ASSERT( IS_ZONE_SECONDARY( pZone ) );
        ASSERT( !pZone->pSoaRR );
        ASSERT( IS_ZONE_EMPTY( pZone ) );

        return DNS_ERROR_ZONE_IS_SHUTDOWN;
    }

    //
    //  save old type and DS info
    //

    oldType = (DWORD) pZone->fZoneType;
    oldDsIntegrated = (BOOL) pZone->fDsIntegrated;

    if ( oldType == DNS_ZONE_TYPE_SECONDARY
        || oldType == DNS_ZONE_TYPE_STUB )
    {
        pZone->fZoneType = DNS_ZONE_TYPE_PRIMARY;
    }

    //
    //  reset zone's database
    //

    status = Zone_DatabaseSetup(
                pZone,
                FALSE,      // not DsIntegrated
                pszFile,
                0 );
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  if file, attempt to write back
    //

    //  restoring original
    if ( !File_WriteZoneToFile( pZone, NULL ) )
    {
        status = ERROR_CANTWRITE;
        goto Failure;
    }


    //
    //  reset zone type and setup as primary
    //

    if ( ! IS_ZONE_CACHE(pZone) )
    {
        status = Zone_ResetType(
                    pZone,
                    DNS_ZONE_TYPE_PRIMARY,
                    NULL );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }
    }

    //
    //  if originally DS integrated, must remove from DS
    //
    //  DEVNOTE: could return status warning if DS delete fails
    //

    if ( oldDsIntegrated )
    {
        status = Ds_DeleteZone( pZone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "DS delete of zone %s failed, when changing to standard primary.\n",
                pZone->pszZoneName ));
        }
    }

    return( ERROR_SUCCESS );

Failure:

    pZone->fZoneType = (DWORD) oldType;
    pZone->fDsIntegrated = (BOOL) oldDsIntegrated;
    return( status );
}



DNS_STATUS
zoneResetToSecondary(
    IN OUT  PZONE_INFO      pZone,
    IN      LPSTR           pszFile,
    IN      PIP_ARRAY       aipMasters
    )
/*++

Routine Description:

    Reset zone to secondary.

    Assumes zone is locked for update.

Arguments:

    pZone -- zone to make secondary

    pszFile -- data file for zone

    aipMasters -- master IP array

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DWORD           oldType = ( DWORD ) pZone->fZoneType;
    BOOL            oldDsIntegrated = ( BOOL ) pZone->fDsIntegrated;

    ASSERT( pZone && pZone->pszZoneName && pZone->fLocked );

    DNS_DEBUG( RPC, (
        "zoneResetToSecondary( %s ):\n"
        "\tFile     = %s\n",
        pZone->pszZoneName,
        pszFile ));

    //
    //  Validate master list.
    //

    status = Zone_ValidateMasterIpList( aipMasters );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    //
    //  If the zone is currently file-backed, write back.
    //

    if ( IS_ZONE_DSINTEGRATED( pZone ) )
    {
        File_WriteZoneToFile( pZone, NULL );
    }

    //
    //  if previously primary reset zone type
    //  if previously secondary just update master list
    //
    //  note:   admin calls Rpc_ZoneResetTypeEx() for all sorts of property
    //          changes, and Zone_ResetType() will have the effect of
    //          reinitializing all XFR information (effectively turning on
    //          expired zone) which is not what we want when adding a master
    //          to the list
    //

    if ( oldType != DNS_ZONE_TYPE_SECONDARY )
    {
        //
        //  If we're changing zone type and the zone is currently DS-integrated
        //  we need to nuke the zone from the DS before we change any of the
        //  important zone properties.
        //

        if ( oldDsIntegrated )
        {
            status = Ds_DeleteZone( pZone );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( ANY, (
                    "DS delete of zone %s failed when changing to standard secondary\n",
                    pZone->pszZoneName ));
            }
        }

        //
        //  For not-auth zones clean out the zone data to force
        //  good clean transfer.
        //

        if ( oldType == DNS_ZONE_TYPE_STUB || oldType == DNS_ZONE_TYPE_FORWARDER )
        {
            File_DeleteZoneFileA( pszFile );
            File_DeleteZoneFileA( pZone->pszDataFile );
            Zone_DumpData( pZone );
        }

        //
        //  Reset the zone's type and database.
        //

        status = Zone_ResetType(
                    pZone,
                    DNS_ZONE_TYPE_SECONDARY,
                    aipMasters );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }

        status = Zone_DatabaseSetup(
                    pZone,
                    FALSE,      // not DsIntegrated
                    pszFile,
                    0 );
    }
    else
    {
        //
        //  Not changing type so set database and masters.
        //

        status = Zone_DatabaseSetup(
                    pZone,
                    FALSE,      // not DsIntegrated
                    pszFile,
                    0 );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }

        status = Zone_SetMasters(
                    pZone,
                    aipMasters,
                    FALSE );
    }

    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    Xfr_ForceZoneExpiration( pZone );

    return status;

Failure:

    pZone->fZoneType = (DWORD) oldType;
    pZone->fDsIntegrated = (BOOL) oldDsIntegrated;
    return status;
}



DNS_STATUS
zoneResetToStub(
    IN OUT  PZONE_INFO      pZone,
    IN      BOOL            fDsIntegrated,
    IN      LPSTR           pszFile,
    IN      PIP_ARRAY       aipMasters
    )
/*++

Routine Description:

    Reset zone to stub.

    Assumes zone is locked for update.

Arguments:

    pZone -- zone to make secondary

    fDsIntegrated -- is the new zone to become ds-integrated?
    
    pszFile -- data file for zone

    aipMasters -- master IP array

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DBG_FN( "zoneResetToStub" )

    DNS_STATUS      status;
    DWORD           oldType;
    BOOL            oldDsIntegrated = FALSE;

    ASSERT( pZone && pZone->pszZoneName && pZone->fLocked );

    DNS_DEBUG( RPC, (
        "%s( %s ):\n"
        "\tFile             = %s\n"
        "\tDS-integrated    = %d\n",
        fn,
        pZone->pszZoneName,
        pszFile,
        fDsIntegrated ));

    //
    //  validate master list
    //

    status = Zone_ValidateMasterIpList( aipMasters );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  save current type in case of failure
    //

    oldType = ( DWORD ) pZone->fZoneType;
    oldDsIntegrated = ( BOOL ) pZone->fDsIntegrated;

    //
    //  note:   admin calls Rpc_ZoneResetTypeEx() for all sorts of property
    //          changes, and Zone_ResetType() will have the effect of
    //          reinitializing all XFR information (effectively turning on
    //          expired zone) which is not what we want when adding a master
    //          to the list
    //

    if ( oldType != DNS_ZONE_TYPE_STUB || oldDsIntegrated != fDsIntegrated )
    {
        //
        //  Delete the current zone files so that any data present
        //  will not be read back when the zone file is loaded.
        //

        File_DeleteZoneFileA( pszFile );
        File_DeleteZoneFileA( pZone->pszDataFile );

        //
        //  Clear out existing zone data. 
        //

        Zone_DumpData( pZone );

        //
        //  If we're changing zone type and the zone is currently DS-integrated
        //  we need to nuke the zone from the DS before we change any of the
        //  important zone properties.
        //

        if ( oldDsIntegrated )
        {
            status = Ds_DeleteZone( pZone );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( ANY, (
                    "DS delete of zone %s failed when changing to standard secondary\n",
                    pZone->pszZoneName ));
            }
        }

        //
        //  Reset zone's type and database.
        //

        status = Zone_ResetType(
                    pZone,
                    DNS_ZONE_TYPE_STUB,
                    aipMasters );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }

        status = Zone_DatabaseSetup(
                    pZone,
                    fDsIntegrated,
                    pszFile,
                    0 );
    }
    else
    {
        status = Zone_SetMasters(
                    pZone,
                    aipMasters,
                    FALSE );
    }
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  If necessary write zone to DS.
    //

    if ( fDsIntegrated )
    {
        status = Ds_WriteZoneToDs( pZone, DNS_ZONE_LOAD_OVERWRITE_DS );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }
    }

    return status;

Failure:

    DNS_DEBUG( RPC, (
        "%s: failed %d\n",
        fn,
        status ));

    pZone->fZoneType = ( DWORD ) oldType;
    pZone->fDsIntegrated = ( BOOL ) oldDsIntegrated;
    return status;
}



DNS_STATUS
zoneResetToForwarder(
    IN OUT  PZONE_INFO      pZone,
    IN      BOOL            fDsIntegrated,
    IN      LPSTR           pszFile,
    IN      PIP_ARRAY       aipMasters
    )
/*++

Routine Description:

    Reset zone to forwarder.

    Assumes zone is locked for update.

Arguments:

    pZone -- zone to make secondary

    fDsIntegrated -- is the new zone to become ds-integrated?
    
    pszFile -- data file for zone

    aipMasters -- master IP array

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DBG_FN( "zoneResetToForwarder" )

    DNS_STATUS      status;
    DWORD           oldType;
    BOOL            oldDsIntegrated = FALSE;

    ASSERT( pZone && pZone->pszZoneName && pZone->fLocked );

    DNS_DEBUG( RPC, (
        "%s( %s ):\n"
        "\tFile             = %s\n",
        fn,
        pZone->pszZoneName,
        pszFile ));

    //
    //  validate master list
    //

    status = Zone_ValidateMasterIpList( aipMasters );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  save current type in case of failure
    //

    oldType = ( DWORD ) pZone->fZoneType;
    oldDsIntegrated = ( BOOL ) pZone->fDsIntegrated;

    //
    //  if file, write back before we switch types
    //

    if ( !oldDsIntegrated )
    {
        File_WriteZoneToFile( pZone, NULL );
    }

    //
    //  note:   admin calls Rpc_ZoneResetTypeEx() for all sorts of property
    //          changes, and Zone_ResetType() will have the effect of
    //          reinitializing all XFR information (effectively turning on
    //          expired zone) which is not what we want when adding a master
    //          to the list
    //

    if ( oldType != DNS_ZONE_TYPE_FORWARDER || oldDsIntegrated != fDsIntegrated )
    {
        //
        //  Delete the current zone files so that any data present
        //  will not be read back when the zone file is loaded.
        //

        File_DeleteZoneFileA( pszFile );
        File_DeleteZoneFileA( pZone->pszDataFile );

        //
        //  Clear out existing zone data. 
        //

        Zone_DumpData( pZone );

        //
        //  If we're changing zone type and the zone is currently DS-integrated
        //  we need to nuke the zone from the DS before we change any of the
        //  important zone properties.
        //

        if ( oldDsIntegrated )
        {
            status = Ds_DeleteZone( pZone );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( ANY, (
                    "DS delete of zone %s failed when changing to standard secondary\n",
                    pZone->pszZoneName ));
            }
        }

        //
        //  Reset zone's database.
        //

        status = Zone_ResetType(
                    pZone,
                    DNS_ZONE_TYPE_FORWARDER,
                    aipMasters );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }

        status = Zone_DatabaseSetup(
                    pZone,
                    fDsIntegrated,
                    pszFile,
                    0 );
    }
    else
    {
        status = Zone_SetMasters(
                    pZone,
                    aipMasters,
                    FALSE );
    }
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  If necessary, write zone to DS.
    //

    if ( fDsIntegrated )
    {
        status = Ds_WriteZoneToDs( pZone, DNS_ZONE_LOAD_OVERWRITE_DS );
        if ( status != ERROR_SUCCESS )
        {
            goto Failure;
        }
    }

    return status;

Failure:

    DNS_DEBUG( RPC, (
        "%s: failed %d\n",
        fn,
        status ));

    pZone->fZoneType = ( DWORD ) oldType;
    pZone->fDsIntegrated = ( BOOL ) oldDsIntegrated;
    return status;
}



DNS_STATUS
Zone_DcPromoConvert(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Change DC promo created zone.

Arguments:

    pZone   -- ptr to zone

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       dwOldZoneType;

    //
    //  must be file backed primary
    //

    if ( ! IS_ZONE_PRIMARY(pZone) || pZone->fDsIntegrated )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    //
    //  convert to DS primary, writing to DS
    //

    status = zoneResetToDsPrimary(
                pZone,
                0 );        // neither force overwrite, nor load from DS

    //
    //  if converted, then set secure
    //      - zero secure time so stuff written from file is secure
    //      - force property write
    //

    if ( status == ERROR_SUCCESS )
    {
        ASSERT( pZone->fDsIntegrated );

        DNS_DEBUG( DS, (
            "Successfully converted DC promo zone %S\n",
            pZone->pwsZoneName ));

        pZone->bDcPromoConvert = FALSE;
        pZone->fAllowUpdate = ZONE_UPDATE_SECURE;
        pZone->llSecureUpdateTime = 0;

        Ds_WriteZoneProperties( pZone );
    }

    //
    //   if already DS integrated -- load it
    //       - this can happen if another DC converts and reboots first
    //       - must

    else if ( status == DNS_ERROR_DS_ZONE_ALREADY_EXISTS )
    {
        DNS_DEBUG( DS, (
            "DC Promo conversion zone %S, already in DS\n"
            "\tloading DS version.\n",
            pZone->pwsZoneName ));

        //  must clear DcPromoConvert flag since this will call zone load

        pZone->bDcPromoConvert = FALSE;

        status = zoneResetToDsPrimary(
                    pZone,
                    DNS_ZONE_LOAD_OVERWRITE_MEMORY );
    }

    //
    //  kill off DC promo regkey
    //      - we'll let the failure case spin
    //      - note, could be DS slow to start so don't necessarily
    //      want to delete even if no DS on box
    //

    if ( pZone->fDsIntegrated )
    {
        Reg_DeleteValue(
            NULL,
            pZone,
            DNS_REGKEY_ZONE_DCPROMO_CONVERT );
    }
    ELSE
    {
        DNS_DEBUG( ANY, (
            "ERROR:  unable to convert DC-promo zone %S to DS integrated!\n"
            "\tstatus = %d (%p)\n",
            pZone->pwsZoneName,
            status, status ));
    }

    return( status );
}




//
//  Dispatched RPC Zone Operations
//

DNS_STATUS
Rpc_ResetZoneTypeEx(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone's database setup.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_ZONE_CREATE_INFO pinfo = (PDNS_RPC_ZONE_CREATE_INFO)pData;
    DNS_STATUS      status;
    DWORD           fdsIntegrated;
    DWORD           newType;
    BOOL            fexpireZone = FALSE;

    newType = pinfo->dwZoneType;
    fdsIntegrated = pinfo->fDsIntegrated;

    DNS_DEBUG( RPC, (
        "RpcResetZoneTypeEx( %s ):\n"
        "\tNew type     = %d\n"
        "\tLoad options = %p\n"
        "\tDS Integrate = %d\n"
        "\tFile         = %s\n",
        pZone->pszZoneName,
        newType,
        pinfo->fLoadExisting,
        fdsIntegrated,
        pinfo->pszDataFile ));

    //
    //  for any database change, lock zone
    //  this is just a simplification, otherwise we have to lock specifically
    //  for those causing DS load, or DS\file write
    //

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        return( DNS_ERROR_ZONE_LOCKED );
    }

    //
    //  Call the appropriate reset type function.
    //

    switch ( newType )
    {
        case DNS_ZONE_TYPE_PRIMARY:
            if ( fdsIntegrated )
            {
                status = zoneResetToDsPrimary(
                            pZone,
                            pinfo->fLoadExisting );
            }
            else
            {
                status = zoneResetToPrimary(
                            pZone,
                            pinfo->pszDataFile );
            }
            break;

        case DNS_ZONE_TYPE_SECONDARY:
            status = zoneResetToSecondary(
                        pZone,
                        pinfo->pszDataFile,
                        pinfo->aipMasters );
            fexpireZone = TRUE;
            break;

        case DNS_ZONE_TYPE_STUB:
            status = zoneResetToStub(
                        pZone,
                        fdsIntegrated,
                        pinfo->pszDataFile,
                        pinfo->aipMasters );
            fexpireZone = TRUE;
            break;

        case DNS_ZONE_TYPE_FORWARDER:
            status = zoneResetToForwarder(
                        pZone,
                        fdsIntegrated,
                        pinfo->pszDataFile,
                        pinfo->aipMasters );
            break;

        default:
            DNS_DEBUG( RPC, (
                "RpcResetZoneTypeEx( %s ): invalid zone type %d\n",
                pZone->pszZoneName,
                newType ));
            return DNS_ERROR_INVALID_ZONE_TYPE;
            break;
    }

    //
    //  if successful, update boot file
    //

    if ( status == ERROR_SUCCESS )
    {
        Config_UpdateBootInfo();
    }

    Zone_UnlockAfterAdminUpdate( pZone );

    //
    //  Do this outside zone lock, else it's possible the SOA response
    //  will be received while the zone is still locked.
    //

    if ( fexpireZone )
    {
        Xfr_ForceZoneExpiration( pZone );
    }

    return( status );
}



DNS_STATUS
Rpc_WriteAndNotifyZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Write zone to file and notify secondaries.
    Should be called after admin changes to the primary zone.

Arguments:

    pZone -- zone to increment

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_WriteAndNotifyZone( %s ):\n",
        pZone->pszZoneName ));

    //  root-hints write has special call

    if ( IS_ZONE_CACHE(pZone) )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    //
    //  must be primary zone
    //      - secondary not updateable, and always written after AXFR
    //
    //  DEVNOTE: not really true with IXFR, may want to enable secondary write
    //

    if ( !IS_ZONE_PRIMARY(pZone) )
    {
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }
    if ( ! pZone->pSoaRR )
    {
        return( DNS_ERROR_ZONE_CONFIGURATION_ERROR );
    }

    //
    //  if zone is NOT dirty, no need to write back or notify
    //

    if ( ! pZone->fDirty )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  lock out transfer while rebuilding
    //

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        return( DNS_ERROR_ZONE_LOCKED );
    }

    //
    //  re-build zone information that depends on RRs
    //      - name server list
    //      - pointer to SOA record
    //      - WINS or NBSTAT info
    //
    //  note:  except for changes to NS list, this should already be
    //          setup, as individual RR routines do proper zone actions
    //          for SOA, WINS, NBSTAT
    //

    Zone_GetZoneInfoFromResourceRecords( pZone );

    //
    //  update zone version
    //
    //  DEVNOTE: admin tool currently uses this as write zone to file
    //      not update version
    //
    //  Zone_UpdateVersion( pZone );

    //
    //  write zone back to file
    //     - skip if we're ds integrated.
    //

    if ( !pZone->fDsIntegrated &&
         !File_WriteZoneToFile( pZone, NULL ) )
    {
        Zone_UnlockAfterAdminUpdate( pZone );
        return( ERROR_CANTWRITE );
    }
    Zone_UnlockAfterAdminUpdate( pZone );

    //
    //  notify secondaries of update
    //
    //  obviously faster to do this before file write;  doing write first
    //  so that zone is less likely to be locked when SOA requests come
    //  from secondaries
    //

    Xfr_SendNotify( pZone );

    return( ERROR_SUCCESS );
}



DNS_STATUS
Rpc_DeleteZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Delete zone.

Arguments:

    pZone -- zone to delete

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_DeleteZone( %s ):\n",
        pZone->pszZoneName ));

    //
    //  no DIRECT cache delete
    //  delete of cache "zone" only done when admin makes
    //  server authoritative for the root domain
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    //  no delete of DS zone, if in boot-from-DS mode
    //      (must do delete from DS)

    if ( SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY  &&
        pZone->fDsIntegrated )
    {
        DNS_DEBUG( RPC, (
            "Refusing delete of DS zone, while booting from directory.\n" ));
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    //  lock zone -- lock out transfer or other admin action

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        return( DNS_ERROR_ZONE_LOCKED );
    }

    //  delete zone info

    Zone_Delete( pZone );

    //  update boot info

    Config_UpdateBootInfo();

    return( ERROR_SUCCESS );
}



DNS_STATUS
Rpc_RenameZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Rename zone.

Arguments:

    pZone -- zone to rename

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    static const char *         fn = "Rpc_RenameZone";
    PDNS_RPC_ZONE_RENAME_INFO   pinfo = ( PDNS_RPC_ZONE_RENAME_INFO ) pData;
    DNS_STATUS                  status = ERROR_SUCCESS;

    DNS_DEBUG( RPC, (
        "%s( %s )\n\tto %s\n",
        fn,
        pZone->pszZoneName,
        pinfo->pszNewZoneName ));

    //
    //  Not allowed on cache zone.
    //

    if ( IS_ZONE_CACHE( pZone ) )
    {
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    //
    //  Rename the zone and update boot info.
    //

    status = Zone_Rename( pZone,
                pinfo->pszNewZoneName,
                pinfo->pszNewFileName );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    Config_UpdateBootInfo();

    return status;
}



DNS_STATUS
Rpc_ExportZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Export zone to file

Arguments:

    pZone -- zone to export

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    static const char *         fn = "Rpc_ExportZone";
    PDNS_RPC_ZONE_EXPORT_INFO   pinfo = ( PDNS_RPC_ZONE_EXPORT_INFO ) pData;
    DNS_STATUS                  status = ERROR_SUCCESS;
    BOOL                        fZoneLocked = FALSE;
    PWCHAR                      pwsZoneFile = NULL;
    WCHAR                       wsFilePath[ MAX_PATH ];
    HANDLE                      hFile;

    DNS_DEBUG( RPC, (
        "%s( %s )\n\tto file %s\n",
        fn,
        pZone->pszZoneName,
        pinfo->pszZoneExportFile ));

    //
    //  Make a wide copy of the filename.
    //

    if ( ( pwsZoneFile = Dns_StringCopyAllocate(
                            pinfo->pszZoneExportFile,
                            0,                          // length
                            DnsCharSetUtf8,
                            DnsCharSetUnicode ) ) == NULL )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Test to see if the file exists. We do not allow this operation
    //  to overwrite an existing file. Note we must synthesize the full
    //  file path, but later we only pass the bare file name to
    //  File_WriteZoneToFile(). Hopefully both functions synthesize
    //  the full file path the same way.
    //

    if ( !File_CreateDatabaseFilePath(
                wsFilePath,
                NULL,           //  backup file path
                pwsZoneFile ) )
    {
        status = ERROR_OPEN_FAILED;
        goto Done;
    }

    if ( ( hFile = CreateFileW(
                        wsFilePath,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL ) ) != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
        status = ERROR_ALREADY_EXISTS;
        goto Done;
    }

    //
    //  The zone must be locked to iterate it.
    //

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        status = DNS_ERROR_ZONE_LOCKED;
        goto Done;
    }
    fZoneLocked = TRUE;

    //
    //  Write the zone to file.
    //

    if ( !File_WriteZoneToFile( pZone, pwsZoneFile ) )
    {
        status = ERROR_INVALID_DATA;
    }

    //
    //  Free allocations and locks.
    //

    Done:

    if ( pwsZoneFile )
    {
        FREE_HEAP( pwsZoneFile );
    }

    if ( fZoneLocked )
    {
        Zone_UnlockAfterAdminUpdate( pZone );
    }

    return status;
}



DNS_STATUS
Rpc_ReloadZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Delete zone.

Arguments:

    pZone -- zone to delete

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_ReloadZone( %s ):\n",
        pZone->pszZoneName ));

    //
    //  Write the zone back to storage if dirty, otherwise the reload
    //  will overwrite any changes nodes in memory.
    //

    Zone_WriteBack(
        pZone,
        FALSE );        // shutdown flag

    return Zone_Load( pZone );
}



DNS_STATUS
Rpc_RefreshSecondaryZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Force refresh of secondary zone.
    Zone immediately contacts primary for refresh.

Arguments:

    pZone -- zone to refresh

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_RefreshSecondaryZone( %s ):\n",
        pZone->pszZoneName ));

    Xfr_ForceZoneRefresh( pZone );
    return( ERROR_SUCCESS );
}



DNS_STATUS
Rpc_ExpireSecondaryZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Force expiration of secondary zone.
    Unlike Refresh call, this invalidates zone data and causes
    it to contact primary for refresh.

Arguments:

    pZone -- zone to expire

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_ExpireSecondaryZone( %s ):\n",
        pZone->pszZoneName ));

    Xfr_ForceZoneExpiration( pZone );
    return( ERROR_SUCCESS );
}



DNS_STATUS
Rpc_DeleteZoneFromDs(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Delete zone, including data in DS.

Arguments:

    pZone -- zone to delete

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status;

    DNS_DEBUG( RPC, (
        "Rpc_DeleteZoneFromDS( %s ):\n",
        pZone->pszZoneName ));

    //
    //  DEVNOTE: convert zone to file, before DS delete?
    //      perhaps need flag for either
    //          1) delete zone and DS zone
    //          2) switch to database and delete zone
    //
    //      or force flag to follow up with delete zone?
    //

    //
    //  delete from memory first
    //
    //  this protects us from the DS polling thread picking up the delete
    //  and deleting on its own in competition with us
    //

    if ( pZone->fDsIntegrated )
    {
        Zone_Delete( pZone );
    }

    status = Ds_DeleteZone( pZone );

    DNS_DEBUG( RPC, (
        "Leaving Rpc_DeleteZoneFromDS status = %d (0x%08X)\n",
        status, status ));

    return( status );
}



DNS_STATUS
Rpc_UpdateZoneFromDs(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Refresh zone from DS, picking up any updates.

Arguments:

    pZone -- zone to delete

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_UpdateZoneFromDs( %s ):\n",
        pZone->pszZoneName ));

    return  Ds_ZonePollAndUpdate(
                pZone,
                TRUE        // force poll
                );
}



DNS_STATUS
Rpc_PauseZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Pause zone.

Arguments:

    pZone -- zone to delete

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_PauseZone( %s ):\n",
        pZone->pszZoneName ));

    PAUSE_ZONE(pZone);

    return( ERROR_SUCCESS );
}



DNS_STATUS
Rpc_ResumeZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Resume zone.

Arguments:

    pZone -- zone to delete

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, (
        "Rpc_ResumeZone( %s ):\n",
        pZone->pszZoneName ));

    //  no aging refreshes, while paused, so reset
    //  scavenge on-line time

    pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();

    RESUME_ZONE(pZone);

    return( ERROR_SUCCESS );
}


#if DBG

DNS_STATUS
Rpc_LockZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Lock or unlock zone for testing.

Arguments:

    pZone -- zone to refresh

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    LPSTR   psztype;
    BOOL    block;
    BOOL    breturn = FALSE;

    if ( !pZone )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    ASSERT( dwTypeId == DNSSRV_TYPEID_NAME_AND_PARAM );
    ASSERT( pData );
    psztype = ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName;
    block   = ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam;

    DNS_DEBUG( ANY, (
        "Rpc_LockZone( %s ):\n"
        "\ttype = %s %s\n",
        pZone->pszZoneName,
        psztype,
        block ? "lock" : "unlock" ));

    //
    //  lock according to desired operation
    //

    if ( block )
    {
        if ( strcmp( psztype, "read" ) == 0 )
        {
            breturn = Zone_LockForReadEx( pZone, 0, 10000, __FILE__, __LINE__ );
        }
        else if ( strcmp( psztype, "write" ) == 0 )
        {
            breturn = Zone_LockForWriteEx( pZone, 0, 10000, __FILE__, __LINE__ );
        }
        else if ( strcmp( psztype, "admin" ) == 0 )
        {
            breturn = Zone_LockForAdminUpdate( pZone );
        }
        else if ( strcmp( psztype, "update" ) == 0 )
        {
            breturn = Zone_LockForUpdate( pZone );
        }
        else if ( strcmp( psztype, "xfr-recv" ) == 0 )
        {
            breturn = Zone_LockForXfrRecv( pZone );
        }
        else if ( strcmp( psztype, "xfr-send" ) == 0 )
        {
            breturn = Zone_LockForXfrSend( pZone );
        }
        else if ( strcmp( psztype, "file" ) == 0 )
        {
            breturn = Zone_LockForFileWrite( pZone );
        }
        else
        {
            return( ERROR_INVALID_PARAMETER );
        }

        if ( !breturn )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  unable to lock zone %s!\n",
                pZone->pszZoneName ));
            return( DNS_ERROR_ZONE_LOCKED );
        }
    }

    //
    //  unlock
    //      note that write locks will ASSERT if you come in on a different
    //      thread than the locking thread
    //
    //      one approach would be to make the write locks assumable when locking
    //      (above) and assume them here
    //
    //      currently provide hack-around in "write" unlocks, by giving flag
    //      that specifically ignores this ASSERT
    //

    else    // unlock
    {
        if ( strcmp( psztype, "read" ) == 0 )
        {
            Zone_UnlockAfterReadEx( pZone, 0, __FILE__, __LINE__ );
        }
        else if ( strcmp( psztype, "write" ) == 0 )
        {
            Zone_UnlockAfterWriteEx(
                pZone,
                LOCK_FLAG_IGNORE_THREAD,
                __FILE__,
                __LINE__ );
        }
        else if ( strcmp( psztype, "admin" ) == 0 ||
                  strcmp( psztype, "update" ) == 0 )
        {
            Zone_UnlockAfterWriteEx(
                pZone,
                LOCK_FLAG_IGNORE_THREAD | LOCK_FLAG_UPDATE,
                __FILE__,
                __LINE__ );
        }
        else if ( strcmp( psztype, "xfr-recv" ) == 0 )
        {
            Zone_UnlockAfterWriteEx(
                pZone,
                LOCK_FLAG_IGNORE_THREAD | LOCK_FLAG_XFR_RECV,
                __FILE__,
                __LINE__ );
        }
        else if ( strcmp( psztype, "xfr-send" ) == 0 )
        {
            Zone_UnlockAfterXfrSend( pZone );
        }
        else if ( strcmp( psztype, "file" ) == 0 )
        {
            Zone_UnlockAfterFileWrite( pZone );
        }
        else
        {
            return( ERROR_INVALID_PARAMETER );
        }
    }

    DNS_DEBUG( ANY, (
        "RPC initiated zone (%s) lock operation successful!\n",
        pZone->pszZoneName ));

    return( ERROR_SUCCESS );
}
#endif



DNS_STATUS
Rpc_ResetZoneDatabase(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone's database setup.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    DWORD           fdsIntegrated;
    LPSTR           pszfile;

    fdsIntegrated = ((PDNS_RPC_ZONE_DATABASE)pData)->fDsIntegrated;
    pszfile = ((PDNS_RPC_ZONE_DATABASE)pData)->pszFileName;

    DNS_DEBUG( RPC, (
        "RpcResetZoneDatabase( %s ):\n"
        "\tUseDatabase = %d\n"
        "\tFile = %s\n",
        pZone->pszZoneName,
        fdsIntegrated,
        pszfile ));

    //
    //  for any database change, lock zone
    //  this is just a simplification, otherwise we have to lock specifically
    //  for those causing DS load, or DS\file write
    //

    if ( !Zone_LockForAdminUpdate( pZone ) )
    {
        return( DNS_ERROR_ZONE_LOCKED );
    }

    //
    //  if changing zone backing store, then should be calling full
    //      type\database reset API above
    //  exception is changing cache file
    //

    if ( (BOOL)pZone->fDsIntegrated != (BOOL)fdsIntegrated )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    status = Zone_DatabaseSetup(
                pZone,
                fdsIntegrated,
                pszfile,
                0 );

    if ( status == ERROR_SUCCESS )
    {
        Config_UpdateBootInfo();
    }

    Zone_UnlockAfterAdminUpdate( pZone );
    return( status );
}



DNS_STATUS
Rpc_ResetZoneMasters(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone's master servers.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status;
    BOOL        fLocalMasters;

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneMasters( %s ):\n",
        pZone->pszZoneName ));

    if ( !IS_ZONE_SECONDARY(pZone) && !IS_ZONE_FORWARDER(pZone) )
    {
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    //
    //  If the operation string starts with "Local", we are setting
    //  the zone's local masters - currently only allowed for stub zones.
    //

    fLocalMasters = _strnicmp( pszOperation, "Local", 5 ) == 0;
    if ( fLocalMasters && !IS_ZONE_STUB( pZone ) )
    {
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    //
    //  Set the zone's master server list.
    //

    status = Zone_SetMasters(
                pZone,
                ( PIP_ARRAY ) pData,
                fLocalMasters );

    if ( status == ERROR_SUCCESS )
    {
        Config_UpdateBootInfo();
    }
    return( status );
}



DNS_STATUS
Rpc_ResetZoneSecondaries(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone's secondary information.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status;
    DWORD       fnotify;
    DWORD       fsecure;
    PIP_ARRAY   arrayNotify;
    PIP_ARRAY   arraySecure;

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneSecondaries( %s )\n",
        pZone->pszZoneName ));

    if ( IS_ZONE_FORWARDER( pZone ) || IS_ZONE_STUB( pZone ))
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Cleanup;
    } // if

    //
    //  extract params
    //

    fsecure = ((PDNS_RPC_ZONE_SECONDARIES)pData)->fSecureSecondaries;
    arraySecure = ((PDNS_RPC_ZONE_SECONDARIES)pData)->aipSecondaries;
    fnotify = ((PDNS_RPC_ZONE_SECONDARIES)pData)->fNotifyLevel;
    arrayNotify = ((PDNS_RPC_ZONE_SECONDARIES)pData)->aipNotify;

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneSecondaries( %s )\n"
        "\tfsecure      = %d\n"
        "\tsecure array = %p\n"
        "\tfnotify      = %d\n"
        "\tnotify array = %p\n",
        pZone->pszZoneName,
        fsecure,
        arraySecure,
        fnotify,
        arrayNotify ));

    //
    //  allow for partial reset
    //
    //  becauses admin tool may in the future use different property
    //  pages to set notify and secondary info, allow for partial resets
    //

    if ( fsecure == ZONE_PROPERTY_NORESET )
    {
        fsecure = pZone->fSecureSecondaries;
        arraySecure = pZone->aipSecondaries;
    }
    if ( fnotify == ZONE_PROPERTY_NORESET )
    {
        fnotify = pZone->fNotifyLevel;
        arrayNotify = pZone->aipNotify;
    }

    if ( fnotify > ZONE_NOTIFY_HIGHEST_VALUE  ||
         fsecure > ZONE_SECSECURE_HIGHEST_VALUE )
    {
        return ERROR_INVALID_DATA;
    }

    status = Zone_SetSecondaries(
                pZone,
                fsecure,
                arraySecure,
                fnotify,
                arrayNotify );

    if ( status == ERROR_SUCCESS )
    {
        //
        //  Update boot info and notify the new secondary list 
        //

        Config_UpdateBootInfo();
        Xfr_SendNotify( pZone );
    }

    Cleanup:

    return( status );
}



DNS_STATUS
Rpc_ResetZoneScavengeServers(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone's secondary information.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PIP_ARRAY   pserverArray = NULL;

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneScavengeServers( %s )\n"
        "\tserver array = %p\n",
        pZone->pszZoneName,
        (PIP_ARRAY)pData ));

    //
    //  scavenge servers only relevant for DS integrated primaries
    //      - copy new list to zone block
    //      - free old list
    //      - write new list to zone's DS properties

    if ( pZone->bAging )
    {
        if ( pData )
        {
            pserverArray = Dns_CreateIpArrayCopy( (PIP_ARRAY)pData );
            IF_NOMEM( !pserverArray )
            {
                return( DNS_ERROR_NO_MEMORY );
            }
        }
        Timeout_FreeAndReplaceZoneData(
            pZone,
            &pZone->aipScavengeServers,
            pserverArray );

        Ds_WriteZoneProperties( pZone );
        return( ERROR_SUCCESS );
    }
    else
    {
        Timeout_FreeAndReplaceZoneData(
            pZone,
            &pZone->aipScavengeServers,
            NULL );
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }
}



DNS_STATUS
Rpc_ResetZoneAllowAutoNS(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone's list of servers who can auto create NS records.

    
Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PIP_ARRAY       pipArray = NULL;
    PDB_RECORD      prrNs = NULL;
    UPDATE_LIST     updateList;
    BOOL            fApplyUpdate = FALSE;
    BOOL            fLocked = FALSE;
    DNS_STATUS      status = ERROR_SUCCESS;

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneAllowAutoNS( %s )\n"
        "\tserver array = %p\n",
        pZone->pszZoneName,
        ( PIP_ARRAY ) pData ));

    if ( !IS_ZONE_DSINTEGRATED( pZone ) )
    {
        DNS_DEBUG( RPC, (
            "Rpc_ResetZoneAllowAutoNS( %s ) - zone must be ds-integrated\n",
            pZone->pszZoneName ));
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Done;
    }

    if ( !Zone_LockForDsUpdate( pZone ) )
    {
        DNS_PRINT((
            "WARNING: failed to lock zone %s for set auto NS list!\n",
            pZone->pszZoneName ));
        status = DNS_ERROR_ZONE_LOCKED;
        goto Done;
    }
    fLocked = TRUE;

    if ( pData )
    {
        pipArray = Dns_CreateIpArrayCopy( ( PIP_ARRAY ) pData );
        IF_NOMEM( !pipArray )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
    }
    Timeout_FreeAndReplaceZoneData(
        pZone,
        &pZone->aipAutoCreateNS,
        pipArray );

    //
    //  Reset zone auto-create flag.
    //

    Zone_SetAutoCreateLocalNS( pZone );

    //
    //  Write the zone properties back. This will cause other servers
    //  to reload the zone and reset their individual NS records.
    //

    Ds_WriteZoneProperties( pZone );

    //
    //  Add/remove this server's own NS record from the zone root.
    //

    Up_InitUpdateList( &updateList );
    updateList.Flag |= DNSUPDATE_DS;

    prrNs = RR_CreatePtr(
                NULL,                   // no dbase name
                SrvCfg_pszServerName,
                DNS_TYPE_NS,
                pZone->dwDefaultTtl,
                MEMTAG_RECORD_AUTO );
    if ( prrNs )
    {
        if ( RR_IsRecordInRRList(
                    pZone->pZoneRoot->pRRList,
                    prrNs,
                    FALSE,                  // don't care about TTL
                    FALSE ) )               // don't care about Aging
        {
            //
            //  The zone has the local NS ptr, remove it if required.
            //

            if ( pZone->fDisableAutoCreateLocalNS )
            {
                //
                //  Add the RR as a deletion to the update list and remove the
                //  RR from the searchBlob list so it doesn't get added by
                //  the update below.
                //

                DNS_DEBUG( DS, (
                    "Rpc_ResetZoneAllowAutoNS: zone (%S) root node %p\n"
                    "\tDS info has local NS record, removing it\n",
                    pZone->pwsZoneName,
                    pZone->pZoneRoot ));

                Up_CreateAppendUpdate(
                    &updateList,
                    pZone->pZoneRoot,
                    NULL,               //  add list
                    DNS_TYPE_NS,        //  delete type
                    prrNs );            //  delete list
                prrNs = NULL;
                fApplyUpdate = TRUE;
            }
        }
        else if ( !pZone->fDisableAutoCreateLocalNS )
        {
            //
            //  Must add the NS RR.
            //

            DNS_DEBUG( DS, (
                "Rpc_ResetZoneAllowAutoNS: zone (%S) root node %p\n"
                "\tDS info has no local NS record, adding it\n",
                pZone->pwsZoneName,
                pZone->pZoneRoot ));

            Up_CreateAppendUpdate(
                &updateList,
                pZone->pZoneRoot,
                prrNs,              //  add list
                0,                  //  delete type
                NULL );             //  delete list
            prrNs = NULL;
            fApplyUpdate = TRUE;
        }
    }

    //
    //  Apply the update!
    //

    if ( fApplyUpdate )
    {
        DNS_STATUS      status;

        status = Up_ApplyUpdatesToDatabase(
                    &updateList,
                    pZone,
                    DNSUPDATE_DS );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, (
                "Rpc_ResetZoneAllowAutoNS: zone (%S) root node %p\n"
                "\terror %d applying update\n",
                pZone->pwsZoneName,
                pZone->pZoneRoot,
                status ));
        }
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }

        status = Ds_WriteNodeToDs(
                        NULL,                   //  default LDAP handle
                        pZone->pZoneRoot,
                        DNS_TYPE_ALL,
                        DNSDS_REPLACE,
                        pZone,
                        0 );                    //  flags
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( DS, (
                "Rpc_ResetZoneAllowAutoNS: zone (%S) root node %p\n"
                "\terror %d applying update\n",
                pZone->pwsZoneName,
                pZone->pZoneRoot,
                status ));
        }

        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
    }
    Up_FreeUpdatesInUpdateList( &updateList );

    //
    //  Cleanup and return.
    //

    Done:

    if ( fLocked )
    {
        Zone_UnlockAfterDsUpdate( pZone );
    }

    RR_Free( prrNs );       //  Will have been NULLed if not to be freed.

    DNS_DEBUG( DS, (
        "Rpc_ResetZoneAllowAutoNS on zone %S returning %d\n",
        pZone->pwsZoneName,
        status ));
    return status;
}   //  Rpc_ResetZoneAllowAutoNS



DNS_STATUS
Rpc_ResetZoneStringProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone LPWSTR property.
    It is permissable to set a string value to NULL.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPWSTR      value;
    LPWSTR      pwszValueForZone = NULL;
    LPWSTR *    ppwszZoneString = NULL;
    LPSTR       pszPropName = NULL;

    //  extract property name and value

    if ( dwTypeId != DNSSRV_TYPEID_LPWSTR )
    {
        return ERROR_INVALID_PARAMETER;
    }
    value = ( LPWSTR ) pData;

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneStringProperty():\n"
        "\tzone = %s\n"
        "\top   = %s\n"
        "\tval  = \"%S\"\n",
        pZone->pszZoneName,
        pszOperation,
        value ));

    //
    //  Set property.
    //

    if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE ) == 0 )
    {
        //
        //  Tricky: the incoming string is Unicode but save it in the
        //  zone structure as UTF8 for comparison convenience.
        //

        if ( value )
        {
            pwszValueForZone = ( LPWSTR ) Dns_StringCopyAllocate(
                                                ( PCHAR ) value,
                                                0,
                                                DnsCharSetUnicode,
                                                DnsCharSetUtf8 );
            if ( !pwszValueForZone )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Done;
            }
        }

        pszPropName = DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE_PRIVATE;
        ppwszZoneString = ( LPWSTR * ) &pZone->pszBreakOnUpdateName;
    }
    else
    {
        status = DNS_ERROR_INVALID_PROPERTY;
        goto Done;
    }

    //
    //  Copy (if not already copied) value and save to zone structure.
    //  Note: it is legal to set the value to NULL.
    //

    if ( ppwszZoneString )
    {
        if ( value )
        {
            if ( !pwszValueForZone )
            {
                pwszValueForZone = Dns_StringCopyAllocate_W( value, 0 );
            }
            if ( !pwszValueForZone )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Done;
            }
        }
        Timeout_FreeAndReplaceZoneData(
            pZone,
            ppwszZoneString,
            pwszValueForZone );
    }

    //
    //  Reset property in registry.
    //

    if ( pszPropName )
    {
        status = Reg_SetValue(
                    NULL,
                    pZone,
                    pszPropName,        //  actually a Unicode string
                    DNS_REG_WSZ,
                    value ? value : L"",
                    0 );                //  length
    }

    //
    //  Cleanup and return.
    //
    
    Done:

    return status;
}   //  Rpc_ResetZoneStringProperty


DNS_STATUS
Rpc_ResetZoneDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset zone DWORD property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD       value;
    DWORD       oldValue;
    DNS_STATUS  status;
    BOOLEAN     boolValue;
    BOOL        bsecureChange = FALSE;


    //  extract property name and value

    if ( dwTypeId != DNSSRV_TYPEID_NAME_AND_PARAM || !pData )
    {
        return( ERROR_INVALID_PARAMETER );
    }
    pszOperation = ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName;
    value        = ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam;
    boolValue    = (BOOLEAN) (value != 0);

    DNS_DEBUG( RPC, (
        "Rpc_ResetZoneDwordProperty():\n"
        "\tzone = %s\n"
        "\top   = %s\n"
        "\tval  = %d (%p)\n",
        pZone->pszZoneName,
        pszOperation,
        value, value ));

    //
    //  currently, cache zone doesn't have any of these properties
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    //
    //  turn on\off update
    //      - update only allowed on primary
    //      - secure update only on DS-primary
    //      - note update change, will timestamp changes on DS zones
    //
    //  if turning update ON
    //      - reset scanenging start time, as won't have been doing aging
    //      updates while update was off
    //      - notify netlogon
    //

    if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_ALLOW_UPDATE ) == 0 )
    {
        if ( ! IS_ZONE_PRIMARY(pZone) ||
             ( !pZone->fDsIntegrated && ZONE_UPDATE_SECURE == (UCHAR)value ) )
        {
            return( DNS_ERROR_INVALID_ZONE_TYPE );
        }

        if ( pZone->fAllowUpdate != (UCHAR)value )
        {
            bsecureChange = TRUE;
            oldValue = pZone->fAllowUpdate;
            pZone->fAllowUpdate = (UCHAR) value;

            if ( oldValue == ZONE_UPDATE_OFF )
            {
                pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();

                Service_SendControlCode(
                    g_wszNetlogonServiceName,
                    SERVICE_CONTROL_DNS_SERVER_START );
            }
        }
    }

    //  turn on\off secondary security
    //  NOTE: value is stored in a boolean but it takes more than just zero and one!

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_SECURE_SECONDARIES ) == 0 )
    {
        if ( ( int ) value < 0 || ( int ) value > ZONE_SECSECURE_HIGHEST_VALUE )
        {
            return ERROR_INVALID_PARAMETER;
        }
        pZone->fSecureSecondaries = ( BOOLEAN ) value;
    }

    //  turn on\off notify

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_NOTIFY_LEVEL ) == 0 )
    {
        pZone->fNotifyLevel = boolValue;
    }

    //  turn on\off update logging

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_LOG_UPDATES ) == 0 )
    {
        pZone->fLogUpdates = boolValue;
    }

    //
    //  set scavenging properties
    //      - no refresh interval
    //      - refresh interval
    //      - scavenging on\off
    //
    //  for refresh\norefresh times, 0 value will mean restore default
    //

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_NOREFRESH_INTERVAL ) == 0 )
    {
        if ( value == 0 )
        {
            //value = DNS_DEFAULT_NOREFRESH_INTERVAL_HR;
            value = SrvCfg_dwDefaultNoRefreshInterval;
        }
        pZone->dwNoRefreshInterval = value;
    }

    //
    //  refresh interval
    //

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_REFRESH_INTERVAL ) == 0 )
    {
        if ( value == 0 )
        {
            //value = DNS_DEFAULT_REFRESH_INTERVAL_HR;
            value = SrvCfg_dwDefaultRefreshInterval;
        }
        pZone->dwRefreshInterval = value;
    }

    //
    //  scavenge on\off
    //      - if turning on, then reset start of scavenge time
    //      note, do not do this unless was previously off, otherwise
    //      repeated admin "set" operation keeps moving out scavenge time
    //

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_AGING ) == 0 )
    {
        if ( !pZone->bAging && boolValue )
        {
            pZone->dwAgingEnabledTime = Aging_UpdateAgingTime();
        }
        pZone->bAging = boolValue;
    }

    //
    //  forwarder slave flag
    //

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_FWD_SLAVE ) == 0 )
    {
        if ( !IS_ZONE_FORWARDER( pZone ) )
        {
            return DNS_ERROR_INVALID_ZONE_TYPE;
        }
        pZone->fForwarderSlave = boolValue;
    }

    //
    //  forwarder timeout
    //

    else if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_FWD_TIMEOUT ) == 0 )
    {
        if ( !IS_ZONE_FORWARDER( pZone ) )
        {
            return DNS_ERROR_INVALID_ZONE_TYPE;
        }
        pZone->dwForwarderTimeout = value;
    }

    //
    //  changing all other DWORD properties
    //      - type
    //      - secure secondaries
    //      - DS integration
    //  should all be done in context of specific reset operation
    //

    else
    {
        return( DNS_ERROR_INVALID_PROPERTY );
    }

    //
    //  reset property DWORD in registry
    //

    status = Reg_SetDwordValue(
                NULL,
                pZone,
                pszOperation,
                value );

    ASSERT( status == ERROR_SUCCESS ||
            ( status == ERROR_OPEN_FAILED &&
                pZone->fDsIntegrated &&
                SrvCfg_fBootMethod == BOOT_METHOD_DIRECTORY ) );

    //
    //  reset property in DS
    //

    if ( pZone->fDsIntegrated )
    {
        if ( bsecureChange )
        {
            //
            // Get current Time & set zone llSecureUpdateTime value
            // Note: the time won't match the whenCreated on the ms, but
            // it should be close enough. The benefit this way, is that
            // we don't need to write, read whenChanged, & write again.
            //
            //  DEVNOTE: only really need time when go TO secure
            //      but writing it is harmless
            //

            LONGLONG llTime = GetSystemTimeInSeconds64();

            ASSERT( llTime > 0 );

            DNS_DEBUG( RPC, (
                "Setting zone->llSecureUpdateTime = %I64d\n",
                llTime ));

            pZone->llSecureUpdateTime = llTime;
       }

       //   write changes to the DS

       status = Ds_WriteZoneProperties( pZone );

       if ( status == ERROR_SUCCESS )
       {
           //
           // Touch DC=@ node to mark that the security on this node hasn't
           // node expired.
           // The security on the @ node should never be expired (otherwise we
           // introduce a security hole when the zone update state is flipped & anyone
           // can take over this node. We want to prevent this.
           // All we need to do is generate a node DS write. Currently the node dnsproperty
           // isn't used for anything (& even if it was this write is valid property update),
           // so we'll use this to generate the write.
           //
           //   DEVNOTE: ridiculous;  a better way is simply to special case "@" dn
           //       since we NEVER use any other node property but have to read and write
           //       it because of this
           //

           if ( pZone->pZoneRoot )
           {
               status = Ds_WriteNodeProperties(
                            pZone->pZoneRoot,
                            DSPROPERTY_ZONE_SECURE_TIME );
           }
       }
    }


    return( status );
}



DNS_STATUS
Rpc_ResetAllZonesDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset all zones DWORD property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS dwLastError = ERROR_SUCCESS, status;
    PZONE_INFO pzone;

    DNS_DEBUG( RPC, (
        "Rpc_ResetAllZonesDwordProperty\n" ));


    for ( pzone = Zone_ListGetNextZone(NULL);
          pzone != NULL;
          pzone = Zone_ListGetNextZone(pzone) )
    {

        if ( pzone->fAutoCreated ||
             IS_ZONE_CACHE ( pzone ) )
        {
            // rpc op on AutoCreated is not supported (see dispatching function).
            continue;
        }

        status = Rpc_ResetZoneDwordProperty(
                    dwClientVersion,
                    pzone,
                    pszOperation,
                    dwTypeId,
                    pData );
        if ( status != ERROR_SUCCESS )
        {
            dwLastError = status;
        }
    }

    DNS_DEBUG( RPC, (
        "Exit <%lu>: Rpc_ResetAllZonesDwordProperty\n",
        dwLastError ));

    return dwLastError;
}



//
//  Dispatched RPC Zone Queries
//

DNS_STATUS
Rpc_GetZoneInfo(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get zone info.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_ZONE_INFO  pinfo;

    DNS_DEBUG( RPC, (
        "RpcGetZoneInfo()\n"
        "  client ver       = 0x%08lX\n"
        "  zone name        = %s\n",
        dwClientVersion,
        pZone->pszZoneName ));

    if ( dwClientVersion == DNS_RPC_W2K_CLIENT_VERSION )
    {
        return W2KRpc_GetZoneInfo(
                    dwClientVersion,
                    pZone,
                    pszQuery,
                    pdwTypeId,
                    ppData );
    }

    //
    //  allocate\create zone info
    //

    pinfo = allocateRpcZoneInfo( pZone );
    if ( !pinfo )
    {
        DNS_PRINT(( "ERROR:  unable to allocate DNS_RPC_ZONE_INFO block.\n" ));
        goto DoneFailed;
    }

    //  set return ptrs

    *(PDNS_RPC_ZONE_INFO *)ppData = pinfo;
    *pdwTypeId = DNSSRV_TYPEID_ZONE_INFO;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneInfo(
            "GetZoneInfo return block",
            pinfo );
    }
    return( ERROR_SUCCESS );

DoneFailed:

    //  free newly allocated info block

    return( DNS_ERROR_NO_MEMORY );
}



DNS_STATUS
Rpc_GetZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get zone info.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_ZONE  prpcZone;

    DNS_DEBUG( RPC, ( "RpcGetZone(%s)\n", pZone->pszZoneName ));

    //
    //  allocate\create zone info
    //

    prpcZone = allocateRpcZone( pZone );
    if ( !prpcZone )
    {
        DNS_PRINT(( "ERROR:  unable to allocate DNS_RPC_ZONE block.\n" ));
        goto DoneFailed;
    }

    //  set return ptrs

    *(PDNS_RPC_ZONE *)ppData = prpcZone;
    *pdwTypeId = DNSSRV_TYPEID_ZONE;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZone(
            "GetZone return block",
            prpcZone );
    }
    return( ERROR_SUCCESS );

DoneFailed:

    //  free newly allocated info block

    return( DNS_ERROR_NO_MEMORY );
}



DNS_STATUS
Rpc_QueryZoneDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get zone DWORD property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD   value;

    DNS_DEBUG( RPC, ( "RpcQueryZoneDwordProperty(%s)\n", pZone->pszZoneName ));

    //
    //  check for each match, until get table going
    //

    if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_TYPE ) == 0 )
    {
        value = pZone->fZoneType;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_ALLOW_UPDATE ) == 0 )
    {
        value = pZone->fAllowUpdate;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_DS_INTEGRATED ) == 0 )
    {
        value = pZone->fDsIntegrated;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_SECURE_SECONDARIES ) == 0 )
    {
        value = pZone->fSecureSecondaries;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_NOTIFY_LEVEL ) == 0 )
    {
        value = pZone->fNotifyLevel;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_AGING ) == 0 )
    {
        value = pZone->bAging;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_NOREFRESH_INTERVAL ) == 0 )
    {
        value = pZone->dwNoRefreshInterval;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_REFRESH_INTERVAL ) == 0 )
    {
        value = pZone->dwRefreshInterval;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_FWD_TIMEOUT ) == 0 )
    {
        value = pZone->dwForwarderTimeout;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_FWD_SLAVE ) == 0 )
    {
        value = pZone->fForwarderSlave;
    }
    else
    {
        return( DNS_ERROR_INVALID_PROPERTY );
    }

    *(PDWORD)ppData = value;
    *pdwTypeId = DNSSRV_TYPEID_DWORD;
    return( ERROR_SUCCESS );
}



DNS_STATUS
Rpc_QueryZoneIPArrayProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get zone IP array property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PIP_ARRAY   value = NULL;

    DNS_DEBUG( RPC, ( "Rpc_QueryZoneIPArrayProperty(%s)\n", pZone->pszZoneName ));

    //
    //  check for each match, until get table going
    //

    if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_ALLOW_AUTONS ) == 0 )
    {
        value = pZone->aipAutoCreateNS;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_MASTERS ) == 0 )
    {
        value = pZone->aipMasters;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_LOCAL_MASTERS ) == 0 )
    {
        value = pZone->aipLocalMasters;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_SECONDARIES ) == 0 )
    {
        value = pZone->aipSecondaries;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_NOTIFY_LIST ) == 0 )
    {
        value = pZone->aipNotify;
    }
    else
    {
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //
    //  Allocate a copy of the IP array and return it. If we have a NULL array
    //  return NULL to the client so it knows the request was valid but there is
    //  no array set.
    //

    if ( value )
    {
        value = Dns_CreateIpArrayCopy( value );
        if ( !value )
        {
            return DNS_ERROR_NO_MEMORY;
        }
    }
    *( PIP_ARRAY * ) ppData = value;
    *pdwTypeId = DNSSRV_TYPEID_IPARRAY;
    return ERROR_SUCCESS;
}   //  Rpc_QueryZoneIPArrayProperty



DNS_STATUS
Rpc_QueryZoneStringProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get zone string property - returns wide string.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    LPWSTR      pwszValue = NULL;
    LPSTR       pszValue = NULL;

    DNS_DEBUG( RPC, (
        "Rpc_QueryZoneStringProperty( %s, %s )\n",
        pZone->pszZoneName,
        pszQuery ));

    //
    //  Check for each match, until get table going. Set either the wide
    //  or narrow value string pointer.
    //

    if ( _stricmp( pszQuery, DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE ) == 0 )
    {
        pszValue = pZone->pszBreakOnUpdateName;
    }
    else
    {
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //
    //  Copy (converting if necessary) the wide or narrow string.
    //

    if ( pszValue )
    {
        pwszValue = Dns_StringCopyAllocate(
                            pszValue,
                            0,                          // length
                            DnsCharSetUtf8,
                            DnsCharSetUnicode );
    }
    else if ( pwszValue )
    {
        pwszValue = Dns_StringCopyAllocate_W(
                            pwszValue,
                            0 );
    }

    * ( LPWSTR * ) ppData = pwszValue;
    *pdwTypeId = DNSSRV_TYPEID_LPWSTR;
    return ERROR_SUCCESS;
}   //  Rpc_QueryZoneIPArrayProperty



DNS_STATUS
Rpc_CreateZone(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Create a new zone

    Note this is a "ServerOperation" in the RPC sense.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DBG_FN( "Rpc_CreateZone" )

    PDNS_RPC_ZONE_CREATE_INFO pcreate = (PDNS_RPC_ZONE_CREATE_INFO)pData;

    PDNS_DP_INFO    pDpInfo = NULL;
    PZONE_INFO      pzone;
    PDB_NODE        pnodeCache;
    PDB_NODE        pnodeRoot;
    DWORD           zoneType = pcreate->dwZoneType;
    DNS_STATUS      status;
    INT             i;
    BOOL            fAutodelegate;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcUnion(
            "Rpc_CreateZone ",
            DNSSRV_TYPEID_ZONE_CREATE,
            pcreate );
    }

    //
    //  verify that zone type is valid
    //

    if ( zoneType != DNS_ZONE_TYPE_PRIMARY
        && zoneType != DNS_ZONE_TYPE_SECONDARY
        && zoneType != DNS_ZONE_TYPE_STUB
        && zoneType != DNS_ZONE_TYPE_FORWARDER )
    {
        status = DNS_ERROR_INVALID_ZONE_TYPE;
        goto Exit;
    }
    if ( !pcreate->pszZoneName )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  zone already exists?
    //

    pzone = Zone_FindZoneByName( (LPSTR) pcreate->pszZoneName );
    if ( pzone )
    {
        DNS_DEBUG( RPC, (
            "Zone %s already exists!\n",
            pcreate->pszZoneName ));
        status = IS_ZONE_FORWARDER( pzone ) ?
                    DNS_ERROR_FORWARDER_ALREADY_EXISTS :
                    DNS_ERROR_ZONE_ALREADY_EXISTS;
        goto Exit;
    }

    //
    //  Verify DP params make sense.
    //

    if ( ( pcreate->dwDpFlags || pcreate->pszDpFqdn ) &&
        !IS_DP_INITIALIZED() )
    {
        return ERROR_NOT_SUPPORTED;
    }

    if ( pcreate->dwDpFlags & 
        ~( DNS_DP_LEGACY | DNS_DP_DOMAIN_DEFAULT | DNS_DP_FOREST_DEFAULT ) )
    {
        //  Only certain flags have meaning here.
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    i = 0;
    if ( pcreate->dwDpFlags & DNS_DP_LEGACY )           ++i;
    if ( pcreate->dwDpFlags & DNS_DP_DOMAIN_DEFAULT )   ++i;
    if ( pcreate->dwDpFlags & DNS_DP_FOREST_DEFAULT )   ++i;

    if ( !pcreate->fDsIntegrated &&
        ( i != 0 || pcreate->pszDpFqdn != NULL ) )
    {
        //  partition specified for non-DS integrated zone!
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    if ( i > 1 )
    {
        //  Can specify at most one flag.
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    if ( i != 0 && pcreate->pszDpFqdn != NULL )
    {
        //  Cannot specify flag and custom name, only one or the other.
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  Find the partition specified. If not found then the zone can't be created.
    //
    //  For built-in partitions if the zone is not enlisted or not created, attempt
    //  to create it now using the admin's credentials.
    //

    if ( i || pcreate->pszDpFqdn ) 
    {
        PSTR        psz;

        //
        //  If a built-in partition was specified by name, substitute the
        //  flag instead.
        //

        if ( pcreate->pszDpFqdn )
        {
            psz = g_pszDomainDefaultDpFqdn;
            if ( psz && _stricmp( pcreate->pszDpFqdn, psz ) == 0 )
            {
                pcreate->dwDpFlags = DNS_DP_DOMAIN_DEFAULT;
            }
            else
            {
                psz = g_pszForestDefaultDpFqdn;
                if ( psz && _stricmp( pcreate->pszDpFqdn, psz ) == 0 )
                {
                    pcreate->dwDpFlags = DNS_DP_FOREST_DEFAULT;
                }
            }
        }

        //
        //  Find (and auto-create for built-in partitions) the DP.
        //

        if ( pcreate->dwDpFlags & DNS_DP_LEGACY )
        {
            pDpInfo = g_pLegacyDp;
        }
        else if ( pcreate->dwDpFlags & DNS_DP_DOMAIN_DEFAULT )
        {
            Dp_AutoCreateBuiltinPartition( DNS_DP_DOMAIN_DEFAULT );
            pDpInfo = g_pDomainDp;
        }
        else if ( pcreate->dwDpFlags & DNS_DP_FOREST_DEFAULT )
        {
            Dp_AutoCreateBuiltinPartition( DNS_DP_FOREST_DEFAULT );
            pDpInfo = g_pForestDp;
        }
        else if ( pcreate->pszDpFqdn != NULL )
        {
            pDpInfo = Dp_FindByFqdn( pcreate->pszDpFqdn );
        }

        if ( !pDpInfo )
        {
            status = DNS_ERROR_DP_DOES_NOT_EXIST;
            goto Exit;
        }
        if ( !IS_DP_ENLISTED( pDpInfo ) )
        {
            status = DNS_ERROR_DP_NOT_ENLISTED;
            goto Exit;
        }
    }

    //
    //  if zone root already exists, delete any existing cached records within zone
    //
    //  --  if creating in middle of authoritative zone => no delete
    //
    //  DEVNOTE: creating zone within existing, delete if file?
    //      might want to change this case to delete if reading from a file
    //
    //  --  if creating in cached area, delete everything in desired zone
    //      root's subtree EXCEPT any underlying authoritative zones
    //
    //  DEVNOTE: need zone split function
    //
    //  DEVNOTE: clean cache on new zone create
    //              - delete subtree of zone
    //              - or delete whole cache

    pnodeCache = Lookup_ZoneNodeFromDotted(
                    NULL,               // cache
                    (LPSTR) pcreate->pszZoneName,
                    0,
                    LOOKUP_FQDN,
                    LOOKUP_FIND_PTR,    // find mode
                    NULL                // no status
                    );
    if ( pnodeCache )
    {
        RpcUtil_DeleteNodeOrSubtreeForAdmin(
            pnodeCache,
            NULL,       //  no zone
            NULL,       //  no update list
            TRUE        //  deleting subtree
            );
    }

    //
    //  create primary zone?
    //      - create zone info
    //      - load database file, if specified
    //      - otherwise auto-create default zone records (SOA, NS)
    //

    if ( zoneType == DNS_ZONE_TYPE_PRIMARY )
    {
        DWORD   createFlag;

        //
        //  temp hack -- was passing all flags in LoadExisting
        //      making it fire even if DCPROMO was flag set
        //

        pcreate->fLoadExisting &= ~DNS_ZONE_CREATE_FOR_DCPROMO;

        //  end hack -- can remove after a few builds


        if ( pcreate->fLoadExisting ||
             (pcreate->dwFlags & DNS_ZONE_LOAD_EXISTING) )
        {
            createFlag = ZONE_CREATE_LOAD_EXISTING;
        }
        else
        {
            createFlag = ZONE_CREATE_DEFAULT_RECORDS;
        }

        //  catch DS failure
        //  temporarily special case DS integrated create until UI
        //      straightened out, allow both load attempt and
        //      default create if zone not yet in DS
        //      - don't wait for open
        //      - don't log error if can not open

        if ( pcreate->fDsIntegrated )
        {
            status = Ds_OpenServer( 0 );
            if ( status != ERROR_SUCCESS )
            {
                goto Exit;
            }
            createFlag |= ZONE_CREATE_DEFAULT_RECORDS;
        }

        status = Zone_CreateNewPrimary(
                    & pzone,
                    (LPSTR) pcreate->pszZoneName,
                    (LPSTR) pcreate->pszAdmin,
                    (LPSTR) pcreate->pszDataFile,
                    pcreate->fDsIntegrated,
                    pDpInfo,
                    createFlag );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  Failure to admin create primary zone %s.\n"
                "\tstatus = %d (%p).\n",
                pcreate->pszZoneName,
                status, status ));
            goto Exit;
        }

        //  DC promo transitional zone
        //      - write regkey, on reboot it is fixed

        if ( pcreate->dwFlags & DNS_ZONE_CREATE_FOR_DCPROMO )
        {
            Reg_SetDwordValue(
                NULL,
                pzone,
                DNS_REGKEY_ZONE_DCPROMO_CONVERT,
                TRUE );
        }
    }

    //
    //  create a zone with master IP list (secondary, stub, or forwarder)
    //

    else
    {
        ZONE_TYPE_SPECIFIC_INFO     ztsi;
        PZONE_TYPE_SPECIFIC_INFO    pztsi = NULL;

        status = Zone_ValidateMasterIpList( pcreate->aipMasters );
        if ( status != ERROR_SUCCESS )
        {
            goto Exit;
        }

        //
        //  Set up ztsi (zone type specific info).
        //

        if ( zoneType == DNS_ZONE_TYPE_FORWARDER )
        {
            ztsi.Forwarder.dwTimeout = pcreate->dwTimeout;
            ztsi.Forwarder.fSlave = ( BOOLEAN ) pcreate->fSlave;
            pztsi = &ztsi;
        }

        //
        //  Create the zone.
        //

        status = Zone_Create(
                    &pzone,
                    zoneType,
                    (LPSTR) pcreate->pszZoneName,
                    0,
                    pcreate->aipMasters,
                    pcreate->fDsIntegrated,
                    pDpInfo,
                    pcreate->pszDataFile,
                    0,
                    pztsi,
                    NULL );     //  existing zone
        if ( status != ERROR_SUCCESS )
        {
            goto Exit;
        }

        //
        //  Forwarder zones:
        //      - They never change so manually set them dirty to force write-back.
        //      - Start it up now.
        //

        if ( IS_ZONE_FORWARDER( pzone ) )
        {
            MARK_DIRTY_ZONE( pzone );
            status = Zone_PrepareForLoad( pzone );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( RPC, (
                    "Rpc_CreateZone( %s ) = %d from Zone_PrepareForLoad\n",
                    pcreate->pszZoneName,
                    status ));
                goto Exit;
            }
            status = Zone_ActivateLoadedZone( pzone );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DEBUG( RPC, (
                    "Rpc_CreateZone( %s ) = %d from Zone_ActivateLoadedZone\n",
                    pcreate->pszZoneName,
                    status ));
                goto Exit;
            }
        } // if

        //
        //  JJW: I'm not 100% sure if this is the proper place for this
        //  Write non-primary DS-integrated zones to the DS.
        //

        if ( IS_ZONE_DSINTEGRATED( pzone ) )
        {
            status = Ds_WriteZoneToDs( pzone, 0 );
            if ( status != ERROR_SUCCESS )
            {
                goto Failed;
            }
        }

        //  unlock zone
        //      zone is created locked, unlock here and let
        //      secondary zone control thread contact master and do transfer

        Zone_UnlockAfterAdminUpdate( pzone );
    }

    ASSERT( pzone && pzone->pZoneTreeLink );


    //
    //  Add delegation to parent zone?
    //  Do not do this for stub or forwarder zones. Also skip 
    //  autodelegation if the new zone is secondary and
    //  begins with _msdcs. This is generally an forest-wide 
    //  zone so adding an autodelegation may cause
    //  clients across the forest to hit branch office servers.
    //

    fAutodelegate = !IS_ZONE_FORWARDER( pzone ) && !IS_ZONE_STUB( pzone );

    if ( fAutodelegate && !IS_ZONE_PRIMARY( pzone ) )
    {
        #define DNS_MSDCS_ZONE_NAME_PREFIX          "_msdcs."
        #define DNS_MSDCS_ZONE_NAME_PREFIX_LEN      7

        fAutodelegate = 
             _strnicmp( pzone->pszZoneName,
                        DNS_MSDCS_ZONE_NAME_PREFIX,
                        DNS_MSDCS_ZONE_NAME_PREFIX_LEN ) != 0;
    }
        
    if ( fAutodelegate )
    {
        Zone_CreateDelegationInParentZone( pzone );
    }

    //
    //  DEVNOTE: set additional zone properties (Update, Unicode, etc.) on create
    //      - AllowUpdate
    //      - Unicode file
    //      - Secondaries
    //      - secondary security
    //

    //
    //  update boot info
    //

    Config_UpdateBootInfo();

    goto Exit;

Failed:

    Zone_Delete( pzone );

Exit:

    DNS_DEBUG( RPC, (
        "Rpc_CreateZone( %s ) = %d (%p)\n",
        pcreate->pszZoneName,
        status, status ));

    return( status );
}



DNS_STATUS
Rpc_EnumZones(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Enumerate zones.

    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

    None

Return Value:

    None

--*/
{
    PZONE_INFO          pzone = NULL;
    DWORD               count = 0;
    PDNS_RPC_ZONE       prpcZone;
    DNS_STATUS          status;
    PDNS_RPC_ZONE_LIST  pzoneList;

    DNS_DEBUG( RPC, (
        "RpcEnumZones():\n"
        "  client ver   = 0x%08lX\n", 
        "  filter       = 0x%08lX\n",
        dwClientVersion,
        ( ULONG_PTR ) pDataIn ));

    if ( dwClientVersion == DNS_RPC_W2K_CLIENT_VERSION )
    {
        return W2KRpc_EnumZones(
                    dwClientVersion,
                    pZone,
                    pszOperation,
                    dwTypeIn,
                    pDataIn,
                    pdwTypeOut,
                    ppDataOut );
    }

    //
    //  allocate zone enumeration block
    //  by default allocate space for 64k zones, if go over this we do
    //  a huge reallocation
    //

    pzoneList = (PDNS_RPC_ZONE_LIST)
                    MIDL_user_allocate(
                        sizeof(DNS_RPC_ZONE_LIST) +
                        sizeof(PDNS_RPC_ZONE) * MAX_RPC_ZONE_COUNT_DEFAULT );
    IF_NOMEM( !pzoneList )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    pzoneList->dwRpcStuctureVersion = DNS_RPC_ZONE_LIST_VER;

    //
    //  add all zones that pass filter
    //

    while ( pzone = Zone_ListGetNextZoneMatchingFilter( pzone, (DWORD)(ULONG_PTR)pDataIn ) )
    {
        //  create RPC zone struct for zone
        //  add to list, keep count

        prpcZone = allocateRpcZone( pzone );
        IF_NOMEM( !prpcZone )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }
        pzoneList->ZoneArray[count] = prpcZone;
        count++;

        //  check against max count
        //
        //  DEVNOTE: reallocate if more than 64K zones

        if ( count >= MAX_RPC_ZONE_COUNT_DEFAULT )
        {
            break;
        }
    }

    //  set return count
    //  set returned type
    //  return enumeration

    pzoneList->dwZoneCount = count;

    *(PDNS_RPC_ZONE_LIST *)ppDataOut = pzoneList;
    *pdwTypeOut = DNSSRV_TYPEID_ZONE_LIST;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneList(
            "Leaving R_DnsEnumZones() zone list sent:",
            pzoneList );
    }
    return( ERROR_SUCCESS );

Failed:

    DNS_PRINT((
        "R_DnsEnumZones(): failed\n"
        "\tstatus       = %p\n",
        status ));

    pzoneList->dwZoneCount = count;
    freeZoneList( pzoneList );
    return( status );
}



DNS_STATUS
Rpc_WriteDirtyZones(
    IN      DWORD       dwClientVersion,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Write back dirty zones.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PZONE_INFO  pzone = NULL;
    DNS_STATUS  status = ERROR_SUCCESS;

    DNS_DEBUG( RPC, ( "Rpc_WriteDirtyZones():\n" ));

    //
    //  loop through all zones
    //      - if dirty
    //  => then write back
    //

    while ( pzone = Zone_ListGetNextZone( pzone ) )
    {
        if ( ! pzone->fDirty )
        {
            continue;
        }

        if ( IS_ZONE_CACHE(pzone) )
        {
            Zone_WriteBackRootHints(
                FALSE       // don't write if not dirty
                );
        }

        //
        //  lock out transfer while rebuilding
        //

        if ( !Zone_LockForAdminUpdate( pzone ) )
        {
            status = DNS_ERROR_ZONE_LOCKED;
            continue;
        }

        //
        //  re-build zone information that depends on RRs
        //      - name server list
        //      - pointer to SOA record
        //      - WINS or NBSTAT info
        //
        //  note:  except for changes to NS list, this should already be
        //          setup, as individual RR routines do proper zone actions
        //          for SOA, WINS, NBSTAT
        //

        Zone_GetZoneInfoFromResourceRecords( pzone );

        //
        //  write zone back to file
        //

        if ( ! pzone->fDsIntegrated  )
        {
            if ( ! File_WriteZoneToFile( pzone, NULL ) )
            {
                status = ERROR_CANTWRITE;
            }
        }
        Zone_UnlockAfterAdminUpdate( pzone );

        //
        //  notify secondaries of update
        //
        //  obviously faster to do this before file write;  doing write first
        //  so that zone is less likely to be locked when SOA requests come
        //  from secondaries
        //

        if ( !IS_ZONE_CACHE(pzone) )
        {
            Xfr_SendNotify( pzone );
        }
    }

    //  note, we have error code if ANY zone failed

    return( status );
}



#if 0
//
//  Zone property tables
//
//  NOTE:   These MUST be kept in ssync.
//
//  In ZonePropertyCheckTable ID must match index.  Will fail on
//  startup of debug builds to insure that tables are kept in ssync.
//

PZONE_INFO   pz;

DWORD   value = (PBYTE)&pz->AllowUpdate - (PBYTE)pz;

#define ZONE_OFFSET(a)  ( ((PBYTE)&pz-> ## a) - (PBYTE)pz )

typedef struct _ZoneDwordProperty
{
    LPSTR   pszProperty;
    DWORD   dwOffset;
    DWORD   dwDefault;
}
ZONE_DWORD_PROPERTY;

ZONE_DWORD_PROPERTY ZoneDwordPropertyTable[] =
{
    DNS_REGKEY_ALLOW_UPDATE             ,
        ZONE_OFFSET( AllowUpdate )      ,
        0                               ,
    DNS_REGKEY_DS_INTEGRATED            ,
        ZONE_OFFSET( DsIntegrated )     ,
        0                               ,
    NULL,
        NULL,
        0
};



//
//  Zone Remote Calls
//

DNS_STATUS
R_DnssrvEnumZones(
    IN      DNS_SRV_HANDLE  hServer,
    IN      DWORD           dwFilter,
    OUT     PDWORD          pdwZoneCount,
    OUT     PDNS_RPC_ZONE * ppZones
    )
/*++

Routine Description:

    Enumerate zones.

Arguments:

    None

Return Value:

    None

--*/
{
    PZONE_INFO      pzone = NULL;
    DWORD           count = 0;
    PDNS_RPC_ZONE   prpcZone;
    DNS_STATUS      status;
    DNS_LIST        zoneList;

    if ( ERROR_SUCCESS != RpcUtil_ApiAccessCheck(DNS_ADMIN_ACCESS) )
    {
        return( ERROR_ACCESS_DENIED );
    }
    DNS_DEBUG( RPC, (
        "R_DnssrvEnumZones():\n"
        "\tdwFilter     = %p\n"
        "\tpdwZoneCount = %p\n"
        "\tppZones      = %p\n",
        dwFilter,
        pdwZoneCount,
        ppZones ));

    //
    //  add all zones that pass filter
    //

    DNS_LIST_INIT( &zoneList );

    while ( pzone = Zone_ListGetNextZoneMatchingFilter( pzone, dwFilter ) )
    {
        //  create RPC zone struct for zone

        prpcZone = allocateRpcZone( pzone );
        if ( !prpcZone )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }

        //  add to list, keep count

        DNS_LIST_ADD( &zoneList, prpcZone );
        count++;
    }

    //  return count and zone list

    *pdwZoneCount = count;
    *ppZones = (PDNS_RPC_ZONE) zoneList.pFirst;

    IF_DEBUG( RPC )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Leaving R_DnsEnumZones():\n"
            "\tzone count   = %d\n",
            count ));
        DnsDbg_RpcZoneList(
            "Zone list sent ",
            *ppZones );
        DnsDebugUnlock();
    }
    return( ERROR_SUCCESS );

Failed:

    DNS_PRINT((
        "R_DnsEnumZones(): failed\n"
        "\tstatus       = %p\n",
        status ));

    freeRpcZoneList( zoneList.pFirst );

    *pdwZoneCount = 0;
    *ppZones = NULL;
    return( status );
}

#endif

//
//  End of zonerpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\setup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by dnssetup.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\zonesec.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    zonesec.c

Abstract:

    Domain Name System (DNS) Server

    Routines to handle zone transfer for secondary.

Author:

    Jim Gilroy (jamesg)     May 1995

Revision History:

    jamesg      Oct 1997    -- IXFR support

--*/


#include "dnssrv.h"


//
//  Globals
//

BOOL    g_fUsingSecondary;


//  Notifies and SOA check responses queued by recv() threads
//  DEVNOTE: it might simply things if we had a separate queue
//      for notifies/SOA check responses/etc instead of sticking
//      them all in the same queue.

#define DNS_SECONDARY_QUEUE_DEFAULT_TIMEOUT     (5*60)

PPACKET_QUEUE   g_SecondaryQueue;


//  Zone transfer completion event
//  Allows us to wake secondary control thread when transfer completes

HANDLE  g_hWakeSecondaryEvent;


//
//  List of masters with outstanding XFR connections.
//  Keep this list, so don't attempt multiple connections to the same
//  master.  This will fail, as we always setup on DNS port to simplify
//  router configuration.
//

PIP_ARRAY   aipMastersOut;

//
//  Do SOA check on empty zone every minute.
//
//  Bracket zone check loop timeouts to reasonable values, so we
//  neither "lose control" and fail to check regularly, nor waste
//  cycles spinning.
//

#define DEFAULT_ZONE_RETRY_INTERVAL     (60)
#define IXFR_RETRY_INTERVAL             (60)
#define MIN_SOA_RETRY_TIME              (15)
#define MAX_FAST_SOA_CHECKS             (3)

#define MIN_SECONDARY_ZONE_CHECK_LOOP_TIME   (60)
#define MAX_SECONDARY_ZONE_CHECK_LOOP_TIME   (1200)

//  Backoff to avoid spinning in AXFR attempts to failing master

#define MAX_BAD_MASTER_SUPPRESS_INTERVAL    (10)    // 10 seconds

//  Timeout on non-responding primary

#define ZONE_TRANSFER_SELECT_TIMEOUT        (30)    // give up after 30 seconds

//  Bogus type to indicate stub transfer

#define DNS_TYPE_STUBXFR                    240

//  Stub zone transfers are controlled by a simple state machine. Start an
//  index at zero and iterate through the table below.

struct
{
    WORD                type;
    BYTE                recursionDesired : 1;   // type matches DNS_HEADER for simplicity
} g_stubXfrData[] =
{
    { DNS_TYPE_SOA,     0 },
    { DNS_TYPE_NS,      1 },
    { DNS_TYPE_ZERO,    0 }       // terminatator
};


//
//  Private protos
//

PZONE_INFO
readZoneFromSoaAnswer(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            wType,
    OUT     PDWORD          pdwMasterVersion,
    OUT     PDB_RECORD *    ppSoaRR
    );

VOID
processNotify(
    IN OUT  PDNS_MSGINFO    pMsg
    );

BOOL
processSoaCheckResponse(
    IN OUT  PDNS_MSGINFO    pResponse
    );

VOID
processIxfrUdpResponse(
    IN OUT  PDNS_MSGINFO    pResponse
    );

BOOL
startTcpXfr(
    IN OUT  PZONE_INFO      pZone,
    IN      IP_ADDRESS      ipMaster,
    IN      DWORD           dwMasterVersion,
    IN      SOCKET          Socket
    );

#if 0
BOOLEAN
Zone_SerialNumber(
    IN      PZONE_INFO      pZone,
    OUT     PDWORD          pdwSerialNo
    );
#endif



//
//  Public secondary utilities.
//
//  These are used by both secondary control thread and
//      zone transfer reception threads.
//

BOOL
Xfr_RefreshZone(
    IN OUT  PZONE_INFO  pZone
    )
/*++

Routine Description:

    Reset zone properties for successful refresh of zone.
    May be called after matching SOA check, or transfer of zone.

Arguments:

    pZone -- zone that has been refreshed

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PDB_RECORD  prrSoa = NULL;
    DWORD       currentTime;

    ASSERT( pZone );

    //
    //  Find SOA RR for new zone
    //      - save direct ptr to it
    //      - save serial number in host order for faster compares
    //
    //  DEVNOTE: should NOT need to find SOA unless
    //          - load
    //          - AXFR
    //          - IXFR
    //      in these cases should already have been loaded by standard "UpdateRoot"
    //      before this is called
    //      that processing also set serialNo
    //

    if ( pZone->pZoneRoot )
    {
        prrSoa = RR_FindNextRecord(
                    pZone->pZoneRoot,
                    DNS_TYPE_SOA,
                    NULL,
                    0 );
    }
    if ( !prrSoa )
    {
        DNS_PRINT(( "ERROR:  No SOA RR at new zone root\n" ));
        ASSERT( FALSE );
        pZone->pSoaRR = NULL;
        pZone->fEmpty = TRUE;
        pZone->fStale = TRUE;
        pZone->fShutdown = TRUE;
        return( FALSE );
    }

    pZone->pSoaRR = prrSoa;
    pZone->dwSerialNo = ntohl( prrSoa->Data.SOA.dwSerialNo );

    //
    //  Reset refresh and expire timeouts
    //      - set zone expiration time
    //      - attempt next SOA check after refresh interval
    //          (or at expire if sooner)
    //

    currentTime = DNS_TIME();

    pZone->dwExpireTime = ntohl( prrSoa->Data.SOA.dwExpire ) + currentTime;

    pZone->dwNextSoaCheckTime = ntohl( prrSoa->Data.SOA.dwRefresh ) + currentTime;

    if ( pZone->dwNextSoaCheckTime > pZone->dwExpireTime )
    {
        pZone->dwNextSoaCheckTime = pZone->dwExpireTime;
    }

    //
    //  Clear zone secondary state info
    //
    //  Note this does not include TRANSFER flags.
    //  Send may be in progress during check, and RECV flag serves
    //  as ownership flag for zone during transfer.
    //

    REFRESH_ZONE(pZone);

    return( TRUE );
}



VOID
Xfr_RetryZone(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Reset zone to retry SOA check.

    May be called after failure to receive SOA check, or failure
    during zone transfer attempt.

Arguments:

    pZone -- zone that must retry

Return Value:

    None.

--*/
{
    DWORD   dwRetryInterval = DEFAULT_ZONE_RETRY_INTERVAL;
    DWORD   currentTime = DNS_TIME();
    DWORD   nextTime;

    ASSERT( pZone );

    //
    //  We use UDP queries for SOA checks, which means that we need some
    //  limited fast retry. If a number of UDP SOA checks fail, assume that
    //  the connectivity problem is serious and drop back to the slow retry
    //  specified in the SOA for the zone.
    //

    if ( pZone->fSlowRetry || pZone->dwFastSoaChecks >= MAX_FAST_SOA_CHECKS )
    {
        DNS_DEBUG( XFR, (
            "Xfr_RetryZone( %s ): using slow interval from SOA RR %p\n",
            pZone->pszZoneName,
            pZone->pSoaRR ));

        if ( pZone->pSoaRR )
        {
            dwRetryInterval = ntohl( pZone->pSoaRR->Data.SOA.dwRetry );
        }
        pZone->fSlowRetry = FALSE;
        pZone->dwFastSoaChecks = 0;
    }
    else
    {
        ++pZone->dwFastSoaChecks;
    }


    DNS_DEBUG( XFR, (
        "Xfr_RetryZone( %s ): interval=%d fSlow=%d dwChecks=%d\n",
        pZone->pszZoneName,
        dwRetryInterval,
        ( int ) pZone->fSlowRetry,
        pZone->dwFastSoaChecks ));

    //
    //  set next SOA check time at retry time
    //
    //  but if expire time is closer, send next SOA at expiration
    //

    nextTime = dwRetryInterval + currentTime;

    if ( pZone->dwExpireTime < nextTime
            &&
        pZone->dwExpireTime > currentTime )
    {
        ASSERT( ! pZone->fShutdown );
        pZone->dwNextSoaCheckTime = pZone->dwExpireTime;
    }

    pZone->dwNextSoaCheckTime = nextTime;
}



VOID
Xfr_ForceZoneExpiration(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Force expiration of zone.
    This can be called from admin RPC thread and forces ZoneControlThread
    to expire the zone.

Arguments:

    pZone -- zone to expire

Return Value:

    None.

--*/
{
    DNS_DEBUG( XFR, (
        "Xfr_ForceZoneExpiration( %s )\n",
        pZone->pszZoneName ));

    //  set expire time to NOW
    //  then wake up zone control thread to force expiration

    pZone->dwExpireTime = DNS_TIME();

    SetEvent( g_hWakeSecondaryEvent );
}



VOID
Xfr_ForceZoneRefresh(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Force immediate refresh on zone.
    This can be called from admin RPC thread and forces ZoneControlThread
    to send SOA query for the zone.

Arguments:

    pZone -- zone to refresh

Return Value:

    None.

--*/
{
    DNS_DEBUG( XFR, (
        "Xfr_ForceZoneRefresh( %s )",
        pZone->pszZoneName ));

    //  set expire time to NOW
    //  then wake up zone control thread to force expiration

    pZone->dwNextSoaCheckTime = DNS_TIME();

    SetEvent( g_hWakeSecondaryEvent );
}




//
//  Secondary control, public functions
//
//  These routines are called by the main thread, or by
//  main UDP reception threads.
//

BOOL
Xfr_InitializeSecondaryZoneControl(
    VOID
    )
/*++

Routine Description:

    Initializes DNS to keep secondaries current with primary
    using zone transfer.

Arguments:

    None

Globals:

    g_fUsingSecondary
    g_SecondaryQueue

Return Value:

    TRUE, if successful
    FALSE otherwise, unable to create threads

--*/
{
    //
    //  if previous initialization
    //      - wakeup secondary control thread to initiate transfer
    //      - but skip initialization
    //

    if ( g_fUsingSecondary )
    {
        SetEvent( g_hWakeSecondaryEvent );
        return( TRUE );
    }

    //
    //  init globals to allow restart
    //

    aipMastersOut = NULL;

    //
    //  create packet queue for SOA check responses and notifications
    //      - set event on queuing
    //      - discard expired packets on queuing, so don't back
    //      up queue (and bloat memory) if someone launches NOTIFY
    //      attack
    //

    g_SecondaryQueue = PQ_CreatePacketQueue(
                            "Secondary",
                            QUEUE_SET_EVENT |
                                QUEUE_DISCARD_EXPIRED,
                            DNS_SECONDARY_QUEUE_DEFAULT_TIMEOUT );
    if ( !g_SecondaryQueue )
    {
        goto Failed;
    }

    //
    //  create zone transfer completion event
    //

    g_hWakeSecondaryEvent = CreateEvent(
                                NULL,       //  no security attributes
                                FALSE,      //  auto-reset
                                FALSE,      //  start non-signalled
                                NULL );     //  no name

    //
    //  create secondary version checking thread
    //

    if ( ! Thread_Create(
                "Secondary Control",
                Xfr_ZoneControlThread,
                NULL,
                DNS_EVENT_AXFR_INIT_FAILED ) )
    {
        goto Failed;
    }

    //
    //  indicate successful initialization
    //
    //  no protection is required on setting this as it is done
    //  only during startup database parsing
    //

    g_fUsingSecondary = TRUE;
    return( TRUE );

Failed:

    DNS_DEBUG( INIT, ( "Xfr_InitializeSecondaryZoneControl() failed.\n" ));
    return( FALSE );

}   //  Xfr_InitializeSecondaryZoneControl



VOID
Xfr_CleanupSecondaryZoneControl(
    VOID
    )
/*++

Routine Description:

    Cleanup secondary control handles for restart.

Arguments:

    None

Return Value:

    None

--*/
{
    //  cleanup secondary packet queue

    PQ_CleanupPacketQueueHandles( g_SecondaryQueue );

    //  cleanup secondary thread wakeup event

    CloseHandle( g_hWakeSecondaryEvent );
    g_hWakeSecondaryEvent = NULL;

}   //  Xfr_CleanupSecondaryZoneControl



VOID
Xfr_InitializeSecondaryZoneTimeouts(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Setup initial timeouts for secondary zone.

    Note, this routine is called on creating secondary zone, giving
    EVERY secondary zone the NO SOA initialization below.  After file
    load initialization may be reset to the have SOA version.

Arguments:

    pZone - info structure for zone

Return Value:

    None.

--*/
{
    PDB_RECORD  prrSoa = NULL;
    DWORD       currentTime;

    //
    //  DEVNOTE: should pick use RefreshZone for most of this and just
    //      add LoadVersion
    //

    //
    //  DEVNOTE: this should be called after zone loaded, to reset values
    //

    pZone->dwFastSoaChecks = 0;

    //
    //  get ptr to SOA -- if available
    //

    if ( pZone->pZoneRoot )
    {
        prrSoa = RR_FindNextRecord(
                    pZone->pZoneRoot,
                    DNS_TYPE_SOA,
                    NULL,
                    0 );
    }

    pZone->pSoaRR = prrSoa;

    currentTime = GetCurrentTimeInSeconds();


    //
    //  SOA exists -- set timeouts from SOA
    //
    //      - load version, is THIS version
    //      - set to do IMMEDIATE SOA check
    //      - clear shutdown and stale flags set on zone creation
    //

    if ( prrSoa )
    {
        pZone->dwSerialNo = ntohl( prrSoa->Data.SOA.dwSerialNo );
        pZone->dwLoadSerialNo = pZone->dwSerialNo;

        pZone->dwExpireTime = ntohl(prrSoa->Data.SOA.dwExpire) + currentTime;

        pZone->dwNextSoaCheckTime = 0;

        pZone->fEmpty = FALSE;
        pZone->fShutdown = FALSE;
        pZone->fStale = FALSE;

        IF_DEBUG( ZONEXFR )
        {
            Dbg_Zone(
                "Startup of active secondary zone:\n",
                pZone );
        }
    }

    //
    //  NO SOA -- setup for zone starting shutdown
    //      - set shutdown and stale flags
    //      - check immediately
    //
    //  note, this is the default initialization for ALL secondary zones
    //  on creation;  effectively covers the case of loading secondary
    //  without datafile OR admin created zone;  for normal file load
    //  this routine is called again after data load to read SOA above
    //

    else
    {
        pZone->fEmpty = TRUE;
        pZone->fShutdown = TRUE;
        pZone->fStale = TRUE;
        pZone->dwExpireTime = 0;
        pZone->dwNextSoaCheckTime = 0;

        IF_DEBUG( ZONEXFR )
        {
            Dbg_Zone(
                "Startup of shutdown secondary zone:\n",
                pZone );
        }
    }

}   //  Xfr_InitializeSecondaryZoneTimeouts



VOID
Xfr_QueueSoaCheckResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Queue SOA check response to secondary packet queue.
    This routine is called by UDP receive thread.

    Secondary zone control thread will dequeue and process.

Arguments:

    pMsg - ptr to message info

Return Value:

    None.

--*/
{
    //
    //  DEVNOTE: prevent security attack on secondary queue
    //  DEVNOTE: validation before queuing to secondary queue
    //      - is valid zone
    //      - already NOTIFIED?
    //      - packet queue that screens for duplicates (same remote IP and zone)
    //

    if ( g_fUsingSecondary )
    {
        PQ_QueuePacketEx( g_SecondaryQueue, pMsg, FALSE );
        DNS_DEBUG( ZONEXFR2, (
            "Xfr_QueueSoaCheckResponse queued %p, new queue length %d\n",
            pMsg,
            g_SecondaryQueue->cLength ));
        return;
    }

    //
    //  DEVNOTE-LOG: log warning to admin for bogus NOTIFY
    //
    //   may get NOTIFIES from server that thinks this server secondary
    //      for one of its zones
    //

    IF_DEBUG( ANY )
    {
        Dbg_DnsMessage(
            "WARNING:  Notify or SOA response while NOT secondary",
            pMsg );
    }
    Packet_Free( pMsg );

}   //  Xfr_QueueSoaCheckResponse




//
//  Secondary (and DS) control thread
//

DNS_STATUS
Xfr_ZoneControlThread(
    IN      LPVOID  pvDummy
    )
/*++

Routine Description:

    Thread to do version checking of all secondary zones.
    Initiates zone transfer when necessary.

Arguments:

    pvDummy - unused

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    DBG_FN( "Xfr_ZoneControlThread" )

    PZONE_INFO      pzone;              // zone info with nearest timeout
    PDNS_MSGINFO    pmsg;               // SOA response or notify message
    DNS_STATUS      status;
    DWORD           timeout;            // next timeout
    DWORD           currentTime;        // current time in seconds
    HANDLE          waitHandleArray[3];
    PCHAR           pszeventArgs[2];    // logging strings
    PPACKET_QUEUE   ptempQueue;

    //
    //  Create and lock temp queue. It will be held locked by this thread
    //  all the time since no other thread will need to use it.
    //

    ptempQueue = PQ_CreatePacketQueue( "ZoneXfrControl", 0, 0 );
    if ( ptempQueue )
    {
        LOCK_QUEUE( ptempQueue );
    }
    else
    {
        DNS_DEBUG( ZONEXFR, (
            "%s: unable to create temp queue\n"
            "\twill not requeue unhandled soa checks!", fn ));
    }

    //
    //  initialize array of objects to wait on
    //      - shutdown
    //      - received SOA or notify packet
    //      - transfer completed

    waitHandleArray[0] = hDnsShutdownEvent;
    waitHandleArray[1] = g_SecondaryQueue->hEvent;
    waitHandleArray[2] = g_hWakeSecondaryEvent;

    //
    //  keep array of masters with outstanding transfers
    //
    //  with this, we can avoid attempting multiple connections to
    //  same server (which will fail, since we use port 53 always)
    //

    aipMastersOut = DnsCreateIpArray( 10 );

    //
    //  Initial sleep. This thread usually starts up before all zones have 
    //  been created. Give the server some time to populate the zone list
    //  so that the first pass through the zone list takes all (or at 
    //  least more) zones into account.
    //

    status = WaitForSingleObject( hDnsShutdownEvent, 15 * 1000 );
    if ( status == WAIT_OBJECT_0 )
    {
        goto Cleanup;
    }

    //
    //  loop until service exit
    //
    //  This loop is executed essentially everytime we receive
    //  an SOA check response or notify packet OR when a timeout
    //  expires.
    //
    //  On each loop we send any SOA checks that are due (changing next
    //  timeout to retry interval), then wait for response or next timeout.
    //  On SOA response, timeouts reset for refresh, or zone transfer is
    //  initiated.
    //

    while ( TRUE )
    {
        DWORD       dwTimeSlept;

        //
        //  Check and possibly wait on service status
        //
        //  Note, we MUST do this check BEFORE any processing to make
        //  sure all zones are loaded before we begin checks.
        //

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( ZONEXFR, (
                "Terminating secondary zone control thread.\n" ));
            goto Cleanup;
        }
#if 0
        //
        //  transfering multiple zones to same master
        //      - no need for master list
        //
        //  clear masters outstanding list for rebuild

        Dns_ClearIpArray( aipMastersOut );
#endif
        //
        //  calculate next zone transfer timeout
        //
        //      - loop through all secondary zones
        //      - get lowest "next time"
        //      - find offset from current time
        //        if a timeout has already elapsed, use zero
        //

        currentTime = UPDATE_DNS_TIME();
        DNS_DEBUG( ZONEXFR, (
            "Timeout check current time = %lu (s).\n",
            currentTime ));

        //
        //  loop through secondaries
        //      - inititate needed SOA checks or zone transfer
        //      - determine timeout to next check
        //
        //  note:  set no timeout at no less than a few second
        //      minimum, so don't loop pointlessly before any SOA
        //      responses come back
        //
        //  DEVNOTE: may need a timeout max value to avoid
        //              long timeout locking things up while a
        //              zone is out for transfer
        //

        pzone = NULL;
        timeout = MAXULONG;

        while ( pzone = Zone_ListGetNextZone(pzone) )
        {
            //  ignore cache

            if ( IS_ZONE_CACHE(pzone) )
            {
                continue;
            }

            //
            // ignore primaries and forwarding zones
            //
            else if ( IS_ZONE_PRIMARY( pzone ) || IS_ZONE_FORWARDER( pzone ) )
            {
                continue;
            }

            //
            //  secondary
            //
            //  transfer in progress -- no SOA check
            //
            //  - add master to outstanding list
            //  - include zone in timeout check below, so that
            //      we don't forget its next timeout
            //

            else if ( pzone->fXfrRecvLock )
            {
                DNS_DEBUG( XFR, (
                    "%s: zone %s still transfering from %s\n", fn,
                    pzone->pszZoneName,
                    IP_STRING( pzone->ipFreshMaster ) ));
            }

            //
            //  zone expiring -- shut it down
            //
            //  note:  to avoid continuous sends, while master is offline,
            //  send SOA query on expiration, then only at retry intervals
            //

            else if ( pzone->dwExpireTime <= currentTime
                        &&
                    ! pzone->fShutdown )
            {
                IF_DEBUG( XFR )
                {
                    Dbg_Zone(
                        "Expiring zone ",
                        pzone );
                }
                pzone->fShutdown = TRUE;

                DNS_LOG_EVENT(
                    DNS_EVENT_ZONE_EXPIRATION,
                    1,
                    & pzone->pwsZoneName,
                    NULL,
                    0 );

                //  make immediate XFR attempt

                pzone->dwNextSoaCheckTime = currentTime;
                Xfr_SendSoaQuery( pzone );
            }

            //
            //  notified / refresh / retry => send SOA
            //
            //  send SOA check when zone
            //      - at refresh
            //      - or in retry from NOTIFY (SOA or IXFR attempt)
            //          or failed refresh SOA query
            //
            //  note:  processNotify() sends immediately, so no need to
            //          check it's flag here;  retries handled through timeout
            //

            else if ( pzone->dwNextSoaCheckTime < currentTime )
            {
                Xfr_SendSoaQuery( pzone );
            }
            ELSE_IF_DEBUG( ZONEXFR )
            {
                DNS_PRINT((
                    "%s: zone %s waiting for next timeout\n", fn,
                    pzone->pszZoneName ));
            }

            //
            //  find shortest timeout in zone list
            //

            if ( pzone->dwNextSoaCheckTime < timeout )
            {
                timeout = pzone->dwNextSoaCheckTime;
            }
        }

        //
        //  time to next retry/refresh time
        //
        //  a zone's next timeout may fall behind current time while
        //  zone is "owned" by transfer thread, producing a negative
        //  timeout interval;
        //
        //  hence use a small minimum loop interval
        //      - allows reception of SOA check packets
        //      - prompt check when transfer reception thread returns
        //          zone to our control
        //      - prevent spinning and wasted cycles is zone improperly
        //          configured with zero retry
        //
        //  for safety, fire up loop every hour or so to check things out
        //  convert to milliseconds for use in WaitForMultipleObjects()
        //

        timeout -= currentTime;
        DNS_DEBUG( ZONEXFR2, (
            "Min timeout found = %lu (s).\n",
             timeout ));

        if ( (LONG)timeout < MIN_SECONDARY_ZONE_CHECK_LOOP_TIME )
        {
            timeout = MIN_SECONDARY_ZONE_CHECK_LOOP_TIME;
        }
        else if ( timeout > (DWORD)MAX_SECONDARY_ZONE_CHECK_LOOP_TIME )
        {
            timeout = MAX_SECONDARY_ZONE_CHECK_LOOP_TIME;
        }

        //
        //  Wait for
        //      - SOA packet queued event
        //      - termination event
        //  with timeout to next zone SOA check.
        //

        WaitForTimeout:

        dwTimeSlept = UPDATE_DNS_TIME();

        DNS_DEBUG( ZONEXFR, (
            "%s: sleeping for %lu seconds at %lu\n", fn,
            timeout, 
            dwTimeSlept ));

        status = WaitForMultipleObjects(
                    3,
                    waitHandleArray,
                    FALSE,                // either event
                    ( timeout * 1000 )    // timeout in ms
                    );

        dwTimeSlept = UPDATE_DNS_TIME() - dwTimeSlept;

        #if 0

        //
        //  Adjust timeout by the amount of time we slept. Set it to
        //  zero to indicate that we slept as long as we need to.
        //

        if ( status != WAIT_OBJECT_0 + 2 || dwTimeSlept >= timeout )
        {
            //
            //  This event doesn't require us to go back to sleep or
            //  the time slept didn't make sense (could have wrapped).
            //

            timeout = 0;
        }
        else
        {
            timeout = timeout - dwTimeSlept;
        }

        #else

        //
        //  There seems to be some confusion about event usage. For now
        //  always set timeout to zero. This forces us to jump back up to
        //  top of loop and perform SOA checks as necessary after processing
        //  any outstanding received packets.
        //

        timeout = 0;

        #endif

        DNS_DEBUG( ZONEXFR2, (
            "%s: slept for %d seconds, timeout remaining %d, queue len %d\n", fn,
            dwTimeSlept,
            timeout,
            g_SecondaryQueue->cLength ));

        //
        //  Check and possibly wait on service status
        //

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( ZONEXFR, ( "%s: terminating\n", fn ));
            goto Cleanup;
        }

        //
        //  Read queued SOA check responses and NOTIFY messages
        //
        //  When indicated spawn the zone transfer threads
        //

        while ( pmsg = PQ_DequeueNextPacket( g_SecondaryQueue, FALSE ) )
        {
            DNS_DEBUG( ZONEXFR2, (
                "%s: deqeued %p length now %d\n", fn,
                 pmsg,
                 g_SecondaryQueue->cLength ));

            if ( pmsg->Head.Opcode == DNS_OPCODE_NOTIFY )
            {
                processNotify( pmsg );
            }
            else if ( IS_SOA_CHECK_XID(pmsg->Head.Xid) )
            {
                if ( !processSoaCheckResponse( pmsg ) )
                {
                    if ( ptempQueue )
                    {
                        DNS_DEBUG( ZONEXFR2, (
                            "%s: SOA check resp %p not handled, requeue later", fn,
                            pmsg ));
                        PQ_QueuePacketEx( ptempQueue, pmsg, TRUE );
                        pmsg = NULL;
                    }
                }

            }
            else
            {
                ASSERT( IS_IXFR_XID(pmsg->Head.Xid) );
                processIxfrUdpResponse( pmsg );
            }

            if ( pmsg )
            {
                Packet_Free( pmsg );
            }
        }

        //
        //  Requeue any messages not handled.
        //

        if ( ptempQueue && ptempQueue->cLength )
        {
            LOCK_QUEUE( g_SecondaryQueue );
            while ( pmsg = PQ_DequeueNextPacket( ptempQueue, TRUE ) )
            {
                PQ_QueuePacketEx( g_SecondaryQueue, pmsg, TRUE );
            }
            UNLOCK_QUEUE( g_SecondaryQueue );
        }

        //
        //  If there is more time left to sleep, just back up to the wait
        //  otherwise continue to the top of the loop for zone expiry checks.
        //

        if ( timeout > 0 )
        {
            goto WaitForTimeout;
        }
    }

    Cleanup:

    if ( ptempQueue )
    {
        UNLOCK_QUEUE( ptempQueue );
        PQ_DeletePacketQueue( ptempQueue );
    }

    return 1;
}   // Xfr_ZoneControlThread



//
//  SOA\IXFR request routines
//

PDNS_MSGINFO
Xfr_BuildXfrRequest(
    IN OUT  PZONE_INFO      pZone,
    IN      WORD            wType,
    IN      BOOL            fTcp
    )
/*++

Routine Description:

    Build IXFR query.

Arguments:

    pZone - info structure for zone

Return Value:

    Ptr to IXFR message buffer.

--*/
{
    PDNS_MSGINFO    pmsg;
    DWORD           length;

    //  verify secondary

    ASSERT( pZone );
    ASSERT( IS_ZONE_SECONDARY(pZone) );

    DNS_DEBUG( ZONEXFR, (
        "buildIxfrRequest() for zone %s\n",
        pZone->pszZoneName ));

    //
    //  if on startup with no file, may not have SOA
    //  then can't do IXFR
    //

    if ( !pZone->pSoaRR && wType == DNS_TYPE_IXFR )
    {
        DNS_DEBUG( ZONEXFR, (
            "Skipping IXFR, no SOA in zone %s\n",
            pZone->pszZoneName ));
        return( FALSE );
    }

    //
    //  create message info structure
    //

    length = 0;
    if ( fTcp )
    {
        length = DNS_TCP_MAXIMUM_RECEIVE_LENGTH;
    }
    pmsg = Msg_CreateSendMessage( length );
    IF_NOMEM( !pmsg )
    {
        return( NULL );
    }

    //
    //  write zone name question
    //

    if ( ! Msg_WriteQuestion(
                pmsg,
                pZone->pZoneTreeLink,
                wType ) )
    {
        DNS_DEBUG( ANY, (
            "ERROR: unable to write type=%d query for zone %s\n",
            wType,
            pZone->pszZoneName ));
        ASSERT( FALSE );
        goto Failed;
    }

    //
    //  for IXFR
    //      - current SOA in authority section
    //      - set XID to indicate IXFR check
    //

    if ( wType == DNS_TYPE_IXFR )
    {
        ASSERT( pZone->pZoneRoot && pZone->pSoaRR );

        pmsg->Head.Xid = MAKE_IXFR_XID( pmsg->Head.Xid );

        //  write current SOA

        pmsg->fDoAdditional = FALSE;

        SET_TO_WRITE_AUTHORITY_RECORDS(pmsg);

        if ( 1 != Wire_WriteRecordsAtNodeToMessage(
                        pmsg,
                        pZone->pZoneRoot,
                        DNS_TYPE_SOA,
                        DNS_OFFSET_TO_QUESTION_NAME,
                        0 ) )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Unable to write SOA to IXFR packet %s\n",
                pZone->pszZoneName ));
            ASSERT( FALSE );
            goto Failed;
        }
    }

    //  write MS transfer tag

    APPEND_MS_TRANSFER_TAG( pmsg );

    return( pmsg );

Failed:

    if ( pmsg )
    {
        Packet_Free( pmsg );
    }
    ASSERT( FALSE );
    return( NULL );
}



BOOL
Xfr_SendUdpIxfrQuery(
    IN OUT  PZONE_INFO      pZone,
    IN      IP_ADDRESS      ipAddress
    )
/*++

Routine Description:

    Send IXFR query to master.

Arguments:

    pZone - info structure for zone

    ipMaster - IP of master to send IXFR to

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    pmsg;

    //  verify secondary

    ASSERT( pZone );
    ASSERT( IS_ZONE_SECONDARY(pZone) );
    ASSERT( ZONE_MASTERS( pZone ) );

    DNS_DEBUG( ZONEXFR, (
        "Xfr_SendUdpIxfrQuery() for zone %s\n",
        pZone->pszZoneName ));

    //
    //  if zone has no SOA -- can't IXFR
    //

    if ( !pZone->pSoaRR )
    {
        ASSERT( IS_ZONE_EMPTY(pZone) );
        return( FALSE );
    }
    ASSERT( pZone->pZoneRoot );

    //
    //  create IXFR query
    //  - may be impossible if "fileless" zone on startup as no SOA to send
    //  - also possible to overrun UDP packet size with really long SOA name fields
    //

    pmsg = Xfr_BuildXfrRequest(
                pZone,
                DNS_TYPE_IXFR,
                FALSE           // use UDP
                );
    if( !pmsg )
    {
        return( FALSE );
    }

    //
    //  since UDP may lose query or non-IXFR-aware master may eat query
    //      or mangle response, set flag indicating IXFR tried and
    //      do short retry
    //

    pZone->dwNextSoaCheckTime = DNS_TIME() + IXFR_RETRY_INTERVAL;
    pZone->cIxfrAttempts++;

    pmsg->fDelete = TRUE;
    pmsg->RemoteAddress.sin_addr.s_addr = ipAddress;
    STAT_INC( SecondaryStats.IxfrUdpRequest );
    Send_Msg( pmsg );

    return( TRUE );
}



VOID
Xfr_SendSoaQuery(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Send SOA question to primary.

Arguments:

    pZone - info structure for zone

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    pmsg;
    PSOCKADDR_IN    pSockaddr;
    DWORD           i;

    //  verify secondary

    ASSERT( pZone );
    ASSERT( IS_ZONE_SECONDARY(pZone) );
    ASSERT( ZONE_MASTERS( pZone ) );

    DNS_DEBUG( ZONEXFR, (
        "Xfr_SendSoaQuery() to masters for zone %s\n",
        pZone->pszZoneName ));

    //
    //  if zone is in transfer then don't send
    //
    //  generally should NOT be locked to process SOA or IXFR response as
    //  these should occur along with SoaQuery in zone control thread)
    //

    if ( IS_ZONE_LOCKED_FOR_WRITE(pZone) )
    {
        DNS_DEBUG( XFR, (
            "Zone %s is write-locked, skipping SOA query!\n",
            pZone->pszZoneName ));
        return;
    }

    //
    //  if NOT required SOA send, avoid spin
    //
    //  DEVNOTE: may be issue here with SOA query lockout
    //      - SOA, IXFR attempt (possibly lost other SOA responses), SOA rejected
    //

    if ( pZone->dwLastSoaCheckTime + MIN_SOA_RETRY_TIME > DNS_TIME() )
    {
        DNS_DEBUG( XFR, (
            "Skipping SOA resend on zone %s.\n"
            "\tLast SOA send within last %d(s).\n"
            "\tlast send at %d\n"
            "\tcurrent time %d\n",
            pZone->pszZoneName,
            MIN_SOA_RETRY_TIME,
            pZone->dwLastSoaCheckTime,
            DNS_TIME() ));
        return;
    }

    //
    //  create message info structure
    //

    pmsg = Msg_CreateSendMessage( 0 );
    IF_NOMEM( !pmsg )
    {
        Xfr_RetryZone( pZone );
        return;
    }

    //
    //  build SOA query
    //      - set XID to indicate SOA check

    if ( ! Msg_WriteQuestion(
                pmsg,
                pZone->pZoneTreeLink,
                DNS_TYPE_SOA ) )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Unable to write SOA query for zone %s\n",
            pZone->pszZoneName ));
        Packet_Free( pmsg );
        ASSERT( FALSE );
        return;
    }
    pmsg->Head.Xid = MAKE_SOA_CHECK_XID( pmsg->Head.Xid );

    //
    //  send query to each master in list
    //      - no need to lock, atomic creation\deletion of master list
    //

    ASSERT( !pmsg->fDelete );

    pmsg->fDelete = TRUE;

    Send_Multiple(
        pmsg,
        ZONE_MASTERS( pZone ),
        & SecondaryStats.SoaRequest );

    pZone->dwLastSuccessfulSoaCheckTime = ( DWORD ) time( NULL );

    //
    //  reset timeouts for retry
    //

    Xfr_RetryZone( pZone );

    //
    //  DEVNOTE: zone expiration\stale issues
    //  DEVNOTE: when IXFR fails, should be doing direct connect for AXFR
    //
    //  DEVNOTE: need flags for each server in master list
    //      - sent SOA
    //      - sent IXFR
    //      - got response
    //      - has inferior version (if all masters hit this, REBUILD!)
    //      - has superior version (or reverse, "no-help" flag)
    //      - needs AXFR resposne to IXFR
    //      - invalid IXFR (primaryServer not valid)
    //      - refused IXFR (bad candidate for AXFR)
    //      - refused AXFR
    //
    //      Permanent flags:
    //      - doesn't understand IXFR
    //
    //  then can push through list trying IXFR until
    //      - success IXFR
    //      - known in ssync (all back are in ssync at least one at current)
    //      - need AXFR
    //      - can't get response from anyone, fall to default timeouts
    //

}   //  Xfr_SendSoaQuery



//
//  SOA\IXFR response routines
//

IP_ADDRESS
matchMessageToMaster(
    IN      PDNS_MSGINFO    pMsg,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Matches message sender to a zone master.

Arguments:

    pMsg -- message received

    pZone -- zone to find master in

Return Value:

    IP address of matching master, if successful.
    0 if no match.

--*/
{
    IP_ADDRESS  ip;

    ASSERT( ZONE_MASTERS( pZone ) );

    ip = pMsg->RemoteAddress.sin_addr.s_addr;

    if ( DnsIsAddressInIpArray(
            ZONE_MASTERS( pZone ),
            ip ) )
    {
        return( ip );
    }
    return( 0 );
}



PZONE_INFO
readZoneFromSoaAnswer(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            wType,
    OUT     PDWORD          pdwVersion,
    OUT     PDB_RECORD *    ppSoaRR
    )
/*++

Routine Description:

    Read zone info from SOA response.

Arguments:

    pMsg - ptr to response info

Return Value:

    None.

--*/
{
    register PCHAR  pch;
    PZONE_INFO      pzone;
    PDB_RECORD      psoaRR = NULL;


    DNS_DEBUG( ZONEXFR, ( "readZoneFromSoaAnswer(%p).\n", pMsg ));

    //
    //  validate as response packet
    //      - also points pCurrent at response
    //
    //  DEVNOTE: may want to handle no-answer case to catch authority empty
    //      responses from BIND servers that are not IXFR aware
    //

    if ( !Msg_ValidateResponse( pMsg, NULL, wType, 0 ) )
    {
        goto PacketError;
    }

    //
    //  find the zone
    //      - answer for node in database
    //      - must be zone root
    //      - zone must be secondary in list
    //      - sender IP, should be zone master
    //

    pzone = Lookup_ZoneForPacketName(
                pMsg->MessageBody,
                pMsg );
    if ( ! pzone )
    {
        Dbg_MessageName(
            "ERROR:  received SOA\\IXFR\\NOTIFY for non-authoritative zone ",
            pMsg->pCurrent,
            pMsg );
        //CLIENT_ASSERT( FALSE );
        goto PacketError;
    }
    pMsg->pzoneCurrent = pzone;

    //
    //  must be secondary (though may get NOTIFY to primary for DS-integrated)
    //

    if ( !IS_ZONE_SECONDARY(pzone) )
    {
        if ( pMsg->Head.Opcode == DNS_OPCODE_NOTIFY )
        {
            return( pzone );
        }
        //CLIENT_ASSERT( FALSE );
        goto PacketError;
    }

    //
    //  if notify, may not have SOA
    //

    if ( pMsg->Head.AnswerCount == 0 )
    {
        if ( pMsg->Head.Opcode == DNS_OPCODE_NOTIFY )
        {
            return( pzone );
        }
        CLIENT_ASSERT( FALSE );       // no SOA in response
        goto PacketError;
    }

    //
    //  parse SOA record
    //      - pull out master's version
    //

    pch = Wire_SkipPacketName( pMsg, pMsg->pCurrent );
    if ( ! pch )
    {
        goto PacketError;
    }

    //
    //  build SOA
    //      - will always need to check version
    //      - sometimes will need to check primary server
    //

    psoaRR = Wire_CreateRecordFromWire(
                pMsg,
                NULL,       //  haven't parsed RR header
                pch,
                MEMTAG_RECORD_AXFR );

    if ( !psoaRR )
    {
        goto PacketError;
    }
    if ( psoaRR->wType != DNS_TYPE_SOA )
    {
        goto PacketError;
    }

    *pdwVersion = ntohl( psoaRR->Data.SOA.dwSerialNo );

    if ( ppSoaRR )
    {
        *ppSoaRR = psoaRR;
    }
    else
    {
        RR_Free( psoaRR );
    }
    return( pzone );


PacketError:

    DNS_PRINT((
        "ERROR:  bogus SOA\\IXFR\\NOTIFY packet at %p from master %s\n",
        pMsg,
        IP_STRING( pMsg->RemoteAddress.sin_addr.s_addr )
        ));

    if ( ppSoaRR )
    {
        *ppSoaRR = NULL;
    }
    if ( psoaRR )
    {
        RR_Free( psoaRR );
    }
    return( NULL );
}



BOOL
doesMasterHaveFreshVersion(
    IN OUT  PZONE_INFO      pZone,
    IN      IP_ADDRESS      ipMaster,
    IN      DWORD           dwMasterVersion,
    IN      BOOL            fIxfr
    )
/*++

Routine Description:

    Check if response is fresh version.
    If master has fresh version, return.
    If master has older version reset zone timeouts.

    This exists simply to share code between IXFR and SOA query
    responses.

Arguments:

    pZone -- zone to transfer

    ipMaster -- master IP address

    dwMasterVersion -- master version

    fIxfr -- TRUE if response from IXFR

Return Value:

    TRUE if master has fresh (higher) version.
    FALSE otherwise.

--*/
{
    INT versionDiff;

    //
    //  compare versions, if fresh return
    //

    versionDiff = Zone_SerialNoCompare( dwMasterVersion, pZone->dwSerialNo );
    if ( versionDiff > 0 )
    {
        return( TRUE );
    }

    //
    //  DEVNOTE: need IN_SYNC_VERSION and LOWER_VERSION master flags
    //      then
    //          => refresh immediately if notifier
    //      otherwise
    //          -- all IN_SYNC => refresh
    //          -- all higher => log error
    //

    if ( versionDiff == 0 )
    {
#if 0
        //
        //  DEVNOTE: log to log, not event log
        //
        pszeventArgs[0] = pZone->pszZoneName;
        pszeventArgs[1] = szdwMasterVersion;
        pszeventArgs[2] = pszipMaster;

        DNS_LOG_EVENT(
            DNS_EVENT_ZONE_IN_SYNC,
            3,
            pszeventArgs,
            EVENTARG_ALL_UTF8,
            0 );
#endif
        DNS_DEBUG( ZONEXFR, (
            "Zone %s in sync with master, refresh timeouts.\n",
            pZone->pszZoneName ));

        if ( !pZone->ipNotifier || pZone->ipNotifier == ipMaster )
        {
            Xfr_RefreshZone( pZone );
        }
        else
        {
            pZone->fSlowRetry = TRUE;
            Xfr_RetryZone( pZone );
        }
    }

    //
    //  newer version than current?
    //
    //  if contacting another secondary rather than primary, then
    //  might have a version that is actually older than our own
    //
    //  test if difference < 0, this should not be true in any reasonable
    //  case IF not at startup of no file secondary
    //
    //  instead test if difference is greater than half a DWORD,
    //  then the "New" version is actually older
    //
    //  example:
    //      sNew = 5            sOld = 10           => transfer
    //      sNew = 0            sOld = 0xffffffff   => transfer
    //      sNew = 0xffffffff   sOld = 5            => hold onto old
    //

    else
    {
       ASSERT( (LONG)versionDiff < 0 );
#if 0
       argArray[0]  = pZone->pszZoneName;
       argArray[1]  = (PCHAR) pZone->dwSerialNo;
       argArray[2]  = (PCHAR) dwMasterVersion;
       argArray[3]  = (PCHAR) ipMaster;

       typeArray[0] = EVENTARG_UTF8;
       typeArray[1] = EVENTARG_DWORD;
       typeArray[2] = EVENTARG_DWORD;
       typeArray[3] = EVENTARG_IP_ADDRESS;

       DNS_LOG_EVENT(
           DNS_EVENT_ZONE_NEWER_THAN_SERVER_VERSION,
           4,
           argArray,
           typeArray,
           0 );
#endif

       DNS_DEBUG( XFR, (
           "WARNING:  Secondary zone %s newer than master (%s) -- no transfer.\n"
           "\tnew version      = %08lx\n"
           "\tcurrent version  = %08lx\n",
           pZone->pszZoneName,
           IP_STRING( ipMaster ),
           dwMasterVersion,
           pZone->dwSerialNo ));

       if ( !pZone->ipNotifier || pZone->ipNotifier == ipMaster )
       {
           Xfr_RefreshZone( pZone );
       }
       else
       {
           pZone->fSlowRetry = TRUE;
           Xfr_RetryZone( pZone );
       }
    }
    return( FALSE );
}



VOID
processNotify(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process NOTIFY packet.

    Find zone for notify, and setup zone for SOA check.
    Note:  Does NOT free NOTIFY packet -- callers responsibility.

Arguments:

    pMsg -- NOTIFY packet

Return Value:

    None.

--*/
{
    PZONE_INFO      pzone;
    IP_ADDRESS      ipnotifier;
    DWORD           masterVersion = 0;
    INT             versionDiff;

    ASSERT( pMsg->Head.Opcode == DNS_OPCODE_NOTIFY );

    DNS_DEBUG( ZONEXFR, ( "processNotify( %p ).\n", pMsg ));

    STAT_INC( SecondaryStats.NotifyReceived );

    //
    //  verify we have SOA notify, ignore other types
    //

    ipnotifier = pMsg->RemoteAddress.sin_addr.s_addr;

    if ( pMsg->wQuestionType != DNS_TYPE_SOA )
    {
        DNS_PRINT(( "WARNING:  message at %p, non-SOA NOTIFY.\n", pMsg ));
        STAT_INC( SecondaryStats.NotifyInvalid );
        return;
    }

    //
    //  verify packet
    //      - set to response since readZoneFromSoaAnswer will use ValidateResponse()
    //      - will extract SOA in notify if available
    //

    pMsg->Head.IsResponse = TRUE;

    pzone = readZoneFromSoaAnswer(
                pMsg,
                DNS_TYPE_SOA,
                & masterVersion,
                NULL );
    if ( !pzone )
    {
        Dbg_MessageName(
            "ERROR:  received notify for non-existent or non-root node.\n",
            pMsg->MessageBody,
            pMsg );
        STAT_INC( SecondaryStats.NotifyInvalid );
        return;
    }
    pMsg->Head.IsResponse = FALSE;

    DNS_DEBUG( XFR, (
        "Received notify for zone %s, at version %d\n"
        "\tcurrent version = %d\n",
        pzone->pszZoneName,
        masterVersion,
        pzone->dwSerialNo ));

    //
    //  check if primary zone
    //
    //  DEVNOTE: should log non-DS primary partner
    //  DEVNOTE: should we ACK notifies even if bogus?
    //

    if ( IS_ZONE_PRIMARY(pzone) )
    {
        //STAT_INC( PrivateStats.PrimaryNotifies );

        if ( pzone->fDsIntegrated )
        {
            DNS_DEBUG( XFR, (
                "Notify to primary-DS zone (presumably from partner).\n",
                pzone->pszZoneName ));
        }

        //
        //  DEVNOTE-LOG: log someone sending NOTIFYs to primary
        //

        Dbg_MessageName(
            "ERROR:  received notify for PRIMARY zone.\n",
            pMsg->MessageBody,
            pMsg );
        STAT_INC( SecondaryStats.NotifyPrimary );
        return;
    }

    //
    //  Check if other zone type that does not want notifies.
    //

    if ( IS_ZONE_STUB( pzone ) || IS_ZONE_FORWARDER( pzone ) )
    {
        DNS_DEBUG( XFR, (
            "Notify to non-primary zone %s zone type %d\n",
            pzone->pszZoneName,
            pzone->fZoneType ));
        Dbg_MessageName(
            "ERROR: received notify for non-primary zone\n",
            pMsg->MessageBody,
            pMsg );
        STAT_INC( SecondaryStats.NotifyNonPrimary );
        return;
    }

    //
    //  ACK notify packet
    //      - reset pCurrent to message length
    //      (readZoneFromSoaAnswer() leaves pCurrent at end of Question)
    //      - simply flip on IsResponse bit and send back
    //      - clear fDelete as message freed in main thread routine
    //

    pMsg->pCurrent = DNSMSG_END( pMsg );
    pMsg->Head.IsResponse = TRUE;
    pMsg->fDelete = FALSE;
    Send_Msg( pMsg );

    //
    //  no current version -- must send
    //

    if ( !pzone->pSoaRR )
    {
        STAT_INC( SecondaryStats.NotifyNoVersion );
        goto Send;
    }

    //
    //  check serial
    //      - notify only interesting if larger serial
    //

    if ( masterVersion )
    {
        versionDiff = Zone_SerialNoCompare( masterVersion, pzone->dwSerialNo );
        if ( versionDiff == 0 )
        {
            DNS_DEBUG( XFR, (
                "Notified by %s at same as current zone version %d\n",
                IP_STRING( ipnotifier ),
                pzone->dwSerialNo ));
            STAT_INC( SecondaryStats.NotifyCurrentVersion );
            return;
        }
        else if ( versionDiff < 0 )
        {
            DNS_DEBUG( XFR, (
                "Notified by %s at version %d less than current version %d\n",
                IP_STRING( ipnotifier ),
                masterVersion,
                pzone->dwSerialNo ));
            STAT_INC( SecondaryStats.NotifyOldVersion );
            return;
        }
        else
        {
            DNS_DEBUG( XFR, (
                "Notified by %s at version %d greater than current version %d\n",
                IP_STRING( ipnotifier ),
                masterVersion,
                pzone->dwSerialNo ));
            STAT_INC( SecondaryStats.NotifyNewVersion );
        }
    }

Send:

    //
    //  DEVNOTE: pick best notifier (highest version), if already notified
    //
    //  DEVNOTE: log complaint, if ONLY one master and it is behind in count
    //
    //  DEVNOTE: notified, same version, different primary???
    //
    //  DEVNOTE: fNotified flag is currently doing anything
    //

    //
    //  check if notifier is in zone's master list
    //  not necessarily a problem, as primary master may notify everyone
    //

    pzone->ipNotifier = 0;
    pzone->fNotified = TRUE;
    ipnotifier = pMsg->RemoteAddress.sin_addr.s_addr;

    if ( DnsIsAddressInIpArray(
            ZONE_MASTERS( pzone ),
            ipnotifier ) )
    {
        pzone->ipNotifier = ipnotifier;

        if ( Xfr_SendUdpIxfrQuery(
                pzone,
                ipnotifier ) )
        {
            return;
        }
    }

    STAT_INC( SecondaryStats.NotifyMasterUnknown );

    //
    //  notifier not in master list OR we can't build IXFR
    //

    DNS_DEBUG( ZONEXFR, (
        "WARNING:  Notify packet (%p), for zone %s, from %s\n"
        "\tNOT a specified master for this secondary zone.\n",
        pMsg,
        pzone->pszZoneName,
        IP_STRING(ipnotifier) ));

    Xfr_SendSoaQuery( pzone );

    //
    //  set NOTIFIED flag on zone -- forces SOA check request
    //
    //  DEVNOTE: save notified version, keep trying until get IT
    //
    //  DEVNOTE: save notify recv() socket
    //      this lets us send XFR on socket bound to this address
    //      either
    //      1) send SOA query on this socket, so get SOA response on it
    //      and hence have existing code to XFR with SOA response socket binding
    //      2) save notify recv socket binding IP, then can use it in XFR
    //      problem here is to know that notify binding() is correct
    //          - multiple notifies, second overwrites first
    //          - final responding server not original notifier
    //

}   //  processNotify



BOOL
processSoaCheckResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process response to SOA query from primary.

    Check that response is valid or determine whether serial number is
    new for its zone.

    Then refresh zone or initiate zone transfer.

Arguments:

    pMsg - ptr to response info

Return Value:

    Returns FALSE if no action was taken for this packet, for example if
    a zone transfer thread was not created because too many threads are
    already outstanding. The caller may will to requeue the msg and handle
    it later.

--*/
{
    DBG_FN( "processSoaCheckResponse" )

    BOOL        bMessageHandled = TRUE;
    PZONE_INFO  pzone = NULL;
    PDB_NODE    pnode = NULL;
    DWORD       i;
    BOOL        fzoneLocked = FALSE;
    DWORD       masterVersion = 0;      // serial number in SOA response
    DWORD       currentVersion;         // current serial number
    DWORD       versionDiff;
    IP_ADDRESS  masterIp;
    PCHAR       argArray[4];            // logging args
    BYTE        typeArray[4];

    DNS_DEBUG( ZONEXFR, ( "%s: pMsg %p\n", fn,  pMsg ));

    STAT_INC( SecondaryStats.SoaResponse );

    //
    //  Verify valid SOA response and extract zone. Note that AnswerCount
    //  can be greater than 1 because of SIGs.
    //

    if ( pMsg->Head.AnswerCount == 0 ||
        pMsg->Head.ResponseCode != DNS_RCODE_NO_ERROR )
    {
        goto SoaPacketError;
    }
    pzone = readZoneFromSoaAnswer(
                pMsg,
                DNS_TYPE_SOA,
                & masterVersion,
                NULL );
    if ( !pzone )
    {
        goto SoaPacketError;
    }

    ASSERT( IS_ZONE_SECONDARY(pzone) );

    //
    //  match SOA sender to a zone master server
    //
    //  don't do XID match, as may get caught always receiving
    //  and ignoring responses to previous SOA queries
    //
    //
    //  DEVNOTE: can not count on getting response from same master IP as sent
    //
    //  DEVNOTE: needs protection from admin or else master list structure
    //              must be atomic update
    //

    masterIp = pMsg->RemoteAddress.sin_addr.s_addr;

    if ( ! DnsIsAddressInIpArray(
            ZONE_MASTERS( pzone ),
            masterIp ) )
    {
        DNS_DEBUG( ZONEXFR, (
            "ERROR: SOA response (%p), for zone %s, from %s\n"
            "\tNOT from specified master for this secondary.\n",
            pMsg,
            pzone->pszZoneName,
            IP_STRING(masterIp) ));
        goto SoaPacketError;
    }

    //
    //  Reset the fast SOA checks counter on the zone. Since we got some kind
    //  of response the next time we want to start retries fresh.
    //

    pzone->dwFastSoaChecks = 0;

    //
    //  lock zone
    //

    if ( !Zone_LockForXfrRecv(pzone) )
    {
        DNS_DEBUG( XFR, (
            "%s: zone %s is locked ignoring SOA response\n", fn,
            pzone->pszZoneName ));
        goto Cleanup;
    }
    fzoneLocked = TRUE;


    //
    //  get current serial number for zone
    //      - make string representation for logging
    //
    //  if zone has no serial (i.e. no SOA) it is new unloaded zone
    //      (or broken somehow) and needs immediate transfer
    //

    if ( IS_ZONE_EMPTY(pzone) )
    {
        pzone->fNeedAxfr = TRUE;
        goto TransferZone;
    }

    //
    //  compare versions
    //      - if unchanged or lower, reset timeouts and we're done
    //      - if higher then transfer
    //

    if ( ! doesMasterHaveFreshVersion(
                pzone,
                masterIp,
                masterVersion,
                FALSE           // not IXFR response
                ) )
    {
        goto Cleanup;
    }

    //
    //  disable IXFR for stub zones - always use "customized" zone
    //  transfer (overridden in AXFR code).
    //

    if ( IS_ZONE_STUB( pzone ) )
    {
        pzone->fNeedAxfr = TRUE;
    }


TransferZone:

    DNS_DEBUG( XFR, (
        "%s: attempting to start xfer for zone %s\n", fn,
        pzone->pszZoneName ));

    //
    //  indicate new version on master
    //      - if unable to transfer, we'll know to keep trying
    //

    pzone->fStale = TRUE;

    //
    //  if haven't done IXFR, try it (if possible)
    //  otherwise do AXFR
    //
    //  DEVNOTE: consider SOA response master to be different from notifier
    //      a notifier definitely WILL XFR with you;  this one may not
    //
    //  DEVNOTE: need to check if THIS server has failed IXFR
    //

    if ( !pzone->fNeedAxfr  &&
            !pzone->fSkipIxfr &&
            pzone->cIxfrAttempts < 5 &&
            (DWORD)pzone->cIxfrAttempts < ZONE_MASTERS( pzone )->AddrCount  )
    {
        ASSERT( !IS_ZONE_EMPTY(pzone) );
        if ( Xfr_SendUdpIxfrQuery( pzone, masterIp ) )
        {
            goto Cleanup;
        }
    }

    pzone->fNeedAxfr = TRUE;    // force AXFR

    if ( !startTcpXfr(
                pzone,
                masterIp,
                masterVersion,
                pMsg->Socket ) )
    {
        bMessageHandled = FALSE;
    }
    return bMessageHandled;

SoaPacketError:

    //
    //  bad response, problem with other server
    //      or
    //  server doesn't have zone (NAME_ERROR)
    //

    STAT_INC( SecondaryStats.SoaResponseInvalid );
#if 0
    pszeventArgs[0] = pzone->pszZoneName;
    pszeventArgs[1] = pszmasterIp;

    DNS_LOG_EVENT(
        DNS_EVENT_ZONE_SERVER_BAD_RESPONSE,
        2,
        pszeventArgs,
        EVENTARG_ALL_UTF8,
        GetLastError() );
#endif

    IF_DEBUG( ZONEXFR )
    {
        Dbg_DnsMessage(
            "ERROR:  Bad SOA check response",
            pMsg );
    }

Cleanup:

    if ( fzoneLocked )
    {
        Zone_UnlockAfterXfrRecv( pzone );
    }
    return bMessageHandled;
}   //  processSoaCheckResponse




VOID
processIxfrUdpResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process IXFR response.

Arguments:

    pMsg - ptr to response info

Return Value:

    None.

--*/
{
    PZONE_INFO  pzone = NULL;
    PDB_RECORD  psoaRR = NULL;
    DNS_STATUS  status;
    DWORD       masterVersion;          // serial number in SOA response
    DWORD       currentVersion;
    DWORD       versionDiff;
    IP_ADDRESS  masterIp;
    BOOL        fzoneLocked = FALSE;
    UPDATE_LIST ixfrUpdateList;
    UPDATE_LIST passUpdateList;
    DWORD       eventId;
    PVOID       argArray[4];            // logging args
    BYTE        typeArray[4];


    DNS_DEBUG( ZONEXFR, (
        "processIxfrUdpMsg(%p).\n"
        "\tfrom master %s\n",
        pMsg,
        IP_STRING( pMsg->RemoteAddress.sin_addr.s_addr )
        ));
    IF_DEBUG( ZONEXFR2 )
    {
        Dbg_DnsMessage(
            "IXFR response\n",
            pMsg );
    }

    STAT_INC( SecondaryStats.IxfrUdpResponse );

    //  init update lists here, so we can call free routine in all cases
    //  both success and failure during parsing require free to avoid leak

    Up_InitUpdateList( &ixfrUpdateList );
    Up_InitUpdateList( &passUpdateList );

    //
    //  verify packet
    //

    pzone = readZoneFromSoaAnswer(
                pMsg,
                DNS_TYPE_IXFR,
                & masterVersion,
                & psoaRR );
    if ( !pzone )
    {
        //  DEVNOTE: check for authoritative empty response here
        //      non-ixfr MS-DNS would FORMERR IXFR, but a BIND server might
        //      accept as and simply indicate no "IXFR records"
        //  when stop generally going to AXFR on packet errors, need to
        //  make sure this particular case gets handled that way

        //  also should set SkipIxfr flag if clearly detect valid master with
        //      IXFR support problem

        DNS_DEBUG( ANY, (
            "ERROR:  IXFR response not for secondary zone!\n" ));
        status = DNS_ERROR_ZONE_NOT_SECONDARY;
        STAT_INC( SecondaryStats.IxfrUdpInvalid );
        goto Cleanup;
    }

    ASSERT( IS_ZONE_SECONDARY(pzone) );

#if 0
    //
    //  DEVNOTE: nice to do IXFR parsing outside of lock, but DOES NOT
    //              have much impact as really only affects locking out primary
    //              XFR;  other secondary action (outside AXFR) is on this thread
    //
    //  zone transfer lock to another server?
    //      - if so, dangerous to munge flags
    //
    //  note:  once verify zone not locked, then we can munge with
    //      impunity since ONLY zone control thread calls this function
    //      and starts transfers
    //      might lock zone on another thread to service an XFR as master
    //      but that wouldn't affect these secondary flags
    //

    if ( IS_ZONE_LOCKED(pzone) )
    {
        DNS_DEBUG( XFR, (
            "IXFR response from %s, for currently LOCKED zone %s\n"
            "\tignoring IXFR response\n",
            IP_STRING(masterIp),
            pzone->pszZoneName ));
        goto Cleanup;
    }
#endif

    //
    //  lock zone
    //

    if ( !Zone_LockForXfrRecv(pzone) )
    {
        DNS_DEBUG( XFR, (
            "Secondary Zone %s, locked -- unable to process UDP IXFR response.\n"
            "\tipFreshMaster    = %s\n"
            "\tIXFR master      = %s\n",
            pzone->pszZoneName,
            IP_STRING( pzone->ipFreshMaster ),
            IP_STRING( pMsg->RemoteAddress.sin_addr.s_addr )
            ));
        goto Cleanup;
    }
    fzoneLocked = TRUE;

    //
    //  match IXFR sender to a zone master server
    //
    //  DEVNOTE: can not count on getting response from same master IP as sent
    //
    //  DEVNOTE: needs protection from admin or else master list structure
    //              must be atomic update
    //
    //  DEVNOTE: use IXFR version info on IXFR from other server
    //      issues:
    //          - need to verify in list, or use just to force SOA requery
    //          - if in list, and higher than expected, try to get IXFR?
    //
    //  DEVNOTE: can not count on getting response from same master IP as sent
    //
    //  DEVNOTE: needs protection from admin or else master list structure
    //              must be atomic update
    //

    masterIp = pMsg->RemoteAddress.sin_addr.s_addr;

    if ( ! DnsIsAddressInIpArray(
            ZONE_MASTERS( pzone ),
            masterIp ) )
    {
        DNS_DEBUG( ZONEXFR, (
            "ERROR:  IXFR response (%p), for zone %s, from %s\n"
            "\tNOT from specified master for this secondary.\n",
            pMsg,
            pzone->pszZoneName,
            IP_STRING(masterIp) ));
        STAT_INC( SecondaryStats.IxfrUdpWrongServer );
        goto Cleanup;
    }

#if 0
    //
    //  if do SOA query first and designate "fresh master" then this is correct
    //      approach.  currently sending IXFR instead
    //
    //  if not master IP we just sent to
    //      - then assume this is stale, toss away
    //

    masterIp = pMsg->RemoteAddress.sin_addr.s_addr;

    if ( masterIp != pzone->ipFreshMaster && pzone->ipFreshMaster )
    {
        DNS_DEBUG( ZONEXFR, (
            "WARNING:  IXFR response (%p), for zone %s, version = %d, from %s\n"
            "\tNOT from specified master %p for this secondary.\n",
            pMsg,
            pzone->pszZoneName,
            IP_STRING(masterIp),
            pzone->ipFreshMaster ));

        STAT_INC( SecondaryStats.IxfrUdpWrongServer );
        goto Cleanup;
    }
#endif

    //
    //  need AXFR
    //      - now sending IXFR requests sometimes like SOA requests
    //

    if ( !pzone->pSoaRR )
    {
        DNS_PRINT((
            "ERROR:  IXFR response to zone %s, with no SOA\n"
            "\tshould have never sent IXFR!!!\n",
            pzone->pszZoneName ));
        goto TryAxfr;
    }

    //
    //  compare versions
    //      - if unchanged or lower, reset timeouts and we're done
    //      - if higher then continue to process IXFR
    //

    if ( ! doesMasterHaveFreshVersion(
                pzone,
                masterIp,
                masterVersion,
                TRUE        // IXFR
                ) )
    {
        STAT_INC( SecondaryStats.IxfrUdpNoUpdate );
        goto Cleanup;
    }

    //
    //  protect against bad IXFR to multi-DS-primary
    //  IXFR must satisfy one of two conditions
    //      - be from IP of last AXFR
    //      - have the same PrimaryServer field in the SOA
    //          indicating ultimate source is the same
    //
    //  DEVNOTE: should keep trying last AXFR master until sure it's dead
    //              before pulling whole AXFR
    //

    if ( masterIp != pzone->ipLastAxfrMaster )
    {
        if ( ! Name_IsEqualDbaseNames(
                    & psoaRR->Data.SOA.namePrimaryServer,
                    & pzone->pSoaRR->Data.SOA.namePrimaryServer ) )
        {
            DNS_DEBUG( XFR, (
                "WARNING:  IXFR response with new primary, forcing AXFR!\n"
                "\tIXFR master      = %s\n"
                "\tlast AXFR master = %s\n",
                IP_STRING( masterIp ),
                IP_STRING( pzone->ipLastAxfrMaster )
                ));
            STAT_INC( SecondaryStats.IxfrUdpNewPrimary );
            goto TryAxfr;
        }
    }

    //
    //  parse IXFR packet
    //      - init update lists
    //      - init packet context
    //      - parse packet
    //

    XFR_MESSAGE_NUMBER(pMsg) = 1;
    IXFR_CLIENT_VERSION(pMsg) = pzone->dwSerialNo;

    IXFR_MASTER_VERSION(pMsg) = 0;
    RECEIVED_XFR_STARTUP_SOA(pMsg) = FALSE;

    pMsg->pzoneCurrent = pzone;

    status =  Xfr_ParseIxfrResponse(
                    pMsg,
                    & ixfrUpdateList,   // full update list for transfer
                    & passUpdateList    // update list for this pass
                    );

    switch ( status )
    {

    case DNSSRV_STATUS_AXFR_COMPLETE:
        DNS_DEBUG( ZONEXFR, (
            "Recv'd valid UDP IXFR %p, from %s\n",
            pMsg,
            IP_STRING(masterIp) ));
        goto Done;

    case DNSSRV_STATUS_NEED_AXFR:

        //  the server has sent a single response SOA with its version
        //  this can be because
        //      - TCP necessary (IXFR does not fit in UDP message)
        //      - or AXFR required

        DNS_DEBUG( ZONEXFR, (
            "IXFR msg at %p indicates need TCP\n",
            pMsg ));

        STAT_INC( SecondaryStats.IxfrUdpUseTcp );
        goto TryTcp;

    case DNSSRV_STATUS_IXFR_UNSUPPORTED:

        //  master doesn't support IXFR
        //  set flag so always skipped

        pzone->fSkipIxfr = TRUE;

        DNS_DEBUG( ZONEXFR, (
            "WARNING:  IXFR msg at %p confused server %s, try AXFR\n",
            pMsg ));

        STAT_INC( SecondaryStats.IxfrUdpFormerr );
        goto TryAxfr;

    case DNS_ERROR_RCODE:
    {
        DNS_DEBUG( ZONEXFR, (
            "IXFR msg at %p with RCODE %d\n",
            pMsg,
            pMsg->Head.ResponseCode ));

        goto MasterFailure;
    }

#if 0
    case ERROR_SUCCESS:

        //  log this error -- malfunctioning IXFR implementation

        DNS_DEBUG( ANY, (
            "DNS server at %s, sent incomplete UDP IXFR %p\n",
            IP_STRING(masterIp),
            pMsg ));
        CLIENT_ASSERT( FALSE );
        goto MasterFailure;

    case DNSSRV_STATUS_AXFR_IN_IXFR:

        //  log this error -- malfunctioning IXFR implementation

        DNS_DEBUG( ANY, (
            "ERROR:  Recving AXFR in UDP IXFR message at %p\n",
            pMsg ));
        CLIENT_ASSERT( FALSE );
        goto MasterFailure;
#endif

    default:

        DNS_DEBUG( ANY, (
            "ERROR:  Unknown status %p (%d) from ParseIxfrResponse() on packet %p\n",
            status, status,
            pMsg ));

        //ASSERT( FALSE );
        goto MasterFailure;
    }

Done:

#if 0
    //  currently locking up above, before parsing message
    //
    //  valid IXFR message, read records into zone
    //

    if ( !Zone_LockForXfrRecv(pzone) )
    {
        DNS_PRINT((
            "ERROR:  Zone %s, locked -- unable to read in UDP IXFR transfer.\n",
            pzone->pszZoneName ));
        goto ServerFailure;
    }
    fzoneLocked = TRUE;
#endif


    //
    //  execute IXFR updates
    //      - leave zone locked until zone XFR flags reset
    //      - reinit update list to no-op global update list cleanup below
    //

    status = Up_ApplyUpdatesToDatabase(
                & ixfrUpdateList,
                pzone,
                DNSUPDATE_IXFR |
                    DNSUPDATE_COMPLETE |
                    DNSUPDATE_NO_UNLOCK |
                    DNSUPDATE_NO_NOTIFY
                );
    if ( status != ERROR_SUCCESS )
    {
        goto ServerFailure;
    }
    Up_InitUpdateList( &ixfrUpdateList );

    ASSERT( passUpdateList.pListHead == NULL );
    ASSERT( ixfrUpdateList.pListHead == NULL );

    //
    //  turn zone back on, reset its timeouts, reset failure count
    //
    //  save this version as base version -- may not do incrementals to
    //  secondaries with lower versions
    //

    STAT_INC( SecondaryStats.IxfrUdpSuccess );
    pzone->dwBadMasterCount = 0;
    Xfr_RefreshZone( pzone );
    pzone->dwLoadSerialNo = pzone->dwSerialNo;

    //
    //  write zone back to file -- if any
    //  notify any secondaries
    //
    //  DEVNOTE: push IXFR updates to disk
    //

    //File_WriteZoneToFile( pzone );

    Xfr_SendNotify( pzone );

    ASSERT( !pzone->fSkipIxfr );
    ASSERT( !pzone->fNeedAxfr );
    goto Cleanup;


MasterFailure:

    if ( pMsg->Head.ResponseCode == DNS_RCODE_REFUSED )
    {
        STAT_INC( SecondaryStats.IxfrUdpRefused );
        eventId = DNS_EVENT_AXFR_REFUSED;
    }
    else if ( pMsg->Head.ResponseCode == DNS_RCODE_FORMERR )
    {
        STAT_INC( SecondaryStats.IxfrUdpFormerr );
        eventId = DNS_EVENT_IXFR_UNSUPPORTED;
    }
    else
    {
        STAT_INC( SecondaryStats.IxfrUdpInvalid );

        DNS_DEBUG( ANY, (
            "ERROR:  %p (%d) parsing IXFR message %p\n",
            status, status,
            pMsg ));
        IF_DEBUG( ZONEXFR )
        {
            Dbg_DnsMessage(
                "ERROR:  Bad UDP IXFR response",
                pMsg );
        }
        eventId = DNS_EVENT_AXFR_BAD_RESPONSE;
        CLIENT_ASSERT( FALSE );
    }

    //
    //  log master failure -- but avoid log spinning
    //

    if ( pzone->dwBadMasterCount < 3 )
    {
        argArray[0]  = pzone->pwsZoneName;
        argArray[1]  = ( PCHAR ) ( DWORD_PTR ) masterIp;

        typeArray[0] = EVENTARG_UNICODE;
        typeArray[1] = EVENTARG_IP_ADDRESS;

        DNS_LOG_EVENT(
            eventId,
            2,
            argArray,
            typeArray,
            0 );
    }

    //  Count successive failures so we can back off and avoid spinning
    //  when server(s) are off-line, broken or refusing AXFR

    pzone->dwBadMasterCount++;

    //
    //  DEVNOTE: separate bad server, from broken IXFR -> go to AXFR
    //      => wrong zone, misbehaving => try different server
    //      => broken IXFR -> goto AXFR
    //

    if ( pMsg->Head.ResponseCode == DNS_RCODE_REFUSED )
    {
        goto Cleanup;
    }
    goto TryAxfr;


TryAxfr:

    DNS_DEBUG( XFR, (
        "Recv() unuseable UDP IXFR (%p) from %s, forcing AXFR.\n",
        pMsg,
        IP_STRING( masterIp ) ));

    STAT_INC( SecondaryStats.IxfrUdpUseAxfr );
    pzone->fNeedAxfr = TRUE;    // force AXFR

    fzoneLocked = FALSE;
    startTcpXfr( pzone, masterIp, masterVersion, pMsg->Socket );
    goto Cleanup;


TryTcp:

    ASSERT( !pzone->fSkipIxfr );
    STAT_INC( SecondaryStats.IxfrUdpUseTcp );
    pzone->fNeedAxfr = FALSE;   // try IXFR first

    startTcpXfr( pzone, masterIp, masterVersion, pMsg->Socket );
    fzoneLocked = FALSE;
    goto Cleanup;


ServerFailure:

    //
    //  Retry on transfer errors:
    //      - failure to contact server
    //      - bad packet
    //      - connection aborted or packets stop coming
    //

    STAT_INC( SecondaryStats.IxfrUdpInvalid );
    DNS_DEBUG( ANY, (
        "ERROR:  Server failure %p (%d) during transfer\n",
        status, status ));
    Xfr_RetryZone( pzone );

    //  fall through to thread exit


Cleanup:

    //
    //  cleanup
    //      - release lock on zone
    //      - free update lists
    //      - free copy of master SOA from packet
    //

    if ( fzoneLocked )
    {
        Zone_UnlockAfterXfrRecv( pzone );
    }

    if ( psoaRR )
    {
        RR_Free( psoaRR );
    }

    Up_FreeUpdatesInUpdateList( &ixfrUpdateList );
    Up_FreeUpdatesInUpdateList( &passUpdateList );

    return;

}   //  processIxfrResponse



BOOL
startTcpXfr(
    IN OUT  PZONE_INFO      pZone,
    IN      IP_ADDRESS      ipMaster,
    IN      DWORD           dwMasterVersion,
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Start up AXFR transfer.

Arguments:

    pZone -- zone to transfer

    ipMaster -- master IP address

    dwMasterVersion -- master version

    Socket -- socket of previous contact (SOA query, IXFR query) to master

Return Value:

    Return TRUE if transfer started, FALSE if not started.

--*/
{
    HANDLE  hthread;
    DWORD   waitTime;


    DNS_DEBUG( ZONEXFR, ( "startTcpXfr( %s ).\n", pZone->pszZoneName ));


    ASSERT( IS_ZONE_LOCKED_FOR_WRITE(pZone) );

    //
    //  if no master given, use current fresh master
    //

    if ( !ipMaster )
    {
        ASSERT( FALSE );
        goto Failed;
        //ipMaster = pZone->ipFreshMaster;
    }

    //
    //  make sure we don't spin attempting transfer from master
    //      -- bogus misbehaving master
    //      -- master refusing this secondary
    //
    //  if master is the same as previous attempt then will refuse retry
    //  for an interval that grows with each failed attempt
    //
    //  if master is different then last attempt we based on count,
    //      no suppression for first 5 attempts so retries to other
    //      possible masters may succeeds, then limit all retries to
    //      a minute
    //

    if ( pZone->dwBadMasterCount )
    {
        waitTime = 0;

        if ( pZone->ipFreshMaster == ipMaster )
        {
            waitTime = 60 + (pZone->dwBadMasterCount * 10);
            if ( waitTime > MAX_BAD_MASTER_SUPPRESS_INTERVAL )
            {
                waitTime = MAX_BAD_MASTER_SUPPRESS_INTERVAL;
            }
        }
        else if ( pZone->dwBadMasterCount > 5 )
        {
            waitTime = 60;
        }

        if ( pZone->dwZoneRecvStartTime + waitTime > DNS_TIME() )
        {
            DNS_DEBUG( XFR, (
                "WARNING:  Suppressing AXFR attempt on zone %s\n"
                "\tto master        = %p\n"
                "\tprevious master  = %p\n"
                "\tbad master count = %d\n"
                "\tlast recv() start time   %d\n"
                "\tcurrent time             %d\n"
                "\tsuppression lasts until  %d\n",
                pZone->pszZoneName,
                ipMaster,
                pZone->ipFreshMaster,
                pZone->dwBadMasterCount,
                pZone->dwZoneRecvStartTime,
                DNS_TIME(),
                pZone->dwZoneRecvStartTime + waitTime
                ));
            goto Failed;
        }
    }

#if 0
    //
    //  disable check for master in transfer, now using port > 53
    //

    //  check for current connection to master?
    //
    //  if so, we will be unable to connect to create new connection
    //  -- as we always use port 53 to simplify router configuration
    //

    if ( DnsIsAddressInIpArray(
            aipMastersOut,
            ipMaster ) )
    {
        IF_DEBUG( ZONEXFR )
        {
            DNS_PRINT((
                "\nWARNING:  Master %s currently busy with another zone.\n"
                "\tNo attempt to transfer zone %s, until it is finished.\n",
                IP_STRING(ipMaster),
                pZone->pszZoneName ));
            DnsDbg_IpArray(
                "Masters with outstanding XFR connections:",
                "master",
                aipMastersOut );
        }
        goto Failed;
    }
#endif

#if 0
    //  calling routines now locking while processing flags
    //
    //  lock zone for transfer
    //
    //  note:  if switch to locking with CS held during transfer
    //          then test should move to recv thread
    //

    if ( ! Zone_LockForXfrRecv(pZone) )
    {
        DNS_PRINT((
            "Zone %s, locked -- unable to transfer.\n",
            pZone->pszZoneName ));
        return FALSE;
    }
#endif

    //
    //  save master address
    //

    pZone->ipFreshMaster = ipMaster;
    //pZone->dwMasterSerialNo = masterVersion;

    //
    //  get binding address from previous contact with master
    //
    //  in multi-homed case where not listening on all sockets
    //  we may be in a situation where INADDR_ANY binding would
    //  give us an non-DNS interface;  this is ok, except that
    //  master may have secondary security set and only be listing
    //  addresses that secondary is configured to run DNS on;
    //  safest course is simply to bind() to IP address corresponding
    //  to UDP socket that we just reached the master with;  obviously
    //  we can reach master from this address
    //

    pZone->ipXfrBind = INADDR_ANY;

    if ( Socket )
    {
        pZone->ipXfrBind = Sock_GetAssociatedIpAddr( Socket );
        if ( pZone->ipXfrBind == (SOCKET)(-1) )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  UDP IXFR-SOA recv socket %d (%p), not found!\n"
                "\tBinding TCP XFR INADDR_ANY\n",
                Socket, Socket ));

            pZone->ipXfrBind = INADDR_ANY;
        }
    }

    //
    //  log zone transfer attempt
    //
    //  DEVNOTE: log file for this, regular log for completion
    //      with dynamic update may not want even completion to be logged
    //
    //  avoid spining when transfers are failing, by only logging first
    //  attempt

    if ( !pZone->dwBadMasterCount )
    {
        PVOID   argArray[3];
        BYTE    typeArray[3];

        argArray[0]  = ( PVOID ) ( DWORD_PTR ) dwMasterVersion;
        argArray[1]  = pZone->pwsZoneName;
        argArray[2]  = ( PVOID ) ( DWORD_PTR ) ipMaster;

        typeArray[0] = EVENTARG_DWORD;
        typeArray[1] = EVENTARG_UNICODE;
        typeArray[2] = EVENTARG_IP_ADDRESS;

        DNS_LOG_EVENT(
            DNS_EVENT_ZONE_TRANSFER_IN_PROGRESS,
            3,
            argArray,
            typeArray,
            0 );
    }

    //
    //  setup to transfer write lock to XFR thread
    //

    Zone_TransferWriteLock( pZone );

    //
    //  spawn zone transfer receptions thread
    //

    hthread = Thread_Create(
                  "Zone Transfer Receive",
                  Xfr_ReceiveThread,
                  (PVOID) pZone,
                  0 );
    if ( hthread )
    {
        DNS_DEBUG( ZONEXFR, (
            "Created XFR thread %p to recv zone %s\n",
            hthread,
            pZone->pszZoneName ));
        return TRUE;
    }

    //
    //  failed to create thread
    //
    //  - may well be unable to create thread, if many zones out
    //    for transfer at once
    //  - if can not start thread, then assume write lock ourselves
    //      to unlock before quit
    //
    //  DEVNOTE-LOG:  need logging for this error
    //

    DNS_DEBUG( ZONEXFR, (
        "ERROR:  unable to create thread to recv zone %s\n"
        "\tfrom %s.\n",
        pZone->pszZoneName,
        IP_STRING(ipMaster) ));

    Zone_AssumeWriteLock( pZone );

Failed:

    //  unlock and quit

    Zone_UnlockAfterXfrRecv( pZone );
    return FALSE;
}   //  startTcpXfr



//
//  XFR recv thread
//

DWORD
Xfr_ReceiveThread(
    IN      LPVOID  pvZone
    )
/*++

Routine Description:

    Zone transfer reception thread routine.

Arguments:

    pvZone - ptr to zone info for zone being transfered

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    DBG_FN( "Xfr_ReceiveThread" )

    PZONE_INFO      pzone = (PZONE_INFO) pvZone;
    PDNS_MSGINFO    pmsg = NULL;
    PDB_NODE        pzoneRoot = NULL;
    DWORD           currentTime;
    DWORD           eventId = 0;
    DNS_STATUS      status;
    INT             count;
    WORD            type = DNS_TYPE_IXFR;
    WORD            requestType;
    BOOL            fparseIxfr = TRUE;
    BOOL            finitialized = FALSE;
    BOOL            fupdateLists = FALSE;
    FD_SET          recvFdset;
    struct timeval  timeval;
    PCHAR           pszMasterIp;
    UPDATE_LIST     ixfrUpdateList;
    UPDATE_LIST     passUpdateList;
    INT             stubZoneXfrState = 0;
    PIP_ARRAY       pipMasters;

    //  verify secondary

    ASSERT( pzone );
    ASSERT( IS_ZONE_SECONDARY(pzone) );
    ASSERT( pzone->fLocked && pzone->fXfrRecvLock );
    ASSERT( pzone->ipFreshMaster );

    //  assume the zone write lock

    Zone_AssumeWriteLock( pzone );

    //  save master IP string

    pszMasterIp = inet_ntoa( *(struct in_addr *) &pzone->ipFreshMaster );

    DNS_DEBUG( ZONEXFR, (
        "%s starting for zone %s\n"
        "\tReceive transfer from master at %s.\n", fn,
        pzone->pszZoneName,
        pszMasterIp ));

    //  force STUBXFR or AXFR

    if ( IS_ZONE_STUB( pzone ) )
    {
        fparseIxfr = FALSE;
        type = DNS_TYPE_STUBXFR;
    }
    else if ( pzone->fNeedAxfr || pzone->fSkipIxfr || !pzone->pSoaRR )
    {
        fparseIxfr = FALSE;
        type = DNS_TYPE_AXFR;
    }

    //
    //  loop to receive zone transfer messages
    //      - build new zone outside database
    //
    //  continue until
    //      - receive entire new zone
    //      - connection dies
    //      - service termination
    //

    while ( TRUE )
    {
        //
        //  if this is a stub zone check if we're done
        //

        if ( IS_ZONE_STUB( pzone ) &&
             g_stubXfrData[ stubZoneXfrState ].type == DNS_TYPE_ZERO )
        {
            break;
        }

        //
        //  For stub zones:
        //      Send a query for the next type in the global state table.
        //  For other zones:
        //      Do init (we do this inside the loop, so we can retry server 
        //          that fails IXFR with AXFR)
        //

        if ( finitialized && type == DNS_TYPE_STUBXFR )
        {
            //
            //  Format and send next STUBAXR request message.
            //  We already have a pmsg, so just clear the data in it
            //  and write a new question.
            //

            //  Clear current pmsg contents.

            RtlZeroMemory(
                ( PCHAR ) DNS_HEADER_PTR( pmsg ),
                sizeof( DNS_HEADER ) );
            pmsg->pCurrent = pmsg->MessageBody;

            //
            //  Write new question to pmsg.
            //

            if ( IS_ZONE_STUB( pzone ) )
            {
                requestType = g_stubXfrData[ stubZoneXfrState ].type;
                pmsg->Head.RecursionDesired =
                    g_stubXfrData[ stubZoneXfrState ].recursionDesired;
            }
            else
            {
                requestType = type;
            }

            if ( ! Msg_WriteQuestion(
                        pmsg,
                        pzone->pZoneTreeLink,
                        requestType ) )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  Unable to write type=%d query for stub zone %s\n",
                    requestType,
                    pzone->pszZoneName ));
                ASSERT( FALSE );
                goto ServerFailure;
            }

            //  Send pmsg to zone master server.
            Send_Query( pmsg );
            pmsg->fMessageComplete = TRUE;
            pmsg->pzoneCurrent = pzone;
        } 
        else if ( !finitialized )
        {
            finitialized = TRUE;

            //
            //  create temp record store
            //      AXFR:  database to hold new zone during transfer
            //      IXFR:  update lists
            //
            //  then build IXFR or AXFR request
            //

            if ( IS_ZONE_STUB( pzone ) )
            {
                status = Zone_PrepareForLoad( pzone );
                if ( status != ERROR_SUCCESS )
                {
                    DNS_DEBUG( XFR, (
                        "WARNING:  Unable to init zone for STUBXFR for zone %s.\n"
                        "\tThis should only happen when have copy of zone in cleanup queue.\n",
                        pzone->pszZoneName ));
                    ASSERT( pzone->pOldTree );
                    goto ServerFailure;
                }
                STAT_INC( SecondaryStats.StubAxfrRequest );
                PERF_INC( pcAxfrRequestSent );               // PerfMon hook JJW
            } 
            else if ( fparseIxfr )
            {
                Up_InitUpdateList( &ixfrUpdateList );
                Up_InitUpdateList( &passUpdateList );
                fupdateLists = TRUE;
                STAT_INC( SecondaryStats.IxfrTcpRequest );
                PERF_INC( pcIxfrRequestSent );       // PerfMon hook
            }
            else
            {
                status = Zone_PrepareForLoad( pzone );
                if ( status != ERROR_SUCCESS )
                {
                    DNS_DEBUG( XFR, (
                        "WARNING:  Unable to init zone for AXFR in TCP-IXFR for zone %s.\n"
                        "\tThis should only happen when have copy of zone in cleanup queue.\n",
                        pzone->pszZoneName ));
                    ASSERT( pzone->pOldTree );
                    goto ServerFailure;
                }
                STAT_INC( SecondaryStats.AxfrRequest );
                PERF_INC( pcAxfrRequestSent );               // PerfMon hook
            }

            //  flag indicates we are in transfer

            pzone->fNeedAxfr = TRUE;

            //
            //  create XFR request message
            //

            requestType = IS_ZONE_STUB( pzone ) ?
                g_stubXfrData[ stubZoneXfrState ].type :
                type;
            pmsg = Xfr_BuildXfrRequest(
                        pzone,
                        requestType,
                        TRUE    // TCP message buffer
                        );
            if ( !pmsg )
            {
                goto ServerFailure;
            }

            //
            //  connect to primary and send
            //  use select to protect against hanging attempting to connect
            //

            pzone->dwZoneRecvStartTime = DNS_TIME();

            if ( ! Msg_MakeTcpConnection(
                        pmsg,
                        pzone->ipFreshMaster,
                        pzone->ipXfrBind,       // bind() address
                        0                       // no flags, non-blocking socket
                        ) )
            {
                DNS_DEBUG( ZONEXFR, (
                    "Zone transfer for %s failed connection to master at %s.\n",
                    pzone->pszZoneName,
                    pszMasterIp ));

                eventId = DNS_EVENT_XFR_MASTER_UNAVAILABLE;
                goto MasterFailure;
            }

            FD_ZERO( &recvFdset );
            FD_SET( pmsg->Socket, &recvFdset );

            timeval.tv_sec = SrvCfg_dwXfrConnectTimeout;
            timeval.tv_usec = 0;

            count = select( 0, NULL, &recvFdset, NULL, &timeval );

            if ( count != 1 )
            {
                DNS_DEBUG( ZONEXFR, (
                    "Zone transfer for %s timed out connecting to master at %s.\n",
                    pzone->pszZoneName,
                    pszMasterIp ));

                eventId = DNS_EVENT_XFR_MASTER_UNAVAILABLE;
                goto MasterFailure;
            }

            Send_Query( pmsg );

            //
            //  receive setup
            //      - mark message complete so Tcp_ReceiveMessage() will know
            //        that need to receive message length
            //

            pmsg->fMessageComplete = TRUE;
            pmsg->pzoneCurrent = pzone;

            XFR_MESSAGE_NUMBER(pmsg) = 0;
            IXFR_CLIENT_VERSION(pmsg) = pzone->dwSerialNo;
            IXFR_MASTER_VERSION(pmsg) = 0;
            RECEIVED_XFR_STARTUP_SOA(pmsg) = FALSE;
        }

        //
        //  wait for indication
        //
        //  DEVNOTE: better to have some hosed AXFR thread detection mechanism
        //      - could detect hosed thread and kill socket waking us up
        //        (detect by timeout on transfer or since last send, when go
        //        through secondaryControlThread and find zone locked for transfer)
        //

        count = select( 0, &recvFdset, NULL, NULL, &timeval );

        if ( count != 1 )
        {
            DnsDebugLock();
            DNS_DEBUG( ANY, (
                "ERROR:  timeout on select() receiving AXFR for zone %s (%p)\n"
                "\tattempting transfer from %s\n",
                pzone->pszZoneName,
                pzone,
                pszMasterIp ));

            Dbg_DnsMessage(
                "Current message of AXFR recv",
                pmsg );

            Dbg_Zone(
                "Zone hanging in AXFR recv:",
                pzone );
            DnsDebugUnlock();

            eventId = DNS_EVENT_XFR_ABORTED_BY_MASTER;
            goto MasterFailure;
        }

        //
        //  Receive the packet
        //

        DNS_DEBUG( ZONEXFR, (
            "Recv()ing zone transfer:  time = %lu.\n",
            pzone->dwZoneRecvStartTime ));

        pmsg = Tcp_ReceiveMessage( pmsg );

        //
        //  Check and possibly wait on service status
        //
        //  Check before recv() error check, as shutdown will cause
        //  recv() failure.
        //

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( ZONEXFR, (
                "Terminating zone transfer thread on service exit.\n" ));
            goto ThreadExit;
        }

        //
        //  No message received indicates error -- abort zone transfer
        //  Message not complete, loop back for more
        //

        if ( !pmsg )
        {
            goto ServerFailure;
        }
        if ( !pmsg->fMessageComplete )
        {
            continue;
        }

        if ( XFR_MESSAGE_NUMBER(pmsg) == 0 )
        {
            if ( fparseIxfr )
            {
                STAT_INC( SecondaryStats.IxfrTcpResponse );
                PERF_INC( pcIxfrResponseReceived );      //PerfMon hook
            }
            else if ( IS_ZONE_STUB( pzone ) )
            {
                STAT_INC( SecondaryStats.StubAxfrResponse );
                PERF_INC( pcAxfrResponseReceived );      //PerfMon hook JJW
            }
            else
            {
                STAT_INC( SecondaryStats.AxfrResponse );
                PERF_INC( pcAxfrResponseReceived );      //PerfMon hook
            }
        }
        XFR_MESSAGE_NUMBER(pmsg)++;

        IF_DEBUG( ZONEXFR )
        {
            Dbg_DnsMessage(
                "Response from master:",
                pmsg );
        }

        //
        //  Validate packet
        //
        requestType = IS_ZONE_STUB( pzone ) ?
            g_stubXfrData[ stubZoneXfrState ].type :
            type;
        if ( ! Msg_ValidateResponse(
                    pmsg,
                    NULL,
                    requestType,
                    DNS_OPCODE_QUERY ) )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Invalid response from primary.\n" ));
            goto MasterFailure;
        }

        //
        //  read IXFR packet
        //

        if ( fparseIxfr )
        {
            status =  Xfr_ParseIxfrResponse(
                            pmsg,
                            & ixfrUpdateList,   // full update list for transfer
                            & passUpdateList    // update list for this pass
                            );
            if ( status == ERROR_SUCCESS )
            {
                continue;
            }
            else if ( status == DNSSRV_STATUS_AXFR_COMPLETE )
            {
                DNS_DEBUG( ZONEXFR, ( "Recv'd last message zone transfer\n" ));
                break;
            }
            else if ( status == DNSSRV_STATUS_AXFR_IN_IXFR )
            {
                DNS_DEBUG( ZONEXFR, (
                    "Recving AXFR in TCP IXFR message at %p\n",
                    pmsg ));

                //  drops through to AXFR recv
                //  note type stays IXFR, but parse remaining messages AXFR

                status = Zone_PrepareForLoad( pzone );
                if ( status != ERROR_SUCCESS )
                {
                    DNS_DEBUG( XFR, (
                        "WARNING:  Unable to init zone for AXFR in TCP-IXFR for zone %s.\n"
                        "\tThis should only happen when have copy of zone in cleanup queue.\n",
                        pzone->pszZoneName ));
                    ASSERT( pzone->pOldTree );
                    goto ServerFailure;
                }
                fparseIxfr = FALSE;
                STAT_INC( SecondaryStats.IxfrTcpAxfr );
            }
            else if ( status == DNSSRV_STATUS_IXFR_UNSUPPORTED )
            {
                DNS_DEBUG( ZONEXFR, (
                    "WARNING:  IXFR msg at %p confused server, try AXFR\n",
                    pmsg ));

                shutdown( pmsg->Socket, 2 );
                Sock_CloseSocket( pmsg->Socket );
                Packet_FreeTcpMessage( pmsg );

                //  we reinitialize and try AXFR

                fparseIxfr = FALSE;
                type = DNS_TYPE_AXFR;
                finitialized = FALSE;
                STAT_INC( SecondaryStats.IxfrTcpFormerr );
                continue;
            }
            else
            {
                DNS_DEBUG( ZONEXFR, (
                    "ERROR:  ParseIxfrResponse() failure %p (%d).\n",
                    status, status ));
                goto MasterFailure;
            }
        }

        //
        //  read AXFR packet
        //      - not in else block as drop here if receiving AXFR in IXFR
        //

        status = Xfr_ReadXfrMesssageToDatabase(
                        pzone,
                        pmsg
                        );
        if ( status == ERROR_SUCCESS )
        {
            if ( IS_ZONE_STUB( pzone ) )
            {
                ++stubZoneXfrState; // Advance the stub state machine.
            }
            continue;
        }
        else if ( status == DNSSRV_STATUS_AXFR_COMPLETE )
        {
            DNS_DEBUG( ZONEXFR, ( "Recv'd last message zone transfer\n" ));
            break;
        }

        DNS_DEBUG( ZONEXFR, ( "Error <%lu>: Xfr_ReadXfrMessageToDatabase() failed.\n" \
                              "\tTerminating zone xfr processing.\n",
                              status
                              ) );

        goto MasterFailure;
    }

    //
    //  IXFR transfer done, execute IXFR updates
    //      - leave zone locked until zone XFR flags reset
    //      - reinit update list to no-op global update list cleanup below
    //

    if ( fparseIxfr )
    {
        status = Up_ApplyUpdatesToDatabase(
                    & ixfrUpdateList,
                    pzone,
                    DNSUPDATE_IXFR |
                        DNSUPDATE_COMPLETE |
                        DNSUPDATE_NO_UNLOCK |
                        DNSUPDATE_NO_NOTIFY
                    );
        if ( status != ERROR_SUCCESS )
        {
            goto ServerFailure;
        }
        Up_InitUpdateList( &ixfrUpdateList );

        ASSERT( passUpdateList.pListHead == NULL );
        ASSERT( ixfrUpdateList.pListHead == NULL );
        STAT_INC( SecondaryStats.IxfrTcpSuccess );
        PERF_INC( pcIxfrTcpSuccessReceived );        // PerfMon hook
        PERF_INC( pcIxfrSuccessReceived );           // PerfMon hook
    }

    //
    //  AXFR transfer done
    //      - splice zone into database
    //      - delete temp database
    //

    else
    {
        status = Zone_ActivateLoadedZone( pzone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Failed writing in new zone information for zone %s\n",
                pzone->pszZoneName
                ));
            ASSERT( FALSE );
            goto ServerFailure;
        }

        //  save last AXFR master, can not do incrementals from differing DS primaries//      as given version does NOT mean indentical data across all DS primaries

        pzone->ipLastAxfrMaster = pzone->ipFreshMaster;
        if ( IS_ZONE_STUB( pzone ) )
        {
            STAT_INC( SecondaryStats.StubAxfrSuccess );
            PERF_INC( pcAxfrSuccessReceived );       // PerfMon hook JJW
        }
        else
        {
            STAT_INC( SecondaryStats.AxfrSuccess );
            PERF_INC( pcAxfrSuccessReceived );       // PerfMon hook
        }
    }

    //
    //  refresh zone XFR info
    //

    pzone->dwBadMasterCount = 0;
    pzone->ipFreshMaster = 0;
    pzone->ipNotifier = 0;

    Xfr_RefreshZone( pzone );
    pzone->dwLoadSerialNo = pzone->dwSerialNo;

    //
    //  write zone back to file -- if any
    //  notify any secondaries
    //

    File_WriteZoneToFile( pzone, NULL );
    Xfr_SendNotify( pzone );

    pzone->dwLastSuccessfulXfrTime = ( DWORD ) time( NULL );

    DNS_DEBUG( ZONEXFR, (
        "%s: success on zone %s at %lu\n", fn,
        pzone->pszZoneName,
        pzone->dwLastSuccessfulXfrTime ));

    goto ThreadExit;


MasterFailure:

    if ( eventId == 0 )
    {
        if ( pmsg->Head.ResponseCode == DNS_RCODE_REFUSED )
        {
            if ( type == DNS_TYPE_IXFR )
            {
                STAT_INC( SecondaryStats.IxfrTcpRefused );
            }
            else if ( IS_ZONE_STUB( pzone ) )
            {
                STAT_INC( SecondaryStats.StubAxfrRefused );
            }
            else
            {
                STAT_INC( SecondaryStats.AxfrRefused );
            }
            eventId = DNS_EVENT_AXFR_REFUSED;
        }
        else
        {
            DNS_DEBUG( ANY, (
                "ERROR:  %p (%d) parsing XFR message\n",
                status, status,
                pmsg ));

            IF_DEBUG( ANY )
            {
                Dbg_DnsMessage(
                    "Bogus XFR message:\n",
                    pmsg );
            }
            eventId = DNS_EVENT_AXFR_BAD_RESPONSE;
            if ( type == DNS_TYPE_IXFR )
            {
                STAT_INC( SecondaryStats.IxfrTcpInvalid );
            }
            else if ( IS_ZONE_STUB( pzone ) )
            {
                STAT_INC( SecondaryStats.StubAxfrInvalid );
            }
            else
            {
                STAT_INC( SecondaryStats.AxfrInvalid );
            }
            CLIENT_ASSERT( FALSE );
        }
    }

    //
    //  log master failure -- but avoid log spinning
    //

    if ( pzone->dwBadMasterCount < 3 )
    {
        PVOID   argArray[2];
        BYTE    typeArray[2];

        argArray[0] = pzone->pwsZoneName;
        argArray[1] = pszMasterIp;

        typeArray[0] = EVENTARG_UNICODE;
        typeArray[1] = EVENTARG_UTF8;

        DNS_LOG_EVENT(
            eventId,
            2,
            argArray,
            typeArray,
            GetLastError() );
    }

    //  Count successive failures so we can back off and avoid spinning
    //  when server(s) are off-line, broken or refusing AXFR
    //
    //  DEVNOTE: track bad masters and avoid (with long retry) using them

    pzone->ipFreshMaster = 0;
    pzone->dwBadMasterCount++;
    goto ThreadExit;


ServerFailure:

    //
    //  Retry on transfer errors:
    //      - failure to contact server
    //      - bad packet
    //      - connection aborted or packets stop coming
    //

    DNS_DEBUG( ANY, (
        "ERROR:  Server failure %p (%d) during transfer\n",
        status, status ));
    Xfr_RetryZone( pzone );

    //  fall through to thread exit

ThreadExit:

    //
    //  shut connection
    //

    if ( pmsg )
    {
        //  close transfer socket

        if ( pmsg->Socket && pmsg->Socket != INVALID_SOCKET )
        {
            shutdown( pmsg->Socket, 2 );
            Sock_CloseSocket( pmsg->Socket );
        }
        Packet_FreeTcpMessage( pmsg );
    }

    //
    //  reset zone flags
    //
    //  always reset cIxfrAttempts, as can have failed IXFR because lost packet
    //
    //  however don't reset fSkipIxfr unless multiple masters;
    //  if have just single non-IXFR aware master, then flag prevents
    //  unnecessary IXFR queries;  with multiple masters
    //  if multiple masters, reset force AXFR flag as other masters
    //  might be IXFR aware
    //

    pzone->fNeedAxfr = FALSE;
    pzone->cIxfrAttempts = 0;
    pipMasters = ZONE_MASTERS( pzone );
    if ( pipMasters && pipMasters->AddrCount > 1 )
    {
        pzone->fSkipIxfr = FALSE;
    }

    //
    //  cleanup
    //      - free temp database
    //      - free update lists
    //      - release lock on zone
    //      - signal transfer completion
    //      - clear this thread from global array
    //

    Zone_CleanupFailedLoad( pzone );

    Zone_UnlockAfterXfrRecv( pzone );

    if ( fupdateLists )
    {
        Up_FreeUpdatesInUpdateList( &ixfrUpdateList );
        Up_FreeUpdatesInUpdateList( &passUpdateList );
    }

    //
    //  requery SOA if multiple masters
    //  this ensures we get the latest zone available
    //
    //  DEVNOTE: better would be to save best SOA response
    //      then make sure we update from that version (or better)
    //
    //  DEVNOTE: should probably eliminate this in favor of notify
    //

    ASSERT( ZONE_MASTERS( pzone ) );
    if ( ZONE_MASTERS( pzone ) &&
        ZONE_MASTERS( pzone )->AddrCount > 1 )
    {
        Xfr_SendSoaQuery( pzone );
    }

    //
    //  Signal the zone transfer master thread so that if other zones
    //  are ready to be transferred they can be started immediately.
    //  DEVNOTE: it would be cool to reuse this thread, but that would
    //  require getting the zone pointer from here. That would require
    //  some locking since two threads would be dequeuing responses,
    //  plus some responses are not supposed to be handled by this thread.
    //  So let's not bother with that for now.
    //

    if ( g_SecondaryQueue->cLength )
    {
        DNS_DEBUG( ZONEXFR2, (
            "%s: setting event to wake secondary thread (%d queued)\n", fn,
            g_SecondaryQueue->cLength ));
        SetEvent( g_hWakeSecondaryEvent );
    }

    Thread_Close( TRUE );
    return 0;
}



//
//  End zonesec.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\setup\dnssetup.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    DnsClnt.c

Abstract:

    Setup program for installing/removing the "EchoExample" service.

Author:

    David Treadwell (davidtr)    30-June-1994

Revision History:

    Chuck Y. Chan   (chuckc)     17-July-1994
        Misc cleanup. Pointer based blobs.

    Charles K. Moore (keithmo)   27-July-1994
        Added RrnSvc service setup option.

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define DNS_SERVICE_NAME       "DNS"
#define DNS_DISPLAY_NAME       "Domain Name Server"

#define SERVICES_KEY_NAME       "System\\CurrentControlSet\\Services"
#define EVENTLOG_KEY_NAME       SERVICES_KEY_NAME "\\EventLog\\System\\"

#define DNS_EVENT_KEY_NAME      EVENTLOG_KEY_NAME DNS_SERVICE_NAME

#define DNS_EXE_PATH            "%SystemRoot%\\system32\\dns.exe"

#define START_AUTOMATICALLY 0x2
#define START_MANUALLY      0x3

#define SERVICE_DEPENDENCY_LIST ("TcpIp\0Afd\0NetBT\0RpcSs\0NtLmSsp\0\0")


void
DnsServiceSetup(
    VOID
    )
{
    SC_HANDLE ServiceManagerHandle;
    SC_HANDLE ServiceHandle;
    HKEY DnsKey;
    LONG err;
    DWORD Disposition;
    DWORD Startval;

    //
    //  open service manager
    //

    ServiceManagerHandle = OpenSCManager(
                                NULL,
                                NULL,
                                SC_MANAGER_ALL_ACCESS );

    if( ServiceManagerHandle == NULL )
    {
        printf( "OpenSCManager failed: %ld\n", GetLastError() );
        exit(1);
    }

    //
    //  create the service
    //

    ServiceHandle = CreateService(
                        ServiceManagerHandle,
                        DNS_SERVICE_NAME,
                        DNS_DISPLAY_NAME,
                        GENERIC_READ | GENERIC_WRITE,
                        SERVICE_WIN32_SHARE_PROCESS,
                        SERVICE_DEMAND_START,
                        SERVICE_ERROR_NORMAL,
                        DNS_EXE_PATH,
                        NULL,
                        NULL,
                        SERVICE_DEPENDENCY_LIST,
                        NULL,
                        NULL );

    if( ServiceHandle == NULL )
    {
        //
        //  Service already exists?
        //

        if ( ( GetLastError() & 0xFFFF ) == ERROR_SERVICE_EXISTS )
        {
            printf( "Updating previously installed DNS service.\n" );

            ServiceHandle = OpenService(
                                ServiceManagerHandle,
                                DNS_SERVICE_NAME,
                                GENERIC_READ | GENERIC_WRITE );

            if ( ServiceHandle == NULL )
            {
                printf( "OpenService failed: %ld\n", GetLastError() );
                CloseServiceHandle( ServiceManagerHandle );
                exit(1);
            }

            if ( !ChangeServiceConfig(
                        ServiceHandle,
                        SERVICE_WIN32_SHARE_PROCESS,
                        SERVICE_DEMAND_START,
                        SERVICE_ERROR_NORMAL,
                        DNS_EXE_PATH,
                        NULL,
                        NULL,
                        SERVICE_DEPENDENCY_LIST,
                        NULL,
                        NULL,
                        DNS_DISPLAY_NAME ) )
            {
                printf(
                    "ERROR:  Could not change services configuration.\n"
                    "\tError = %ld\n"
                    "The DNS services may not be installed properly.\n",
                    GetLastError() );
            }
        }
        else
        {
            printf( "CreateService failed: %ld\n", GetLastError() );
            CloseServiceHandle( ServiceManagerHandle );
            exit(1);
        }
    }
    else
    {
        //
        //  successful creation of service
        //

        printf(
            "%s created with path %s\n",
            DNS_SERVICE_NAME,
            DNS_EXE_PATH );
    }

    CloseServiceHandle( ServiceHandle );
    CloseServiceHandle( ServiceManagerHandle );

    //
    //  Add the data to the EventLog's registry key so that the
    //  log insertion strings may be found by the Event Viewer.
    //

    err = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                DNS_EVENT_KEY_NAME,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                NULL,
                &DnsKey,
                &Disposition );

    if( err != ERROR_SUCCESS )
    {
        printf( "RegCreateKeyEx failed: %ld\n", err );
        exit(1);
    }

    err = RegSetValueEx(
                DnsKey,
                "EventMessageFile",
                0,
                REG_EXPAND_SZ,
                DNS_EXE_PATH,
                strlen( DNS_EXE_PATH ) + 1 );

    if( err == ERROR_SUCCESS )
    {
        DWORD Value;

        Value = EVENTLOG_ERROR_TYPE
                | EVENTLOG_WARNING_TYPE
                | EVENTLOG_INFORMATION_TYPE;

        err = RegSetValueEx(
                    DnsKey,
                    "TypesSupported",
                    0,
                    REG_DWORD,
                    (CONST BYTE *)&Value,
                    sizeof(Value) );
    }
    RegCloseKey( DnsKey );

    if( err != 0 )
    {
        printf( "RegSetValueEx failed: %ld\n", err );
        exit(1);
    }

    //
    //  Add the data to the EventLog's registry key so that the
    //  log insertion strings may be found by the Event Viewer.
    //

    RegCloseKey( DnsKey );

    if( err != 0 )
    {
        printf( "RegSetValueEx (%s) failed: %ld\n", "Start", err );
        exit(1);
    }

    exit(0);
}

void __cdecl
main (
    int argc,
    CHAR *argv[]
    )
{
    DnsServiceSetup();

    exit(0);

} // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\inc\sqllex.h ===
//***************************************************************************
//
//  SQLLEX.H
//
//  SQL Level 1 DFA Table & Tokens
//
//  Copyright 1998 Microsoft Corporation
//
//***************************************************************************


#ifndef _SQLLEX_H_

#define SQL_1_TOK_EOF       0
#define SQL_1_TOK_ERROR     1
#define SQL_1_TOK_IDENT     100
#define SQL_1_TOK_QSTRING   101
#define SQL_1_TOK_INT       102
#define SQL_1_TOK_REAL      103
#define SQL_1_TOK_CHAR      104

#define SQL_1_TOK_LE        105
#define SQL_1_TOK_LT        106
#define SQL_1_TOK_GE        107
#define SQL_1_TOK_GT        108
#define SQL_1_TOK_EQ        109
#define SQL_1_TOK_NE        110

#define SQL_1_TOK_DOT           111
#define SQL_1_TOK_OPEN_PAREN    112
#define SQL_1_TOK_CLOSE_PAREN   113
#define SQL_1_TOK_ASTERISK      114
#define SQL_1_TOK_COMMA         115

#define SQL_1_TOK_SELECT        120
#define SQL_1_TOK_WHERE         121
#define SQL_1_TOK_FROM          122
#define SQL_1_TOK_LIKE          123
#define SQL_1_TOK_OR            124
#define SQL_1_TOK_AND           125
#define SQL_1_TOK_NOT           126
#define SQL_1_TOK_IS            127
#define SQL_1_TOK_NULL          128

extern LexEl Sql_1_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\inc\ntrkcomm.h ===
#ifndef __provider_lib__
#define __provider_lib__

#if _MSC_VER > 1000
#pragma once
#endif 

#include <wbemprov.h>
#include <objbase.h>


typedef LPVOID * PPVOID;

class CWbemServices
{
protected:
	IWbemServices* m_pWbemServices;
public:
	CWbemServices(IWbemServices* );
	virtual ~CWbemServices();
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
		
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ BSTR QueryLanguage,
        /* [in] */ BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ BSTR QueryLanguage,
        /* [in] */ BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
		
    HRESULT STDMETHODCALLTYPE ExecMethod( 
		BSTR, 
		BSTR, 
		long, 
		IWbemContext*,
        IWbemClassObject*,
		IWbemClassObject**, 
		IWbemCallResult**) ;
		

};


class CImpersonatedProvider : public IWbemServices, public IWbemProviderInit 
{
protected:
    ULONG              m_cRef;         //Object reference count
    CWbemServices*  m_pNamespace;
 
public:
	CImpersonatedProvider(BSTR =NULL, BSTR =NULL , BSTR =NULL, IWbemContext* =NULL);
	virtual ~CImpersonatedProvider();

	//Non-delegating object IUnknown

	STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

            //IWbemProviderInit

    HRESULT STDMETHODCALLTYPE Initialize(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink
                    );

     //IWbemServices  

	  HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};

    
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecMethod( 
		const BSTR, 
		const BSTR, 
		long, 
		IWbemContext*,
        IWbemClassObject*,
		IWbemClassObject**, 
		IWbemCallResult**) 
		{return WBEM_E_NOT_SUPPORTED;}

    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync(
		const BSTR,
		const BSTR, 
		long, 
        IWbemContext*,
		IWbemClassObject*,
		IWbemObjectSink*);
protected:
	virtual HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
		/* [in] */ BSTR,	// Class,
		/* [in] */ long,	// lFlags,
		/* [in] */ IWbemContext __RPC_FAR *,	//pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *	//pResponseHandler
		)=0;

    virtual HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
        /* [in] */ BSTR ,	//ObjectPath,
        /* [in] */ long,	// lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,	//pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *	//pResponseHandler
		) =0;

	virtual HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
		BSTR,
		BSTR, 
		long, 
        IWbemContext*,
		IWbemClassObject*,
		IWbemObjectSink*
		)=0;

    virtual HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
        /* [in] */ BSTR, // QueryLanguage,
        /* [in] */ BSTR, // Query,
        /* [in] */ long, // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,   // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR * //pResponseHandler
		) =0;
	virtual HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
		/* [in] */ BSTR ObjectPath,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
		)=0;


	virtual HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
		/* [in] */ IWbemClassObject __RPC_FAR *,	//pInst,
		/* [in] */ long	,	// lFlags,
		/* [in] */ IWbemContext __RPC_FAR *,	//pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *	//pResponseHandler
		) =0;



};

class CWbemInstanceMgr
{
	
protected:
	IWbemObjectSink* m_pSink;
	IWbemClassObject **m_ppInst;
	DWORD m_dwThreshHold;
	DWORD m_dwIndex;
public:

	CWbemInstanceMgr(
		IWbemObjectSink*,
		DWORD =50);
	virtual ~CWbemInstanceMgr();
	void Indicate(IWbemClassObject*);
	void SetStatus(
		LONG,
		HRESULT,
		BSTR, 
		IWbemClassObject*);
};



#endif // end of provlib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\inc\sqleval.h ===
#ifndef __provider_sql_eval_lib__
#define __provider_sql_eval_lib__
#if _MSC_VER > 1000
#pragma once
#endif 

#include <wbemprov.h>
#include <objbase.h>
#include <list>
using namespace std;
struct SQL_LEVEL_1_RPN_EXPRESSION;
// object to be evaluated by sql eval
// a CSqlEvalee is provided based on IWbemClassObject
// To Evaluate different object, provide your class inherit from
// CSqlEvalee

class CSqlEvalee
{
public:
	virtual const VARIANT* Get(WCHAR*)=0;
};

class CSqlWmiEvalee : public CSqlEvalee
{
protected:
	IWbemClassObject* m_pInstance;
	VARIANT m_v;
public:
	CSqlWmiEvalee(
		IWbemClassObject*);
	~CSqlWmiEvalee();
	const VARIANT* Get(WCHAR*);
};
// sql eval
class CQueryEnumerator;

class CSqlEval
{
	
public:
	virtual BOOL Evaluate(CSqlEvalee*);
	virtual ~CSqlEval(){};
	virtual void GenerateQueryEnum(CQueryEnumerator&){};
	static CSqlEval* CreateClass(
		SQL_LEVEL_1_RPN_EXPRESSION*,
		int* );
};

class CSqlEvalAnd : public CSqlEval
{
public:
	BOOL Evaluate(CSqlEvalee*);
	CSqlEvalAnd(
		SQL_LEVEL_1_RPN_EXPRESSION*,
		int* );
	void GenerateQueryEnum(CQueryEnumerator&);
	virtual ~CSqlEvalAnd();
protected:
	CSqlEval* m_left;
	CSqlEval* m_right;

};

class CSqlEvalOr: public CSqlEval
{
public:
	BOOL Evaluate(CSqlEvalee*);
	CSqlEvalOr(
		SQL_LEVEL_1_RPN_EXPRESSION*,
		int* );
	void GenerateQueryEnum(CQueryEnumerator&);
	virtual ~CSqlEvalOr();
protected:
	CSqlEval* m_left;
	CSqlEval* m_right;

};

class CSqlEvalNot: public CSqlEval
{
public:
	BOOL Evaluate(CSqlEvalee*);
	CSqlEvalNot(
		SQL_LEVEL_1_RPN_EXPRESSION*,
		int* );
	virtual ~CSqlEvalNot();
	void GenerateQueryEnum(CQueryEnumerator&);
protected:
	CSqlEval* m_exp;
};

class CSqlEvalExp: public CSqlEval
{
	enum DATATYPE{IntergerType, StringType};
public:
	BOOL Evaluate(CSqlEvalee*);
	CSqlEvalExp(
		SQL_LEVEL_1_RPN_EXPRESSION*,
		int* );
	~CSqlEvalExp();
protected:
	virtual void GenerateQueryEnum(CQueryEnumerator&);
	BSTR m_BstrName;
	VARIANT m_v;
	int m_op;
	DWORD m_dw;
	BSTR m_bstr;
	int m_DataType;
};


class CQueryEnumerator
{
	friend CSqlEvalExp;
	friend CSqlEvalAnd;
	friend CSqlEvalOr;
	friend CSqlEvalNot;
	enum{INITIAL_SIZE = 10};
	class CStringArray
	{
	protected:
		WCHAR** m_ppWstr;
		int m_cNumString;
		BOOL m_bIsNull;
		BOOL	StringArrayCopy(
			WCHAR***,
			WCHAR**,
			int cArgs);

	public:
		CStringArray();
		~CStringArray();
		CStringArray(CStringArray&);
		CStringArray(
			WCHAR**,
			int cNumString);
		CStringArray& operator=(CStringArray&);
		int Size();
		BOOL IsNULL(){return m_bIsNull;};
		void Merge(CStringArray&);
		const WCHAR** Data();

	};
protected:
	void ArrayMerge(
		CStringArray&);
	void ArrayDelete();
	void ArrayAdd(CStringArray&);
	CStringArray	m_QueryFields;
	CStringArray*	m_QuerySet;
	int			m_cNumOfRecordInSet;
	int			m_index;
	int		m_MaxSize;


public:
	CQueryEnumerator(
		WCHAR**,	//array of string identifying the name fields to
					//be queried
		int cArg	// number of argument
		);
	CQueryEnumerator(CQueryEnumerator&);
	
	void And(CQueryEnumerator&);
	void Or(CQueryEnumerator&);
	virtual ~CQueryEnumerator();
//	DWORD InitEnumerator(
//		WCHAR**,	//array of string identifying the name fields to
//					//be queried
//		int cArg,	// number of argument
//		CSqlEval*);
	const WCHAR** GetNext(int&);
	void Reset(void);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\inc\sql_1.h ===
//***************************************************************************
//
//  SQL_1.H
//
//  Level 1 Syntax SQL Parser
//
//  Copyright 1999 Microsoft Corporation
//
//
//=================================================================


#ifndef _SQL_1_H_
#define _SQL_1_H_

#include <wbemprov.h>


struct SQL_LEVEL_1_TOKEN
{
    enum { OP_EXPRESSION = 1, TOKEN_AND, TOKEN_OR, TOKEN_NOT };
    enum { IFUNC_NONE = 0, IFUNC_UPPER = 1, IFUNC_LOWER = 2 };

    int nTokenType; //  OP_EXPRESSION,TOKEN_AND, TOKEN_OR, TOKEN_NOT
    

    // If the field is a OP_EXPRESSION, then the following are used.
    enum { OP_EQUAL = 1, OP_NOT_EQUAL, OP_EQUALorGREATERTHAN,
		       OP_EQUALorLESSTHAN, OP_LESSTHAN, OP_GREATERTHAN, OP_LIKE };
    
    BSTR    pPropertyName;		// Name of the property on which the operator is applied
    int     nOperator;			// Operator that is applied on property
    BOOL	bConstIsStrNumeric;	// True if the vConstValue is a BSTR and is a UINT32 or any 64bit number
	VARIANT vConstValue;		// Value applied by operator
    BSTR    pPropName2;         // Property compared to.

    DWORD   dwPropertyFunction; // 0=no instrinsic function applied
    DWORD   dwConstFunction;    // "
    
    SQL_LEVEL_1_TOKEN();
    SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN&);
   ~SQL_LEVEL_1_TOKEN(); 
    SQL_LEVEL_1_TOKEN& operator=(SQL_LEVEL_1_TOKEN &Src);
    
    void Dump(FILE *);
};


// Contains RPN version of expression.
// ===================================

struct SQL_LEVEL_1_RPN_EXPRESSION
{
    int nNumTokens;
    int nCurSize;
    SQL_LEVEL_1_TOKEN *pArrayOfTokens;
    BSTR bsClassName;

	int nNumberOfProperties;          // Zero means all properties selected
    int nCurPropSize;
	BSTR *pbsRequestedPropertyNames;  // Array of property names which values are to be returned if
    
    SQL_LEVEL_1_RPN_EXPRESSION();
   ~SQL_LEVEL_1_RPN_EXPRESSION();
   
   //Note: this method deletes the token it is passed as an argument
    void AddToken(SQL_LEVEL_1_TOKEN *pTok);
    void AddToken(SQL_LEVEL_1_TOKEN &pTok);
    void AddProperty(LPWSTR pProp);
    void Dump(const char *pszTextFile);
};


class SQL1_Parser
{
    CGenLexer *m_pLexer;
    int        m_nLine;
    wchar_t*   m_pTokenText;
    int        m_nCurrentToken;
    SQL_LEVEL_1_RPN_EXPRESSION* m_pExpression;

	//Cleanup used by d'tor and SetSource
	void Cleanup();

	//Init used by c'tor and SetSource
	void Init(CGenLexSource *pSrc);

    // Semantic transfer variables.
    // ============================
    VARIANT    m_vTypedConst;
    int        m_nRelOp;
    DWORD      m_dwConstFunction;
    DWORD      m_dwPropFunction;
    LPWSTR     m_pIdent;
    LPWSTR     m_pPropComp;
	BOOL       m_bConstIsStrNumeric;
        
    // Parsing functions.
    // ==================
    BOOL Next();
    
    int parse();

    int prop_list();
    int class_name();
    int opt_where();
    int expr();
    int property_name();
    int prop_list_2();
    int term();
    int expr2();
    int simple_expr();
    int term2();
    int leading_ident_expr();
    int finalize();
    int rel_operator();
    int equiv_operator();
    int comp_operator();
    int is_operator();
    int trailing_prop_expr();
    int trailing_prop_expr2();
    int trailing_or_null();
    int trailing_const_expr();
    int unknown_func_expr();
    int typed_constant();

public:
    enum { 
        SUCCESS,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL
        };

    SQL1_Parser(CGenLexSource *pSrc);
   ~SQL1_Parser();

    int GetQueryClass(LPWSTR pBuf, int nBufSize);
       
    int Parse(SQL_LEVEL_1_RPN_EXPRESSION **pOutput);
        // use operator delete on pOutput
            
    int CurrentLine() { return m_nLine; }
    LPWSTR CurrentToken() { return m_pTokenText; }
	void SetSource(CGenLexSource *pSrc);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\ntrkcomm\opathlex.cpp ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

  OPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\ntrkcomm\ntrkcomm.cpp ===
#include <objbase.h>
#include <ntrkcomm.h>


//
//  Most of the functions in this module need to call CoImpersonateClient.
//  This macro wraps the call and a check on the return code.

#define DNS_IMPERSONATE_CLIENT();               \
{                                               \
    HRESULT scimpcli = CoImpersonateClient();   \
    if ( FAILED( scimpcli ) )                   \
    {                                           \
        throw scimpcli;                         \
    }                                           \
}

CWbemServices::CWbemServices(
	IWbemServices* pNamespace)
	:m_pWbemServices(NULL)
{
	m_pWbemServices = pNamespace;
	if(m_pWbemServices != NULL)
		m_pWbemServices->AddRef();
}

CWbemServices::~CWbemServices()
{
	if(m_pWbemServices != NULL)
		m_pWbemServices->Release();
}

HRESULT
CWbemServices::CreateClassEnum(
	/* [in] */ BSTR Superclass,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext __RPC_FAR *pCtx,
	/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
	) 
{
	SCODE sc = m_pWbemServices->CreateClassEnum(
		Superclass,
		lFlags,
		pCtx,
		ppEnum);
	DNS_IMPERSONATE_CLIENT();	
	return sc;
}

HRESULT
CWbemServices::CreateInstanceEnum(
	/* [in] */ BSTR Class,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext __RPC_FAR *pCtx,
	/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
	HRESULT hr = m_pWbemServices->CreateInstanceEnum(
		Class,
		lFlags,
		pCtx,
		ppEnum);
	DNS_IMPERSONATE_CLIENT();	
	return hr;
}

HRESULT
CWbemServices::DeleteClass(
	/* [in] */ BSTR Class,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext __RPC_FAR *pCtx,
	/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	HRESULT hr = m_pWbemServices->DeleteClass(
		Class,
		lFlags,
		pCtx,
		ppCallResult);
	DNS_IMPERSONATE_CLIENT();	
	return hr;
}

HRESULT
CWbemServices::DeleteInstance(
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	HRESULT hr = m_pWbemServices->DeleteInstance(
		ObjectPath,
		lFlags,
		pCtx,
		ppCallResult);
	DNS_IMPERSONATE_CLIENT();	
	return hr;
}



HRESULT
CWbemServices::ExecMethod(
	BSTR strObjectPath, 
	BSTR MethodName, 
	long lFlags, 
	IWbemContext* pCtx,
    IWbemClassObject* pInParams,
	IWbemClassObject** ppOurParams, 
	IWbemCallResult** ppCallResult) 
{
	HRESULT hr = m_pWbemServices->ExecMethod(
		strObjectPath, 
		MethodName, 
		lFlags, 
		pCtx,
		pInParams,
		ppOurParams, 
		ppCallResult) ;
	DNS_IMPERSONATE_CLIENT();	
	return hr;	
}

HRESULT
CWbemServices::ExecNotificationQuery(
    /* [in] */ BSTR QueryLanguage,
    /* [in] */ BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
	HRESULT hr = m_pWbemServices->ExecNotificationQuery(
		QueryLanguage,
		Query,
		lFlags,
		pCtx,
		ppEnum);
	DNS_IMPERSONATE_CLIENT();	
	return hr;
}

HRESULT
CWbemServices::ExecQuery(
	/* [in] */ BSTR QueryLanguage,
	/* [in] */ BSTR Query,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext __RPC_FAR *pCtx,
	/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
	HRESULT hr = m_pWbemServices->ExecQuery(
		QueryLanguage,
		Query,
		lFlags,
		pCtx,
		ppEnum);
	DNS_IMPERSONATE_CLIENT();	
	return hr;
}

HRESULT
CWbemServices::GetObject(
	/* [in] */ BSTR ObjectPath,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext __RPC_FAR *pCtx,
	/* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
	/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	HRESULT hr = m_pWbemServices->GetObject(
		ObjectPath,
		lFlags,
		pCtx,
		ppObject,
		ppCallResult);
	DNS_IMPERSONATE_CLIENT();	
	return hr;

}
 
HRESULT
CWbemServices::PutClass(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	HRESULT hr = m_pWbemServices->PutClass(
		pObject,
		lFlags,
		pCtx,
		ppCallResult);
	DNS_IMPERSONATE_CLIENT();	
	return hr;

}

HRESULT
CWbemServices::PutInstance(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{	

	HRESULT hr = m_pWbemServices->PutInstance(
		pInst,
		lFlags,
		pCtx,
		ppCallResult);
	DNS_IMPERSONATE_CLIENT();	
	return hr;
}

/*CImpersonatedProvider
*  Purpose: provide a general solution for impersonate client for 
*  Wbem providers.
*  USAGE:
*  Inherit from this class, and implement abstact virtual functions.
*  child class should implement function prefixed with "Do".
* ******************************************/
CImpersonatedProvider::CImpersonatedProvider(
	BSTR ObjectPath,
	BSTR User, 
	BSTR Password, 
	IWbemContext * pCtx)
	:m_cRef(0), m_pNamespace(NULL)
{

}
CImpersonatedProvider::~CImpersonatedProvider()
{
	if(m_pNamespace)
		delete m_pNamespace;
}

STDMETHODIMP_(ULONG) 
CImpersonatedProvider::AddRef(void)
{
    return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) 
CImpersonatedProvider::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}
STDMETHODIMP 
CImpersonatedProvider::QueryInterface(
	REFIID riid, 
	PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}

STDMETHODIMP 
CImpersonatedProvider::Initialize(
	LPWSTR pszUser, LONG lFlags,
    LPWSTR pszNamespace, LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	LONG lStatus = WBEM_S_INITIALIZED;
	m_pNamespace = new CWbemServices(pNamespace); 
	if(m_pNamespace == NULL)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
		lStatus = WBEM_E_FAILED;
	}
		
    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(lStatus,0);
    return hr;
}



HRESULT
CImpersonatedProvider::CreateInstanceEnumAsync(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	DNS_IMPERSONATE_CLIENT();
	return DoCreateInstanceEnumAsync(
		Class,
		lFlags,
		pCtx,
		pResponseHandler);
}

HRESULT
CImpersonatedProvider::DeleteInstanceAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	DNS_IMPERSONATE_CLIENT();
	return DoDeleteInstanceAsync(
		ObjectPath,
		lFlags,
		pCtx,
		pResponseHandler);
}


HRESULT
CImpersonatedProvider::ExecMethodAsync(
	const BSTR strObjectPath,
	const BSTR MethodName, 
	long lFlags, 
	IWbemContext* pCtx,
    IWbemClassObject* pInParams,
	IWbemObjectSink* pResponseHandler)
{
	DNS_IMPERSONATE_CLIENT();
	return DoExecMethodAsync(
		strObjectPath,
		MethodName,
		lFlags,
		pCtx,
		pInParams,
		pResponseHandler);
	
}


HRESULT
CImpersonatedProvider::ExecQueryAsync(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	DNS_IMPERSONATE_CLIENT();
	return DoExecQueryAsync(
		QueryLanguage,
		Query,
		lFlags,
		pCtx,
		pResponseHandler);
	
}

HRESULT
CImpersonatedProvider::GetObjectAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	DNS_IMPERSONATE_CLIENT();
	return DoGetObjectAsync(
		ObjectPath,
		lFlags,
		pCtx,
		pResponseHandler);
	
}


HRESULT
CImpersonatedProvider::PutInstanceAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	DNS_IMPERSONATE_CLIENT();
	return DoPutInstanceAsync(
		pInst,
		lFlags,
		pCtx,
		pResponseHandler);
	
}

// CWbemInstanceMgr

CWbemInstanceMgr::CWbemInstanceMgr(
	IWbemObjectSink* pHandler,
	DWORD dwSize)
	:m_pSink(NULL), m_ppInst(NULL), m_dwIndex(0)
{
	m_pSink = pHandler;
	if(m_pSink != NULL)
		m_pSink->AddRef();
	m_dwThreshHold = dwSize;
	m_ppInst = new IWbemClassObject*[dwSize];
	for(DWORD i = 0; i < dwSize; i++)
		m_ppInst[i] = NULL;
}
CWbemInstanceMgr::~CWbemInstanceMgr()
{
	if(m_ppInst != NULL)
	{
		if(m_dwIndex >0)
		{
			m_pSink->Indicate(
				m_dwIndex,
				m_ppInst);
		}

		for(DWORD i =0; i<m_dwIndex; i++)
		{
			if(m_ppInst[i] != NULL)
				(m_ppInst[i])->Release();
		}
		delete [] m_ppInst;
	}
	if(m_pSink != NULL)
		m_pSink->Release();

}

void
CWbemInstanceMgr::Indicate(IWbemClassObject* pInst)
{
	if(pInst == NULL)
		throw WBEM_E_INVALID_PARAMETER;

	m_ppInst[m_dwIndex++] = pInst;
	pInst->AddRef();
	if(m_dwIndex == m_dwThreshHold)
	{

		SCODE  sc = m_pSink->Indicate(
			m_dwIndex,
			m_ppInst);
		if(sc != S_OK)
			throw sc;
		
		// reset state
		for(DWORD i=0; i< m_dwThreshHold; i++)
		{
			if(m_ppInst[i] != NULL)
				(m_ppInst[i])->Release();
			m_ppInst[i] = NULL;
		}
		m_dwIndex = 0;
	
	}
	return;
}

void
CWbemInstanceMgr::SetStatus(
	LONG lFlags,
	HRESULT hr,
	BSTR strParam,
	IWbemClassObject* pObjParam)
{
	m_pSink->SetStatus(
		lFlags,
		hr,
		strParam,
		pObjParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\ntrkcomm\sqleval.cpp ===
#include "sqleval.h"
#include <stdio.h>
#include <genlex.h>
#include <sqllex.h>
#include <sql_1.h>

// CSqlWmiEvalee
CSqlWmiEvalee::~CSqlWmiEvalee()
{
	if(m_pInstance)
		m_pInstance->Release();
}


CSqlWmiEvalee::CSqlWmiEvalee(
	IWbemClassObject* pInst)
	:m_pInstance(NULL)
{
	m_pInstance = pInst;
	if(m_pInstance)
		m_pInstance->AddRef();
	VariantInit(&m_v);
}

const VARIANT*
CSqlWmiEvalee::Get(
	WCHAR* wszName)
{
	VariantClear(&m_v);
	BSTR bstr = SysAllocString(wszName);
	if (bstr != NULL)
	{
		SCODE sc = m_pInstance->Get(
			bstr, 
			0, 
			&m_v,
			NULL,
			NULL);
		SysFreeString(bstr);
		if(sc != S_OK)
				throw sc;
	}
	
	return &m_v;
}
// CSqlEval

CSqlEval*
CSqlEval::CreateClass(
	SQL_LEVEL_1_RPN_EXPRESSION* pExpr,
	int* pNumberOfToken)
{
	if(pExpr== NULL || *pNumberOfToken<= 0)
		return NULL;
	SQL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens+(*pNumberOfToken-1);
	
//	(*pNumberOfToken)--;
	switch(pToken->nTokenType)
	{
	case SQL_LEVEL_1_TOKEN::TOKEN_AND:
		return new CSqlEvalAnd(
			pExpr,
			pNumberOfToken);
	case SQL_LEVEL_1_TOKEN::TOKEN_OR:
		return new CSqlEvalOr(
			pExpr,
			pNumberOfToken);
	case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
		return new CSqlEvalExp(
			pExpr,
			pNumberOfToken);
	}
	return NULL;
}

BOOL
CSqlEval::Evaluate(
	CSqlEvalee* pInst)
{
	return TRUE;
}

// CSqlEvalAnd
CSqlEvalAnd::~CSqlEvalAnd()
{
	delete m_left;
	delete m_right;
}

CSqlEvalAnd::CSqlEvalAnd(
	SQL_LEVEL_1_RPN_EXPRESSION* pExpr,
	int* pTokens)
:m_left(NULL),m_right(NULL)
{
	(*pTokens)-- ;
	m_left = CSqlEval::CreateClass(
		pExpr,
		pTokens);
	m_right = CSqlEval::CreateClass(
		pExpr,
		pTokens);
	
}

BOOL
CSqlEvalAnd::Evaluate(
	CSqlEvalee* pInst)
{
	return m_left->Evaluate(pInst) && m_right->Evaluate(pInst);
}

void
CSqlEvalAnd::GenerateQueryEnum(CQueryEnumerator& qeInst)
{
	CQueryEnumerator qeNew = qeInst;
	m_left->GenerateQueryEnum(qeNew);

	m_right->GenerateQueryEnum(qeInst);
	qeInst.And(qeNew);

}


// CSqlEvalOR
CSqlEvalOr::~CSqlEvalOr()
{
	delete m_left;
	delete m_right;
}

CSqlEvalOr::CSqlEvalOr(
	SQL_LEVEL_1_RPN_EXPRESSION* pExpr,
	int* pTokens)
:m_left(NULL),m_right(NULL)
{
	(*pTokens)-- ;
	m_left = CSqlEval::CreateClass(
		pExpr,
		pTokens);
	m_right = CSqlEval::CreateClass(
		pExpr,
		pTokens);
	
}

BOOL
CSqlEvalOr::Evaluate(
	CSqlEvalee* pInst)
{
	return m_left->Evaluate(pInst) || m_right->Evaluate(pInst);
}

void
CSqlEvalOr::GenerateQueryEnum(CQueryEnumerator& qeInst)
{
	CQueryEnumerator qeNew = qeInst;
	m_left->GenerateQueryEnum(qeNew);

	m_right->GenerateQueryEnum(qeInst);
	qeInst.Or(qeNew);

}





// CSqlEvalExp
CSqlEvalExp::~CSqlEvalExp()
{
	SysFreeString(m_BstrName);
	VariantClear(&m_v);
}

CSqlEvalExp::CSqlEvalExp(
	SQL_LEVEL_1_RPN_EXPRESSION* pExpr,
	int* pTokens)
:m_BstrName(NULL) 
{
	VariantInit(&m_v);
	SQL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens+(*pTokens-1);
	(*pTokens)--;
	m_BstrName = SysAllocString(pToken->pPropertyName);
	VariantCopy(&m_v, &(pToken->vConstValue));
	m_op = pToken->nOperator;
	switch(m_v.vt)
	{
	case VT_I2:
		m_dw =  m_v.iVal;
		m_DataType = IntergerType;
		break;
	case VT_I4:
		m_dw = m_v.lVal;
		m_DataType = IntergerType;
		break;
	case VT_BOOL:
		m_DataType = IntergerType;
		m_dw = m_v.boolVal;
		break;
	case VT_BSTR:
		m_DataType = StringType;
		m_bstr = m_v.bstrVal;
		break;
	default:
		throw WBEM_E_INVALID_PARAMETER;
	}
}

BOOL
CSqlEvalExp::Evaluate(
	CSqlEvalee* pInst)
{

	BOOL Result=FALSE;
	const VARIANT* pv = pInst->Get(m_BstrName);
	
	switch(m_DataType)
	{
	case IntergerType:
		DWORD dw;
		switch(pv->vt)
		{
		case VT_I2:
			dw =  pv->iVal;
			break;
		case VT_I4:
			dw = pv->lVal;
			break;
		case VT_BOOL:
			dw = pv->boolVal;
			break;
		}

		// compare
		switch(m_op)
		{
		case SQL_LEVEL_1_TOKEN::OP_EQUAL:
			Result = (dw == m_dw);
			break;
		case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
			Result = !(dw == m_dw);
			break;
		case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
			Result = (dw >= m_dw);
			break;
		case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
			Result = (dw <= m_dw);
			break;
		case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
			Result = (dw < m_dw);
			break;
		case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
			Result = (dw > m_dw);
			break;
		}
		break;
	case StringType:
		int rt = _wcsicmp(pv->bstrVal, m_bstr);
		switch(m_op)
		{
		case SQL_LEVEL_1_TOKEN::OP_EQUAL:
			Result = (rt == 0);
			break;
		case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
			Result = !(rt == 0);
			break;
		case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
			Result = (rt > 0 || rt == 0);
			break;
		case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
			Result = (rt < 0 || rt == 0);
			break;
		case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
			Result = (rt < 0);
			break;
		case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
			Result = (rt > 0 );
			break;
		}
		break;
	}

	return Result;
}

void
CSqlEvalExp::GenerateQueryEnum(CQueryEnumerator& qeInst)
{
	int nSize = qeInst.m_QueryFields.Size();
	const WCHAR** ppName = qeInst.m_QueryFields.Data();
	WCHAR** ppWstr = new WCHAR*[nSize];
    if ( ppWstr )
    {
	    for(int i=0;  i< nSize; i++)
	    {
		    if(_wcsicmp( m_BstrName, ppName[i]) == 0)
		    {
			    ppWstr[i] = m_v.bstrVal;
		    }
		    else
			    ppWstr[i] = NULL;
	    }
	    CQueryEnumerator::CStringArray strArray(
		    ppWstr,
		    nSize);
	    delete [] ppWstr;
	    qeInst.ArrayAdd(strArray);
    }
}


//CQueryEnumerator;
CQueryEnumerator::CQueryEnumerator(
	WCHAR** ppKeyName,
	int cArg  ):
	m_index(0),m_cNumOfRecordInSet(0),
	m_QuerySet(NULL), m_MaxSize(INITIAL_SIZE)
{
	m_QueryFields = CStringArray(
	ppKeyName,
	cArg);

}


CQueryEnumerator::CQueryEnumerator(
	CQueryEnumerator& instEnumerator)								  
	:m_index(0), m_MaxSize(INITIAL_SIZE),
	m_QuerySet(NULL), m_cNumOfRecordInSet(0)
{

	m_QueryFields = instEnumerator.m_QueryFields;
	int nSize = instEnumerator.m_cNumOfRecordInSet;
	for(int i=0; i< nSize; i++)
	{
		ArrayAdd(instEnumerator.m_QuerySet[i]);
	}
			
}


CQueryEnumerator::~CQueryEnumerator()
{	

}

/*
DWORD
CQueryEnumerator::InitEnumerator(
	WCHAR** wszFieldNames,
	int cArg,
	CSqlEval* pEval)
{
	m_QueryFields = CStringArray(
		wszFieldNames,
		cArg);
	

	return S_OK;
}
*/
const
WCHAR**
CQueryEnumerator::GetNext(int& cElement)
{
	if(m_index == m_cNumOfRecordInSet)
	{
		return NULL;
	}
	else
	{
		cElement = m_QuerySet[m_index].Size();
		return m_QuerySet[m_index++].Data();
	}
}


void
CQueryEnumerator::ArrayMerge(
	CQueryEnumerator::CStringArray& strArray)
{
	
	for(int i=0; i< m_cNumOfRecordInSet; i++)
	{
		// if all element of strArray are null, no need to proceed
		if( !strArray.IsNULL())
			m_QuerySet[i].Merge(strArray);
	}
	
}


void
CQueryEnumerator::ArrayAdd(
	CQueryEnumerator::CStringArray& strArray)
{
	// if all elements are null for strArray, means no keys are 
	// selected,we should therefore replace M_querySet this StrArray
	if(strArray.IsNULL())
		ArrayDelete();

	if(m_QuerySet == NULL)
	{
		m_QuerySet = new CStringArray[m_MaxSize];
        if ( !m_QuerySet )
        {
            return;
        }
	}

	// if array is full, then expand
	if(m_index == m_MaxSize)
	{
		CStringArray * pOldSet = m_QuerySet;
		m_MaxSize = m_MaxSize *2;
		m_QuerySet = new CStringArray[m_MaxSize];
        if ( !m_QuerySet )
        {
            return;
        }
		for( int i =0; i < m_MaxSize; i++ )
		{
			if( i < m_index )
			{
				m_QuerySet[ i ] = pOldSet[ i ];
			}
		}
        delete [] pOldSet;
	}

	if(!( m_cNumOfRecordInSet> 0 && (m_QuerySet[0]).IsNULL()))
	{
		m_QuerySet[m_index++] = strArray;
		m_cNumOfRecordInSet = m_index;
	}
}


void
CQueryEnumerator::ArrayDelete()
{
	delete [] m_QuerySet;
	m_QuerySet = NULL;
	m_cNumOfRecordInSet = 0;
	m_MaxSize = INITIAL_SIZE;
	m_index = 0;
}

void
CQueryEnumerator::And(
	CQueryEnumerator& instEnumerator)
{
	int nSize = instEnumerator.m_cNumOfRecordInSet;
	if(nSize > 0)
	{
		CQueryEnumerator qeOld= *this;
		ArrayDelete();	
		for(int i=0; i< nSize; i++)
		{   
			CQueryEnumerator qeNew = qeOld;
            if ( !qeNew.m_QuerySet )
            {
                return;
            }
			qeNew.ArrayMerge(instEnumerator.m_QuerySet[i]);
			for(int j=0; j< qeNew.m_cNumOfRecordInSet; j++)
			{
				ArrayAdd(qeNew.m_QuerySet[j]);
			}
		}
	}	
}

void
CQueryEnumerator::Or(
	CQueryEnumerator& instEnumerator)
{
	for(int i=0; i< instEnumerator.m_cNumOfRecordInSet; i++)
	{

		if(instEnumerator.m_QuerySet[i].IsNULL())
		{
			if(m_cNumOfRecordInSet > 0)
				ArrayDelete();
			ArrayAdd(instEnumerator.m_QuerySet[i]);
		}
		else
		{
			ArrayAdd(instEnumerator.m_QuerySet[i]);
		}
	}
	
}
void
CQueryEnumerator::Reset()
{
	m_index = 0;
}
// CStringArray

CQueryEnumerator::CStringArray::CStringArray()
:m_ppWstr(NULL), m_cNumString(0), m_bIsNull(TRUE)
{
}

CQueryEnumerator::CStringArray::~CStringArray()
{
	if(m_ppWstr != NULL)
	{
		for (int i=0; i< m_cNumString; i++)
		{
			delete [] m_ppWstr[i];
		}
		delete [] m_ppWstr;
	}
}

CQueryEnumerator::CStringArray::CStringArray(
	WCHAR **ppWstrInput,
	int cNumString)
	:m_ppWstr(NULL)
{
	m_cNumString = cNumString;
	m_bIsNull = !StringArrayCopy(
		&m_ppWstr,
		ppWstrInput,
		cNumString);
	
}
CQueryEnumerator::CStringArray::CStringArray(
	CQueryEnumerator::CStringArray& strArray)
	:m_ppWstr(NULL)
{
	m_cNumString = strArray.m_cNumString;
	m_bIsNull = !StringArrayCopy(
		&m_ppWstr,
		strArray.m_ppWstr,
		strArray.m_cNumString);
}

CQueryEnumerator::CStringArray&
CQueryEnumerator::CStringArray::operator =(
	CQueryEnumerator::CStringArray& strArray)
{
	if(m_ppWstr != NULL)
	{
		for (int i=0; i< m_cNumString; i++)
		{
			delete [] *m_ppWstr;
			*m_ppWstr = NULL;
		}
		delete [] m_ppWstr;
		m_ppWstr = NULL;
	}

	m_cNumString = strArray.m_cNumString;
	m_bIsNull= !StringArrayCopy(
		&m_ppWstr,
		strArray.m_ppWstr,
		strArray.m_cNumString);
	return *this;
}

int CQueryEnumerator::CStringArray::Size()
{
	return m_cNumString;
}

const 
WCHAR**
CQueryEnumerator::CStringArray::Data()
{
	return (const WCHAR**) m_ppWstr;
}

// return true if any element is copied,
// false if no element is copied, and no element set to NULL

BOOL
CQueryEnumerator::CStringArray::StringArrayCopy(
	WCHAR*** pppDest,
	WCHAR** ppSrc,
	int cArgs)
{
	BOOL bFlag = FALSE;
	if(cArgs >0 && ppSrc != NULL)
	{
		*pppDest = new WCHAR*[cArgs];
        if ( *pppDest )
        {
		    for(int i=0; i< cArgs; i++)
		    {
			    (*pppDest)[i] = NULL;
			    if(ppSrc[i] != NULL)
			    {
				    int len = wcslen(ppSrc[i]);
				    (*pppDest)[i] = new WCHAR[len+1];
                    if ( (*pppDest)[i] == NULL )
                    {
    					throw WBEM_E_OUT_OF_MEMORY;
                    }
				    wcscpy((*pppDest)[i], ppSrc[i]);
				    bFlag = TRUE;
			    }
    		}
		}
	}
	return bFlag;
}

void
CQueryEnumerator::CStringArray::Merge(
	CQueryEnumerator::CStringArray& instStrArray)
{
	if(instStrArray.Size() != m_cNumString)
		throw WBEM_E_FAILED;
	const WCHAR** ppSrc = instStrArray.Data();
	for(int i=0; i<m_cNumString; i++)
	{
		// if source is null, we leave target string as it was
		if( ppSrc[i] != NULL)
		{
			if(m_ppWstr[i] == NULL)
			{
				m_ppWstr[i] = new WCHAR[wcslen(ppSrc[i])+1];
                if ( m_ppWstr[i] == NULL )
                {
    				throw WBEM_E_OUT_OF_MEMORY;
                }
				wcscpy(m_ppWstr[i], ppSrc[i]);
			}
			else
			{
				// a key can not take two different value
				if(_wcsicmp(m_ppWstr[i], ppSrc[i]) != 0)
					throw WBEM_E_INVALID_PARAMETER;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\ntrkcomm\genlex.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    m_pTokenBuf = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                    if (m_pTokenBuf == 0)
                        return 0; // out of memory
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\ntrkcomm\sqllex.cpp ===
//***************************************************************************
//
//  SQLLEX.CPP
//
//  SQL Level 1 DFA Table
//
//  24-Jun-95       Created.
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <sqllex.h>             

#define ST_STRING   22
#define ST_IDENT    27
#define ST_GE       32
#define ST_LE       34
#define ST_NE       37
#define ST_NUMERIC  39
#define ST_REAL     42
#define ST_STRING2  48
#define ST_STRING_ESC 53
#define ST_STRING2_ESC 54

// DFA State Table for SQL Level 1 lexical symbols.
// ================================================

LexEl Sql_1_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

/* 3 */  L'(',   GLEX_EMPTY, 0,          SQL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 4 */  L')',   GLEX_EMPTY, 0,  SQL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 5 */  L'.',   GLEX_EMPTY, 0,  SQL_1_TOK_DOT,         GLEX_ACCEPT,
/* 6 */  L'*',   GLEX_EMPTY, 0,  SQL_1_TOK_ASTERISK,    GLEX_ACCEPT,
/* 7 */  L'=',   GLEX_EMPTY, 0,  SQL_1_TOK_EQ,          GLEX_ACCEPT,

/* 8 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 9 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 10 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 11 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 12 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 13 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 14 */ L'-',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 15 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 19 */ 0,      GLEX_EMPTY, 0,  SQL_1_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  SQL_1_TOK_COMMA, GLEX_ACCEPT,

    // Unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        SQL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 22 */   L'\n', GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 23 */   L'\r', GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 24 */   L'"',  GLEX_EMPTY, 0,  SQL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 25 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 26 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 27 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 28 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 29 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 30 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY,  0,       SQL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 32 */  L'=',   GLEX_EMPTY,  0,  SQL_1_TOK_GE,  GLEX_ACCEPT,
/* 33 */  GLEX_ANY, GLEX_EMPTY,  0,       SQL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 34 */  L'=',   GLEX_EMPTY,      0,  SQL_1_TOK_LE,  GLEX_ACCEPT,
/* 35 */  L'>',   GLEX_EMPTY,      0,  SQL_1_TOK_NE,  GLEX_ACCEPT,
/* 36 */  GLEX_ANY, GLEX_EMPTY,    0,  SQL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 37 */  L'=',   GLEX_EMPTY,      0,  SQL_1_TOK_NE,     GLEX_ACCEPT,
/* 38 */  GLEX_ANY,  GLEX_EMPTY,   0,  SQL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 39 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 40 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 41 */  GLEX_ANY, GLEX_EMPTY, 0,          SQL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 42 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 43 */  L'E',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 44 */  L'e',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 45 */  L'+',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 46 */  L'-',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 47 */  GLEX_ANY,       GLEX_EMPTY,   0,     SQL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 48 */   L'\n',  GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 49 */   L'\r',  GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 50 */   L'\'',  GLEX_EMPTY, 0,  SQL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 51 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 52 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 53 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

// ST_STRING2_ESC
/* 54 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifndef _MFC_VER
#define _MFC_VER 0x0600
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// Tab Control styles
#ifndef TCS_MULTILINE // new in later versions of Win32
#define TCS_MULTILINE       0x0200
#endif

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#if _MFC_VER >= 0x0600
#define CBRS_GRIPPER        0x00400000L
#endif

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#if _MFC_VER >= 0x0600
#define CBRS_ALL            0x0040FFFFL
#else
#define CBRS_ALL            0xFFFFL
#endif

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#if _MFC_VER >= 0x0600
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar
#endif

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#if _MFC_VER >= 0x0600
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
#endif
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#if _MFC_VER >= 0x0600
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#endif
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

#if _MFC_VER >= 0x0600
// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D
#endif

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dconvert.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dconvert.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client Library

    RPC record conversion routines.
    Convert DNS_RECORD records into RPC buffer.

Author:

    Jing Chen (t-jingc)     June, 1998
    reverse functions of rconvert.c

Revision History:

--*/


#include "dnsclip.h"


//
//  size of string in RPC format
//
//  JBUGBUG:  may have to do (-1) for terminating NULL
//

#define STRING_UTF8_BUF_SIZE( string, fUnicode ) \
        Dns_GetBufferLengthForStringCopy( \
            (string),   \
            0,          \
            ((fUnicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )
#if 0
    // with comments
        Dns_GetBufferLengthForStringCopy( \
            (string),   \           // string
            0,          \           // unknown length
            ((fUnicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \  // in string
            DnsCharSetUtf8 )        // RPC string always UTF8
#endif

//
//  Writing strings to RPC buffer format
//

#define WRITE_STRING_TO_RPC_BUF(buf, psz, len, funicode) \
        Dns_StringCopy(     \
            (buf),          \
            NULL,           \
            (psz),          \
            (len),          \
            ((funicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )
#if 0
    // with commments
        Dns_StringCopy(     \
            (buf),          \   // buffer
            NULL,           \   // adequate buffer length
            (psz),          \   // string
            (len),          \   // string length (if known)
            ((funicode) ? DnsCharSetUnicode : DnsCharSet), \  // input format
            DnsCharSetUtf8 )    // RPC buffer always in UTF8
#endif


//
//  size of name in RPC format
//
//  JBUGBUG:  may have to do (-1) for terminating NULL
//

#define NAME_UTF8_BUF_SIZE( string, fUnicode ) \
        Dns_GetBufferLengthForStringCopy( \
            (string),   \
            0,          \
            ((fUnicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )
#if 0
    // with comments
        Dns_GetBufferLengthForStringCopy( \
            (string),   \           // string
            0,          \           // unknown length
            ((fUnicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \  // in string
            DnsCharSetUtf8 )        // RPC string always UTF8
#endif


//
//  Writing names to RPC buffer format
//

#define WRITE_NAME_TO_RPC_BUF(buf, psz, len, funicode) \
        Dns_StringCopy(     \
            (buf),          \
            NULL,           \
            (psz),          \
            (len),          \
            ((funicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )
#if 0
    // with commments
        Dns_StringCopy(     \
            (buf),          \   // buffer
            NULL,           \   // adequate buffer length
            (psz),          \   // string
            (len),          \   // string length (if known)
            ((funicode) ? DnsCharSetUnicode : DnsCharSet), \  // input format
            DnsCharSetUtf8 )    // RPC buffer always in UTF8
#endif


//
//  Private protos
//

PDNS_RPC_RECORD
Rpc_AllocateRecord(
    IN      DWORD           BufferLength
    );



//
//  RPC buffer conversion functions
//

PDNS_RPC_RECORD
ADnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert A record from DNS Record to RPC buffer.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;

    DNS_ASSERT( pRR->wDataLength == sizeof(IP_ADDRESS) );

    prpcRR = Rpc_AllocateRecord( sizeof(IP_ADDRESS) );
    if ( !prpcRR )
    {
        return( NULL );
    }
    prpcRR->Data.A.ipAddress = pRR->Data.A.IpAddress;

    return( prpcRR);
}



PDNS_RPC_RECORD
PtrDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Process PTR compatible record from wire.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  PTR data is another domain name
    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE(pRR->Data.PTR.pNameHost, funicode);

    prpcRR = Rpc_AllocateRecord( sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  write hostname into buffer, immediately following PTR data struct
    //

    prpcRR->Data.PTR.nameNode.cchNameLength = (UCHAR)length;

    WRITE_NAME_TO_RPC_BUF(
        prpcRR->Data.PTR.nameNode.achName,      // buffer
        pRR->Data.PTR.pNameHost,
        0,
        funicode );

    return( prpcRR );
}



PDNS_RPC_RECORD
SoaDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert SOA record from DNS Record to RPC buffer.

Arguments:

    pRR - ptr to record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD     prpcRR;
    DWORD               length1;
    DWORD               length2;
    PDNS_RPC_NAME       pnamePrimary;
    PDNS_RPC_NAME       pnameAdmin;
    BOOL                funicode = IS_UNICODE_RECORD( pRR );


    //
    //  determine required buffer length and allocate
    //

    length1 = NAME_UTF8_BUF_SIZE( pRR->Data.SOA.pNamePrimaryServer, funicode );

    length2 = NAME_UTF8_BUF_SIZE( pRR->Data.SOA.pNameAdministrator, funicode );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_SOA_FIXED_DATA + sizeof(DNS_RPC_NAME) * 2 +
                    length1 + length2 );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  copy fixed fields
    //

    RtlCopyMemory(
        (PCHAR) & prpcRR->Data.SOA.dwSerialNo,
        (PCHAR) & pRR->Data.SOA.dwSerialNo,
        SIZEOF_SOA_FIXED_DATA );

    //
    //  copy names into RR buffer
    //      - primary server immediately follows SOA data struct
    //      - responsible party follows primary server
    //

    pnamePrimary = &prpcRR->Data.SOA.namePrimaryServer;
    pnamePrimary->cchNameLength = (UCHAR) length1;

    pnameAdmin = DNS_GET_NEXT_NAME( pnamePrimary );
    pnameAdmin->cchNameLength = (UCHAR) length2;

    WRITE_NAME_TO_RPC_BUF(
        pnamePrimary->achName,
        pRR->Data.Soa.pNamePrimaryServer,
        0,
        funicode );

    WRITE_NAME_TO_RPC_BUF(
        pnameAdmin->achName,
        pRR->Data.Soa.pNameAdministrator,
        0,
        funicode );

    return( prpcRR );
}



PDNS_RPC_RECORD
TxtDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Read TXT compatible record from wire.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           bufLength;
    DWORD           length;
    INT             count;
    PCHAR           pch;
    PCHAR *         ppstring;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //      - allocate space for each string
    //      - and ptr for each string
    //

    bufLength = 0;
    count = pRR->Data.TXT.dwStringCount;
    ppstring = pRR->Data.TXT.pStringArray;

    while ( count-- )
    {
        length = STRING_UTF8_BUF_SIZE( *ppstring++, funicode );
        bufLength += sizeof(DNS_RPC_NAME) + length;
    }

    //  allocate

    prpcRR = Rpc_AllocateRecord( bufLength );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  go back through list copying strings to buffer
    //      - ptrs to strings are saved to argv like data section
    //          ppstring walks through this section
    //      - first string written immediately following data section
    //      - each subsequent string immediately follows predecessor
    //          pchbuffer keeps ptr to position to write strings
    //
    //  JBUGBUG:  a mess
    //

    pch = (PCHAR) &prpcRR->Data.TXT;
    ppstring = pRR->Data.TXT.pStringArray;
    count =  pRR->Data.TXT.dwStringCount;

    while ( count-- )
    {
        length = STRING_UTF8_BUF_SIZE( *ppstring, funicode );
        (UCHAR) *pch++ += (UCHAR) length;    //+1 for TXT type only

        length = WRITE_STRING_TO_RPC_BUF(
                    pch,
                    *ppstring++,
                    0,
                    funicode
                    );
        pch += length;
#if DBG
        DNS_PRINT((
            "Read text string %s\n",
            * (ppstring - 1)
            ));
#endif
    }

    return( prpcRR );
}



PDNS_RPC_RECORD
MinfoDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Read MINFO record from wire.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           length1;
    DWORD           length2;
    PDNS_RPC_NAME   prpcName1;
    PDNS_RPC_NAME   prpcName2;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //

    length1 = NAME_UTF8_BUF_SIZE( pRR->Data.MINFO.pNameMailbox, funicode );
    length2 = NAME_UTF8_BUF_SIZE( pRR->Data.MINFO.pNameErrorsMailbox, funicode );

    prpcRR = Rpc_AllocateRecord( sizeof(DNS_RPC_NAME) * 2 + length1 + length2 );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  copy names into RR buffer
    //      - mailbox immediately follows MINFO data struct
    //      - errors mailbox immediately follows primary server
    //

    prpcName1 = &prpcRR->Data.MINFO.nameMailBox;
    prpcName1->cchNameLength = (UCHAR) length1;

    prpcName2 = DNS_GET_NEXT_NAME( prpcName1);
    prpcName2->cchNameLength = (UCHAR) length2;

    WRITE_NAME_TO_RPC_BUF(
        prpcName1->achName,
        pRR->Data.MINFO.pNameMailbox,
        0,
        funicode );

    WRITE_NAME_TO_RPC_BUF(
        prpcName2->achName,
        pRR->Data.MINFO.pNameErrorsMailbox,
        0,
        funicode );

    return( prpcRR );
}



PDNS_RPC_RECORD
MxDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    convert MX compatible record.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    PDNS_RPC_NAME   prpcName;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );


    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE( pRR->Data.MX.pNameExchange, funicode );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_MX_FIXED_DATA + sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  copy preference
    //

    prpcRR->Data.MX.wPreference = pRR->Data.MX.wPreference;

    //
    //  write hostname into buffer, immediately following MX struct
    //

    prpcName = &prpcRR->Data.MX.nameExchange;
    prpcName->cchNameLength = (UCHAR) length;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.MX.pNameExchange,
        0,
        funicode );

    return( prpcRR );
}



PDNS_RPC_RECORD
FlatDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert memory copy compatible record.
    Includes AAAA and WINS types.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           bufLength;

    //
    //  determine required buffer length and allocate
    //

    bufLength = pRR->wDataLength;

    prpcRR = Rpc_AllocateRecord( bufLength );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  copy packet data to record
    //

    RtlCopyMemory(
        & prpcRR->Data,
        & pRR->Data,
        bufLength );

    return( prpcRR );
}



PDNS_RPC_RECORD
SrvDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    convert SRV record.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    PDNS_RPC_NAME   prpcName;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE( pRR->Data.SRV.pNameTarget, funicode );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_SRV_FIXED_DATA + sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  copy SRV fixed fields
    //

    prpcRR->Data.SRV.wPriority = pRR->Data.SRV.wPriority;
    prpcRR->Data.SRV.wWeight   = pRR->Data.SRV.wWeight;
    prpcRR->Data.SRV.wPort     = pRR->Data.SRV.wPort;

    //
    //  write hostname into buffer, immediately following SRV struct
    //

    prpcName = &prpcRR->Data.SRV.nameTarget;
    prpcName->cchNameLength = (UCHAR) length;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.SRV.pNameTarget,
        0,
        funicode );

    return( prpcRR );
}



PDNS_RPC_RECORD
NbstatDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Read WINSR record from wire.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    PDNS_RPC_NAME   prpcName;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );


    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE( pRR->Data.WINSR.pNameResultDomain, funicode );

    prpcRR = Rpc_AllocateRecord(
                SIZEOF_NBSTAT_FIXED_DATA + sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return( NULL );
    }

    //
    //  copy WINSR fixed fields
    //

    prpcRR->Data.WINSR.dwMappingFlag   = pRR->Data.WINSR.dwMappingFlag;
    prpcRR->Data.WINSR.dwLookupTimeout = pRR->Data.WINSR.dwLookupTimeout;
    prpcRR->Data.WINSR.dwCacheTimeout  = pRR->Data.WINSR.dwCacheTimeout;

    //
    //  write hostname into buffer, immediately following WINSR struct
    //

    prpcName = &prpcRR->Data.WINSR.nameResultDomain;
    prpcName->cchNameLength = (UCHAR) length;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.WINSR.pNameResultDomain,
        0,
        funicode );

    return( prpcRR );
}



//
//  Jump table for DNS_RECORD => RPC buffer conversion.
//

typedef PDNS_RPC_RECORD (* RECORD_TO_RPC_CONVERT_FUNCTION)( PDNS_RECORD );

RECORD_TO_RPC_CONVERT_FUNCTION   RecordToRpcConvertTable[] =
{
    NULL,                       //  ZERO
    ADnsRecordConvert,          //  A
    PtrDnsRecordConvert,        //  NS
    PtrDnsRecordConvert,        //  MD
    PtrDnsRecordConvert,        //  MF
    PtrDnsRecordConvert,        //  CNAME
    SoaDnsRecordConvert,        //  SOA
    PtrDnsRecordConvert,        //  MB
    PtrDnsRecordConvert,        //  MG
    PtrDnsRecordConvert,        //  MR
    NULL,                       //  NULL
    FlatDnsRecordConvert,       //  WKS
    PtrDnsRecordConvert,        //  PTR
    TxtDnsRecordConvert,        //  HINFO
    MinfoDnsRecordConvert,      //  MINFO
    MxDnsRecordConvert,         //  MX
    TxtDnsRecordConvert,        //  TXT
    MinfoDnsRecordConvert,      //  RP
    MxDnsRecordConvert,         //  AFSDB
    TxtDnsRecordConvert,        //  X25
    TxtDnsRecordConvert,        //  ISDN
    MxDnsRecordConvert,         //  RT
    NULL,                       //  NSAP
    NULL,                       //  NSAPPTR
    NULL,                       //  SIG
    NULL,                       //  KEY
    NULL,                       //  PX
    NULL,                       //  GPOS
    FlatDnsRecordConvert,       //  AAAA
    NULL,                       //  29
    NULL,                       //  30
    NULL,                       //  31
    NULL,                       //  32
    SrvDnsRecordConvert,        //  SRV

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    NULL,                       //  DNS_TYPE_ATMA
    NULL,                       //  0x0023
    NULL,                       //  0x0024
    NULL,                       //  0x0025
    NULL,                       //  0x0026
    NULL,                       //  0x0027
    NULL,                       //  0x0028

    NULL,                       //  DNS_TYPE_TKEY
    NULL,                       //  DNS_TYPE_TSIG

    FlatDnsRecordConvert,       //  WINS
    NbstatDnsRecordConvert      //  WINS-R
};



PDNS_RPC_RECORD
Rpc_AllocateRecord(
    IN      DWORD           BufferLength
    )
/*++

Routine Description:

    Allocate RPC record structure.

Arguments:

    wBufferLength - desired buffer length (beyond structure header)

Return Value:

    Ptr to buffer.
    NULL on error.

--*/
{
    PDNS_RPC_RECORD prr;

    if ( BufferLength > MAXWORD )
    {
        return( NULL );
    }

    prr = ALLOCATE_HEAP( SIZEOF_DNS_RPC_RECORD_HEADER + BufferLength );
    if ( !prr )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( NULL );
    }

    // set datalength to buffer length

    prr->wDataLength = (WORD) BufferLength;

    return( prr );
}




PDNS_RPC_RECORD
DnsConvertRecordToRpcBuffer(
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Convert standard DNS record to RPC buffer.

Arguments:

    pRecord  -- DNS Record to be converted.

    //fUnicode -- flag, write records into unicode

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRecord;
    WORD            index;
    WORD            type;
    RECORD_TO_RPC_CONVERT_FUNCTION   pFunc;


    DNS_ASSERT( DNS_IS_DWORD_ALIGNED(pRecord) );
    IF_DNSDBG( RPC2 )
    {
        DNS_PRINT((
            "Enter DnsConvertRecordToRpcBuffer()\n"
            "\tpRecord   = %p\n",
            pRecord ));
    }

    //DNS_RRSET_INIT( rrset );

        //
        //  convert record
        //      set unicode flag if converting
        //

        //if ( fUnicode )
        //{
            //SET_RPC_UNICODE( pRecord );
        //}

        type = pRecord->wType;
        index = INDEX_FOR_TYPE( type );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !(pFunc = RecordToRpcConvertTable[ index ]) )
        {
            //  if unknown type try flat record copy -- best we can
            //  do to protect if server added new types since admin built

            DNS_PRINT((
                "ERROR:  no DNS_RECORD to RPC conversion routine for type %d.\n"
                "\tusing flat conversion routine.\n",
                type ));
            pFunc = FlatDnsRecordConvert;
        }

        prpcRecord = (*pFunc)( pRecord );
        if ( ! prpcRecord )
        {
            DNS_PRINT((
                "ERROR:  Record build routine failure for record type %d.\n"
                "\tstatus = %p\n\n",
                type,
                GetLastError() ));
            return(NULL);
        }

        //
        //  fill out record structure
        //

        prpcRecord->wType = type;
        prpcRecord->dwTtlSeconds = pRecord->dwTtl;

        //
        //  JBUGBUG:  data types (root hint, glue set)
        //      - need way to default that works for NT4
        //
/*
        if ( prpcRecord->dwFlags & DNS_RPC_RECORD_FLAG_CACHE_DATA )
        {
            precord->Flags.S.Section = DNSREC_CACHE_DATA;
        }
        else
        {
            precord->Flags.S.Section = DNSREC_ZONE_DATA;
        }
*/

        IF_DNSDBG( INIT )
        {
            DNS_PRINT((
                "New RPC buffer built\n"
                ));
        }


    IF_DNSDBG( RPC2 )
    {
/*
        DnsDbg_RecordSet(
            "Finished DnsConvertRpcBufferToRecords() ",
            rrset.pFirstRR );
*/
        DNS_PRINT((
            "Finished DnsConvertRpcBufferToRecords() "
            ));
    }

    return(prpcRecord);
}

//
//  End dconvert.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsbase.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnsbase.h
//
//	Implementation File:
//		dnsbase.cpp
//
//	Description:
//		Definition of the CDnsbase class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#include "common.h"
#include "dnsWrap.h"
class CSqlEval;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsBase
//
//	Description:
//  interface class defines all operations can be performed on provider
//  
//
//	Inheritance:
//	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsBase  
{
public:
	virtual SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler) = 0;
	virtual SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler ) = 0;
	virtual SCODE ExecuteMethod(
		CObjPath &,
		WCHAR *,
		long,
		IWbemClassObject *,
		IWbemObjectSink *
		) =0;

	virtual SCODE PutInstance( 
		IWbemClassObject *,
        long ,
		IWbemContext *,
		IWbemObjectSink* ); 
	virtual SCODE DeleteInstance( 
		CObjPath &, 
		long ,
		IWbemContext * ,
		IWbemObjectSink *
		); 
	virtual SCODE ExecQuery(
	    CSqlEval * ,
        long lFlags,
        IWbemContext * pCtx,
        IWbemObjectSink * pResponseHandler) ;

	
	CDnsBase();
	CDnsBase(
        const WCHAR *, 
        CWbemServices *);
	virtual  ~CDnsBase();

protected:
    CWbemServices *  m_pNamespace;
	IWbemClassObject* m_pClass;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnscache.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: dnscache.cpp
//
//  Description:    
//      Implementation of CDnscache class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsBase* 
CDnsCache::CreateThis(
    const WCHAR *       wszName,         //class name
    CWbemServices *     pNamespace,  //namespace
    const char *        szType         //str type id
    )
{
    return new CDnsCache(wszName, pNamespace);
}
CDnsCache::CDnsCache()
{

}
CDnsCache::CDnsCache(
	const WCHAR* wszName,
	CWbemServices *pNamespace)
	:CDnsBase(wszName, pNamespace)
{
	
}


CDnsCache::~CDnsCache()
{

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDnsCache::EnumInstance
//
//	Description:
//		enum instances of dns cache
//
//	Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsCache::EnumInstance(
	long				lFlags,
	IWbemContext *		pCtx,
	IWbemObjectSink *	pHandler )
{
	CWbemClassObject Inst;
	m_pClass->SpawnInstance(0,&Inst);
	CDnsWrap& dns = CDnsWrap::DnsObject();
	Inst.SetProperty(
		dns.GetServerName(),
		PVD_DOMAIN_SERVER_NAME);
	Inst.SetProperty(
		PVD_DNS_CACHE,
		PVD_DOMAIN_FQDN);
	Inst.SetProperty(
		PVD_DNS_CACHE,
		PVD_DOMAIN_CONTAINER_NAME);
	pHandler->Indicate(1, &Inst);
	return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDnsCache::GetObject
//
//	Description:
//		retrieve cache object based given object path
//
//	Arguments:
//      ObjectPath          [IN]    object path to cluster object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsCache::GetObject(
	CObjPath &          ObjectPath,
	long                lFlags,
	IWbemContext  *     pCtx,
	IWbemObjectSink *   pHandler)
{
	CDnsWrap& dns = CDnsWrap::DnsObject();
	wstring wstrServer = ObjectPath.GetStringValueForProperty(
		PVD_DOMAIN_SERVER_NAME);
// dww - 6/14/99
// Changed to make see if ValidateServerName does not return WBEM_S_NO_ERROR.
//
	if(WBEM_S_NO_ERROR != dns.ValidateServerName(wstrServer.data()))
		return WBEM_E_FAILED;
	wstring wstrContainer = ObjectPath.GetStringValueForProperty(
			PVD_DOMAIN_CONTAINER_NAME);
	if(_wcsicmp(
        wstrContainer.data(),
		PVD_DNS_CACHE) == 0)
	{
		wstring wstrFQDN= ObjectPath.GetStringValueForProperty(
				PVD_DOMAIN_FQDN);
		if(_wcsicmp(wstrFQDN.data(),
				PVD_DNS_CACHE) == 0)
		{
			// founded
			CWbemClassObject Inst;
			m_pClass->SpawnInstance(0, &Inst);
			Inst.SetProperty(
				dns.GetServerName(),
				PVD_DOMAIN_SERVER_NAME);
			Inst.SetProperty(
				PVD_DNS_CACHE,
				PVD_DOMAIN_FQDN);
			Inst.SetProperty(
				PVD_DNS_CACHE,
				PVD_DOMAIN_CONTAINER_NAME);
			pHandler->Indicate(1, &Inst);
		}
	}

	return WBEM_S_NO_ERROR;

}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDnsCache::ExecuteMethod
//
//	Description:
//		execute methods defined for cache class in the mof 
//
//	Arguments:
//      ObjectPath          [IN]    object path to cluster object
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsCache::ExecuteMethod(
	CObjPath &          objPath,
	WCHAR *             wzMethodName,
	long                lFlag,
	IWbemClassObject *  pInArgs,
	IWbemObjectSink *   pHandler) 
{
	CDnsWrap& dns = CDnsWrap::DnsObject();
	wstring wstrServer =  objPath.GetStringValueForProperty(
		PVD_DOMAIN_SERVER_NAME);
	
// dww - 6/14/99
// Changed to make see if ValidateServerName does not return WBEM_S_NO_ERROR.
//
	if( FAILED ( dns.ValidateServerName(wstrServer.data())) )
		return WBEM_E_INVALID_PARAMETER;

	if(_wcsicmp(
		wzMethodName,  
		PVD_MTH_CACHE_CLEARDNSSERVERCACHE) == 0)
	{
		  return dns.dnsClearCache();
	}

// dww - 6/14/99
// Added the GetDistinguishedName method in the CDnsCache class.
//
	else if(_wcsicmp(
		wzMethodName,
		PVD_MTH_ZONE_GETDISTINGUISHEDNAME) == 0)
	{
		wstring wstrName;
		wstring wstrCache = PVD_DNS_CACHE;
		CWbemClassObject OutParams, OutClass, Class ;
		HRESULT hr;
	
		dns.dnsDsZoneName(wstrName, wstrCache);


		BSTR ClassName=NULL;
		ClassName = AllocBstr(PVD_CLASS_CACHE); 
		hr = m_pNamespace->GetObject(ClassName, 0, 0, &Class, NULL);
		SysFreeString(ClassName);
		if ( SUCCEEDED ( hr ) )
		{
			Class.GetMethod(wzMethodName, 0, NULL, &OutClass);
			OutClass.SpawnInstance(0, &OutParams);
			OutParams.SetProperty(wstrName, PVD_DNS_RETURN_VALUE);
			hr = pHandler->Indicate(1, &OutParams);
		}

		return hr;
	}
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDnsCache::PutInstance
//
//	Description:
//		save this instance
//
//	Arguments:
//      InstToPut           [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_E_NOT_SUPPORTED
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsCache::PutInstance(
	IWbemClassObject *  pInst ,
    long                lFlags,
	IWbemContext*       pCtx ,
	IWbemObjectSink *   pHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}; 

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDnsCache::DeleteInstance
//
//	Description:
//		delete the object specified in rObjPath
//
//	Arguments:
//      rObjPath            [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_E_NOT_SUPPORTED
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsCache::DeleteInstance( 
	CObjPath &          ObjectPath,
	long                lFlags,
	IWbemContext *      pCtx,
	IWbemObjectSink *   pResponseHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnscache.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnscache.h
//
//	Implementation File:
//		dnscache.cpp
//
//	Description:
//		Definition of the CDnscache class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once


#include "dnsbase.h"
class CObjPath;
/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsCache
//
//	Description:
//      class defination for dns cache
//  
//
//	Inheritance:
//	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsCache  :  CDnsBase
{
public:
	CDnsCache();
	CDnsCache(
		const WCHAR*, 
		CWbemServices*);
	~CDnsCache();
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;

	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 
	SCODE DeleteInstance(
        CObjPath &          ObjectPath,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pResponseHandler 
		); 

    static CDnsBase* CreateThis(
        const WCHAR *       wszName,         //class name
        CWbemServices *     pNamespace,  //namespace
        const char *        szType         //str type id
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\ntrkcomm\sql_1.cpp ===
//***************************************************************************
//
//  SQL_1.CPP
//
//  Level 1 Syntax SQL Parser
//
//  Implements the syntax described in SQL_1.BNF.  This translates the input
//  into an RPN stream of tokens.
//
//  21-Jun-96       Created.
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <sqllex.h>
#include <sql_1.h>

//#define trace(x) printf x
#define trace(x)

static DWORD TranslateIntrinsic(LPWSTR pFuncName)
{
    if (_wcsicmp(pFuncName, L"UPPER") == 0)
        return SQL_LEVEL_1_TOKEN::IFUNC_UPPER;
    if (_wcsicmp(pFuncName, L"LOWER") == 0)
        return SQL_LEVEL_1_TOKEN::IFUNC_LOWER;
    return SQL_LEVEL_1_TOKEN::IFUNC_NONE;
}

SQL1_Parser::SQL1_Parser(CGenLexSource *pSrc)
{
    m_pLexer = new CGenLexer(Sql_1_LexTable, pSrc);
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    // Semantic transfer variables.
    // ============================
    m_nRelOp = 0;
    VariantInit(&m_vTypedConst);
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_pIdent = 0;
	m_bConstIsStrNumeric = FALSE;

    m_pExpression = new SQL_LEVEL_1_RPN_EXPRESSION;
}

SQL1_Parser::~SQL1_Parser()
{
    VariantClear(&m_vTypedConst);
    delete m_pIdent;
    delete m_pLexer;
    delete m_pExpression;
}


int SQL1_Parser::GetQueryClass(
    LPWSTR pDestBuf,
    int nBufLen
    )
{
    // Scan until 'FROM' and then get the class name.
    // ==============================================

    for (;;)
    {
        m_nCurrentToken = m_pLexer->NextToken();

        if (m_nCurrentToken == SQL_1_TOK_EOF)
        {
            m_pLexer->Reset();
            return FAILED;
        }

        if (_wcsicmp(m_pLexer->GetTokenText(), L"from") == 0)
        {
            m_nCurrentToken = m_pLexer->NextToken();
            if (m_nCurrentToken != SQL_1_TOK_IDENT)
            {
                m_pLexer->Reset();
                return FAILED;
            }

            // If here, we have the class name.
            // ================================
            if (wcslen(m_pLexer->GetTokenText()) >= (size_t)nBufLen)
            {
                m_pLexer->Reset();
                return BUFFER_TOO_SMALL;
            }

            wcscpy(pDestBuf, m_pLexer->GetTokenText());
            break;
        }
    }

    // Reset the scanner.
    // ==================
    m_pLexer->Reset();

    return SUCCESS;
}

int SQL1_Parser::Parse(SQL_LEVEL_1_RPN_EXPRESSION **pOutput)
{
    *pOutput = 0;

    int nRes = parse();
    if (nRes)
        return nRes;

    *pOutput = m_pExpression;
    m_pExpression = 0;

    return SUCCESS;
}

LPSTR ToAnsi(LPWSTR Src)
{
    static char buf[256];
	WideCharToMultiByte(CP_ACP, NULL, Src, -1, buf, 256, NULL, NULL);
    return buf;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

BOOL SQL1_Parser::Next()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == SQL_1_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == SQL_1_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check.
    // ==============

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        if (_wcsicmp(m_pTokenText, L"select") == 0)
            m_nCurrentToken = SQL_1_TOK_SELECT;
        else if (_wcsicmp(m_pTokenText, L"from") == 0)
            m_nCurrentToken = SQL_1_TOK_FROM;
        else if (_wcsicmp(m_pTokenText, L"where") == 0)
            m_nCurrentToken = SQL_1_TOK_WHERE;
        else if (_wcsicmp(m_pTokenText, L"like") == 0)
            m_nCurrentToken = SQL_1_TOK_LIKE;
        else if (_wcsicmp(m_pTokenText, L"or") == 0)
            m_nCurrentToken = SQL_1_TOK_OR;
        else if (_wcsicmp(m_pTokenText, L"and") == 0)
            m_nCurrentToken = SQL_1_TOK_AND;
        else if (_wcsicmp(m_pTokenText, L"not") == 0)
            m_nCurrentToken = SQL_1_TOK_NOT;
        else if (_wcsicmp(m_pTokenText, L"IS") == 0)
            m_nCurrentToken = SQL_1_TOK_IS;
        else if (_wcsicmp(m_pTokenText, L"NULL") == 0)
            m_nCurrentToken = SQL_1_TOK_NULL;
        else if (_wcsicmp(m_pTokenText, L"TRUE") == 0)
        {
            m_nCurrentToken = SQL_1_TOK_INT;
            m_pTokenText = L"65535";
        }
        else if (_wcsicmp(m_pTokenText, L"FALSE") == 0)
        {
            m_nCurrentToken = SQL_1_TOK_INT;
            m_pTokenText = L"0";
        }
    }

    return TRUE;
}

//***************************************************************************
//
// <parse> ::= SELECT <prop_list> FROM <classname> WHERE <expr>;
//
//***************************************************************************
// ok

int SQL1_Parser::parse()
{
    int nRes;

    // SELECT
    // ======
    if (!Next())
        return LEXICAL_ERROR;
    if (m_nCurrentToken != SQL_1_TOK_SELECT)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // <prop_list>
    // ===========
    if (nRes = prop_list())
        return nRes;

    // FROM
    // ====
    if (m_nCurrentToken != SQL_1_TOK_FROM)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // <classname>
    // ===========
    if (nRes = class_name())
        return nRes;

    // WHERE clause.
    // =============
    return opt_where();
}

//***************************************************************************
//
//  <opt_where> ::= WHERE <expr>;
//  <opt_where> ::= <>;
//
//***************************************************************************
int SQL1_Parser::opt_where()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_EOF)
    {
        trace(("No WHERE clause\n"));
        return SUCCESS;
    }

    if (m_nCurrentToken != SQL_1_TOK_WHERE)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    // <expr>
    // ======
    if (nRes = expr())
        return nRes;

    // Verify that the current token is SQL_1_TOK_EOF.
    // ===============================================
    if (m_nCurrentToken != SQL_1_TOK_EOF)
        return SYNTAX_ERROR;

    return SUCCESS;
}



//***************************************************************************
//
//  <prop_list> ::= <property_name> <prop_list_2>;
//
//***************************************************************************

int SQL1_Parser::prop_list()
{
    int nRes;

    if (m_nCurrentToken != SQL_1_TOK_ASTERISK &&
        m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (nRes = property_name())
        return nRes;

    if (!Next())
        return LEXICAL_ERROR;

    return prop_list_2();
}

//***************************************************************************
//
//  <prop_list_2> ::= COMMA <prop_list>;
//  <prop_list_2> ::= <>;
//
//***************************************************************************

int SQL1_Parser::prop_list_2()
{
    if (m_nCurrentToken == SQL_1_TOK_COMMA)
    {
        if (!Next())
            return LEXICAL_ERROR;
        return prop_list();
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <property_name> ::= PROPERTY_NAME_STRING;
//  <property_name> ::= ASTERISK;
//
//***************************************************************************

int SQL1_Parser::property_name()
{
    if (m_nCurrentToken == SQL_1_TOK_ASTERISK)
    {
        trace(("Asterisk\n"));
        m_pExpression->nNumberOfProperties = 0;
            // This signals 'all properties' to the evaluator
        return SUCCESS;
    }

    // Else a property name.
    // =====================

    trace(("Property name %S\n", m_pTokenText));

    m_pExpression->AddProperty(m_pTokenText);

    return SUCCESS;
}


//***************************************************************************
//
//  <classname> ::= CLASS_NAME_STRING;
//
//***************************************************************************

int SQL1_Parser::class_name()
{
    if (m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    trace(("Class name is %S\n", m_pTokenText));
    m_pExpression->bsClassName = SysAllocString(m_pTokenText);

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr> ::= <term> <expr2>;
//
//***************************************************************************

int SQL1_Parser::expr()
{
    int nRes;

    if (nRes = term())
        return nRes;

    if (nRes = expr2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr2> ::= OR <term> <expr2>;
//  <expr2> ::= <>;
//
//  Entry: Assumes token OR already current.
//  Exit:  Advances a token
//
//***************************************************************************

int SQL1_Parser::expr2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == SQL_1_TOK_OR)
        {
            trace(("Token OR\n"));

            if (!Next())
                return LEXICAL_ERROR;

            if (nRes = term())
                return nRes;

            SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
            pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
            m_pExpression->AddToken(pNewTok);
        }
        else break;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <term> ::= <simple_expr> <term2>;
//
//***************************************************************************

int SQL1_Parser::term()
{
    int nRes;
    if (nRes = simple_expr())
        return nRes;

    if (nRes = term2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <term2> ::= AND <simple_expr> <term2>;
//  <term2> ::= <>;
//
//***************************************************************************

int SQL1_Parser::term2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == SQL_1_TOK_AND)
        {
            trace(("Token AND\n"));

            if (!Next())
                return LEXICAL_ERROR;

            if (nRes = simple_expr())
                return nRes;

            // Add the AND token.
            // ==================
            SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
            pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
            m_pExpression->AddToken(pNewTok);
        }
        else break;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <simple_expr> ::= NOT <expr>;
//  <simple_expr> ::= OPEN_PAREN <expr> CLOSE_PAREN;
//  <simple_expr> ::= IDENTIFIER <leading_ident_expr> <finalize>;
//  <simple_expr> ::= VARIANT <rel_operator> <trailing_prop_expr> <finalize>;
//
//***************************************************************************
// ok
int SQL1_Parser::simple_expr()
{
    int nRes;

    // NOT <expr>
    // ==========
    if (m_nCurrentToken == SQL_1_TOK_NOT)
    {
        trace(("Operator NOT\n"));
        if (!Next())
            return LEXICAL_ERROR;
        if (nRes = simple_expr())
            return nRes;

        SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
        pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
        m_pExpression->AddToken(pNewTok);

        return SUCCESS;
    }

    // OPEN_PAREN <expr> CLOSE_PAREN
    // =============================
    else if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        trace(("Open Paren: Entering subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;
        if (expr())
            return SYNTAX_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        trace(("Close paren: Exiting subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // IDENTIFIER <leading_ident_expr> <finalize>
    // ==========================================
    else if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        trace(("    Identifier <%S>\n", m_pTokenText));

        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;

        if (nRes = leading_ident_expr())
            return SYNTAX_ERROR;

        return finalize();
    }

    // <typed_constant> <rel_operator> <trailing_prop_expr> <finalize>
    // ======================================================
    else if (m_nCurrentToken == SQL_1_TOK_INT ||
             m_nCurrentToken == SQL_1_TOK_REAL ||
             m_nCurrentToken == SQL_1_TOK_QSTRING
            )
    {
        if (nRes = typed_constant())
            return nRes;

        if (nRes = rel_operator())
            return nRes;

        if (nRes = trailing_prop_expr())
            return nRes;

        return finalize();
    }

    return SYNTAX_ERROR;
}


//***************************************************************************
//
//  <trailing_prop_expr> ::=  IDENTIFIER <trailing_prop_expr2>;
//
//***************************************************************************
// ok
int SQL1_Parser::trailing_prop_expr()
{
    if (m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
    wcscpy(m_pIdent, m_pTokenText);

    if (!Next())
        return LEXICAL_ERROR;

    return trailing_prop_expr2();
}

//***************************************************************************
//
//  <trailing_prop_expr2> ::= OPEN_PAREN IDENTIFIER CLOSE_PAREN;
//  <trailing_prop_expr2> ::= <>;
//
//***************************************************************************
// ok

int SQL1_Parser::trailing_prop_expr2()
{
    if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;

        // If we got to this point, the string pointed to by m_pIdent
        // was an intrinsic function and not a property name, and we
        // are about to get the property name, so we have to translate
        // the function name to its correct code before overwriting it.
        // ============================================================
        trace(("Translating intrinsic function %S\n", m_pIdent));
        m_dwPropFunction = TranslateIntrinsic(m_pIdent);
        delete m_pIdent;

        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;

        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;
    }

    trace(("Property name is %S\n", m_pIdent));
    return SUCCESS;
}


//***************************************************************************
//
//  <leading_ident_expr> ::= OPEN_PAREN <unknown_func_expr>;
//  <leading_ident_expr> ::= <comp_operator> <trailing_const_expr>;
//  <leading_ident_expr> ::= <equiv_operator> <trailing_or_null>;
//  <leading_ident_expr> ::= <is_operator> NULL;
//
//***************************************************************************
// ok
int SQL1_Parser::leading_ident_expr()
{
    int nRes;
    if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;
        return unknown_func_expr();
    }
    if (SUCCESS ==  comp_operator())
    {
        return trailing_const_expr();
    }    
    else if(SUCCESS == equiv_operator())
        return trailing_or_null();
    nRes = is_operator();
    if(nRes != SUCCESS)
        return nRes;
    if (m_nCurrentToken != SQL_1_TOK_NULL)
        return LEXICAL_ERROR;
    if (Next())
        return SUCCESS;
    else
        return LEXICAL_ERROR;
}


//***************************************************************************
//
//  <unknown_func_expr> ::= IDENTIFIER CLOSE_PAREN
//                          <rel_operator> <trailing_const_expr>;
//
//  <unknown_func_expr> ::= <typed_constant> CLOSE_PAREN
//                          <rel_operator> <trailing_prop_expr>;
//
//***************************************************************************
// ok
int SQL1_Parser::unknown_func_expr()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        m_dwPropFunction = TranslateIntrinsic(m_pIdent);
        delete m_pIdent;
        m_pIdent = new wchar_t[wcslen(m_pTokenText) + 1];
        wcscpy(m_pIdent, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;
        if (nRes = rel_operator())
            return nRes;
        return trailing_const_expr();
    }

    // Else the other production.
    // ==========================

    if (nRes = typed_constant())
        return nRes;

    // If here, we know that the leading ident was
    // an intrinsic function.
    // ===========================================

    m_dwConstFunction = TranslateIntrinsic(m_pIdent);
    delete m_pIdent;
    m_pIdent = 0;

    if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;
    if (nRes = rel_operator())
        return nRes;

    return trailing_prop_expr();
}

//***************************************************************************
//
//  <trailing_or_null> ::= NULL;
//  <trailing_or_null> ::= <trailing_const_expr>;
//
//***************************************************************************

int SQL1_Parser::trailing_or_null()
{
    if (m_nCurrentToken == SQL_1_TOK_NULL)
    {
	    if (!Next())
		    return LEXICAL_ERROR;
		else
        {
            V_VT(&m_vTypedConst) = VT_NULL;
			return SUCCESS;
        }
    }
    return trailing_const_expr();
}

//***************************************************************************
//
//  <trailing_const_expr> ::= IDENTIFIER OPEN_PAREN
//                            <typed_constant> CLOSE_PAREN;
//  <trailing_const_expr> ::= <typed_constant>;
//
//***************************************************************************
// ok
int SQL1_Parser::trailing_const_expr()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        trace(("Function applied to typed const = %S\n", m_pTokenText));

        m_dwConstFunction = TranslateIntrinsic(m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_OPEN_PAREN)
            return SYNTAX_ERROR;
	if (!Next())
            return LEXICAL_ERROR;

        if (nRes = typed_constant())
            return nRes;

        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    return typed_constant();
}

//***************************************************************************
//
//  <finalize> ::= <>;
//
//  This composes the SQL_LEVEL_1_TOKEN for a simple relational expression,
//  complete with any associated intrinsic functions.  All of the other
//  parse functions help isolate the terms of the expression, but only
//  this function builds the token.
//
//  To build the token, the following member variables are used:
//      m_pPropName
//      m_vTypedConst
//      m_dwPropFunction
//      m_dwConstFunction
//      m_nRelOp;
//
//  After the token is built, these are cleared/deallocated as appropriate.
//  No tokens are consumed and the input is not advanced.
//
//***************************************************************************
int SQL1_Parser::finalize()
{
    // At this point, we have all the info needed for a token.
    // =======================================================

    SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
    if ( pNewTok == NULL )
    {
        return FAILED;
    }

    pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::OP_EXPRESSION;
    pNewTok->pPropertyName = SysAllocString(m_pIdent);
    pNewTok->nOperator = m_nRelOp;
    VariantInit(&pNewTok->vConstValue);
    VariantCopy(&pNewTok->vConstValue, &m_vTypedConst);
    pNewTok->dwPropertyFunction = m_dwPropFunction;
    pNewTok->dwConstFunction = m_dwConstFunction;
	pNewTok->bConstIsStrNumeric = m_bConstIsStrNumeric;

    m_pExpression->AddToken(pNewTok);

    // Cleanup.
    // ========
    VariantClear(&m_vTypedConst);
    delete m_pIdent;
    m_pIdent = 0;
    m_nRelOp = 0;
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
	m_bConstIsStrNumeric = FALSE;

    return SUCCESS;
}

//***************************************************************************
//
//  <typed_constant> ::= VARIANT;
//
//  Ouput: m_vTypedConst is set to the value of the constant. The only
//         supported types are VT_I4, VT_R8 and VT_BSTR.
//
//***************************************************************************

int SQL1_Parser::typed_constant()
{
    trace(("    Typed constant <%S> ", m_pTokenText));
    VariantClear(&m_vTypedConst);
	m_bConstIsStrNumeric = FALSE;

    if (m_nCurrentToken == SQL_1_TOK_INT)
    {
        trace((" Integer\n"));
		DWORD x = wcslen(m_pTokenText);

		if (*m_pTokenText == L'-')
		{
			//negative

			if ((x < 11) || 
				((x == 11) && (wcscmp(m_pTokenText, L"-2147483648") <= 0)))
			{
				V_VT(&m_vTypedConst) = VT_I4;
				V_I4(&m_vTypedConst) = _wtol(m_pTokenText);
			}
			else
			{
				trace((" Actually Integer String\n"));
				V_VT(&m_vTypedConst) = VT_BSTR;
				V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
				m_bConstIsStrNumeric = TRUE;
			}
		}
		else
		{
			//positive

			if ((x < 10) || 
				((x == 10) && (wcscmp(m_pTokenText, L"2147483647") <= 0)))
			{
				V_VT(&m_vTypedConst) = VT_I4;
				V_I4(&m_vTypedConst) = _wtol(m_pTokenText);
			}
			else
			{
				trace((" Actually Integer String\n"));
				V_VT(&m_vTypedConst) = VT_BSTR;
				V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
				m_bConstIsStrNumeric = TRUE;
			}
		}

    }
    else if (m_nCurrentToken == SQL_1_TOK_QSTRING)
    {
        trace((" String\n"));
        V_VT(&m_vTypedConst) = VT_BSTR;
        V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
    }
    else if (m_nCurrentToken == SQL_1_TOK_REAL)
    {
		trace((" Real\n"));
		V_VT(&m_vTypedConst) = VT_R8;
		V_R8(&m_vTypedConst) = 0.0;

		if (m_pTokenText)
		{
			VARIANT varFrom;
			varFrom.vt = VT_BSTR;
			varFrom.bstrVal = SysAllocString(m_pTokenText);

			if(varFrom.bstrVal != NULL)
			{
				VariantClear(&m_vTypedConst);
				VariantInit(&m_vTypedConst);
				SCODE sc = VariantChangeTypeEx(&m_vTypedConst, &varFrom, 0, 0x409, VT_R8);
				VariantClear(&varFrom);

				if(sc != S_OK) 
				{
					VariantClear(&m_vTypedConst);
					VariantInit(&m_vTypedConst);
					return LEXICAL_ERROR;
				}
			}
		}
    }
    // Else, not a typed constant.
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <rel_operator> ::= <equiv_operator>; 
//  <rel_operator> ::= <comp_operator>; 
//
//***************************************************************************

int SQL1_Parser::rel_operator()
{
    if(SUCCESS == equiv_operator())
        return SUCCESS;
    else if (SUCCESS == comp_operator())
        return SUCCESS;
    else return LEXICAL_ERROR;
}

//***************************************************************************
//
//  <equiv_operator> ::= EQUIV_OPERATOR; // =, !=
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::equiv_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == SQL_1_TOK_EQ)
    {
        trace(("    REL OP =\n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUAL;
    }
    else if (m_nCurrentToken == SQL_1_TOK_NE)
    {
        trace(("    REL OP <> (!=) \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
    }
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <is_operator> ::= IS_OPERATOR; // is, isnot
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::is_operator()
{
    m_nRelOp = 0;
    if (m_nCurrentToken != SQL_1_TOK_IS)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == SQL_1_TOK_NOT)
    {
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        if (!Next())
            return LEXICAL_ERROR;

        trace(("    REL OP IS NOT \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
		return SUCCESS;
    }
    else
    {
        trace(("    REL OP IS \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUAL;
		return SUCCESS;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <comp_operator> ::= COMP_OPERATOR; // <=, >=, <, >, like
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::comp_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == SQL_1_TOK_LE)
    {
        trace(("    REL OP <=\n"));

		if (m_pIdent)
		{
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
		}
		else
		{
			trace(("    REL OP changed to >=\n"));
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
		}
    }
    else if (m_nCurrentToken == SQL_1_TOK_LT)
    {
        trace(("    REL OP <\n"));

		if (m_pIdent)
		{
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LESSTHAN;
		}
		else
		{
			trace(("    REL OP changed to >\n"));
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_GREATERTHAN;
		}
    }
    else if (m_nCurrentToken == SQL_1_TOK_GE)
    {
        trace(("    REL OP >=\n"));

		if (m_pIdent)
		{
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
		}
		else
		{
			trace(("    REL OP changed to <=\n"));
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
		}
    }
    else if (m_nCurrentToken == SQL_1_TOK_GT)
    {
        trace(("    REL OP >\n"));

		if (m_pIdent)
		{
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_GREATERTHAN;
		}
		else
		{
			trace(("    REL OP changed to <\n"));
			m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LESSTHAN;
		}
    }
    else if (m_nCurrentToken == SQL_1_TOK_LIKE)
    {
        trace(("    REL OP 'like' \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LIKE;
    }
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  Expression and token structure methods.
//
//***************************************************************************

SQL_LEVEL_1_RPN_EXPRESSION::SQL_LEVEL_1_RPN_EXPRESSION()
{
    nNumTokens = 0;
    pArrayOfTokens = 0;
    bsClassName = 0;
	nNumberOfProperties = 0;
 	pbsRequestedPropertyNames = 0;
    nCurSize = 32;
    nCurPropSize = 32;
    pArrayOfTokens = new SQL_LEVEL_1_TOKEN[nCurSize];
    pbsRequestedPropertyNames = new BSTR[nCurPropSize];
}

SQL_LEVEL_1_RPN_EXPRESSION::~SQL_LEVEL_1_RPN_EXPRESSION()
{
    delete [] pArrayOfTokens;
    if (bsClassName)
        SysFreeString(bsClassName);
    for (int i = 0; i < nNumberOfProperties; i++)
        SysFreeString(pbsRequestedPropertyNames[i]);
    delete pbsRequestedPropertyNames;        
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddToken(SQL_LEVEL_1_TOKEN *pTok)
{
	AddToken(*pTok);
    delete pTok;
	pTok = NULL;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddToken(SQL_LEVEL_1_TOKEN &pTok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 32;
        SQL_LEVEL_1_TOKEN *pTemp = new SQL_LEVEL_1_TOKEN[nCurSize];
        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = pTok;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddProperty(LPWSTR pProp)
{
    if (nCurPropSize == nNumberOfProperties)
    {
        nCurPropSize += 32;

        BSTR * pTemp = new BSTR[ nCurPropSize ];
        if ( !pTemp )
        {
            return;
        }

        memcpy(pTemp, pbsRequestedPropertyNames,
            sizeof(BSTR) * nNumberOfProperties);
        delete pbsRequestedPropertyNames;
        pbsRequestedPropertyNames = pTemp;
    }

    pbsRequestedPropertyNames[nNumberOfProperties++] = SysAllocString(pProp);
}

void SQL_LEVEL_1_RPN_EXPRESSION::Dump(const char *pszTextFile)
{
    FILE *f = fopen(pszTextFile, "wt");
    if (!f)
        return;

    fprintf(f, "----RPN Expression----\n");
    fprintf(f, "Class name = %S\n", bsClassName);
    fprintf(f, "Properties selected: ");

    if (!nNumberOfProperties)
    {
        fprintf(f, "* = all properties selected\n");
    }
    else for (int i = 0; i < nNumberOfProperties; i++)
    {
        fprintf(f, "%S ", pbsRequestedPropertyNames[i]);
    }
    fprintf(f, "\n------------------\n");
    fprintf(f, "Tokens:\n");

    for (int i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i].Dump(f);

    fprintf(f, "---end of expression---\n");
    fclose(f);
}

SQL_LEVEL_1_TOKEN::SQL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    pPropertyName = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
	bConstIsStrNumeric = FALSE;
}

SQL_LEVEL_1_TOKEN::SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN &Src)
{
    nTokenType = 0;
    pPropertyName = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
	bConstIsStrNumeric = FALSE;

    *this = Src;
}

SQL_LEVEL_1_TOKEN& SQL_LEVEL_1_TOKEN::operator =(SQL_LEVEL_1_TOKEN &Src)
{
	//first clear any old values...
    if (pPropertyName)
        SysFreeString(pPropertyName);

    VariantClear(&vConstValue);

    nTokenType = Src.nTokenType;
    pPropertyName = SysAllocString(Src.pPropertyName);
    nOperator = Src.nOperator;
    VariantCopy(&vConstValue, &Src.vConstValue);
    dwPropertyFunction = Src.dwPropertyFunction;
    dwConstFunction = Src.dwConstFunction;
	bConstIsStrNumeric = Src.bConstIsStrNumeric;
    return *this;
}

SQL_LEVEL_1_TOKEN::~SQL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    if (pPropertyName)
        SysFreeString(pPropertyName);

    nOperator = 0;
    VariantClear(&vConstValue);
}

void SQL_LEVEL_1_TOKEN::Dump(FILE *f)
{
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            fprintf(f, "OP_EXPRESSION ");
            break;
        case TOKEN_AND:
            fprintf(f, "TOKEN_AND ");
            break;
        case TOKEN_OR:
            fprintf(f, "TOKEN_OR ");
            break;
        case TOKEN_NOT:
            fprintf(f, "TOKEN_NOT ");
            break;
        default:
            fprintf(f, "Error: no token type specified\n");
    }

    if (nTokenType == OP_EXPRESSION)
    {
        char *pOp = "<no op>";
        switch (nOperator)
        {
            case OP_EQUAL: pOp = "OP_EQUAL"; break;
            case OP_NOT_EQUAL: pOp = "OP_NOT_EQUAL"; break;
            case OP_EQUALorGREATERTHAN: pOp = "OP_EQUALorGREATERTHAN"; break;
            case OP_EQUALorLESSTHAN: pOp = "OP_EQUALorLESSTHAN"; break;
            case OP_LESSTHAN: pOp = "OP_LESSTHAN"; break;
            case OP_GREATERTHAN: pOp = "OP_GREATERTHAN"; break;
            case OP_LIKE: pOp = "OP_LIKE"; break;
        }

        fprintf(f, "    Property = %S\n", pPropertyName);
        fprintf(f, "    Operator = %s\n", pOp);
        fprintf(f, "    Value =    ");

        switch (V_VT(&vConstValue))
        {
            case VT_I4:
                fprintf(f, "VT_I4 = %d\n", V_I4(&vConstValue));
                break;
            case VT_BSTR:
                fprintf(f, "VT_BSTR = %S\n", V_BSTR(&vConstValue));
                break;
            case VT_R8:
                fprintf(f, "VT_R8 = %f\n", V_R8(&vConstValue));
                break;
            default:
                fprintf(f, "<unknown>\n");
        }

        switch (dwPropertyFunction)
        {
            case IFUNC_NONE:
                break;
            case IFUNC_LOWER:
                fprintf(f, "Intrinsic function LOWER() applied to property\n");
                break;
            case IFUNC_UPPER:
                fprintf(f, "Intrinsic function UPPER() applied to property\n");
                break;
        }
        switch (dwConstFunction)
        {
            case IFUNC_NONE:
                break;
            case IFUNC_LOWER:
                fprintf(f, "Intrinsic function LOWER() applied to const value\n");
                break;
            case IFUNC_UPPER:
                fprintf(f, "Intrinsic function UPPER() applied to const value\n");
                break;
        }

    }

    fprintf(f, " <end of token>\n");
}

/////////////////////////////////////////////////////////////////////////////
//
// Algorithm for evaluating the expression, assuming that it has been
// tokenized and translated to Reverse Polish.
//
// Starting point:  (a) An array of SQL tokens.
//                  (b) An empty boolean token stack.
//
// 1.  Read Next Token
//
// 2.  If a SIMPLE EXPRESSION, evaluate it to TRUE or FALSE, and
//     place this boolean result on the stack.  Go to 1.
//
// 3.  If an OR operator, then pop a boolean token into A,
//     pop another boolean token into B. If either A or B are TRUE,
//     stack TRUE.  Else stack FALSE.
//     Go to 1.
//
// 4.  If an AND operator, then pop a boolean token into A,
//     and pop another into B.  If both are TRUE, stack TRUE.
//     Else stack FALSE.
//     Go to 1.
//
// 5.  If a NOT operator, reverse the value of the top-of-stack boolean.
//     Go to 1.
//
// At end-of-input, the result is at top-of-stack.
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsbase.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: dnsbase.cpp
//
//  Description:    
//      Implementation of CDnsbase class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////

#include "DnsWmi.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsBase::CDnsBase()
{

}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CProvBase::CProvBase
//
//	Description:
//		constructor
//
//	Arguments:
//      wzName            [IN]    class name
//      pNamespace        [IN]    WMI namespace
//
//	Return Value:
//		none
//
//--
/////////////////////////////////////////////////////////////////////////////

CDnsBase::CDnsBase(
	const WCHAR *   wzName,
	CWbemServices * pNamespace)
	:m_pNamespace(NULL),
	m_pClass(NULL)
{
	m_pNamespace = pNamespace;
	BSTR bstrClass = SysAllocString(wzName);
	SCODE sc;
	
	if(bstrClass == NULL)
	{
		sc = WBEM_E_OUT_OF_MEMORY;
	}
	else
	{
		sc = m_pNamespace->GetObject(
			bstrClass, 
			0,
			0,
			&m_pClass, 
			NULL);
		SysFreeString(bstrClass);
	}

	// failed to construct object, 
	if( FAILED ( sc ) )
	{
		throw sc;
		
	}
}

CDnsBase::~CDnsBase()
{
	if(m_pClass)
		m_pClass->Release();
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDnsBase::PutInstance
//
//	Description:
//		default implementation of PutInstance
//
//	Arguments:
//      pInst               [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_E_NOT_SUPPORTED
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE CDnsBase::PutInstance(
	IWbemClassObject *  pInst ,
    long                lFlags,
	IWbemContext*       pCtx ,
	IWbemObjectSink *   pHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}; 
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CProvBase::DeleteInstance
//
//	Description:
//		delete the instance pointed by ObjectPath
//
//	Arguments:
//      ObjectPath          [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_E_NOT_SUPPORTED
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE CDnsBase::DeleteInstance( 
	CObjPath&			ObjectPath,
	long				lFlags,
	IWbemContext *		pCtx,
	IWbemObjectSink *	pHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}


SCODE CDnsBase::ExecQuery(
	CSqlEval*			pSqlEval,
    long				lFlags,
    IWbemContext *		pCtx,
    IWbemObjectSink *	pHandler) 
{
	return EnumInstance(
		lFlags,
		pCtx,
		pHandler);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsclip.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    dnsclip.h

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    Main header file for DNS client API library.

Author:

    Jim Gilroy (jamesg)     September 1995

Revision History:

--*/


#ifndef _DNSCLIP_INCLUDED_
#define _DNSCLIP_INCLUDED_

#pragma warning(disable:4214)
#pragma warning(disable:4514)
#pragma warning(disable:4152)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>

//  headers are screwed up
//  if you bring in nt.h, then don't bring in winnt.h and
//  then you miss these

#ifndef MAXWORD
#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXWORD     0xffff
#define MAXDWORD    0xffffffff
#endif

#include <winsock2.h>
#include "dnsrpc_c.h"   //  MIDL generated RPC interface definitions
#include <dnsrpc.h>

#include <stdio.h>
#include <stdlib.h>

#define  NO_DNSAPI_DLL
#include "dnslib.h"


//
//  Internal routines
//
#ifdef __cplusplus
extern "C"
{
#endif

VOID
DnssrvCopyRpcNameToBuffer(
    IN      PSTR            pResult,
    IN      PDNS_RPC_NAME   pName
    );

PDNS_RPC_RECORD
DnsConvertRecordToRpcBuffer(
    IN      PDNS_RECORD     pRecord
    );

PVOID
DnssrvMidlAllocZero(
    IN      DWORD           dwSize
    );

PDNS_NODE
DnsConvertRpcBuffer(
    OUT     PDNS_NODE *     ppNodeLast,
    IN      DWORD           dwBufferLength,
    IN      BYTE            abBuffer[],
    IN      BOOLEAN         fUnicode
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumRecordsStub(
    IN      LPCSTR      Server,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszStartChild,
    IN      WORD        wRecordType,
    IN      DWORD       dwSelectFlag,
    IN OUT  PDWORD      pdwBufferLength,
    OUT     PBYTE *     ppBuffer
    );

#ifdef __cplusplus
}
#endif  // __cplusplus
//
//  Heap routines
//  Use dnsapi.dll memory routines
//

#define ALLOCATE_HEAP(iSize)            Dns_Alloc(iSize)
#define ALLOCATE_HEAP_ZERO(iSize)       Dns_AllocZero(iSize)
#define REALLOCATE_HEAP(pMem,iSize)     Dns_Realloc((pMem),(iSize))
#define FREE_HEAP(pMem)                 Dns_Free(pMem)


//
//  Debug stuff
//

#if DBG

#undef  ASSERT
#define ASSERT( expr )          DNS_ASSERT( expr )

#define DNSRPC_DEBUG_FLAG_FILE  ("dnsrpc.flag")
#define DNSRPC_DEBUG_FILE_NAME  ("dnsrpc.log")

#define DNS_DEBUG_EVENTLOG      0x00000010
#define DNS_DEBUG_RPC           0x00000020
#define DNS_DEBUG_STUB          0x00000040

#define DNS_DEBUG_HEAP          0x00010000
#define DNS_DEBUG_HEAP_CHECK    0x00020000
#define DNS_DEBUG_REGISTRY      0x00080000

#endif

#endif //   _DNSCLIP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\common.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		common.h
//
//	Implementation File:
//		util.cpp
//
//	Description:
//		Definition of the CDnsbase class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#include <wbemprov.h>
#include <objbase.h>
#include "ntrkcomm.h"
#include <string>
#include <list>
#include <memory>

using namespace std;


class CDnsBase;
class CDnsRpcNode;
class CObjPath;
class CDomainNode;
class CWbemInstanceMgr;


typedef LPVOID * PPVOID;
typedef SCODE (*FILTER) (
	CDomainNode&, 
	//CObjPath*, 
	PVOID,
	CDnsRpcNode*, 
	IWbemClassObject* ,
	CWbemInstanceMgr& 
	);
typedef CDnsBase* (*FPNEW) (
    const WCHAR*,
    CWbemServices*,
    const char*
    );
SCODE CreateClass(
	const WCHAR* , 
	CWbemServices* p, 
	void** );

//string convertion
BSTR 
AllocBstr(const WCHAR* );

int 
CharToWchar(
	LPCSTR, 
	LPWSTR* 
	);
wstring 
CharToWstring(
	LPCSTR , 
	DWORD 
	);
wstring IpAddressToString(DWORD ip);
int 
WcharToChar(
	LPCWSTR , 
	LPSTR* 
	);
int 
WcharToString(
	LPCWSTR,
	string& 
	);

//WBEM_CLASSS
extern const WCHAR* const PVD_CLASS_SERVER;

extern const WCHAR* const PVD_CLASS_DOMAIN;
extern const WCHAR* const PVD_CLASS_ZONE;
extern const WCHAR* const PVD_CLASS_CACHE;
extern const WCHAR* const PVD_CLASS_ROOTHINTS;
extern const WCHAR* const PVD_CLASS_RESOURCERECORD;
extern const WCHAR* const PVD_CLASS_RR_A;
extern const WCHAR* const PVD_CLASS_RR_SOA; 
extern const WCHAR* const PVD_CLASS_RR_PTR;
extern const WCHAR* const PVD_CLASS_RR_NS ;
extern const WCHAR* const PVD_CLASS_RR_CNAME; 
extern const WCHAR* const PVD_CLASS_RR_MB;
extern const WCHAR* const PVD_CLASS_RR_MD;
extern const WCHAR* const PVD_CLASS_RR_MF;
extern const WCHAR* const PVD_CLASS_RR_MG;
extern const WCHAR* const PVD_CLASS_RR_MR;
extern const WCHAR* const PVD_CLASS_RR_MINFO;
extern const WCHAR* const PVD_CLASS_RR_RP;
extern const WCHAR* const PVD_CLASS_RR_MX;
extern const WCHAR* const PVD_CLASS_RR_AFSDB;
extern const WCHAR* const PVD_CLASS_RR_RT;
extern const WCHAR* const PVD_CLASS_RR_HINFO;
extern const WCHAR* const PVD_CLASS_RR_ISDN;
extern const WCHAR* const PVD_CLASS_RR_TXT;
extern const WCHAR* const PVD_CLASS_RR_X25;
extern const WCHAR* const PVD_CLASS_RR_NULL;
extern const WCHAR* const PVD_CLASS_RR_WKS;
extern const WCHAR* const PVD_CLASS_RR_AAAA;
extern const WCHAR* const PVD_CLASS_RR_SRV;
extern const WCHAR* const PVD_CLASS_RR_ATMA;
extern const WCHAR* const PVD_CLASS_RR_WINS;
extern const WCHAR* const PVD_CLASS_RR_WINSR;

extern const WCHAR* const PVD_CLASS_SERVERDOMAIN;
extern const WCHAR* const PVD_CLASS_DOMAINDOMAIN;
extern const WCHAR* const PVD_CLASS_DOMAINRESOURCERECORD;
// server
extern const WCHAR* const PVD_SRV_ADDRESS_ANSWER_LIMIT;
extern const WCHAR* const PVD_SRV_BOOT_METHOD;
extern const WCHAR* const PVD_SRV_DS_POLLING_INTERVAL;
extern const WCHAR* const PVD_SRV_EVENT_LOG_LEVEL;
extern const WCHAR* const PVD_SRV_ALLOW_UPDATE;
extern const WCHAR* const PVD_SRV_AUTO_CACHE_UPDATE;
extern const WCHAR* const PVD_SRV_AUTO_REVERSE_ZONES;
extern const WCHAR* const PVD_SRV_BIND_SECONDARIES;
extern const WCHAR* const PVD_SRV_DISJOINT_NETS;
extern const WCHAR* const PVD_SRV_DS_AVAILABLE;
extern const WCHAR* const PVD_SRV_FORWARD_DELEGATION;
extern const WCHAR* const PVD_SRV_LOCAL_NETPRIORITY;
extern const WCHAR* const PVD_SRV_LOOSE_WILDCARDING;
extern const WCHAR* const PVD_SRV_NO_RECURSION;
extern const WCHAR* const PVD_SRV_FORWARDERS_IPADDRESSES_ARRAY;
extern const WCHAR* const PVD_SRV_FORWARD_TIMEOUT;
extern const WCHAR* const PVD_SRV_ROUND_ROBIN;
extern const WCHAR* const PVD_SRV_SECURE_RESPONSES;
extern const WCHAR* const PVD_SRV_SLAVE;
extern const WCHAR* const PVD_SRV_STRICT_FILE_PARSING;
extern const WCHAR* const PVD_SRV_AUTO_CONFIG_FILE_ZONES;
extern const WCHAR* const PVD_SRV_DEFAULT_AGING_STATE;
extern const WCHAR* const PVD_SRV_DEFAULT_REFRESH_INTERVAL;
extern const WCHAR* const PVD_SRV_DEFAULT_NOREFRESH_INTERVAL;
extern const WCHAR* const PVD_SRV_ENABLE_EDNS;
extern const WCHAR* const PVD_SRV_EDNS_CACHE_TIMEOUT;
extern const WCHAR* const PVD_SRV_MAX_UDP_PACKET_SIZE;
extern const WCHAR* const PVD_SRV_ENABLE_DNSSEC;
extern const WCHAR* const PVD_SRV_ENABLE_DP;
extern const WCHAR* const PVD_SRV_WRITE_AUTHORITY_NS;
extern const WCHAR* const PVD_SRV_LISTEN_IP_ADDRESSES_ARRAY;
extern const WCHAR* const PVD_SRV_LOG_LEVEL;
extern const WCHAR* const PVD_SRV_MAX_CACHE_TTL;
extern const WCHAR* const PVD_SRV_NAME_CHECK_FLAG; 
extern const WCHAR* const PVD_SRV_RECURSION_RETRY;
extern const WCHAR* const PVD_SRV_RECURSION_TIMEOUT; 
extern const WCHAR* const PVD_SRV_RPC_PROTOCOL;
extern const WCHAR* const PVD_SRV_SEND_ON_NON_DNS_PORT;
extern const WCHAR* const PVD_SRV_SERVER_IP_ADDRESSES_ARRAY;
extern const WCHAR* const PVD_SRV_SERVER_NAME;
extern const WCHAR* const PVD_SRV_VERSION;
extern const WCHAR* const PVD_SRV_STARTED;
extern const WCHAR* const PVD_SRV_STARTMODE;
// resource record

extern const WCHAR* const PVD_REC_CONTAINER_NAME;
extern const WCHAR* const PVD_REC_SERVER_NAME;
extern const WCHAR* const PVD_REC_DOMAIN_NAME;
extern const WCHAR* const PVD_REC_OWNER_NAME;
extern const WCHAR* const PVD_REC_CLASS;
extern const WCHAR* const PVD_REC_RDATA;
extern const WCHAR* const PVD_REC_TXT_REP; 
extern const WCHAR* const PVD_REC_TTL;
extern const WCHAR* const PVD_REC_TYPE;

extern const WCHAR* const PVD_REC_AAAA_IP;
extern const WCHAR* const PVD_REC_AFSBD_SERVER_NAME;
extern const WCHAR* const PVD_REC_AFSBD_SUB_TYPE;
extern const WCHAR* const PVD_REC_ATMA_FORMAT;
extern const WCHAR* const PVD_REC_ATMA_ATM_ADDRESS;
extern const WCHAR* const PVD_REC_A_IP;
extern const WCHAR* const PVD_REC_CNAME_PRIMARY_NAME;
extern const WCHAR* const PVD_REC_HINFO_CPU;
extern const WCHAR* const PVD_REC_HINFO_OS;
extern const WCHAR* const PVD_REC_ISDN_ISDN_NUM;
extern const WCHAR* const PVD_REC_ISDN_SUB_ADDRESS;
extern const WCHAR* const PVD_REC_MB_MBHOST;
extern const WCHAR* const PVD_REC_MD_MDHOST;
extern const WCHAR* const PVD_REC_MF_MFHOST;
extern const WCHAR* const PVD_REC_MG_MGMAILBOX;
extern const WCHAR* const PVD_REC_MINFO_ERROR_MAILBOX;
extern const WCHAR* const PVD_REC_MINFO_RESP_MAILBOX;
extern const WCHAR* const PVD_REC_MR_MRMAILBOX;
extern const WCHAR* const PVD_REC_MX_MAIL_EXCHANGE;
extern const WCHAR* const PVD_REC_MX_PREFERENCE;
extern const WCHAR* const PVD_REC_NS_NSHOST;
extern const WCHAR* const PVD_REC_NULL_NULLDATA;
extern const WCHAR* const PVD_REC_PTR_PTRDOMAIN_NAME;
extern const WCHAR* const PVD_REC_RP_RPMAILBOX;
extern const WCHAR* const PVD_REC_RP_TXT_DOMAIN_NAME;
extern const WCHAR* const PVD_REC_RT_HOST;
extern const WCHAR* const PVD_REC_RT_PREFERENCE;
extern const WCHAR* const PVD_REC_SOA_EXPIRE_LIMIT;
extern const WCHAR* const PVD_REC_SOA_TTL;
extern const WCHAR* const PVD_REC_SOA_PRIMARY_SERVER;
extern const WCHAR* const PVD_REC_SOA_REFRESH;
extern const WCHAR* const PVD_REC_SOA_RESPONSIBLE;
extern const WCHAR* const PVD_REC_SOA_RETRY_DELAY;
extern const WCHAR* const PVD_REC_SOA_SERIAL_NUMBER; 
extern const WCHAR* const PVD_REC_SRV_PORT;
extern const WCHAR* const PVD_REC_SRV_PRIORITY;
extern const WCHAR* const PVD_REC_SRV_WEIGHT;
extern const WCHAR* const PVD_REC_SRV_DOMAINNAME;
extern const WCHAR* const PVD_REC_TXT_TEXT;
extern const WCHAR* const PVD_REC_WINSR_TIMEOUT;
extern const WCHAR* const PVD_REC_WINSR_MAPPING_FLAG;
extern const WCHAR* const PVD_REC_WINSR_RESULT_DOMAIN;
extern const WCHAR* const PVD_REC_WINSR_CACHE_TIMEOUT;

extern const WCHAR* const PVD_REC_WINS_TIMEOUT;
extern const WCHAR* const PVD_REC_WINS_MAPPING_FLAG;
extern const WCHAR* const PVD_REC_WINS_WINS_SERVER;
extern const WCHAR* const PVD_REC_WINS_CACHE_TIMEOUT;
extern const WCHAR* const PVD_REC_WKS_INTERNET_ADDRESS;
extern const WCHAR* const PVD_REC_WKS_IP_PROTOCOL;
extern const WCHAR* const PVD_REC_WKS_BIT_MASK;
extern const WCHAR* const PVD_REC_X25_PSDNADDRESS;

// domain 


extern const WCHAR* const PVD_DOMAIN_CONTAINER_NAME;
extern const WCHAR* const PVD_DOMAIN_FQDN;
extern const WCHAR* const PVD_DOMAIN_SERVER_NAME;


//
//  Zone properties
//

extern const WCHAR* const PVD_ZONE_ALLOW_UPDATE;
extern const WCHAR* const PVD_ZONE_AUTO_CREATED;
extern const WCHAR* const PVD_ZONE_DISABLE_WIN_SRECORD_REPLICATION;
extern const WCHAR* const PVD_ZONE_NOTIFY;
extern const WCHAR* const PVD_ZONE_PAUSED;
extern const WCHAR* const PVD_ZONE_REVERSE;
extern const WCHAR* const PVD_ZONE_AGING;
extern const WCHAR* const PVD_ZONE_SECURE_SECONDARIES;
extern const WCHAR* const PVD_ZONE_SHUTDOWN;
extern const WCHAR* const PVD_ZONE_USE_WINS;
extern const WCHAR* const PVD_ZONE_MASTERS_IP_ADDRESSES_ARRAY;
extern const WCHAR* const PVD_ZONE_LOCAL_MASTERS_IP_ADDRESSES_ARRAY;
extern const WCHAR* const PVD_ZONE_DATA_FILE;
extern const WCHAR* const PVD_ZONE_SECONDARIES_IP_ADDRESSES_ARRAY;
extern const WCHAR* const PVD_ZONE_NOTIFY_IPADDRESSES_ARRAY;
extern const WCHAR* const PVD_ZONE_ZONE_TYPE;
extern const WCHAR* const PVD_ZONE_DS_INTEGRATED;
extern const WCHAR* const PVD_ZONE_AVAIL_FOR_SCAVENGE_TIME;
extern const WCHAR* const PVD_ZONE_REFRESH_INTERVAL;
extern const WCHAR* const PVD_ZONE_NOREFRESH_INTERVAL;
extern const WCHAR* const PVD_ZONE_SCAVENGE_SERVERS;
extern const WCHAR* const PVD_ZONE_FORWARDER_SLAVE;
extern const WCHAR* const PVD_ZONE_FORWARDER_TIMEOUT;
extern const WCHAR* const PVD_ZONE_LAST_SOA_CHECK;
extern const WCHAR* const PVD_ZONE_LAST_GOOD_XFR;


//domaindomain
//domain resource record containment
// server domain  containment
extern const WCHAR* const PVD_ASSOC_CHILD;
extern const WCHAR* const PVD_ASSOC_PARENT;
// method
extern const WCHAR* const PVD_MTH_SRV_RESTART;
extern const WCHAR* const PVD_MTH_SRV_START_SERVICE;
extern const WCHAR* const PVD_MTH_SRV_STOP_SERVICE;
extern const WCHAR* const PVD_MTH_ZONE_RESUMEZONE;
extern const WCHAR* const PVD_MTH_ZONE_PAUSEZONE;
extern const WCHAR* const PVD_MTH_ZONE_RELOADZONE;
extern const WCHAR* const PVD_MTH_ZONE_FORCEREFRESH;
extern const WCHAR* const PVD_MTH_ZONE_UPDATEFROMDS;
extern const WCHAR* const PVD_MTH_ZONE_WRITEBACKZONETOFILE;
extern const WCHAR* const PVD_MTH_ZONE_CHANGEZONETYPE;
extern const WCHAR* const PVD_MTH_ZONE_CREATEZONE;
extern const WCHAR* const PVD_MTH_ZONE_RESETNOTIFYIPARRAY;
extern const WCHAR* const PVD_MTH_ZONE_RESETSECONDARYIPARRAY;
extern const WCHAR* const PVD_MTH_ZONE_GETDISTINGUISHEDNAME;
extern const WCHAR* const PVD_MTH_ZONE_ARG_ZONENAME;
extern const WCHAR* const PVD_MTH_ZONE_ARG_ZONETYPE;
extern const WCHAR* const PVD_MTH_ZONE_ARG_DATAFILENAME;
extern const WCHAR* const PVD_MTH_ZONE_ARG_IPADDRARRAY;
extern const WCHAR* const PVD_MTH_ZONE_ARG_ADMINEMAILNAME;
extern const WCHAR* const PVD_MTH_ZONE_ARG_SECURITY;
extern const WCHAR* const PVD_MTH_ZONE_ARG_NOTIFY;
extern const WCHAR* const PVD_MTH_ZONE_ARG_MASTERIPARRAY;
extern const WCHAR* const PVD_MTH_ZONE_ARG_MASTERSLOCAL;
extern const WCHAR* const PVD_MTH_ZONE_ARG_SECONDARYIPARRAY;
extern const WCHAR* const PVD_MTH_ZONE_ARG_NOTIFYIPARRAY;

extern const WCHAR* const PVD_MTH_REC_CREATEINSTANCEFROMTEXTREPRESENTATION;
extern const WCHAR* const PVD_MTH_REC_MODIFY;
extern const WCHAR* const PVD_MTH_REC_CREATEINSTANCEFROMPROPERTYDATA;
extern const WCHAR* const PVD_MTH_REC_GETOBJECTBYTEXT;
extern const WCHAR* const PVD_MTH_REC_ARG_DNSSERVER_NAME;
extern const WCHAR* const PVD_MTH_REC_ARG_CONTAINER_NAME;
extern const WCHAR* const PVD_MTH_REC_ARG_TEXTREP;
extern const WCHAR* const PVD_MTH_REC_ARG_RR;
extern const WCHAR* const PVD_MTH_RH_WRITEBACKROOTHINTDATAFILE;
extern const WCHAR* const PVD_MTH_CACHE_CLEARDNSSERVERCACHE;
//general
extern const WCHAR* const PVD_DNS_CACHE;
extern const WCHAR* const PVD_DNS_ROOTHINTS;
extern const WCHAR* const PVD_DNS_LOCAL_SERVER;
extern const WCHAR* const PVD_DNS_RETURN_VALUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsdomain.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnsdomain.h
//
//	Implementation File:
//		dnscache.cpp
//
//	Description:
//		Definition of the CDnsDomain class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsbase.h"

class CObjPath;
class CDnsRpcNode;
/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsDomain
//
//	Description:
//      class defination for dns domain
//  
//
//	Inheritance:
//	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsDomain : public CDnsBase 
{
public:
	CDnsDomain();
	~CDnsDomain();
	CDnsDomain(
		const WCHAR*,
		CWbemServices*
		);
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;

	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 
	SCODE DeleteInstance(
        CObjPath &          ObjectPath,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pHandler 
		); 

    static CDnsBase* CreateThis(
        const WCHAR *       wszName,         //class name
        CWbemServices *     pNamespace,  //namespace
        const char *        szType         //str type id
        );
    static SCODE InstanceFilter(
	    CDomainNode &       ParentDomain,
	    PVOID               pFilter,
	    CDnsRpcNode *       pNode,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr &  InstMgr
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsdomain.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: dnsdomain.cpp
//
//  Description:    
//      Implementation of CDnsDomain class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		create an instance of CDnsDomain
//
//	Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
CDnsBase* 
CDnsDomain::CreateThis(
    const WCHAR *       wszName,         //class name
    CWbemServices *     pNamespace,  //namespace
    const char *        szType         //str type id
    )
{
    return new CDnsDomain(wszName, pNamespace);
}

CDnsDomain::CDnsDomain()
{

}

CDnsDomain::CDnsDomain(
	const WCHAR *   wszName,
	CWbemServices * pNamespace)
	:CDnsBase(wszName, pNamespace)
{
}

CDnsDomain::~CDnsDomain()
{
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		call back function to enum domain instance. 
//      if pNode represents a domain node, create a wmi domain instance
//
//	Arguments:
//      ParentDomain        [IN]    Parent domain
//      pFilter             [IN]    pointer to object that contains the criteria to filter
//                                  which instance should be send to wmi
//                                  not used here
//      pNode               [IN]    pointer to Dns Rpc Node object
//      pClass              [IN]    wmi class used to create instance
//      InstMgr             [IN]    a ref to Instance manager obj that is 
//                                  responsible to send mutiple instance 
//                                  back to wmi at once
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE CDnsDomain::InstanceFilter(
	CDomainNode &       ParentDomain,
	PVOID               pFilter,
	CDnsRpcNode *       pNode,
	IWbemClassObject *  pClass,
	CWbemInstanceMgr &  InstMgr )
	
{
	if (!pNode->IsDomainNode())
		return 0;
	CWbemClassObject NewInst;
	CDnsWrap& dns = CDnsWrap::DnsObject();
	pClass->SpawnInstance(0, &NewInst);
	
	//setting server name
	NewInst.SetProperty(
		dns.GetServerName(),
		PVD_DOMAIN_SERVER_NAME);
	
	// setting container name             
	NewInst.SetProperty(
		ParentDomain.wstrZoneName, 
		PVD_DOMAIN_CONTAINER_NAME
		);

	// concatinate domain name
	wstring wstrParentFQDN = ParentDomain.wstrNodeName;
	wstring wstrFQDN = pNode->GetNodeName();
	wstrFQDN += PVD_DNS_LOCAL_SERVER + wstrParentFQDN;

	// setting domain name
	NewInst.SetProperty(
        wstrFQDN, 
        PVD_DOMAIN_FQDN);

	InstMgr.Indicate(NewInst.data());
	return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		enum instances of dns domain
//
//	Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE CDnsDomain::EnumInstance(
	long				lFlags,
	IWbemContext *		pCtx,
	IWbemObjectSink *	pHandler)
{
	// Get all zones
	list<CDomainNode> objList, domainList;
	CDnsWrap& dns = CDnsWrap::DnsObject();
	SCODE sc = dns.dnsEnumDomainForServer(&objList);

	list<CDomainNode>::iterator i;
	CWbemInstanceMgr InstMgr(
		pHandler,
		100);
	for(i=objList.begin(); i!=objList.end(); ++i)
	{
		sc = dns.dnsEnumRecordsForDomainEx(
			*i,
			NULL,
			&InstanceFilter,
			TRUE,
			DNS_TYPE_ALL,
			DNS_RPC_VIEW_ALL_DATA,
			m_pClass,
			InstMgr);
		// Zones are domains, let's set them
		CWbemClassObject NewInst;
		if( SUCCEEDED ( m_pClass->SpawnInstance(0, &NewInst) ) )
		{
			
			wstring wstrNodeName = i->wstrNodeName;
			NewInst.SetProperty(
				dns.GetServerName(), 
				PVD_DOMAIN_SERVER_NAME);
			NewInst.SetProperty(
				i->wstrZoneName, 
				PVD_DOMAIN_CONTAINER_NAME);
			if(! _wcsicmp(i->wstrZoneName.data(), PVD_DNS_ROOTHINTS) ||
				! _wcsicmp(i->wstrZoneName.data(), PVD_DNS_CACHE) )
				 wstrNodeName = i->wstrZoneName;
			
			NewInst.SetProperty(
				wstrNodeName,
				PVD_DOMAIN_FQDN);
			pHandler->Indicate(
				1,
				&NewInst);
		}


	}

	return sc;
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		retrieve domain object pointed by the given object path
//
//	Arguments:
//      ObjectPath          [IN]    object path to object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsDomain::GetObject(
	CObjPath &          ObjectPath,
	long                lFlags,
	IWbemContext  *     pCtx,
	IWbemObjectSink *   pHandler)
{
	// validate input
	wstring wstrServerName = 
		ObjectPath.GetStringValueForProperty(
			PVD_DOMAIN_SERVER_NAME);
	if( wstrServerName.empty() ||
		ObjectPath.GetStringValueForProperty(
			PVD_DOMAIN_CONTAINER_NAME).empty() ||
		ObjectPath.GetStringValueForProperty(PVD_DOMAIN_FQDN).empty()
		)
	{
		return WBEM_E_INVALID_PARAMETER;
	}
	
	CDnsWrap& dns = CDnsWrap::DnsObject();
// dww - 6/14/99
// Changed to make see if ValidateServerName does not return WBEM_S_NO_ERROR.
//
	if(WBEM_S_NO_ERROR != dns.ValidateServerName(wstrServerName.data()))
		return WBEM_E_INVALID_PARAMETER;

	SCODE sc = dns.dnsGetDomain(
		ObjectPath,
		m_pClass,
		pHandler);
	return sc;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		execute methods defined for domain class in the mof 
//
//	Arguments:
//      ObjPath             [IN]    pointing to the object that the 
//                                  method should be performed on
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsDomain::ExecuteMethod(
    CObjPath &          ObjPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler) 
{
	CDnsWrap& dns = CDnsWrap::DnsObject();
	wstring wstrDomainName =  ObjPath.GetStringValueForProperty(
		PVD_DOMAIN_FQDN);

// dww - 6/14/99
// Added the GetDistinguishedName method in the CDnsDomain class.
//
	if(_wcsicmp(
		wzMethodName,
		PVD_MTH_ZONE_GETDISTINGUISHEDNAME) == 0)
	{
		wstring wstrName;
		CWbemClassObject OutParams, OutClass, Class ;
		HRESULT hr;
	
		dns.dnsDsZoneName(wstrName, wstrDomainName);


		BSTR ClassName=NULL;
		ClassName = AllocBstr(PVD_CLASS_DOMAIN); 
		hr = m_pNamespace->GetObject(ClassName, 0, 0, &Class, NULL);
		SysFreeString(ClassName);
		if ( SUCCEEDED ( hr ) )
		{
			Class.GetMethod( wzMethodName, 0, NULL, &OutClass);
			OutClass.SpawnInstance(0, &OutParams);
			OutParams.SetProperty(wstrName, PVD_DNS_RETURN_VALUE);
			hr = pHandler->Indicate(1, &OutParams);
		}

		return hr;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		save this instance
//
//	Arguments:
//      InstToPut           [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE CDnsDomain::PutInstance(
	IWbemClassObject *  pInst ,
    long                lFlags,
	IWbemContext*       pCtx ,
	IWbemObjectSink *   pHandler)
{

	return WBEM_S_NO_ERROR;
}; 
/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		delete the object specified in ObjectPath
//
//	Arguments:
//      ObjectPath          [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsDomain::DeleteInstance( 
	CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext *      pCtx,
    IWbemObjectSink *   pHandler) 
{
	wstring wstrContainer = ObjectPath.GetStringValueForProperty(
		PVD_DOMAIN_CONTAINER_NAME);
	string strContainer;
	WcharToString(
		wstrContainer.data(),
		strContainer);

	wstring wstrDomain = ObjectPath.GetStringValueForProperty(PVD_DOMAIN_FQDN);
	string strDomain;
	WcharToString(
		wstrDomain.data(), 
		strContainer);

	CDnsWrap& dns = CDnsWrap::DnsObject();
	SCODE sc =  dns.dnsDeleteDomain(
		(char*)strContainer.data(),
		(char*) strDomain.data());
	pHandler->SetStatus(
		0,
		sc,
		NULL,
		NULL);
	return WBEM_S_NO_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsdomaindomaincontainment.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnsdomanidomaincontainment.h
//
//	Implementation File:
//		dnsdomanidomaincontainment.cpp
//
//	Description:
//		Definition of the CDnsDomainDomainContainment class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsbase.h"
class CObjPath;
class CDnsRpcNode;


class CDnsDomainDomainContainment  : CDnsBase
{
public:
	CDnsDomainDomainContainment();
	CDnsDomainDomainContainment(
		const WCHAR*, 
		CWbemServices*
		);
	~CDnsDomainDomainContainment();
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;
	static SCODE InstanceFilter(
	    CDomainNode &       ParentDomain,
	    PVOID               pFilter,
	    CDnsRpcNode *       pNode,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr &  InstMgr
		);
    static CDnsBase* CreateThis(
        const WCHAR *       wszName,        
        CWbemServices *     pNamespace,  
        const char *        szType       
        );



};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsdomainresourcerecordcontainment.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		DnsDomainResourceRecordContainment.h
//
//	Implementation File:
//		DnsDomainResourceRecordContainment.cpp
//
//	Description:
//		Definition of the CDnsDomainResourceRecordContainment class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsbase.h"
class CObjPath;


class CDnsDomainResourceRecordContainment  : CDnsBase
{
public:
	CDnsDomainResourceRecordContainment();
	CDnsDomainResourceRecordContainment(
		const WCHAR*, 
		CWbemServices*
		);
	~CDnsDomainResourceRecordContainment();
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;
	static SCODE InstanceFilter(
	    CDomainNode &       ParentDomain,
	    PVOID               pFilter,
	    CDnsRpcNode *       pNode,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr &  InstMgr
		);
    static CDnsBase* CreateThis(
        const WCHAR *       wszName,        
        CWbemServices *     pNamespace,  
        const char *        szType       
        );




};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsdomaindomaincontainment.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: DnsDomainDomainContainment.cpp
//
//  Description:    
//      Implementation of CDnsDomainDomainContainment class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"

 
/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		create an instance of CDnsDomainDomainContainment
//
//	Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
CDnsBase* 
CDnsDomainDomainContainment::CreateThis(
    const WCHAR *       wszName,        
    CWbemServices *     pNamespace,  
    const char *        szType       
    )
{
    return new CDnsDomainDomainContainment(wszName, pNamespace);
}

CDnsDomainDomainContainment::CDnsDomainDomainContainment()
{

}
CDnsDomainDomainContainment::CDnsDomainDomainContainment(
	const WCHAR* wszName,
	CWbemServices *pNamespace)
	:CDnsBase(wszName, pNamespace)
{
}

CDnsDomainDomainContainment::~CDnsDomainDomainContainment()
{
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//
//	Description:
//		enum instances of domain and domain association
//
//	Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsDomainDomainContainment::EnumInstance( 
    long				lFlags,
    IWbemContext *		pCtx,
    IWbemObjectSink *	pHandler)
{
	// get top level zones
	list<CDomainNode> objList;
	CDnsWrap& dns = CDnsWrap::DnsObject();
	SCODE sc = dns.dnsEnumDomainForServer(&objList);
	list<CDomainNode>::iterator i;
	CWbemInstanceMgr InstMgr(
		pHandler);
	// enumerate all domaindomain for all zones
	for(i=objList.begin(); i!=objList.end(); ++i)
	{
		sc = dns.dnsEnumRecordsForDomainEx(
			*i,
			NULL,
			InstanceFilter,
			TRUE,
			DNS_TYPE_ALL,
			DNS_RPC_VIEW_ALL_DATA,
			m_pClass, 
			InstMgr);
	}

	return sc;

}

SCODE 
CDnsDomainDomainContainment::GetObject(
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext  *     pCtx,
    IWbemObjectSink *   pHandler
    )
{
		return WBEM_S_NO_ERROR;
}

SCODE CDnsDomainDomainContainment::ExecuteMethod(	
    CObjPath &          objPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler
    ) 
{
		return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		call back function to enum domain instance. 
//      if pNode represents a domain node, create a wmi domain instance
//
//	Arguments:
//      CDomainNode         [IN]    Parent domain
//      pFilter             [IN]    pointer to object that contains the criteria to filter
//                                  which instance should be send to wmi
//                                  not used here
//      pNode               [IN]    pointer to Dns Rpc Node object
//      pClass              [IN]    wmi class used to create instance
//      InstMgr             [IN]    a ref to Instance manager obj that is 
//                                  responsible to send mutiple instance 
//                                  back to wmi at once
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsDomainDomainContainment::InstanceFilter(
    CDomainNode &       ParentDomain,
    PVOID               pFilter,
    CDnsRpcNode *       pNode,
    IWbemClassObject *  pClass,
    CWbemInstanceMgr &  InstMgr
    )
{
	CWbemClassObject NewInst;
	if(!pNode->IsDomainNode())
		return WBEM_S_NO_ERROR;
//	CObjPath* pFilterObj = (CObjPath*) pFilter;
	CDnsWrap& dns = CDnsWrap::DnsObject();
    pClass->SpawnInstance(0, &NewInst);
	
    // setting object path for parent in association
	CObjPath objPathParent;
	objPathParent.SetClass(PVD_CLASS_DOMAIN);
	objPathParent.AddProperty(
		PVD_DOMAIN_SERVER_NAME,
		dns.GetServerName().data()
		);
	objPathParent.AddProperty(
		PVD_DOMAIN_CONTAINER_NAME, 
		ParentDomain.wstrZoneName.data()
		);
	objPathParent.AddProperty(
		PVD_DOMAIN_FQDN, 
		ParentDomain.wstrNodeName.data()
		);
	NewInst.SetProperty(
		objPathParent.GetObjectPathString(),
		PVD_ASSOC_PARENT);

	//setting object path for child in association
	wstring wzFQDN = pNode->GetNodeName();
	wzFQDN += PVD_DNS_LOCAL_SERVER + ParentDomain.wstrNodeName;
 	CObjPath opChild = objPathParent;
	opChild.SetProperty(
		PVD_DOMAIN_FQDN,
		wzFQDN.data()
		);
	NewInst.SetProperty(
		opChild.GetObjectPathString(),
		PVD_ASSOC_CHILD
		);
	InstMgr.Indicate(NewInst.data());
	return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsdomainresourcerecordcontainment.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: DnsDomainResourceRecordContainment.cpp
//
//  Description:    
//      Implementation of CDnsDomainResourceRecordContainment class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsBase* 
CDnsDomainResourceRecordContainment::CreateThis(
    const WCHAR *       wszName,         //class name
    CWbemServices *     pNamespace,  //namespace
    const char *        szType         //str type id
    )
{
    return new CDnsDomainResourceRecordContainment(wszName, pNamespace);
}
CDnsDomainResourceRecordContainment::CDnsDomainResourceRecordContainment()
{

}
CDnsDomainResourceRecordContainment::CDnsDomainResourceRecordContainment(
	const WCHAR* wszName, 
	CWbemServices *pNamespace)
	:CDnsBase(wszName, pNamespace)
{

}

CDnsDomainResourceRecordContainment::~CDnsDomainResourceRecordContainment()
{

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//
//	Description:
//		enum instances of domain and record association
//
//	Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsDomainResourceRecordContainment::EnumInstance( 
    long				lFlags,
    IWbemContext *		pCtx,
    IWbemObjectSink *	pHandler)
{
	list<CDomainNode> objList;
	CDnsWrap& dns = CDnsWrap::DnsObject();
	SCODE sc = dns.dnsEnumDomainForServer(&objList);
	list<CDomainNode>::iterator i;
	CWbemInstanceMgr InstMgr(
		pHandler);
	for(i=objList.begin(); i!=objList.end(); ++i)
	{
		sc = dns.dnsEnumRecordsForDomainEx(
			*i,
			NULL,
			InstanceFilter,
			TRUE,
			DNS_TYPE_ALL,
			DNS_RPC_VIEW_ALL_DATA,
			m_pClass,
			InstMgr);
	}
	return sc;
}

SCODE 
CDnsDomainResourceRecordContainment::GetObject(
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext  *     pCtx,
    IWbemObjectSink *   pHandler
    )
{
		return WBEM_E_NOT_SUPPORTED;
}

SCODE CDnsDomainResourceRecordContainment::ExecuteMethod(
    CObjPath &          objPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler
    )
{
		return WBEM_E_NOT_SUPPORTED;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		call back function to enum domain and record association instance. 
//      if pNode represents a domain node, create a wmi domain instance
//
//	Arguments:
//      ParentDomain        [IN]    Parent domain
//      pFilter             [IN]    pointer to object that contains the criteria to filter
//                                  which instance should be send to wmi
//                                  not used here
//      pNode               [IN]    pointer to Dns Rpc Node object
//      pClass              [IN]    wmi class used to create instance
//      InstMgr             [IN]    a ref to Instance manager obj that is 
//                                  responsible to send mutiple instance 
//                                  back to wmi at once
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE CDnsDomainResourceRecordContainment::InstanceFilter(
    CDomainNode &       ParentDomain,
    PVOID               pFilter,
    CDnsRpcNode *       pNode,
    IWbemClassObject *  pClass,
    CWbemInstanceMgr &  InstMgr
    )
{
	if (pNode->IsDomainNode())
		return 0;
	
//	CObjPath* pFilterObj = (CObjPath*) pFilter;
	CDnsWrap& dns = CDnsWrap::DnsObject();
	CObjPath objPathParent;
	objPathParent.SetClass(PVD_CLASS_DOMAIN);
	objPathParent.AddProperty(
		PVD_DOMAIN_SERVER_NAME, 
		dns.GetServerName().data()
		);
	objPathParent.AddProperty(
		PVD_DOMAIN_CONTAINER_NAME, 
		ParentDomain.wstrZoneName.data()
		);
	objPathParent.AddProperty(
		PVD_DOMAIN_FQDN, 
		ParentDomain.wstrNodeName.data()
		);

	wstring wstrOwner = pNode->GetNodeName();
	if(!wstrOwner.empty())
		wstrOwner += PVD_DNS_LOCAL_SERVER + ParentDomain.wstrNodeName;
	else
		wstrOwner = ParentDomain.wstrNodeName;

	CDnsRpcRecord* p;
	while(  (p = pNode->GetNextRecord()) != NULL )
	{
		auto_ptr<CDnsRpcRecord> pRec(p);

		CObjPath objPathChild;

		// populate rdata section
		pRec->GetObjectPath(
			dns.GetServerName(),
			ParentDomain.wstrZoneName,
			ParentDomain.wstrNodeName,
			wstrOwner,
			objPathChild);
		
		CWbemClassObject NewInst;
		pClass->SpawnInstance(0, &NewInst);
		// set domain ref
		NewInst.SetProperty(
			objPathParent.GetObjectPathString(), 
			PVD_ASSOC_PARENT
			);
		// set record ref
		NewInst.SetProperty(
			objPathChild.GetObjectPathString(), 
			PVD_ASSOC_CHILD
			);
		InstMgr.Indicate(NewInst.data());
	}

	
	return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsresourcerecord.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: Dnsresourcerecord.cpp
//
//  Description:    
//      Implementation of CDnsResourceRecord class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsResourceRecord::CDnsResourceRecord()
{

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		create an instance of CDnsResourceRecord
//
//	Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
CDnsBase* 
CDnsResourceRecord::CreateThis(
    const WCHAR *       wszName,        
    CWbemServices *     pNamespace,  
    const char *        szType       
    )
{
    return new CDnsResourceRecord(wszName, pNamespace, szType);
}

CDnsResourceRecord::CDnsResourceRecord(
	const WCHAR* wszName,
	CWbemServices *pNamespace,
	const char* szType)
	:CDnsBase(wszName, pNamespace)
{
		
	m_wType = Dns_RecordTypeForName(
		(char*)szType,
        0       // null terminated
        );
	if(m_wType == 0)
		m_wType = DNS_TYPE_ALL;
	m_wstrClassName = wszName;

}

CDnsResourceRecord::~CDnsResourceRecord()
{

}

CDnsResourceRecord::CDnsResourceRecord(
	WCHAR* wsClass, 
	char* szType)
{
	
	m_wType = Dns_RecordTypeForName(
		szType,
        0       // null terminated
        );
	if(m_wType == 0)
		m_wType = DNS_TYPE_ALL;
	m_wstrClassName = wsClass;

}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		enum instances of dns record
//
//	Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsResourceRecord::EnumInstance( 
	long				lFlags,
	IWbemContext *		pCtx,
	IWbemObjectSink *	pHandler)
{
	IWbemClassObject* pNewInst;
	list<CDomainNode> objList;
	CDnsWrap& dns = CDnsWrap::DnsObject();
	SCODE sc = dns.dnsEnumDomainForServer(&objList);
	list<CDomainNode>::iterator i;
	CWbemInstanceMgr InstanceMgr(
		pHandler);
	for(i=objList.begin(); i!=objList.end(); ++i)
	{
		
		sc = dns.dnsEnumRecordsForDomainEx(
			*i,
			NULL,
			&InstanceFilter, 
			TRUE,
			m_wType,
			DNS_RPC_VIEW_ALL_DATA,
			m_pClass,
			InstanceMgr);
	}
    
	return sc;
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		retrieve record object pointed by the given object path
//
//	Arguments:
//      ObjectPath          [IN]    object path to object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsResourceRecord::GetObject(
	CObjPath &          ObjectPath,
	long                lFlags,
	IWbemContext  *     pCtx,
	IWbemObjectSink *   pHandler)

{

	CDomainNode objNode;
	objNode.wstrZoneName = ObjectPath.GetStringValueForProperty(
		PVD_REC_CONTAINER_NAME);
	wstring wstrNodeName = ObjectPath.GetStringValueForProperty(
		PVD_REC_DOMAIN_NAME
		);
	if(_wcsicmp(wstrNodeName.data(), PVD_DNS_CACHE) == 0 ||
		_wcsicmp(wstrNodeName.data(), PVD_DNS_ROOTHINTS) ==0)
	{
		wstrNodeName = L"";
		ObjectPath.SetProperty(PVD_REC_OWNER_NAME,L"");
	}
	objNode.wstrNodeName = wstrNodeName;

	CDnsWrap& dns = CDnsWrap::DnsObject();
	CWbemInstanceMgr InstMgr(
		pHandler);
	SCODE sc = 	dns.dnsEnumRecordsForDomainEx(
		objNode,
		&ObjectPath,
		&GetObjectFilter, 
		FALSE,
		m_wType,
		DNS_RPC_VIEW_ALL_DATA,
		m_pClass,
		InstMgr);

	return sc;

}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		execute methods defined for record class in the mof 
//
//	Arguments:
//      ObjPath             [IN]    pointing to the object that the 
//                                  method should be performed on
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsResourceRecord::ExecuteMethod(	
    CObjPath &          ObjPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler) 
{
	CDnsWrap& dns = CDnsWrap::DnsObject();
	SCODE sc;

	CComPtr<IWbemClassObject> pOutParams;
	CComPtr<IWbemClassObject> pOutClass;
	sc = m_pClass->GetMethod(wzMethodName, 0, NULL, &pOutClass);
	if(sc != S_OK)
	{
		return sc;
	}
	
	pOutClass->SpawnInstance(0, &pOutParams);
	
	if(_wcsicmp(
		wzMethodName,
		PVD_MTH_REC_GETOBJECTBYTEXT) == 0)
	{
		return GetObjectFromText(
			pInArgs,
			pOutParams,
			pHandler);
	}
	else if(_wcsicmp(
		wzMethodName,
		PVD_MTH_REC_CREATEINSTANCEFROMTEXTREPRESENTATION) == 0)
	{
		return CreateInstanceFromText(
			pInArgs,
			pOutParams,
			pHandler);
	}
	else if (_wcsicmp(
		wzMethodName,
		PVD_MTH_REC_CREATEINSTANCEFROMPROPERTYDATA) == 0)
	{
		return CreateInstanceFromProperty(
			pInArgs,
			pOutParams,
			pHandler);

	}
	else if (_wcsicmp(
		wzMethodName,
		PVD_MTH_REC_MODIFY) == 0)
	{
		return Modify(ObjPath,
			pInArgs,
			pOutParams,
			pHandler);
	}
	else
	{
		return WBEM_E_NOT_SUPPORTED;
	}
	
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		call back function to enum record instance. 
//
//	Arguments:
//      ParentDomain        [IN]    Parent domain
//      pFilter             [IN]    pointer to object that contains the criteria to filter
//                                  which instance should be send to wmi
//                                  not used here
//      pNode               [IN]    pointer to Dns Rpc Node object
//      pClass              [IN]    wmi class used to create instance
//      InstMgr             [IN]    a ref to Instance manager obj that is 
//                                  responsible to send mutiple instance 
//                                  back to wmi at once
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsResourceRecord::InstanceFilter(
	CDomainNode &       ParentDomain,
	PVOID               pFilter,
	CDnsRpcNode *       pNode,
	IWbemClassObject *  pClass,
	CWbemInstanceMgr &  InstMgr )
{
	if(!pNode || !pClass )
		return WBEM_E_FAILED;
	if (pNode->IsDomainNode())
		return 0;
	CDnsRpcRecord* pRec=NULL;
	CDnsWrap& dns = CDnsWrap::DnsObject();
	wstring wzContainer = ParentDomain.wstrZoneName;
	wstring wstrFQDN;
	if( ParentDomain.wstrNodeName.empty())
    {
		wstrFQDN = ParentDomain.wstrZoneName;
    }
	else
    {
        wstrFQDN = ParentDomain.wstrNodeName;
    }
	wstring wstrNodeName = pNode->GetNodeName();
	if (!wstrNodeName.empty())
    {
        wstrNodeName += PVD_DNS_LOCAL_SERVER + wstrFQDN;
    }
	else
    {
        wstrNodeName = wstrFQDN;
    }

	while( (pRec = pNode->GetNextRecord()) != NULL)
	{
		auto_ptr<CDnsRpcRecord> apRec(pRec);
		CWbemClassObject NewInst;
		pClass->SpawnInstance(0, &NewInst);
		NewInst.SetProperty(
			dns.GetServerName(), 
			PVD_REC_SERVER_NAME);
		NewInst.SetProperty(
			wzContainer, 
			PVD_REC_CONTAINER_NAME);
		NewInst.SetProperty(
			wstrFQDN,
			PVD_REC_DOMAIN_NAME);
		NewInst.SetProperty(
			wstrNodeName, 
			PVD_REC_OWNER_NAME);
		NewInst.SetProperty(
			pRec->GetTextRepresentation(wstrNodeName),
			PVD_REC_TXT_REP);
		apRec->ConvertToWbemObject(NewInst);
		InstMgr.Indicate(NewInst.data());
	}

	
	return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		call back function in response to ExceQuery call. Return instances
//      that satisfy query language
//
//	Arguments:
//      ParentDomain        [IN]    Parent domain
//      pFilter             [IN]    pointer to CSqlEval object that implements 
//                                  logic based on sql language to filter 
//                                  which instance should be send to wmi
//                                  not used here
//      pNode               [IN]    pointer to Dns Rpc Node object
//      pClass              [IN]    wmi class used to create instance
//      InstMgr             [IN]    a ref to Instance manager obj that is 
//                                  responsible to send mutiple instance 
//                                  back to wmi at once
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsResourceRecord::QueryFilter(
	CDomainNode &       ParentDomain,
	PVOID               pFilter,
	CDnsRpcNode *       pNode,
	IWbemClassObject *  pClass,
	CWbemInstanceMgr &  InstMgr )
{
	if(!pNode || !pClass || !pFilter)
    {
		return WBEM_E_FAILED;
    }
	if (pNode->IsDomainNode())
    {
        return 0;
    }

	CSqlEval* pFilterObj = (CSqlEval*) pFilter;
	CDnsRpcRecord* pRec=NULL;
	CDnsWrap& dns = CDnsWrap::DnsObject();
	wstring wzContainer = ParentDomain.wstrZoneName;
	wstring wstrFQDN;
	if( ParentDomain.wstrNodeName.empty())
    {
		wstrFQDN = ParentDomain.wstrZoneName;
    }
	else
    {
        wstrFQDN = ParentDomain.wstrNodeName;
    }
	wstring wstrNodeName = pNode->GetNodeName();
	if (!wstrNodeName.empty())
    {
        wstrNodeName += PVD_DNS_LOCAL_SERVER + wstrFQDN;
    }
	else
    {
        wstrNodeName = wstrFQDN;
    }

	while( (pRec = pNode->GetNextRecord()) != NULL)
	{
		auto_ptr<CDnsRpcRecord> apRec(pRec);
		CWbemClassObject NewInst;
		pClass->SpawnInstance(0, &NewInst);
		NewInst.SetProperty(
			dns.GetServerName(), 
			PVD_REC_SERVER_NAME);
		NewInst.SetProperty(
			wzContainer, 
			PVD_REC_CONTAINER_NAME);
		NewInst.SetProperty(
			wstrFQDN,
			PVD_REC_DOMAIN_NAME);
		NewInst.SetProperty(
			wstrNodeName, 
			PVD_REC_OWNER_NAME);
		NewInst.SetProperty(
			pRec->GetTextRepresentation(wstrNodeName),
			PVD_REC_TXT_REP);
		pRec->ConvertToWbemObject(NewInst);
		
		CSqlWmiEvalee sqlEvalee(NewInst.data());
		if(pFilterObj->Evaluate(&sqlEvalee))
        {
			InstMgr.Indicate(NewInst.data());
        }
	}

	
	return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		call back function to enum record instance. 
//
//	Arguments:
//      ParentDomain        [IN]    Parent domain
//      pFilter             [IN]    pointer to an CObjPath object that 
//                                  contains the criteria to filter
//                                  which instance should be send to wmi
//                                  not used here
//      pNode               [IN]    pointer to Dns Rpc Node object
//      pClass              [IN]    wmi class used to create instance
//      InstMgr             [IN]    a ref to Instance manager obj that is 
//                                  responsible to send mutiple instance 
//                                  back to wmi at once
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsResourceRecord::GetObjectFilter(
	CDomainNode &       ParentDomain,
	PVOID               pFilter,
	CDnsRpcNode *       pNode,
	IWbemClassObject *  pClass,
	CWbemInstanceMgr &  InstMgr )
{

	if(!pNode || !pClass || !pFilter)
		return WBEM_E_FAILED;
	
	if (pNode->IsDomainNode())
		return 0;
	
	CObjPath* pFilterObj = (CObjPath*) pFilter;
	CDnsRpcRecord* pRec=NULL;
	
	wstring wstrResultOwner = pNode->GetNodeName();
	if(wstrResultOwner.empty())
		wstrResultOwner = ParentDomain.wstrNodeName;
	else
		wstrResultOwner += PVD_DNS_LOCAL_SERVER + ParentDomain.wstrNodeName;
	while( (pRec = pNode->GetNextRecord()) != NULL)
	{
		auto_ptr<CDnsRpcRecord> apRec(pRec);	
		wstring wstrSourceOwner = 
			pFilterObj->GetStringValueForProperty(
			PVD_REC_OWNER_NAME);
		if(_wcsicmp(wstrResultOwner.data(), wstrSourceOwner.data())==0)
		{
			wstring wstrData = pRec->GetData();
			if(_wcsicmp(wstrData.data(),
				pFilterObj->GetStringValueForProperty(
				PVD_REC_RDATA).data()) == 0)
			{
				// now find match
				CWbemClassObject NewInst;
				pClass->SpawnInstance(0, &NewInst);
				NewInst.SetProperty(
					CDnsWrap::DnsObject().GetServerName(),
					PVD_REC_SERVER_NAME);
				NewInst.SetProperty(
					ParentDomain.wstrZoneName,
					PVD_REC_CONTAINER_NAME);
				NewInst.SetProperty(
					ParentDomain.wstrNodeName,
					PVD_REC_DOMAIN_NAME);
				NewInst.SetProperty(
					wstrResultOwner, 
					PVD_REC_OWNER_NAME);
				NewInst.SetProperty(
					pRec->GetTextRepresentation(wstrResultOwner),
					PVD_REC_TXT_REP);
				apRec->ConvertToWbemObject(NewInst);
				InstMgr.Indicate(NewInst.data());
			}
		}

	}
	return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		save this instance
//
//	Arguments:
//      InstToPut           [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsResourceRecord::PutInstance(
	IWbemClassObject *  pInst ,
    long                lFlags,
	IWbemContext*       pCtx ,
	IWbemObjectSink *   pHandler)
{
	DWORD dwType;
	if(!pInst)
    {
		return WBEM_E_FAILED;
    }
	CDnsRpcRecord* pRecord = NULL;
	SCODE sc = CDnsRpcRecord::CreateClass(
		m_wType, 
		(PVOID*) &pRecord);
	if (sc != S_OK)
    {
        return sc;
    }
    auto_ptr<CDnsRpcRecord> apRecord(pRecord);
    CWbemClassObject Inst(pInst);
	string strOwner;
	Inst.GetProperty(
		strOwner, 
		PVD_REC_OWNER_NAME);
	string strRdata;
	Inst.GetProperty(
		strRdata,
		PVD_REC_RDATA);
	string strZone ;
	Inst.GetProperty(
		strZone,
		PVD_REC_CONTAINER_NAME);

	sc = apRecord->Init(
		strOwner,
		strRdata
		); 
	if( FAILED ( sc ) )
    {
		return sc;
    }
	sc = apRecord->SendToServer(
		strZone.data(),
		CDnsRpcRecord::AddRecord);

	return WBEM_S_NO_ERROR;
}; 
/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		delete the object specified in ObjectPath
//
//	Arguments:
//      ObjectPath          [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsResourceRecord::DeleteInstance( 
	CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext *      pCtx,
    IWbemObjectSink *   pHandler) 
{
	CDnsRpcRecord* pRecord = NULL;

	// get Rdata
	wstring wstrRdata = ObjectPath.GetStringValueForProperty(
		PVD_REC_RDATA);
	string strRdata;
	WcharToString(wstrRdata.data(), strRdata);

	// get owner
	wstring wstrOwner = ObjectPath.GetStringValueForProperty(
		PVD_REC_OWNER_NAME);	
	string strOwner;
	WcharToString(wstrOwner.data(), strOwner);

	SCODE sc = CDnsRpcRecord::CreateClass(
		m_wType,
		(PVOID*) &pRecord);
	if ( FAILED ( sc ) )
    {
		return sc;
    }
	auto_ptr<CDnsRpcRecord> apRecord(pRecord);	
	string strZone;
	sc = apRecord->Init(
		strOwner,
		strRdata
		); 
	if( FAILED(sc ) )
    {
		return sc;
    }
	wstring wstrContainer = ObjectPath.GetStringValueForProperty(
		PVD_REC_CONTAINER_NAME);
	string strContainer;
	WcharToString(wstrContainer.data(), strContainer);
	sc = apRecord->SendToServer(
		strContainer.data(),
		CDnsRpcRecord::DeleteRecord);

	return sc;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		modify a record. for the given objpath, it tries to get the record first, 
//      error out if not exist. Create new record based on pInArgs, error out if conflict
//      existing one. if success, delete old record.
//
//	Arguments:
//      objPath             [IN]    point to record to be modified
//      pInArgs             [IN]    new property of a record to be modified to 
//      pOutParams          [IN]    new object path after modify
//      pHandler            [IN]    wmi sink
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsResourceRecord::Modify(
	CObjPath&           objPath,
	IWbemClassObject*   pInArgs,
	IWbemClassObject*   pOutParams,
	IWbemObjectSink*    pHandler)
{
	CDnsWrap& dns = CDnsWrap::DnsObject();
	//Get zonename
	wstring wstrZone = objPath.GetStringValueForProperty(
		PVD_REC_CONTAINER_NAME);
	if(wstrZone.empty())
    {
		return WBEM_E_INVALID_PARAMETER;
    }
	string strZone;
	WcharToString(wstrZone.data(), strZone);

	//Get owner
	wstring wstrOwner = objPath.GetStringValueForProperty(
		PVD_REC_OWNER_NAME);
	if(wstrOwner.empty())
    {
		return WBEM_E_INVALID_PARAMETER;
    }
	string strOwner;
	WcharToString(wstrOwner.data(), strOwner);

	//Get Rdata
	wstring wstrRdata = objPath.GetStringValueForProperty(
		PVD_REC_RDATA);
	if(wstrRdata.empty())
    {
		return WBEM_E_INVALID_PARAMETER;
    }
	string strRdata;
	WcharToString(wstrRdata.data(), strRdata);

	// create class
	CDnsRpcRecord* pRecord;
	SCODE sc = CDnsRpcRecord::CreateClass(
		m_wType, 
		(PVOID*) &pRecord);
	if ( FAILED ( sc ) )
    {
		return sc;
    }
	auto_ptr<CDnsRpcRecord> apRec(pRecord);
	CWbemClassObject InstInArgs(pInArgs);
	sc = apRec->Init(
		m_wstrClassName,
		strOwner, 
		strRdata,
		InstInArgs
		);
	if ( FAILED ( sc ) )
    {
        return sc;
    }
	apRec->SendToServer(
		strZone.data(),
		CDnsRpcRecord::AddRecord);

	// new record created, delete old one
	if ( apRec->RdataIsChanged()) 
	{
		try
		{
			CDnsRpcRecord* pOldRecord;
			SCODE sc = CDnsRpcRecord::CreateClass(
				m_wType, 
				(PVOID*) &pOldRecord);
			if ( FAILED ( sc ) )
            {
				throw sc;
            }
			auto_ptr<CDnsRpcRecord> apOldRec(pOldRecord);	
			sc = apOldRec->Init(
				strOwner,
				strRdata);
			if( FAILED ( sc ) )
            {
				throw sc;
            }
			apOldRec->SendToServer(
				strZone.data(),
				CDnsRpcRecord::DeleteRecord);
		}
		catch(SCODE sc_e)
		{	
			// if we fail to delete old record,
			// delete the one we just created
			apRec->SendToServer(
				strZone.data(),
				CDnsRpcRecord::DeleteRecord);
			return sc_e;
		}
	}
    //
    // set output 
    //
	CObjPath newObjPath;
	apRec->GetObjectPath(
		dns.GetServerName(),
		wstrZone,
		L"",
		wstrOwner,
		newObjPath);
	CWbemClassObject instOutParams(pOutParams);
	instOutParams.SetProperty(
		newObjPath.GetObjectPathString(),
		PVD_MTH_REC_ARG_RR);
	return pHandler->Indicate(1, &instOutParams);

}

// dww - 6/24/99
// Added GetDomainNameFromZoneAndOwner to find the right DomainName...
SCODE 
CDnsResourceRecord::GetDomainNameFromZoneAndOwner(
	string & InZone,
	string & InOwner,
	string & OutNode
    )
{
	if( _stricmp( InOwner.c_str(), "@" ) == 0 )
	{
		OutNode = InZone;
		InOwner = InZone;
	}
	else if( _stricmp( InOwner.c_str(), InZone.c_str() ) == 0 )
	{
		OutNode = InZone;
	}
	else if( _wcsicmp( m_wstrClassName.c_str(), PVD_CLASS_RR_NS ) == 0 ) // NSType exception
	{
		OutNode = InOwner;
	}
	else {
		int posZone = InOwner.find( InZone, 0 );
		int posFirstPeriod = InOwner.find_first_of( '.' );
		string strtempZoneNode = InOwner.substr( posZone, InOwner.length() );
		string strtempPeriodNode = InOwner.substr( posFirstPeriod + 1, InOwner.length() );

		if( _stricmp( strtempZoneNode.c_str(), strtempPeriodNode.c_str() ) == 0 )
		{
			OutNode = strtempZoneNode;
		}
		else {
			OutNode = strtempPeriodNode;
		}
	}

	return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		get an instance of record based on record text representation
//
//	Arguments:
//      pInArgs             [IN]    input args contains text rep of record
//      pOutParams          [IN]    output parameter
//      pHandler            [IN]    wmi sink
//
//	Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsResourceRecord::GetObjectFromText(
	IWbemClassObject *  pInArgs,
	IWbemClassObject *  pOutParams,
	IWbemObjectSink *   pHandler
    )
{

	// get zonename
	string strZone;
	CWbemClassObject InstInArgs(pInArgs);
	
    if(InstInArgs.GetProperty(
		strZone, 
		PVD_MTH_REC_ARG_CONTAINER_NAME) != S_OK)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
	//get textrepresentation
	string strTextRep;
	if(InstInArgs.GetProperty(
		strTextRep,
		PVD_MTH_REC_ARG_TEXTREP) != S_OK)
    {
		return WBEM_E_INVALID_PARAMETER;
    }
	// get OwnerName
	string strOwner;
	int pos = strTextRep.find(' ');
	if(pos != string::npos)
    {
        strOwner = strTextRep.substr(0, pos);
    }

	// get recordType
	pos = strTextRep.find_first_not_of(' ', pos);	// move to record class
	pos = strTextRep.find_first_of(' ', pos);
	if(pos == string::npos)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

	pos = strTextRep.find_first_not_of(' ', pos);
	int endpos = strTextRep.find(' ', pos);	// move to record type
	if(endpos == string::npos)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
	string strRecordType = strTextRep.substr(pos,endpos-pos);
	// set the record type
	m_wType = Dns_RecordTypeForName(
		(char*)strRecordType.data(),
		0       // null terminated
		);

	// get Rdata

	pos = strTextRep.find_first_not_of(' ', endpos);
	string strRdata = strTextRep.substr(pos);

	// dww - 6/24/99
	// Domain Name is incorrect. Re-wrote logic in GetDomainNameFromZoneAndOwner
	// to find the right DomainName...
	string strNode = "";
	GetDomainNameFromZoneAndOwner(strZone, strOwner, strNode);

	//Form filter object
	CObjPath opFilter;
	opFilter.SetClass(PVD_CLASS_RESOURCERECORD);
	opFilter.AddProperty(PVD_REC_CONTAINER_NAME, strZone);
	opFilter.AddProperty(PVD_REC_DOMAIN_NAME, strNode);
	opFilter.AddProperty(PVD_REC_OWNER_NAME, strOwner);
	opFilter.AddProperty(PVD_REC_RDATA, strRdata);

	// get object
	return GetObject(
		opFilter,
		0,
		0,
		pHandler);
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		create an instance of record based on record text representation
//
//	Arguments:
//      pInArgs             [IN]    input args contains text rep of record
//      pOutParams          [IN]    output parameter
//      pHandler            [IN]    wmi sink
//
//	Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsResourceRecord::CreateInstanceFromText(
	IWbemClassObject *  pInArgs,
	IWbemClassObject *  pOutParams,
	IWbemObjectSink *   pHandler)
{
	CDnsWrap& dns = CDnsWrap::DnsObject();
	// get zone name
	string strZone;
	CWbemClassObject InstInArgs(pInArgs);
	if( FAILED ( InstInArgs.GetProperty(
		strZone, 
		PVD_MTH_REC_ARG_CONTAINER_NAME) ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
	//get textrepresentation
	string strTextRep;
	if( FAILED ( InstInArgs.GetProperty(
		strTextRep,
		PVD_MTH_REC_ARG_TEXTREP) ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

	// get OwnerName
	string strOwner;
	int pos = strTextRep.find(' ');
	if(pos != string::npos)
    {
        strOwner = strTextRep.substr(0, pos);
    }

	// get recordType
		// move to record class
	pos = strTextRep.find_first_not_of(' ', pos);	
	pos = strTextRep.find_first_of(' ', pos);
	if(pos == string::npos)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

		// move to record type
	pos = strTextRep.find_first_not_of(' ', pos);
	int endpos = strTextRep.find(' ', pos);	
	if(endpos == string::npos)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
	string strRecordType = strTextRep.substr(pos,endpos-pos);
	// get Rdata

	pos = strTextRep.find_first_not_of(' ', endpos);
	string strRdata = strTextRep.substr(pos);

	// set the record type
	m_wType = Dns_RecordTypeForName(
		(char*)strRecordType.data(),
		0       // null terminated
		);

	// create class
	CDnsRpcRecord* pRecord;
	SCODE sc = CDnsRpcRecord::CreateClass(
		m_wType, 
		(PVOID*) &pRecord);
	if ( FAILED ( sc ))
    {
        return sc;
    }
	
	auto_ptr<CDnsRpcRecord> apRecord(pRecord);		
	sc = apRecord->Init(
		strOwner, 
		strRdata
		);
	if ( FAILED ( sc ) )
    {
		return sc;
    }

	apRecord->SendToServer(
		strZone.data(),
		CDnsRpcRecord::AddRecord);

	// set output parameter
	CObjPath newObjPath;
	
	apRecord->GetObjectPath(
		dns.GetServerName(),
		CharToWstring(strZone.data(), strZone.length()),
		L"",
		CharToWstring(strOwner.data(), strOwner.length()),
		newObjPath );
	CWbemClassObject instOutParams( pOutParams );
	instOutParams.SetProperty(
		newObjPath.GetObjectPathString(),
		PVD_MTH_REC_ARG_RR);
	return pHandler->Indicate(1, &instOutParams);
	//done

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		create an instance of record based on input parameter 
//      with proper property setting
//
//	Arguments:
//      pInArgs             [IN]    input args contains property setting
//      pOutParams          [IN]    output parameter
//      pHandler            [IN]    wmi sink
//
//	Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsResourceRecord::CreateInstanceFromProperty(
	IWbemClassObject *  pInArgs,
	IWbemClassObject *  pOutParams,
	IWbemObjectSink *   pHandler
    )
{
	CDnsWrap& dns = CDnsWrap::DnsObject();
	CWbemClassObject InstInArgs(pInArgs);
	string strZone;
    // get zone name
	if( FAILED ( InstInArgs.GetProperty(
		strZone, 
		PVD_REC_CONTAINER_NAME) ) )
    {
		return WBEM_E_INVALID_PARAMETER;
    }
	
    // get owner name
	string strOwner;
	if( FAILED ( InstInArgs.GetProperty(
		strOwner,
		PVD_REC_OWNER_NAME) ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
	string strRdata;

	// create class
	CDnsRpcRecord* pRecord;
	SCODE sc = CDnsRpcRecord::CreateClass(
		m_wType, 
		(PVOID*) &pRecord);
	if ( FAILED( sc ) )
    {
        return sc;
    }
	auto_ptr<CDnsRpcRecord> apRecord(pRecord);	
	sc = apRecord->Init(
		m_wstrClassName,
		strOwner, 
		strRdata,
		InstInArgs
		);
	if ( FAILED ( sc ) )
    {
		return sc;
    }
	apRecord->SendToServer(
		strZone.data(),
		CDnsRpcRecord::AddRecord);
	
	// set output parameter
	CObjPath newObjPath;
	apRecord->GetObjectPath(
		dns.GetServerName(),
		CharToWstring(strZone.data(),strZone.length()),
		L"",
		CharToWstring(strOwner.data(), strOwner.length()),
		newObjPath);

	CWbemClassObject instOutParams(pOutParams);
	instOutParams.SetProperty(
		newObjPath.GetObjectPathString(),
		PVD_MTH_REC_ARG_RR);
	return pHandler->Indicate(1, &instOutParams);

	//done

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		enum instances of dns domain
//
//	Arguments:
//      pSqlEval            [IN]    pointer to CSqlEval object that implements 
//                                  logic based on sql language to filter 
//                                  which instance should be send to wmi
//                                  not used here
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////


SCODE CDnsResourceRecord::ExecQuery(
	CSqlEval *          pSqlEval,
    long                lFlags,
    IWbemContext *      pCtx,
    IWbemObjectSink *   pHandler
    ) 
{
	SCODE sc = WBEM_S_NO_ERROR;
	const WCHAR * ppName[] = 
	{
		PVD_REC_CONTAINER_NAME,
		PVD_REC_DOMAIN_NAME,
		PVD_REC_OWNER_NAME
	};
	if (pSqlEval == NULL)
    {
		return WBEM_E_INVALID_PARAMETER;
    }

    //
    // converting from sql to a set of zone, domain and owner name to be queried on
    //
	CQueryEnumerator qeInst(
		(WCHAR**) ppName,
		3);
	pSqlEval->GenerateQueryEnum(qeInst);


	qeInst.Reset();
	BOOL flag = TRUE;
	CWbemInstanceMgr InstanceMgr(
					pHandler);

	CDnsWrap& dns = CDnsWrap::DnsObject();
    //
    // loop through a array of ppName, figure out what zone, domain and owner
    // criteria should be used, then call dnsEnumRecordsForDomainEx with those 
    // parameter plus CSqlEval, CSqlEval is used further to filter out record
    //
	while(flag)
	{
		int nSize;
		const WCHAR **pp = qeInst.GetNext(nSize);
		if(pp != NULL)
		{
			// if no domain specified, do recursive search
			BOOL bRecursive = (pp[1] == NULL);

			//if zone not specified, enum all zones
			if(pp[0] == NULL)
			{
				list<CDomainNode> objList;
				SCODE sc = dns.dnsEnumDomainForServer(&objList);
				list<CDomainNode>::iterator i;
				for(i=objList.begin(); i!=objList.end(); ++i)
				{
					//if(_wcsicmp(i->wstrZoneName.data(), PVD_DNS_ROOTHINTS)==0)
					//	i->wstrNodeName = i->wstrZoneName;
					if(pp[1] != NULL)
					{
						i->wstrNodeName = pp[1];
						if(pp[2] != NULL)
						{
						//take only name ifself, not FQDN

							i->wstrChildName = pp[2];
							int pos = i->wstrChildName.find_first_of('.',0);
							if(pos != string::npos)
								i->wstrChildName = i->wstrChildName.substr(0,pos);

						}
					}

					try
					{
						sc = dns.dnsEnumRecordsForDomainEx(
							*i,
							pSqlEval,
							&QueryFilter, 
							bRecursive,
							m_wType,
							DNS_RPC_VIEW_ALL_DATA,
							m_pClass,
							InstanceMgr);
					}
					catch(CDnsProvException e)
					{
						if(e.GetErrorCode() != DNS_ERROR_NAME_DOES_NOT_EXIST)
							throw;

					}
				}


			}
			else
			{
				CDomainNode node;
				if(pp[2] != NULL)
				{
					//take only name ifself, not FQDN
					if( pp[1] != NULL)
					{
						node.wstrChildName = pp[2];
						int pos = node.wstrChildName.find_first_of('.',0);
						if(pos != string::npos)
							node.wstrChildName = node.wstrChildName.substr(0,pos);
					}
				}

			
				node.wstrZoneName = pp[0];
				if(pp[1] != NULL)
				{
					if ( _wcsicmp( pp[0], PVD_DNS_ROOTHINTS) != 0 &&
						 _wcsicmp ( pp[0], PVD_DNS_CACHE ) != 0 ) 
					{
						node.wstrNodeName = pp[1];
					}
				}
				else
				{
					if ( _wcsicmp( pp[0], PVD_DNS_ROOTHINTS) != 0 &&
						 _wcsicmp ( pp[0], PVD_DNS_CACHE ) != 0 )
					{
						node.wstrNodeName = pp[0];
					}
				}

				sc = dns.dnsEnumRecordsForDomainEx(
					node,
					pSqlEval,
					&QueryFilter, 
					bRecursive,
					m_wType,
					DNS_RPC_VIEW_ALL_DATA,
					m_pClass,
					InstanceMgr);

			}
		}
		else
		{
			flag = FALSE;
		}
    }
	return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsresourcerecord.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnsdomain.h
//
//	Implementation File:
//		dnscache.cpp
//
//	Description:
//		Definition of the CDnsDomain class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once


#include "dnsbase.h"
class CObjPath;

class CDnsResourceRecord  : CDnsBase
{
public:
	CDnsResourceRecord();
	CDnsResourceRecord(
		const WCHAR*,
		CWbemServices*, 
		const char*
		);
	~CDnsResourceRecord();
	CDnsResourceRecord(
		WCHAR*, 
		char*);
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;
	SCODE ExecQuery(
	    CSqlEval *          pSqlEval,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pHandler
        );
	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 
	SCODE DeleteInstance(
        CObjPath &          ObjectPath,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pHandler 
		); 

    static CDnsBase* CreateThis(
        const WCHAR *       wszName,         //class name
        CWbemServices *     pNamespace,  //namespace
        const char *        szType         //str type id
        );
    static SCODE InstanceFilter(
	    CDomainNode &       ParentDomain,
	    PVOID               pFilter,
	    CDnsRpcNode *       pNode,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr &  InstMgr
        );
		
	static SCODE GetObjectFilter(
	    CDomainNode &       ParentDomain,
	    PVOID               pFilter,
	    CDnsRpcNode *       pNode,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr &  InstMgr
        );
	static SCODE QueryFilter(
	    CDomainNode &       ParentDomain,
	    PVOID               pFilter,
	    CDnsRpcNode *       pNode,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr &  InstMgr
        );


protected:
	SCODE Modify(
        CObjPath&           objPath,
        IWbemClassObject*   pInArgs,
        IWbemClassObject*   pOutParams,
        IWbemObjectSink*    pHandler
        );

	SCODE CreateInstanceFromText(
	    IWbemClassObject *  pInArgs,
	    IWbemClassObject *  pOutParams,
	    IWbemObjectSink *   pHandler
        );
	SCODE CreateInstanceFromProperty(
	    IWbemClassObject *  pInArgs,
	    IWbemClassObject *  pOutParams,
	    IWbemObjectSink *   pHandler
        );
    SCODE GetObjectFromText(
        IWbemClassObject *  pInArgs,
        IWbemClassObject *  pOutParams,
        IWbemObjectSink *   pHandler
        ) ;
	SCODE GetDomainNameFromZoneAndOwner(
        string & InZone,
        string & InOwner,
        string & OutNode
        ) ;


	wstring m_wstrClassName;
	WORD m_wType;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsprov.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: Dnsprov.cpp
//
//  Description:    
//      Implementation of dll exported functions
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////

#include "DnsWmi.h"

                             
DEFINE_GUID(CLSID_DNS_SERVER,0x62269fec, 0x7b32, 0x11d2, 0x9a, 0xb7,0x00, 0x00, 0xf8, 0x75, 0xc5, 0xd4);
// { 62269fec-7b32-11d2-9ab7-0000f875c5d4 }

//Count number of objects and number of locks.

long            g_cObj=0;
long            g_cLock=0;
HMODULE         ghModule;


extern DWORD        DnsWmiDebugFlag = 0;
extern DWORD        DnsLibDebugFlag = 0;



//***************************************************************************
//
// CompileMofFile
//
// Purpose: Automagically compile the MOF file into the WMI repository.
//
// Return:  S_OK or error if unable to compile or file MOF.
//
//***************************************************************************
static
SCODE
CompileMofFile(
    VOID )
{
    SCODE           sc = S_OK;
    const WCHAR     szMofRelativePath[] = L"\\system32\\wbem\\dnsprov.mof";
    WCHAR           szMofPath[ MAX_PATH + 5 ] = L"";
    IMofCompiler *  pMofComp = NULL;
    HANDLE          h;

    WBEM_COMPILE_STATUS_INFO    Info;

    //
    //  Formulate path of MOF file
    //
       
    if ( GetSystemWindowsDirectoryW(
            szMofPath,
            MAX_PATH - wcslen( szMofRelativePath ) ) == 0 )
    {
        sc = GetLastError();
        goto Done;
    }
    lstrcatW( szMofPath, szMofRelativePath );

    //
    //  Verify that MOF file exists.
    //

    h = CreateFileW(
            szMofPath,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL );
    if ( h == INVALID_HANDLE_VALUE )
    {
        sc = ERROR_FILE_NOT_FOUND;
        goto Done;
    }
    CloseHandle( h );

    //
    //  Load and invoke the MOF compiler.
    //
           
    sc = CoCreateInstance(
            CLSID_MofCompiler,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMofCompiler,
            ( LPVOID * ) &pMofComp );
    if ( FAILED( sc ) )
    {
        goto Done;        
    }
    sc = pMofComp->CompileFile (
                ( LPWSTR ) szMofPath,
                NULL,                   // load into namespace specified in MOF file
                NULL,           // use default User
                NULL,           // use default Authority
                NULL,           // use default Password
                0,              // no options
                0,                              // no class flags
                0,              // no instance flags
                &Info );

    //
    //  Cleanup and return.
    //

    Done:

    if ( pMofComp )
    {
        pMofComp->Release();
    }
    return sc;
}   //  CompileMofFile


//***************************************************************************
//
BOOL 
WINAPI 
DllMain( 
        HANDLE hModule, 
    DWORD  dwReason, 
    LPVOID lpReserved
                                         )
{
    DBG_FN( "DllMain" );

    #if DBG

    DWORD   pid = GetCurrentProcessId();

    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        CHAR    szBase[ MAX_PATH ];
        CHAR    szFlagFile[ MAX_PATH + 50 ];
        CHAR    szLogFile[ MAX_PATH + 50 ];

        //
        //  Initialize debug logging.
        //

        GetWindowsDirectoryA( szBase, sizeof( szBase ) );
        strcat( szBase, DNSWMI_DBG_LOG_DIR );
        strcpy( szFlagFile, szBase );
        strcat( szFlagFile, DNSWMI_DBG_FLAG_FILE_NAME );
        sprintf(
            szLogFile,
            "%s" DNSWMI_DBG_LOG_FILE_BASE_NAME ".%03X.log",
            szBase,
            pid );

        Dns_StartDebug(
            0,
            szFlagFile,
            &DnsWmiDebugFlag,
            szLogFile,
            DNSWMI_DBG_LOG_FILE_WRAP );
        
        //  Turn off dnslib logging except for basic output controls.

        if ( pDnsDebugFlag )
        {
            pDnsDebugFlag = &DnsLibDebugFlag;
            *pDnsDebugFlag = 0x1000000D;
        }

        IF_DEBUG( START_BREAK )
        {
            DebugBreak();
        }
    }

    #endif

    DNS_DEBUG( INIT, (
        "%s: PID %03X reason %d returning TRUE\n", fn, pid, dwReason ));

    return TRUE;
}   //  DllMain


//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    DBG_FN( "DllCanUnloadNow" )

    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;

    DNS_DEBUG( INIT, ( "%s: returning 0x%08x\n", fn, sc ));

    return sc;
}


//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    SCODE   sc = S_OK;
    TCHAR       szID[128];
    WCHAR   wcID[128];
    TCHAR   szCLSID[128];
    TCHAR   szModule[MAX_PATH];
    TCHAR       * pName = TEXT("MS_NT_DNS_PROVIDER");
    TCHAR       * pModel = TEXT("Both");
    HKEY        hKey1, hKey2;

        ghModule = GetModuleHandle(TEXT("Dnsprov"));
    // Create the path.

    StringFromGUID2(
                CLSID_DNS_SERVER, 
                wcID,
                128);
#ifndef UNICODE
    wcstombs(szID, wcID, 128);
#else
        _tcscpy(szID, wcID);
#endif
    lstrcpy(
                szCLSID,
                TEXT("Software\\classes\\CLSID\\")
                );
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(
                HKEY_LOCAL_MACHINE, 
                szCLSID,
                &hKey1);
    RegSetValueEx(
                hKey1, 
                NULL,
                0,
                REG_SZ, 
                (BYTE *)pName, 
                lstrlen(pName)+1
                );
    RegCreateKey(
                hKey1,
                TEXT("InprocServer32"),
                &hKey2);

    GetModuleFileName(
                ghModule, 
                szModule,
                MAX_PATH);
    RegSetValueEx(
                hKey2,
                NULL, 
                0,
                REG_SZ,
                (BYTE *)szModule, 
        lstrlen(szModule)+1);
    RegSetValueEx(
                hKey2, 
                TEXT("ThreadingModel"),
                0,
                REG_SZ, 
        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);

    //
    //  Compile the MOF file. If this fails, it would be good to
    //  tell the admin, but I don't have an easy way to do that.
    //

    CompileMofFile();

    return sc;

}


//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    TCHAR   szID[128];
    WCHAR   wcID[128];
    TCHAR       szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_DNS_SERVER, wcID, 128);
#ifndef UNICODE
    wcstombs(szID, wcID, 128);
#else
        _tcscpy(szID, wcID);
#endif


    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(
                HKEY_LOCAL_MACHINE, 
                szCLSID,
                &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(
                        hKey, 
                        TEXT("InProcServer32"));
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                TEXT("Software\\classes\\CLSID"),
                &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(
                        hKey,
                        szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    DBG_FN( "DllGetClassObject" )

    HRESULT hr;
    CProvFactory *pObj = NULL;

    if ( CLSID_DNS_SERVER != rclsid )
    {
        hr = E_FAIL;
        goto Done;
    }

    pObj = new CProvFactory();
    if ( NULL == pObj )
    {
        hr = E_OUTOFMEMORY;
        goto Done;
    }

    hr = pObj->QueryInterface( riid, ppv );
    if ( FAILED( hr ) )
    {
        delete pObj;
    }

    Done:

    DNS_DEBUG( INIT, ( "%s: returning 0x%08x\n", fn, hr ));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsroothints.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		DnsRootHints.h
//
//	Implementation File:
//		DnsRootHints.cpp
//
//	Description:
//		Definition of the CDnsRootHints class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsbase.h"
class CObjPath;

class CDnsRootHints  : CDnsBase
{
public:
	CDnsRootHints();
	CDnsRootHints(
		const WCHAR*, 
		CWbemServices*);
	~CDnsRootHints();

	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;

	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 
	SCODE DeleteInstance(
        CObjPath &          ObjectPath,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pResponseHandler 
		); 

    static CDnsBase* CreateThis(
        const WCHAR *       wszName,         //class name
        CWbemServices *     pNamespace,  //namespace
        const char *        szType         //str type id
        );


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsroothints.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: Dnsroothints.cpp
//
//  Description:    
//      Implementation of CDnsRootHints class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		create an instance of CDnsRootHints
//
//	Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

CDnsBase* 
CDnsRootHints::CreateThis(
    const WCHAR *       wszName,        
    CWbemServices *     pNamespace,  
    const char *        szType       
    )
{
    return new CDnsRootHints(wszName, pNamespace);
}
CDnsRootHints::CDnsRootHints()
{

}
CDnsRootHints::CDnsRootHints(
	const WCHAR* wszName,
	CWbemServices *pNamespace)
	:CDnsBase(wszName, pNamespace)
{

}

CDnsRootHints::~CDnsRootHints()
{

}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		enum instances of dns roothints
//
//	Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsRootHints::EnumInstance( 
	long lFlags,
	IWbemContext *pCtx,
	IWbemObjectSink FAR* pHandler)
{
	CDnsWrap& dns = CDnsWrap::DnsObject();
	CWbemClassObject InstNew;
	m_pClass->SpawnInstance(0, &InstNew);
	InstNew.SetProperty(
		dns.GetServerName(),
		PVD_DOMAIN_SERVER_NAME);
	InstNew.SetProperty(
		PVD_DNS_ROOTHINTS,
		PVD_DOMAIN_FQDN);
	InstNew.SetProperty(
		PVD_DNS_ROOTHINTS,
		PVD_DOMAIN_CONTAINER_NAME);
	pHandler->Indicate(1, &InstNew);
	return WBEM_S_NO_ERROR;
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		retrieve roothints object pointed by the given object path
//
//	Arguments:
//      ObjectPath          [IN]    object path to object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsRootHints::GetObject(
	CObjPath& ObjectPath,
	long lFlags,
	IWbemContext  *pCtx,
	IWbemObjectSink FAR* pHandler
					)
{
	CDnsWrap& dns = CDnsWrap::DnsObject();
	wstring wstrServer = ObjectPath.GetStringValueForProperty(
		PVD_DOMAIN_SERVER_NAME);
// dww - 6/14/99
// Changed to make see if ValidateServerName does not return WBEM_S_NO_ERROR.
//
	if(WBEM_S_NO_ERROR != dns.ValidateServerName(wstrServer.data()))
    {
		return WBEM_E_FAILED;
    }
	wstring wstrContainer = ObjectPath.GetStringValueForProperty(
			PVD_DOMAIN_CONTAINER_NAME);
	if(_wcsicmp(wstrContainer.data(),
			PVD_DNS_ROOTHINTS) == 0)
	{
		wstring wstrFQDN= ObjectPath.GetStringValueForProperty(
				PVD_DOMAIN_FQDN);
		if(_wcsicmp(wstrFQDN.data(),
				PVD_DNS_ROOTHINTS) == 0)
		{
			// founded
			CWbemClassObject Inst;
			m_pClass->SpawnInstance(0, &Inst);
			Inst.SetProperty(
				dns.GetServerName(),
				PVD_DOMAIN_SERVER_NAME);
			Inst.SetProperty(
				PVD_DNS_ROOTHINTS,
				PVD_DOMAIN_FQDN);
			Inst.SetProperty(
				PVD_DNS_ROOTHINTS,
				PVD_DOMAIN_CONTAINER_NAME);
			pHandler->Indicate(1, &Inst);
		}
	}
	return WBEM_S_NO_ERROR;

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		execute methods defined for roothints class in the mof 
//
//	Arguments:
//      ObjPath             [IN]    pointing to the object that the 
//                                  method should be performed on
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsRootHints::ExecuteMethod(
    CObjPath &          ObjPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler) 
{
	CDnsWrap& dns = CDnsWrap::DnsObject();
	wstring wstrZoneName =  ObjPath.GetStringValueForProperty(
		PVD_DOMAIN_CONTAINER_NAME);
	string strZoneName;
	WcharToString(wstrZoneName.data(), strZoneName);
	SCODE sc;

	if(_wcsicmp(
		wzMethodName,  
		PVD_MTH_RH_WRITEBACKROOTHINTDATAFILE ) == 0)
	{
		return dns.dnsOperation(
			strZoneName,
			CDnsWrap::DNS_WRAP_WRITE_BACK_ZONE);
	}

// dww - 6/14/99
// Added the GetDistinguishedName method in the CDnsDomain class.
//
	else if(_wcsicmp(
		wzMethodName,
		PVD_MTH_ZONE_GETDISTINGUISHEDNAME) == 0)
	{
		wstring wstrName;
		wstring wstrRootHints = PVD_DNS_ROOTHINTS;
		CWbemClassObject OutParams, OutClass, Class ;
		HRESULT hr;
	
		dns.dnsDsZoneName(wstrName, wstrRootHints);


		BSTR ClassName=NULL;
		ClassName = AllocBstr(PVD_CLASS_ROOTHINTS); 
		hr = m_pNamespace->GetObject(ClassName, 0, 0, &Class, NULL);
		SysFreeString(ClassName);
		if ( SUCCEEDED ( hr ) )
		{
			Class.GetMethod(wzMethodName, 0, NULL, &OutClass);
			OutClass.SpawnInstance(0, &OutParams);
			OutParams.SetProperty(wstrName, PVD_DNS_RETURN_VALUE);
			hr = pHandler->Indicate(1, &OutParams);
		}

		return hr;
	}

	return S_OK;
	
}


SCODE CDnsRootHints::PutInstance(
	IWbemClassObject *pInst ,
	long lF,
	IWbemContext* pCtx ,
	IWbemObjectSink *pHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}; 

SCODE CDnsRootHints::DeleteInstance( 
	CObjPath& ObjectPath,
	long lFlags,
	IWbemContext *pCtx,
	IWbemObjectSink *pResponseHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsrpcrecord.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: dnsrpcreocrd.cpp
//
//  Description:    
//      Implementation of dns rpc related class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


// defination for CDnsRpcmemory

CDnsRpcMemory::CDnsRpcMemory()
{

}

CDnsRpcMemory::~CDnsRpcMemory()
{
}

PBYTE 
CDnsRpcMemory::IncrementPtrByNodeHead(PBYTE pByte)
{
        pByte += ((PDNS_RPC_NODE)pByte)->wLength;
        return DNS_NEXT_DWORD_PTR(pByte);
}

PBYTE
CDnsRpcMemory::IncrementPtrByRecord(PBYTE pByte)
{
        pByte += ((PDNS_RPC_RECORD)pByte)->wDataLength
                    + SIZEOF_DNS_RPC_RECORD_HEADER;
        
        return DNS_NEXT_DWORD_PTR(pByte);
}


SCODE 
CDnsRpcRecord::Init(
        string& strOwner,
        string& strRdata,
        DWORD dwTtl
    )
{
    m_dwTtl = dwTtl;
    m_strOwnerName = strOwner;
    
    ParseRdata(strRdata, m_cRdata);
    return BuildRpcRecord(m_cRdata, m_ppRdata+1);
}

SCODE
CDnsRpcRecord::Init(
        wstring&            wstrClass,
        string&             strOwner,
        string&             strRdata,
        CWbemClassObject&   Inst
    )
{
        if(Inst.GetProperty(
                &m_dwTtl,
                PVD_REC_TTL) != S_OK)
                m_dwTtl = 0;
        m_strOwnerName = strOwner;
        if(!strRdata.empty())
        {
                ParseRdata(
                        strRdata, 
                        m_cRdata);
        }

        // what value we got in wmi?
        const WCHAR** ppName = GetRdataName();
   for(int i = 0; i<m_cRdata; i++)
        {
            ReplaceRdata(
            i+1,
            ppName[i],
            Inst);
        }
        return BuildRpcRecord(m_cRdata, m_ppRdata+1);
        
}


CDnsRpcRecord::CDnsRpcRecord(
    WORD wRdataSize)
    :m_pRecord(NULL), 
    m_bRdataChange(FALSE),
    m_cRdata(0)
{
    m_ppRdata = new char* [wRdataSize+1];
    if ( m_ppRdata )
    {
        for(int i=0; i<= wRdataSize; i++)
        {
            m_ppRdata[i] = NULL;
        }
        m_cRdata = wRdataSize;
    }
    else
    {
        m_cRdata = 0;
    }
}


CDnsRpcRecord::~CDnsRpcRecord()
{
    if(m_cRdata > 0)
    {
        for(int i = 0; i<= m_cRdata; i++)
        {
            delete [] m_ppRdata[i];
        }
    }
    delete [] m_ppRdata;
    if ( m_pRecord )
    {
        FREE_HEAP( m_pRecord );
    }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              helper function to arguments from rdata string. each time the function
//      is called, it sets *ppszOut to the newly allocated buffer and copy the 
//      value over, and return a pointer that moved to the char after that rdata
//      argument
//
//      Arguments:
//      pszIn               [IN]    input Rdata string
//      ppszOut             [OUT]   output string which is one of the rdata arg
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

char* 
CDnsRpcRecord::GetNextArg(
        char *  pszIn, 
        char ** ppszOut
    )
{
        if(!pszIn || *pszIn == '\0')
    {
                return NULL;
    }
        char* bin ;
        //ignore leading space
        for(bin = pszIn; *bin == ' '; bin++);
        char* end;
        char delimeter = ' ';
        if( *bin == '\"')
    {
                delimeter = *bin++;
    }
        int length = 1;
        for(end = bin; *end != delimeter && *end != '\0'; end++, length++);
        if(delimeter == '\"')
    {
                end++;  // pass delimeter
    }
        *ppszOut = new char[length];
        strncpy(
                *ppszOut, 
                bin,
                length-1);
        *(*ppszOut+length-1) = '\0';
        return end;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              use data in record to set wbem object
//
//      Arguments:
//      Inst               [IN OUT]    wmi object 
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsRpcRecord::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        Inst.SetProperty(
                (DWORD)1,
                PVD_REC_CLASS);
        Inst.SetProperty(
                GetTtl(),
                PVD_REC_TTL);
        return WBEM_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              creating concrete record type class based on a type value
//
//      Arguments:
//      wType               [IN]    type indicating the type of record
//      pptr                [OUT]   a pointer to base record class.
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsRpcRecord::CreateClass(
        WORD        wType,
        PVOID *     pptr
    )
{

        switch ( wType)
        {
                case DNS_TYPE_ATMA:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcATMA(wType);
                        break;
                case DNS_TYPE_A:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcA(wType);
                        break;
                case DNS_TYPE_SOA:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcSOA(wType);
                        break;
                case DNS_TYPE_PTR:
                case DNS_TYPE_NS:
                case DNS_TYPE_CNAME:
                case DNS_TYPE_MD:
                case DNS_TYPE_MB:
                case DNS_TYPE_MF:
                case DNS_TYPE_MG:
                case DNS_TYPE_MR:

                        *pptr = (CDnsRpcRecord*) new CDnsRpcNS(wType);
                        break;
                case DNS_TYPE_MX:
                case DNS_TYPE_RT:
                case DNS_TYPE_AFSDB:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcMX(wType);
                        break;
                case DNS_TYPE_MINFO:
                case DNS_TYPE_RP:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcMINFO(wType);
                        break;
                case DNS_TYPE_AAAA:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcAAAA(wType);
                        break;
                case DNS_TYPE_HINFO:
                case DNS_TYPE_ISDN:
                case DNS_TYPE_X25:
                case DNS_TYPE_TEXT:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcTXT(wType);
                        break;
                case DNS_TYPE_WKS:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcWKS(wType);
                        break;
                case DNS_TYPE_SRV:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcSRV(wType);
                        break;
                case DNS_TYPE_WINS:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcWINS(wType);
                        break;
                case DNS_TYPE_WINSR:
                        *pptr = (CDnsRpcRecord*) new CDnsRpcWINSR(wType);
                        break;
                default:
                                return WBEM_E_FAILED; 
                }
        
        return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              send the record to dns server to delete or add
//
//      Arguments:
//      szContainerName     [IN]    zone name
//      Type                [IN]    type of action,delete or add
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsRpcRecord::SendToServer(
        const char* szContainerName,
        ActionType Type 
    )
{

        PDNS_RPC_RECORD pRecordToAdd=NULL, pRecordToDelete=NULL;
        if(Type == AddRecord)
    {
                pRecordToAdd = m_pRecord;
    }
        else if(Type == DeleteRecord)
    {
        pRecordToDelete = m_pRecord;
    }
        else
    {
        return WBEM_E_INVALID_PARAMETER;
    }

        int status = DnssrvUpdateRecord(
                PVD_DNS_LOCAL_SERVER,    // server
                szContainerName,                //zone
                m_strOwnerName.data(),  //node
                pRecordToAdd,            // RR to add
                pRecordToDelete
                );
        if ( status != ERROR_SUCCESS )  

    {
                CDnsWrap::DnsObject().ThrowException(status);
    }
        
        // when SOA saved, serial no. automaticly increment by 1
        if(m_wType == DNS_TYPE_SOA && Type == AddRecord)
        {               PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
                pData->SOA.dwSerialNo++;
        }
        return WBEM_S_NO_ERROR;

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              initialize a record based on PDNS_RPC_RECORD
//
//      Arguments:
//      pRecord         [IN]    pointer to a rpc record
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL 
CDnsRpcRecord::Init(
        PDNS_RPC_RECORD pRecord
    )
{
        if(!pRecord)
        {
                return FALSE;
        }
        m_pRecord = pRecord;
        m_wType = pRecord->wType;
        return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              get the type of a record
//
//      Arguments:
//    
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

WORD
CDnsRpcRecord::GetType()
{
        if(m_pRecord==NULL)
    {
        return 0;
    }
        return m_pRecord->wType;
}

DWORD
CDnsRpcRecord::GetTtl()
{
        if(m_pRecord == NULL)
    {
        return 0;
    }
        return m_pRecord->dwTtlSeconds;
}

BOOL 
CDnsRpcRecord::RpcNameCopy(
        wstring&        wstrTarget, 
        PDNS_RPC_NAME   pName
    )
{
        wstrTarget = CharToWstring(
                pName->achName,
                pName->cchNameLength);
        return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              retrieve object path from rpc record
//
//      Arguments:
//      wstrServer      [IN]        dns server name
//      wstrZone        [IN]        dns zone name
//      wstrDomain      [IN]        dns domain name
//      wstrOwner       [IN]        dns owner name
//      objOP           [IN OUT]    objpath to be set
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsRpcRecord::GetObjectPath(
        wstring     wstrServer,
        wstring     wstrZone,
        wstring     wstrDomain,
        wstring     wstrOwner,
        CObjPath&   objOP
    )
{
    objOP.SetClass(m_pwszClassName);
        objOP.AddProperty(
                PVD_REC_RDATA, 
                GetData().data());

        objOP.AddProperty(
                PVD_REC_CLASS, 
                (WORD)1);
                
        objOP.AddProperty(
                        PVD_REC_SERVER_NAME, 
                        wstrServer.data()
                        );
        objOP.AddProperty(
                        PVD_REC_CONTAINER_NAME, 
                        wstrZone.data()
                        );
        objOP.AddProperty(
                        PVD_REC_DOMAIN_NAME, 
                        GetRecDomain(wstrZone, wstrDomain, wstrOwner).data()
                        );
        objOP.AddProperty(
                        PVD_REC_OWNER_NAME, 
                        wstrOwner.data()
                        );
        return WBEM_S_NO_ERROR;
}

wstring 
CDnsRpcRecord::GetTextRepresentation(
        wstring wstrNodeName  // fully qualified 
        )
{
        wstring wstrTxt = GetClass() + L" " + GetTypeString()+ L" ";
        return wstrNodeName + L" " + wstrTxt + GetData();
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              figure out what's domain name and return it
//
//      Arguments:
//    
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

wstring
CDnsRpcRecord::GetRecDomain(
        wstring wstrZone,
        wstring wstrDomain,
        wstring wstrOwner
    )
{
        
        if(!wstrDomain.empty())
        {
                return wstrDomain;
        }
        else if( _wcsicmp( wstrZone.c_str(), wstrOwner.c_str() ) == 0 )
        {
                wstrDomain = wstrZone;
        }
        else 
        {
                int posFirstPeriod = wstrOwner.find_first_of( '.' );
                if( posFirstPeriod == wstring::npos)
                        throw WBEM_E_INVALID_PARAMETER;
                wstrDomain = wstrOwner.substr(
                        posFirstPeriod + 1, 
                        wstrOwner.length() );
                //varify if this is valid domain
                //if(wstrZone.find(wstrDomain, 0) == string::npos)
                //      throw WBEM_E_INVALID_PARAMETER;
        }

        return wstrDomain;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              use the property value from Inst to modify Rdata. pwsz identifies
//      which value in Inst should be used. and wIndex identifies which
//      one in rdata should be replaced.
//
//      Arguments:
//      wIndex      [IN]        index for m_ppRdata
//      pwsz        [IN]        Name for Rdata field
//      Inst        [IN]        wmi object
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////


SCODE 
CDnsRpcRecord::ReplaceRdata(
    WORD                wIndex,   // index for m_ppRdata
    const WCHAR*        pwsz,   // Name for Rdata field
    CWbemClassObject&   Inst 
    )
{
    string str;
    wstring wstr;
    VARIANT v;
    VariantInit(&v);
    try
    {
        Inst.GetProperty(
                &v,
                pwsz);

        switch(v.vt)
        {
        case VT_I4:
            char sz[30];
            _ltoa(v.lVal, sz, 10);
            str = sz;
            break;
        case VT_BSTR:
            WcharToString(v.bstrVal, str);
            break;
        case VT_NULL:
            return WBEM_S_NO_ERROR;
        default:
            throw WBEM_E_INVALID_PARAMETER;
        }

        delete [] m_ppRdata[wIndex];
        m_ppRdata[wIndex] = new char[str.length()+1];
        strcpy(m_ppRdata[wIndex], str.data());
                m_bRdataChange = TRUE;  
        VariantClear(&v);
    }
    catch(...)
    {
        VariantClear(&v);
        throw;
    }

    return WBEM_S_NO_ERROR;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              parse rdata string and save them as an array of string in 
//      member variable m_ppRdata
//
//      Arguments:
//      strRdata    [IN]        rdata string
//      wSize       [IN]        number of arg in rdata
//
//
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsRpcRecord::ParseRdata(
        string& strRdata,
        WORD    wSize
        )
{
    m_ppRdata[0] =  new char[strRdata.length()+1];
    strcpy(m_ppRdata[0], strRdata.data());
    char * bin = m_ppRdata[0];
    for(int i=1; i<=wSize; i++)
    {
        if(bin == NULL || *bin == '\0')
        {
            return WBEM_E_INVALID_PARAMETER;
        }
        bin = GetNextArg(bin , &(m_ppRdata[i]));
    }
    return S_OK;
}

CDnsRpcRecord::RdataIsChanged()
{
        return m_bRdataChange;
}

CDnsRpcSOA::~CDnsRpcSOA()
{
}
CDnsRpcSOA::CDnsRpcSOA(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
        m_pwszClassName = PVD_CLASS_RR_SOA;
}


const 
WCHAR**
CDnsRpcSOA::GetRdataName(void)
{
        static const WCHAR* pwsz[] ={
                PVD_REC_SOA_PRIMARY_SERVER,
                PVD_REC_SOA_RESPONSIBLE,
                PVD_REC_SOA_SERIAL_NUMBER,
                PVD_REC_SOA_REFRESH,
                PVD_REC_SOA_RETRY_DELAY,
                PVD_REC_SOA_EXPIRE_LIMIT,
                PVD_REC_SOA_TTL};
        return pwsz;
}

SCODE 
CDnsRpcSOA::BuildRpcRecord(
                WORD argc, 
                char** argv)
{
    int cLength  = strlen(argv[0]);
    if(*(argv[0]+cLength-1) != '.')
    {
        char * pNew = new char[cLength+2];
        if ( !pNew )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        strcpy(pNew, argv[0]);
        strcat(pNew, ".");
        delete argv[0];
        argv[0] = pNew;
    }
    cLength  = strlen(argv[1]);
    if(*(argv[1]+cLength-1) != '.')
    {
        char * pNew = new char[cLength+2];
        if ( !pNew )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        strcpy(pNew, argv[1]);
        strcat(pNew, ".");
        delete argv[1];
        argv[1] = pNew;
    }
    return CDnsRpcRecord::BuildRpcRecord( argc, argv );
}


DWORD 
CDnsRpcSOA::GetMinimumTtl(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->SOA.dwMinimumTtl;
}

DWORD 
CDnsRpcSOA::GetExpire(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->SOA.dwExpire;
}

DWORD 
CDnsRpcSOA::GetRefresh(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->SOA.dwRefresh;
}

DWORD
CDnsRpcSOA::GetRetry(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->SOA.dwRetry;
}

DWORD 
CDnsRpcSOA::GetSerialNo(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->SOA.dwSerialNo;
}

wstring 
CDnsRpcSOA::GetPrimaryServer(void)
{
        wstring wstrTxt;
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        RpcNameCopy(wstrTxt, &(pData->SOA.namePrimaryServer));
        return wstrTxt;
}

wstring 
CDnsRpcSOA::GetResponsible(void)
{
        wstring wstrTxt;
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        int iLength = pData->SOA.namePrimaryServer.cchNameLength;
        RpcNameCopy(
                wstrTxt, 
                (PDNS_RPC_NAME)(pData->SOA.namePrimaryServer.achName+iLength));
        return wstrTxt;
}

wstring 
CDnsRpcSOA::GetData(void)
{
        char temp[MAX_PATH];
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        sprintf(temp," %lu %lu %lu %lu %lu",
            pData->SOA.dwSerialNo,
            pData->SOA.dwRefresh,
            pData->SOA.dwRetry,
            pData->SOA.dwExpire,
            pData->SOA.dwMinimumTtl );
        return  GetPrimaryServer() +
                        L" " + 
                        GetResponsible()+
                        L" " + 
                        CharToWstring(temp, strlen(temp));

}

SCODE 
CDnsRpcSOA::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        Inst.SetProperty(
                GetExpire(),
                PVD_REC_SOA_EXPIRE_LIMIT);
        Inst.SetProperty(
                GetMinimumTtl(), 
                PVD_REC_SOA_TTL);
        Inst.SetProperty(
                GetRefresh(), 
                PVD_REC_SOA_REFRESH);
        Inst.SetProperty(
                GetRetry(),
                PVD_REC_SOA_RETRY_DELAY);
        Inst.SetProperty(
                GetSerialNo(),
                PVD_REC_SOA_SERIAL_NUMBER);
        Inst.SetProperty(
                GetPrimaryServer(),
                PVD_REC_SOA_PRIMARY_SERVER );
        Inst.SetProperty(
                GetResponsible(),
                PVD_REC_SOA_RESPONSIBLE);
        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}


CDnsRpcA::~CDnsRpcA()
{
}
CDnsRpcA::CDnsRpcA(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)

{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_A;    
}

SCODE
CDnsRpcA::ConvertToWbemObject(
        CWbemClassObject& Inst)
{

        Inst.SetProperty(
                GetIP(), 
                PVD_REC_A_IP);
        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
wstring 
CDnsRpcA::GetIP(void)
{
        char temp[MAX_PATH];
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return IpAddressToString(pData->A.ipAddress);
}
wstring 
CDnsRpcA::GetData(void)
{
        return GetIP();
}

// CDnsRpcNS
CDnsRpcNS::CDnsRpcNS(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    switch (m_wType)
    {
                case DNS_TYPE_PTR:
                        m_pwszClassName = PVD_CLASS_RR_PTR;
                        break;
                case DNS_TYPE_NS:
                        m_pwszClassName = PVD_CLASS_RR_NS;
                        break;
                case DNS_TYPE_CNAME:
                        m_pwszClassName = PVD_CLASS_RR_CNAME;
                        break;
                case DNS_TYPE_MD:
                        m_pwszClassName = PVD_CLASS_RR_MD;
                        break;
                case DNS_TYPE_MB:
                        m_pwszClassName = PVD_CLASS_RR_MB;
                        break;
                case DNS_TYPE_MF:
                        m_pwszClassName =PVD_CLASS_RR_MF;
                        break;
                case DNS_TYPE_MG:
                        m_pwszClassName = PVD_CLASS_RR_MG;
                        break;
                case DNS_TYPE_MR:
                        m_pwszClassName = PVD_CLASS_RR_MR;
                        break;
                default:
            throw WBEM_E_INVALID_PARAMETER;
        }       

}
CDnsRpcNS::~CDnsRpcNS()
{
}       
const 
WCHAR**
CDnsRpcNS::GetRdataName(void)
{
        switch (m_wType)
    {
                case DNS_TYPE_PTR:
                {
                        static const WCHAR* pwszPTR[] =
                        {PVD_REC_PTR_PTRDOMAIN_NAME};
                        return pwszPTR;
                }
                case DNS_TYPE_NS:
                {
                        static const WCHAR* pwszNS[] =
                                {PVD_REC_NS_NSHOST};
                        return pwszNS;
                }
                case DNS_TYPE_CNAME:
                {
                        static const WCHAR* pwszCNAME[] =
                        {PVD_REC_CNAME_PRIMARY_NAME};
                        return pwszCNAME;
                }
                case DNS_TYPE_MD:
                {
                        static const WCHAR* pwszMD[] =
                        {PVD_REC_MD_MDHOST};
                        return pwszMD;
                }
                case DNS_TYPE_MB:
                {
                        static const WCHAR* pwszMB[] =
                                {PVD_REC_MB_MBHOST};
                        return pwszMB;
                }
                case DNS_TYPE_MF:
                {
                        static const WCHAR* pwszMF[] =
                                {PVD_REC_MF_MFHOST};
                        return pwszMF;
                }
                case DNS_TYPE_MG:
                {
                        static const WCHAR* pwszMG[] =
                                {PVD_REC_MG_MGMAILBOX};
                        return pwszMG;
                }
                case DNS_TYPE_MR:
                {
                        static const WCHAR* pwszMR[] =
                                {PVD_REC_MR_MRMAILBOX};
                        return pwszMR;
                }
                default:
            throw WBEM_E_INVALID_PARAMETER;
        }
        return NULL;
}

wstring 
CDnsRpcNS::GetNodeName(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        RpcNameCopy(wstrTxt, &(pData->NS.nameNode));
        return wstrTxt;

}

wstring
CDnsRpcNS::GetRecDomain(
        wstring wstrZone,
        wstring wstrDomain,
        wstring wstrOwner)
{
        
        if(m_wType == DNS_TYPE_NS)
        {
                return wstrOwner;
        }

        return CDnsRpcRecord::GetRecDomain(
                wstrZone,
                wstrDomain,
                wstrOwner);
}

wstring 
CDnsRpcNS::GetData(void)
{
        return GetNodeName();
}

SCODE
CDnsRpcNS::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        const WCHAR** ppName = GetRdataName();
    Inst.SetProperty(
        GetNodeName(),
        ppName[0]);
    Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}

SCODE 
CDnsRpcNS::BuildRpcRecord(
                WORD argc, 
                char** argv)
{
        
        int cLength  = strlen(argv[0]);
        if(*(argv[0]+cLength-1) != '.')
        {
                char * pNew = new char[ cLength + 2 ];
                if ( !pNew )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }
                strcpy(pNew, argv[0]);
                strcat(pNew, ".");
                delete argv[0];
                argv[0] = pNew;
        }
        return CDnsRpcRecord::BuildRpcRecord(
                argc,
                argv);
}

// CDnsRpcMX
CDnsRpcMX::CDnsRpcMX(WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    switch(m_wType)
    {
    case DNS_TYPE_MX:
        m_pwszClassName = PVD_CLASS_RR_MX;
        break;
    case DNS_TYPE_RT:
        m_pwszClassName = PVD_CLASS_RR_RT;
                break;
    case DNS_TYPE_AFSDB:
        m_pwszClassName = PVD_CLASS_RR_AFSDB;
                break;
    default:
        throw WBEM_E_INVALID_PARAMETER;
    }

}
CDnsRpcMX::~CDnsRpcMX()
{
}       

SCODE
CDnsRpcMX::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        const WCHAR** ppName = GetRdataName();
        Inst.SetProperty(
                GetPreference(),
                ppName[0]);

    Inst.SetProperty(
                GetNodeName(), 
                ppName[1]);

    Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
const 
WCHAR**
CDnsRpcMX::GetRdataName(void)
{

    switch(m_wType)
    {
    case DNS_TYPE_MX:
        {
                static const WCHAR* pwszMX[] = 
                {PVD_REC_MX_PREFERENCE,
                PVD_REC_MX_MAIL_EXCHANGE};
                return pwszMX;
        }
    case DNS_TYPE_RT:
        {
                static const WCHAR* pwszRT[] = 
                { PVD_REC_RT_PREFERENCE,
                PVD_REC_RT_HOST};
                return pwszRT;
        }
    case DNS_TYPE_AFSDB:
        {
                static const WCHAR* pwszAFSDB[] = 
                {PVD_REC_AFSBD_SUB_TYPE,
                PVD_REC_AFSBD_SERVER_NAME};
                return pwszAFSDB;
        }
    default:
        throw WBEM_E_INVALID_PARAMETER;
    }
        return NULL;
}

wstring 
CDnsRpcMX::GetNodeName()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        RpcNameCopy(wstrTxt, &(pData->MX.nameExchange));
        return wstrTxt;
}

DWORD
CDnsRpcMX::GetPreference()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->MX.wPreference;
}
wstring 
CDnsRpcMX::GetData(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        WCHAR temp[MAX_PATH];
        swprintf(
                temp, 
                L" %d ", 
                pData->MX.wPreference);
        
        return temp + GetNodeName();
}

CDnsRpcMINFO::CDnsRpcMINFO(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    switch(m_wType)
        {
        case DNS_TYPE_MINFO:
        m_pwszClassName = PVD_CLASS_RR_MINFO;
                break;
        case DNS_TYPE_RP:
        m_pwszClassName = PVD_CLASS_RR_RP;
                break;
        default:
                throw WBEM_E_INVALID_PARAMETER;
        }

}
CDnsRpcMINFO::~CDnsRpcMINFO()
{
}       

SCODE
CDnsRpcMINFO::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        const WCHAR** ppName = GetRdataName();
    Inst.SetProperty(
        GetRPMailBox(),
        ppName[0]);
    Inst.SetProperty(
        GetErrMailBox(),
        ppName[1]);
        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
const 
WCHAR**
CDnsRpcMINFO::GetRdataName(void)
{

    switch(m_wType)
        {
        case DNS_TYPE_MINFO:
        {       static const WCHAR* pwszMINFO[] = 
                {PVD_REC_MINFO_RESP_MAILBOX,
                PVD_REC_MINFO_ERROR_MAILBOX};
                return pwszMINFO;
        }
        case DNS_TYPE_RP:
        {
                static const WCHAR* pwszRP[] = 
        {PVD_REC_RP_RPMAILBOX, 
                PVD_REC_RP_TXT_DOMAIN_NAME};
                return pwszRP;
        }
        default:
                throw WBEM_E_INVALID_PARAMETER;
        }
        return NULL;
}

wstring 
CDnsRpcMINFO::GetRPMailBox()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        RpcNameCopy(
                wstrTxt, 
                &(pData->MINFO.nameMailBox));
        return wstrTxt;

}
wstring 
CDnsRpcMINFO::GetErrMailBox()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        int iLength = pData->MINFO.nameMailBox.cchNameLength;
        RpcNameCopy(
                wstrTxt,
                (PDNS_RPC_NAME)(pData->MINFO.nameMailBox.achName+iLength));
        return wstrTxt;
}

wstring 
CDnsRpcMINFO::GetData(void)
{
        return GetRPMailBox() + L" " + GetErrMailBox();
}

CDnsRpcAAAA::~CDnsRpcAAAA()
{
}
CDnsRpcAAAA::CDnsRpcAAAA(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_AAAA;
}
SCODE
CDnsRpcAAAA::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        Inst.SetProperty(
                GetIP(), 
                PVD_REC_AAAA_IP);
        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}

wstring 
CDnsRpcAAAA::GetData(void)
{
        return GetIP();
}

wstring 
CDnsRpcAAAA::GetIP(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        CHAR    ip6String[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

        Dns_Ip6AddressToString_A(
            ip6String,
            &pData->AAAA.ipv6Address );

        return  CharToWstring( ip6String, strlen(ip6String) );
}

const 
WCHAR**
CDnsRpcAAAA::GetRdataName(void)
{

        static const WCHAR* pwsz[] ={PVD_REC_AAAA_IP};
        return pwsz;
}

// CDnsRpcTXT

CDnsRpcTXT::~CDnsRpcTXT()
{
}
CDnsRpcTXT::CDnsRpcTXT(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA_HINFO)
{
        m_wType = wType;
    switch(m_wType)
    {
    case DNS_TYPE_HINFO:
        m_pwszClassName = PVD_CLASS_RR_HINFO;
                m_cRdata=NUM_OF_ARG_IN_RDATA_HINFO;
        break;
    case DNS_TYPE_ISDN:
        m_pwszClassName = PVD_CLASS_RR_ISDN;
                m_cRdata=NUM_OF_ARG_IN_RDATA_HINFO;
        break;
    case DNS_TYPE_X25:
        m_pwszClassName = PVD_CLASS_RR_X25;
                m_cRdata=NUM_OF_ARG_IN_RDATA_TXT;
                break;
    case DNS_TYPE_TEXT:
        m_pwszClassName = PVD_CLASS_RR_TXT;
                m_cRdata=NUM_OF_ARG_IN_RDATA_TXT;
                break;
    default:
        throw WBEM_E_INVALID_PARAMETER;
    }
}

SCODE
CDnsRpcTXT::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        const WCHAR** ppName = GetRdataName();
    Inst.SetProperty(
                GetString1(), 
                ppName[0]);
        //exception case .num of rdata arg varies depends on type. 
        // handle it.
        if(m_cRdata == 2)
        {
                Inst.SetProperty(
                        GetString2(),
                        ppName[1]);
        }
  Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);


  CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
const 
WCHAR**
CDnsRpcTXT::GetRdataName(void)
{

        switch(m_wType)
    {
    case DNS_TYPE_HINFO:
        {
                static const WCHAR* pwszHINFO[] = 
                {PVD_REC_HINFO_CPU,
                PVD_REC_HINFO_OS};
                return pwszHINFO;
        }
    case DNS_TYPE_ISDN:
        {
                static const WCHAR* pwszISDN[] = 
                { PVD_REC_ISDN_ISDN_NUM,
                PVD_REC_ISDN_SUB_ADDRESS};
                return pwszISDN;
        }
    case DNS_TYPE_X25:
        {
                static const WCHAR* pwszX25[] = 
                {PVD_REC_X25_PSDNADDRESS};
                return pwszX25;
        }
    case DNS_TYPE_TEXT:
        {
                static const WCHAR* pwszTEXT[] = 
                {PVD_REC_TXT_TEXT};
        return pwszTEXT;
        }
    default:
        throw WBEM_E_INVALID_PARAMETER;
    }
        return NULL;
}

wstring
CDnsRpcTXT::GetString1()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        RpcNameCopy(
                wstrTxt, 
                &(pData->TXT.stringData));
        return wstrTxt;

}
wstring
CDnsRpcTXT::GetString2()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        int iLength = pData->TXT.stringData.cchNameLength;
        if( (m_pRecord->wDataLength-1) > iLength)
        {
                RpcNameCopy(
                        wstrTxt,
                        (PDNS_RPC_NAME)(pData->TXT.stringData.achName+iLength));
        }
        return wstrTxt;
}

wstring 
CDnsRpcTXT::GetTextRepresentation(
        wstring wstrNodeName)
{
        wstring wstrTxt = GetClass() + L" " + GetTypeString()+ L" ";
        return wstrNodeName + L" " + wstrTxt + GetData();
}
        

wstring 
CDnsRpcTXT::GetData(void)
{
        wstring wstrTxt = L"\"" + GetString1() + L"\"";
        wstring wstrTxt2 = GetString2();
        if(wstrTxt2.empty())
        {
                return wstrTxt;
        }
        else
                return wstrTxt + L" \""  +wstrTxt2 +L"\"";
}

CDnsRpcWKS::~CDnsRpcWKS()
{
}
CDnsRpcWKS::CDnsRpcWKS(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_WKS;
}

SCODE
CDnsRpcWKS::ConvertToWbemObject(
        CWbemClassObject& Inst)
{

        Inst.SetProperty(
                GetIP(), 
                PVD_REC_WKS_INTERNET_ADDRESS);
        Inst.SetProperty(
                GetIPProtocal(), 
                PVD_REC_WKS_IP_PROTOCOL);
        Inst.SetProperty(
                GetServices(),
                PVD_REC_WKS_BIT_MASK);

        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
const 
WCHAR**
CDnsRpcWKS::GetRdataName(void)
{

        static const WCHAR* pwsz[] ={   
                PVD_REC_WKS_IP_PROTOCOL,
                PVD_REC_WKS_INTERNET_ADDRESS,
                PVD_REC_WKS_BIT_MASK};
        return pwsz;
}wstring 
CDnsRpcWKS::GetIP(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return IpAddressToString(pData->WKS.ipAddress);
}
wstring 
CDnsRpcWKS::GetIPProtocal(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        WSADATA wsaData;
        struct protoent * pProtoent;
        DNS_STATUS status = WSAStartup(
                DNS_WINSOCK_VERSION, 
                &wsaData );
    if ( status == SOCKET_ERROR )
    {
        status = WSAGetLastError();
                CDnsWrap::ThrowException(status);
    }
        // get protocal name
    pProtoent = getprotobynumber( pData->WKS.chProtocol );
    if ( ! pProtoent || pProtoent->p_proto >= MAXUCHAR )
        {
                status = WSAGetLastError();
                CDnsWrap::ThrowException(status);
        }
        return CharToWstring(
                pProtoent->p_name, 
                strlen(pProtoent->p_name));
}
wstring 
CDnsRpcWKS::GetServices(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        char temp[MAX_PATH];
        WORD wLength = m_pRecord->wDataLength -
                sizeof(pData->WKS.ipAddress) - 
                sizeof(pData->WKS.chProtocol)-1;
        UCHAR* p = &pData->WKS.bBitMask[1]; //ignore the first
        for(WORD i=0; i< wLength; i++)
        {
                temp[i] = *p++;
        }
        temp[i]='\0';
        wstring wstr = CharToWstring(temp, wLength);
        if(wstr.find_first_of(L" ") != string::npos)
        { //if string contains space, enclose it in quote
                
                wstr = L"\"" + wstr + L"\"";
        }

        return wstr;
}


wstring 
CDnsRpcWKS::GetData(void)
{
        
        return GetIPProtocal() +L" " + GetIP()+ L" " + GetServices();
}


// CDnsRpcSRV

CDnsRpcSRV::~CDnsRpcSRV()
{
}
CDnsRpcSRV::CDnsRpcSRV(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_SRV;
}

SCODE
CDnsRpcSRV::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        wstring wstrClassName;
        Inst.SetProperty(
                GetPriority(), 
                PVD_REC_SRV_PRIORITY);
        Inst.SetProperty(
                GetWeight(), 
                PVD_REC_SRV_WEIGHT);
        Inst.SetProperty(
                GetPort(), 
                PVD_REC_SRV_PORT);
        
        Inst.SetProperty(
                GetDomainName(), 
                PVD_REC_SRV_DOMAINNAME);
        

        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
const 
WCHAR**
CDnsRpcSRV::GetRdataName(void)
{

        static const WCHAR* pwsz[] ={ 
                PVD_REC_SRV_PRIORITY,
                PVD_REC_SRV_WEIGHT,
                PVD_REC_SRV_PORT,
                PVD_REC_SRV_DOMAINNAME};
        return pwsz;
}

wstring 
CDnsRpcSRV::GetDomainName(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        wstring wstrTxt;
        RpcNameCopy(wstrTxt, &(pData->SRV.nameTarget));
        return wstrTxt;
}

DWORD
CDnsRpcSRV::GetPort()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->SRV.wPort;
}
DWORD
CDnsRpcSRV::GetPriority()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->SRV.wPriority;
}

DWORD
CDnsRpcSRV::GetWeight()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->SRV.wWeight;
}
        

wstring 
CDnsRpcSRV::GetData(void)
{
        WCHAR temp[MAX_PATH];
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        swprintf(temp,
                        L"%d %d %d ",
                        pData->SRV.wPriority,
                        pData->SRV.wWeight,
                        pData->SRV.wPort);
        return temp + GetDomainName();
}


// CDnsRpcWINS

CDnsRpcWINS::~CDnsRpcWINS()
{
}
CDnsRpcWINS::CDnsRpcWINS(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_WINS;
}

SCODE
CDnsRpcWINS::ConvertToWbemObject(
        CWbemClassObject& Inst)
{

        Inst.SetProperty(
                GetCacheTimeOut(), 
                PVD_REC_WINS_CACHE_TIMEOUT);
        Inst.SetProperty(
                GetLookupTimeOut(), 
                PVD_REC_WINS_TIMEOUT);

        Inst.SetProperty(
                GetMapFlag(), 
                PVD_REC_WINS_MAPPING_FLAG );

        Inst.SetProperty(
                GetWinServer(), 
                PVD_REC_WINS_WINS_SERVER);


        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}
const 
WCHAR**
CDnsRpcWINS::GetRdataName(void)
{

        static const WCHAR* pwsz[] ={ 
                PVD_REC_WINS_MAPPING_FLAG,
                PVD_REC_WINS_TIMEOUT,
                PVD_REC_WINS_CACHE_TIMEOUT,
                PVD_REC_WINS_WINS_SERVER};
        return pwsz;
}

SCODE 
CDnsRpcWINS::BuildRpcRecord(
                WORD argc, 
                char** argv)
{
        char* pWinserver = argv[3];

        // if winser string has mutiple server, then change it from 
        // from flat string to array
        int nCount=0;
        char*p = pWinserver;
        while(*p != '\0')
        {
                if(*p != ' ')
                {
                        nCount++;
                        while(*(++p) != ' ' && *p != '\0' );
                }
                else
        {
                        p++;
        }
        }
        if(nCount >1 )
        {
                int nSize = strlen(pWinserver)+1;
                char* pArg = (char*) _alloca(nSize);
                strcpy(pArg, pWinserver);

                // alloc new array
                WORD cNewArray = argc+nCount-1;
                char** pNewArgv = (char**) _alloca(cNewArray*sizeof(char*));
                
                // copy old value first
                for(int i =0; i< argc-1; i++)
                {
                        pNewArgv[i] = (char*) _alloca(sizeof(char) * (strlen(argv[i])+1));
                        strcpy(pNewArgv[i], argv[i]);
                }

                        
                for(; i<cNewArray; i++)
                {
                        if(pArg == NULL || *pArg == '\0')
                                return WBEM_E_INVALID_PARAMETER;
                        pArg = GetNextArg(pArg , &(pNewArgv[i]));
                }
                return CDnsRpcRecord::BuildRpcRecord(cNewArray,
                        pNewArgv);
        }
        return CDnsRpcRecord::BuildRpcRecord(
                argc,
                argv);
}
DWORD
CDnsRpcWINS::GetCacheTimeOut()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->WINS.dwCacheTimeout;
}

DWORD
CDnsRpcWINS::GetLookupTimeOut()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->WINS.dwLookupTimeout;
}

DWORD
CDnsRpcWINS::GetMapFlag()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->WINS.dwMappingFlag;
}

wstring
CDnsRpcWINS::GetWinServer()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        wstring wstrServers;
        for(int i=0; i < pData->WINS.cWinsServerCount; i++)
        {
                wstrServers += IpAddressToString(
                        pData->WINS.aipWinsServers[i]);
                wstrServers +=L" ";
        }
        return L"\"" + wstrServers + L"\"";
}

wstring 
CDnsRpcWINS::GetData(void)
{
        WCHAR temp[MAX_PATH];
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        swprintf(temp,
                        L"%d %d %d ",
                        pData->WINS.dwMappingFlag,
                        pData->WINS.dwLookupTimeout,
                        pData->WINS.dwCacheTimeout);
        return temp + GetWinServer() ;
}

// CDnsRpcWINSR

CDnsRpcWINSR::~CDnsRpcWINSR()
{
}
CDnsRpcWINSR::CDnsRpcWINSR(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_WINSR;
}

SCODE
CDnsRpcWINSR::ConvertToWbemObject(
        CWbemClassObject& Inst)
{

        Inst.SetProperty(
                GetCacheTimeOut(), 
                PVD_REC_WINSR_CACHE_TIMEOUT);
        Inst.SetProperty(
                GetLookupTimeOut(), 
                PVD_REC_WINSR_TIMEOUT);

        Inst.SetProperty(
                GetMapFlag(), 
                PVD_REC_WINSR_MAPPING_FLAG );

        Inst.SetProperty(
                GetResultDomain(), 
                PVD_REC_WINSR_RESULT_DOMAIN);


        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}

const 
WCHAR**
CDnsRpcWINSR::GetRdataName(void)
{

        static const WCHAR* pwsz[] ={ 
                PVD_REC_WINSR_MAPPING_FLAG,
                PVD_REC_WINSR_TIMEOUT,
                PVD_REC_WINSR_CACHE_TIMEOUT,
                PVD_REC_WINSR_RESULT_DOMAIN};
        return pwsz;
}

DWORD
CDnsRpcWINSR::GetCacheTimeOut()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->WINSR.dwCacheTimeout;
}

DWORD
CDnsRpcWINSR::GetLookupTimeOut()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->WINSR.dwLookupTimeout;
}

DWORD
CDnsRpcWINSR::GetMapFlag()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        return pData->WINSR.dwMappingFlag;
}

wstring
CDnsRpcWINSR::GetResultDomain()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);        
        wstring wstrTxt;
        RpcNameCopy(wstrTxt, &(pData->WINSR.nameResultDomain));
        return wstrTxt;
}


wstring 
CDnsRpcWINSR::GetData(void)
{
        WCHAR temp[MAX_PATH];
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        swprintf(temp,
                        L"%d %d %d ",
                        pData->WINSR.dwMappingFlag,
                        pData->WINSR.dwLookupTimeout,
                        pData->WINSR.dwCacheTimeout);
        return temp + GetResultDomain();
}

// CDnsRpcNULL

CDnsRpcNULL::~CDnsRpcNULL()
{
}
CDnsRpcNULL::CDnsRpcNULL(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_NULL;
}
SCODE
CDnsRpcNULL::ConvertToWbemObject(
        CWbemClassObject& Inst)
{
        Inst.SetProperty(
                        GetNullData(), 
                        PVD_REC_NULL_NULLDATA);

        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}

const 
WCHAR**
CDnsRpcNULL::GetRdataName(void)
{
        return NULL;
}

const 
WCHAR**
CDnsRpcA::GetRdataName(void)
{
        static const WCHAR* pwsz[] ={ PVD_REC_A_IP};
        return pwsz;
}

wstring 
CDnsRpcNULL::GetData(void)
{
        return GetNullData();
}

wstring 
CDnsRpcNULL::GetNullData(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        WCHAR temp[1000];
        WCHAR* pos = temp;
        for(int i=0; i < m_pRecord->wDataLength; i++)
        {
                swprintf(pos++,L"%c",pData->Null.bData[i]);
        }
        return temp;
}

SCODE
CDnsRpcNULL::Init(
                wstring& wstrClass,
                string& strOwner, 
                string& strRdata,
                CWbemClassObject& pInst
                )
{
        return WBEM_E_NOT_SUPPORTED;
}
SCODE 
CDnsRpcNULL::Init(
        string& strOwner,
        string& strRdata, 
        DWORD dwTtl)
{
        return WBEM_E_NOT_SUPPORTED;
}


// CDnsRpcATMA

CDnsRpcATMA::~CDnsRpcATMA()
{
}
CDnsRpcATMA::CDnsRpcATMA(
    WORD wType)
    :CDnsRpcRecord(NUM_OF_ARG_IN_RDATA)
{
        m_wType = wType;
    m_pwszClassName = PVD_CLASS_RR_ATMA;
}
SCODE
CDnsRpcATMA::ConvertToWbemObject(
        CWbemClassObject& Inst)
{

    Inst.SetProperty(
                        GetFormat(), 
                        PVD_REC_ATMA_FORMAT);
        Inst.SetProperty(
                GetData(), 
                PVD_REC_RDATA);
        CDnsRpcRecord::ConvertToWbemObject(Inst);
        return WBEM_NO_ERROR;
}


wstring 
CDnsRpcATMA::GetData(void)
{
        WCHAR temp[MAX_PATH];
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        swprintf(temp,
                        L" %d ",
                        pData->ATMA.chFormat);
        return temp + GetAddress();
}

DWORD
CDnsRpcATMA::GetFormat(void)
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        return pData->ATMA.chFormat;
}

wstring
CDnsRpcATMA::GetAddress()
{
        PDNS_RPC_RECORD_DATA pData = &(m_pRecord->Data);
        char temp[MAX_PATH];
        WORD wLength = m_pRecord->wDataLength -
                sizeof(pData->ATMA.chFormat)-1;
        UCHAR* p = &pData->ATMA.bAddress[1]; //ignore the first
        for(WORD i=0; i< wLength; i++)
        {
                temp[i] = *p++;
        }
        temp[i]='\0';
        wstring wstr = CharToWstring(temp, wLength);
        return wstr;
}

const 
WCHAR**
CDnsRpcATMA::GetRdataName(void)
{

        return NULL;
}

SCODE
CDnsRpcATMA::Init(
                wstring& wstrClass,
                string& strOwner, 
                string& strRdata,
                CWbemClassObject& pInst
                )
{
        return WBEM_E_NOT_SUPPORTED;
}
SCODE 
CDnsRpcATMA::Init(
        string& strOwner,
        string& strRdata, 
        DWORD dwTtl)
{
        return WBEM_E_NOT_SUPPORTED;
}




//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsRpcRecordSet::~CDnsRpcRecordSet()
{
        DnssrvFreeRecordsBuffer(m_pbStart);
}
CDnsRpcRecordSet::CDnsRpcRecordSet(
        CDomainNode& DomainNode,
        WORD wType,
        DWORD dwFlag,
        LPCSTR pszFilterStart,
        LPCSTR pszFilterStop
        )
        :m_pbStart(NULL),m_pbCurrent(NULL),m_pbStop(NULL),
        m_pbPrevious(NULL), m_bMoreData(FALSE)
{
        // remember query
        WcharToString(DomainNode.wstrZoneName.data(), m_strZone);
        WcharToString(DomainNode.wstrNodeName.data(), m_strNode);
        WcharToString(DomainNode.wstrChildName.data(), m_strStartChild);
        m_wType = wType;
        m_dwFlag = dwFlag;
        if(pszFilterStart)
                m_strFilterStart = pszFilterStart;
        if(pszFilterStop)
                m_strFilterStop = pszFilterStop;

        // make query 
        GetRecordSet();
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              a helper function when first called, it returns a block of rpc memory
//      of the record set. when more data follows, the next call release this 
//      memory block and then bring in next rpc memory block for the remaining 
//      records
//
//      Arguments:
//      wType               [IN]    type indicating the type of record
//      pptr                [OUT]   a pointer to base record class.
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

void
CDnsRpcRecordSet::GetRecordSet()
{
        DNS_STATUS              status = ERROR_SUCCESS;
    DWORD           dwBufferLength;
    PBYTE           pBuffer;
        WORD wRetryTime=1, wRetryMax=3;
        while(TRUE)
        {
                status = DnssrvEnumRecords(
                        PVD_DNS_LOCAL_SERVER,
                        m_strZone.data(),
                        m_strNode.data(),
                        m_strStartChild.data(),
                        m_wType,
                        m_dwFlag,
                        m_strFilterStart.data(),
                        m_strFilterStop.data(),
                        &dwBufferLength,
                        &pBuffer);
                wRetryTime++;
                if( status == RPC_S_SERVER_TOO_BUSY && wRetryTime <= wRetryMax)
        {
                        Sleep(2000);
        }
                else
        {
            break;
        }
        }
        if( status == ERROR_SUCCESS || status == ERROR_MORE_DATA)
        {
                //let's free the record set
                if(m_pbStart != NULL)
                {
                        DnssrvFreeRecordsBuffer(m_pbStart);
                }
        // set beginning pointer to the rpc buffer
                m_pbStart = pBuffer;
                m_pbStop = m_pbStart + dwBufferLength;
                m_bMoreData = (status == ERROR_MORE_DATA);
        }
    //
    // we don't throw exeception if zone is shutdown.
    //
        else if(status == DNS_ERROR_NAME_DOES_NOT_EXIST)
        {
                DNS_STATUS CheckZoneStatus;
                PDNS_RPC_ZONE_INFO pZoneInfo=NULL;

                CheckZoneStatus = DnssrvGetZoneInfo(
                        PVD_DNS_LOCAL_SERVER,
                        m_strZone.data(),
                        &pZoneInfo );

                BOOL bShutDown=TRUE;
                if( CheckZoneStatus == ERROR_SUCCESS)
                {
                        // if zone is shutdown, ignor this zone, continue with the 
                        // rest zones
                        bShutDown = pZoneInfo->fShutdown;       
                }
        
        

                //clean up
                DnssrvFreeZoneInfo(pZoneInfo);

                if( CheckZoneStatus != ERROR_SUCCESS || bShutDown == FALSE )
                {
                        CDnsWrap::ThrowException(status);
                }


        }
        else
                CDnsWrap::ThrowException(status);
        return;
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              return the next node in the record set
//
//      Arguments:
//      wType               [IN]    type indicating the type of record
//      pptr                [OUT]   a pointer to base record class.
//      Return Value:
//
//--
/////////////////////////////////////////////////////////////////////////////

const 
PDNS_RPC_NODE 
CDnsRpcRecordSet::GetNextNode()
{
        if (m_pbCurrent >= m_pbStop)
    {
                return NULL;
    }
        //return first node if current is NULL
        // otherwise, return the node follows the current
        if (m_pbCurrent == NULL)
        {
                m_pbCurrent = m_pbStart;
        }
        else
        {
                m_pbPrevious = m_pbCurrent;
                m_pbCurrent = IncrementPtrByNodeHead(m_pbCurrent);
                while (m_cRecord -- > 0)
                {
                        m_pbCurrent = IncrementPtrByRecord(m_pbCurrent);
                }
        }
        
        if (m_pbCurrent >= m_pbStop)
        {
                // prepare another query if there are more data
                if(m_bMoreData)
                {
                        PDNS_RPC_NODE pNode = (PDNS_RPC_NODE)m_pbPrevious;
                        WORD wSize = pNode->dnsNodeName.cchNameLength;
                        PCHAR p = new CHAR[wSize+1];
                        if ( !p )
                        {
                            return NULL;
                        }
                        strncpy(p,
                                pNode->dnsNodeName.achName, 
                                wSize);
                        *(p+wSize) = '\0';
                        m_strStartChild = p;
                        delete [] p;
                        // query again
                        GetRecordSet();
                        // skip the first record, since it's the last record in 
            // previous rpc buffer and it's already handled
                        m_pbCurrent = m_pbStart;
                        m_cRecord = ((PDNS_RPC_NODE)m_pbCurrent)->wRecordCount;
                        return GetNextNode();
                }
                else
        {
                        return NULL;
        }
        }
        else
        {
                m_cRecord = ((PDNS_RPC_NODE)m_pbCurrent)->wRecordCount;
                return (PDNS_RPC_NODE) m_pbCurrent;
        }

}

BOOL 
CDnsRpcRecordSet::IsDomainNode()
{
        return (m_cRecord == 0);
}

//class defination for CDnsRpcNode

CDnsRpcNode::~CDnsRpcNode()
{
}
CDnsRpcNode::CDnsRpcNode()
{
}


BOOL 
CDnsRpcNode::Init(
        PDNS_RPC_NODE pNode)
{
        if(!pNode)
    {
                return FALSE;
    }
        m_pNode = pNode;
        m_cRecord = m_pNode->wRecordCount;
        m_Index = 0;
        m_pCurrent = NULL;
        
        PDNS_RPC_NAME pName = &(m_pNode->dnsNodeName);
        m_wstrNodeName = CharToWstring(
                pName->achName, 
                (WORD)pName->cchNameLength);
        return TRUE;
}

BOOL 
CDnsRpcNode::IsDomainNode()
{
        return ( m_cRecord == 0 && m_Index ==0 && !m_wstrNodeName.empty());
        
}
wstring 
CDnsRpcNode::GetNodeName()
{
        return  m_wstrNodeName;
}

CDnsRpcRecord* 
CDnsRpcNode::GetNextRecord()
{
        if(m_cRecord == 0 || m_pNode == NULL)
    {
        return NULL;
    }

        CDnsRpcRecord * pRec = NULL;
        if (m_Index < m_cRecord )
        {
                if(m_Index ++ == 0)
        {
            m_pCurrent = IncrementPtrByNodeHead((PBYTE)m_pNode);
        }
                else
        {
            m_pCurrent = IncrementPtrByRecord((PBYTE) m_pCurrent);
        }
                
                SCODE sc = CDnsRpcRecord::CreateClass(
                        ((PDNS_RPC_RECORD)m_pCurrent)->wType, 
                        (PVOID*) &pRec
                        );
                if ( SUCCEEDED ( sc ) && pRec )
                {
                        pRec->Init( (PDNS_RPC_RECORD)m_pCurrent);
                        return pRec;
                }
                else
        {
                        return NULL;
        }
        }
        else
    {
                return NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//      Description:
//              build a rpc record based on rdata arguments
//
//      Arguments:
//      argc                [IN]    number of argument in argv
//      argv                [IN]    array of string represent 
//
//      Return Value:
//              WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsRpcRecord::BuildRpcRecord(
        WORD    argc, 
        char ** argv)
{

        PDNS_RECORD pdnsRecord;
        pdnsRecord = Dns_RecordBuild_A(
                NULL,           // ptr to RRSet
                (char*) m_strOwnerName.data(), //NULL, //(char*) strFQDN.data(),    // nameOwner
                m_wType,          // RR type in WORD
                TRUE,           // add record
                0,              // S.section
                argc,           // count of strings
                argv                    // strings to fill into RR
                );
    if ( ! pdnsRecord )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //  convert DNS_RECORD to RPC buffer

    m_pRecord = DnsConvertRecordToRpcBuffer( pdnsRecord );
    if ( ! m_pRecord )
    {
        return WBEM_E_FAILED;
    }

        if( m_dwTtl != 0)
        {
                m_pRecord->dwTtlSeconds = m_dwTtl;
                m_pRecord->dwFlags = DNS_RPC_RECORD_FLAG_TTL_CHANGE;
        }
        else
    {
                m_pRecord->dwFlags = DNS_RPC_RECORD_FLAG_DEFAULT_TTL;
    }
        return WBEM_S_NO_ERROR;

}

wstring CDnsRpcRecord::GetTypeString()
{
        if(m_pRecord==NULL)
    {
                return 0;
    }
        PCHAR pszType = Dns_RecordStringForType(m_pRecord->wType );
        return CharToWstring(pszType, strlen(pszType));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsrpcrecord.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		Dnsrpcrecord.h
//
//	Implementation File:
//		Dnsrpcrecord.cpp
//
//	Description:
//		Definition of the dns rpc record related class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsclip.h"
#include "common.h"

#ifndef DNS_WINSOCK2

#define DNS_WINSOCK_VERSION (0x0101)    //  Winsock 1.1

#else   // Winsock2

#define DNS_WINSOCK_VERSION (0x0002)    //  Winsock 2.0

#endif
  
class CDnsRpcRecord ;
class CWbemClassObject;
/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsRpcMemory
//
//	Description:
//      Define common pointer increment operation in memory block that's 
//      returned from dns rpc call
//  
//
//	Inheritance:
//	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsRpcMemory
{
public:
	CDnsRpcMemory();
	virtual ~CDnsRpcMemory();
	PBYTE IncrementPtrByRecord(PBYTE);
	PBYTE IncrementPtrByNodeHead(PBYTE);
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsRpcNode
//
//	Description:
//      represents a dns rpc node structure and related operations
//  
//
//	Inheritance:
//	    CDnsRpcMemory
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsRpcNode : public CDnsRpcMemory
{
public:  
	CDnsRpcNode();
	~CDnsRpcNode();
	BOOL Init(PDNS_RPC_NODE);
	BOOL IsDomainNode();
	CDnsRpcRecord* GetNextRecord();
	wstring GetNodeName();
protected:
	wstring m_wstrNodeName;
	PBYTE m_pCurrent;
	PDNS_RPC_NODE m_pNode;
	WORD m_cRecord;
	WORD m_Index;
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsRpcNode
//
//	Description:
//      base class for all concrete dns record type such A, SOA. defines operation and 
//      data member common to concrete record type
//  
//
//	Inheritance:
//	    CDnsRpcMemory
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsRpcRecord 
{

public:
	enum ActionType               
	{
	   AddRecord,
	   DeleteRecord
	} ;                

    CDnsRpcRecord( WORD wRdataSize );
    virtual ~CDnsRpcRecord();

    wstring GetTypeString();
	BOOL Init(
		PDNS_RPC_RECORD pRecord
		);
	wstring GetClass(
		void
		) {return L"IN";};
	WORD    GetType() ;
	DWORD	GetTtl();
	char* GetNextArg(
	    char *  pszIn, 
	    char ** ppszOut
        );
    static BOOL RpcNameCopy(
	    wstring&        wstrTarget, 
	    PDNS_RPC_NAME   pName
        );
	SCODE SendToServer(
	    const char* szContainerName,
	    ActionType Type 
		);
	BOOL RdataIsChanged();
	virtual SCODE ConvertToWbemObject(
		CWbemClassObject& Inst
		);
	virtual SCODE Init(
		string&, 
		string&,
		DWORD =0
		);
	virtual SCODE Init(
	    wstring&            wstrClass,
	    string&             strOwner,
	    string&             strRdata,
	    CWbemClassObject&   Inst
		);
	virtual SCODE GetObjectPath(
	    wstring     wstrServer,
	    wstring     wstrZone,
	    wstring     wstrDomain,
	    wstring     wstrOwner,
	    CObjPath&   objOP
		);
	virtual wstring GetTextRepresentation(
		wstring wstrNodeName
		);
	virtual wstring GetData(
		void
		) {return L"";};
	static SCODE CreateClass(
	    WORD        wType,
	    PVOID *     pptr
		);

protected:

	virtual const WCHAR** GetRdataName(void){return (const WCHAR**)NULL;};
	SCODE ParseRdata(
	    string& strRdata,
	    WORD    wSize
		);
	virtual SCODE BuildRpcRecord(
        WORD argc, 
        char ** argv
        );
	virtual wstring GetRecDomain(
	    wstring wstrZone,
	    wstring wstrDomain,
	    wstring wstrOwner
        );
    SCODE ReplaceRdata(
        WORD                wIndex,   // index for m_ppRdata
        const WCHAR*        pwsz,   // Name for Rdata field
        CWbemClassObject&   Inst 
        );

	//member data
	BOOL	m_bRdataChange;
	string	m_strOwnerName;		//record owner name
	WORD	m_wType;			// record type
	DWORD	m_dwTtl;			// time to live
    WORD	m_cRdata;
	char**	m_ppRdata;			// Rdata pointer;
    const WCHAR* m_pwszClassName;
    PDNS_RPC_RECORD m_pRecord;	
	
};

/* for record type
	DNS_TYPE_SOA
*/

class CDnsRpcSOA : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 7};
public:
	CDnsRpcSOA(WORD);
	~CDnsRpcSOA();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	DWORD GetSerialNo();
	DWORD GetRefresh();
	DWORD GetRetry();
	DWORD GetExpire();
	DWORD GetMinimumTtl();
	const WCHAR** GetRdataName();
	wstring GetPrimaryServer(void);
	wstring GetResponsible(void);
	SCODE BuildRpcRecord(
		WORD, 
		char** );

};

/* for record type
	DNS_TYPE_A
*/
class CDnsRpcA : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 1};
public:
	~CDnsRpcA();
	CDnsRpcA(WORD);
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	const WCHAR** GetRdataName(void);
	wstring GetIP(void);
}
;

/* for record type
	DNS_TYPE_PTR
    DNS_TYPE_NS
    DNS_TYPE_CNAME
    DNS_TYPE_MD
    DNS_TYPE_MB
    DNS_TYPE_MF
    DNS_TYPE_MG
    DNS_TYPE_MR
*/
class CDnsRpcNS : public  CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 1};
public:
	CDnsRpcNS(WORD);
	~CDnsRpcNS();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	wstring GetNodeName();
	SCODE BuildRpcRecord(
		WORD, 
		char**);
	wstring GetRecDomain(
		wstring ,
		wstring ,
		wstring );
	const WCHAR** GetRdataName();

};

/* for record type
	DNS_TYPE_RT
    DNS_TYPE_AFSDB
*/
class CDnsRpcMX : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 2};
public:

	CDnsRpcMX(WORD);
	~CDnsRpcMX();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	wstring GetNodeName();
	DWORD GetPreference();
	const WCHAR** GetRdataName();

};

/* for record type
	DNS_TYPE_MINFO
    DNS_TYPE_RP

*/
class CDnsRpcMINFO : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 2};
public:
	CDnsRpcMINFO(WORD);
	~CDnsRpcMINFO();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	wstring GetRPMailBox();
	wstring GetErrMailBox();
	const WCHAR** GetRdataName();
};

/* for record type
	DNS_TYPE_AAAA
*/
class CDnsRpcAAAA : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 1};
public:
	CDnsRpcAAAA(WORD);
	~CDnsRpcAAAA();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	wstring GetIP(void);
	const WCHAR** GetRdataName();

};

/* for record type
	DNS_TYPE_HINFO:
	DNS_TYPE_ISDN:
	DNS_TYPE_X25:
	DNS_TYPE_TEXT
*/
class CDnsRpcTXT : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA_TXT=1,
		NUM_OF_ARG_IN_RDATA_HINFO = 2
		};
public:
	CDnsRpcTXT(WORD);
	~CDnsRpcTXT();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetTextRepresentation(
		wstring
		);
	wstring GetData(void);
protected:
	wstring GetString1(void);
	wstring GetString2(void);
	const WCHAR** GetRdataName();
};
/* for record type
	DNS_TYPE_WKS
*/
class CDnsRpcWKS : CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 3};
public:
	CDnsRpcWKS(WORD);
	~CDnsRpcWKS();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	wstring GetIP(void);
	wstring GetIPProtocal(void);
	wstring GetServices(void);
	const WCHAR** GetRdataName();
};

/* for record type
	DNS_TYPE_SRV
*/
class CDnsRpcSRV : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 4};
public:
	CDnsRpcSRV(WORD);
	~CDnsRpcSRV();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	DWORD GetPriority(void);
	DWORD GetWeight(void);
	DWORD GetPort(void);
	wstring GetDomainName(void);
	const WCHAR** GetRdataName();

};

/* for record type
	DNS_TYPE_WINS
*/
class CDnsRpcWINS : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 4};
public:

	CDnsRpcWINS(WORD);
	~CDnsRpcWINS();
	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	DWORD GetMapFlag(void);
	DWORD GetLookupTimeOut(void);
	DWORD GetCacheTimeOut(void);
	wstring GetWinServer(void);
	const WCHAR** GetRdataName();
	SCODE BuildRpcRecord(
		WORD, 
		char**);
};
/* for record type
	DNS_TYPE_WINSR
*/
class CDnsRpcWINSR : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 4};
public:

	CDnsRpcWINSR(WORD);
	~CDnsRpcWINSR();

	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	DWORD GetMapFlag(void);
	DWORD GetLookupTimeOut(void);
	DWORD GetCacheTimeOut(void);
	wstring GetResultDomain(void);
	const WCHAR** GetRdataName();
};

/* DNS_TYPE_NULL
*/
class CDnsRpcNULL: public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 1};
public:
	CDnsRpcNULL(WORD);
	~CDnsRpcNULL();
	SCODE Init(
		string&, 
		string&,
		DWORD 
		);
	SCODE Init(
		wstring&,
		string&, 
		string&,
		CWbemClassObject&
		);

	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);

protected:
	wstring GetNullData(void);
	const WCHAR** GetRdataName();
};

class CDnsRpcATMA : public CDnsRpcRecord
{
	enum{NUM_OF_ARG_IN_RDATA = 2};
public:
	CDnsRpcATMA(WORD);
	~CDnsRpcATMA();
	SCODE Init(
		string&, 
		string&,
		DWORD =0
		);
	SCODE Init(
		wstring&,
		string&, 
		string&,
		CWbemClassObject&
		);

	SCODE ConvertToWbemObject(
		CWbemClassObject&
		);
	wstring GetData(void);
protected:
	DWORD GetFormat(void);
	wstring GetAddress(void);
	const WCHAR** GetRdataName();

};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsRpcNode
//
//	Description:
//      a recordset are collection of records can be returned for a query. 
//      when number of records are too large( eg error more data), mutiple
//      rpc call has to make to bring back all record. this class manage this
//      and retrieve nodes from the set 
//  
//
//	Inheritance:
//	    CDnsRpcMemory
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsRpcRecordSet : public CDnsRpcMemory
{

public:
	BOOL IsDomainNode();
	const PDNS_RPC_NODE GetNextNode();
	CDnsRpcRecordSet(
		CDomainNode&,
		WORD wType,
		DWORD dwFlag,
		LPCSTR pszFilterStart,
		LPCSTR pszFilterStop
		);
	~CDnsRpcRecordSet();

protected:
	void GetRecordSet();
	DWORD	m_cRecord;		//number of records in a node	
	PBYTE	m_pbPrevious;	
	PBYTE	m_pbCurrent;	// current node
	PBYTE	m_pbStop;		// end position
	PBYTE	m_pbStart;		// start position

	string	m_strZone;		
	string	m_strNode;
	string	m_strStartChild;
	string	m_strFilterStart;
	string	m_strFilterStop	;	
	WORD  m_wType;			// record type
	DWORD m_dwFlag;			
	BOOL  m_bMoreData;		//more data indicator
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsstatistics.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnscache.h
//
//	Implementation File:
//		dnscache.cpp
//
//	Description:
//		Definition of the CDnsStatistic class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once


#include "dnsbase.h"

class CObjPath;


/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsStatistic
//
//	Description:
//
//      Class definition for DNS Server statistics
//  
//
//	Inheritance:
//	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsStatistic : CDnsBase
{
public:
	CDnsStatistic();

	CDnsStatistic(
		const WCHAR*, 
		CWbemServices*
        );

	~CDnsStatistic();

	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler
        );

	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;

	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 

	SCODE DeleteInstance(
        CObjPath &          ObjectPath,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pResponseHandler 
		); 

    static CDnsBase * CreateThis(
        const WCHAR *       wszName,
        CWbemServices *     pNamespace,
        const char *        szType
        );
};  //  CDnsStatistic
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnswmi.h ===
/////////////////////////////////////////////////////////////////////////////
//
//      Copyright (c) 1999 Microsoft Corporation
//
//      Module Name:
//              wmi.h
//
//      Description:
//              Pre-compiled header file for DNS WMI provider project
//
//      Author:
//              Jeff Westhead (jwesth)      December 2000
//
//      Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#include "DnsCliP.h"            //  private DNS client header

#include "ntrkcomm.h"

#include <initguid.h>

#include <string>
#include <list>
#include <memory>

#include "ProvFactory.h"
#include "InstanceProv.h"

#include <tchar.h>

#include "common.h"
#include "InstanceProv.h"
#include "Dnsbase.h"
#include "ObjectPath.h"
#include "sql_1.h"
#include "genlex.h"
#include "sqleval.h"
#include "Server.h"
#include "DnsDomain.h"
#include "DnsBase.h"
#include "DnsWrap.h"
#include "DnsCache.h"
#include "Dnsdomain.h"
#include "DnsZone.h"
#include "DnsDomainDomainContainment.h"
#include "DnsDomainResourceRecordContainment.h"
#include "DnsResourceRecord.h"
#include "DnsRootHints.h"
#include "DnsServerDomainContainment.h"
#include "DnsStatistics.h"
#include "DnsRpcRecord.h"

#include <crtdbg.h>
#include <atlbase.h>


//
//  Debug logging
//


extern DWORD        DnsWmiDebugFlag;


#if DBG

#define DNSWMI_DBG_LOG_DIR              "\\system32\\WBEM\\Logs\\"
#define DNSWMI_DBG_FLAG_FILE_NAME       "DnsWmi"
#define DNSWMI_DBG_LOG_FILE_BASE_NAME   "DnsWmi"
#define DNSWMI_DBG_LOG_FILE_WRAP        10000000

#define IF_DEBUG(a)         if ( (DnsWmiDebugFlag & DNS_DEBUG_ ## a) )
#define ELSE_IF_DEBUG(a)    else if ( (DnsWmiDebugFlag & DNS_DEBUG_ ## a) )

#define DNS_DEBUG( _flag_, _print_ )    \
        IF_DEBUG( _flag_ )              \
        {                               \
            (DnsDbg_Printf _print_ );   \
        }

//
//  Debug flags. Some of these flags are shared with DNSRPC.LIB
//

#define DNS_DEBUG_BREAKPOINTS   0x00000001
#define DNS_DEBUG_DEBUGGER      0x00000002
#define DNS_DEBUG_FILE          0x00000004

//  #define DNS_DEBUG_RPC       0x00000100
//  #define DNS_DEBUG_STUB      0x00000100

#define DNS_DEBUG_INIT          0x00000010
#define DNS_DEBUG_INSTPROV      0x00000020

#define DNS_DEBUG_START_BREAK   0x80000000

#define DNS_DEBUG_ALL           0xffffffff
#define DNS_DEBUG_ANY           0xffffffff
#define DNS_DEBUG_OFF           (0)

#else

#define IF_DEBUG(a)                 if (0)
#define ELSE_IF_DEBUG(a)            else if (0)

#define DNS_DEBUG( flag, print )

#endif


//
//  If you like having a local variable in functions to hold the function 
//  name so that you can include it in debug logs without worrying about 
//  changing all the occurences when the function is renamed, use this 
//  at the top of the function:
//      DBG_FN( "MyFunction" )      <--- NOTE: no semi-colon!!
//

#if DBG
#define DBG_FN( funcName ) static const char * fn = (funcName);
#else
#define DBG_FN( funcName )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsserverdomaincontainment.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnsdomanidomaincontainment.h
//
//	Implementation File:
//		dnsdomanidomaincontainment.cpp
//
//	Description:
//		Definition of the CDnsDomainDomainContainment class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsbase.h"
class CObjPath;


class CDnsServerDomainContainment : CDnsBase 
{
public:
	CDnsServerDomainContainment();
	CDnsServerDomainContainment(
		const WCHAR*,
		CWbemServices*
		);
	~CDnsServerDomainContainment();
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;
    static CDnsBase* CreateThis(
        const WCHAR *       wszName,        
        CWbemServices *     pNamespace,  
        const char *        szType       
        );




};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsstatistics.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: DnsStatistics.cpp
//
//  Description:    
//      Implementation of CDnsStatistic class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsBase* 
CDnsStatistic::CreateThis(
    const WCHAR *       wszName,         //class name
    CWbemServices *     pNamespace,  //namespace
    const char *        szType         //str type id
    )
{
    return new CDnsStatistic(wszName, pNamespace);
}

CDnsStatistic::CDnsStatistic()
{
}

CDnsStatistic::CDnsStatistic(
    const WCHAR* wszName,
    CWbemServices *pNamespace ) :
    CDnsBase( wszName, pNamespace )
{
}

CDnsStatistic::~CDnsStatistic()
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    CDnsStatistic::EnumInstance
//
//    Description:
//        Enum instances of statistics
//
//    Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsStatistic::EnumInstance(
    long                lFlags,
    IWbemContext *      pCtx,
    IWbemObjectSink *   pHandler )
{
    SCODE       sc = S_OK;

    CDnsWrap & dns = CDnsWrap::DnsObject();

    sc = dns.dnsGetStatistics( m_pClass, pHandler );

    return sc;
}   //  CDnsStatistic::EnumInstance


/////////////////////////////////////////////////////////////////////////////
//++
//
//    CDnsStatistic::GetObject
//
//    Description:
//        retrieve cache object based given object path
//
//    Arguments:
//      ObjectPath          [IN]    object path to cluster object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsStatistic::GetObject(
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext  *     pCtx,
    IWbemObjectSink *   pHandler)
{
    return WBEM_E_NOT_SUPPORTED;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    CDnsStatistic::ExecuteMethod
//
//    Description:
//        execute methods defined for cache class in the mof 
//
//    Arguments:
//      ObjectPath          [IN]    object path to cluster object
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsStatistic::ExecuteMethod(
    CObjPath &          objPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler) 
{
    return WBEM_E_NOT_SUPPORTED;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    CDnsStatistic::PutInstance
//
//    Description:
//        save this instance
//
//    Arguments:
//      InstToPut           [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_E_NOT_SUPPORTED
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsStatistic::PutInstance(
    IWbemClassObject *  pInst ,
    long                lFlags,
    IWbemContext*       pCtx ,
    IWbemObjectSink *   pHandler)
{
    return WBEM_E_NOT_SUPPORTED;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    CDnsStatistic::DeleteInstance
//
//    Description:
//        delete the object specified in rObjPath
//
//    Arguments:
//      rObjPath            [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_E_NOT_SUPPORTED
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsStatistic::DeleteInstance( 
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext *      pCtx,
    IWbemObjectSink *   pResponseHandler )
{
    return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnswrap.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: DnsWrap.cpp
//
//  Description:    
//      Implementation of dnswrap class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//
//  These string tables are in client\print.c
//

extern "C" LPSTR   MemTagStringsNT5[];
extern "C" LPSTR   MemTagStrings[];


//
//  These macros allow us to widen DNS RPC string constants.
//

#define MYTEXT2(str)     L##str
#define MYTEXT(str)      MYTEXT2(str)


//
//  Globals for statistics.
//

struct
{
    DWORD                   dwStatId;
    const WCHAR *           pszName;
} g_StatInfo[] =
{
    {   DNSSRV_STATID_TIME,             L"Time Stats" },
    {   DNSSRV_STATID_QUERY,            L"Query and Response Stats" },
    {   DNSSRV_STATID_QUERY2,           L"Query Stats" },
    {   DNSSRV_STATID_RECURSE,          L"Recursion Stats" },
    {   DNSSRV_STATID_MASTER,           L"Master Stats" },
    {   DNSSRV_STATID_SECONDARY,        L"Secondary Stats" },
    {   DNSSRV_STATID_WINS,             L"WINS Referral Stats" },
    {   DNSSRV_STATID_WIRE_UPDATE,      L"Packet Dynamic Update Stats" },
    {   DNSSRV_STATID_SKWANSEC,         L"SkwanSec Stats" },
    {   DNSSRV_STATID_DS,               L"DS Integration Stats" },
    {   DNSSRV_STATID_NONWIRE_UPDATE,   L"Internal Dynamic Update Stats" },
    {   DNSSRV_STATID_MEMORY,           L"Memory Stats" },
    {   DNSSRV_STATID_DBASE,            L"Database Stats" },
    {   DNSSRV_STATID_RECORD,           L"Record Stats" },
    {   DNSSRV_STATID_PACKET,           L"Packet Memory Usage Stats" },
    {   DNSSRV_STATID_NBSTAT,           L"Nbstat Memory Usage Stats" },
    {   DNSSRV_STATID_ERRORS,           L"Error Stats" },
    {   DNSSRV_STATID_TIMEOUT,          L"Timeout Stats" },
    {   DNSSRV_STATID_CACHE,            L"Query" },
    {   DNSSRV_STATID_PRIVATE,          L"Private Stats" },
    {   0,                              NULL }              //  terminator
};


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CDnsWrap::CDnsWrap()
:m_wszpServerName(NULL)
{
    CServerInfo serverInfo;
    PDNS_RPC_SERVER_INFO pdata = (PDNS_RPC_SERVER_INFO) serverInfo.m_pInfo;
    char* p = pdata->pszServerName;
    CharToWchar(p, &m_wszpServerName);

    
}

CDnsWrap::~CDnsWrap()
{
    delete [] m_wszpServerName;
}

CDnsWrap::CServerInfo::CServerInfo()
:m_pInfo(NULL)
{
    DWORD       dwtypeid;
    int status = DnssrvQuery(
        PVD_DNS_LOCAL_SERVER, 
        NULL,
        DNSSRV_QUERY_SERVER_INFO,
        &dwtypeid,
        &m_pInfo);
    
    if(status != ERROR_SUCCESS)
        ThrowException(status);
}
CDnsWrap::CServerInfo::~CServerInfo()
{
    DnssrvFreeServerInfo((PDNS_RPC_SERVER_INFO)m_pInfo);
}

CDnsWrap& CDnsWrap::DnsObject(void)
{
    static CDnsWrap dns;
    return dns;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enumerates record for a give domain. If bRecursive is true, enum all 
//      records including subdomain, otherwise, enum records directly under
//      the domain. It also take a call back function pFilter to allow
//      further filtering the records 
//
//    Arguments:
//      objNode             [IN ]   list of domains
//      pFilter             [IN]    pointer a class contains the criteria
//                                  on how to filter records
//        pfFilter            [IN]    call back function allows further 
//                                  processing of records using pFilter
//      bRecursive          [IN]    true for deep enum, otherwise false
//      wType,              [IN]    type of records to enum
//      dwFlag,             [IN]    flag
//      pClass,             [IN]    wmi class for the type of records to enum
//      InstMgr             [IN]    manage wmi object and send them wmi

//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsWrap::dnsEnumRecordsForDomainEx(    
    CDomainNode&        objNode,
    PVOID                pFilter,
    FILTER              pfFilter,
    BOOL                bRecursive,
    WORD                wType,
    DWORD               dwFlag,
    IWbemClassObject *  pClass,
    CWbemInstanceMgr&   InstMgr
    )
{
    
    CDnsRpcRecordSet RecordSet(
            objNode,
            wType,
            dwFlag,
            NULL,
            NULL);
    PDNS_RPC_NODE pNode=NULL;
    WCHAR DomainName[MAX_PATH] = L"";
    while (( pNode = RecordSet.GetNextNode()) != NULL)
    {
        CDnsRpcNode dnsNode;
        CObjPath opNew;
        if( !dnsNode.Init(pNode))
        {
                return WBEM_E_FAILED;
        }
        //find record node
        if(dnsNode.IsDomainNode())
        {
            
            // get domain name
            wstring wstrSubDomainName = dnsNode.GetNodeName();;
            wstrSubDomainName += PVD_DNS_LOCAL_SERVER + objNode.wstrNodeName;
            CDomainNode subDomain = objNode;
            subDomain.wstrNodeName = wstrSubDomainName;

            //recursion
            if(bRecursive)
            {

                dnsEnumRecordsForDomainEx(
                    subDomain,
                    pFilter, 
                    pfFilter,
                    bRecursive,
                    wType,
                    dwFlag,
                    pClass,
                    InstMgr);
                    
            }
        }

        pfFilter(
            objNode, 
            pFilter, 
            &dnsNode,  
            pClass, 
            InstMgr);
            

        }
                
    return WBEM_S_NO_ERROR;
}

SCODE 
CDnsWrap::dnsGetDomain(
    CObjPath&           objParent,
    IWbemClassObject*   pClass,
    IWbemObjectSink*    pHandler
    )
{

    // get top level domain
    wstring wstrZoneName = objParent.GetStringValueForProperty(
        PVD_DOMAIN_CONTAINER_NAME);
    wstring wstrNodeName = objParent.GetStringValueForProperty(
        PVD_DOMAIN_FQDN);
    list<CDomainNode> nodeList;
    dnsEnumDomainForServer(&nodeList);
    list<CDomainNode>::iterator i;
    BOOL FoundFlag = FALSE;
    // check for zone
    for(i=nodeList.begin(); i != nodeList.end(); ++i)
    {
        if(_wcsicmp(
            wstrZoneName.data(),
            i->wstrZoneName.data()) == 0 )
        {
            // only roothints and catch, NodeName is initialize to
            // nil, we can't do the compare 
            if(i->wstrNodeName.empty() ||
                (_wcsicmp(
                wstrNodeName.data(), 
                i->wstrNodeName.data())==0))
            {
                FoundFlag = TRUE;
                break;
            }
        }
    }


    // check for domain in container
    if(! FoundFlag)
    {
        DNS_STATUS status ;
        char    *pszZoneName=NULL, *pszNodeName=NULL, *pszStartChild=NULL;
        DWORD   dwBufferLength;
        PBYTE       pBuffer = NULL;
    

        WcharToChar(wstrZoneName.data(), &pszZoneName);
        WcharToChar(wstrNodeName.data(), &pszNodeName);

        status = DnssrvEnumRecords(
            PVD_DNS_LOCAL_SERVER,
            pszZoneName,
            pszNodeName,
            pszStartChild,
            DNS_TYPE_ALL,
            DNS_RPC_VIEW_ALL_DATA,
            NULL,
            NULL,
            & dwBufferLength,
            & pBuffer);
        delete [] pszNodeName;
        delete [] pszZoneName;
        DnssrvFreeRecordsBuffer(pBuffer);

        if (status != ERROR_SUCCESS)
            ThrowException(status);
        FoundFlag = TRUE;
    }

    if(FoundFlag)
    {

        CWbemClassObject Inst;
        pClass->SpawnInstance(0, &Inst);
        Inst.SetProperty(
            wstrNodeName, 
            PVD_DOMAIN_FQDN);
        Inst.SetProperty(
            wstrZoneName, 
            PVD_DOMAIN_CONTAINER_NAME);
        Inst.SetProperty(
            m_wszpServerName,
            PVD_DOMAIN_SERVER_NAME);

        // clean up
        pHandler->Indicate(1, &Inst);
    }

    return WBEM_S_NO_ERROR;

}
SCODE 
CDnsWrap::dnsDeleteDomain(
    char *  pszContainer, 
    char *  pszDomain
    )
{
     LONG status = DnssrvDeleteNode(
        PVD_DNS_LOCAL_SERVER,
        pszContainer,
        pszDomain,
        1 //fDeleteSubtree
        );
    if ( status != ERROR_SUCCESS )
    {
        ThrowException(status);
    }
    return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enumeratr all zones including cache for local dns server, returns
//      them as a list of object path
//
//    Arguments:
//      pList               [IN OUT]    list of object path to domains
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsWrap::dnsEnumDomainForServer(
    list<CObjPath>* pList
    )
{

    PDNS_RPC_ZONE_LIST  pZoneList = NULL;
    DNS_STATUS status = DnssrvEnumZones(
        PVD_DNS_LOCAL_SERVER,
        ZONE_REQUEST_ALL_ZONES_AND_CACHE,
        NULL,
        &pZoneList);

    if(status == ERROR_SUCCESS)
    {
        DNS_RPC_ZONE* pDnsZone = NULL;
        CDnsWrap& dns = CDnsWrap::DnsObject();
        for(DWORD i = 0; i < pZoneList->dwZoneCount; i++)
        {
            pDnsZone = (pZoneList->ZoneArray[i]);
            if(_wcsicmp(pDnsZone->pszZoneName, PVD_DNS_LOCAL_SERVER))
            {
                CObjPath opInst;
                opInst.SetClass(PVD_CLASS_DOMAIN);
                opInst.AddProperty(
                    PVD_DOMAIN_SERVER_NAME ,
                    dns.GetServerName().data()
                    );
                opInst.AddProperty(
                    PVD_DOMAIN_CONTAINER_NAME, 
                    pDnsZone->pszZoneName
                    );
                opInst.AddProperty(
                    PVD_DOMAIN_FQDN, 
                    pDnsZone->pszZoneName
                    );
            
                pList->insert(
                    pList->end(),
                    opInst);
            }
        }
        
        // add catch domain
        CObjPath opCache;
        opCache.SetClass(PVD_CLASS_DOMAIN);
        opCache.AddProperty(
            PVD_DOMAIN_SERVER_NAME,
            dns.GetServerName().data()
            );
        opCache.AddProperty(
            PVD_DOMAIN_CONTAINER_NAME,
            PVD_DNS_CACHE
            );
        opCache.AddProperty(
            PVD_DOMAIN_FQDN,
            PVD_DNS_CACHE
            );

        //add roothints 
        CObjPath opRh;
        opRh.SetClass(PVD_CLASS_DOMAIN);
        opRh.AddProperty(
            PVD_DOMAIN_SERVER_NAME, 
            dns.GetServerName().data()
            );
        opRh.AddProperty(
            PVD_DOMAIN_CONTAINER_NAME, 
            PVD_DNS_ROOTHINTS
            );
        opRh.AddProperty(
            PVD_DOMAIN_FQDN, 
            PVD_DNS_ROOTHINTS
            );

        pList->insert(pList->begin(), opRh);    
        pList->insert(pList->begin(), opCache);    
    }

    // CLEAN UP
    DnssrvFreeZoneList(pZoneList);
    
    if(status != ERROR_SUCCESS)
    {
        ThrowException(status);
    }

    return WBEM_S_NO_ERROR;

}
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enumeratr all zones including cache for local dns server, returns
//      them as a list of domain node
//
//    Arguments:
//      pList               [IN OUT]    list of domains
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE CDnsWrap::dnsEnumDomainForServer(
    list<CDomainNode>* pList
    )
{

    PDNS_RPC_ZONE_LIST  pZoneList = NULL;
    LONG status = DnssrvEnumZones(
        PVD_DNS_LOCAL_SERVER,
        ZONE_REQUEST_ALL_ZONES_AND_CACHE,
        NULL,
        &pZoneList);

    DNS_RPC_ZONE * pDnsZone = NULL;
    if( status == ERROR_SUCCESS && pZoneList )
    {

        for(DWORD i = 0; i < pZoneList->dwZoneCount; i++)
        {
            pDnsZone = (pZoneList->ZoneArray[i]);
            if(_wcsicmp(pDnsZone->pszZoneName, L"."))
            {
                CDomainNode objNode;
                objNode.wstrNodeName = pDnsZone->pszZoneName;
                objNode.wstrZoneName = pDnsZone->pszZoneName;
                pList->insert(pList->end(), objNode);
            }
        }
        
        // add catch domain
        CDomainNode nodeCache;

        nodeCache.wstrZoneName = PVD_DNS_CACHE;
        //add roothints 
        CDomainNode nodeRH;
        nodeRH.wstrZoneName = PVD_DNS_ROOTHINTS;
        

        pList->insert(pList->begin(), nodeCache);    
        pList->insert(pList->begin(), nodeRH);    
    
    }

    // CLEAN UP
    DnssrvFreeZoneList(pZoneList);
    
    if (status != ERROR_SUCCESS)
    {
        ThrowException(status);
    }

    return WBEM_S_NO_ERROR;

}


SCODE 
CDnsWrap::ValidateServerName(
    const WCHAR* pwzStr)
{
    if(_wcsicmp(pwzStr, PVD_DNS_LOCAL_SERVER))
        if(_wcsicmp(pwzStr, L"127.0.0.1"))
            if(_wcsicmp(pwzStr, m_wszpServerName) )
                return WBEM_E_INVALID_PARAMETER;

    return WBEM_S_NO_ERROR;
}
SCODE 
CDnsWrap::dnsQueryServerInfo(
    const WCHAR*        strServerName,
    CWbemClassObject&   NewInst,
    IWbemObjectSink*    pHandler
    )
{
        // get dnsserver
    DWORD       dwtypeid;
    PVOID       pdata=NULL;
    DNS_STATUS  status;
    PDNS_RPC_SERVER_INFO pServerInfo = NULL;

// dww - 6/14/99
// Changed to make see if ValidateServerName does not return WBEM_S_NO_ERROR.
//
    if(WBEM_S_NO_ERROR != ValidateServerName(strServerName))
        return WBEM_E_INVALID_PARAMETER;

    status = DnssrvQuery(
        strServerName, 
        NULL,
        DNSSRV_QUERY_SERVER_INFO,
        &dwtypeid,
        &pdata);
    
    if( status == ERROR_SUCCESS)
    {
        pServerInfo = (PDNS_RPC_SERVER_INFO) pdata;
        NewInst.SetProperty(
            pServerInfo->dwVersion, 
            PVD_SRV_VERSION);
        NewInst.SetProperty(
            pServerInfo->fDsAvailable,
            PVD_SRV_DS_AVAILABLE);
        // ListenAddress array
        if(pServerInfo->aipListenAddrs)
        {
            NewInst.SetProperty(
                pServerInfo->aipListenAddrs->AddrArray,
                pServerInfo->aipListenAddrs->AddrCount,
                MYTEXT( DNS_REGKEY_LISTEN_ADDRESSES ) );
        }
        if(pServerInfo->aipForwarders)
        {
            NewInst.SetProperty(
                pServerInfo->aipForwarders->AddrArray,
                pServerInfo->aipForwarders->AddrCount,
                MYTEXT( DNS_REGKEY_FORWARDERS ) );
        }
        
        if(pServerInfo->aipServerAddrs)
        {
            NewInst.SetProperty(
                pServerInfo->aipServerAddrs->AddrArray,
                pServerInfo->aipServerAddrs->AddrCount,
                PVD_SRV_SERVER_IP_ADDRESSES_ARRAY);
        }
    }

    DnssrvFreeServerInfo(pServerInfo);

    if ( status != ERROR_SUCCESS )
    {
        ThrowException(status);
    }


    return ERROR_SUCCESS;
}

SCODE 
CDnsWrap::dnsRestartServer(
    WCHAR* strServerName
    )
{
    
    LONG status =  DnssrvOperation(
        strServerName,
        NULL,
        DNSSRV_OP_RESTART,
        DNSSRV_TYPEID_NULL,
        NULL );
    if(status != ERROR_SUCCESS)
    {
        ThrowException(status);
    }
    return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        using property value from wmi instance to set dns server property
//
//    Arguments:
//      Inst                [IN]   wmi instance whose property value
//                                 to be sent to dns server
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
    
SCODE
CDnsWrap::dnsServerPropertySet(
    CWbemClassObject&   Inst,
    BOOL                bGet
    )
{
    DBG_FN( "CDnsWrap::dnsServerPropertySet" )

    //
    // get mapping table
    //
    DWORD cNumOfEntries;
    PropertyTable* pt = (PropertyTable*)GetPropertyTable(&cNumOfEntries);

    for(int i=0; i<cNumOfEntries; i++)
    {
        FPDNSOPS fp;
        fp = pt[i].fpOperationSet;
        if(fp != NULL)
        {    
            DNS_DEBUG( INSTPROV, (
                "%s: Inst=%p prop=%S\n", fn,
                &Inst,
                pt[i].pwzProperty ));

            // set dns server property 
            fp(
                NULL,
                pt[i].pwzProperty,
                pt[i].OperationName,
                Inst);
        }

    }

    return S_OK;
}

// dww - 6/14/99
// Added the dnsDsServerName method in the CDnsWrap class.
//
SCODE
CDnsWrap::dnsDsServerName(
    wstring& wstrDsName)
{

    CServerInfo serverInfo;
    LPWSTR pwsz = DnssrvCreateDsServerName(
            (PDNS_RPC_SERVER_INFO)serverInfo.m_pInfo);
    if(pwsz)
        wstrDsName = pwsz;
    FREE_HEAP(pwsz);

    return WBEM_S_NO_ERROR;
}

// dww - 6/14/99
// Added the dnsDsZoneName method in the CDnsWrap class.
//
SCODE
CDnsWrap::dnsDsZoneName(
    wstring& wstrDsName,
    wstring& wstrInZone
    )
{
    CServerInfo serverInfo;
    LPWSTR pwsz = DnssrvCreateDsZoneName(
            (PDNS_RPC_SERVER_INFO)serverInfo.m_pInfo,
            (LPWSTR)wstrInZone.data());
    if(pwsz)
        wstrDsName = pwsz;
    FREE_HEAP(pwsz);

    return WBEM_S_NO_ERROR;
}

// dww - 6/14/99
// Added the dnsDsNodeName method in the CDnsWrap class.
//
SCODE
CDnsWrap::dnsDsNodeName(
    wstring&    wstrDsName,
    wstring&    wstrInZone,
    wstring&    wstrInNode
    )
{
    CServerInfo serverInfo;
    LPWSTR pwsz = DnssrvCreateDsNodeName(
            (PDNS_RPC_SERVER_INFO)serverInfo.m_pInfo,
            (LPWSTR)wstrInZone.data(),
            (LPWSTR)wstrInNode.data());
    if(pwsz)
        wstrDsName = pwsz;
    FREE_HEAP(pwsz);

    return WBEM_S_NO_ERROR;
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        retrive dns server property and output to wmi instance
//
//    Arguments:
//      Inst                [IN OUT]   wmi instance to receive property value
//                                      got from dns server
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsWrap::dnsServerPropertyGet(
    CWbemClassObject&   Inst,
    BOOL                bGet
    )
{
    //
    // get maping table
    //
    DWORD cNumOfEntries;
    PropertyTable* pt = (PropertyTable*)GetPropertyTable(&cNumOfEntries);

    // set array and name property
    dnsQueryServerInfo(
        PVD_DNS_LOCAL_SERVER,
        Inst,
        NULL);
    for(int i=0; i<cNumOfEntries; i++)
    {
        FPDNSOPS fp;
        fp = pt[i].fpOperationGet;
        if(fp != NULL)
        {    //
            // get property from dns, and set wmi property
            //
            fp(
                NULL,
                pt[i].pwzProperty,
                pt[i].OperationName,
                Inst);
        }
    }

    //
    //  Hard-code the Status property to OK.
    //

    Inst.SetProperty( L"OK", L"Status" );

    return S_OK;
}


/*---------------------------------------------------------------------------
*/
SCODE 
CDnsWrap::dnsGetDwordProperty(
    const char *        pszZoneName,
    const WCHAR*        wszWbemProperty, 
    const char*         pszOperationName,
    CWbemClassObject&   Inst
    )
{
    DWORD dwValue;
    DNS_STATUS status = DnssrvQueryDwordProperty(
        PVD_DNS_LOCAL_SERVER,
        pszZoneName,
        pszOperationName,
        &dwValue);
    
    if(status != ERROR_SUCCESS)
            ThrowException(status);
    
    Inst.SetProperty(
        dwValue,
        (WCHAR*)wszWbemProperty);

    return WBEM_S_NO_ERROR;
}


/*---------------------------------------------------------------------------
*/
SCODE 
CDnsWrap::dnsSetDwordProperty(
    const char *        pszZoneName,
    const WCHAR*        wszWbemProperty, 
    const char*         pszOperationName,
    CWbemClassObject&   Inst
    )
{
    
    DWORD dwValue;
    if(Inst.GetProperty(
        &dwValue,
        (WCHAR*)wszWbemProperty) == S_OK)
    {

        DNS_RPC_NAME_AND_PARAM  param;
        param.dwParam = dwValue;
        param.pszNodeName = (LPSTR) pszOperationName;

        DNS_STATUS status = DnssrvOperation(
            PVD_DNS_LOCAL_SERVER,
            pszZoneName,
            DNSSRV_OP_RESET_DWORD_PROPERTY,
            DNSSRV_TYPEID_NAME_AND_PARAM,
            & param );
    
        if(status != ERROR_SUCCESS)
            ThrowException(status);
    }

    return WBEM_S_NO_ERROR;
}


/*---------------------------------------------------------------------------
*/
SCODE 
CDnsWrap::dnsGetStringProperty(
    const char *        pszZoneName,
    const WCHAR *       wszWbemProperty, 
    const char *        pszDnssrvPropertyName,
    CWbemClassObject&   Inst
    )
{
    DWORD       dataType;
    PVOID       pdata;

    DNS_STATUS status = DnssrvQuery(
                            PVD_DNS_LOCAL_SERVER,
                            pszZoneName,
                            pszDnssrvPropertyName,
                            &dataType,
                            &pdata );
    if( status != ERROR_SUCCESS )
    {
        ThrowException( status );
    }
    if ( dataType != DNSSRV_TYPEID_LPWSTR )
    {
        ThrowException( WBEM_E_TYPE_MISMATCH );
    }
    
    Inst.SetProperty(
        ( PWSTR ) pdata,
        ( PWCHAR ) wszWbemProperty);
    return WBEM_S_NO_ERROR;
}


/*---------------------------------------------------------------------------
*/
SCODE 
CDnsWrap::dnsSetStringProperty(
    const char *        pszZoneName,
    const WCHAR *       wszWbemProperty, 
    const char *        pszDnssrvPropertyName,
    CWbemClassObject &  Inst
    )
{
    wstring val;
    if( Inst.GetProperty(
                val,
                ( PWCHAR ) wszWbemProperty ) == S_OK )
    {
        DNS_STATUS status = DnssrvResetStringProperty(
                                PVD_DNS_LOCAL_SERVER,
                                pszZoneName,
                                pszDnssrvPropertyName,
                                val.c_str(),
                                0 );
        if( status != ERROR_SUCCESS )
        {
            ThrowException( status );
        }
    }
    return WBEM_S_NO_ERROR;
}   //  CDnsWrap::dnsSetStringProperty


/*---------------------------------------------------------------------------
Read the property value from DNS server and set in class object.
*/
SCODE 
CDnsWrap::dnsGetIPArrayProperty(
    const char *        pszZoneName,
    const WCHAR *       wszWbemProperty, 
    const char *        pszDnssrvPropertyName,
    CWbemClassObject &  Inst
    )
{
    SCODE               sc = WBEM_S_NO_ERROR;
    DWORD               dataType = 0;
    PVOID               pdata = 0;
    SAFEARRAY *         psa = NULL;
    SAFEARRAYBOUND      rgsabound[ 1 ] = { 0, 0 };
    PIP_ARRAY           pipArray;

    //
    //  Retrieve the setting from the DNS server and check it's type.
    //

    DNS_STATUS status = DnssrvQuery(
                            PVD_DNS_LOCAL_SERVER,
                            pszZoneName,
                            pszDnssrvPropertyName,
                            &dataType,
                            &pdata );
    if( status != ERROR_SUCCESS )
    {
        sc = status;
        goto Done;
    }
    if ( dataType != DNSSRV_TYPEID_IPARRAY )
    {
        sc = WBEM_E_TYPE_MISMATCH;
        goto Done;
    }
    if ( pdata == NULL )
    {
        Inst.SetProperty(
            ( PWCHAR ) NULL,
            ( PWCHAR ) wszWbemProperty );
        goto Done;
    }
    pipArray = ( PIP_ARRAY ) pdata;

    //
    //  Create a SAFEARRAY of BSTRs to represent the IP address list.
    //

    rgsabound[ 0 ].cElements = pipArray->AddrCount;
    psa = SafeArrayCreate( VT_BSTR, 1, rgsabound );
    if ( psa == NULL )
    {
        sc = WBEM_E_OUT_OF_MEMORY;
        goto Done;
    }
    for ( int i = 0; i < pipArray->AddrCount; ++i )
    {
        BSTR bstr = AllocBstr(
                IpAddressToString( pipArray->AddrArray[ i ] ).c_str() );
        if ( bstr == NULL )
        {
            sc = WBEM_E_OUT_OF_MEMORY;
            goto Done;
        }
        LONG ix = i;
        sc = SafeArrayPutElement( psa, &ix, bstr );
        SysFreeString( bstr );
        if ( sc != S_OK )
        {
            goto Done;
        }
    }
            
    Inst.SetProperty(
        psa,
        ( PWCHAR ) wszWbemProperty );
    
    Done:

    if ( pdata )
    {
        //  JJW: do something to free RPC piparray???
    }
    if ( psa )
    {
        SafeArrayDestroy( psa );
    }
    
    return sc;
}   //  CDnsWrap::dnsGetIPArrayProperty


/*---------------------------------------------------------------------------
Read the property value out of the class object and send to DNS server.

If the specified property does not exist on the object, do nothing and
return WBEM_S_NO_ERROR.
*/
SCODE 
CDnsWrap::dnsSetIPArrayProperty(
    const char *        pszZoneName,
    const WCHAR *       wszWbemProperty, 
    const char *        pszDnssrvPropertyName,
    CWbemClassObject &  Inst
    )
{
    DBG_FN( "CDnsWrap::dnsSetIPArrayProperty" )

    SCODE               sc = WBEM_S_NO_ERROR;
    SAFEARRAY *         psa = NULL;
    VARIANT             var;

    VariantInit( &var );

    if( Inst.GetProperty(
                &var,
                ( LPCWSTR ) wszWbemProperty ) == S_OK &&
        var.vt != VT_NULL )
    {
        DNS_DEBUG( INSTPROV, (
            "%s: %s on zone %s\n", fn, pszDnssrvPropertyName, pszZoneName ));

        if ( var.vt != ( VT_ARRAY |VT_BSTR ) )
        {
            sc = WBEM_E_TYPE_MISMATCH;
            goto Done;
        }

        sc = SafeArrayCopy( var.parray, &psa );

        BSTR * pbstr = NULL;
        sc = SafeArrayAccessData( psa, ( void ** ) &pbstr );
        if ( sc != S_OK )
        {
            goto Done;
        }

        int ipCount = psa->rgsabound[ 0 ].cElements;
        IP_ADDRESS * pipAddrArray = new IP_ADDRESS[ ipCount + 1 ];
        if ( pipAddrArray == NULL )
        {
            ThrowException( WBEM_E_OUT_OF_MEMORY );
        }
        for ( int i = 0; i < ipCount; ++i )
        {
            string str;
            WcharToString( pbstr[ i ], str );
            pipAddrArray[ i ] = inet_addr( str.c_str() );
        }
        SafeArrayUnaccessData( psa );

        PIP_ARRAY pipArray = Dns_BuildIpArray( ipCount, pipAddrArray );
        delete [] pipAddrArray;

        DNS_STATUS status = DnssrvResetIPListProperty(
                                PVD_DNS_LOCAL_SERVER,
                                pszZoneName,
                                pszDnssrvPropertyName,
                                pipArray,
                                0 );

        FREE_HEAP( pipArray );

        if( status != ERROR_SUCCESS )
        {
            sc = status;
        }
    }
    
    Done:

    VariantClear( &var );
    if ( psa )
    {
        SafeArrayDestroy( psa );
    }
    return sc;
}   //  CDnsWrap::dnsSetIPArrayProperty


SCODE
CDnsWrap::dnsSetServerForwarders(
    const char *        pszZoneName,
    const WCHAR*        wszWbemProperty, 
    const char*         pszOperationName,
    CWbemClassObject &  Inst
    )
{

    // get forward ip array
    DWORD* pdwValue=NULL;
    DWORD dwSize;
    if(Inst.GetProperty(
        &pdwValue,
        &dwSize,
        (WCHAR*)wszWbemProperty) == S_OK)
    {
        DWORD dwSlave;
        DWORD dwTimeOut;
        try
        {
            // start changing forwarders process
            // get slave
            if(Inst.GetProperty(
                &dwSlave,
                MYTEXT( DNS_REGKEY_SLAVE ) ) != S_OK)
            {
                return WBEM_E_INVALID_PARAMETER;
            }

            // get forward time out
            
            if(Inst.GetProperty(
                &dwTimeOut,
                MYTEXT( DNS_REGKEY_FORWARD_TIMEOUT ) ) != S_OK)
            {
                return WBEM_E_INVALID_PARAMETER;
            }
        }
        catch(...)
        {
            delete [] pdwValue;
            throw;
        }
        // now let's change it

        DNS_STATUS status = DnssrvResetForwarders(
            PVD_DNS_LOCAL_SERVER,
            dwSize,
            pdwValue,
            dwTimeOut,
            dwSlave );

        delete [] pdwValue;
        if(status != ERROR_SUCCESS)
        {
            ThrowException(status);
        }
    
    }
    
    return WBEM_S_NO_ERROR;
}

SCODE
CDnsWrap::dnsSetServerListenAddress(
    const char *        pszZoneName,
    const WCHAR*        wszWbemProperty, 
    const char*         pszOperationName,
    CWbemClassObject&   Inst
    )
{

    // dww - 6/28/99
    // Rewrote to accept NULL as a valid parameter.
    //
    DWORD* dwValue = NULL;
    DWORD dwSize = 0;
    Inst.GetProperty( &dwValue, &dwSize, (WCHAR*)wszWbemProperty);

    if ( dwSize == 0 ) 
    {
        dwValue = new DWORD[1];
        if ( !dwValue )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        dwValue[0] = 0;
    }

    DNS_STATUS status = DnssrvResetServerListenAddresses(
            PVD_DNS_LOCAL_SERVER,
            dwSize,
            dwValue);

    delete [] dwValue;

    if(status != ERROR_SUCCESS)
    {
        ThrowException(status);
    }
    return WBEM_S_NO_ERROR;
}


SCODE 
CDnsWrap::dnsDeleteZone(
    CObjPath& objZone)
{
    wstring wstrZoneName = objZone.GetStringValueForProperty(
        PVD_DOMAIN_CONTAINER_NAME
        );

// dww - 6/14/99
// Added code to see if this is an integrated zone. If it is, you have to use
// The DNSSRV_OP_ZONE_DELETE_FROM_DS operation. All other zone types use the 
// DNSSRV_OP_ZONE_DELETE operation.
//
    // Get the Zone Type to determine if it is an integrated zone.
    DWORD dwValue = -1;
    LONG status = WBEM_S_NO_ERROR;
    char* pszZoneName = NULL;
    WcharToChar(wstrZoneName.data(), &pszZoneName);

    DnssrvQueryDwordProperty(
        PVD_DNS_LOCAL_SERVER,
        pszZoneName,
        DNS_REGKEY_ZONE_DS_INTEGRATED,
        &dwValue
        );

    if(dwValue == 1)  // integrated zone
    {
        status= DnssrvOperation(
                        PVD_DNS_LOCAL_SERVER,
                        pszZoneName,
                        DNSSRV_OP_ZONE_DELETE_FROM_DS,
                        DNSSRV_TYPEID_NULL,
                        (PVOID) NULL
                        );
    }
    else 
    {
        status= DnssrvOperation(
                        PVD_DNS_LOCAL_SERVER,
                        pszZoneName,
                        DNSSRV_OP_ZONE_DELETE,
                        DNSSRV_TYPEID_NULL,
                        (PVOID) NULL
                        );
    }
    delete [] pszZoneName;
    if( status != ERROR_SUCCESS)
        ThrowException(status);

    return WBEM_S_NO_ERROR;

}

wstring 
CDnsWrap::GetServerName(void)
{
    return m_wszpServerName;
}


SCODE 
CDnsWrap::dnsGetZone(
    const WCHAR*        wszServer, 
    const WCHAR*        wszZone,
    CWbemClassObject&   Inst,
    IWbemObjectSink*    pHandler
    )
{
    DBG_FN( "CDnsWrap::dnsGetZone" )

    DNS_STATUS status;
    char* pszZoneName = NULL;
    PDNS_RPC_ZONE_INFO pZoneInfo=NULL;
    WcharToChar(wszZone, &pszZoneName);
    status = DnssrvGetZoneInfo(
        wszServer,
        pszZoneName,
        &pZoneInfo );

    DNS_DEBUG( INSTPROV, (
        "%s: server %S zone %S\n", fn, wszServer, wszZone ));

    DWORD dwDsIntegratedValue = 0;
    if ( status == ERROR_SUCCESS)
    {
        status = DnssrvQueryDwordProperty(
            PVD_DNS_LOCAL_SERVER,
            pszZoneName,
            DNS_REGKEY_ZONE_DS_INTEGRATED,
            &dwDsIntegratedValue );
    }
    
    delete [] pszZoneName;
    if ( status == DNS_ERROR_ZONE_DOES_NOT_EXIST)
    {
        return WBEM_E_NOT_FOUND;
    }

    // setup wbem object

    if(status == ERROR_SUCCESS)
    {
        Inst.SetProperty(
            pZoneInfo->dwZoneType,    
            PVD_ZONE_ZONE_TYPE);

        // setup keys
        Inst.SetProperty(
            m_wszpServerName, 
            PVD_DOMAIN_SERVER_NAME);
        
        Inst.SetProperty(
            wszZone, 
            PVD_DOMAIN_CONTAINER_NAME);
        
        Inst.SetProperty(
            wszZone, 
            PVD_DOMAIN_FQDN);
        
        Inst.SetProperty(
            pZoneInfo->fAllowUpdate, 
            PVD_ZONE_ALLOW_UPDATE);
        
        Inst.SetProperty(
            pZoneInfo->fAutoCreated, 
            PVD_ZONE_AUTO_CREATED);
        
        Inst.SetProperty(
            pZoneInfo->fPaused, 
            PVD_ZONE_PAUSED );
        
        Inst.SetProperty(
            pZoneInfo->fReverse, 
            PVD_ZONE_REVERSE );
        
        Inst.SetProperty(
            pZoneInfo->fAging, 
            PVD_ZONE_AGING );
        
        Inst.SetProperty(
            pZoneInfo->fSecureSecondaries, 
            PVD_ZONE_SECURE_SECONDARIES );

        Inst.SetProperty(
            pZoneInfo->fNotifyLevel, 
            PVD_ZONE_NOTIFY);
       
        Inst.SetProperty(
            pZoneInfo->fShutdown, 
            PVD_ZONE_SHUTDOWN );
        
        Inst.SetProperty(
            pZoneInfo->fUseWins, 
            PVD_ZONE_USE_WINS);
        
        Inst.SetProperty(
            pZoneInfo->pszDataFile, 
            PVD_ZONE_DATA_FILE); 
        
        Inst.SetProperty(
            dwDsIntegratedValue, 
            PVD_ZONE_DS_INTEGRATED); 
        
       Inst.SetProperty(
            pZoneInfo->dwAvailForScavengeTime, 
            PVD_ZONE_AVAIL_FOR_SCAVENGE_TIME ); 
        
        Inst.SetProperty(
            pZoneInfo->dwNoRefreshInterval, 
            PVD_ZONE_NOREFRESH_INTERVAL ); 
        
        Inst.SetProperty(
            pZoneInfo->dwRefreshInterval, 
            PVD_ZONE_REFRESH_INTERVAL ); 
        
        Inst.SetProperty(
            pZoneInfo->fForwarderSlave, 
            PVD_ZONE_FORWARDER_SLAVE ); 
        
        Inst.SetProperty(
            pZoneInfo->dwForwarderTimeout, 
            PVD_ZONE_FORWARDER_TIMEOUT ); 
        
        if (pZoneInfo->aipMasters != NULL)
        {
            Inst.SetProperty(
                pZoneInfo->aipMasters->AddrArray,
                pZoneInfo->aipMasters->AddrCount,
                PVD_ZONE_MASTERS_IP_ADDRESSES_ARRAY );
        }
        
        if (pZoneInfo->aipSecondaries != NULL)
        {
          Inst.SetProperty(
                pZoneInfo->aipSecondaries->AddrArray,
                pZoneInfo->aipSecondaries->AddrCount,
                PVD_ZONE_SECONDARIES_IP_ADDRESSES_ARRAY );
        }

        if( pZoneInfo->aipNotify != NULL)
        {
            Inst.SetProperty(
                pZoneInfo->aipNotify->AddrArray,
                pZoneInfo->aipNotify->AddrCount,
                PVD_ZONE_NOTIFY_IPADDRESSES_ARRAY );
        }

        if( pZoneInfo->aipScavengeServers )
        {
            Inst.SetProperty(
                pZoneInfo->aipScavengeServers->AddrArray,
                pZoneInfo->aipScavengeServers->AddrCount,
                PVD_ZONE_SCAVENGE_SERVERS );
        }

        Inst.SetProperty(
            pZoneInfo->dwLastSuccessfulSoaCheck, 
            PVD_ZONE_LAST_SOA_CHECK );

        Inst.SetProperty(
            pZoneInfo->dwLastSuccessfulXfr, 
            PVD_ZONE_LAST_GOOD_XFR ); 
    }
    
    //clean up
    DnssrvFreeZoneInfo(pZoneInfo);

    if( status != ERROR_SUCCESS)
    {
        DNS_DEBUG( INSTPROV, (
            "%s: server %S zone %S throwing %s\n", fn, wszServer, wszZone, status ));
        ThrowException(status);
    }

    DNS_DEBUG( INSTPROV, (
        "%s: server %S zone %S returning WBEM_S_NO_ERROR\n", fn, wszServer, wszZone ));
    return WBEM_S_NO_ERROR;    
}

SCODE 
CDnsWrap::dnsSetProperty(
    const WCHAR*    wszZoneName, 
    const char*     pszPropertyName, 
    DWORD           dwValue
    )
{
    char * pszZone = NULL;
    WcharToChar(wszZoneName, &pszZone);

    return dnsSetProperty( pszZone, pszPropertyName, dwValue );
}

SCODE 
CDnsWrap::dnsSetProperty(
    const char*     pszZoneName, 
    const char*     pszPropertyName, 
    DWORD           dwValue
    )
{
    DBG_FN( "CDnsWrap::dnsSetDwordProperty" );

    DNS_DEBUG( INSTPROV, (
        "%s: zone %s property %s value %d\n", fn,
        pszZoneName,
        pszPropertyName,
        dwValue ));

    LONG status = DnssrvResetDwordProperty(
                        PVD_DNS_LOCAL_SERVER,
                        pszZoneName,
                        pszPropertyName,
                        dwValue );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INSTPROV, (
            "%s: throwing 0x%X for zone %s property %s\n", fn,
            status,
            pszZoneName,
            pszPropertyName ));
        ThrowException( status );
    }
    return WBEM_S_NO_ERROR;
}

SCODE 
CDnsWrap::dnsQueryProperty(
    const WCHAR*    wszZoneName, 
    const WCHAR*    wszPropertyName, 
    DWORD*          pdwResult
    )
{
    
    char * szZone = NULL;
    char * szProp = NULL;
    WcharToChar(wszZoneName, &szZone);
    WcharToChar(wszPropertyName, &szProp);
    LONG status = DnssrvQueryZoneDwordProperty(
        PVD_DNS_LOCAL_SERVER,
        szZone,
        szProp,
        pdwResult
    );

    delete [] szZone;
    delete [] szProp;
    
    if(status != ERROR_SUCCESS)
        ThrowException(status);
    return WBEM_S_NO_ERROR;
}

SCODE 
CDnsWrap::dnsResumeZone(
    const char* strZoneName
    )
{
    DNS_STATUS status = DnssrvResumeZone(
        PVD_DNS_LOCAL_SERVER,
        strZoneName);
    if(status != ERROR_SUCCESS)
    {
        ThrowException(status);
    }
    return WBEM_S_NO_ERROR;
}
SCODE 
CDnsWrap::dnsPauseZone(
    const char *strZoneName
    )
{
    int status = DnssrvPauseZone(
        PVD_DNS_LOCAL_SERVER,
        strZoneName        // zone name
        );

    if ( status != ERROR_SUCCESS )
    {
        ThrowException(status);
    }
    
    return WBEM_S_NO_ERROR;
}

void 
CDnsWrap::ThrowException(
    LONG status)
{
    CDnsProvException dnsExcep(Dns_StatusString(status),status);
    throw dnsExcep;
}

void 
CDnsWrap::ThrowException(
    LPCSTR ErrString
    )
{
    CDnsProvException dnsExcep(ErrString);
    throw dnsExcep;
}

SCODE CDnsWrap::dnsClearCache()
{
    DNS_STATUS status = DnssrvOperation(
        PVD_DNS_LOCAL_SERVER,
        NULL,
        DNSSRV_OP_CLEAR_CACHE,
        DNSSRV_TYPEID_NULL,
        NULL );
    if(status != S_OK)
        ThrowException(status);
    return WBEM_S_NO_ERROR;

}

SCODE 
CDnsWrap::dnsOperation(
        string& strZone,    //zone name
        OpsFlag OperationID
        )
{
    string strOps;
    switch(OperationID)
    {
    case DNS_WRAP_RELOAD_ZONE:
        strOps = DNSSRV_OP_ZONE_RELOAD;
        break;
    case DNS_WRAP_RESUME_ZONE:
        strOps = DNSSRV_OP_ZONE_RESUME;
        break;
    case DNS_WRAP_PAUSE_ZONE:
        strOps = DNSSRV_OP_ZONE_PAUSE;
        break;
    case DNS_WRAP_DS_UPDATE:
        strOps = DNSSRV_OP_ZONE_UPDATE_FROM_DS;
        break;
    case DNS_WRAP_WRITE_BACK_ZONE:
        strOps = DNSSRV_OP_ZONE_WRITE_BACK_FILE;
        break;
    case DNS_WRAP_REFRESH_SECONDARY:
        strOps = DNSSRV_OP_ZONE_REFRESH;
        break;
    default:
        return WBEM_E_FAILED;
    }


    DNS_STATUS status = DnssrvOperation(
        PVD_DNS_LOCAL_SERVER,
        strZone.data(),
        strOps.data(),
        DNSSRV_TYPEID_NULL,
        NULL );
    if(status != S_OK)
        ThrowException(status);
    return WBEM_S_NO_ERROR;

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//      returns a mapping table that maps wbem property and dns property 
//      , and operation can be performed 
//      on the property such as get and set
//
//    Arguments:
//      pdwSize             [IN ]   size of the table

//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

PVOID
CDnsWrap::GetPropertyTable(
    DWORD* pdwSize
    )
{
    //
    //  Macros to simplify adding elements to the property array. 
    //

    #define DECLARE_DW_ELEMENT( str )   \
    {                                   \
        MYTEXT( str ),                  \
        str,                            \
        dnsSetDwordProperty,            \
        dnsGetDwordProperty             \
    }

    #define DECLARE_STR_ELEMENT( str )  \
    {                                   \
        MYTEXT( str ),                  \
        str,                            \
        dnsSetStringProperty,           \
        dnsGetStringProperty            \
    }

    #define DECLARE_IPARRAY_ELEMENT( str )  \
    {                                       \
        MYTEXT( str ),                      \
        str,                                \
        dnsSetIPArrayProperty,              \
        dnsGetIPArrayProperty               \
    }

    //
    //  Array of server properties.
    //

    static PropertyTable pt[] =
    {
        DECLARE_DW_ELEMENT( DNS_REGKEY_ADDRESS_ANSWER_LIMIT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_ALLOW_UPDATE ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_RPC_PROTOCOL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_NO_RECURSION ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_RECURSION_RETRY ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_RECURSION_TIMEOUT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_FORWARD_TIMEOUT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_SLAVE ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_AUTO_CACHE_UPDATE ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_DISJOINT_NETS ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_ROUND_ROBIN ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_BIND_SECONDARIES ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_WRITE_AUTHORITY_NS ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_STRICT_FILE_PARSING ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_LOOSE_WILDCARDING ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_EVENTLOG_LEVEL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_LOG_LEVEL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_MAX_CACHE_TTL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_MAX_NEGATIVE_CACHE_TTL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_DS_POLLING_INTERVAL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_DS_TOMBSTONE_INTERVAL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_NAME_CHECK_FLAG ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_SEND_PORT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_BOOT_METHOD ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_NO_AUTO_REVERSE_ZONES ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_LOCAL_NET_PRIORITY ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_FORWARD_DELEGATIONS ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_SECURE_RESPONSES ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_AUTO_CONFIG_FILE_ZONES ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_DEFAULT_AGING_STATE ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_DEFAULT_REFRESH_INTERVAL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_DEFAULT_NOREFRESH_INTERVAL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_ENABLE_DNSSEC ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_ENABLE_EDNS ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_EDNS_CACHE_TIMEOUT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_ENABLE_DP ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_XFR_CONNECT_TIMEOUT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_SCAVENGING_INTERVAL ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_UPDATE_OPTIONS ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_LOG_FILE_MAX_SIZE ),
        DECLARE_STR_ELEMENT( DNS_REGKEY_LOG_FILE_PATH ),
        DECLARE_IPARRAY_ELEMENT( DNS_REGKEY_LOG_IP_FILTER_LIST ),
        {
            MYTEXT( DNS_REGKEY_FORWARDERS ),
            DNS_REGKEY_FORWARDERS,
            dnsSetServerForwarders,
            NULL
        },
        DECLARE_DW_ELEMENT( DNS_REGKEY_FORWARD_TIMEOUT ),
        DECLARE_DW_ELEMENT( DNS_REGKEY_SLAVE ),
        {
            MYTEXT( DNS_REGKEY_LISTEN_ADDRESSES ),
            DNS_REGKEY_LISTEN_ADDRESSES,
            dnsSetServerListenAddress,
            NULL
        },
    };

    static DWORD dwNumofElements =
        sizeof(pt)/sizeof(PropertyTable);
    *pdwSize = dwNumofElements;
    return &pt;
}

SCODE 
CDnsWrap::dnsZoneCreate(
    string& strZoneName,
    DWORD    dwZoneType,
    string&    strDataFile,
    string& strAdmin,
    DWORD*  pIp,
    DWORD    cIp
    )
{
        
    DWORD loadOptions = 0, fuseDs = FALSE;
    LPSTR pszData = NULL;
    if(dwZoneType == 2)        
    //secondary zone must supply master ip array
    {
        if( cIp <=0 || pIp == NULL)
            return WBEM_E_INVALID_PARAMETER;
    }
    else if(dwZoneType == 0)    //dsIntegrated
    {
        loadOptions = TRUE;     //load existing
        fuseDs = TRUE;
        dwZoneType =1;            // dsPrimary
    }

    if( !strDataFile.empty())
    {
         loadOptions |= DNS_ZONE_LOAD_EXISTING;
         pszData = (LPSTR) strDataFile.data();
    }
    
    string strAdminEmail = strAdmin;
    if(strAdminEmail.empty())
        strAdminEmail = "Admin";
    DNS_STATUS status;

    status = DnssrvCreateZone(
        PVD_DNS_LOCAL_SERVER,                            //server
        (char*) strZoneName.data(),        //zone
        dwZoneType,                        //zone type    
        strAdminEmail.data(),                        // admin email
        cIp,                        // size of master
        pIp,                        // master ip
        loadOptions,                    // load option
        fuseDs,                    //dwDsIntegrated, //fuseDs,
        pszData,                //pszDataFile 
        0,                          // timeout for forwarder zone
        0                           // doNotRecurse flag for forwarder zone
        );

    if ( status != ERROR_SUCCESS )
        ThrowException(status);
   return WBEM_S_NO_ERROR;

}


SCODE 
CDnsWrap::dnsZoneChangeType(
    string& strZone,
    DWORD    dwZoneType,
    string&    strDataFile,
    string& strAdmin,
    DWORD*    pIp,
    DWORD    cIp
    )
{
        //set zone type
    DWORD dwUseDs=FALSE, dwLoadOptions=TRUE, cMaster=0;
    if(dwZoneType ==1 && strDataFile.empty())
    {
        ThrowException("DataFile required");
    }

    if( dwZoneType == 2)
    {
        // change to secondary zone
        if(pIp == NULL || cIp <= 0 )    // secondary must have master IP
            return WBEM_E_INVALID_PARAMETER;
    }
    else if (dwZoneType == 0)
    {
        if(!strDataFile.empty())    //dsIntegrated doesn't use file
            return WBEM_E_INVALID_PARAMETER;
        dwUseDs = TRUE;
    }
    DNS_STATUS status;            
    status = DnssrvResetZoneTypeEx(
        PVD_DNS_LOCAL_SERVER,
        strZone.data(),
        dwZoneType,
        cIp,
        pIp,
        dwLoadOptions,
        dwUseDs,
        strDataFile.data());
    if(status != S_OK)
        ThrowException(status);
    return WBEM_S_NO_ERROR;

}


SCODE
CDnsWrap::dnsZoneResetSecondary(
    string& strZoneName,
    DWORD   dwSecurity,
    DWORD*  pSecondaryIp,
    DWORD   cSecondaryIp,
    DWORD   dwNotify,
    DWORD * pNotifyIp,
    DWORD   cNotifyIp
    )
{
    DNS_STATUS status;
    DWORD       tdwNotifyLevel = ZONE_NOTIFY_ALL;
    DWORD       tdwSecurity = ZONE_SECSECURE_NO_SECURITY;

    if( dwSecurity <=3 )
    {
        tdwSecurity = dwSecurity;
    }
    if( dwNotify <=2)
    {
        tdwNotifyLevel = dwNotify;
    }
    status = DnssrvResetZoneSecondaries(
        PVD_DNS_LOCAL_SERVER,
        strZoneName.data(),
        tdwSecurity,
        cSecondaryIp,
        pSecondaryIp,
        tdwNotifyLevel,
        cNotifyIp,
        pNotifyIp);

    if ( status != ERROR_SUCCESS )
    {
        ThrowException(status);
    }

    return WBEM_S_NO_ERROR;
}


SCODE
CDnsWrap::dnsZoneResetMaster(
    string& strZoneName,
    DWORD*  pMasterIp,
    DWORD   cMasterIp,
    DWORD   dwLocal
    )
{
    DNS_STATUS status;
    DWORD dwValue = -1;

    status = DnssrvResetZoneMastersEx(
                PVD_DNS_LOCAL_SERVER,
                strZoneName.data(),
                cMasterIp,
                pMasterIp,
                dwLocal );
    if ( status != ERROR_SUCCESS )
    {
        ThrowException(status);
    }
    return WBEM_S_NO_ERROR;
}



SCODE
CDnsWrap::dnsZonePut(
    CWbemClassObject& Inst
    )
/*++

Routine Description:

    This function commits all of the property values in a zone
    object to the DNS server.

Arguments:

    Inst -- zone object

Return Value:

    S_OK on success.

--*/
{
    DBG_FN( "CDnsWrap::dnsZonePut" )

    SCODE sc;
    DNS_STATUS status = ERROR_SUCCESS;
    DWORD dwProperty = 0;
    DWORD dwZoneType = -1;
    DWORD * dwArray = NULL;
    DWORD dwArraySize = 0;
    string strZoneName;
    string strDataFile;
    DWORD dwValue;

    #define DNS_CHECK_STATUS()   if ( status != ERROR_SUCCESS ) goto Done

    //
    //  Get basic properties of the new zone.
    //

    Inst.GetProperty( strZoneName, PVD_DOMAIN_CONTAINER_NAME );
    Inst.GetProperty( &dwZoneType, PVD_ZONE_ZONE_TYPE );

    DNS_DEBUG( INSTPROV, (
        "%s: zone %s\n", fn, strZoneName.c_str() ));

    //
    //  Retrieve properties from the class object and set values
    //  to the server.
    //

    if( dwZoneType == DNS_ZONE_TYPE_PRIMARY &&
        Inst.GetProperty(
                &dwProperty, 
                PVD_ZONE_ALLOW_UPDATE ) == S_OK )
    {
        status = dnsSetProperty(
                        strZoneName.data(), 
                        DNS_REGKEY_ZONE_ALLOW_UPDATE, 
                        dwProperty );
        DNS_CHECK_STATUS();
    }

    if( Inst.GetProperty(
                &dwProperty, 
                PVD_ZONE_REFRESH_INTERVAL ) == S_OK )
    {
        status = dnsSetProperty(
                        strZoneName.data(), 
                        DNS_REGKEY_ZONE_REFRESH_INTERVAL, 
                        dwProperty );
        DNS_CHECK_STATUS();
    }

    if( Inst.GetProperty(
                &dwProperty, 
                PVD_ZONE_NOREFRESH_INTERVAL ) == S_OK )
    {
        status = dnsSetProperty(
                        strZoneName.data(), 
                        DNS_REGKEY_ZONE_NOREFRESH_INTERVAL, 
                        dwProperty );
        DNS_CHECK_STATUS();
    }

    status = dnsSetIPArrayProperty(
                strZoneName.data(), 
                MYTEXT( DNS_REGKEY_ZONE_MASTERS ), 
                DNS_REGKEY_ZONE_MASTERS,
                Inst );
    DNS_CHECK_STATUS();

    status = dnsSetIPArrayProperty(
                strZoneName.data(), 
                MYTEXT( DNS_REGKEY_ZONE_LOCAL_MASTERS ), 
                DNS_REGKEY_ZONE_LOCAL_MASTERS,
                Inst );
    DNS_CHECK_STATUS();

    status = dnsSetIPArrayProperty(
                strZoneName.data(), 
                MYTEXT( DNS_REGKEY_ZONE_SCAVENGE_SERVERS ), 
                DNS_REGKEY_ZONE_SCAVENGE_SERVERS,
                Inst );
    DNS_CHECK_STATUS();

    //
    //  Forwarder zone properties.
    //

    if ( dwZoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        if( Inst.GetProperty(
                    &dwProperty, 
                    MYTEXT( DNS_REGKEY_ZONE_FWD_SLAVE ) ) == S_OK )
        {
            status = dnsSetProperty(
                            strZoneName.data(), 
                            DNS_REGKEY_ZONE_FWD_SLAVE, 
                            dwProperty );
            DNS_CHECK_STATUS();
        }

        if( Inst.GetProperty(
                    &dwProperty, 
                    MYTEXT( DNS_REGKEY_ZONE_FWD_TIMEOUT ) ) == S_OK )
        {
            status = dnsSetProperty(
                            strZoneName.data(), 
                            DNS_REGKEY_ZONE_FWD_TIMEOUT, 
                            dwProperty );
            DNS_CHECK_STATUS();
        }
    }

    //
    //  To handle the zone data file, call DnssrvResetZoneDatabase
    //

    dwValue = 0;
    DnssrvQueryDwordProperty(
        PVD_DNS_LOCAL_SERVER,
        strZoneName.data(),
        DNS_REGKEY_ZONE_DS_INTEGRATED,
        &dwValue );
    if( Inst.GetProperty(
            strDataFile, 
            PVD_ZONE_DATA_FILE ) == S_OK )
    {
        if( status == S_OK && dwZoneType != 0 && !strDataFile.empty() )
        {
            status = DnssrvResetZoneDatabase(    
                            PVD_DNS_LOCAL_SERVER, 
                            strZoneName.data(),
                            dwValue,
                            strDataFile.data() );
            DNS_CHECK_STATUS();
        }
    }

    Done:    
    
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INSTPROV, (
            "%s: zone %s throwing %d\n", fn, strZoneName.c_str(), status ));
        ThrowException( status );
    }

    DNS_DEBUG( INSTPROV, (
        "%s: zone %s returning WBEM_S_NO_ERROR\n", fn, strZoneName.c_str() ));
    return WBEM_S_NO_ERROR;

    #undef DNS_CHECK_STATUS
}



static SCODE
dnsWrapCreateStatistic(
    IWbemClassObject *      pClass,
    IWbemObjectSink *       pHandler,
    DWORD                   dwStatCollection,
    const WCHAR *           pszStatisticName,
    CIMTYPE                 cimType,
    const void *            value
    )
/*++

Routine Description:

    Creates and populates a single DNS statistic object.

Arguments:

    pClass -- MicrosoftDNS_Statistic class object used to spawn new instance

    dwStatCollection -- index into global collection array

    pszStatisticName -- statistic name

    cimType - type of statistic 
                    VT_UI4: value is a DWORD
                    VT_BSTR: value is a pointer to a string

    value - interpret as per cimType

Return Value:

    S_OK or error code.

--*/
{
    CDnsWrap & dns = CDnsWrap::DnsObject();

    CWbemClassObject Inst;
    pClass->SpawnInstance( 0, &Inst);

    Inst.SetProperty( dns.GetServerName(), PVD_DOMAIN_SERVER_NAME );
    Inst.SetProperty( g_StatInfo[ dwStatCollection ].pszName, L"CollectionName" );
    Inst.SetProperty( g_StatInfo[ dwStatCollection ].dwStatId, L"CollectionId" );
    Inst.SetProperty( pszStatisticName, L"Name" );

    if ( cimType == VT_BSTR )
    {
        Inst.SetProperty( ( LPCWSTR ) value, L"StringValue" );
    }
    else
    {
        DWORD dw = ( DWORD ) ( DWORD_PTR ) value;

        Inst.SetProperty( dw, L"Value" );
    }

    pHandler->Indicate( 1, &Inst );

    return S_OK;
}   //  dnsWrapCreateStatistic



static SCODE
dnsWrapAddStatisticsForTypeArray(
    IWbemClassObject *      pClass,
    IWbemObjectSink *       pHandler,
    DWORD                   statCollIdx,
    PWSTR                   pszHeader,
    PDWORD                  pArray
    )
/*++

Routine Description:

    Adds DWORD statistics for each member of a type array.

Arguments:

    pClass -- WMI statistic class

    pHandler -- WMI object sink

    statCollIdx -- index into global stat information array

    pszHeader -- header text used to format statistic description

    pArray -- array of DWORDs for types


Return Value:

    None

--*/
{
    WCHAR sz[ 80 ];

    #define dwStat( pwszName, dwValue )     \
        dnsWrapCreateStatistic(             \
            pClass,                         \
            pHandler,                       \
            statCollIdx,                    \
            pwszName,                       \
            VT_UI4,                         \
            ( void * ) ( DWORD_PTR ) ( dwValue ) );

    for ( DWORD i = 0; i < STATS_TYPE_MAX; i++ )
    {
        if ( i == STATS_TYPE_MIXED || i == STATS_TYPE_UNKNOWN )
        {
            continue;
        }

        wsprintfW(
            sz,
            L"%s for %S type",
            pszHeader,
            Dns_RecordStringForType( ( WORD ) i ) );
        dwStat( sz, pArray[ i ] );
    }

    wsprintfW(
        sz,
        L"%s for unknown type",
        pszHeader );
    dwStat( sz, pArray[ STATS_TYPE_UNKNOWN ] );

    wsprintfW(
        sz,
        L"%s for mixed type",
        pszHeader );
    dwStat( sz, pArray[ STATS_TYPE_MIXED ] );

    #undef dwStat

    return S_OK;
}   //  dnsWrapAddStatisticsForTypeArray

    

static SCODE
dnsWrapHandleSingleStat(
    IWbemClassObject *      pClass,
    IWbemObjectSink *       pHandler,
    PDNSSRV_STAT            pStat
    )
/*++

Routine Description:

    Process a single statistic buffer by creating Statistic object
    instances for each of the members of the stat buffer.

Arguments:

    pClass -- WMI statistic class

    pHandler -- WMI object sink

    pStat -- buffer of stats to process

Return Value:

    None

--*/
{
    SCODE               sc = S_OK;
    const int           szBufferLen = 254;
    WCHAR               szBuffer[ szBufferLen ];
    SAFEARRAY *         psa = NULL;
    SAFEARRAYBOUND      rgsabound[ 1 ] = { 0, 0 };
    int                 statCollIdx = -1;

    //
    //  Get index into g_StatInfo element for this stat.
    //

    for ( int i = 0;
          g_StatInfo[ i ].dwStatId != 0 &&
                g_StatInfo[ i ].dwStatId != pStat->Header.StatId;
          ++i );
    if ( g_StatInfo[ i ].dwStatId != 0 )
    {
        statCollIdx = i;
    }

    //
    //  Macros to creating individual stat objects.
    //

    #define strStat( pwszName, pwszValue )  \
        dnsWrapCreateStatistic(             \
            pClass,                         \
            pHandler,                       \
            statCollIdx,                    \
            pwszName,                       \
            VT_BSTR,                        \
            pwszValue );

    #define dwStat( pwszName, dwValue )     \
        dnsWrapCreateStatistic(             \
            pClass,                         \
            pHandler,                       \
            statCollIdx,                    \
            pwszName,                       \
            VT_UI4,                         \
            ( void * ) ( DWORD_PTR ) ( dwValue ) );

    //
    //  Process the individual statistics in this stat collection.
    //

    switch ( pStat->Header.StatId )
    {
        case DNSSRV_STATID_TIME:
        {
            PDNSSRV_TIME_STATS      pstat = ( PDNSSRV_TIME_STATS ) pStat;
            SYSTEMTIME              localTime;

            SystemTimeToTzSpecificLocalTime(
                NULL,
                ( PSYSTEMTIME ) &pstat->ServerStartTime,
                &localTime );
            GetDateFormatW(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &localTime,
                NULL,
                szBuffer,
                szBufferLen );
            wcscat( szBuffer, L" " );
            GetTimeFormatW(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &localTime,
                NULL,
                szBuffer + wcslen( szBuffer ),
                szBufferLen - wcslen( szBuffer ) );

            strStat( L"Server started", szBuffer );

            SystemTimeToTzSpecificLocalTime(
                NULL,
                ( PSYSTEMTIME ) &pstat->LastClearTime,
                &localTime );
            GetDateFormatW(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &localTime,
                NULL,
                szBuffer,
                szBufferLen );
            wcscat( szBuffer, L" " );
            GetTimeFormatW(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &localTime,
                NULL,
                szBuffer + wcslen( szBuffer ),
                szBufferLen - wcslen( szBuffer ) );

            strStat( L"Statistics last cleared", szBuffer );

            break;
        }

        case DNSSRV_STATID_QUERY:
        {
            PDNSSRV_QUERY_STATS  pstat = ( PDNSSRV_QUERY_STATS ) pStat;

            dwStat( L"Queries received", pstat->UdpQueries + pstat->TcpQueries );
            dwStat( L"Responses sent", pstat->UdpResponses + pstat->TcpResponses );
            dwStat( L"UDP queries received", pstat->UdpQueries );
            dwStat( L"UDP responses sent", pstat->UdpResponses );
            dwStat( L"UDP queries sent", pstat->UdpQueriesSent );
            dwStat( L"UDP responses received", pstat->UdpResponsesReceived );
            dwStat( L"TCP client connections", pstat->TcpClientConnections );
            dwStat( L"TCP queries received", pstat->TcpQueries );
            dwStat( L"TCP responses sent", pstat->TcpResponses );
            dwStat( L"TCP queries sent", pstat->TcpQueriesSent );
            dwStat( L"TCP responses received", pstat->TcpResponsesReceived );
            break;
        }

        case DNSSRV_STATID_QUERY2:
        {
            PDNSSRV_QUERY2_STATS  pstat = ( PDNSSRV_QUERY2_STATS ) pStat;

            dwStat( L"Total queries", pstat->TotalQueries );
            dwStat( L"Notify queries", pstat->Notify );
            dwStat( L"Update queries", pstat->Update );
            dwStat( L"TKeyNego queries", pstat->TKeyNego );
            dwStat( L"Standard queries", pstat->Standard );
            dwStat( L"A queries", pstat->TypeA );
            dwStat( L"NS queries", pstat->TypeNs );
            dwStat( L"SOA queries", pstat->TypeSoa );
            dwStat( L"MX queries", pstat->TypeMx );
            dwStat( L"PTR queries", pstat->TypePtr );
            dwStat( L"SRV queries", pstat->TypeSrv );
            dwStat( L"ALL queries", pstat->TypeAll );
            dwStat( L"IXFR queries", pstat->TypeIxfr );
            dwStat( L"AXFR queries", pstat->TypeAxfr );
            dwStat( L"Other queries", pstat->TypeOther );
            break;
        }

        case DNSSRV_STATID_RECURSE:
        {
            PDNSSRV_RECURSE_STATS  pstat = ( PDNSSRV_RECURSE_STATS ) pStat;

            dwStat( L"Queries recursed", pstat->QueriesRecursed );
            dwStat( L"Original questions recursed", pstat->OriginalQuestionRecursed );
            dwStat( L"Additional questions recursed", pstat->AdditionalRecursed );
            dwStat( L"Total questions recursed", pstat->TotalQuestionsRecursed );
            dwStat( L"Original questions recursed", pstat->OriginalQuestionRecursed );
            dwStat( L"Retries", pstat->Retries );
            dwStat( L"Total passes", pstat->LookupPasses );
            dwStat( L"To forwarders", pstat->Forwards );
            dwStat( L"Sends", pstat->Sends );

            dwStat( L"Total responses", pstat->Responses );
            dwStat( L"Responses unmatched", pstat->ResponseUnmatched );
            dwStat( L"Responses mismatched", pstat->ResponseMismatched );
            dwStat( L"Responses from forwarders", pstat->ResponseFromForwarder );
            dwStat( L"Authoritative responses", pstat->ResponseAuthoritative );
            dwStat( L"NotAuthoritative responses", pstat->ResponseNotAuth );
            dwStat( L"Answer responses", pstat->ResponseAnswer );
            dwStat( L"Empty responses", pstat->ResponseEmpty );
            dwStat( L"Name error responses", pstat->ResponseAnswer );
            dwStat( L"Rcode responses", pstat->ResponseRcode );
            dwStat( L"Delegation responses", pstat->ResponseDelegation );
            dwStat( L"Non-zone data responses", pstat->ResponseNonZoneData );
            dwStat( L"Unsecure responses", pstat->ResponseUnsecure );
            dwStat( L"Bad packet responses", pstat->ResponseBadPacket );

            dwStat( L"Forwarded responses", pstat->SendResponseDirect );
            dwStat( L"Continue current recursion responses", pstat->ContinueCurrentRecursion );
            dwStat( L"Continue current lookup responses", pstat->ContinueCurrentLookup );
            dwStat( L"Continue next lookup responses", pstat->ContinueNextLookup );

            dwStat( L"Send timeouts", pstat->PacketTimeout );
            dwStat( L"Final queued timeouts", pstat->FinalTimeoutQueued );
            dwStat( L"Final timeouts expired", pstat->FinalTimeoutExpired );

            dwStat( L"Recurse failures", pstat->RecursePassFailure );
            dwStat( L"Into authority failures", pstat->FailureReachAuthority );
            dwStat( L"Previous zone failures", pstat->FailureReachPreviousResponse );
            dwStat( L"Retry count failures", pstat->FailureRetryCount );
            dwStat( L"Cache update failures", pstat->CacheUpdateFailure );
            dwStat( L"Server failure responses", pstat->ServerFailure );
            dwStat( L"Total failures", pstat->Failures );

            dwStat( L"TCP recursions tried", pstat->TcpTry );
            dwStat( L"TCP recursion queries", pstat->TcpQuery );
            dwStat( L"TCP recursion responses", pstat->TcpResponse );
            dwStat( L"TCP recursion disconnects", pstat->TcpDisconnect );

            dwStat( L"Cache update queries allocated", pstat->CacheUpdateAlloc );
            dwStat( L"Cache update query responses", pstat->CacheUpdateResponse );
            dwStat( L"Cache update query retries", pstat->CacheUpdateRetry );
            dwStat( L"Cache update queries freed", pstat->CacheUpdateFree );
            dwStat( L"Cache update queries for root NS", pstat->RootNsQuery );
            dwStat( L"Cache update responses for root NS", pstat->RootNsResponse );
            dwStat( L"Cache update queries suspended", pstat->SuspendedQuery );
            dwStat( L"Cache update queries resumed", pstat->ResumeSuspendedQuery );

            break;
        }

        case DNSSRV_STATID_MASTER:
        {
            PDNSSRV_MASTER_STATS pstat = ( PDNSSRV_MASTER_STATS ) pStat;

            dwStat( L"Notifies sent", pstat->NotifySent );
            dwStat( L"Requests", pstat->Request );
            dwStat( L"NameErrors", pstat->NameError );
            dwStat( L"FormErrors", pstat->FormError );
            dwStat( L"Refused", pstat->Refused );
            dwStat( L"AxfrLimit refused", pstat->AxfrLimit );
            dwStat( L"Security refused", pstat->RefuseSecurity );
            dwStat( L"Shutdown refused", pstat->RefuseShutdown );
            dwStat( L"ServFail refused", pstat->RefuseServerFailure );
            dwStat( L"Transfer failures", pstat->Failure );
            dwStat( L"Transfer successes", pstat->AxfrSuccess + pstat->IxfrUpdateSuccess );
            dwStat( L"AXFR requests", pstat->AxfrRequest );
            dwStat( L"AXFR successes", pstat->AxfrSuccess );
            dwStat( L"AXFR in IXFR", pstat->IxfrAxfr );
            dwStat( L"IXFR requests", pstat->IxfrRequest );
            dwStat( L"IXFR successes", pstat->IxfrUpdateSuccess );
            dwStat( L"IXFR UDP requests", pstat->IxfrUdpRequest );
            dwStat( L"IXFR UDP successes", pstat->IxfrUdpSuccess );
            dwStat( L"IXFR UDP force TCP", pstat->IxfrUdpForceTcp );
            dwStat( L"IXFR UDP force AXFR", pstat->IxfrUdpForceAxfr );
            dwStat( L"IXFR TCP requests", pstat->IxfrTcpRequest );
            dwStat( L"IXFR TCP successes", pstat->IxfrTcpSuccess );
            dwStat( L"IXFR TCP force AXFR", pstat->IxfrAxfr );
            break;
        }

        case DNSSRV_STATID_SECONDARY:
        {
            PDNSSRV_SECONDARY_STATS pstat = (PDNSSRV_SECONDARY_STATS)pStat;

            dwStat( L"Notifies received", pstat->NotifyReceived );
            dwStat( L"Notifies invalid", pstat->NotifyInvalid );
            dwStat( L"Notifies primary", pstat->NotifyPrimary );
            dwStat( L"Notifies no version", pstat->NotifyNoVersion );
            dwStat( L"Notifies new version", pstat->NotifyNewVersion );
            dwStat( L"Notifies current version", pstat->NotifyCurrentVersion );
            dwStat( L"Notifies old version", pstat->NotifyOldVersion );
            dwStat( L"Notifies master unknown", pstat->NotifyMasterUnknown );

            dwStat( L"SOA requests", pstat->SoaRequest );
            dwStat( L"SOA responses", pstat->SoaResponse );
            dwStat( L"SOA invalid responses", pstat->SoaResponseInvalid );
            dwStat( L"SOA NameError responses", pstat->SoaResponseNameError );

            dwStat( L"AXFR requests", pstat->AxfrRequest );
            dwStat( L"AXFR in IXFR requests", pstat->IxfrTcpAxfr );
            dwStat( L"AXFR responses", pstat->AxfrResponse );
            dwStat( L"AXFR success responses", pstat->AxfrSuccess );
            dwStat( L"AXFR refused responses", pstat->AxfrRefused );
            dwStat( L"AXFR invalid responses", pstat->AxfrInvalid );

            dwStat( L"Stub zone AXFR requests", pstat->StubAxfrRequest );
            dwStat( L"Stub zone AXFR responses", pstat->StubAxfrResponse );
            dwStat( L"Stub zone AXFR success responses", pstat->StubAxfrSuccess );
            dwStat( L"Stub zone AXFR refused responses", pstat->StubAxfrRefused );
            dwStat( L"Stub zone AXFR invalid responses", pstat->StubAxfrInvalid );

            dwStat( L"IXFR UDP requests", pstat->IxfrUdpRequest );
            dwStat( L"IXFR UDP responses", pstat->IxfrUdpResponse );
            dwStat( L"IXFR UDP success responses", pstat->IxfrUdpSuccess );
            dwStat( L"IXFR UDP UseTcp responses", pstat->IxfrUdpUseTcp );
            dwStat( L"IXFR UDP UseAxfr responses", pstat->IxfrUdpUseAxfr );
            dwStat( L"IXFR UDP new primary responses", pstat->IxfrUdpNewPrimary );
            dwStat( L"IXFR UDP refused responses", pstat->IxfrUdpRefused );
            dwStat( L"IXFR UDP wrong server responses", pstat->IxfrUdpWrongServer );
            dwStat( L"IXFR UDP FormError responses", pstat->IxfrUdpFormerr );
            dwStat( L"IXFR UDP invalid responses", pstat->IxfrUdpInvalid );

            dwStat( L"IXFR TCP requests", pstat->IxfrTcpRequest );
            dwStat( L"IXFR TCP responses", pstat->IxfrTcpResponse );
            dwStat( L"IXFR TCP success responses", pstat->IxfrTcpSuccess );
            dwStat( L"IXFR TCP AXFR responses", pstat->IxfrTcpAxfr );
            dwStat( L"IXFR TCP FormError responses", pstat->IxfrTcpFormerr );
            dwStat( L"IXFR TCP refused responses", pstat->IxfrTcpRefused );
            dwStat( L"IXFR TCP invalid responses", pstat->IxfrTcpInvalid );
            break;
        }

        case DNSSRV_STATID_WINS:
        {
            PDNSSRV_WINS_STATS  pstat = ( PDNSSRV_WINS_STATS ) pStat;

            dwStat( L"WINS forward lookups", pstat->WinsLookups );
            dwStat( L"WINS forward lookup responses", pstat->WinsResponses );
            dwStat( L"WINS reverse lookups", pstat->WinsReverseLookups );
            dwStat( L"WINS reverse lookup responses", pstat->WinsReverseResponses );
            break;
        }

        case DNSSRV_STATID_NBSTAT:
        {
            PDNSSRV_NBSTAT_STATS  pstat = (PDNSSRV_NBSTAT_STATS)pStat;

            dwStat( L"Nbstat total buffers allocated", pstat->NbstatAlloc );
            dwStat( L"Nbstat total buffers freed", pstat->NbstatFree );
            dwStat( L"Nbstat net buffers allocated", pstat->NbstatNetAllocs );
            dwStat( L"Nbstat net bytes allocated", pstat->NbstatMemory );
            dwStat( L"Nbstat memory highwater mark", pstat->NbstatUsed );
            dwStat( L"Nbstat buffers returned", pstat->NbstatReturn );
            dwStat( L"Nbstat buffers in use", pstat->NbstatInUse );
            dwStat( L"Nbstat buffers on free list", pstat->NbstatInFreeList );
            break;
        }

        case DNSSRV_STATID_WIRE_UPDATE:
        case DNSSRV_STATID_NONWIRE_UPDATE:
        {
            PDNSSRV_UPDATE_STATS  pstat = ( PDNSSRV_UPDATE_STATS ) pStat;

            dwStat( L"Updates received", pstat->Received );
            dwStat( L"Updates forwarded", pstat->Forwards );
            dwStat( L"Updates retried", pstat->Retry );
            dwStat( L"Updates empty (precon only)", pstat->Empty );
            dwStat( L"Updates NoOps (duplicates)", pstat->NoOps );
            dwStat( L"Updates rejected", pstat->Rejected );
            dwStat( L"Updates completed", pstat->Completed );
            dwStat( L"Updates timed out", pstat->Timeout );
            dwStat( L"Updates in queue", pstat->InQueue );

            dwStat( L"Updates rejected", pstat->Rejected );
            dwStat( L"Updates rejected with FormError", pstat->FormErr );
            dwStat( L"Updates rejected with NameError", pstat->NxDomain );
            dwStat( L"Updates rejected with NotImpl", pstat->NotImpl );
            dwStat( L"Updates rejected with Refused", pstat->Refused );
            dwStat( L"Updates rejected with Refused (nonsecure)", pstat->RefusedNonSecure );
            dwStat( L"Updates rejected with Refused (access denied)", pstat->RefusedAccessDenied );
            dwStat( L"Updates rejected with YxDomain", pstat->YxDomain );
            dwStat( L"Updates rejected with YxRRSet", pstat->YxRrset );
            dwStat( L"Updates rejected with NxRRSet", pstat->NxRrset );
            dwStat( L"Updates rejected with NotAuth", pstat->NotAuth );
            dwStat( L"Updates rejected with NotZone", pstat->NotZone );


            dwStat( L"Secure update successes", pstat->SecureSuccess );
            dwStat( L"Secure update continues", pstat->SecureContinue );
            dwStat( L"Secure update failures", pstat->SecureFailure );
            dwStat( L"Secure update DS write failures", pstat->SecureDsWriteFailure );

            dwStat( L"Updates forwarded via TCP", pstat->TcpForwards );
            dwStat( L"Responses for forwarded updates", pstat->ForwardResponses );
            dwStat( L"Timeouts for forwarded updates", pstat->ForwardTimeouts );
            dwStat( L"Forwarded updates in queue", pstat->ForwardInQueue );

            dnsWrapAddStatisticsForTypeArray(
                pClass,
                pHandler,
                statCollIdx,
                L"Updates",
                pstat->UpdateType );
            break;
        }

        case DNSSRV_STATID_DS:
        {
            PDNSSRV_DS_STATS  pstat = ( PDNSSRV_DS_STATS ) pStat;

            dwStat( L"Nodes read", pstat->DsTotalNodesRead );
            dwStat( L"Records read", pstat->DsTotalRecordsRead );
            dwStat( L"Nodes loaded", pstat->DsNodesLoaded );
            dwStat( L"Records loaded", pstat->DsRecordsLoaded );
            dwStat( L"Update searches", pstat->DsUpdateSearches );
            dwStat( L"Update nodes read", pstat->DsUpdateNodesRead );
            dwStat( L"Update records read", pstat->DsUpdateRecordsRead );

            dwStat( L"Nodes added", pstat->DsNodesAdded );
            dwStat( L"Nodes modified", pstat->DsNodesModified );
            dwStat( L"Nodes tombstoned", pstat->DsNodesTombstoned );
            dwStat( L"Tombstones read", pstat->DsTombstonesRead );
            dwStat( L"Nodes deleted", pstat->DsNodesDeleted );
            dwStat( L"Nodes write suppressed", pstat->DsWriteSuppressed );
            dwStat( L"RR sets added", pstat->DsRecordsAdded );
            dwStat( L"RR sets replaced", pstat->DsRecordsReplaced );
            dwStat( L"Serial number writes", pstat->DsSerialWrites );
    
            dwStat( L"Update lists", pstat->UpdateLists );
            dwStat( L"Update nodes", pstat->UpdateNodes );
            dwStat( L"Updates suppressed ", pstat->UpdateSuppressed );
            dwStat( L"Update writes", pstat->UpdateWrites );
            dwStat( L"Update tombstones", pstat->UpdateTombstones );
            dwStat( L"Update record changes", pstat->UpdateRecordChange );
            dwStat( L"Update aging refresh", pstat->UpdateAgingRefresh );
            dwStat( L"Update aging on", pstat->UpdateAgingOn );
            dwStat( L"Update aging off", pstat->UpdateAgingOff );
            dwStat( L"Update from packet", pstat->UpdatePacket );
            dwStat( L"Update from packet (precon)", pstat->UpdatePacketPrecon );
            dwStat( L"Update from admin", pstat->UpdateAdmin );
            dwStat( L"Update from auto config", pstat->UpdateAutoConfig );
            dwStat( L"Update from scavenge", pstat->UpdateScavenge );

            dwStat( L"LDAP timed writes", pstat->LdapTimedWrites );
            dwStat( L"LDAP total write time", pstat->LdapWriteTimeTotal );
            dwStat( L"LDAP average write time", pstat->LdapWriteAverage );
            dwStat( L"LDAP writes < 10 ms", pstat->LdapWriteBucket0 );
            dwStat( L"LDAP writes < 100 ms", pstat->LdapWriteBucket1 );
            dwStat( L"LDAP writes < 1 s", pstat->LdapWriteBucket2 );
            dwStat( L"LDAP writes < 10 s", pstat->LdapWriteBucket3 );
            dwStat( L"LDAP writes < 100 s", pstat->LdapWriteBucket4 );
            dwStat( L"LDAP writes > 100 s", pstat->LdapWriteBucket5 );
            dwStat( L"LDAP writes max timeout", pstat->LdapWriteMax );

            dwStat( L"Total LDAP search time", pstat->LdapSearchTime );

            dwStat( L"Failed deletions", pstat->FailedDeleteDsEntries );
            dwStat( L"Failed reads", pstat->FailedReadRecords );
            dwStat( L"Failed modifies", pstat->FailedLdapModify );
            dwStat( L"Failed adds", pstat->FailedLdapAdd );

            dwStat( L"Polling passes with DS errors", pstat->PollingPassesWithDsErrors );

            dnsWrapAddStatisticsForTypeArray(
                pClass,
                pHandler,
                statCollIdx,
                L"LDAP writes",
                pstat->DsWriteType );
            break;
        }

        case DNSSRV_STATID_SKWANSEC:
        {
            PDNSSRV_SKWANSEC_STATS pstat = ( PDNSSRV_SKWANSEC_STATS ) pStat;

            dwStat( L"Security contexts created", pstat->SecContextCreate );
            dwStat( L"Security contexts freed", pstat->SecContextFree );
            dwStat( L"Security contexts timed out", pstat->SecContextTimeout );
            dwStat( L"Security contexts queue length", pstat->SecContextQueueLength );
            dwStat( L"Security contexts queued", pstat->SecContextQueue );
            dwStat( L"Security contexts queued in negotiation", pstat->SecContextQueueInNego );
            dwStat( L"Security contexts queued negotiation complete", pstat->SecContextQueueNegoComplete );
            dwStat( L"Security contexts dequeued", pstat->SecContextDequeue );

            dwStat( L"Security packet contexts allocated", pstat->SecPackAlloc );
            dwStat( L"Security packet contexts freed", pstat->SecPackFree );

            dwStat( L"Invalid TKEYs", pstat->SecTkeyInvalid );
            dwStat( L"Bad time TKEYs", pstat->SecTkeyBadTime );

            dwStat( L"FormErr TSIGs", pstat->SecTsigFormerr );
            dwStat( L"Echo TSIGs", pstat->SecTsigEcho );
            dwStat( L"BadKey TSIGs", pstat->SecTsigBadKey );
            dwStat( L"Verify success TSIGs", pstat->SecTsigVerifySuccess );
            dwStat( L"Verify failed TSIGs", pstat->SecTsigVerifyFailed );
            break;
        }

        case DNSSRV_STATID_MEMORY:
        {
            PDNSSRV_MEMORY_STATS pstat = ( PDNSSRV_MEMORY_STATS ) pStat;
            LPSTR * pnameArray = MemTagStrings;
            DWORD   count = MEMTAG_COUNT;

            dwStat( L"Total memory", pstat->StdUsed );
            dwStat( L"Allocation count", pstat->Alloc );
            dwStat( L"Free count", pstat->Free );

            dwStat( L"Standard allocs used", pstat->StdUsed );
            dwStat( L"Standard allocs returned", pstat->StdReturn );
            dwStat( L"Standard allocs in use", pstat->StdInUse );
            dwStat( L"Standard allocs memory", pstat->StdMemory );

            dwStat( L"Standard to heap allocs used", pstat->StdToHeapAlloc );
            dwStat( L"Standard to heap allocs returned", pstat->StdToHeapFree );
            dwStat( L"Standard to heap allocs in use", pstat->StdToHeapInUse );
            dwStat( L"Standard to heap allocs memory", pstat->StdToHeapMemory );

            dwStat( L"Standard blocks allocated", pstat->StdBlockAlloc );
            dwStat( L"Standard blocks used", pstat->StdBlockUsed );
            dwStat( L"Standard blocks returned", pstat->StdBlockReturn );
            dwStat( L"Standard blocks in use", pstat->StdBlockInUse );
            dwStat( L"Standard blocks in free list", pstat->StdBlockFreeList );
            dwStat( L"Standard block memory in free list", pstat->StdBlockFreeListMemory );
            dwStat( L"Standard block total memory", pstat->StdBlockMemory );

            for ( DWORD i = 0; i < count; ++i )
            {
                WCHAR sz[ 80 ];

                wsprintfW( sz, L"%S blocks allocated", pnameArray[ i ] );
                dwStat( sz, pstat->MemTags[ i ].Alloc );
                wsprintfW( sz, L"%S blocks freed", pnameArray[ i ] );
                dwStat( sz, pstat->MemTags[ i ].Free );
                wsprintfW( sz, L"%S blocks in use", pnameArray[ i ] );
                dwStat( sz, pstat->MemTags[ i ].Alloc - pstat->MemTags[ i ].Free );
                wsprintfW( sz, L"%S memory", pnameArray[ i ] );
                dwStat( sz, pstat->MemTags[ i ].Memory );
            }
            break;
        }

        case DNSSRV_STATID_DBASE:
        {
            PDNSSRV_DBASE_STATS  pstat = ( PDNSSRV_DBASE_STATS ) pStat;

            dwStat( L"Database nodes used", pstat->NodeUsed );
            dwStat( L"Database nodes returned", pstat->NodeReturn );
            dwStat( L"Database nodes in use", pstat->NodeInUse );
            dwStat( L"Database nodes memory", pstat->NodeMemory );
            break;
        }

        case DNSSRV_STATID_RECORD:
        {
            PDNSSRV_RECORD_STATS  pstat = ( PDNSSRV_RECORD_STATS ) pStat;

            dwStat( L"Records used", pstat->Used );
            dwStat( L"Records returned", pstat->Return );
            dwStat( L"Records in use", pstat->InUse );
            dwStat( L"Records memory", pstat->Memory );
            dwStat( L"Records queued for slow free", pstat->SlowFreeQueued );
            dwStat( L"Records slow freed", pstat->SlowFreeFinished );
            dwStat( L"Total records cached", pstat->CacheTotal );
            dwStat( L"Records currently cached", pstat->CacheCurrent );
            dwStat( L"Cached records timed out", pstat->CacheTimeouts );
            break;
        }

        case DNSSRV_STATID_PACKET:
        {
            PDNSSRV_PACKET_STATS  pstat = ( PDNSSRV_PACKET_STATS ) pStat;

            dwStat( L"UDP messages allocated", pstat->UdpAlloc );
            dwStat( L"UDP messages freed", pstat->UdpFree );
            dwStat( L"UDP messages net allocations", pstat->UdpNetAllocs );
            dwStat( L"UDP messages memory", pstat->UdpMemory );
            dwStat( L"UDP messages used", pstat->UdpUsed );
            dwStat( L"UDP messages returned", pstat->UdpReturn );
            dwStat( L"UDP messages in use", pstat->UdpInUse );
            dwStat( L"UDP messages in free list", pstat->UdpInFreeList );

            dwStat( L"UDP messages allocated", pstat->TcpAlloc );
            dwStat( L"UDP messages reallocated", pstat->TcpRealloc );
            dwStat( L"UDP messages freed", pstat->TcpFree );
            dwStat( L"UDP messages net allocations", pstat->TcpNetAllocs );
            dwStat( L"UDP messages memory", pstat->TcpMemory );

            dwStat( L"Recursion messages used", pstat->RecursePacketUsed );
            dwStat( L"Recursion messages returned", pstat->RecursePacketReturn );
            break;
        }

        case DNSSRV_STATID_TIMEOUT:
        {
            PDNSSRV_TIMEOUT_STATS  pstat = ( PDNSSRV_TIMEOUT_STATS ) pStat;

            dwStat( L"Nodes queued", pstat->SetTotal );
            dwStat( L"Nodes directed queued", pstat->SetDirect );
            dwStat( L"Nodes queued from reference", pstat->SetFromDereference );
            dwStat( L"Nodes queued from child delete", pstat->SetFromChildDelete );
            dwStat( L"Nodes duplicate (already queued)", pstat->AlreadyInSystem );

            dwStat( L"Nodes checked", pstat->Checks );
            dwStat( L"Recent access nodes checked", pstat->RecentAccess );
            dwStat( L"Active record nodes checked", pstat->ActiveRecord );
            dwStat( L"Can not delete nodes checked", pstat->CanNotDelete );
            dwStat( L"Deleted nodes checked", pstat->Deleted );

            dwStat( L"Timeout blocks created", pstat->ArrayBlocksCreated );
            dwStat( L"Timeout blocks deleted", pstat->ArrayBlocksDeleted );

            dwStat( L"Delayed frees queued", pstat->DelayedFreesQueued );
            dwStat( L"Delayed frees queued with function", pstat->DelayedFreesQueuedWithFunction );
            dwStat( L"Delayed frees executed", pstat->DelayedFreesExecuted );
            dwStat( L"Delayed frees executed with function", pstat->DelayedFreesExecutedWithFunction );
            break;
        }

        case DNSSRV_STATID_ERRORS:
        {
            PDNSSRV_ERROR_STATS pstat = ( PDNSSRV_ERROR_STATS ) pStat;

            dwStat( L"NoError", pstat->NoError );
            dwStat( L"FormError", pstat->FormError );
            dwStat( L"ServFail", pstat->ServFail );
            dwStat( L"NxDomain", pstat->NxDomain );
            dwStat( L"NotImpl", pstat->NotImpl );
            dwStat( L"Refused", pstat->Refused );
            dwStat( L"YxDomain", pstat->YxDomain );
            dwStat( L"YxRRSet", pstat->YxRRSet );
            dwStat( L"NxRRSet", pstat->NxRRSet );
            dwStat( L"NotAuth", pstat->NotAuth );
            dwStat( L"NotZone", pstat->NotZone );
            dwStat( L"Max", pstat->Max );
            dwStat( L"BadSig", pstat->BadSig );
            dwStat( L"BadKey", pstat->BadKey );
            dwStat( L"BadTime", pstat->BadTime );
            dwStat( L"UnknownError", pstat->UnknownError );
            break;
        }

        case DNSSRV_STATID_CACHE:
        {
            PDNSSRV_CACHE_STATS pstat = ( PDNSSRV_CACHE_STATS ) pStat;

            dwStat( L"Checks where cache exceeded limit", pstat->CacheExceededLimitChecks );
            dwStat( L"Successful cache enforcement passes", pstat->SuccessfulFreePasses );
            dwStat( L"Failed cache enforcement passes", pstat->FailedFreePasses );
            dwStat( L"Passes requiring aggressive free", pstat->PassesRequiringAggressiveFree );
            dwStat( L"Passes where nothing was freed", pstat->PassesWithNoFrees );
            break;
        }

        default:
            break;
    }

    //
    //  Cleanup and return.
    //

    return sc;
}



SCODE
CDnsWrap::dnsGetStatistics(
    IWbemClassObject *  pClass,
    IWbemObjectSink *   pHandler,
    DWORD               dwStatId
    )
/*++

Routine Description:

    Retrieve DNS statistics.

Arguments:

    dwStatId -- statistic ID or zero for all

    pClass -- ptr to StatisticsCollection class object

Return Value:

    None

--*/
{
    SCODE               sc = S_OK;
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_RPC_BUFFER     pstatbuff = NULL;
    BSTR                bstrStatClass = NULL;
    IWbemClassObject *  pStatClass = NULL;

    //
    //  Retrieve RPC stat buffer from server.
    //

    if ( dwStatId == 0 )
    {
        dwStatId = DNSSRV_STATID_ALL;
    }
    status = DnssrvGetStatistics(
                PVD_DNS_LOCAL_SERVER, 
                dwStatId,
                &pstatbuff );
    if ( status != ERROR_SUCCESS )
    {
        ThrowException( status );
    }
    if ( !pstatbuff )
    {
        ThrowException( ERROR_NO_DATA );
    }

    //
    //  Iterate stats in buffer. Add each "single stat" in the buffer
    //  to the WMI instance as a StatisticCollection. Add each individual
    //  statistics in each "single stat" buffer as a value to that
    //  statistic collection.
    //

    PDNSSRV_STAT    pstat;
    PBYTE           pch = &pstatbuff->Buffer[ 0 ];
    PBYTE           pchstop = pch + pstatbuff->dwLength;

    while ( sc == S_OK && pch < pchstop )
    {
        pstat = ( PDNSSRV_STAT ) pch;
        pch = ( PBYTE ) GET_NEXT_STAT_IN_BUFFER( pstat );

        sc = dnsWrapHandleSingleStat( pClass, pHandler, pstat );
        if ( sc != S_OK )
        {
            break;
        }
    }

    //
    //  Cleanup and return.
    //

    SysFreeString( bstrStatClass );
    if ( pstatbuff )
    {
        MIDL_user_free( pstatbuff );
    }
    if ( pStatClass )
    {
        pStatClass->Release();
    }
    return sc;
}   //  CDnsWrap::dnsGetStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnsserverdomaincontainment.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: DnsServerDomainContainment.cpp
//
//  Description:    
//      Implementation of CDnsServerDomainContainment class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		create an instance of CDnsServerDomainContainment
//
//	Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
CDnsBase* 
CDnsServerDomainContainment::CreateThis(
    const WCHAR *       wszName,        
    CWbemServices *     pNamespace,  
    const char *        szType       
    )
{
    return new CDnsServerDomainContainment(wszName, pNamespace);
}
CDnsServerDomainContainment::CDnsServerDomainContainment()
{

}
CDnsServerDomainContainment::CDnsServerDomainContainment(
	const WCHAR* wszName,
	CWbemServices *pNamespace)
	:CDnsBase(wszName, pNamespace)
{
	
}

CDnsServerDomainContainment::~CDnsServerDomainContainment()
{

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		enum instances of dns server and domain association
//
//	Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsServerDomainContainment::EnumInstance( 
	long				lFlags,
	IWbemContext *		pCtx,
	IWbemObjectSink *	pHandler
    )
{
	list<CObjPath> opList;
	list<CObjPath>::iterator i;
	SCODE sc;
	CDnsWrap& dns = CDnsWrap::DnsObject();
	sc = dns.dnsEnumDomainForServer(&opList);
	if (FAILED(sc))
	{
		return sc;
	}

	CObjPath opServer;
	opServer.SetClass(PVD_CLASS_SERVER);
	opServer.AddProperty(
		PVD_SRV_SERVER_NAME,
		dns.GetServerName().data());

	for(i=opList.begin(); i!=opList.end(); ++i)
	{
		CWbemClassObject Inst;
		m_pClass->SpawnInstance(0, &Inst);
		Inst.SetProperty(
			opServer.GetObjectPathString(), 
			PVD_ASSOC_PARENT);
		Inst.SetProperty(
			(*i).GetObjectPathString(), 
			PVD_ASSOC_CHILD); 
		pHandler->Indicate(1, &Inst);
	}
	
	return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Description:
//		retrieve server domain association object pointed by the 
//      given object path
//
//	Arguments:
//      ObjectPath          [IN]    object path to object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsServerDomainContainment::GetObject(
	CObjPath &          ObjectPath,
	long                lFlags,
	IWbemContext  *     pCtx,
	IWbemObjectSink *   pHandler
    )
{
		return WBEM_E_NOT_SUPPORTED;
}

SCODE 
CDnsServerDomainContainment::ExecuteMethod(	
	CObjPath&,
	WCHAR*,
	long,
	IWbemClassObject*,
	IWbemObjectSink*) 
{
		return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnszone.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: dnszone.cpp
//
//  Description:    
//      Implementation of CDnsZone class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        create an instance of CDnsZone
//
//    Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

CDnsBase* 
CDnsZone::CreateThis(
    const WCHAR *       wszName,        
    CWbemServices *     pNamespace,  
    const char *        szType       
    )
{
    return new CDnsZone(wszName, pNamespace);
}
CDnsZone::CDnsZone()
{

}

CDnsZone::CDnsZone(
    const WCHAR* wszName,
    CWbemServices *pNamespace)
    :CDnsBase(wszName, pNamespace)
{

}

CDnsZone::~CDnsZone()
{

}
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enum instances of dns zone
//
//    Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsZone::EnumInstance( 
    long                lFlags,
    IWbemContext *        pCtx,
    IWbemObjectSink *    pHandler)
{
    list<CDomainNode> opList;
    list<CDomainNode>::iterator i;
    SCODE sc;
    CDnsWrap& dns = CDnsWrap::DnsObject();
    sc = dns.dnsEnumDomainForServer(&opList);
    if (FAILED(sc))
    {
        return sc;
    }


    for(i=opList.begin(); i!=opList.end(); ++i)
    {
        if(_wcsicmp(i->wstrZoneName.data(), PVD_DNS_CACHE)  &&
            _wcsicmp(i->wstrZoneName.data(), PVD_DNS_ROOTHINTS) )
        {
            CWbemClassObject Inst;
            m_pClass->SpawnInstance(0, &Inst);
            sc = dns.dnsGetZone(
                dns.GetServerName().data(),
                i->wstrZoneName.data(),
                Inst,
                pHandler);
            if ( SUCCEEDED ( sc ) )
            {
                pHandler->Indicate(1, &Inst);
            }
            
        }
    }

    return sc;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        retrieve record object pointed by the given object path
//
//    Arguments:
//      ObjectPath          [IN]    object path to object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsZone::GetObject(
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext  *     pCtx,
    IWbemObjectSink *   pHandler)
{
    DBG_FN( "CDnsZone::GetObject" )

    wstring wstrZone = ObjectPath.GetStringValueForProperty(
        PVD_DOMAIN_CONTAINER_NAME);
    wstring wstrNode = ObjectPath.GetStringValueForProperty(
        PVD_DOMAIN_FQDN);

    DNS_DEBUG( INSTPROV, (
        "%s: zone %S\n", fn, wstrNode.c_str() ));

    // incase of zone, container name and fqdn are same
    // roothints and cache are managed by roothints and cache class
    if( (_wcsicmp(wstrZone.data(), wstrNode.data()) != 0 ) ||
        _wcsicmp(wstrZone.data(), PVD_DNS_CACHE) == 0 ||
        _wcsicmp(wstrZone.data(), PVD_DNS_ROOTHINTS) ==0 )
    {
        return WBEM_S_NO_ERROR;
    }

    CWbemClassObject Inst;
    m_pClass->SpawnInstance(0, &Inst);

    CDnsWrap& dns = CDnsWrap::DnsObject();
    SCODE sc = dns.dnsGetZone(
        PVD_DNS_LOCAL_SERVER,
        ObjectPath.GetStringValueForProperty(PVD_DOMAIN_CONTAINER_NAME).data(),
        Inst,
        pHandler);
    if( SUCCEEDED ( sc ) )
    {
        pHandler->Indicate(1, &Inst);
    }

    return sc;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        save this instance
//
//    Arguments:
//      InstToPut           [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsZone::PutInstance( 
    IWbemClassObject *  pInst ,
    long                lFlags,
    IWbemContext*       pCtx ,
    IWbemObjectSink *   pHandler)
{
    DBG_FN( "CDnsZone::PutInstance" )

    DNS_DEBUG( INSTPROV, (
        "%s: pInst=%p\n", fn, pInst ));

    CDnsWrap& dns = CDnsWrap::DnsObject();
    CWbemClassObject Inst(pInst);
    return dns.dnsZonePut(Inst);
}; 

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        delete the object specified in ObjectPath
//
//    Arguments:
//      ObjectPath          [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////


SCODE 
CDnsZone::DeleteInstance( 
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext *      pCtx,
    IWbemObjectSink *   pHandler) 
{
    CDnsWrap& dns = CDnsWrap::DnsObject();
    SCODE sc =  dns.dnsDeleteZone(ObjectPath);
    pHandler->SetStatus(
        0,
        sc, 
        NULL, 
        NULL);
    return sc;

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        execute methods defined in the mof 
//
//    Arguments:
//      ObjPath             [IN]    pointing to the object that the 
//                                  method should be performed on
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsZone::ExecuteMethod(
    CObjPath &          ObjPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler) 
{
    DBG_FN( "CDnsZone::ExecuteMethod" )

    CDnsWrap& dns = CDnsWrap::DnsObject();
    wstring wstrZoneName =  ObjPath.GetStringValueForProperty(
        PVD_DOMAIN_CONTAINER_NAME);
    string strZoneName;
    WcharToString(wstrZoneName.data(), strZoneName);
    SCODE sc;
    if(_wcsicmp(wzMethodName,  PVD_MTH_ZONE_PAUSEZONE) == 0)
    {
        //sc = dns.dnsPauseZone(strZoneName.data());
        sc = dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_PAUSE_ZONE);
    }
    else if(_wcsicmp(wzMethodName, PVD_MTH_ZONE_RESUMEZONE) == 0)
    {
        //sc = dns.dnsResumeZone(strZoneName.data());
        sc = dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_RESUME_ZONE);
    }
    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_RELOADZONE ) == 0)
    {
        sc = dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_RELOAD_ZONE);
    }
    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_FORCEREFRESH ) == 0)
    {
        sc = dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_REFRESH_SECONDARY);
    }
    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_UPDATEFROMDS ) == 0)
    {
    
        sc = dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_DS_UPDATE );
    }
    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_WRITEBACKZONETOFILE ) == 0)
    {
            sc = dns.dnsOperation(
            strZoneName,
            CDnsWrap::DNS_WRAP_WRITE_BACK_ZONE);
    }

    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_CHANGEZONETYPE) == 0)
    {
        CWbemClassObject Inst(pInArgs);
        string strDataFile, strAdmin;
        DWORD *pIp=NULL, cIp=0, dwZoneType=-1;

        Inst.GetProperty(
            strDataFile,
            PVD_MTH_ZONE_ARG_DATAFILENAME);
        
        Inst.GetProperty(
            strAdmin,
            PVD_MTH_ZONE_ARG_ADMINEMAILNAME);

        Inst.GetProperty(
            &pIp,
            &cIp,
            PVD_MTH_ZONE_ARG_IPADDRARRAY);
        Inst.GetProperty(
            &dwZoneType,
            PVD_MTH_ZONE_ARG_ZONETYPE);
        
        sc = dns.dnsZoneChangeType(
            strZoneName,
            dwZoneType,
            strDataFile,
            strAdmin,
            pIp,
            cIp);
        delete [] pIp;
    }

    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_CREATEZONE) == 0)
    {
        CWbemClassObject Inst(pInArgs);
        CWbemClassObject wcoOutArgs;
        CWbemClassObject wcoOutArgsClass;
        string strDataFile, strAdmin, strNewZoneName;
        strAdmin = "Admin";
        DWORD *pIp=NULL, cIp=0, dwZoneType=-1;
        
        sc = m_pClass->GetMethod(wzMethodName, 0, NULL, &wcoOutArgsClass );
        if( FAILED ( sc ) )
        {
            return sc;
        }
    
        wcoOutArgsClass.SpawnInstance(0, & wcoOutArgs);

        Inst.GetProperty(
            strDataFile,
            PVD_MTH_ZONE_ARG_DATAFILENAME);
        
        Inst.GetProperty(
            strAdmin,
            PVD_MTH_ZONE_ARG_ADMINEMAILNAME);

        Inst.GetProperty(
            &pIp,
            &cIp,
            PVD_MTH_ZONE_ARG_IPADDRARRAY);
        Inst.GetProperty(
            &dwZoneType,
            PVD_MTH_ZONE_ARG_ZONETYPE);
        Inst.GetProperty(
            strNewZoneName,
            PVD_MTH_ZONE_ARG_ZONENAME);
        
        sc = dns.dnsZoneCreate(
            strNewZoneName,
            dwZoneType,
            strDataFile,
            strAdmin,
            pIp,
            cIp);
        if ( SUCCEEDED ( sc ) )
        {
            CWbemClassObject wco;
            wstring wstrObjPath;
            m_pClass->SpawnInstance( 0 , & wco );
            

            wco.SetProperty(
                PVD_DNS_LOCAL_SERVER,
                PVD_DOMAIN_SERVER_NAME );
            wco.SetProperty(
                strNewZoneName.data(),
                PVD_DOMAIN_CONTAINER_NAME );
            wco.SetProperty(
                strNewZoneName.data(),
                PVD_DOMAIN_FQDN );
            wco.GetProperty(
                wstrObjPath,
                L"__RelPath");
            wcoOutArgs.SetProperty(
                wstrObjPath,
                L"RR" );
            pHandler->Indicate( 1, & wcoOutArgs );
        }
        delete [] pIp;
    }
    else if(_wcsicmp(
        wzMethodName, 
        PVD_MTH_ZONE_RESETSECONDARYIPARRAY) == 0)
    {
        DNS_DEBUG( INSTPROV, (
            "%s: executing %S\n", fn, PVD_MTH_ZONE_RESETSECONDARYIPARRAY ));

        CWbemClassObject Inst(pInArgs);
        DWORD *pSecondaryIp=NULL, cSecondaryIp=0, dwSecurity=-1;
        DWORD *pNotifyIp=NULL, cNotifyIp=0, dwNotify=-1;

        Inst.GetProperty(
            &pSecondaryIp,
            &cSecondaryIp,
            PVD_MTH_ZONE_ARG_SECONDARYIPARRAY);
        Inst.GetProperty(
            &pNotifyIp,
            &cNotifyIp,
            PVD_MTH_ZONE_ARG_NOTIFYIPARRAY);

        Inst.GetProperty(
            &dwSecurity,
            PVD_MTH_ZONE_ARG_SECURITY);
        Inst.GetProperty(
            &dwNotify,
            PVD_MTH_ZONE_ARG_NOTIFY);
        
        sc = dns.dnsZoneResetSecondary(
            strZoneName,
            dwSecurity,
            pSecondaryIp,
            cSecondaryIp,
            dwNotify,
            pNotifyIp,
            cNotifyIp);

        DNS_DEBUG( INSTPROV, (
            "%s: dnsZoneResetSecondary returned 0x%08X\n", fn, sc ));

        delete [] pSecondaryIp;
        delete [] pNotifyIp;
    }
    else if(_wcsicmp(
        wzMethodName,
        PVD_MTH_ZONE_GETDISTINGUISHEDNAME) == 0)
    {
        wstring wstrName;
        CWbemClassObject OutParams, OutClass, Class ;
        HRESULT hr;
    
        dns.dnsDsZoneName(wstrName, wstrZoneName);


        BSTR ClassName=NULL;
        ClassName = AllocBstr(PVD_CLASS_ZONE); 
        hr = m_pNamespace->GetObject(ClassName, 0, 0, &Class, NULL);
        SysFreeString(ClassName);
        if ( SUCCEEDED ( hr ) )
        {
            Class.GetMethod(wzMethodName, 0, NULL, &OutClass);
            OutClass.SpawnInstance(0, &OutParams);
            OutParams.SetProperty(wstrName, PVD_DNS_RETURN_VALUE);
            hr = pHandler->Indicate(1, &OutParams);
        }

        return hr;
    }
    else

    {
        return WBEM_E_NOT_SUPPORTED;    
    }
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnswrap.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnswrap.h
//
//	Implementation File:
//		dnswrap.cpp
//
//	Description:
//		Definition of the CDnsDomainDomainContainment class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include <list>
class CObjPath;
class CDomainNode;
class CWbemClassObject;
using namespace std;
/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDnsBase
//
//	Description:
//  this is a wrap class for dns rpc API used in the provider. This class is
//  implemented as singlton class, that's at any time, there is only one instance
//  of this class.
//  
//
//	Inheritance:
//	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsWrap  
{
protected:
// some def
	typedef SCODE (*FPDNSOPS)(
        const CHAR * pszZoneName,
		const WCHAR*,
		const CHAR*,
		CWbemClassObject&);
    //
    // map wbem property get and set to dns functions
    //
	typedef struct _table
	{
		const WCHAR* pwzProperty;//wbem property name
		CHAR*  OperationName;	// dns operation name
		FPDNSOPS fpOperationSet;
		FPDNSOPS fpOperationGet;
	} PropertyTable;

    //
    // dns server info class
    //
	class CServerInfo
	{
	public:
		CServerInfo();
		~CServerInfo();
		PVOID m_pInfo;
	};
// end def
	WCHAR* m_wszpServerName;

	PVOID GetPropertyTable(
        DWORD*  pdwSize
        );

public:
	typedef enum{
		DNS_WRAP_RELOAD_ZONE,
		DNS_WRAP_DS_UPDATE,
		DNS_WRAP_WRITE_BACK_ZONE,
		DNS_WRAP_REFRESH_SECONDARY,
		DNS_WRAP_RESUME_ZONE,
		DNS_WRAP_PAUSE_ZONE
		} OpsFlag;

	SCODE dnsClearCache(void);
	SCODE dnsResumeZone(
		const char* strZoneName
		);
	wstring GetServerName(void);
	SCODE dnsPauseZone(
		const char *strZoneName
		);
	static CDnsWrap& DnsObject(void);
	CDnsWrap();
	virtual ~CDnsWrap();
	SCODE dnsEnumRecordsForDomainEx(
	    CDomainNode&        objNode,
	    PVOID	            pFilter,
	    FILTER              pfFilter,
	    BOOL                bRecursive,
	    WORD                wType,
	    DWORD               dwFlag,
	    IWbemClassObject *  pClass,
	    CWbemInstanceMgr&   InstMgr
        );
	SCODE dnsGetDomain(
	    CObjPath&           objParent,
	    IWbemClassObject*   pClass,
	    IWbemObjectSink*    pHandler
    	);
	SCODE dnsEnumDomainForServer(
        list<CObjPath>* pList
		);
	SCODE dnsEnumDomainForServer(
		list<CDomainNode>* pList 
		);
	SCODE dnsDeleteDomain(
	    char *  pszContainer, 
        char *  pszDomain
        );
	SCODE dnsRestartServer(
		WCHAR* strServerName 
		);
	SCODE dnsDsServerName(
		wstring&);
	SCODE dnsDsZoneName(
		wstring& wstrDsName,
	    wstring& wstrInZone
        );
	SCODE dnsDsNodeName(
        wstring&    wstrDsName,
        wstring&    wstrInZone,
        wstring&    wstrInNode
        );
	SCODE dnsServerPropertySet(
	    CWbemClassObject&   Inst,
	    BOOL                bGet
        );
	SCODE dnsServerPropertyGet(
	    CWbemClassObject&   Inst,
	    BOOL                bGet
        );
	SCODE dnsQueryServerInfo(
	    const WCHAR*        strServerName,
	    CWbemClassObject&   NewInst,
	    IWbemObjectSink*    pHandler
		);
	SCODE dnsDeleteZone(
		CObjPath&   objZone
		);
	SCODE dnsGetZone(
	    const WCHAR*        wszServer, 
	    const WCHAR*        wszZone,
	    CWbemClassObject&   Inst,
	    IWbemObjectSink*    pHandler
		);
	SCODE dnsQueryProperty(
	    const WCHAR*    wszZoneName, 
	    const WCHAR*    wszPropertyName, 
	    DWORD*          pdwResult
		);

	static SCODE dnsGetDwordProperty(
        const char *        pszZoneName,
	    const WCHAR*        wszWbemProperty, 
	    const char*         pszOperationName,
	    CWbemClassObject&   Inst
        );
	
	static SCODE dnsSetDwordProperty(
        const char *        pszZoneName,
        const WCHAR*        wszWbemProperty, 
        const char*         pszOperationName,
        CWbemClassObject&   Inst
        );

    static SCODE 
    dnsGetStringProperty(
        const char *        pszZoneName,
        const WCHAR *       wszWbemProperty, 
        const char *        pszDnssrvPropertyName,
        CWbemClassObject&   Inst
        );

    static SCODE 
    dnsSetStringProperty(
        const char *        pszZoneName,
        const WCHAR *       wszWbemProperty, 
        const char *        pszDnssrvPropertyName,
        CWbemClassObject&   Inst
        );

    static SCODE 
    dnsGetIPArrayProperty(
        const char *        pszZoneName,
        const WCHAR *       wszWbemProperty, 
        const char *        pszDnssrvPropertyName,
        CWbemClassObject&   Inst
        );

    static SCODE 
    dnsSetIPArrayProperty(
        const char *        pszZoneName,
        const WCHAR *       wszWbemProperty, 
        const char *        pszDnssrvPropertyName,
        CWbemClassObject&   Inst
        );

	static SCODE dnsSetServerListenAddress(
        const char *        pszZoneName,
        const WCHAR*        wszWbemProperty, 
        const char*         pszOperationName,
        CWbemClassObject&   Inst
        );

	static SCODE dnsSetServerForwarders(
        const char *        pszZoneName,
        const WCHAR*        wszWbemProperty, 
        const char*         pszOperationName,
        CWbemClassObject&   Inst
        );

	SCODE dnsSetProperty(
        const WCHAR*    wszZoneName, 
        const char*     pszPropertyName, 
        DWORD           dwValue
        );

	SCODE dnsSetProperty(
        const char*     pszZoneName, 
        const char*     pszPropertyName, 
        DWORD           dwValue
        );

	SCODE ValidateServerName(
		const WCHAR*    pwzStr
		);

	SCODE dnsOperation(
		string&,	//zone name
		OpsFlag
		);

	SCODE dnsZoneCreate(
	    string& strZoneName,
	    DWORD	dwZoneType,
	    string&	strDataFile,
	    string& strAdmin,
	    DWORD*  pIp,
	    DWORD	cIp
		);

	SCODE dnsZoneChangeType(
        string& strZone,
        DWORD	dwZoneType,
        string&	strDataFile,
        string& strAdmin,
        DWORD*	pIp,
        DWORD	cIp
        );

	SCODE dnsZoneResetMaster(
        string& strZoneName,
        DWORD*  pMasterIp,
        DWORD   cMasterIp,
        DWORD   dwLocal
        );

	SCODE dnsZoneResetSecondary(
        string& strZoneName,
        DWORD   dwSecurity,
        DWORD*  pSecondaryIp,
        DWORD   cSecondaryIp,
        DWORD   dwNotify,
        DWORD * pNotifyIp,
        DWORD   cNotifyIp
        );

	SCODE dnsZonePut(
		CWbemClassObject& Inst
        );

    SCODE
    CDnsWrap::dnsGetStatistics(
        IWbemClassObject *  pClass,
        IWbemObjectSink *   pHandler,
        DWORD               dwStatId = 0
        );

	static void ThrowException(
		LONG    status
		);
	static void ThrowException(
		LPCSTR ErrString
		);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\instanceprov.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: instanceprov.cpp
//
//  Description:    
//      Implementation of CInstanceProv class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


long glNumInst = 0;



//***************************************************************************
//
// CInstanceProv::CInstanceProv
// CInstanceProv::~CInstanceProv
//
//***************************************************************************

CInstanceProv::CInstanceProv(
	BSTR ObjectPath,
	BSTR User, 
	BSTR Password, 
	IWbemContext * pCtx)
{
    DBG_FN( "ctor" )

    DNS_DEBUG( INSTPROV, (
        "%s: count before increment is %d\n"
        "  ObjectPath   %S\n"
        "  User         %S\n",
        fn, g_cObj, ObjectPath, User ));
        
    InterlockedIncrement(&g_cObj);
    return;
}

CInstanceProv::~CInstanceProv(void)
{
    DBG_FN( "dtor" )

    DNS_DEBUG( INSTPROV, (
        "%s: count before decrement is %d\n", fn, g_cObj ));
        
    InterlockedDecrement(&g_cObj);
#ifdef _DEBUG
	_CrtDumpMemoryLeaks();
#endif

    return;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::DoExecQueryAsync
//
//	Description:
//		enum instance for a given class
//
//	Arguments:
//      QueryLanguage       [IN]  
//           A valid BSTR containing one of the query languages 
//           supported by Windows Management. This must be WQL. 
//      Query               [IN]
//          A valid BSTR containing the text of the query
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CInstanceProv::DoExecQueryAsync( 
    BSTR             QueryLanguage,
    BSTR             Query,
    long             lFlags,
    IWbemContext     *pCtx,
    IWbemObjectSink  *pHandler
    ) 
{
    DBG_FN( "CIP::DoExecQueryAsync" )

    DNS_DEBUG( INSTPROV, (
        "%s: %S flags=%lu %S\n",
        fn, QueryLanguage, lFlags, Query ));

	SCODE sc = WBEM_S_NO_ERROR;
	try
	{
		CTextLexSource objQuerySource(Query);
		SQL1_Parser objParser(&objQuerySource);
		SQL_LEVEL_1_RPN_EXPRESSION * objQueryExpr = NULL;
		objParser.Parse( &objQueryExpr );
        if ( !objQueryExpr )
        {
            throw( WBEM_E_OUT_OF_MEMORY );
        }

		CDnsBase* pDns = NULL ;

		sc = CreateClass(
			objQueryExpr->bsClassName,
			m_pNamespace, 
			(void**) &pDns);
	
		if( FAILED ( sc ) )
		{
			return sc;
		}
		auto_ptr<CDnsBase> pDnsBase(pDns);
		
		int nNumTokens = objQueryExpr->nNumTokens;
		CSqlEval* pEval = CSqlEval::CreateClass(
			objQueryExpr,
			&nNumTokens);
		auto_ptr<CSqlEval> apEval(pEval);

		sc = pDnsBase->ExecQuery(
			&(*apEval),
			lFlags,
			pCtx,
			pHandler);
	}

	catch(CDnsProvException e)
	{
		CWbemClassObject Status;
	    SCODE sc = SetExtendedStatus(e.what(), Status);
        if ( SUCCEEDED ( sc ) )
        {
            sc = pHandler->SetStatus(0, WBEM_E_FAILED,NULL,*(&Status));
			return sc;
        }
		
	}

	catch(SCODE exSc)
	{
		sc = exSc;
	}

	catch(...)
	{
		sc =  WBEM_E_FAILED;
	}
	
	pHandler->SetStatus(0, sc,NULL,NULL);
	return sc;

};
    
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::DoCreateInstanceEnumAsync
//
//	Description:
//		enum instance for a given class
//
//	Arguments:
//      RefStr              [IN[    name the class to enumerate
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CInstanceProv::DoCreateInstanceEnumAsync( 
	BSTR                 RefStr,
	long                 lFlags,
	IWbemContext         *pCtx,
    IWbemObjectSink      *pHandler
    )
{
    DBG_FN( "CIP::DoCreateInstanceEnumAsync" );

    DNS_DEBUG( INSTPROV, (
        "%s: flags=%lu %S\n",
        fn, lFlags, RefStr ));
        
    SCODE sc;
    int iCnt;

    // Do a check of arguments and make sure we have pointer to Namespace

    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

	try
	{
	
		CDnsBase* pDns = NULL ;
		sc = CreateClass(RefStr, m_pNamespace, (void**) &pDns);
		if( FAILED ( sc ) )
		{
			return sc;
		}

		auto_ptr<CDnsBase> pDnsBase(pDns);
		sc = pDnsBase->EnumInstance(
            lFlags,
            pCtx,
            pHandler);
	}
	catch(CDnsProvException e)
	{
		CWbemClassObject Status;
	    SCODE sc = SetExtendedStatus(e.what(), Status);
        if ( SUCCEEDED ( sc ) )
        {
            sc = pHandler->SetStatus(0, WBEM_E_FAILED,NULL,*(&Status));
			return sc;
        }
		
	}
	catch(SCODE exSc)
	{
		sc = exSc;
	}
	catch(...)
	{
		
		sc =  WBEM_E_FAILED;
	}
	
	pHandler->SetStatus(0, sc,NULL,NULL);
	return sc;


}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::GetObject
//
//	Description:
//		Creates an instance given a particular path value.
//
//	Arguments:
//      ObjectPath          [IN]    object path to an object
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//      win32 error
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CInstanceProv::DoGetObjectAsync(
	BSTR                 ObjectPath,
	long                 lFlags,
	IWbemContext         *pCtx,
    IWbemObjectSink FAR* pHandler
    )
{
    DBG_FN( "CIP::DoGetObjectAsync" );

    DNS_DEBUG( INSTPROV, (
        "%s: flags=%lu %S\n",
        fn, lFlags, ObjectPath ));

    SCODE sc;
    IWbemClassObject FAR* pObj;
    BOOL bOK = FALSE;

    // Do a check of arguments and make sure we have pointer to Namespace

    if( ObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL )
    {
        DNS_DEBUG( INSTPROV, (
            "%s: bad parameter - WBEM_E_INVALID_PARAMETER\n", fn ));
        return WBEM_E_INVALID_PARAMETER;
    }

    // do the get, pass the object on to the notify
    
	try
	{
		CObjPath ObjPath;
		if(!ObjPath.Init(ObjectPath))
		{
            DNS_DEBUG( INSTPROV, (
                "%s: bad object path - WBEM_E_INVALID_PARAMETER\n", fn ));
			return WBEM_E_INVALID_PARAMETER;
		}
		
		CDnsBase* pDns = NULL;
		wstring wstrClass = ObjPath.GetClassName();
		sc = CreateClass(
			(WCHAR*)wstrClass.data(), 
			m_pNamespace,
			(void**) &pDns);

		if( FAILED(sc) )
		{
            DNS_DEBUG( INSTPROV, (
                "%s: CreateClass returned 0x%08X\n", fn, sc ));
			return sc;
		}
		auto_ptr<CDnsBase> pDnsBase(pDns);
		sc =  pDnsBase->GetObject(
			ObjPath,
			lFlags,
			pCtx, 
			pHandler);
	}
	catch( CDnsProvException e )
	{
        DNS_DEBUG( INSTPROV, (
            "%s: caught CDnsProvException \"%s\"\n", fn, e.what() ));
		CWbemClassObject Status;
	    SCODE sc = SetExtendedStatus(e.what(), Status);
        if ( SUCCEEDED ( sc ) )
        {
            sc = pHandler->SetStatus(0, WBEM_E_FAILED,NULL,*(&Status));
        
			return sc;
		}
		
	}
	catch(SCODE exSc)
	{
		sc = exSc;
	}
	catch(...)
	{
		sc = WBEM_E_FAILED;
	}
	
	pHandler->SetStatus(0, sc,NULL,NULL);
#ifdef _DEBUG
//	_CrtDumpMemoryLeaks();
#endif
	return sc;

}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::DoPutInstanceAsync
//
//	Description:
//		save this instance
//
//	Arguments:
//      pInst               [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CInstanceProv::DoPutInstanceAsync( 
	IWbemClassObject *pInst,
    long             lFlags,
	IWbemContext     *pCtx,
	IWbemObjectSink  *pHandler
    ) 
{
    DBG_FN( "CIP::DoPutInstanceAsync" )

    DNS_DEBUG( INSTPROV, (
        "%s: flags=%lu pInst=%p\n",
        fn, lFlags, pInst ));
        
	SCODE sc;
	
    if(pInst == NULL || pHandler == NULL )
    {
        DNS_DEBUG( INSTPROV, (
            "%s: returning WBEM_E_INVALID_PARAMETER\n" ));
        return WBEM_E_INVALID_PARAMETER;
    }
	try
	{
		// get class name
		wstring wstrClass;
		CWbemClassObject Inst(pInst);
		Inst.GetProperty(
			wstrClass,
			L"__Class");
	
		wstring wstrPath;
		Inst.GetProperty(
			wstrPath, 
			L"__RelPath");
		
				
		CDnsBase* pDns = NULL;
		sc = CreateClass(
			wstrClass.data(),
			m_pNamespace,
			(void**) &pDns);

		if( FAILED(sc) )
		{
			return sc;
		}
		auto_ptr<CDnsBase> pDnsBase(pDns);

        DNS_DEBUG( INSTPROV, (
            "%s: doing base PutInstance\n"
            "  class: %S\n"
            "  path: %S\n", 
            fn,
            wstrClass.c_str(),
            wstrPath.c_str() ));

		sc = pDnsBase->PutInstance(
				pInst, 
				lFlags,
				pCtx, 
				pHandler);
	}
	catch(CDnsProvException e)
	{
        DNS_DEBUG( INSTPROV, (
            "%s: caught CDnsProvException \"%s\"\n", fn,
            e.what() ));

		CWbemClassObject Status;
	    SCODE sc = SetExtendedStatus(e.what(), Status);
        if (SUCCEEDED ( sc ))
        {
            sc = pHandler->SetStatus(0, WBEM_E_FAILED,NULL,*(&Status));
			return sc;
        }

	}
	catch(SCODE exSc)
	{
        DNS_DEBUG( INSTPROV, (
            "%s: cauught SCODE 0x%08X\n", fn, exSc ));

		sc = exSc;
	}
	catch(...)
	{
        DNS_DEBUG( INSTPROV, (
            "%s: cauught unknown exception returning WBEM_E_FAILED\n", fn ));

		sc = WBEM_E_FAILED;
	}
	
	pHandler->SetStatus(0, sc,NULL,NULL);
#ifdef _DEBUG
//	_CrtDumpMemoryLeaks();
#endif
	return sc;


}
 
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::DoDeleteInstanceAsync
//
//	Description:
//		delete this instance
//
//	Arguments:
//      rObjPath            [IN]    ObjPath for the instance to be deleted
//      lFlags              [IN]    WMI flag
//      pCtx*               [IN]    WMI context
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////      
      
SCODE CInstanceProv::DoDeleteInstanceAsync( 
    BSTR                 ObjectPath,
    long                 lFlags,
    IWbemContext *       pCtx,
    IWbemObjectSink *    pHandler
     ) 
{
    DBG_FN( "CIP::DoDeleteInstanceAsync" );

    DNS_DEBUG( INSTPROV, (
        "%s: flags=%lu %S\n",
        fn, lFlags, ObjectPath ));

	SCODE sc;
 
    // Do a check of arguments and make sure we have pointer to Namespace

    if(ObjectPath == NULL || pHandler == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // do the get, pass the object on to the notify
    
	try
		{
		CObjPath ObjPath;
		if(!ObjPath.Init(ObjectPath))
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		
		CDnsBase* pDns = NULL;
		wstring wstrClass = ObjPath.GetClassName();
		sc = CreateClass(
			(WCHAR*)wstrClass.data(), 
			m_pNamespace, 
			(void**) &pDns);

		if( FAILED(sc) )
		{
			return sc;
		}
		auto_ptr<CDnsBase> pDnsBase(pDns);
		sc = pDnsBase->DeleteInstance(
			ObjPath,
			lFlags,
			pCtx, 
			pHandler);
	}
	catch(CDnsProvException e)
	{
		CWbemClassObject Status;
	    SCODE sc = SetExtendedStatus(e.what(), Status);
        if (SUCCEEDED ( sc ))
        {
            sc = pHandler->SetStatus(0, WBEM_E_FAILED,NULL,*(&Status));
			return sc;
		}
		
	}
	catch(SCODE exSc)
	{
		sc = exSc;
	}
	catch(...)
	{
		sc = WBEM_E_FAILED;
	}
	
	pHandler->SetStatus(0, sc,NULL,NULL);
	return sc;


}	
    
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::DoExecMethodAsync
//
//	Description:
//		execute methods for the given object
//
//	Arguments:
//      ObjectPath          [IN]    object path to a given object
//      pwszMethodName      [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams*          [IN]    Input parameters for the method
//      pHandler*           [IN]    WMI sink pointer
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CInstanceProv::DoExecMethodAsync(
	BSTR             strObjectPath, 
    BSTR             strMethodName, 
	long             lFlags, 
    IWbemContext     *pCtx,
	IWbemClassObject *pInParams, 
	IWbemObjectSink  *pHandler
    )
{
    DBG_FN( "CIP::DoExecMethodAsync" );

    DNS_DEBUG( INSTPROV, (
        "%s: flags=%lu method=%S %S\n",
        fn, lFlags, strMethodName, strObjectPath ));

	SCODE sc;
	if(strObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL
		|| strMethodName == NULL )
        return WBEM_E_INVALID_PARAMETER;
	
    CDnsBase * pDns;
    try 
	{

        CObjPath ObjPath;
	    if(!ObjPath.Init(strObjectPath))
	    {
		    return WBEM_E_INVALID_PARAMETER;
	    }
	    

	    wstring wstrClass = ObjPath.GetClassName();


	    sc = CreateClass(
		    wstrClass.data(),
		    m_pNamespace, 
		    (void**) &pDns);

	    if( FAILED(sc) )
	    {
		    return sc;
	    }
		auto_ptr<CDnsBase> pDnsBase(pDns);
		sc = pDnsBase->ExecuteMethod(
			ObjPath,
			strMethodName, 
			lFlags, 
			pInParams,
			pHandler);
	}

	catch(CDnsProvException e)
	{
        DNS_DEBUG( INSTPROV, (
            "%s: caught CDnsProvException %s\n",
            fn, e.what() ));

		CWbemClassObject Status;
	    SCODE sc = SetExtendedStatus(e.what(), Status);
        if (SUCCEEDED ( sc ))
        {
            sc = pHandler->SetStatus(
                0, 
                WBEM_E_FAILED,
                NULL,
                *(&Status));
			return sc;
		}
	
	}
	catch(SCODE exSc)
	{
		sc = exSc;
        DNS_DEBUG( INSTPROV, ( "%s: caught SCODE 0x%08X\n", fn, sc ));
	}
	catch(...)
	{
		sc = WBEM_E_FAILED;
        DNS_DEBUG( INSTPROV, ( "%s: caught unknown exception returning WBEM_E_FAILED\n", fn ));
	}
	
	pHandler->SetStatus(0, sc,NULL,NULL);
#ifdef _DEBUG
//	_CrtDumpMemoryLeaks();
#endif

    DNS_DEBUG( INSTPROV, ( "%s: returning 0x%08X\n", fn, sc ));
	return sc;

	
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CInstanceProv::SetExtendedStatus
//
//	Description:
//		create and set extended error status
//
//	Arguments:
//      ErrString           [IN]    Error message string
//      Inst                [IN OUT]    reference to WMI instance
//
//	Return Value:
//		WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CInstanceProv::SetExtendedStatus(
    const char* ErrString, 
    CWbemClassObject& Inst)
{
    DBG_FN( "CIP::SetExtendedStatus" );

    DNS_DEBUG( INSTPROV, ( "%s\n", fn ));

    IWbemClassObject* pStatus;
	BSTR bstrStatus = SysAllocString(L"__ExtendedStatus");
    if( bstrStatus == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
	
    SCODE  sc =  m_pNamespace->GetObject(
        bstrStatus, 
        0, 
        0,
        &pStatus, 
        NULL) ;
    SysFreeString(bstrStatus);
    if( SUCCEEDED ( sc ) )
    {
	    sc = pStatus->SpawnInstance(0, &Inst);
	    if ( SUCCEEDED ( sc ))
        {
            sc = Inst.SetProperty(
                ErrString, 
                L"Description");
        }
    }
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\provfactory.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		provfactory.h
//
//	Implementation File:
//		provfactory.cpp
//
//	Description:
//		Definition of the CProvFactory class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once


#include "common.h"
#include "instanceprov.h"


class CProvFactory  : public IClassFactory
{
   protected:
        ULONG           m_cRef;

	public:
		CProvFactory();
		virtual ~CProvFactory();

		STDMETHODIMP         QueryInterface(REFIID, PPVOID);
		STDMETHODIMP_(ULONG) AddRef(void);
		STDMETHODIMP_(ULONG) Release(void);
		//IClassFactory members
	    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                       , PPVOID);
	    STDMETHODIMP         LockServer(BOOL);


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\dnszone.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnszone.h
//
//	Implementation File:
//		dnszone.cpp
//
//	Description:
//		Definition of the CDnsZone.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "dnsbase.h"
class CObjPath;


class CDnsZone  : CDnsBase
{
public:
	CDnsZone();
	CDnsZone(
		const WCHAR*, 
		CWbemServices*
		);
	~CDnsZone();

	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;

	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 
	SCODE DeleteInstance(
        CObjPath &          ObjectPath,
        long                lFlags,
        IWbemContext *      pCtx,
        IWbemObjectSink *   pHandler 
		); 

    static CDnsBase* CreateThis(
        const WCHAR *       wszName,         //class name
        CWbemServices *     pNamespace,  //namespace
        const char *        szType         //str type id
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\instanceprov.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		InstanceProv.h
//
//	Implementation File:
//		InstanceProv.cpp
//
//	Description:
//		Definition of the CInstanceProv.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include <wbemprov.h>
#include "ntrkcomm.h"
class CWbemClassObject;

class CInstanceProv : public CImpersonatedProvider
{
protected:
	SCODE SetExtendedStatus(
        const char* , 
        CWbemClassObject& );
 
public:
	CInstanceProv(
		BSTR =NULL, 
		BSTR =NULL , 
		BSTR =NULL, 
		IWbemContext * = NULL
		);
	virtual ~CInstanceProv();

	HRESULT STDMETHODCALLTYPE DoGetObjectAsync( 
	    BSTR                ObjectPath,
	    long                lFlags,
	    IWbemContext *		pCtx,
        IWbemObjectSink	*	pHandler
        );
    
	HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
	    IWbemClassObject *   pInst,
        long                 lFlags,
	    IWbemContext *       pCtx,
	    IWbemObjectSink *    pHandler
        ) ;
    
    HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
        BSTR                 ObjectPath,
        long                 lFlags,
        IWbemContext *       pCtx,
        IWbemObjectSink *    pHandler
        ) ;
    
    HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
	    BSTR                 RefStr,
	    long                 lFlags,
	    IWbemContext         *pCtx,
        IWbemObjectSink      *pHandler
        );
     
    
    HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
        BSTR                 QueryLanguage,
        BSTR                 Query,
        long                 lFlags,
        IWbemContext         *pCtx,
        IWbemObjectSink      *pHandler
        ) ;
    

    HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
	    BSTR             strObjectPath, 
        BSTR             strMethodName, 
	    long             lFlags, 
        IWbemContext     *pCtx,
	    IWbemClassObject *pInParams, 
	    IWbemObjectSink  *pHandler
        );
	

};

extern long       g_cObj;
extern long       g_cLock;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\provfactory.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight (c) 1999 Microsoft Corporation
//
//  Module Name: provfactory.cpp
//
//  Description:    
//      Implementation of CProvFactory class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
    {
        delete this;
    }
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    CInstanceProv *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj=new CInstanceProv();
    if (NULL==pObj)
    {
        return E_OUTOFMEMORY;
    }

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
    {
        delete pObj;
    }
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\objectpath.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: objectpath.cpp
//
//  Description:    
//      Implementation of CObjectpath and other utility class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CPropertyValue::~CPropertyValue()
{
	VariantClear(&m_PropValue);
}

CPropertyValue::CPropertyValue()
{
	VariantInit(&m_PropValue);
}

CPropertyValue::CPropertyValue(
	const CPropertyValue& pv)
{
	m_Operator = pv.m_Operator;
	m_PropName = pv.m_PropName;
	VariantInit(&m_PropValue);
	VariantCopy(
		&m_PropValue, 
		(VARIANT*)&pv.m_PropValue
		);
}

CPropertyValue& 
CPropertyValue::operator =(
	const CPropertyValue& pv)
{
	m_Operator = pv.m_Operator;
	m_PropName = pv.m_PropName;
	VariantInit(&m_PropValue);
	VariantCopy(
		&m_PropValue,
		(VARIANT*)&pv.m_PropValue
		);
	return *this;
}

CObjPath::CObjPath()
{

}
CObjPath::CObjPath(
	const CObjPath& op)
{
	m_Class = op.m_Class;
	m_NameSpace = op.m_NameSpace;
	m_Server = op.m_Server;
	m_PropList = op.m_PropList;
}	



 CObjPath::~CObjPath()
{

}


wstring 
CObjPath::GetStringValueForProperty(
	const WCHAR* str
    )
{
	list<CPropertyValue>::iterator i;
	for(i=m_PropList.begin(); i!= m_PropList.end(); ++i)
	{
		if( _wcsicmp(
			(*i).m_PropName.data(),
			str) == 0
		)
		{
			if( i->m_PropValue.vt == VT_BSTR)
				return i->m_PropValue.bstrVal;
		}
	}
	return L"";
}

wstring 
CObjPath::GetClassName(void)
{
	return m_Class;
}



BOOL 
CObjPath::Init(
	const WCHAR* szObjPath
    )
{
	BOOL flag = TRUE;
	CPropertyValue* pObjPV=NULL;
	BSTR bstrInput = SysAllocString(szObjPath);
	CObjectPathParser objParser(e_ParserAcceptRelativeNamespace);
	ParsedObjectPath* pParsed = NULL;
	objParser.Parse(bstrInput, &pParsed);
	SysFreeString(bstrInput);
	if( pParsed == NULL)
    {
        return FALSE;
    }
	SetClass(pParsed->m_pClass);
	WORD wKeyCount = pParsed->m_dwNumKeys;
	for(DWORD i = 0; i < wKeyCount; i++)
	{
		KeyRef* pKeyRef = pParsed->m_paKeys[i];
		AddProperty(
			pKeyRef->m_pName, 
			&(pKeyRef->m_vValue)
			);
	}
	delete pParsed;

	return TRUE;
}


BOOL 
CObjPath::SetClass(
	const WCHAR *wszValue
    )			   
{
	m_Class = wszValue;
	return TRUE;
}

BOOL 
CObjPath::SetNameSpace(
	const WCHAR *wszValue
    )				   
{
	m_NameSpace = wszValue;
	return TRUE;
}

BOOL 
CObjPath::SetServer(
	const WCHAR *wszValue)				
{
	m_Server = wszValue;
	return TRUE;
}

BOOL
CObjPath::SetProperty(
	const WCHAR* wszName, 
	const WCHAR* wszValue)
{
	list<CPropertyValue>::iterator i;
	for(i=m_PropList.begin(); i!= m_PropList.end(); ++i)
	{
		if ( _wcsicmp( (*i).m_PropName.data() ,  wszName )  == 0)
		{
			m_PropList.erase(i);
			break;
		}
	}  
	return AddProperty(wszName, wszValue);
	
}
BOOL 
CObjPath::AddProperty(
	const WCHAR *   wszName, 
	const WCHAR *   wszValue
    )
{

	CPropertyValue pv;
	pv.m_PropName = wszName;
	pv.m_Operator = L"=";
	pv.m_PropValue.vt = VT_BSTR;
	pv.m_PropValue.bstrVal = SysAllocString(wszValue);
	m_PropList.insert(m_PropList.end(), pv);
	return TRUE;
    
}
BOOL CObjPath::AddProperty(
	const WCHAR *   wszName,
	string &        strValue
    )
{
	wstring wstrValue = CharToWstring(strValue.data(), strValue.length());
	AddProperty(wszName, wstrValue.data());
	return TRUE;
}
wstring 
CObjPath::GetObjectPathString()
{
	list<CPropertyValue>::iterator i;
	
	ParsedObjectPath parsed;
	parsed.SetClassName(GetClassName().data());
	
	for(i=m_PropList.begin(); i!= m_PropList.end(); ++i)
	{
		parsed.AddKeyRefEx(i->m_PropName.data(), &(i->m_PropValue));
	}
	LPWSTR pwszPath;
	CObjectPathParser::Unparse(&parsed, &pwszPath);
	wstring wstrResult = pwszPath;
	delete [] pwszPath;
	return wstrResult;
}

BOOL
CObjPath::AddProperty(
	const WCHAR *   wszName, 
	VARIANT *       pvValue
    )
{
	CPropertyValue pvObj;
	pvObj.m_PropName = wszName;
	pvObj.m_Operator = L"=";
	VariantCopy(&pvObj.m_PropValue, pvValue);
	m_PropList.insert(m_PropList.end(), pvObj);
	return TRUE;
}
BOOL
CObjPath::AddProperty(
	const WCHAR *   wszName, 
	WORD            wValue
    )
{
	VARIANT v;
	VariantInit(&v);
	v.vt = VT_I2;
	v.iVal = wValue;
	AddProperty(wszName, &v);
	VariantClear(&v);
	return TRUE;
}
BOOL
CObjPath::GetNumericValueForProperty(
	const WCHAR *   wszName, 
	WORD *          wValue
    )
{
	list<CPropertyValue>::iterator i;
	for(i=m_PropList.begin(); i!= m_PropList.end(); ++i)
	{
		if( _wcsicmp((*i).m_PropName.data(), wszName) == 0)
		{
			if(i->m_PropValue.vt == VT_I4)
			{
				*wValue = i->m_PropValue.iVal;
				return TRUE;
			}
				
		}
	}
	return FALSE;
}
CDomainNode::CDomainNode()
{
}
CDomainNode::~CDomainNode()
{
}
CDomainNode::CDomainNode(
	const CDomainNode& rhs)
{
	wstrZoneName = rhs.wstrZoneName;
	wstrNodeName = rhs.wstrNodeName;
	wstrChildName = rhs.wstrChildName;
}

CDnsProvException::CDnsProvException():m_dwCode(0)
{
}
CDnsProvException::CDnsProvException(const char* psz, DWORD dwCode)
{
    m_strError = psz;
	m_dwCode = dwCode;
}

CDnsProvException::~CDnsProvException()
{
}


CDnsProvException& 
CDnsProvException::operator =(
	const CDnsProvException& rhs)
{
	m_strError = rhs.m_strError;
	m_dwCode = rhs.m_dwCode;
	return *this;
}

const 
char* 
CDnsProvException::what() const
{
	return m_strError.data();
}
DWORD 
CDnsProvException::GetErrorCode()
{ 
	return m_dwCode;
}
CDnsProvException::CDnsProvException(
	const CDnsProvException& rhs)
{
	m_strError = rhs.m_strError;
	m_dwCode = rhs.m_dwCode;
}

CDnsProvSetValueException::CDnsProvSetValueException()
{
}
CDnsProvSetValueException::~CDnsProvSetValueException()
{
}

CDnsProvSetValueException::CDnsProvSetValueException(
	const WCHAR* pwz)
{
	string temp;
	WcharToString(pwz, temp);
	m_strError = "Fail to set value of " + temp;
}

CDnsProvSetValueException::CDnsProvSetValueException(
	const CDnsProvSetValueException &rhs)
{
	m_strError = rhs.m_strError;
}
CDnsProvSetValueException& 
CDnsProvSetValueException::operator =(
	const CDnsProvSetValueException &rhs)
{
	m_strError = rhs.m_strError;
	return *this;
}


CDnsProvGetValueException::CDnsProvGetValueException()
{
}
CDnsProvGetValueException::~CDnsProvGetValueException()
{
}

CDnsProvGetValueException::CDnsProvGetValueException(
	const WCHAR* pwz)
{
	string temp;
	WcharToString(pwz, temp);
	m_strError = "Fail to get value of " + temp;
}

CDnsProvGetValueException::CDnsProvGetValueException(
	const CDnsProvGetValueException &rhs)
{
	m_strError = rhs.m_strError;
}
CDnsProvGetValueException& 
CDnsProvGetValueException::operator =(
	const CDnsProvGetValueException &rhs)
{
	m_strError = rhs.m_strError;
	return *this;
}

// CWbemClassObject

CWbemClassObject::CWbemClassObject()
	:m_pClassObject(NULL)
{
	VariantInit(&m_v);
}
CWbemClassObject::CWbemClassObject(
	IWbemClassObject* pInst								   )
	:m_pClassObject(NULL)
{
	m_pClassObject = pInst;
	if(m_pClassObject)
		m_pClassObject->AddRef();
	VariantInit(&m_v);
}

CWbemClassObject::~CWbemClassObject()
{
	if(m_pClassObject)
		m_pClassObject->Release();
	VariantClear(&m_v);
}
IWbemClassObject** 
CWbemClassObject::operator&()
{
	return &m_pClassObject;
}

SCODE
CWbemClassObject::SetProperty(
    DWORD   dwValue, 
    LPCWSTR wszPropName
    )
{
	SCODE sc;
	VariantClear(&m_v);
	m_v.vt = VT_I4;
	m_v.lVal = dwValue;
	BSTR bstrName = AllocBstr(wszPropName);
	sc = m_pClassObject->Put(bstrName, 0, &m_v,0);
	SysFreeString(bstrName);

	if( sc != S_OK)
	{
		CDnsProvSetValueException e(wszPropName);
		throw e;
	}

	return sc;
}



SCODE 
CWbemClassObject::SetProperty(
    UCHAR   ucValue, 
    LPCWSTR wszPropName
    )
{
	SCODE sc;
	VariantClear(&m_v);
	m_v.vt = VT_UI1;
	m_v.bVal = ucValue;
	BSTR bstrName = AllocBstr(wszPropName);
	sc = m_pClassObject->Put(bstrName, 0, &m_v,0);
	SysFreeString(bstrName);

	if( sc != S_OK)
	{
		CDnsProvSetValueException e(wszPropName);
		throw e;
	}

	return sc;
}


SCODE 
CWbemClassObject::SetProperty(
    LPCWSTR pszValue, 
    LPCWSTR wszPropName
    )
{
	SCODE sc;
	VariantClear(&m_v);
	if(!pszValue)
		return 0;
	m_v.vt = VT_BSTR;
	m_v.bstrVal = AllocBstr(pszValue);
	BSTR bstrName = AllocBstr(wszPropName);

    sc = m_pClassObject->Put(bstrName, 0, &m_v,0);
	VariantClear(&m_v);
	SysFreeString(bstrName);

	if( sc != S_OK)
	{
		CDnsProvSetValueException e(wszPropName);
		throw e;
	}

	return sc;
 
}



SCODE 
CWbemClassObject::SetProperty(
    wstring &   wstrValue, 
    LPCWSTR     wszPropName
    )
{
    SCODE sc;
	VariantClear(&m_v);
	if(wstrValue.empty())
		return S_OK;
	m_v.vt = VT_BSTR;
	m_v.bstrVal = AllocBstr(wstrValue.data());
	BSTR bstrName = AllocBstr(wszPropName);

    sc = m_pClassObject->Put(bstrName, 0, &m_v,0);
	SysFreeString(bstrName);

	if( sc != S_OK)
	{
		CDnsProvSetValueException e(wszPropName);
		throw e;
	}

	return sc;
}



SCODE 
CWbemClassObject::SetProperty(
    SAFEARRAY * psa, 
    LPCWSTR     wszPropName
    )
{
	SCODE sc;
	VariantClear(&m_v);
	m_v.vt = (VT_ARRAY |VT_BSTR);
	m_v.parray = psa;
	BSTR bstrName = AllocBstr(wszPropName);
	sc = m_pClassObject->Put(bstrName, 0, &m_v,0);
	SysFreeString(bstrName);
	if( sc != S_OK)
	{
		CDnsProvSetValueException e(wszPropName);
		throw e;
	}

	return sc;
}

SCODE 
CWbemClassObject::SetProperty(
    DWORD *     pdwValue, 
    DWORD       dwSize, 
    LPCWSTR     wszPropName
    )
{
	SCODE sc;
	VariantClear(&m_v);

	SAFEARRAY * psa;
	SAFEARRAYBOUND rgsabound[1];
	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = dwSize;
	try
	{

		psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
		if(psa == NULL)
		{
			throw WBEM_E_OUT_OF_MEMORY;
		}

		for(int i=0; i< dwSize; i++)
		{
			BSTR bstrIP = AllocBstr(
				IpAddressToString(pdwValue[i]).data());
			LONG ix = i;
			sc = SafeArrayPutElement(
				psa, 
				&ix, 
				bstrIP);
			SysFreeString(bstrIP);
			if( sc != S_OK)
				throw sc;
		}

		m_v.vt = (VT_ARRAY |VT_BSTR);
		m_v.parray = psa;
		BSTR bstrName = AllocBstr(wszPropName);
		sc = m_pClassObject->Put(bstrName, 0, &m_v,0);
		SysFreeString(bstrName);
		
		if( sc != S_OK)
		{
			CDnsProvSetValueException e(wszPropName);
			throw e;
		}
			
	}
	catch(...)
	{
		if(psa != NULL)
			SafeArrayDestroy(psa);
		throw ;
	}

	return WBEM_S_NO_ERROR;
}
SCODE 
CWbemClassObject::SetProperty(
    LPCSTR  pszValue, 
    LPCWSTR wszPropName
    )
{
    if(pszValue == NULL)
        return S_OK;
	wstring wstrValue = CharToWstring(pszValue, strlen(pszValue));
    return SetProperty(wstrValue, wszPropName);
}


SCODE
CWbemClassObject::SpawnInstance(
	LONG lFlag,
	IWbemClassObject** ppNew)
{
	return m_pClassObject->SpawnInstance(lFlag, ppNew);
}

SCODE
CWbemClassObject::GetMethod(
	BSTR                name,
	LONG                lFlag,
	IWbemClassObject**  ppIN,
	IWbemClassObject**  ppOut
    )
{
	return m_pClassObject->GetMethod(
		name,
		lFlag,
		ppIN,
		ppOut);
}
	

SCODE 
CWbemClassObject::GetProperty(
    DWORD *     dwValue, 
    LPCWSTR     wszPropName
    )
{
	SCODE sc;
	VariantClear(&m_v);
	BSTR bstrPropName = AllocBstr(wszPropName);
	sc = m_pClassObject->Get(bstrPropName, 0, &m_v,NULL, NULL);
	SysFreeString(bstrPropName);
	
	if(sc == S_OK)
	{
		if(m_v.vt == VT_I4)
		{
			*dwValue = m_v.lVal;
			return sc;
		}
		else if (m_v.vt == VT_BOOL)
		{
			if (m_v.boolVal == VARIANT_TRUE)
				*dwValue = 1;
			else
				*dwValue = 0;
			return sc;
		}
		else if(m_v.vt == VT_UI1)
		{
			*dwValue = (DWORD) m_v.bVal;
		}
		else if (m_v.vt == VT_NULL)
		{
			return WBEM_E_FAILED;
		}
	}

	// raise exception if sc is not S_OK or vt is not expected
	CDnsProvGetValueException e(wszPropName);
	throw e;
	
	return WBEM_E_FAILED;
}


SCODE 
CWbemClassObject::GetProperty(
    wstring &   wsStr, 
    LPCWSTR     wszPropName
    )
{
	SCODE sc;
	VariantClear(&m_v);
	BSTR bstrPropName = AllocBstr(wszPropName);
	sc = m_pClassObject->Get(bstrPropName, 0, &m_v,NULL, NULL);
	SysFreeString(bstrPropName);
	if(sc == S_OK)
	{
		if(m_v.vt == VT_BSTR)
		{
			wsStr = m_v.bstrVal;
			return sc;
		}
		else if(m_v.vt == VT_NULL)
		{
			return WBEM_E_FAILED;
		}
	}

	CDnsProvGetValueException e(wszPropName);
	throw e;
	return WBEM_E_FAILED;
}


SCODE 
CWbemClassObject::GetProperty(
    string &    strStr, 
    LPCWSTR     wszPropName
    )
{
	SCODE sc;
	VariantClear(&m_v);
	BSTR bstrPropName = AllocBstr(wszPropName);
	sc = m_pClassObject->Get(bstrPropName, 0, &m_v,NULL, NULL);
	SysFreeString(bstrPropName);
	if( sc == S_OK)
	{
		if(m_v.vt == VT_BSTR)
		{
			char* temp=NULL;
			WcharToChar(m_v.bstrVal, &temp);
			strStr = temp;
			delete [] temp;
			return sc;
		}
		else if (m_v.vt == VT_NULL)
		{
			return WBEM_E_FAILED;
		}
	}
	// exception
	CDnsProvGetValueException e(wszPropName);
	throw e;
	
	return WBEM_E_FAILED;
}

SCODE 
CWbemClassObject::GetProperty(
    BOOL *  bValue, 
    LPCWSTR szPropName
    )
{
	SCODE sc;
	VariantClear(&m_v);
	BSTR bstrPropName = AllocBstr(szPropName);
	sc = m_pClassObject->Get(bstrPropName, 0, &m_v,NULL, NULL);
	SysFreeString(bstrPropName);
	if(m_v.vt == VT_BOOL)
	{
		*bValue = m_v.boolVal;
		return sc;
	}

	return WBEM_E_FAILED;
}


SCODE 
CWbemClassObject::GetProperty(
    DWORD **    ppValue, 
    DWORD *     dwSize, 
    LPCWSTR     szPropName
    )
{
	SCODE sc;
	VariantClear(&m_v);
	BSTR bstrPropName = AllocBstr(szPropName);
	sc = m_pClassObject->Get(bstrPropName, 0, &m_v, NULL, NULL);
	SysFreeString(bstrPropName);
	*dwSize = 0;

	if(m_v.vt == (VT_ARRAY |VT_BSTR) && m_v.vt != VT_NULL)
	{
		SAFEARRAY* psa;
		sc = SafeArrayCopy(m_v.parray, &psa);
		if(sc == S_OK)
        {
            *dwSize = psa->rgsabound[0].cElements;
		    *ppValue = new DWORD[*dwSize];
            if ( *ppValue )
            {
		        BSTR* pbstr;
		        sc = SafeArrayAccessData(psa, (void**) &pbstr);
                if(sc != S_OK)
                {   
                    delete [] *ppValue;
                    throw sc;
                }
		        for(LONG i = 0; i < *dwSize; i++)
		        {
			        //CHAR* pChar
                    string str;
			        WcharToString(pbstr[i], str);
			        (*ppValue)[i] = inet_addr(str.data());
		        }
            }
            else
            {
                sc = E_OUTOFMEMORY;
            }
		    return sc;
        }
    }

	return WBEM_E_FAILED;
}


SCODE 
CWbemClassObject::GetProperty(
    DWORD Value[], 
    DWORD *dwSize, 
    LPCWSTR szPropName
    )
{
	SCODE sc;
	VariantClear(&m_v);
	BSTR bstrPropName = AllocBstr(szPropName);
	sc = m_pClassObject->Get(bstrPropName, 0, &m_v,NULL, NULL);
	SysFreeString(bstrPropName);
	if(m_v.vt == (VT_ARRAY |VT_BSTR) && m_v.vt != VT_NULL)
	{
		SAFEARRAY* psa;
		try
		{
			sc = SafeArrayCopy(m_v.parray, &psa);
			if(sc != S_OK)
				throw sc;
			if(psa->rgsabound[0].cElements > *dwSize)
				throw WBEM_E_INVALID_PARAMETER;

			*dwSize = psa->rgsabound[0].cElements;
			BSTR* pbstr;
			sc = SafeArrayAccessData(psa, (void**) &pbstr);
			if(sc != S_OK)
				throw sc;
			
			for(LONG i = 0; i < *dwSize; i++)
			{
				//CHAR* pChar
				string str;
				WcharToString(pbstr[i], str);
				Value[i] = inet_addr(str.data());
			}
			SafeArrayDestroy(psa);
			return sc;
			
		}
		catch(SCODE sc)
		{
			SafeArrayDestroy(psa);
			throw sc;
		}

	}

	return WBEM_E_FAILED;
}

SCODE 
CWbemClassObject::GetProperty(
    VARIANT *   pv, 
    LPCWSTR     wszPropName 
    )
{
    SCODE sc;
    BSTR bstrPropName = AllocBstr(wszPropName);
    sc = m_pClassObject->Get(bstrPropName, 0, pv,NULL, NULL);
    SysFreeString(bstrPropName);
    if(sc != S_OK)
    {
        CDnsProvGetValueException e(wszPropName);
	    throw e;
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\objectpath.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		objectpath.h
//
//	Implementation File:
//		objectpath.cpp
//
//	Description:
//		Definition of the CObjpath class and other common class.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once


#include "common.h"
#include <list>
#include <string>
#include "genlex.h"		//wbem sdk header
#include "objpath.h"	//wbem sdk header


using namespace std;


class CPropertyValue
{
public:
	CPropertyValue();
	CPropertyValue(
		const CPropertyValue&
		);
	CPropertyValue& operator=(
		const CPropertyValue&
		);
	virtual ~CPropertyValue();
	wstring m_PropName;
	VARIANT m_PropValue;
	wstring m_Operator;
};


/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CObjPath
//
//	Description:
//		CObjpath class make it easier to work with Object path string
//
//	Inheritance:
//		
//
//--
/////////////////////////////////////////////////////////////////////////////

class CObjPath 
{
public:
	wstring GetObjectPathString();
	BOOL SetProperty(
	    const WCHAR *   wszName,
	    //string &        strValue
        const WCHAR *   wszValue
		);
	BOOL AddProperty(
		const WCHAR*,
		string&
        );
	BOOL AddProperty(
	    const WCHAR *   wszName, 
	    const WCHAR *   wszValue
		);
	BOOL AddProperty(
	    const WCHAR *   wszName, 
	    VARIANT *       pvValue
        );
	BOOL AddProperty(
	    const WCHAR *   wszName, 
	    WORD            wValue
		);
	BOOL SetServer(
		const WCHAR *
		);
	BOOL SetNameSpace(
    	const WCHAR *wszValue
  		);
	BOOL SetClass(
    	const WCHAR *wszValue
		);
	wstring	GetStringValueForProperty(
    	const WCHAR* str
		);
	BOOL GetNumericValueForProperty(
	    const WCHAR *   wszName, 
	    WORD *          wValue
		);
	wstring	GetClassName(void);
	BOOL Init(
    	const WCHAR* szObjPath
		);
/*	wstring m_Server;
	wstring m_NameSpace;
	wstring m_Class;
	list<CPropertyValue> m_PropList;
*/	
	CObjPath();
	CObjPath(
		const CObjPath&
		);
	virtual ~CObjPath();
protected:
	wstring m_Server;
	wstring m_NameSpace;
	wstring m_Class;
	list<CPropertyValue> m_PropList;

};

class CDomainNode
{
public:
	wstring wstrZoneName;
	wstring wstrNodeName;
	wstring wstrChildName;
	CDomainNode();
	~CDomainNode();
	CDomainNode(
		const CDomainNode& 
		);
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CObjPath
//
//	Description:
//		base provider exception class
//
//	Inheritance:
//		exception
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsProvException : public exception
{
public:
    CDnsProvException(
		const char* ,
		DWORD = 0);
    CDnsProvException();
	~CDnsProvException();
	CDnsProvException(
		const CDnsProvException& 
		) 
		throw();
    CDnsProvException& operator=(
		const CDnsProvException& 
		) throw();

	const char *what() const throw();
	DWORD GetErrorCode(void);
protected:
	string m_strError;
	DWORD m_dwCode;
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CObjPath
//
//	Description:
//		exception class specialized for set value exception
//
//	Inheritance:
//		CDnsProvException
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsProvSetValueException : public CDnsProvException
{
public:
	CDnsProvSetValueException();
	~CDnsProvSetValueException();
	CDnsProvSetValueException(
		const WCHAR*
		);
	CDnsProvSetValueException(
		const CDnsProvSetValueException& rhs
		) throw();
    CDnsProvSetValueException& operator=(
		const CDnsProvSetValueException& rhs
		) throw();
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CObjPath
//
//	Description:
//		exception class specialized for get value exception
//
//	Inheritance:
//		CDnsProvException
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDnsProvGetValueException : public CDnsProvException
{
public:
	CDnsProvGetValueException();
	~CDnsProvGetValueException();
	CDnsProvGetValueException(
		const WCHAR*
		);
	CDnsProvGetValueException(
		const CDnsProvGetValueException& rhs
		) throw();
    CDnsProvGetValueException& operator=(
		const CDnsProvGetValueException& rhs
		) throw();
};
/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWbemClassObject
//
//	Description:
//		Wrap for IWbemClassObject
//  
//
//	Inheritance:
//      	
//
//--
/////////////////////////////////////////////////////////////////////////////

class CWbemClassObject
{
protected:
	IWbemClassObject* m_pClassObject;
	VARIANT m_v;
public:
	CWbemClassObject();
	CWbemClassObject(IWbemClassObject*);
	virtual ~CWbemClassObject();
	IWbemClassObject** operator&();
	
	SCODE SetProperty(
        LPCSTR  pszValue, 
        LPCWSTR wszPropName
        );

	SCODE SetProperty(
        DWORD   dwValue, 
        LPCWSTR wszPropName
		);
	SCODE SetProperty(
        UCHAR   ucValue, 
        LPCWSTR wszPropName
        );

	SCODE SetProperty(
        LPCWSTR pszValue, 
        LPCWSTR wszPropName
		);

	SCODE SetProperty(
        wstring &   wstrValue, 
        LPCWSTR     wszPropName
        );

	SCODE SetProperty(
        SAFEARRAY * psa, 
        LPCWSTR     wszPropName
        );
	SCODE SetProperty(
        DWORD *     pdwValue, 
        DWORD       dwSize, 
        LPCWSTR     wszPropName
        );


	SCODE GetProperty(
        DWORD *     dwValue, 
        LPCWSTR     wszPropName
		);

	SCODE GetProperty(
        wstring &   wsStr, 
        LPCWSTR     wszPropName
        );
	SCODE GetProperty(
        string &    strStr, 
        LPCWSTR     wszPropName
        );
	SCODE GetProperty(
        BOOL *  bValue, 
        LPCWSTR szPropName
		);
	SCODE GetProperty(
		SAFEARRAY** ,
		LPCWSTR);
	SCODE GetProperty(
        DWORD **    ppValue, 
        DWORD *     dwSize, 
        LPCWSTR     szPropName
		);
	SCODE GetProperty(
        DWORD Value[], 
        DWORD *dwSize, 
        LPCWSTR szPropName
        );
	SCODE GetProperty(
        VARIANT *   pv, 
        LPCWSTR     wszPropName 
        );
	SCODE GetMethod(
        BSTR                name,
        LONG                lFlag,
        IWbemClassObject**  ppIN,
        IWbemClassObject**  ppOut
        );
	SCODE SpawnInstance(
		LONG,
		IWbemClassObject**);

	IWbemClassObject* data() { return m_pClassObject;};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\server.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: server.cpp
//
//  Description:    
//      Implementation of CDnsserver class 
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        execute methods defined for dns server class in the mof 
//
//    Arguments:
//      ObjPath             [IN]    pointing to the object that the 
//                                  method should be performed on
//      wzMethodName        [IN]    name of the method to be invoked
//      lFlags              [IN]    WMI flag
//      pInParams           [IN]    Input parameters for the method
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//      WBEM_E_INVALID_PARAMETER
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsServer::ExecuteMethod(    
    CObjPath &          ObjPath,
    WCHAR *             wzMethodName,
    long                lFlag,
    IWbemClassObject *  pInArgs,
    IWbemObjectSink *   pHandler) 
{
    CDnsWrap& dns = CDnsWrap::DnsObject();

#if 0
    //
    //  Restart is so totally broken I'm not going to expose it.
    //

    if(_wcsicmp( wzMethodName, PVD_MTH_SRV_RESTART) == 0)
    {
        wstring wstrServer = ObjPath.GetStringValueForProperty(
            PVD_SRV_SERVER_NAME );
        int rt  = dns.dnsRestartServer((WCHAR*)wstrServer.data());
        if( rt != ERROR_SUCCESS)
        {
            return WBEM_E_FAILED;
        }
    }
    else
#endif

    if(_wcsicmp( wzMethodName, PVD_MTH_SRV_START_SERVICE) == 0)
    {
        return StartServer();
    }
    else if(_wcsicmp( wzMethodName, PVD_MTH_SRV_STOP_SERVICE) == 0)
    {
        return StopServer();
    }
    else if(_wcsicmp(
        wzMethodName,
        PVD_MTH_ZONE_GETDISTINGUISHEDNAME) == 0)
    {
        wstring wstrName ;
        CWbemClassObject OutParams, OutClass, Class ;
        HRESULT hr;
    
        dns.dnsDsServerName(wstrName);

        BSTR ClassName=NULL;
        ClassName = AllocBstr(PVD_CLASS_SERVER); 
        hr = m_pNamespace->GetObject(ClassName, 0, 0, &Class, NULL);
        SysFreeString(ClassName);
        if ( SUCCEEDED ( hr ) )
        {
            Class.GetMethod(wzMethodName, 0, NULL, &OutClass);
            OutClass.SpawnInstance(0, &OutParams);
            OutParams.SetProperty(wstrName, PVD_DNS_RETURN_VALUE);
            hr = pHandler->Indicate(1, &OutParams);
        }

        return hr;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        retrieve record object pointed by the given object path
//
//    Arguments:
//      ObjectPath          [IN]    object path to object
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsServer::GetObject(
    CObjPath &          ObjectPath,
    long                lFlags,
    IWbemContext  *     pCtx,
    IWbemObjectSink *   pHandler
    )
{
    SCODE sc;
    CWbemClassObject NewInst;
    sc = m_pClass->SpawnInstance(0, &NewInst);
    if(FAILED(sc))
    {
        return sc;
    }

    wstring wstrServerName = ObjectPath.GetStringValueForProperty(
        PVD_SRV_SERVER_NAME );
    if ( wstrServerName.empty())
    {
        return WBEM_E_FAILED;
    }

    SC_HANDLE   schService = NULL;
    SC_HANDLE    schSCManager = NULL;
    LPQUERY_SERVICE_CONFIG lpServiceConfig = NULL;
    DWORD cbBufSize;
    DWORD BytesNeeded;
    SERVICE_STATUS ServiceStatus;
    
    try
    {    
        if ((schSCManager = OpenSCManager (
            NULL,            // machine (NULL == local)
            NULL,            // database (NULL == default)
            SC_MANAGER_ALL_ACCESS))==NULL)    // access required
        {
            throw GetLastError();
        }

        if ((schService = OpenService(
            schSCManager, 
            "DNS", 
            SERVICE_ALL_ACCESS))==NULL)
        {
            throw GetLastError();
        }

        if (QueryServiceConfig(
            schService,     // handle to service
            lpServiceConfig, 
            0,   // size of structure
            &cbBufSize        // bytes needed
            ) == FALSE)
        {
            lpServiceConfig = 
                (LPQUERY_SERVICE_CONFIG)  new BYTE[cbBufSize];
            if ( !lpServiceConfig)
            {
                throw ( ERROR_OUTOFMEMORY );
            }
            if(QueryServiceConfig(
                schService,     // handle to service
                lpServiceConfig, 
                cbBufSize,   // size of structure
                &BytesNeeded // bytes needed
                ) == FALSE)
                throw GetLastError();
            
            wstring wstrStartMode;
            switch(lpServiceConfig->dwStartType)
            {
            case SERVICE_DEMAND_START:
                wstrStartMode = L"Manual";
                break;
            default:
                wstrStartMode = L"Automatic";
                break;
            }

            NewInst.SetProperty(
                wstrStartMode,
                PVD_SRV_STARTMODE);


            if(QueryServiceStatus(
                schService,               // handle to service
                &ServiceStatus  // pointer to service status structure
                ) == FALSE)
            {
                throw GetLastError();
            }
            
            DWORD dwStatus;
            switch(ServiceStatus.dwCurrentState)
            {
            case SERVICE_RUNNING:
                dwStatus = 1;
                break;
            default:
                dwStatus = 0;
            }

            NewInst.SetProperty(
                dwStatus,
                PVD_SRV_STARTED);
 
        }
 
        CDnsWrap& dns = CDnsWrap::DnsObject();
        NewInst.SetProperty(
            dns.GetServerName(),
            PVD_SRV_SERVER_NAME);
        dns.dnsServerPropertyGet(
            NewInst,
            TRUE);
    }
    catch(DWORD dwError)
    {
        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
        delete [] lpServiceConfig;

    }
    catch(CDnsProvException e)
    {
        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
        delete [] lpServiceConfig;
        lpServiceConfig=NULL;
        // if server not running, we still want to 
        //return an instance, so user can call start service 
        //
        if(_stricmp(e.what(), "RPC_S_SERVER_UNAVAILABLE") != 0)
        {
            throw e;
        }
    }

    CloseServiceHandle(schService);
    CloseServiceHandle(schSCManager);
    delete [] lpServiceConfig;
    pHandler->Indicate(1,&NewInst);
    return sc;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        enum instances of dns server
//
//    Arguments:
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE 
CDnsServer::EnumInstance(
    long                lFlags,
    IWbemContext *        pCtx,
    IWbemObjectSink *    pHandler
    )
{


    // there is only one instance
    CObjPath ObjPath;
    ObjPath.SetClass(PVD_CLASS_SERVER);
    ObjPath.AddProperty(
        PVD_SRV_SERVER_NAME, 
        PVD_DNS_LOCAL_SERVER);
    return  GetObject(ObjPath, lFlags,pCtx,pHandler);

}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDnsServer::CDnsServer()
{

}
CDnsServer::CDnsServer(
    const WCHAR* wszName,
    CWbemServices *pNamespace)
    :CDnsBase(wszName, pNamespace)
{

}

CDnsServer::~CDnsServer()
{

}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        create an instance of CDnsServer
//
//    Arguments:
//      wszName             [IN]    class name
//      pNamespace          [IN]    wmi namespace
//      szType              [IN]    child class name of resource record class
//
//    Return Value:
//        WBEM_S_NO_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////

CDnsBase* 
CDnsServer::CreateThis(
    const WCHAR *       wszName,        
    CWbemServices *     pNamespace,  
    const char *        szType       
    )
{
    return new CDnsServer(wszName, pNamespace);
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        start dns server
//
//    Arguments:
//    Return Value:
//        
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsServer::StartServer()
{
    SC_HANDLE   schService = NULL;
    SC_HANDLE    schSCManager = NULL;
    try
    {
        if ((schSCManager = OpenSCManager (
            NULL,            // machine (NULL == local)
            NULL,            // database (NULL == default)
            SC_MANAGER_ALL_ACCESS))==NULL)    // access required
        {
            throw GetLastError();
        }

        if ((schService = OpenService(
            schSCManager, 
            "DNS", 
            SERVICE_ALL_ACCESS))==NULL)
        {
            throw GetLastError();
        }

        // make sure database is not locked
        QUERY_SERVICE_LOCK_STATUS qsls;
        DWORD dwbBytesNeeded, dwRet=1;

        while(dwRet)
        {
            if(!QueryServiceLockStatus(
                schSCManager, 
                &qsls, 
                sizeof(qsls)+2, 
                &dwbBytesNeeded))
            {
                throw GetLastError();
            }
            
            if( (dwRet = qsls.fIsLocked) > 0)
            {
                Sleep(2000);
            }
        }

        if (StartService(
            schService, 
            0, 
            NULL)==FALSE)
        {
            throw GetLastError();
        }
        
        DWORD dwTimeOut=6000; // 6 sec
        DWORD dwTimeCount=0;
        while ( dwTimeCount < dwTimeOut)
        {

            SERVICE_STATUS ServiceStatus;
            if(QueryServiceStatus(
                schService,               // handle to service
                &ServiceStatus  // pointer to service status structure
                ) == FALSE)
            {
                throw GetLastError();
            }

            
            if(ServiceStatus.dwCurrentState != SERVICE_RUNNING)
            {
                Sleep(2000);
                dwTimeCount +=2000;
            }
            else 
            {
                break;
            }
        }

    }
    catch(DWORD dwError)
    {
        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
    
        CHAR szErrDesc[MAX_PATH];
        FormatMessage( 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            szErrDesc,
            MAX_PATH,
            NULL 
            );
        CHAR szErr[MAX_PATH];
        strcpy(szErr, "Fail to start Dns because ");
        strcat(szErr, szErrDesc);
        CDnsProvException e(szErr);
        throw e;
    }
    CloseServiceHandle(schService);
    CloseServiceHandle(schSCManager);
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        stop dns server
//
//    Arguments:
//    Return Value:
//        
//
//--
/////////////////////////////////////////////////////////////////////////////

SCODE
CDnsServer::StopServer()
{
    SERVICE_STATUS    ss;
    SC_HANDLE        schService = NULL;
    SC_HANDLE        schSCManager = NULL;
    try
    {
        if ((schSCManager = OpenSCManager (
                NULL,    // machine (NULL == local)
                NULL,    // database (NULL == default)
                SC_MANAGER_ALL_ACCESS))==NULL)    // access required
        {
            
            throw GetLastError();
        }

        if ((schService = OpenService(
            schSCManager, 
            "DNS", 
            SERVICE_ALL_ACCESS))==NULL)
        {
            throw GetLastError();
        }

        if (ControlService(
            schService, 
            SERVICE_CONTROL_STOP, 
            (LPSERVICE_STATUS)&ss) == FALSE)
        {
            throw GetLastError();
        }

        // check its state
        DWORD dwTimeOut=6000; // 6 sec
        DWORD dwTimeCount=0;
        while ( dwTimeCount < dwTimeOut)
        {

            SERVICE_STATUS ServiceStatus;
            if(QueryServiceStatus(
                schService,               // handle to service
                &ServiceStatus  // pointer to service status structure
                ) == FALSE)
            {
                throw GetLastError();
            }
            
            if(ServiceStatus.dwCurrentState != SERVICE_STOPPED)
            {
                Sleep(2000);
                dwTimeCount +=2000;
            }
            else 
                break;
        }
    }
    catch(DWORD dwError)
    {
        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
        
        CHAR szErrDesc[MAX_PATH];
        FormatMessage( 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            szErrDesc,
            MAX_PATH,
            NULL 
            );
        CHAR szErr[MAX_PATH];
        strcpy(szErr, "Fail to stop Dns because ");
        strcat(szErr, szErrDesc);
        CDnsProvException e(szErr);
        throw e;
        
    }

    CloseServiceHandle(schService);
    CloseServiceHandle(schSCManager);

    return WBEM_S_NO_ERROR;
}
/////////////////////////////////////////////////////////////////////////////
//++
//
//    Description:
//        save this instance
//
//    Arguments:
//      InstToPut           [IN]    WMI object to be saved
//      lFlags              [IN]    WMI flag
//      pCtx                [IN]    WMI context
//      pHandler            [IN]    WMI sink pointer
//
//    Return Value:
//        
//
//--
/////////////////////////////////////////////////////////////////////////////
SCODE 
CDnsServer::PutInstance( 
    IWbemClassObject *  pInst ,
    long                lFlags,
    IWbemContext*       pCtx ,
    IWbemObjectSink *   pHandler
    )
{
    DBG_FN( "CDnsServer::PutInstance" )

    DNS_DEBUG( INSTPROV, (
        "%s: pInst=%p\n",  fn, pInst ));

    CDnsWrap& dns = CDnsWrap::DnsObject();
    CWbemClassObject Inst(pInst);
    dns.dnsServerPropertySet(
        Inst,
        FALSE);
    return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\ulti.h ===
//#if !defined(_DNS_UTIL_H_)
//#define _DNS_UTIL_H_

//#if _MSC_VER > 1000
//#pragma once
//#endif // _MSC_VER > 1000

#include <wbemprov.h>
//typedef LPVOID * PPVOID;

//SCODE CreateInst( IWbemServices * pNamespace, LPWSTR pKey, long lVal, 
//                                             IWbemClassObject ** pNewInst,
//                                             WCHAR * pwcClassName,
//											 IWbemContext  *pCtx); 



// #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\server.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		dnsserver.h
//
//	Implementation File:
//		dnsserver.cpp
//
//	Description:
//		Definition of the CDnsServerclass.
//
//	Author:
//		Henry Wang (Henrywa)	March 8, 2000
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once



#include "dnsbase.h"
class CObjPath;


class CDnsServer : public CDnsBase 
{
public:
	CDnsServer();
	CDnsServer(
        const WCHAR*,
		CWbemServices*
		);
	~CDnsServer();
	SCODE EnumInstance( 
		long				lFlags,
		IWbemContext *		pCtx,
		IWbemObjectSink *	pHandler);
	SCODE GetObject(
		CObjPath &          ObjectPath,
		long                lFlags,
		IWbemContext  *     pCtx,
		IWbemObjectSink *   pHandler
		);

	SCODE ExecuteMethod(
		CObjPath &          objPath,
	    WCHAR *             wzMethodName,
	    long                lFlag,
	    IWbemClassObject *  pInArgs,
	    IWbemObjectSink *   pHandler
		) ;

	SCODE PutInstance(
		IWbemClassObject *  pInst ,
        long                lFlags,
	    IWbemContext*       pCtx ,
	    IWbemObjectSink *   pHandler
		); 

    static CDnsBase* CreateThis(
        const WCHAR *       wszName,         //class name
        CWbemServices *     pNamespace,  //namespace
        const char *        szType         //str type id
        );

protected:
	SCODE StartServer(void);
	SCODE StopServer(void);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ds.inc ===
############################################################################
#
#   Copyright (C) 1992, Microsoft Corporation.
#
#   All rights reserved.
#
#   This file contains default definitions for building the DS project
#   under the NT build environment. It should be included into the sources
#   file of any component with a line of the form
#
#       !include ..\..\ds.inc
#
#   where the number of "..\"s is sufficient to reach the root of the
#   DS\SRC subtree.
#
############################################################################


MAJORCOMP=ds
# each subdirectory must define MINORCOMP

USE_MSVCRT=1

# Include code to support unit tests if INCLUDE_UNIT_TESTS env var is set.
!ifdef INCLUDE_UNIT_TESTS
C_DEFINES=$(C_DEFINES) -DINCLUDE_UNIT_TESTS
!endif

# Include code to support thalloc trace if USE_THALLOC_TRACE env var is set.
!ifdef USE_THALLOC_TRACE
C_DEFINES=$(C_DEFINES) -DUSE_THALLOC_TRACE
!endif

USER_C_FLAGS=$(USER_C_FLAGS)

LINKER_FLAGS=$(LINKER_FLAGS)

# Disable optimization for the checked build
# This should hopefully eliminate the stack reuse behavior which confounds
# debugging. [wlees Apr 28, 1998]


# If you use a global pch file, the compiler emits warnings if the defines
#  used to build the pch are different than those used to build the
#  source module which references the pch. Such warnings are usually benign
#  but all the same should be avoided. The following macros define the
#  additional settings used to build each of the global pch's in the dsys
#  tree. Any sources file which references a global pch must set
#
#       C_DEFINES= $(C_DEFINES) $(xxxPCH_DEFINES)

!ifndef DONT_USE_NtDsPch
! ifndef CPLUSPLUSDIR
PRECOMPILED_OPTION=/YuNtDsPch.h /Fp$(NTDS_INC)\c\$(O)\ntdspch.pch
HEADEROBJNAME= $(NTDS_INC)\c\$(O)\ntdspch.obj
!  ifdef USE_PDB_TO_COMPILE
PRECOMPILED_OPTION=$(PRECOMPILED_OPTION) /Fd$(NTDS_INC)\c\$(O)\pch.pdb
!  endif
! else
PRECOMPILED_OPTION=/YuNtDsPchX.h /Fp$(NTDS_INC)\cxx\$(O)\ntdspchx.pch
!  ifdef USE_PDB_TO_COMPILE
PRECOMPILED_OPTION=$(PRECOMPILED_OPTION) /Fd$(NTDS_INC)\cxx\$(O)\pch.pdb
!  endif
HEADEROBJNAME= $(NTDS_INC)\cxx\$(O)\ntdspchx.obj
PRECOMPILED_CXX=1
! endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\abw.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

      abw2.cxx

   Abstract:
      This module implements functions required for bandwidth throttling
       of network usage by ATQ module.

   Author:

       Murali R. Krishnan    ( MuraliK )     1-June-1995
       Bilal Alam            ( t-bilala )    7-March-1997

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Asynchronous Thread Queue DLL

--*/

#include "isatq.hxx"

//
// Global variables
//

extern PBANDWIDTH_INFO       g_pBandwidthInfo;

//
// Bandwidth Info shared variables
//

CRITICAL_SECTION        BANDWIDTH_INFO::sm_csSharedLock;
LIST_ENTRY              BANDWIDTH_INFO::sm_BornListHead;
LIST_ENTRY              BANDWIDTH_INFO::sm_ActiveListHead;
DWORD                   BANDWIDTH_INFO::sm_cBornList;
DWORD                   BANDWIDTH_INFO::sm_cActiveList;
ALLOC_CACHE_HANDLER*    BANDWIDTH_INFO::sm_pachBWInfos;
BOOL                    BANDWIDTH_INFO::sm_fGlobalEnabled;
BOOL                    BANDWIDTH_INFO::sm_fGlobalActive;
DWORD                   BANDWIDTH_INFO::sm_cNonInfinite;
DWORD                   BANDWIDTH_INFO::sm_cSamplesForTimeout;

//
// BANDWIDTH_INFO methods
//

VOID
BANDWIDTH_INFO::Initialize(
    IN BOOL             fPersistent
)
/*++
  Initialize bandwidth info object.  This is a pseudo-constructor for the
  class.

  Arguments:
    fPersistent - TRUE if this object is destroyed explicitly
                  FALSE if destroyed when refcount hits 0

  Returns:
    None

--*/
{
    _fMemberOfActiveList        = FALSE;
    _bandwidth.dwSpecifiedLevel = INFINITE;
    _bandwidth.dwLowThreshold   = INFINITE;
    _bandwidth.dwHighThreshold  = INFINITE;
    _cMaxBlockedList            = INFINITE;
    _fEnabled                   = FALSE;
    _Signature                  = ATQ_BW_INFO_SIGNATURE;
    _fIsFreed                   = FALSE;
    _fPersistent                = fPersistent;
    _cReference                 = 1;

    InitializeCriticalSection( &_csPrivateLock );
    SET_CRITICAL_SECTION_SPIN_COUNT( &_csPrivateLock,
                                     IIS_DEFAULT_CS_SPIN_COUNT);
    InitializeListHead( &_BlockedListHead );

    ZeroMemory( _rgBytesXfered, sizeof( _rgBytesXfered ) );

    _pBytesXferCur = _rgBytesXfered;  // points to start of array
    _cbXfered.QuadPart = 0;

    _pStatus = &sm_rgStatus[ ZoneLevelLow ][ 0 ];

    ClearStatistics();

    AddToBornList();

    SetDescription( "Default" );
}

VOID
BANDWIDTH_INFO::Terminate( VOID )
/*++
  Destroys bandwidth info object.  This is a pseudo-destructor.

  Arguments:
    None

  Returns:
    None

--*/
{
    Lock();

    // first prevent any new requests from getting blocked

    InterlockedExchangePointer((PVOID *) &_pStatus,
                               &sm_rgStatus[ZoneLevelLow][0] );

    // disable the descriptor

    InterlockedExchange( (LPLONG) &_fEnabled, FALSE );

    // now remove any blocked requests

    ATQ_REQUIRE( CheckAndUnblockRequests() );
    ATQ_ASSERT( _cCurrentBlockedRequests == 0 );
    ATQ_ASSERT( IsListEmpty( &_BlockedListHead ) );

    Unlock();

    DeleteCriticalSection( &_csPrivateLock );

    // remove self from shared bandwidth info list

    SharedLock();

    RemoveFromBornList();

    SharedUnlock();

    _Signature = ATQ_BW_INFO_SIGNATURE_FREE;
}

BOOL
BANDWIDTH_INFO::PrepareToFree( VOID )
{
    InterlockedExchange( (LPLONG) &_fIsFreed, TRUE );
    Dereference();
    return TRUE;
}

BOOL
BANDWIDTH_INFO::BlockRequest(
    IN OUT PATQ_CONT        pAtqContext
)
/*++
  Block this request on the queue of requests waiting to be processed.

  Arguments:
    pAtqContext   pointer to ATQ context information for request that needs
                  to be blocked.

  Returns:
    TRUE on success. FALSE if there are any errors.
    (Use GetLastError() for details)

--*/
{
    BOOL            fRet = TRUE;

    ATQ_ASSERT( pAtqContext != NULL);
    ATQ_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( IsValidAtqOp( pAtqContext->arInfo.atqOp ) );

    Lock();

    if ( _cCurrentBlockedRequests == _cMaxBlockedList )
    {
        fRet = FALSE;
    }
    else
    {
        pAtqContext->SetFlag( ACF_BLOCKED );

        InsertTailList( &_BlockedListHead, &pAtqContext->BlockedListEntry );

        IncCurrentBlockedRequests();
    }

    Unlock();

    return fRet;
}

BOOL
BANDWIDTH_INFO::RemoveFromBlockedList(
    IN PATQ_CONT            pAtqContext
)
/*++
  This function forcibly removes an ATQ context from blocked list of requests.

  Argument:
   pAtqContext    pointer to ATQ context whose request is in blocked list.

  Returns:
   TRUE on success and FALSE if there is any error.
--*/
{
    if ( !pAtqContext->IsBlocked() ) {

        // some other thread just removed this request from waiting list.
        return TRUE;
    }

    Lock();

    RemoveEntryList(&pAtqContext->BlockedListEntry);

    DecCurrentBlockedRequests();

    pAtqContext->ResetFlag( ACF_BLOCKED);

    Unlock();

    //
    // On such a forcible removal, we may have to make a callback indicating
    //   failure. Ignored!  To be done by the caller of this API.
    //

    return TRUE;
}

BOOL
BANDWIDTH_INFO::UnblockRequest(
    IN OUT PATQ_CONT        pAtqContext
)
/*++
  Unblocks this request from the queue of requests waiting to be processed.
  Call this function only when
       _pStatus[pAtqContext->atqOp] != StatusBlockOperation.
  First, this function removes the request from queue of requests and processes
   it according to status and operation to be performed.
  If the status is AllowRequest ==> this function restarts the operation.
  If the status is reject operation ==> rejects operation and invokes
                        call back function indicating the error status.

  Call this function after lock()ing


  Arguments:
    pAtqContext   pointer to ATQ context information for request that needs
                     to be unblocked.

  Returns:
    TRUE on success. FALSE if there are any errors.
    (Use GetLastError() for details)

--*/
{

    DBG_ASSERT(FALSE);
    return FALSE;
#if 0
    BOOL fRet = FALSE;

    ATQ_ASSERT( pAtqContext != NULL);
    ATQ_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE );

    // Remove the request from the blocked list entry
    RemoveEntryList( &pAtqContext->BlockedListEntry);
    DecCurrentBlockedRequests();
    pAtqContext->ResetFlag( ACF_BLOCKED );

    // Check and re enable the operation of pAtqContext

    switch ( _pStatus[ pAtqContext->arInfo.atqOp ] ) {

      case StatusAllowOperation:

        IncTotalAllowedRequests();
        switch ( pAtqContext->arInfo.atqOp) {

          case AtqIoRead:
            {
                DWORD cbRead;  // Discard after calling ReadFile()
                DWORD dwFlags = 0;

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opReadWrite.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    fRet =
                        ((WSARecv( (SOCKET ) pAtqContext->hAsyncIO,
                                   pAtqContext->arInfo.uop.opReadWrite.pBufAll,
                                   pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                   &cbRead,
                                   &dwFlags,
                                   pAtqContext->arInfo.lpOverlapped,
                                   NULL
                                   ) == 0)||
                         (WSAGetLastError() == WSA_IO_PENDING)
                         );

                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                } else {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opReadWrite.buf1.len,
                      pAtqContext->arInfo.uop.opReadWrite.buf1.buf
                    };
                    fRet = (( WSARecv( (SOCKET ) pAtqContext->hAsyncIO,
                                       &wsaBuf,
                                       1,
                                       &cbRead,
                                       &dwFlags,
                                       pAtqContext->arInfo.lpOverlapped,
                                       NULL
                                       ) == 0)||
                            (WSAGetLastError() == WSA_IO_PENDING)
                            );
                }
                break;
            }

          case AtqIoWrite:
            {
                DWORD cbWrite;  // Discard after calling WriteFile()

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opReadWrite.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    fRet =
                        ((WSASend( (SOCKET ) pAtqContext->hAsyncIO,
                                   pAtqContext->arInfo.uop.opReadWrite.pBufAll,
                                   pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                   &cbWrite,
                                   0,
                                   pAtqContext->arInfo.lpOverlapped,
                                   NULL
                                   ) == 0)||
                         (WSAGetLastError() == WSA_IO_PENDING)
                         );

                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                } else {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opReadWrite.buf1.len,
                      pAtqContext->arInfo.uop.opReadWrite.buf1.buf
                    };
                    fRet = (( WSASend( (SOCKET ) pAtqContext->hAsyncIO,
                                       &wsaBuf,
                                       1,
                                       &cbWrite,
                                       0,
                                       pAtqContext->arInfo.lpOverlapped,
                                       NULL
                                       ) == 0)||
                            (WSAGetLastError() == WSA_IO_PENDING)
                            );
                }
                break;
            }

          case AtqIoXmitFile:
            {
                fRet = TransmitFile( (SOCKET ) pAtqContext->hAsyncIO,
                                     pAtqContext->arInfo.uop.opXmit.hFile,
                                     pAtqContext->arInfo.uop.opXmit.
                                         dwBytesInFile,
                                     0,
                                     pAtqContext->arInfo.lpOverlapped,
                                     pAtqContext->arInfo.uop.
                                           opXmit.lpXmitBuffers,
                                     pAtqContext->arInfo.uop.
                                           opXmit.dwFlags );

                if ( !fRet && (GetLastError() == ERROR_IO_PENDING) ) {
                    fRet = TRUE;
                }
                break;
            }

          case AtqIoXmitFileRecv:
            {
                DWORD cbRead;

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opXmitRecv.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opXmitRecv.pBufAll);
                    fRet = I_AtqTransmitFileAndRecv
                               ( (PATQ_CONTEXT) pAtqContext,
                                 pAtqContext->arInfo.uop.opXmitRecv.hFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwBytesInFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.lpXmitBuffers,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwTFFlags,
                                 pAtqContext->arInfo.uop.opXmitRecv.pBufAll,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwBufferCount
                                );
                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opXmitRecv.pBufAll);
                    pAtqContext->arInfo.uop.opXmitRecv.pBufAll = NULL;
                }
                else
                {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opXmitRecv.buf1.len,
                      pAtqContext->arInfo.uop.opXmitRecv.buf1.buf
                    };
                    fRet = I_AtqTransmitFileAndRecv
                               ( (PATQ_CONTEXT) pAtqContext,
                                 pAtqContext->arInfo.uop.opXmitRecv.hFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwBytesInFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.lpXmitBuffers,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwTFFlags,
                                 &wsaBuf,
                                 1 );
                }

                if ( !fRet && GetLastError() == ERROR_IO_PENDING )
                {
                    fRet = TRUE;
                }
                break;
            }

          case AtqIoSendRecv:
            {
                WSABUF wsaSendBuf =
                { pAtqContext->arInfo.uop.opSendRecv.sendbuf1.len,
                  pAtqContext->arInfo.uop.opSendRecv.sendbuf1.buf
                };

                WSABUF wsaRecvBuf =
                {
                  pAtqContext->arInfo.uop.opSendRecv.recvbuf1.len,
                  pAtqContext->arInfo.uop.opSendRecv.recvbuf1.buf
                };

                LPWSABUF     pSendBuf = &wsaSendBuf;
                LPWSABUF     pRecvBuf = &wsaRecvBuf;

                if ( pAtqContext->arInfo.uop.opSendRecv.dwSendBufferCount > 1 )
                {
                    pSendBuf = pAtqContext->arInfo.uop.opSendRecv.pSendBufAll;
                }

                if ( pAtqContext->arInfo.uop.opSendRecv.dwRecvBufferCount > 1 )
                {
                    pRecvBuf = pAtqContext->arInfo.uop.opSendRecv.pRecvBufAll;
                }

                ATQ_ASSERT( pSendBuf != NULL );
                ATQ_ASSERT( pRecvBuf != NULL );

                fRet = I_AtqSendAndRecv
                                    ( (PATQ_CONTEXT) pAtqContext,
                                      pSendBuf,
                                      pAtqContext->arInfo.uop.opSendRecv.
                                        dwSendBufferCount,
                                      pRecvBuf,
                                      pAtqContext->arInfo.uop.opSendRecv.
                                        dwRecvBufferCount );

                if ( pAtqContext->arInfo.uop.opSendRecv.pSendBufAll != NULL )
                {
                    ::LocalFree( pAtqContext->arInfo.uop.opSendRecv.pSendBufAll );
                }

                if ( pAtqContext->arInfo.uop.opSendRecv.pRecvBufAll != NULL )
                {
                    ::LocalFree( pAtqContext->arInfo.uop.opSendRecv.pSendBufAll );
                }

                if ( !fRet && (GetLastError() == ERROR_IO_PENDING ) ) {
                    fRet = TRUE;
                }

                break;
            }

          default:
            ATQ_ASSERT( FALSE);
            break;
        } // switch

        pAtqContext->arInfo.atqOp = AtqIoNone; // reset since operation done.
        break;

      case StatusRejectOperation:

        IncTotalRejectedRequests();
        if ( ((pAtqContext->arInfo.atqOp == AtqIoRead) ||
             (pAtqContext->arInfo.atqOp == AtqIoRead)) &&
             (pAtqContext->arInfo.uop.opReadWrite.pBufAll != NULL)
             ) {
            ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
            pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
        }
        pAtqContext->arInfo.atqOp = AtqIoNone; // reset since op rejected.
        SetLastError( ERROR_NETWORK_BUSY);
        fRet = FALSE;
        break;

      case StatusBlockOperation:
        // do nothing. we cannot unblock
        ATQ_ASSERT(FALSE);
        return (TRUE);

      default:
        ATQ_ASSERT( FALSE);
        break;
    } // switch

    if (!fRet) {

        // Call the completion function to signify the error in operation.

        //
        //  Reset the timeout value so requests don't
        //  timeout multiple times
        //

        InterlockedExchange(
                    (LPLONG ) &pAtqContext->NextTimeout,
                    ATQ_INFINITE
                    );

        InterlockedDecrement( &pAtqContext->m_nIO);

        pAtqContext->IOCompletion( 0,
                                   GetLastError(),
                                   pAtqContext->arInfo.lpOverlapped );
    } // on failure.

    return (fRet);
#endif
}

BOOL
BANDWIDTH_INFO::CheckAndUnblockRequests( VOID )
/*++
  Checks the list of blocked requests and identifies all operations
  that needs to be unblocked. This function unblocks those requests and
  removes them from blocked list.

  Always call this function after lock()ing

  Returns:
    TRUE on success and FALSE on failure.

--*/
{
    BOOL fRet = TRUE;

    //
    //  If the list is not empty, then check and process blocked requests.
    //

    if ( !IsListEmpty( &_BlockedListHead ) ) {

        PLIST_ENTRY pentry;

        //
        //  Scan the blocked requests list looking for pending requests
        //   that needs to be unblocked and unblock these requests.
        //

        for (pentry  = _BlockedListHead.Flink;
             pentry != &_BlockedListHead;
             pentry  = pentry->Flink )
          {
              PATQ_CONT pContext = CONTAINING_RECORD(pentry,
                                                     ATQ_CONTEXT,
                                                     BlockedListEntry );

              if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE)
                {
                    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                    fRet = FALSE;
                    break;
                }

              if ( !pContext->IsBlocked()) {

                  // This should not happen.
                  ATQ_ASSERT( !pContext->IsBlocked());
                  fRet = FALSE;
                  continue;
              }

              //
              //  Check to see if the status for operation has changed.
              //  If so, unblock the request.
              //

              if ( _pStatus[pContext->arInfo.atqOp] !=
                  StatusBlockOperation) {

                  fRet &= UnblockRequest( pContext );
              }

          } // scan list
    }

    return (fRet);
}

BOOL
BANDWIDTH_INFO::UpdateBandwidth(
    VOID
)
/*++
  This function updates the current bandwidth value using the histogram
   of bytes transferred.
  The histogram maintains a history of bytes transferred over different sample
   periods of a single minute. Each entry in the histogram corresponds to one
   interval of sample. The sum of all entries gives the total bytes transferred
   in a single minute. We divide this measure by 60 to obtain the count of
   bytes transferred over a second. This update bandwidth is used to
   reevalute the tuner of bandwidth throttle based on our throttling policy
   (specified in throttling algorithm). The updated action information is
   used by subsequent requests.
  In addition the _pcbXfered pointer is advanced forward using the
   histogram entries as a circular buffer, to obtain the count of bytes
   for next interval.

  Arguments:
    pdwPrivateBw - Filled with bandwidth for this descriptor

  Returns:
    TRUE on success. FALSE otherwise.

  Note:
   It is recommended that this function be called as infrequently as
    possible, using reasonable sample intervals.

--*/
{
    BOOL fRet = TRUE;
    ZoneLevel zonelevel;

    Lock();

    // accumulate current byte count to global counter, to minimize computation
    _cbXfered.QuadPart = _cbXfered.QuadPart + _pBytesXferCur->QuadPart;

    //
    // Current n/ws support a max of 1 to 100 MB/s. We can represent
    //  4GB/s in a DWORD. Hence the cast is used. This may need revision later.
    // Better yet, later we should store bandwidth as KB/seconds.
    //
    _dwMeasuredBw = (DWORD ) (_cbXfered.QuadPart/ATQ_AVERAGING_PERIOD);

    CIRCULAR_INCREMENT( _pBytesXferCur, _rgBytesXfered, ATQ_HISTOGRAM_SIZE);
    // Adjust the global cumulative bytes sent after increment.
    _cbXfered .QuadPart = _cbXfered.QuadPart - _pBytesXferCur->QuadPart;
    // Reset the counter to start with the new counter value.
    _pBytesXferCur->QuadPart = 0;

    //
    // update the operation status depending upon the bandwidth comparisons.
    // we use band/zone calculations to split the result into 3 zones.
    // Depending upon the zone we update the global status pointer to
    //   appropriate row.
    //

    if ( _dwMeasuredBw < ATQ_LOW_BAND_THRESHOLD(_bandwidth)) {

        //
        // Lower zone. Modify the pointer to OPERATION_STATUS accordingly.
        //

        zonelevel = ZoneLevelLow;

    } else if ( _dwMeasuredBw > ATQ_HIGH_BAND_THRESHOLD(_bandwidth)) {

        //
        // Higher zone. Modify the pointer to OPERATION_STATUS accordingly.
        //

        zonelevel = ZoneLevelHigh;

    } else {

        zonelevel = ZoneLevelMedium;
    }

    /*++
      Above calculation can be implemented as:
      zonelevel = (( sm_dwMeasuredBw > ATQ_LOW_BAND_THRESHOLD( sm_bandwidth)) +
                   ( sm_dwMeasuredBw > ATQ_HIGH_BAND_THRESHOLD( sm_bandwidth)));

      This is based on implicit dependence of ordering of ZoneLevel entries.
      So avoided for present now.
    --*/

    if ( _pStatus != &sm_rgStatus[zonelevel][0]) {

        // Status needs to be changed.
        _pStatus = &sm_rgStatus[zonelevel][0];

        // Examine and reenable blocked operations if any.
        fRet &= CheckAndUnblockRequests();
    }

    // remove the bandwidth info object from the list if it is
    // "inactive" (bandwidth = 0)

    if ( !_dwMeasuredBw )
    {
        // there should be no requests in the blocked queue!

        ATQ_ASSERT( _cCurrentBlockedRequests == 0 );

        RemoveFromActiveList();
    }

    Unlock();

    return fRet;
}

DWORD
BANDWIDTH_INFO::SetBandwidthLevel(
    IN DWORD                    Data
)
/*++
   Sets the bandwidth threshold

   Arguments:
      Data - Bandwidth threshold

   Returns:
      Old bandwidth threshold (DWORD)
--*/
{
    DWORD dwOldVal;
    INT iListDelta = 0;

    Lock();

    dwOldVal = _bandwidth.dwSpecifiedLevel;

    if ( Data != INFINITE) {

        DWORD dwTemp;

        _bandwidth.dwSpecifiedLevel  = ATQ_ROUNDUP_BANDWIDTH( Data );
        dwTemp = ( Data *9)/10;               //low threshold = 0.9*specified
        _bandwidth.dwLowThreshold    = ATQ_ROUNDUP_BANDWIDTH( dwTemp);
        dwTemp = ( Data *11)/10;              //high threshold= 1.1*specified
        _bandwidth.dwHighThreshold   = ATQ_ROUNDUP_BANDWIDTH( dwTemp);

        _fEnabled = TRUE;
        // we should recheck the throttling and blocked requests
        // Will be done when the next timeout occurs in the ATQ Timeout Thread

        if ( dwOldVal == INFINITE )
        {
            iListDelta = 1;
        }

    } else {

        _bandwidth.dwSpecifiedLevel = INFINITE;
        _bandwidth.dwLowThreshold   = INFINITE;
        _bandwidth.dwHighThreshold  = INFINITE;

        _fEnabled = FALSE;

        // enable all operations, since we are in low zone
        _pStatus = &sm_rgStatus[ZoneLevelLow][0];

        // we should recheck and enable all blocked requests.
        if ( _cCurrentBlockedRequests > 0) {
            ATQ_REQUIRE( CheckAndUnblockRequests());
        }

        if ( dwOldVal != INFINITE )
        {
            iListDelta = -1;
        }
    }

    Unlock();

    // update the static counter of how many non-infinite throttles we have

    if ( iListDelta )
    {
        SharedLock();

        if ( iListDelta > 0 )
        {
            sm_cNonInfinite++;
        }
        else
        {
            sm_cNonInfinite--;
        }
        sm_fGlobalEnabled = !!sm_cNonInfinite;

        SharedUnlock();
    }

    return dwOldVal;

}

DWORD
BANDWIDTH_INFO::SetMaxBlockedListSize(
    IN DWORD                    cMaxSize
)
/*++
   Sets the maximum size of blocked request list

   Arguments:
      cMaxSize - maximum size of list

   Returns:
      Old max size (DWORD)
--*/
{
    DWORD           cOldMax;

    Lock();

    cOldMax = _cMaxBlockedList;
    _cMaxBlockedList = cMaxSize;

    Unlock();

    return cOldMax;
}

DWORD
BANDWIDTH_INFO::QueryBandwidthLevel( VOID )
/*++
   Retrieve the current bandwidth level

   Arguments:
      None

   Returns:
      Set Bandwidth level (DWORD)
--*/
{
    DWORD dwBw;

    Lock();

    dwBw = _bandwidth.dwSpecifiedLevel;

    Unlock();

    return dwBw;
}

BOOL
BANDWIDTH_INFO::ClearStatistics( VOID )
{
    Lock();

    _cTotalAllowedRequests = 0;
    _cTotalBlockedRequests = 0;
    _cTotalRejectedRequests = 0;

    Unlock();

    return TRUE;
}

BOOL
BANDWIDTH_INFO::GetStatistics( OUT ATQ_STATISTICS * pAtqStats )
{
    ATQ_ASSERT( pAtqStats != NULL );

    pAtqStats->cRejectedRequests = _cTotalRejectedRequests;
    pAtqStats->cBlockedRequests = _cTotalBlockedRequests;
    pAtqStats->cAllowedRequests = _cTotalAllowedRequests;
    pAtqStats->cCurrentBlockedRequests = _cCurrentBlockedRequests;
    pAtqStats->MeasuredBandwidth = _dwMeasuredBw;

    return TRUE;
}

BOOL
BANDWIDTH_INFO::UpdateAllBandwidths( VOID )
{
    PLIST_ENTRY             pEntry;
    BOOL                    fRet = TRUE;
    DWORD                   dwCounter = 0;

    SharedLock();

    for ( pEntry = sm_ActiveListHead.Flink;
          pEntry != &sm_ActiveListHead; )
    {
        BANDWIDTH_INFO *pBandwidthInfo = CONTAINING_RECORD( pEntry,
                                                            BANDWIDTH_INFO,
                                                            _ActiveListEntry );

        ATQ_ASSERT( pBandwidthInfo != NULL );

        // we might be deleting this entry from the list.  Grab the next
        // link now before we do so the traversal can happen smoothly

        pEntry = pEntry->Flink;

        if ( !pBandwidthInfo->Enabled() )
        {
            continue;
        }

        if ( !pBandwidthInfo->UpdateBandwidth() )
        {
            fRet = FALSE;
            break;
        }

        ATQ_PRINTF(( DBG_CONTEXT, "pBWInfo =  %p (%s), Bandwidth = %u, Threshold = %d\n",
                     pBandwidthInfo,
                     pBandwidthInfo->_achDescription,
                     pBandwidthInfo->QueryMeasuredBw(),
                     pBandwidthInfo->QueryBandwidthLevel() ) );
    }

    SharedUnlock();

    return fRet;
}

BOOL
BANDWIDTH_INFO::AbwInitialize( VOID )
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, 10, sizeof(BANDWIDTH_INFO)};

    ATQ_ASSERT( sm_pachBWInfos == NULL );

    sm_pachBWInfos = new ALLOC_CACHE_HANDLER( "BandwidthInfos",
                                              &acConfig );

    if ( sm_pachBWInfos == NULL )
    {
        return FALSE;
    }

    InitializeListHead( &sm_ActiveListHead );
    InitializeListHead( &sm_BornListHead );
    InitializeCriticalSection( &sm_csSharedLock );

    sm_cActiveList          = 0;
    sm_cBornList            = 0;
    sm_fGlobalEnabled       = FALSE;
    sm_fGlobalActive        = FALSE;
    sm_cNonInfinite         = 0;
    sm_cSamplesForTimeout   = 1;

    g_pBandwidthInfo = new BANDWIDTH_INFO( TRUE );

    if ( !g_pBandwidthInfo )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
BANDWIDTH_INFO::AbwTerminate( VOID )
{
    PBANDWIDTH_INFO         pBandwidthInfo;

    ATQ_PRINTF(( DBG_CONTEXT,
                 "AbwTerminate() called.  Born List Size = %d\n",
                 sm_cBornList ));

    SharedLock();

    while( !IsListEmpty( &sm_BornListHead ) )
    {
        pBandwidthInfo = CONTAINING_RECORD( sm_BornListHead.Flink,
                                            BANDWIDTH_INFO,
                                            _BornListEntry );

        ATQ_ASSERT( pBandwidthInfo != NULL );

        delete pBandwidthInfo;
    }

    ATQ_ASSERT( sm_cBornList == 0 );
    ATQ_ASSERT( sm_cActiveList == 0 );
    ATQ_ASSERT( IsListEmpty( &sm_BornListHead ) );
    ATQ_ASSERT( IsListEmpty( &sm_ActiveListHead ) );

    SharedUnlock();

    DeleteCriticalSection( &sm_csSharedLock );

    if ( sm_pachBWInfos != NULL )
    {
        delete sm_pachBWInfos;
        sm_pachBWInfos = NULL;
    }

    return TRUE;
}


PVOID
AtqCreateBandwidthInfo( VOID )
/*++

Routine Description:

    Allocate a bandwidth throttling descriptor

Arguments:

    none

Return Value:

    If successful, pointer to allocated descriptor.  Otherwise NULL.

--*/
{
    PBANDWIDTH_INFO         pBandwidthInfo;

    pBandwidthInfo = new BANDWIDTH_INFO( FALSE );
    if ( pBandwidthInfo == NULL )
    {
        return NULL;
    }
    else
    {
        ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );
        return pBandwidthInfo;
    }
}


BOOL
AtqFreeBandwidthInfo(
    IN PVOID        pvBandwidthInfo
)
/*++

Routine Description:

    Free bandwidth throttling descriptor

Arguments:

    pBandwidthInfo - Descriptor to destroy

Return Value:

    TRUE If successful, else FALSE.

--*/
{
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    return pBandwidthInfo->PrepareToFree();
}


DWORD_PTR
AtqBandwidthSetInfo(
      IN PVOID                 pvBandwidthInfo,
      IN ATQ_BANDWIDTH_INFO    BwInfo,
      IN DWORD_PTR             Data
)
/*++

Routine Description:

    Set member of bandwidth descriptor

Arguments:

    pBandwidthInfo - Descriptor to change
    BwInfo - Value of descriptor to set
    Data - Data to set to

Return Value:

    Previous value of descriptor

--*/
{
    DWORD_PTR       dwOldVal = 0;
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( pBandwidthInfo &&
         pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE )
    {
        switch ( BwInfo )
        {
        case ATQ_BW_BANDWIDTH_LEVEL:
            dwOldVal = pBandwidthInfo->QueryBandwidthLevel();
            pBandwidthInfo->SetBandwidthLevel( (DWORD)Data );
            break;
        case ATQ_BW_MAX_BLOCKED:
            dwOldVal = pBandwidthInfo->QueryMaxBlockedSize();
            pBandwidthInfo->SetMaxBlockedListSize( (DWORD)Data );
            break;
        case ATQ_BW_DESCRIPTION:
            dwOldVal = Data;
            pBandwidthInfo->SetDescription( (CHAR*) Data );
            break;
        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            ATQ_ASSERT( FALSE );
            break;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
    }

    return dwOldVal;
}


BOOL
AtqBandwidthGetInfo(
      IN PVOID                 pvBandwidthInfo,
      IN ATQ_BANDWIDTH_INFO    BwInfo,
      OUT DWORD_PTR *          pdwData
)
/*++

Routine Description:

    Get member of bandwidth descriptor

Arguments:

    pvBandwidthInfo - Descriptor to change
    BwInfo - Value of descriptor to set
    pdwData - Output here

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    BOOL            fRet = TRUE;
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );
    ATQ_ASSERT( pdwData );

    if ( pBandwidthInfo &&
         pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE &&
         pdwData )
    {
        switch ( BwInfo )
        {
        case ATQ_BW_BANDWIDTH_LEVEL:
            *pdwData = pBandwidthInfo->QueryBandwidthLevel();
            break;
        case ATQ_BW_MAX_BLOCKED:
            *pdwData = pBandwidthInfo->QueryMaxBlockedSize();
            break;
        case ATQ_BW_STATISTICS:
            fRet = pBandwidthInfo->GetStatistics( (ATQ_STATISTICS*) pdwData );
            break;
        case ATQ_BW_DESCRIPTION:
            *pdwData = (DWORD_PTR) pBandwidthInfo->QueryDescription();
            break;
        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            ATQ_ASSERT( FALSE );
            fRet = FALSE;
            break;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\wmi\source\util.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  CopyRight ( c ) 1999 Microsoft Corporation
//
//  Module Name: util.cpp
//
//  Description:    
//      const definition
//
//  Author:
//      Henry Wang ( henrywa ) March 8, 2000
//
//
//////////////////////////////////////////////////////////////////////


#include "DnsWmi.h"


//
//  These macros allow us to widen DNS RPC string constants.
//

#define MYTXT2(str)     L##str
#define MYTXT(str)      MYTXT2(str)


const WCHAR* const PVD_CLASS_SERVER = L"MicrosoftDNS_Server";

const WCHAR* const PVD_CLASS_DOMAIN = L"MicrosoftDNS_Domain";
const WCHAR* const PVD_CLASS_ZONE = L"MicrosoftDNS_Zone";
const WCHAR* const PVD_CLASS_CACHE = L"MicrosoftDNS_Cache";
const WCHAR* const PVD_CLASS_ROOTHINTS = L"MicrosoftDNS_RootHints";
const WCHAR* const PVD_CLASS_RESOURCERECORD = L"MicrosoftDNS_ResourceRecord";
const WCHAR* const PVD_CLASS_RR_A = L"MicrosoftDNS_AType";
const WCHAR* const PVD_CLASS_RR_SOA = L"MicrosoftDNS_SOAType";
const WCHAR* const PVD_CLASS_RR_PTR = L"MicrosoftDNS_PTRType";
const WCHAR* const PVD_CLASS_RR_NS = L"MicrosoftDNS_NSType";
const WCHAR* const PVD_CLASS_RR_CNAME = L"MicrosoftDNS_CNAMEType";
const WCHAR* const PVD_CLASS_RR_MB = L"MicrosoftDNS_MBType";
const WCHAR* const PVD_CLASS_RR_MD = L"MicrosoftDNS_MDType";
const WCHAR* const PVD_CLASS_RR_MF = L"MicrosoftDNS_MFType";
const WCHAR* const PVD_CLASS_RR_MG = L"MicrosoftDNS_MGType";
const WCHAR* const PVD_CLASS_RR_MR = L"MicrosoftDNS_MRType";
const WCHAR* const PVD_CLASS_RR_MINFO = L"MicrosoftDNS_MINFOType";
const WCHAR* const PVD_CLASS_RR_RP = L"MicrosoftDNS_RPType";
const WCHAR* const PVD_CLASS_RR_MX = L"MicrosoftDNS_MXType";
const WCHAR* const PVD_CLASS_RR_AFSDB = L"MicrosoftDNS_AFSDBType";
const WCHAR* const PVD_CLASS_RR_RT = L"MicrosoftDNS_RTType";
const WCHAR* const PVD_CLASS_RR_HINFO = L"MicrosoftDNS_HINFOType";
const WCHAR* const PVD_CLASS_RR_ISDN = L"MicrosoftDNS_ISDNType";
const WCHAR* const PVD_CLASS_RR_TXT = L"MicrosoftDNS_TXTType";
const WCHAR* const PVD_CLASS_RR_X25 = L"MicrosoftDNS_X25Type";
const WCHAR* const PVD_CLASS_RR_NULL = L"MicrosoftDNS_NULLType";
const WCHAR* const PVD_CLASS_RR_WKS = L"MicrosoftDNS_WKSType";
const WCHAR* const PVD_CLASS_RR_AAAA = L"MicrosoftDNS_AAAAType";
const WCHAR* const PVD_CLASS_RR_SRV = L"MicrosoftDNS_SRVType";
const WCHAR* const PVD_CLASS_RR_ATMA = L"MicrosoftDNS_ATMAType";
const WCHAR* const PVD_CLASS_RR_WINS = L"MicrosoftDNS_WINSType";
const WCHAR* const PVD_CLASS_RR_WINSR = L"MicrosoftDNS_WINSRType";
const WCHAR* const PVD_CLASS_RR_KEY = L"MicrosoftDNS_KEYType";
const WCHAR* const PVD_CLASS_RR_SIG = L"MicrosoftDNS_SIGType";
const WCHAR* const PVD_CLASS_RR_NXT = L"MicrosoftDNS_NXTType";

const WCHAR* const PVD_CLASS_SERVERDOMAIN = L"MicrosoftDNS_ServerDomainContainment";
const WCHAR* const PVD_CLASS_DOMAINDOMAIN = L"MicrosoftDNS_DomainDomainContainment";
const WCHAR* const PVD_CLASS_DOMAINRESOURCERECORD = L"MicrosoftDNS_DomainResourceRecordContainment";

const WCHAR* const PVD_CLASS_STATISTIC= L"MicrosoftDNS_Statistic";

//  server

const WCHAR* const PVD_SRV_ADDRESS_ANSWER_LIMIT = L"AddressAnswerLimit";
const WCHAR* const PVD_SRV_BOOT_METHOD = L"BootMethod";
const WCHAR* const PVD_SRV_DS_POLLING_INTERVAL = L"DsPollingInterval";
const WCHAR* const PVD_SRV_EVENT_LOG_LEVEL = L"EventLogLevel";
const WCHAR* const PVD_SRV_ALLOW_UPDATE = L"AllowUpdate";
const WCHAR* const PVD_SRV_AUTO_CACHE_UPDATE = L"AutoCacheUpdate";
const WCHAR* const PVD_SRV_AUTO_REVERSE_ZONES = L"DisableAutoReverseZones";
const WCHAR* const PVD_SRV_BIND_SECONDARIES = L"SlowZoneTransfer";
const WCHAR* const PVD_SRV_DISJOINT_NETS = L"DisjointNets";
const WCHAR* const PVD_SRV_DS_AVAILABLE = L"DsAvailable";
const WCHAR* const PVD_SRV_FORWARD_DELEGATION = L"ForwardDelegations";
const WCHAR* const PVD_SRV_LOCAL_NETPRIORITY = L"LocalNetPriority";
const WCHAR* const PVD_SRV_LOOSE_WILDCARDING = L"LooseWildcarding";
const WCHAR* const PVD_SRV_NO_RECURSION = L"NoRecursion";
const WCHAR* const PVD_SRV_ROUND_ROBIN = L"RoundRobin";
const WCHAR* const PVD_SRV_SECURE_RESPONSES = L"SecureResponses";
const WCHAR* const PVD_SRV_SLAVE = L"Slave";
const WCHAR* const PVD_SRV_STRICT_FILE_PARSING = L"StrictFileParsing";
const WCHAR* const PVD_SRV_AUTO_CONFIG_FILE_ZONES = L"AutoConfigFileZones";
const WCHAR* const PVD_SRV_DEFAULT_AGING_STATE = L"DefaultAgingState";
const WCHAR* const PVD_SRV_DEFAULT_REFRESH_INTERVAL = L"DefaultRefreshInterval";
const WCHAR* const PVD_SRV_DEFAULT_NOREFRESH_INTERVAL = L"DefaultNoRefreshInterval";
const WCHAR* const PVD_SRV_ENABLE_EDNS = L"EnableEDnsProbes";
const WCHAR* const PVD_SRV_EDNS_CACHE_TIMEOUT = L"EDnsCacheTimeout";
const WCHAR* const PVD_SRV_MAX_UDP_PACKET_SIZE = L"MaximumUdpPacketSize";
const WCHAR* const PVD_SRV_ENABLE_DNSSEC = L"EnableDnsSec";
const WCHAR* const PVD_SRV_ENABLE_DP = L"EnableDirectoryPartitionSupport";
const WCHAR* const PVD_SRV_UPDATE_OPTIONS = MYTXT( DNS_REGKEY_UPDATE_OPTIONS );

// dww - 6/24/99
// WriteAuthoritySoa removed from the schema.
// const WCHAR* const PVD_SRV_WRITE_AUTHIORITY_SOA = L"WriteAuthoritySoa";
const WCHAR* const PVD_SRV_WRITE_AUTHORITY_NS = L"WriteAuthorityNS";
const WCHAR* const PVD_SRV_LISTEN_IP_ADDRESSES_ARRAY = L"ListenIPAddresses";
const WCHAR* const PVD_SRV_LOG_LEVEL = L"LogLevel";
const WCHAR* const PVD_SRV_MAX_CACHE_TTL = L"MaxCacheTTL";
const WCHAR* const PVD_SRV_NAME_CHECK_FLAG = L"NameCheckFlag";
const WCHAR* const PVD_SRV_RECURSION_RETRY = L"RecursionRetry";
const WCHAR* const PVD_SRV_RECURSION_TIMEOUT = L"RecursionTimeout";
const WCHAR* const PVD_SRV_RPC_PROTOCOL = L"RpcProtocol";
const WCHAR* const PVD_SRV_SEND_ON_NON_DNS_PORT = L"SendOnNonDnsPort";
const WCHAR* const PVD_SRV_SERVER_IP_ADDRESSES_ARRAY = L"ServerAddresses";
const WCHAR* const PVD_SRV_SERVER_NAME = L"Name";
const WCHAR* const PVD_SRV_VERSION = L"Version";
const WCHAR* const PVD_SRV_STARTED = L"Started";
const WCHAR* const PVD_SRV_STARTMODE = L"StartMode";

// resource record

const WCHAR* const PVD_REC_CONTAINER_NAME = L"ContainerName";
const WCHAR* const PVD_REC_SERVER_NAME = L"DnsServerName";
const WCHAR* const PVD_REC_DOMAIN_NAME = L"DomainName";
const WCHAR* const PVD_REC_OWNER_NAME = L"OwnerName";
const WCHAR* const PVD_REC_CLASS = L"RecordClass";
const WCHAR* const PVD_REC_RDATA = L"RecordData";
const WCHAR* const PVD_REC_TXT_REP = L"TextRepresentation";
const WCHAR* const PVD_REC_TTL = L"TTL";
const WCHAR* const PVD_REC_TYPE = L"RecordType";

const WCHAR* const PVD_REC_AAAA_IP = L"IPv6Address";
const WCHAR* const PVD_REC_AFSBD_SERVER_NAME = L"ServerName";
const WCHAR* const PVD_REC_AFSBD_SUB_TYPE = L"SubType";
const WCHAR* const PVD_REC_ATMA_FORMAT = L"Format";
const WCHAR* const PVD_REC_ATMA_ATM_ADDRESS = L"ATMAddress";
const WCHAR* const PVD_REC_A_IP = L"IPAddress";
const WCHAR* const PVD_REC_CNAME_PRIMARY_NAME = L"PrimaryName";
const WCHAR* const PVD_REC_HINFO_CPU = L"CPU";
const WCHAR* const PVD_REC_HINFO_OS = L"OS";
const WCHAR* const PVD_REC_ISDN_ISDN_NUM = L"ISDNNumber";
const WCHAR* const PVD_REC_ISDN_SUB_ADDRESS = L"SubAddress";
const WCHAR* const PVD_REC_MB_MBHOST = L"MBHost";
const WCHAR* const PVD_REC_MD_MDHOST = L"MDHost";
const WCHAR* const PVD_REC_MF_MFHOST = L"MFHost";
const WCHAR* const PVD_REC_MG_MGMAILBOX = L"MGMailBox";
const WCHAR* const PVD_REC_MINFO_ERROR_MAILBOX = L"ErrorMailBox";
const WCHAR* const PVD_REC_MINFO_RESP_MAILBOX = L"ResponsibleMailBox";
const WCHAR* const PVD_REC_MR_MRMAILBOX = L"MRMailBox";
const WCHAR* const PVD_REC_MX_MAIL_EXCHANGE = L"MailExchange";
const WCHAR* const PVD_REC_MX_PREFERENCE = L"Preference";
const WCHAR* const PVD_REC_NS_NSHOST = L"NSHost";
const WCHAR* const PVD_REC_NULL_NULLDATA = L"NULLDATA";
const WCHAR* const PVD_REC_PTR_PTRDOMAIN_NAME = L"PTRDomainName";
const WCHAR* const PVD_REC_RP_RPMAILBOX = L"RPMailBox";
const WCHAR* const PVD_REC_RP_TXT_DOMAIN_NAME = L"TxtDomainName";
const WCHAR* const PVD_REC_RT_HOST = L"IntermediateHost";
const WCHAR* const PVD_REC_RT_PREFERENCE = L"Preference";
const WCHAR* const PVD_REC_SOA_EXPIRE_LIMIT = L"ExpireLimit";
const WCHAR* const PVD_REC_SOA_TTL = L"MinimumTTL";
const WCHAR* const PVD_REC_SOA_PRIMARY_SERVER = L"PrimaryServer";
const WCHAR* const PVD_REC_SOA_REFRESH = L"RefreshInterval";
const WCHAR* const PVD_REC_SOA_RESPONSIBLE = L"ResponsibleParty";
const WCHAR* const PVD_REC_SOA_RETRY_DELAY = L"RetryDelay";
const WCHAR* const PVD_REC_SOA_SERIAL_NUMBER = L"SerialNumber";
const WCHAR* const PVD_REC_SRV_PORT = L"Port";
const WCHAR* const PVD_REC_SRV_PRIORITY = L"Priority";
const WCHAR* const PVD_REC_SRV_WEIGHT = L"Weight";
const WCHAR* const PVD_REC_SRV_DOMAINNAME = L"DomainName";
const WCHAR* const PVD_REC_TXT_TEXT = L"DescriptiveText";
const WCHAR* const PVD_REC_WINSR_TIMEOUT = L"LookupTimeOut";
const WCHAR* const PVD_REC_WINSR_MAPPING_FLAG = L"MappingFlag";
const WCHAR* const PVD_REC_WINSR_RESULT_DOMAIN = L"ResultDomain";
const WCHAR* const PVD_REC_WINSR_CACHE_TIMEOUT = L"CacheTimeOut";

const WCHAR* const PVD_REC_WINS_TIMEOUT = L"LookupTimeOut";
const WCHAR* const PVD_REC_WINS_MAPPING_FLAG = L"MappingFlag";
const WCHAR* const PVD_REC_WINS_WINS_SERVER = L"WinsServers";
const WCHAR* const PVD_REC_WINS_CACHE_TIMEOUT = L"CacheTimeOut";
const WCHAR* const PVD_REC_WKS_INTERNET_ADDRESS = L"InternetAddress";
const WCHAR* const PVD_REC_WKS_IP_PROTOCOL = L"IPProtocol";
const WCHAR* const PVD_REC_WKS_BIT_MASK = L"Services";
const WCHAR* const PVD_REC_X25_PSDNADDRESS = L"PSDNAddress";

// domain 


const WCHAR* const PVD_DOMAIN_CONTAINER_NAME = L"ContainerName";
const WCHAR* const PVD_DOMAIN_FQDN = L"Name";
const WCHAR* const PVD_DOMAIN_SERVER_NAME = L"DnsServerName";

//zone


const WCHAR* const PVD_ZONE_ALLOW_UPDATE = L"AllowUpdate";
const WCHAR* const PVD_ZONE_AUTO_CREATED = L"AutoCreated";
const WCHAR* const PVD_ZONE_DISABLE_WIN_SRECORD_REPLICATION = L"DisableWINSRecordReplication";
//const WCHAR* const PVD_DS_INTEGRATED L"DsIntegrated"  
const WCHAR* const PVD_ZONE_NOTIFY = L"Notify";
const WCHAR* const PVD_ZONE_PAUSED = L"Paused";
const WCHAR* const PVD_ZONE_REVERSE = L"Reverse";
const WCHAR* const PVD_ZONE_AGING = L"Aging";
const WCHAR* const PVD_ZONE_SECURE_SECONDARIES = L"SecureSecondaries";
const WCHAR* const PVD_ZONE_SHUTDOWN = L"Shutdown";
const WCHAR* const PVD_ZONE_USE_WINS = L"UseWins";
const WCHAR* const PVD_ZONE_MASTERS_IP_ADDRESSES_ARRAY = L"MasterServers";
const WCHAR* const PVD_ZONE_LOCAL_MASTERS_IP_ADDRESSES_ARRAY = L"LocalMasterServers";
const WCHAR* const PVD_ZONE_DATA_FILE = L"DataFile";
const WCHAR* const PVD_ZONE_SECONDARIES_IP_ADDRESSES_ARRAY = L"SecondaryServers";
const WCHAR* const PVD_ZONE_NOTIFY_IPADDRESSES_ARRAY = L"NotifyServers";
const WCHAR* const PVD_ZONE_ZONE_TYPE = L"ZoneType";
const WCHAR* const PVD_ZONE_DS_INTEGRATED = L"DsIntegrated";
const WCHAR* const PVD_ZONE_AVAIL_FOR_SCAVENGE_TIME = L"AvailForScavengeTime";
const WCHAR* const PVD_ZONE_REFRESH_INTERVAL = L"RefreshInterval";
const WCHAR* const PVD_ZONE_NOREFRESH_INTERVAL = L"NoRefreshInterval";
const WCHAR* const PVD_ZONE_SCAVENGE_SERVERS = L"ScavengeServers";
const WCHAR* const PVD_ZONE_FORWARDER_SLAVE = L"ForwarderSlave";
const WCHAR* const PVD_ZONE_FORWARDER_TIMEOUT = L"ForwarderTimeout";
const WCHAR* const PVD_ZONE_LAST_SOA_CHECK = L"LastSuccessfulSoaCheck";
const WCHAR* const PVD_ZONE_LAST_GOOD_XFR = L"LastSuccessfulXfr";

//domaindomain
//domain resource record containment
// server domain  containment

const WCHAR* const PVD_ASSOC_CHILD = L"PartComponent";
const WCHAR* const PVD_ASSOC_PARENT = L"GroupComponent";
// method
const WCHAR* const PVD_MTH_SRV_RESTART = L"RestartDNSServer";
const WCHAR* const PVD_MTH_SRV_START_SERVICE = L"StartService";
const WCHAR* const PVD_MTH_SRV_STOP_SERVICE = L"StopService";
const WCHAR* const PVD_MTH_ZONE_RESUMEZONE = L"ResumeZone";
const WCHAR* const PVD_MTH_ZONE_PAUSEZONE = L"PauseZone";
const WCHAR* const PVD_MTH_ZONE_RELOADZONE = L"ReloadZone";
const WCHAR* const PVD_MTH_ZONE_FORCEREFRESH = L"ForceRefresh";
const WCHAR* const PVD_MTH_ZONE_UPDATEFROMDS = L"UpdateFromDS";
const WCHAR* const PVD_MTH_ZONE_WRITEBACKZONETOFILE = L"WriteBackZoneToFile";
const WCHAR* const PVD_MTH_ZONE_CHANGEZONETYPE = L"ChangeZoneType";
const WCHAR* const PVD_MTH_ZONE_CREATEZONE = L"CreateZone";
const WCHAR* const PVD_MTH_ZONE_RESETNOTIFYIPARRAY = L"ResetNotifyIpArray";
const WCHAR* const PVD_MTH_ZONE_RESETSECONDARYIPARRAY = L"ResetSecondaries";
const WCHAR* const PVD_MTH_ZONE_GETDISTINGUISHEDNAME = L"GetDistinguishedName";
const WCHAR* const PVD_MTH_ZONE_ARG_ZONENAME = L"ZoneName";
const WCHAR* const PVD_MTH_ZONE_ARG_ZONETYPE = L"ZoneType";
const WCHAR* const PVD_MTH_ZONE_ARG_DATAFILENAME = L"DataFileName";
const WCHAR* const PVD_MTH_ZONE_ARG_IPADDRARRAY = L"IpAddr";
const WCHAR* const PVD_MTH_ZONE_ARG_ADMINEMAILNAME = L"AdminEmailName";
const WCHAR* const PVD_MTH_ZONE_ARG_SECURITY = L"SecureSecondaries";
const WCHAR* const PVD_MTH_ZONE_ARG_NOTIFY = L"Notify";
const WCHAR* const PVD_MTH_ZONE_ARG_SECONDARYIPARRAY = L"SecondaryServers";
const WCHAR* const PVD_MTH_ZONE_ARG_NOTIFYIPARRAY = L"NotifyServers";


//
//  Methods and stuff
//

const WCHAR* const PVD_MTH_REC_CREATEINSTANCEFROMTEXTREPRESENTATION = L"CreateInstanceFromTextRepresentation";
const WCHAR* const PVD_MTH_REC_MODIFY = L"Modify";
const WCHAR* const PVD_MTH_REC_CREATEINSTANCEFROMPROPERTYDATA = L"CreateInstanceFromPropertyData";
const WCHAR* const PVD_MTH_REC_GETOBJECTBYTEXT = L"GetObjectByTextRepresentation";
const WCHAR* const PVD_MTH_REC_ARG_DNSSERVER_NAME = L"DnsServerName";
const WCHAR* const PVD_MTH_REC_ARG_CONTAINER_NAME = L"ContainerName";
const WCHAR* const PVD_MTH_REC_ARG_TEXTREP = L"TextRepresentation";
const WCHAR* const PVD_MTH_REC_ARG_RR = L"RR";
const WCHAR* const PVD_MTH_RH_WRITEBACKROOTHINTDATAFILE = L"WriteBackRootHintDatafile";
const WCHAR* const PVD_MTH_CACHE_CLEARDNSSERVERCACHE = L"ClearCache";
//general
const WCHAR* const PVD_DNS_CACHE = L"..Cache";
const WCHAR* const PVD_DNS_ROOTHINTS = L"..RootHints";
const WCHAR* const PVD_DNS_LOCAL_SERVER = L".";
const WCHAR* const PVD_DNS_RETURN_VALUE = L"ReturnValue";
class CClassData
{
public:
    const WCHAR* wszClassName;
    FPNEW pfConstruct;
    const char* szType;
};

CClassData g_ClassDataArray[]=
{
    {PVD_CLASS_SERVER,  CDnsServer::CreateThis, ""},
    {PVD_CLASS_DOMAIN,  CDnsDomain::CreateThis, ""},
    {PVD_CLASS_ZONE,    CDnsZone::CreateThis, ""},
    {PVD_CLASS_CACHE,   CDnsCache::CreateThis, ""},
    {PVD_CLASS_ROOTHINTS,   CDnsRootHints::CreateThis, ""},
    {PVD_CLASS_RESOURCERECORD, CDnsResourceRecord::CreateThis, ""},
    {PVD_CLASS_RR_A,    CDnsResourceRecord::CreateThis, "A"},
    {PVD_CLASS_RR_SOA,  CDnsResourceRecord::CreateThis, "SOA"},
    {PVD_CLASS_RR_NS,   CDnsResourceRecord::CreateThis, "NS"},
    {PVD_CLASS_RR_CNAME,CDnsResourceRecord::CreateThis, "CNAME"},
    {PVD_CLASS_RR_PTR,  CDnsResourceRecord::CreateThis, "PTR"},
	{PVD_CLASS_RR_MB, CDnsResourceRecord::CreateThis, "MB"},
	{PVD_CLASS_RR_MD, CDnsResourceRecord::CreateThis, "MD"},
	{PVD_CLASS_RR_MF, CDnsResourceRecord::CreateThis, "MF"},
	{PVD_CLASS_RR_MG, CDnsResourceRecord::CreateThis, "MG"},
	{PVD_CLASS_RR_MR, CDnsResourceRecord::CreateThis, "MR"},
	{PVD_CLASS_RR_MINFO, CDnsResourceRecord::CreateThis, "MINFO"},
	{PVD_CLASS_RR_RP, CDnsResourceRecord::CreateThis, "RP"},
	{PVD_CLASS_RR_MX, CDnsResourceRecord::CreateThis, "MX"},
	{PVD_CLASS_RR_AFSDB, CDnsResourceRecord::CreateThis, "AFSDB"},
	{PVD_CLASS_RR_RT, CDnsResourceRecord::CreateThis, "RT"},
	{PVD_CLASS_RR_HINFO, CDnsResourceRecord::CreateThis, "HINFO"},
	{PVD_CLASS_RR_ISDN, CDnsResourceRecord::CreateThis, "ISDN"},
	{PVD_CLASS_RR_TXT, CDnsResourceRecord::CreateThis, "TXT"},
	{PVD_CLASS_RR_X25, CDnsResourceRecord::CreateThis, "X25"},
	{PVD_CLASS_RR_NULL, CDnsResourceRecord::CreateThis, "NULL"},
	{PVD_CLASS_RR_WKS, CDnsResourceRecord::CreateThis, "WKS"},
	{PVD_CLASS_RR_AAAA, CDnsResourceRecord::CreateThis, "AAAA"},
	{PVD_CLASS_RR_SRV, CDnsResourceRecord::CreateThis, "SRV"},
	{PVD_CLASS_RR_ATMA, CDnsResourceRecord::CreateThis, "ATMA"},
	{PVD_CLASS_RR_WINS, CDnsResourceRecord::CreateThis, "WINS"},
	{PVD_CLASS_RR_WINSR, CDnsResourceRecord::CreateThis, "WINSR"},
    {PVD_CLASS_RR_SIG,    CDnsResourceRecord::CreateThis, "SIG"},
    {PVD_CLASS_RR_KEY,    CDnsResourceRecord::CreateThis, "KEY"},
    {PVD_CLASS_RR_NXT,    CDnsResourceRecord::CreateThis, "NXT"},
    {PVD_CLASS_SERVERDOMAIN, CDnsServerDomainContainment::CreateThis, ""},
    {PVD_CLASS_DOMAINDOMAIN, CDnsDomainDomainContainment::CreateThis,""},
    {PVD_CLASS_STATISTIC, CDnsStatistic::CreateThis,""},
    {PVD_CLASS_DOMAINRESOURCERECORD,
        CDnsDomainResourceRecordContainment::CreateThis,""}

};

int g_cClassDataEntries = sizeof(g_ClassDataArray) / sizeof(CClassData);


SCODE CreateClass(
	const WCHAR* strClassName, 
	CWbemServices* pNamespace, 
	void** ppNewClass)
{
    for(int i =0; i< g_cClassDataEntries; i++)
    {
        if(_wcsicmp(
            strClassName,
            g_ClassDataArray[i].wszClassName) == 0)
        {
            *ppNewClass = (void*) g_ClassDataArray[i].pfConstruct(
                strClassName, 
                pNamespace, 
                g_ClassDataArray[i].szType);
            return WBEM_S_NO_ERROR;
        }
    }

	throw WBEM_E_INVALID_PARAMETER;

	return S_OK;
}

BSTR AllocBstr(const WCHAR* pwsz)
{
    BSTR bstr = SysAllocString(pwsz);
    if (bstr == NULL)
        throw WBEM_E_OUT_OF_MEMORY;
    return bstr;
}

wstring 
CharToWstring(
    LPCSTR lpFromStr, 
    DWORD wLength)
{
	wstring wStr;
	if (wLength == 0)
		return wStr; //L"";

	WCHAR * pwchar = new WCHAR[ sizeof( WCHAR ) * ( wLength + 1 ) ];
    if ( !pwchar )
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

	int rt = MultiByteToWideChar(	
                    CP_ACP,
		            0,
		            lpFromStr,
		            wLength,
		            pwchar,
		            wLength);
	if(rt != 0)
	{
		*(pwchar+wLength)=L'\0';
		wStr = pwchar;
	}

	delete [] pwchar;
	return wStr;
}
int 
CharToWchar(
    LPCSTR lpMultiByteStr, 
    LPWSTR* lppWideCharStr)
{
	int cchMultiByte;
	cchMultiByte = strlen(lpMultiByteStr);
	*lppWideCharStr = (WCHAR*) malloc ((cchMultiByte+1)*sizeof(WCHAR));
    if ( *lppWideCharStr == NULL )
    {
        return 0;
    }
	return  MultiByteToWideChar(  
        CP_ACP,			// code page
        0 ,			
        lpMultiByteStr,		// address of string to map
        -1,					// number of bytes in string
        *lppWideCharStr,		// address of wide-character buffer
        (cchMultiByte+1)*sizeof(WCHAR)        // size of buffer
        );
}


int 
WcharToString(
    LPCWSTR lpWideCharStr, 
    string& str)
{
	char * temp = NULL;
	int rt = WcharToChar(lpWideCharStr, &temp);
	if ( rt != 0)
	{
		str = temp;
	}
	delete [] temp;
	return rt;
}

int 
WcharToChar(
    LPCWSTR lpWideCharStr, 
    LPSTR* lppMultiByteStr)
{
	int cWchar;
	if ( !lpWideCharStr )
		return 0;

	cWchar= wcslen(lpWideCharStr)+1;
	*lppMultiByteStr = ( CHAR * ) new char[ cWchar * sizeof ( CHAR ) ];
    if ( !*lppMultiByteStr )
    {
        throw WBEM_E_OUT_OF_MEMORY;
    }

	return  WideCharToMultiByte(  
        CP_ACP,			// code page
        0,					// character-type options
        lpWideCharStr,		// address of string to map
        -1,					// number of bytes in string
        *lppMultiByteStr,	// address of wide-character buffer
        cWchar*sizeof(CHAR) ,// size of buffer
        NULL,
        NULL
        );
}

wstring 
IpAddressToString(DWORD ip)
{
	char temp[30];
	sprintf(temp, "%d.%d.%d.%d",
			* ( (PUCHAR) &ip + 0 ),
            * ( (PUCHAR) &ip + 1 ),
            * ( (PUCHAR) &ip + 2 ),
            * ( (PUCHAR) &ip + 3 ) );
     
	 return CharToWstring(temp, strlen(temp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\acache.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       acache.cxx

   Abstract:
       This module implements the Allocation cache handler and associated
        objects.

   Author:

       Murali R. Krishnan    ( MuraliK )     12-Sept-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <isatq.hxx>
# include "acache.hxx"
# include "dbgutil.h"

// 
// # of CPUs in machine (for allocation threshold scaling)
// 
DWORD g_cCPU = 0;

//
// specifies the registry location to use for getting the ATQ Configuration
//   (Global overrides)
//
CHAR g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY[] =
 TEXT("System\\CurrentControlSet\\Services\\InetInfo\\Parameters");


//
// Lookaside cleanup interval
//

#define ACACHE_REG_LOOKASIDE_CLEANUP_INTERVAL \
                     TEXT( "LookasideCleanupInterval" )
#define ACACHE_REG_DEFAULT_CLEANUP_INTERVAL              ((15)*(60))

/************************************************************
 *    Inlined Documentation on Alloc-Cache
 *
 * Allocation Cache:
 *    This module is to cache the commonly allocated objects
 *    to serve following goals 
 *      1) we can have maximum reuse of blocks
 *      2) avoid traffic to the process heap manager
 *      3) gather statistics for understanding of usage
 *
 * Details on Allocation Cache:
 *   There is one ALLOC_CACHE_HANDLER (shortly ACH) object per 
 *   object that we decide to cache. The ACH is initialized by
 *   the configuration supplied during its construction. ACH serves
 *   as the main object for allocation/free of the objects it is created
 *   to cache. ACH gathers statistics of various operations and provides
 *   hooks to export the gathered statistics. There is a periodic cleanup
 *   scavenger that frees up long unused blocks thus reducing the working
 *   set of the system.
 *
 *   All ACH objects created are chained and maintained in the global
 *   list of allocation cache handler objects. This global list is used
 *   for enumeration, debugging, and statistics dumps
 *   
 * Allocation cache Configuration:
 * 
 *   Each ACH object is created with the ALLOC_CACHE_CONFIGURATION that
 *   specifies the (concurrency factor, threshold, size) desired.
 *   The concurrency factor ensures that we support the specified level 
 *   of concurrency in allocations. The threshold specifies the number 
 *   of objects that we will maintain (max) in the free-list. When the
 *   threshold is exceeded the freed objects are pushed to the process
 *   pool until the currently active objects fall below the threshold.
 *   In addition, each ACH object also retains a read-only name for the
 *   object allocated - for friendly tracking purposes.
 *
 *   There is also a global configuration parameter that specifies the 
 *   Lookaside cleanup interval. 
 *
 * Allocation and Free:
 *   Allocation allocates one free object from the free-list if any exist.
 *   Otherwise the allocation will result in fetching a new object from
 *   the process heap manager.
 *   A free adds the freed object to the free-list if the # free objects
 *   is less than the threshold specified. Otherwise the object is freed
 *   to the process heap manager.
 *   Statistics are gathered during both allocation and free operations.
 *
 * Statisitcs:
 *   Statistics are gathered during the alloc/free operations throughout
 *   the life-time of the ACH. These statistics are reported via the 
 *   DumpStatsToHtml() exported function. The statistics can also be 
 *   gathered by the NTSD helper function.
 *
 * Scheduled List cleanup:
 *   There is a scheduled work item for the lookaside cleanup interval. 
 *   The callback function walks through the list of ACH items on global
 *   list and takes snapshot of the # allocation calls. On a subsequent
 *   walk-through, if the # allocation calls remains the same (which will
 *   be the case if there is no allocation activity), then, the entire
 *   list of alloced objects is pruned. This pruning reduces the working
 *   set of the process.
 ************************************************************/

/************************************************************
 *    Static Functions of ALLOC_CACHE_HANDLER
 ************************************************************/

CRITICAL_SECTION ALLOC_CACHE_HANDLER::sm_csItems;
LIST_ENTRY       ALLOC_CACHE_HANDLER::sm_lItemsHead;
DWORD            ALLOC_CACHE_HANDLER::sm_dwScheduleCookie;

/* class static */
BOOL
ALLOC_CACHE_HANDLER::Initialize(VOID)
{
    // get the number of processors for this machine
    // do it only for NT Server only (don't scale workstation)
    if ( TsIsNtServer() ) {
        SYSTEM_INFO si;
        GetSystemInfo( &si );
        g_cCPU = si.dwNumberOfProcessors;
    } else {
        g_cCPU = 1;
    }

    // initialize the class statics
    InitializeListHead( &sm_lItemsHead);
    InitializeCriticalSection( &sm_csItems);
    SET_CRITICAL_SECTION_SPIN_COUNT( &sm_csItems, IIS_DEFAULT_CS_SPIN_COUNT);
    return ( TRUE);
} // ALLOC_CACHE_HANDLER::Initialize()


/* class static */
BOOL
ALLOC_CACHE_HANDLER::Cleanup(VOID)
{
    DBG_ASSERT( sm_dwScheduleCookie == 0);

    DBG_ASSERT( IsListEmpty(&sm_lItemsHead));
    DeleteCriticalSection( &sm_csItems);

    return ( TRUE);

} // ALLOC_CACHE_HANDLER::Cleanup()


/* class static */
VOID
ALLOC_CACHE_HANDLER::InsertNewItem( IN ALLOC_CACHE_HANDLER * pach)
{
    EnterCriticalSection( &sm_csItems);

    InsertTailList( &sm_lItemsHead, &pach->m_lItemsEntry);
    LeaveCriticalSection( &sm_csItems);

    return;
} // ALLOC_CACHE_HANDLER::InsertNewItem()



/* class static */
VOID
ALLOC_CACHE_HANDLER::RemoveItem( IN ALLOC_CACHE_HANDLER * pach)
{
    EnterCriticalSection( &sm_csItems);

    RemoveEntryList( &pach->m_lItemsEntry);
    LeaveCriticalSection( &sm_csItems);

    return;
} // ALLOC_CACHE_HANDLER::RemoveItem()



/* class static */
BOOL
ALLOC_CACHE_HANDLER::DumpStatsToHtml(
   OUT CHAR * pchBuffer,
   IN OUT LPDWORD lpcchBuffer )
/*++
  Description:
    This function dumps the stats on all allocation cached objects
     to HTML format for diagnostics

  Arguments:
    pchBuffer - pointer to buffer that will contain the html results
    lpcchBuffer - pointer to DWORD containing the size of buffer on entry
               On return this contains the # of bytes written out to buffer

  Return:
    TRUE for success and FALSE for failure
    Look at GetLastError() for the error code.
--*/
{
    LIST_ENTRY  * pEntry;
    DWORD  iCount, cch;
    DWORD  cbTotalMem = 0;
    BOOL   fRet = TRUE;

    if ( (lpcchBuffer == NULL) ) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    EnterCriticalSection( &sm_csItems);

    if ( 300 < *lpcchBuffer ) {

        // Print the header blob
        cch = wsprintf( pchBuffer,
                        " AllocCacheTable Data <br>"
                        "<TABLE BORDER> <TR> "
                        "<TH> Item Name </TH> "
                        "<TH> Config(concurr, threshold, size) </TH> "
                        "<TH> # Total Items </TH> "
                        "<TH> # Alloc Calls </TH> "
                        "<TH> # Free Calls </TH> "
                        "<TH> # Free Entries </TH> "
                        "<TH> # Total Size (bytes) </TH> "
                        " </TR>"
                        );
    } else {
        cch = 300;
    }

    for ( pEntry = sm_lItemsHead.Flink, iCount = 0;
          pEntry != &sm_lItemsHead;
          pEntry = pEntry->Flink, iCount++
          ) {

        ALLOC_CACHE_HANDLER * pach =
            CONTAINING_RECORD( pEntry,
                               ALLOC_CACHE_HANDLER,
                               m_lItemsEntry
                               );

        cbTotalMem += pach->m_acConfig.cbSize * pach->m_nTotal;

        if ( (cch + 150 + strlen( pach->m_pszName)) < *lpcchBuffer) {
            cch += wsprintf( pchBuffer + cch,
                             " <TR> <TD> [%d] %s </TD> <TD> (%d, %d, %d) </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " </TR>"
                             ,
                             iCount,
                             pach->m_pszName,
                             pach->m_acConfig.nConcurrency,
                             pach->m_acConfig.nThreshold,
                             pach->m_acConfig.cbSize,
                             pach->m_nTotal,
                             pach->m_nAllocCalls,
                             pach->m_nFreeCalls,
                             pach->m_nFreeEntries,
                             pach->m_acConfig.cbSize * pach->m_nTotal
                             );
        } else {
            cch += 150 + strlen( pach->m_pszName);
        }
    } // for

    LeaveCriticalSection( &sm_csItems);

    //
    // dump the final summary
    //
    if ( (cch + 100 ) < *lpcchBuffer) {
        cch += wsprintf( pchBuffer + cch,
                         " <b>"
                         " <TR> </TR>"
                         " <TR> <TD> Total </TD> <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> %4d </TD>"
                         " </TR>"
                         "</b>"
                         " </TABLE>"
                         ,
                         cbTotalMem
                         );
    } else {
        cch += 100;
    }

    if ( *lpcchBuffer < cch ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fRet = FALSE;
    }

    *lpcchBuffer = cch;

    return (fRet);
} // ALLOC_CACHE_HANDLER::DumpStatsToHtml()

extern "C"
BOOL AllocCacheDumpStatsToHtml( OUT CHAR * pch, 
                                IN OUT LPDWORD lpcchBuff)
{
    return ( ALLOC_CACHE_HANDLER::DumpStatsToHtml( pch, lpcchBuff));
} 
    
/* class static */
BOOL
ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval( VOID )
{
    DWORD               dwError;
    DWORD               dwVal = 0;
    HKEY                hkey;

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY,
                            0,
                            KEY_READ,
                            &hkey);

    if ( dwError == NO_ERROR ) {

        //
        // get the lookaside list cleanup period
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ACACHE_REG_LOOKASIDE_CLEANUP_INTERVAL,
                                   ACACHE_REG_DEFAULT_CLEANUP_INTERVAL );

        ATQ_REQUIRE( !RegCloseKey( hkey ) );
    }

    if ( dwVal != 0 )
    {
        sm_dwScheduleCookie =
            ScheduleWorkItem( ALLOC_CACHE_HANDLER::CleanupAllLookasides,
                              NULL,
                              dwVal * 1000,
                              TRUE );

        if ( sm_dwScheduleCookie == 0 )
        {
            return FALSE;
        }
    }

    return TRUE;
} // ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval()


/* class static */
BOOL
ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval( VOID )
{
    BOOL fReturn = TRUE;
    if ( sm_dwScheduleCookie )
    {
        fReturn = RemoveWorkItem( sm_dwScheduleCookie );
        if (fReturn) {
            sm_dwScheduleCookie = 0;
        }
    }

    return ( fReturn);
} // ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval()



/* class static */
VOID
ALLOC_CACHE_HANDLER::CleanupAllLookasides(
    IN PVOID            pvContext
)
{
    LIST_ENTRY *        pEntry;

    EnterCriticalSection( &sm_csItems);

    for ( pEntry = sm_lItemsHead.Flink;
          pEntry != &sm_lItemsHead;
          pEntry = pEntry->Flink )
    {
        ALLOC_CACHE_HANDLER * pach =
            CONTAINING_RECORD( pEntry,
                               ALLOC_CACHE_HANDLER,
                               m_lItemsEntry
                               );

        IF_DEBUG( ALLOC_CACHE) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "Cleaning lookaside list for '%s' handler\n",
                         pach->m_pszName ));
        }

        pach->CleanupLookaside( FALSE );
    }

    LeaveCriticalSection( &sm_csItems);
} // ALLOC_CACHE_HANDLER::CleanupAllLookasides()




/************************************************************
 *    Member Functions of ALLOC_CACHE_HANDLER
 ************************************************************/

ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER(
    IN LPCSTR pszName,
    IN const ALLOC_CACHE_CONFIGURATION * pacConfig
    )
    : m_fValid ( FALSE),
      m_nTotal       (0),
      m_nAllocCalls  (0),
      m_nFreeCalls   (0),
      m_nFreeEntries (0),
      m_pszName      (pszName),
      m_nLastAllocCount(0)
{
    DBG_ASSERT( NULL != pacConfig );
    m_acConfig = *pacConfig;

    if ( pacConfig->nThreshold == INFINITE) {
        // this will be compared against a signed value. So be careful.
        m_acConfig.nThreshold = 0x7FFFFFFF;
    } else {
        // scale by the number of processors on MP machines
        m_acConfig.nThreshold *= g_cCPU;
    }

    InitializeCriticalSection( & m_csLock);
    SET_CRITICAL_SECTION_SPIN_COUNT( &m_csLock, IIS_DEFAULT_CS_SPIN_COUNT);

    m_lHead.Next = NULL;

    ALLOC_CACHE_HANDLER::InsertNewItem( this);
    m_fValid = TRUE;
    return;
} // ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER()



ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER(VOID)
{
    if ( m_fValid) {

        CleanupLookaside( TRUE );

        DeleteCriticalSection( & m_csLock);
        ALLOC_CACHE_HANDLER::RemoveItem( this);
    }

    DBG_ASSERT( 0 == m_nTotal );
    DBG_ASSERT( m_lHead.Next == NULL);
    return;
} // ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER()



VOID
ALLOC_CACHE_HANDLER::CleanupLookaside(
    IN BOOL             fForceCleanup
)
/*++
  Description:
    This function cleans up the lookaside list by removing excess storage space
    used by the objects allocated by this instance. This function is
    used by the periodic scavenging operation as well as for final cleanup.

  Arguments:
    fForceCleanup - forces a cleanup operation always.

  Returns:
     None
--*/
{
    if ( !fForceCleanup )
    {
        //
        // We are called for the regular scavenging operation
        // Take a snapshot of the # allocation calls so that
        //  we may cleanup space when services are idle.
        //

        IF_DEBUG( ALLOC_CACHE) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AllocCalls = %ld, LastAllocCount = %ld\n",
                         m_nAllocCalls,
                         m_nLastAllocCount ));
        }

        if ( m_nAllocCalls != m_nLastAllocCount )
        {
            InterlockedExchange( &m_nLastAllocCount,
                                 m_nAllocCalls );
            return;
        }
    }

    SINGLE_LIST_ENTRY listHeadCopy;

    //
    // make a copy of the first element in the list inside the lock
    // Free the entire chain outside the locked section.
    // Otherwise on a busy system the threads will be waiting for 
    //  this thread to complete
    //

    Lock();
    listHeadCopy.Next = m_lHead.Next;

    //
    // we are about to cleanup all entries -> so set state back properly.
    //
    m_lHead.Next      = NULL;
    m_nFreeEntries    = 0; // no more free-entries available
    Unlock();

    //
    // free up all the entries in the list
    //

    PSINGLE_LIST_ENTRY pl;
    pl = PopEntryList( &listHeadCopy);
    while ( pl != NULL) {

        InterlockedDecrement( &m_nTotal);
        ::LocalFree( pl);
        pl = PopEntryList( &listHeadCopy);
    } // for

    DBG_ASSERT( listHeadCopy.Next == NULL);

    return;
} // ALLOC_CACHE_HANDLER::CleanupLookaside()



LPVOID
ALLOC_CACHE_HANDLER::Alloc( VOID )
{
    LPVOID pv = NULL;

    if ( m_nFreeEntries > 0) {

        // 
        // There are free entries available - allocate from the free pool
        //

        Lock();

        // Check again if the free entry is available.
        if ( m_nFreeEntries > 0) {
            pv = (LPVOID )PopEntryList( & m_lHead);  // get the real object
            m_nFreeEntries--;
        }
        Unlock();
    }

    if ( NULL == pv) {

        //
        // No free entry. Need to alloc a new object.
        //

        pv = (LPVOID ) LocalAlloc( LPTR, m_acConfig.cbSize);

        if ( NULL != pv) {

            // initialize the list head properly and extract exact object.
            ((PSINGLE_LIST_ENTRY ) pv)->Next = NULL;

            // pv = (LPVOID ) (((PSINGLE_LIST_ENTRY ) pv));

            // update counters
            InterlockedIncrement( &m_nTotal);
        }
    }

    if ( NULL != pv ) { InterlockedIncrement( &m_nAllocCalls); }

    return ( pv);
} // ALLOC_CACHE_HANDLER::Alloc()



BOOL
ALLOC_CACHE_HANDLER::Free( LPVOID pv)
{
    // Assume that this is allocated using the Alloc() function
    DBG_ASSERT( NULL != pv);

    // store the items in the alloc cache.

    if ( m_nFreeEntries >= m_acConfig.nThreshold) {

        //
        // threshold for free entries is exceeded. free the object to 
        //  process pool
        //

        ::LocalFree( pv);
        InterlockedDecrement( &m_nTotal);
    } else {

        //
        // Store the given pointer in the single linear list
        //

        Lock();
        PushEntryList( &m_lHead,  (((PSINGLE_LIST_ENTRY ) pv)));
        m_nFreeEntries++;
        Unlock();
    }

    InterlockedIncrement( &m_nFreeCalls);

    return ( TRUE);
} // ALLOC_CACHE_HANDLER::Free()




VOID
ALLOC_CACHE_HANDLER::Print( VOID)
{
    CHAR  rgchBuffer[8192];
    DWORD cchBuffer = sizeof(rgchBuffer);

    DBG_REQUIRE( IpPrint( rgchBuffer, &cchBuffer));

    DBGDUMP(( DBG_CONTEXT, rgchBuffer));

    return;
} // ALLOC_CACHE_HANDLER::Print()



BOOL
ALLOC_CACHE_HANDLER::IpPrint( OUT CHAR * pchBuffer, IN OUT LPDWORD pcchSize)
{
    DWORD cchUsed;

    cchUsed = wsprintfA( pchBuffer,
                         "[%d]ALLOC_CACHE_HANDLER[%08x]. Config: "
                         " ObjSize = %d. Concurrency=%d. Thres=%d.\n"
                         " TotalObjs = %d. Calls: Alloc(%d), Free(%d)."
                         " FreeEntries = %d.\n"
                         ,
                         GetCurrentThreadId(),
                         this,
                         m_acConfig.cbSize, m_acConfig.nConcurrency,
                         m_acConfig.nThreshold,
                         m_nTotal, m_nAllocCalls, m_nFreeCalls, m_nFreeEntries
                         );
    Lock();

    // NYI: Print the list of individual pointers
    Unlock();

    DBG_ASSERT( *pcchSize > cchUsed);
    *pcchSize = cchUsed;

    return (TRUE);
} // ALLOC_CACHE_HANDLER::IpPrint()



VOID
ALLOC_CACHE_HANDLER::QueryStats( IN ALLOC_CACHE_STATISTICS * pacStats )
{
    DBG_ASSERT( pacStats != NULL );

    pacStats->acConfig      = m_acConfig;
    pacStats->nTotal        = m_nTotal;
    pacStats->nAllocCalls   = m_nAllocCalls;
    pacStats->nFreeCalls    = m_nFreeCalls;
    pacStats->nFreeEntries  = m_nFreeEntries;

    return;
} // ALLOC_CACHE_HANDLER::QueryStats()


//
// Global functions
//


DWORD
I_AtqReadRegDword(
   IN HKEY     hkey,
   IN LPCSTR   pszValueName,
   IN DWORD    dwDefaultValue )
/*++

    NAME:       I_AtqReadRegDword

    SYNOPSIS:   Reads a DWORD value from the registry.

    ENTRY:      hkey - Openned registry key to read

                pszValueName - The name of the value.

                dwDefaultValue - The default value to use if the
                    value cannot be read.

    RETURNS     DWORD - The value from the registry, or dwDefaultValue.

--*/
{
    DWORD  err;
    DWORD  dwBuffer;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL ) {
        err = RegQueryValueExA( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) ) {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;

} // I_AtqReadRegDword()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\atqdgram.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      atqmain.cxx

   Abstract:
      This module implements entry points for ATQ - Asynchronous Thread Queue.

   Author:

       Murali R. Krishnan    ( MuraliK )     8-Apr-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

--*/

#include "isatq.hxx"

typedef GUID UUID;

extern "C" {

#include <ntdsa.h>

};

VOID
AtqGetDatagramAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrRemote,
    OUT INT *        pcbsockaddrRemote
    )
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    ATQ_ASSERT( g_fUseAcceptEx);
    ATQ_ASSERT( pContext->pEndpoint);

    *pSock   = (SOCKET) pContext->hAsyncIO;
    *pEndpointContext = pContext->pEndpoint->Context;
    *ppvBuff = pContext->pvBuff;

    //
    //  The buffer not only receives the initial received data, it also
    //  gets the sock addrs, which must be at least sockaddr_in + 16 bytes
    //  large
    //

    *ppsockaddrRemote = (PSOCKADDR) pContext->AddressInformation;
    *pcbsockaddrRemote = pContext->AddressLength;

    return;
} // AtqGetDatagramAddrs()


DWORD_PTR
AtqContextGetInfo(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo
    )
/*++

Routine Description:

    Sets various bits of information for this context

Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    DWORD_PTR dwOldVal = 0;

    ATQ_ASSERT( pContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

    if ( pContext && pContext->Signature == ATQ_CONTEXT_SIGNATURE )
    {
        switch ( atqInfo ) {

        case ATQ_INFO_TIMEOUT:
            dwOldVal = pContext->TimeOut;
            break;

        case ATQ_INFO_RESUME_IO:

            //
            // set back the max timeout from pContext->TimeOut
            // This will ensure that timeout processing can go on
            //   peacefully.
            //

            {
                dwOldVal = pContext->NextTimeout;
            }
            break;

        case ATQ_INFO_COMPLETION:

            dwOldVal = (DWORD_PTR) pContext->pfnCompletion;
            break;

        case ATQ_INFO_COMPLETION_CONTEXT:

            dwOldVal = (DWORD_PTR) pContext->ClientContext;
            break;

        default:
            ATQ_ASSERT( FALSE );
        }
    }

    return dwOldVal;

} // AtqContextGetInfo()



BOOL
AtqWriteDatagramSocket(
    IN PATQ_CONTEXT  patqContext,
    IN LPWSABUF     pwsaBuffers,
    IN DWORD        dwBufferCount,
    IN OVERLAPPED *  lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

    I_SetNextTimeout(pContext);

    // count the number of bytes
    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf <= (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    fRes = ( (WSASendTo( (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       &cbWritten,
                       0,               // no flags
                       (PSOCKADDR) pContext->AddressInformation,
                       pContext->AddressLength,
                       lpo,
                       NULL             // no completion routine
                       ) == 0) ||
             (WSAGetLastError() == WSA_IO_PENDING));
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); }

    return fRes;

} // AtqWriteDatagramSocket()



VOID
ATQ_CONTEXT::InitDatagramState(
            VOID
            )
{

    fDatagramContext= IS_DATAGRAM_CONTEXT(this);

    if (fDatagramContext) {

        //
        // The address information is stored in the buffer after
        // the data. Store a pointer to it as well as its
        // length
        //

        AddressLength = 2*MIN_SOCKADDR_SIZE;
        AddressInformation = (PVOID) ((PUCHAR) pvBuff + pEndpoint->InitialRecvSize);
        NextTimeout = ATQ_INFINITE;
    }

    return;
} // ATQ_CONTEXT::InitDatagramState


#define I_SetNextTimeout2( _c, _t ) {                               \
    (_c)->NextTimeout = AtqGetCurrentTick() + (_t);                 \
    if ( (_c)->NextTimeout < (_c)->ContextList->LatestTimeout ) {   \
        (_c)->ContextList->LatestTimeout = (_c)->NextTimeout;       \
    }                                                               \
}


DWORD_PTR
AtqContextSetInfo2(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo,
    DWORD_PTR              Data
    )
/*++

Routine Description:

    Sets various bits of information for this context

Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    PATQ_CONT   pContext = (PATQ_CONT) patqContext;
    DWORD_PTR   dwOldVal = 0;
    DWORD       timeout;

    ATQ_ASSERT( pContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

    if ( pContext && pContext->Signature == ATQ_CONTEXT_SIGNATURE ) {
        switch ( atqInfo ) {

        case ATQ_INFO_NEXT_TIMEOUT:
            dwOldVal = pContext->NextTimeout;
            timeout = CanonTimeout( (DWORD)Data );
            I_SetNextTimeout2( pContext, timeout );
            break;

        default:
            ATQ_ASSERT( FALSE );
        }
    }

    return dwOldVal;

} // AtqContextSetInfo2



VOID
AtqUpdatePerfStats(
    IN ATQ_CONSUMER_TYPE        ConsumerType,
    IN DWORD                    dwOperation,
    IN DWORD                    dwVal
    )
/*++

Routine Description:

    Updates DS Perfmon counters.

Arguments:

    ConsumerType - Which statistic to update.
    dwOperation  - What to do to statistic
                   FLAG_COUNTER_INCREMENT - increment the value - INC()
                   FLAG_COUNTER_DECREMENT - decrement the value - DEC()
                   FLAG_COUNTER_SET - set the value directly - ISET()

Return Value:

    None

--*/
{
    //
    // Make sure that g_pfnUpdatePerfCountersCallback has been set.
    //
    if (g_pfnUpdatePerfCounterCallback == NULL) {
        return;
    }

    switch ( ConsumerType ) {

        case AtqConsumerLDAP:
            g_pfnUpdatePerfCounterCallback(DSSTAT_ATQTHREADSLDAP, dwOperation, dwVal);
            break;

        case AtqConsumerOther:
            g_pfnUpdatePerfCounterCallback(DSSTAT_ATQTHREADSOTHER, dwOperation, dwVal);
            break;

        case AtqConsumerAtq:
            g_pfnUpdatePerfCounterCallback(DSSTAT_ATQTHREADSTOTAL, dwOperation, dwVal);
            break;

        default:
            ATQ_ASSERT( FALSE );
    }
} // AtqUpdatePerfStats


DWORD_PTR
AtqEndpointSetInfo2(
    IN PVOID                Endpoint,
    IN ATQ_ENDPOINT_INFO    EndpointInfo,
    IN DWORD_PTR            dwInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    Endpoint    - endpoint to set info on
    EndpointInfo - type of info to set
    dwInfo       - info to set

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD_PTR     dwVal = 0;

    switch ( EndpointInfo ) {

        case EndpointInfoConsumerType:
            dwVal = pEndpoint->ConsumerType;
            pEndpoint->ConsumerType = (ATQ_CONSUMER_TYPE)dwInfo;
            break;

      default:
        ATQ_ASSERT( FALSE );
    }
    return dwVal;
} // AtqEndpointSetInfo2()


DWORD_PTR
AtqSetInfo2(
    IN ATQ_INFO         atqInfo,
    IN DWORD_PTR        Data
    )
/*++

Routine Description:

    Sets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    DWORD_PTR dwOldVal = 0;

    switch ( atqInfo ) {

      case AtqUpdatePerfCounterCallback:

        dwOldVal = (DWORD_PTR) g_pfnUpdatePerfCounterCallback;
        g_pfnUpdatePerfCounterCallback =  (ATQ_UPDATE_PERF_CALLBACK ) Data;
        //
        // Now that we can communicate perf stats, update them to
        // where they are now.
        //
        AtqUpdatePerfStats(AtqConsumerAtq, FLAG_COUNTER_SET, g_cThreads);
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    }

    return dwOldVal;
} // AtqSetInfo2()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\atqendp.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      atqendp.cxx

   Abstract:
      This module implements ATQ endpoints

   Author:

       Johnson Apacible    (JohnsonA)     13-May-1996

   Environment:

       User Mode -- Win32

--*/

#include "isatq.hxx"

//
// Forward declarations
//

BOOL
I_CreateListenSocket(
    IN PATQ_ENDPOINT Endpoint
    );

BOOL
I_CloseListenSocket(
    IN PATQ_ENDPOINT Endpoint
    );

BOOL
StartListenThread(
    IN PATQ_ENDPOINT Endpoint
    );

extern DWORD g_cCPU;

# define ATQ_MIN_ACCEPTEX_TIMEOUT    (120)  // 2 minutes = 120 seconds

#define ATQ_CLOSE_ENDPOINT_SLEEP_TIME (200) // 200ms = 1/5 second
#define ATQ_CLOSE_ENDPOINT_TIMEOUT    ((100 * 1000) / ATQ_CLOSE_ENDPOINT_SLEEP_TIME)
                                            // 100 seconds

#define ATQ_MIN_ACCEPTEX_SOCKETS         (5)
#define ATQ_MAX_ACCEPTEX_SOCKETS         (150) // just seems like a lot.


PVOID
AtqCreateEndpoint(
    IN PATQ_ENDPOINT_CONFIGURATION Configuration,
    IN PVOID EndpointContext
    )

/*++

Routine Description:

    Creates a server instance.

Arguments:

    Context - Context value returned

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

{

    DWORD timeout = Configuration->AcceptExTimeout;
    PATQ_ENDPOINT endpoint;
    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"AtqCreateEndpoint entered\n"));
    }

    //
    // Allocate list
    //

    endpoint = (PATQ_ENDPOINT)LocalAlloc(0,sizeof(ATQ_ENDPOINT));
    if ( endpoint == NULL ) {
        ATQ_PRINTF(( DBG_CONTEXT,"Unable to allocate ATQ Endpoint\n"));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error;
    }

    //
    // Initialize
    //

    ZeroMemory(endpoint,sizeof(ATQ_ENDPOINT));
    endpoint->Signature = ATQ_ENDPOINT_SIGNATURE;
    endpoint->m_refCount = 1;
    SET_BLOCK_STATE(endpoint, AtqStateActive);

    endpoint->EnableBw = FALSE;
    endpoint->ConnectCompletion = Configuration->pfnConnect;
    endpoint->ConnectExCompletion = Configuration->pfnConnectEx;
    endpoint->IoCompletion = Configuration->pfnIoCompletion;
    endpoint->fDatagram = Configuration->fDatagram;
    endpoint->ListenSocket = INVALID_SOCKET;
    endpoint->pListenAtqContext = NULL;
    endpoint->nAvailDuringTimeOut = 0;
    endpoint->nSocketsAvail = 0;
    endpoint->Context = EndpointContext;
    endpoint->fExclusive = Configuration->fLockDownPort;
    endpoint->fReverseQueuing = Configuration->fReverseQueuing;
    endpoint->cbDatagramWSBufSize = Configuration->cbDatagramWSBufSize;
    
    endpoint->InitialRecvSize = Configuration->cbAcceptExRecvBuffer;

    // we need to maintain at least 5 outstanding accept ex sockets
    // for our auto-tune algo to work.
    endpoint->nAcceptExOutstanding = 
        min((g_cCPU * (max(ATQ_MIN_ACCEPTEX_SOCKETS, Configuration->nAcceptExOutstanding))),
             ATQ_MAX_ACCEPTEX_SOCKETS);

    endpoint->fAddingSockets = FALSE;

    //
    // Check and set the timeout to be atleast minimum timeout for AcceptEx
    //
    if ( timeout <= ATQ_MIN_ACCEPTEX_TIMEOUT)  {
        timeout = ATQ_MIN_ACCEPTEX_TIMEOUT;
    }

    endpoint->AcceptExTimeout = CanonTimeout( timeout);

    endpoint->Port = Configuration->ListenPort;
    endpoint->IpAddress = Configuration->IpAddress;
    endpoint->ConsumerType = AtqConsumerOther;

    //endpoint->ContextList.Initialize( );

#if DBG
    endpoint->RefTraceLog = CreateRefTraceLog( TRACE_LOG_SIZE, 0 );
#endif

#if 0
    ATQ_PRINTF(( DBG_CONTEXT,"port %d nAX %d nAT %d nLB %d\n",
        endpoint->Port, endpoint->nAcceptExOutstanding,
        endpoint->AcceptExTimeout, g_cListenBacklog));
#endif

    //
    // Create the socket
    //

    if (!I_CreateListenSocket(endpoint) ) {

        goto error;
    }

    return((PVOID)endpoint);

error:

    if ( endpoint != NULL ) {
#if DBG
        if( endpoint->RefTraceLog != NULL ) {
            DestroyRefTraceLog( endpoint->RefTraceLog );
        }
#endif
        LocalFree( endpoint );
    }

    return(NULL);

} // AtqCreateEndpoint



BOOL
AtqStartEndpoint(
    IN PVOID Endpoint
    )
{
    BOOL useAcceptEx;
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    BOOL fReturn;

    ATQ_ASSERT(IS_BLOCK_ACTIVE(pEndpoint));

    pEndpoint->UseAcceptEx = useAcceptEx =
        ((g_fUseAcceptEx) && (pEndpoint->ConnectExCompletion != NULL)) ||
        pEndpoint->fDatagram;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"AtqStartEndpoint called. UseAcceptEx[%d]\n",
            useAcceptEx));
    }

    //
    // if AcceptEx is supported, create AcceptEx contexts
    //

    if ( useAcceptEx ) {

        //
        // Add AcceptEx sockets
        //

        fReturn = pEndpoint->ActivateEndpoint();

        if ( !fReturn ) {
            DBGPRINTF(( DBG_CONTEXT,"Error %d in %08x::ActivateEndpoint()\n",
                GetLastError(), pEndpoint));
        }

    } else {

        //
        // We need to start a listen thread
        //

        fReturn = StartListenThread( pEndpoint );

        if ( !fReturn ) {
            DBGPRINTF(( DBG_CONTEXT,"Error %d in %08x::StartListenThread()\n",
                GetLastError(), pEndpoint));
        }
    }

    return (fReturn);

} // AtqStartEndpoint



DWORD_PTR
AtqEndpointGetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ endpoint

Arguments:

    Endpoint    - endpoint to get data from
    EndpointInfo - type of info to get

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD_PTR     dwVal = 0;

    switch ( EndpointInfo ) {

      case EndpointInfoListenPort:
        dwVal = pEndpoint->Port;
        break;

      case EndpointInfoListenSocket:
        dwVal = pEndpoint->ListenSocket;
        break;

      default:
        ATQ_ASSERT( FALSE );
    }

    return dwVal;
} // AtqEndpointGetInfo()



DWORD_PTR
AtqEndpointSetInfo(
    IN PVOID                Endpoint,
    IN ATQ_ENDPOINT_INFO    EndpointInfo,
    IN DWORD_PTR            dwInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    Endpoint    - endpoint to set info on
    EndpointInfo - type of info to set
    dwInfo       - info to set

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD_PTR     dwVal = 0;

    switch ( EndpointInfo ) {

        case EndpointInfoAcceptExOutstanding:

        dwVal = pEndpoint->nAcceptExOutstanding;

        if ( dwVal < dwInfo ) {

            //
            // Make up for increased limit
            //

            if ( (DWORD ) pEndpoint->nSocketsAvail < (dwInfo >> 2) ) {
                (VOID ) I_AtqPrepareAcceptExSockets(
                                        pEndpoint,
                                        ((DWORD)dwInfo>>2) - pEndpoint->nSocketsAvail
                                        );
            }
            pEndpoint->nAcceptExOutstanding = (DWORD)dwInfo;
        }
        break;

      default:
        ATQ_ASSERT( FALSE );
    }

    return dwVal;
} // AtqEndpointSetInfo()




BOOL
AtqStopEndpoint(
    IN PVOID     Endpoint
    )
/*++

Routine Description:

    Stops the endpoint - marks the Endpoint as to be shutdown and closes
    the listening socket -> forcing new connections to stop for this endpoint

Arguments:

    Endpoint - endpoint to be stopped

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD  nClosed;

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqStopEndpoint( %08x)\n", pEndpoint));
    }

    //
    //  Find the listen socket info
    //

    AcquireLock( &AtqEndpointLock );

    if ( !IS_BLOCK_ACTIVE(pEndpoint) ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Attempt to Stop Endpoint (%08x) more than once",
                     pEndpoint
                     ));
        ReleaseLock( &AtqEndpointLock );
        return(FALSE);
    }

    //
    //  Mark the listen info as no longer accepting connections
    //

    SET_BLOCK_STATE(pEndpoint, AtqStateClosed);

    //
    //  Remove the entry from the end points list
    //

    RemoveEntryList(&pEndpoint->ListEntry);
    ReleaseLock( &AtqEndpointLock );

    //
    // Close the listen socket which forces the cleanup for all the
    //  pending LISTEN ATQ contexts. We do this early on so that
    //  we can prevent any new entrant connections into the processing code.
    //

    I_CloseListenSocket( pEndpoint );

    //
    // Forcibly close all the pending LISTEN contexts tied to this endpoint
    //

    nClosed = pEndpoint->CloseAtqContexts( TRUE);

    DBGPRINTF(( DBG_CONTEXT,
                "ATQ_ENDPOINT(%08x)::Closed %d pending Listen sockets\n",
                pEndpoint, nClosed));

    //
    // if this is a non-acceptex socket, wait for the listen thread to die
    //

    if ( !pEndpoint->UseAcceptEx ) {
        WaitForSingleObject(pEndpoint->hListenThread, 10*1000);
    }

    return ( TRUE);

} // AtqStopEndpoint()


BOOL
AtqCloseEndpoint(
    IN PVOID     Endpoint
    )
/*++

Routine Description:

    Closes the endpoint - it forcefully fress up all references to the
    endpoint (held by ATQ Contexts) by shutting down the ATQ contexts.
    In the course of this operation if some context does not go away, this
    code will end up looping forever!

    Note: Should be called *after* AtqStopEndpoint()

Arguments:

    Endpoint - endpoint to be stopped

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD  nClosed;
    DWORD i;

    ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );


    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqCloseEndpoint( %08x)\n", pEndpoint));
    }

    if ( pEndpoint->State != AtqStateClosed) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Attempt to Close Endpoint (%08x) when it is "
                     " not stopped yet!\n'",
                     pEndpoint
                     ));
        return(FALSE);
    }

    //
    // wait for all the contexts for this endpoint to go away
    // or for about two minutes
    //

    i = 0;
    while (( pEndpoint->m_refCount > 1) && (i < ATQ_CLOSE_ENDPOINT_TIMEOUT)) {

        ATQ_PRINTF(( DBG_CONTEXT, " Endpoint(%08x) has %d refs\n",
                     pEndpoint, pEndpoint->m_refCount));

        //
        // Forcibly close all the contexts tied to this endpoint again!
        // Sometimes for some random reasons ATQ contexts get left out
        //  during the first clean we did above. In such case it is important
        //  to retry again
        // THIS IS UGLY. But if we did not do this then the Endpoint
        //  structure might get freed => ATQ contexts will be hanging on to
        //  dead ATQ endpoint
        //

        nClosed = pEndpoint->CloseAtqContexts();

        DBGPRINTF(( DBG_CONTEXT, " ATQ_ENDPOINT(%08x)::Closed %d sockets\n",
                    pEndpoint, nClosed));

        //
        // NYI: I need to auto-tune this sleep function
        //
        Sleep( ATQ_CLOSE_ENDPOINT_SLEEP_TIME); // sleep and check again.

#if DBG
        //
        // loop forever for checked builds
        //
#else
        //
        // loop until timeout for retail
        //
        i++;
#endif

        // wake up and check again.
    } // while (busy wait)

    //
    //  Undo the reference for being on the listen info list.
    //    decr final ref count => the endpoint will be cleaned up & freed
    //
    //  If we timed out just leak the endpoints!
    //

    if ( pEndpoint->m_refCount == 1 ) {
        pEndpoint->Dereference();

        return TRUE;
    } else {
        return FALSE;
    }

} // AtqCloseEndpoint()



BOOL
AtqStopAndCloseEndpoint(
    IN PVOID                    Endpoint,
    IN LPTHREAD_START_ROUTINE   lpCompletion,
    IN PVOID                    lpCompletionContext
    )
/*++

Routine Description:

    Stops the endpoint and closes it after forcing close of
    associated ATQ contexts.

Arguments:

    Endpoint - endpoint to shutdown.
    lpCompletion - routine to be called when endpoint is completely shutdown.
    lpCompletionContext - Context to be returned with the routine

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    BOOL fReturn;

    //
    // Warn all the callers of this to be deprecated API and pray that
    // they will all switch over
    //
    OutputDebugStringA( "\n-----------------------------------------------\n");
    OutputDebugStringA( " AtqStopAndCloseEndpoint() should NOT be called\n");
    OutputDebugStringA( "         Call 1) AtqStopEndpoint()  and \n");
    OutputDebugStringA( "              2) AtqCloseEndpoint() instead\n");
    OutputDebugStringA( "   For Now, this call will simulate 1 & 2\n");
    OutputDebugStringA( "-----------------------------------------------\n");


    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqStopAndCloseEndpoint( %08x)\n", pEndpoint));
    }

    fReturn = AtqStopEndpoint( Endpoint);

    if ( fReturn) {

        //
        // Call any custom shutdown function
        // NYI: Too Bad the Endpoint object is not a base class object
        //

        if ( lpCompletion != NULL ) {
            pEndpoint->ShutdownCallback = lpCompletion;
            pEndpoint->ShutdownCallbackContext = lpCompletionContext;
        }

        //
        // Now that the Endpoint is stopped and callback functions are called,
        //  Let us call the AtqCloseEndpoint() to cleanup the endpoint itself.
        //
        fReturn = AtqCloseEndpoint( Endpoint);
    }

    return (fReturn);

} // AtqStopAndCloseEndpoint()



BOOL
ATQ_ENDPOINT::ActivateEndpoint( VOID)
/*++

Routine Description:


    This function creates the initial listening socket & ATQ context for given
    endpoint. It also adds initial set of AcceptEx Sockets to the ATQ listening
    pool (if we are using the AcceptEx())

Arguments:
    None

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    PATQ_CONT   patqContext = NULL;
    BOOL        fReturn;
    DWORD       cInitial = this->nAcceptExOutstanding;

    //
    //  Add the listen socket
    //
    DBG_ASSERT( this->pListenAtqContext == NULL);

    fReturn =
        I_AtqAddListenEndpointToPort(
                                     (PATQ_CONT*)&this->pListenAtqContext,
                                     this
                                     );

    if ( !fReturn) {

        if ( this->pListenAtqContext ) {
            AtqFreeContext( this->pListenAtqContext, FALSE);
            this->pListenAtqContext = NULL;
        }

        return FALSE;
    }

    cInitial = max(cInitial, 1);

    if ( !TsIsNtServer( ) ) {

        //
        // Limit what a workstation can specify
        //

        cInitial = min(cInitial, ATQ_MIN_CTX_INC);
        this->nAcceptExOutstanding = cInitial;

    }

    //
    // start with 1/4 of the intended
    //

    cInitial = max( cInitial >> 2, 1);

    //
    //  Now add the acceptex sockets for this ListenInfo object
    //

    return(I_AtqPrepareAcceptExSockets(this, cInitial));

} // ATQ_ENDPOINT::ActivateEndpoint()



DWORD
ATQ_ENDPOINT::CloseAtqContexts( IN BOOL fPendingOnly)
/*++
  Description:
    This function searches for all ATQ contexts associated
     with the given endpoint and forcibly closes them all.

  Arguments:
    fPendingOnly - close only the pending sockets

  Returns:
    DWORD containing the number of ATQ contexts closed.
--*/
{
    DWORD  nClosed = 0;
    DWORD  i;
    PLIST_ENTRY   pEntry;
    PATQ_CONT     pContext;

    //
    //  Force a close on all the connected sockets so that all the holders
    //   and use of such contexts will bail out of this endpoint entirely.
    // NYI: We need a way to tag on all these lists on per-endpoint basis
    //

    for ( i = 0; i < g_dwNumContextLists; i++) {

        PLIST_ENTRY pListHead;

        AtqActiveContextList[i].Lock();

        //
        // Hard close sockets in the pending list
        //

        pListHead = &AtqActiveContextList[i].PendingAcceptExListHead;
        for ( pEntry = pListHead->Flink;
             pEntry != pListHead;
             pEntry  = pEntry->Flink ) {

            pContext = CONTAINING_RECORD( pEntry, ATQ_CONTEXT, m_leTimeout );

            ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

            if ( (pContext->pEndpoint == this) &&
                 (pContext->IsState( ACS_SOCK_CONNECTED) ||
                  pContext->IsState( ACS_SOCK_LISTENING)
                  ) &&
                 (pContext->hAsyncIO  != NULL) ) {

                nClosed++;
                pContext->HardCloseSocket();
            }
        } // for items in pending list

        if ( !fPendingOnly) {
            //
            // Hard close sockets in the active list
            // Active list includes sockets in ACS_SOCK_CLOSED state
            //  that ought to be freed up, because we could have reached
            //  this through the optimizations for TransmitFile()
            //

            pListHead = &AtqActiveContextList[i].ActiveListHead;
            for ( pEntry = pListHead->Flink;
                  pEntry != pListHead;
                  pEntry  = pEntry->Flink ) {

                pContext = CONTAINING_RECORD( pEntry, ATQ_CONTEXT,
                                              m_leTimeout );

                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

                if ( (pContext->pEndpoint == this)  &&
                     (pContext->IsState( ACS_SOCK_CONNECTED) ||
                      pContext->IsState( ACS_SOCK_LISTENING) ||
                      pContext->IsState( ACS_SOCK_CLOSED) ||
                      pContext->IsState( ACS_SOCK_UNCONNECTED)
                      ) &&
                     (pContext->hAsyncIO  != NULL) ) {

                    nClosed++;
                    pContext->HardCloseSocket();
                }
            } // for items in active list
        } // if (! fPendingOnly)

        AtqActiveContextList[i].Unlock();

    } // for

    return ( nClosed);

} // ATQ_ENDPOINT::CloseAtqContexts()


/************************************************************
 * Internal Functions
 ************************************************************/


BOOL
I_CreateListenSocket(
    IN PATQ_ENDPOINT pEndpoint
    )
/*++

    Creates a socket for listening to connections on given address.

    Arguments:

       lpSockAddress    pointer to local socket address structure used to bind
                           the given connection.
       lenSockAddress   length of the socket address structure.
       socketType       integer containing the type of the socket ( stream )
       socketProtocol   protocol to be used for the socket.
       nBackLog         Maximum length to which a queue of pending connections
                           may grow.

    Returns:
       NO_ERROR on success; otherwise returns Sockets error code.

--*/
{
    INT serr;
    SOCKET  sNew;
    SOCKADDR_IN inAddr;
    PSOCKADDR addr;
    INT addrLength;
    PLIST_ENTRY listEntry;
    PATQ_ENDPOINT scanEndpoint;
    DWORD     cbOut;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"I_CreateListenEndpoint called. \n"));
    }

    //
    // Create a new socket
    //

#if WINSOCK11
    sNew =  socket(
                AF_INET,
                SOCK_STREAM,
                IPPROTO_TCP
                );
#else
    sNew = WSASocket(
                  AF_INET,
                  pEndpoint->fDatagram ? SOCK_DGRAM : SOCK_STREAM,
                  pEndpoint->fDatagram ? IPPROTO_UDP: IPPROTO_TCP,
                  NULL,  // protocol info
                  0,     // Group ID = 0 => no constraints
                  WSA_FLAG_OVERLAPPED    // completion port notifications
                  );
# endif // WINSOCK11

    if ( sNew == INVALID_SOCKET ) {
        serr = WSAGetLastError();
        ATQ_PRINTF(( DBG_CONTEXT,
                    "Error %d in socket( %d, %d, %d)\n",
                    serr,
                    AF_INET,
                    SOCK_STREAM,
                    IPPROTO_TCP
                    ));

        goto cleanup;
    }

    //
    // Set EXCLUSIVE use if needed
    //

    if ( pEndpoint->fExclusive ) {
        ATQ_PRINTF(( DBG_CONTEXT,
                    " Setting %s port %d to exclusive access\n",
                    pEndpoint->fDatagram ? "UDP" : "TCP",
                    pEndpoint->Port));

        if ( setsockopt( sNew, SOL_SOCKET, SO_EXCLUSIVEADDRUSE,
                        (const CHAR *) &pEndpoint->fExclusive,
                        sizeof( pEndpoint->fExclusive )) != 0) {

            serr = WSAGetLastError();

            ATQ_PRINTF(( DBG_CONTEXT,
                        " setsockopt( %d, EXCLUSIVEADDR, FALSE) failed."
                        " Error = %d\n",
                        sNew, serr));
            serr = 0;
        }
    }

    if ( pEndpoint->fDatagram ) {

        //
        // ReverseQueuing means that if winsock runs out of buffer space for
        // receives then it will drop the oldest datagrams first.  The default 
        // is for it to drop the newest datagrams.
        //
        if ( pEndpoint->fReverseQueuing
            && WSAIoctl(sNew,                          // socket
                        SIO_ENABLE_CIRCULAR_QUEUEING,  // IoControlCode
                        NULL,                          // pvInBuffer
                        0,                             // cbInBuffer
                        NULL,                          // pvOutBuffer
                        0,                             // cbOutBuffer
                        &cbOut,                        // cbActualBytesReturned
                        NULL,                          // pvOverlapped
                        NULL)) {                       // pCompletionRoutine

            serr = WSAGetLastError();

            ATQ_PRINTF(( DBG_CONTEXT,
                         " WSAIoctl( %d, SIO_ENABLE_CIRCULAR_QUEUEING...) failed.  Error = 0x%x\n",
                         sNew, serr));

            serr = 0;
        }

        //
        // If they have specified a winsock receive buffer size use that instead
        // the winsock default of 8K.
        //
        if ( pEndpoint->cbDatagramWSBufSize
             && setsockopt(sNew,
                           SOL_SOCKET,
                           SO_RCVBUF,
                           (char *)&pEndpoint->cbDatagramWSBufSize,
                           sizeof(pEndpoint->cbDatagramWSBufSize))) {
            
            serr = WSAGetLastError();

            ATQ_PRINTF(( DBG_CONTEXT,
                         " setsockopt( %d, SO_RECVBUF, %d...) failed.  Error = 0x%x\n",
                         sNew, pEndpoint->cbDatagramWSBufSize, serr));

            serr = 0;
        }
    }
    
    //
    // See which address family we're dealing with
    //

    addr = (PSOCKADDR)&inAddr;
    addrLength = sizeof(inAddr);
    ZeroMemory(addr, addrLength);

    inAddr.sin_family = AF_INET;
    inAddr.sin_port = htons(pEndpoint->Port);
    inAddr.sin_addr.s_addr = pEndpoint->IpAddress;

    //
    // Bind an address to socket
    //

    if ( bind( sNew, addr, addrLength) != 0) {

        serr = WSAGetLastError();

        ATQ_PRINTF(( DBG_CONTEXT,
                    "bind ( socket = %d, Address = %08x, len = %d) "
                    " returns error = %u\n",
                    sNew, addr, addrLength, serr));

        goto cleanup;
    }

    //
    // Put the socket in listen mode
    //

    if ( !pEndpoint->fDatagram ) {

        if ( listen( sNew, g_cListenBacklog) != 0) {

            serr = WSAGetLastError();

            ATQ_PRINTF(( DBG_CONTEXT,
                        " listen( %d, %d) returned %d.\n",
                        sNew, g_cListenBacklog, serr));
            goto cleanup;
        }
    }
    pEndpoint->ListenSocket = sNew;

    //
    // Link to server listen list
    //

    AcquireLock( &AtqEndpointLock);

    InsertTailList(
                &AtqEndpointList,
                &pEndpoint->ListEntry
                );

    ReleaseLock( &AtqEndpointLock);
    return(TRUE);

cleanup:

    if ( sNew != INVALID_SOCKET) {
        closesocket( sNew);
    }

    SetLastError(serr);
    return(FALSE);

} // I_CreateListenSocket




BOOL
I_CloseListenSocket(
    IN PATQ_ENDPOINT Endpoint
    )
/*++

  Closes the socket on which a listen was possibly established.

  Returns:
    TRUE, if successful,
    FALSE, otherwise

--*/
{
    INT  serr = NO_ERROR;
    LINGER linger;
    SOCKET s;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"I_CloseListenSocket called.\n"));
    }

    s = (SOCKET)InterlockedExchangePointer(
                    (PVOID *)&Endpoint->ListenSocket,
                    (PVOID)INVALID_SOCKET
                    );

    if ( s == INVALID_SOCKET) {
        return(TRUE);
    }

    //
    //  Enable linger with timeout of ZERO for "hard" close
    //
    //  Error code from sock option is ignored, since we are
    //   anyway closing the socket
    //

    linger.l_onoff = TRUE;
    linger.l_linger = 0;
    setsockopt( s, SOL_SOCKET, SO_LINGER, (PCHAR)&linger,sizeof(linger));

    //
    // Close the socket
    //

    if (closesocket(s) != 0) {
        serr = WSAGetLastError();
        ATQ_PRINTF(( DBG_CONTEXT,"error %d in closesocket\n",serr));
    } else {

        // Remove the socket from the ListenAtq Context as well
        //  since the socket is now closed here in this function.
        PATQ_CONTEXT patqc = Endpoint->pListenAtqContext;
        if ( patqc != NULL) {
            patqc->hAsyncIO = NULL;
        }
    }

    return (TRUE);
} // I_CloseListenSocket()




DWORD
ListenThreadFunc(
        LPVOID Context
        )
/*++

    Main loop waiting for connections. ( The core of server)
    The thread loops around waiting on an accept() call on
     listenSocket.
    If there is a new message on socket, it invokes the
     callback function for connection.

    NEVER returns untill it is requested to stop by someother
      thread using a call to TS_CONNECTION_INFO::StopConnectionThread().

    Returns:

      0 on success and error code if there is a fatal error.


--*/
{

    INT serr;
    register SOCKET  sNewConnection;
    SOCKADDR_IN sockAddrRemote;
    PATQ_ENDPOINT endpoint = (PATQ_ENDPOINT)Context;

    IF_DEBUG(ENDPOINT) {
        ATQ_PRINTF((DBG_CONTEXT,"ListenThreadFunc() running.\n"));
    }

    //
    //  Loop Forever
    //

    for( ; ;) {

        int cbAddr = sizeof( sockAddrRemote);

        //
        //  Wait for a connection
        //

        IF_DEBUG(ENDPOINT) {
            ATQ_PRINTF((DBG_CONTEXT,"Listening for new connection\n"));
        }

        if ((sNewConnection = WSAAccept(
                                    endpoint->ListenSocket,
                                    (LPSOCKADDR ) &sockAddrRemote,
                                    &cbAddr,
                                    NULL,
                                    0)) != INVALID_SOCKET) {

            //
            // Valid Connection has been established.
            // Invoke the callback function to process this connection
            //   and then continue the loop
            //

            IF_DEBUG(ENDPOINT) {
                ATQ_PRINTF((DBG_CONTEXT,"Got new connection. sock[%d]\n",
                    sNewConnection));
            }

            (*endpoint->ConnectCompletion)(
                                sNewConnection,
                                &sockAddrRemote,
                                endpoint->Context,
                                (PVOID)endpoint
                                );

        } else {

            //
            // Some low level error has occured.
            //

            serr = WSAGetLastError();
            ATQ_PRINTF((DBG_CONTEXT,"Error %d in accept\n", serr));

            if ( serr == WSAEINTR) {

                //
                // Socket was closed by low-level call. Get out.
                //

                break;
            }

            //
            // Check if we are shutting down and if so QUIT
            //

            if (!IS_BLOCK_ACTIVE(endpoint)) {
                IF_DEBUG(ENDPOINT) {
                    ATQ_PRINTF((DBG_CONTEXT,"ListenThread shutting down\n"));
                }
                break;
            }

            //
            // Perform a graceful recovery from failure. NYI
            //  ( Tricky code). Both FTP and Web server are to test it!
            //    Will add this code later. ( MuraliK)
            //

            IF_DEBUG(ENDPOINT) {
                ATQ_PRINTF((DBG_CONTEXT,"Unexpected error %d on accept\n",
                    serr));
            }
        }
    }

    //
    // Cleanup & Exit. Cleanup is done by the code which called the shut down.
    //

    IF_DEBUG(ENDPOINT) {
        ATQ_PRINTF((DBG_CONTEXT,"ListenThread exiting.\n"));
    }
    return ( 0);  // No errors

} // ListenThreadFunc()



BOOL
StartListenThread(
    IN PATQ_ENDPOINT Endpoint
    )
{
    DWORD  id;

    Endpoint->hListenThread = CreateThread(
                                        NULL,
                                        0,
                                        ListenThreadFunc,
                                        (PVOID )Endpoint,
                                        0,
                                        &id
                                        );

    if ( Endpoint->hListenThread != NULL) {
        return(TRUE);
    }

    return(FALSE);

} // StartListenThread



VOID
ATQ_ENDPOINT::CleanupEndpoint(
    VOID
    )
/*++

  Description:
     This function cleansup the internal state of the object and prepares
     it for the deletion.
     All endpoints should pass through this function when the ref count
     this zero.

--*/
{
    DBG_ASSERT( this->m_refCount == 0);
    ATQ_ASSERT( !IS_BLOCK_ACTIVE( this) );
    ASSERT( this->Signature == ATQ_ENDPOINT_SIGNATURE );

    // the following free will throw away the listen atq context
    if ( this->pListenAtqContext != NULL) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "Endpoint(%08x) frees listen context %08x\n",
                     this, this->pListenAtqContext));
        AtqFreeContext( this->pListenAtqContext, FALSE);
        this->pListenAtqContext = NULL;
    }

    if ( this->ShutdownCallback != NULL ) {
        //
        // This only happens when someone calls AtqStopAndCloseEndpoint which should
        // never happen in K2.
        //
        ASSERT( FALSE );
        this->ShutdownCallback( this->ShutdownCallbackContext);
    }

    this->Signature = ATQ_ENDPOINT_SIGNATURE_FREE;

#if DBG
    if( this->RefTraceLog != NULL ) {
        DestroyRefTraceLog( this->RefTraceLog );
    }
#endif

    return;

} // ATQ_ENDPOINT::CleanupEndpoint()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\auxctrs.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       auxctrs.h

   Abstract:
       This module defines the auxiliary counters for Internet Common Services.

   Author:

       Murali R. Krishnan    ( MuraliK )    02-Apr-1996

   Environment:

       Windows NT - User Mode

   Project:

       Internet Services Common DLL

   Revision History:

--*/

# ifndef _IIS_AUX_COUNTERS_HXX_
# define _IIS_AUX_COUNTERS_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Definitions
 ************************************************************/

/*++
  Counters belong to two categories
  1. Active Counter - one that counts up and down
      It is expected that this counter consists of the current
      active items and hence this should not be wildly high, unless
      there are large # of counted objects.

  2. Cumulative Counters - counts values up and up
      This count value is used to measure the # of times event(s)
      related to this counter occurred.

  Naming Conventions:
   prefixes used are: Aac & Cac
   Aac - Active Auxiliary Counter
   Cac - Cumulative Auxiliary Counter
   Ac  - Auxiliar Counter

--*/

typedef enum  {   // Ac - stands for Aux Counters.

    AacAtqContextsAlloced = 0,

    CacAtqContextsReused,
    CacAtqContextsCleanedup,
    CacAtqPrepareContexts,
    CacAtqPendingAcceptExScans,

    CacAtqContextsTimedOut,
    CacAtqWaitsForTimeout,
    CacAtqProcWhenTimeout,           // in processing when timeout occurred.

    AacIISMaxCounters                // sentinel counter
} ENUM_IIS_AUX_COUNTER;



#ifdef IIS_AUX_COUNTERS

# define NUM_AUX_COUNTERS    (AacIISMaxCounters)

//
// Macros for operating on these counters
//

# define AcIncrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
   g_AuxCounters[acCounter]++ : \
  0)

# define AcDecrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
  g_AuxCounters[acCounter]-- : \
  0)

# define AcCounter( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ? g_AuxCounters[acCounter] : 0)


extern LONG g_AuxCounters[];


# else // IIS_AUX_COUNTERS

# define NUM_AUX_COUNTERS              (0)

# define AcIncrement( acCounter)       (0)    /* do nothing */
# define AcDecrement( acCounter)       (0)    /* do nothing */
# define AcCounter  ( acCounter)       (0)    /* do nothing */

#endif // IIS_AUX_COUNTERS


# endif // _IIS_AUX_COUNTERS_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\atqmain.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      atqmain.cxx

   Abstract:
      This module implements entry points for ATQ - Asynchronous Thread Queue.

   Author:

       Murali R. Krishnan    ( MuraliK )     8-Apr-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

   Functions Exported:

       BOOL  AtqInitialize();
       BOOL  AtqTerminate();

       DWORD AtqSetInfo();
       DWORD AtqGetInfo();
       BOOL  AtqGetStatistics();
       BOOL  AtqClearStatistics();

       BOOL  AtqAddAcceptExSockets();
       BOOL  AtqAddAsyncHandle();
       DWORD AtqContextSetInfo();
       VOID  AtqCloseSocket();
       VOID  AtqFreeContext();

       BOOL  AtqReadFile();
       BOOL  AtqWriteFile();
       BOOL  AtqTransmitFile();
       BOOL  AtqPostCompletionStatus();

       PVOID AtqAllocateBandwidthInfo();
       BOOL  AtqFreeBandwidthInfo();
       DWORD AtqBandwidthSetInfo();
--*/

#include "isatq.hxx"
#include <inetsvcs.h>
#include "sched.hxx"

# define ATQ_REG_DEF_THREAD_TIMEOUT_PWS    (30*60)  // 30 minutes

/************************************************************
 * Globals
 ************************************************************/

// ------------------------------
// Configuration for ATQ package
// ------------------------------

extern CHAR g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY[];

// ----------------------------------------
// # of CPUs in machine (for thread-tuning)
// ----------------------------------------

extern DWORD g_cCPU;

//
// Used for guarding the initialization code
//

extern CRITICAL_SECTION MiscLock;

//
// concurrent # of threads to run per processor
//

DWORD g_cConcurrency = ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY;

//
//  Amount of time (in ms) a worker thread will be idle before suicide
//

DWORD g_msThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT * 1000;

BOOL  g_fUseAcceptEx = TRUE;    // Use AcceptEx if available

//
// The absolute thread limit
//

LONG   g_cMaxThreadLimit = ATQ_REG_DEF_POOL_THREAD_LIMIT;

//
// Should we use fake completion port
//

BOOL g_fUseFakeCompletionPort =  FALSE;

//
// Assumed minimum file transfer rate
//

DWORD g_cbMinKbSec = ATQ_REG_DEF_MIN_KB_SEC;

//
// Size of buffers for fake xmits
//

DWORD g_cbXmitBufferSize = ATQ_REG_DEF_NONTF_BUFFER_SIZE;

//
// number of active context list
//

DWORD g_dwNumContextLists = ATQ_NUM_CONTEXT_LIST;

//
// Max winsock datagram send.
// 

DWORD g_cbMaxDGramSend = 2048;

/*
   g_pfnExitThreadCallback()
    This routine sets the callback routine to be called when one of the
    Atq threads exit so that thread state data can be cleaned up. Currently
    support is for a single routine. One way to support multiple routines would
    be for the caller to save the return value. Such an application would not
    be able to delete the "saved" callback routine.
 */
ATQ_THREAD_EXIT_CALLBACK g_pfnExitThreadCallback = NULL;

//
// g_pfnUpdatePerfCountersCallback()
//  This routine is used to update PerfMon counters that are located in the
//  DS core.
//
ATQ_UPDATE_PERF_CALLBACK g_pfnUpdatePerfCounterCallback = NULL;

// ----------------------------------
// Fake Completion port
// -----------------------------------
//
// Used to gauge pool thread creation. This variable shows number of
// ATQ contexts // ready to be processed by ATQ pool thread. Basically
// this is length of outcoming queue in SIO module and is modified by
// routines there
//

DWORD   g_AtqWaitingContextsCount = 0;

// ------------------------------
// Current State Information
// ------------------------------


HANDLE  g_hCompPort = NULL;      // Handle for completion port
LONG    g_cThreads = 0;          // number of thread in the pool
LONG    g_cAvailableThreads = 0; // # of threads waiting on the port.

//
// Is the NTS driver in use
//

BOOL    g_fUseDriver = FALSE;

//
// Current thread limit
//

LONG    g_cMaxThreads = ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS;

DWORD   g_cListenBacklog = ATQ_REG_DEF_LISTEN_BACKLOG;

BOOL    g_fShutdown = FALSE;   // if set, indicates that we are shutting down
                               // in that case, all threads should exit.

HANDLE  g_hShutdownEvent = NULL; // set when all running threads shutdown

// ------------------------------
// Bandwidth Throttling Info
// ------------------------------

PBANDWIDTH_INFO     g_pBandwidthInfo = NULL;

// ------------------------------
// Various State/Object Lists
// ------------------------------

//
// Used to switch context between lists
//

DWORD AtqGlobalContextCount = 0;

//
// List of active context
//

ATQ_CONTEXT_LISTHEAD AtqActiveContextList[ATQ_NUM_CONTEXT_LIST];

//
// List of Endpoints in ATQ - one per listen socket
//

LIST_ENTRY AtqEndpointList;
CRITICAL_SECTION AtqEndpointLock;

PALLOC_CACHE_HANDLER  g_pachAtqContexts;

#ifdef IIS_AUX_COUNTERS

LONG g_AuxCounters[NUM_AUX_COUNTERS];

#endif // IIS_AUX_COUNTERS

// ------------------------------
// local to this module
// ------------------------------

LONG  sg_AtqInitializeCount = -1;
BOOL  g_fSpudInitialized = FALSE;

DWORD
I_AtqGetGlobalConfiguration(VOID);

DWORD
I_NumAtqEndpointsOpen(VOID);

VOID
WaitForWinsockCallback(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN DWORD dwFlags
    );

BOOL
WaitForWinsockToInitialize(
    VOID
    );


/************************************************************
 * Functions
 ************************************************************/

BOOL
AtqInitialize(
    IN DWORD   dwFlags
    )
/*++
Routine Description:

    Initializes the ATQ package

Arguments:
    dwFlags - DWORD containing the flags for use to initialize ATQ library.
    Notably in many cases one may not need the SPUD driver initialized
      for processes other than the IIS main process. This dword helps
      to shut off the unwanted flags.

    This is an ugly way to initialize/shutdown SPUD, but that is what we
    will do. SPUD supports only ONE completion port and hence when we use
    ATQ in multiple processes we should be careful to initialize SPUD only
    once and hopefully in the IIS main process!

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

Note:
    As of 4/16/97 the pszRegKey that is sent is no more utilized.
    We always load the internal configuration parameters from
     one single registry entry specified by PSZ_ATQ_CONFIG_PARAMS_REG_KEY
    The parameter is left in the command line for compatibility
      with old callers :( - NYI: Need to change this.
--*/
{
    DWORD       i;
    DWORD       dwErr;

    //
    // We need to acquire a lock here to make this thread safe
    //

    AcquireLock(&MiscLock);

    if ( InterlockedIncrement( &sg_AtqInitializeCount) != 0) {

        IF_DEBUG( API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqInitialize( %08x). ATQ is already initialized.\n",
                         dwFlags));
        }

        //
        // we are already initialized. Ignore the new registry settings
        //

        ReleaseLock(&MiscLock);
        return ( TRUE);
    }

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize[%08x]. Initializing....\n",
                     dwFlags));
    }

    DBG_REQUIRE( ALLOC_CACHE_HANDLER::Initialize());
    IF_DEBUG( INIT_CLEAN ) {
        DBGPRINTF(( DBG_CONTEXT, "Alloc Cache initialized\n" ));
    }

    if ( !SchedulerInitialize()) {
        DBGPRINTF(( DBG_CONTEXT, "Initializing Scheduler Failed\n"));
        InterlockedDecrement( &sg_AtqInitializeCount);
        ReleaseLock(&MiscLock);
        return FALSE;
    }

    DBG_REQUIRE( ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval() );

    IF_DEBUG( INIT_CLEAN ) {
        DBGPRINTF(( DBG_CONTEXT, "Scheduler Initialized\n" ));
    }

    //
    // Initialize context lists and crit sects
    //

    ATQ_CONTEXT_LISTHEAD * pacl;

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {
        pacl->Initialize();
    }

    InitializeListHead( &AtqEndpointList );
    InitializeCriticalSection( &AtqEndpointLock );

    //
    // init bandwidth throttling
    //

    ATQ_REQUIRE( BANDWIDTH_INFO::AbwInitialize() );

    //
    //  Read registry configurable Atq options.  We have to read these now
    //  because concurrency is set for the completion port at creation time.
    //

    DWORD dwError = I_AtqGetGlobalConfiguration();

    if ( NO_ERROR != dwError) {
        SetLastError( dwError);
        InterlockedDecrement( &sg_AtqInitializeCount);
        IIS_PRINTF((buff,"GetGlobal failed\n"));
        ReleaseLock(&MiscLock);
        return ( FALSE);
    }

    //
    // Setup an allocation cache for the ATQ Contexts
    // NYI: Auto-tune the threshold limit
    //

    {
        ALLOC_CACHE_CONFIGURATION acConfig;

        DWORD nCachedAtq = ATQ_CACHE_LIMIT_NTS;

        if ( TsIsWindows95()) { nCachedAtq = ATQ_CACHE_LIMIT_W95; }

        acConfig.nConcurrency = 1;
        acConfig.nThreshold = nCachedAtq;
        acConfig.cbSize = sizeof(ATQ_CONTEXT);

        g_pachAtqContexts = new ALLOC_CACHE_HANDLER( "ATQ", &acConfig);

        if ( NULL == g_pachAtqContexts) {
            IIS_PRINTF((buff,"alloc failed %d\n", GetLastError()));
            goto cleanup;
        }
    }


    //
    //  Create the shutdown event
    //

    g_hShutdownEvent = IIS_CREATE_EVENT(
                           "g_hShutdownEvent",
                           &g_hShutdownEvent,
                           TRUE,        // Manual reset
                           FALSE        // Not signalled
                           );

    //
    //  Create the completion port
    //

    g_hCompPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,
                                            g_hCompPort,
                                            (DWORD) NULL,
                                            g_cConcurrency
                                            );

    if ( !g_hShutdownEvent || !g_hCompPort ) {

        OutputDebugString( " Create IoComp port failed\n");
        goto cleanup;
    }

    //
    // initialize spud driver
    //

    if ( dwFlags & ATQ_INIT_SPUD_FLAG ) {
        (VOID) I_AtqSpudInitialize(g_hCompPort);
        g_fSpudInitialized = TRUE;
    }

    //
    // Ensure all other initializations also are done
    //

    g_cThreads  = 0;
    g_fShutdown = FALSE;
    g_cAvailableThreads = 0;

    if ( !I_AtqStartTimeoutProcessing( NULL ) ) {
        IIS_PRINTF((buff,"Start processing failed\n"));
        goto cleanup;
    }

    IF_DEBUG(INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT,
                    "fUseAcceptEx[%d] NT CompPort[%d] Platform[%d]"
                    " fUseDriver[%d]\n",
                    g_fUseAcceptEx,  !g_fUseFakeCompletionPort,
                    IISPlatformType(),
                    g_fUseDriver
                    ));
    }

    //
    // Create the initial ATQ thread.
    //

    (VOID)I_AtqCheckThreadStatus( (PVOID)UIntToPtr(ATQ_INITIAL_THREAD) );

    //
    // Create a second thread if we are NTS
    //

    if ( TsIsNtServer() ) {
        (VOID)I_AtqCheckThreadStatus( (PVOID)UIntToPtr(ATQ_INITIAL_THREAD) );
    }

    dwErr = I_AtqStartThreadMonitor();
    ATQ_ASSERT( dwErr != FALSE );

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize( %08x) returns %d.\n",
                     dwFlags, TRUE));
    }

    WaitForWinsockToInitialize();

    ReleaseLock(&MiscLock);
    return TRUE;

cleanup:
    IIS_PRINTF((buff,"cleanup!!!\n"));
    for (i=0; i<g_dwNumContextLists; i++) {

        AtqActiveContextList[i].Cleanup();
    }

    DeleteCriticalSection( &AtqEndpointLock);

    if ( g_hShutdownEvent != NULL ) {
        CloseHandle( g_hShutdownEvent );
        g_hShutdownEvent = NULL;
    }

    if ( g_hCompPort != NULL ) {
        CloseHandle( g_hCompPort );
        g_hCompPort = NULL;
    }

    if ( NULL != g_pachAtqContexts) {
        delete g_pachAtqContexts;
        g_pachAtqContexts = NULL;
    }

    ATQ_REQUIRE( BANDWIDTH_INFO::AbwTerminate());

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize( %08x) returns %d.\n",
                     dwFlags, FALSE));
    }

    InterlockedDecrement( &sg_AtqInitializeCount);
    ReleaseLock(&MiscLock);
    return(FALSE);

} // AtqInitialize()





BOOL
AtqTerminate(
    VOID
    )
/*++

Routine Description:

    Cleans up the ATQ package.  Should only be called after all of the
    clients of ATQ have been shutdown.

Arguments:

    None.

Return Value:

    TRUE, if ATQ was shutdown properly
    FALSE, otherwise

--*/
{
    DWORD       currentThreadCount;
    ATQ_CONTEXT_LISTHEAD * pacl;

    // there are outstanding users, don't fully terminate
    if ( InterlockedDecrement( &sg_AtqInitializeCount) >= 0) {

        IF_DEBUG( API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqTerminate() - there are other users."
                         " Not terminating now\n"
                         ));
        }
        return (TRUE);
    }

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqTerminate() - Terminating ATQ ...\n"
                     ));
    }


    //
    // All the ATQ endpoints should have been terminated before calling
    //  this ATQTerminate() function. If not, sorry return failure.
    //
    DWORD nEndpointsToBeClosed = I_NumAtqEndpointsOpen();

    if ( nEndpointsToBeClosed > 0) {

        DBGPRINTF(( DBG_CONTEXT,
                    " There are %d endpoints remaining to be closed."
                    " Somebody above stream did not close endpoints."
                    " BUG IN CODE ABOVE ATQ\n"
                    ,
                    nEndpointsToBeClosed
                    ));
        SetLastError( ERROR_NETWORK_BUSY);
        return ( FALSE);
    }


    if ( (g_hShutdownEvent == NULL) || g_fShutdown ) {

        //
        // We have not been intialized or have already terminated.
        //
        SetLastError( ERROR_NOT_READY );
        return FALSE;
    }

    // Cleanup variables in ATQ Bandwidth throttle module
    if ( !BANDWIDTH_INFO::AbwTerminate()) {

        // there may be a few blocked IO. We should avoid them all.
        // All clients should have cleaned themselves up before coming here.
        return (FALSE);
    }

    //
    // All clients should have cleaned themselves up before calling us.
    //

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {

        pacl->Lock();

        if ( !IsListEmpty(&pacl->ActiveListHead)) {

            ATQ_ASSERT( IsListEmpty( &pacl->ActiveListHead));
            pacl->Unlock();

            IF_DEBUG( API_EXIT) {
                ATQ_PRINTF(( DBG_CONTEXT,
                             "AtqTerminate() - ContextList(%08x) has "
                             "Active Contexts. Failed Termination.\n",
                             pacl
                             ));
            }

            return FALSE;
        }

        pacl->Unlock();
    } // for

    //
    // Note that we are shutting down and prevent any more handles from
    // being added to the completion port.
    //

    g_fShutdown = TRUE;

    //
    // Attempt and remove the TimeOut Context from scheduler queue
    //
    DBG_REQUIRE( I_AtqStopTimeoutProcessing());
    DBG_REQUIRE( I_AtqStopThreadMonitor() );

    currentThreadCount = g_cThreads;
    if (currentThreadCount > 0) {

        DWORD       i;
        BOOL        fRes;
        OVERLAPPED  overlapped;

        //
        // Post a message to the completion port for each worker thread
        // telling it to exit. The indicator is a NULL context in the
        // completion.
        //

        ZeroMemory( &overlapped, sizeof(OVERLAPPED) );

        for (i=0; i<currentThreadCount; i++) {

            fRes = PostQueuedCompletionStatus( g_hCompPort,
                                               0,
                                               0,
                                               &overlapped );

            ATQ_ASSERT( (fRes == TRUE) ||
                       ( (fRes == FALSE) &&
                        (GetLastError() == ERROR_IO_PENDING) )
                       );
        }
    }

    //
    // Now wait for the pool threads to shutdown.
    //

    DWORD dwErr =
        WaitForSingleObject( g_hShutdownEvent, ATQ_WAIT_FOR_THREAD_DEATH);
#if 0
    DWORD dwWaitCount = 0;
    while ( dwErr == WAIT_TIMEOUT) {

        dwWaitCount++;
        DebugBreak();
        Sleep( 10*1000);  // sleep for some time
        dwErr =
            WaitForSingleObject( g_hShutdownEvent, ATQ_WAIT_FOR_THREAD_DEATH);
    } // while
# endif // 0

    //
    // At this point, no other threads should be left running.
    //
    //
    //  g_cThreads counter is decremented by AtqPoolThread().
    //  AtqTerminate() is called during the DLL termination
    //  But at DLL termination, all ATQ pool threads are killed =>
    //    no one is decrementing the count. Hence this assert will always fail.
    //

    // ATQ_ASSERT( !g_cThreads );

    ATQ_REQUIRE( CloseHandle( g_hShutdownEvent ) );
    CloseHandle( g_hCompPort );

    g_hShutdownEvent = NULL;
    g_hCompPort = NULL;

    //
    // Cleanup our synchronization resources
    //

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {
        PLIST_ENTRY pEntry;

        pacl->Lock();

        if ( !IsListEmpty( &pacl->PendingAcceptExListHead)) {
            for ( pEntry = pacl->PendingAcceptExListHead.Flink;
                  pEntry != &pacl->PendingAcceptExListHead;
                  pEntry  = pEntry->Flink ) {

                PATQ_CONT pContext =
                    CONTAINING_RECORD( pEntry, ATQ_CONTEXT, m_leTimeout );

                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                pContext->Print();
            } // for
        }

        pacl->Unlock();
        pacl->Cleanup();
    }


    //
    // Free all the elements in the Allocation caching list
    //
    if ( NULL != g_pachAtqContexts) {
        delete g_pachAtqContexts;
        g_pachAtqContexts = NULL;
    }

    DeleteCriticalSection( &AtqEndpointLock);

    //
    // cleanup driver
    //

    if ( g_fSpudInitialized ) {
        (VOID)I_AtqSpudTerminate();
        g_fSpudInitialized = FALSE;
    }

    //
    // Cleanup scheduler
    //

    DBG_REQUIRE( ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval() );

    SchedulerTerminate();
    DBG_REQUIRE( ALLOC_CACHE_HANDLER::Cleanup());

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqTerminate() - Successfully cleaned up.\n"
                     ));
    }

    return TRUE;
} // AtqTerminate()





DWORD_PTR
AtqSetInfo(
    IN ATQ_INFO         atqInfo,
    IN DWORD_PTR        Data
    )
/*++

Routine Description:

    Sets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    DWORD_PTR dwOldVal = 0;

    switch ( atqInfo ) {

    case AtqBandwidthThrottle:

        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwOldVal = g_pBandwidthInfo->SetBandwidthLevel( (DWORD)Data );
        break;

    case AtqBandwidthThrottleMaxBlocked:

        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwOldVal = g_pBandwidthInfo->SetMaxBlockedListSize( (DWORD)Data );
        break;

    case AtqExitThreadCallback:

        dwOldVal = (DWORD_PTR) g_pfnExitThreadCallback;
        g_pfnExitThreadCallback =  (ATQ_THREAD_EXIT_CALLBACK ) Data;
        break;

    case AtqMaxPoolThreads:
          // the value is per processor values
        // internally we maintain value for all processors
        dwOldVal = g_cMaxThreads/g_cCPU;
        g_cMaxThreads = (DWORD)Data * g_cCPU;
        break;

      //
      //  Increment or decrement the max thread count.  In this instance, we
      //  do not scale by the number of CPUs
      //

      case AtqIncMaxPoolThreads:
        InterlockedIncrement( (LONG *) &g_cMaxThreads );
        dwOldVal = TRUE;
        break;

      case AtqDecMaxPoolThreads:
        InterlockedDecrement( (LONG *) &g_cMaxThreads );
        dwOldVal = TRUE;
        break;


      case AtqMaxConcurrency:
        dwOldVal = g_cConcurrency;
        g_cConcurrency = (DWORD)Data;
        break;

      case AtqThreadTimeout:
        dwOldVal = g_msThreadTimeout/1000;  // convert back to seconds
        g_msThreadTimeout = (DWORD)Data * 1000; // convert value to millisecs
        break;

      case AtqUseAcceptEx:
        dwOldVal = g_fUseAcceptEx;
        if ( !TsIsWindows95() ) {
            g_fUseAcceptEx = (DWORD)Data;
        }
        break;

      case AtqMinKbSec:

        //
        //  Ignore it if the value is zero
        //

        if ( Data ) {
            dwOldVal = g_cbMinKbSec;
            g_cbMinKbSec = (DWORD)Data;
        }
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    }

    return dwOldVal;
} // AtqSetInfo()





DWORD_PTR
AtqGetInfo(
    IN ATQ_INFO  atqInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set

Return Value:

    The old value of the parameter

--*/
{
    DWORD_PTR dwVal = 0;

    switch ( atqInfo ) {

      case AtqBandwidthThrottle:
        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwVal = g_pBandwidthInfo->QueryBandwidthLevel();
        break;

      case AtqExitThreadCallback:

        dwVal = (DWORD_PTR) g_pfnExitThreadCallback;
        break;

      case AtqMaxPoolThreads:
        dwVal = g_cMaxThreads/g_cCPU;
        break;

      case AtqMaxConcurrency:
        dwVal = g_cConcurrency;
        break;

      case AtqThreadTimeout:
        dwVal = g_msThreadTimeout/1000; // convert back to seconds
        break;

      case AtqUseAcceptEx:
        dwVal = g_fUseAcceptEx;
        break;

      case AtqMinKbSec:
        dwVal = g_cbMinKbSec;
        break;

      case AtqMaxDGramSend:
        dwVal = g_cbMaxDGramSend;
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    } // switch

    return dwVal;
} // AtqGetInfo()





BOOL
AtqGetStatistics(IN OUT ATQ_STATISTICS * pAtqStats)
{
    if ( pAtqStats != NULL) {

        return g_pBandwidthInfo->GetStatistics( pAtqStats );

    } else {

        SetLastError( ERROR_INVALID_PARAMETER);
        return (FALSE);
    }
} // AtqGetStatistics()





BOOL
AtqClearStatistics( VOID)
{
    return g_pBandwidthInfo->ClearStatistics();

} // AtqClearStatistics()





DWORD_PTR
AtqContextSetInfo(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo,
    DWORD_PTR              Data
    )
/*++

Routine Description:

    Sets various bits of information for this context

Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    DWORD_PTR dwOldVal = 0;

    ATQ_ASSERT( pContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

    if ( pContext && pContext->Signature == ATQ_CONTEXT_SIGNATURE )
    {
        switch ( atqInfo ) {

        case ATQ_INFO_TIMEOUT:
            dwOldVal = pContext->TimeOut;
            pContext->TimeOut = CanonTimeout( (DWORD)Data );
            break;

        case ATQ_INFO_RESUME_IO:

            //
            // set back the max timeout from pContext->TimeOut
            // This will ensure that timeout processing can go on
            //   peacefully.
            //

            {
                DWORD currentTime = AtqGetCurrentTick( );
                DWORD timeout;
                dwOldVal = pContext->NextTimeout;
                timeout = pContext->TimeOut;

                //
                // Set the new timeout
                //

                I_SetNextTimeout(pContext);

                //
                // Return the old
                //

                if ( currentTime >= dwOldVal ) {
                    ATQ_ASSERT((dwOldVal & ATQ_INFINITE) == 0);
                    dwOldVal = 0;
                } else if ( (dwOldVal & ATQ_INFINITE) == 0 ) {
                    dwOldVal -= currentTime;
                }

                // return correct units
                dwOldVal = UndoCanonTimeout( (DWORD)dwOldVal );
            }
            break;

        case ATQ_INFO_COMPLETION:
            dwOldVal = (DWORD_PTR) pContext->pfnCompletion;
            pContext->pfnCompletion = (ATQ_COMPLETION) Data;
            break;

        case ATQ_INFO_COMPLETION_CONTEXT:

            ATQ_ASSERT( Data != 0 );        // NULL context not allowed

            dwOldVal = (DWORD_PTR) pContext->ClientContext;
            pContext->ClientContext = (void *) Data;
            break;

        case ATQ_INFO_BANDWIDTH_INFO:
        {
            ATQ_ASSERT( Data != 0 );

            PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) Data;

            ATQ_ASSERT( pBandwidthInfo->QuerySignature() ==
                                                ATQ_BW_INFO_SIGNATURE );

            if ( !pBandwidthInfo->IsFreed() )
            {
                pContext->m_pBandwidthInfo = (PBANDWIDTH_INFO) Data;
                pContext->m_pBandwidthInfo->Reference();
            }
            break;
        }

        case ATQ_INFO_ABORTIVE_CLOSE:
            dwOldVal = pContext->IsFlag( ACF_ABORTIVE_CLOSE );
            if ( Data )
            {
                pContext->SetFlag( ACF_ABORTIVE_CLOSE );
            }
            else
            {
                pContext->ResetFlag( ACF_ABORTIVE_CLOSE );
            }
            break;

        default:
            ATQ_ASSERT( FALSE );
        }
    }

    return dwOldVal;

} // AtqContextSetInfo()



BOOL
AtqAddAsyncHandle(
    PATQ_CONTEXT * ppatqContext,
    PVOID          EndpointObject,
    PVOID          ClientContext,
    ATQ_COMPLETION pfnCompletion,
    DWORD          TimeOut,
    HANDLE         hAsyncIO
    )
/*++

Routine Description:

    Adds a handle to the thread queue

    The client should call this after the IO handle is opened
    and before the first IO request is made

    Even in the case of failure, client should call AtqFreeContext() and
     free the memory associated with this object.

Arguments:

    ppatqContext - Receives allocated ATQ Context
    Context - Context to call client with
    pfnCompletion - Completion to call when IO completes
    TimeOut - Time to wait (sec) for IO completion (INFINITE is valid)
    hAsyncIO - Handle with pending read or write

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    return ( I_AtqAddAsyncHandle( (PATQ_CONT *) ppatqContext,
                                  (PATQ_ENDPOINT) EndpointObject,
                                  ClientContext,
                                  pfnCompletion,
                                  TimeOut,
                                  hAsyncIO)
             &&
             I_AddAtqContextToPort( *((PATQ_CONT *) ppatqContext))
            );

} // AtqAddAsyncHandle()




VOID
AtqGetAcceptExAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrLocal,
    OUT SOCKADDR * * ppsockaddrRemote
    )
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    INT       cbsockaddrLocal;
    INT       cbsockaddrRemote;
    DWORD     cb;

    ATQ_ASSERT( g_fUseAcceptEx);
    ATQ_ASSERT( pContext->pEndpoint);

    *pSock   = (SOCKET) pContext->hAsyncIO;
    *pEndpointContext = pContext->pEndpoint->Context;

    //
    //  The buffer not only receives the initial received data, it also
    //  gets the sock addrs, which must be at least sockaddr_in + 16 bytes
    //  large
    //

    GetAcceptExSockaddrs( pContext->pvBuff,
                               (cb = pContext->pEndpoint->InitialRecvSize),
                               MIN_SOCKADDR_SIZE,
                               MIN_SOCKADDR_SIZE,
                               ppsockaddrLocal,
                               &cbsockaddrLocal,
                               ppsockaddrRemote,
                               &cbsockaddrRemote );

    *ppvBuff = ( ( cb == 0) ? NULL : pContext->pvBuff);

    return;
} // AtqGetAcceptExAddrs()




BOOL
AtqCloseSocket(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    )
/*++

  Routine Description:

    Closes the socket in this atq structure if it wasn't
    closed by transmitfile. This function should be called only
    if the embedded handle in AtqContext is a Socket.

  Arguments:

    patqContext - Context whose socket should be closed.
    fShutdown - If TRUE, means we call shutdown and always close the socket.
        Note that if TransmitFile closed the socket, it will have done the
        shutdown for us

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

        BOOL fAbortiveClose;

        fAbortiveClose = pContext->IsFlag( ACF_ABORTIVE_CLOSE );
        pContext->ResetFlag( ACF_ABORTIVE_CLOSE );

        //
        //  Don't delete the socket if we don't have to
        //

        if ( pContext->IsState( ACS_SOCK_UNCONNECTED |
                                ACS_SOCK_CLOSED)
             ) {

            //
            //  Do nothing
            //

        } else {

            // default:
            // case ACS_SOCK_LISTENING:
            // case ACS_SOCK_CONNECTED: {

            HANDLE hIO;
            PATQ_ENDPOINT pEndpoint;

            pEndpoint = pContext->pEndpoint;

            pContext->MoveState( ACS_SOCK_CLOSED);

            //
            //  During shutdown, the socket may be closed while this thread
            //  is doing processing, so only give a warning if any of the
            //  following fail
            //

            hIO = (HANDLE )InterlockedExchangePointer((PVOID *) &pContext->hAsyncIO,
                                                      NULL);

            if ( hIO == NULL ) {

                //
                // No socket - it is already closed - do nothing.
                //

            } else {

                if ( pContext->fDatagramContext ) {
                    return TRUE;
                }

                if (fAbortiveClose || fShutdown ) {

                    //
                    //  If this is an AcceptEx socket, we must first force a
                    //  user mode context update before we can call shutdown
                    //

                    if ( (pEndpoint != NULL) && (pEndpoint->UseAcceptEx) ) {

                        if ( setsockopt( (SOCKET) hIO,
                                         SOL_SOCKET,
                                         SO_UPDATE_ACCEPT_CONTEXT,
                                         (char *) &pEndpoint->ListenSocket,
                                         sizeof(SOCKET) ) == SOCKET_ERROR ) {

                            ATQ_PRINTF(( DBG_CONTEXT,
                                         "[AtqCloseSocket] Warning- setsockopt "
                                         "failed, error %d, socket = %x,"
                                         " Context= %08x, Listen = %lx\n",
                                         GetLastError(),
                                         hIO,
                                         pContext,
                                         pEndpoint->ListenSocket ));
                        }
                    }
                } // setsock-opt call

                if ( fAbortiveClose ) {
                    LINGER  linger;

                    linger.l_onoff = TRUE;
                    linger.l_linger = 0;

                    if ( setsockopt( (SOCKET) hIO,
                                     SOL_SOCKET,
                                     SO_LINGER,
                                     (char *) &linger,
                                     sizeof(linger) ) == SOCKET_ERROR
                         ) {
                        ATQ_PRINTF(( DBG_CONTEXT,
                                     "[AtqCloseSocket] Warning- setsockopt "
                                     "failed, error %d, socket = %x,"
                                     " Context= %08x, Listen = %lx\n",
                                     GetLastError(),
                                     hIO,
                                     pContext,
                                     pEndpoint->ListenSocket ));
                    }
                    else {
                        ATQ_PRINTF(( DBG_CONTEXT,
                                     "[AtqCloseSocket(%08x)] requested"
                                     " abortive close\n",
                                     pContext));
                    }
                } // set up linger

                if ( fShutdown ) {

                    //
                    //  Note that shutdown can fail in instances where the
                    //  client aborts in the middle of a TransmitFile.
                    //  This is an acceptable failure case
                    //

                    shutdown( HandleToUlong(hIO), 1 );
                }

                DBG_ASSERT( hIO != NULL);

                if ( closesocket( HandleToUlong(hIO)) ) {

                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[AtqCloseSocket] Warning- closesocket "
                                 " failed, Context = %08x, error %d,"
                                 " socket = %x\n",
                                 pContext,
                                 GetLastError(),
                                 hIO ));
                }
            } // if (hIO != NULL)
        }

        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "[AtqCloseSocket] Warning - NULL Atq context\n"));
    SetLastError( ERROR_INVALID_PARAMETER );
    return FALSE;
} // AtqCloseSocket()



BOOL
AtqCloseFileHandle(
    PATQ_CONTEXT patqContext
    )
/*++

  Routine Description:

    Closes the file handle in this atq structure.
    This function should be called only if the embedded handle
    in AtqContext is a file handle.

  Arguments:

    patqContext - Context whose file handle should be closed.

  Returns:
    TRUE on success and FALSE if there is a failure.

  Note:
   THIS FUNCTIONALITY IS ADDED TO SERVE A SPECIAL REQUEST!!!
   Most of the ATQ code thinks that the handle here is a socket.
   Except of course this function...
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    if ( pContext != NULL ) {

        HANDLE hIO;

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
        ATQ_ASSERT( !pContext->IsAcceptExRootContext());
        ATQ_ASSERT( !TsIsWindows95() );  // NYI

        hIO =
          (HANDLE ) InterlockedExchangePointer((PVOID *) &pContext->hAsyncIO,
                                               NULL);

        if ( (hIO == NULL) || !CloseHandle( hIO ) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                        "[AtqCloseFileHandle] Warning- CloseHandle failed, "
                        " Context = %08x, error %d, handle = %x\n",
                        pContext,
                        GetLastError(),
                        hIO ));
        }

        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "[AtqCloseSocket] Warning - NULL Atq context\n"));
    SetLastError( ERROR_INVALID_PARAMETER );
    return FALSE;
} // AtqCloseFileHandle()





VOID
AtqFreeContext(
    PATQ_CONTEXT patqContext,
    BOOL         fReuseContext
    )
/*++

Routine Description:

    Frees the context created in AtqAddAsyncHandle.
    Call this after the async handle has been closed and all outstanding
    IO operations have been completed. The context is invalid after this call.
    Call AtqFreeContext() for same context only ONCE.

Arguments:

    patqContext - Context to free
    fReuseContext - TRUE if this can context can be reused in the context of
        the calling thread.  Should be FALSE if the calling thread will exit
        soon (i.e., isn't an AtqPoolThread).

--*/
{
    PATQ_CONT pContext = (PATQ_CONT)patqContext;

    ATQ_ASSERT( pContext != NULL );

    IF_DEBUG( API_ENTRY) {

        ATQ_PRINTF(( DBG_CONTEXT, "AtqFreeContext( %08x (handle=%08x,"
                     " nIOs = %d), fReuse=%d)\n",
                     patqContext, patqContext->hAsyncIO,
                     pContext->m_nIO,
                     fReuseContext));
    }

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

#if 1
        //
        // !! DS change
        //
        //

        //
        //  If the socket is an AcceptEx socket, redo the AcceptEx and put
        //  it back on the in use list
        //

        PATQ_ENDPOINT pEndpoint = pContext->pEndpoint;

        //
        // If we have plenty of outstanding sockets (the number requested),
        // don't re-use this one.
        //

        if (pEndpoint != NULL) {
            if ( pEndpoint->nSocketsAvail >
                (LONG )(pEndpoint->nAcceptExOutstanding) ) {

                fReuseContext= FALSE;
            }
        }
#endif

        if ( fReuseContext ) {
            pContext->SetFlag( ACF_REUSE_CONTEXT);
        } else {
            pContext->ResetFlag( ACF_REUSE_CONTEXT);
        }

        if ( InterlockedDecrement(  &pContext->m_nIO) == 0) {

            //
            // The number of outstanding ref holders is ZERO.
            // Free up this ATQ context.
            //
            // We really do not free up the context - but try to reuse
            //  it if possible
            //

            DBG_ASSERT( pContext->lSyncTimeout == 0);
            AtqpReuseOrFreeContext( pContext, fReuseContext);
        }
    }

    return;
} // AtqFreeContext()



BOOL
AtqReadFile(
        IN PATQ_CONTEXT patqContext,
        IN LPVOID       lpBuffer,
        IN DWORD        BytesToRead,
        IN OVERLAPPED * lpo OPTIONAL
        )
/*++

  Routine Description:

    Does an async read using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    InterlockedIncrement( &pContext->m_nIO);

    I_SetNextTimeout(pContext);
    pContext->BytesSent = 0;

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    fRes = ( ReadFile( pContext->hAsyncIO,
                      lpBuffer,
                      BytesToRead,
                      &cbRead,
                      lpo ) ||
            GetLastError() == ERROR_IO_PENDING);

    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqReadFile()



BOOL
AtqReadSocket(
        IN PATQ_CONTEXT  patqContext,
        IN LPWSABUF     pwsaBuffers,
        IN DWORD        dwBufferCount,
        IN OVERLAPPED *  lpo OPTIONAL
        )
/*++

  Routine Description:

    Does an async recv using the handle defined in the context
     as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                 "AtqReadSocket(%08lx) called.\n", pContext));
    }

    if (pContext->IsFlag( ACF_RECV_ISSUED)) {
        IF_DEBUG( SPUD ) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqReadSocket -> WSARecv bypassed.\n"));
        }
        pContext->BytesSent = 0;
        pContext->SetFlag( ACF_RECV_CALLED);
        return TRUE;
    }

    I_SetNextTimeout(pContext);


    // count the number of bytes
    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = 0;

    InterlockedIncrement( &pContext->m_nIO);

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    DWORD  lpFlags = 0;

    fRes = ( (WSARecv( (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       &cbRead,
                       &lpFlags,  // no flags
                       lpo,
                       NULL       // no completion routine
                       ) == 0) ||
             (WSAGetLastError() == WSA_IO_PENDING));
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqReadSocket()



BOOL
AtqWriteFile(
    IN PATQ_CONTEXT patqContext,
    IN LPCVOID      lpBuffer,
    IN DWORD        BytesToWrite,
    IN OVERLAPPED * lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to write
    BytesToWrite - number of bytes to write
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( !TsIsWindows95() );  // NYI
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    I_SetNextTimeout(pContext);
    pContext->BytesSent = BytesToWrite;

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    fRes = ( WriteFile( pContext->hAsyncIO,
                        lpBuffer,
                        BytesToWrite,
                        &cbWritten,
                        lpo ) ||
             GetLastError() == ERROR_IO_PENDING);
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqWriteFile()



BOOL
AtqWriteSocket(
    IN PATQ_CONTEXT  patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN OVERLAPPED *  lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    I_SetNextTimeout(pContext);

    //
    // count the number of bytes
    //

    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf < (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( lpo == NULL ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    fRes = ( (WSASend( (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       &cbWritten,
                       0,               // no flags
                       lpo,
                       NULL             // no completion routine
                       ) == 0) ||
             (WSAGetLastError() == WSA_IO_PENDING));
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqWriteSocket()




BOOL
AtqSyncWsaSend(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    OUT LPDWORD      pcbWritten
    )
/*++

  Routine Description:

    Does a sync write of an array of wsa buffers using WSASend.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    pcbWritten - ptr to count of bytes written

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{

    BOOL fRes = FALSE;
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

    fRes = ( WSASend(  (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       pcbWritten,
                       0,               // no flags
                       NULL,            // lpo == NULL for sync write
                       NULL             // no completion routine
                       ) == 0);

    return fRes;

} // AtqSyncWsaSend()




BOOL
AtqTransmitFile(
    IN PATQ_CONTEXT            patqContext,
    IN HANDLE                  hFile,
    IN DWORD                   dwBytesInFile,
    IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN DWORD                   dwFlags
    )
/*++

  Routine Description:

    Does a TransmitFile  using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    hFile - handle of file to read from
    dwBytesInFile - Bytes to transmit
    lpTransmitBuffers - transmit buffer structure
    dwFlags - Transmit file flags

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
#if 0
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    //
    //  For large file sends, the client's default timeout may not be
    //  adequte for slow links.  Scale based on bytes being sent
    //

    I_SetNextTimeout(pContext);
    pContext->BytesSent = dwBytesInFile;

    if ( dwFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwFlags = TF_WRITE_BEHIND;

    } else if ( dwFlags & TF_DISCONNECT ) {

        //
        //  If the socket is getting disconnected, mark it appropriately
        //

        pContext->MoveState( ( ( dwFlags & TF_REUSE_SOCKET )?
                               ACS_SOCK_UNCONNECTED:
                               ACS_SOCK_CLOSED
                               )
                             );
    }

    InterlockedIncrement( &pContext->m_nIO);

    fRes = (TransmitFile( (SOCKET ) pContext->hAsyncIO,
                           hFile,
                           dwBytesInFile,
                           0,
                           &pContext->Overlapped,
                           lpTransmitBuffers,
                           dwFlags ) ||
            (GetLastError() == ERROR_IO_PENDING));
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

    //
    //  Restore the socket state if we failed so that the handle gets freed
    //

    if ( !fRes )
    {
        pContext->MoveState( ACS_SOCK_CONNECTED);
    }

    return fRes;
#else
    DBG_ASSERT(FALSE);
    return FALSE;
#endif
} // AtqTransmitFile()


BOOL
AtqReadDirChanges(IN PATQ_CONTEXT patqContext,
                  IN LPVOID       lpBuffer,
                  IN DWORD        BytesToRead,
                  IN BOOL         fWatchSubDir,
                  IN DWORD        dwNotifyFilter,
                  IN OVERLAPPED * lpo
                  )
/*++
  AtqReadDirChanges()

  Description:
    This function submits an Async ReadDirectoryChanges() call for
    the Async handle in the ATQ context supplied.
    It always requires a non-NULL overlapped pointer for processing
    this call.

  Arguments:
    patqContext  - pointer to ATQ Context
    lpBuffer     - buffer for the data to be read from ReadDirectoryChanges()
    BytesToRead  - count of bytes to read into buffer
    fWatchSubDir - should we watch for sub directory changes
    dwNotifyFilter - DWORD containing the flags for Notification
    lpo          - pointer to overlapped structure.

  Returns:
    TRUE if ReadDirectoryChanges() is successfully submitted.
    FALSE if there is any failure in submitting IO.
--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

#if 0
    if ( lpo == NULL ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    I_SetNextTimeout(pContext);
    pContext->BytesSent = 0;

    InterlockedIncrement( &pContext->m_nIO);
    fRes = ReadDirectoryChangesW( pContext->hAsyncIO,
                          lpBuffer,
                          BytesToRead,
                          fWatchSubDir,
                          dwNotifyFilter,
                          &cbRead,
                          lpo,
                          NULL);
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
#else
    return FALSE;
#endif
} // AtqReadDirChanges()



BOOL
AtqPostCompletionStatus(
        IN PATQ_CONTEXT patqContext,
        IN DWORD        BytesTransferred
        )
/*++

Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API

    NOTES:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

{
    BOOL fRes;
    PATQ_CONT  pAtqContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;

    ATQ_ASSERT( (pAtqContext)->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( !pAtqContext->IsBlocked()) {

        InterlockedIncrement( &pAtqContext->m_nIO);

        fRes = ( PostQueuedCompletionStatus( g_hCompPort,
                                          BytesTransferred,
                                          (DWORD_PTR) patqContext,
                                          &pAtqContext->Overlapped ) ||
                (GetLastError() == ERROR_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pAtqContext->m_nIO); };
    } else {

        //
        // Forcibly remove the context from blocking list.
        //

        fRes = pBandwidthInfo->RemoveFromBlockedList(pAtqContext);

        // There is a possibility of race conditions!
        //  If we cant remove an item from blocking list before
        //         its IO operation is scheduled.
        // there wont be any call back generated for this case!
    }

    return fRes;

} // AtqPostCompletionStatus



DWORD
I_AtqGetGlobalConfiguration(VOID)
/*++
Description:
   This function sets several global config params for the ATQ package.
   It also reads the global configuration from registry for ATQ.
   The values if present will override the defaults

Returns:
   Win32 Errorcode - NO_ERROR on success and anything else for error
--*/
{
    DWORD       dwError = NO_ERROR;
    DWORD       dwDefaultThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT;

    //
    // If this is a NTW, do the right thing
    //

    MEMORYSTATUS ms;

    //
    // get the memory size
    //

    ms.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus( &ms );

    //
    // attempt to use driver
    //

    g_fUseDriver = FALSE;

    //
    // Alloc two threads per MB of memory.
    //

    g_cMaxThreadLimit = (LONG)(ms.dwTotalPhys >> 19) + 2;

    if ( g_cMaxThreadLimit < ATQ_REG_MIN_POOL_THREAD_LIMIT ) {
        g_cMaxThreadLimit = ATQ_REG_MIN_POOL_THREAD_LIMIT;
    } else if ( g_cMaxThreadLimit > ATQ_REG_MAX_POOL_THREAD_LIMIT ) {
        g_cMaxThreadLimit = ATQ_REG_MAX_POOL_THREAD_LIMIT;
    }

    AtqSetInfo( AtqMaxConcurrency, ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY);
    AtqSetInfo( AtqUseAcceptEx, TRUE );
    AtqSetInfo( AtqMaxPoolThreads, ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS);
    AtqSetInfo( AtqThreadTimeout, ATQ_REG_DEF_THREAD_TIMEOUT);

    return ( dwError);
} // I_AtqGetGlobalConfiguration()



DWORD
I_NumAtqEndpointsOpen(VOID)
/*++
  Description:
    This function counts the number of Enpoints that remain open.

  Arguments:
     None

  Returns:
     DWORD containing the number of endpoints that are open.
--*/
{
    DWORD nEPOpen = 0;
    AcquireLock( &AtqEndpointLock);

    PLIST_ENTRY plEP;
    for( plEP  = AtqEndpointList.Flink;
         plEP != &AtqEndpointList;
         plEP  = plEP->Flink ) {

        nEPOpen++;
    } // for

    ReleaseLock( &AtqEndpointLock);
    return ( nEPOpen);
} // I_NumAtqEndpointsOpen()


#define WINSOCK_INIT_WAIT_TIME      (25 * 1000)  // 25 seconds
#define WINSOCK_INIT_WAIT_RETRIES   4



BOOL
WaitForWinsockToInitialize(
    VOID
    )
/*++

Routine Description:

    Spin until winsock comes up.

Arguments:

    None.

Return Value:

    TRUE if winsock is up. FALSE, if something bad happened.

--*/
{
    INT             err;
    WSADATA         wsaData;
    SOCKET          s = INVALID_SOCKET;
    SOCKADDR_IN     sockAddr;
    INT             retryCount = WINSOCK_INIT_WAIT_RETRIES;
    BOOL            fRet      = FALSE;
    BOOL            fTCP      = FALSE;
    BOOL            fSignaled = TRUE;
    BOOL            fAddr     = FALSE;
    DWORD           dwErr;
    DWORD           dwBytes;
    DWORD           cbMaxDGramSend;
    OVERLAPPED      Overlapped;
    HANDLE          hConfig = NULL;
    
    err = WSAStartup(MAKEWORD(2,0), &wsaData);
    if ( err != 0 ) {
        ATQ_PRINTF((DBG_CONTEXT,"err %d in WSAStartup\n", err));
        return FALSE;
    }
    
    Overlapped.hEvent = CreateEvent(NULL,   // default SD
                                    FALSE,  // auto reset the event
                                    FALSE,  // initialize as non signaled
                                    NULL);  // no name

    if (NULL == Overlapped.hEvent) {
        goto cleanup;
    }
    
    s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, NULL, WSA_FLAG_OVERLAPPED);
    if (INVALID_SOCKET != s) {
        
        fTCP = TRUE;
    
    } else {
        
        // TCP is not installed or setup.  Wait a reasonable amount of time for it
        // to be setup and then bail.

        // Get the initial handle so we will be sure and not miss it when/if
        // tcp is installed.  We don't need an overlapped structure for the 
        // first call since it will complete emediately.
        if (WSAProviderConfigChange(&hConfig, NULL, NULL)) {
            ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize WSAProviderConfigChange returned 0x%x\n", WSAGetLastError()));
            goto cleanup;
        }
        
        s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, NULL, WSA_FLAG_OVERLAPPED);
        if (INVALID_SOCKET != s) {

            fTCP = TRUE;
        }
        
        while (retryCount && !fTCP) {
                
            if (fSignaled) {
                err = WSAProviderConfigChange(&hConfig,
                                              &Overlapped, 
                                              NULL);

                if (err && (WSA_IO_PENDING != WSAGetLastError())) {
                    ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize ConfigChange failed with 0x%x\n", WSAGetLastError()));
                    goto cleanup;
                }
            }

            ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize waiting for socket . . .\n"));
            dwErr = WaitForSingleObject(Overlapped.hEvent, WINSOCK_INIT_WAIT_TIME);
            switch (dwErr) {
            default:
                // Something went pretty wrong here.
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize Failed at WaitForSingleObject with 0x%x\n", GetLastError()));
                goto cleanup;
            case WAIT_OBJECT_0:
                //
                // See if we have TCP now.
                //
                fSignaled = TRUE;
                s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, NULL, WSA_FLAG_OVERLAPPED);
                if (INVALID_SOCKET != s) {
                    //
                    // This will cause us to exit the retry loop
                    //
                    fTCP = TRUE;
                }
                break;
            case WAIT_TIMEOUT:
                // try again.  The event wasn't signaled so don't bother
                // calling WSAProviderConfigChange again.
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize waiting for TCP timed out.\n"));
                fSignaled = FALSE;
                break;
            }
            retryCount--;
        }
    }

    if (fTCP) {
        ATQ_ASSERT(TRUE == fSignaled);

        retryCount = WINSOCK_INIT_WAIT_RETRIES;
        
        // init sockAddr
        ZeroMemory(&sockAddr, sizeof(sockAddr));
        sockAddr.sin_family = AF_INET;
        sockAddr.sin_port = 0;
        sockAddr.sin_addr.s_addr = INADDR_ANY;

        err = bind(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr));
        if ( err != SOCKET_ERROR ) {

            fAddr = TRUE;
        
        } else {

            err = WSAIoctl(s,                                      
                           SIO_ADDRESS_LIST_CHANGE,
                           NULL,                // no input buffer
                           0,                   // size of input buffer
                           NULL,                // don't need an ouput buffer either
                           0,                   // size of out buffer
                           &dwBytes,            // bytes returned
                           &Overlapped,         // overlapped structure
                           NULL);               // no callback routine

            if (err && (WSAGetLastError() != WSA_IO_PENDING)) {
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize Failed at WSAIoctl with 0x%x\n", WSAGetLastError()));
                goto cleanup;
            }

            err = bind(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr));
            if ( err != SOCKET_ERROR ) {

                fAddr = TRUE;

            }

            while (retryCount && !fAddr) {

                ATQ_PRINTF(( DBG_CONTEXT, "WaitWinsockToInitialize waiting for address . . .\n"));
                dwErr = WaitForSingleObject(Overlapped.hEvent, WINSOCK_INIT_WAIT_TIME);
                switch (dwErr) {
                default:
                    // Something went pretty wrong here.
                    ATQ_PRINTF(( DBG_CONTEXT, "WaitWinsockToInitialize Failed at WaitForSingleObject with 0x%x\n", GetLastError()));
                    goto cleanup;
                case WAIT_OBJECT_0:
                    //
                    // Register for address change notification again so that
                    // nothing is missed in case there still aren't any TCP
                    // addresses.
                    //
                    err = WSAIoctl(s,                                      
                                   SIO_ADDRESS_LIST_CHANGE,
                                   NULL,                // no input buffer
                                   0,                   // size of input buffer
                                   NULL,                // don't need an ouput buffer either
                                   0,                   // size of out buffer
                                   &dwBytes,            // bytes returned
                                   &Overlapped,         // overlapped structure
                                   NULL);               // no callback routine

                    if (err && (WSA_IO_PENDING != WSAGetLastError())) {
                        ATQ_PRINTF(( DBG_CONTEXT, "WaitWinsockToInitialize Failed at WSAIoctl with 0x%x\n", WSAGetLastError()));
                        goto cleanup;
                    }

                    //
                    // See if we have an address to bind to now.
                    //
                    err = bind(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr));
                    if (SOCKET_ERROR != err) {
                        //
                        // This will cause us to exit the retry loop
                        //
                        fAddr = TRUE;
                    }
                    break;
                case WAIT_TIMEOUT:
                    // try again.  The event wasn't signaled so don't bother
                    // calling WSAIoctl again.
                    ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize waiting for addr's timed out.\n"));
                    break;
                }
                retryCount--;

            }     // while
        } // if err != SOCKET_ERROR
    } // if fTCP

    if (fTCP && fAddr) {
        SOCKET s2;
        INT    size = sizeof(cbMaxDGramSend);

        //
        // Set the return value as TRUE
        //
        fRet = TRUE;
        

        // record the largest possible datagram send.
        s2 = WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, NULL, NULL, 0);
        if ( s == INVALID_SOCKET) {

            err = WSAGetLastError();
            ATQ_PRINTF(( DBG_CONTEXT, "WSASocket failed with %d.\n", err));
        } else {
        
            err = getsockopt(s,
                             SOL_SOCKET,
                             SO_MAX_MSG_SIZE,
                             (PCHAR)&cbMaxDGramSend,
                             &size);

            if ( err == 0 ) {
                g_cbMaxDGramSend = cbMaxDGramSend;
                ATQ_PRINTF(( DBG_CONTEXT, "Setting g_cbMaxDGramSend to 0x%x\n", g_cbMaxDGramSend));
            } else {
                ATQ_PRINTF(( DBG_CONTEXT, "Cannot query max datagram size [err %d]\n",
                        WSAGetLastError()));
            }
            closesocket(s2);
        }
    }

cleanup:

    if (NULL != hConfig) {
        CloseHandle(hConfig);
    }
    
    if (INVALID_SOCKET != s) {
        closesocket(s);
    }

    if (NULL != Overlapped.hEvent) {
        CloseHandle(Overlapped.hEvent);
    }
        
    if (!fRet) {
        WSACleanup();
    }

    IF_DEBUG(ERROR) {
        if (!fRet) {
            if (!fTCP) {
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize there's no sockets.\n"));
            } else {
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize there's no ip addresses.\n"));
            }
        }
    }
    return fRet;
} // WaitForWinsockToInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\atqsupp.cxx ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

       atqsupp.cxx

   Abstract:

        Contains internal support routines for the ATQ package
        From atqnew.c

   Author:
        Murali R. Krishnan     (MuraliK)     02-Apr-1996

   Project:
        Internet Server Common DLL
--*/

#include "isatq.hxx"

typedef GUID UUID;

extern "C" {

#include <ntdsa.h>

}

DWORD AtqPoolThread( LPDWORD param );

VOID I_AtqThreadMonitor( IN PVOID NotUsed );

DWORD g_dwThreadMonitorCookie = 0;

extern PBANDWIDTH_INFO g_pBandwidthInfo;

# ifdef ENABLE_REUSE_THROTTLE

DWORD g_fAlwaysReuseSockets = TRUE;

# endif // ENABLE_REUSE_THROTTLE

//
// If this is true then no AtqPoolThreads have completed
// servicing an IO since the last time I_AtqThreadMonitor
// ran.
//
BOOL  g_fDeadManSwitch = FALSE;


/************************************************************
 * Functions for ATQ_CONTEXT
 ************************************************************/


PATQ_CONT
I_AtqAllocContextFromCache( VOID);

VOID
I_AtqFreeContextToCache(
            IN PATQ_CONT pAtqContext,
            IN BOOL UnlinkContext
            );
VOID
I_ResetListenSocket(
    IN PATQ_ENDPOINT pEndpoint
    );



PATQ_CONT
I_AtqAllocContextFromCache( VOID)
/*++
  This function attempts to allocate an ATQ context from the allocation cache.
  It then initializes the state information in the ATQ context object and
    returns the context on success.

  Arguments:
    None

  Returns:
    On success a valid pointer to ATQ_CONT. Otherwise NULL.

--*/
{
    PATQ_CONT  pAtqContext;

    DBG_ASSERT( NULL != g_pachAtqContexts);

    pAtqContext = (ATQ_CONTEXT * ) g_pachAtqContexts->Alloc();

    if ( NULL != pAtqContext ) {


        pAtqContext->ContextList =
            &AtqActiveContextList[(++AtqGlobalContextCount %
                                   g_dwNumContextLists)];

        pAtqContext->Signature = ATQ_CONTEXT_SIGNATURE;
    }

    return (pAtqContext);
} // I_AtqAllocContextFromCache()




VOID
I_AtqFreeContextToCache(
        IN PATQ_CONT pAtqContext
        )
/*++
  This function releases the given context to the allocation cache.

  Arguments:
    pAtqContext  pointer to the ATQ_CONTEXT that is being freed.

  Returns:
    None

  Issues:
    This function also performs some other cleanup specific to AtqContexts.
--*/
{

#if 0
      ATQ_PRINTF(( DBG_CONTEXT,
                 "[I_AtqFreeCtxtToCache] Freed up %08x\n",
                 pAtqContext
                 ));
#endif

    DBG_ASSERT( pAtqContext->Signature == ATQ_FREE_CONTEXT_SIGNATURE);
    DBG_ASSERT( pAtqContext->lSyncTimeout ==0);
    DBG_ASSERT( pAtqContext->m_nIO ==0);
    DBG_ASSERT( pAtqContext->m_acFlags == 0);
    DBG_ASSERT( pAtqContext->m_acState == 0);
    DBG_ASSERT( pAtqContext->m_leTimeout.Flink == NULL);
    DBG_ASSERT( pAtqContext->m_leTimeout.Blink == NULL);
    DBG_ASSERT( pAtqContext->pvBuff == NULL);
    DBG_ASSERT( pAtqContext->pEndpoint == NULL);
    DBG_ASSERT( pAtqContext->hAsyncIO == NULL);

    DBG_REQUIRE( g_pachAtqContexts->Free( pAtqContext));

    return;

} // I_AtqFreeContextToCache



void
ATQ_CONTEXT::Print( void) const
{
    DBGPRINTF(( DBG_CONTEXT,
                " ATQ_CONTEXT (%08x)\n"
                "\thAsyncIO            = %08lx   Signature        = %08lx\n"
                "\tOverlapped.Internal = %08lx   Overlapped.Offset= %08lx\n"
                "\tm_leTimeout.Flink   = %08lx   m_leTimeout.Blink= %08lx\n"
                "\tClientContext       = %08lx   ContextList      = %08lx\n"
                "\tpfnCompletion       = %08lx ()\n"
                "\tpEndPoint           = %08lx   fAcceptExContext = %s\n"
                "\tlSyncTimeout        = %8d     fInTimeout       = %s\n"

                "\tTimeOut             = %08lx   NextTimeout      = %08lx\n"
                "\tBytesSent           = %d (0x%08lx)\n"

                "\tpvBuff              = %08lx   JraAsyncIo       = %08lx\n"
                "\tfConnectionIndicated= %s      fBlocked         = %8lx\n"

                "\tState               = %8lx    Flags            = %8lx\n",
                this,
                hAsyncIO,
                Signature,
                Overlapped.Internal,
                Overlapped.Offset,
                m_leTimeout.Flink,
                m_leTimeout.Blink,
                ClientContext,
                ContextList,
                pfnCompletion,
                pEndpoint,
                (IsAcceptExRootContext() ? "TRUE" : "FALSE"),
                lSyncTimeout,
                (IsFlag( ACF_IN_TIMEOUT) ? "TRUE" : "FALSE"),
                TimeOut,
                NextTimeout,
                BytesSent,
                BytesSent,
                pvBuff,
                hJraAsyncIO,
                (IsFlag( ACF_CONN_INDICATED) ? "TRUE" : "FALSE"),
                IsBlocked(),
                m_acState, m_acFlags
                ));

    // Print the buffer if necessary.

    return;
} // ATQ_CONTEXT::Print()




VOID
ATQ_CONTEXT::HardCloseSocket( VOID)
/*++
  Description:
     This socket closes the socket by forcibly calling closesocket() on
     the socket. This function is used during the endpoint shutdown
     stage for an atq context

  Arguments:
     None

  Returns:
     None

--*/
{
    HANDLE haio = (HANDLE )
        InterlockedExchangePointer( (PVOID *) &hAsyncIO, NULL);

    DBG_ASSERT( IsState( ACS_SOCK_LISTENING) ||
                IsState( ACS_SOCK_CONNECTED) ||
                IsState( ACS_SOCK_CLOSED) ||
                IsState( ACS_SOCK_UNCONNECTED)
                );

    MoveState( ACS_SOCK_CLOSED);


    //
    //  Let us do a hard close on the socket (handle).
    //  This should generate an IO completion which will free this
    //     ATQ context
    //

    if ( !this->fDatagramContext ) {
        if ( (haio != NULL) &&
             (closesocket((SOCKET) haio) == SOCKET_ERROR)
             ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "Warning - "
                         " Context=%08x closesocket failed,"
                         " error %d, socket = %x\n",
                         this,
                         GetLastError(),
                         haio ));
            Print();
        }
    }

    return;
} // ATQ_CONTEXT::HardCloseSocket()



VOID
ATQ_CONTEXT::InitWithDefaults(
    IN ATQ_COMPLETION pfnCompletion,
    IN DWORD TimeOut,
    IN HANDLE hAsyncIO
    )
{
    DBG_ASSERT( this->Signature == ATQ_CONTEXT_SIGNATURE);

    this->InitTimeoutListEntry();

    this->Signature    = ATQ_CONTEXT_SIGNATURE;

     // start life at 1. This ref count will be freed up by AtqFreeContext()
    this->m_nIO = 1;

    this->pfnCompletion   = pfnCompletion;

    this->TimeOut         = TimeOut;
    this->TimeOutScanID   = 0;
    this->lSyncTimeout    = 0;

    this->hAsyncIO        = hAsyncIO;
    this->hJraAsyncIO     = HandleToUlong(hAsyncIO) | 0x80000000;

    this->m_acState       = 0;
    this->m_acFlags       = 0;

    this->fDatagramContext  = FALSE;

    // Initialize pbandwidthinfo to point to global object

    this->m_pBandwidthInfo  = g_pBandwidthInfo;

    ZeroMemory(
               &this->Overlapped,
               sizeof( this->Overlapped )
               );

    DBG_ASSERT( this->lSyncTimeout == 0);

    //
    // Following added for bandwidth throttling purposes
    //

    DBG_ASSERT( !this->IsBlocked());
    this->arInfo.atqOp    = AtqIoNone;
    this->arInfo.lpOverlapped = NULL;
    // bandwidth throttling initialization ends here.

} // ATQ_CONTEXT::InitWithDefaults()




VOID
ATQ_CONTEXT::InitNonAcceptExState(
    IN PVOID pClientContext
    )
{
    //
    //  Note that if we're not using AcceptEx, then we consider the client
    //  to have been notified externally (thus ACF_CONN_INDICATED is set).
    //  Also we set the next timeout to be infinite, which may be reset
    //   when the next IO is submitted.
    //

    this->NextTimeout          = ATQ_INFINITE;
    this->ClientContext        = pClientContext;
    this->pEndpoint            = NULL;
    this->SetFlag( ACF_CONN_INDICATED);
    this->SetState( ACS_SOCK_CONNECTED);
    this->ResetFlag( ACF_ACCEPTEX_ROOT_CONTEXT);

    //
    // Insert this into the active list - since this is a non-acceptex socket
    //

    DBG_ASSERT( this->ContextList != NULL);
    this->ContextList->InsertIntoActiveList( &this->m_leTimeout );

    return;

} // ATQ_CONTEXT::InitNonAcceptExState()



VOID
ATQ_CONTEXT::InitAcceptExState(
            IN DWORD NextTimeOut
            )
{
    this->NextTimeout          = NextTimeOut;
    this->ClientContext        = NULL;
    this->lSyncTimeout         = 0;

    this->ResetFlag( ACF_CONN_INDICATED);
    this->SetState( ACS_SOCK_LISTENING);

    //
    //  Add it to the pending accept ex list
    //
    DBG_ASSERT( this->ContextList != NULL);

    this->ContextList->InsertIntoPendingList( &this->m_leTimeout);

    return;
} // ATQ_CONTEXT::InitAcceptExState()



BOOL
ATQ_CONTEXT::PrepareAcceptExContext(
    PATQ_ENDPOINT          pEndpoint
    )
/*++

Routine Description:

    Initializes the state for completely initializing the state and
    hence prepares the context for AcceptEx

    It expects the caller to send a AtqContext with certain characteristics
      1) this is not NULL
      2) this->pvBuff has valid values

    In the case of failure, caller should call
     pAtqContext->CleanupAndRelese() to free the memory associated with
     this object.

Arguments:

    pEndpoint     - pointer to endpoint object for this context

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

    The caller should free the object on a failure.

--*/
{
    DBG_ASSERT( g_fUseAcceptEx); // only support AcceptEx() cases
    DBG_ASSERT( pEndpoint != NULL);
    DBG_ASSERT( this != NULL);
    DBG_ASSERT( this->pvBuff != NULL);

    //
    //  Make sure that we are adding a AcceptEx() version of AtqContext
    //

    DBG_ASSERT( pEndpoint->ConnectExCompletion != NULL);
    DBG_ASSERT( pEndpoint->UseAcceptEx);

    //
    //  Fill out the context.  We set NextTimeout to INFINITE
    //  so the timeout thread will ignore this entry until an IO
    //  request is made unless this is an AcceptEx socket, that means
    //  we're about to submit the IO.
    //

    this->
        InitWithDefaults(
                         pEndpoint->IoCompletion,
                         pEndpoint->AcceptExTimeout, // canonical Timeout
                         this->hAsyncIO
                         );


    //
    // TBD: What is the circumstance in which this->pEndpoint!= NULL?
    //

    if ( this->pEndpoint == NULL ) {
        pEndpoint->Reference();
        this->pEndpoint  = pEndpoint;
    }

    this->InitDatagramState( );

    this->ResetFlag( ACF_ACCEPTEX_ROOT_CONTEXT );

    this->InitAcceptExState( AtqGetCurrentTick() + TimeOut);

    DBG_ASSERT( this->pvBuff != NULL);

    return (TRUE);

} // ATQ_CONTEXT::PrepareAcceptExContext()




VOID
ATQ_CONTEXT::CleanupAndRelease( VOID)
/*++
  Routine Description:
     This function does the cleanup of the ATQ context. It does not
     attempt to do any reuse of the atq context. After cleanup
     the context is freed to the ATQ pool. Supplied context
     is not valid after calling this function.

  Arguments:
     None

  Returns:
     None
--*/
{
    DBG_ASSERT( this->m_nIO == 0);

    //
    //  Cleanup and free the ATQ Context entirely
    //

    if ( this->hAsyncIO != NULL ) {

        // It is too dangerous to assume that the handle is a socket!
        // But we will do that for fast-pathing IIS operations.

        SOCKET hIO =
            (SOCKET ) InterlockedExchangePointer( (PVOID *) &this->hAsyncIO,
                                                  NULL);
        //
        // no cleanups for datagram
        //

        if ( !this->fDatagramContext ) {

            if ( hIO != NULL &&
                 (closesocket( hIO ) == SOCKET_ERROR ) ) {

                ATQ_PRINTF(( DBG_CONTEXT,
                             "ATQ_CONTEXT(%08x)::CleanupAndRelease() : Warning"
                             " - Context=%08x, "
                             " closesocket failed, error %d, socket = %x\n",
                             this,
                             GetLastError(),
                             hIO ));
                this->Print();
            }
        }
    }

    DBG_ASSERT( this->hAsyncIO == NULL);

    if ( this->pvBuff != NULL ) {
        LocalFree( this->pvBuff );
        this->pvBuff = NULL;
    }

    //
    // Unlink from the list
    //

    DBG_ASSERT( this->ContextList != NULL);

    // NYI: Can I avoid this comparison?
    //
    // Check if this context is part of a timeout list.
    // If it is then remove it from the list
    // Only during shutdown code path, we will see trouble here.
    //
    if ( this->m_leTimeout.Flink != NULL ) {
        this->ContextList->RemoveFromList( &this->m_leTimeout);
    }

    //
    //  Deref the listen info if this context is associated with one
    //

    if ( this->pEndpoint != NULL ) {
        this->pEndpoint->Dereference();
        this->pEndpoint = NULL;
    }

    this->Signature    = ATQ_FREE_CONTEXT_SIGNATURE;
    this->lSyncTimeout = 0;
    this->m_acState    = 0;
    this->m_acFlags    = 0;

    I_AtqFreeContextToCache( this);

    return;
} // ATQ_CONTEXT::CleanupAndRelease()





inline VOID
DBG_PRINT_ATQ_SPUDCONTEXT( IN PATQ_CONT  pAtqContext,
                           IN PSPUD_REQ_CONTEXT reqContext)
{
    ATQ_PRINTF(( DBG_CONTEXT,
                 "[AtqPoolThread] pAtqContext = %08lx\n"
                 "[AtqPoolThread] IoStatus1.Status = %08lx\n"
                 "[AtqPoolThread] IoStatus1.Information = %08lx\n"
                 "[AtqPoolThread] IoStatus2.Status = %08lx\n"
                 "[AtqPoolThread] IoStatus2.Information = %08lx\n"
                 ,
                 pAtqContext,
                 reqContext->IoStatus1.Status,
                 reqContext->IoStatus1.Information,
                 reqContext->IoStatus2.Status,
                 reqContext->IoStatus2.Information
                 ));
    return;
} // DBG_PRINT_ATQ_SPUDCONTEXT()


VOID
AtqpUpdateBandwidth( IN PATQ_CONT  pAtqContext,
                    IN DWORD      cbWritten)
{
    PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;

    DBG_ASSERT( pBandwidthInfo != NULL );
    DBG_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    // add the bandwidth info to active list if necessary

    pBandwidthInfo->AddToActiveList();

    //this will have problems when we use XmitFile for large files.

    pBandwidthInfo->UpdateBytesXfered( pAtqContext, cbWritten );
} // AtqpUpdateBandwidth()


VOID
AtqpCallOplockCompletion( IN PATQ_CONT pAtqContext,
                          IN DWORD cbWritten)
{
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion;
    PVOID OplockContext;
    POPLOCK_INFO pOplock;

    IF_DEBUG( SPUD) {
        DBGPRINTF(( DBG_CONTEXT,
                    "CallOplockCompletion on OpLockInfo=%08x.cbWritten = %d\n",
                    (POPLOCK_INFO ) pAtqContext, cbWritten));
    }

    //
    // The ATQ context object received is a fake one. We actually get
    //  back POPLOCK_INFO object that is used to extract the callback
    //  function & context for the callback
    //

    pOplock = (POPLOCK_INFO)pAtqContext;
    pfnOplockCompletion = (ATQ_OPLOCK_COMPLETION)pOplock->pfnOplockCompletion;
    OplockContext = (PVOID)pOplock->Context;

    LocalFree(pOplock);


    (*pfnOplockCompletion)(OplockContext, (DWORD)cbWritten);
    return;

} // AtqpCallOplockCompletion()



VOID
AtqpProcessContext( IN PATQ_CONT  pAtqContext,
                    IN DWORD      cbWritten,
                    IN LPOVERLAPPED lpo,
                    IN BOOL       fRet)
{
    BOOL fDriverCall = FALSE;
    BOOL fRecvCalled = FALSE;
    PSPUD_REQ_CONTEXT  reqContext = NULL;
    DWORD dwError;

    DBG_ASSERT( pAtqContext != NULL);

    //
    // Check to see if this is a completion request from the
    // NTS kernel driver.
    //

    if ( lpo == NULL ) {

        if ( cbWritten == 0xffffffff ) {

            //
            // One of the SPUD's IO completion. Handle it appropriately.
            //

            reqContext = (PSPUD_REQ_CONTEXT)pAtqContext;

            pAtqContext = CONTAINING_RECORD( reqContext, ATQ_CONTEXT,
                                             spudContext );

            IF_DEBUG( SPUD) {
                DBG_PRINT_ATQ_SPUDCONTEXT( pAtqContext, reqContext);
            }
#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of all non-oplock notification.
            // This is for debugging purpose only.
            //
            // Code 0xfcfcfcfc indicates a SPUD I/O Completion
            //

            pAtqContext->NotifyIOCompletion( cbWritten, reqContext->IoStatus1.Status, 0xfcfcfcfc );
#endif

            cbWritten = (DWORD)reqContext->IoStatus1.Information;
            fRet = (reqContext->IoStatus1.Status == STATUS_SUCCESS);
            SetLastError(RtlNtStatusToDosError(reqContext->IoStatus1.Status));

            lpo = &pAtqContext->Overlapped;

            //
            // If the TransmitFile fails then the receive is not issued.
            //

            if ( fRet ) {
                fDriverCall = TRUE;
            } else {
                DBG_ASSERT( fDriverCall == FALSE);
                pAtqContext->ResetFlag( ACF_RECV_ISSUED);
            }
        } else {

            //
            // An Oplock notification - handle it via oplock path.
            //

            AtqpCallOplockCompletion( pAtqContext, cbWritten);
            return;
        }
    }

    dwError = (fRet) ? NO_ERROR: GetLastError();

    //
    //  If this is an AcceptEx listen socket atq completion, then the
    //  client Atq context we really want is keyed from the overlapped
    //  structure that is stored in the client's Atq context.
    //

    if ( pAtqContext->IsAcceptExRootContext() || pAtqContext->fDatagramContext ) {

        pAtqContext = CONTAINING_RECORD( lpo, ATQ_CONTEXT, Overlapped );

    }


#if CC_REF_TRACKING
    //
    // ATQ notification trace
    //
    // Notify client context of all non-oplock notification.
    // This is for debugging purpose only.
    //

    pAtqContext->NotifyIOCompletion( cbWritten, (fRet) ? NO_ERROR: GetLastError(), 0xfefefefe );
#endif

    DBG_CODE(
             if ( ATQ_CONTEXT_SIGNATURE != pAtqContext->Signature) {
                 pAtqContext->Print();
                 DBG_ASSERT( FALSE);
             });


    //
    //  m_nIO also acts as the reference count for the atq contexts
    //  So, increment the count now, so that there is no other thread
    //   that will free up this ATQ context accidentally.
    //

    InterlockedIncrement( &pAtqContext->m_nIO);

    //
    // Busy wait for timeout processing to complete!
    //  This is ugly :( A fix in time for IIS 2.0/Catapult 1.0 release
    //

    InterlockedIncrement(  &pAtqContext->lSyncTimeout);
    while ( pAtqContext->IsFlag( ACF_IN_TIMEOUT)) {

        AcIncrement( CacAtqWaitsForTimeout);

        Sleep( ATQ_WAIT_FOR_TIMEOUT_PROCESSING);
    };

    //
    //  We need to make sure the timeout thread doesn't time this
    //  request out so reset the timeout value
    //

    InterlockedExchange( (LPLONG )&pAtqContext->NextTimeout,
                         (LONG ) ATQ_INFINITE);

    //
    // Update Bandwidth information on successful completion, if needed
    //

    if ( BANDWIDTH_INFO::GlobalEnabled() && fRet && cbWritten > 0)
    {
        AtqpUpdateBandwidth( pAtqContext, cbWritten);
    }

    //
    // Since the IO completion means that one of the async operation finished
    //  decrement our internal ref count appropriately to balance the addition
    //  when the IO operation was submitted.
    //
    InterlockedDecrement( &pAtqContext->m_nIO);

    //
    //  Is this a connection indication?
    //

    if ( !pAtqContext->IsFlag( ACF_CONN_INDICATED) &&
         !pAtqContext->fDatagramContext ) {

        PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

        if ( NULL == pEndpoint) {
            pAtqContext->Print();
            OutputDebugString( "Found an ATQ context with bad Endpoint\n");
            DBG_ASSERT( FALSE);
            DBG_REQUIRE( InterlockedDecrement(  &pAtqContext->lSyncTimeout) == 0);
            InterlockedDecrement( &pAtqContext->m_nIO); // balance entry count
            return;
        }

        DBG_ASSERT( pEndpoint != NULL );

        //
        //  Indicate this socket is in use
        //

        InterlockedDecrement( &pEndpoint->nSocketsAvail );

        //
        //  If we're running low on sockets, add some more now
        //

        if ( pEndpoint->nSocketsAvail <
             (LONG )(pEndpoint->nAcceptExOutstanding >> 2) ) {

            AcIncrement( CacAtqPrepareContexts);

            (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                pEndpoint->nAcceptExOutstanding
                                                );
        }

        //
        //  If an error occurred on this completion,
        //    shutdown the socket
        //

        if ( !fRet ) {

            IF_DEBUG( ERROR) {
                if ( dwError != ERROR_OPERATION_ABORTED ) {
                    ATQ_PRINTF(( DBG_CONTEXT,
                                 " Free Context(%08x, EP=%08x) to cache. "
                                 "Err=%d, sock=%08x\n",
                                 pAtqContext, pEndpoint,
                                 dwError,
                                 pAtqContext->hAsyncIO));
                }
            }

            DBG_REQUIRE( InterlockedDecrement(  &pAtqContext->lSyncTimeout) == 0);

            InterlockedDecrement( &pAtqContext->m_nIO); // balance entry count

            // balance original count
            InterlockedDecrement( &pAtqContext->m_nIO);
            // Free up the atq context without Reuse
            pAtqContext->CleanupAndRelease();
            return;
        }

        //
        //  Shutdown may close the socket from underneath us so don't
        //  assert, just warn.
        //

        if ( !pAtqContext->IsState( ACS_SOCK_LISTENING) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "[AtqPoolThread] Warning-Socket state not listening\n"
                         ));
            DBG_CODE( pAtqContext->Print());
        }

        pAtqContext->MoveState( ACS_SOCK_CONNECTED);

        //
        // Remove the context from the pending list and put
        // it on the active list
        //

        DBG_ASSERT( pAtqContext->ContextList != NULL);
        pAtqContext->ContextList->MoveToActiveList( &pAtqContext->m_leTimeout);

        //
        //  Set the connection indicated flag.  After we return from
        //  the connection completion routine we assume it's
        //  safe to call the IO completion routine
        //  (or the connection indication routine should do cleanup
        //  and never issue an IO request).  This is primarily for
        //  the timeout thread.
        //

        pAtqContext->ConnectionCompletion( cbWritten, lpo);
    } else {


        //
        //  Not a connection completion indication. I/O completion.
        //

        //
        //  If an error occurred on a TransmitFile (or other IO),
        //  set the state to connected so the socket will get
        //  closed on cleanup
        //

        if ( !fRet &&
             pAtqContext->IsState( ACS_SOCK_UNCONNECTED)
             ){
            pAtqContext->MoveState( ACS_SOCK_CONNECTED);
        }

#if 0
        if (fDriverCall) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "[AtqPoolThread] pfnCompletion1(%08lx)\n",
                         pAtqContext ));
        }
#endif

        //
        // !!! DS
        // Indicate that we have completed a datagram context
        //

        if ( !pAtqContext->IsFlag( ACF_CONN_INDICATED) ) {

            PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

            pAtqContext->SetFlag( ACF_CONN_INDICATED);
            if ( pEndpoint != NULL ) {

                ATQ_ASSERT(pAtqContext->fDatagramContext);

                //
                // Decrement the in-use count here for
                //

                InterlockedDecrement( &pEndpoint->nSocketsAvail );

                //
                //  If we're running low on sockets, add some more now
                //

                if ( pEndpoint->nSocketsAvail <
                     (LONG )(pEndpoint->nAcceptExOutstanding >> 2) ) {

                    (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                        pEndpoint->nAcceptExOutstanding
                                                        );
                }
            }
        }

        pAtqContext->IOCompletion( cbWritten, dwError, lpo);

        if (fDriverCall) {
            pAtqContext->ResetFlag( ACF_RECV_ISSUED);
            fRet = (reqContext->IoStatus2.Status == STATUS_SUCCESS);
            SetLastError( RtlNtStatusToDosError(
                                         reqContext->IoStatus2.Status));

            //
            //  If an error occurred on a TransmitFile (or other IO),
            //  set the state to connected so the socket will get
            //  closed on cleanup
            //

            if ( !fRet &&
                 pAtqContext->IsState( ACS_SOCK_UNCONNECTED) ) {
                pAtqContext->MoveState( ACS_SOCK_CONNECTED);
            }

#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of status after 1st notification
            // This is for debugging purpose only.
            //
            // Code 0xfafafafa means we're processing a recv that
            // SPUD combined with another notification
            //

            pAtqContext->NotifyIOCompletion( pAtqContext->m_acFlags, reqContext->IoStatus1.Status, 0xfafafafa );
#endif
            if ( pAtqContext->IsFlag( ACF_RECV_CALLED ) ) {
                fRecvCalled = TRUE;
                pAtqContext->ResetFlag( ACF_RECV_CALLED);
            }

            if ((reqContext->IoStatus1.Status == STATUS_SUCCESS) &&
                (pAtqContext->ClientContext != NULL) &&
                fRecvCalled ) {

#if CC_REF_TRACKING
                //
                // ATQ notification trace
                //
                // Notify client context of all non-oplock notification.
                // This is for debugging purpose only.
                //
                // Code 0xfdfdfdfd means we're processing a recv that
                // SPUD combined with another notification
                //

                pAtqContext->NotifyIOCompletion( cbWritten, (fRet) ? NO_ERROR: GetLastError(), 0xfdfdfdfd );
#endif


                IF_DEBUG( SPUD) {

                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[AtqPoolThread] pfnCompletion2(%08lx)\n",
                                 pAtqContext ));
                };

                pAtqContext->IOCompletion( (DWORD)reqContext->IoStatus2.Information,
                                        (fRet) ? NO_ERROR : GetLastError(),
                                        lpo
                                        );
            }
        }
    }

    DBG_ASSERT( pAtqContext->lSyncTimeout > 0);
    InterlockedDecrement( &pAtqContext->lSyncTimeout);

    //
    // We do an interlocked decrement on m_nIO to sync up state
    //  so that the context is not prematurely deleted.
    //

    if ( InterlockedDecrement(  &pAtqContext->m_nIO) == 0) {

        //
        // The number of outstanding ref holders is ZERO.
        // Free up this ATQ context.
        //
        // We really do not free up the context - but try to reuse
        //  it if possible
        //

        // free the atq context now or reuse if possible.
        AtqpReuseOrFreeContext( pAtqContext,
                                (pAtqContext->
                                 IsFlag( ACF_REUSE_CONTEXT) != 0)
                                );
    }

    return;
} // AtqpProcessContext()



DWORD
AtqPoolThread(
    LPDWORD ThreadType
    )
/*++

Routine Description:

    This is the pool thread wait and dispatch routine

  Arguments:
    ThreadType : Indicates whether this is the initial pool thread, 
    a temp thread, or just a joe blow pool thread.

  Return Value:

    Thread return value (ignored)

--*/
{
    PATQ_CONT    pAtqContext;
    BOOL         fRet;
    LPOVERLAPPED lpo;
    DWORD        cbWritten;
    DWORD        returnValue = NO_ERROR;
    DWORD        availThreads;
    DWORD        dwIOsServiced;


    AtqUpdatePerfStats(AtqConsumerAtq, FLAG_COUNTER_SET, g_cThreads);

    for (;;) {

        pAtqContext = NULL;
        InterlockedIncrement( &g_cAvailableThreads );

        fRet = GetQueuedCompletionStatus( g_hCompPort,
                                          &cbWritten,
                                          (PDWORD_PTR)&pAtqContext,
                                          &lpo,
                                          g_msThreadTimeout );

        availThreads = InterlockedDecrement( &g_cAvailableThreads );

        if ( fRet || lpo ) {

            if ( pAtqContext == NULL) {
                if ( g_fShutdown ) {

                    //
                    // This is our signal to exit.
                    //

                    returnValue = NO_ERROR;
                    break;
                }

                OutputDebugString( "A null context received\n");
                continue;  // some error in the context has occured.
            }

            //
            // Make sure we're not running out of threads
            //

            if ( availThreads == 0 ) {

                //
                //  Make sure there are pool threads to service the request
                //

                (VOID)I_AtqCheckThreadStatus( NULL );
            }

            AtqpProcessContext( pAtqContext, cbWritten, lpo, fRet);

            // Clear the dead man switch
            g_fDeadManSwitch = FALSE;
        } else {

            //
            // don't kill the initial thread
            //

            if ( ((DWORD_PTR)ThreadType == ATQ_INITIAL_THREAD) && !g_fShutdown ) {
                continue;
            }

            //
            //  An error occurred.  Either the thread timed out, the handle
            //  is going away or something bad happened.  Let the thread exit.
            //

            returnValue = GetLastError();

            break;
        }

    } // for

    if ( NULL != g_pfnExitThreadCallback) {

        //
        //  Client wishes to be told when ATQ threads terminate.
        //

        g_pfnExitThreadCallback();
    }

    if ( InterlockedDecrement( &g_cThreads ) == 0 ) {

        //
        // Wake up ATQTerminate()
        //
        IF_DEBUG( ERROR) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqPoolThread() - setting shutdown event %08x."
                         " g_cThreads = %d\n",
                         g_hShutdownEvent, g_cThreads
                         ));
        }

        SetEvent( g_hShutdownEvent );
    }

    AtqUpdatePerfStats(AtqConsumerAtq, FLAG_COUNTER_SET, g_cThreads);

    return returnValue;
} // AtqPoolThread




BOOL
I_AtqCheckThreadStatus(
    PVOID Context
    )
/*++

Routine Description:

    This routine makes sure there is at least one thread in
    the thread pool.  We're fast and loose so a couple of extra
    threads may be created.

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    BOOL fRet = TRUE;

    //
    //  If no threads are available, kick a new one off up to the limit
    //
    //  WE NEED TO CHANGE THE CONDITIONS FOR STARTING ANOTHER THREAD
    //  IT SHOULD NOT BE VERY EASY TO START A THREAD ....
    //

    if ( (g_cAvailableThreads == 0) &&
         (g_cThreads < g_cMaxThreads) &&
         (g_cThreads < g_cMaxThreadLimit) ) {

        HANDLE hThread;
        DWORD  dwThreadID;

        InterlockedIncrement( &g_cThreads );

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AtqPoolThread,
                                Context,
                                0,
                                &dwThreadID );

        if ( hThread ) {
            CloseHandle( hThread );     // Free system resources
        } else {

            //
            // We fail if there are no threads running
            //

            if ( InterlockedDecrement( &g_cThreads ) == 0) {
                ATQ_PRINTF(( DBG_CONTEXT,
                    "AtqCheckThread: Cannot create ATQ threads\n"));
                fRet = FALSE;
            }
        }
    }

    return fRet;
} // I_AtqCheckThreadStatus()



/************************************************************
 *  Functions to Add/Delete Atq Contexts
 ************************************************************/


BOOL
I_AtqAddAsyncHandle(
    IN OUT PATQ_CONT  *    ppAtqContext,
    IN PATQ_ENDPOINT       pEndpoint,
    PVOID                  ClientContext,
    ATQ_COMPLETION         pfnCompletion,
    DWORD                  TimeOut,
    HANDLE                 hAsyncIO
    )
/*++

  Description:
    This functio adds creates a new NON-AcceptEx() based Atq Context,
     and includes it in proper lists fo ATQ Context management.


  Note:
    The client should call this after the IO handle is openned
    and before the first IO request is made

    Even in the case of failure, client should call AtqFreeContext() and
     free the memory associated with this object.

--*/
{
    BOOL         fReturn = TRUE;

    DBG_ASSERT( ppAtqContext != NULL);
    DBG_ASSERT( ClientContext != NULL);

    *ppAtqContext = NULL; // initialize

    if ( g_fShutdown) {

        SetLastError( ERROR_NOT_READY);
        return (FALSE);

    } else {

        PATQ_CONT    pAtqContext;

        //
        //  Note we take and release the lock here as we're
        //  optimizing for the reuseable context case
        //

        pAtqContext = I_AtqAllocContextFromCache();
        if ( pAtqContext == NULL) {

            return (FALSE);
        }

        //
        //  Fill out the context.  We set NextTimeout to INFINITE
        //  so the timeout thread will ignore this entry until an IO
        //  request is made unless this is an AcceptEx socket, that means
        //  we're about to submit the IO.
        //


        pAtqContext->InitWithDefaults(pfnCompletion,
                                      CanonTimeout( TimeOut ), hAsyncIO);

        //
        //  These data members are used if we're doing AcceptEx processing
        //

        pAtqContext->SetAcceptExBuffer( NULL);

        pAtqContext->InitNonAcceptExState(ClientContext);

        //
        // If an endpoint is provided, reference it
        //

        if ( pEndpoint != NULL ) {
            pEndpoint->Reference();
            pAtqContext->pEndpoint = pEndpoint;
        }

        *ppAtqContext = pAtqContext;
    }

    return (TRUE);

} // I_AtqAddAsyncHandle()




BOOL
I_AtqAddListenEndpointToPort(
    IN OUT PATQ_CONT    * ppAtqContext,
    IN PATQ_ENDPOINT    pEndpoint
    )
/*++

  Description:
    This function creates a new AtqContext for the given ListenSocket.
    It uses the listen socket as the AcceptEx() socket too for adding
     the atq context to the completion port.
    It assumes
      TimeOut to be INFINITE, with no Endpoint structure.

  Arguments:
    ppAtqContext - pointer to location that will contain the atq context
                   on successful return.
    pEndpoint - pointer to the endpoint.

  Returns:
    TRUE on success
    FALSE if there is a failure.

  Note:
    The caller should free the *ppAtqContext if there is a failure.

--*/
{
    BOOL         fReturn = TRUE;
    PATQ_CONT    pAtqContext;

    DBG_ASSERT( g_fUseAcceptEx); // only support AcceptEx() cases

    *ppAtqContext = NULL; // initialize

    if ( g_fShutdown) {

        SetLastError( ERROR_NOT_READY);
        return (FALSE);

    } else {

        //
        //  Note we take and release the lock here as we're
        //  optimizing for the reuseable context case
        //

        pAtqContext = I_AtqAllocContextFromCache();

        if ( pAtqContext == NULL) {

            return (FALSE);
        }

        //
        //  Fill out the context.
        //  We set the TimeOut for this object to be ATQ_INFINITE,
        //   since we do not want any interference from the Timeout loop.
        //

        pAtqContext->InitWithDefaults(
                                      pEndpoint->IoCompletion,
                                      ATQ_INFINITE,
                                      (HANDLE)pEndpoint->ListenSocket
                                      );

        //
        //  These data members are used if we're doing AcceptEx processing
        //


        pAtqContext->SetAcceptExBuffer( NULL);

        //
        // Among AcceptEx ATQ Contexts,
        //  only the listen ATQ context will have the Endpoint field as NULL
        //
        pAtqContext->pEndpoint       = NULL;
        pAtqContext->SetFlag( ACF_ACCEPTEX_ROOT_CONTEXT );

        //
        // We set NextTimeout to INFINITE
        //  so the timeout thread will ignore this entry until an IO
        //  request is made unless this is an AcceptEx socket, that means
        //  we're about to submit the IO.

        DBG_ASSERT( g_fUseAcceptEx && pEndpoint->ConnectExCompletion != NULL);

        pAtqContext->InitAcceptExState( ATQ_INFINITE);

        *ppAtqContext = pAtqContext;
    }

    fReturn = I_AddAtqContextToPort( pAtqContext);

    return (fReturn);

} // I_AtqAddListenEndpointToPort()



BOOL
I_AtqAddAcceptExSocket(
    IN PATQ_ENDPOINT          pEndpoint,
    IN PATQ_CONT              pAtqContext
    )
/*++

Routine Description:

    Adds the AtqContext to the AcceptEx() waiters list,
    after allocating a new socket, since pAtqContext->hAsyncIO = NULL.

Arguments:

    pEndpoint - Information about this listenning socket
    patqReusedContext - optional context to use

Return Value:

    TRUE on success, FALSE on failure.
    On failure the caller should free the pAtqContext

--*/
{
    BOOL   fAddToPort = FALSE;
    BOOL   fSuccess = TRUE;

    DBG_ASSERT( pAtqContext != NULL);
    DBG_ASSERT( pAtqContext->pvBuff != NULL);
    DBG_ASSERT( !TsIsWindows95() );

    //
    //  If this listen socket isn't accepting new connections, just return
    //

    if ( !IS_BLOCK_ACTIVE(pEndpoint) ) {

        SetLastError( ERROR_NOT_READY );
        return ( FALSE);
    }

    //
    //  Use the supplied socket if any.
    //  Otherwise create a new socket
    //

    if ( pAtqContext->hAsyncIO == NULL) {

        HANDLE sAcceptSocket;

        sAcceptSocket = (HANDLE )
#if WINSOCK11
            socket(
                   AF_INET,
                   SOCK_STREAM,
                   IPPROTO_TCP
                   );
#else
        WSASocketW(
                   AF_INET,
                   SOCK_STREAM,
                   IPPROTO_TCP,
                   NULL,  // protocol info
                   0,     // Group ID = 0 => no constraints
                   (g_fUseFakeCompletionPort ?
                    0:
                    WSA_FLAG_OVERLAPPED // completion port notifications
                    )
                   );
#endif // WINSOCK11

        if ( (SOCKET ) sAcceptSocket == INVALID_SOCKET ) {

            fSuccess = FALSE;
            sAcceptSocket = NULL;

            //
            // no need to unlink from any list, since we did not add it to any
            //

        } else {

            //
            // Setup the accept ex socket in the atq context.
            //

            pAtqContext->hAsyncIO = sAcceptSocket;
            pAtqContext->hJraAsyncIO  = HandleToUlong(sAcceptSocket) | 0x80000000;
            fAddToPort = TRUE;
            DBG_ASSERT( fSuccess);
        }
    }

    if ( fSuccess) {

        DWORD        cbRecvd;

        if ( g_fShutdown) {

            //
            // no need to unlink from any list, since we did not add it to any
            //

            SetLastError( ERROR_NOT_READY);
            return (FALSE);
        }

        DBG_ASSERT( pAtqContext->hAsyncIO != NULL);

        //
        // 1. Call I_AtqAddAsyncHandleEx() to establish the links with
        //  proper AcceptEx & AtqContext processing lists.
        //
        //  After 1, the atqcontext will be in the lists, so
        //    cleanup should remove the context from proper lists.
        //
        // 2. Add the socket to Completion Port (if new),
        //    i.e. if fAddToPort is true)
        //
        // 3. Submit the new socket to AcceptEx() so that it may be
        //  used for processing about the new connections.
        //

        // 1.
        DBG_ASSERT( pAtqContext->m_nIO == 0);
        DBG_REQUIRE( pAtqContext->PrepareAcceptExContext(pEndpoint));

        // increment outstanding async io operations before AcceptEx() call
        InterlockedIncrement( &pAtqContext->m_nIO);

        // 2.
        if ( fAddToPort ) {
            ATQ_ASSERT(!pAtqContext->fDatagramContext);
            fSuccess = I_AddAtqContextToPort( pAtqContext);
        }
        // 3.
        if (fSuccess) {
            if (!pEndpoint->fDatagram) {
                 fSuccess = AcceptEx(
                                (SOCKET ) pEndpoint->ListenSocket,
                                (SOCKET ) pAtqContext->hAsyncIO,
                                pAtqContext->pvBuff,
                                pEndpoint->InitialRecvSize,
                                MIN_SOCKADDR_SIZE,
                                MIN_SOCKADDR_SIZE,
                                &cbRecvd,
                                &pAtqContext->Overlapped );

                 if (!fSuccess) {
                     fSuccess = (GetLastError() == ERROR_IO_PENDING);
                 }

            } else {

                WSABUF Buffer;
                DWORD lpFlags;
                int RetCode = 0;
                DWORD retry=0;

                //
                // For datagram, do a WSARecvFrom instead of AcceptEx.
                // All the output parameters have to be in the context
                // structure
                //

                for (;;) {

                    lpFlags = 0;
                    Buffer.len = pEndpoint->InitialRecvSize;
                    Buffer.buf = (char *) pAtqContext->pvBuff;

                    RetCode = WSARecvFrom(
                            (SOCKET) pAtqContext->hAsyncIO,
                            &Buffer,
                            1,                          // buffer count
                            &cbRecvd,
                            &lpFlags,
                            (PSOCKADDR) pAtqContext->AddressInformation,
                            &pAtqContext->AddressLength,
                            &pAtqContext->Overlapped,
                            NULL
                            );

                    //
                    // If this is a conn reset, then retry until we
                    // don't get this error anymore.  It looks like we 
                    // get this everytime someone sends us something and
                    // then shuts down the socket before we can respond.
                    // The sockets layer seems to give us a max of 160 of 
                    // these at a time, but for now retry infinitely since
                    // we don't know what this 160 is based on.
                    // RRandall - 7/16/99
                    //

                    if ( (RetCode == 0) || (WSAGetLastError() != WSAECONNRESET) ) {
                        break;
                    }

                    ATQ_PRINTF((DBG_CONTEXT,"AtqRecvFrom[%x] reset error. Retrying[%d]\n",
                                pAtqContext, retry));
                    retry++;
                }

                if (RetCode != 0) {

                    fSuccess = (WSAGetLastError() == ERROR_IO_PENDING);
                }
            }
        }

        if ( fSuccess) {

            //
            //  We've successfully added this socket, increment the count
            //

            InterlockedIncrement( &pEndpoint->nSocketsAvail );

        } else {

            ATQ_PRINTF(( DBG_CONTEXT,
                        "[AtqAddAcceptExSocket] Reusing an old context (%08x)"
                        " failed; error %d:%d, sAcceptSocket = %x, "
                        " pEndpoint = %lx, parm4 = %d, parm7 = %lx,"
                        " parm8 = %lx\n",
                        pAtqContext,
                        GetLastError(),
                        WSAGetLastError(),
                        pAtqContext->hAsyncIO,
                        pEndpoint,
                        pEndpoint->InitialRecvSize,
                        &cbRecvd,
                        &pAtqContext->Overlapped ));

            //
            // Unlink from the current list, where it was added as a result of
            //  step 1 above.
            //
            DBG_ASSERT( pAtqContext->ContextList != NULL);

            // balance the increment of the async operations outstanding
            DBG_REQUIRE( InterlockedDecrement( &pAtqContext->m_nIO) > 0);

            DBG_ASSERT( pAtqContext->m_leTimeout.Flink != NULL);
            pAtqContext->ContextList->
                RemoveFromList( &pAtqContext->m_leTimeout);

            //
            // balance the increment done
            // by pAtqContext->PrepareAcceptExContext()
            //
            DBG_REQUIRE( InterlockedDecrement( &pAtqContext->m_nIO) == 0);
            DBG_ASSERT( !fSuccess);

            //
            // the caller will free the Atq context on failure
            //
        }
    }

    return ( fSuccess);
} // I_AtqAddAcceptExSocket()




VOID
AtqpReuseContext( PATQ_CONT  pAtqContext)
/*++
  Description:
     This function attempts to reuse the ATQ context.
     It first cleans up the state and then uses the function
      I_AtqAddAccetpEx() socket to re-add the context to acceptex pool

  Arguments:
     pAtqContext - pointer to ATQ context that can be reused

  Returns:
     None
--*/
{
    PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

    DBG_ASSERT( pEndpoint != NULL);
    DBG_ASSERT( pEndpoint->UseAcceptEx);

    //
    // Complete connection has been processed prior to coming here
    //

    DBG_ASSERT(pAtqContext->IsFlag( ACF_CONN_INDICATED));

    //
    // Remove from the current active list
    //
    if ( pAtqContext->m_leTimeout.Flink != NULL ) {
        pAtqContext->ContextList->RemoveFromList( &pAtqContext->m_leTimeout );
    }

    DBG_ASSERT( pAtqContext->m_leTimeout.Flink == NULL);
    DBG_ASSERT( pAtqContext->m_leTimeout.Blink == NULL);

    DBG_ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

        //
        //  Either there is no socket or the socket must be in the
        //  unconnected state (meaning reused after TransmitFile)
        //


    DBG_ASSERT( !pAtqContext->hAsyncIO ||
                (  pAtqContext->hAsyncIO &&
                  (  pAtqContext->fDatagramContext ||
                     pAtqContext->IsState( ACS_SOCK_UNCONNECTED |
                                           ACS_SOCK_TOBE_FREED)
                  )
                )
              );

    //
    // !! DS
    //

    if ( pAtqContext->fDatagramContext ) {

        DBG_ASSERT(pEndpoint->fDatagram);
        pAtqContext->hAsyncIO = (HANDLE)pEndpoint->ListenSocket;
    }

    //
    // I need to make sure that the state information is cleaned up
    //  before re-adding the context to the list
    //

    if ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {

        //
        //  Failed to add the socket, free up the context without reuse
        //

        ATQ_PRINTF(( DBG_CONTEXT,
                     "[AtqpReuseContext] for (%08x) failed with "
                     " Error = %d;  Now freeing the context ...\n",
                     pAtqContext, GetLastError()
                     ));

        DBG_ASSERT( pAtqContext->m_nIO == 0);

        // free without reuse
        pAtqContext->CleanupAndRelease();
    }

    return;
} // AtqpReuseContext()



VOID
AtqpReuseOrFreeContext(
    PATQ_CONT    pAtqContext,
    BOOL         fReuseContext
    )
/*++
  Routine Description:
     This function does a free-up of the ATQ contexts. During the free-up
     path, we also attempt to reuse the ATQ context if the fReuseContext is
     set.

  Arguments:
     pAtqContext - pointer to the ATQ context that needs to be freedup
     fReuseContext - BOOLEAN flag indicating if this context should be reused

  Returns:
     None
--*/
{
    //
    // Get this object out of the Blocked Requests List.
    //

    if ( pAtqContext->IsBlocked()) {
        ATQ_REQUIRE( pAtqContext->m_pBandwidthInfo
                      ->RemoveFromBlockedList( pAtqContext ));
        DBG_ASSERT( !pAtqContext->IsBlocked());
    }

    DBG_ASSERT( pAtqContext->m_pBandwidthInfo != NULL);
    pAtqContext->m_pBandwidthInfo->Dereference();

    //
    //  Conditions for Reuse:
    //   1) fReuseContext == TRUE => caller wants us to reuse context
    //   2) pAtqContext->pEndpoint != NULL => valid endpoint exists
    //   3)  pEndpoint->UseAcceptEx => AcceptEx is enabled
    //   4)  pEndpoint->nSocketsAvail < nAcceptExOutstanding * 2 =>
    //           We do not have lots of outstanding idle sockets
    //       Condition (4) ensures that we do not flood the system
    //         with too many AcceptEx sockets as a result of some spike.
    //       AcceptEx sockets once added to the pool are hard to
    //         remove, because of various timing problems.
    //       Hence we want to prevent arbitrarily adding AcceptEx sockets.
    //
    //    In condition (4) I use a fudge factor of "2", so that
    //     we do continue to prevent reuse of sockets prematurely.
    //

    if ( fReuseContext &&
         (pAtqContext->pEndpoint != NULL)  &&
         (pAtqContext->pEndpoint->UseAcceptEx)
#ifdef ENABLE_REUSE_THROTTLE
         //
         // Reuse Throttle causes trouble in bursty traffic mode
         // especially with benchmarks like SpecWeb96
         //
         &&
         ( g_fAlwaysReuseSockets ||
           ((DWORD )pAtqContext->pEndpoint->nSocketsAvail <
            pAtqContext->pEndpoint->nAcceptExOutstanding * 2)
           )
#endif // ENABLE_REUSE_THROTTLE
         ) {

        //
        // Call the function to reuse context. On failure
        // the AtqpReuseContext will free up the context
        //

        AcIncrement( CacAtqContextsReused);

        AtqpReuseContext( pAtqContext);

    } else {

        AcIncrement( CacAtqContextsCleanedup);

        pAtqContext->CleanupAndRelease();

    }

    return;
} // AtqpReuseOrFreeContext()



BOOL
I_AtqPrepareAcceptExSockets(
    IN PATQ_ENDPOINT          pEndpoint,
    IN DWORD                  nSockets
    )
/*++

Routine Description:

    Prepare specified number of AcceptEx sockets for the given
      ListenSocket in [pEndpoint]

Arguments:

    pEndpoint - Information about this listenning socket
    nSockets    - number of AcceptEx() sockets to be created.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL   fReturn;
    DWORD  cbBuffer;
    DWORD  i;

    if ( !g_fUseAcceptEx ) {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    //
    //  If this listen socket isn't accepting new connections, just return
    //

    if ( pEndpoint->State != AtqStateActive ) {
        SetLastError( ERROR_NOT_READY );
        return(FALSE);
    }

    if ( pEndpoint->fAddingSockets) {
        //
        // Someone is already adding sockets. Do not add more
        // Just return success
        //
        return ( TRUE);
    }

    pEndpoint->fAddingSockets = TRUE;

    // calculate the buffer size
    cbBuffer = pEndpoint->InitialRecvSize + 2* MIN_SOCKADDR_SIZE;

    for ( fReturn = TRUE, i = 0 ; fReturn && i++ < nSockets; ) {

        PVOID        pvBuff;
        PATQ_CONT    pAtqContext;

        //
        //  Alloc a buffer for receive data
        //  TBD: Pool all these buffers into one large buffer.
        //

        pvBuff = LocalAlloc( LPTR, cbBuffer);

        //
        //  Get the ATQ context now because we need its overlapped structure
        //

        pAtqContext = I_AtqAllocContextFromCache();


        //
        // Now check if allocations are valid and do proper cleanup on failure
        //

        if ( pvBuff == NULL || pAtqContext == NULL) {

            if ( pvBuff ) {
                LocalFree( pvBuff );
                pvBuff = NULL;
            }

            if ( pAtqContext ) {
                I_AtqFreeContextToCache( pAtqContext );
                pAtqContext = NULL;
            }

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            fReturn = FALSE;
            break;
        } else {

            //
            // Add this socket to AtqContext lists & completion ports
            // From now on the called function will take care of freeing up
            //  pAtqContext, if there is a failure.
            //

            pAtqContext->SetAcceptExBuffer( pvBuff);
            if ( pEndpoint->fDatagram ) {
                pAtqContext->hAsyncIO = (HANDLE)pEndpoint->ListenSocket;
            } else {
                pAtqContext->hAsyncIO = NULL;
            }
            pAtqContext->hJraAsyncIO = 0;

            if ( !pEndpoint->fDatagram ) {
            
                if ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {

                    //
                    //  Failed to add the socket, free up the context without reuse
                    //

                    ATQ_PRINTF(( DBG_CONTEXT,
                                "[I_AtqPrepareAcceptExSockets] for Endpoint %08x"
                                " and AtqContext (%08x) failed with "
                                " Error = %d;  Now freeing the context ...",
                                pEndpoint, pAtqContext, GetLastError()
                                ));

                    // free without reuse
                    DBG_ASSERT( pAtqContext->m_nIO == 0);
                    pAtqContext->CleanupAndRelease();
                    fReturn = FALSE;
                }

            } else {
                while ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {
                    // UDP is more fragile than TCP, so keep trying.  If
                    // we give up, then we might run out of posted receives,
                    // and there's no way to recover from that.
                    Sleep(100);
                }
            }
        }
    } // for

    //
    // Finished Adding sockets. Indicate that by resetting the flab
    //

    pEndpoint->fAddingSockets = FALSE;

    ATQ_PRINTF(( DBG_CONTEXT,
                "PrepareAcceptExSockets( Endpoint[%08x], nSockets = %d)==>"
                " avail = %d; Total Refs = %d.\n",
                pEndpoint,
                nSockets,
                pEndpoint->nSocketsAvail,
                pEndpoint->m_refCount
                ));

    return ( fReturn);

} // I_AtqPrepareAcceptExSockets()


BOOL
I_AtqStartThreadMonitor(
    VOID
    )
/*++

Routine Description:

    Adds the ThreadMonitor function to the scheduler.
    
    Note: The scheduler should be initialized before getting to this function.

Arguments:

    None.

Return Value:

    TRUE if successful, FALSE on error 

--*/
{

    g_dwThreadMonitorCookie =
        ScheduleWorkItem(
                         (PFN_SCHED_CALLBACK)I_AtqThreadMonitor,
                         NULL, // No need for a context
                         TimeToWait(ATQ_THREAD_MONITOR_PERIOD),
                         TRUE  // ask for periodic timeout
                         );

    if ( g_dwThreadMonitorCookie == 0 ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Error %d scheduling ThreadMonitor\n",GetLastError()));
        return(FALSE);
    }

    return(TRUE);
}



BOOL
I_AtqStopThreadMonitor(
    VOID
    )
/*++

Routine Description:

    Removes the ThreadMonitor function from the scheduler.
    
    Note: The scheduler should be initialized before getting to this function.

Arguments:

    None.

Return Value:

    TRUE if successful, FALSE on error 

--*/
{
    if ( 0 != g_dwThreadMonitorCookie) {
        DBG_REQUIRE( RemoveWorkItem( g_dwThreadMonitorCookie ));
        g_dwThreadMonitorCookie = 0;
    }

    return ( TRUE);
}


VOID
I_AtqThreadMonitor(
    IN PVOID NotUsed
    )
/*++

Routine Description:

    Checks to see whether the AtqPoolThreads have stalled out for longer than
    ATQ_THREAD_MONITOR_PERIOD, and if so starts up a temporary AtqPoolThread.
    This is to prevent deadlocks due to all the atq threads being used by
    processes that are trying to call a network service on this same machine
    that also used atq.

Arguments:

    NotUsed - This argument is only here because sheduler callback functions
    require a PVOID argument.  It is not actually used in the body of the
    function.

Return Value:

    None.

--*/
{
    HANDLE  hThread;
    DWORD   dwThreadID;

    if (!g_fDeadManSwitch || 0 != g_cAvailableThreads) {
        // The switch has been cleared since
        // the last time or there are still available threads, the AtqPoolThreads
        // must not be stuck.
        g_fDeadManSwitch = TRUE;
        return;
    }

    ATQ_ASSERT( ATQ_REG_MAX_POOL_THREAD_LIMIT > g_cThreads );

    if ( ATQ_REG_MAX_POOL_THREAD_LIMIT > g_cThreads ) { 
        // There are no free threads and there hasn't been any
        // for ATQ_THREAD_MONITOR_PERIOD.  Start up a temporary
        // thread to service calls until hopefully the rest of 
        // the threads make some progress.
        ATQ_PRINTF(( DBG_CONTEXT, "AtqThreadMonitor: Starting a new thread.\n"));

        InterlockedIncrement( &g_cThreads );

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AtqPoolThread,
                                (PVOID)UIntToPtr(ATQ_TEMP_THREAD),  // Let the thread know that it is temporary.
                                0,
                                &dwThreadID );

        if ( hThread ) {
            CloseHandle( hThread );     // Free system resources
        } else {
            InterlockedDecrement( &g_cThreads );
            ATQ_PRINTF(( DBG_CONTEXT,
                "AtqThreadMonitor: Unable to create a temp thread.\n"));                    
        }
    } 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable
// begin_user_unmodifiable



/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants
//

#define DEBUG_SIO                   0x10000000
#define DEBUG_TIMEOUT               0x20000000
#define DEBUG_ENDPOINT              0x40000000
#define DEBUG_SPUD                  0x80000000

# define DEBUG_ALLOC_CACHE          0x01000000

// Use the default constants from pudebug.h

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\dllmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1996           **/
/**********************************************************************/

/*
    dllmain.cxx

        Library initialization for isatq.dll  --
           Internet Information Services - ATQ dll.

    FILE HISTORY:

        MuraliK     08-Apr-1996  Created.
*/


#include "isatq.hxx"


/************************************************************
 * Globals
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();


//
// is winsock initialized?
//

BOOL    g_fSocketsInitialized = FALSE;

//
// This Misc lock is used to guard the initialization code (and anything else
// that might come up later).
//

BOOL    miscLockInitialized = FALSE;
CRITICAL_SECTION    MiscLock;


/************************************************************
 * Functions
 ************************************************************/



extern "C"
BOOL WINAPI
DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:  {

        CREATE_DEBUG_PRINT_OBJECT( "isatq");
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            return ( FALSE);
        }

        //
        // Initialize global init critsect
        //

        miscLockInitialized =
            InitializeCriticalSectionAndSpinCount(&MiscLock, 400);

        if ( !miscLockInitialized ) {
            return FALSE;
        }

        SET_DEBUG_FLAGS( DEBUG_ERROR );

        //
        // Initialize sockets
        //

        {
            DWORD dwError = NO_ERROR;

            WSADATA   wsaData;
            INT       serr;

            //
            //  Connect to WinSock 2.0
            //

            serr = WSAStartup( MAKEWORD( 2, 0), &wsaData);

            if( serr != 0 ) {
                DBGPRINTF((DBG_CONTEXT,"WSAStartup failed with %d\n",serr));
                return(FALSE);
            }
            g_fSocketsInitialized = TRUE;
        }

        //
        // Initialize the platform type
        //
        INITIALIZE_PLATFORM_TYPE();
        ATQ_ASSERT(IISIsValidPlatform());

        DisableThreadLibraryCalls( hDll );
        break;
    }

    case DLL_PROCESS_DETACH:

        if ( lpvReserved != NULL) {

            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            break;
        }


        //
        // Cleanup sockets
        //

        if ( g_fSocketsInitialized ) {

            INT serr = WSACleanup();

            if ( serr != 0) {
                ATQ_PRINTF((DBG_CONTEXT,"WSACleanup failed with %d\n",
                            WSAGetLastError()));
            }
            g_fSocketsInitialized = FALSE;
        }

        if ( miscLockInitialized ) {
            DeleteCriticalSection(&MiscLock);
            miscLockInitialized = FALSE;
        }

        DELETE_DEBUG_PRINT_OBJECT();
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break ;
    }

    return ( fReturn);

} // main()


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\hashtab.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       hashtab.cxx

   Abstract:
       Implements the member functions for Hash table

   Author:

       Murali R. Krishnan    ( MuraliK )     02-Oct-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# if !defined(dllexp)
# define dllexp __declspec( dllexport)
# endif

# include "isatq.hxx"
# include "hashtab.hxx"

# include "dbgutil.h"



/*++
  Organization of Hash Table

  The hash table consists of a set of hash buckets controlled
  by the number of buckets specified during creation.

  Each bucket consists of a set of bucket chunks. Each bucket
  owns a separate critical section to protect the entries in
  the bucket itself.

  Each bucket chunk consists of an array of MAX_ELEMENTS_PER_BUCKET
   HashTableBucketElement Entries (HTBE_ENTRY).

  Each HTBE_ENTRY maintains a hash value and pointer to the Hash Element.

--*/

/************************************************************
 *    HASH_TABLE_BUCKET
 ************************************************************/

struct HTBE_ENTRY {
    DWORD        m_hashValue;
    HT_ELEMENT * m_phte;

    inline
    BOOL IsMatch( DWORD hashValue, LPCSTR pszKey, DWORD cchKey) const
    { return ((hashValue == m_hashValue) &&
              (NULL != m_phte) &&
              m_phte->IsMatch( pszKey, cchKey)
              );
    }

    inline
    BOOL IsMatch( IN HT_ELEMENT * phte) const
    { return ( phte == m_phte); }

    inline BOOL
    IsEmpty( VOID) const { return ( NULL == m_phte); }

    VOID Print( VOID) const
    { m_phte->Print(); }
};

typedef HTBE_ENTRY * PHTBE_ENTRY;

//
// Chunk size should be carefully (empirically) chosen.
// Small Chunk size => large number of chunks
// Large Chunk size => high cost of search on failures.
// For now we choose the chunk size to be 20 entries.
# define MAX_ELEMENTS_PER_BUCKET    ( 20 )

struct HTB_ELEMENT {

    HTBE_ENTRY   m_rgElements[MAX_ELEMENTS_PER_BUCKET];
    DWORD        m_nElements;
    LIST_ENTRY   m_ListEntry;

    HTB_ELEMENT(VOID)
        : m_nElements ( 0)
    {
        InitializeListHead( &m_ListEntry);
        ZeroMemory( m_rgElements, sizeof( m_rgElements));
    }

    ~HTB_ELEMENT(VOID)
    { Cleanup(); }

    VOID Cleanup( VOID);

    inline
    HT_ELEMENT * Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey);

    inline
    BOOL Insert( IN DWORD hashVal, IN HT_ELEMENT * phte);

    inline
    BOOL Delete( IN HT_ELEMENT * phte);

    VOID Print( IN DWORD level) const;

    HTBE_ENTRY * FirstElement(VOID) { return ( m_rgElements); }
    HTBE_ENTRY * LastElement(VOID)
    { return ( m_rgElements + MAX_ELEMENTS_PER_BUCKET); }
    VOID NextElement( HTBE_ENTRY * & phtbe)
    { phtbe++; }

    VOID IncrementElements(VOID) { m_nElements++; }
    VOID DecrementElements(VOID) { m_nElements--; }
    DWORD NumElements( VOID) const { return ( m_nElements); }
    BOOL IsSpaceAvailable(VOID) const
    { return ( NumElements() < MAX_ELEMENTS_PER_BUCKET); }

    DWORD FindNextElement( IN OUT LPDWORD pdwPos,
                           OUT HT_ELEMENT ** pphte);

};

typedef HTB_ELEMENT * PHTB_ELEMENT;

class HASH_TABLE_BUCKET {

public:
    HASH_TABLE_BUCKET(VOID);
    ~HASH_TABLE_BUCKET( VOID);

    HT_ELEMENT * Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey);
    BOOL Insert( IN DWORD       hashVal,
                 IN HT_ELEMENT * phte,
                 IN BOOL        fCheckForDuplicate);

    BOOL Delete( IN HT_ELEMENT * phte);
    VOID Print( IN DWORD level);

    DWORD NumEntries( VOID);

    DWORD  InitializeIterator( IN HT_ITERATOR * phti);

    dllexp DWORD  FindNextElement( IN HT_ITERATOR * phti,
                                   OUT HT_ELEMENT ** pphte);
    dllexp DWORD  CloseIterator( IN HT_ITERATOR * phti);

private:
    CRITICAL_SECTION   m_csLock;

    LIST_ENTRY         m_lHead;
    DWORD              m_nEntries;

    HTB_ELEMENT        m_htbeFirst; // the first bucket chunk

    VOID Lock(VOID) { EnterCriticalSection( &m_csLock); }
    VOID Unlock( VOID) { LeaveCriticalSection( &m_csLock); }
};




/************************************************************
 *    Member Functions of HTB_ELEMENT
 ************************************************************/

VOID
HTB_ELEMENT::Cleanup( VOID)
{

    if ( m_nElements > 0) {
        PHTBE_ENTRY phtbeEntry;

        // free up all the entries in this bucket.
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            if ( !phtbeEntry->IsEmpty() ) {

                // release the object now.
                DecrementElements();

                // Assert that ref == 1
                DerefAndKillElement( phtbeEntry->m_phte);
                phtbeEntry->m_phte = NULL;
                phtbeEntry->m_hashValue = 0;
            }
        } // for
    }

    DBG_ASSERT( 0 == m_nElements);
    return;
} // HTB_ELEMENT::Cleanup()


inline
HT_ELEMENT *
HTB_ELEMENT::Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey)
{
    HT_ELEMENT * phte = NULL;

    if ( m_nElements > 0) {

        PHTBE_ENTRY phtbeEntry;
        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            //
            // If the hash values match and the strings match up, return
            //  the corresponding hash table entry object
            //
            if ( phtbeEntry->IsMatch( hashValue, pszKey, cchKey)) {

                // we found the entry. return it.
                phte = phtbeEntry->m_phte;
                DBG_REQUIRE( phte->Reference() > 0);
                break;
            }
        } // for
    }

    return ( phte);
} // HTB_ELEMENT::Lookup()


inline BOOL
HTB_ELEMENT::Insert( IN DWORD hashVal,
                     IN HT_ELEMENT * phte
                     )
{
    if ( m_nElements < MAX_ELEMENTS_PER_BUCKET) {

        // there is some empty space.
        // Find one such a slot and add this new entry

        PHTBE_ENTRY phtbeEntry;

        for (phtbeEntry = FirstElement();
             phtbeEntry < LastElement();
             NextElement( phtbeEntry)) {

            if ( phtbeEntry->IsEmpty() ) {

                DBG_ASSERT( NULL != phte);

                // Assume that the object phte already has non-zero ref count

                // we found a free entry. insert the new element here.
                phtbeEntry->m_hashValue = hashVal;
                phtbeEntry->m_phte = phte;
                IncrementElements();
                return ( TRUE);
            }
        } // for

        // we should not come here. If we do then there is trouble :(
        DBG_ASSERT( FALSE);
    }

    SetLastError( ERROR_INSUFFICIENT_BUFFER);
    return ( FALSE);
} // HTB_ELEMENT::Insert()


DWORD
HTB_ELEMENT::FindNextElement( IN OUT LPDWORD pdwPos, OUT HT_ELEMENT ** pphte)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;

    DBG_ASSERT( NULL != pdwPos );
    DBG_ASSERT( NULL != pphte );

    // Find the first valid element to return back.

    //
    // Given that deletion might happen any time, we cannot rely on the
    //   comparison  *pdwPos < m_nElements
    //
    // Do scans with *pdwPos < MAX_ELEMENTS_PER_BUCKET
    //

    if ( *pdwPos < MAX_ELEMENTS_PER_BUCKET ) {

        PHTBE_ENTRY phtbeEntry;

        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = m_rgElements + *pdwPos;
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            if ( phtbeEntry->m_phte != NULL ) {

                //
                // Store the element pointer and the offset
                // and return after referencing the element
                //
                *pphte = phtbeEntry->m_phte;
                (*pphte)->Reference();
                *pdwPos = ( 1 + (DWORD)(phtbeEntry - FirstElement()));
                dwErr = NO_ERROR;
                break;
            }
        } // for
    }

    return ( dwErr);
} // HTB_ELEMENT::FindNextElement()


inline BOOL
HTB_ELEMENT::Delete( IN HT_ELEMENT * phte)
{
    DBG_ASSERT( NULL != phte);

    if ( m_nElements > 0) {

        PHTBE_ENTRY phtbeEntry;
        // find the entry by scanning all entries in this bucket chunk
        // if found, increment ref count and return a pointer to the object
        for (phtbeEntry = FirstElement();
             phtbeEntry < (LastElement());
             NextElement( phtbeEntry)) {

            //
            // If the hash values match and the strings match up,
            //  decrement ref count and kill the element.
            //
            if ( phtbeEntry->IsMatch( phte)) {

                // We found the entry.  Remove it from the table

                phtbeEntry->m_phte = NULL;
                DecrementElements();

                DerefAndKillElement( phte);

                return ( TRUE);
            }
        } // for
    }

    return ( FALSE);
} // HTB_ELEMENT::Delete()


VOID
HTB_ELEMENT::Print(IN DWORD level) const
{
    const HTBE_ENTRY * phtbeEntry;
    CHAR rgchBuffer[MAX_ELEMENTS_PER_BUCKET * 22 + 200];
    DWORD cch;
    DWORD i;

    cch = wsprintf( rgchBuffer,
                    "HTB_ELEMENT(%08x)  # Elements %4d; "
                    "Flink: %08x  Blink: %08x\n"
                    ,
                    this, m_nElements,
                    m_ListEntry.Flink, m_ListEntry.Blink);

    if ( level > 0) {

        // NYI: I need to walk down the entire array.
        // Not just the first few entries
        for( i = 0; i < m_nElements; i++) {

            phtbeEntry = &m_rgElements[i];
            cch += wsprintf( rgchBuffer + cch,
                             "  %08x %08x",
                         phtbeEntry->m_hashValue,
                             phtbeEntry->m_phte
                             );
            if ( i % 4 == 0) {
                rgchBuffer[cch++] = '\n';
                rgchBuffer[cch] = '\0';
            }
        } // for
    }

    DBGDUMP(( DBG_CONTEXT, rgchBuffer));
    return;
} // HTB_ELEMENT::Print()



/************************************************************
 *    Member Functions of HASH_TABLE_BUCKET
 ************************************************************/

HASH_TABLE_BUCKET::HASH_TABLE_BUCKET(VOID)
    : m_nEntries ( 0),
      m_htbeFirst()
{
    InitializeListHead( &m_lHead);
    InitializeCriticalSection( & m_csLock);
    SET_CRITICAL_SECTION_SPIN_COUNT( &m_csLock, IIS_DEFAULT_CS_SPIN_COUNT);
} // HASH_TABLE_BUCKET::HASH_TABLE_BUCKET()


HASH_TABLE_BUCKET::~HASH_TABLE_BUCKET( VOID)
{
    PLIST_ENTRY pl;
    PHTB_ELEMENT phtbe;

    // Free up the elements in the list
    Lock();
    while ( !IsListEmpty( &m_lHead)) {
        pl = RemoveHeadList( &m_lHead);
        phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT, m_ListEntry);
        delete phtbe;
    } // while

    m_htbeFirst.Cleanup();
    Unlock();

    DeleteCriticalSection( &m_csLock);
} // HASH_TABLE_BUCKET::~HASH_TABLE_BUCKET()



HT_ELEMENT *
HASH_TABLE_BUCKET::Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey)
{
    HT_ELEMENT * phte;

    Lock();
    // 1. search in the first bucket
    phte = m_htbeFirst.Lookup( hashValue, pszKey, cchKey);

    if ( NULL == phte ) {

        // 2. search in the auxiliary buckets
        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink; (phte == NULL) && (pl != &m_lHead);
              pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl,
                                                     HTB_ELEMENT,
                                                     m_ListEntry);
            phte = phtbe->Lookup( hashValue, pszKey, cchKey);
        } // for
    }

    Unlock();

    return (phte);
} // HASH_TABLE_BUCKET::Lookup()


BOOL
HASH_TABLE_BUCKET::Insert( IN DWORD hashValue,
                           IN HT_ELEMENT * phte,
                           IN BOOL fCheckForDuplicate)
{
    BOOL fReturn = FALSE;

    if ( fCheckForDuplicate) {

        Lock();

        // do a lookup and find out if this data exists.
        HT_ELEMENT * phteLookedup = Lookup( hashValue,
                                            phte->QueryKey(),
                                            phte->QueryKeyLen()
                                            );

        if ( NULL != phteLookedup) {
            // the element is already present - return failure

            DerefAndKillElement( phteLookedup);
        }

        Unlock();

        if ( NULL != phteLookedup) {
            SetLastError( ERROR_DUP_NAME);
            return ( FALSE);
        }
    }

    Lock();

    // 1. try inserting in the first bucket chunk, if possible
    if ( m_htbeFirst.IsSpaceAvailable()) {

        fReturn = m_htbeFirst.Insert( hashValue, phte);
    } else {

        // 2. Find the first chunk that has space and insert it there.
        PLIST_ENTRY pl;
        HTB_ELEMENT * phtbe;

        for ( pl = m_lHead.Flink; (pl != &m_lHead);
              pl = pl->Flink) {

            phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT, m_ListEntry);

            if ( phtbe->IsSpaceAvailable()) {
                fReturn = phtbe->Insert( hashValue, phte);
                break;
            }
        } // for

        if ( !fReturn ) {

            //
            // We ran out of space.
            // Allocate a new bucket and insert the new element.
            //

            phtbe = new HTB_ELEMENT();
            if ( NULL != phtbe) {

                // add the bucket to the list of buckets and
                // then add the element to the bucket
                InsertTailList( &m_lHead, &phtbe->m_ListEntry);
                fReturn = phtbe->Insert(hashValue, phte);
            } else {

                IF_DEBUG( ERROR) {
                    DBGPRINTF(( DBG_CONTEXT,
                                " HTB(%08x)::Insert: Unable to add a chunk\n",
                                this));
                }
                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    }

    Unlock();

    return ( fReturn);
} // HASH_TABLE_BUCKET::Insert()



BOOL
HASH_TABLE_BUCKET::Delete( IN HT_ELEMENT * phte)
{
    BOOL fReturn = FALSE;


    // We do not know which bucket this element belongs to.
    // So we should try all chunks to delete this element.

    Lock();

    // 1. try deleting the element from first bucket chunk, if possible
    fReturn = m_htbeFirst.Delete( phte);

    if (!fReturn) {

        // it was not on the first bucket chunk.

        // 2. Find the first chunk that might contain this element
        // and delete it.
        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink;
              !fReturn && (pl != &m_lHead);
              pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl,
                                                     HTB_ELEMENT,
                                                     m_ListEntry);
            fReturn = phtbe->Delete( phte);
        } // for

        // the element should have been in the hash table,
        // otherwise the app is calling with wrong entry
        DBG_ASSERT( fReturn);
    }

    Unlock();

    return ( fReturn);
} // HASH_TABLE_BUCKET::Delete()


DWORD
HASH_TABLE_BUCKET::NumEntries( VOID)
{
    DWORD nEntries;

    Lock();

    nEntries = m_htbeFirst.NumElements();

    PLIST_ENTRY pl;

    for ( pl = m_lHead.Flink;
          (pl != &m_lHead);
          pl = pl->Flink) {

        HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                 m_ListEntry);
        nEntries += phtbe->NumElements();
    } // for

    Unlock();

    return (nEntries);

} // HASH_TABLE_BUCKET::NumEntries()


DWORD
HASH_TABLE_BUCKET::InitializeIterator( IN HT_ITERATOR * phti)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;

    //
    // find the first chunk that has a valid element.
    // if we find one, leave the lock on for subsequent accesses.
    // CloseIterator will shut down the lock
    // If we do not find one, we should unlock and return
    //

    phti->nChunkId = NULL;
    phti->nPos = 0;

    Lock();
    if ( m_htbeFirst.NumElements() > 0) {
        phti->nChunkId = (DWORD_PTR) &m_htbeFirst;
        dwErr = NO_ERROR;
    } else {

        // find the first chunk that has an element

        PLIST_ENTRY pl;

        for ( pl = m_lHead.Flink; (pl != &m_lHead); pl = pl->Flink) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                     m_ListEntry);
            if ( phtbe->NumElements() > 0) {
                phti->nChunkId = (DWORD_PTR) phtbe;
                dwErr = NO_ERROR;
                break;
            }
        } // for
    }

    // if we did not find any elements, then unlock and return
    // Otherwise leave the unlocking to the CloseIterator()
    if ( dwErr == ERROR_NO_MORE_ITEMS) {

        // get out of this bucket completely.
        Unlock();
    }

    return ( dwErr);

} // HASH_TABLE_BUCKET::InitializeIterator()


DWORD
HASH_TABLE_BUCKET::FindNextElement( IN HT_ITERATOR * phti,
                                    OUT HT_ELEMENT ** pphte)
{
    //  this function should be called only when the bucket is locked.

    DWORD dwErr;
    HTB_ELEMENT * phtbe = (HTB_ELEMENT * )phti->nChunkId;

    //
    // phti contains the <chunk, pos> from which we should start scan for
    //   next element.
    //

    DBG_ASSERT( NULL != phtbe);
    dwErr = phtbe->FindNextElement( &phti->nPos, pphte);

    if ( ERROR_NO_MORE_ITEMS == dwErr ) {

        // scan the rest of the chunks for next element

        PLIST_ENTRY pl = ((phtbe == &m_htbeFirst) ? m_lHead.Flink :
                          phtbe->m_ListEntry.Flink);

        for ( ; (pl != &m_lHead); pl = pl->Flink) {

            phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                       m_ListEntry);
            if ( phtbe->NumElements() > 0) {
                phti->nPos = 0;
                dwErr = phtbe->FindNextElement( &phti->nPos, pphte);
                DBG_ASSERT( NO_ERROR == dwErr);
                phti->nChunkId = (DWORD_PTR) phtbe;
                break;
            }
        } // for
    }

    if ( dwErr == ERROR_NO_MORE_ITEMS) {

        phti->nChunkId = (DWORD ) NULL;
    }

    return ( dwErr);
} // HASH_TABLE_BUCKET::FindNextElement()


DWORD
HASH_TABLE_BUCKET::CloseIterator( IN HT_ITERATOR * phti)
{
    // just unlock the current bucket.
    Unlock();

    return ( NO_ERROR);
} // HASH_TABLE_BUCKET::CloseIterator()


VOID
HASH_TABLE_BUCKET::Print( IN DWORD level)
{
    Lock();
    DBGPRINTF(( DBG_CONTEXT,
                "\n\nHASH_TABLE_BUCKET (%08x): Head.Flink=%08x; Head.Blink=%08x\n"
                " Bucket Chunk # 0:\n"
                ,
                this, m_lHead.Flink, m_lHead.Blink
                ));

    m_htbeFirst.Print( level);

    if ( level > 0) {
        PLIST_ENTRY pl;
        DWORD i;

        for ( pl = m_lHead.Flink, i = 1;
              (pl != &m_lHead);
              pl = pl->Flink, i++) {

            HTB_ELEMENT * phtbe = CONTAINING_RECORD( pl, HTB_ELEMENT,
                                                     m_ListEntry);
            DBGPRINTF(( DBG_CONTEXT, "\n Bucket Chunk # %d\n", i));
            phtbe->Print( level);
        } // for
    }

    Unlock();
    return;
} // HASH_TABLE_BUCKET::Print()




/************************************************************
 *    Member Functions of HASH_TABLE
 ************************************************************/

HASH_TABLE::HASH_TABLE( IN DWORD   nBuckets,
                        IN LPCSTR  pszIdentifier,
                        IN DWORD   dwHashTableFlags
                        )
    : m_nBuckets   ( nBuckets),
      m_dwFlags    ( dwHashTableFlags),
      m_nEntries   ( 0),
      m_nLookups   ( 0),
      m_nHits      ( 0),
      m_nInserts   ( 0),
      m_nFlushes   ( 0)
{
    if ( NULL != pszIdentifier) {

        lstrcpynA( m_rgchId, pszIdentifier, sizeof( m_rgchId));
    }

    m_prgBuckets = new HASH_TABLE_BUCKET[nBuckets];

} // HASH_TABLE::HASH_TABLE()



DWORD
HASH_TABLE::CalculateHash( IN LPCSTR pszKey, DWORD cchKey) const
{
    DWORD hash = 0;

    DBG_ASSERT( pszKey != NULL );

    if ( cchKey > 8) {
        //
        // hash the last 8 characters
        //
        pszKey = (pszKey + cchKey - 8);
    }

    while ( *pszKey != '\0') {

        //
        // This is an extremely slimey way of getting upper case.
        // Kids, don't try this at home
        // -johnson
        //

        DWORD ch = ((*pszKey++) & ~0x20);

        // NYI: this is a totally pipe-line unfriendly code. Improve this.
        hash <<= 2;
        hash ^= ch;
        hash += ch;
    } // while

    //
    // Multiply by length (to introduce some randomness.  Murali said so.
    //

    return( hash * cchKey);
} // CalculateHash()


VOID
HASH_TABLE::Cleanup(VOID)
{
    if ( NULL != m_prgBuckets ) {

        delete [] m_prgBuckets;
        m_prgBuckets = NULL;
    }

} // HASH_TABLE::Cleanup()



# define INCREMENT_LOOKUPS()  \
       { InterlockedIncrement( (LPLONG ) &m_nLookups); }

# define INCREMENT_HITS( phte)  \
       if ( NULL != phte) { InterlockedIncrement( (LPLONG ) &m_nHits); }

# define INCREMENT_INSERTS()  \
       { InterlockedIncrement( (LPLONG ) &m_nInserts); }

# define INCREMENT_FLUSHES()  \
       { InterlockedIncrement( (LPLONG ) &m_nFlushes); }

# define INCREMENT_ENTRIES( fRet)  \
       if ( fRet) { InterlockedIncrement( (LPLONG ) &m_nEntries); }

# define DECREMENT_ENTRIES( fRet)  \
       if ( fRet) { InterlockedDecrement( (LPLONG ) &m_nEntries); }

HT_ELEMENT *
HASH_TABLE::Lookup( IN LPCSTR pszKey, DWORD cchKey)
{
    // 1. Calculate the hash value for pszKey
    // 2. Find the bucket for the hash value
    // 3. Search for given item in the bucket
    // 4. return the result, after updating statistics

    DWORD hashVal = CalculateHash( pszKey, cchKey);
    HT_ELEMENT * phte;

    INCREMENT_LOOKUPS();

    DBG_ASSERT( NULL != m_prgBuckets);
    phte = m_prgBuckets[hashVal % m_nBuckets].Lookup( hashVal, pszKey, cchKey);

    INCREMENT_HITS( phte);

    return ( phte);
} // HASH_TABLE::Lookup()


BOOL
HASH_TABLE::Insert( HT_ELEMENT * phte, IN BOOL fCheckBeforeInsert)
{
    // 1. Calculate the hash value for key of the HT_ELEMENT object
    // 2. Find the bucket for the hash value
    // 3. Check if this item is not already present and insert
    //     it into the hash table.
    //  (the check can be bypassed if fCheck is set to FALSE)
    // 4. return the result, after updating statistics

    DWORD hashVal = CalculateHash( phte->QueryKey());
    BOOL  fRet;

    INCREMENT_INSERTS();

    DBG_ASSERT( NULL != m_prgBuckets);
    fRet = m_prgBuckets[hashVal % m_nBuckets].Insert( hashVal,
                                                      phte,
                                                      fCheckBeforeInsert);

    IF_DEBUG( ERROR) {
        if ( !fRet) {
            DBGPRINTF(( DBG_CONTEXT,
                        " Unable to insert %08x into bucket %d."
                        "  Bucket has %d elements. Error = %d\n",
                        phte, hashVal % m_nBuckets,
                        m_prgBuckets[hashVal % m_nBuckets].NumEntries(),
                        GetLastError()
                        ));
        }
    }
    INCREMENT_ENTRIES( fRet);

    return ( fRet);
} // HASH_TABLE::Insert()



BOOL
HASH_TABLE::Delete( HT_ELEMENT * phte)
{
    BOOL  fRet;
    DWORD hashVal = CalculateHash( phte->QueryKey(), phte->QueryKeyLen());

    DBG_ASSERT( NULL != m_prgBuckets);
    fRet = m_prgBuckets[hashVal % m_nBuckets].Delete( phte);

    DECREMENT_ENTRIES( fRet);

    return ( fRet);
} // HASH_TABLE::Delete()



VOID
HASH_TABLE::Print( IN DWORD level)
{
    DWORD i;

    DBGPRINTF(( DBG_CONTEXT,
                "HASH_TABLE(%08x) "
                "%s: nBuckets = %d; dwFlags = %d;"
                " nEntries = %d; nLookups = %d; nHits = %d;"
                " nInserts = %d; nFlushes = %d;"
                " m_prgBuckets = %d\n",
                this, m_rgchId, m_nBuckets, m_dwFlags,
                m_nEntries, m_nLookups, m_nHits, m_nInserts,
                m_nFlushes, m_prgBuckets));

    if ( level == 0 ) {

        CHAR rgchBuff[2000];
        DWORD cch;

        cch = wsprintfA( rgchBuff, "\tBucket  NumEntries\n");
        DBG_ASSERT( NULL != m_prgBuckets);
        for (i = 0; i < m_nBuckets; i++) {

            cch += wsprintf( rgchBuff + cch, "\t[%4d]  %4d,\n",
                             i, m_prgBuckets[i].NumEntries());
        } // for

        DBGDUMP(( DBG_CONTEXT, rgchBuff));
    } else {

        DBG_ASSERT( NULL != m_prgBuckets);
        for (i = 0; i < m_nBuckets; i++) {

            m_prgBuckets[i].Print( level);
        } // for
    }

    return;
} // HASH_TABLE::Print()



DWORD
HASH_TABLE::InitializeIterator( IN HT_ITERATOR * phti)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);

    // initialize the iterator
    phti->nBucketNumber = INFINITE;
    phti->nChunkId = NULL;
    phti->nPos = 0;

    if ( m_nEntries > 0) {
        // set the iterator to point to the first bucket with some elements.
        for ( DWORD i = 0; (i < m_nBuckets); i++) {

            dwErr = m_prgBuckets[i].InitializeIterator( phti);
            if ( dwErr == NO_ERROR) {
                phti->nBucketNumber = i;
                break;
            }
        }
    }

    return ( dwErr);
} // HASH_TABLE::InitializeIterator()


DWORD
HASH_TABLE::FindNextElement( IN HT_ITERATOR * phti,
                             OUT HT_ELEMENT ** pphte)
{
    DWORD dwErr = ERROR_NO_MORE_ITEMS;
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);
    DBG_ASSERT( NULL != pphte);

    if ( INFINITE != phti->nBucketNumber) {

        // iterator has some valid state use it.
        DBG_ASSERT( phti->nBucketNumber < m_nBuckets);

        dwErr =
            m_prgBuckets[ phti->nBucketNumber].FindNextElement( phti, pphte);

        if ( ERROR_NO_MORE_ITEMS == dwErr) {

            DBG_REQUIRE( m_prgBuckets[ phti->nBucketNumber].
                            CloseIterator( phti)
                         == NO_ERROR
                        );

            // hunt for the next bucket with an element.
            for ( DWORD i = (phti->nBucketNumber + 1); (i < m_nBuckets); i++) {

                dwErr = m_prgBuckets[i].InitializeIterator( phti);

                if ( dwErr == NO_ERROR) {
                    phti->nBucketNumber = i;
                    dwErr = m_prgBuckets[ i].FindNextElement( phti, pphte);
                    DBG_ASSERT( dwErr == NO_ERROR);
                    break;
                }
            } // for

            if ( ERROR_NO_MORE_ITEMS == dwErr) {
                // reset the bucket number
                phti->nBucketNumber = INFINITE;
            }
        }
    }

    return ( dwErr);
} // HASH_TABLE::FindNextElement()


DWORD
HASH_TABLE::CloseIterator( IN HT_ITERATOR * phti)
{
    DBG_ASSERT( IsValid());
    DBG_ASSERT( NULL != phti);

    if ( INFINITE != phti->nBucketNumber) {
        DBG_ASSERT( phti->nBucketNumber < m_nBuckets);
        DBG_REQUIRE( m_prgBuckets[ phti->nBucketNumber].
                     CloseIterator( phti)
                     == NO_ERROR
                     );
        phti->nBucketNumber = INFINITE;
    }

    return ( NO_ERROR);
} // HASH_TABLE::CloseIterator()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\reftrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reftrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging reference count problems. This module uses the generic
    TRACE_LOG facility in tracelog.h.

    Ref count trace logs can be dumped via the !inetdbg.ref command
    in either NTSD or CDB.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/


#ifndef _REFTRACE_H_
#define _REFTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


#include <tracelog.h>


//
// This is the number of stack backtrace values captured in each
// trace log entry. This value is chosen to make the log entry
// exactly eight dwords long, making it a bit easier to interpret
// from within the debugger without the debugger extension.
//

#define REF_TRACE_LOG_STACK_DEPTH   5


//
// This defines the entry written to the trace log.
//

typedef struct _REF_TRACE_LOG_ENTRY {

    LONG NewRefCount;
    PVOID Context;
    PVOID Context1;
    PVOID Context2;
    PVOID Context3;
    DWORD Thread;
    PVOID Stack[REF_TRACE_LOG_STACK_DEPTH];

} REF_TRACE_LOG_ENTRY, *PREF_TRACE_LOG_ENTRY;


//
// Manipulators.
//

PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    );

VOID
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context
    );

VOID
WriteRefTraceLogEx(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context,
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Context3
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _REFTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\pudebug.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        pudebug.h

   Abstract:

      This module declares the DEBUG_PRINTS object helpful in
       testing the programs

   Author:

      Murali R. Krishnan    ( MuraliK )    14-Dec-1994
      Modified to include a and other functions ( 22-Dec-1994)

   Revision History:
      MuraliK  16-May-1995   Added function to read debug flags.
      MuraliK  12-Sept-1996  Added functions to dump the output.

--*/

# ifndef _PUDEBUG_H_
# define _PUDEBUG_H_


/************************************************************
 *     Include Headers
 ************************************************************/

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# include <windows.h>

# ifndef dllexp
# define dllexp   __declspec( dllexport)
# endif // dllexp

/***********************************************************
 *    Macros
 ************************************************************/

enum  PRINT_REASONS {
    PrintNone     = 0x0,   // Nothing to be printed
    PrintError    = 0x1,   // An error message
    PrintWarning  = 0x2,   // A  warning message
    PrintLog      = 0x3,   // Just logging. Indicates a trace of where ...
    PrintMsg      = 0x4,   // Echo input message
    PrintCritical = 0x5,   // Print and Exit
    PrintAssertion= 0x6    // Printing for an assertion failure
  };


enum  DEBUG_OUTPUT_FLAGS {
    DbgOutputNone     = 0x0,            // None
    DbgOutputKdb      = 0x1,            // Output to Kernel Debugger
    DbgOutputLogFile  = 0x2,            // Output to LogFile
    DbgOutputTruncate = 0x4,            // Truncate Log File if necessary
    DbgOutputStderr   = 0x8,            // Send output to std error
    DbgOutputBackup   = 0x10,           // Make backup of debug file ?
    DbgOutputAll      = 0xFFFFFFFF      // All the bits set.
  };


# define MAX_LABEL_LENGTH                 ( 100)



/*++
  class DEBUG_PRINTS

  This class is responsible for printing messages to log file / kernel debugger

  Currently the class supports only member functions for <ANSI> char.
   ( not unicode-strings).

--*/

typedef struct _DEBUG_PRINTS {

    CHAR         m_rgchLabel[MAX_LABEL_LENGTH];
    CHAR         m_rgchLogFilePath[MAX_PATH];
    CHAR         m_rgchLogFileName[MAX_PATH];
    HANDLE       m_LogFileHandle;
    HANDLE       m_StdErrHandle;
    BOOL         m_fInitialized;
    DWORD        m_dwOutputFlags;

} DEBUG_PRINTS, FAR * LPDEBUG_PRINTS;


dllexp
LPDEBUG_PRINTS
 PuCreateDebugPrintsObject(
   IN const char * pszPrintLabel,
   IN DWORD  dwOutputFlags);

//
// frees the debug prints object and closes any file if necessary.
//  Returns NULL on success or returns pDebugPrints on failure.
//
dllexp
LPDEBUG_PRINTS
 PuDeleteDebugPrintsObject(
   IN OUT LPDEBUG_PRINTS  pDebugPrints);


dllexp
VOID
 PuDbgPrint(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...);                               // arglist

/*++
  PuDbgDump() does not do any formatting of output.
  It just dumps the given message onto the debug destinations.
--*/
dllexp
VOID
 PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   );

//
// PuDbgAssertFailed() *must* be __cdecl to properly capture the
// thread context at the time of the failure.
//

dllexp
VOID
__cdecl
 PuDbgAssertFailed(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszExpression,
   IN const char *         pszMessage);

dllexp
VOID
 PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    );

VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum
    );

dllexp
VOID
 PuSetDbgOutputFlags(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN DWORD                dwFlags);

dllexp
DWORD
 PuGetDbgOutputFlags(
   IN const LPDEBUG_PRINTS       pDebugPrints);


//
// Following functions return Win32 error codes.
// NO_ERROR if success
//

dllexp
DWORD
 PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFileName,
   IN const char *         pszPathForFile);

dllexp
DWORD
 PuReOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);

dllexp
DWORD
 PuCloseDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);

dllexp
DWORD
  PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault);

dllexp DWORD
  PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault);

dllexp
DWORD
  PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg);


# define PuPrintToKdb( pszOutput)    \
                    if ( pszOutput != NULL)   {   \
                        OutputDebugString( pszOutput);  \
                    } else {}



# ifdef __cplusplus
};
# endif // __cplusplus

// begin_user_unmodifiable

# if DBG


/***********************************************************
 *    Macros
 ************************************************************/


extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
 DEBUG_PRINTS  *  g_pDebug;        // define a global debug variable


# define DECLARE_DEBUG_PRINTS_OBJECT()          \
         DEBUG_PRINTS  *  g_pDebug = NULL;


//
// Call the following macro as part of your initialization for program
//  planning to use the debugging class.
//
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)  \
        g_pDebug = PuCreateDebugPrintsObject( pszLabel, DEFAULT_OUTPUT_FLAGS);\
         if  ( g_pDebug == NULL) {   \
               OutputDebugStringA( "Unable to Create Debug Print Object \n"); \
         }

//
// Call the following macro once as part of the termination of program
//    which uses the debugging class.
//
# define DELETE_DEBUG_PRINT_OBJECT( )  \
        g_pDebug = PuDeleteDebugPrintsObject( g_pDebug);


# define VALID_DEBUG_PRINT_OBJECT()     \
        ( ( g_pDebug != NULL) && g_pDebug->m_fInitialized)


//
//  Use the DBG_CONTEXT without any surrounding braces.
//  This is used to pass the values for global DebugPrintObject
//     and File/Line information
//
# define DBG_CONTEXT        g_pDebug, __FILE__, __LINE__



# define DBG_CODE(s)          s          /* echoes code in debugging mode */


# define DBG_ASSERT( exp)    if ( !(exp)) { \
                                 PuDbgAssertFailed( DBG_CONTEXT, #exp, NULL); \
                             } else {}

# define DBG_ASSERT_MSG( exp, pszMsg)    \
                             if ( !(exp)) { \
                                  PuDbgAssertFailed( DBG_CONTEXT, #exp, pszMsg); \
                              } else {}

# define DBG_REQUIRE( exp)    DBG_ASSERT( exp)

# define DBG_LOG()            PuDbgPrint( DBG_CONTEXT, "\n")

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)   \
                  PuOpenDbgPrintFile( g_pDebug, (pszFile), (pszPath))

# define DBG_CLOSE_LOG_FILE( )   \
                  PuCloseDbgPrintFile( g_pDebug)


//
//  DBGPRINTF() is printing function ( much like printf) but always called
//    with the DBG_CONTEXT as follows
//   DBGPRINTF( ( DBG_CONTEXT, format-string, arguments for format list);
//
# define DBGPRINTF( args)     PuDbgPrint args

# define DBGDUMP( args)       PuDbgDump  args

# define DBGPRINT_CURRENT_TIME()  PuDbgPrintCurrentTime( DBG_CONTEXT)

# else // DBG


# define DECLARE_DEBUG_PRINTS_OBJECT()           /* Do Nothing */
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)    ((void)0) /* Do Nothing */
# define DELETE_DEBUG_PRINT_OBJECT( )            ((void)0) /* Do Nothing */
# define VALID_DEBUG_PRINT_OBJECT()              ( TRUE)

# define DBG_CODE(s)                             ((void)0) /* Do Nothing */

# define DBG_ASSERT(exp)                         ((void)0) /* Do Nothing */

# define DBG_ASSERT_MSG(exp, pszMsg)             ((void)0) /* Do Nothing */

# define DBG_REQUIRE( exp)                       ( (void) (exp))

# define DBGPRINTF( args)                        ((void)0) /* Do Nothing */

# define DBGDUMP( args)                          ((void)0) /* Do nothing */

# define DBG_LOG()                               ((void)0) /* Do Nothing */

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)    ((void)0) /* Do Nothing */

# define DBG_CLOSE_LOG_FILE()                    ((void)0) /* Do Nothing */

# define DBGPRINT_CURRENT_TIME()                 ((void)0) /* Do Nothing */

# endif // DBG


// end_user_unmodifiable

// begin_user_unmodifiable


#ifdef ASSERT
# undef ASSERT
#endif


# define ASSERT( exp)           DBG_ASSERT( exp)


# if DBG

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
 DWORD  g_dwDebugFlags;           // Debugging Flags

# define DECLARE_DEBUG_VARIABLE()     \
             DWORD  g_dwDebugFlags

# define SET_DEBUG_FLAGS( dwFlags)         g_dwDebugFlags = dwFlags
# define GET_DEBUG_FLAGS()                 ( g_dwDebugFlags)

# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault)  \
             g_dwDebugFlags = PuLoadDebugFlagsFromReg((hkey), (dwDefault))

# define LOAD_DEBUG_FLAGS_FROM_REG_STR(pszRegKey, dwDefault)  \
             g_dwDebugFlags = PuLoadDebugFlagsFromRegStr((pszRegKey), (dwDefault))

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)  \
               PuSaveDebugFlagsInReg((hkey), (dwDbg))

# define DEBUG_IF( arg, s)     if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                } else {}

# define IF_DEBUG( arg)        if ( DEBUG_## arg & GET_DEBUG_FLAGS())


# else   // DBG


# define DECLARE_DEBUG_VARIABLE()                /* Do Nothing */
# define SET_DEBUG_FLAGS( dwFlags)               /* Do Nothing */
# define GET_DEBUG_FLAGS()                       ( 0)
# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault) /* Do Nothing */

# define LOAD_DEBUG_FLAGS_FROM_REG_STR(pszRegKey, dwDefault)  /* Do Nothing */

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)    /* Do Nothing */

# define DEBUG_IF( arg, s)                       /* Do Nothing */
# define IF_DEBUG( arg)                          if ( 0)

# endif // DBG

// end_user_unmodifiable

// begin_user_modifiable

//
//  Debugging constants consist of two pieces.
//  All constants in the range 0x0 to 0x8000 are reserved
//  User extensions may include additional constants (bit flags)
//

# define DEBUG_API_ENTRY                  0x00000001L
# define DEBUG_API_EXIT                   0x00000002L
# define DEBUG_INIT_CLEAN                 0x00000004L
# define DEBUG_ERROR                      0x00000008L

                   // End of Reserved Range
# define DEBUG_RESERVED                   0x00000FFFL

// end_user_modifiable




/***********************************************************
 *    Platform Type related variables and macros
 ************************************************************/

//
// Enum for product types
//

typedef enum _PLATFORM_TYPE {

    PtInvalid = 0,                 // Invalid
    PtNtWorkstation = 1,           // NT Workstation
    PtNtServer = 2,                // NT Server
    PtWindows95 = 3,               // Windows 95
    PtWindows9x = 4                // Windows 9x - not implemented

} PLATFORM_TYPE;

//
// IISGetPlatformType is the function used to the platform type
//

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
dllexp
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        );

//
// External Macros
//

#define InetIsNtServer( _pt )           ((_pt) == PtNtServer)
#define InetIsNtWksta( _pt )            ((_pt) == PtNtWorkstation)
#define InetIsWindows95( _pt )          ((_pt) == PtWindows95)
#define InetIsValidPT(_pt)              ((_pt) != PtInvalid)

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
PLATFORM_TYPE    g_PlatformType;


// Use the DECLARE_PLATFORM_TYPE macro to declare the platform type
#define DECLARE_PLATFORM_TYPE()  \
   PLATFORM_TYPE    g_PlatformType = PtInvalid;

// Use the INITIALIZE_PLATFORM_TYPE to init the platform type
// This should typically go inside the DLLInit or equivalent place.
#define INITIALIZE_PLATFORM_TYPE()  \
   g_PlatformType = IISGetPlatformType();

//
// Additional Macros to use the Platform Type
//

#define TsIsNtServer( )         InetIsNtServer(g_PlatformType)
#define TsIsNtWksta( )          InetIsNtWksta(g_PlatformType)
#define TsIsWindows95()         InetIsWindows95(g_PlatformType)
#define IISIsValidPlatform()    InetIsValidPT(g_PlatformType)
#define IISPlatformType()       (g_PlatformType)


/***********************************************************
 *    Some utility functions for Critical Sections
 ************************************************************/

//
// IISSetCriticalSectionSpinCount() provides a thunk for the
//  original NT API SetCriticalSectionSpinCount() for CS with Spin counts
// Users of this function should definitely dynlink with kernel32.dll,
//  Otherwise errors will surface to a large extent
//
extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
);

//
// Macro for the calls to SetCriticalSectionSpinCount()
//
# define SET_CRITICAL_SECTION_SPIN_COUNT( lpCS, dwSpins) \
  IISSetCriticalSectionSpinCount( (lpCS), (dwSpins))

//
// IIS_DEFAULT_CS_SPIN_COUNT is the default value of spins used by
//  Critical sections defined within IIS.
// NYI: We should have to switch the individual values based on experiments!
// Current value is an arbitrary choice
//
# define IIS_DEFAULT_CS_SPIN_COUNT   (400)

# endif  /* _DEBUG_HXX_ */

//
// The following macros allow the automatic naming of certain Win32 objects.
// See IIS\SVCS\IRTL\DBGSUPP\WIN32OBJ.C for details on the naming convention.
//
// Set IIS_NAMED_WIN32_OBJECTS to a non-zero value to enable named events,
// semaphores, and mutexes.
//

#if DBG
#define IIS_NAMED_WIN32_OBJECTS 1
#else
#define IIS_NAMED_WIN32_OBJECTS 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

dllexp
HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    );

dllexp
HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );

dllexp
HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    );

#ifdef __cplusplus
}   // extern "C"
#endif

#if IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    PuDbgCreateEvent(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (manual),                                                           \
        (state)                                                             \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    PuDbgCreateSemaphore(                                                   \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial),                                                          \
        (maximum)                                                           \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    PuDbgCreateMutex(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial)                                                           \
        )

#else   // !IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    CreateEventA(                                                           \
        NULL,                                                               \
        (manual),                                                           \
        (state),                                                            \
        NULL                                                                \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    CreateSemaphoreA(                                                       \
        NULL,                                                               \
        (initial),                                                          \
        (maximum),                                                          \
        NULL                                                                \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    CreateMutexA(                                                           \
        NULL,                                                               \
        (initial),                                                          \
        NULL                                                                \
        )

#endif  // IIS_NAMED_WIN32_OBJECTS


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\sched.cxx ===
/*++
   Copyright    (c)    1995-1996     Microsoft Corporation

   Module Name:

       sched.cxx

   Abstract:

        This module contains a simple timer interface for scheduling future
        work items


   Author:

        John Ludeman    (johnl)     17-Jul-1995

   Project:

        Internet Servers Common Server DLL

   Revisions:
        Murali R. Krishnan  (MuraliK)     16-Sept-1996
          Added scheduler items cache
--*/

//
//  Include Headers
//

#include "isatq.hxx"
#include "sched.hxx"

//
//  Global definitions
//

#define LockScheduleList()      EnterCriticalSection( &csSchedulerLock )
#define UnlockScheduleList()    LeaveCriticalSection( &csSchedulerLock )

#define NUM_SCHEDULE_THREADS_PWS        1
#define NUM_SCHEDULE_THREADS_NTS        1

ALLOC_CACHE_HANDLER * SCHED_ITEM::sm_pachSchedItems = NULL;

SCHED_ITEM_STATE sg_rgSchedNextState[SI_OP_MAX][SI_MAX_ITEMS] = {
    // operation = SI_OP_ADD
    {
        SI_ERROR,
        SI_ACTIVE,
        SI_ERROR,
        SI_ERROR,
        SI_ERROR,
        SI_ERROR,
    },

    // operation = SI_OP_ADD_PERIODIC
    {
        SI_ERROR,
        SI_ACTIVE_PERIODIC,
        SI_ERROR,
        SI_ERROR,
        SI_ACTIVE_PERIODIC,  // rescheduling periodic item
        SI_ERROR,
    },

    // operation = SI_OP_CALLBACK
    {
        SI_ERROR,
        SI_ERROR,
        SI_TO_BE_DELETED,  // to be removed after completing callbacks
        SI_CALLBACK_PERIODIC,
        SI_ERROR,
        SI_ERROR,
    },

    // operation = SI_OP_DELETE
    {
        SI_ERROR,
        SI_ERROR,
        SI_IDLE,
        SI_IDLE,
        SI_TO_BE_DELETED,  // mark this to be deleted after return
        SI_TO_BE_DELETED,  // idempotent delete operations
    }
};



SCHED_ITEM *
I_FindSchedulerItem( DWORD dwCookie);

VOID
I_InsertIntoWorkItemList( SCHED_ITEM * psi);


DWORD
SchedulerThread(
    LPDWORD lpdwParam
    );

//
//  Global data items
//

LIST_ENTRY        ScheduleListHead;
CRITICAL_SECTION  csSchedulerLock;
BOOL              fSchedulerInitialized = FALSE;
BOOL              fSchedShutdown = FALSE;
HANDLE            hSchedulerEvent;
DWORD             cSchedThreads = 0;

//
//  Used as identification cookie for removing items
//

DWORD             dwSchedSerial = 0;


/************************************************************
 *  Public functions of Scheduler
 ************************************************************/



BOOL
SchedulerInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the scheduler/timer package

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    DWORD   idThread;
    DWORD   i;
    DWORD   numThreads;

    if ( fSchedulerInitialized ) {
        return TRUE;
    }

    InitializeSecondsTimer();

    hSchedulerEvent = IIS_CREATE_EVENT(
                          "hSchedulerEvent",
                          &hSchedulerEvent,
                          FALSE,
                          FALSE
                          );

    if ( hSchedulerEvent == NULL ) {
        return FALSE;
    }

    if ( TsIsNtServer() ) {
        numThreads = NUM_SCHEDULE_THREADS_NTS;
    } else {
        numThreads = NUM_SCHEDULE_THREADS_PWS;
    }

    InitializeCriticalSection( &csSchedulerLock );
    SET_CRITICAL_SECTION_SPIN_COUNT( &csSchedulerLock,
                                     IIS_DEFAULT_CS_SPIN_COUNT);

    InitializeListHead( &ScheduleListHead );

    for ( i = 0; i < numThreads; i++ ) {

        HANDLE hSchedulerThread;

        hSchedulerThread =
            CreateThread( NULL,
                          0,
                          (LPTHREAD_START_ROUTINE) SchedulerThread,
                          NULL,
                          0,
                          &idThread );

        if ( !hSchedulerThread ) {
            DeleteCriticalSection( &csSchedulerLock );
            CloseHandle( hSchedulerEvent );
            return FALSE;
        }

        DBG_REQUIRE( CloseHandle( hSchedulerThread ));

        cSchedThreads++;
    }

    DBG_REQUIRE( SCHED_ITEM::Initialize());

    fSchedulerInitialized = TRUE;

    return TRUE;
} // SchedulerInitialize()



VOID
SchedulerTerminate(
    VOID
    )
/*++

Routine Description:

    Terminates and cleans up the scheduling package.  Any items left on the
    list are *not* called during cleanup.

--*/
{
    DWORD iRetry;

    if ( !fSchedulerInitialized || fSchedShutdown) {
        // either uninitialized or already shutting down
        return;
    }

    fSchedShutdown = TRUE;

    DBG_REQUIRE( SetEvent( hSchedulerEvent ) );

    LockScheduleList();

    //
    //  Delete all of the items that were scheduled, note we do *not*
    //  call any scheduled items in the list (there shouldn't be any)
    //

    if ( !IsListEmpty( &ScheduleListHead ) ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "[SchedulerTerminate] Warning - Items in schedule list "
                    "at termination\n" ));
    }

    UnlockScheduleList();

    //
    // If this function is called from DLL terminate, then the threads are dead
    //  So try finite times and give up
    // loop and wait for scheduler thread to die out
    //

    for ( iRetry = 0; cSchedThreads && (iRetry < 5); iRetry++) {

        //
        // Set the event again, so that some other thread will wake up and die
        //

        DBG_REQUIRE( SetEvent( hSchedulerEvent ) );
        Sleep( 100 );  // give some time for thread to die out
    } // for

    DeleteCriticalSection( &csSchedulerLock );
    CloseHandle( hSchedulerEvent );

    SCHED_ITEM::Cleanup();
    fSchedulerInitialized = FALSE;
} // SchedulerTerminate()



DWORD
ScheduleWorkItem(
    PFN_SCHED_CALLBACK pfnCallback,
    PVOID              pContext,
    DWORD              msecTime,
    BOOL               fPeriodic
    )
/*++

Routine Description:

    Adds a timed work item to the work list

Arguments:

    pfnCallback - Function to call
    pContext - Context to pass to the callback
    msecTime - number of milliseconds to wait before calling timeout
    nPriority - Thread priority to set for work item

Return Value:

    zero on failure, non-zero on success.  The return value can be used to
    remove the scheduled work item.

--*/
{
    SCHED_ITEM * psi;
    DWORD        dwRet;

    ATQ_ASSERT( fSchedulerInitialized );

    //
    // 1. alloc a new scheduler item
    //

    psi = new SCHED_ITEM( pfnCallback,
                          pContext,
                          msecTime,
                          ++dwSchedSerial );

    if ( !psi ) {

        //
        // unable to create the item - return error cookie '0'
        //

        return 0;
    }

    dwRet = psi->_dwSerialNumber;
    SCHED_OPS  siop = ((fPeriodic)? SI_OP_ADD_PERIODIC : SI_OP_ADD);
    psi->_siState = sg_rgSchedNextState[siop][SI_IDLE];

    //
    // 2. Insert the scheduler item into the active scheduler work-items list.
    //

    LockScheduleList();
    I_InsertIntoWorkItemList( psi);
    UnlockScheduleList();

    //
    // 3. Indicate to scheduler threads that there is one new item on the list
    //

    DBG_REQUIRE( SetEvent( hSchedulerEvent ));

    return dwRet;
} // ScheduleWorkItem()



BOOL
RemoveWorkItem(
    DWORD  dwCookie
    )
/*++

Routine Description:

    Removes a scheduled work item

Arguments:

    dwCookie - The return value from a previous call to ScheduleWorkItem

Return Value:

    TRUE if the item was found, FALSE if the item was not found.

--*/
{
    SCHED_ITEM * psi;
    BOOL fWait = FALSE;

    //
    // 1. lock the list
    //

    LockScheduleList();

    //
    // 2. Find scheduler item on the list.
    //

    psi = I_FindSchedulerItem( dwCookie);

    if ( NULL != psi) {

        //
        // 3. based on the state of the item take necessary actions.
        //

        SCHED_ITEM_STATE st =
            sg_rgSchedNextState[SI_OP_DELETE][psi->_siState];
        psi->_siState = st;
        switch ( st) {
        case SI_IDLE: {
            // delete immediately
            RemoveEntryList( &psi->_ListEntry );
            psi->_ListEntry.Flink = NULL;
            delete psi;
            break;
        }

        case SI_TO_BE_DELETED: {

            DBGPRINTF(( DBG_CONTEXT,
                        "SchedItem(%08x) marked to be deleted\n",
                        psi));
            // item will be deleted later.

            if (psi->FInsideCallbackOnOtherThread()) {
                // need to wait till callback complete
                psi->AddEvent();
                fWait = TRUE;
            }
            break;
        }

        default:
            DBG_ASSERT( FALSE);
            break;
        } // switch()
    }

    // 4. Unlock the list
    UnlockScheduleList();

    // 5. Wait for callback event and release the item
    if (fWait)
        psi->WaitForEventAndRelease();

    // return TRUE if we found the item
    return ( NULL != psi);
} // RemoveWorkItem()





dllexp
DWORD
ScheduleAdjustTime(
    DWORD dwCookie,
    DWORD msecNewTime
    )
/*++
  This function finds the scheduler object for given cookie and changes
  the interval for next timeout of the item.

--*/
{
    SCHED_ITEM * psi;

    DBG_ASSERT( 0 != dwCookie);

    LockScheduleList();
    // 1. Find the work item for given cookie
    psi = I_FindSchedulerItem( dwCookie);

    if ( NULL != psi) {

        // 2. Remove the item from the list
        RemoveEntryList( &psi->_ListEntry );
        psi->_ListEntry.Flink = NULL;

        // 2. Change the timeout value

        psi->ChangeTimeInterval( msecNewTime);

        // 3. Recalc expiry time and reinsert into the list of work items.
        psi->CalcExpiresTime();
        I_InsertIntoWorkItemList( psi);
    }

    UnlockScheduleList();

    // 4. Indicate to scheduler threads that there is one new item on the list
    DBG_REQUIRE( SetEvent( hSchedulerEvent ));

    return ( (NULL != psi) ? NO_ERROR : ERROR_INVALID_PARAMETER);
} // ScheduleAdjustTime()



/************************************************************
 *  Internal functions of Scheduler
 ************************************************************/



VOID
I_InsertIntoWorkItemList( SCHED_ITEM * psi)
{
    SCHED_ITEM * psiList;
    LIST_ENTRY * pEntry;

    DBG_ASSERT( NULL != psi);

    DBG_ASSERT( (psi->_siState == SI_ACTIVE) ||
                (psi->_siState == SI_ACTIVE_PERIODIC) ||
                (psi->_siState == SI_CALLBACK_PERIODIC ) );

    // Assumed that the scheduler list is locked.

    //
    //  Insert the list in order based on expires time
    //

    for ( pEntry =  ScheduleListHead.Flink;
          pEntry != &ScheduleListHead;
          pEntry =  pEntry->Flink )
    {
        psiList = CONTAINING_RECORD( pEntry, SCHED_ITEM, _ListEntry );

        if ( psiList->_msecExpires > psi->_msecExpires )
        {
            break;
        }
    }

    //
    // Insert the item psi in front of the item pEntry
    //  This should work in whether the list is empty or this is the last item
    //  on the list
    //

    psi->_ListEntry.Flink = pEntry;
    psi->_ListEntry.Blink = pEntry->Blink;

    pEntry->Blink->Flink = &psi->_ListEntry;
    pEntry->Blink        = &psi->_ListEntry;

    return;
} // I_InsertIntoWorkItemList()


SCHED_ITEM *
I_FindSchedulerItem( DWORD dwCookie)
{
    PLIST_ENTRY  pEntry;
    SCHED_ITEM * psi = NULL;

    // Should be called with the scheduler list locked.

    for ( pEntry =  ScheduleListHead.Flink;
          pEntry != &ScheduleListHead;
          pEntry = pEntry->Flink )
    {
        psi = CONTAINING_RECORD( pEntry, SCHED_ITEM, _ListEntry );

        ATQ_ASSERT( psi->CheckSignature() );

        if ( dwCookie == psi->_dwSerialNumber ) {

            // found the match - return
            return ( psi);
        }
    } // for

    return ( NULL);
} // I_FindSchedulerItem()



DWORD
SchedulerThread(
    LPDWORD lpdwParam
    )
/*++

Routine Description:

    Initializes the scheduler/timer package

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    DWORD        cmsecWait = INFINITE;
    __int64      TickCount;
    SCHED_ITEM * psi, * psiExpired;
    LIST_ENTRY * pEntry;
    BOOL         fListLocked = FALSE;
    DWORD        dwWait = 0;

    while (!fSchedShutdown) {

        ATQ_ASSERT(!fListLocked); // the list must be unlocked here

        while ( TRUE ) {

            MSG msg;

            //
            // Need to do MsgWait instead of WaitForSingleObject
            // to process windows msgs.  We now have a window
            // because of COM.
            //

            dwWait = MsgWaitForMultipleObjects( 1,
                                             &hSchedulerEvent,
                                             FALSE,
                                             cmsecWait,
                                             QS_ALLINPUT );

            if (fSchedShutdown) {
                goto exit;
            }

            if ( (dwWait == WAIT_OBJECT_0) ||
                 (dwWait == WAIT_TIMEOUT) ) {
                break;
            }

            while ( PeekMessage( &msg,
                                 NULL,
                                 0,
                                 0,
                                 PM_REMOVE ))
            {
                DispatchMessage( &msg );
            }
        }

        switch (dwWait) {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "[Scheduler] Error %d waiting on SchedulerEvent\n",
                        GetLastError() ));
            //  Fall through

        case WAIT_OBJECT_0:
            //  Means a new item has been scheduled, reset the timeout or
            //  we are shutting down

            LockScheduleList();
            fListLocked = TRUE;

            //  Get the timeout value for the first item in the list

            if (!IsListEmpty(&ScheduleListHead)) {
                psi = CONTAINING_RECORD( ScheduleListHead.Flink,
                                         SCHED_ITEM,
                                         _ListEntry );

                ATQ_ASSERT(psi->CheckSignature());

                //  Make sure the front item hasn't already expired

                TickCount = GetCurrentTimeInMilliseconds();

                if (TickCount > psi->_msecExpires) {
                    //  Run scheduled items
                    break;
                }

                // the delay is guaranteed NOT to be > 1<<32
                // as per parameter to SCHED_ITEM constructor

                cmsecWait = (DWORD)(psi->_msecExpires - TickCount);
            }
            else {
                cmsecWait = INFINITE;
            }

            UnlockScheduleList();
            fListLocked = FALSE;

            // Wait for something else (back to sleep)
            continue;

        case WAIT_TIMEOUT:
            //  Run scheduled items
            break;
        }

        //  Run scheduled items

        while (!fSchedShutdown) {
            //  Lock the list if needed

            if (!fListLocked) {
                LockScheduleList();
                fListLocked = TRUE;
            }

            //  No timeout by default (if no items found)

            cmsecWait = INFINITE;

            if (IsListEmpty(&ScheduleListHead))
                break;

            //  Find the first expired work item

            TickCount = GetCurrentTimeInMilliseconds();

            psiExpired = NULL;

            for ( pEntry  = ScheduleListHead.Flink;
                  pEntry != &ScheduleListHead;
                ) {
                psi = CONTAINING_RECORD(pEntry, SCHED_ITEM, _ListEntry);
                pEntry = pEntry->Flink;

                ATQ_ASSERT(psi->CheckSignature());

                if ( ((psi->_siState == SI_ACTIVE) ||
                      (psi->_siState == SI_ACTIVE_PERIODIC)) ) {

                    if (TickCount > psi->_msecExpires) {
                        //  Found Expired Item
                        psiExpired = psi;
                    }
                    else {
                        //  Since they are in sorted order once we hit one that's
                        //  not expired we don't need to look further
                        cmsecWait = (DWORD)(psi->_msecExpires - TickCount);
                    }
                    break;
                }
            }

            //  If no expired work items found, go back to sleep

            if (psiExpired == NULL) {
                break;
            }

            //  Take care of the found expired work item

            SCHED_ITEM_STATE st =
                sg_rgSchedNextState[SI_OP_CALLBACK][psiExpired->_siState];

            psiExpired->_siState = st;

            //  Take care of the NON-PERIODIC case

            if (st == SI_TO_BE_DELETED) { // non-periodic?

                //  Remove this item from the list
                RemoveEntryList( &psiExpired->_ListEntry );
                psiExpired->_ListEntry.Flink = NULL;

                //  Unlock List
                ATQ_ASSERT(fListLocked);
                UnlockScheduleList();
                fListLocked = FALSE;

                //  Call callback funcitons
                psiExpired->_pfnCallback(psiExpired->_pContext);

                //  Get rid of the item regardless of state
                delete psiExpired;
                //  Find next expired item
                continue;
            }

            //  Take care of the PERIODIC case

            DBG_ASSERT(st == SI_CALLBACK_PERIODIC);

            psiExpired->_dwCallbackThreadId = GetCurrentThreadId();

            //  Unlock the list while in the callback
            ATQ_ASSERT(fListLocked);
            UnlockScheduleList();
            fListLocked = FALSE;

            //  While in PERIODIC callback the list is kept unlocked
            //  leaving the object exposed

            psiExpired->_pfnCallback( psiExpired->_pContext );

            //  Relock the list
            ATQ_ASSERT(!fListLocked);
            LockScheduleList();
            fListLocked = TRUE;

            psiExpired->_dwCallbackThreadId = 0;

            //  While in the callback the state can change
            if (psiExpired->_siState == SI_TO_BE_DELETED) {
                //  User requested delete

                //  Remove this item from the list
                RemoveEntryList( &psiExpired->_ListEntry );
                psiExpired->_ListEntry.Flink = NULL;

                //  While in callback RemoveWorkItem() could have attached
                //  an event to notify itself when callback is done
                if (psiExpired->_hCallbackEvent) {
                    //  Signal the event after item is gone from the list
                    SetEvent(psiExpired->_hCallbackEvent);
                    //  RemoveWorkItem() will remove the item
                }
                else {
                    //  Get rid of the item
                    delete psiExpired;
                }
            }
            else {
                // no events attached
                DBG_ASSERT(psiExpired->_hCallbackEvent == NULL);

                // must still remain SI_CALLBACK_PERIODIC unless deleted
                DBG_ASSERT(psiExpired->_siState == SI_CALLBACK_PERIODIC);

                // NYI: For now remove from the list and reinsert it
                RemoveEntryList( &psiExpired->_ListEntry );
                psiExpired->_ListEntry.Flink = NULL;

                // recalc the expiry time and reinsert into the list
                psiExpired->_siState =
                    sg_rgSchedNextState[SI_OP_ADD_PERIODIC]
                                       [psiExpired->_siState];
                psiExpired->CalcExpiresTime();
                I_InsertIntoWorkItemList(psiExpired);
            }

            //  Start looking in the list from the beginning in case
            //  new items have been added or other threads removed
            //  them

        } // while

        if (fListLocked) {
            UnlockScheduleList();
            fListLocked = FALSE;
        }

    } // while

exit:
    InterlockedDecrement( (LONG *) &cSchedThreads );
    return 0;
} // SchedulerThread()



BOOL
SCHED_ITEM::Initialize( VOID)
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, 25, sizeof(SCHED_ITEM)};

    if ( NULL != sm_pachSchedItems) {

        // already initialized
        return ( TRUE);
    }

    sm_pachSchedItems = new ALLOC_CACHE_HANDLER( "SchedItems",
                                                 &acConfig);

    return ( NULL != sm_pachSchedItems);
} // SCHED_ITEM::Initialize()


VOID
SCHED_ITEM::Cleanup( VOID)
{
    if ( NULL != sm_pachSchedItems) {

        delete sm_pachSchedItems;
        sm_pachSchedItems = NULL;
    }

    return;
} // SCHED_ITEM::Cleanup()


VOID *
SCHED_ITEM::operator new( size_t s)
{
    DBG_ASSERT( s == sizeof( SCHED_ITEM));

    // allocate from allocation cache.
    DBG_ASSERT( NULL != sm_pachSchedItems);
    return (sm_pachSchedItems->Alloc());
} // SCHED_ITEM::operator new()

VOID
SCHED_ITEM::operator delete( void * psi)
{
    DBG_ASSERT( NULL != psi);

    // free to the allocation pool
    DBG_ASSERT( NULL != sm_pachSchedItems);
    DBG_REQUIRE( sm_pachSchedItems->Free(psi));

    return;
} // SCHED_ITEM::operator delete()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\inetsvcs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetsvcs.h

Abstract:

    Header file for Internet Services common data/functions.

Author:

    Murali R. Krishnan (MuraliK)   20-Feb-1996  - Migrated from old tcpsvcs.h

Revision History:

--*/

#ifndef _INETSVCS_H_
#define _INETSVCS_H_

//
// Service DLLs are loaded into master service executable (eg: inetinfo.exe)
//   All the dlls should export this entry point
//    defined by INETSVCS_ENTRY_POINT
//
// Note that INETSVCS_ENTRY_POINT_STRING is always ANSI, because that's
// what GetProcAddress takes.
//

#define INETSVCS_ENTRY_POINT         ServiceEntry
#define INETSVCS_ENTRY_POINT_STRING  "ServiceEntry"

//
// Start and stop RPC server entry point prototype.
//

typedef
DWORD
(*PTCPSVCS_START_RPC_SERVER_LISTEN) (
    VOID
    );

typedef
DWORD
(*PTCPSVCS_STOP_RPC_SERVER_LISTEN) (
    VOID
    );

//
// Structure containing "global" data for the various DLLs.
//

typedef struct _TCPSVCS_GLOBAL_DATA {

    //
    // Entry points provided by TCPSVCS.EXE.
    //

    PTCPSVCS_START_RPC_SERVER_LISTEN  StartRpcServerListen;
    PTCPSVCS_STOP_RPC_SERVER_LISTEN   StopRpcServerListen;

} TCPSVCS_GLOBAL_DATA, *PTCPSVCS_GLOBAL_DATA;

//
// Service DLL entry point prototype.
//

typedef
VOID
(*PINETSVCS_SERVICE_DLL_ENTRY) (
    IN DWORD argc,
    IN LPSTR argv[],
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    );


#if DBG
#define IIS_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define IIS_PRINTF( x )
#endif

#define BUG_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }


#define INIT_LOCK(_lock)        InitializeCriticalSection( _lock );
#define DELETE_LOCK(_lock)      DeleteCriticalSection( _lock );
#define ACQUIRE_LOCK(_lock)     EnterCriticalSection( _lock );
#define RELEASE_LOCK(_lock)     LeaveCriticalSection( _lock );

//
// Event used to indicate whether service is running as exe
//

#define IIS_AS_EXE_OBJECT_NAME  "Internet_infosvc_as_exe"


#endif	// ifndef _INETSVCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\spud.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      spud.cxx

   Abstract:
      This module implements the user mode entry points for SPUD.SYS.
      SPUD = Special Purpose Utility Driver.

   Author:

       John Ballard ( jballard )     22-Oct-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

   Functions Exported:

       BOOL  AtqTransmitFileAndRecv();
       BOOL  AtqSendAndRecv();
       BOOL  AtqBatchRequest();

--*/


#include "isatq.hxx"
#include <tdi.h>
#include <afd.h>
#include <spud.h>
#include "uspud.h"

#if 0
VOID
EnableLoadDriverPrivilege(
    VOID
    );

#define SPUD_REG_PATH   \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Spud"

BOOL
I_AtqSpudInitialize(
            IN HANDLE hPort
            )
{
    NTSTATUS    status;
    UNICODE_STRING  DriverName;
    DWORD   Version = SPUD_VERSION;

    if ( !g_fUseDriver ) {
        return(FALSE);
    }

    EnableLoadDriverPrivilege();

    g_pfnRtlInitUnicodeString( &DriverName, SPUD_REG_PATH );
    status = g_pfnNtLoadDriver( &DriverName );
    if ( ( status != STATUS_SUCCESS ) &&
         ( status != STATUS_IMAGE_ALREADY_LOADED ) ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "NtLoadDriver failed!!! status == %08lx\n",
                     status
                     ));
        goto disable_driver;
    }

    status = SPUDInitialize(Version, hPort);
    if ( status != STATUS_SUCCESS ) {

        if ( status == STATUS_INVALID_DEVICE_REQUEST ) {
            SPUDTerminate();
            if ( SPUDInitialize(Version, hPort) == STATUS_SUCCESS ) {
                return TRUE;
            }
        }

        ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDInitialize failed!!! status == %08lx\n",
                     status
                     ));
        goto disable_driver;
    }

    return TRUE;

disable_driver:

    g_fUseDriver = FALSE;

    ATQ_PRINTF((DBG_CONTEXT, "SPUDInitialize: Disabling driver\n"));
    return(FALSE);
} // I_AtqSpudInitialize


BOOL
I_AtqSpudTerminate()
{
    NTSTATUS    status;

    status = SPUDTerminate();
    if ( status != STATUS_SUCCESS ) {

        IF_DEBUG(ERROR) {
            ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDTerminate failed!!! status == %08lx\n",
                     status
                     ));
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
I_AtqSpudCheckStatus(
    IN PATQ_CONT                patqContext             // pointer to ATQ context
    )
{
        ULONG status;

        status = SPUDCheckStatus( &patqContext->spudContext );

        if ( status != STATUS_SUCCESS ) {
                return FALSE;
        }

        return TRUE;
}

BOOL
I_AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
/*++
Routine Description:

    Calls SPUDTransmitFileAndRecv().  Cannot be blocked by bandwidth throttler

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
--*/
{
        ULONG   status;
        AFD_TRANSMIT_FILE_INFO transmitInfo;
        AFD_RECV_INFO          recvInfo;
        PATQ_CONT              patqCont = (PATQ_CONT)patqContext;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                     "I_AtqTransmitFileAndRecv(%08lx) called.\n", patqContext));
        }

        transmitInfo.WriteLength.QuadPart = dwBytesInFile;
        transmitInfo.SendPacketLength = 0;
        transmitInfo.FileHandle = hFile;
        transmitInfo.Flags = dwTFFlags;
        if ( lpTransmitBuffers != NULL ) {
            transmitInfo.Head = lpTransmitBuffers->Head;
            transmitInfo.HeadLength = lpTransmitBuffers->HeadLength;
            transmitInfo.Tail = lpTransmitBuffers->Tail;
            transmitInfo.TailLength = lpTransmitBuffers->TailLength;
        } else {
            transmitInfo.Head = NULL;
            transmitInfo.HeadLength = 0;
            transmitInfo.Tail = NULL;
            transmitInfo.TailLength = 0;
        }

        transmitInfo.Offset.LowPart = patqContext->Overlapped.Offset;
        transmitInfo.Offset.HighPart = 0;

        recvInfo.BufferArray = pwsaBuffers;
        recvInfo.BufferCount = dwBufferCount;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
        patqCont->ResetFlag( ACF_RECV_CALLED);

        //
        // Set this flag here to avoid a race with completion handling code
        // Reset if SPUDTransmitFileAndRecv fails
        //
        patqCont->SetFlag( ACF_RECV_ISSUED);

        status = SPUDTransmitFileAndRecv( patqCont->hAsyncIO,
                                         &transmitInfo,
                                         &recvInfo,
                                         &patqCont->spudContext
                                         );

#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of all non-oplock notification.
            // This is for debugging purpose only.
            //
            // Code 0xfbfbfbfb indicates a SPUD TransmitFileAndRecv request
            //

            patqCont->NotifyIOCompletion( 0, status, 0xfbfbfbfb );
#endif

        if ( status != STATUS_SUCCESS &&
             status != STATUS_PENDING ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "SPUDTransmitFileAndRecv failed!!! status == %08lx\n",
                         status
                         ));
            SetLastError(g_pfnRtlNtStatusToDosError(status));
            patqCont->MoveState( ACS_SOCK_CONNECTED);
            patqCont->ResetFlag( ACF_RECV_ISSUED);
            return FALSE;
        }

        return TRUE;
}

BOOL
AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( !g_fUseDriver || pContext->IsFlag( ACF_RECV_ISSUED) ) {
        BOOL            fRes;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                "AtqTransmitFileAndRecv(%08lx) g_fUseDriver == FALSE\n Calling AtqTransmitFile.\n", patqContext));
        }

        return AtqTransmitFile( patqContext,
                                hFile,
                                dwBytesInFile,
                                lpTransmitBuffers,
                                dwTFFlags );
    }

    I_SetNextTimeout(pContext);

    pContext->BytesSent = dwBytesInFile;

    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent += pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf <= (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( dwTFFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwTFFlags = TF_WRITE_BEHIND;

    }

    InterlockedIncrement( &pContext->m_nIO);

    switch ( pBandwidthInfo->QueryStatus( AtqIoXmitFileRecv ) )
    {
    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();

        fRes = I_AtqTransmitFileAndRecv( patqContext,
                                         hFile,
                                         dwBytesInFile,
                                         lpTransmitBuffers,
                                         dwTFFlags,
                                         pwsaBuffers,
                                         dwBufferCount ) ||
                (GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoXmitFileRecv;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;

        pContext->arInfo.uop.opXmitRecv.hFile = hFile;
        pContext->arInfo.uop.opXmitRecv.dwBytesInFile = dwBytesInFile;
        pContext->arInfo.uop.opXmitRecv.lpXmitBuffers = lpTransmitBuffers;
        pContext->arInfo.uop.opXmitRecv.dwTFFlags     = dwTFFlags;
        pContext->arInfo.uop.opXmitRecv.dwBufferCount = dwBufferCount;

        if ( dwBufferCount == 1) {
            pContext->arInfo.uop.opXmitRecv.buf1.len = pwsaBuffers->len;
            pContext->arInfo.uop.opXmitRecv.buf1.buf = pwsaBuffers->buf;
            pContext->arInfo.uop.opXmitRecv.pBufAll  = NULL;
        } else {

            DBG_ASSERT( dwBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opXmitRecv.pBufAll = pBuf;
                CopyMemory( pBuf, pwsaBuffers,
                            dwBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqTransmitFileAndRecv()

BOOL
I_AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
/*++
Routine Description:

    Calls SPUDSendAndRecv().  Cannot be blocked by bandwidth throttler.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
--*/
{
        ULONG   status;
        AFD_SEND_INFO          sendInfo;
        AFD_RECV_INFO          recvInfo;
        PATQ_CONT              patqCont = (PATQ_CONT)patqContext;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                 "I_AtqSendAndRecv(%08lx) called.\n", patqContext));
        }

        sendInfo.BufferArray = pwsaSendBuffers;
        sendInfo.BufferCount = dwSendBufferCount;
        sendInfo.AfdFlags = AFD_OVERLAPPED;
        sendInfo.TdiFlags = 0;

        recvInfo.BufferArray = pwsaRecvBuffers;
        recvInfo.BufferCount = dwRecvBufferCount;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
        patqCont->ResetFlag( ACF_RECV_CALLED);

        //
        // Set this flag before SPUD call to avoid a race with completion
        // Reset if SPUDSendAndRecv fails
        //
        patqCont->SetFlag( ACF_RECV_ISSUED);

        status = SPUDSendAndRecv( patqCont->hAsyncIO,
                                 &sendInfo,
                                 &recvInfo,
                                 &patqCont->spudContext
                                 );

        if ( status != STATUS_SUCCESS &&
             status != STATUS_PENDING ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDSendAndRecv failed!!! status == %08lx\n",
                     status
                     ));
             SetLastError(g_pfnRtlNtStatusToDosError(status));
             patqCont->ResetFlag( ACF_RECV_ISSUED);
             return FALSE;
        }

        return TRUE;
}

BOOL
AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
            "AtqSendAndRecv(%08lx) called.\n", patqContext));
    }

    if ( !g_fUseDriver || pContext->IsFlag( ACF_RECV_ISSUED) ) {

        BOOL            fRes;
        DWORD           cbWritten;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                 "AtqSendAndRecv(%08lx) g_fUseDriver == FALSE\n Calling AtqWriteSocket.\n", patqContext));
        }

        return AtqWriteSocket( patqContext,
                               pwsaSendBuffers,
                               dwSendBufferCount,
                               &patqContext->Overlapped );
    }

    InterlockedIncrement( &pContext->m_nIO);

    I_SetNextTimeout(pContext);

    //
    // count the number of bytes
    //

    DBG_ASSERT( dwSendBufferCount >= 1);
    pContext->BytesSent = pwsaSendBuffers->len;
    if ( dwSendBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaSendBuffers + 1;
            pWsaBuf <= (pwsaSendBuffers + dwSendBufferCount);
            pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }


    DBG_ASSERT( dwRecvBufferCount >= 1);
    pContext->BytesSent += pwsaRecvBuffers->len;
    if ( dwRecvBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaRecvBuffers + 1;
              pWsaBuf <= (pwsaRecvBuffers + dwRecvBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    switch ( pBandwidthInfo->QueryStatus( AtqIoSendRecv ) )
    {
    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();

        fRes = I_AtqSendAndRecv( patqContext,
                                 pwsaSendBuffers,
                                 dwSendBufferCount,
                                 pwsaRecvBuffers,
                                 dwRecvBufferCount ) ||
                (GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoSendRecv;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;
        pContext->arInfo.uop.opSendRecv.dwSendBufferCount = dwSendBufferCount;
        pContext->arInfo.uop.opSendRecv.dwRecvBufferCount = dwRecvBufferCount;

        if ( dwSendBufferCount == 1) {
            pContext->arInfo.uop.opSendRecv.sendbuf1.len = pwsaSendBuffers->len;
            pContext->arInfo.uop.opSendRecv.sendbuf1.buf = pwsaSendBuffers->buf;
            pContext->arInfo.uop.opSendRecv.pSendBufAll  = NULL;
        } else {

            DBG_ASSERT( dwSendBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwSendBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opSendRecv.pSendBufAll = pBuf;
                CopyMemory( pBuf, pwsaSendBuffers,
                            dwSendBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        if ( dwRecvBufferCount == 1) {
            pContext->arInfo.uop.opSendRecv.recvbuf1.len = pwsaRecvBuffers->len;
            pContext->arInfo.uop.opSendRecv.recvbuf1.buf = pwsaRecvBuffers->buf;
            pContext->arInfo.uop.opSendRecv.pRecvBufAll = NULL;
        } else {

            DBG_ASSERT( dwRecvBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwRecvBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opSendRecv.pRecvBufAll = pBuf;
                CopyMemory( pBuf, pwsaRecvBuffers,
                            dwRecvBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqSendAndRecv()




//
//  Short routine to enable the LoadDriverPrivilege for loading spud.sys
//

VOID EnableLoadDriverPrivilege(
    VOID
    )
{
    HANDLE ProcessHandle;
    HANDLE TokenHandle;
    BOOL Result;
    LUID LoadDriverValue;
    TOKEN_PRIVILEGES * TokenPrivileges;
    CHAR buf[ 5 * sizeof(TOKEN_PRIVILEGES) ];

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        goto Cleanup;
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 &TokenHandle
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        goto Cleanup;

    }

    //
    // Find out the value of LoadDriverPrivilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeLoadDriverPrivilege",
                 &LoadDriverValue
                 );

    if ( !Result ) {

        goto Cleanup;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges = (TOKEN_PRIVILEGES *) buf;

    TokenPrivileges->PrivilegeCount = 1;
    TokenPrivileges->Privileges[0].Luid = LoadDriverValue;
    TokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                TokenPrivileges,
                sizeof(buf),
                NULL,
                NULL
                );
Cleanup:

    if ( TokenHandle )
    {
        CloseHandle( TokenHandle );
    }

    if ( ProcessHandle )
    {
        CloseHandle( ProcessHandle );
    }
}

HANDLE
AtqCreateFile(
    LPCSTR lpAFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    )
{

    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR lpFileName;

    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    ULONG CreateFlags;
    DWORD SQOSFlags;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    POPLOCK_INFO pOplock;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    g_pfnRtlInitAnsiString(&AnsiString,lpAFileName);
    Status = g_pfnRtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            SetLastError(g_pfnRtlNtStatusToDosError(Status));
            }
        return INVALID_HANDLE_VALUE;
        }

    lpFileName = Unicode->Buffer;


    CreateFlags = 0;

    TranslationStatus = g_pfnRtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );


    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
        }
    } else {
        pOplock = NULL;
    }

    Status = SPUDCreateFile(
                &Handle,
                &Obja,
                &IoStatusBlock,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateFlags,
                si,
                sd,
                Length,
                LengthNeeded,
                pOplock
                );

    g_pfnRtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ||
             Status == STATUS_OPLOCK_NOT_GRANTED ) {
             SetLastError(ERROR_INVALID_ACCESS);
             return Handle;
        }
        if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            SetLastError(ERROR_ACCESS_DENIED);
        } else {
            SetLastError(g_pfnRtlNtStatusToDosError(Status));
        }
        return INVALID_HANDLE_VALUE;
    }

    SetLastError(ERROR_SUCCESS);
    return Handle;

}

HANDLE
AtqCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    )
{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    ULONG CreateFlags;
    DWORD SQOSFlags;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    POPLOCK_INFO pOplock;

    CreateFlags = 0;

//    DbgPrint("AtqCreateFileW - %ws\n", lpFileName );

    TranslationStatus = g_pfnRtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );


    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
        }
    } else {
        pOplock = NULL;
    }

    Status = SPUDCreateFile(
                &Handle,
                &Obja,
                &IoStatusBlock,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateFlags,
                si,
                sd,
                Length,
                LengthNeeded,
                pOplock
                );

    g_pfnRtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ||
             Status == STATUS_OPLOCK_NOT_GRANTED ) {
             SetLastError(ERROR_INVALID_ACCESS);
             return Handle;
        }
        if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            SetLastError(ERROR_ACCESS_DENIED);
        } else {
            SetLastError(g_pfnRtlNtStatusToDosError(Status));
        }
        return INVALID_HANDLE_VALUE;
    }

    SetLastError(ERROR_SUCCESS);
    return Handle;

}

BOOL
AtqOplockAcknowledge(
    IN HANDLE   FileHandle,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
)
{
    POPLOCK_INFO pOplock;
    NTSTATUS Status;

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
            Status = SPUDOplockAcknowledge(
                          FileHandle,
                          pOplock
                          );

            if ( Status == STATUS_SUCCESS ) {
                return TRUE;
            }

        }
    }
    return FALSE;

}

#else

BOOL
I_AtqSpudInitialize(
            IN HANDLE hPort
            )
{
    return FALSE;
}

BOOL
I_AtqSpudTerminate()
{
    return TRUE;
}

BOOL
I_AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
{
    return FALSE;
}

BOOL
I_AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
{
    return FALSE;
}
#endif
BOOL
AtqSpudInitialized(
    VOID
)
{
    return g_fUseDriver;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\uspud.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1997           **/
/**********************************************************************/

/*
    uspud.h

    This module contains usermode interface to the spud.sys driver.


*/

#ifndef _USPUD_H_
#define _USPUD_H_


#ifdef __cplusplus
extern "C" {
#endif

extern
NTSTATUS
NTAPI
SPUDTransmitFileAndRecv(
    HANDLE                  hSocket,                // Socket handle to use for operation
    PAFD_TRANSMIT_FILE_INFO transmitInfo,           // transmit file req info
    PAFD_RECV_INFO          recvInfo,               // recv req info
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );


extern
NTSTATUS
NTAPI
SPUDSendAndRecv(
    HANDLE                  hSocket,                // Socket handle to use for operation
    PAFD_SEND_INFO          sendInfo,               // send req info
    PAFD_RECV_INFO          recvInfo,               // recv req info
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );


extern
NTSTATUS
NTAPI
SPUDCancel(
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );

extern
NTSTATUS
NTAPI
SPUDCheckStatus(
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );

extern
NTSTATUS
NTAPI
SPUDGetCounts(
    PSPUD_COUNTERS      SpudCounts,              // Counters
    DWORD               ClearCounts
    );

extern
NTSTATUS
NTAPI
SPUDInitialize(
    DWORD       Version,        // Version information from spud.h
    HANDLE      hPort           // Handle of completion port for atq
    );

extern
NTSTATUS
NTAPI
SPUDTerminate(
    VOID
    );

extern
NTSTATUS
NTAPI
SPUDCreateFile(
    OUT PHANDLE FileHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateOptions,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded,
    IN PVOID pOplock
    );

extern
NTSTATUS
NTAPI
SPUDOplockAcknowledge(
    IN HANDLE FileHandle,
    IN PVOID pOplock
    );

#ifdef __cplusplus
}
#endif

#endif //!_USPUD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\timer.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.h

Abstract:

    Domain Name System (DNS) Server

    Wrap proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Revision History:

--*/


#ifndef _TIMER_INCLUDED_
#define _TIMER_INCLUDED_

dllexp
VOID
InitializeSecondsTimer(
    VOID
    );

dllexp
DWORD
GetCurrentTimeInSeconds(
    VOID
    );

dllexp
__int64
GetCurrentTimeInMilliseconds(
    VOID
    );

#endif  // _TIMER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\timer.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Wrap proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

    For DNS the added instructions are well worth the cost in that it
    eliminates any issue involving cleaning packet queues or resetting
    cache timeouts when millisecond timer (GetCurrentTime) wraps.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Environment:

    Win32 User Mode

Project:

    Common Code for Internet Services

Functions Exported:

    InitializeSecondsTimer()
    GetCurrentTimeInSeconds()

Revision History:
    MuraliK  14-Nov-1995 Made multi thread safe.
    
--*/


# include "isatq.hxx"


//
//  Timer globals
//

static LONG      g_lTimerInitialized = (LONG ) FALSE;
CRITICAL_SECTION    g_csTimerWrap;



VOID
InitializeSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Initialize DNS timer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( InterlockedExchange( &g_lTimerInitialized, (LONG ) TRUE) == FALSE) { 
        
        // I am the first thread to initialize. Let me do so.
          
        InitializeCriticalSection( &g_csTimerWrap );
        SET_CRITICAL_SECTION_SPIN_COUNT( &g_csTimerWrap, 
                                         IIS_DEFAULT_CS_SPIN_COUNT);
    }

} // InitializeSecondsTimer()



DWORD
GetCurrentTimeInSeconds(
    VOID
    )
/*++

Routine Description:

    Get current time in seconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   dwCurrentTime;
    static DWORD    dwPreviousTime = 0;     // previous GetCurrentTime()
    static DWORD    dwWrapTime = 0;         // accumulated time (s) from timer
                                            //  wraps

    dwCurrentTime = GetCurrentTime();

    //
    //  check for timer wrap
    //
    //  Check that previous time is bigger, but since multi-threaded,
    //  occasionally preempted before making test and another thread
    //  may reset dwPreviousTime.  So we also explicitly verify the
    //  switch from a very large DWORD to a small one.
    //
    //  Note:  that we completely avoid using the CS, except right at
    //  an actual timer wrap.   Hence the cost for this function
    //  remains low.
    //

    if ( dwPreviousTime > dwCurrentTime
            &&
         (LONG)dwPreviousTime < 0
            &&
         (LONG)dwCurrentTime > 0 )
    {
        //
        //  detected timer wrap
        //
        //  inside CS, verify actual wrap and reset dwPreviousTime
        //  so other waiting threads will NOT count wrap
        //

        EnterCriticalSection( &g_csTimerWrap );

        if ( (LONG)dwPreviousTime < 0
                &&
            (LONG)dwCurrentTime > 0 )
        {
            dwPreviousTime = dwCurrentTime;
            dwWrapTime += (0xffffffff / 1000);
        }
        LeaveCriticalSection( &g_csTimerWrap );
    }
    dwPreviousTime = dwCurrentTime;

    return (dwCurrentTime / 1000 + dwWrapTime);
}


__int64
GetCurrentTimeInMilliseconds(
    VOID
    )
/*++

Routine Description:

    Get current time in milliseconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   dwCurrentTime;
    static DWORD    dwPreviousTime = 0;     // previous GetCurrentTime()
    static DWORD    dwWrapTime = 0;         // accumulated time (s) from timer
                                            //  wraps

    dwCurrentTime = GetTickCount();

    //
    //  check for timer wrap
    //
    //  Check that previous time is bigger, but since multi-threaded,
    //  occasionally preempted before making test and another thread
    //  may reset dwPreviousTime.  So we also explicitly verify the
    //  switch from a very large DWORD to a small one.
    //
    //  Note:  that we completely avoid using the CS, except right at
    //  an actual timer wrap.   Hence the cost for this function
    //  remains low.
    //

    if ( dwPreviousTime > dwCurrentTime
            &&
         (LONG)dwPreviousTime < 0
            &&
         (LONG)dwCurrentTime > 0 )
    {
        //
        //  detected timer wrap
        //
        //  inside CS, verify actual wrap and reset dwPreviousTime
        //  so other waiting threads will NOT count wrap
        //

        EnterCriticalSection( &g_csTimerWrap );

        if ( (LONG)dwPreviousTime < 0
                &&
            (LONG)dwCurrentTime > 0 )
        {
            dwPreviousTime = dwCurrentTime;
            ++dwWrapTime;
        }
        LeaveCriticalSection( &g_csTimerWrap );
    }
    dwPreviousTime = dwCurrentTime;

    return (((__int64)dwWrapTime)<<32) |  dwCurrentTime;
}


//
//  End of timer.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\tracelog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.h

Abstract:

    This module contains public declarations and definitions for creating
    trace logs.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

    Note that the creator of the log has the option of adding "extra"
    bytes to the log header. This can be useful if the creator wants to
    create a set of global logs, each on a linked list.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _TRACELOG_H_
#define _TRACELOG_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


typedef struct _TRACE_LOG {

    //
    // Signature.
    //

    LONG Signature;

    //
    // The total number of entries available in the log.
    //

    LONG LogSize;

    //
    // The index of the next entry to use.
    //

    LONG NextEntry;

    //
    // The byte size of each entry.
    //

    LONG EntrySize;

    //
    // Pointer to the start of the circular buffer.
    //

    PUCHAR LogBuffer;

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize][EntrySize];
    //

} TRACE_LOG, *PTRACE_LOG;


//
// Log header signature.
//

#define TRACE_LOG_SIGNATURE   ((DWORD)'gOlT')
#define TRACE_LOG_SIGNATURE_X ((DWORD)'golX')


//
// This macro maps a TRACE_LOG pointer to a pointer to the 'extra'
// data associated with the log.
//

#define TRACE_LOG_TO_EXTRA_DATA(log)    (PVOID)( (log) + 1 )


//
// Manipulators.
//

PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    );

VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    );

VOID
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    );

VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\dscommon\alert.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       alert.c
//
//--------------------------------------------------------------------------

//
// This file contains the source for RaiseAlert. RaiseAlert takes a 
// character string , builds the necessary buffers and calls NetRaiseAlertEx
// to raise an alert. This is in a separate file because this api is unicode
// only. In order for the alert to be raised the ALERTE service has to be
// running on the derver machine. In order for the alert to be received, the 
// messenger service has to be running on the receiving machine
//

#include <NTDSpch.h>
#pragma  hdrstop


#ifndef UNICODE
#define UNICODE
#endif
#include <windows.h>
#include	<lm.h>
#include	<lmalert.h>
#include <fileno.h>
#define  FILENO FILENO_ALERT

DWORD
RaiseAlert(char *szMsg)
{

	UINT  			CodePage = CP_ACP;
	DWORD 			dwFlags  = MB_PRECOMPOSED;
	int   			cchMultiByte = -1;
	size_t 			cbBuffer;
	size_t			cbMsg;
	BYTE  			*pbBuffer;
	PADMIN_OTHER_INFO	pAdminOtherInfo;
	WCHAR 			*szMergeString;
	DWORD			dwErr;


	cbMsg = strlen(szMsg) + 1;
	cbBuffer = sizeof(ADMIN_OTHER_INFO) + 	(sizeof(WCHAR) * cbMsg);
        pbBuffer = malloc(cbBuffer);

	if (!pbBuffer)
	    return GetLastError();

	pAdminOtherInfo = (PADMIN_OTHER_INFO) pbBuffer;
	szMergeString   = (WCHAR *) (pbBuffer + sizeof(ADMIN_OTHER_INFO));

	// convert multi byte string to unicode

	if (!MultiByteToWideChar(
		CodePage,
		dwFlags,
		szMsg,
		cchMultiByte,
		szMergeString,
		cbMsg))
	{
		dwErr = GetLastError();
		goto CommonExit;
	}

	pAdminOtherInfo->alrtad_errcode		=	(DWORD) -1;
	pAdminOtherInfo->alrtad_numstrings	=	1;

	dwErr = NetAlertRaiseEx(
		ALERT_ADMIN_EVENT,
		(LPVOID) pbBuffer,
		cbBuffer,
		L"Directory Service");

CommonExit:

	free(pbBuffer);
	return dwErr;
}

DWORD
RaiseAlertW(WCHAR *szMsg)
{

    int             cchMultiByte = -1;
    size_t          cbBuffer;
    size_t          cbMsg;
    BYTE            *pbBuffer;
    PADMIN_OTHER_INFO   pAdminOtherInfo;
    WCHAR           *szMergeString;
    DWORD           dwErr;


    cbMsg = wcslen(szMsg) + 1;
    cbBuffer = sizeof(ADMIN_OTHER_INFO) +   (sizeof(WCHAR) * cbMsg);
    pbBuffer = malloc(cbBuffer);

    if (!pbBuffer)
        return GetLastError();

    pAdminOtherInfo = (PADMIN_OTHER_INFO) pbBuffer;
    szMergeString   = (WCHAR *) (pbBuffer + sizeof(ADMIN_OTHER_INFO));
    wcscpy(szMergeString, szMsg);

    pAdminOtherInfo->alrtad_errcode     =   (DWORD) -1;
    pAdminOtherInfo->alrtad_numstrings  =   1;

    dwErr = NetAlertRaiseEx(
        ALERT_ADMIN_EVENT,
        (LPVOID) pbBuffer,
        cbBuffer,
        L"Directory Service");

    free(pbBuffer);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\dscommon\checkacl.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       checkacl.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <winldap.h>
#include <ntldap.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>             // alloca()
#include <rpc.h>                // RPC defines
#include <rpcdce.h>             // RPC_AUTH_IDENTITY_HANDLE
#include <sddl.h>               // ConvertSidToStringSid
#include <ntdsapi.h>            // DS APIs
#include <permit.h>             // DS_GENERIC_MAPPING
#include <checkacl.h>           // CheckAclInheritance()

//
// Define some SIDs for later use.
//

static UCHAR    S_1_3_0[] = { 1, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0 };
static SID      *pCreatorOwnerSid = (SID *) S_1_3_0;

static UCHAR    S_1_3_1[] = { 1, 1, 0, 0, 0, 0, 0, 3, 1, 0, 0, 0 };
static SID      *pCreatorGroupSid = (SID *) S_1_3_1;

// 
// Define some ACCESS_MASK masks
//

#define GENERIC_BITS_MASK ((ACCESS_MASK) (   GENERIC_READ \
                                           | GENERIC_WRITE \
                                           | GENERIC_EXECUTE \
                                           | GENERIC_ALL))

//
// Extract the ACCESS_MASK from an ACE.
//

ACCESS_MASK
MaskFromAce(
    ACE_HEADER  *p,                 // IN
    BOOL        fMapGenericBits     // IN
    )
{
    ACCESS_MASK     mask;
    GENERIC_MAPPING genericMapping = DS_GENERIC_MAPPING;


    // depending on the type of the ace extract mask from the related structure
    //
    if ( p->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {
        // we are using a standard ACE (not object based)
        mask = ((ACCESS_ALLOWED_ACE *) p)->Mask;
    }
    else
    {
        // we are using an object ACE (supports inheritance)
        mask = ((ACCESS_ALLOWED_OBJECT_ACE *) p)->Mask;
    }

    if ( fMapGenericBits )
    {
        // map the generic access rights used by the DS
        // to the specific access mask and standard access rights
        mask &= GENERIC_BITS_MASK;
        RtlMapGenericMask(&mask, &genericMapping);
    }

    // SYNCHRONIZE is not inherited/supported on DS objects, so mask this out.
    return(mask & ~SYNCHRONIZE);
}

//
// Compare two ACEs for equality.  This is not binary equality but
// instead is based on the subset of fields in the ACE which must be
// the same when inherited from parent to child.  
//
// pChildOwnerSid and pChildGroupSid semantics are as follows:
//   If present, then if the parent ACE's SID is pCreatorOwnerSid 
//   or pCreatorGroupSid respectively, then the child ACE's SID 
//   should match the passed in value, not the value in the parent.  
//   See comments in CheckAclInheritance for how this is used when 
//   a single parent ACE is split into two child ACEs.
//

BOOL
IsEqualAce(
    ACE_HEADER  *p1,                // IN - parent ACE
    ACE_HEADER  *p2,                // IN - child ACE
    ACCESS_MASK maskToMatch,        // IN - ACCESS_MASK bits to match on
    SID         *pChildOwnerSid,    // IN - child owner SID - OPTIONAL
    SID         *pChildGroupSid,    // IN - child group SID - OPTIONAL
    BOOL        fMapMaskOfParent,   // IN
    BOOL        *pfSubstMatch       // OUT
    )
{
    ACCESS_ALLOWED_ACE          *paaAce1, *paaAce2;
    ACCESS_ALLOWED_OBJECT_ACE   *paaoAce1, *paaoAce2;
    GUID                        *pGuid1, *pGuid2;
    PBYTE                       ptr1, ptr2;
    ACCESS_MASK                 mask1, mask2;

    *pfSubstMatch = TRUE;

    // ACEs should be at least of the same type
    if ( p1->AceType != p2->AceType )
        return(FALSE);

    mask1 = MaskFromAce(p1, fMapMaskOfParent) & maskToMatch;
    mask2 = MaskFromAce(p2, FALSE) & maskToMatch;

    if ( mask1 != mask2 )
        return(FALSE);


    // we are using a standard ACE (not object based)
    //
    if ( p1->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {
        paaAce1 = (ACCESS_ALLOWED_ACE *) p1;
        paaAce2 = (ACCESS_ALLOWED_ACE *) p2;

        if (    pChildOwnerSid
             && RtlEqualSid((PSID) &paaAce1->SidStart, pCreatorOwnerSid) )
        {
            return(RtlEqualSid((PSID) &paaAce2->SidStart, pChildOwnerSid));
        }
        else if (    pChildGroupSid
                  && RtlEqualSid((PSID) &paaAce1->SidStart, pCreatorGroupSid) )
        {
            return(RtlEqualSid((PSID) &paaAce2->SidStart, pChildGroupSid));
        }

        *pfSubstMatch = FALSE;
        return(RtlEqualSid((PSID) &paaAce1->SidStart, 
                           (PSID) &paaAce2->SidStart));
    }

    // we are using an object ACE (supports inheritance)
    //
    paaoAce1 = (ACCESS_ALLOWED_OBJECT_ACE *) p1;
    paaoAce2 = (ACCESS_ALLOWED_OBJECT_ACE *) p2;


    // if ACE_OBJECT_TYPE_PRESENT is set, we are protecting an
    // object, property set, or property identified by the specific GUID.
    // check that we are protecting the same object - property
    //
    if (    (paaoAce1->Flags & ACE_OBJECT_TYPE_PRESENT)
         && memcmp(&paaoAce1->ObjectType, &paaoAce2->ObjectType, sizeof(GUID)) )
            return(FALSE);

    // if ACE_INHERITED_OBJECT_TYPE_PRESENT is set, we are inheriting an
    // object, property set, or property identified by the specific GUID.
    // check to see that we are inheriting the same type of object - property
    // only if we are also protecting the particular object - property
    //
    if ( paaoAce1->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT ) 
    {
        if ( paaoAce1->Flags & ACE_OBJECT_TYPE_PRESENT ) 
        {
            pGuid1 = &paaoAce1->InheritedObjectType;
            pGuid2 = &paaoAce2->InheritedObjectType;

            if ( memcmp(pGuid1, pGuid2, sizeof(GUID)) )
                return(FALSE);
        }
    }

    // possibly, we are protecting the same object - property and we
    // inherit the same object - property, so possition after these GUIDS
    // and compare the SIDS hanging on the ACE.
    //
    ptr1 = (PBYTE) &paaoAce1->ObjectType;
    ptr2 = (PBYTE) &paaoAce2->ObjectType;

    if ( paaoAce1->Flags & ACE_OBJECT_TYPE_PRESENT ) 
    {
        ptr1 += sizeof(GUID);
        ptr2 += sizeof(GUID);
    }

    if ( paaoAce1->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT ) 
    {
        ptr1 += sizeof(GUID);
        ptr2 += sizeof(GUID);
    }

    // compare the SID part of the ACE
    //
    if (    pChildOwnerSid
         && RtlEqualSid((PSID) ptr1, pCreatorOwnerSid) )
    {
        return(RtlEqualSid((PSID) ptr2, pChildOwnerSid));
    }
    else if (    pChildGroupSid
              && RtlEqualSid((PSID) ptr1, pCreatorGroupSid) )
    {
        return(RtlEqualSid((PSID) ptr2, pChildGroupSid));
    }

    *pfSubstMatch = FALSE;
    return(RtlEqualSid((PSID) ptr1, (PSID) ptr2));
}

// 
// Determine if an ACE is class specific and if so, return the GUID.
//

BOOL
IsAceClassSpecific(
    ACE_HEADER  *pAce,      // IN
    GUID        *pGuid      // IN
    )
{
    ACCESS_ALLOWED_OBJECT_ACE   *paaoAce;
    GUID                        *p;

    // this is not an object based ACE, so it does not have a class
    if ( pAce->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
        return(FALSE);

    // object ACE

    paaoAce = (ACCESS_ALLOWED_OBJECT_ACE *) pAce;
    p = (GUID *) &paaoAce->ObjectType;

    if ( paaoAce->Flags & ACE_OBJECT_TYPE_PRESENT )
        p++;

    // if ACE_INHERITED_OBJECT_TYPE_PRESENT is set, we are inheriting an
    // object, property set, or property identified by the specific GUID.
    // so it is class specific.
    if ( paaoAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT ) 
    {
        // mariosz: is this the same as using paaoAce->InheritedObjectType ??
        *pGuid = *p;                    
        return(TRUE);
    }

    return(FALSE);
}

//
// Find an ACE in an ACL.  Intended use is to verify that inheritable ace 
// on a parent object is present on a child object.  The merge SD code does
// not guarantee that only one ACE in the child matches the ACE in the
// parent, so we check against all ACEs in the parent and return all matches.
//

VOID
FindAce(
    PACL            pAclChild,          // IN
    ACE_HEADER      *pAceParent,        // IN
    ACCESS_MASK     maskToMatch,        // IN - ACCESS_MASK bits to match on
    SID             *pChildOwner,       // IN - child owner SID
    SID             *pChildGroup,       // IN - child group SID
    DWORD           *pcAcesFound,       // OUT
    DWORD           **ppiAceChild,      // OUT
    AclPrintFunc    pfn,                // IN - OPTIONAL
    UCHAR           flagsRequired,      // IN
    UCHAR           flagsDisallowed,    // IN
    BOOL            fMapMaskOfParent,   // IN
    BOOL            *pfSubstMatch       // OUT
    )
{
    DWORD           i, dwErr;
    ACE_HEADER      *pAceChild;

    *pcAcesFound = 0;
    *ppiAceChild = (DWORD *) LocalAlloc(LPTR, 
                                        pAclChild->AceCount * sizeof(DWORD));

    if ( NULL == *ppiAceChild )
    {
        if ( pfn )
        {
            (*pfn)("*** Error: LocalAlloc failed, analysis incomplete\n");
        }

        return;
    }
        
    // iterate all ACEs and look for equal
    //
    for ( i = 0; i < pAclChild->AceCount; i++ )
    {
        // mariosz: so pAceChild is an OUT variable
        if ( !GetAce(pAclChild, i, &pAceChild) )
        {
            if ( pfn )
            {
                dwErr = GetLastError();
                (*pfn)("*** Error: GetAce ==> 0x%x - analysis incomplete\n",
                       dwErr);
            }

            LocalFree(*ppiAceChild);
            *ppiAceChild = NULL;
            *pcAcesFound = 0;
            return;
        }

        // add to array of equal ACEs
        //
        if (    IsEqualAce(pAceParent, pAceChild, maskToMatch,
                           pChildOwner, pChildGroup, fMapMaskOfParent,
                           pfSubstMatch)
             && (flagsRequired == (flagsRequired & pAceChild->AceFlags))
             && (0 == (flagsDisallowed & pAceChild->AceFlags)) )
        {
            (*ppiAceChild)[*pcAcesFound] = i;
            *pcAcesFound += 1;
        }
    }

    if ( 0 == *pcAcesFound )
    {
        LocalFree(*ppiAceChild);
        *ppiAceChild = NULL;
    }
}

// 
// Perform various inheritance checks on the ACLs of an object and its child.
//

DWORD
CheckAclInheritance(
    PSECURITY_DESCRIPTOR pParentSD,             // IN
    PSECURITY_DESCRIPTOR pChildSD,              // IN
    GUID                *pChildClassGuid,       // IN
    AclPrintFunc        pfn,                    // IN - OPTIONAL
    BOOL                fContinueOnError,       // IN
    BOOL                fVerbose,               // IN
    DWORD               *pdwLastError           // OUT
    )
{   
    DWORD           iAceParent;     // index ace parent
    DWORD           iAceChild;      // index ace child
    DWORD           cAceParent;     // parent ace count
    DWORD           cAceChild;      // child ace count
    PACL            pAclParent;     // parent ACL
    PACL            pAclChild;      // child ACL
    ACE_HEADER      *pAceParent;    // parent ACE
    ACE_HEADER      *pAceChild;     // child ACE
    BOOL            present;
    BOOL            defaulted;
    ACCESS_MASK     *rInheritedChildMasks = NULL;
    GUID            guid;
    UCHAR           flagsRequired, flagsDisallowed, parentObjContFlags;
    DWORD           cAce1, cAce2, cAce2_5, cAce3;
    DWORD           *riAce1, *riAce2, *riAce2_5, *riAce3;
    DWORD           i1, i2, i3;
    BOOL            fClassSpecific;
    BOOL            fClassMatch;
    DWORD           dwErr;
    PSID            pChildOwner = NULL;
    PSID            pChildGroup = NULL;
    DWORD           iMask, iTmp;
    ACCESS_MASK     bitToMatch, maskToMatch;
    BOOL            fMatchedOnCreatorSubstitution;
    BOOL            fCase2_5;
    SECURITY_DESCRIPTOR_CONTROL Control = 0;
    DWORD           revision = 0;

    if ( !pParentSD || !pChildSD || !pChildClassGuid || !pdwLastError )
    {
        return(AclErrorNone);
    }

    *pdwLastError = 0;

    if (!GetSecurityDescriptorControl  (pChildSD, &Control, &revision)) {
        dwErr = GetLastError();

        if ( pfn )
        {
            (*pfn)("*** Warning: GetSecurityDescriptorControl ==> 0x%x - analysis may be incomplete\n", dwErr);
        }
    }

    // check to see if the childSD cannot inherit the DACL from his parent
    //
    if ( SE_DACL_PROTECTED & Control )
    {
        if ( pfn && fVerbose )
        {
            (*pfn)("*** Warning: Child has SE_DACL_PROTECTED set, therefore doesn't inherit - skipping test\n");
        }

        return(AclErrorNone);
    }

    // retrieve the owner information from the security descriptor of the child
    //
    if ( !GetSecurityDescriptorOwner(pChildSD, &pChildOwner, &defaulted) )
    {
        dwErr = GetLastError();
        pChildOwner = NULL;

        if ( pfn )
        {
            (*pfn)("*** Warning: GetSecurityDescriptorOwner ==> 0x%x - analysis may be incomplete\n", dwErr);
        }
    }

    // retrieve the primary group information from the security descriptor of the child
    //
    if ( !GetSecurityDescriptorGroup(pChildSD, &pChildGroup, &defaulted) )
    {
        dwErr = GetLastError();
        pChildGroup = NULL;

        if ( pfn )
        {
            (*pfn)("*** Warning: GetSecurityDescriptorGroup ==> 0x%x - analysis may be incomplete\n", dwErr);
        }
    }

    // retrieve pointers to the discretionary access-control list (DACL) 
    // in the security descriptor of the parent and child
    //
    if (    !GetSecurityDescriptorDacl(pParentSD, &present, 
                                       &pAclParent, &defaulted) 
         || !GetSecurityDescriptorDacl(pChildSD, &present, 
                                       &pAclChild, &defaulted) )
    {
        *pdwLastError = GetLastError();

        if ( pfn )
        {
            (*pfn)("*** Error: GetSecurityDescriptorDacl ==> 0x%x - analysis incomplete\n", *pdwLastError);
        }

        return(AclErrorGetSecurityDescriptorDacl);
    }

    cAceParent = pAclParent->AceCount;
    cAceChild = pAclChild->AceCount;

    // Record ACCESS_MASKs of ACEs in child which have the INHERITED_ACE bit so
    // we can verify later that the child doesn't have mask bits
    // which are not present on (i.e. inherited from) the parent.

    rInheritedChildMasks = (ACCESS_MASK *) 
                                    alloca(cAceChild * sizeof(ACCESS_MASK));
    
    for ( iAceChild = 0; iAceChild < cAceChild; iAceChild++ )
    {
        rInheritedChildMasks[iAceChild] = 0;

        if ( !GetAce(pAclChild, iAceChild, &pAceChild) )
        {
            *pdwLastError = GetLastError();

            if ( pfn )
            {
                (*pfn)("*** Error: GetAce ==> 0x%x - analysis incomplete\n", *pdwLastError);
            }

            return(AclErrorGetAce);
        }
        
        // INHERITED_ACE Indicates that the ACE was inherited from parent
        if ( pAceChild->AceFlags & INHERITED_ACE )
        {
            rInheritedChildMasks[iAceChild] = MaskFromAce(pAceChild, FALSE);
        }
    }

    // Iterate over parent's ACEs and check the child.

    for ( iAceParent = 0; iAceParent < cAceParent; iAceParent++ )
    {
        if ( !GetAce(pAclParent, iAceParent, &pAceParent) )
        {
            *pdwLastError = GetLastError();

            if ( pfn )
            {
                (*pfn)("*** Error: GetAce ==> 0x%x - analysis incomplete\n", *pdwLastError);
            }

            return(AclErrorGetAce);
        }

        // This is for Noncontainer child objects, which is not supported in the DS
        if ( pAceParent->AceFlags & OBJECT_INHERIT_ACE )
        {
            if ( pfn )
            {
                (*pfn)("*** Warning: Parent ACE [%d] is OBJECT_INHERIT_ACE but DS objects should be CONTAINER_INHERIT_ACE\n", iAceParent);
            }
        }

        // skip ACLs that are not inheritable
        if (    !(pAceParent->AceFlags & OBJECT_INHERIT_ACE)
             && !(pAceParent->AceFlags & CONTAINER_INHERIT_ACE) )
        {
            continue;
        }

        parentObjContFlags = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
        parentObjContFlags &= pAceParent->AceFlags;

        // check to see if the inheritable descriptor is class specific and
        // the child is of the same class
        //
        if ( (fClassSpecific = IsAceClassSpecific(pAceParent, &guid)) )
        {
            fClassMatch = (0 == memcmp(pChildClassGuid, &guid, sizeof(GUID)));
        }
        else
        {
            fClassMatch = FALSE;
        }

        // Iterate over parent ACE's inheritable ACCESS_MASK bits and 
        // check the child.  The access mask can be considered to have
        // three (potential) components:
        //
        // 1) Generic rights identified as GENERIC_* in ntseapi.h.
        // 2) Specific rights identified in ntseapi.h and accctrl.h.
        // 3) Implied rights which are obtained by mapping the generic rights.
        //
        // If there exists an inheritable ACE on the parent, then there
        // should exist child ACEs which cumulatively represent the generic
        // and specific rights.  The implied rights may also be represented,
        // but need not be.
        //
        // If there exists an inheritable ACE on the parent which is effective
        // on the child, then there should exist child ACEs which cumulatively
        // represent the specific rights and implied rights, but do NOT
        // represent the generic rights.
        //
        // Since the specific bits are a common case, we do that first.

        maskToMatch = MaskFromAce(pAceParent, FALSE) & ~GENERIC_BITS_MASK;

        for ( bitToMatch = 0x1, iMask = 0; 
              iMask < (sizeof(ACCESS_MASK) * 8); 
              bitToMatch = (bitToMatch << 1), iMask++ )
        {
            if ( !(bitToMatch & maskToMatch) )
            {
                // Current bitToMatch not present on parent.
                continue;
            }

            if (    (!fClassSpecific || (fClassSpecific && fClassMatch))
                 && !(pAceParent->AceFlags & NO_PROPAGATE_INHERIT_ACE) )
            {
                // Parent ACE applies to the child.  In this case we can have 
                // combinations of ACEs on the child as follows.  See CliffV!
                //
                // ACE 1: INHERIT_ONLY  + INHERITED + parentObjContFlags
                // ACE 2: !INHERIT_ONLY + INHERITED + !parentObjContFlags
                //
                // If the SID in the parent ACE is either Creator Owner or
                // Creator Group, (call this Creator XXX) then we must have 
                // the split case as this is the only way to end up with 
                // something which is both inheritable for Creator XXX and 
                // at the same time applicable on the child object for the 
                // owner/group in the child object SD.  So we disallow
                // matching on pChildOwner/pChildGroup when looking for ACE 1
                // and require it when looking for ACE 2.
                //
                // But there is an exception to this rule.  It could be that
                // the child has the following:
                //
                // ACE 2_5: !INHERIT_ONLY + INHERITED + parentObjContFlags
                //
                // This will occur if the child ACE is of the Creator XXX form
                // and the parent additionally has an inheritable ACE whose
                // SID happens to be the child's creator XXX SID.  In this case
                // ACE 2_5 is just like ACE 2 except that the parentObjContFlags
                // are carried forward in the child ACE as a result of the 
                // additional ACE in the parent.
                //
                //                    --- OR ---
                //
                // ACE 3: !INHERIT_ONLY + INHERITED + parentObjContFlags
                // 
                // In this case child ACE must have the same SID as the parent
                // ACE thus we disallow matching on pChildOwner/pChildGroup
                // when looking for the ACE.
                // 
                // N.B. It is legitimate to have both the ACE 1+2 case AND the
                // ACE 3 case concurrently in the child.  It is inefficient in
                // that the child has more ACEs than it needs, but it is valid.
    
                // ACE 1:
                flagsRequired = (   INHERIT_ONLY_ACE 
                                  | INHERITED_ACE 
                                  | parentObjContFlags);
                flagsDisallowed = 0;
                FindAce(pAclChild, pAceParent, bitToMatch,
                        NULL, NULL, &cAce1, &riAce1, pfn,
                        flagsRequired, flagsDisallowed, FALSE,
                        &fMatchedOnCreatorSubstitution);

                // ACE 2:
                flagsRequired = INHERITED_ACE;
                flagsDisallowed = (INHERIT_ONLY_ACE | parentObjContFlags);
                FindAce(pAclChild, pAceParent, bitToMatch,
                        pChildOwner, pChildGroup, &cAce2, &riAce2, pfn,
                        flagsRequired, flagsDisallowed, FALSE,
                        &fMatchedOnCreatorSubstitution);

                // ACE 2_5:
                flagsRequired = (INHERITED_ACE | parentObjContFlags);
                flagsDisallowed = INHERIT_ONLY_ACE;
                FindAce(pAclChild, pAceParent, bitToMatch,
                        pChildOwner, pChildGroup, &cAce2_5, &riAce2_5, pfn,
                        flagsRequired, flagsDisallowed, FALSE,
                        &fMatchedOnCreatorSubstitution);

                fCase2_5 = ( cAce2_5 && fMatchedOnCreatorSubstitution);
    
                // ACE 3:
                flagsRequired = (INHERITED_ACE | parentObjContFlags);
                flagsDisallowed = INHERIT_ONLY_ACE;
                FindAce(pAclChild, pAceParent, bitToMatch,
                        NULL, NULL, &cAce3, &riAce3, pfn,
                        flagsRequired, flagsDisallowed, FALSE,
                        &fMatchedOnCreatorSubstitution);
    
                if ( cAce1 && cAce2 )
                {
                    for ( iTmp = 0; iTmp < cAce1; iTmp++ )
                        rInheritedChildMasks[riAce1[iTmp]] &= ~bitToMatch;
                    for ( iTmp = 0; iTmp < cAce2; iTmp++ )
                        rInheritedChildMasks[riAce2[iTmp]] &= ~bitToMatch;

                    if ( pfn && fVerbose )
                    {
                        (*pfn)("(Debug) Parent ACE [%d] specific Mask [0x%x] split into child ACEs [%d] and [%d] %s\n", iAceParent, bitToMatch, riAce1[0], riAce2[0], (((cAce1 > 1) || (cAce2 > 1)) ? "(and others)" : ""));
                    }

                    LocalFree(riAce1); riAce1 = NULL;
                    LocalFree(riAce2); riAce2 = NULL;
                }
                else if ( cAce1 && !cAce2 && fCase2_5 )
                {
                    for ( iTmp = 0; iTmp < cAce1; iTmp++ )
                        rInheritedChildMasks[riAce1[iTmp]] &= ~bitToMatch;
                    for ( iTmp = 0; iTmp < cAce2_5; iTmp++ )
                        rInheritedChildMasks[riAce2_5[iTmp]] &= ~bitToMatch;
                    
                    if ( pfn && fVerbose )
                    {
                        (*pfn)("(Debug) Parent ACE [%d] specific Mask [0x%x] split1 into child ACEs [%d] and [%d] %s\n", iAceParent, bitToMatch, riAce1[0], riAce2_5[0], (((cAce1 > 1) || (cAce2_5 > 1)) ? "(and others)" : ""));
                    }

                    LocalFree(riAce1); riAce1 = NULL;
                    LocalFree(riAce2_5); riAce2_5 = NULL;
                }
                
                if ( cAce3 )
                {
                    for ( iTmp = 0; iTmp < cAce3; iTmp++ )
                        rInheritedChildMasks[riAce3[iTmp]] &= ~bitToMatch;

                    if ( pfn && fVerbose )
                    {
                        (*pfn)("(Debug) Parent ACE [%d] specific Mask [0x%x] found in child ACE [%d] %s\n", iAceParent, bitToMatch, riAce3[0], ((cAce3 > 1) ? "(and others)" : ""));
                    }

                    LocalFree(riAce3); riAce3 = NULL;
                }

                if ( riAce1 )   LocalFree(riAce1);
                if ( riAce2 )   LocalFree(riAce2);
                if ( riAce2_5 ) LocalFree(riAce2_5);
                if ( riAce3 )   LocalFree(riAce3);

                if (    !(    (cAce1 && cAce2) 
                           || (cAce1 && !cAce2 && fCase2_5) )
                     && !cAce3 )
                {
                    if ( pfn )
                    {
                        (*pfn)("*** Error: Parent ACE [%d] specific Mask [0x%x] not found1 in child\n", iAceParent, bitToMatch);
                    }
    
                    if ( fContinueOnError )
                    {
                        continue;
                    }
                    else
                    {
                        return(AclErrorParentAceNotFoundInChild);
                    }
                }
            }
            else if (    fClassSpecific 
                      && !fClassMatch
                      && !(pAceParent->AceFlags & NO_PROPAGATE_INHERIT_ACE) )
            {
                // All we should have on the child is an ACE with
                // INHERIT_ONLY + INHERITED + parentObjContFlags.
                // There should have been no mapping of Creator Owner
                // or Creator Group to the child's owner/group SID, 
                // thus we pass NULL for those parameters.
    
                flagsRequired = (   INHERIT_ONLY_ACE 
                                  | INHERITED_ACE 
                                  | parentObjContFlags);
                flagsDisallowed = 0;
                FindAce(pAclChild, pAceParent, bitToMatch,
                        NULL, NULL, &cAce1, &riAce1, pfn,
                        flagsRequired, flagsDisallowed, FALSE,
                        &fMatchedOnCreatorSubstitution);
    
                if ( cAce1 )
                {
                    for ( iTmp = 0; iTmp < cAce1; iTmp++ )
                        rInheritedChildMasks[riAce1[iTmp]] &= ~bitToMatch;

                    if ( pfn && fVerbose )
                    {
                        (*pfn)("(Debug) Parent ACE [%d] specific Mask [0x%x] found in child ACE [%d] %s\n", iAceParent, bitToMatch, riAce1[0], ((cAce1 > 1) ? "(and others)" : ""));
                    }

                    LocalFree(riAce1);
                }
                else
                {
                    if ( pfn )
                    {
                        (*pfn)("*** Error: Parent ACE [%d] specific Mask [0x%x] not found2 in child\n", iAceParent, bitToMatch);
                    }
    
                    if ( fContinueOnError )
                    {
                        continue;
                    }
                    else
                    {
                        return(AclErrorParentAceNotFoundInChild);
                    }
                }
            }
            else if ( pAceParent->AceFlags & NO_PROPAGATE_INHERIT_ACE )
            {
                // Parent ACE applies to the child but should not inherit
                // past the child.  In this case all we require is an
                // effective ace on the child of the form:
                //
                // !INHERIT_ONLY + INHERITED + !parentObjContFlags
                //
                // The inherited ACE may show Creator XXX on the parent, thus
                // it needs to be mapped to the child's owner/group SID.

                flagsRequired = INHERITED_ACE;
                flagsDisallowed = (INHERIT_ONLY_ACE | parentObjContFlags);
                FindAce(pAclChild, pAceParent, bitToMatch,
                        pChildOwner, pChildGroup, &cAce1, &riAce1, pfn,
                        flagsRequired, flagsDisallowed, FALSE,
                        &fMatchedOnCreatorSubstitution);

                if ( cAce1 )
                {
                    for ( iTmp = 0; iTmp < cAce1; iTmp++ )
                        rInheritedChildMasks[riAce1[iTmp]] &= ~bitToMatch;

                    if ( pfn && fVerbose )
                    {
                        (*pfn)("(Debug) Parent (NO_PROPAGATE_INHERIT) ACE [%d] specific Mask [0x%x] found in child ACE [%d] %s\n", iAceParent, bitToMatch, riAce1[0], ((cAce1 > 1) ? "(and others)" : ""));
                    }

                    LocalFree(riAce1); riAce1 = NULL;
                }
                else
                {
                    if ( pfn )
                    {
                        (*pfn)("*** Error: Parent ACE [%d] specific Mask [0x%x] not found1 in child\n", iAceParent, bitToMatch);
                    }
    
                    if ( fContinueOnError )
                    {
                        continue;
                    }
                    else
                    {
                        return(AclErrorParentAceNotFoundInChild);
                    }
                }
            }
            else
            {
                if ( pfn )
                {
                    (*pfn)("*** Error: Algorithm failure - unexpected condition!\n");
                }
    
                return(AclErrorAlgorithmError);
            }

        }   // for each bit in specific bits

        // Next verify that generic bits in the parent ACE are represented
        // in inheritable ACEs on the child.  Skip for NO_PROPAGATE_INHERIT_ACE
        // as in this case there is only an effective ACE on the child, not
        // an inheritable one.

        if ( pAceParent->AceFlags & NO_PROPAGATE_INHERIT_ACE )
        {
            goto SkipGenericTests;
        }

        maskToMatch = MaskFromAce(pAceParent, FALSE) & GENERIC_BITS_MASK;

        for ( bitToMatch = 0x1, iMask = 0; 
              iMask < (sizeof(ACCESS_MASK) * 8); 
              bitToMatch = (bitToMatch << 1), iMask++ )
        {
            if ( !(bitToMatch & maskToMatch) )
            {
                // Current bitToMatch not present on parent.
                continue;
            }

            // We wish to find an inheritable, non-effective ACE in the child 
            // with the corresponding bit set.  The reason it must be
            // non-effective is that effective ACEs can't have generic bits.
            // Since this is a non-effective ACE, there also isn't any
            // mapping of Creator Owner or Creator Group.
    
            flagsRequired = (   INHERIT_ONLY_ACE        // non-effective
                              | INHERITED_ACE           // inherited
                              | parentObjContFlags);    // inheritable
            flagsDisallowed = 0;
            FindAce(pAclChild, pAceParent, bitToMatch,
                    NULL, NULL, &cAce1, &riAce1, pfn,
                    flagsRequired, flagsDisallowed, FALSE,
                    &fMatchedOnCreatorSubstitution);

            if ( cAce1 )
            {
                for ( iTmp = 0; iTmp < cAce1; iTmp++ )
                    rInheritedChildMasks[riAce1[iTmp]] &= ~bitToMatch;

                if ( pfn && fVerbose )
                {
                    (*pfn)("(Debug) Parent ACE [%d] generic Mask [0x%x] found in child ACE [%d] %s\n", iAceParent, bitToMatch, riAce1[0], ((cAce1 > 1) ? "(and others)" : ""));
                }

                LocalFree(riAce1);
            }
            else
            {
                if ( pfn )
                {
                    (*pfn)("*** Error: Parent ACE [%d] generic Mask [0x%x] not found in child\n", iAceParent, bitToMatch);
                }

                if ( fContinueOnError )
                {
                    continue;
                }
                else
                {
                    return(AclErrorParentAceNotFoundInChild);
                }
            }
        }   // for each bit in generic bits

SkipGenericTests:

        // Next verify that implied bits in the parent ACE are represented 
        // in effective ACEs on the child.  So first check whether the
        // parent ACE is even effective for the child.

        if ( fClassSpecific && !fClassMatch )
        {
            goto SkipImpliedTests;
        }

        maskToMatch = MaskFromAce(pAceParent, TRUE);

        for ( bitToMatch = 0x1, iMask = 0; 
              iMask < (sizeof(ACCESS_MASK) * 8); 
              bitToMatch = (bitToMatch << 1), iMask++ )
        {
            if ( !(bitToMatch & maskToMatch) )
            {
                // Current bitToMatch not present on parent.
                continue;
            }

            // We wish to find an effective ACE in the child with the
            // corresponding bit set.  Since this is an effective ACE,
            // we need to map Creator Owner or Creator Group if present.
            // Since we don't really care whether the effective ACE
            // is inheritable or not, we don't ask for parentObjContFlags.

            flagsRequired = INHERITED_ACE;          // inherited
            flagsDisallowed = INHERIT_ONLY_ACE;     // effective
            FindAce(pAclChild, pAceParent, bitToMatch,
                    pChildOwner, pChildGroup, &cAce1, &riAce1, pfn,
                    flagsRequired, flagsDisallowed, TRUE,
                    &fMatchedOnCreatorSubstitution);

            if ( cAce1 )
            {
                for ( iTmp = 0; iTmp < cAce1; iTmp++ )
                    rInheritedChildMasks[riAce1[iTmp]] &= ~bitToMatch;

                if ( pfn && fVerbose )
                {
                    (*pfn)("(Debug) Parent ACE [%d] implied Mask [0x%x] found in child ACE [%d] %s\n", iAceParent, bitToMatch, riAce1[0], ((cAce1 > 1) ? "(and others)" : ""));
                }

                LocalFree(riAce1);
            }
            else
            {
                if ( pfn )
                {
                    (*pfn)("*** Error: Parent ACE [%d] implied Mask [0x%x] not found in child\n", iAceParent, bitToMatch);
                }

                if ( fContinueOnError )
                {
                    continue;
                }
                else
                {
                    return(AclErrorParentAceNotFoundInChild);
                }
            }
        }   // for each bit in implied bits

SkipImpliedTests:

        NULL;

    }   // for each ACE in parent

    // See if the child has any inherited ACCESS_MASKs which weren't on parent.

    for ( iAceChild = 0; iAceChild < cAceChild; iAceChild++ )
    {
        if ( rInheritedChildMasks[iAceChild] )
        {
            if ( pfn )
            {
                (*pfn)("*** Error: Child ACE [%d] Mask [0x%x] is INHERITED_ACE but there is no such inheritable ACE on parent\n", iAceChild, rInheritedChildMasks[iAceChild]);
            }

            if ( !fContinueOnError )
            {
                return(AclErrorInheritedAceOnChildNotOnParent);
            }
        }
    }

    return(AclErrorNone);
}

void DumpGUID (GUID *Guid, AclPrintFunc pfn)
{
    if ( Guid ) {

        (*pfn)( "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                     Guid->Data1, Guid->Data2, Guid->Data3, Guid->Data4[0],
                     Guid->Data4[1], Guid->Data4[2], Guid->Data4[3], Guid->Data4[4],
                     Guid->Data4[5], Guid->Data4[6], Guid->Data4[7] );
    }
}

void
DumpSID (PSID pSID, AclPrintFunc pfn)
{
    UNICODE_STRING StringSid;
    
    RtlConvertSidToUnicodeString( &StringSid, pSID, TRUE );
    (*pfn)( "%wZ", &StringSid );
    RtlFreeUnicodeString( &StringSid );
}

void
DumpAce(
    ACE_HEADER   *pAce,     // IN
    AclPrintFunc pfn,       // IN
    LookupGuidFunc pfnguid, // IN
    LookupSidFunc  pfnsid)  // IN
{
    ACCESS_ALLOWED_ACE          *paaAce = NULL;   //initialized to avoid C4701 
    ACCESS_ALLOWED_OBJECT_ACE   *paaoAce = NULL;  //initialized to avoid C4701
    GUID                        *pGuid;
    PBYTE                       ptr;
    ACCESS_MASK                 mask;
    CHAR                        *name;
    CHAR                        *label;
    BOOL                        fIsClass;

    (*pfn)("\t\tAce Type:  0x%x - ", pAce->AceType);
#define DOIT(flag) if (flag == pAce->AceType) (*pfn)("%s\n", #flag)
    DOIT(ACCESS_ALLOWED_ACE_TYPE);
    DOIT(ACCESS_DENIED_ACE_TYPE);
    DOIT(SYSTEM_AUDIT_ACE_TYPE);
    DOIT(SYSTEM_ALARM_ACE_TYPE);
    DOIT(ACCESS_ALLOWED_COMPOUND_ACE_TYPE);
    DOIT(ACCESS_ALLOWED_OBJECT_ACE_TYPE);
    DOIT(ACCESS_DENIED_OBJECT_ACE_TYPE);
    DOIT(SYSTEM_AUDIT_OBJECT_ACE_TYPE);
    DOIT(SYSTEM_ALARM_OBJECT_ACE_TYPE);
#undef DOIT

    (*pfn)("\t\tAce Size:  %d bytes\n", pAce->AceSize);

    (*pfn)("\t\tAce Flags: 0x%x\n", pAce->AceFlags);
#define DOIT(flag) if (pAce->AceFlags & flag) (*pfn)("\t\t\t%s\n", #flag)
    DOIT(OBJECT_INHERIT_ACE);
    DOIT(CONTAINER_INHERIT_ACE);
    DOIT(NO_PROPAGATE_INHERIT_ACE);
    DOIT(INHERIT_ONLY_ACE);
    DOIT(INHERITED_ACE);
#undef DOIT

    if ( pAce->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {
        paaAce = (ACCESS_ALLOWED_ACE *) pAce;
        mask = paaAce->Mask;
        (*pfn)("\t\tAce Mask:  0x%08x\n", mask);
    }
    else
    {
        // object ACE
        paaoAce = (ACCESS_ALLOWED_OBJECT_ACE *) pAce;
        mask = paaoAce->Mask;
        (*pfn)("\t\tObject Ace Mask:  0x%08x\n", mask);
    }

#define DOIT(flag) if (mask & flag) (*pfn)("\t\t\t%s\n", #flag)
    DOIT(DELETE);
    DOIT(READ_CONTROL);
    DOIT(WRITE_DAC);
    DOIT(WRITE_OWNER);
    DOIT(SYNCHRONIZE);
    DOIT(ACCESS_SYSTEM_SECURITY);
    DOIT(MAXIMUM_ALLOWED);
    DOIT(GENERIC_READ);
    DOIT(GENERIC_WRITE);
    DOIT(GENERIC_EXECUTE);
    DOIT(GENERIC_ALL);
    DOIT(ACTRL_DS_CREATE_CHILD);
    DOIT(ACTRL_DS_DELETE_CHILD);
    DOIT(ACTRL_DS_LIST);
    DOIT(ACTRL_DS_SELF);
    DOIT(ACTRL_DS_READ_PROP);
    DOIT(ACTRL_DS_WRITE_PROP);
    DOIT(ACTRL_DS_DELETE_TREE);
    DOIT(ACTRL_DS_LIST_OBJECT);
    DOIT(ACTRL_DS_CONTROL_ACCESS);
#undef DOIT

    if ( pAce->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {

        if (pfnsid) {
            (*pfn)("\t\tAce Sid:   %s\n",
               (*pfnsid)((PSID) &paaAce->SidStart));
        }
        else {
            (*pfn)("\t\tAce Sid:");
            DumpSID ((PSID) &paaAce->SidStart, pfn);
            (*pfn)("\n");
        }

    }
    else
    {
        // object ACE

        (*pfn)("\t\tObject Ace Flags: 0x%x\n" , paaoAce->Flags);

#define DOIT(flag) if (paaoAce->Flags & flag) (*pfn)("\t\t\t%s\n", #flag)
        DOIT(ACE_OBJECT_TYPE_PRESENT);
        DOIT(ACE_INHERITED_OBJECT_TYPE_PRESENT);
#undef DOIT

        if ( paaoAce->Flags & ACE_OBJECT_TYPE_PRESENT )
        {
            (*pfn)("\t\tObject Ace Type: ");
            if (pfnguid) {
                (*pfnguid)((GUID *) &paaoAce->ObjectType, &name,
                       &label, &fIsClass);
                (*pfn)(" %s - %s\n", label, name);
            }
            else {
                DumpGUID ((GUID *)&paaoAce->ObjectType, pfn);
                (*pfn)("\n");
            }
        }

        if ( paaoAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT )
        {
            if ( paaoAce->Flags & ACE_OBJECT_TYPE_PRESENT )
                pGuid = &paaoAce->InheritedObjectType;
            else
                pGuid = &paaoAce->ObjectType;

            (*pfn)("\t\tInherited object type: ");
            if (pfnguid) {
                (*pfnguid)(pGuid, &name, &label, &fIsClass);
                (*pfn)("%s - %s\n", label, name);
            }
            else {
                DumpGUID (pGuid, pfn);
                (*pfn)("\n");
            }
        }

        ptr = (PBYTE) &paaoAce->ObjectType;

        if ( paaoAce->Flags & ACE_OBJECT_TYPE_PRESENT )
            ptr += sizeof(GUID);

        if ( paaoAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT )
            ptr += sizeof(GUID);

        if (pfnsid) {
            (*pfn)("\t\tObject Ace Sid:   %s\n", (*pfnsid)((PSID) ptr));
        }
        else {
            (*pfn)("\t\tObject Ace Sid:");
            DumpSID ((PSID) ptr, pfn);
            (*pfn)("\n");
        }
    }
}


void
DumpAclHeader(
    PACL    pAcl,           // IN
    AclPrintFunc pfn)       // IN
{
    (*pfn)("\tRevision      %d\n", pAcl->AclRevision);
    (*pfn)("\tSize:         %d bytes\n", pAcl->AclSize);
    (*pfn)("\t# Aces:       %d\n", pAcl->AceCount);
}

//
// Dump an ACL to stdout in all its glory.
//

void
DumpAcl(
    PACL    pAcl,           // IN
    AclPrintFunc pfn,       // IN
    LookupGuidFunc pfnguid, //IN
    LookupSidFunc  pfnsid
    )
{
    DWORD                       dwErr;
    WORD                        i;
    ACE_HEADER                  *pAce;

    DumpAclHeader (pAcl, pfn);

    for ( i = 0; i < pAcl->AceCount; i++ )
    {
        (*pfn)("\tAce[%d]\n", i);

        if ( !GetAce(pAcl, i, (LPVOID *) &pAce) )
        {
            dwErr = GetLastError();
            (*pfn)("*** Error: GetAce ==> 0x%x - output incomplete\n",
                   dwErr);
        }
        else
        {
            DumpAce (pAce, pfn, pfnguid, pfnsid);
        }
    }
}


void DumpSDHeader (SECURITY_DESCRIPTOR *pSD,        // IN
                   AclPrintFunc        pfn)
{
    (*pfn)("SD Revision: %d\n", pSD->Revision);
    (*pfn)("SD Control:  0x%x\n", pSD->Control);
#define DOIT(flag) if (pSD->Control & flag) (*pfn)("\t\t%s\n", #flag)
    DOIT(SE_OWNER_DEFAULTED);
    DOIT(SE_GROUP_DEFAULTED);
    DOIT(SE_DACL_PRESENT);
    DOIT(SE_DACL_DEFAULTED);
    DOIT(SE_SACL_PRESENT);
    DOIT(SE_SACL_DEFAULTED);
//  DOIT(SE_SE_DACL_UNTRUSTED);
//  DOIT(SE_SE_SERVER_SECURITY);
    DOIT(SE_DACL_AUTO_INHERIT_REQ);
    DOIT(SE_SACL_AUTO_INHERIT_REQ);
    DOIT(SE_DACL_AUTO_INHERITED);
    DOIT(SE_SACL_AUTO_INHERITED);
    DOIT(SE_DACL_PROTECTED);
    DOIT(SE_SACL_PROTECTED);
    DOIT(SE_SELF_RELATIVE);
#undef DOIT

}


//
// Dump a security descriptor to stdout in all its glory.
//

void
DumpSD(
    SECURITY_DESCRIPTOR *pSD,        // IN
    AclPrintFunc        pfn,         // IN 
    LookupGuidFunc      pfnguid,     // IN
    LookupSidFunc       pfnsid       // IN
    )
{
    DWORD   dwErr;
    PSID    owner, group;
    BOOL    present, defaulted;
    PACL    dacl, sacl;

    DumpSDHeader (pSD, pfn);

    if ( !GetSecurityDescriptorOwner(pSD, &owner, &defaulted) )
    {
        dwErr = GetLastError();
        (*pfn)("*** Error: GetSecurityDescriptorOwner ==> 0x%x - output incomplete\n", dwErr);
    }
    else
    {
        if (pfnsid) {
            (*pfn)("Owner%s: %s\n",
               defaulted ? "(defaulted)" : "",
               (*pfnsid)(owner));
        }
        else {
            (*pfn)("Owner%s:", defaulted ? "(defaulted)" : "");
            DumpSID (owner, pfn);
            (*pfn)("\n");
        }
    }

    if ( !GetSecurityDescriptorGroup(pSD, &group, &defaulted) )
    {
        dwErr = GetLastError();
        (*pfn)("*** Error: GetSecurityDescriptorGroup ==> 0x%x - output incomplete\n", dwErr);
    }
    else
    {
        if (pfnsid) {
            (*pfn)("Group%s: %s\n",
               defaulted ? "(defaulted)": "",
               (*pfnsid)(group));
        }
        else {
            (*pfn)("Group%s", defaulted ? "(defaulted)" : "");
            DumpSID (group, pfn);
            (*pfn)("\n");
        }
    }

    if ( !GetSecurityDescriptorDacl(pSD, &present, &dacl, &defaulted) )
    {
        dwErr = GetLastError();
        (*pfn)("*** Error: GetSecurityDescriptorDacl ==> 0x%x - output incomplete\n", dwErr);
    }
    else if ( !present )
    {
        (*pfn)("DACL%s not present\n", (defaulted ? "(defaulted)" : ""));
    }
    else if ( !dacl )
    {
        (*pfn)("DACL%s is <NULL>\n", (defaulted ? "(defaulted)" : ""));
    }
    else
    {
        (*pfn)("DACL%s:\n", (defaulted ? "(defaulted)" : ""));
        DumpAcl(dacl, pfn, pfnguid, pfnsid);
    }

    if ( !GetSecurityDescriptorSacl(pSD, &present, &sacl, &defaulted) )
    {
        dwErr = GetLastError();
        (*pfn)("*** Error: GetSecurityDescriptorSacl ==> 0x%x - output incomplete\n", dwErr);
    }
    else if ( !present )
    {
        (*pfn)("SACL%s not present\n", (defaulted ? "(defaulted)" : ""));
    }
    else if ( !sacl )
    {
        (*pfn)("SACL%s is <NULL>\n", (defaulted ? "(defaulted)" : ""));
    }
    else
    {
        (*pfn)("SACL%s:\n", (defaulted ? "(defaulted)" : ""));
        DumpAcl(sacl, pfn, pfnguid, pfnsid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\atq\timeout.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
        timeout.cxx

   Abstract:
        This module contains code for timeout processing of ATQ contexts

   Author:

       Murali R. Krishnan    ( MuraliK )     16-July-1997

   Environment:
       Win32 - User Mode

   Project:
       Internet Server - Asynchronous Thread Queue Module

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "isatq.hxx"


/************************************************************
 * Globals
 ************************************************************/

DWORD   g_dwTimeoutCookie = 0; // Scheduler Cookie for timeout processing

DWORD   g_AtqCurrentTick = 1;

DWORD g_dwTimeout = ATQ_TIMEOUT_INTERVAL;  // active timeout value

/************************************************************
 *    Functions
 ************************************************************/



BOOL
I_TimeOutContext(
    PATQ_CONT pAtqContext
    )
/*++

Routine Description:

    This function does the actual timeout for a particular context.
    Note: The Context list lock is held while processing this function

Arguments:

    Context - Pointer to the context to be timed out

Return value:

    TRUE, if the completion routine was called
    FALSE, otherwise

--*/
{

    DWORD timeout;

    //
    //  Call client after re-checking that this item
    //  really has timed out

    //
    // Fake timeout
    //

    if ( pAtqContext->TimeOut == ATQ_INFINITE ) {
        pAtqContext->NextTimeout = ATQ_INFINITE;
        return(FALSE);
    }

    //
    // Was our timeout long enough?
    //

    // NYI: Optimize: CanonTimeout should be called only once per IO submitted
    timeout = CanonTimeout( pAtqContext->BytesSent/g_cbMinKbSec);
    if ( timeout > pAtqContext->TimeOut ) {

        //
        // Reset the Timeout value based on the bytes to be sent
        // as well as update the time when this pAtqContext be timedout
        //

        pAtqContext->TimeOut = timeout;
        pAtqContext->NextTimeout = AtqGetCurrentTick( ) + timeout;
        return(FALSE);
    }

    //
    // If this is on blocked list, remove it.
    //

    if ( pAtqContext->IsBlocked()) {
        PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;
        ATQ_ASSERT( pBandwidthInfo != NULL );
        ATQ_REQUIRE( pBandwidthInfo->RemoveFromBlockedList(pAtqContext));
    }

    //
    //  If we've already indicated this connection to the client,
    //  then we abort them by calling their IO completion routine
    //  and letting them cleanup.  Otherwise we close the socket
    //  which will generally cause an IO aborted completion that
    //  we will cleanup.  Note there is a window where we may
    //  close the socket out from under a client in their
    //  connection completion routine but that should be ok.
    //

    if ( pAtqContext->pfnCompletion &&
         pAtqContext->IsFlag( ACF_CONN_INDICATED)) {

        //
        //  TransmitFile socket state will be unconnected because
        //  we're expecting it to complete successfully.  Reset the
        //  state so the socket gets cleaned up properly
        //

        if ( pAtqContext->IsState( ACS_SOCK_UNCONNECTED) ) {
            pAtqContext->MoveState( ACS_SOCK_CONNECTED);
        }

        AcIncrement( CacAtqContextsTimedOut);

        pAtqContext->NextTimeout = ATQ_INFINITE;

        pAtqContext->IOCompletion( 0, ERROR_SEM_TIMEOUT, NULL);

        //
        //  We can't touch any items on the list after notifying
        //  the client as the client may have re-entered
        //  and freed some items from the list
        //

        return(TRUE);

    } else {

        HANDLE hIO;

        hIO = (HANDLE ) InterlockedExchangePointer(
                                        (PVOID *) &pAtqContext->hAsyncIO,
                                        NULL
                                        );
        DBG_ASSERT(!pAtqContext->fDatagramContext);
        IF_DEBUG( TIMEOUT) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "Timeout: closesocket(%d) Context=%08x\n",
                         hIO, pAtqContext));
        }
        closesocket( (SOCKET) hIO );
    }

    return(FALSE); // we can touch the items on current list.

} // I_TimeOutContext




VOID
AtqProcessTimeoutOfRequests(
    PATQ_CONTEXT_LISTHEAD ContextList
    )
/*++

Routine Description:

    Walks the list of Atq clients looking for any item that has timed out and
    notifies the client if it has.

    TimeOutScanID is used as a serial number to prevent evaluating the same
    context twice.  We start from the beginning of the list everytime we
    notify a client an Atq context has timed out.  We do this because the
    client timeout processing may remove any number of Items from the
    list (including the next couple of items in the list).

    This routine also checks to make sure outstanding AcceptEx sockets
    haven't been exhausted (if less then 25% available, adds some more).

--*/
{
    DWORD                  newLatest = ATQ_INFINITE;
    BOOL                   fRescan;

    //
    // See if the latest one is timed-out
    //

    if ( ContextList->LatestTimeout > AtqGetCurrentTick( ) ) {

        return;
    }

    // set the latest timeout in the context list,
    // to avoid races with IO being started.
    ContextList->LatestTimeout = ATQ_INFINITE;

    //
    //  Scan the timeout list looking for items that have timed out
    //  and adjust the timeout values
    //

    do {

        LIST_ENTRY *           pentry;
        LIST_ENTRY *           pentryNext;
        DWORD                  scanId = AtqGetCurrentTick( );

        ContextList->Lock( );

        fRescan = FALSE;

        for ( pentry  = ContextList->ActiveListHead.Flink;
              pentry != &ContextList->ActiveListHead;
              pentry  = pentryNext ) {

            PATQ_CONT              pContext;

            pentryNext = pentry->Flink;

            pContext = CONTAINING_RECORD(
                                pentry,
                                ATQ_CONTEXT,
                                m_leTimeout
                                );

            if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE ) {
                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                break;
            }

            //
            //  Ignore items we've already processed
            //

            if ( pContext->TimeOutScanID == scanId ) {
                continue;
            }

            pContext->TimeOutScanID = scanId;

            //
            // If there is an IO which has popped up now,
            //  we have to do nothing. This code was added to protect catapult!
            //
            pContext->SetFlag( ACF_IN_TIMEOUT);

            if ( !pContext->lSyncTimeout) {

                // no body is using this context. Check and synchronize
                // the timeout state.

                //
                //  The client specifies the IO doesn't timeout if
                //  INFINITE is in the TimeOut field of the ATQ context
                //  If we've timed out, then notify the client.
                //

                DWORD nextTimeout = pContext->NextTimeout;
                if ( nextTimeout > AtqGetCurrentTick() ) {


                    // pick up the latest "low" value for
                    // firing next timeout thread
                    if ( nextTimeout < newLatest ) {
                        newLatest = nextTimeout;
                    }
                } else if ( I_TimeOutContext(pContext) ) {

                    // we are done checking and processing timeout.
                    // reset the In Timeout flag
                    pContext->ResetFlag( ACF_IN_TIMEOUT);
                    fRescan = TRUE;
                    break;
                } else {

                    //
                    // It is possible that the timeout got reset
                    // Check for the latest "low" value
                    //
                    nextTimeout = pContext->NextTimeout;
                    if ( nextTimeout < newLatest ) {
                        newLatest = nextTimeout;
                    }
                }

            } else {
                AcIncrement( CacAtqProcWhenTimeout);
            }

            // we are done checkin and processing timeouts.
            // reset the In Timeout flag
            pContext->ResetFlag( ACF_IN_TIMEOUT);

        } // scan list

        // let other system threads also run happily for a while
        ContextList->Unlock( );

    } while (fRescan);

    if ( newLatest != ATQ_INFINITE) {
        // We picked up the latest timeout. store it.
        ContextList->LatestTimeout = newLatest;
    }

    return;

} // AtqProcessTimeoutOfRequests




//
// ACCEPT_EX_TIMEOUT_STATS collects statistics for the
//   timeout processing in the Pending AcceptEx List//
//
struct ACCEPT_EX_TIMEOUT_STATS {

    DWORD  m_nScanned;
    DWORD  m_nTimedOut;
    DWORD  m_nSkipped;
    DWORD  m_nConnected;
    DWORD  m_nNotConnected;
};


BOOL
I_TimeOutPendingAcceptExContext(
    PATQ_CONT pAtqContext
    )
/*++

Routine Description:

    This function does the actual timeout for a pending AcceptEx context.
    Note: The Context list lock is held while processing this function

Arguments:

    pAtqContext - Pointer to the context to be timed out

Return value:

    TRUE, if a tmieout operation was conducted.
    FALSE, otherwise

--*/
{
    DBG_ASSERT( pAtqContext != NULL);

    //
    // in the shutdown case it is possible that someone closed this socket already
    // so don't worry about it.
    //
    if ( pAtqContext->hAsyncIO == NULL ) {
        return TRUE;
    }

    //
    // Validate our assumptions about this Pending AcceptEx Context
    // there is an endpoint => AcceptEx context
    DBG_ASSERT( pAtqContext->pEndpoint != NULL);
    DBG_ASSERT( pAtqContext->IsState( ACS_SOCK_LISTENING));
    DBG_ASSERT( !pAtqContext->IsFlag( ACF_CONN_INDICATED));
    DBG_ASSERT( pAtqContext->TimeOut != ATQ_INFINITE);


    //
    // We will obtain the socket handle stored inside the AcceptEx Context
    //    and free up the context.
    // Warning:
    //   The AcceptEx socket did not have a connection when this function
    //   was called. However now between the time when the state was checked
    //   and the time this timeout operation completes, it is possible that
    //   a new connection is bound to this AcceptEx context => we can get IO completion.
    //   I need to handle this case
    //

    HANDLE hIO;

    hIO = (HANDLE ) InterlockedExchangePointer(
                            (PVOID *) &pAtqContext->hAsyncIO,
                            NULL
                            );
    DBG_ASSERT(!pAtqContext->fDatagramContext);
    IF_DEBUG( TIMEOUT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "TimeoutPendingAcceptExContext(%08x): closesocket(%d)\n",
                      pAtqContext, hIO));
    }

    closesocket( (SOCKET) hIO );

    return ( TRUE);
} // I_TimeOutPendingAcceptExContext()


BOOL
I_IsTimeoutForAcceptExContext(
    IN OUT PATQ_CONT                  pAtqContext,
    IN OUT ACCEPT_EX_TIMEOUT_STATS  * pAetStats
    )
/*++

Routine Description:

    This function checks to see if timeout operation has to be performed
    for a given AtqContext. It bases the decision on the a variety of
    details maintained in Atq Context and the Endpoint.
    Note: The Context list lock is held while processing this function

Arguments:

    pAtqContext - Pointer to the context to be timed out
    pAetStats   - pointer to AcceptEx Timeout Statistics structure

Return value:

    TRUE, if a tmieout operation has to be conducted.
    FALSE, when no timeout is required.

--*/
{
    DBG_ASSERT( pAtqContext);
    DBG_ASSERT( pAetStats);

    PATQ_ENDPOINT  pEndpoint;
    pEndpoint = pAtqContext->pEndpoint;

    if ( pEndpoint != NULL) {

        //
        // We will use getsockopt() to query the connection status
        //  for the socket inside the Atq context.
        // If Socket is not connected => leave it in the pool
        // If Socket is connected and waiting for receive operation =>
        //        do timeout processing
        //
        // The goal is to maintain a pool of sockets in listening state
        //  so that any new connection will be picked up quickly.
        //
        // getsockopt() is a very costly function.
        // We check to see if we have enough sockets available
        //  for an endpoint. If they are, then we bypass calling getsockopt
        // "enough" is defined as # of available sockets is at least
        //   25% of the total # of accept ex sockets outstanding.
        // Optimize calling getsockopt() based on
        //   current count in pEndpoint->nAvailDuringTimeOut
        //

        if ( pEndpoint->nAvailDuringTimeOut >
             ( pEndpoint->nAcceptExOutstanding >> 2)
             ) {

            // Already enough Contexts are available.
            //  Do nothing
            pAetStats->m_nSkipped++;

            return (FALSE); // Do not timeout
        }

        DWORD dwConnect;
        int   cbOptLen = sizeof( dwConnect );

        //
        // Query the socket layer if the current socket has a valid connection
        // An AcceptEx socket can be connected and waiting for new request to
        //   be read. If we are in such state we should not blow away context.
        //
        if ( getsockopt((SOCKET) pAtqContext->hAsyncIO,
                        SOL_SOCKET,
                        SO_CONNECT_TIME,
                        (char *) &dwConnect,
                        &cbOptLen ) != SOCKET_ERROR
             ) {

            //
            //  A return value of 0xFFFFFFFF indicates that the given
            //   AcceptEx socket is not connected yet.
            //  Otherwise the socket is connected and is probably wating
            //   for request to be read or maybe a completion is already
            //   on its way.
            //

            if ( dwConnect == (DWORD) 0xFFFFFFFF ) {

                //
                //  Ignore the "Listen" socket context
                //

                pAetStats->m_nNotConnected++;

                DBG_ASSERT( NULL != pEndpoint);
                pEndpoint->nAvailDuringTimeOut++;

                // Update timeout values to give a breather interval
                pAtqContext->NextTimeout =
                    AtqGetCurrentTick() + pAtqContext->TimeOut;

                return ( FALSE);  // Do not timeout
            }
            else if ( !pAtqContext->IsFlag(ACF_WINSOCK_CONNECTED) ) {

                //
                // Mark that this context has connection indicated.
                // If this context waits around in connected state for
                //  long-time we need to blow the context away.
                //

                pAetStats->m_nConnected++;

                // Update timeout values to give a breather interval
                pAtqContext->NextTimeout =
                    AtqGetCurrentTick() + pAtqContext->TimeOut;

                pAtqContext->SetFlag(ACF_WINSOCK_CONNECTED);

                return (FALSE); // do not timeout now
            }
        }
    } // if Endpoint exists

    return (TRUE); // yes timeout this context
} // I_IsTimeoutForAcceptExContext()


VOID
I_AtqProcessPendingListens(
    IN PATQ_CONTEXT_LISTHEAD pContextList
    )
/*++

Routine Description:

    Walks the list of Pending accept ex and makes sure none has timed out.
    Also checks to see if we need to allocate more AcceptEx sockets.

  Arguments:
    pContextList - pointer to ATQ_CONTEXT_LISTHEAD object

  Returns:
    None

--*/
{
    BOOL                    fRescan;

    ACCEPT_EX_TIMEOUT_STATS AetStats;

    //
    // Initialize Statistics block
    //
    AetStats.m_nScanned         = 0;
    AetStats.m_nTimedOut        = 0;
    AetStats.m_nSkipped         = 0;
    AetStats.m_nConnected       = 0;
    AetStats.m_nNotConnected    = 0;


    //
    //  Look through the listening sockets to make sure the AcceptEx sockets
    //  haven't been exhausted
    //

    do {

        LIST_ENTRY *           pentry;
        LIST_ENTRY *           pentryNext;
        DWORD                  scanId = AtqGetCurrentTick( );

        fRescan = FALSE;

        pContextList->Lock();

        for ( pentry  = pContextList->PendingAcceptExListHead.Flink;
              pentry != &pContextList->PendingAcceptExListHead;
              pentry  = pentryNext ) {

            PATQ_CONT      pContext;

            pentryNext = pentry->Flink;
            pContext = CONTAINING_RECORD(
                                pentry,
                                ATQ_CONTEXT,
                                m_leTimeout
                                );

            if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE ) {
                DBG_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                break;
            }

            //
            //  Ignore items we've already processed
            //

            if ( pContext->TimeOutScanID == scanId ) {
                continue;
            }

            AetStats.m_nScanned++;
            pContext->TimeOutScanID = scanId;

            if ( pContext->fDatagramContext ) {
                continue;
            }

            //
            // If the context has Timeout value smaller than the one in our global tick
            //  then examine if this context can be timedout
            //

            DBG_CODE( if ( pContext->IsAcceptExRootContext())
                        {
                            DBG_ASSERT( pContext->TimeOut == ATQ_INFINITE);
                            DBG_ASSERT( pContext->NextTimeout == ATQ_INFINITE);
                        }
                        );

            if ( pContext->NextTimeout <= AtqGetCurrentTick()) {

                //
                // Protect against the race with the normal IO completion
                //
                pContext->SetFlag( ACF_IN_TIMEOUT);

                if ( !pContext->lSyncTimeout ) {

                    if ( !I_IsTimeoutForAcceptExContext( pContext, &AetStats)) {

                        pContext->ResetFlag( ACF_IN_TIMEOUT);
                        continue;
                    }

                    if ( I_TimeOutPendingAcceptExContext(pContext)) {
                        AetStats.m_nTimedOut++;
                        fRescan = TRUE;
                        pContext->ResetFlag(ACF_IN_TIMEOUT);
                        break;
                    }
                } // if (!pContext->lSyncTimeout)

                pContext->ResetFlag( ACF_IN_TIMEOUT);
            } // if the context's timeout value <= CurrentTick
            else {

                //
                // Timeout value has not been reached. Skip this context
                //

                AetStats.m_nSkipped++;
           }
        } // scan list

        pContextList->Unlock();

    } while (fRescan);

    IF_DEBUG( TIMEOUT) {
       DBGPRINTF(( DBG_CONTEXT,
                   "TimeoutPendingListens( CtxtList[%d], AtqTick=%d)\n"
                   " Contexts Scanned=%d, Skipped=%d, TimedOut=%d,"
                   " Connected=%d, NotConnected=%d\n",
                   pContextList - AtqActiveContextList, AtqGetCurrentTick(),
                   AetStats.m_nScanned, AetStats.m_nSkipped,
                   AetStats.m_nTimedOut, AetStats.m_nConnected,
                   AetStats.m_nNotConnected
                ));
    }

# ifdef IIS_AUX_COUNTERS
    g_AuxCounters[CacAtqPendingAcceptExScans] += AetStats.m_nScanned;
# endif // IIS_AUX_COUNTERS

    return;

} // I_AtqProcessPendingListens()




VOID
I_AtqCheckEndpoints(
            VOID
            )
/*++
  Description:
    This function checks all the listen info objects and adds appropriate
     number of accept ex sockets as necessary.

  Arguments:
    None

  Returns:
    None
--*/
{
    LIST_ENTRY *  pEntry;
    PATQ_ENDPOINT pEndpoint;

    AcquireLock( &AtqEndpointLock);

    for ( pEntry  = AtqEndpointList.Flink;
          pEntry != &AtqEndpointList;
          pEntry  = pEntry->Flink ) {

        pEndpoint = CONTAINING_RECORD(
                                    pEntry,
                                    ATQ_ENDPOINT,
                                    ListEntry
                                    );

        DBG_ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

        DBG_ASSERT( pEndpoint->nSocketsAvail >= 0);

        //
        // Check to make sure outstanding AcceptEx sockets
        // haven't been exhausted (if less then 25% available, adds some more).
        //

        if ( !pEndpoint->fDatagram ) {

            if ( ((DWORD ) pEndpoint->nSocketsAvail) <
                 (pEndpoint->nAcceptExOutstanding >> 2) ) {

                IF_DEBUG( TIMEOUT ) {
                    DBGPRINTF(( DBG_CONTEXT,
                                "[Timeout] Adding AcceptEx Contexts for EP=%08x; nAvail = %d;\n",
                                pEndpoint, pEndpoint->nSocketsAvail));
                }

                (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                    pEndpoint->nAcceptExOutstanding
                                                    );
            }
        }

        //
        // set to zero, so recount will be done during next timeout loop
        //

        pEndpoint->nAvailDuringTimeOut = 0;

    }

    ReleaseLock( &AtqEndpointLock);

    return;
} // I_AtqCheckEndpoints



VOID
I_AtqTimeOutWorker(VOID)
/*++
  Description:
    This function handles timeout processing using the simple
    clock algorithm, wherein partial set of lists are scanned
    during each timeout processing call.

  Arguments:
    None


  Returns:
    None
--*/
{
    DWORD start;
    PATQ_CONTEXT_LISTHEAD pContextList;

    IF_DEBUG(TIMEOUT) {
        DBGPRINTF((DBG_CONTEXT, "TimeoutWorker: entered\n"));
    }

    start = (AtqGetCurrentTick() & 0x1);

    for ( pContextList = AtqActiveContextList + start;
          pContextList < (AtqActiveContextList + g_dwNumContextLists) ;
          pContextList += 2 ) {

        IF_DEBUG(TIMEOUT) {
            DBGPRINTF((DBG_CONTEXT,
                       "TimeoutWorker: Processing list[%d] = %08x\n",
                       (pContextList - AtqActiveContextList),
                       pContextList));
        }

        AtqProcessTimeoutOfRequests( pContextList );
        I_AtqProcessPendingListens( pContextList );
    } // for

    if ( start != 0 ) {
        I_AtqCheckEndpoints( );
    }

    return;

} // I_AtqTimeOutWorker()




VOID
WINAPI
I_AtqTimeoutCompletion(
    IN PVOID Context
    )
/*++

Routine Description:

    Callback routine for the scheduled version of the timeout thread.

    The callback assumes timeouts are rounded to ATQ_TIMEOUT_INTERVAL

    In addition to timing out requests when necessary, the timeout thread
     also performs the job of bandwidth calculation and tuning the bandwidth
     throttle operation (which works on feedback mechanism).
    At every sampling interval the scheduled callback comes in and it updates
     the bandwidth.

Arguments:

    Context - Context returned by the scheduler thread.

Return Value:

    none.

--*/
{
    DWORD Timeout = ATQ_TIMEOUT_INTERVAL;
    BOOL  fDoContextTimeout = TRUE;

    if ( g_fShutdown ) {

        ATQ_PRINTF(( DBG_CONTEXT,
            "Detected a shutdown while entering timeout callback\n"));
        return;
    }

    InterlockedIncrement( (PLONG)&g_AtqCurrentTick );

    //
    //  Perform necessary steps to handle Bandwidth throttling.
    //

    ATQ_ASSERT( BANDWIDTH_INFO::sm_cSamplesForTimeout >= 1);

    IF_DEBUG(TIMEOUT) {
        DBGPRINTF((DBG_CONTEXT,
                 "Timeout: BANDWIDTH_INFO::cSamplesForTimeout=%d\n",
                 BANDWIDTH_INFO::sm_cSamplesForTimeout ));
    }

    if ( BANDWIDTH_INFO::GlobalActive() ) {

        --(BANDWIDTH_INFO::sm_cSamplesForTimeout);

        // Perform a sampling to update measured bandwidth +
        //  apply feedback policy

        BANDWIDTH_INFO::UpdateAllBandwidths();

        Timeout = ATQ_SAMPLE_INTERVAL_IN_SECS;
        if ( BANDWIDTH_INFO::sm_cSamplesForTimeout != 0) {

            // We have not reached timeout yet. So skip context timeouts

            fDoContextTimeout = FALSE;
        } else {

            // We had reached the timeout interval for requests.
            // Examine and release requests.
            ATQ_ASSERT( BANDWIDTH_INFO::sm_cSamplesForTimeout == 0);

            // reset the count of samples before proceeding.
            BANDWIDTH_INFO::sm_cSamplesForTimeout = NUM_SAMPLES_PER_TIMEOUT_INTERVAL;
        }
    } else {
        BANDWIDTH_INFO::sm_cSamplesForTimeout = 1;
    }

    //
    // We are at a Timeout Interval. Examine and timeout requests.
    //

    if ( fDoContextTimeout ) {
        I_AtqTimeOutWorker();
    }

    if ( Timeout != g_dwTimeout) {

        // the scheduled interval is different from this current interval
        // Inidicate the changed timeout value to the scheduler

        ScheduleAdjustTime( g_dwTimeoutCookie, TimeToWait(Timeout));
        g_dwTimeout = Timeout;
    }

    return;
} // I_AtqTimeoutCompletion




BOOL
I_AtqStartTimeoutProcessing(
    IN PVOID Context
    )
/*++

Routine Description:

    Starts the timeout processing. It always uses the scheduler to schedule
    a timeout operation.

    Note: The scheduler should be initialized before getting to this function.

Arguments:

    Context - Context passed to the thread creation or scheduler thread.

Return Value:

    TRUE, if ok
    FALSE, otherwise

--*/
{
    ATQ_ASSERT( ATQ_SAMPLE_INTERVAL_IN_SECS < ATQ_TIMEOUT_INTERVAL );

    if ( BANDWIDTH_INFO::GlobalEnabled() ) {
        g_dwTimeout = ATQ_SAMPLE_INTERVAL_IN_SECS;
        BANDWIDTH_INFO::sm_cSamplesForTimeout =
            NUM_SAMPLES_PER_TIMEOUT_INTERVAL;
    } else {
        g_dwTimeout = ATQ_TIMEOUT_INTERVAL;
        BANDWIDTH_INFO::sm_cSamplesForTimeout = 1;
    }

    g_dwTimeoutCookie =
        ScheduleWorkItem(
                         (PFN_SCHED_CALLBACK)I_AtqTimeoutCompletion,
                         Context,
                         TimeToWait(g_dwTimeout)
                         , TRUE  // ask for periodic timeout
                         );

    if ( g_dwTimeoutCookie == 0 ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Error %d scheduling timeout\n",GetLastError()));
        return(FALSE);
    }

    return(TRUE);

} // I_AtqStartTimeoutProcessing()



BOOL
I_AtqStopTimeoutProcessing(
    VOID
    )
/*++

Routine Description:

    Stops the timeout processing. It terminates the scheduled workitem and
    cleans up any state.

    Note: The scheduler should be terminated only after this call

Arguments:

    Context - Context passed to the thread creation or scheduler thread.

Return Value:

    TRUE, if ok
    FALSE, otherwise

--*/
{

    if ( 0 != g_dwTimeoutCookie) {
        DBG_REQUIRE( RemoveWorkItem( g_dwTimeoutCookie ));
        g_dwTimeoutCookie = 0;
    }

    return ( TRUE);

} // I_AtqStopTimeoutProcessing()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\dscommon\dbopen.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dbopen.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains the subroutines that are related to opening
    the DS Jet database. These subroutines are used in two places:
        In the core DS and
        in the various utilities that want to open the DS database directly.

    A client application that wants to open the DS database, has to follow these steps:
        call DBSetRequiredDatabaseSystemParameters
        call DBInitializeJetDatabase

    In order to close the database it has to follow the standard Jet procedure.

Author:

    MariosZ 6-Feb-99

Environment:

    User Mode - Win32

Revision History:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <errno.h>
#include <esent.h>
#include <dsconfig.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>

#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>


#include <mdcodes.h>
#include <dsevent.h>
#include <dsexcept.h>
#include <dbopen.h>
#include "anchor.h"
#include "objids.h"     /* Contains hard-coded Att-ids and Class-ids */
#include "usn.h"
#include "debug.h"      /* standard debugging header */
#define DEBSUB     "DBOPEN:"   /* define the subsystem for debugging */
#include <ntdsctr.h>
#include <dstaskq.h>
#include <fileno.h>
#define  FILENO FILENO_DBOPEN
#include "dbintrnl.h"


/*
 * Global variables
 */
BOOL  gFirstTimeThrough = TRUE;
BOOL  gfNeedJetShutdown = FALSE;
ULONG gulCircularLogging = TRUE;


/* put name and password definitions here for now.  At some point
   someone or something must enter these.
*/

#define SZUSER          "admin"         /* JET user name */
#define SZPASSWORD      "password"      /* JET password */

/* Global variables for JET user name and password,
   JET database pathname, and column IDs for fixed columns.
   externals defined in dbjet.h
*/

char            szUser[] = SZUSER;
char            szPassword[] = SZPASSWORD;
char            szJetFilePath[MAX_PATH];
ULONG           gcMaxJetSessions;


//
// Used for detecting drive name change
//
DS_DRIVE_MAPPING DriveMappings[DS_MAX_DRIVES] = {0};


DWORD gcOpenDatabases = 0;

// if 1, then we allow disk write caching.
//
DWORD gulAllowWriteCaching = 0;



    extern int APIENTRY DBAddSess(JET_SESID sess, JET_DBID dbid);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function gets the path to the database files from the registry
*/
BOOL dbGetFilePath(UCHAR *pFilePath, DWORD dwSize)
{

   DPRINT(2,"dbGetFilePath entered\n");

   if (GetConfigParam(FILEPATH_KEY, pFilePath, dwSize)){
      DPRINT(1,"Missing FilePath configuration parameter\n");
      return !0;
   }
   return 0;

}/*dbGetFilePath*/


BOOL
DisableDiskWriteCache(
    IN PCHAR DriveName
    );

//
// points to the drive mapping array used to resolve drive letter/volume mappings
//

PDS_DRIVE_MAPPING   gDriveMapping = NULL;


INT
FindDriveFromVolume(
    IN LPCSTR VolumeName
    )
/*++

Routine Description:

    Searches for the drive letter corresponding to the given volume name.

Arguments:

    VolumeName - The volume name used to find the drive letter for

Return Value:

    the drive letter (zero indexed i.e. a=0,z=25) if successful
    -1 if not.

--*/
{

    CHAR volname[MAX_PATH];
    CHAR driveLetter;
    CHAR path[4];
    path[1] = ':';
    path[2] = '\\';
    path[3] = '\0';

    for (driveLetter = 'a'; driveLetter <= 'z'; driveLetter++ ) {

        path[0] = driveLetter;

        if (!GetVolumeNameForVolumeMountPointA(path,volname,MAX_PATH)) {
            continue;
        }


        if ( _stricmp(volname, VolumeName) == 0) {

            return (INT)(driveLetter - 'a');
        }
    }

    DPRINT1(0,"FindDriveFromVolume for %s not found.\n",VolumeName);
    return -1;

} // FindDriveFromVolume



VOID
DBInitializeDriveMapping(
    IN PDS_DRIVE_MAPPING DriveMapping
    )
/*++

Routine Description:

    Read the current registry setting for the mapping and detects if something
    has changed.

Arguments:

    DriveMapping - the drive mapping structure to record changes

Return Value:

    None.

--*/
{
    PCHAR p;
    HKEY hKey;
    CHAR tmpBuf[4 * MAX_PATH];
    DWORD nRead = sizeof(tmpBuf);
    DWORD err;
    DWORD type;

    gDriveMapping = DriveMapping;

    //
    // Write it down
    //

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       DSA_CONFIG_SECTION,
                       0,
                       KEY_ALL_ACCESS,
                       &hKey);

    if ( err != ERROR_SUCCESS ) {
        DPRINT2(0,"RegOpenKeyEx[%s] failed with %d\n",DSA_CONFIG_SECTION,err);
        return;
    }

    err = RegQueryValueEx(hKey,
                          DSA_DRIVE_MAPPINGS,
                          NULL,
                          &type,
                          tmpBuf,
                          &nRead
                          );

    if ( err != ERROR_SUCCESS ) {
        DPRINT2(0,"RegQueryValueEx[%s] failed with %d\n",
                DSA_DRIVE_MAPPINGS,err);
        goto cleanup;
    }

    RegCloseKey(hKey);

    p = tmpBuf;
    while (*p != '\0') {

        CHAR path[4];
        DWORD drive;
        CHAR volName[MAX_PATH];

        CopyMemory(path,p,3);
        path[3] = '\0';
        path[0] = (CHAR)tolower(path[0]);
        p += 3;

        //
        // Should be X:\=\\?\Volume{...}\
        //

        if ( isalpha(path[0]) &&
             (path[1] == ':') &&
             (path[2] == '\\') &&
             (*p == '=') ) {

            p++;
            drive = path[0] - 'a';

            //
            // Get the volume name for the listed path and see if it matches
            //

            gDriveMapping[drive].fListed = TRUE;
            if (GetVolumeNameForVolumeMountPointA(path,volName,sizeof(volName)) ) {

                //
                // if it matches, go on.
                //

                if ( _stricmp(p, volName) == 0 ) {
                    p += strlen(p) + 1;
                    continue;
                } else {
                    DPRINT3(0,"Drive path %s has changed[%s != %s]\n",path,p,volName);
                }
            } else {
                DPRINT2(0,"GetVolName[%s] failed with %d\n",path,GetLastError());
            }

            //
            // Either we could not get the volume info or it did not match.  Mark
            // it as changed.
            //

            gDriveMapping[drive].fChanged = TRUE;
            gDriveMapping[drive].NewDrive = FindDriveFromVolume(p);

            p += strlen(p) + 1;

        } else {
            DPRINT1(0,"Invalid path name [%s] found in mapping.\n", path);
            goto cleanup;
        }
    }

cleanup:
    return;

} // DBInitializeDriveMapping




VOID
DBRegSetDriveMapping(
    VOID
    )
/*++

Routine Description:

    Writes out the drive information to the registry

Arguments:

    None.

Return Value:

    None.

--*/
{

    DWORD i;
    DWORD err;

    CHAR tmpBuf[4 * MAX_PATH]; // we only have 4 paths to worry about
    PCHAR p;

    HKEY hKey;
    BOOL  fOverwrite = FALSE;

    if ( gDriveMapping == NULL ) {
        return;
    }

    //
    // Go through the list to figure out if we need to change anything
    //

    for (i=0;i < DS_MAX_DRIVES;i++) {

        //
        // if anything has changed, we need to overwrite.
        //

        if ( gDriveMapping[i].fChanged ||
             (gDriveMapping[i].fUsed != gDriveMapping[i].fListed) ) {

            fOverwrite = TRUE;
            break;
        }
    }

    //
    // if the old regkeys are fine, we're done.
    //

    if ( !fOverwrite ) {
        return;
    }

    //
    // Write it down
    //

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       DSA_CONFIG_SECTION,
                       0,
                       KEY_ALL_ACCESS,
                       &hKey);

    if ( err != ERROR_SUCCESS ) {
        DPRINT2(0,"RegOpenKeyEx[%s] failed with %d\n",DSA_CONFIG_SECTION,GetLastError());
        return;
    }

    //
    // Delete the old key
    //

    err = RegDeleteValue(hKey, DSA_DRIVE_MAPPINGS);

    if ( err != ERROR_SUCCESS ) {
        DPRINT2(0,"RegDeleteValue[%s] failed with %d\n",DSA_DRIVE_MAPPINGS,GetLastError());
        // ignore
    }

    //
    // Compose the new key
    //

    p = tmpBuf;
    for (i=0;i<DS_MAX_DRIVES;i++) {

        //
        // format of each entry is X:=\\?\Volume{...}
        //

        if ( gDriveMapping[i].fUsed ) {

            CHAR path[4];

            strcpy(path,"a:\\");
            path[0] = (CHAR)('a' + i);

            strcpy(p, path);
            p[3] = '=';
            p += 4;

            if (!GetVolumeNameForVolumeMountPointA(path,p,MAX_PATH)) {

                DPRINT2(0,"GetVolumeName[%s] failed with %d\n",path,GetLastError());
                p -= 4;
                break;
            }

            p += (strlen(p)+1);
        }
    }

    *p++ = '\0';

    //
    // Set the new key
    //

    if ( (DWORD)(p-tmpBuf) != 0 ) {

        err = RegSetValueEx(hKey,
                            DSA_DRIVE_MAPPINGS,
                            0,
                            REG_MULTI_SZ,
                            tmpBuf,
                            (DWORD)(p - tmpBuf)
                            );

        if ( err != ERROR_SUCCESS ) {
            DPRINT2(0,"RegSetValueEx[%s] failed with %d\n",
                    DSA_DRIVE_MAPPINGS,GetLastError());
        }
    }

    RegCloseKey(hKey);
    return;

} // DBRegSetDriveMapping




VOID
ValidateDsPath(
    IN LPSTR  Parameter,
    IN LPSTR  szPath,
    IN DWORD  Flags,
    IN PBOOL  fSwitched, OPTIONAL
    IN PBOOL  fDriveChanged OPTIONAL
    )
/*++

Routine Description:

    Takes a path and see if it is still valid.  If not, it detects whether a drive
    letter change happened and tries to use the old drive letter.

Arguments:

    Parameter - reg key used to store the path
    szPath - the current value for the path
    Flags - Flags to specify some options. Valid options are:
        VALDSPATH_DIRECTORY
        VALDSUSE_ALTERNATE
        VALDSUSE_ROOT_ONLY
    fSwitched - Did we change the value of szPath on exit?
    fDriveChanged - allows us to indicate whether there was a drive name change

Return Value:

    None.

--*/
{
    DWORD drive;
    DWORD flags;
    CHAR tmpPath[MAX_PATH+1];
    DWORD err;
    CHAR savedChar;

    DWORD expectedFlag =
        ((Flags & VALDSPATH_DIRECTORY) != 0) ? FILE_ATTRIBUTE_DIRECTORY:0;

    if (gDriveMapping == NULL) return;

    if ( fSwitched != NULL ) {
        *fSwitched = FALSE;
    }

    if ( fDriveChanged != NULL ) {
        *fDriveChanged = FALSE;
    }

    //
    // make sure the path starts with X:\\
    //

    if ( !isalpha(szPath[0]) || (szPath[1] != ':') || (szPath[2] != '\\') ) {
        return;
    }

    //
    // get the drive number a == 0, ..., z== 25
    //

    drive = tolower(szPath[0]) - 'a';

    //
    // if fChange is FALSE, that means that no rename happened.
    //

    if ( !gDriveMapping[drive].fChanged ) {

        //
        // indicate that we saw these
        //

        gDriveMapping[drive].fUsed = TRUE;
        return;
    }

    if ( fDriveChanged != NULL ) {
        *fDriveChanged = TRUE;
    }

    //
    // see if we're told to skip the first one
    //

    if ( (Flags & VALDSPATH_USE_ALTERNATE) != 0 ) {
        goto use_newdrive;
    }

    //
    // if we want to check the root only. terminate after the \\
    //

    savedChar = szPath[3];
    if ( (Flags & VALDSPATH_ROOT_ONLY) != 0 ) {
        szPath[3] = '\0';
    }

    //
    // there was a rename. See if the path is still valid.
    //

    flags = GetFileAttributes(szPath);
    szPath[3] = savedChar;

    //
    // if we failed or it is a directory or file (depending on what the user wanted),
    // then we're ok.
    //

    if ( (flags != 0xffffffff) && ((flags & FILE_ATTRIBUTE_DIRECTORY) == expectedFlag) ) {
        gDriveMapping[drive].fUsed = TRUE;
        return;
    }

use_newdrive:

    //
    // not a valid directory, try with the new drive letter
    //

    strcpy(tmpPath, szPath);
    tmpPath[0] = gDriveMapping[drive].NewDrive + 'a';

    //
    // if we want to check the root only. terminate after the \\
    //

    savedChar = tmpPath[3];
    if ( (Flags & VALDSPATH_ROOT_ONLY) != 0 ) {
        tmpPath[3] = '\0';
    }

    //
    // see if this is ok.  If not, return.
    //

    flags = GetFileAttributes(tmpPath);
    tmpPath[3] = savedChar;

    //
    // if it failed, then use the original one.
    //

    if ( (flags == 0xffffffff) || ((flags & FILE_ATTRIBUTE_DIRECTORY) != expectedFlag) ) {
        DPRINT3(0,"ValidateDsPath: GetFileAttribute [%s] failed with %d. Using %s.\n",
                tmpPath, GetLastError(),szPath);
        gDriveMapping[drive].fUsed = TRUE;
        return;
    }

    //
    // We are going out on a limb here and declare that because it failed
    // with the current path and succeeded with the old path, we are going to
    // change back to the old path.  Log an event and write back to registry
    //

    err = SetConfigParam(Parameter, REG_SZ, tmpPath, strlen(tmpPath)+1);
    if ( err != ERROR_SUCCESS ) {
        DPRINT3(0,"SetConfigParam[%s, %s] failed with %d\n",Parameter, szPath, err);
        gDriveMapping[drive].fUsed = TRUE;
        return;
    }

    // log an event

    DPRINT3(0,"Changing %s key from %s to %s\n",Parameter,szPath,tmpPath);

    LogEvent(DS_EVENT_CAT_STARTUP_SHUTDOWN,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_DB_REG_PATH_CHANGED,
             szInsertSz(Parameter),
             szInsertSz(szPath),
             szInsertSz(tmpPath));

    //
    // Mark this new drive as being used
    //

    gDriveMapping[gDriveMapping[drive].NewDrive].fUsed = TRUE;

    szPath[0] = tmpPath[0];
    if ( fSwitched != NULL ) {
        *fSwitched = TRUE;
    }

    return;

} // ValidateDsPath


VOID
DsaDetectAndDisableDiskWriteCache(
    IN PCHAR szPath
    )
/*++

Routine Description:

    Detect and disable disk write cache.

Arguments:

    szPath - Null terminated pathname on drive to disable.  Should start with X:\

Return Value:

   None.

--*/
{
    CHAR driveName[3];
    DWORD driveNum;

    //
    // see if we should do the check
    //

    if ( gulAllowWriteCaching == 1 ) {
        return;
    }

    //
    // Get and check path
    //

    if ( !isalpha(szPath[0]) || (szPath[1] != ':') ) {
        return;
    }

    driveName[0] = (CHAR)tolower(szPath[0]);
    driveName[1] = ':';
    driveName[2] = '\0';

    //
    // If disk write cache is enabled, log an event
    //

    if ( DisableDiskWriteCache( driveName ) ) {

        LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DISABLE_DISK_WRITE_CACHE,
                 szInsertSz(driveName),
                 NULL,
                 0);

    } else {

        //
        // If the disk did not respond properly to our disable attempts,
        // log an error
        //

        if ( GetLastError() == ERROR_IO_DEVICE) {
            LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_FAILED_TO_DISABLE_DISK_WRITE_CACHE,
                     szInsertSz(driveName),
                     NULL,
                     0);
        }
    }

    return;

} // DsaDetectDiskWriteCache


void
DBSetRequiredDatabaseSystemParameters (JET_INSTANCE *jInstance)
{
    ULONG ulPageSize = JET_PAGE_SIZE;               // jet page size
    const ULONG ulLogFileSize = JET_LOG_FILE_SIZE;  // Never, ever, change this.
    ULONG ulMaxTables;
    char  szSystemDBPath[MAX_PATH] = "";
    char  szTempDBPath[MAX_PATH] = "";
    char  szRecovery[MAX_PATH] = "";
    JET_SESID sessid = (JET_SESID) 0;
    JET_UNICODEINDEX      unicodeIndexData;


    //
    // Initialize Drive mapping to handle drive name changes
    //

    DBInitializeDriveMapping(DriveMappings);


    // Set the default info for unicode indices

    memset(&unicodeIndexData, 0, sizeof(unicodeIndexData));
    unicodeIndexData.lcid = DS_DEFAULT_LOCALE;
    unicodeIndexData.dwMapFlags = (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                                   LCMAP_SORTKEY);
    JetSetSystemParameter(
            jInstance,
            sessid,
            JET_paramUnicodeIndexDefault,
            (ULONG_PTR)&unicodeIndexData,
            NULL);


    // Ask for 8K pages.

    JetSetSystemParameter(
                    jInstance,
                    sessid,
                    JET_paramDatabasePageSize,
                    ulPageSize,
                    NULL);

    // Indicate that Jet may nuke old, incompatible log files
    // if and only if there was a clean shut down.

    JetSetSystemParameter(jInstance,
                          sessid,
                          JET_paramDeleteOldLogs,
                          1,
                          NULL);

    // Tell Jet that it's ok for it to check for (and later delete) indices
    // that have been corrupted by NT upgrades.
    JetSetSystemParameter(jInstance,
                          sessid,
                          JET_paramEnableIndexChecking,
                          TRUE,
                          NULL);


    //
    // Get relevant DSA registry parameters
    //

    // system DB path
    if (!GetConfigParam(
            JETSYSTEMPATH_KEY,
            szSystemDBPath,
            sizeof(szSystemDBPath)))
    {
        //
        // Handle the drive rename case
        //

        ValidateDsPath(JETSYSTEMPATH_KEY,
                       szSystemDBPath,
                       VALDSPATH_DIRECTORY,
                       NULL, NULL);

        JetSetSystemParameter(jInstance,
                sessid,
                JET_paramSystemPath,
                0,
                szSystemDBPath);
        /* setup the temp file path, which is
         * the working directory path + "\temp.edb"
         */
        strcpy(szTempDBPath, szSystemDBPath);
        strcat(szTempDBPath, "\\temp.edb");

        JetSetSystemParameter(jInstance,
                sessid,
                JET_paramTempPath,
                0,
                szTempDBPath);
    }
    else
    {
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_BASIC,
            DIRLOG_CANT_FIND_REG_PARM,
            szInsertSz(JETSYSTEMPATH_KEY),
            NULL,
            NULL);
    }


    // recovery
    if (!GetConfigParam(
            RECOVERY_KEY,
            szRecovery,
            sizeof(szRecovery)))
    {
        JetSetSystemParameter(jInstance,
                sessid,
                JET_paramRecovery,
                0,
                szRecovery);
    }
    else
    {
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_VERBOSE,
            DIRLOG_CANT_FIND_REG_PARM,
            szInsertSz(RECOVERY_KEY),
            NULL,
            NULL);
    }


    //
    // In order to get to the root of some of the suspected Jet problems,
    // force Jet asserts to break into the debugger. Note, you must use
    // a debug version of ese.dll for Jet asserts.

    // BUG: It appears that Jet asserts do not work on Alpha.

    // how to die
    JetSetSystemParameter(jInstance,
        sessid,
        JET_paramAssertAction,
        // gfRunningInsideLsa ? JET_AssertStop: JET_AssertMsgBox,
        JET_AssertBreak,
        NULL);



    // event logging parameters
    JetSetSystemParameter(jInstance,
        sessid,
        JET_paramEventSource,
        0,
        SERVICE_NAME);




    //  log file size
    JetSetSystemParameter(jInstance,
                          sessid,
                          JET_paramLogFileSize,
                          ulLogFileSize,
                          NULL);


    // max tables - Currently no reason to expose this
    // In Jet600, JET_paramMaxOpenTableIndexes is removed. It is merged with
    // JET_paramMaxOpenTables. So if you used to set JET_paramMaxOpenIndexes
    // to be 2000 and and JET_paramMaxOpenTables to be 1000, then for new Jet,
    // you need to set JET_paramMaxOpenTables to 3000.

    // AndyGo 7/14/98: You need one for each open table index, plus one for
    // each open table with no indexes, plus one for each table with long
    // column data, plus a few more.
    
    // NOTE: the number of maxTables is calculated in scache.c
    // and stored in the registry setting, only if it exceeds the default 
    // number of 500

    if (GetConfigParam(
            DB_MAX_OPEN_TABLES,
            &ulMaxTables,
            sizeof(ulMaxTables)))
    {
        ulMaxTables = 500;

        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_VERBOSE,
            DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
            szInsertSz(DB_MAX_OPEN_TABLES),
            szInsertUL(ulMaxTables),
            NULL);
    }

    if (ulMaxTables < 500) {
        DPRINT1 (1, "Found MaxTables: %d. Too low. Using Default of 500.\n", ulMaxTables);
        ulMaxTables = 500;
    }

    JetSetSystemParameter(jInstance,
        sessid,
        JET_paramMaxOpenTables,
        ulMaxTables * 2,
        NULL);

    // circular logging used to be exposed through a normal reg key, but
    // now only through a heuristic.  That heuristic should have altered
    // the global, if needed.
    JetSetSystemParameter(jInstance,
                          sessid,
                          JET_paramCircularLog,
                          gulCircularLogging,
                          NULL);

} /* DBSetRequiredDatabaseSystemParameters */




INT
DBInitializeJetDatabase(
    IN JET_INSTANCE* JetInst,
    IN JET_SESID* SesId,
    IN JET_DBID* DbId,
    IN const char *szDBPath,
    IN BOOL bLogSeverity
    )
/*++

Routine Description:

    Does the JetInitialization. Sets the log file path, calls JetInit,
    JetBeginSession, AttachDatabase, and OpenDatabase.  In addition, it
    tries to read the old volume location in case a drive renaming/replacement
    was done.

Arguments:

    SesId - pointer to the variable to receive the session id from BeginSession
    DbId - pointer to the variable to receive the db id from OpenDatabase
    szDBPath - pointer to the path of the database.
               if NULL the path is retrieved from the regisrty.
               
    bLogSeverity - TRUE/FALSE whether to log unhandled errors. 
               DS calls with TRUE, utilities with FALSE.

Return Value:

    The jet error code

--*/
{
    char  szLogPath[MAX_PATH] = "";
    JET_SESID sessid = (JET_SESID) 0;
    JET_DBID    dbid;
    JET_ERR err;
    PVOID dwEA;
    ULONG ulErrorCode, dwException, dsid;
    BOOL fGotLogFile = TRUE;
    BOOL fLogSwitched = FALSE, fLogDriveChanged = FALSE;
    BOOL fDbSwitched = FALSE, fDbDriveChanged = FALSE;
    BOOL fRetry = FALSE;
    CHAR szBackupPath[MAX_PATH+1];

    //
    // Get the backup file path and see if it is ok.
    //

    if ( GetConfigParam(BACKUPPATH_KEY, szBackupPath, MAX_PATH) == ERROR_SUCCESS ) {

        //
        // Handle drive renames for the backup key. The backup dir usually does
        // not exist do just check for the root of the volume.
        //

        ValidateDsPath(BACKUPPATH_KEY,
                       szBackupPath,
                       VALDSPATH_ROOT_ONLY | VALDSPATH_DIRECTORY,
                       NULL, NULL);
    }

    //
    // Set The LogFile path
    //

    if ( GetConfigParam(
            LOGPATH_KEY,
            szLogPath,
            sizeof(szLogPath)) != ERROR_SUCCESS ) {

        // indicate that we did not get a path from the registry so we don't retry
        fGotLogFile = FALSE;
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_BASIC,
            DIRLOG_CANT_FIND_REG_PARM,
            szInsertSz(LOGPATH_KEY),
            NULL,
            NULL);
        goto open_jet;
    }

    //
    // Handle drive renames. This does not handle the case where
    // it gets set to the wrong directory.  This depends whether
    // jet was shutdown cleanly or not. If not, then jet needs those
    // log files to start up.
    //

    ValidateDsPath(LOGPATH_KEY,
                   szLogPath,
                   VALDSPATH_DIRECTORY,
                   &fLogSwitched, &fLogDriveChanged);

    //
    // Disable write caching to avoid jet corruption
    //

    DsaDetectAndDisableDiskWriteCache(szLogPath);

    JetSetSystemParameter(JetInst,
            sessid,
            JET_paramLogFilePath,
            0,
            szLogPath);

open_jet:

    /* Open JET session. */

    __try {
        err = JetInit(JetInst);
    }
    __except (GetExceptionData(GetExceptionInformation(), &dwException,
                               &dwEA, &ulErrorCode, &dsid)) {

        CHAR szScratch[24];
        _ultoa((FILENO << 16) | __LINE__, szScratch, 16);
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_JET_FAULTED,
                 szInsertHex(dwException),
                 szInsertPtr(dwEA),
                 szInsertUL(ulErrorCode));

        err = 1;
    }

    if (err != JET_errSuccess) {
        if (bLogSeverity) {
            LogUnhandledError(err);
        }
        DPRINT1(0, "JetInit error: %d\n", err);
        goto exit;
    }

    /* If we fail after here, our caller should go through full shutdown
    /* so JetTerm will be called to release any file locks               */
    gfNeedJetShutdown = TRUE;

    DPRINT(5, "JetInit complete\n");

    if ((err = JetBeginSession(*JetInst, &sessid, szUser, szPassword))
        != JET_errSuccess) {
        if (bLogSeverity) {
            LogUnhandledError(err);
        }
        DPRINT1(0, "JetBeginSession error: %d\n", err);
        goto exit;
    }

    DPRINT(5,"JetBeginSession complete\n");

    if ( !fRetry ) {

        if ( szDBPath != NULL ) {
            strncpy (szJetFilePath, szDBPath, MAX_PATH);
        }
        else if (dbGetFilePath(szJetFilePath, MAX_PATH)) {
            LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CONFIG_PARAM_MISSING,
                     szInsertSz(FILEPATH_KEY),
                     NULL,
                     NULL);
            return !0;
        }

        //
        // Make sure the database is valid
        //

        ValidateDsPath(FILEPATH_KEY,
                       szJetFilePath,
                       0,
                       &fDbSwitched,
                       &fDbDriveChanged);

        //
        // Disable write caching to avoid jet corruption
        //

        DsaDetectAndDisableDiskWriteCache(szJetFilePath);
    }

    /* Attach the database */

    err = JetAttachDatabase(sessid,
                            szJetFilePath,
                            JET_bitDbDeleteCorruptIndexes);
    switch (err) {
        case 0:
            /* Uh, oh, our attach gave no error, which probably means that
             * we weren't previously attached, which means that we were
             * probably attached to some other file.  We will now try to
             * detach everything and reattach only the one file we want.
             */
            DPRINT(1, "JetAttachDatabase succeeded, retrying\n");
            err = JetDetachDatabase(sessid, NULL);
            if (err < 0) {
                if (bLogSeverity) {
                    LogUnhandledError(err);
                }
                goto exit;
            }

            err = JetAttachDatabase(sessid, szJetFilePath, 0);
            if (err < 0) {
                if (bLogSeverity) {
                    LogUnhandledError(err);
                }
                goto exit;
            }
            break;

        case JET_wrnCorruptIndexDeleted:
            /* Well, we must have upgraded NT since the last time we started
             * and we've lost some of our indices as a result.  As soon as
             * we have the database open again we need to start rebuilding
             * the indices, which we'll do in DBRecreateFixedIndices, below.
             * Other, non-vital indices will be recreated by the schema cache's
             * normal index management.
             */
             DPRINT(0,"Jet has detected and deleted potentially corrupt indices. The indices will be rebuilt\n");
            LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CORRUPT_INDICES_DELETED,
                     NULL,
                     NULL,
                     NULL);

            /* Jet has a bug such that the updated (with new version no.)
             * database header at this point is not flushed until (1) a
             * JetDetachDatabse is done, or (2) the database is shut down
             * cleanly. So if the dc crashes after we rebuild the indices,
             * the header info is stale and Jet will again delete the indices
             * on the next boot. To avoid this, force a header flush by
             * detaching and attaching again at this point.
             */
            err = JetDetachDatabase(sessid, szJetFilePath);
            DPRINT1(1,"JetDetachDatabase returned %d\n", err);
            if (err < 0) {
                if (bLogSeverity) {
                    LogUnhandledError(err);
                }
                goto exit;
            }

            err = JetAttachDatabase(sessid, szJetFilePath, 0);
            DPRINT1(1,"JetAttachDatabase returned %d\n", err);
            if (err < 0) {
                if (bLogSeverity) {
                    LogUnhandledError(err);
                }
                goto exit;
            }
            break;

        case JET_wrnDatabaseAttached:
            /* This is actually the success case */
            break;

        case JET_errFileNotFound:

            //
            // file not found!!! Nothing we can do at this point.
            // ValidatePath should have switched the path if it was possible.
            //

            if (bLogSeverity) {
                LogUnhandledError(err);
            }
            DPRINT1(0, "Ds database %s cannot be found\n",szJetFilePath);
            goto exit;

        case JET_errDatabaseInconsistent:

            //
            // We usually get this error if the log file path is not set to
            // the correct one and Jet tries to do a soft recovery.  We will
            // try to change the log path if 1) the drive letter has changed and
            // 2) we successfully got a path from the registry
            //

            if ( fGotLogFile && !fLogSwitched && fLogDriveChanged && !fRetry ) {

                //
                // uninitialize everything and try a different log file location
                //

                DPRINT2(0, "JetAttachDatabase failed with %d [log path %s].\n",
                        err,szLogPath);

                ValidateDsPath(LOGPATH_KEY,
                               szLogPath,
                               VALDSPATH_DIRECTORY | VALDSPATH_USE_ALTERNATE,
                               &fLogSwitched,
                               &fLogDriveChanged);

                //
                // if log file not switched, bail.
                //

                if ( fLogSwitched ) {

                    gfNeedJetShutdown = FALSE;
                    JetEndSession(sessid, JET_bitForceSessionClosed);
                    JetTerm(*JetInst);
                    sessid = 0;
                    fRetry = TRUE;

                    DPRINT1(0, "Retrying JetInit with logpath %s\n",szLogPath);
                    JetSetSystemParameter(JetInst,
                            sessid,
                            JET_paramLogFilePath,
                            0,
                            szLogPath);
                    goto open_jet;
                }
            }

            // fall through

        default:
            if (bLogSeverity) {
                LogUnhandledError(err);
            }
            DPRINT1(0, "JetAttachDatabase error: %d\n", err);
            /* The assert that this is a fatal error and not an assert
             * is here because we've been promised that there are only
             * two possible warnings (both handled above) from this call.
             */
            Assert(err < 0);
            goto exit;
    }

    //
    // add this session to the list of open sessions
    //

    DBAddSess(sessid, 0);

    /* Open database */

    if ((err = JetOpenDatabase(sessid, szJetFilePath, "", &dbid,
                               0)) != JET_errSuccess) {
        if (bLogSeverity) {
            LogUnhandledError(err);
        }
        DPRINT1(0, "JetOpenDatabase error: %d\n", err);
        goto exit;
    }
    DPRINT(5,"JetOpenDatabase complete\n");

    *DbId = dbid;
    *SesId = sessid;

    InterlockedIncrement(&gcOpenDatabases);
    DPRINT3(2,
            "DBInit - JetOpenDatabase. Session = %d. Dbid = %d.\n"
            "Open database count: %d\n",
            sessid, dbid,  gcOpenDatabases);

exit:

    //
    // Set the drive mapping reg key
    //

    DBRegSetDriveMapping( );
    return err;

} // DBInitializeJetDatabase
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\dscommon\dsexcept.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsexcept.c
//
//--------------------------------------------------------------------------

//
// dsexcept.c - contains routines for raising, filtering, and handling exception generated by
// the Directory service
//

#include <NTDSpch.h>
#pragma  hdrstop

#include <esent.h>
#include   "debug.h"         /* standard debugging header */
#define DEBSUB              "DSEXCEPT:" /* define the subsystem for debugging */
#include "ntdsa.h"
#include "scache.h"
#include "dbglobal.h"
#include "mdglobal.h"      /* MD global definition header */
#include "mdlocal.h"      /* MD global definition header */
#include "dsatools.h"       /*needed for output allocation */
#include <dsevent.h>      /* header Audit\Alert logging (includes lanman)*/
#include "mdcodes.h"       /* header for error codes */
#include "drserr.h"
#include "draerror.h"
#include <dsexcept.h>
#include <fileno.h>
#define  FILENO FILENO_DSEXCEPT

#if DBG

// This is static because it easier to get to from the debugger
// We have to save these records indside the filter function. I've
// tried saving the exception_pointer pointer and it didn't work.

CONTEXT			gContextRecord;
EXCEPTION_RECORD 	gExceptionRecord;

#endif

// The v2 stubs raise the exceptions 43210000+errcode and 43220000+errcode
// These exceptions are searched for by checking the top 3 nibbles
// in the filter function.

#define V2_EXCEPTION_MASK 0xfff00000
#define V2_EXCEPTION_GENERIC 0x43200000

// Error routine that raises exception
// exceptions are logged with an internal identifier. This identifier should
// be parsed as follows:
//
// bits  012345678901234567890123456789012
//       |  dir || file ||    line       |
// where :
//     dir is the directory the source file is in (defined in filno.h)
//     file is the file where the exception occurred
//     line is the line at which the exception occurred
//

void RaiseDsaExcept (DWORD dwException, ULONG ulErrorCode, ULONG_PTR ul2,
    DWORD dwId ,  ULONG ulSeverity)
{
    ULONG_PTR lpArguments[NUM_DSA_EXCEPT_ARGS];

    // Always report internal errors
    if ( (ulErrorCode == ERROR_DS_INTERNAL_FAILURE) ||
         (ulErrorCode == ERROR_DS_DRA_INTERNAL_ERROR) ||
         (ulErrorCode == ERROR_INTERNAL_ERROR) ||
         (ulErrorCode == ERROR_INTERNAL_DB_ERROR) ||
         (ulErrorCode == RPC_S_INTERNAL_ERROR) ) {
        ulSeverity = DS_EVENT_SEV_ALWAYS;
    }

    if (ulSeverity != DS_EVENT_SEV_NO_LOGGING) {
        LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                        ulSeverity,
		        DIRLOG_EXCEPTION,
		        szInsertHex(dwException),
		        szInsertInt(ulErrorCode),
		        szInsertPtr(ul2),
		        szInsertHex(dwId),
		        NULL,
		        NULL,
		        NULL,
		        NULL);
    }

    lpArguments[0] = ulErrorCode;
    lpArguments[1] = ul2;
    lpArguments[2] = dwId;

    RaiseException (dwException, 0, NUM_DSA_EXCEPT_ARGS, lpArguments);
}


// Error routine that raises exceptions for the DRA

void DraExcept (ULONG ulErrorCode, ULONG_PTR ul2, DWORD dwId,
                       ULONG ulSeverity)
{
    DWORD dwException =
	(ulErrorCode == DRAERR_OutOfMem) ? DSA_MEM_EXCEPTION : DRA_GEN_EXCEPTION;

    if (ulErrorCode == DRAERR_InternalError) {
        Assert(!"Replication internal error");
    }
    else if (!ulErrorCode) {
        Assert(!"DRA exception without proper error code");
        ulErrorCode = ERROR_DS_DRA_GENERIC;
    }

    RaiseDsaExcept(dwException, ulErrorCode, ul2, dwId, ulSeverity);
}


// This is the generic filter expression called directly by the DSA
// exception handlers and by the DRA filter expression.

DWORD
GetExceptionData(EXCEPTION_POINTERS* pExceptPtrs,
                 DWORD *pdwException,
                 PVOID * pExceptionAddress,
                 ULONG *pulErrorCode,
                 ULONG *pdsid)
{
    ULONG_PTR * pExceptInfo;
    ULONG ul2Unused;

#if DBG

// Save information for debugger. Have to save here, can't just save pointer.

    memcpy (&gExceptionRecord, pExceptPtrs->ExceptionRecord,
                                        sizeof(EXCEPTION_RECORD));
    memcpy (&gContextRecord, pExceptPtrs->ContextRecord,
                                        sizeof (CONTEXT));
#endif

    /* Get the address the exception was caused at. */
    *pExceptionAddress = pExceptPtrs->ExceptionRecord->ExceptionAddress;


    switch (*pdwException = pExceptPtrs->ExceptionRecord->ExceptionCode) {
      case DSA_EXCEPTION:
      case DSA_BAD_ARG_EXCEPTION:
      case DRA_GEN_EXCEPTION:
      case DSA_DB_EXCEPTION:
      case DSA_CRYPTO_EXCEPTION:
	pExceptInfo = pExceptPtrs->ExceptionRecord->ExceptionInformation;
	*pulErrorCode = (ULONG)pExceptInfo[0];
        ul2Unused = (ULONG)pExceptInfo[1];
	*pdsid = (ULONG)pExceptInfo[2];
	break;

      case STATUS_NO_MEMORY:
      case DSA_MEM_EXCEPTION:
	break;

      default:
	*pulErrorCode = 0;
	ul2Unused = 0;
	*pdsid = 0;
	break;
    }

    return DoHandleMostExceptions(pExceptPtrs, *pdwException, *pdsid);
}


// This is the generic filter expression for the top level DRA
// exception handlers.

DWORD GetDraException (EXCEPTION_POINTERS* pExceptPtrs, ULONG *pret)
{
    DWORD dwException;
    ULONG ulErrorCode;
    ULONG dsid;
    DWORD dwStatus;
    PVOID dwEA;

    dwStatus = GetExceptionData(pExceptPtrs, &dwException, &dwEA,
				&ulErrorCode, &dsid);

    switch (dwException) {

    case STATUS_NO_MEMORY:
    case DSA_MEM_EXCEPTION:
	LogEvent(DS_EVENT_CAT_REPLICATION,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_DRA_OUT_OF_MEMORY,
		NULL,
		NULL,
		NULL);
        *pret = DRAERR_OutOfMem;
        break;

    case DRA_GEN_EXCEPTION:
        Assert(ulErrorCode && "Missing error code in exception");
        *pret = ulErrorCode;
        break;

    case DSA_DB_EXCEPTION:
        Assert(ulErrorCode && "Missing error code in exception");
        switch (ulErrorCode) {

        case JET_errKeyDuplicate:
        case JET_errWriteConflict:
            *pret = DRAERR_Busy;
            break;

        case JET_errLogDiskFull:
        case JET_errDiskFull:
            *pret = ERROR_DISK_FULL;
            break;

        case JET_errVersionStoreOutOfMemory:
            *pret = ERROR_DS_OUT_OF_VERSION_STORE;
            break;

        case JET_errRecordTooBig:
            *pret = ERROR_DS_MAX_OBJ_SIZE_EXCEEDED;
            break;

        default:
            *pret = DRAERR_DBError;
            break;
        }
        break;

    case DSA_CRYPTO_EXCEPTION:
        Assert(ulErrorCode && "Missing error code in exception");
        Assert(!"crypto exception -- call Murli, not Will & Jeff");
        *pret = ulErrorCode;
        break;

    default:

        *pret = DRAERR_InternalError;
        Assert (!"Encountered unexpected DRA exception");
        break;
    }

    return dwStatus;
}


DWORD
DoHandleMostExceptions(EXCEPTION_POINTERS* pExceptPtrs,
                       DWORD dwException,
                       ULONG ulInternalId)
{
    switch (dwException) {
      case EXCEPTION_ACCESS_VIOLATION:	        // these exceptions are
      case EXCEPTION_BREAKPOINT:                // not handeled
      case EXCEPTION_DATATYPE_MISALIGNMENT:     // (added to trap JET problems)
      case STATUS_POSSIBLE_DEADLOCK:
      case EXCEPTION_SINGLE_STEP:
      case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
      case EXCEPTION_FLT_DENORMAL_OPERAND:
      case EXCEPTION_FLT_DIVIDE_BY_ZERO:
      case EXCEPTION_FLT_INEXACT_RESULT:
      case EXCEPTION_FLT_INVALID_OPERATION:
      case EXCEPTION_FLT_OVERFLOW:
      case EXCEPTION_FLT_STACK_CHECK:
      case EXCEPTION_FLT_UNDERFLOW:
      case EXCEPTION_INT_DIVIDE_BY_ZERO:
      case EXCEPTION_INT_OVERFLOW:
      case EXCEPTION_PRIV_INSTRUCTION:
      case EXCEPTION_IN_PAGE_ERROR:
      case EXCEPTION_ILLEGAL_INSTRUCTION:
      case EXCEPTION_NONCONTINUABLE_EXCEPTION:
      case EXCEPTION_INVALID_DISPOSITION:
      case EXCEPTION_GUARD_PAGE:
      case EXCEPTION_INVALID_HANDLE:
        LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_EXCEPTION,
                  szInsertHex(dwException),
                  szInsertPtr(pExceptPtrs->ExceptionRecord->ExceptionAddress),
                  szInsertInt(0),
                  szInsertHex(ulInternalId),
                  NULL,
                  NULL,
                  NULL,
                  NULL);
        // fall through...

      case EXCEPTION_STACK_OVERFLOW: // Don't try to log when we have no stack
        return EXCEPTION_CONTINUE_SEARCH;

      default:					// others, however, are
        return EXCEPTION_EXECUTE_HANDLER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\dscommon\time.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    time.c

ABSTRACT:

DETAILS:

CREATED:

    01/13/97   Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <drs.h>

#include <fileno.h>
#define  FILENO FILENO_TASKQ_TIME


DSTIME
GetSecondsSince1601( void )
{
    FILETIME   fileTime;
    DSTIME     dsTime = 0, tempTime = 0;

    GetSystemTimeAsFileTime( &fileTime );
    dsTime = fileTime.dwLowDateTime;
    tempTime = fileTime.dwHighDateTime;
    dsTime |= (tempTime << 32);

    // Ok. now we have the no. of 100 ns intervals since 1601
    // in dsTime. Convert to seconds and return

    return(dsTime/(10*1000*1000L));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\dscommon\dsutil.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dsutil.c
//
//  Contents:  Common Utility Routines
//
//  Functions:
//
//----------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsa.h>
#include <drs.h>
#include <issperr.h>        // Security package errors
#include <crt\limits.h>     // ULONG_MAX
#include <debug.h>          // Assert

#define TIME_TICK_HALF_RANGE (ULONG_MAX >> 2)

LARGE_INTEGER
atoli
(
    char* Num
)
{
    LONG base=10;
    int  sign=1;

    LARGE_INTEGER ret;
    char* next=Num;

    ret.QuadPart = 0;

    switch (*next)
    {
        case '-': sign = -sign; next++; break;
        case '+':               next++; break;
        case '\\':
        {
            next++;
            switch (toupper(*next))
            {
                case 'X': base=16; next++;break;
                case '0': base= 8; next++;break;
            }
        }
        break;
    }

    for (;*next!='\0';next++)
    {
        int nextnum = 0;

        if (*next>='0' && *next<='9')
        {
             nextnum= *next - '0';
        }
        else if ( toupper(*next)>='A' && toupper(*next)<='F' )
        {
             nextnum= 10 + toupper(*next) - 'A';
        }


        if ( nextnum < base)
        {
            ret = RtlLargeIntegerAdd
            (
                RtlConvertLongToLargeInteger(nextnum),
                RtlExtendedIntegerMultiply(ret, base)
            );
        }
        else
        {
            break;
        }
    }

    return RtlExtendedIntegerMultiply(ret, sign);
}


char *litoa
(
    LARGE_INTEGER value,
    char *string,
    int radix
)
{

    RtlLargeIntegerToChar(&value,radix,64,string);

    return string;
}



UUID gNullUuid = {0,0,0,{0,0,0,0,0,0,0,0}};

// Return TRUE if the ptr to the UUID is NULL, or the uuid is all zeroes

BOOL fNullUuid (const UUID *pUuid)
{
    if (!pUuid) {
        return TRUE;
    }

    if (memcmp (pUuid, &gNullUuid, sizeof (UUID))) {
        return FALSE;
    }
    return TRUE;
}

// This function converts a UUID to a hex string. The UUID is actually a
// structure with a ULONG 2 USHORTS and a 8 byte array, but for logging
// we construct the string as if it were a 16 byte array. This is so that
// it matches the view from the DIT browser. We special case the case where
// the pUUID is NULL.
// If Uuid Cahcing is enabled, we put the server name on the end if we can
// find it.
// Returns a ptr to the string

UCHAR * UuidToStr(UUID* pUuid, UCHAR *pOutUuid)
{
    int i;
    unsigned char * pchar;

    if (!fNullUuid (pUuid)) {
        pchar = (char*) pUuid;

        for (i=0;i < sizeof(UUID);i++) {
             sprintf (&(pOutUuid[i*2]), "%.2x", (*(pchar++)));
        }
#ifdef CACHE_UUID
        if (pchar = FindUuid (pUuid)) {
            strcat (pOutUuid, " ");
            strcat (pOutUuid, pchar);
        }
#endif
    } else {
        memset (pOutUuid, '0', sizeof(UUID)*2);
        pOutUuid[sizeof(UUID)*2] = 0;
    }
    return pOutUuid;
}

VOID
SidToStr(
    PUCHAR  pSid,
    DWORD   SidLen,
    PUCHAR  pOutSid
    )
/*++

Routine Description:

    Format a SID as a hex string

Arguments:

    pSid - pointer to Sid
    SidLen - Length of the Sid
    pOutSid - Output buffer to contain data.  Must be at least SidLen*2 +1

Return Value:

    None.

--*/
{
    int i;
    unsigned char * pchar;
    for (i=0;i < (INT)SidLen;i++) {
        sprintf(&(pOutSid[i*2]), "%.2x", pSid[i]);
    }
    pOutSid[SidLen*2] = '\0';
    return;
} // SidToStr

LPSTR
DsUuidToStructuredString(
    UUID * pUuid,
    LPSTR pszUuidBuffer
    )

/*++

Routine Description:

Format a UUID as a string with separated subfields

Arguments:

    pUuid - pointer to uuid
    pszUuidBuffer - Storage to hold the ascii representation. Should be atleast
                    40 characters.

Return Value:

    LPSTR - Returned pszUuidBuffer or NULL for error

--*/

{
    sprintf( pszUuidBuffer,
             "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
             pUuid->Data1,
             pUuid->Data2,
             pUuid->Data3,
             pUuid->Data4[0],
             pUuid->Data4[1],
             pUuid->Data4[2],
             pUuid->Data4[3],
             pUuid->Data4[4],
             pUuid->Data4[5],
             pUuid->Data4[6],
             pUuid->Data4[7] );

    return pszUuidBuffer;

} /* DsUuidToStructuredString */

LPWSTR
DsUuidToStructuredStringW(
    UUID * pUuid,
    LPWSTR pszUuidBuffer
    )

/*++

Routine Description:

Format a UUID as a string with separated subfields

Arguments:

    pUuid - pointer to uuid
    pszUuidBuffer - Storage to hold the wide-char representation. 
                    Should be atleast 40 characters.

Return Value:

    LPWSTR - Returned pszUuidBuffer or NULL for error

--*/

{
    swprintf( pszUuidBuffer,
             L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
             pUuid->Data1,
             pUuid->Data2,
             pUuid->Data3,
             pUuid->Data4[0],
             pUuid->Data4[1],
             pUuid->Data4[2],
             pUuid->Data4[3],
             pUuid->Data4[4],
             pUuid->Data4[5],
             pUuid->Data4[6],
             pUuid->Data4[7] );

    return pszUuidBuffer;

} /* DsUuidToStructuredString */

void
DSTimeToUtcSystemTime(
    IN  DSTIME          dstime,
    OUT SYSTEMTIME *    psystime
    )
/*++

Routine Description:

    Converts DSTIME to UTC SYSTEMTIME.
    
Arguments:

    dstime (IN) - DSTIME to convert.
    
    psystime (OUT) - On return, holds the corresponding UTC SYSTEMTIME.

Return Values:

    None.

--*/
{
    ULONGLONG   ull;
    FILETIME    filetime;
    BOOL        ok;
    
    Assert(sizeof(DSTIME) == sizeof(ULONGLONG));

    // Convert DSTIME to FILETIME.
    ull = (LONGLONG) dstime * 10*1000*1000L;
    filetime.dwLowDateTime  = (DWORD) (ull & 0xFFFFFFFF);
    filetime.dwHighDateTime = (DWORD) (ull >> 32);

    // Convert FILETIME to SYSTEMTIME,
    ok = FileTimeToSystemTime(&filetime, psystime);
    Assert(ok);
}

void
FileTimeToDSTime(
    IN  FILETIME        Filetime,
    OUT DSTIME *        pDstime
    )
/*++

Routine Description:

    Converts DSTIME to UTC SYSTEMTIME.
    
Arguments:

    dstime (IN) - DSTIME to convert.
    
    psystime (OUT) - On return, holds the corresponding FILETIME.

Return Values:

    None.

--*/
{
    ULONGLONG   ull;
    
    Assert(sizeof(DSTIME) == sizeof(ULONGLONG));

    // Convert FILETIME To DSTIME.
    ull = Filetime.dwHighDateTime;
    ull <<= 32;
    ull |= Filetime.dwLowDateTime;

    *pDstime = ull / (10 * 1000 * 1000);
}
void
DSTimeToFileTime(
    IN  DSTIME          dstime,
    OUT FILETIME *      pFiletime
    )
/*++

Routine Description:

    Converts DSTIME to FILETIME
    
Arguments:

    dstime (IN) - DSTIME to convert.
    
    pFiletime (OUT) - On return, holds the corresponding FILETIME.

Return Values:

    None.

--*/
{
    ULONGLONG   ull;
    
    Assert(sizeof(DSTIME) == sizeof(ULONGLONG));

    // Convert DSTIME to FILETIME.
    ull = (LONGLONG) dstime * 10*1000*1000L;
    pFiletime->dwLowDateTime  = (DWORD) (ull & 0xFFFFFFFF);
    pFiletime->dwHighDateTime = (DWORD) (ull >> 32);
}


void
DSTimeToLocalSystemTime(
    IN  DSTIME          dstime,
    OUT SYSTEMTIME *    psystime
    )
/*++

Routine Description:

    Converts DSTIME to local SYSTEMTIME.
    
Arguments:

    dstime (IN) - DSTIME to convert.
    
    psystime (OUT) - On return, holds the corresponding local SYSTEMTIME.

Return Values:

    None.

--*/
{
    SYSTEMTIME  utcsystime;
    BOOL        ok;
    
    DSTimeToUtcSystemTime(dstime, &utcsystime);

    // For those cases where the local time call fails (usually because dstime
    // was something like 3)
    *psystime = utcsystime;

    ok = SystemTimeToTzSpecificLocalTime(NULL, &utcsystime, psystime);
    Assert(ok || dstime < 20);
}


LPSTR
DSTimeToDisplayString(
    IN  DSTIME  dstime,
    OUT LPSTR   pszTime
    )
/*++

Routine Description:

    Converts DSTIME to display string; e.g., "1998-04-19 12:29.53" for April
    19, 1998 at 12:29 pm and 53 seconds.
    
Arguments:

    dstime (IN) - DSTIME to convert.
    
    pszTime (OUT) - On return, holds the corresponding time display string.
        This buffer should be allocated to hold at least SZDSTIME_LEN
        characters.

Return Values:

    The pszTime input parameter.

--*/
{
    if (0 == dstime) {
        strcpy(pszTime, "(never)");
    }
    else {
        SYSTEMTIME systime;

        DSTimeToLocalSystemTime(dstime, &systime);

        sprintf(pszTime,
                "%04d-%02d-%02d %02d:%02d:%02d",
                systime.wYear % 10000,
                systime.wMonth,
                systime.wDay,
                systime.wHour,
                systime.wMinute,
                systime.wSecond);
    }
    
    return pszTime;
}


DWORD
MapRpcExtendedHResultToWin32(
    HRESULT hrCode
    )
/*++

Routine Description:

    This routine attempts to map HRESULT errors returned from
    I_RpcGetExtendedError in win32 values.

    The SEC_E_XXX errors get generated in the following
    File: security\lsa\security\dll\support.cxx
    Function: SspNtStatusToSecStatus

Arguments:

    hrCode - HResult code to be mapped

Return Value:

    DWORD - Corresponding Win32 value

--*/
{
    DWORD status;

    switch (hrCode) {

        // Errors with straight-forward translations

    case SEC_E_INSUFFICIENT_MEMORY:
        status = ERROR_NOT_ENOUGH_MEMORY;
        break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        status = ERROR_BAD_USERNAME;
        break;
    case SEC_E_INVALID_TOKEN:
        status = ERROR_INVALID_PASSWORD;
        break;
    case SEC_E_NOT_OWNER:
        status = ERROR_PRIVILEGE_NOT_HELD;
        break;
    case SEC_E_INVALID_HANDLE:
        status = ERROR_INVALID_HANDLE;
        break;
    case SEC_E_BUFFER_TOO_SMALL:
        status = ERROR_INSUFFICIENT_BUFFER;
        break;
    case SEC_E_UNSUPPORTED_FUNCTION:
        status = ERROR_NOT_SUPPORTED;
        break;
    case SEC_E_INTERNAL_ERROR:
        status = ERROR_INTERNAL_ERROR;
        break;

        // These are the important security specific codes

    case SEC_E_TIME_SKEW:
        status = ERROR_TIME_SKEW;
        break;

        //STATUS_LOGON_FAILURE:
        //STATUS_NO_SUCH_USER:
        //STATUS_ACCOUNT_DISABLED:
        //STATUS_ACCOUNT_RESTRICTION:
        //STATUS_ACCOUNT_LOCKED_OUT:
        //STATUS_WRONG_PASSWORD:
        //STATUS_ACCOUNT_EXPIRED:
        //STATUS_PASSWORD_EXPIRED:
        //STATUS_PASSWORD_MUST_CHANGE:
    case SEC_E_LOGON_DENIED:
        status = ERROR_LOGON_FAILURE;
        break;

        //STATUS_OBJECT_NAME_NOT_FOUND:
        //STATUS_NO_TRUST_SAM_ACCOUNT:
        //SPN not found
        // talking to wrong system
        // mutual authentication failure
    case SEC_E_TARGET_UNKNOWN:
        status = ERROR_WRONG_TARGET_NAME;
        break;

        //STATUS_NETLOGON_NOT_STARTED:
        //STATUS_DOMAIN_CONTROLLER_NOT_FOUND:
        //STATUS_NO_LOGON_SERVERS:
        //STATUS_NO_SUCH_DOMAIN:
        //STATUS_BAD_NETWORK_PATH:
        //STATUS_TRUST_FAILURE:
        //STATUS_TRUSTED_RELATIONSHIP_FAILURE:
    case SEC_E_NO_AUTHENTICATING_AUTHORITY:
        status = ERROR_DOMAIN_CONTROLLER_NOT_FOUND;
        break;

    default:
        // We don't recognize the code: just return it
        status = hrCode;
        break;
    }

    return status;

} /* MapRpcExtendedHResultToWin32 */


DWORD
AdvanceTickTime(
    DWORD BaseTick,
    DWORD Delay
    )

/*++

Routine Description:

Add an offset to a base time expressed in ticks.  The offset must fall within
half of the range of a tick count.

Jeffparh wrote:
By the same argument, is it possible that AdvanceTickTime(BaseTick, Delay)
should just be BaseTick + Delay?  That's what's returned if the tick count
won't wrap before then.  If it will wrap, it returns:
Delay - timeToWrap
= Delay - (ULONG_MAX - BaseTick)
= Delay + BaseTick - ULONG_MAX
= BaseTick + Delay + 1 (and the +1 seems wrong)

[wlees] I think we do it this way to avoid a hardware overflow, which should
be harmless

Arguments:

    BaseTick - Starting time
    Delay - Offset to add, must be within half of range

Return Value:

    DWORD - Resulting tick time, maybe wrapped

--*/

{
    DWORD timeToWrap, when;

    timeToWrap = ULONG_MAX - BaseTick;

    Assert( Delay <= TIME_TICK_HALF_RANGE );

    if ( timeToWrap < Delay ) {
        when = Delay - timeToWrap;
    } else {
        when = BaseTick + Delay;
    }

    return when;
} /* AdvanceTickTime */


DWORD
CalculateFutureTickTime(
    IN DWORD Delay
    )

/*++

Routine Description:

Calculate a future time by adding a delay in milliseconds to the
current tick count.  Handles wrap around.

Taken from Davestr's code in rpccancel.c

Tick counts are in milliseconds.

Arguments:

    Delay - time in milliseconds to delay, must be less than HALF RANGE

Return Value:

    DWORD - future time

--*/

{
    return AdvanceTickTime( GetTickCount(), Delay );

} /* CalculateFutureTickTime */


DWORD
DifferenceTickTime(
    DWORD GreaterTick,
    DWORD LesserTick
    )

/*++

Routine Description:

Return the difference between the two tick times.

Note, this is not a general purpose subtraction routine.  It assumes that
the first time is greater than the second time.  Greater as determined by the
CompareTickTime routine, not strictly by numerical ordering because of wrap
around considerations.

Jeffparh wrote:
DifferenceTickTime() is unnecessary.  If you know Tick1 is "later" than Tick2,
and you assume that ULONG_MAX+1 ticks have not transpired since Tick1, then the
tick difference is *always* Tick2 - Tick1, regardless of signs, etc.

Arguments:

    Tick1 - Greater tick time
    Tick2 - Lesser tick time to be subtracted

Return Value:

    DWORD - difference time in milliseconds

--*/

{
    DWORD diff;

    if (GreaterTick == LesserTick) {
        return 0;
    }

    if (GreaterTick > LesserTick) {
        diff = GreaterTick - LesserTick;
    } else {
        diff = ULONG_MAX - LesserTick + GreaterTick;
    }

    Assert( diff < TIME_TICK_HALF_RANGE );

    return diff;
} /* DifferenceTickTime */



int
CompareTickTime(
    DWORD Tick1,
    DWORD Tick2
    )

/*++

Routine Description:

Compare two tick counts. Return <, = or >.  Tick counts can wrap.

It is implicit in this algorithm that this test will be evaluated atleast
every HALF_RANGE, so that the test has a chance to trigger accurately.

Davestr wrote in the original code, rpccancel.c, by way of explanation:

We handle wrap of GetTickCount based on the fact that we
disallow delays of more than 1/2 the GetTickCount wrap
period.  So if timeNow is less than 1/2 the wrap period
later than whenToCancel, cancellation should happen.

Arguments:

    Time1 - 
    Time2 - 

Return Value:

    int - -1 for less t1 < t2, 0 for t1 == t2, +1 for t1 > t2

--*/

{
    if (Tick1 == Tick2) {
        return 0;
    }

    if ( ((Tick1 > Tick2) && ((Tick1 - Tick2) < TIME_TICK_HALF_RANGE)) ||
         ((Tick1 < Tick2) && (((ULONG_MAX - Tick2) + Tick1) < TIME_TICK_HALF_RANGE)) ) {
        return 1;
    }

    return -1;

} /* CompareTickTime */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\dscommon\ntutils.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       nttools.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module contains various tools from NT land. Made a separate file because of the
    use of various nt headers.

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <nt.h>
#include <ntdddisk.h>

BOOL
DisableDiskWriteCache(
    IN PCHAR DriveName
    )
/*++

Description:

    Determines if the disk has enabled write caching and disable it.
    
Arguments:

    DriveName - name of the drive.

Return value:

    TRUE if write cache was enabled and then disabled, FALSE otherwise.

--*/
{
    HANDLE              hDisk = INVALID_HANDLE_VALUE;
    DISK_CACHE_INFORMATION cacheInfo;
    UCHAR               driveBuffer[20];
    DWORD               len;
    DWORD               err = ERROR_SUCCESS;
    BOOL                fCacheWasEnabled = FALSE;
    BOOL                fCacheDisabled = FALSE;

    //
    // Open handle to the PhysicalDrive
    //

    strcpy(driveBuffer,"\\\\.\\");
    strcat(driveBuffer,DriveName);

    hDisk = CreateFile(driveBuffer,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hDisk == INVALID_HANDLE_VALUE) {
        goto exit;
    }

    //
    // Get cache info - IOCTL_DISK_GET_CACHE_INFORMATION
    //

    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_GET_CACHE_INFORMATION,
                         NULL,
                         0,
                         &cacheInfo,
                         sizeof(DISK_CACHE_INFORMATION),
                         &len,
                         NULL))   {

        KdPrint(("DeviceIoControl[GET] on %s failed with %d\n",
                 driveBuffer,GetLastError()));
        goto exit;
    }

    //
    // If caching is turned on, turn it off.
    //

    fCacheWasEnabled = cacheInfo.WriteCacheEnabled;

    if ( !fCacheWasEnabled ) {
        goto exit;
    }

    cacheInfo.WriteCacheEnabled = FALSE;

    //
    // Set cache info - IOCTL_DISK_SET_CACHE_INFORMATION
    //

    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_SET_CACHE_INFORMATION,
                         &cacheInfo,
                         sizeof(DISK_CACHE_INFORMATION),
                         NULL,
                         0,
                         &len,
                         NULL))   {

        KdPrint(("DevIoControl[SET] on %s failed with %d\n",
                 driveBuffer,GetLastError()));

        err = ERROR_IO_DEVICE;
        goto exit;
    }

    //
    // See if it really got turned off!
    //

    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_GET_CACHE_INFORMATION,
                         NULL,
                         0,
                         &cacheInfo,
                         sizeof(DISK_CACHE_INFORMATION),
                         &len,
                         NULL))   {

        KdPrint(("DeviceIoControl[VERIFY] on %s failed with %d\n",
                 driveBuffer,GetLastError()));
        err = ERROR_IO_DEVICE;
        goto exit;
    }

    fCacheDisabled = (BOOL)(!cacheInfo.WriteCacheEnabled);
    if ( !fCacheDisabled ) {
        KdPrint(("DeviceIoControl failed to turn off disk write caching on %s\n",
                 driveBuffer));
        err = ERROR_IO_DEVICE;
        goto exit;
    }

exit:
    if ( hDisk != INVALID_HANDLE_VALUE ) {
        CloseHandle(hDisk );
    }

    //
    // return true if write caching was enabled and then disabled.
    //

    SetLastError(err);
    return (fCacheWasEnabled && fCacheDisabled);

} // DisableDiskWriteCache
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\dscommon\filelog.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tlog.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    File logging routines. A lot of them copied unshamefully from
    netlogon.

--*/

#include <NTDSpch.h>
#include "dststlog.h"

#define MAX_PRINTF_LEN  (16 * 1024)

HANDLE           hLogFile = INVALID_HANDLE_VALUE;
HANDLE           hChange = INVALID_HANDLE_VALUE;
HANDLE           hWait = INVALID_HANDLE_VALUE;

//
// tags used by our debug logs
// format is [PN=<process name>][CN=<computername>]
//

CHAR CnPnTag[MAX_COMPUTERNAME_LENGTH+1+64+MAX_PATH+1] = {0};
CHAR Windir[MAX_PATH+1] = {0};
CHAR ProcessName[MAX_PATH+1] = {0};
CHAR LogFileName[1024] = {0};

BOOL
GetProcName(
    IN PCHAR    ProcessName,
    IN DWORD    TaskId
    );

BOOL
GetLogFileName(
    IN PCHAR Name,
    IN PCHAR Prefix,
    IN PCHAR Middle,
    IN BOOL  fCheckDSLOGMarker
    );

VOID
DsCloseLogFile(
    VOID
    );

VOID
DsPrintRoutineV(
    IN DWORD Flags,
    IN LPSTR Format,
    va_list arglist
    )
// Must be called with DsGlobalLogFileCritSect locked

{
    static LPSTR DsGlobalLogFileOutputBuffer = NULL;
    ULONG length;
    DWORD BytesWritten;
    static BeginningOfLine = TRUE;
    static LineCount = 0;
    static TruncateLogFileInProgress = FALSE;
    static LogProblemWarned = FALSE;

    if ( hLogFile == INVALID_HANDLE_VALUE ) {
        return;
    }

    //
    // Allocate a buffer to build the line in.
    //  If there isn't already one.
    //

    length = 0;

    if ( DsGlobalLogFileOutputBuffer == NULL ) {
        DsGlobalLogFileOutputBuffer = LocalAlloc( 0, MAX_PRINTF_LEN );

        if ( DsGlobalLogFileOutputBuffer == NULL ) {
            return;
        }
    }

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // Never print empty lines.
        //

        if ( Format[0] == '\n' && Format[1] == '\0' ) {
            return;
        }

        //
        // If we're writing to the debug terminal,
        //  indicate this is a Netlogon message.
        //

        //
        // Put the timestamp at the begining of the line.
        //

        if ( (Flags & DSLOG_FLAG_NOTIME) == 0) {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &DsGlobalLogFileOutputBuffer[length],
                                  "%02u/%02u/%04u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wYear,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        } else {
            CopyMemory(&DsGlobalLogFileOutputBuffer[length], 
                       "               ", 
                       15);
            length += 15;
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    length += (ULONG) vsprintf(&DsGlobalLogFileOutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && DsGlobalLogFileOutputBuffer[length-1] == '\n' );
    if ( BeginningOfLine ) {
        DsGlobalLogFileOutputBuffer[length-1] = '\r';
        DsGlobalLogFileOutputBuffer[length] = '\n';
        DsGlobalLogFileOutputBuffer[length+1] = '\0';
        length++;
    } 

    //
    // Do we need to add tags
    //

    if ( (Flags & DSLOG_FLAG_TAG_CNPN) != 0 ) {

        strcat(DsGlobalLogFileOutputBuffer, CnPnTag);
        length = strlen(DsGlobalLogFileOutputBuffer);
    }

    //
    // Write the debug info to the log file.
    //

    if ( !WriteFile( hLogFile,
                     DsGlobalLogFileOutputBuffer,
                     length,
                     &BytesWritten,
                     NULL ) ) {

        if ( !LogProblemWarned ) {
            DbgPrint( "[DSLOGS] Cannot write to log file error %ld\n", 
                             GetLastError() );
            LogProblemWarned = TRUE;
        }
    }

} // DsPrintRoutineV

BOOL
DsPrintLog(
    IN LPSTR    Format,
    ...
    )

{
    va_list arglist;

    //
    // Simply change arguments to va_list form and call DsPrintRoutineV
    //

    va_start(arglist, Format);

    DsPrintRoutineV( 0, Format, arglist );

    va_end(arglist);
    return TRUE;
} // DsPrintRoutine


VOID
NotifyCallback(
    PVOID Context,
    BOOLEAN fTimeout
    )
{    
    CHAR fileName[MAX_PATH+1];
    BOOL fDelayedDeletion = FALSE;

    strcpy(fileName,Windir);
    strcat(fileName,"\\");
    strcat(fileName, (PCHAR)Context);

    if ( !DeleteFile(fileName) ) {
        if ( GetLastError() == ERROR_SHARING_VIOLATION ) {
            fDelayedDeletion = TRUE;
            //KdPrint(("Failed to delete file %s. Err %d\n",fileName, GetLastError()));
        }
        goto exit;
    } else {
        //KdPrint(("Detected file %s. Rollover in progress\n",fileName));
    }

    //
    // we deleted the file name corresponding to our process. 
    // This is a signal for us to roll the logs over.
    //

    strcat(LogFileName,".0");
    CloseHandle(hLogFile);
    hLogFile = CreateFileA( LogFileName,
                            GENERIC_WRITE|GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

    if ( hLogFile == INVALID_HANDLE_VALUE ) {
        DsCloseLogFile();
    }

exit:
    FindNextChangeNotification(hChange);
    UnregisterWaitEx(hWait,NULL);
    hWait = RegisterWaitForSingleObjectEx(hChange,
                                        NotifyCallback,
                                        ProcessName,
                                        fDelayedDeletion? 10*1000 : INFINITE,
                                        WT_EXECUTEONLYONCE  );
    return;
} // NotifyCallback


BOOL
DsOpenLogFile(
    IN PCHAR FilePrefix,
    IN PCHAR MiddleName,
    IN BOOL fCheckDSLOGMarker
    )
{
    BOOL ret = TRUE;
    static BOOL haveFailed = FALSE;
    CHAR computerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD nCN = sizeof(computerName);

    //
    // Open the file.
    //

    if ( (hLogFile != INVALID_HANDLE_VALUE) || haveFailed ) {
        goto exit;
    }

    //
    // Get Name to open
    //

    if (!GetLogFileName(LogFileName,FilePrefix,MiddleName,fCheckDSLOGMarker)) {
        ret = FALSE;
        goto exit;
    }

    hLogFile = CreateFileA( LogFileName,
                            GENERIC_WRITE|GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

    if ( hLogFile == INVALID_HANDLE_VALUE ) {
        //KdPrint(("DSOpenLog: cannot open %s Error %d\n", LogFileName,GetLastError() ));
        ret=FALSE;
        haveFailed = TRUE;
        goto exit;
    } 

    //
    // Initialize CnPnTag
    //

    if ( GetProcName(ProcessName, GetCurrentProcessId()) &&
         GetComputerName(computerName, &nCN) ) {

        strcpy(CnPnTag, "[PN=");
        strcat(CnPnTag, ProcessName);
        strcat(CnPnTag, "][CN=");
        strcat(CnPnTag, computerName);
        strcat(CnPnTag, "]");

        //
        // Register a notification. If we see a file with the same name as
        // the process, we need to roll the log over
        //

        if ( fCheckDSLOGMarker ) {

            hChange = FindFirstChangeNotificationA(Windir,
                                                  FALSE,
                                                  FILE_NOTIFY_CHANGE_FILE_NAME);

            if ( hChange != INVALID_HANDLE_VALUE ) {

                hWait = RegisterWaitForSingleObjectEx(hChange,
                                                    NotifyCallback,
                                                    ProcessName,
                                                    INFINITE,
                                                    WT_EXECUTEONLYONCE );
            }
        }
    } else {
        strcpy(CnPnTag,"[PN=unknown][CN=unknown]");
    }

exit:

    return ret;

} // DsOpenFile



BOOL
GetProcName(
    IN PCHAR    ProcessName,
    IN DWORD    TaskId
    )

/*++

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses internal NT apis and data structures.  This
    api is MUCH faster that the non-internal version that uses the registry.

Arguments:

    dwNumTasks       - maximum number of tasks that the pTask array can hold

Return Value:

    Number of tasks placed into the pTask array.

--*/

{
    PSYSTEM_PROCESS_INFORMATION  ProcessInfo;
    NTSTATUS                     status;
    ANSI_STRING                  pname;
    PCHAR                        p;
    ULONG                        TotalOffset;
    BOOL    ret = FALSE;
    PCHAR   CommonLargeBuffer;
    DWORD   CommonLargeBufferSize = 8192;


retry:

    CommonLargeBuffer = VirtualAlloc (NULL,
                                      CommonLargeBufferSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE);
    if (CommonLargeBuffer == NULL) {
        return FALSE;
    }

    status = NtQuerySystemInformation(
                SystemProcessInformation,
                CommonLargeBuffer,
                CommonLargeBufferSize,
                NULL
                );

    if (status == STATUS_INFO_LENGTH_MISMATCH) {
        CommonLargeBufferSize += 8192;
        VirtualFree (CommonLargeBuffer, 0, MEM_RELEASE);
        CommonLargeBuffer = NULL;
        goto retry;
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) CommonLargeBuffer;
    TotalOffset = 0;
    while (TRUE) {
        DWORD dwProcessId;

        pname.Buffer = NULL;
        dwProcessId = (DWORD)(DWORD_PTR)ProcessInfo->UniqueProcessId;

        if ( dwProcessId == TaskId) {

            if ( ProcessInfo->ImageName.Buffer ) {
                status = RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
                if (!NT_SUCCESS(status)) {
                    VirtualFree (CommonLargeBuffer, 0, MEM_RELEASE);
                    return FALSE;
                }
                p = strrchr(pname.Buffer,'\\');
                if ( p ) {
                    p++;
                }
                else {
                    p = pname.Buffer;
                }
            }
            else {
                p = "System Process";
            }

            strcpy( ProcessName, p );
            p=strrchr(ProcessName,'.');
            if ( p!=NULL) {
                *p = '\0';
            }
            ret=TRUE;
            break;
        }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CommonLargeBuffer[TotalOffset];
    }

    VirtualFree (CommonLargeBuffer, 0, MEM_RELEASE);
    return ret;
}


BOOL
GetLogFileName(
    IN PCHAR Name,
    IN PCHAR Prefix,
    IN PCHAR MiddleName,
    IN BOOL  fCheckDSLOGMarker
    )
{
    CHAR FileName[MAX_PATH+1];
    DWORD err;
    DWORD i;
    DWORD   TaskId = GetCurrentProcessId();
    WIN32_FIND_DATA w32Data;
    HANDLE hFile;

    if ( GetWindowsDirectory(Windir,MAX_PATH+1) == 0 ) {
        strcpy(Windir, "C:\\");
    }

    strcat(Windir,"\\Debug");

    //
    // does the marker file exist? if not, don't log
    //

    if ( fCheckDSLOGMarker ) {
        sprintf(Name,"%s\\DSLOG", Windir);

        hFile = FindFirstFile(Name, &w32Data);
        if ( hFile == INVALID_HANDLE_VALUE ) {
            return FALSE;
        }
        FindClose(hFile);
    }

    if ( MiddleName == NULL ) {
        if (!GetProcName(FileName,TaskId)) {
            strcpy(FileName, Prefix);
        }
    } else {
        strcpy(FileName, MiddleName);
    }

    //
    // ok, add a suffix
    //

    (VOID)CreateDirectory(Windir,NULL);

    for (i=0;i<500000;i++) {

        sprintf(Name,"%s\\%s.%s.%u",Windir,Prefix,FileName,i);

        hFile = FindFirstFile(Name, &w32Data);
        if ( hFile == INVALID_HANDLE_VALUE ) {
            if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
                break;
            }
            break;
        } else {
            FindClose(hFile);
        }
    }

    return TRUE;
} // GetLogFileName


VOID
DsCloseLogFile(
    VOID
    )
{
    if ( hWait != INVALID_HANDLE_VALUE ) {
        UnregisterWait(hWait);
        hWait = INVALID_HANDLE_VALUE;
    }

    if ( hChange != INVALID_HANDLE_VALUE ) {
        FindCloseChangeNotification(hChange);
        hChange = INVALID_HANDLE_VALUE;
    }

    if ( hLogFile != INVALID_HANDLE_VALUE ) {
        CloseHandle(hLogFile);
        hLogFile = INVALID_HANDLE_VALUE;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\dscommon\dsconfig.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsconfig.c
//
//--------------------------------------------------------------------------

/*
 * GetConfigParam reads a configuration keyword from the registry
 */

#include <NTDSpch.h>
#pragma  hdrstop

#include <ctype.h>

#define  DEBSUB  "DSCONFIG:"
#include <debug.h>
#include <ntdsa.h>

#include <dsconfig.h>
#include <fileno.h>
#define  FILENO FILENO_DSCONFIG


DWORD
GetConfigParam(
    char * parameter,
    void * value,
    DWORD dwSize)
{

    DWORD herr, err = 0, dwType;
    HKEY  hk;

    DPRINT2( 2,
            " ** attempt to read [%s] \"%s\" param\n",
            DSA_CONFIG_SECTION,
            parameter );

    if ((herr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) ||
        (err = RegQueryValueEx(hk, parameter, NULL, &dwType, (LPBYTE) value, &dwSize))) {

        DPRINT3( 1, " ** [%s] \"%s\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

    } else if (dwType == REG_SZ) {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"%s\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);

    } else {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }
    if (herr) {
        // we don't have a handle, so just return the error
        return herr;
    }

    //  Close the handle if one was opened.
    RegCloseKey(hk);

    return err;
}

DWORD
GetConfigParamW(
    WCHAR * parameter,
    void * value,
    DWORD dwSize)
{

    DWORD herr, err = 0, dwType;
    HKEY  hk;

    DPRINT2( 2,
            " ** attempt to read [%s] \"%S\" param\n",
            DSA_CONFIG_SECTION,
            parameter );

    if ((herr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) ||
        (err = RegQueryValueExW(hk, parameter, NULL, &dwType, (LPBYTE) value, &dwSize))) {

        DPRINT3( 1, " ** [%s] \"%S\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

    } else if (dwType == REG_SZ) {

        DPRINT3( 2, " ** [%s] \"%S\" param = \"%S\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);

    } else {

        DPRINT3( 2, " ** [%s] \"%S\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }
    //  Close the handle if one was opened.
    if (!herr) {
        RegCloseKey(hk);
    }

    return herr?herr:err;
}

DWORD
GetConfigParamA(
    char * parameter,
    void * value,
    DWORD dwSize)
{

    DWORD herr, err = ERROR_FILE_NOT_FOUND, dwType;
    HKEY  hk;

    DPRINT2( 2,
             " ** attempt to read [%s] \"%s\" param\n",
         DSA_CONFIG_SECTION,
         parameter );

    if ((herr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) ||
        (err = RegQueryValueExA(hk, parameter, NULL, &dwType, (LPBYTE) value, &dwSize))) {

        DPRINT3( 1, " ** [%s] \"%s\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

    } else if (dwType == REG_SZ) {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"%s\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);

    } else {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }
    //  Close the handle if one was opened.
    if (!herr) {
        RegCloseKey(hk);
    }

    return err;
}


DWORD
GetConfigParamAlloc(
    IN  PCHAR   parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize)
/*++

Routine Description:

    Reads a value out of the DSA_CONFIG_SECTION of the registry, and 
    returns a newly allocated buffer containing the value.
    
Parameters

    parameter - The name of the value to read.

    value     - Used to pass back a pointer to the newly allocated buffer 
                containing the value that was read.  The buffer must be freed
                with free().
                
    pdwSize   - Used to pass back the size of the buffer allocated.

Return values:

    0 if all went well, otherwise a Win32 error code.

++*/
{

    DWORD err = 0, dwType;
    HKEY  hk;

    DPRINT2( 2,
            " ** attempt to read [%s] \"%s\" param\n",
            DSA_CONFIG_SECTION,
            parameter );

    if (err = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) {
         
        DPRINT2( 1, " ** [%s] key not found. Status = %d\n",
            DSA_CONFIG_SECTION, err );
        return err;
    }
        
    //
    // Find out how big the buffer needs to be.
    //
    if (err = RegQueryValueEx(hk, parameter, NULL, &dwType, (LPBYTE) NULL, pdwSize)) {

        DPRINT3( 1, " ** [%s] \"%s\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

        goto cleanup;
    }
    
    *value = malloc(*pdwSize);
    if (!*value) {
        DPRINT1( 1, " ** GetConfigParamAlloc failed to allocate %d bytes.\n", *pdwSize );
        err = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
    
    if (err = RegQueryValueEx(hk, parameter, NULL, &dwType, (LPBYTE) *value, pdwSize)) {

            DPRINT3( 1, " ** [%s] \"%s\" param not found. Status = %d\n",
                DSA_CONFIG_SECTION, parameter, err );
            free(*value); *value = NULL;

    } else if (dwType == REG_SZ) {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"%s\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);

    } else {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }

cleanup:
    //  Close the handle if one was opened.
    RegCloseKey(hk);

    return err;
}

DWORD
GetConfigParamAllocW(
    IN  PWCHAR  parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize)
/*++

Routine Description:

    Reads a value out of the DSA_CONFIG_SECTION of the registry, and 
    returns a newly allocated buffer containing the value.
    
    This version of GetConfigParamAlloc uses the the wide character version
    of RegQueryValueExW.
    
Parameters

    parameter - The name of the value to read.

    value     - Used to pass back a pointer to the newly allocated buffer 
                containing the value that was read.  The buffer must be freed
                with free().
                
    pdwSize   - Used to pass back the size of the buffer allocated.

Return values:

    0 if all went well, otherwise a Win32 error code.

++*/
{

    DWORD err = 0, dwType;
    HKEY  hk;

    DPRINT2( 2,
            " ** attempt to read [%s] \"%S\" param\n",
            DSA_CONFIG_SECTION,
            parameter );

    if (err = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) {
         
        DPRINT2( 1, " ** [%S] key not found. Status = %d\n",
            DSA_CONFIG_SECTION, err );
        return err;
    }
        
    //
    // Find out how big the buffer needs to be.
    //
    if (err = RegQueryValueExW(hk, parameter, NULL, &dwType, (LPBYTE) NULL, pdwSize)) {

        DPRINT3( 1, " ** [%s] \"%S\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

        goto cleanup;
    }
    
    *value = malloc(*pdwSize);
    if (!*value) {
        DPRINT1( 1, " ** GetConfigParamAlloc failed to allocate %d bytes.\n", *pdwSize );
        err = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
    
    if (err = RegQueryValueExW(hk, parameter, NULL, &dwType, (LPBYTE) *value, pdwSize)) {

            DPRINT3( 1, " ** [%s] \"%S\" param not found. Status = %d\n",
                DSA_CONFIG_SECTION, parameter, err );
            free(*value); *value = NULL;

    } else if (dwType == REG_SZ) {

        DPRINT3( 2, " ** [%s] \"%S\" param = \"%S\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);

    } else {

        DPRINT3( 2, " ** [%s] \"%S\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }

cleanup:
    //  Close the handle if one was opened.
    RegCloseKey(hk);

    return err;
}

DWORD
GetConfigParamAllocA(
    IN  PCHAR   parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize)
/*++

Routine Description:

    Reads a value out of the DSA_CONFIG_SECTION of the registry, and 
    returns a newly allocated buffer containing the value.
    
    This version of GetConfigParamAlloc uses the ascii version of RegQueryValueEx.
    
Parameters

    parameter - The name of the value to read.

    value     - Used to pass back a pointer to the newly allocated buffer 
                containing the value that was read.  The buffer must be freed
                with free().
                
    pdwSize   - Used to pass back the size of the buffer allocated.

Return values:

    0 if all went well, otherwise a Win32 error code.

++*/
{

    DWORD err = 0, dwType;
    HKEY  hk;

    DPRINT2( 2,
            " ** attempt to read [%s] \"%s\" param\n",
            DSA_CONFIG_SECTION,
            parameter );

    if (err = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk)) {
         
        DPRINT2( 1, " ** [%s] key not found. Status = %d\n",
            DSA_CONFIG_SECTION, err );
        return err;
    }
        
    //
    // Find out how big the buffer needs to be.
    //
    if (err = RegQueryValueExA(hk, parameter, NULL, &dwType, (LPBYTE) NULL, pdwSize)) {

        DPRINT3( 1, " ** [%s] \"%s\" param not found. Status = %d\n",
            DSA_CONFIG_SECTION, parameter, err );

        goto cleanup;
    }
    
    *value = malloc(*pdwSize);
    if (!*value) {
        DPRINT1( 1, " ** GetConfigParamAlloc failed to allocate %d bytes.\n", *pdwSize );
        err = ERROR_OUTOFMEMORY;
        goto cleanup;
    }
    
    if (err = RegQueryValueExA(hk, parameter, NULL, &dwType, (LPBYTE) *value, pdwSize)) {

            DPRINT3( 1, " ** [%s] \"%s\" param not found. Status = %d\n",
                DSA_CONFIG_SECTION, parameter, err );

    } else if (dwType == REG_SZ) {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"%s\"\n",
            DSA_CONFIG_SECTION, parameter,  (LPTSTR) value);
        free(*value); *value = NULL;

    } else {

        DPRINT3( 2, " ** [%s] \"%s\" param = \"0x%x\"\n",
            DSA_CONFIG_SECTION, parameter,  *((DWORD *) value));
    }

cleanup:
    //  Close the handle if one was opened.
    RegCloseKey(hk);

    return err;
}

DWORD
SetConfigParam(
    char * parameter,
    DWORD dwType,
    void * value,
    DWORD dwSize)
{

    DWORD herr = 0, err = 0;
    HKEY  hk;

    DPRINT2( 2,
             " ** attempt to write [%s] \"%s\" param\n",
         DSA_CONFIG_SECTION,
         parameter );

    herr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk); 
    if (herr) {
        // we don't have a handle, so just return the error
        return herr;
    }

    err = RegSetValueEx(hk, parameter, 0, dwType, (LPBYTE) value, dwSize);

    //  Close the handle if one was opened.
    RegCloseKey(hk);

    return err;
}

DWORD
DeleteConfigParam(
    char * parameter)
{
    DWORD herr = 0, err = 0;
    HKEY  hk;

    herr = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk);
    if (herr) {
        // we don't have a handle, so just return the error
        return herr;
    }

    err = RegDeleteValueA(hk, parameter);

    RegCloseKey(hk);
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\dscommon\debug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       debug.c
//
//--------------------------------------------------------------------------

/*  Debug initialization routine
    This routine reads input from STDIN and initializes the debug structure.
    It reads a list of subsystems to debug and a severity level.
*/
#include <NTDSpch.h>
#pragma  hdrstop


#include <nminsert.h>

DWORD  RaiseAlert(char *szMsg);


#include "debug.h"
#define DEBSUB "DEBUG:"

#include <dsconfig.h>
#include <mdcodes.h>
#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <dsevent.h>
#include <ntrtl.h>
#include <dsexcept.h>
#include <fileno.h>
#define  FILENO FILENO_DEBUG

DWORD DbgPageSize=0x1000;

#if DBG

DWORD * pDebugThreadId;

UCHAR     _dbPrintBuf[ 512 ];
UCHAR     _dbOutBuf[512];


BOOL     fProfiling;
BOOL     fEarlyXDS;
BOOL     gfIsConsoleApp = TRUE;
BOOL     fLogOpen = FALSE;

extern  DWORD  * pDebugThreadId;    /*Current thread id  */
#define DEBTH  GetCurrentThreadId() /*The actual thread value*/

// This flag is set to TRUE when we take a normal exit.The atexit routine
// checks this flag and asserts if it isn't set.

DEBUGARG DebugInfo;
ASSERTARG AssertInfo;
BOOL     fProfiling;
BOOL     fEarlyXDS;

//
// from filelog.c
//

VOID
DsCloseLogFile(
    VOID
    );

BOOL
DsOpenLogFile(
    IN PCHAR FilePrefix,
    IN PCHAR MiddleName,
    IN BOOL fCheckDSLOGMarker
    );

BOOL
DsPrintLog(
    IN LPSTR    Format,
    ...
    );

static int initialized = 0;

//
// forward references
//

VOID
DoAssertToDebugger(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    );


VOID
Debug(
    int argc, 
    char *argv[], 
    PCHAR Module
    )
{

    SYSTEM_INFO SystemInfo;
    CHAR logList[MAX_PATH];
    
    /* Insure that this function is only visited once */

    if (initialized != 0) {
        return;
    }

    __try {
        InitializeCriticalSection(&DebugInfo.sem);
        initialized = 1;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        initialized = 0;
    }

    if(!initialized) {
        DsaExcept(DSA_MEM_EXCEPTION, 0, 0);
    }

    GetSystemInfo(&SystemInfo);
    DbgPageSize=SystemInfo.dwPageSize;

    /* Setup a pointer to the current thread id */


    // Anticipate no debugging

    fProfiling = FALSE;
    fEarlyXDS = FALSE;
    DebugInfo.severity = 0;
    DebugInfo.threadId = 0;
    strcpy(DebugInfo.DebSubSystems, "*");
    AssertInfo.dwCount = 0;

    if (argc <= 2) {

        //
        //   Attempt to load debuginfo from registry.
        //

        GetConfigParam(DEBUG_SYSTEMS, DebugInfo.DebSubSystems, sizeof(DebugInfo.DebSubSystems));
        GetConfigParam(DEBUG_SEVERITY, &DebugInfo.severity, sizeof(DebugInfo.severity));
    }

    //
    // See if logging is turned on
    //

    if ( GetConfigParam(DEBUG_LOGGING, logList, sizeof(logList) ) == ERROR_SUCCESS ) {

        //
        // see if this module is in the list
        //

        if ( strstr(logList, Module) != NULL ) {

            EnterCriticalSection(&DebugInfo.sem);
            fLogOpen = DsOpenLogFile("dsprint", Module, FALSE);
            LeaveCriticalSection(&DebugInfo.sem);

            if ( !fLogOpen ) {
                KdPrint(("Unable to open debug log file\n"));
            }
        }
    }

    // If user passed -d, prompt for input.

    while (argc > 1) {
        argc--;
        if(_stricmp(argv[argc], "-p") == 0) {
            /* Profile flag.  Means to stop on a carriage return in the
             * DSA window.
             */
            printf("Profiling flag on.  DSA will shutdown after carriage return in this window.\n");
            fProfiling = TRUE;
        }
        else if(_stricmp(argv[argc], "-x") == 0) {
            /* Early XDS flag.  Means to load the XDS interface at start up,
             * before full installation of the system.  Useful for loading
             * the initial schema.
             */
            printf("Early XDS initialization on.\n");
            fEarlyXDS = TRUE;
        }
        else if (!(_stricmp(argv[argc], "-noconsole"))) {
            gfIsConsoleApp = FALSE;
        }
        else if (!(_stricmp(argv[argc], "-d"))){
            /* A bad result prints all */
            /* prompt and get subsystem list */

            printf("Enter one of the following:  \n"
            "  A list of subsystems to debug (e.g. Sub1: Sub2:).\n"
            "  An asterisk (*) to debug all subsystems.\n"
            "  A (cr) for no debugging.\n");

            DebugInfo.DebSubSystems[0] ='\0';
            if ( gets(DebugInfo.DebSubSystems) == NULL ||
                    strlen( DebugInfo.DebSubSystems ) == 0 )
                    strcpy(DebugInfo.DebSubSystems, "*");

            if (strlen(DebugInfo.DebSubSystems) == 0)     /* default (cr) */
            strcpy(DebugInfo.DebSubSystems, ":");

            /* prompt and get severity level */

            printf("Enter the debug severity level 1 - 5 (low - high).\n"
            "  (A severity of 0 specifies no debugging.)\n");

            /* read the severity level (1 - 5) */

            if (1 != scanf("%hu", &DebugInfo.severity))
            DebugInfo.severity = 5;

            /* Read a thread Id to trace */

            printf("Enter a specific thread to debug.\n"
            "  (A thread ID of 0 specifies DEBUG ALL THREADS.)\n");

            /* read the thread ID to debug */

            if (1 != scanf("%u", &DebugInfo.threadId))
            DebugInfo.threadId = 0;

            /*  to make this thing work with stdin */
            getchar();

            break;
        }
    }
}/*debug*/





/*
**      returns TRUE if a debug message should be printed, false if not.
*/
USHORT DebugTest(USHORT sev, CHAR *debsub)
{
    if (!initialized) {
        return FALSE;
    }

    /* level 0 prints should always happen */
    if (sev == 0) {
        return TRUE;
    }

    /* don't print if it's not severe enough */
    if (DebugInfo.severity < sev) {
        return FALSE;
    }

    /* if a subsystem has been specified and this isn't it, quit */
    if (debsub && 
        (0 == strstr(DebugInfo.DebSubSystems, debsub)) &&
        (0 == strstr(DebugInfo.DebSubSystems, "*"))) {
        return FALSE;
    }

    /* if we're only debugging a specific thread and this isn't it, quit */
    if (DebugInfo.threadId != 0 &&
        DebugInfo.threadId != (DEBTH)) {
        return FALSE;
    }

    return TRUE;
}

/*
**      Actual function that does the printf
*/
void
DebPrint(USHORT sev,
     UCHAR * str,
     CHAR * debsub,
     unsigned uLineNo,
     ... )
{
    va_list   argptr;
    DWORD tid = DEBTH;

    // Test for whether output should be printed is now done by the caller
    // using DebugTest()

    EnterCriticalSection(&DebugInfo.sem);
    __try
    {
        char buffer[512];
        DWORD cchBufferSize = sizeof(buffer);
        char *pBuffer = buffer;
        char *pNewBuffer;
        DWORD cchBufferUsed = 0;
        DWORD cchBufferUsed2;
        BOOL fTryAgainWithLargerBuffer;

        va_start( argptr, uLineNo );

        do {
            if (debsub) {
                _snprintf(pBuffer, cchBufferSize, "<%s%u:%u> ", debsub, tid,
                          uLineNo);
                cchBufferUsed = lstrlenA(pBuffer);
            }
            cchBufferUsed2 = _vsnprintf(pBuffer + cchBufferUsed,
                                        cchBufferSize - cchBufferUsed,
                                        str,
                                        argptr);

            fTryAgainWithLargerBuffer = FALSE;
            if (((DWORD) -1 == cchBufferUsed2) && (cchBufferSize < 64*1024)) {
                // Buffer too small -- try again with bigger buffer.
                if (pBuffer == buffer) {
                    pNewBuffer = malloc(cchBufferSize * 2);
                } else {
                    pNewBuffer = realloc(pBuffer, cchBufferSize * 2);
                }

                if (NULL != pNewBuffer) {
                    cchBufferSize *= 2;
                    pBuffer = pNewBuffer;
                    fTryAgainWithLargerBuffer = TRUE;
                } else {
                    // Deal with what we have.
                    pBuffer[cchBufferSize-2] = '\n';
                    pBuffer[cchBufferSize-1] = '\0';
                }
            }
        } while (fTryAgainWithLargerBuffer);
        
        va_end( argptr );

        if (gfIsConsoleApp) {
            printf("%s", pBuffer);
        }

        if ( fLogOpen ) {

            DsPrintLog("%s", pBuffer);

        } else {
            DbgPrint(pBuffer);
        }

        if (pBuffer != buffer) {
            free(pBuffer);
        }
    }
    __finally
    {
        LeaveCriticalSection(&DebugInfo.sem);
    }

    return;

} // DebPrint

VOID
TerminateDebug(
    VOID
    )
{
    DsCloseLogFile( );
    return;
} // TerminateDebug

char gDebugAsciiz[256];

char *asciiz(char *var, USHORT len)
{
   if (len < 256){
      memcpy(gDebugAsciiz, var, len);
      gDebugAsciiz[len] = '\0';
      return gDebugAsciiz;
   }
   else{
      strcpy(gDebugAsciiz, "**VAR TOO BIG**");
      return gDebugAsciiz;
   }
}


BOOL
addDisabledAssertion(
    IN PVOID FileName,
    IN ULONG LineNumber
    )

/*++

Routine Description:

   Add an assertion to the disabled assertion list

Arguments:

    FileName - 
    LineNumber - 

Return Value:

    BOOL - 

--*/

{
    ASSERT_ENTRY *pae;

    if (AssertInfo.dwCount == MAX_DISABLED_ASSERTIONS) {
        return FALSE;
    }

    pae = AssertInfo.Entry + AssertInfo.dwCount;

    strncpy( pae->szFile, FileName, MAX_ASSERT_FILE_SIZE );
    pae->szFile[MAX_ASSERT_FILE_SIZE] = '\0';
    pae->dwLine = LineNumber;

    AssertInfo.dwCount++;

    return TRUE;

} /* addDisabledAssertion */


void DoAssert(char *szExp, char *szFile, int nLine )
{
    DWORD i;

    // Check if assertion is already disabled
    for( i = 0; i < AssertInfo.dwCount; i++ ) {
        if ( (_strnicmp( szFile, AssertInfo.Entry[i].szFile, MAX_ASSERT_FILE_SIZE) == 0) &&
             ((DWORD) nLine == AssertInfo.Entry[i].dwLine) ) {
            // The assertion is disabled
            return;
        }
    }

    if (!gfIsConsoleApp) {
        //
        // For the DLL case Assert to Kernel Debugger,
        // as a looping assert will effectively freeze
        // the security system and no debugger can attach
        // either
        //
        DoAssertToDebugger( szExp, szFile, nLine, NULL );
    }
    else {

        char szMessage[1024];

        _snprintf(szMessage, sizeof(szMessage), "DSA assertion failure: \"%s\"\n"
        "File %s line %d\nFor bug reporting purposes, please enter the "
        "debugger (Retry) and record the current call stack.  Also, please "
        "record the last messages in the Application Event Log.\n"
        "Thank you for your support.",
        szExp, szFile, nLine);

        __try {
            RaiseAlert(szMessage);
        } __except(1) {
            /* bummer */
        };

        switch(MessageBox(NULL, szMessage, "DSA assertion failure",
            MB_TASKMODAL | MB_ICONSTOP | MB_ABORTRETRYIGNORE | MB_DEFBUTTON2 |
            MB_SETFOREGROUND))
        {
        case IDABORT:
            exit(1);
            break;
        case IDRETRY:
            DebugBreak();
            break;
        case IDIGNORE:
            /* best of luck, you're gonna need it */
            break;
            // case DISABLE:
            // The ToDebugger case has the ability to disable assertions.
            // Call addDisabledAssertion()
            // There is no way to express that at present via the MessageBox.
        }
    }
}


VOID
DoAssertToDebugger(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
/*++

Routine Description:

    This is a copy of RtlAssert() from ntos\rtl\assert.c.  This is
    unforntunately required if we want the ability to generate assertions
    from checked DS binaries on a free NT base.  (RtlAssert() is a no-op on
    a free NT base.)

Arguments:

    Same as RtlAssert().

Return Values:

    None.

--*/
{
    char Response[ 2 ];
    CONTEXT Context;

    while (TRUE) {
        DbgPrint( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );

        DbgPrompt( "Break, Ignore, Disable, Terminate Process or Terminate Thread (bidpt)? ",
                   Response,
                   sizeof( Response )
                 );
        switch (Response[0]) {
            case 'B':
            case 'b':
                DbgBreakPoint();
                break;

            case 'I':
            case 'i':
                return;

            case 'D':
            case 'd':
                if (addDisabledAssertion( FileName, LineNumber )) {
                    // Automatically ignore after disable
                    return;
                }
                DbgPrint( "Maximum number of %d disabled assertions has been reached!\n",
                          MAX_DISABLED_ASSERTIONS );
                // Failed to disable, reprompt
                break;

            case 'P':
            case 'p':
                NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
                break;

            case 'T':
            case 't':
                NtTerminateThread( NtCurrentThread(), STATUS_UNSUCCESSFUL );
                break;
            }
        }

    DbgBreakPoint();
    NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
}

#endif

BOOL
IsValidReadPointer(
        IN PVOID pv,
        IN DWORD cb
        )
{
    BOOL fReturn = TRUE;
    DWORD i;
    UCHAR *pTemp, cTemp;

    if(!cb) {
        // We define a check of 0 bytes to always succeed
        return TRUE;
    }
    
    if(!pv) {
        // We define a check of a NULL pointer to fail unless we were checking
        // for 0 bytes.
        return FALSE;
    }
        
    __try {
        pTemp = (PUCHAR)pv;

        // Check out the last byte.
        cTemp = pTemp[cb - 1];
        
        for(i=0;i<cb;i+=DbgPageSize) {
            cTemp = pTemp[i];
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        fReturn = FALSE;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\dsevent\dslogevt.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

Abstract:

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <winldap.h>
#include <locale.h>

#include <ntdsa.h>
#include <dsevent.h>
#include <dsconfig.h>
#include <dsutil.h>
#include <mdcodes.h>
#include <debug.h>
#include <fileno.h>


#define ARRAY_SIZE(x) (sizeof(x)/sizeof(*(x)))

#define MAX_BUFFERS_TO_FREE (16)

typedef enum {
    INSERT_MACRO_SZ,
    INSERT_MACRO_WC,
    INSERT_MACRO_WC2,
    INSERT_MACRO_INT,
    INSERT_MACRO_HEX,
    INSERT_MACRO_PTR,
    INSERT_MACRO_UL,
    INSERT_MACRO_USN,
    INSERT_MACRO_DN,
    INSERT_MACRO_MTX,
    INSERT_MACRO_UUID,
    INSERT_MACRO_DSMSG,
    INSERT_MACRO_WIN32MSG,
    INSERT_MACRO_JETERRMSG,
    INSERT_MACRO_DBERRMSG,
    INSERT_MACRO_THSTATEERRMSG,
    INSERT_MACRO_LDAPERRMSG,
    INSERT_MACRO_ATTRTYPE,
    INSERT_MACRO_DSTIME,
} INSERT_MACRO_TYPE;

// Needed by dsevent.lib.
DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }

HMODULE g_hmodNtdsMsg = NULL;

LPWSTR
Win32ErrToString(
    IN  ULONG   dwMsgId
    )
{
    static WCHAR szError[1024];

    DWORD       cch;

    cch = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
                          | FORMAT_MESSAGE_IGNORE_INSERTS,
                         NULL,
                         dwMsgId,
                         GetSystemDefaultLangID(),
                         szError,
                         ARRAY_SIZE(szError),
                         NULL);
    if (0 != cch) {
        // Chop off trailing \r\n.
        Assert(L'\r' == szError[wcslen(szError)-2]);
        Assert(L'\n' == szError[wcslen(szError)-1]);
        szError[wcslen(szError)-2] = L'\0';
    }
    else {
        swprintf(szError, L"Can't retrieve message string %d (0x%x), error %d.",
                 dwMsgId, dwMsgId, GetLastError());
    }

    return szError;
}

DWORD
AddHighBitsToNtdsMsgNum(
    IN OUT  DWORD * pdwMsgNum
    )
{
    DWORD err = 0;
    DWORD iTry;
    DWORD cch;

    // Determine actual message number, which includes the severity encoded
    // in the high bits.
    for (iTry = 0; iTry < 4; iTry++) {
        DWORD dwTmpMsgNum = *pdwMsgNum;
        LPWSTR pszMessage;
    
        switch (iTry) {
        case 0:
            dwTmpMsgNum = (dwTmpMsgNum & 0x3FFFFFFF);
            break;
    
        case 1:
            dwTmpMsgNum = (dwTmpMsgNum & 0x3FFFFFFF) | 0x40000000;
            break;
    
        case 2:
            dwTmpMsgNum = (dwTmpMsgNum & 0x3FFFFFFF) | 0x80000000;
            break;
    
        case 3:
            dwTmpMsgNum = (dwTmpMsgNum & 0x3FFFFFFF) | 0xC0000000;
            break;
        }
    
        cch = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE
                              | FORMAT_MESSAGE_ALLOCATE_BUFFER
                              | FORMAT_MESSAGE_IGNORE_INSERTS,
                             g_hmodNtdsMsg,
                             dwTmpMsgNum,
                             GetSystemDefaultLangID(),
                             (LPWSTR) &pszMessage,
                             -1,
                             NULL);
        if (0 != cch) {
            LocalFree(pszMessage);
            *pdwMsgNum = dwTmpMsgNum;
            break;
        } else {
            err = GetLastError();
        }
    }
    
    if (0 == cch) {
        Assert(0 != err);
        printf("Can't retrieve message %d (0x%x), error %d:\n\t%ls\n",
               *pdwMsgNum, *pdwMsgNum, err, Win32ErrToString(err));
    } else {
        err = 0;
    }

    return err;
}

DWORD
InsertParamFromString(
    IN      INSERT_MACRO_TYPE   eInsertMacro,
    IN      LPWSTR              pszValue,
    IN OUT  void ***            pppBuffersToFree,
    OUT     INSERT_PARAMS *     pParam
    )
{
    DWORD err = 0;
    LPWSTR pszNext;

    pParam->InsertType = eInsertMacro;

    switch (eInsertMacro) {
    case INSERT_MACRO_INT:
    case INSERT_MACRO_JETERRMSG:
        // Signed 32-bit int.
        pParam->tmpDword = (ULONG_PTR) wcstol(pszValue, &pszNext, 0);
        if ((pszNext == pszValue) || (L'\0' != *pszNext)) {
            printf("Failed to parse value \"%ls\"; signed 32-bit integer expected.\n",
                   pszValue);
            err = ERROR_INVALID_PARAMETER;
        }
        break;

#ifndef _WIN64
    case INSERT_MACRO_PTR:
#endif
    case INSERT_MACRO_HEX:
    case INSERT_MACRO_UL:
    case INSERT_MACRO_WIN32MSG:
    case INSERT_MACRO_DBERRMSG:
    case INSERT_MACRO_LDAPERRMSG:
        // Unsigned 32-bit int.
        pParam->tmpDword = (ULONG_PTR) wcstoul(pszValue, &pszNext, 0);
        if ((pszNext == pszValue) || (L'\0' != *pszNext)) {
            printf("Failed to parse value \"%ls\"; unsigned 32-bit integer expected.\n",
                   pszValue);
            err = ERROR_INVALID_PARAMETER;
        }
        break;

    case INSERT_MACRO_USN:
        // Signed 64-bit int.
        pParam->tmpDword = (DWORD_PTR) malloc(sizeof(LONGLONG));
        if (NULL == pParam->tmpDword) {
            printf("No memory.\n");
            err = ERROR_OUTOFMEMORY;
        } else {
            DWORD cNumConverted;

            *((*pppBuffersToFree)++) = (void *) pParam->tmpDword;

            if ((pszValue[0] == L'0') && (tolower(pszValue[1]) == L'x')) {
                cNumConverted = swscanf(&pszValue[2], L"%I64x", pParam->tmpDword);
            }
            else {
                cNumConverted = swscanf(pszValue, L"%I64d", pParam->tmpDword);
            }

            if (1 != cNumConverted) {
                printf("Failed to parse value \"%ls\"; signed 64-bit integer expected.\n",
                       pszValue);
                err = ERROR_INVALID_PARAMETER;
            }
        }
        break;

#ifdef _WIN64
    case INSERT_MACRO_PTR:
#endif
    case INSERT_MACRO_DSTIME:
        // Unsigned 64-bit int.
        pParam->tmpDword = (DWORD_PTR) malloc(sizeof(ULONGLONG));
        if (NULL == pParam->tmpDword) {
            printf("No memory.\n");
            err = ERROR_OUTOFMEMORY;
        } else {
            DWORD cNumConverted;

            *((*pppBuffersToFree)++) = (void *) pParam->tmpDword;
            
            if ((pszValue[0] == L'0') && (tolower(pszValue[1]) == L'x')) {
                cNumConverted = swscanf(&pszValue[2], L"%I64x", pParam->tmpDword);
            }
            else {
                cNumConverted = swscanf(pszValue, L"%I64u", pParam->tmpDword);
            }

            if (1 != cNumConverted) {
                printf("Failed to parse value \"%ls\"; unsigned 64-bit integer expected.\n",
                       pszValue);
                err = ERROR_INVALID_PARAMETER;
            }
        }
        break;

    case INSERT_MACRO_DSMSG:
        {
            DWORD dwMsgNum;
            
            dwMsgNum = wcstoul(pszValue, &pszNext, 0);
            if ((pszNext == pszValue) || (L'\0' != *pszNext)) {
                printf("Failed to parse value \"%ls\"; unsigned 32-bit integer expected.\n",
                       pszValue);
                err = ERROR_INVALID_PARAMETER;
            } else {
                err = AddHighBitsToNtdsMsgNum(&dwMsgNum);
                if (0 == err) {
                    pParam->tmpDword = (ULONG_PTR) dwMsgNum;
                }
            }
        }
        break;

    case INSERT_MACRO_WC:
        pParam->tmpDword = (ULONG_PTR) pszValue;
        break;

    case INSERT_MACRO_SZ:
    case INSERT_MACRO_WC2:
    case INSERT_MACRO_DN:
    case INSERT_MACRO_MTX:
    case INSERT_MACRO_UUID:
    case INSERT_MACRO_THSTATEERRMSG:
    case INSERT_MACRO_ATTRTYPE:
    default:
        printf("This tool does not yet support this insertion type.\n");
        err = ERROR_INVALID_PARAMETER;
        break;
    }

    return err;
}

void
InsertType(
    IN      INSERT_PARAMS *     pParam,
    IN OUT  LOG_PARAM_BLOCK &   logBlock,
    IN OUT  void ***            pppBuffersToFree
    )
{
    switch (pParam->InsertType) {
    case INSERT_MACRO_SZ:             szInsertSz((LPSTR) pParam->tmpDword);                             break;
    case INSERT_MACRO_WC:             szInsertWC((LPWSTR) pParam->tmpDword);                            break;
    case INSERT_MACRO_WC2:            szInsertWC2((LPWSTR) pParam->tmpDword, pParam->InsertLen);        break;
    case INSERT_MACRO_INT:            szInsertInt((int) pParam->tmpDword);                              break;
    case INSERT_MACRO_HEX:            szInsertHex((int) pParam->tmpDword);                              break;
    case INSERT_MACRO_PTR:            szInsertPtr(pParam->tmpDword);                                    break;
    case INSERT_MACRO_UL:             szInsertUL((ULONG) pParam->tmpDword);                             break;
    case INSERT_MACRO_USN:            szInsertUSN(*((USN *) pParam->tmpDword));                         break;
    case INSERT_MACRO_DN:             szInsertDN((DSNAME *) pParam->tmpDword);                          break;
    case INSERT_MACRO_MTX:            szInsertMTX((MTX_ADDR *) pParam->tmpDword);                       break;
    case INSERT_MACRO_UUID:           szInsertUUID((UUID *) pParam->tmpDword);                          break;
    case INSERT_MACRO_DSMSG:          szInsertDsMsg((DWORD) pParam->tmpDword);                          break;
    case INSERT_MACRO_WIN32MSG:       szInsertWin32Msg((DWORD) pParam->tmpDword);                       break;
    case INSERT_MACRO_JETERRMSG:      szInsertJetErrMsg((DWORD) pParam->tmpDword);                      break;
    case INSERT_MACRO_DBERRMSG:       szInsertDbErrMsg((DWORD) pParam->tmpDword);                       break;
    case INSERT_MACRO_THSTATEERRMSG:  Assert(!"szInsertThStateErrMsg() not supported by this tool!");   break;
    case INSERT_MACRO_LDAPERRMSG:     szInsertLdapErrMsg((DWORD) pParam->tmpDword);                     break;
    case INSERT_MACRO_ATTRTYPE:       Assert(!"szInsertAttrType() not supported by this tool!");        break;
    case INSERT_MACRO_DSTIME:
        {
            LPSTR pszTime = (LPSTR) malloc(SZDSTIME_LEN);
    
            if (NULL == pszTime) {
                printf("No memory.\n");
                exit(ERROR_OUTOFMEMORY);
            }
            
            *((*pppBuffersToFree)++) = (void *) pszTime;
            
            szInsertDSTIME(*((DSTIME *) pParam->tmpDword), pszTime);
        }
        break;
    default:                          Assert(!"Unknown insertion type!");                               break;
    }
}

#define szInsertType(x) InsertType((x), logBlock, &ppBuffersToFree)

int
__cdecl wmain(
    IN  int     argc,
    IN  LPWSTR  argv[]
    )
{
    static struct {
        LPWSTR pszKey;
        LPWSTR pszDescription;
        INSERT_MACRO_TYPE eInsertMacro;
    } rgInsertTypes[] = {
        { L"SZ:",             L"ANSI string.",                          INSERT_MACRO_SZ },
        { L"WC:",             L"Unicode string.",                       INSERT_MACRO_WC },
        { L"WC2:",            L"Counted Unicode string.",               INSERT_MACRO_WC2 },
        { L"INT:",            L"32-bit signed integer.",                INSERT_MACRO_INT },
        { L"HEX:",            L"32-bit unsigned hexadecimal integer.",  INSERT_MACRO_HEX },
        { L"PTR:",            L"Memory pointer.",                       INSERT_MACRO_PTR },
        { L"UL:",             L"32-bit unsigned integer.",              INSERT_MACRO_UL },
        { L"USN:",            L"64-bit signed integer.",                INSERT_MACRO_USN },
        { L"DN:",             L"DSNAME structure.",                     INSERT_MACRO_DN },
        { L"MTX:",            L"MTX_ADDR structure.",                   INSERT_MACRO_MTX },
        { L"UUID:",           L"UUID (aka GUID) structure.",            INSERT_MACRO_UUID },
        { L"DSMSG:",          L"NTDSMSG.DLL message string.",           INSERT_MACRO_DSMSG },
        { L"WIN32MSG:",       L"Win32 error message.",                  INSERT_MACRO_WIN32MSG },
        { L"JETERRMSG:",      L"ESE error message.",                    INSERT_MACRO_JETERRMSG },
        { L"DBERRMSG:",       L"DS database error (DB_ERR) message.",   INSERT_MACRO_DBERRMSG },
        { L"THSTATEERRMSG:",  L"DS thread state error message.",        INSERT_MACRO_THSTATEERRMSG },
        { L"LDAPERRMSG:",     L"LDAP error message.",                   INSERT_MACRO_LDAPERRMSG },
        { L"ATTRTYPE:",       L"DS attribute name.",                    INSERT_MACRO_ATTRTYPE },
        { L"DSTIME:",         L"DSTIME structure.",                     INSERT_MACRO_DSTIME },
    };

    static struct {
        LPWSTR  pszCategory;
        DWORD   dwCategory;
    } rgCategories[] = {
        { L"Knowledge Consistency Checker", DS_EVENT_CAT_KCC },
        { L"Security",                      DS_EVENT_CAT_SECURITY },
        { L"ExDS Interface",                DS_EVENT_CAT_XDS_INTERFACE },
        { L"MAPI Interface",                DS_EVENT_CAT_MAPI },
        { L"Replication",                   DS_EVENT_CAT_REPLICATION },
        { L"Garbage Collection",            DS_EVENT_CAT_GARBAGE_COLLECTION },
        { L"Internal Configuration",        DS_EVENT_CAT_INTERNAL_CONFIGURATION },
        { L"Directory Access",              DS_EVENT_CAT_DIRECTORY_ACCESS },
        { L"Internal Processing",           DS_EVENT_CAT_INTERNAL_PROCESSING },
        { L"Performance",                   DS_EVENT_CAT_PERFORMANCE_MONITOR },
        { L"Initialization/Termination",    DS_EVENT_CAT_STARTUP_SHUTDOWN },
        { L"Service Control",               DS_EVENT_CAT_SERVICE_CONTROL },
        { L"Name Resolution",               DS_EVENT_CAT_NAME_RESOLUTION },
        { L"Backup",                        DS_EVENT_CAT_BACKUP },
        { L"Field Engineering",             DS_EVENT_CAT_FIELD_ENGINEERING },
        { L"LDAP Interface",                DS_EVENT_CAT_LDAP_INTERFACE },
        { L"Setup",                         DS_EVENT_CAT_SETUP },
        { L"Global Catalog",                DS_EVENT_CAT_GLOBAL_CATALOG },
        { L"Inter-Site Messaging",          DS_EVENT_CAT_ISM },
        { L"Group Caching",                 DS_EVENT_CAT_GROUP_CACHING },
        { L"Linked-Value Replication",      DS_EVENT_CAT_LVR },
        { L"DS RPC Client",                 DS_EVENT_CAT_RPC_CLIENT },
        { L"DS RPC Server",                 DS_EVENT_CAT_RPC_SERVER },
    };

    static struct {
        LPWSTR  pszSource;
        DWORD   dwDirNo;
    } rgSources[] = {
        { MAKE_WIDE(pszNtdsSourceReplication),  DIRNO_DRA },
        { MAKE_WIDE(pszNtdsSourceDatabase),     DIRNO_DBLAYER },
        { MAKE_WIDE(pszNtdsSourceGeneral),      DIRNO_SRC },
        { MAKE_WIDE(pszNtdsSourceMapi),         DIRNO_NSPIS },
        { MAKE_WIDE(pszNtdsSourceReplication),  DIRNO_DRS },
        { MAKE_WIDE(pszNtdsSourceXds),          DIRNO_XDS },
        { MAKE_WIDE(pszNtdsSourceSecurity),     DIRNO_PERMIT },
        { MAKE_WIDE(pszNtdsSourceXds),          DIRNO_LIBXDS },
        { MAKE_WIDE(pszNtdsSourceSam),          DIRNO_SAM },
        { MAKE_WIDE(pszNtdsSourceLdap),         DIRNO_LDAP },
        { MAKE_WIDE(pszNtdsSourceSdprop),       DIRNO_SDPROP },
        { MAKE_WIDE(pszNtdsSourceKcc),          DIRNO_KCC },
        { MAKE_WIDE(pszNtdsSourceIsam),         DIRNO_ISAM },
        { MAKE_WIDE(pszNtdsSourceIsm),          DIRNO_ISMSERV },
        { MAKE_WIDE(pszNtdsSourceSetup),        DIRNO_NTDSETUP },
    };

    INSERT_PARAMS rgInsertParams[8] = {
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst1]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst2]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst3]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst4]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst5]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst6]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst7]" },
        { INSERT_MACRO_WC, 0, 0, (ULONG_PTR) L"[Subst8]" },
    };

    UINT    Codepage;
    char    achCodepage[12] = ".OCP";
    DWORD   err = 0;
    DWORD   dwMsgNum = 0;
    BOOL    fPrintUsage = FALSE;
    DWORD   cNumExplicitSubstStrings = 0;
    int     iArg;
    DWORD   iTry;
    DWORD   iCat;
    DWORD   iSrc;
    DWORD   iInsertType;
    DWORD   cch;
    HANDLE  hevtLoggingLevelChange = NULL;
    DWORD   dwCategory = DS_EVENT_CAT_DIRECTORY_ACCESS;
    DWORD   dwFileNo = FILENO_DSAMAIN;
    void *  rgpBuffersToFree[MAX_BUFFERS_TO_FREE] = {NULL};
    void ** ppBuffersToFree = rgpBuffersToFree;
    DWORD   iBuffer;
    
    // Set locale to the default
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%u", Codepage);
    }
    setlocale(LC_ALL, achCodepage);

    // Initialize debug library.
    DEBUGINIT(0, NULL, "repadmin");

    __try {
        g_hmodNtdsMsg = LoadLibrary("ntdsmsg.dll");
        if (NULL == g_hmodNtdsMsg) {
            err = GetLastError();
            printf("Can't load ntdsmsg.dll, error %d:\n\t%ls\n.",
                   err, Win32ErrToString(err));
            __leave;
        }
    
        for (iArg = 1; iArg < argc; iArg++) {
            if ((L'/' == argv[iArg][0]) || (L'-' == argv[iArg][0])) {
                // Process command-line option.
                WCHAR *pchColon = wcschr(&argv[iArg][1], L':');
    
                if (NULL == pchColon) {
                    if ((0 == _wcsicmp(&argv[iArg][1], L"?"))
                        || (0 == _wcsicmp(&argv[iArg][1], L"h"))
                        || (0 == _wcsicmp(&argv[iArg][1], L"help"))) {
                        fPrintUsage = TRUE;
                        break;
                    } else {
                        printf("Unknown option, \"%ls\".\n", argv[iArg]);
                        err = ERROR_INVALID_PARAMETER;
                        __leave;
                    }
                } else {
                    DWORD cchKey = (DWORD) (pchColon - argv[iArg]);
                    LPWSTR pszValue = pchColon + 1;
    
                    if ((0 == _wcsnicmp(&argv[iArg][1], L"c:", cchKey))
                        || (0 == _wcsnicmp(&argv[iArg][1], L"cat:", cchKey))
                        || (0 == _wcsnicmp(&argv[iArg][1], L"category:", cchKey))) {
                        
                        for (iCat = 0; iCat < ARRAY_SIZE(rgCategories); iCat++) {
                            if (0 == _wcsicmp(rgCategories[iCat].pszCategory, pszValue)) {
                                dwCategory = rgCategories[iCat].dwCategory;
                                break;
                            }
                        }

                        if (iCat == ARRAY_SIZE(rgCategories)) {
                            printf("Unknown category, \"%ls\".\n", pszValue);
                            err = ERROR_INVALID_PARAMETER;
                            __leave;
                        }
                    } else if ((0 == _wcsnicmp(&argv[iArg][1], L"s:", cchKey))
                               || (0 == _wcsnicmp(&argv[iArg][1], L"src:", cchKey))
                               || (0 == _wcsnicmp(&argv[iArg][1], L"source:", cchKey))) {
                        
                        for (iSrc = 0; iSrc < ARRAY_SIZE(rgSources); iSrc++) {
                            if (0 == _wcsicmp(rgSources[iSrc].pszSource, pszValue)) {
                                dwFileNo = rgSources[iSrc].dwDirNo;
                                break;
                            }
                        }

                        if (iSrc == ARRAY_SIZE(rgSources)) {
                            printf("Unknown source, \"%ls\".\n", pszValue);
                            err = ERROR_INVALID_PARAMETER;
                            __leave;
                        }
                    } else if (cNumExplicitSubstStrings < ARRAY_SIZE(rgInsertParams)) {
                        for (iInsertType = 0;
                             iInsertType < ARRAY_SIZE(rgInsertTypes);
                             iInsertType++) {
                            if (0 == _wcsnicmp(rgInsertTypes[iInsertType].pszKey, &argv[iArg][1], cchKey)) {
                                err = InsertParamFromString(rgInsertTypes[iInsertType].eInsertMacro,
                                                            pszValue,
                                                            &ppBuffersToFree,
                                                            &rgInsertParams[cNumExplicitSubstStrings++]);
                                break;
                            }
                        }

                        if (iInsertType == ARRAY_SIZE(rgInsertTypes)) {
                            printf("Unknown option, \"%ls\".\n", argv[iArg]);
                            err = ERROR_INVALID_PARAMETER;
                        }

                        if (err) {
                            __leave;
                        }
                    } else {
                        printf("Unknown option, \"%ls\".\n", argv[iArg]);
                        err = ERROR_INVALID_PARAMETER;
                        __leave;
                    }
                }
            } else if (0 == dwMsgNum) {
                dwMsgNum = wcstoul(argv[iArg], NULL, 0);
                
                if (0 == dwMsgNum) {
                    printf("Invalid message ID, \"%ls\".\n", argv[iArg]);
                    err = ERROR_INVALID_PARAMETER;
                    __leave;
                }
            } else if (cNumExplicitSubstStrings < ARRAY_SIZE(rgInsertParams)) {
                Assert(INSERT_MACRO_WC == rgInsertParams[cNumExplicitSubstStrings].InsertType);
                rgInsertParams[cNumExplicitSubstStrings++].tmpDword = (ULONG_PTR) argv[iArg];
            } else {
                printf("Unknown argument, \"%ls\".\n", argv[iArg]);
                err = ERROR_INVALID_PARAMETER;
                __leave;
            }
        }
        
        Assert(0 == err);

        if (fPrintUsage) {
            printf("Generates DS event to event log and the console.\n"
                   "\n"
                   "Usage: %ls [/cat:category] [/src:source] msgnum\n"
                   "       [[/syntax:]subst1 [[/syntax:]subst2 [...]]]\n"
                   "\n"
                   "/cat    Specifies a category under which to log the event; defaults to\n"
                   "        Directory Access.\n"
                   "\n"
                   "/src    Specifies a source under which to log the event; defaults to\n"
                   "        NTDS General.\n"
                   "\n"
                   "msgnum  Event number in decimal or hex (if prefixed with \"0x\").\n"
                   "\n"
                   "substN  Substitution string for event; defaults to \"[SubstN]\".\n"
                   "        May be prefixed by one of the syntaxes below, which will be decoded\n"
                   "        from its string representation and then re-encoded using the DS event\n"
                   "        logging infrastructure.  E.g., /Win32Msg:5 would be logged as\n"
                   "        \"Access denied.\"  If no syntax is specified, /WC: is assumed.\n",
                   argv[0]);

            printf("\nValid categories are:\n");
            for (iCat = 0; iCat < ARRAY_SIZE(rgCategories); iCat++) {
                printf("\t%ls\n", rgCategories[iCat].pszCategory);
            }

            printf("\nValid sources are:\n");
            for (iSrc = 0; iSrc < ARRAY_SIZE(rgSources); iSrc++) {
                printf("\t%ls\n", rgSources[iSrc].pszSource);
            }
            
            printf("\nValid syntaxes are:\n");
            for (iInsertType = 0;
                 iInsertType < ARRAY_SIZE(rgInsertTypes);
                 iInsertType++) {
                printf("\t/%-15ls  %ls\n",
                       rgInsertTypes[iInsertType].pszKey,
                       rgInsertTypes[iInsertType].pszDescription);
            }

            printf("\n");
            __leave;
        }

        if (0 == dwMsgNum) {
            printf("No message number given.\n");
            err = ERROR_INVALID_PARAMETER;
            __leave;
        }

        err = AddHighBitsToNtdsMsgNum(&dwMsgNum);
        if (err) {
            __leave;
        }

        hevtLoggingLevelChange = LoadEventTable();

        LogEvent8WithFileNo(dwCategory,
                            DS_EVENT_SEV_ALWAYS,
                            dwMsgNum,
                            szInsertType(&rgInsertParams[0]),
                            szInsertType(&rgInsertParams[1]),
                            szInsertType(&rgInsertParams[2]),
                            szInsertType(&rgInsertParams[3]),
                            szInsertType(&rgInsertParams[4]),
                            szInsertType(&rgInsertParams[5]),
                            szInsertType(&rgInsertParams[6]),
                            szInsertType(&rgInsertParams[7]),
                            dwFileNo);
        printf("\n");
    } __finally {
        for (iBuffer = 0; &rgpBuffersToFree[iBuffer] < ppBuffersToFree; iBuffer++) {
            free(rgpBuffersToFree[iBuffer]);
        }

        if (NULL != hevtLoggingLevelChange) {
            // Event closed by UnloadEventTable() (along with other cleanup).
            UnloadEventTable();
        }

        if (NULL != g_hmodNtdsMsg) {
            FreeLibrary(g_hmodNtdsMsg);
        }

        DEBUGTERM();
    }
    
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\iislib\stktrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.h

Abstract:

    This module contains public declarations and definitions for capturing
    stack back traces.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _STKTRACE_H_
#define _STKTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _STKTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\dsevent\dsevent.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsevent.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>
#include <dsevent.h>
#include <dsconfig.h>
#include <mdcodes.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <fileno.h>
#include <drserr.h>
#include <dstrace.h>
#include <debug.h>
#include <dsatools.h>
#include <dsutil.h>
#include <esent.h>

#define  FILENO FILENO_DSEVENT
#define DEBSUB "DSEVENT:"

// Buffer size required to hold an arbitrary stringized base-10 USN value.
// 0xFFFF FFFF FFFF FFFF = 18446744073709551615 = 20 chars + '\0'
#define SZUSN_LEN (24)

// Convenient macro to get array size from bytecount
#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))

DWORD  RaiseAlert(char *szMsg);
DWORD  RaiseAlertW(WCHAR *szMsg);

HANDLE ghMsgFile = NULL;

// Dummy string to insert when the proposed insertion string cannot be
// determined (e.g., failed to read from message file) or represented (e.g.,
// a NULL string).
// ISSUE: Might be good if these were in mdcodes so different dummy strings
// could be used for different languages.
WCHAR gwszDummyString[] = L"[]";
CHAR  gaszDummyString[] =  "[]";

// Note, if you update this table, please also update the table of registry
// keys which gets written during installation.  This is found at
// ds\src\ntdsetup\config.c

DS_EVENT_CONFIG DsEventConfig = {
    FALSE,          // fTraceEvents
    FALSE,          // fLogOverride

    // rgEventCategories
    {
        {KCC_CATEGORY,                      0, KCC_KEY},                    // 0
        {SECURITY_CATEGORY,                 0, SECURITY_KEY},               // 1
        {XDS_INTERFACE_CATEGORY,            0, XDS_INTERFACE_KEY},          // 2
        {MAPI_CATEGORY,                     0, MAPI_KEY},                   // 3
        {REPLICATION_CATEGORY,              0, REPLICATION_KEY},            // 4
        {GARBAGE_COLLECTION_CATEGORY,       0, GARBAGE_COLLECTION_KEY},     // 5
        {INTERNAL_CONFIGURATION_CATEGORY,   0, INTERNAL_CONFIGURATION_KEY}, // 6
        {DIRECTORY_ACCESS_CATEGORY,         0, DIRECTORY_ACCESS_KEY},       // 7
        {INTERNAL_PROCESSING_CATEGORY,      0, INTERNAL_PROCESSING_KEY},    // 8
        {PERFORMANCE_CATEGORY,              0, PERFORMANCE_KEY},            // 9
        {STARTUP_SHUTDOWN_CATEGORY,         0, STARTUP_SHUTDOWN_KEY},       // 10
        {SERVICE_CONTROL_CATEGORY,          0, SERVICE_CONTROL_KEY},        // 11
        {NAME_RESOLUTION_CATEGORY,          0, NAME_RESOLUTION_KEY},        // 12
        {BACKUP_CATEGORY,                   0, BACKUP_KEY},                 // 13
        {FIELD_ENGINEERING_CATEGORY,        0, FIELD_ENGINEERING_KEY},      // 14
        {LDAP_INTERFACE_CATEGORY ,          0, LDAP_INTERFACE_KEY },        // 15
        {SETUP_CATEGORY ,                   0, SETUP_KEY },                 // 16
        {GC_CATEGORY ,                      0, GC_KEY },                    // 17
        {ISM_CATEGORY,                      0, ISM_KEY },                   // 18
        {GROUP_CACHING_CATEGORY,            0, GROUP_CACHING_KEY },         // 19
        {LVR_CATEGORY,                      0, LVR_KEY },                   // 20
        {DS_RPC_CLIENT_CATEGORY,            0, DS_RPC_CLIENT_KEY },         // 21
        {DS_RPC_SERVER_CATEGORY,            0, DS_RPC_SERVER_KEY },         // 22
        {DS_SCHEMA_CATEGORY,                0, DS_SCHEMA_KEY }              // 23
    }
};

DS_EVENT_CONFIG * gpDsEventConfig = &DsEventConfig;

EventSourceMapping rEventSourceMappings[] =
{
    // Any DIRNO_* not listed here will map to NTDS_SOURCE_GENERAL.
    // See pszEventSourceFromFileNo().  NTDS_SOURCE_* are not
    // internationalized.

    DIRNO_DRA,      pszNtdsSourceReplication,
    DIRNO_DBLAYER,  pszNtdsSourceDatabase,
    DIRNO_SRC,      pszNtdsSourceGeneral,
    DIRNO_NSPIS,    pszNtdsSourceMapi,
    DIRNO_DRS,      pszNtdsSourceReplication,
    DIRNO_XDS,      pszNtdsSourceXds,
    DIRNO_PERMIT,   pszNtdsSourceSecurity,
    DIRNO_LIBXDS,   pszNtdsSourceXds,
    DIRNO_SAM,      pszNtdsSourceSam,
    DIRNO_LDAP,     pszNtdsSourceLdap,
    DIRNO_SDPROP,   pszNtdsSourceSdprop,
    DIRNO_KCC,      pszNtdsSourceKcc,
    DIRNO_ISAM,     pszNtdsSourceIsam,
    DIRNO_ISMSERV,  pszNtdsSourceIsm,
    DIRNO_NTDSETUP, pszNtdsSourceSetup
};

DWORD cEventSourceMappings = sizeof(rEventSourceMappings) /
                                        sizeof(rEventSourceMappings[0]);
DWORD iDefaultEventSource = 2;  // DIRNO_SRC / NTDS_SOURCE_GENERAL

DWORD *pdwLogOverrides = NULL;
DWORD cdwLogOverrides = 0;
#define MAX_LOG_OVERRIDES 128

CHAR *
pszEventSourceFromFileNo(
    DWORD   fileNo)
{
    DWORD       i, dirNo;
    static  CHAR netEventSource[] = "EventLog";

    // rEventSourceMappings contains DIRNO_*'s which are already left shifted
    // by 8, so we can just mask out the noise bits from the FILENO_*.

    dirNo = fileNo & 0x0000ff00;

    //
    // If we get this, this means that eventlogging is hosed.
    //

    if ( dirNo == DIRNO_NETEVENT ) {
        return netEventSource;
    }

    for ( i = 0; i < cEventSourceMappings; i++ )
    {
        if ( dirNo == rEventSourceMappings[i].dirNo )
        {
            return(rEventSourceMappings[i].pszEventSource);
        }
    }

    return(rEventSourceMappings[iDefaultEventSource].pszEventSource);
}

void __fastcall DoLogUnhandledError(unsigned long ulID, int iErr, int iIncludeName)
{
    char szErr[12];
    char szHexErr[12];
    char szID[9];

    DPRINT3(0,"Unhandled error %d (0x%X) with DSID %X\n", iErr, iErr, ulID);

    _itoa(iErr, szErr, 10);
    _itoa(iErr, szHexErr, 16);
    _ultoa(ulID, szID, 16);
    DoLogEvent(ulID >> 16,
           DsEventConfig.rgEventCategories[DS_EVENT_CAT_INTERNAL_PROCESSING].midCategory,
           DS_EVENT_SEV_ALWAYS,
           DIRLOG_INTERNAL_FAILURE,
           iIncludeName,
           szErr, szHexErr, szID, NULL, NULL, NULL,
           NULL, NULL, 0, NULL);
}

BOOL
DoLogOverride(
        DWORD fileno,
        ULONG sev
        )
{
    DWORD dwTemp, i;
    Assert(DsEventConfig.fLogOverride);

    // make the fileno look like a DSID number, which is the format stored in
    // the overrides.
    fileno = (fileno << 16);

    // Look through our list of overrides.
    for(i=0;i<cdwLogOverrides;i++) {
        Assert(cdwLogOverrides <= MAX_LOG_OVERRIDES);
        Assert(pdwLogOverrides);
        // First, get the directory of the file passed in.
        if((pdwLogOverrides[i] & 0xFF000000) != (fileno & 0xFF000000)) {
            // Not the same directory.
            return FALSE;
        }

        if(((pdwLogOverrides[i] & 0x00FF0000) != 0x00FF0000) &&
           ((pdwLogOverrides[i] & 0x00FF0000) != (fileno & 0x00FF0000))) {
            // Not doing all files and not the correct file
            return FALSE;
        }

        // OK, this file qualifies

        return (sev <= (pdwLogOverrides[i] & 0x0000FFFF));
    }

    return FALSE;
}

BOOL
DoLogEvent(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, int iIncludeName,
    char *arg1, char *arg2, char *arg3, char *arg4,
    char *arg5, char *arg6, char *arg7, char *arg8,
    DWORD cbData, VOID * pvData)
{
    char        *rgszInserts[8] = {NULL, NULL, NULL, NULL, NULL,
                                            NULL, NULL, NULL};
    WORD        cInserts =  0;
    HANDLE      hEventSource;
    BYTE        *pbSid = NULL;
    BOOL        fStatus = FALSE;
    WORD        eventType;

    if (ulSeverity > 5) { /* only five levels of severity */
        return FALSE;
    }

    // set up inserts

    if (arg1) rgszInserts[cInserts++] = arg1;
    if (arg2) rgszInserts[cInserts++] = arg2;
    if (arg3) rgszInserts[cInserts++] = arg3;
    if (arg4) rgszInserts[cInserts++] = arg4;
    if (arg5) rgszInserts[cInserts++] = arg5;
    if (arg6) rgszInserts[cInserts++] = arg6;
    if (arg7) rgszInserts[cInserts++] = arg7;
    if (arg8) rgszInserts[cInserts++] = arg8;

    switch((midEvent >> 30) & 0xFF) {
    case DIR_ETYPE_SECURITY:
        eventType = EVENTLOG_AUDIT_FAILURE;
        break;

    case DIR_ETYPE_WARNING:
        eventType = EVENTLOG_WARNING_TYPE;
        break;

    case DIR_ETYPE_INFORMATIONAL:
        eventType = EVENTLOG_INFORMATION_TYPE;
        break;

    case DIR_ETYPE_ERROR:
    default:
        eventType = EVENTLOG_ERROR_TYPE;
        break;
    }

    //
    // Log the event
    //

    hEventSource = RegisterEventSource(NULL,
                                       pszEventSourceFromFileNo(fileNo));

    if ( hEventSource != NULL ) {

         if (!ReportEvent(
                        hEventSource,
                        eventType,
                        (WORD) midCategory,
                        (DWORD) midEvent,
                        (pbSid = (iIncludeName)?GetCurrentUserSid():0),
                        cInserts,
                        cbData,
                        rgszInserts,
                        pvData) ) {

            DPRINT1(0,"Error %d in ReportEvent\n",GetLastError());

        } else {
            fStatus = TRUE;
        }

        DeregisterEventSource(hEventSource);
    } else {
        DPRINT1(0,"Error %d in RegisterEventSource\n",GetLastError());
    }

    if (pbSid) {
        free(pbSid);
    }

    return fStatus;
}

BOOL
DoLogEventW(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, int iIncludeName,
    WCHAR *arg1, WCHAR *arg2, WCHAR *arg3, WCHAR *arg4,
    WCHAR *arg5, WCHAR *arg6, WCHAR *arg7, WCHAR *arg8,
    DWORD cbData, VOID * pvData)
{
    WCHAR        *rgszInserts[8] = {NULL, NULL, NULL, NULL, NULL,
                                            NULL, NULL, NULL};
    WORD        cInserts =  0;
    HANDLE      hEventSource;
    BYTE        *pbSid = NULL;
    BOOL        fStatus = FALSE;
    WORD        eventType;

    if (ulSeverity > 5) { /* only five levels of severity */
        return FALSE;
    }

    // set up inserts

    if (arg1) rgszInserts[cInserts++] = arg1;
    if (arg2) rgszInserts[cInserts++] = arg2;
    if (arg3) rgszInserts[cInserts++] = arg3;
    if (arg4) rgszInserts[cInserts++] = arg4;
    if (arg5) rgszInserts[cInserts++] = arg5;
    if (arg6) rgszInserts[cInserts++] = arg6;
    if (arg7) rgszInserts[cInserts++] = arg7;
    if (arg8) rgszInserts[cInserts++] = arg8;

    switch((midEvent >> 30) & 0xFF) {
    case DIR_ETYPE_SECURITY:
        eventType = EVENTLOG_AUDIT_FAILURE;
        break;

    case DIR_ETYPE_WARNING:
        eventType = EVENTLOG_WARNING_TYPE;
        break;

    case DIR_ETYPE_INFORMATIONAL:
        eventType = EVENTLOG_INFORMATION_TYPE;
        break;

    case DIR_ETYPE_ERROR:
    default:
        eventType = EVENTLOG_ERROR_TYPE;
        break;
    }

    //
    // Log the event
    //

    hEventSource = RegisterEventSource(NULL,
                                       pszEventSourceFromFileNo(fileNo));

    if ( hEventSource != NULL ) {

         if (!ReportEventW(
                        hEventSource,
                        eventType,
                        (WORD) midCategory,
                        (DWORD) midEvent,
                        (pbSid = (iIncludeName)?GetCurrentUserSid():0),
                        cInserts,
                        cbData,
                        rgszInserts,
                        pvData) ) {

            DPRINT1(0,"Error %d in ReportEvent\n",GetLastError());

        } else {
            fStatus = TRUE;
        }

        DeregisterEventSource(hEventSource);
    } else {
        DPRINT1(0,"Error %d in RegisterEventSource\n",GetLastError());
    }

    if (pbSid) {
        free(pbSid);
    }

    return fStatus;
}

#if DBG
void
DoDPrintEvent(
    IN  DWORD       fileNo,
    IN  MessageId   midCategory,
    IN  ULONG       ulSeverity,
    IN  MessageId   midEvent,
    IN  int         iIncludeName,
    IN  LPWSTR      arg1,
    IN  LPWSTR      arg2,
    IN  LPWSTR      arg3,
    IN  LPWSTR      arg4,
    IN  LPWSTR      arg5,
    IN  LPWSTR      arg6,
    IN  LPWSTR      arg7,
    IN  LPWSTR      arg8
    )
{
    LPWSTR  rgszInserts[8] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
    DWORD   cInserts =  0;
    DWORD   eventType;
    DWORD   cch;
    LPWSTR  pszMessage = NULL;
    LPSTR   pszSeverity = NULL;
    LPWSTR  pszCategory = NULL;

    // set up inserts

    if (arg1) rgszInserts[cInserts++] = arg1;
    if (arg2) rgszInserts[cInserts++] = arg2;
    if (arg3) rgszInserts[cInserts++] = arg3;
    if (arg4) rgszInserts[cInserts++] = arg4;
    if (arg5) rgszInserts[cInserts++] = arg5;
    if (arg6) rgszInserts[cInserts++] = arg6;
    if (arg7) rgszInserts[cInserts++] = arg7;
    if (arg8) rgszInserts[cInserts++] = arg8;

    switch((midEvent >> 30) & 0xFF) {
    case DIR_ETYPE_SECURITY:
        pszSeverity = "Audit Failure";
        break;

    case DIR_ETYPE_WARNING:
        pszSeverity = "Warning";
        break;

    case DIR_ETYPE_INFORMATIONAL:
        pszSeverity = "Informational";
        break;

    case DIR_ETYPE_ERROR:
    default:
        pszSeverity = "Error";
        break;
    }

    // Get category name.
    cch = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE
                          | FORMAT_MESSAGE_ALLOCATE_BUFFER
                          | FORMAT_MESSAGE_IGNORE_INSERTS,
                         ghMsgFile,
                         midCategory,
                         0,
                         (LPWSTR) &pszCategory,
                         0,
                         NULL);
    if (0 == cch) {
        DPRINT1(0, "Failed to read category, error %d.\n", GetLastError());
        Assert(NULL == pszCategory);
    } else {
        cch = wcslen(pszCategory);
        if ((cch > 2)
            && (L'\r' == pszCategory[cch-2])
            && (L'\n' == pszCategory[cch-1])) {
            pszCategory[cch-2] = L'\0';
        }
    }
    
    // Get message text (w/ inserts).
    cch = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE
                          | FORMAT_MESSAGE_ALLOCATE_BUFFER
                          | FORMAT_MESSAGE_ARGUMENT_ARRAY
                          | 80,   // line width
                         ghMsgFile,
                         midEvent,
                         0,
                         (LPWSTR) &pszMessage,
                         0,
                         (va_list *) rgszInserts);
    if (0 == cch) {
        DPRINT1(0, "Failed to read message, error %d.\n", GetLastError());
        Assert(NULL == pszMessage);
    }

    DPRINT4(0, "EVENTLOG (%s): %s / %ls:\n%ls\n\n",
            pszSeverity,
            pszEventSourceFromFileNo(fileNo),
            pszCategory ? pszCategory : L"(Failed to read event category.)",
            pszMessage ? pszMessage : L"Failed to read event text.\n");

    if (pszCategory) {
        LocalFree(pszCategory);
    }

    if (pszMessage) {
        LocalFree(pszMessage);
    }
}
#endif

BOOL
DoAlertEvent(MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, ...)
{
    va_list     args;
    WORD    cMessageInserts =  0;
    char    szMessage[256];
    char    szCategory[256];
    char    szAlertText[1024];
    char    szSeverity[10];

    char    *rgszAlertInserts[3] = {szSeverity, szCategory, szMessage};

    // set up inserts

    va_start(args, midEvent);

    _ultoa(ulSeverity, szSeverity, 10);

    if (FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        (LPVOID) ghMsgFile,
        (DWORD) midEvent,
            0,
        szMessage,
        sizeof(szMessage),
        &args)      &&
    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        (LPVOID) ghMsgFile,
        (DWORD) midCategory,
            0,
        szCategory,
        sizeof(szCategory),
        NULL)           &&
    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        (LPVOID) ghMsgFile,
        (DWORD) ALERT_TEMPLATE,
            0,
        szAlertText,
        sizeof(szAlertText),
        (va_list *)rgszAlertInserts))
    {
        va_end(args);
        RaiseAlert(szAlertText);
        return TRUE;
    }

    va_end(args);
    return FALSE;
}

BOOL
DoAlertEventW(MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, ...)
{
    va_list     args;
    WORD    cMessageInserts =  0;
    WCHAR    szMessage[256];
    WCHAR    szCategory[256];
    WCHAR    szAlertText[1024];
    WCHAR    szSeverity[10];

    WCHAR    *rgszAlertInserts[3] = {szSeverity, szCategory, szMessage};

    // set up inserts

    va_start(args, midEvent);

    _ultow(ulSeverity, szSeverity, 10);

    if (FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE,
        (LPVOID) ghMsgFile,
        (DWORD) midEvent,
            0,
        szMessage,
        ARRAY_SIZE(szMessage),
        &args)      &&
    FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE,
        (LPVOID) ghMsgFile,
        (DWORD) midCategory,
            0,
        szCategory,
        ARRAY_SIZE(szCategory),
        NULL)           &&
    FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        (LPVOID) ghMsgFile,
        (DWORD) ALERT_TEMPLATE,
            0,
        szAlertText,
        ARRAY_SIZE(szAlertText),
        (va_list *)rgszAlertInserts))
    {
        va_end(args);
        RaiseAlertW(szAlertText);
        return TRUE;
    }

    va_end(args);
    return FALSE;
}

HKEY   ghkLoggingKey = NULL;
HANDLE ghevLoggingChange = NULL;

VOID
RegisterLogOverrides (
        )
{
    LPBYTE pLogOverrideBuff = NULL;
    DWORD i, j, index;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    DWORD err;


    Assert(ghkLoggingKey);

    // Free up any log overrides we have.
    cdwLogOverrides = 0;
    DsEventConfig.fLogOverride = FALSE;


    if(RegQueryValueEx(ghkLoggingKey,
                       LOGGING_OVERRIDE_KEY,
                       NULL,
                       &dwType,
                       pLogOverrideBuff,
                       &dwSize)) {
        // No overrides in the registry.
        return;
    }

    // The value for this key should be repeated groups of 9 bytes, with bytes
    // 1-8 being hex characters and byte 9 being a NULL (at least one group must
    // be present).  Also, there should be a final NULL.  Verify this.

    if(((dwSize - 1) % 9) ||
       (dwSize < 9)          )        {
        // Size is wrong.  This isn't going to work.
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_BAD_CHAR_COUNT_FOR_LOG_OVERRIDES,
                 NULL,
                 NULL,
                 NULL);
        return;
    }

    if(dwType != REG_MULTI_SZ) {
        // Uh, this isn't going to work either.
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_BAD_CHAR_COUNT_FOR_LOG_OVERRIDES,
                 NULL,
                 NULL,
                 NULL);
        return;
    }

    // OK, get the value.
    pLogOverrideBuff = malloc(dwSize);
    if(!pLogOverrideBuff) {
        // Oops.
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_NO_MEMORY_FOR_LOG_OVERRIDES,
                 szInsertUL(dwSize),
                 NULL,
                 NULL);
        return;
    }

    err = RegQueryValueEx(ghkLoggingKey,
                          LOGGING_OVERRIDE_KEY,
                          NULL,
                          &dwType,
                          pLogOverrideBuff,
                          &dwSize);
    if(err) {
        LogUnhandledError(err);
        free(pLogOverrideBuff);
        return;
    }

    Assert(dwType == REG_MULTI_SZ);
    Assert((dwSize > 9) && !((dwSize - 1) % 9));
    Assert(!pLogOverrideBuff[dwSize - 1]);

    // Ignore the NULL on the very end of the string.
    dwSize--;


    // Parse the buffer for log overrides.
    Assert(!cdwLogOverrides);
    if(!pdwLogOverrides) {
        pdwLogOverrides = malloc(MAX_LOG_OVERRIDES * sizeof(DWORD));
        if(!pdwLogOverrides) {
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_NO_MEMORY_FOR_LOG_OVERRIDES,
                     szInsertUL(MAX_LOG_OVERRIDES * sizeof(DWORD)),
                     NULL,
                     NULL);
            free(pLogOverrideBuff);
            return;
        }
    }


    index = 0;
    for(i=0;i<dwSize;(i += 9)) {
        PCHAR pTemp = &pLogOverrideBuff[i];

        if(index == MAX_LOG_OVERRIDES) {
            // We've done as many as we will do, but there's more buffer.
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_TOO_MANY_OVERRIDES,
                     szInsertUL(MAX_LOG_OVERRIDES),
                     NULL,
                     NULL);
            i = dwSize;
            continue;
        }

        for(j=0;j<8;j++) {
            if(!isxdigit(pTemp[j])) {
                // Invalidly formatted string.  Bail
                Assert(!cdwLogOverrides);
                free(pLogOverrideBuff);
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_BAD_CHAR_FOR_LOG_OVERRIDES,
                         szInsertUL(j),
                         szInsertUL(index),
                         NULL);
                return;
            }
        }
        if(pTemp[8]) {
            free(pLogOverrideBuff);
            Assert(!cdwLogOverrides);
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BAD_CHAR_FOR_LOG_OVERRIDES,
                     szInsertUL(8),
                     szInsertUL(index),
                     NULL);
            return;
        }

        pdwLogOverrides[index] = strtol(&pLogOverrideBuff[i], NULL, 16);
        index++;
    }

    free(pLogOverrideBuff);

    Assert(index);
    Assert(pdwLogOverrides);
    // OK, correctly parsed through everything.
    cdwLogOverrides = index;
    DsEventConfig.fLogOverride = TRUE;
    return;
}



void
UnloadEventTable(void)
{
    if (ghkLoggingKey) {
        RegCloseKey(ghkLoggingKey);
        ghkLoggingKey = NULL;
    }
    if (ghevLoggingChange) {
        CloseHandle(ghevLoggingChange);
        ghevLoggingChange = NULL;
    }
}

HANDLE
LoadEventTable(void)
{
    DWORD dwType, dwSize;
    ULONG i;
    LONG lErr;

    if ( !ghMsgFile ) {
        ghMsgFile = LoadLibrary(DSA_MESSAGE_DLL);

        if ( !ghMsgFile ) {
            DPRINT2(0,"LoadLibrary %s failed with %d\n", DSA_MESSAGE_DLL, GetLastError());
            return(NULL);
        }
    }

    if (!ghevLoggingChange) {
        ghevLoggingChange = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( ghevLoggingChange == NULL ) {
            DPRINT1(0,"CreateEvent failed with %d\n",GetLastError());
        }
    }
    
    if (!ghkLoggingKey
        && (lErr = RegOpenKey(HKEY_LOCAL_MACHINE,
                              DSA_EVENT_SECTION,
                              &ghkLoggingKey))) {
        DPRINT2(0,"Cannot open %s. Error %d\n", DSA_EVENT_SECTION, lErr);
    }

    if (NULL != ghkLoggingKey) {
        for (i=0; i<DS_EVENT_MAX_CATEGORIES; i++) {
            if ( DsEventConfig.rgEventCategories[i].szRegistryKey ) {
                dwSize = sizeof(DsEventConfig.rgEventCategories[i].ulLevel);
    
                lErr = RegQueryValueEx(
                            ghkLoggingKey,
                            DsEventConfig.rgEventCategories[i].szRegistryKey,
                            NULL,
                            &dwType,
                            (LPBYTE) &(DsEventConfig.rgEventCategories[i].ulLevel),
                            &dwSize);
                if ( lErr != ERROR_SUCCESS ) {
                    //
                    // Maybe it isn't there at all.
                    // Lets try to create it.
                    //
                    DWORD dwVal = 0;
                    (void)RegSetValueEx(
                            ghkLoggingKey,
                            DsEventConfig.rgEventCategories[i].szRegistryKey,
                            0,          // reserved
                            REG_DWORD,
                            (CONST BYTE*) &dwVal,
                            sizeof(dwVal));
                }
            }
        }
    
        // Now, the logging overrides.
        RegisterLogOverrides();
    
        RegNotifyChangeKeyValue(ghkLoggingKey,
                                TRUE,
                                (   REG_NOTIFY_CHANGE_NAME
                                 | REG_NOTIFY_CHANGE_ATTRIBUTES
                                 | REG_NOTIFY_CHANGE_LAST_SET
                                 ),
                                ghevLoggingChange,
                                TRUE
                                );
    }

    return ghevLoggingChange;
}


LoadParametersCallbackFn pLoadParamFn = NULL;
HKEY   ghkParameterKey = NULL;
HANDLE ghevParameterChange = NULL;

void SetLoadParametersCallback (LoadParametersCallbackFn pFn)
{
    pLoadParamFn = pFn;
}

void UnloadParametersTable(void)
{
    if (ghkLoggingKey) {
        RegCloseKey(ghkLoggingKey);
        ghkLoggingKey = NULL;
    }
    if (ghevParameterChange) {
        CloseHandle(ghevParameterChange);
        ghevParameterChange = NULL;
    }
}


HANDLE LoadParametersTable(void)
{
    DWORD dwType, dwSize;
    ULONG i;
    LONG lErr;

    if (!ghkParameterKey
        && RegOpenKey(HKEY_LOCAL_MACHINE,
                      DSA_CONFIG_SECTION,
                      &ghkParameterKey)) {
        DPRINT2(0,"Cannot open %s. Error %d\n", DSA_EVENT_SECTION, GetLastError());
        return NULL;
    }

    if (pLoadParamFn) {
        (pLoadParamFn)();
    }

    if (!ghevParameterChange) {
        ghevParameterChange = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( ghevParameterChange == NULL ) {
            DPRINT1(0,"CreateEvent failed with %d\n",GetLastError());
        }
    }

    RegNotifyChangeKeyValue(ghkParameterKey,
                            TRUE,
                            (   REG_NOTIFY_CHANGE_NAME
                             | REG_NOTIFY_CHANGE_ATTRIBUTES
                             | REG_NOTIFY_CHANGE_LAST_SET
                             ),
                            ghevParameterChange,
                            TRUE
                            );

    return ghevParameterChange;
}


PSID GetCurrentUserSid()
{
    TOKEN_USER      *ptoken_user = NULL;
    DWORD       dwSize;
    HANDLE      hClientToken = INVALID_HANDLE_VALUE;
    PSID        pSid = NULL;
    DWORD       dwError;

    dwError = ImpersonateAnyClient();

    if (dwError)
        return NULL;

    if (OpenThreadToken(            // Get thread token
        GetCurrentThread(),
        TOKEN_READ,
        TRUE,
        &hClientToken)      &&
    !GetTokenInformation(           // Get size of buffer
        hClientToken,
        TokenUser,
        (LPVOID) NULL,
        0,
        &dwSize)        &&
    (ptoken_user =
        (TOKEN_USER *) LocalAlloc(LPTR,dwSize))     &&
    GetTokenInformation(            // Get user sid
        hClientToken,
        TokenUser,
        (LPVOID) (ptoken_user),
        dwSize,
        &dwSize))
    {
        dwSize = GetLengthSid(ptoken_user->User.Sid);
        if (pSid = (PSID) malloc(dwSize))
            memcpy(pSid, ptoken_user->User.Sid, dwSize);

    }

    if ( INVALID_HANDLE_VALUE != hClientToken )
    {
        CloseHandle(hClientToken);
    }

    UnImpersonateAnyClient();

    if ( ptoken_user != NULL ) {
        LocalFree(ptoken_user);
    }

    return pSid;
}


#define MAX_DS_MSG_STRING   128
#define DSEVENT_MAX_ALLOCS_TO_FREE (8)

typedef LPSTR FN_TH_GET_ERROR_STRING();
typedef void FN_TH_FREE(void *);

VOID
InsertThStateError(
    IN OUT  LPWSTR *    ppszPreAllocatedBuffer,
    IN OUT  DWORD *     pcNumPointersToLocalFree,
    OUT     VOID **     ppPointersToLocalFree,
    OUT     LPWSTR *    ppszInsertionString
    )
/*++

Routine Description:

    Insert the error associated with the current thread state as an insertion
    parameter in an event log entry.

Arguments:

    ppszPreAllocatedBuffer (IN/OUT) - Pointer to pre-allocated buffer to hold
        insertion string.  Buffer must be at least MAX_DS_MSG_STRING
        *characters* long.
    
    pcNumPointersToLocalFree (IN/OUT) - If retrieved message is longer than
        MAX_DS_MSG_STRING (i.e., is too long to fit into pre-allocated buffer),
        on return is incremented.  Otherwise unchanged.
    
    ppPointersToLocalFree (OUT) - If retrieved message is longer than
        MAX_DS_MSG_STRING (i.e., is too long to fit into pre-allocated buffer),
        on return holds a pointer to the message string that must be
        LocalFree()'d when the message is no longer needed.  Otherwise
        unchanged.
    
    ppszInsertionString (OUT) - On return, holds a pointer to the corresponding
        message string (or the dummy string, if the message text could not be
        retrieved).

Return Values:

    None.

--*/
{
    static FN_TH_GET_ERROR_STRING *s_pfnTHGetErrorString = NULL;
    static FN_TH_FREE *s_pfnTHFree = NULL;
    
    LPSTR pszError;
    DWORD cch = 0;

    if ((NULL == s_pfnTHGetErrorString)
        || (NULL == s_pfnTHFree)) {
        // We assume that ntdsa.dll is already loaded by this process, and
        // that we simply need to get a handle to the existing image of the
        // DLL in our address space.  This frees us from having to perform
        // the ref-counted LoadLibrary() and calling FreeLibrary() later.
        HMODULE hNtDsaDll = GetModuleHandle("ntdsa.dll");
        Assert((NULL != hNtDsaDll)
               && "Must statically link to ntdsa.dll to szInsertThStateErrMsg()!");
        
        s_pfnTHGetErrorString
            = (FN_TH_GET_ERROR_STRING *)
                    GetProcAddress(hNtDsaDll, "THGetErrorString");
        s_pfnTHFree
            = (FN_TH_FREE *)
                    GetProcAddress(hNtDsaDll, "THFree");
    }

    if ((NULL != s_pfnTHGetErrorString)
        && (NULL != s_pfnTHFree)) {
        
        pszError = (*s_pfnTHGetErrorString)();

        if (NULL != pszError) {
            cch = MultiByteToWideChar(CP_ACP,
                                      0,
                                      pszError,
                                      -1,
                                      NULL,
                                      0);
            if (cch <= MAX_DS_MSG_STRING) {
                // String will fit in pre-allocated buffer.
                cch = MultiByteToWideChar(CP_ACP,
                                          0,
                                          pszError,
                                          -1,
                                          *ppszPreAllocatedBuffer,
                                          MAX_DS_MSG_STRING);
                
                if (0 != cch) {
                    // Success -- error string placed in pre-allocated buffer.
                    *ppszInsertionString = *ppszPreAllocatedBuffer;
                    *ppszPreAllocatedBuffer += 1 + wcslen(*ppszPreAllocatedBuffer);
                }
            } else {
                LPWSTR pszLocalAllocedBuffer;

                pszLocalAllocedBuffer = LocalAlloc(LPTR, cch * sizeof(WCHAR));
                if (NULL == pszLocalAllocedBuffer) {
                    // No memory.
                    cch = 0;
                } else {
                    cch = MultiByteToWideChar(CP_ACP,
                                              0,
                                              pszError,
                                              -1,
                                              pszLocalAllocedBuffer,
                                              cch);
    
                    if (0 != cch) {
                        // Success -- error string placed in LocalAlloc()'ed buffer.
                        *ppszInsertionString = pszLocalAllocedBuffer;
            
                        Assert(*pcNumPointersToLocalFree < DSEVENT_MAX_ALLOCS_TO_FREE);
                        ppPointersToLocalFree[(*pcNumPointersToLocalFree)++] = pszLocalAllocedBuffer;
                    } else {
                        // Failed to convert string -- why?
                        DPRINT2(0, "Failed to convert TH error string \"%s\", error %d.\n",
                                pszError, GetLastError());
                        Assert(!"Failed to convert TH error string!");
                        LocalFree(pszLocalAllocedBuffer);
                    }
                }
            }

            (*s_pfnTHFree)(pszError);
        }
    }
    
    if (0 == cch) {
        // Failed to read/convert error string.  Insert dummy string.
        *ppszInsertionString = gwszDummyString;
    }
}

VOID
InsertMsgString(
    IN      HMODULE     hMsgFile        OPTIONAL,
    IN      DWORD       dwMsgNum,
    IN OUT  LPWSTR *    ppszPreAllocatedBuffer,
    IN OUT  DWORD *     pcNumPointersToLocalFree,
    OUT     VOID **     ppPointersToLocalFree,
    OUT     LPWSTR *    ppszInsertionString
    )
/*++

Routine Description:

    Reads a message string (correpsonding to e.g. a Win32 error or DS DIRLOG
    code) to be used as an insertion parameter in an event log entry.

Arguments:

    hMsgFile (IN, OPTIONAL) - A handle to the binary containing the message
        resources, or NULL if the system is to be used.
    
    dwMsgNum (IN) - Message number to retrieve.
    
    ppszPreAllocatedBuffer (IN/OUT) - Pointer to pre-allocated buffer to hold
        insertion string.  Buffer must be at least MAX_DS_MSG_STRING
        *characters* long.
    
    pcNumPointersToLocalFree (IN/OUT) - If retrieved message is longer than
        MAX_DS_MSG_STRING (i.e., is too long to fit into pre-allocated buffer),
        on return is incremented.  Otherwise unchanged.
    
    ppPointersToLocalFree (OUT) - If retrieved message is longer than
        MAX_DS_MSG_STRING (i.e., is too long to fit into pre-allocated buffer),
        on return holds a pointer to the message string that must be
        LocalFree()'d when the message is no longer needed.  Otherwise
        unchanged.
    
    ppszInsertionString (OUT) - On return, holds a pointer to the corresponding
        message string (or the dummy string, if the message text could not be
        retrieved).

Return Values:

    None.

--*/
{
    DWORD cch = 0;
    DWORD dwFormatFlags = hMsgFile ? FORMAT_MESSAGE_FROM_HMODULE
                                   : FORMAT_MESSAGE_FROM_SYSTEM;
    
    dwFormatFlags |= FORMAT_MESSAGE_IGNORE_INSERTS;

    cch = FormatMessageW(dwFormatFlags,
                         hMsgFile,
                         dwMsgNum,
                         0,
                         *ppszPreAllocatedBuffer,
                         MAX_DS_MSG_STRING,
                         NULL);
    if (0 != cch) {
        // Success -- message read and placed in pre-allocated buffer.
        *ppszInsertionString = *ppszPreAllocatedBuffer;
        *ppszPreAllocatedBuffer += 1 + wcslen(*ppszPreAllocatedBuffer);
    } else if (ERROR_INSUFFICIENT_BUFFER == GetLastError()) {
        // The pre-allocated buffer wasn't big enough to hold this message;
        // let FormatMessage() allocate a buffer of the appropriate size.
        PWCHAR pBuffer = NULL;

        cch = FormatMessageW(dwFormatFlags | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                             hMsgFile,
                             dwMsgNum,
                             0,
                             (LPWSTR) &pBuffer,
                             0,
                             NULL);

        if (0 != cch) {
            // Success -- message read and placed in LocalAlloc()'ed buffer.
            Assert(NULL != pBuffer);
            *ppszInsertionString = pBuffer;

            Assert(*pcNumPointersToLocalFree < DSEVENT_MAX_ALLOCS_TO_FREE);
            ppPointersToLocalFree[(*pcNumPointersToLocalFree)++] = pBuffer;
        }
    }

    if (0 == cch) {
        // Failed to read message.  Insert dummy string.
        *ppszInsertionString = gwszDummyString;
    }
}


typedef JET_ERR (JET_API FN_JET_GET_SYSTEM_PARAMETER)(
    JET_INSTANCE    instance,
    JET_SESID       sesid,
    unsigned long   paramid,
    JET_API_PTR *   plParam,
    char *          sz,
    unsigned long   cbMax
    );

VOID
InsertJetString(
    IN      JET_ERR     jetErrToInsert,
    IN OUT  LPWSTR *    ppszPreAllocatedBuffer,
    OUT     LPWSTR *    ppszInsertionString
    )
/*++

Routine Description:

    Reads a Jet error message string to be used as an insertion parameter in an
    event log entry.

Arguments:

    jetErrToInsert (IN) - Message number to retrieve.
    
    ppszPreAllocatedBuffer (IN/OUT) - Pointer to pre-allocated buffer to hold
        insertion string.  Buffer must be at least MAX_DS_MSG_STRING
        *characters* long.
    
    ppszInsertionString (OUT) - On return, holds a pointer to the corresponding
        message string (or the dummy string, if the message text could not be
        retrieved).

Return Values:

    None.

--*/
{
    static FN_JET_GET_SYSTEM_PARAMETER *s_pfnJetGetSystemParameter = NULL;
    
    DWORD cch = 0;
    CHAR szJetError[MAX_DS_MSG_STRING];

    if (NULL == s_pfnJetGetSystemParameter) {
        // We assume that esent.dll is already loaded by this process, and
        // that we simply need to get a handle to the existing image of the
        // DLL in our address space.  This frees us from having to perform
        // the ref-counted LoadLibrary() and calling FreeLibrary() later.
        HMODULE hEseNtDll = GetModuleHandle("esent.dll");
        Assert((NULL != hEseNtDll)
               && "Must statically link to esent.dll to szInsertJetErrMsg()!");
        
        s_pfnJetGetSystemParameter
            = (FN_JET_GET_SYSTEM_PARAMETER *)
                    GetProcAddress(hEseNtDll, "JetGetSystemParameter");
    }

    if (NULL != s_pfnJetGetSystemParameter) {
        JET_ERR jetErr = (*s_pfnJetGetSystemParameter)(0,
                                                       0,
                                                       JET_paramErrorToString,
                                                       (JET_API_PTR *) &jetErrToInsert,
                                                       szJetError,
                                                       ARRAY_SIZE(szJetError));
        if (JET_errSuccess == jetErr) {
            cch = MultiByteToWideChar(CP_ACP,
                                      0,
                                      szJetError,
                                      -1,
                                      *ppszPreAllocatedBuffer,
                                      MAX_DS_MSG_STRING);
            if (0 != cch) {
                // Success!
                *ppszInsertionString = *ppszPreAllocatedBuffer;
                *ppszPreAllocatedBuffer += 1 + wcslen(*ppszPreAllocatedBuffer);
            }
        }
    }

    if (0 == cch) {
        // Failed to read Jet error text.  Insert dummy string.
        *ppszInsertionString = gwszDummyString;
    }
}


VOID
DoLogEventAndTrace(
    IN PLOG_PARAM_BLOCK LogBlock
    )
{
    const GUID NullGuid = {0};

    PWCHAR   args[8];
    PWCHAR   tofree[DSEVENT_MAX_ALLOCS_TO_FREE];
    DWORD   nAllocs = 0;
    DWORD   len = 0;
    DWORD   i;
    PWCHAR   p;
    PWCHAR   pTmp = NULL;

    ZeroMemory(args, sizeof(args));

    //
    // Get total length of inserts
    //

    for ( i=0; i< LogBlock->nInsert; i++) {

        PINSERT_PARAMS  pParams;
        pParams = &LogBlock->params[i];

        switch (pParams->InsertType) {
        case inSz:
            if (pParams->pInsert) {
                pParams->InsertLen = strlen(pParams->pInsert)+1;
            } else {
                pParams->InsertLen = ARRAY_SIZE(gaszDummyString);
                pParams->pInsert = gaszDummyString;
            }
            len += pParams->InsertLen;
            break;

        case inWCCounted:
            len += pParams->InsertLen + 1;
            break;

        case inInt:
            Assert(sizeof(INT) <= 4);
            len += 16;
            break;

        case inHex:
            Assert(sizeof(INT) <= 4);
            len += 10;
            break;

        case inHex64:
            len += 20;
            break;

        case inUL:
            len += 16;
            break;

        case inUSN:
            len += SZUSN_LEN;
            break;

        case inDN: {
            DSNAME *ds;
            ds = (DSNAME*)pParams->pInsert;
            if (ds == NULL) {
                pParams->InsertLen = ARRAY_SIZE(gwszDummyString);
                pParams->pInsert = gwszDummyString;
                pParams->InsertType = inWC;
                len += pParams->InsertLen;
            } else if ( ds->NameLen != 0 ) {
                pParams->InsertLen = ds->NameLen + 1;
                pParams->pInsert = ds->StringName;
                pParams->InsertType = inWC;
                len += pParams->InsertLen;
            } else if (ds->SidLen != 0) {

                pParams->pInsert = (PVOID)ds->Sid.Data;
                pParams->InsertType = inNT4SID;
                len += 128;

            } else if (0 != memcmp(&ds->Guid, &NullGuid, sizeof(GUID))) {

                pParams->pInsert = &ds->Guid;
                pParams->InsertType = inUUID;
                len += 40;

            } else {
                pParams->InsertLen = ARRAY_SIZE(gwszDummyString);
                pParams->pInsert = gwszDummyString;
                pParams->InsertType = inWC;
                len += pParams->InsertLen;
            }
        }
            break;

        case inUUID:
            len += 40;
            break;

        case inDsMsg:
        case inWin32Msg:
        case inJetErrMsg:
        case inDbErrMsg:
        case inThStateErrMsg:
            len += MAX_DS_MSG_STRING;
            break;

        default:
        case inNT4SID:
            Assert(FALSE);
        
        case inWC:
            break;
        }
    }

    pTmp = LocalAlloc(LPTR,len*sizeof(WCHAR));
    if ( pTmp == NULL ) {
        goto exit;
    }

    p = pTmp;
    for ( i=0; i< LogBlock->nInsert; i++) {

        PINSERT_PARAMS  pParams;
        pParams = &LogBlock->params[i];

        switch (pParams->InsertType) {
        case inWC:
            if (pParams->pInsert) {
               args[i] = pParams->pInsert;
            }
            else {
               args[i] = gwszDummyString;
            }
            break;

        case inWCCounted:
            if (pParams->pInsert) {
               args[i] = p;
               memcpy(p, pParams->pInsert, (pParams->InsertLen)*sizeof(WCHAR));
               p += pParams->InsertLen;
               *p++ = L'\0';
            }
            else {
               args[i] = gwszDummyString;
            }
            break;

        case inNT4SID: {

            NTSTATUS    status;
            WCHAR    wzSid[128];
            PSID    sid = (PSID)pParams->pInsert;
            UNICODE_STRING  uniString;

            uniString.MaximumLength = sizeof(wzSid) - sizeof (WCHAR);
            uniString.Length = 0;
            uniString.Buffer = wzSid;

            status = RtlConvertSidToUnicodeString(
                                         &uniString,
                                         sid,
                                         FALSE
                                         );

            if ( status != STATUS_SUCCESS ) {
                args[i] = gwszDummyString;
                break;
            } else {

                int cb = uniString.Length / sizeof (WCHAR);

                wcsncpy(p, uniString.Buffer, cb);
                p[cb] = 0;
                args[i] = p;
                p += (cb + 1);
            
            }
            break;
        }
        case inSz: {

            DWORD cch;
            cch = MultiByteToWideChar(CP_ACP,
                                      0,
                                      (PCHAR)pParams->pInsert,
                                      pParams->InsertLen,
                                      p,
                                      pParams->InsertLen);

            if ( cch == 0 ) {
                args[i] = gwszDummyString;
            } else {
                args[i] = p;
                p += cch;
            }
            break;
        }
        case inInt: {
            INT num = (INT)pParams->tmpDword;
            _itow(num, p, 10);
            args[i] = p;
            p += (wcslen(p)+1);
            break;
        }

        case inHex: {
            INT num = (INT)pParams->tmpDword;
            _itow(num, p, 16);
            args[i] = p;
            p += (wcslen(p)+1);
            break;
        }

        case inHex64: {
            DWORD_PTR num = pParams->tmpDword;
            Assert(sizeof(DWORD_PTR) == sizeof(ULONGLONG));
            _i64tow(num, p, 16);
            args[i] = p;
            p += (wcslen(p)+1);
            break;
        }

        case inUL: {
            DWORD num = (ULONG)pParams->tmpDword;
            _ultow(num, p, 10);
            args[i] = p;
            p += (wcslen(p)+1);
            break;
        }

        case inUSN: {
            LARGE_INTEGER *pli = (LARGE_INTEGER *) pParams->pInsert;
            char pszTemp[SZUSN_LEN];
            DWORD cch;

            // Unfortunately, ntdll.dll doesn't export RtlLargeIntergerToUnicode

            RtlLargeIntegerToChar( pli, 10, SZUSN_LEN, pszTemp);
            cch = MultiByteToWideChar(CP_ACP,
                                      0,
                                      (PCHAR)pszTemp,
                                      strlen(pszTemp) + 1,
                                      p,
                                      SZUSN_LEN);

            if ( cch == 0 ) {
                args[i] = L"0";
            } else {
                args[i] = p;
                p += cch;
            }
            break;
        }

        case inUUID: {
            UUID * pUuid = (UUID*)pParams->pInsert;
            args[i] = DsUuidToStructuredStringW(pUuid,p);
            p += (wcslen(p)+1);
            break;
        }
        break;

        case inThStateErrMsg:
            InsertThStateError(&p,
                               &nAllocs,
                               tofree,
                               &args[i]);
            break;

        case inDsMsg:
            InsertMsgString(ghMsgFile,
                            (DWORD) pParams->tmpDword,
                            &p,
                            &nAllocs,
                            tofree,
                            &args[i]);
            break;

        case inDbErrMsg:
            InsertMsgString(ghMsgFile,
                            (DWORD) pParams->tmpDword + DIRMSG_DB_success,
                            &p,
                            &nAllocs,
                            tofree,
                            &args[i]);
            break;

        case inWin32Msg:
            InsertMsgString(NULL,
                            (DWORD) pParams->tmpDword,
                            &p,
                            &nAllocs,
                            tofree,
                            &args[i]);
            break;

        case inJetErrMsg:
            InsertJetString((JET_ERR) pParams->tmpDword,
                            &p,
                            &args[i]);
            break;

        default:
            Assert(FALSE);
        }
    }

    if ( LogBlock->fLog ) {

        DoLogEventW(
            LogBlock->fileNo,
            LogBlock->category,
            LogBlock->severity,
            LogBlock->mid,
            LogBlock->fIncludeName,
            args[0],
            args[1],
            args[2],
            args[3],
            args[4],
            args[5],
            args[6],
            args[7],
            LogBlock->cData,
            LogBlock->pData);

#if DBG
        if (DS_EVENT_SEV_ALWAYS == LogBlock->severity) {
            DoDPrintEvent(
                LogBlock->fileNo,
                LogBlock->category,
                LogBlock->severity,
                LogBlock->mid,
                LogBlock->fIncludeName,
                args[0],
                args[1],
                args[2],
                args[3],
                args[4],
                args[5],
                args[6],
                args[7]);
        }
#endif
    }

    if ( LogBlock->traceFlag != 0 ) {
        LogBlock->TraceEvent(
            LogBlock->mid,
            LogBlock->event,
            LogBlock->TraceGuid,
            LogBlock->TraceHeader,
            LogBlock->ClientID,
            args[0],
            args[1],
            args[2],
            args[3],
            args[4],
            args[5],
            args[6],
            args[7]);
    }

    if ( LogBlock->fAlert ) {
        DoAlertEventW(
            LogBlock->category,
            LogBlock->severity,
            LogBlock->mid,
            args[0],
            args[1],
            args[2]
            );
    }

exit:

    //
    // free all allocated buffers
    //

    for (i=0;i<nAllocs;i++) {
        LocalFree(tofree[i]);
    }

    if ( pTmp != NULL ) {
        LocalFree(pTmp);
    }
    return;

} // DoLogEventAndTrace


DS_EVENT_CONFIG *
DsGetEventConfig(void)
// May be exported to in-process, ex-module clients to allow the event logging
// infrastructure to be shared between modules.
{
    return gpDsEventConfig;
}



#define OLDEVENTLOG \
    "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application"
#define NEWEVENTLOGPREFIX \
    "SYSTEM\\CurrentControlSet\\Services\\EventLog\\"

#define LOGFILE                         "File"
#define LOGMAXSIZE                      "MaxSize"
#define LOGRETENTION                    "Retention"
#define SOURCECATEGORYCOUNT             "CategoryCount"
#define SOURCECATEGORYMSGFILE           "CategoryMessageFile"
#define SOURCEEVENTMSGFILE              "EventMessageFile"

#define DISPLAYNAMEFILE                 "DisplayNameFile"
#define DISPLAYNAMEFILEVALUE            "%SystemRoot%\\system32\\els.dll"
#define DISPLAYNAMEID                   "DisplayNameID"
#define DISPLAYNAMEIDVALUE              0x00000104

#define LOGFILEPATH             "%SystemRoot%\\system32\\config\\NTDS.Evt"
#define MESSAGEFILEPATH         "%SystemRoot%\\system32\\" DSA_MESSAGE_DLL
#define MESSAGEFILEPATHESE      "%SystemRoot%\\system32\\" ESE_MESSAGE_DLL

DWORD
InitializeEventLogging()
/*
Description:

    We used to initialize the registry keys for event logging during
    DC installation.  Now we do it (if required) on every startup.  This
    is so that new executables can add new event sources dynamically
    and so that we can nuke the old "NTDS" event source on existing
    systems.

    In the past, all directory service log entries went into the
    "Application Log" under the "NTDS" source.  This code implements
    the DS-specific log "Directory Service" and maps various DIRNO_*
    values to unique event sources so that one can scan the log for
    specific kinds of entries easily - eg: NTDS_Replication.

Arguments:

    None

Return Value:

    ERROR_SUCCESS on success, WIN32 error code otherwise.
*/

{
    LONG    err = ERROR_SUCCESS;
    HKEY    hkey = INVALID_HANDLE_VALUE;
    ULONG   cBytes;
    DWORD   tmpDWORD;
    DWORD   i;
    DWORD   dwType;
    CHAR    *pszTmp;
    CHAR    *pszNewEventLogName;
    DWORD   dirNo;

    pszNewEventLogName = (CHAR *) alloca(1 +
                                         strlen(NEWEVENTLOGPREFIX) +
                                         strlen(pszNtdsEventLogName));
    strcpy(pszNewEventLogName, NEWEVENTLOGPREFIX);
    strcat(pszNewEventLogName, pszNtdsEventLogName);

    // Use do/while/break instead of goto.

    do
    {
        //
        // Add key for new log if required.
        //

        err = RegOpenKey(HKEY_LOCAL_MACHINE, pszNewEventLogName, &hkey);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            err = RegCreateKey(HKEY_LOCAL_MACHINE, pszNewEventLogName, &hkey);
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot create key %s\n",pszNewEventLogName);
            break;
        }

        //
        // Add required values for the new log if they are missing.
        //

        cBytes = 0;
        err = RegQueryValueEx(hkey,
                              LOGFILE,
                              NULL,
                              &dwType,
                              NULL,
                              &cBytes);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            err = RegSetValueEx(hkey,
                                LOGFILE,
                                0,
                                REG_EXPAND_SZ,
                                LOGFILEPATH,
                                strlen(LOGFILEPATH) + 1);
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot set value %s\n",LOGFILE);
            break;
        }

        cBytes = 0;
        err = RegQueryValueEx(hkey,
                              LOGMAXSIZE,
                              NULL,
                              &dwType,
                              NULL,
                              &cBytes);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            tmpDWORD = 0x80000;

            err = RegSetValueEx(hkey,
                                LOGMAXSIZE,
                                0,
                                REG_DWORD,
                                (PBYTE) &tmpDWORD,
                                sizeof(tmpDWORD));
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot set value %s\n", LOGMAXSIZE);
            break;
        }

        cBytes = 0;
        err = RegQueryValueEx(hkey,
                              LOGRETENTION,
                              NULL,
                              &dwType,
                              NULL,
                              &cBytes);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            tmpDWORD = 0;

            err = RegSetValueEx(hkey,
                                LOGRETENTION,
                                0,
                                REG_DWORD,
                                (PBYTE) &tmpDWORD,
                                sizeof(tmpDWORD));
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot set value %s\n",LOGRETENTION);
            break;
        }


        cBytes = 0;
        err = RegQueryValueEx(hkey,
                              DISPLAYNAMEFILE,
                              NULL,
                              &dwType,
                              NULL,
                              &cBytes);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            err = RegSetValueEx(hkey,
                                DISPLAYNAMEFILE,
                                0,
                                REG_EXPAND_SZ,
                                DISPLAYNAMEFILEVALUE,
                                strlen(DISPLAYNAMEFILEVALUE) + 1);
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot set value %s\n",DISPLAYNAMEFILE);
            break;
        }

        cBytes = 0;
        err = RegQueryValueEx(hkey,
                              DISPLAYNAMEID,
                              NULL,
                              &dwType,
                              NULL,
                              &cBytes);

        if ( ERROR_FILE_NOT_FOUND == err )
        {
            tmpDWORD = DISPLAYNAMEIDVALUE;

            err = RegSetValueEx(hkey,
                                DISPLAYNAMEID,
                                0,
                                REG_DWORD,
                                (PBYTE) &tmpDWORD,
                                sizeof(tmpDWORD));
        }

        if ( ERROR_SUCCESS != err )
        {
            DPRINT1(0,"Cannot set value %s\n",DISPLAYNAMEID);
            break;
        }


        RegCloseKey(hkey);
        hkey = INVALID_HANDLE_VALUE;

        //
        // Determine maximum buffer size required to hold the event source
        // subkey names, then allocate buffer.
        //

        cBytes = 0;

        for ( i = 0; i < cEventSourceMappings; i++ )
        {
            if ( strlen(rEventSourceMappings[i].pszEventSource) > cBytes )
            {
                cBytes = strlen(rEventSourceMappings[i].pszEventSource);
            }
        }

        cBytes += (2 +                              // NULL terminator + '\'
                   strlen(pszNewEventLogName));     // event log key name

        pszTmp = (CHAR *) alloca(cBytes);

        //
        // Add subkeys for each source and the associated values.
        //

        for ( i = 0; i < cEventSourceMappings; i++ )
        {
            dirNo = rEventSourceMappings[i].dirNo;

            strcpy(pszTmp, pszNewEventLogName);
            strcat(pszTmp, "\\");
            strcat(pszTmp, rEventSourceMappings[i].pszEventSource);

            err = RegOpenKey(HKEY_LOCAL_MACHINE, pszTmp, &hkey);

            if ( ERROR_FILE_NOT_FOUND == err )
            {
                err = RegCreateKey(HKEY_LOCAL_MACHINE, pszTmp, &hkey);
            }

            if ( ERROR_SUCCESS != err )
            {
                DPRINT1(0,"Cannot create key %s\n",pszTmp);
                break;
            }

            //
            // Add required values for the event source if they are missing.
            //

            cBytes = 0;
            err = RegQueryValueEx(hkey,
                                  SOURCECATEGORYCOUNT,
                                  NULL,
                                  &dwType,
                                  NULL,
                                  &cBytes);

            if ( ERROR_FILE_NOT_FOUND == err )
            {
                tmpDWORD = (DIRNO_ISAM == dirNo)
                                ? ESE_EVENT_MAX_CATEGORIES
                                : DS_EVENT_MAX_CATEGORIES;

                err = RegSetValueEx(hkey,
                                    SOURCECATEGORYCOUNT,
                                    0,
                                    REG_DWORD,
                                    (PBYTE) &tmpDWORD,
                                    sizeof(tmpDWORD));
            }

            if ( ERROR_SUCCESS != err )
            {
                DPRINT1(0,"Cannot set value %s\n",SOURCECATEGORYCOUNT);
                break;
            }

            cBytes = 0;
            err = RegQueryValueEx(hkey,
                                  SOURCECATEGORYMSGFILE,
                                  NULL,
                                  &dwType,
                                  NULL,
                                  &cBytes);

            if ( ERROR_FILE_NOT_FOUND == err )
            {
                err = RegSetValueEx(hkey,
                                    SOURCECATEGORYMSGFILE,
                                    0,
                                    REG_EXPAND_SZ,
                                    (DIRNO_ISAM == dirNo)
                                        ? MESSAGEFILEPATHESE
                                        : MESSAGEFILEPATH,
                                    (DIRNO_ISAM == dirNo)
                                        ? strlen(MESSAGEFILEPATHESE) + 1
                                        : strlen(MESSAGEFILEPATH) + 1);
            }

            if ( ERROR_SUCCESS != err )
            {
                DPRINT1(0,"Cannot set value %s\n",SOURCECATEGORYMSGFILE);
                break;
            }

            cBytes = 0;
            err = RegQueryValueEx(hkey,
                                  SOURCEEVENTMSGFILE,
                                  NULL,
                                  &dwType,
                                  NULL,
                                  &cBytes);

            if ( ERROR_FILE_NOT_FOUND == err )
            {
                err = RegSetValueEx(hkey,
                                    SOURCEEVENTMSGFILE,
                                    0,
                                    REG_EXPAND_SZ,
                                    (DIRNO_ISAM == dirNo)
                                        ? MESSAGEFILEPATHESE
                                        : MESSAGEFILEPATH,
                                    (DIRNO_ISAM == dirNo)
                                        ? strlen(MESSAGEFILEPATHESE) + 1
                                        : strlen(MESSAGEFILEPATH) + 1);
            }

            if ( ERROR_SUCCESS != err )
            {
                DPRINT1(0,"Cannot set value %s\n",SOURCEEVENTMSGFILE);
                break;
            }

            RegCloseKey(hkey);
            hkey = INVALID_HANDLE_VALUE;

        } // for i in cEventSourceMappings

        if ( ERROR_SUCCESS != err )
        {
            break;
        }

        //
        // Remove old NTDS source under Application log if present.
        //

        err = RegOpenKey(HKEY_LOCAL_MACHINE, OLDEVENTLOG, &hkey);

        if ( ERROR_SUCCESS != err )
        {
            DPRINT2(0,"RegOpenKey %s failed with %d\n",OLDEVENTLOG,err);
            break;
        }

        err = RegDeleteKey(hkey, SERVICE_NAME);

        //
        // Ignore delete errors.
        //

        err = ERROR_SUCCESS;

    }
    while ( FALSE );

    if ( INVALID_HANDLE_VALUE != hkey )
    {
        RegCloseKey(hkey);
    }

    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\iislib\pudebug.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

    Module  Name :
        pudebug.c

    Abstract:

        This module defines functions required for
         Debugging and logging messages for a dynamic program.

    Author:
         Murali R. Krishnan ( MuraliK )    10-Sept-1994
         Modified to be moved to common dll in 22-Dec-1994.

    Revisions:
         MuraliK  16-May-1995  Code to load and save debug flags from registry
         MuraliK  16-Nov-1995  Remove DbgPrint (undoc api)
--*/


/************************************************************
 * Include Headers
 ************************************************************/

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
# include <stdio.h>
# include <stdlib.h>
# include <stdarg.h>
# include <string.h>

# include "pudebug.h"


/*************************************************************
 * Global Variables and Default Values
 *************************************************************/

# define MAX_PRINTF_OUTPUT  ( 10240)

# define DEFAULT_DEBUG_FLAGS_VALUE  ( 0)
# define DEBUG_FLAGS_REGISTRY_LOCATION_A   "DebugFlags"


/*************************************************************
 *   Functions
 *************************************************************/

LPDEBUG_PRINTS
  PuCreateDebugPrintsObject(
    IN const char *         pszPrintLabel,
    IN DWORD                dwOutputFlags)
/*++
   This function creates a new DEBUG_PRINTS object for the required
     program.

   Arguments:
      pszPrintLabel     pointer to null-terminated string containing
                         the label for program's debugging output
      dwOutputFlags     DWORD containing the output flags to be used.

   Returns:
       pointer to a new DEBUG_PRINTS object on success.
       Returns NULL on failure.
--*/
{

   LPDEBUG_PRINTS   pDebugPrints;

   pDebugPrints = GlobalAlloc( GPTR, sizeof( DEBUG_PRINTS));

   if ( pDebugPrints != NULL) {

        if ( strlen( pszPrintLabel) < MAX_LABEL_LENGTH) {

            strcpy( pDebugPrints->m_rgchLabel, pszPrintLabel);
        } else {
            strncpy( pDebugPrints->m_rgchLabel,
                     pszPrintLabel, MAX_LABEL_LENGTH - 1);
            pDebugPrints->m_rgchLabel[MAX_LABEL_LENGTH-1] = '\0';
                // terminate string
        }

        memset( pDebugPrints->m_rgchLogFilePath, 0, MAX_PATH);
        memset( pDebugPrints->m_rgchLogFileName, 0, MAX_PATH);

        pDebugPrints->m_LogFileHandle = INVALID_HANDLE_VALUE;

        pDebugPrints->m_dwOutputFlags = dwOutputFlags;
        pDebugPrints->m_StdErrHandle  = GetStdHandle( STD_ERROR_HANDLE);
        pDebugPrints->m_fInitialized = TRUE;
    }


   return ( pDebugPrints);
} // PuCreateDebugPrintsObject()




LPDEBUG_PRINTS
  PuDeleteDebugPrintsObject(
    IN OUT LPDEBUG_PRINTS pDebugPrints)
/*++
    This function cleans up the pDebugPrints object and
      frees the allocated memory.

    Arguments:
       pDebugPrints     poitner to the DEBUG_PRINTS object.

    Returns:
        NULL  on  success.
        pDebugPrints() if the deallocation failed.

--*/
{
    if ( pDebugPrints != NULL) {

        DWORD dwError = PuCloseDbgPrintFile( pDebugPrints);

        if ( dwError != NO_ERROR) {

            SetLastError( dwError);
        } else {

            pDebugPrints = GlobalFree( pDebugPrints);
        }
    }

    return ( pDebugPrints);

} // PuDeleteDebugPrintsObject()




VOID
PuSetDbgOutputFlags(
    IN OUT LPDEBUG_PRINTS   pDebugPrints,
    IN DWORD                dwFlags)
{

    if ( pDebugPrints == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
    } else {

        pDebugPrints->m_dwOutputFlags = dwFlags;
    }

    return;
} // PuSetDbgOutputFlags()



DWORD
PuGetDbgOutputFlags(
    IN const LPDEBUG_PRINTS      pDebugPrints)
{
    return ( pDebugPrints != NULL) ? pDebugPrints->m_dwOutputFlags : 0;

} // PuGetDbgOutputFlags()


static DWORD
PuOpenDbgFileLocal(
   IN OUT LPDEBUG_PRINTS pDebugPrints)
{

    if ( pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

        //
        // Silently return as a file handle exists.
        //
        return ( NO_ERROR);
    }

    pDebugPrints->m_LogFileHandle =
                      CreateFile( pDebugPrints->m_rgchLogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

    if ( pDebugPrints->m_LogFileHandle == INVALID_HANDLE_VALUE) {

        CHAR  pchBuffer[1024];
        DWORD dwError = GetLastError();

        wsprintfA( pchBuffer,
                  " Critical Error: Unable to Open File %s. Error = %d\n",
                  pDebugPrints->m_rgchLogFileName, dwError);
        OutputDebugString( pchBuffer);

        return ( dwError);
    }

    return ( NO_ERROR);
} // PuOpenDbgFileLocal()





DWORD
PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS      pDebugPrints,
   IN const char *            pszFileName,
   IN const char *            pszPathForFile)
/*++

  Opens a Debugging log file. This function can be called to set path
  and name of the debugging file.

  Arguments:
     pszFileName           pointer to null-terminated string containing
                            the name of the file.

     pszPathForFile        pointer to null-terminated string containing the
                            path for the given file.
                           If NULL, then the old place where dbg files were
                           stored is used or if none,
                           default windows directory will be used.

   Returns:
       Win32 error codes. NO_ERROR on success.

--*/
{

    if ( pszFileName == NULL || pDebugPrints == NULL) {

        return ( ERROR_INVALID_PARAMETER);
    }

    //
    //  Setup the Path information. if necessary.
    //

    if ( pszPathForFile != NULL) {

        // Path is being changed.

        if ( strlen( pszPathForFile) < MAX_PATH) {

            strcpy( pDebugPrints->m_rgchLogFilePath, pszPathForFile);
        } else {

            return ( ERROR_INVALID_PARAMETER);
        }
    } else {

        if ( pDebugPrints->m_rgchLogFilePath[0] == '\0' &&  // no old path
            !GetWindowsDirectory( pDebugPrints->m_rgchLogFilePath, MAX_PATH)) {

            //
            //  Unable to get the windows default directory. Use current dir
            //

            strcpy( pDebugPrints->m_rgchLogFilePath, ".");
        }
    }

    //
    // Should need be, we need to create this directory for storing file
    //


    //
    // Form the complete Log File name and open the file.
    //
    if ( (strlen( pszFileName) + strlen( pDebugPrints->m_rgchLogFilePath))
         >= MAX_PATH) {

        return ( ERROR_NOT_ENOUGH_MEMORY);
    }

    //  form the complete path
    strcpy( pDebugPrints->m_rgchLogFileName, pDebugPrints->m_rgchLogFilePath);

    if ( pDebugPrints->m_rgchLogFileName[ strlen(pDebugPrints->m_rgchLogFileName) - 1]
        != '\\') {
        // Append a \ if necessary
        strcat( pDebugPrints->m_rgchLogFileName, "\\");
    };
    strcat( pDebugPrints->m_rgchLogFileName, pszFileName);

    return  PuOpenDbgFileLocal( pDebugPrints);

} // PuOpenDbgPrintFile()




DWORD
PuReOpenDbgPrintFile(
    IN OUT LPDEBUG_PRINTS    pDebugPrints)
/*++

  This function closes any open log file and reopens a new copy.
  If necessary. It makes a backup copy of the file.

--*/
{

    PuCloseDbgPrintFile( pDebugPrints);      // close any existing file.

    if ( pDebugPrints->m_dwOutputFlags & DbgOutputBackup) {

        // MakeBkupCopy();

        OutputDebugString( " Error: MakeBkupCopy() Not Yet Implemented\n");
    }

    return PuOpenDbgFileLocal( pDebugPrints);

} // PuReOpenDbgPrintFile()




DWORD
PuCloseDbgPrintFile(
    IN OUT LPDEBUG_PRINTS    pDebugPrints)
{
    DWORD dwError = NO_ERROR;

    if ( pDebugPrints == NULL ) {
        dwError = ERROR_INVALID_PARAMETER;
    } else {

        if ( pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

            FlushFileBuffers( pDebugPrints->m_LogFileHandle);

            if ( !CloseHandle( pDebugPrints->m_LogFileHandle)) {

                CHAR pchBuffer[1024];

                dwError = GetLastError();

                wsprintf( pchBuffer,
                          "CloseDbgPrintFile() : CloseHandle( %d) failed."
                          " Error = %d\n",
                          pDebugPrints->m_LogFileHandle,
                          dwError);
                OutputDebugString( pchBuffer);
            }

            pDebugPrints->m_LogFileHandle = INVALID_HANDLE_VALUE;
        }
    }

    return ( dwError);
} // DEBUG_PRINTS::CloseDbgPrintFile()


VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS      pDebugPrints,
   IN const char *            pszFilePath,
   IN int                     nLineNum,
   IN const char *            pszFormat,
   ...)
/*++

   Main function that examines the incoming message and prints out a header
    and the message.

--*/
{
   LPCSTR pszFileName = strrchr( pszFilePath, '\\');
   char pszOutput[ MAX_PRINTF_OUTPUT + 2];
   LPCSTR pszMsg = "";
   INT  cchOutput;
   INT  cchPrologue;
   va_list argsList;
   DWORD dwErr;


   //
   //  Skip the complete path name and retain file name in pszName
   //

   if ( pszFileName== NULL) {

      pszFileName = pszFilePath;  // if skipping \\ yields nothing use whole path.
   }

# ifdef _PRINT_REASONS_INCLUDED_

  switch (pr) {

     case PrintError:
        pszMsg = "ERROR: ";
        break;

     case PrintWarning:
        pszMsg = "WARNING: ";
        break;

     case PrintCritical:
        pszMsg = "FATAL ERROR ";
        break;

     case PrintAssertion:
        pszMsg = "ASSERTION Failed ";
        break;

     case PrintLog:
        pfnPrintFunction = &DEBUG_PRINTS::DebugPrintNone;
     default:
        break;

  } /* switch */

# endif // _PRINT_REASONS_INClUDED_

  dwErr = GetLastError();

  // Format the message header

  cchPrologue = wsprintf( pszOutput, "%s (%lu)[ %12s : %05d]",
                        pDebugPrints->m_rgchLabel,
                        GetCurrentThreadId(),
                        pszFileName, nLineNum);

  // Format the incoming message using vsnprintf() so that the overflows are
  //  captured

  va_start( argsList, pszFormat);

  cchOutput = _vsnprintf( pszOutput + cchPrologue,
                          MAX_PRINTF_OUTPUT - cchPrologue - 1,
                          pszFormat, argsList);
  va_end( argsList);

  //
  // The string length is long, we get back -1.
  //   so we get the string length for partial data.
  //

  if ( cchOutput == -1 ) {

      //
      // terminate the string properly,
      //   since _vsnprintf() does not terminate properly on failure.
      //
      cchOutput = MAX_PRINTF_OUTPUT;
      pszOutput[ cchOutput] = '\0';
  }

  //
  // Send the outputs to respective files.
  //

  if ( pDebugPrints->m_dwOutputFlags & DbgOutputStderr) {

      DWORD nBytesWritten;

      ( VOID) WriteFile( pDebugPrints->m_StdErrHandle,
                         pszOutput,
                         strlen( pszOutput),
                         &nBytesWritten,
                         NULL);
  }

  if ( pDebugPrints->m_dwOutputFlags & DbgOutputLogFile &&
       pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

      DWORD nBytesWritten;

      //
      // Truncation of log files. Not yet implemented.

      ( VOID) WriteFile( pDebugPrints->m_LogFileHandle,
                         pszOutput,
                         strlen( pszOutput),
                         &nBytesWritten,
                         NULL);

  }


  if ( pDebugPrints->m_dwOutputFlags & DbgOutputKdb) {

      OutputDebugString( pszOutput);
   }

  SetLastError( dwErr );

  return;

} // PuDbgPrint()



VOID
 PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   )
{
   LPCSTR pszFileName = strrchr( pszFilePath, '\\');
   LPCSTR pszMsg = "";
   DWORD dwErr;
   DWORD cbDump;


   //
   //  Skip the complete path name and retain file name in pszName
   //

   if ( pszFileName== NULL) {

      pszFileName = pszFilePath;
   }

   dwErr = GetLastError();

   // No message header for this dump
   cbDump = strlen( pszDump);

   //
   // Send the outputs to respective files.
   //

   if ( pDebugPrints->m_dwOutputFlags & DbgOutputStderr) {

       DWORD nBytesWritten;

       ( VOID) WriteFile( pDebugPrints->m_StdErrHandle,
                          pszDump,
                          cbDump,
                          &nBytesWritten,
                          NULL);
   }

   if ( pDebugPrints->m_dwOutputFlags & DbgOutputLogFile &&
        pDebugPrints->m_LogFileHandle != INVALID_HANDLE_VALUE) {

       DWORD nBytesWritten;

       //
       // Truncation of log files. Not yet implemented.

       ( VOID) WriteFile( pDebugPrints->m_LogFileHandle,
                          pszDump,
                          cbDump,
                          &nBytesWritten,
                          NULL);

   }

   if ( pDebugPrints->m_dwOutputFlags & DbgOutputKdb) {

       OutputDebugString( pszDump);
   }

   SetLastError( dwErr );

  return;
} // PuDbgDump()

//
// N.B. For PuDbgCaptureContext() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// PuDbgAssertFailed() with the __cdecl modifier and disable the frame pointer
// omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)
VOID
__cdecl
PuDbgAssertFailed(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum,
    IN const char *               pszExpression,
    IN const char *               pszMessage)
/*++
    This function calls assertion failure and records assertion failure
     in log file.

--*/
{
    CONTEXT context;

    PuDbgCaptureContext( &context );

    PuDbgPrint( pDebugPrints, pszFilePath, nLineNum,
                " Assertion (%s) Failed: %s\n"
                " use !cxr %lx to dump context\n",
                pszExpression,
                pszMessage,
                &context);

    DebugBreak();

    return;
} // PuDbgAssertFailed()
#pragma optimize( "", on )      // restore frame pointer omission (FPO)



VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum
    )
/*++
  This function generates the current time and prints it out to debugger
   for tracing out the path traversed, if need be.

  Arguments:
      pszFile    pointer to string containing the name of the file
      lineNum    line number within the file where this function is called.

  Returns:
      NO_ERROR always.
--*/
{
    PuDbgPrint( pDebugPrints, pszFilePath, nLineNum,
                " TickCount = %u\n",
                GetTickCount()
                );

    return;
} // PrintOutCurrentTime()




DWORD
PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault)
/*++
  This function reads the debug flags assumed to be stored in
   the location  "DebugFlags" under given key.
  If there is any error the default value is returned.
--*/
{
    DWORD err;
    DWORD dwDebug = dwDefault;
    DWORD  dwBuffer;
    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL )
    {
        err = RegQueryValueExA( hkey,
                               DEBUG_FLAGS_REGISTRY_LOCATION_A,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) )
        {
            dwDebug = dwBuffer;
        }
    }

    return dwDebug;
} // PuLoadDebugFlagsFromReg()




DWORD
PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault)
/*++
Description:
  This function reads the debug flags assumed to be stored in
   the location  "DebugFlags" under given key location in registry.
  If there is any error the default value is returned.

Arguments:
  pszRegKey - pointer to registry key location from where to read the key from
  dwDefault - default values in case the read from registry fails

Returns:
   Newly read value on success
   If there is any error the dwDefault is returned.
--*/
{
    HKEY        hkey = NULL;

    DWORD dwVal = dwDefault;

    DWORD dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                  pszRegKey,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hkey);
    if ( dwError == NO_ERROR) {
        dwVal = PuLoadDebugFlagsFromReg( hkey, dwDefault);
        RegCloseKey( hkey);
        hkey = NULL;
    }

    return ( dwVal);
} // PuLoadDebugFlagsFromRegStr()





DWORD
PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg)
/*++
  Saves the debug flags in registry. On failure returns the error code for
   the operation that failed.

--*/
{
    DWORD err;

    if( hkey == NULL ) {

        err = ERROR_INVALID_PARAMETER;
    } else {

        err = RegSetValueExA(hkey,
                             DEBUG_FLAGS_REGISTRY_LOCATION_A,
                             0,
                             REG_DWORD,
                             (LPBYTE)&dwDbg,
                             sizeof(dwDbg) );
    }

    return (err);
} // PuSaveDebugFlagsInReg()


//
// Dummy PuDbgCaptureContext(), only used if we're ever built for
// a target processor other than x86 or alpha.
//

VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    )
{
    //
    // This space intentionally left blank.
    //

}   // PuDbgCaptureContext


/****************************** End of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\iislib\reftrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reftrace.c

Abstract:

    This module implements a reference count tracing facility.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>
#include <reftrace.h>
#include <stktrace.h>



PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
/*++

Routine Description:

    Creates a new (empty) ref count trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    return CreateTraceLog(
               LogSize,
               ExtraBytesInHeader,
               sizeof(REF_TRACE_LOG_ENTRY)
               );

}   // CreateRefTraceLog


VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a ref count trace log buffer created with CreateRefTraceLog().

Arguments:

    Log - The ref count trace log buffer to destroy.

Return Value:

    None.

--*/
{

    DestroyTraceLog( Log );

}   // DestroyRefTraceLog


//
// N.B. For PuDbgCaptureContext() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// PuDbgAssertFailed() with the __cdecl modifier and disable the frame pointer
// omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

VOID
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context
    )
/*++

Routine Description:

    Writes a new entry to the specified ref count trace log. The entry
    written contains the updated reference count and a stack backtrace
    leading up to the current caller.

Arguments:

    Log - The log to write to.

    NewRefCount - The updated reference count.

    Context - An uninterpreted context to associate with the log entry.

Return Value:

    None.

--*/
{

    WriteRefTraceLogEx(
        Log,
        NewRefCount,
        Context,
        (PVOID) -1, // suppress use of optional extra contexts
        (PVOID) -1,
        (PVOID) -1
        );

}   // WriteRefTraceLog




VOID
WriteRefTraceLogEx(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context,
    IN PVOID Context1, // optional extra context
    IN PVOID Context2, // optional extra context
    IN PVOID Context3  // optional extra context
    )
/*++

Routine Description:

    Writes a new "extended" entry to the specified ref count trace log.
    The entry written contains the updated reference count, stack backtrace
    leading up to the current caller and extra context information.

Arguments:

    Log - The log to write to.

    NewRefCount - The updated reference count.

    Context  - An uninterpreted context to associate with the log entry.
    Context1 - An uninterpreted context to associate with the log entry.
    Context2 - An uninterpreted context to associate with the log entry.
    Context3 - An uninterpreted context to associate with the log entry.

    NOTE Context1/2/3 are "optional" in that the caller may suppress
    debug display of these values by passing -1 for each of them.

Return Value:

    None

--*/
{

    REF_TRACE_LOG_ENTRY entry;
    ULONG hash;
    DWORD cStackFramesSkipped;

    //
    // Initialize the entry.
    //

    RtlZeroMemory(
        &entry,
        sizeof(entry)
        );

    //
    //  Set log entry members.
    //

    entry.NewRefCount = NewRefCount;
    entry.Context = Context;
    entry.Thread = GetCurrentThreadId();
    entry.Context1 = Context1;
    entry.Context2 = Context2;
    entry.Context3 = Context3;

    //
    // Capture the stack backtrace. Normally, we skip two stack frames:
    // one for this routine, and one for IISCaptureStackBackTrace() itself.
    // For non-Ex callers who come in via WriteRefTraceLog,
    // we skip three stack frames.
    //

    if (    entry.Context1 == (PVOID) -1 
         && entry.Context2 == (PVOID) -1
         && entry.Context3 == (PVOID) -1
         ) {

         cStackFramesSkipped = 3;

    } else {
    
         cStackFramesSkipped = 2;

    }

    IISCaptureStackBackTrace(
        cStackFramesSkipped,
        REF_TRACE_LOG_STACK_DEPTH,
        entry.Stack,
        &hash
        );

    //
    // Write it to the log.
    //

    WriteTraceLog(
        Log,
        &entry
        );

}   // WriteRefTraceLogEx
#pragma optimize( "", on )      // restore frame pointer omission (FPO)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\iislib\tracelog.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.c

Abstract:

    This module implements a trace log.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>
#include <tracelog.h>


#define ALLOC_MEM(cb) (PVOID)LocalAlloc( LPTR, (cb) )
#define FREE_MEM(ptr) (VOID)LocalFree( (HLOCAL)(ptr) )



PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    )
/*++

Routine Description:

    Creates a new (empty) trace log buffer.

Arguments:

    LogSize - The number of entries in the log.

    ExtraBytesInHeader - The number of extra bytes to include in the
        log header. This is useful for adding application-specific
        data to the log.

    EntrySize - The size (in bytes) of each entry.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--*/
{

    LONG totalSize;
    PTRACE_LOG log;

    //
    // Sanity check the parameters.
    //

    DBG_ASSERT( LogSize > 0 );
    DBG_ASSERT( EntrySize > 0 );
    DBG_ASSERT( ( EntrySize & 3 ) == 0 );

    //
    // Allocate & initialize the log structure.
    //

    totalSize = sizeof(*log) + ( LogSize * EntrySize ) + ExtraBytesInHeader;
    DBG_ASSERT( totalSize > 0 );

    log = (PTRACE_LOG)ALLOC_MEM( totalSize );

    //
    // Initialize it.
    //

    if( log != NULL ) {

        RtlZeroMemory( log, totalSize );

        log->Signature = TRACE_LOG_SIGNATURE;
        log->LogSize = LogSize;
        log->NextEntry = -1;
        log->EntrySize = EntrySize;
        log->LogBuffer = (PUCHAR)( log + 1 ) + ExtraBytesInHeader;
    }

    return log;

}   // CreateTraceLog


VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    )
/*++

Routine Description:

    Destroys a trace log buffer created with CreateTraceLog().

Arguments:

    Log - The trace log buffer to destroy.

Return Value:

    None.

--*/
{
	if ( Log != NULL ) {
        DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

        Log->Signature = TRACE_LOG_SIGNATURE_X;
        FREE_MEM( Log );
    }

}   // DestroyTraceLog


VOID
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    )
/*++

Routine Description:

    Writes a new entry to the specified trace log.

Arguments:

    Log - The log to write to.

    Entry - Pointer to the data to write. This buffer is assumed to be
        Log->EntrySize bytes long.

Return Value:

    None

--*/
{

    PUCHAR target;
    LONG index;

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );
    DBG_ASSERT( Entry != NULL );

    //
    // Find the next slot, copy the entry to the slot.
    //

    index = InterlockedIncrement( &Log->NextEntry ) % Log->LogSize;
    target = Log->LogBuffer + ( index * Log->EntrySize );

    RtlCopyMemory(
        target,
        Entry,
        Log->EntrySize
        );

}   // WriteTraceLog


VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    )
{

    DBG_ASSERT( Log != NULL );
    DBG_ASSERT( Log->Signature == TRACE_LOG_SIGNATURE );

    RtlZeroMemory(
        ( Log + 1 ),
        Log->LogSize * Log->EntrySize
        );

    Log->NextEntry = -1;

}   // ResetTraceLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\iislib\stktrace.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.c

Abstract:

    Implements IISCaptureStackBackTrace().

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>
#include <stktrace.h>


typedef
USHORT
(NTAPI * PFN_RTL_CAPTURE_STACK_BACK_TRACE)(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    );

PFN_RTL_CAPTURE_STACK_BACK_TRACE g_pfnRtlCaptureStackBackTrace = NULL;



USHORT
NTAPI
DummyCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    Dummy implementation of RtlCaptureStackBackTrace() for Win9x.

Arguments:

    See IISCaptureStackBackTrace() below.

Return Value:

    USHORT - Always 0.

--*/
{

    return 0;

}   // DummyRtlCaptureStackBackTrace


USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    Wrapper around RtlCaptureStackBackTrace(). Attempts to capture the
    stack backtrace leading up to the current instruction counter.
    Doesn't work very well on RISC platforms, and is often confused on
    X86 when FPO is enabled.

Arguments:

    FramesToSkip - The number of stack frames to skip before capturing.

    FramesToCapture - The number of stack frames to capture.

    BackTrace - Receives the captured frames.

    BackTraceHash - Some kind of hash thingie.

Return Value:

    USHORT - The number of frames captured.

--*/
{

    //
    // Initialize if necessary.
    //

    if( g_pfnRtlCaptureStackBackTrace == NULL ) {

        HMODULE mod;
        PFN_RTL_CAPTURE_STACK_BACK_TRACE proc = NULL;

        //
        // Note that it is perfectly safe to use GetModuleHandle() here
        // rather than LoadLibrary(), for the following reasons:
        //
        //     1. Under NT, NTDLL.DLL is a "well known" DLL that *never*
        //        gets detached from the process. It's very special.
        //
        //     2. Under Win95, NTDLL.DLL doesn't export the
        //        RtlCaptureStackBackTrace() function, so we will not be
        //        referencing any routines within the DLL.
        //
        // Also note that we retrieve the function pointer into a local
        // variable, not directly into the global. This prevents a nasty
        // race condition that can occur when two threads try to
        // initialize g_pfnRtlCaptureStackBackTrace simultaneously.
        //

        mod = GetModuleHandle( "ntdll.dll" );

        if( mod != NULL ) {
            proc = (PFN_RTL_CAPTURE_STACK_BACK_TRACE)
                GetProcAddress( mod, "RtlCaptureStackBackTrace" );
        }

        if( proc == NULL ) {
            g_pfnRtlCaptureStackBackTrace = &DummyCaptureStackBackTrace;
        } else {
            g_pfnRtlCaptureStackBackTrace = proc;
        }

    }

    return (g_pfnRtlCaptureStackBackTrace)(
               FramesToSkip,
               FramesToCapture,
               BackTrace,
               BackTraceHash
               );

}   // IISCaptureStackBackTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\iislib\isplat.cxx ===
/*++

    Copyright (c) 1996  Microsoft Corporation

    Module  Name :
        isplat.cxx

    Abstract:

        This module defines functions for determining platform types

    Author:

        Johnson Apacible    (johnsona)      19-Nov-1996

        Murali Krishnan     (MuraliK)       17-Apr-1997
                   Added CriticalSectionWith SpinCount stuff
--*/

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>

}   // extern "C"


#if DBG
#define IIS_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define IIS_PRINTF( x )
#endif

DECLARE_PLATFORM_TYPE();

typedef
BOOLEAN
(NTAPI *GET_PRODUCT_TYPE)(
            PNT_PRODUCT_TYPE
            );

extern "C"
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        )
/*++

  This function consults the registry and determines the platform type
   for this machine.

  Arguments:

    None

  Returns:
    Platform type

--*/
{
    PLATFORM_TYPE pt;
    LONG result;
    HKEY keyHandle;
    WCHAR productType[30];
    DWORD type;
    BOOL isNt = TRUE;

    OSVERSIONINFO osInfo;

    //
    // See if the platform type has already been discovered.
    //

    if ( g_PlatformType != PtInvalid ) {
        return(g_PlatformType);
    }

    //
    // see if this is win95
    //

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx( &osInfo ) ) {
        isNt = (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } else {
        IIS_PRINTF((buff,"GetVersionEx failed with %d\n",
                    GetLastError()));
    }

    if ( isNt ) {

        HINSTANCE hNtdll;
        NT_PRODUCT_TYPE ntType;
        GET_PRODUCT_TYPE pfnGetProductType;

        //
        // Get the product type from the system
        //

        pt = PtNtWorkstation;
        hNtdll = LoadLibrary("ntdll.dll");
        if ( hNtdll != NULL ) {

            pfnGetProductType = (GET_PRODUCT_TYPE)
                GetProcAddress(hNtdll, "RtlGetNtProductType");

            if ( (pfnGetProductType != NULL) &&
                  pfnGetProductType( &ntType ) ) {

                if ( (ntType == NtProductLanManNt) ||
                     (ntType == NtProductServer) ) {

                    pt = PtNtServer;
                }
            }

            FreeLibrary( hNtdll );
        }

    } else {
        pt = PtWindows95;
    }

    g_PlatformType = pt;
    return(pt);

} // IISGetPlatformType



/************************************************************
 *  Critical Section With Spin Count thunks
 ************************************************************/

typedef
DWORD
(WINAPI * PFN_SET_CRITICAL_SECTION_SPIN_COUNT)(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   );

PFN_SET_CRITICAL_SECTION_SPIN_COUNT  g_pfnSetCSSpinCount = NULL;


DWORD
FakeSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   )
/*++
Description:
  This function fakes setting critical section spin count.
  See IISSetCriticalSectionSpinCount() for details

Returns:
   0 - since we are faking the set of cs with spin count
--*/
{
    UNREFERENCED_PARAMETER( lpCriticalSection);
    UNREFERENCED_PARAMETER( dwSpinCount);

    // For faked critical sections, the previous spin count is just ZERO!
    return (0);
} // FakeSetCriticalSectionSpinCount()


static VOID
LoadNtFunctionPointers(VOID)
/*++
Description:
  This function loads the entry point for SetCriticalSectionSpinCount()
  API from Kernel32.dll. If the entry point is missing, the function
  pointer will point to a fake routine which does nothing. Otherwise,
  it will point to the real function.

  It dynamically loads the kernel32.dll to find the entry ponit and then
  unloads it after getting the address. For the resulting function
  pointer to work correctly one has to ensure that the kernel32.dll is
  linked with the dll/exe which links to this file.
--*/
{
    if ( g_pfnSetCSSpinCount == NULL ) {

        HINSTANCE tmpInstance;

        //
        // load kernel32 and get NT specific entry points
        //

        tmpInstance = LoadLibrary("kernel32.dll");
        if ( tmpInstance != NULL ) {

            g_pfnSetCSSpinCount = (PFN_SET_CRITICAL_SECTION_SPIN_COUNT )
                GetProcAddress( tmpInstance, "SetCriticalSectionSpinCount");

            if ( g_pfnSetCSSpinCount == NULL ) {
                // the set CS Spincount function is not availble.
                //  Just thunk it.
                g_pfnSetCSSpinCount = FakeSetCriticalSectionSpinCount;
            }

            //
            // We can free this because we are statically linked to it
            //

            FreeLibrary(tmpInstance);
        }
    }

    return;
} // LoadNtFunctionPointers()


extern "C"
DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   )
/*++
Description:
  This function is used to call the appropriate underlying functions to
   set the spin count for the supplied critical section.
  The original function is supposed to be exported out of kernel32.dll from NT
  4.0 SP3. If the func is not available from the dll, we will use a fake
  function.

Arguments:
  lpCriticalSection
      Points to the critical section object.

  dwSpinCount
      Supplies the spin count for the critical section object. For UP systems,
      the spin count is ignored and the critical section spin
      count is set to 0. For MP systems, if contention occurs, instead of
      waiting on a semaphore associated with the critical section,
      the calling thread will spin for spin count iterations before doing the
      hard wait. If the critical section becomes free during the spin,
      a wait is avoided.

Returns:
   The previous spin count for the critical section is returned.
--*/
{
    if ( g_pfnSetCSSpinCount == NULL ) {
        LoadNtFunctionPointers();
    }

    // Pass the inputs to the global function pointer which is already setup.
    return ( g_pfnSetCSSpinCount( lpCriticalSection, dwSpinCount));

} // IISSetCriticalSectionSpinCount()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\dynarray.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    dynarray.c

Abstract:

    This file contains the definition of a dynamic array data type.

Author:

    Colin Brace ColinBr
    
Revision History

    3-12-97   ColinBr    Created
    
--*/


#include <nt.h>
#include <ntrtl.h>

typedef unsigned long DWORD;


#include <w32topl.h>
#include <w32toplp.h>

#include <dynarray.h>

VOID
DynamicArrayInit(
    IN PDYNAMIC_ARRAY a
    )
/*++                                                                           

Routine Description:

Parameters:

--*/
{
    ASSERT(a);

    memset(a, 0, sizeof(DYNAMIC_ARRAY));

    return;
}

VOID
DynamicArrayDestroy(
    IN PDYNAMIC_ARRAY a
    )
{
    ASSERT(a);

    if (a->Array) {
        ToplFree(a->Array);
    }
}

DWORD
DynamicArrayGetCount(
    IN PDYNAMIC_ARRAY a
    )
/*++                                                                           

Routine Description:

Parameters:

--*/
{
    ASSERT(a);

    return a->Count;
}

VOID
DynamicArrayAdd(
    IN PDYNAMIC_ARRAY a,
    IN VOID*          pElement
    )
/*++                                                                           

Routine Description:

Parameters:

--*/
{
    ASSERT(a);

    if (a->Count >= a->ElementsAllocated) {
        //
        // Realloc more space!
        //
        #define CHUNK_SIZE               100  // this is the number of elements

        a->ElementsAllocated += CHUNK_SIZE;
        if (a->Array) {
            a->Array = (PEDGE*) ToplReAlloc(a->Array, a->ElementsAllocated * sizeof(PVOID));
        } else {
            a->Array = (PEDGE*) ToplAlloc(a->ElementsAllocated * sizeof(PVOID));
        }
        ASSERT(a->Array);

    }

    a->Array[a->Count] = pElement;
    a->Count++;

    return;
}

VOID*
DynamicArrayRetrieve(
    IN PDYNAMIC_ARRAY a,
    IN ULONG          Index
    )
/*++                                                                           

Routine Description:

    This routine returns the element at Index of a

Parameters:


--*/
{
    ASSERT(a);
    ASSERT(Index < a->Count);

    return a->Array[Index];
}

VOID
DynamicArrayRemove(
    IN PDYNAMIC_ARRAY a,
    IN VOID*          pElement, 
    IN ULONG          Index
    )
/*++                                                                           

Routine Description:

    This routine removes pElement from a if the element
    exists

Parameters:

    a : the dynamic array
    
    pElement : the element to remove
    
    Index : currently unused

--*/
{
    ULONG i, j;

    ASSERT(a);
    ASSERT(pElement);

    for (i = 0; i < a->Count; i++) {

        if ( a->Array[i] == pElement ) {

            if ( a->Count > 1 )
            {
                for (j = i; j < (a->Count - 1); j++) {
                    a->Array[j] = a->Array[j+1];
                }
            }

            //
            // We wouldn't have gotten in this loop if a->Count <= 0
            // 
            ASSERT( a->Count > 0 );

            a->Array[a->Count-1] = 0;
            a->Count--;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\dynarray.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    dynarray.h

Abstract:

    This file contains the definition of a dynamic array data type.

Author:

    Colin Brace ColinBr
    
Revision History

    3-12-97   ColinBr    Created
    
--*/

#ifndef __DYNARRAY_H
#define __DYNARRAY_H

VOID
DynamicArrayInit(
    IN PDYNAMIC_ARRAY a
    );

VOID
DynamicArrayDestroy(
    IN PDYNAMIC_ARRAY a
    );

DWORD
DynamicArrayGetCount(
    IN PDYNAMIC_ARRAY a
    );

VOID
DynamicArrayAdd(
    IN PDYNAMIC_ARRAY a,
    IN VOID*          pElement
    );

VOID*
DynamicArrayRetrieve(
    IN PDYNAMIC_ARRAY a,
    IN ULONG          Index
    );

VOID
DynamicArrayRemove(
    IN PDYNAMIC_ARRAY a,
    IN VOID*          pElement, OPTIONAL
    IN ULONG          Index
    );

#endif // __DYNARRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\schedman.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    schedman.h

Abstract:

    This file contains the definition of various structures used for the schedule
    cache.  These structures should be considered totally opaque -- the user
    cannot see their internal structure.

    These structures could be defined inside schedman.c, except we want them to
    be visible to 'dsexts.dll', the debugger extension.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    14-7-2000   NickHar   Created

--*/


/***** Header Files *****/
#include <ntrtl.h>


/***** Constants *****/
/* Magic numbers to ensure consistency of the Topl structures */
#define MAGIC_START 0xDEADBEEF
#define MAGIC_END   0x5EAC1C9
#define TOPL_ALWAYS_SCHEDULE         NULL


/***** ToplSched *****/
/* The internal definition of a schedule object */
typedef struct {
    LONG32      magicStart;
    PSCHEDULE   s;
    DWORD       duration;               /* Calculated when schedule is created */
    LONG32      magicEnd;
} ToplSched;


/***** ToplSchedCache *****/
/* The internal definition of a schedule cache */
typedef struct {
    LONG32              magicStart;
    RTL_GENERIC_TABLE   table;
    DWORD               numEntries;
    BOOLEAN             deletionPhase;      /* True if the schedule cache is being deleted */
    PSCHEDULE           pAlwaysSchedule;    /* A cached copy of the always Pschedule. This is
                                             * needed as a special case because the always
                                             * schedule is the only one not actually stored
                                             * in the cache. */
    LONG32              magicEnd;
} ToplSchedCache;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\iislib\win32obj.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    win32obj.c

Abstract:

    This module contains helper functions for creating debug-specific
    named Win32 objects. Functions are included for named events,
    semaphores, and mutexes.

    Object names created by these routines have the following format:

        filename.ext:line_number member:address PID:pid

    Where:

        filename.ext = The file name where the object was created.

        line_number = The line number within the file.

        member = The member/global variable name where the handle is
            stored. This name is provided by the caller, but is usually
            of the form "g_Global" for globals and "CLASS::m_Member" for
            class members.

        address = An address, used to guarantee uniqueness of the objects
            created. This is provided by the caller. For global variables,
            this is typically the address of the global. For class members,
            this is typically the address of the containing class.

        pid = The current process ID. This ensures uniqueness across all
            processes.

    Here are a couple of examples:

        main.cxx:796 g_hShutdownEvent:683a42bc PID:373

        resource.cxx:136 RTL_RESOURCE::SharedSemaphore:00250970 PID:373

Author:

    Keith Moore (keithmo)        23-Sep-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pudebug.h>


#define MAX_OBJECT_NAME 256 // chars


LONG g_PuDbgEventsCreated = 0;
LONG g_PuDbgSemaphoresCreated = 0;
LONG g_PuDbgMutexesCreated = 0;



LPSTR
PuDbgpBuildObjectName(
    IN LPSTR ObjectNameBuffer,
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address
    )

/*++

Routine Description:

    Internal routine that builds an appropriate object name based on
    the file name, line number, member name, address, and process ID.

Arguments:

    ObjectNameBuffer - Pointer to the target buffer for the name.

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

Return Value:

    LPSTR - Pointer to ObjectNameBuffer if successful, NULL otherwise.

    N.B. This routine always returns NULL when running under Win9x.

--*/

{

    PLATFORM_TYPE platformType;
    LPSTR fileNamePart;
    LPSTR result;

    //
    // We have no convenient way to dump objects w/ names from
    // Win9x, so we'll only enable this functionality under NT.
    //

    platformType = IISGetPlatformType();
    result = NULL;

    if( platformType == PtNtServer ||
        platformType == PtNtWorkstation ) {

        //
        // Find the filename part of the incoming source file name.
        //

        fileNamePart = strrchr( FileName, '\\' );

        if( fileNamePart == NULL ) {
            fileNamePart = strrchr( FileName, '/' );
        }

        if( fileNamePart == NULL ) {
            fileNamePart = strrchr( FileName, ':' );
        }

        if( fileNamePart == NULL ) {
            fileNamePart = FileName;
        } else {
            fileNamePart++;
        }

        //
        // Ensure we don't overwrite our object name buffer.
        //

        if( ( sizeof(":1234567890 :12345678 PID:1234567890") +
              strlen( fileNamePart ) +
              strlen( MemberName ) ) < MAX_OBJECT_NAME ) {

            wsprintfA(
                ObjectNameBuffer,
                "%s:%lu %s:%08lx PID:%lu",
                fileNamePart,
                LineNumber,
                MemberName,
                Address,
                GetCurrentProcessId()
                );

            result = ObjectNameBuffer;

        }

    }

    return result;

}   // PuDbgpBuildObjectName


HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    )

/*++

Routine Description:

    Creates a new event object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    ManualReset - TRUE to create a manual reset event, FALSE to create
        an automatic reset event.

    InitialState - The intitial state of the event object.

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateEventA(
                    NULL,                       // lpEventAttributes
                    ManualReset,                // bManualReset
                    InitialState,               // bInitialState
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgEventsCreated );
    }

    return objHandle;

}   // PuDbgCreateEvent


HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    )

/*++

Routine Description:

    Creates a new semaphore object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    InitialCount - The initial count of the semaphore.

    MaximumCount - The maximum count of the semaphore.

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateSemaphoreA(
                    NULL,                       // lpSemaphoreAttributes
                    InitialCount,               // lInitialCount
                    MaximumCount,               // lMaximumCount
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgSemaphoresCreated );
    }

    return objHandle;

}   // PuDbgCreateSemaphore


HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    )

/*++

Routine Description:

    Creates a new mutex object.

Arguments:

    FileName - The filename of the source creating the object. This
        is __FILE__ of the caller.

    LineNumber - The line number within the source. This is __LINE__
        of the caller.

    MemberName - The member/global variable name where the object handle
        is to be stored.

    Address - The address of the containing structure/class or of the
        global itself.

    InitialOwner - TRUE if the mutex should be created "owned".

Return Value:

    HANDLE - Handle to the object if successful, NULL otherwise.

--*/

{

    LPSTR objName;
    HANDLE objHandle;
    CHAR objNameBuffer[MAX_OBJECT_NAME];

    objName = PuDbgpBuildObjectName(
                  objNameBuffer,
                  FileName,
                  LineNumber,
                  MemberName,
                  Address
                  );

    objHandle = CreateMutexA(
                    NULL,                       // lpMutexAttributes
                    InitialOwner,               // bInitialOwner,
                    objName                     // lpName
                    );

    if( objHandle != NULL ) {
        InterlockedIncrement( &g_PuDbgMutexesCreated );
    }

    return objHandle;

}   // PuDbgCreateMutex
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\taskq\taskq.c ===
#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes
#include "dstrace.h"

// Assorted DSA headers.
#include "dsexcept.h"
#include "debug.h"                      // standard debugging header
#define DEBSUB "TASKQ:"                 // define the subsystem for debugging

#include <taskq.h>

#include <fileno.h>
#define  FILENO FILENO_TASKQ_TASKQ
#define  WAIT_OBJECT_1 (WAIT_OBJECT_0 + 1)

// Maximum delay until execution of the task.
//
// Tick counts wrap around after 
// 2^32 / (1000 msec/sec * 60 sec/min * 60 min/hr * 24 hr/day) = 49.7 days.  
// So with the current implementation the max taskq delay must be < 25 days
//
#define MAX_TASKQ_DELAY_SECS (7*24*60*60 + 1)


BOOL                gfIsTqRunning = FALSE;  // is the scheduler running?
CRITICAL_SECTION    gcsTaskQueue;           // acquired before modifying queue
HANDLE              ghTaskSchedulerThread;  // signalled when shutdown is complete
HANDLE              ghTqWakeUp;             // signalled to wake up scheduling thread
PTASKQFN            gpfnTqCurrentTask;      // current task being performed
BOOL                gfTqShutdownRequested;  // set when we're supposed to shut down
DWORD               gTaskSchedulerTID = 0;  // task scheduler thread id
                                            // init here because its exported
RTL_AVL_TABLE       gTaskQueue;             // task queue

// The array of handles to events that the task scheduler waits on, and the
// corresponding array of functions it calls when each event is triggered.
// The only "unique" event/function pair is at index 0 -- the event signals an
// event has been added to the queue, and the associated function is NULL.
PSPAREFN            grgFns[MAXIMUM_WAIT_OBJECTS];
HANDLE              grgWaitHandles[MAXIMUM_WAIT_OBJECTS];
DWORD               gcWaitHandles = 0;

unsigned __stdcall TaskScheduler( void * pv );
void InsertInTaskQueueHelper( pTQEntry pTQNew );
void RemoveFromTaskQueueInternal( pTQEntry pTQOld );
void TriggerCallback(void*, void**, DWORD*);

#if DBG
VOID debugPrintTaskQueue();
#endif

DWORD MsecUntilExecutionTime(
    IN  TQEntry *   ptqe,
    IN  DWORD       cTickNow
    );


RTL_GENERIC_COMPARE_RESULTS
TQCompareTime(
    RTL_AVL_TABLE       *Table,
    PVOID               FirstStruct,
    PVOID               SecondStruct)
{
    DWORD time1, time2;
    pTQEntry pTQ1,pTQ2;
    int res;

    pTQ1 = (pTQEntry)FirstStruct;
    pTQ2 = (pTQEntry)SecondStruct;

    time1 =  pTQ1->cTickDelay + pTQ1->cTickRegistered;
    time2 =  pTQ2->cTickDelay + pTQ2->cTickRegistered;

    // The tick count wraps about every 47 days.
    // The maximum delay a task is allowed to have is 7 days,
    // So the largest difference between two times won't exceed
    // 7 days in ideal situation.  Therefore, it is safe to use
    // a window of 0x7fffffff (23 days) for comparison.

    if (time1 != time2 ) {
        if ( time2-time1 < 0x7fffffff )
        {
            return(GenericLessThan);
        }
        return(GenericGreaterThan);
    }

    // the AVL table data structure requires a strict order.
    // two objects can be equal if and only if they are the
    // same object.  So here, do more test to decide the exact order.

    // (time1 == time2) is true here

    res= memcmp(FirstStruct, SecondStruct,sizeof(TQEntry));

    if ( 0 == res ) {
        return(GenericEqual);
    }
    else if (res < 0) {
        return(GenericLessThan);
    }

    return(GenericGreaterThan);

}


PVOID
TQAlloc(
    RTL_AVL_TABLE       *Table,
    CLONG               ByteSize)
{
    return(malloc(ByteSize));
}

VOID
TQFree(
    RTL_AVL_TABLE       *Table,
    PVOID               Buffer)
{
    free(Buffer);
}


DWORD
MsecUntilExecutionTime(
    IN  TQEntry *   ptqe,
    IN  DWORD       cTickNow
    )
{
    DWORD cTicksSinceRegistration = cTickNow - ptqe->cTickRegistered;

    if (ptqe->cTickDelay > cTicksSinceRegistration) {
        return ptqe->cTickDelay - cTicksSinceRegistration;
    }
    else {
        return 0;
    }
}

BOOL
InitTaskScheduler(
    DWORD           cSpareFns,
    SPAREFN_INFO *  pSpareFnInfo
    )
{
    DWORD i;
    BOOL fInitCS = FALSE;

    if ( gfIsTqRunning )
    {
        Assert( !"Attempt to reinitialize task scheduler while it's running!" );
    }
    else
    {
        Assert(cSpareFns < MAXIMUM_WAIT_OBJECTS-1);

        //init the Avl table

        RtlInitializeGenericTableAvl( &gTaskQueue,
                                      TQCompareTime,
                                      TQAlloc,
                                      TQFree,
                                      NULL );


        // initialize global state.

        gfTqShutdownRequested = FALSE;
        gpfnTqCurrentTask     = NULL;
        ghTqWakeUp            = NULL;
        ghTaskSchedulerThread = NULL;
        gTaskSchedulerTID     = 0;

        if ( InitializeCriticalSectionAndSpinCount( &gcsTaskQueue, 400 ) ) {

            fInitCS = TRUE;
            ghTqWakeUp = CreateEvent(
                            NULL,   // security descriptor
                            FALSE,  // manual reset
                            TRUE,   // initial state signalled?
                            NULL    // event name
                            );
        }

        if ( NULL == ghTqWakeUp )
        {
            LogUnhandledError( GetLastError() );
        }
        else
        {
            // Construct the array of wait handles and corresponding functions
            // to call to be used by the TaskScheduler() thread.
            grgFns[0] = NULL;
            grgWaitHandles[0] = ghTqWakeUp;
            gcWaitHandles = 1;

            for (i = 0; i < cSpareFns; i++) {
                if ((NULL != pSpareFnInfo[i].hevSpare)
                    && (NULL != pSpareFnInfo[i].pfSpare)) {
                    grgFns[gcWaitHandles] = pSpareFnInfo[i].pfSpare;
                    grgWaitHandles[gcWaitHandles] = pSpareFnInfo[i].hevSpare;
                    gcWaitHandles++;
                }
            }

            ghTaskSchedulerThread =
                (HANDLE) _beginthreadex(
                    NULL,
                    10000,
                    TaskScheduler,
                    NULL,
                    0,
                    &gTaskSchedulerTID
                    );

            if ( NULL == ghTaskSchedulerThread )
            {
                LogUnhandledError( GetLastError() );
                LogUnhandledError( errno );
            }
            else
            {
                gfIsTqRunning = TRUE;

                DPRINT( 1, "Synchronous task queue installed\n" );
            }
        }

        if ( !gfIsTqRunning )
        {
            // Unsuccessful startup attempt; free any resources we
            // managed to acquire.

            if ( NULL != ghTqWakeUp )
            {
                CloseHandle( ghTqWakeUp );
            }

            if ( fInitCS ) {
                DeleteCriticalSection(&gcsTaskQueue);
            }
        }
    }

    return gfIsTqRunning;
}

void
ShutdownTaskSchedulerTrigger()
{
    if ( gfIsTqRunning ) {

        gfTqShutdownRequested = TRUE;
        SetEvent( ghTqWakeUp );
    }
}



BOOL
ShutdownTaskSchedulerWait(
    DWORD   dwWaitTimeInMilliseconds
    )
{
    if ( gfIsTqRunning )
    {
        DWORD dwWaitStatus;

        Assert(gfTqShutdownRequested);

        dwWaitStatus = WaitForSingleObject(
                            ghTaskSchedulerThread,
                            dwWaitTimeInMilliseconds
                            );

        gfIsTqRunning = ( WAIT_OBJECT_0 != dwWaitStatus );

        if ( !gfIsTqRunning )
        {
            DeleteCriticalSection( &gcsTaskQueue );

            CloseHandle( ghTaskSchedulerThread );
            CloseHandle( ghTqWakeUp );

            DPRINT( 1, "Synchronous task queue shut down\n" );
        }
    }

    return !gfIsTqRunning;
}

PCHAR getCurrentTime(PCHAR pb)
// get current time in format hh:mm:ss.ddd and put it into the buffer. The buffer should be at least 13 chars long.
{
    SYSTEMTIME stNow;
    Assert(pb);
    GetLocalTime(&stNow);
    sprintf(pb, "%02d:%02d:%02d.%03d", stNow.wHour, stNow.wMinute, stNow.wSecond, stNow.wMilliseconds);
    return pb;
}

BOOL
DoInsertInTaskQueue(
    PTASKQFN    pfnTaskQFn,
    void *      pvParm,
    DWORD       cSecsFromNow,
    BOOL        fReschedule,
    PCHAR       pfnName
    )
/*
 * Insert a task into the task queue.  This version of the routine will return false
 * if the task queue is not running.  It is useful when the code you are calling this
 * from is in a race condition with shutdown.
 * if fReschedule then, it will first attempt to reschedule the task
 *
 */
{
    TQEntry    TQNew;
    CHAR timeStr[13];

    Assert(cSecsFromNow < MAX_TASKQ_DELAY_SECS);

    DPRINT5(1, "%s insert %s, param=%p, secs=%d%s\n", 
            getCurrentTime(timeStr), pfnName, pvParm, 
            cSecsFromNow, fReschedule ? ", reschedule" : "");

    if ( gfIsTqRunning )
    {
        // initialize new entry
        TQNew.pvTaskParm      = pvParm;
        TQNew.pfnTaskFn       = pfnTaskQFn;
        TQNew.cTickRegistered = GetTickCount();
        TQNew.cTickDelay      = cSecsFromNow * 1000;
        TQNew.pfnName         = pfnName;

        if ( fReschedule ) {
            // Remove previously set tasks (if they're there)
            // and then insert a new one.
            // This is more expensive, don't use if don't have to.
            (void)DoCancelTask( pfnTaskQFn, pvParm, pfnName );
        }

        // Duplicate *identical* entries already queued will be removed
        // (note: duplicate entries are only those that are identical
        //  in all fields (extremely unlikely) ).
        InsertInTaskQueueHelper( &TQNew );

#if DBG
        if (DebugTest(5, DEBSUB)) {
            debugPrintTaskQueue();
        }
#endif

        // awaken the task scheduler by posting its event
         SetEvent( ghTqWakeUp );
    }

    return TRUE;
}

void
InsertInTaskQueueHelper(
    pTQEntry    pTQNew
    )
{
    BOOLEAN fNewElement = TRUE;
    // gain access to queue
    EnterCriticalSection(&gcsTaskQueue);
    __try
    {

        RtlInsertElementGenericTableAvl( &gTaskQueue,
                                         pTQNew,
                                         sizeof(TQEntry),
                                         &fNewElement );

    }
    __finally
    {
        LeaveCriticalSection(&gcsTaskQueue);
    }
}


BOOL
DoCancelTask(
    PTASKQFN    pfnTaskQFn,
    void *      pvParm,
    PCHAR       pfnName
    )
/*++

Routine Description:

    Lookup task entry (ignoring time) & remove from task queue.

Arguments:

    pfnTaskQFn - task function
    pvParm - context paramter

Return Value:

    TRUE: Removed.
    FALSE: Wasn't removed

Remarks:
    This is an expensive operation. It traverses the AVL table,
    acquire locks, remove entry, re-insert, & unlocks.
    Don't use if you don't have to.

--*/
{
    TQEntry    TQNew;
    PVOID Restart = NULL;
    pTQEntry    ptqe;
    BOOL fFound = FALSE;
    CHAR timeStr[13];

    Assert(pfnTaskQFn);

    DPRINT3(1, "%s cancel %s, param=%p\n", getCurrentTime(timeStr), pfnName, pvParm);
    
    if ( !gfIsTqRunning )
    {
        Assert( !"CancelTask() called before InitTaskScheduler()!" );
        return FALSE;
    }

    // lock held during entire traversal
    EnterCriticalSection( &gcsTaskQueue );

    __try
    {
        //
        // Traverse table looking for our entry
        //
        for ( ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart);
             (NULL != ptqe) && !gfTqShutdownRequested;
              ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart))
        {

            if (ptqe->pfnTaskFn == pfnTaskQFn &&
                ptqe->pvTaskParm == pvParm) {
                // This is the same task (ignore time values)
                fFound = TRUE;
                break;
            }
        }

        if (fFound) {
            // remove old one
            RemoveFromTaskQueueInternal( ptqe );
        }

#if DBG
        if (DebugTest(5, DEBSUB)) {
            debugPrintTaskQueue();
        }
#endif
    
    }
    __finally
    {
        // why would we ever fail?
        // make sure we see it in case we do.
        Assert(!AbnormalTermination());

        // regardless, release
        LeaveCriticalSection( &gcsTaskQueue );
    }

    return fFound;
}





void
RemoveFromTaskQueueInternal(
    pTQEntry    pTQOld
    )
{
    BOOL res;
    // Critical section already held

    res = RtlDeleteElementGenericTableAvl( &gTaskQueue, (PVOID)pTQOld );

    //make sure the deletion always succeed
    Assert(res);

}

void
RemoveFromTaskQueue(
    pTQEntry    pTQOld
    )
{
    if ( !gfIsTqRunning )
    {
        Assert( !"RemoveFromTaskQueue() called before InitTaskScheduler()!" );
    }
    else
    {
        // gain access to queue
        EnterCriticalSection(&gcsTaskQueue);
        __try
        {
            RemoveFromTaskQueueInternal( pTQOld );
        }
        __finally
        {
            LeaveCriticalSection(&gcsTaskQueue);
        }
    }
}


pTQEntry
GetNextReadyTaskAndRemove( void )
{
    pTQEntry    ptqe, pTemp = NULL;
    PVOID Restart = NULL;

    EnterCriticalSection( &gcsTaskQueue );

    __try
    {
        ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart);
        if (ptqe) {
            if ( 0 == MsecUntilExecutionTime(ptqe, GetTickCount()) ) {

                //make a copy before deletion
                pTemp = malloc(sizeof(TQEntry));
                if (NULL==pTemp) {
                    __leave;
                }
                memcpy(pTemp,ptqe,sizeof(TQEntry));

                RemoveFromTaskQueueInternal( pTemp );
            }
        }
    }
    __finally
    {
        LeaveCriticalSection( &gcsTaskQueue );
    }

    // Note that this routine does not set the event that there is a new
    // task at the head of the queue. The caller is expected to do that.

    return pTemp;
}

pTQEntry
GetNextTask( void )
{
    pTQEntry    ptqe;
    PVOID Restart = NULL;

    EnterCriticalSection( &gcsTaskQueue );

    __try
    {
        ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart);
    }
    __finally
    {
        LeaveCriticalSection( &gcsTaskQueue );
    }

    return ptqe;
}

unsigned __stdcall
TaskScheduler(
    void *  pv
    )
{
    DWORD       cMSecUntilNextTask = 0;
    pTQEntry    ptqe;
    DWORD       err;
    DWORD       dwExcept;
    CHAR        timeStr[13];

    // tracing event buffer and ClientID
    CHAR traceHeaderBuffer[sizeof(EVENT_TRACE_HEADER)+sizeof(MOF_FIELD)];
    PEVENT_TRACE_HEADER traceHeader = (PEVENT_TRACE_HEADER)traceHeaderBuffer;
    PWNODE_HEADER wnode = (PWNODE_HEADER)traceHeader;
    DWORD clientID;
    
    // initialize tracing vars
    ZeroMemory(traceHeader, sizeof(EVENT_TRACE_HEADER)+sizeof(MOF_FIELD));
    wnode->Flags = WNODE_FLAG_USE_GUID_PTR | // Use a guid ptr instead of copying
                   WNODE_FLAG_USE_MOF_PTR  | // Data is not contiguous to header
                   WNODE_FLAG_TRACED_GUID;

    // Task queue does not have a ClientContext. We will create a fake one for tracing.
    // To distinguish between different modules and their task queues lets use a
    // global ptr (any one available, really). Hopefully, different modules will not
    // have it at exactly the same address.
    // If this approach is changed, don't forget to change the matching block of code in TriggerCallback
#if defined(_WIN64)
    {
        ULARGE_INTEGER lu;
        lu.QuadPart = (ULONGLONG)&gTaskQueue;
        clientID = lu.LowPart;
    }
#else
    clientID = (DWORD)&gTaskQueue;
#endif

    while ( !gfTqShutdownRequested )
    {
        // wait until time for next task, shutdown, or a new task
        err = WaitForMultipleObjects(gcWaitHandles,
                                     grgWaitHandles,
                                     FALSE,
                                     cMSecUntilNextTask);

        if (gfTqShutdownRequested) {
            continue;
        }
        if ((WAIT_OBJECT_0 < err)
            && (err < WAIT_OBJECT_0 + gcWaitHandles)) {
            // The event for one of the "spare" funtions has been signalled --
            // execute it.
            __try {
                (grgFns[err - WAIT_OBJECT_0])();
            }
            __except (HandleMostExceptions(dwExcept=GetExceptionCode())) {
                // Spare function generated a non-critical exception -- ignore
                // it.
                DPRINT2(0, "Spare fn %p generated exception %d!",
                        grgFns[err - WAIT_OBJECT_0], dwExcept);
            }
        }
        else {
            if ((WAIT_OBJECT_0 != err) && (WAIT_TIMEOUT != err)) {
                DWORD gle = GetLastError();
                DPRINT2(0, "TASK SCHEDULER WAIT FAILED! -- err = 0x%x, gle = %d\n",
                        err, gle);
                Assert(!"TASK SCHEDULER WAIT FAILED!");
                Sleep(30 * 1000);
            }

            // Rather than reference counting or marking an entry that is in use, the
            // task is removed from the queue during execution so other threads will not
            // disturb it.

            for ( ptqe = GetNextReadyTaskAndRemove() ;
                  ( !gfTqShutdownRequested
                    && ( NULL != ptqe ) ) ;
                  ptqe = GetNextReadyTaskAndRemove()
                )
            {
                void *  pvParamNext = NULL;
                DWORD   cSecsFromNow = TASKQ_DONT_RESCHEDULE;

                if (ptqe->pfnTaskFn != TriggerCallback) {
                    // don't log trigger callback calls -- those are logged inside the callback!
#if DBG
                    DPRINT3(1, "%s exec %s, param=%p\n", getCurrentTime(timeStr), ptqe->pfnName, ptqe->pvTaskParm);
                    if (DebugTest(5, DEBSUB)) {
                        debugPrintTaskQueue();
                    }
#endif
    
                    LogAndTraceEventWithHeader(FALSE,
                                               DS_EVENT_CAT_DIRECTORY_ACCESS,
                                               DS_EVENT_SEV_VERBOSE,
                                               DIRLOG_TASK_QUEUE_BEGIN_EXECUTE,
                                               EVENT_TRACE_TYPE_START,
                                               DsGuidTaskQueueExecute,
                                               traceHeader,
                                               clientID,
                                               szInsertSz(ptqe->pfnName),
                                               szInsertPtr(ptqe->pvTaskParm),
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL);
                }
                dwExcept = 0;
                
                __try {
                    // execute task
                    gpfnTqCurrentTask = ptqe->pfnTaskFn;
                    (*ptqe->pfnTaskFn)( ptqe->pvTaskParm,
                                       &pvParamNext,
                                       &cSecsFromNow );
                    gpfnTqCurrentTask = NULL;
                }
                __except ( HandleMostExceptions( dwExcept = GetExceptionCode() ) ) {
                    // a non-critical exception was generated in the bowels
                    // of the queued function; this clause ensures the
                    // scheduler thread continues unabated
                    ;
                }

                if (ptqe->pfnTaskFn != TriggerCallback) {
                    LogAndTraceEventWithHeader(FALSE,
                                               DS_EVENT_CAT_DIRECTORY_ACCESS,
                                               DS_EVENT_SEV_VERBOSE,
                                               DIRLOG_TASK_QUEUE_END_EXECUTE,
                                               EVENT_TRACE_TYPE_END,
                                               DsGuidTaskQueueExecute,
                                               traceHeader,
                                               clientID,
                                               szInsertSz(ptqe->pfnName),
                                               szInsertPtr(ptqe->pvTaskParm),
                                               szInsertHex(dwExcept),                                   
                                               szInsertInt(cSecsFromNow == TASKQ_DONT_RESCHEDULE ? -1 : cSecsFromNow),
                                               szInsertPtr(pvParamNext),
                                               NULL,
                                               NULL,
                                               NULL);
                }
                
                // Task has already been removed by this point

                if ( TASKQ_DONT_RESCHEDULE == cSecsFromNow ) {
                    // task is not to be rescheduled
                    free( ptqe );
                }
                else {
                    Assert(cSecsFromNow < MAX_TASKQ_DELAY_SECS);

                    // reschedule this task with new parameter and time
                    ptqe->pvTaskParm      = pvParamNext;
                    ptqe->cTickRegistered = GetTickCount();
                    ptqe->cTickDelay      = cSecsFromNow * 1000;

                    // Note that there is a window here where another thread could
                    // have inserted the same task already. We don't worry about this.
                    // At the worst, it results in an extra execution.
                    InsertInTaskQueueHelper( ptqe );

#if DBG
                    DPRINT4(1, "%s reschedule %s, param=%p, secs=%d\n", getCurrentTime(timeStr), ptqe->pfnName, pvParamNext, cSecsFromNow);
                    if (DebugTest(5, DEBSUB)) {
                        debugPrintTaskQueue();
                    }
#endif

                    // the rtl function will create another copy,
                    // so free the user copy.
                    free( ptqe );
                }
            }
        }

        // how much time until the next task?
        if ( NULL == (ptqe = GetNextTask())) {
            cMSecUntilNextTask = INFINITE;
        }
        else {
            cMSecUntilNextTask = MsecUntilExecutionTime(ptqe, GetTickCount());

            // look at comment on definition of MAX_TASKQ_DELAY_SECS
            Assert(cMSecUntilNextTask < 1000*MAX_TASKQ_DELAY_SECS);
        }
    }

    return 0;

    (void *) pv;    // unused
}

// This code shamelessly copied from the task triggering functionality in
// kcctask.cxx by Jeffparh.

typedef struct {
    PTASKQFN    pfnTaskQFn;
    void *      pvParm;
    PCHAR       pfnName;
    HANDLE      hevDone;
} TASK_TRIGGER_INFO;

void
TriggerCallback(
    IN  void *  pvTriggerInfo,
    OUT void ** ppvNextParam,
    OUT DWORD * pcSecsUntilNext
    )
//
// TaskQueue callback for triggered execution.  Wraps task execution.
//
{
    TASK_TRIGGER_INFO * pTriggerInfo;
    void *  pvParamNext = NULL;
    DWORD   cSecsFromNow = TASKQ_DONT_RESCHEDULE;
    CHAR    timeStr[13];
    DWORD   dwExcept = 0;

    // tracing event buffer and ClientID
    CHAR traceHeaderBuffer[sizeof(EVENT_TRACE_HEADER)+sizeof(MOF_FIELD)];
    PEVENT_TRACE_HEADER traceHeader = (PEVENT_TRACE_HEADER)traceHeaderBuffer;
    PWNODE_HEADER wnode = (PWNODE_HEADER)traceHeader;
    DWORD clientID;
    
    // initialize tracing vars
    ZeroMemory(traceHeader, sizeof(EVENT_TRACE_HEADER)+sizeof(MOF_FIELD));
    wnode->Flags = WNODE_FLAG_USE_GUID_PTR | // Use a guid ptr instead of copying
                   WNODE_FLAG_USE_MOF_PTR  | // Data is not contiguous to header
                   WNODE_FLAG_TRACED_GUID;

    // Task queue does not have a ClientContext. We will create a fake one for tracing.
    // To distinguish between different modules and their task queues lets use a
    // global ptr (any one available, really). Hopefully, different modules will not
    // have it at exactly the same address.
#if defined(_WIN64)
    {
        ULARGE_INTEGER lu;
        lu.QuadPart = (ULONGLONG)&gTaskQueue;
        clientID = lu.LowPart;
    }
#else
    clientID = (DWORD)&gTaskQueue;
#endif

    pTriggerInfo = (TASK_TRIGGER_INFO *) pvTriggerInfo;

#if DBG
    DPRINT3(1, "%s exec %s, param=%p\n", getCurrentTime(timeStr), pTriggerInfo->pfnName, pTriggerInfo->pvParm);
    if (DebugTest(5, DEBSUB)) {
        debugPrintTaskQueue();
    }
#endif
    
    LogAndTraceEventWithHeader(FALSE,
                               DS_EVENT_CAT_DIRECTORY_ACCESS,
                               DS_EVENT_SEV_VERBOSE,
                               DIRLOG_TASK_QUEUE_BEGIN_EXECUTE,
                               EVENT_TRACE_TYPE_START,
                               DsGuidTaskQueueExecute,
                               traceHeader,
                               clientID,
                               szInsertSz(pTriggerInfo->pfnName),
                               szInsertPtr(pTriggerInfo->pvParm),
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
    
    // Execute our task.
    __try {
        (*pTriggerInfo->pfnTaskQFn)(
            pTriggerInfo->pvParm,
            &pvParamNext,
            &cSecsFromNow );
    }
    __except ( HandleMostExceptions( dwExcept = GetExceptionCode() ) ) {
        // a non-critical exception was generated in the bowels
        // of the queued function; this clause ensures the
        // scheduler thread continues unabated
        ;
    }

    LogAndTraceEventWithHeader(FALSE,
                               DS_EVENT_CAT_DIRECTORY_ACCESS,
                               DS_EVENT_SEV_VERBOSE,
                               DIRLOG_TASK_QUEUE_END_EXECUTE,
                               EVENT_TRACE_TYPE_END,
                               DsGuidTaskQueueExecute,
                               traceHeader,
                               clientID,
                               szInsertSz(pTriggerInfo->pfnName),
                               szInsertPtr(pTriggerInfo->pvParm),
                               szInsertHex(dwExcept),
                               szInsertInt(-1), // triggered tasks are not allowed to reschedule
                               szInsertPtr(NULL),
                               NULL,
                               NULL,
                               NULL);
    
    // This is a one-shot execution; don't reschedule.
    *pcSecsUntilNext = TASKQ_DONT_RESCHEDULE;

    SetEvent(pTriggerInfo->hevDone);

    free(pTriggerInfo);
}


DWORD
DoTriggerTaskSynchronously(
    PTASKQFN    pfnTaskQFn,
    void *      pvParm,
    PCHAR       pfnName
    )

/*++

Routine Description:

    Cause the given task queue function to be executed synchonously with respect
    to other tasks in the task queue.  The task is executed as soon as possible.
    The task is not automatically rescheduled.

    Execution of the task in this manner does not interfere with other
    scheduled instances of this task already in the queue.

Arguments:

    pfnTaskQFn -
    pvParm -

Return Value:

    DWORD -

--*/

{
    HANDLE                  hevDone = NULL;
    HANDLE                  rgWaitHandles[2];
    DWORD                   waitStatus;
    TASK_TRIGGER_INFO * pTriggerInfo = NULL;
    DWORD                   ret = 0;
    CHAR                    timeStr[13];

#if DBG
    DPRINT3(1, "%s trigger %s, param=%p\n", getCurrentTime(timeStr), pfnName, pvParm);
    if (DebugTest(5, DEBSUB)) {
        debugPrintTaskQueue();
    }
#endif

    pTriggerInfo = (TASK_TRIGGER_INFO *) malloc(sizeof(*pTriggerInfo));
    if (NULL == pTriggerInfo) {
        return ERROR_OUTOFMEMORY;
    }

    // Waiting for completion; create synchronization event.
    hevDone = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == hevDone) {
        free(pTriggerInfo);
        return GetLastError();
    }

    pTriggerInfo->hevDone    = hevDone;
    pTriggerInfo->pfnTaskQFn = pfnTaskQFn;
    pTriggerInfo->pvParm     = pvParm;
    pTriggerInfo->pfnName    = pfnName;

    if (!DoInsertInTaskQueue(&TriggerCallback, pTriggerInfo, 0, FALSE, "TriggerCallback")) {
        free(pTriggerInfo);
        CloseHandle(hevDone);
        return ERROR_OUTOFMEMORY;
    }

    // Wait for completion.
    // The reason we wait on the task scheduler thread is that this code is in
    // a standalone library and cannot rely on any external shutdown event.
    rgWaitHandles[0] = ghTaskSchedulerThread;
    rgWaitHandles[1] = hevDone;

    waitStatus = WaitForMultipleObjects(2,
                                        rgWaitHandles,
                                        FALSE,
                                        INFINITE);
    switch (waitStatus) {
    case WAIT_OBJECT_0:
        // Shutdown.
        ret = ERROR_DS_SHUTTING_DOWN;
        break;
    case WAIT_OBJECT_0 + 1:
        // Task completed!
        ret = ERROR_SUCCESS;
        break;
    case WAIT_FAILED:
        // There may be a race condition where the task thread handle gets closed
        // by the shutdown task scheduler wait routine.
        if (gfTqShutdownRequested) {
            ret = ERROR_DS_SHUTTING_DOWN;
        } else {
            ret = GetLastError();
        }
        break;
    default:
        ret = ERROR_DS_INTERNAL_FAILURE;
        break;
    }

    CloseHandle(hevDone);

    return ret;

} /* TriggerTask */


#if DBG

// maximum number of entries to print
DWORD gDebugPrintTaskQueueMaxEntries = 100;

VOID debugPrintTaskQueue()
/*
  Description:
  
    Prints the current state of the task queue.
    Only for debugging purposes
    
*/
{
    PVOID Restart = NULL;
    pTQEntry    ptqe;
    CHAR execTime[13], schedTime[13];
    DWORD count;
    SYSTEMTIME  st, stNow;
    FILETIME    ft, ftNow;
    DWORD       cTickNow, cTickDiff;
    ULARGE_INTEGER uliTime;
    
    // note: the width of param column (ptr) is different for 32- and 64-bit
#if defined(_WIN64)
    DebPrint(0, "%-12s %-30s %-17s %6s %-12s\n", NULL, 0, "ExecTime", "Function", "Param", "Delay", "SchedTime");
#else
    DebPrint(0, "%-12s %-30s %-8s %6s %-12s\n", NULL, 0, "ExecTime", "Function", "Param", "Delay", "SchedTime");
#endif

    //get current time and tick count
    //use it to calculate the rigistered time later
    cTickNow = GetTickCount();
    GetLocalTime( &stNow );
    SystemTimeToFileTime( &stNow, &ftNow );
    
    // lock held during entire traversal
    EnterCriticalSection( &gcsTaskQueue );
    
    __try
    {
        //
        // Traverse table
        //
        for (ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart), count = 0;
             (NULL != ptqe) && !gfTqShutdownRequested;
             ptqe = RtlEnumerateGenericTableWithoutSplayingAvl(&gTaskQueue, &Restart), count++)
        {
            if (count >= gDebugPrintTaskQueueMaxEntries) {
                // don't print more than max entries
                DebPrint(0, "more entries...\n", NULL, 0);
                break;
            }

            //calculate registered time = current time - tick difference
            cTickDiff = cTickNow - ptqe->cTickRegistered;

            //copy FILETIME to ULARGE_INTEGER
            uliTime.LowPart =  ftNow.dwLowDateTime;
            uliTime.HighPart = ftNow.dwHighDateTime;

            //64-bit substraction, 1 tick = 1 ms = 10000 100-nanosec
            uliTime.QuadPart -= (ULONGLONG)cTickDiff * 10000;

            //copy ULARGE_INTEGER back to FILETIME
            ft.dwLowDateTime = uliTime.LowPart;
            ft.dwHighDateTime = uliTime.HighPart;

            //convert the file time to system time
            FileTimeToSystemTime( &ft, &st );

            sprintf(schedTime, "%02d:%02d:%02d.%03d", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

            // compute exec time
            //64-bit addition, 1 tick = 1 ms = 1000 100-nanosec
            uliTime.QuadPart += (ULONGLONG)ptqe->cTickDelay * 10000;

            //copy ULARGE_INTEGER back to FILETIME
            ft.dwLowDateTime = uliTime.LowPart;
            ft.dwHighDateTime = uliTime.HighPart;

            //convert the file time to system time
            FileTimeToSystemTime( &ft, &st );

            sprintf(execTime, "%02d:%02d:%02d.%03d", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

            // now can print
            DebPrint(0, "%12s %-30s %p %6d %12s\n", NULL, 0, 
                     execTime, ptqe->pfnName, ptqe->pvTaskParm, ptqe->cTickDelay/1000, schedTime);
        }
    }
    __finally
    {
        // regardless, release
        LeaveCriticalSection( &gcsTaskQueue );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\stubs\stubs.c ===
/* Copyright 1998-2000, Microsoft Corp.  All Rights Reserved */
/*
   This file contains stubbed out versions of routines that exist in
   ntdsa.dll, but that we do not want to link to and/or properly initialize
   in mkdit and mkhdr.  For every set of routines added into this file, one
   library should be omitted from the UMLIBS section of the boot\sources file.
 */
#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                   // schema cache
#include <dbglobal.h>                 // The header for the directory database
#include <mdglobal.h>                 // MD global definition header
#include <dsatools.h>                 // needed for output allocation
#include "dsevent.h"                  // header Audit\Alert logging
#include "mdcodes.h"                  // header for error codes
#include "dsexcept.h"
#include "debug.h"                    // standard debugging header

DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }
int DBAddSess(JET_SESID sess, JET_DBID dbid) { return 0; }


//
// Stubs for event logging functions from dsevent.lib.
//

DS_EVENT_CONFIG DsEventConfig = {0};
DS_EVENT_CONFIG * gpDsEventConfig = &DsEventConfig;

void __fastcall DoLogUnhandledError(unsigned long ulID, int iErr, int iIncludeName)
{ ; }

BOOL DoLogOverride(DWORD fileno, ULONG sev)
{ return FALSE; }

BOOL DoLogEvent(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, int iIncludeName,
    char *arg1, char *arg2, char *arg3, char *arg4,
    char *arg5, char *arg6, char *arg7, char *arg8,
    DWORD cbData, VOID * pvData)
{ return TRUE; }

BOOL DoLogEventW(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, int iIncludeName,
    WCHAR *arg1, WCHAR *arg2, WCHAR *arg3, WCHAR *arg4,
    WCHAR *arg5, WCHAR *arg6, WCHAR *arg7, WCHAR *arg8,
    DWORD cbData, VOID * pvData)
{ return TRUE; }

BOOL DoAlertEvent(MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, ...)
{ return FALSE; }

BOOL DoAlertEventW(MessageId midCategory, ULONG ulSeverity,
    MessageId midEvent, ...)
{ return FALSE; }

VOID RegisterLogOverrides(void)
{ ; }

void UnloadEventTable(void)
{ ; }

HANDLE LoadEventTable(void)
{ return NULL; }

PSID GetCurrentUserSid(void)
{ return NULL; }

VOID DoLogEventAndTrace(IN PLOG_PARAM_BLOCK LogBlock)
{ ; }

DS_EVENT_CONFIG * DsGetEventConfig(void)
{ return gpDsEventConfig; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\taskq\tqutest.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    tqutest.c

ABSTRACT:

    Unit test for task scheduler functions.

DETAILS:

CREATED:

    01/13/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop
#include <drs.h>
#include <taskq.h>

BOOL    fFailed = FALSE;
BOOL    rgfExecuted[ 8 ];

// Stuff needed by DSCOMMON.LIB
DWORD ImpersonateAnyClient() { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient() { ; }

void SetFlag( void * pv, void ** ppv, DWORD * pSecsUntilNext )
{
    DWORD   iMyFlag = (DWORD) pv;
    DWORD   iFlag;

    // Make sure previous flags have been set.
    for ( iFlag = 0; iFlag < iMyFlag; iFlag++ )
    {
        if ( !rgfExecuted[ iFlag ] )
        {
            printf( "Function %d was not executed before function %d!\n", iFlag, iMyFlag );
            fFailed = TRUE;
        }
    }

    if ( rgfExecuted[ iMyFlag ] )
    {
        printf( "Function %d was executed twice!\n", iMyFlag );
        fFailed = TRUE;
    }

    rgfExecuted[ iMyFlag ] = TRUE;
    
    *pSecsUntilNext = TASKQ_DONT_RESCHEDULE;
}

    

int
__cdecl
main(
    int     argc,
    char *  argv[]
    )
{
    printf( "TQUTEST.EXE\n"
            "Unit test for task scheduler functions.\n"
            "Jeff Parham (JeffParh), 97/01/13\n"
            "\n" );

    InitTaskScheduler(0, NULL);

    ZeroMemory( rgfExecuted, sizeof( rgfExecuted ) );
    InsertInTaskQueue( SetFlag, (void *) ( 5 - 1 ), 5 );
    InsertInTaskQueue( SetFlag, (void *) ( 1 - 1 ), 1 );
    InsertInTaskQueue( SetFlag, (void *) ( 7 - 1 ), 7 );
    InsertInTaskQueue( SetFlag, (void *) ( 4 - 1 ), 4 );
    InsertInTaskQueue( SetFlag, (void *) ( 6 - 1 ), 6 );
    InsertInTaskQueue( SetFlag, (void *) ( 2 - 1 ), 2 );
    InsertInTaskQueue( SetFlag, (void *) ( 8 - 1 ), 8 );
    InsertInTaskQueue( SetFlag, (void *) ( 3 - 1 ), 3 );

    Sleep( 10000 );

    if ( !fFailed )
    {
        DWORD   iFlag;

        for ( iFlag = 0; iFlag < sizeof( rgfExecuted ) / sizeof( rgfExecuted[ 0 ] ); iFlag++ )
        {
            if ( !rgfExecuted[ iFlag ] )
            {
                printf( "Function %d was not executed!\n", iFlag );
                fFailed = TRUE;
            }
        }

        if ( !fFailed )
        {
            ShutdownTaskSchedulerTrigger();
            fFailed = !ShutdownTaskSchedulerWait( 1000 );

            if ( fFailed )
            {
                printf( "Task scheduler failed to shut down!\n" );
            }
        }
    }

    printf( fFailed ? "Test failed!\n" : "Test passed!\n" );

    return fFailed;
}


void
DebPrint(
    USHORT      sev,
    UCHAR *     str,
    CHAR *      debsub,
    unsigned    uLineNo,
    ...
    )
{
    DWORD tid = GetCurrentThreadId();

    va_list   argptr;
    va_start( argptr, uLineNo );

    if (debsub)
    {
        printf("<%s%u:%u> ", debsub, tid, uLineNo);
    }
    vprintf( str, argptr );

    va_end( argptr );
}


void DoAssert(char *szExp, char *szFile, int nLine )
{
    char szMessage[1024];

    _snprintf(
        szMessage,
        sizeof( szMessage ),
        "DSA assertion failure: \"%s\"\n"
             "File %s line %d\n"
             "For bug reporting purposes, please enter the "
             "debugger (Retry) and record the current call stack.  Also, please "
             "record the last messages in the Application Event Log.\n"
             "Thank you for your support.",
        szExp,
        szFile,
        nLine
        );

    switch (
        MessageBox(
            NULL,
            szMessage,
            "DSA assertion failure",
            (   MB_TASKMODAL
              | MB_ICONSTOP
              | MB_ABORTRETRYIGNORE
              | MB_DEFBUTTON2
              | MB_SETFOREGROUND
            )
        )
    )
    {
    case IDABORT:
        exit(1);
        break;
    case IDRETRY:
        DebugBreak();
        break;
    case IDIGNORE:
        /* best of luck, you're gonna need it */
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\schedman.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    schedman.c

Abstract:

    This file implements a schedule cache, and several 'helper' function to
    manipulate them. The cache is implemented using an efficient dictionary,
    provided by ntrtl.h.

Notes:
    
    'Always schedules' (schedules whose bits are all 1) are represented by
    a NULL pointer. (This is so that that site links without schedules default
    to an always schedule). Always schedules are never stored in the cache.

    'Never schedules' are not desirable and are treated as error conditions.
    They are not valid schedules for importing into the cache.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    13-6-2000   NickHar   Created
    
--*/

/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <w32topl.h>
#include "w32toplp.h"
#include "schedman.h"


/***** Constants *****/
/* Constants for the ToplScheduleCreate() function */
#define DEFAULT_INTERVAL 12          /* Three hours */
#define STARTING_INTERVAL 0          /* Default schedules start at 12am Sun morning */
#define SCHED_NUMBER_INTERVALS_DAY   (4 * 24)
#define SCHED_NUMBER_INTERVALS_WEEK  (7 * SCHED_NUMBER_INTERVALS_DAY)
#define TOPL_ALWAYS_DURATION         (15*SCHED_NUMBER_INTERVALS_WEEK)


/***** CalculateDuration *****/
/* Given a schedule, determine for how many minutes this schedule is available.
 * We do this by counting bits in the schedule data.
 * The format of this schedule should have been checked already. */
DWORD
CalculateDuration(
    IN PSCHEDULE schedule
    )
{
    /* Quick way to count the number of 1 bits in a nibble: use a table */
    const int BitCount[16] = { 
        /* 0000 */  0,       /* 0001 */  1,
        /* 0010 */  1,       /* 0011 */  2,
        /* 0100 */  1,       /* 0101 */  2,
        /* 0110 */  2,       /* 0111 */  3,
        /* 1000 */  1,       /* 1001 */  2,
        /* 1010 */  2,       /* 1011 */  3,
        /* 1100 */  2,       /* 1101 */  3,
        /* 1110 */  3,       /* 1111 */  4
    };
    DWORD cbSchedData, iByte, count;
    const unsigned char DataBitMask = 0xF;
    PBYTE pb;

    cbSchedData = SCHEDULE_DATA_ENTRIES;
    pb = ((unsigned char*) schedule) + schedule->Schedules[0].Offset;

    count = 0;
    for( iByte=0; iByte<cbSchedData; iByte++ ) {
        count += BitCount[ pb[iByte]&DataBitMask ];
    }

    return 15*count;
}


/***** CheckPSchedule *****/
/* Checks that a PSchedule has the format that we expect:
 * there is exactly one schedule header, of type SCHEDULE_INTERVAL,
 * and the structure has the proper size. If the pschedule is NULL
 * or in an unsupported format, we throw an exception. */
VOID
CheckPSchedule(
    IN PSCHEDULE s
    )
{
    if( s==NULL ) {
        ToplRaiseException( TOPL_EX_SCHEDULE_ERROR );
    }

    /* We only support schedules in the exact format that the KCC creates. */
    if( s->Size != sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES
        || s->NumberOfSchedules != 1
        || s->Schedules[0].Type != SCHEDULE_INTERVAL
        || s->Schedules[0].Offset != sizeof(SCHEDULE) )
    {
        ToplRaiseException( TOPL_EX_SCHEDULE_ERROR );
    }
}


/***** CheckSchedule *****/
/* This function is used to check schedules before use. We throw an exception
 * if the schedule is not valid. If the schedule is okay, it is cast to the
 * internal representation.
 * The Schedule passed in should not be NULL. NULL schedules, which represent
 * the always schedule, should be handled as a special case by the caller. */
ToplSched*
CheckSchedule(
    IN TOPL_SCHEDULE Schedule
    )
{
    ToplSched *schedule = (ToplSched*) Schedule;
    PSCHEDULE s;

    ASSERT( Schedule!=NULL );
    if( schedule->magicStart!=MAGIC_START || schedule->magicEnd!=MAGIC_END ) {
        ToplRaiseException( TOPL_EX_SCHEDULE_ERROR );
    }

    CheckPSchedule( schedule->s );
    return schedule;
}


/***** CheckScheduleCache *****/
/* This function is used to schedule a schedule cache before use. We throw
 * an exception if the schedule cache is not valid. If the schedule is okay,
 * it is cast to the internal representation. */
ToplSchedCache*
CheckScheduleCache(
    IN TOPL_SCHEDULE_CACHE ScheduleCache
    )
{
    ToplSchedCache *scheduleCache = (ToplSchedCache*) ScheduleCache;

    if( scheduleCache==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    if( scheduleCache->magicStart!=MAGIC_START
     || scheduleCache->magicEnd!=MAGIC_END ) {
        ToplRaiseException( TOPL_EX_CACHE_ERROR );
    }
    CheckPSchedule( scheduleCache->pAlwaysSchedule );

    return scheduleCache;
}


/***** TableCompare *****/
/* This function checks the actual bitmaps of two schedules to see if
 * they represent the same schedule. Both schedules are in the internal
 * representation, a ToplSched structure. This function is used by the
 * RTL table functions.
 *
 * Preconditions:
 *
 *      Both schedules have successfully passed the CheckSchedule()
 *      function. We don't check that in here for efficiency reasons,
 *      except on DBG builds.
 */
RTL_GENERIC_COMPARE_RESULTS
NTAPI TableCompare(
    RTL_GENERIC_TABLE *Table,
    PVOID Item1, PVOID Item2
	)
{
    ToplSchedCache      *scheduleCache;
	ToplSched           *Schedule1 = (ToplSched*) Item1,
                        *Schedule2 = (ToplSched*) Item2;
    PSCHEDULE           s1, s2;
    unsigned char       *pb1, *pb2;
    const unsigned char DataBitMask = 0x0F;
    DWORD               iByte, cbSchedData;

    /* The always schedule cannot be stored in the cache */
    ASSERT( Item1 != TOPL_ALWAYS_SCHEDULE );
    ASSERT( Item2 != TOPL_ALWAYS_SCHEDULE );

    #ifdef DBG
        scheduleCache = CheckScheduleCache( Table->TableContext );
        if( ! scheduleCache->deletionPhase ) {
            __try {
                CheckSchedule( Schedule1 );
                CheckSchedule( Schedule2 );
            } __except( EXCEPTION_EXECUTE_HANDLER ) {
                /* If the above checks don't pass, it's a bug. */
                ASSERT(0);  
            }
        }
    #endif
    
    s1 = Schedule1->s;
    s2 = Schedule2->s;
    cbSchedData = SCHEDULE_DATA_ENTRIES;

    pb1 = ((unsigned char*) s1) + s1->Schedules[0].Offset;
    pb2 = ((unsigned char*) s2) + s2->Schedules[0].Offset;
    
    for( iByte=0; iByte<cbSchedData; iByte++ ) {
        if( (pb1[iByte] & DataBitMask) < (pb2[iByte] & DataBitMask) ) {
            return GenericLessThan;
        } else if( (pb1[iByte] & DataBitMask) > (pb2[iByte] & DataBitMask) ) {
            return GenericGreaterThan;
        }
    }

    return GenericEqual;
}


/***** TableAlloc *****/
/* This function is used as the allocator for the RTL table */
static PVOID
NTAPI TableAlloc( RTL_GENERIC_TABLE *Table, CLONG ByteSize )
{
    return ToplAlloc( ByteSize );
}


/***** TableFree *****/
/* This function is used as the deallocator for the RTL table */
static VOID
NTAPI TableFree( RTL_GENERIC_TABLE *Table, PVOID Buffer )
{
    ToplFree( Buffer );
}


/***** CreateAlwaysSchedule *****/
/* Allocate and initialize a PSCHEDULE which is always available. */
PSCHEDULE
CreateAlwaysSchedule(
    VOID
    )
{
    const unsigned char OpenHour=0x0F;
    DWORD iByte, cbSchedule, cbSchedData;
    unsigned char *pb;
    PSCHEDULE s;

    /* Create a new schedule */
    cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    cbSchedData = SCHEDULE_DATA_ENTRIES;
    s = (SCHEDULE*) ToplAlloc( cbSchedule );

    /* Set up the header for s */
    s->Size = cbSchedule;
    s->NumberOfSchedules = 1;
    s->Schedules[0].Type = SCHEDULE_INTERVAL;
    s->Schedules[0].Offset = sizeof(SCHEDULE);

    /* Set the schedule data to be all open */
    pb = ((unsigned char*) s) + s->Schedules[0].Offset;
    for( iByte=0; iByte<cbSchedData; iByte++ ) {
        pb[iByte] = OpenHour;
    }

    return s;
}


/***** ToplScheduleCacheCreate *****/
/* Create a cache, and create the RTL table to store cache entries */
TOPL_SCHEDULE_CACHE
ToplScheduleCacheCreate(
    VOID
    )
{
    ToplSchedCache*     scheduleCache;

    scheduleCache = ToplAlloc( sizeof(ToplSchedCache) );

    /* Create the RTL table we will use to store the cache elements */
    RtlInitializeGenericTable( &scheduleCache->table, TableCompare,
        TableAlloc, TableFree, scheduleCache );

    /* Set up the main cache entries. We store a single copy of an
     * 'always available' PSchedule so that it can be passed as a
     * return value from ToplScheduleExportReadonly(). */
    scheduleCache->numEntries = 0;
    scheduleCache->deletionPhase = FALSE;
    scheduleCache->pAlwaysSchedule = CreateAlwaysSchedule();

    /* Set up the magic numbers */
    scheduleCache->magicStart = MAGIC_START;
    scheduleCache->magicEnd = MAGIC_END;

    CheckScheduleCache( scheduleCache );

    return scheduleCache;
}


/***** ToplScheduleCacheDestroy *****/
/* Destroy the cache Frees all storage occupied by the cache and any handles in
 * the cache. The TOPL_SCHEDULE objects are also freed, and should not be used
 * after destroying the cache that they live in.
 *
 * This is not elegant, but we manually enumerate through all table entries in
 * order to delete them. (It appears that we also have to search for an entry
 * in order to delete it). We must clear the entry's magic numbers before
 * deleting it (to catch illegal reuse of an object after the cache has been
 * destroyed). However, if we clear the magic numbers, the search function will
 * be unhappy, so we set a flag 'deletionPhase'. The search function will not
 * check magic numbers if this flag is true.
 */
VOID
ToplScheduleCacheDestroy(
    IN TOPL_SCHEDULE_CACHE ScheduleCache
    )
{
    ToplSchedCache* scheduleCache = CheckScheduleCache( ScheduleCache );
    ToplSched* schedule;
    PSCHEDULE s;
    
    scheduleCache->deletionPhase = TRUE;

    while( ! RtlIsGenericTableEmpty(&scheduleCache->table) ) {

        schedule = (ToplSched*) RtlGetElementGenericTable( &scheduleCache->table, 0 );
        if( TOPL_ALWAYS_SCHEDULE==schedule ) {
            ASSERT(!"RtlGetElementGenericTable() returned NULL but table was not empty");
            break;
        }
        CheckSchedule( schedule );
        s = schedule->s;

        schedule->magicStart = 0;
        schedule->magicEnd = 0;
        RtlDeleteElementGenericTable( &scheduleCache->table, schedule );

        ToplFree(s);
    }
    
    ToplFree( scheduleCache->pAlwaysSchedule );
    scheduleCache->pAlwaysSchedule = NULL;
    scheduleCache->numEntries = 0;
    scheduleCache->magicStart = scheduleCache->magicEnd = 0;
    ToplFree( scheduleCache );
}


/***** ToplScheduleImport *****/
/* Store a schedule in the cache, either by creating a new entry, or
 * reusing an identical entry which is already in the cache. The
 * pExternalSchedule parameter is copied into the cache, and may be
 * immediately freed by the caller.
 * 
 * Note: If pExternalSchedule is NULL, this is interpreted as the 
 * always schedule and TOPL_ALWAYS_SCHEDULE is returned as a result. */
TOPL_SCHEDULE
ToplScheduleImport(
    IN TOPL_SCHEDULE_CACHE ScheduleCache,
    IN PSCHEDULE pExternalSchedule
    )
{
    ToplSchedCache* scheduleCache = CheckScheduleCache( ScheduleCache );
    ToplSched searchKey, *cachedSched;
    PSCHEDULE newSchedule=NULL;
    BOOLEAN newElement=FALSE;
    DWORD cbSchedule, duration;
    
    /* NULL schedules are a special case -- they are the always schedule */
    if( pExternalSchedule==NULL ) {
        return TOPL_ALWAYS_SCHEDULE;
    }
    CheckPSchedule( pExternalSchedule );

    /* Check for an all-ones schedule */
    duration = CalculateDuration( pExternalSchedule );
    if( duration==TOPL_ALWAYS_DURATION ) {
        return TOPL_ALWAYS_SCHEDULE;
    }
    
    /* Create a copy of the external schedule, assuming we need to store
     * it in the cache */
    cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    newSchedule = (PSCHEDULE) ToplAlloc( cbSchedule );
    RtlCopyMemory( newSchedule, pExternalSchedule, cbSchedule );
    
    /* Create a search key containing the copy of the new schedule. This search
     * key is just a dummy. Its contents will be copied into the table. */
    searchKey.magicStart = MAGIC_START;
    searchKey.s = newSchedule;
    searchKey.duration = duration;
    searchKey.magicEnd = MAGIC_END;
    
    __try {
        
        /* Search our cache table for a schedule which matches this one */
        cachedSched = (ToplSched*) RtlInsertElementGenericTable(
            &scheduleCache->table, &searchKey, sizeof(ToplSched), &newElement );
        
        if( newElement ) {
            /* No cached copy existed, so a new copy has been added to the cache */
            scheduleCache->numEntries++;
        }
    }
    __finally {
        /* If RtlInsertElementGenericTable() throws an exception, or if the
         * schedule was already in the cache, we must free the memory used by
         * the new schedule allocated above. */
        if( AbnormalTermination() || newElement==FALSE ) {
            ToplFree( newSchedule );
        }
    }
    
    return cachedSched;
}


/***** ToplScheduleNumEntries *****/
/* Returns a count of how many unique schedules are stored in the cache.
 * Note: this count does not include any always schedules that were
 * imported into the cache. */
DWORD
ToplScheduleNumEntries(
    IN TOPL_SCHEDULE_CACHE ScheduleCache
    )
{
    ToplSchedCache* scheduleCache = CheckScheduleCache( ScheduleCache );
    return scheduleCache->numEntries;
}


/***** ToplScheduleExportReadonly *****/
/* This function is used to grab the PSCHEDULE structure from a
 * TOPL_SCHEDULE. The structure should be considered readonly by
 * the user, and should _not_ be deallocated by him (or her).
 * Note: If the input is TOPL_ALWAYS_SCHEDULE, a properly constructed
 * PSCHEDULE _will_ be returned. */
PSCHEDULE
ToplScheduleExportReadonly(
    IN TOPL_SCHEDULE_CACHE ScheduleCache,
    IN TOPL_SCHEDULE Schedule
    )
{
    ToplSchedCache *scheduleCache = CheckScheduleCache( ScheduleCache );
    ToplSched* schedule;
    PSCHEDULE pExportSchedule;

    if( Schedule==TOPL_ALWAYS_SCHEDULE ) {
        pExportSchedule = scheduleCache->pAlwaysSchedule;
    } else {
        schedule = CheckSchedule( Schedule );
        pExportSchedule = schedule->s;
    }

    ASSERT( NULL!=pExportSchedule );
    return pExportSchedule;
}


/***** ToplScheduleMerge *****/
/* Return a new cached schedule which is the intersection of the two provided 
 * schedules. If the two schedules do not intersect, the fIsNever flag is set
 * to true. */
TOPL_SCHEDULE
ToplScheduleMerge(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN TOPL_SCHEDULE Schedule1,
	IN TOPL_SCHEDULE Schedule2,
    OUT PBOOLEAN fIsNever
	)
{
    TOPL_SCHEDULE result=NULL;
    DWORD iByte, cbSchedule, cbSchedData;
    const unsigned char DataBitMask=0xF, HighBitMask=0xF0;
    unsigned char *pb1, *pb2, *pb3, dataAnd, nonEmpty;
    PSCHEDULE s1=NULL, s2=NULL, s3=NULL;

    /* Check parameters */
    CheckScheduleCache( ScheduleCache );
    if( Schedule1!=TOPL_ALWAYS_SCHEDULE ) {
        s1 = CheckSchedule( Schedule1 )->s;
    }
    if( Schedule2!=TOPL_ALWAYS_SCHEDULE ) {
        s2 = CheckSchedule( Schedule2 )->s;
    }
    if( fIsNever==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }

    /* If either schedule is the always schedule, we can just return the
     * other schedule straight away. */ 
    if( Schedule1==TOPL_ALWAYS_SCHEDULE ) {
        *fIsNever=FALSE;
        return Schedule2;
    }
    if( Schedule2==TOPL_ALWAYS_SCHEDULE ) {
        *fIsNever=FALSE;
        return Schedule1;
    }

    /* Create a new schedule to store the AND of s1 and s2 */
    cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    cbSchedData = SCHEDULE_DATA_ENTRIES;
    s3 = (PSCHEDULE) ToplAlloc( cbSchedule );
    RtlCopyMemory( s3, s1, sizeof(SCHEDULE) );

    pb1 = ((unsigned char*) s1) + s2->Schedules[0].Offset;
    pb2 = ((unsigned char*) s2) + s2->Schedules[0].Offset;
    pb3 = ((unsigned char*) s3) + s3->Schedules[0].Offset;

    nonEmpty = 0;
    for( iByte=0; iByte<cbSchedData; iByte++ ) {
        /* Just take the high nibble from the first schedule. The ISM does the
         * same thing. AND together the low nibble from Schedule1 and Schedule2 */
        dataAnd = (pb1[iByte]&DataBitMask) & (pb2[iByte]&DataBitMask);
        pb3[iByte] = dataAnd | ( pb1[iByte] & HighBitMask );
        nonEmpty |= dataAnd;
    }

    /* Convert the schedule to the Topl format, store it in
     * the cache, and return it to the caller. */
    __try {
        result = ToplScheduleImport( ScheduleCache, s3 );
    } __finally {
        ToplFree( s3 );
    }

    *fIsNever= !nonEmpty;
    return result;
}


/***** CreateDefaultSchedule *****/
/* Create a new schedule in the cache according to the replication interval. 
 *
 * We start with a fully available schedule.
 * Our algorithm is for the cost to represent the separation between the
 * polling intervals.
 *
 * We calculate out the polling intervals for the entire week and don't
 * guarantee that there always is a polling interval each day.  A sufficiently
 * large cost could skip a day.
 *
 * Where it makes sense, we start at 1am just like Exchange does.
 *
 * ReplInterval is in minutes.  It is converted to 15 min chunks as follows:
 * 0 - default, 12 chunks, or 3 hours
 * 1 - 15, 1
 * 16 - 30, 2
 * etc
 *
 * Note: This code was taken from the KCC's original schedule handling code.
 */
TOPL_SCHEDULE
CreateDefaultSchedule(
    IN TOPL_SCHEDULE_CACHE ScheduleCache,
    IN DWORD IntervalInMinutes
    )
{
    TOPL_SCHEDULE result=NULL;
    ToplSched  *internalSched;
    PSCHEDULE  schedule = NULL;
    int        Number15MinChunkToSkip = (IntervalInMinutes + 14) / 15;
    int        startingInterval, cbSchedule, i, hour, subinterval;
    PBYTE      pbSchedule;

    // A skip of 0 means to take the default, every 3 hours
    if (0 == Number15MinChunkToSkip) {
        Number15MinChunkToSkip = DEFAULT_INTERVAL;
    }

    // Always start immediately (Sunday morning, 12am)
    startingInterval = STARTING_INTERVAL;

    cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    schedule = (SCHEDULE*) ToplAlloc( cbSchedule );

    // Zero the buffer
    RtlZeroMemory( schedule, cbSchedule );

    schedule->Size = cbSchedule;
    schedule->NumberOfSchedules = 1;
    schedule->Schedules[0].Type = SCHEDULE_INTERVAL;
    schedule->Schedules[0].Offset = sizeof(SCHEDULE);

    pbSchedule = ((PBYTE) schedule) + schedule->Schedules[0].Offset;

    // Initialize a new schedule with a repeating poll every n intervals
    for (i = startingInterval;
         i < SCHED_NUMBER_INTERVALS_WEEK;
         i += Number15MinChunkToSkip )
    {
        hour = i / 4;
        subinterval = i % 4;
        pbSchedule[hour] |= (1 << subinterval);
    }

    /* Convert the schedule to our internal format, store it in
     * the cache, and return it to the caller. */
    __try {
        result = ToplScheduleImport( ScheduleCache, schedule );
    } __finally {
        ToplFree( schedule );
    }

    return result;
}


/***** ToplScheduleCreate *****/
/* Create a new schedule in the cache according to the criteria.  If the
 * template schedule is not given, or if the template schedule is the always
 * schedule, we call the function CreateDefaultSchedule above. Otherwise,
 * the template schedule is used as the basis for the new schedule.
 *
 * We convert the schedule from a range of availability to a schedule of polls.
 * We map the generic schedule of availability, plus the replication interval
 * (in minutes) into the number of 15 minute intervals to skip.
 *
 * This function is similar to the one above.  It takes a schedule representing
 * a duration of time periods, and it chooses every nth interval out of the
 * intervals that are available in the original schedule.  We always guarantee
 * atleast one interval selected at the start.
 *
 * If ReplInterval > # intervals set in schedule, only one will be set in the
 * new schedule.
 *
 * ReplInterval is in minutes.  It is converted to 15 min chunks as follows:
 * 0 - default, 12 chunks, or 3 hours
 * 1 - 15, 1
 * 16 - 30, 2
 * etc
 *
 * Note: This code was taken from the KCC's original schedule handling code.
 */
TOPL_SCHEDULE
ToplScheduleCreate(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN DWORD IntervalInMinutes,
	IN TOPL_SCHEDULE TemplateSchedule OPTIONAL
	)
{
    TOPL_SCHEDULE result=NULL;
    ToplSched *tempSchedule;
    PSCHEDULE  schedule = NULL;
    int        Number15MinChunkToSkip = (IntervalInMinutes + 14) / 15;
    int        startingInterval, cbSchedule, i, hour, subinterval, mask;
    PBYTE      pbOldSchedule, pbNewSchedule;

    if( TemplateSchedule!=NULL && TemplateSchedule!=TOPL_ALWAYS_SCHEDULE ) {
        tempSchedule = CheckSchedule( TemplateSchedule );
    } else {
        return CreateDefaultSchedule( ScheduleCache, IntervalInMinutes );
    }

    // A skip of 0 means to take the default, every 3 hours
    if (0 == Number15MinChunkToSkip) {
        Number15MinChunkToSkip = DEFAULT_INTERVAL;
    }

    // If the cost is 1, just take the old schedule unaltered
    if (Number15MinChunkToSkip <= 1) {
        return TemplateSchedule;
    }

    // Allocate a new schedule
    cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    schedule = (SCHEDULE*) ToplAlloc( cbSchedule );

    // Transform the schedule according to the replication interval
    RtlCopyMemory( schedule, tempSchedule->s, sizeof( SCHEDULE ) );

    pbOldSchedule = ((PBYTE) tempSchedule->s) + tempSchedule->s->Schedules[0].Offset;
    pbNewSchedule = ((PBYTE) schedule) + schedule->Schedules[0].Offset;
    
    // Initialize; preserve high order nybble for control info
    for( hour = 0; hour < SCHEDULE_DATA_ENTRIES; hour++ ) {
        pbNewSchedule[hour] = pbOldSchedule[hour] & 0xf0;
    }

    // Look for an open slot. Mark the next one we come to. Skip
    // forward n slots. Repeat.
    i = 0;
    while (i < SCHED_NUMBER_INTERVALS_WEEK)
    {
        hour = i / 4;
        subinterval = i % 4;
        mask = (1 << subinterval);

        if (pbOldSchedule[hour] & mask) {
            pbNewSchedule[hour] |= mask;
            i += Number15MinChunkToSkip;
        } else {
            i++;
        }
    }

    /* Convert the schedule to our internal format, store it in
     * the cache, and return it to the caller. */
    __try {
        result = ToplScheduleImport( ScheduleCache, schedule );
    } __finally {
        ToplFree( schedule );
    }

    return result;
}


/***** ToplScheduleIsEqual *****/
/* This function indicates whether two schedule pointers refer to the same
 * schedule. */
BOOLEAN
ToplScheduleIsEqual(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN TOPL_SCHEDULE Schedule1,
	IN TOPL_SCHEDULE Schedule2
	)
{
    ToplSched   *schedule1, *schedule2;

    /* Check parameters */
    CheckScheduleCache( ScheduleCache );
    if( Schedule1 ) {
        CheckSchedule( Schedule1 );
    }
    if( Schedule2 ) {
        CheckSchedule( Schedule2 );
    }

    return (Schedule1 == Schedule2);
}


/***** ToplScheduleDuration *****/
/* Finds the duration of a schedule by simply checking the stored value.
 * This saves many potentially expensive calculations. The duration can
 * be easily calculated when the schedule is created. Duration is in minutes. */
DWORD
ToplScheduleDuration(
	IN TOPL_SCHEDULE Schedule
	)
{
    ToplSched *schedule;
    
    if( Schedule==TOPL_ALWAYS_SCHEDULE ) {
        return TOPL_ALWAYS_DURATION;
    } else {
        schedule = CheckSchedule( Schedule );
        return schedule->duration;
    }
}


// The meaning of the bits in the schedule is not clearly defined.
// I believe that the least-significant-bit in each byte corresponds
// to the first 15-minute interval of the hour.
// Example: Consider the following schedule data: 0F 00 01 0F...
// This example schedule contains a 1 hour period of unavailability
// and a separate 45 min period of unavailability.

#define GetBit(x) (!! ((pb[ (x)>>2 ] & 0xF) & (1 << ((x)&0x3))) )


/***** ToplScheduleMaxUnavailable *****/
/* Return the length in minutes of the longest contiguous period
 * of time for which the schedule is unavailable. */
DWORD
ToplScheduleMaxUnavailable(
	IN TOPL_SCHEDULE Schedule
	)
{
    const DWORD cBits = SCHED_NUMBER_INTERVALS_WEEK;

    ToplSched *schedule;
    PSCHEDULE pSchedule;
    PBYTE pb;
    DWORD iBit, endBit, maxLen=0;
    DWORD runStart, runLen, infLoopCheck=0;
    BOOL  inRun, finished;
    char bit;

    // If this is the always schedule, return the answer immediately.
    if( Schedule==TOPL_ALWAYS_SCHEDULE ) {
        return 0;
    }

    schedule = CheckSchedule( Schedule );
    pSchedule = schedule->s;
    pb = ((unsigned char*) pSchedule) + pSchedule->Schedules[0].Offset;

    // Look for a time when the schedule is available (if any)
    for( iBit=0; iBit<cBits; iBit++ ) {
        if(GetBit(iBit)) break;
    }

    // We didn't find a period of availability. This means the schedule
    // is always unavailable.
    if( iBit==cBits ) {
        ASSERT( 0==ToplScheduleDuration(Schedule) );
        return TOPL_ALWAYS_DURATION;
    }

    // Walk through the bits, starting at this available bit we found,
    // wrapping around at the end, looking for unavailability periods.
    endBit = iBit++;
    inRun = finished = FALSE;
    do {
        ASSERT( infLoopCheck++ < 3*cBits );

        bit = GetBit(iBit);
        if( inRun && bit ) {
            // The end of a run. Check the run's length.
            runLen = (iBit + cBits - runStart) % cBits;
            if(runLen>maxLen) maxLen=runLen;
            inRun = FALSE;
        } else if( !inRun && !bit ) {
            // The start of a run. Remember the starting bit.
            runStart = iBit;
            inRun = TRUE;
        }
        
        // Check to see if we're finished, and advance to the next bit
        if( iBit==endBit ) {
            finished = TRUE;
        }
        iBit=(iBit+1)%cBits;
    } while( !finished );

    return 15*maxLen;
}


/***** ToplGetAlwaysSchedule *****/
/* Return the 'always schedule' */
TOPL_SCHEDULE
ToplGetAlwaysSchedule(
	IN TOPL_SCHEDULE_CACHE ScheduleCache
    )
{
    return TOPL_ALWAYS_SCHEDULE;
}


/***** ToplScheduleValid *****/
/* Returns true if a topl schedule appears to be valid, false otherwise.
 * NULL schedules are accepted -- they are interpreted to mean the
 * 'always schedule'. */
BOOLEAN
ToplScheduleValid(
    IN TOPL_SCHEDULE Schedule
    )
{
    BOOLEAN result=FALSE;

    __try {
        if( Schedule!=TOPL_ALWAYS_SCHEDULE ) {
            CheckSchedule( Schedule );
        }
        result = TRUE;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = FALSE;
    }

    return result;
}


/***** ToplPScheduleValid *****/
/* Returns true if a pschedule is in a supported format, false otherwise.
 * Never schedules are not supported. */
BOOLEAN
ToplPScheduleValid(
    IN PSCHEDULE Schedule
    )
{
    BOOLEAN result;

    __try {
        CheckPSchedule( Schedule );
        if( CalculateDuration(Schedule)==0 ) {
            result=FALSE;
        } else {
            result=TRUE;
        }
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = FALSE;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\stda.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    stda.c

Abstract:

    Implements a dynamic array, for use by the new spanning-tree algorithm.
    Differs from DYNAMIC_ARRAY in that objects can be stored in the array
    instead of pointers to objects.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    19-6-2000   NickHar   Created

Notes:
    W32TOPL's allocator (which can be set by the user) is used for memory allocation
    
--*/

/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <w32topl.h>
#include "w32toplp.h"
#include "stda.h"


/***** Constants *****/
#define MIN_CHUNK_GROW_SIZE 10


/***** DynArrayInit *****/
/* Initialize a dynamic array. The 'allocationChunk' indicates how many new elements will
 * be allocated at a time when we allocate new memory. If this parameter is 0, a default
 * value will be used. */
VOID
DynArrayInit(
    DynArray    *d,
    DWORD       elementSize
    )
{
    ASSERT(d);

    /* Initialize array members */
    d->elementSize = elementSize;
    d->logicalElements = d->physicalElements = 0;
    d->data = NULL;
    d->fSorted = FALSE;
}


/***** DynArrayClear *****/
/* Clear all the entries from an array. The array must have been
 * initialized before calling this function. */
VOID
DynArrayClear(
    DynArray    *d
    )
{
    ASSERT(d);
    if( d->data ) {
        ToplFree( d->data );
    }
    d->logicalElements = d->physicalElements = 0;
    d->data = NULL;
}


/***** DynArrayDestroy *****/
VOID
DynArrayDestroy(
    DynArray    *d
    )
{
    DynArrayClear(d);
}


/***** DynArrayGetCount *****/
DWORD
DynArrayGetCount(
    DynArray    *d
    )
{
    ASSERT(d);
    return d->logicalElements;
}


/***** DynArrayRetrieve *****/
PVOID
DynArrayRetrieve(
    DynArray    *d,
    DWORD       index
    )
{
    PVOID newMem;

    ASSERT( d );
    ASSERT( index < d->logicalElements );

    return &d->data[ index * d->elementSize ];
}


/***** DynArrayAppend *****/
/* Increase the size of the array, making room for (at least) one new element.
 * If newElementData is non-NULL, copy this data into the new spot.
 * Return a pointer to the memory for the newly allocated element. */
PVOID
DynArrayAppend(
    DynArray    *d,
    PVOID       newElementData
    )
{
    DWORD newIndex;
    PVOID newMem;

    ASSERT(d);
    newIndex = d->logicalElements;

    /* Increase the size of the array and allocate new space */
    d->logicalElements++;
    if( d->logicalElements > d->physicalElements ) {
        /* The array grows exponentially */
        d->physicalElements = 2*(d->physicalElements+MIN_CHUNK_GROW_SIZE);
        if( d->data ) {
            d->data = ToplReAlloc( d->data, d->elementSize * d->physicalElements );
        } else {
            d->data = ToplAlloc( d->elementSize * d->physicalElements );
        }
    }

    /* Get the address of where the new element will go */
    newMem = DynArrayRetrieve( d, newIndex );

    /* Copy in the new data, if we were given some */
    if( newElementData ) {
        RtlCopyMemory( newMem, newElementData, d->elementSize );
    }

    d->fSorted = FALSE;

    /* Return a pointer to the memory for the new element */
    return newMem;
}

/***** DynArraySort *****/
VOID
DynArraySort(
    DynArray    *d,
    DynArrayCompFunc cmp
    )
{
    ASSERT(d);
    if( d->logicalElements>1 ) {
        ASSERT(d->data);
        qsort( d->data, d->logicalElements, d->elementSize, cmp );
    }
    d->fSorted = TRUE;
}


/***** DynArraySearch *****/
/* Search an array for an element. If the element is not found, returns
 * DYN_ARRAY_NOT_FOUND, otherwise returns the index of the element in
 * the array. The array must be in sorted order for this to work. */
int
DynArraySearch(
    DynArray    *d,
    PVOID       key,
    DynArrayCompFunc cmp
    )
{
    PVOID result;
    int index;

    ASSERT(d);
    ASSERT(d->data);
    ASSERT(d->fSorted);

    result = bsearch( key, d->data, d->logicalElements, d->elementSize, cmp );
    if( result==NULL ) {
        return DYN_ARRAY_NOT_FOUND;
    }

    index = (int) ( ((unsigned char*) result)-d->data ) / d->elementSize;
    ASSERT( 0<=index && index< (int) d->logicalElements );

    return index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\stalg.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    stalg.h

Abstract:

    This file contains the definition of various structures used in W32TOPL's
    new spanning tree algorithms. These structures should be considered totally
    opaque -- the user cannot see their internal structure.

    These structures could be defined inside stalg.c, except we want them to
    be visible to 'dsexts.dll', the debugger extension.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    10-7-2000   NickHar   Created

--*/


/***** Header Files *****/
#include <w32topl.h>
#include "stda.h"

#ifndef STALG_H
#define STALG_H

/***** ToplVertex *****/
/* Contains basic information about a vertex: id, name, edge list.
 * Also stores some data used by the internal algorithms. */
struct ToplVertex {
    /* Unchanging vertex data */
    DWORD                   vtxId;          /* Always equal to the vertex index in g's
                                             * array of vertices */
    PVOID                   vertexName;     /* Pointer to name provided by user */

    /* Graph data */
    DynArray                edgeList;       /* Unordered PTOPL_MULTI_EDGE list */
    TOPL_VERTEX_COLOR       color;
    DWORD                   acceptRedRed;   /* Edge restrictions for colored vertices */
    DWORD                   acceptBlack;
    
    TOPL_REPL_INFO          ri;             /* Replication-type data */

    /* Dijkstra data */
    int                     heapLocn;
    struct ToplVertex*      root;           /* The closest colored vertex */
    BOOL                    demoted;

    /* Kruskal data */
    int                     componentId;    /* The id of the graph component we live in.
                                               -1 <= componentId < n, where n = |V|   */
    DWORD                   componentIndex; /* The index of the graph component.
                                                0 <= componentIndex < numComponents   */

    /* DFS data (for finding one-way black-black edges */
    DWORD                   distToRed;      /* What is the distance in the spanning tree from
                                             * this vertex to the nearest red vertex. */
    struct ToplVertex*      parent;         /* The parent of this vertex in the spanning-tree */
    DWORD                   nextChild;      /* The next child to check in the DFS */
};
typedef struct ToplVertex ToplVertex;
typedef ToplVertex *PToplVertex;


/***** ToplGraphState *****/
/* An opaque structure -- visible externally, but internals are not visible.
 * This structure stores the entire state of a topology graph and its
 * related structures. */
typedef struct {
    LONG32                  magicStart;
    PVOID*                  vertexNames;    /* Names, as passed in by the user */
    ToplVertex*             vertices;       /* For each vtx we have an internal structure */
    DWORD                   numVertices;
    BOOLEAN                 melSorted;      /* Has the master edge list been sorted yet? */
    DynArray                masterEdgeList; /* Unordered list of edges */
    DynArray                edgeSets;       /* List of all edge sets */
    TOPL_COMPARISON_FUNC    vnCompFunc;     /* User's function to compare vertex names */
    TOPL_SCHEDULE_CACHE     schedCache;     /* Schedule cache, provided by user */ 
    LONG32                  magicEnd;
} ToplGraphState;
typedef ToplGraphState *PToplGraphState;


/***** ToplInternalEdge *****/
/* This structure represents a path which we found in the graph from v1 to v2.
 * Both v1 and v2 are colored vertices. We represent this path by an edge, which we
 * pass as input to Kruskal's alg. */
typedef struct {
    PToplVertex             v1, v2;         /* The endpoints of the path */
    BOOLEAN                 redRed;         /* True if both endpoints are red */
    TOPL_REPL_INFO          ri;             /* Combined replication info for the v1-v2 path */
    DWORD                   edgeType;       /* All path edges must have same type. Range: 0-31 */
} ToplInternalEdge;
typedef ToplInternalEdge *PToplInternalEdge;


#endif /* STALG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\stalg.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    stalg.c

Abstract:

    This file implements w32topl's new graph algorithm, which are used for
    calculating network topologies. The main function of interest here is
    ToplGetSpanningTreeEdgesForVtx(), which runs the algorithm and returns
    its output. The rest of the functions are concerned with setting up and
    freeing the algorithm's input.

    At a theoretical level, the problem that this algorithm solves is
    "Given a graph G, calculate a minimum-cost spanning tree of shortest-
    path between a subset of the vertices of G". The algorithm we employ
    here is a hybrid of Dijkstra's algorithm and Kruskal's algorithm.

    The algorithm also has extra functionality to handle specific details
    of the KCC problem. These include: edge sets, three different colors of
    vertices, edge types, and the ability for a vertex to reject certain types
    of edges.

    It is difficult to give an expression describing the performance of
    ToplGetSpanningTreeEdgesForVtx(), since the performance depends heavily
    on the input network topology. Assuming a constant bound on the number of
    vertices contained in an edge, an rough upper bound is:

        O( (s+1) * ( m + n*log(n) + m*log(m)*logStar(m) ) )
    
    where

        m = the number of multi-edges
        n = the number of vertices
        s = the number of edge sets

    For most cases, O( s*m*log(m) ) is a good estimate.


File Map:

    Headers
    Constants
    Macros

    Functions                          Externally
                                        Visible?

      CheckGraphState
      CheckMultiEdge
      CheckMultiEdgeSet
      InitializeVertex
      ToplMakeGraphState                  Yes 
      FindVertex                                          
      CreateMultiEdge                                          
      FreeMultiEdge                                          
      CopyReplInfo                                          
      ToplAddEdgeToGraph                  Yes 
      ToplEdgeSetVtx                    Yes 
      EdgePtrCmp                                          
      ToplAddEdgeSetToGraph               Yes
      VertexComp                                          
      VertexGetLocn                                          
      VertexSetLocn                                          
      InitColoredVertices                                          
      TableAlloc                                          
      TableFree                                          
      EdgeGetVertex                                          
      ClearEdgeLists
      SetupEdges                                          
      SetupVertices                                          
      SetupDijkstra                                          
      AddDWORDSat
      CombineReplInfo
      RaiseNonIntersectingException
      TryNewPath                                          
      Dijkstra
      AddIntEdge                                          
      ColorComp
      ProcessEdge                                          
      ProcessEdgeSet                                          
      GetComponent                                          
      EdgeCompare                                          
      AddOutEdge                                          
      Kruskal                                          
      DepthFirstSearch
      CalculateDistToRed
      CountComponents
      ScanVertices
      SwapFilterVertexToFront
      ConstructComponents
      CopyOutputEdges                                          
      ClearInternalEdges                                          
      CheckAllMultiEdges                                          
      ToplGetSpanningTreeEdgesForVtx      Yes                                 
      ToplDeleteSpanningTreeEdges         Yes                              
      ToplDeleteComponents                Yes
      ToplDeleteGraphState                Yes                       


Author:

    Nick Harvey    (NickHar)
    
Revision History

    19-06-2000   NickHar   Development Started
    14-07-2000   NickHar   Initial development complete, submit to source control
    02-10-2000   NickHar   Add support for one-way black-black edges
    12-15-2000   NickHar   Add support for component reporting


Notes:
    W32TOPL's allocator (which can be set by the user) is used for memory allocation
    
--*/


/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <w32topl.h>
#include "w32toplp.h"
#include "stheap.h"
#include "stda.h"
#include "stalg.h"


/***** Constants *****/
/* Magic numbers to ensure consistency of the Topl structures */
#define MAGIC_START 0x98052639
#define MAGIC_END   0xADD15ABA

/* Various constants used throughout the code in this file */
const DWORD ACCEPT_ALL=0xFFFFFFFF;
const DWORD INFINITY=0xFFFFFFFF;
const DWORD VTX_DEFAULT_INTERVAL=0;
const DWORD VTX_DEFAULT_OPTIONS=0xFFFFFFFF;
const int UNCONNECTED_COMPONENT=-1;
const DWORD MAX_EDGE_TYPE=31;            /* Maximum edge type */
const int EMPTY_EDGE_SET=-1;             /* Dummy Index for implicit empty edge set */
const BOOLEAN NON_INTERSECTING=FALSE;    /* Return values when combining schedules */
const BOOLEAN INTERSECTING=TRUE;  


/***** Macros *****/
#define MAX(a,b) (((a)>(b))?(a):(b))


/***** CheckGraphState *****/
/* Check that the PTOPL_GRAPH_STATE parameter we were passed is valid.
 * If it is invalid, we throw an exception */
PToplGraphState
CheckGraphState(
    PTOPL_GRAPH_STATE G
    )
{
    PToplGraphState g;

    if( G==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    g = (PToplGraphState) G;

    if( g->magicStart != MAGIC_START
     || g->magicEnd != MAGIC_END ) {
        ToplRaiseException( TOPL_EX_GRAPH_STATE_ERROR );
    }
    if( g->vertices==NULL || g->vertexNames==NULL
     || g->vnCompFunc==NULL || g->schedCache==NULL) {
        ToplRaiseException( TOPL_EX_GRAPH_STATE_ERROR );
    }
    
    return g;
}


/***** CheckMultiEdge *****/
/* Check that the PTOPL_MULTI_EDGE parameter we were passed is valid.
 * If it is invalid, we throw an exception.
 * We only check a few things here -- more substantial checks are done
 * when the edge set is added to the graph state.
 * Note: Edges must have at least 2 vertices. */
VOID
CheckMultiEdge(
    PTOPL_MULTI_EDGE e
    )
{
    if( e==NULL || e->vertexNames==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    if( e->numVertices < 2 ) {
        ToplRaiseException( TOPL_EX_TOO_FEW_VTX );
    }
    if( e->edgeType > MAX_EDGE_TYPE ) {
        ToplRaiseException( TOPL_EX_INVALID_EDGE_TYPE );
    }
    if( ToplScheduleValid(e->ri.schedule)==FALSE ) {
        ToplRaiseException( TOPL_EX_SCHEDULE_ERROR );
    }
}


/***** CheckMultiEdgeSet *****/
/* Check that the PTOPL_MULTI_EDGE_SET parameter we were passed is valid.
 * If it is invalid, we throw an exception. The checks performed here
 * are somewhat cursory, but at least we catch null pointers.
 * More substantial checks are done when the edge set is added to the
 * graph state.
 * Note: An edge set with less than 2 edges is useless, but valid. */
VOID
CheckMultiEdgeSet(
    PTOPL_MULTI_EDGE_SET s
    )
{
    if( s==NULL || s->multiEdgeList==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
}


/***** InitializeVertex *****/
/* Initialize graph g's vertex i to all the default values.
 * Vertices are by default in an unconnected component and have no edges.
 *
 * Warning:
 * An edge list is allocated here, and memory will be orphaned if this
 * function is called twice on the same vertex. This memory is freed when
 * the graph is destroyed in ToplDeleteGraphState(). */
VOID
InitializeVertex(
    PToplGraphState g,
    DWORD i
    )
{
    PToplVertex v;

    /* Check parameters */
    ASSERT( g && g->vertices && g->vertexNames );
    ASSERT( i<g->numVertices );
    v = &g->vertices[i];

    v->vtxId = i;
    v->vertexName = g->vertexNames[i];

    /* Graph data */
    DynArrayInit( &v->edgeList, sizeof(PTOPL_MULTI_EDGE) );
    v->color = COLOR_WHITE;
    v->acceptRedRed = 0;
    v->acceptBlack = 0;
    
    /* Default replication data */
    v->ri.cost = INFINITY;
    v->ri.repIntvl = VTX_DEFAULT_INTERVAL;
    v->ri.options = VTX_DEFAULT_OPTIONS;
    v->ri.schedule = ToplGetAlwaysSchedule( g->schedCache );

    /* Dijkstra data */
    v->heapLocn = STHEAP_NOT_IN_HEAP;
    v->root = NULL;
    v->demoted = FALSE;

    /* Kruskal data */
    v->componentId = UNCONNECTED_COMPONENT;
    v->componentIndex = 0;

    /* DFS data */
    v->distToRed = 0;
    v->parent = NULL;
    v->nextChild = 0;
}


/***** ToplMakeGraphState *****/
/* Create a GraphState object. The vertices are added at creation time; the
 * multi-edges are added later by calling 'ToplAddEdgeToGraph'. Edge sets should be
 * added later to specify edge transitivity.
 * Warning: Contents of 'vertexNames' will be reordered after calling this function */
PTOPL_GRAPH_STATE
ToplMakeGraphState(
    IN PVOID* vertexNames,
    IN DWORD numVertices, 
    IN TOPL_COMPARISON_FUNC vnCompFunc,
    IN TOPL_SCHEDULE_CACHE schedCache
    )
{
    PToplGraphState  g=NULL;
    ToplVertex* v;
    DWORD iVtx;

    /* Check parameters for invalid pointers */
    if( vertexNames==NULL || vnCompFunc==NULL || schedCache==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    for( iVtx=0; iVtx<numVertices; iVtx++ ) {
        if( vertexNames[iVtx]==NULL ) {
            ToplRaiseException( TOPL_EX_NULL_POINTER );
        }
    }

    __try {

        g = (PToplGraphState) ToplAlloc( sizeof(ToplGraphState) );
        g->vertices = NULL;

        /* Store the list of vertex names in g. Sort it, for efficient searches later */
        g->vertexNames = vertexNames;
        g->numVertices = numVertices;
        qsort( vertexNames, numVertices, sizeof(PVOID), vnCompFunc );

        /* Initialize vertex objects */
        g->vertices = (ToplVertex*) ToplAlloc( sizeof(ToplVertex)*numVertices );
        for( iVtx=0; iVtx<numVertices; iVtx++ ) {
            InitializeVertex( g, iVtx );
        }
        
        /* Initialize the rest of the members of the graph state */
        DynArrayInit( &g->masterEdgeList, sizeof(PTOPL_MULTI_EDGE) );
        g->melSorted = FALSE;       /* The master edge list is not sorted yet */
        DynArrayInit( &g->edgeSets, sizeof(PTOPL_MULTI_EDGE_SET) );
        g->vnCompFunc = vnCompFunc;
        g->schedCache = schedCache;

    } __finally {

        if( AbnormalTermination() ) {

            /* An exception occurred -- free memory */
            if( g ) {
                if( g->vertices ) {
                    ToplFree( g->vertices );
                }
                ToplFree( g );
            }
        }

    }

    g->magicStart = MAGIC_START;
    g->magicEnd = MAGIC_END;
    return g;
}


/***** FindVertex *****/
/* Search the list of vertex names in g for a name that matches 'vtxName'.
 * Return the corresponding vertex structure. If no such vertex was found,
 * we return NULL. */
PToplVertex
FindVertex(
    ToplGraphState* g,
    PVOID vtxName )
{
    PVOID *vn;
    DWORD index;

    /* We can check if the name is null, but cannot do much more checking */
    if( vtxName==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }

    /* Use bsearch to find this vertex name in the list of all vertex names */
    vn = (PVOID*) bsearch( &vtxName, g->vertexNames,
        g->numVertices, sizeof(PVOID), g->vnCompFunc );

    /* If this name was not found, then it was an invalid name. Let the
     * caller handle it */
    if(vn==NULL) {
        return NULL;
    }

    /* Determine the index of the vertex name that we found */
    index = (int) (vn - g->vertexNames);
    ASSERT( index<g->numVertices );

    /* Return the appropriate ToplVertex pointer */
    return &g->vertices[index];
}


/***** CreateMultiEdge *****/
/* This function allocates the memory required for a multi-edge object which
 * contains 'numVtx' vertices. It does not initialize any of the fields of the
 * edge except for the vertex names, which are set to NULL. This memory should
 * be deallocated by calling FreeMultiEdge(). */
PTOPL_MULTI_EDGE
CreateMultiEdge(
    IN DWORD numVtx
    )
{
    PTOPL_MULTI_EDGE e;
    DWORD iVtx;

    e = (PTOPL_MULTI_EDGE) ToplAlloc( sizeof(TOPL_MULTI_EDGE)
        + (numVtx-1) * sizeof( TOPL_NAME_STRUCT ) );
    e->numVertices = numVtx;
    e->edgeType = 0;
    e->fDirectedEdge = FALSE;
    for( iVtx=0; iVtx<numVtx; iVtx++ ) {
        e->vertexNames[iVtx].name = NULL;
        e->vertexNames[iVtx].reserved = 0;
    }

    return e;
}


/***** FreeMultiEdge *****/
/* This function frees the memory used by a multi-edge object. It does not
 * free the memory used by the vertices. */
VOID
FreeMultiEdge(
    PTOPL_MULTI_EDGE e
    )
{
    DWORD iVtx;

    ASSERT( e );
    for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
        e->vertexNames[iVtx].name = NULL;
        e->vertexNames[iVtx].reserved = 0;
    }
    e->numVertices = 0;

    ToplFree( e );
}


/***** CopyReplInfo *****/
/* Copy the replication info FROM ri1 TO ri2.
 * Note: The order is different from memcpy(), memmove(), etc. */
VOID
CopyReplInfo(
    TOPL_REPL_INFO *ri1,
    TOPL_REPL_INFO *ri2
    )
{
    ASSERT( ri1!=NULL && ri2!=NULL );
    memcpy( ri2, ri1, sizeof(TOPL_REPL_INFO) );
}


/***** ToplAddEdgeToGraph *****/
/* Allocate a multi-edge object, and add it to the graph G.
 * The number of vertices that this edge will contain must be specified
 * in the 'numVtx' parameter, so that the appropriate amount of memory
 * can be allocated. The names of the vertices contained in this edge
 * are not yet specified -- they are NULL. The names must be specified
 * later, by calling the function ToplEdgeSetVtx(). All names must be
 * set before adding this edge to an edge set, and before calling
 * ToplGetSpanningTreeEdgesForVtx().
 * 
 * Note: All edges should be added to the graph before starting to add
 * edge sets. This is for performance reasons. */
PTOPL_MULTI_EDGE
ToplAddEdgeToGraph(
    IN PTOPL_GRAPH_STATE G,
    IN DWORD numVtx,
    IN DWORD edgeType,
    IN PTOPL_REPL_INFO ri
    )
{
    PToplGraphState g;
    PTOPL_MULTI_EDGE e;
    DWORD iVtx;
    
    /* Check parameters */
    g = CheckGraphState( G );
    if( numVtx<2 ) {
        ToplRaiseException( TOPL_EX_TOO_FEW_VTX );
    }
    if( edgeType>MAX_EDGE_TYPE ) {
        ToplRaiseException( TOPL_EX_INVALID_EDGE_TYPE );
    }
    if( ri==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    if( ! ToplScheduleValid( ri->schedule ) ) {
        ToplRaiseException( TOPL_EX_SCHEDULE_ERROR );
    }
    
    g->melSorted = FALSE; /* The master edge list is now unsorted */

    e = CreateMultiEdge( numVtx );
    e->edgeType = edgeType;
    CopyReplInfo( ri, &e->ri );

    __try {
        DynArrayAppend( &g->masterEdgeList, &e );
    } __finally {
        if( AbnormalTermination() ) {
            ToplFree(e);
            e=NULL;
        }
    }

    return e;
}


/***** ToplEdgeSetVtx *****/
/* This function is used to set the name of a vertex in an edge.
 * If edge e has n vertices, 'whichVtx' should be in the range
 * [0..n-1]. */
VOID
ToplEdgeSetVtx(
    IN PTOPL_GRAPH_STATE G,
    IN PTOPL_MULTI_EDGE e,
    IN DWORD whichVtx,
    IN PVOID vtxName
    )
{
    PToplGraphState g;
    PToplVertex v;
    
    /* Check parameters */
    g = CheckGraphState( G );
    CheckMultiEdge( e );
    if( whichVtx>=e->numVertices ) {
        ToplRaiseException( TOPL_EX_INVALID_VERTEX );
    }
    
    /* Optimization: To describe which vertices this edge contains, the user
     * passes us a list of vertex names. Since using a vertex names requires
     * a binary search, we store an index in the 'reserved' field to help us
     * the vertices even faster.
     *
     * This may seem unnecessary, since the performance of bsearch is usually
     * quite acceptable. However, for very large graphs, comparing two integers
     * can be significantly faster than bsearching. */

    if( vtxName == NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    v = FindVertex( g, vtxName );
    if( v==NULL ) {
        ToplRaiseException( TOPL_EX_INVALID_VERTEX );
    }
    e->vertexNames[whichVtx].name = vtxName;
    e->vertexNames[whichVtx].reserved = v->vtxId;
}


/***** EdgePtrCmp *****/
/* Compare two edge pointers by their _pointer_ value. This is used for
 * sorting the master edge list. */
int
__cdecl EdgePtrCmp(
    const void* p1,
    const void* p2
    )
{
    PTOPL_MULTI_EDGE a=*((PTOPL_MULTI_EDGE*)p1), b=*((PTOPL_MULTI_EDGE*)p2);

    if( a<b ) {
        return -1;
    } else if( a>b ) {
        return 1;
    }
    return 0;
}


/***** ToplAddEdgeSetToGraph *****/
/* Adds a single edge-set to the graph state. Edge sets define transitivity
 * for paths through the graph. When the spanning-tree algorithm searches for
 * paths between vertices, it will only allow paths for which all edges are in
 * an edge set. A given edge can appear in more than one edge set.
 *
 * Note: all edges must be added to the graph before adding edge sets,
 * otherwise performance will suffer.
 */
VOID
ToplAddEdgeSetToGraph(
    IN PTOPL_GRAPH_STATE G,
    IN PTOPL_MULTI_EDGE_SET s
    )
{
    PTOPL_MULTI_EDGE e;
    PToplGraphState g;
    DWORD iEdge;
    int edgeIndex;
    
    g = CheckGraphState( G );
    CheckMultiEdgeSet( s );

    /* Sort the edge list so that we can quickly search for edges */
    if( g->melSorted==FALSE ) {
        DynArraySort( &g->masterEdgeList, EdgePtrCmp );
        g->melSorted = TRUE;
    }

    /* Check the edges */
    for( iEdge=0; iEdge<s->numMultiEdges; iEdge++ ) {
        e = s->multiEdgeList[iEdge];
        if( e == NULL ) {
            ToplRaiseException( TOPL_EX_NULL_POINTER );
        }
        
        /* Check that all edges in this set have the same type */
        if( iEdge>0 && s->multiEdgeList[iEdge-1]->edgeType!=e->edgeType ) {
            ToplRaiseException( TOPL_EX_INVALID_EDGE_SET );
        }

        /* Check that this edge has been added to the graph state */
        edgeIndex = DynArraySearch(&g->masterEdgeList, &e, EdgePtrCmp);
        if( edgeIndex==DYN_ARRAY_NOT_FOUND ) {
            ToplRaiseException( TOPL_EX_INVALID_EDGE_SET );
        }
    }
    
    // If an edge sets contains fewer than two edges it is useless. We only
    // store edge sets with two or more edges.
    if( s->numMultiEdges>1 ) {
        DynArrayAppend( &g->edgeSets, &s );
    }
}


/***** VertexComp *****/
/* Compare vertices using the key (cost,VertexName) */
int
VertexComp(
    PToplVertex v1,
    PToplVertex v2,
    PTOPL_GRAPH_STATE G )
{
    PToplGraphState g;
    int result;

    ASSERT( v1!=NULL && v2!=NULL );
    ASSERT( v1->vertexName!=NULL && v2->vertexName!=NULL );
    g = CheckGraphState( G );

    if(v1->ri.cost==v2->ri.cost) {
        /* Comparing vtxId's is equivalent to comparing the vertex names */
        if( v1->vtxId < v2->vtxId ) {
            result = -1;
            ASSERT( g->vnCompFunc(&v1->vertexName,&v2->vertexName)<0 );
        } else if( v1->vtxId > v2->vtxId ) {
            result = 1;
            ASSERT( g->vnCompFunc(&v1->vertexName,&v2->vertexName)>0 );
        } else {
            result = 0;
            ASSERT( g->vnCompFunc(&v1->vertexName,&v2->vertexName)==0 );
        }
        return result;
    }

    /* Subtraction could lead to overflow, so we compare the numbers
     * the old-fashioned way. */
    if( v1->ri.cost > v2->ri.cost ) {
        return 1;
    } else if( v1->ri.cost < v2->ri.cost ) {
        return -1;
    }

    return 0;
}


/***** VertexGetLocn *****/
/* Get the location of this vertex in the heap. This function is
 * only called internally by the stheap code */
int
VertexGetLocn(
    PToplVertex v,
    PVOID extra
    )
{
    ASSERT( v );
    return v->heapLocn;
}


/***** VertexSetLocn *****/
/* Set the location of this vertex in the heap. This function is
 * only called internally by the stheap code */
VOID
VertexSetLocn(
    PToplVertex v,
    int locn,
    PVOID extra
    )
{
    ASSERT( v );
    v->heapLocn = locn;
}


/***** InitColoredVertices *****/
VOID
InitColoredVertices(
    PToplGraphState g,
    TOPL_COLOR_VERTEX *colorVtx,
    DWORD numColorVtx,
    PToplVertex whichVtx
    )
{
    TOPL_VERTEX_COLOR color;
    PToplVertex v;
    DWORD iVtx;

    if( colorVtx==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }

    /* Clear the coloring for all vertices */
    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        g->vertices[iVtx].color = COLOR_WHITE;
    }

    /* Go through the list of colored vertices, coloring them */
    for( iVtx=0; iVtx<numColorVtx; iVtx++ ) {

        /* Find the vertex with this name */
        if( colorVtx[iVtx].name==NULL ) {
            ToplRaiseException( TOPL_EX_NULL_POINTER );
        }
        v = FindVertex( g, colorVtx[iVtx].name );
        if(v==NULL) {
            ToplRaiseException( TOPL_EX_COLOR_VTX_ERROR );
        }

        /* Ensure that each vertex is colored at most once */
        if( v->color!=COLOR_WHITE ) {
            ToplRaiseException( TOPL_EX_COLOR_VTX_ERROR );
        }

        /* Ensure that each vertex is colored either red or black */
        color = colorVtx[iVtx].color;
        if( color!=COLOR_RED && color!=COLOR_BLACK ) {
            ToplRaiseException( TOPL_EX_COLOR_VTX_ERROR );
        }
        v->color = color;

        v->acceptRedRed = colorVtx[iVtx].acceptRedRed;
        v->acceptBlack = colorVtx[iVtx].acceptBlack;
    }

    /* Ensure that 'whichVtx' is colored */
    if( whichVtx!=NULL && whichVtx->color==COLOR_WHITE ) {
        ToplRaiseException( TOPL_EX_INVALID_VERTEX );
    }
}


/***** TableAlloc *****/
/* This function is used as the allocator for the RTL table */
PVOID
NTAPI TableAlloc( RTL_GENERIC_TABLE *Table, CLONG ByteSize )
{
    return ToplAlloc( ByteSize );
}


/***** TableFree *****/
/* This function is used as the deallocator for the RTL table */
VOID
NTAPI TableFree( RTL_GENERIC_TABLE *Table, PVOID Buffer )
{
    ToplFree( Buffer );
}


/***** EdgeGetVertex *****/
/* When the user passes in edges, they contain the name of the vertices
 * that the edge is incident with. Finding the vertices based on name
 * can be slow, so we cheat and use the 'reserved' field. */
PToplVertex
EdgeGetVertex(
    PToplGraphState g,
    PTOPL_MULTI_EDGE e,
    DWORD iVtx )
{
    DWORD vtxId;

    ASSERT( g );
    ASSERT( e );
    ASSERT( iVtx < e->numVertices );

    vtxId = e->vertexNames[iVtx].reserved;
    ASSERT( vtxId<g->numVertices );

    return &g->vertices[ vtxId ];
}


/***** ClearEdgeLists *****/
/* Clear the edges from all vertices' edge lists. */
VOID
ClearEdgeLists(
    IN PToplGraphState g
    )
{
    DWORD iVtx;

    /* First clear the vertices' edge lists */
    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        DynArrayClear( &g->vertices[iVtx].edgeList );
    }
}

 
/***** SetupEdges *****/
/* Clear all the edges from the graph. Not from the master edge list,
 * just from the vertices' edge lists. Then, add the edges from
 * edge set 'whichEdgeSet' into the graph. Returns the edge type of
 * the edges in the edge set. */
DWORD
SetupEdges(
    PToplGraphState g,
    DWORD whichEdgeSet )
{
    PTOPL_MULTI_EDGE e;
    PTOPL_MULTI_EDGE_SET s;
    DWORD iVtx, iEdge, edgeType;
    ToplVertex* v;

    ClearEdgeLists( g );

    ASSERT( whichEdgeSet < DynArrayGetCount(&g->edgeSets) );
    s = *((PTOPL_MULTI_EDGE_SET*) DynArrayRetrieve( &g->edgeSets, whichEdgeSet ));
    CheckMultiEdgeSet( s );

    /* Add edges from edge set s into the graph */
    ASSERT( s->numMultiEdges>0 );
    for( iEdge=0; iEdge<s->numMultiEdges; iEdge++ ) {
        e = s->multiEdgeList[iEdge];
        CheckMultiEdge( e );
        edgeType = e->edgeType;

        /* For every vertex in edge e, add e to its edge list */
        for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
            v = EdgeGetVertex( g, e, iVtx );
            DynArrayAppend( &v->edgeList, &e );
        }
    }

    return edgeType;
}


/***** SetupVertices *****/
/* Setup the fields of the vertices that are relevant to Phase 1
 * (Dijkstra's Algorithm).  For each vertex we set up its cost, root
 * vertex, and component. This defines the shortest-path forest structures.
 */
VOID
SetupVertices(
    PToplGraphState g
    )
{
    PToplVertex v;
    DWORD iVtx;

    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {

        v = &g->vertices[ iVtx ];

        if( v->color==COLOR_RED || v->color==COLOR_BLACK ) {
            /* Since we reinitialize the vertex every time we set up the graph,
             * we have to reset the important fields of the colored vertices. */
            v->ri.cost = 0;
            v->root = v;
            v->componentId = (int) v->vtxId;
        } else {
            ASSERT( v->color==COLOR_WHITE );
            v->ri.cost = INFINITY;
            v->root = NULL;
            v->componentId = UNCONNECTED_COMPONENT;
        }

        v->ri.repIntvl = VTX_DEFAULT_INTERVAL;
        v->ri.options = VTX_DEFAULT_OPTIONS;
        v->ri.schedule = ToplGetAlwaysSchedule( g->schedCache );
        v->heapLocn = STHEAP_NOT_IN_HEAP;
        v->demoted = FALSE;
    }
}


/***** SetupDijkstra *****/
/* Build the initial heap for use with Dijkstra's algorithm. The heap
 * will contain the red and black vertices as root vertices, unless these
 * vertices accept no edges of the current edgeType, or unless we're
 * not including black vertices. */
PSTHEAP
SetupDijkstra(
    IN PToplGraphState g,
    IN DWORD edgeType,
    IN BOOL fIncludeBlack
    )
{
    PToplVertex v;
    PSTHEAP heap;
    DWORD iVtx, mask;

    ASSERT( edgeType <= MAX_EDGE_TYPE );
    mask = 1 << edgeType;

    SetupVertices( g );
    heap = ToplSTHeapInit( g->numVertices, VertexComp, VertexGetLocn, VertexSetLocn, g );

    __try {
        for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
            v = &g->vertices[ iVtx ];

            if( v->color==COLOR_WHITE ) {
                continue;
            }

            if(   (v->color==COLOR_BLACK && !fIncludeBlack)
               || (   FALSE==(v->acceptBlack&mask)
                   && FALSE==(v->acceptRedRed&mask) ) )
            {
                /* If we're not allowing black vertices, or if this vertex accepts
                 * neither red-red nor black edges, then we 'demote' it to an uncolored
                 * vertex for the purposes of Phase I. Note that the 'color' member of
                 * the vertex structure is not changed. */
                v->ri.cost = INFINITY;
                v->root = NULL;
                v->demoted = TRUE;
            } else {
                /* The vertex is colored and it will accept either red-red or black
                 * edges. Add it to the heap used for Dijkstra's algorithm. */
                ToplSTHeapAdd( heap, v );
            }
        }
    } __finally {
        if( AbnormalTermination() ) {
            ToplSTHeapDestroy( heap );
        }
    }

    return heap;
}


/***** AddDWORDSat *****/
/* Add two DWORDs and saturate the sum at INFINITY. This prevents
 * overflow. */
DWORD
AddDWORDSat(
    IN DWORD a,
    IN DWORD b
    )
{
    DWORD c;
    
    c = a + b;
    if( c<a || c<b || c>INFINITY ) {
        c = INFINITY;
    }
    return c;
}


/***** CombineReplInfo *****/
/* Merge schedules, replication intervals, options and costs.
 * c = Combine( a, b ). Returns NON_INTERSECTING if combined schedule is
 * empty, INTERSECTING otherwise. If the schedules don't intersect,
 * replication info is not disturbed */
BOOLEAN
CombineReplInfo(
    PToplGraphState g,
    TOPL_REPL_INFO *a,
    TOPL_REPL_INFO *b,
    TOPL_REPL_INFO *c
    )
{
    TOPL_SCHEDULE s=NULL;
    BOOLEAN fIsNever;

    s = ToplScheduleMerge( g->schedCache, a->schedule, b->schedule, &fIsNever );
    if( fIsNever ) {
        return NON_INTERSECTING;
    }

    /* Add costs, avoiding overflow */
    c->cost = AddDWORDSat( a->cost, b->cost );
    c->repIntvl = MAX( a->repIntvl, b->repIntvl );

    /* AND the options together -- that's what ISM does */
    c->options = a->options & b->options;        
    c->schedule = s;

    return INTERSECTING;
}


/***** RaiseNonIntersectingException *****/
/* This function is called when non-intersecting schedules are discovered
 * along a path. An exception is raised, and the vertex names describing
 * the erroneous path are passed back to the user. The user can choose to
 * resume processing after catching the exception. */
VOID
RaiseNonIntersectingException(
    IN PToplVertex a,
    IN PToplVertex b,
    IN PToplVertex c
    )
{
    ULONG_PTR       exceptionInfo[3];

    /* Schedules didn't intersect. Throw an exception to let the user
     * know. We allow the user to resume the exceution, which is why
     * we don't call ToplRaiseException. */
    ASSERT( sizeof(PVOID)==sizeof(ULONG_PTR) );
     
    ( (PVOID*) exceptionInfo )[0] = a->vertexName;
    ( (PVOID*) exceptionInfo )[1] = b->vertexName;
    ( (PVOID*) exceptionInfo )[2] = c->vertexName;

    RaiseException( TOPL_EX_NONINTERSECTING_SCHEDULES, 0,
        3, exceptionInfo );
}


/***** TryNewPath *****/
/* Helper function for Dijkstra's algorithm. We have found a new path from a
 * root vertex to vertex v. This path is (u->root, ..., u, v). Edge e is the
 * edge connecting u and v. If this new path is better (in our case cheaper,
 * or has a longer schedule), we update v to use the new path. */
VOID
TryNewPath(
    PToplGraphState g,
    PSTHEAP heap,
    PToplVertex u,
    PTOPL_MULTI_EDGE e,
    PToplVertex v
    )
{
    TOPL_REPL_INFO  newRI;
    DWORD           newDuration, oldDuration;
    BOOLEAN         fIntersect;

    fIntersect = CombineReplInfo( g, &u->ri, &e->ri, &newRI );

    /* If the new path to vertex v has greater cost than an existing
     * path, we can ignore the new path. */
    if( newRI.cost > v->ri.cost ) {
        return;
    }

    /* We know that the new path's cost is <= the existing path's cost */

    if( (newRI.cost<v->ri.cost) && fIntersect==NON_INTERSECTING )
    {
        RaiseNonIntersectingException( u->root, u, v );
        return;
    }

    newDuration = ToplScheduleDuration(newRI.schedule);
    oldDuration = ToplScheduleDuration(v->ri.schedule);

    if( (newRI.cost<v->ri.cost) || (newDuration>oldDuration) ) {

        /* The new path to v is either cheaper or has a longer schedule.
         * We update v with its new root vertex, cost, and replication
         * info. Since its cost has changed, we must reorder the heap a bit. */
        v->root = u->root;
        v->componentId = u->componentId;
        ASSERT( u->componentId == u->root->componentId );
        CopyReplInfo( &newRI, &v->ri  );

        if( v->heapLocn==STHEAP_NOT_IN_HEAP ) {
            ToplSTHeapAdd( heap, v );
        } else {
            ToplSTHeapCostReduced( heap, v );
        }

    }
    
}


/***** Dijkstra *****/
/* Run Dijkstra's algorithm with the red (and possibly black) vertices as
 * the root vertices, and build up a shortest-path forest. To determine the
 * next vertex to add to the forest, we use a variation on a binary heap. This
 * heap supports an additional operation, which efficiently fixes up the
 * heap's ordering if we decrease the cost of an element.
 *
 * Parameters:
 * 'edgeType'           This is the type of the edges in the current edge set.
 * 'fIncludeBlackVtx'   If this is true, black vertices are also used as roots.
 */
VOID
Dijkstra(
    IN PToplGraphState g,
    IN DWORD edgeType,
    IN BOOL fIncludeBlack
    )
{
    PTOPL_MULTI_EDGE e;
    PToplVertex u, v;
    DWORD iEdge, iVtx, cEdge;
    PSTHEAP heap;

    ASSERT( g!=NULL );
    heap = SetupDijkstra( g, edgeType, fIncludeBlack );
    
    __try {

        while( (u=(PToplVertex) ToplSTHeapExtractMin(heap)) ) {

            cEdge = DynArrayGetCount( &u->edgeList );
            for( iEdge=0; iEdge<cEdge; iEdge++ ) {

                e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( &u->edgeList, iEdge ));
                CheckMultiEdge( e );
                
                /* Todo: Potential Optimization: Don't check multi-edges
                 * which have already been checked. This would only really
                 * be advantageous if edges contain many vertices. */

                for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
                    v = EdgeGetVertex( g, e, iVtx );
                    TryNewPath( g, heap, u, e, v );
                } 
            }
        }

    } __finally {
        ToplSTHeapDestroy( heap );
    }
}


/***** AddIntEdge *****/
/* Add an edge to the list of edges we will process with Kruskal's.
 * The endpoints are in fact the roots of the vertices we pass in, so
 * the endpoints are always colored vertices */
VOID
AddIntEdge(
    PToplGraphState g,
    RTL_GENERIC_TABLE *internalEdges,
    PTOPL_MULTI_EDGE e,
    PToplVertex v1,
    PToplVertex v2
    )
{
    ToplInternalEdge newIntEdge;
    TOPL_REPL_INFO ri, ri2;
    PToplVertex root1, root2, temp;
    char redRed;
    DWORD mask;

    /* Check parameters */
    ASSERT( v1!=NULL && v2!=NULL );
    ASSERT( e->edgeType<=MAX_EDGE_TYPE );

    /* The edge we pass on to Kruskal's algorithm actually goes between
     * the roots of the two shortest-path trees. */
    root1 = v1->root;
    root2 = v2->root;
    ASSERT( root1!=NULL && root2!=NULL );
    ASSERT( root1->color!=COLOR_WHITE && root2->color!=COLOR_WHITE );

    /* Check if both endpoints will allow this type of edge */
    redRed = (root1->color==COLOR_RED) && (root2->color==COLOR_RED);
    mask = 1 << e->edgeType;
    if( redRed ) {
        if( (root1->acceptRedRed&mask)==0 || (root2->acceptRedRed&mask)==0 ) {
            return;   /* root1/root2 will not accept this type of red-red edge */
        }
    } else {
        if( (root1->acceptBlack&mask)==0 || (root2->acceptBlack&mask)==0 ) {
            return;   /* root1/root2 will not accept this type of black edge */
        }
    }

    /* Combine the schedules of the path from root1 to v1, root2 to v2, and edge e */
    if( CombineReplInfo(g,&v1->ri,&v2->ri,&ri)==NON_INTERSECTING
     || CombineReplInfo(g,&ri,&e->ri,&ri2)==NON_INTERSECTING )
    {
        RaiseNonIntersectingException( root1, v1, v2 );
        return;
    }

    /* Set up the internal simple edge from root1 to root2 */
    newIntEdge.v1 = root1;
    newIntEdge.v2 = root2;
    newIntEdge.redRed = redRed;
    CopyReplInfo( &ri2, &newIntEdge.ri );
    newIntEdge.edgeType = e->edgeType;

    /* Sort newIntEdge's vertices based on vertexName */
    if( newIntEdge.v1->vtxId > newIntEdge.v2->vtxId ) {
        temp = newIntEdge.v1;
        newIntEdge.v1 = newIntEdge.v2;
        newIntEdge.v2 = temp;
    }

    /* Insert this edge into our table of internal edges. If an identical edge 
     * already exists in the table, newIntEdge will not be inserted. */
    RtlInsertElementGenericTable( internalEdges, &newIntEdge,
        sizeof(ToplInternalEdge), NULL );
}


/***** ColorComp *****/
/* Determine which vertex has better color. Demotion is also taken into account.
 * Return values:
 *  -1  - v1 is better
 *   0  - color-wise, they are the same
 *   1  - v2 is better. */
int
ColorComp(
    IN PToplVertex v1,
    IN PToplVertex v2 )
{
    DWORD color1=v1->color, color2=v2->color;

    if( v1->demoted ) {
        color1 = COLOR_WHITE;
    }
    if( v2->demoted ) {
        color2 = COLOR_WHITE;
    }
    
    switch(color1) {
        case COLOR_RED:
            return (COLOR_RED==color2) ? 0 : -1;
        case COLOR_BLACK:
            switch(color2) {
                case COLOR_RED:
                    return 1;
                case COLOR_BLACK:
                    return 0;
                case COLOR_WHITE:
                    return -1;
                default:
                    ASSERT( !"Invalid Color!" );
                    return 0;
            }
        case COLOR_WHITE:
            return (COLOR_WHITE==color2) ? 0 : 1;
        default:
            ASSERT( !"Invalid Color!" );
            return 0;
    }
}


/***** ProcessEdge *****/
/* After running Dijkstra's algorithm, this function examines a multi-edge
 * and adds internal edges between every tree connected by this edge. */
VOID
ProcessEdge(
    IN ToplGraphState *g,
    IN PTOPL_MULTI_EDGE e,
    IN OUT RTL_GENERIC_TABLE *internalEdges
    )
{
    PToplVertex bestV, v;
    DWORD iVtx;
    int cmp;

    CheckMultiEdge( e );
    ASSERT( e->numVertices>=2 );

    /* Find the best vertex to be the 'root' of this multi-edge.
     * Color is most important (red is best), then cost. */
    bestV = EdgeGetVertex( g, e, 0 );
    for( iVtx=1; iVtx<e->numVertices; iVtx++ ) {
        v = EdgeGetVertex( g, e, iVtx );
        cmp = ColorComp(v,bestV);
        if(   (cmp<0)
           || (cmp==0 && VertexComp(v,bestV,g)<0) )
        {
            bestV = v;
        }
    }

    /* Add to internalEdges an edge from every colored vertex to the best vertex */
    for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
        v = EdgeGetVertex( g, e, iVtx );

        /* Demoted vertices can have a valid component ID but no root. */
        if( v->componentId!=UNCONNECTED_COMPONENT && v->root==NULL ) {
            ASSERT( v->demoted );
            continue;
        }

        /* Only add this edge if it is a valid inter-tree edge.
         * (The two vertices must be reachable from the root vertices,
         * and in different components.) */
        if(  (bestV->componentId!=UNCONNECTED_COMPONENT) && (NULL!=bestV->root)
          && (v->componentId    !=UNCONNECTED_COMPONENT) && (NULL!=v->root)
          && (bestV->componentId!=v->componentId)
        ) {
            AddIntEdge( g, internalEdges, e, bestV, v ); 
        }

    }
}


/***** ProcessEdgeSet *****/
/* After running Dijkstra's algorithm to determine the shortest-path forest,
 * examine all edges in this edge set. We find all inter-tree edges, from
 * which we build the list of 'internal edges', which we will later pass
 * on to Kruskal's algorithm.
 * This function doesn't do much except call ProcessEdge() for every edge. */
VOID
ProcessEdgeSet(
    ToplGraphState *g,
    int whichEdgeSet,
    RTL_GENERIC_TABLE *internalEdges
    )
{
    PTOPL_MULTI_EDGE_SET s;
    PTOPL_MULTI_EDGE e;
    PToplVertex v;
    DWORD iEdge, cEdge, iVtx;

    if( whichEdgeSet==EMPTY_EDGE_SET ) {

        /* Handle the implicit edge set, consisting of no edges */
        cEdge = DynArrayGetCount( &g->masterEdgeList );
        for( iEdge=0; iEdge<cEdge; iEdge++ ) {
            e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( &g->masterEdgeList, iEdge ));
            CheckMultiEdge(e);
            ProcessEdge( g, e, internalEdges );
        }

    } else {

        ASSERT( whichEdgeSet < (int) DynArrayGetCount(&g->edgeSets) );
        s = *((PTOPL_MULTI_EDGE_SET*) DynArrayRetrieve( &g->edgeSets, whichEdgeSet ) );
        CheckMultiEdgeSet(s);

        for( iEdge=0; iEdge<s->numMultiEdges; iEdge++ ) {
            e = s->multiEdgeList[iEdge];
            CheckMultiEdge(e);
            ProcessEdge( g, e, internalEdges );
        }

    }
}


/***** GetComponent *****/
/* Returns the id of the component containing vertex v by traversing
 * the up-tree implied by the component pointers. After finding the root,
 * we do path compression, which makes this operation very efficient. */
DWORD
GetComponent(
    ToplGraphState *g,
    PToplVertex v
    )
{
    PToplVertex u, w;
    DWORD root, cmp;

    /* Find root of the up-tree created by component pointers */
    u=v;
    while( u->componentId!=(int) u->vtxId ) {

        ASSERT( u->componentId != UNCONNECTED_COMPONENT );
        ASSERT( u->componentId >= 0 );
        cmp = (DWORD) u->componentId;
        ASSERT( cmp < g->numVertices ); 

        u = &g->vertices[ cmp ];
        ASSERT( (DWORD) u->vtxId == cmp );
    }
    root = u->vtxId;
    
    /* Compress the path to the root */
    u=v;
    while( u->componentId!=(int) u->vtxId ) {

        ASSERT( u->componentId != UNCONNECTED_COMPONENT );
        ASSERT( u->componentId >= 0 );
        cmp = (DWORD) u->componentId;
        ASSERT( cmp < g->numVertices ); 

        w = &g->vertices[cmp];
        ASSERT( (DWORD) w->vtxId == cmp );
        u->componentId = root;
        u = w;
    }

    return root;
}


/***** EdgeCompare *****/
/* Sort the internal edges by key (redRed,cost,scheduleDuration,Vtx1Name,Vtx2Name).
 * Note: We consider edges with longer duration to be better.
 */
RTL_GENERIC_COMPARE_RESULTS
NTAPI EdgeCompare(
    RTL_GENERIC_TABLE *Table,
    PVOID p1, PVOID p2
    )
{
    PToplInternalEdge e1 = (PToplInternalEdge) p1;
    PToplInternalEdge e2 = (PToplInternalEdge) p2;
    DWORD d1, d2;

    ASSERT( e1!=NULL && e2!=NULL );

    /* Give priority to edges connecting two red vertices */
    if( e1->redRed && !e2->redRed ) {
        return GenericLessThan;
    } else if( !e1->redRed && e2->redRed ) {
        return GenericGreaterThan;
    }

    /* Sort based on cost */
    if( e1->ri.cost < e2->ri.cost ) {
        return GenericLessThan;
    } else if( e1->ri.cost > e2->ri.cost ) {
        return GenericGreaterThan;
    }

    /* Sort based on schedule duration */
    d1 = ToplScheduleDuration( e1->ri.schedule );
    d2 = ToplScheduleDuration( e2->ri.schedule );
    if( d1 > d2 ) {         /* Note: These comparisons are intentionally reversed */
        return GenericLessThan;
    } else if( d1 < d2 ) {
        return GenericGreaterThan;
    }

    /* Sort based on vertex1Name */
    if( e1->v1->vtxId < e2->v1->vtxId ) {
        return GenericLessThan;
    } else if( e1->v1->vtxId > e2->v1->vtxId ) {
        return GenericGreaterThan;
    }

    /* Sort based on vertex2Name */
    if( e1->v2->vtxId < e2->v2->vtxId ) {
        return GenericLessThan;
    } else if( e1->v2->vtxId > e2->v2->vtxId ) {
        return GenericGreaterThan;
    } 

    /* Sort based on edge type. It is possible that the edge types are equal,
     * but in that case we consider the edges to be identical. */
    if( e1->edgeType < e2->edgeType ) {
        return GenericLessThan;
    } else if( e1->edgeType > e2->edgeType ) {
        return GenericGreaterThan;
    }

    return GenericEqual;
}


/***** AddOutEdge *****/
/* We have found a new edge, e, for our spanning tree edge. Add this
 * edge to our list of output edges. */
VOID
AddOutEdge(
    PDynArray outputEdges, 
    PToplInternalEdge e
    )
{
    PTOPL_MULTI_EDGE ee;
    PToplVertex v1, v2;

    v1 = e->v1;
    v2 = e->v2;

    ASSERT( v1->root == v1 );           /* Both v1 and v2 should be root vertices */
    ASSERT( v2->root == v2 );
    ASSERT( v1->color != COLOR_WHITE );  /* ... which means they are colored */
    ASSERT( v2->color != COLOR_WHITE );

    /* Create an output multi edge */
    ee = CreateMultiEdge( 2 );
    ee->vertexNames[0].name = v1->vertexName;
    ee->vertexNames[0].reserved = v1->vtxId;
    ee->vertexNames[1].name = v2->vertexName;
    ee->vertexNames[1].reserved = v2->vtxId;
    ee->edgeType = e->edgeType;
    CopyReplInfo( &e->ri, &ee->ri );
    DynArrayAppend( outputEdges, &ee );

    /* We also add this new spanning-tree edge to the edge lists of its endpoints. */
    CheckMultiEdge( ee );
    DynArrayAppend( &v1->edgeList, &ee );
    DynArrayAppend( &v2->edgeList, &ee );
}


/***** Kruskal *****/
/* Run Kruskal's minimum-cost spanning tree algorithm on the internal edges
 * (which represent shortest paths in the original graph between colored
 * vertices). 
 * */
VOID
Kruskal(
    IN PToplGraphState g,
    IN RTL_GENERIC_TABLE *internalEdges,
    IN DWORD numExpectedTreeEdges,
    OUT PDynArray outputEdges
    )
{
    PToplInternalEdge e;
    DWORD comp1, comp2, cSTEdges;

    ClearEdgeLists( g );
    
    /* Counts the total number of spanning tree edges that we have found. This
     * count includes edges which are not incident with 'whichVtx'. This is done
     * so that we can stop building the spanning tree when we have enough edges. */
    cSTEdges=0;             
    
    /* Process every edge in the priority queue */
    while( ! RtlIsGenericTableEmpty(internalEdges) ) {

        e = (PToplInternalEdge) RtlEnumerateGenericTable( internalEdges, TRUE );
        ASSERT( e );

        /* We must prevent cycles in the spanning tree. If we are to add
         * edge e, we must ensure its endpoints are in different components */
        comp1 = GetComponent( g, e->v1 );
        comp2 = GetComponent( g, e->v2 );
        if( comp1!=comp2 ) {

            /* This internal edge connects two components, so it is a valid
             * spanning tree edge. */
            cSTEdges++;
             
            /* Add this edge to our list of output edges */
            AddOutEdge( outputEdges, e );

            /* Combine the two connected components */
            ASSERT( comp1<g->numVertices );
            ASSERT( g->vertices[comp1].componentId==(int) comp1 );
            g->vertices[comp1].componentId = comp2;

        }

        RtlDeleteElementGenericTable( internalEdges, e );
        if( cSTEdges==numExpectedTreeEdges ) {
            break;
        }
    }
}


/***** DepthFirstSearch *****/
/* Do a non-recursive depth-first-search from node v. To avoid recursion we
 * store a 'parent' pointer in each vertex, and to avoid rescanning the edge-lists
 * unnecessarily, we store a 'nextChild' index in each vertex. */
VOID
DepthFirstSearch(
    IN PToplGraphState g,
    IN PToplVertex rootVtx
    )
{
    PToplVertex v, w;
    PTOPL_MULTI_EDGE e;
    DWORD cEdge;

    rootVtx->distToRed = 0;
    ASSERT( 0==rootVtx->nextChild );
    ASSERT( NULL==rootVtx->parent );
    ASSERT( COLOR_RED==rootVtx->color );
    
    /* DFS through the tree until we reach the root again. */
    for( v=rootVtx; NULL!=v; ) {
        
        /* Examine every edge in v's edge list */
        cEdge = DynArrayGetCount( &v->edgeList );
        if( v->nextChild>=cEdge ) {
            v = v->parent;
            continue;
        }
        
        /* Retrieve the edge from the edge list */
        e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( &v->edgeList, v->nextChild ));
        CheckMultiEdge( e );
        ASSERT( 2==e->numVertices );
        ASSERT( e->vertexNames[0].reserved<g->numVertices );
        ASSERT( e->vertexNames[1].reserved<g->numVertices );
        v->nextChild++;
        
        /* Find the endpoint of the edge which is not v */
        w = &g->vertices[ e->vertexNames[0].reserved ];
        if( v==w ) {
            w = &g->vertices[ e->vertexNames[1].reserved ];
        }
        ASSERT( w!=NULL );
        
        /* Ignore this edge if w has already been processed */
        if( INFINITY!=w->distToRed ) {
            /* Note: No guarantee that w is in the same tree as v, because
             * of directed edges */
            continue;
        }
        
        /* Compute distToRed value for w */
        ASSERT( 0==w->nextChild );
        ASSERT( NULL==w->parent );
        ASSERT( INFINITY==w->distToRed );
        w->parent = v;
        if( COLOR_RED==w->color ) {
            w->distToRed = 0;
            ASSERT( COLOR_RED==v->color );
        } else {
            w->distToRed = v->distToRed+1;
        }
        v = w;
    }
}


/***** CalculateDistToRed *****/
/* Do a DFS on the spanning tree in order to calculate distToRed for all vtx. */
VOID
CalculateDistToRed(
    IN PToplGraphState g,
    IN PDynArray outputEdges
    )
{
    PToplVertex v;
    DWORD iVtx;

    /* Initialize the vertices */
    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        v = &g->vertices[iVtx];
        ASSERT( NULL!=v );

        v->nextChild = 0;
        v->parent = NULL;
        v->distToRed = INFINITY;
    }
        
    /* Start a DFS from all red vertices */
    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        v = &g->vertices[iVtx];
        ASSERT( NULL!=v );
        if( COLOR_RED!=v->color || INFINITY!=v->distToRed ) {
            continue;
        }

        DepthFirstSearch( g, v );
    }
}


/***** CountComponents *****/
/* Count the number of components. A component is considered to be a bunch
 * colered vertices which are connected by the spanning tree. Vertices whose
 * component id is the same as their vertex id are the root of a connected
 * component.
 *
 * When we find a root of a component, we record its 'component index'. The
 * component indices are a contiguous sequence of numbers which uniquely
 * identify a component. */
DWORD
CountComponents(
    IN PToplGraphState      g
    )
{
    PToplVertex     v;
    DWORD           iVtx, numComponents=0, compId;

    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        v = &g->vertices[iVtx];
        if( COLOR_WHITE==v->color ) {
            /* It's a non-colored vertex. Ignore it. */
            continue;
        }
        ASSERT( v->color==COLOR_RED || v->color==COLOR_BLACK );
        ASSERT( v->componentId != UNCONNECTED_COMPONENT );

        compId = GetComponent(g, v);
        if( compId == (int) iVtx ) {        /* It's a component root */
            v->componentIndex = numComponents;
            numComponents++;
        }
    }

    return numComponents;
}


/***** ScanVertices *****/
/* Iterate over all vertices in the graph. Accumulate a count of the number
 * of (red or black) vertices in each graph component.
 *
 * If the parameter 'fWriteToList' is TRUE, we also add each vertex's name
 * into the list of vertices which are in that component. This assumes that
 * memory for the list has already been allocated.
 */
VOID
ScanVertices(
    IN PToplGraphState      g,
    IN BOOL                 fWriteToList,
    IN OUT PTOPL_COMPONENTS pComponents
    )
{
    PToplVertex     v;
    TOPL_COMPONENT *pComp;
    DWORD           i, iVtx, compIndex, numVtx;
    int             compId;

    /* Check the parameters */
    ASSERT( NULL!=pComponents );
    ASSERT( NULL!=pComponents->pComponent );

    /* Clear the vertex counts on all the components */
    for( i=0; i<pComponents->numComponents; i++ ) {
        pComponents->pComponent[i].numVertices = 0;
    }

    /* Scan the vertices, counting the number of vertices per component */
    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        v = &g->vertices[iVtx];
        if( COLOR_WHITE==v->color ) {
            continue;
        }

        /* Find out the component index */
        ASSERT( v->componentId != UNCONNECTED_COMPONENT );
        compId = GetComponent( g, v );
        ASSERT( 0<=compId && compId<(int)g->numVertices );
        ASSERT( g->vertices[compId].componentId == compId );
        compIndex = g->vertices[compId].componentIndex;

        ASSERT( compIndex<pComponents->numComponents );
        pComp = &pComponents->pComponent[compIndex];
        
        /* Add this vertex to the list of vertices in this component */
        if( fWriteToList ) {
            numVtx = pComp->numVertices;
            ASSERT( NULL!=pComp->vertexNames );
            pComp->vertexNames[numVtx] = v->vertexName;
        }

        /* Increment the count of vertices */
        pComp->numVertices++;
    }
}


/***** SwapFilterVertexToFront *****/
/* The caller of ToplGetSpanningTreeEdgesForVtx() probably wants to know which
 * component the filter vertex (i.e. 'whichVertex') is in. We ensure that 
 * the first component in the list contains the filter vertex. */
VOID
SwapFilterVertexToFront(
    IN PToplGraphState      g,
    IN PToplVertex          whichVertex,
    IN OUT PTOPL_COMPONENTS pComponents
    )
{
    TOPL_COMPONENT      tempComp, *pComp1, *pComp2;
    DWORD               iVtx, whichCompId, whichCompIndex, compSize;

    /* If there is no filter vertex, there is no work to be done. */
    if( NULL==whichVertex ) {
        return;
    }

    /* We want the component containing the filter vertex (i.e. 'whichVertex') to
     * be the first one in the list. */
    whichCompId = GetComponent( g, whichVertex );
    ASSERT( -1!=whichCompId );
    ASSERT( g->vertices[whichCompId].componentId == whichCompId );
    whichCompIndex = g->vertices[ whichCompId ].componentIndex;
    ASSERT( whichCompIndex < pComponents->numComponents );

    /* Swap the component containing the filter vertex with the first component */
    pComp1 = &pComponents->pComponent[0];
    pComp2 = &pComponents->pComponent[whichCompIndex];
    compSize = sizeof(TOPL_COMPONENT);
    memcpy( &tempComp, pComp1, compSize );
    memcpy( pComp1, pComp2, compSize );
    memcpy( pComp2, &tempComp, compSize );

    /* The component index fields are now invalid. We don't actually need
     * them any more so we clear them out. */
    for( iVtx=0; iVtx<g->numVertices; iVtx++ ) {
        g->vertices[iVtx].componentIndex = 0;
    }
}


/***** ConstructComponents *****/
/* Build a structure containing a list of components. For each component we
 * store a list of vertices in that component. If 'whichVertex' is non-NULL,
 * the component containing it will be the first one in the list.
 *
 * Note: We only care about the red/black vertices here. We're not interested
 * in which component the white vertices are in. */
VOID
ConstructComponents(
    IN PToplGraphState      g,
    IN PToplVertex          whichVertex,
    IN OUT PTOPL_COMPONENTS pComponents
    )
{
    DWORD           iComp, numComponents, numVtx;
    
    /* Check if the caller actually wants component info */
    if( NULL==pComponents ) {
        return;
    }

    numComponents = CountComponents( g );

    /* Allocate and initialize the structure which will describe the components */
    pComponents->pComponent = ToplAlloc( numComponents * sizeof(TOPL_COMPONENT) );
    pComponents->numComponents = numComponents;
    for( iComp=0; iComp<numComponents; iComp++ ) {
        pComponents->pComponent[iComp].numVertices = 0;
        pComponents->pComponent[iComp].vertexNames = NULL;
    }

    /* Scan the vertices, counting the number of vertices in each component */
    ScanVertices( g, FALSE, pComponents );

    /* Now that we know how many vertices are in each component, allocate memory for
     * each component's list of vertices */
    for( iComp=0; iComp<numComponents; iComp++ ) {
        numVtx = pComponents->pComponent[iComp].numVertices;
        ASSERT( numVtx>0 );
        pComponents->pComponent[iComp].vertexNames =
            (PVOID*) ToplAlloc( numVtx * sizeof(PVOID) );
    }

    /* Scan the vertices again, this time storing each vertex's name in its
     * component's list. */
    ScanVertices( g, TRUE, pComponents );

    SwapFilterVertexToFront( g, whichVertex, pComponents );
}


/***** CopyOutputEdges *****/
/* All spanning-tree edges are stored in the Dynamic Array 'outputEdges'.
 * We extract all edges which contain 'whichVtx' as an endpoint and copy
 * them to a new TOPL_MULTI_EDGE array. If 'whichVtx' is NULL, we extract
 * all edges. */
PTOPL_MULTI_EDGE*
CopyOutputEdges(
    IN PToplGraphState g,
    IN PDynArray outputEdges,
    IN PToplVertex whichVtx,
    OUT DWORD *numEdges
    )
{
    DWORD iEdge, cEdge, iOutputEdge, cOutputEdge=0;
    PToplVertex v, w;
    PTOPL_MULTI_EDGE e;
    PTOPL_MULTI_EDGE *list;
    TOPL_NAME_STRUCT tempVtxName;

    cEdge = DynArrayGetCount( outputEdges );
    /* Count the number of edges which are incident with 'whichVtx' */
    for( iEdge=0; iEdge<cEdge; iEdge++ ) {

        /* Retrieve the next edge */
        e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( outputEdges, iEdge ));
        CheckMultiEdge( e );
        ASSERT( 2==e->numVertices );
        ASSERT( e->vertexNames[0].reserved<g->numVertices );
        ASSERT( e->vertexNames[1].reserved<g->numVertices );

        if(  whichVtx==NULL
          || e->vertexNames[0].reserved==whichVtx->vtxId
          || e->vertexNames[1].reserved==whichVtx->vtxId )
        {
            cOutputEdge++;
        }
    }

    /* Allocate an array to hold the filtered output edges */
    list = (PTOPL_MULTI_EDGE*) ToplAlloc( cOutputEdge*sizeof(PTOPL_MULTI_EDGE) );

    /* Examine every edge in the dynamic array and copy it to the filtered
     * array if necessary. */
    for( iEdge=iOutputEdge=0; iEdge<cEdge; iEdge++ ) {

        /* Retrieve the next edge */
        e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( outputEdges, iEdge ));
        CheckMultiEdge( e );
        ASSERT( 2==e->numVertices );
        ASSERT( e->vertexNames[0].reserved<g->numVertices );
        ASSERT( e->vertexNames[1].reserved<g->numVertices );

        v = &g->vertices[ e->vertexNames[0].reserved ];
        w = &g->vertices[ e->vertexNames[1].reserved ];

        if( whichVtx==NULL || v==whichVtx || w==whichVtx ) {
            ASSERT( iOutputEdge<cOutputEdge );
            list[iOutputEdge++] = e;

            /* Check if this edge meets the criteria of a 'directed edge'. */
            if(  (COLOR_BLACK==v->color || COLOR_BLACK==w->color)
              && INFINITY!=v->distToRed )
            {
                ASSERT( INFINITY!=w->distToRed );
                ASSERT( v->distToRed!=w->distToRed );
                e->fDirectedEdge = TRUE;

                /* Swap the vertices so that e->vertexNames[0] is closer to a
                 * red vertex than e->vertexNames[1]. */
                if( w->distToRed<v->distToRed ) {
                    memcpy( &tempVtxName, &e->vertexNames[0], sizeof(TOPL_NAME_STRUCT) );
                    memcpy( &e->vertexNames[0], &e->vertexNames[1], sizeof(TOPL_NAME_STRUCT) );
                    memcpy( &e->vertexNames[1], &tempVtxName, sizeof(TOPL_NAME_STRUCT) );
                }
            }
        }
    }

    ASSERT( iOutputEdge==cOutputEdge );
    *numEdges = cOutputEdge;
    return list;
}


/***** ClearInternalEdges *****/
/* After the spanning-tree algorithm has completed, we free all edges from
 * the 'internalEdges' list. */
VOID
ClearInternalEdges(
    IN RTL_GENERIC_TABLE *internalEdges
    )
{
    PToplInternalEdge e;

    while( ! RtlIsGenericTableEmpty(internalEdges) ) {
        e = (PToplInternalEdge) RtlEnumerateGenericTable( internalEdges, TRUE );
        RtlDeleteElementGenericTable( internalEdges, e );
    }
}


/***** CheckAllMultiEdges *****/
/* This function is used to check that all multi-edges have been properly
 * setup before running the spanning-tree algorithm. This ensures that
 * all edges have all of their vertices setup properly. */
VOID
CheckAllMultiEdges(
    IN PToplGraphState g
    )
{
    PTOPL_MULTI_EDGE e;
    DWORD iEdge, cEdge, iVtx;

    cEdge = DynArrayGetCount( &g->masterEdgeList );
    for( iEdge=0; iEdge<cEdge; iEdge++ ) {
        e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( &g->masterEdgeList, iEdge ));
        CheckMultiEdge(e);
        for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
            if( e->vertexNames[iVtx].name==NULL ) {
                ToplRaiseException( TOPL_EX_INVALID_VERTEX );
            }
        }
    }
}


/***** ToplGetSpanningTreeEdgesForVtx *****/
/* This function is the heart of the spanning-tree generation algorithm.
 * Its behavior is fairly complicated, but briefly it generates a minimum
 * cost spanning tree connecting the red and black vertices. It uses
 * edge sets and other (non-colored) vertices in the graph to determine how
 * the colored vertices can be connected. This function returns all tree edges
 * containing 'whichVtx'. */
PTOPL_MULTI_EDGE*
ToplGetSpanningTreeEdgesForVtx(
    IN PTOPL_GRAPH_STATE G,
    IN PVOID whichVtxName,
    IN TOPL_COLOR_VERTEX *colorVtx,
    IN DWORD numColorVtx,
    OUT DWORD *numStEdges,
    OUT PTOPL_COMPONENTS pComponents
    )
{
    PToplGraphState g;
    RTL_GENERIC_TABLE internalEdges;
    PTOPL_MULTI_EDGE *stEdgeList;
    PToplVertex whichVtx=NULL;
    DynArray outputEdges;
    DWORD iEdgeSet, cEdgeSet, edgeType, numTreeEdges=numColorVtx-1;


    /* Check parameters */
    g = CheckGraphState( G );
    if( numStEdges==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }
    if( whichVtxName!=NULL ) {
        whichVtx = FindVertex( g, whichVtxName );
        if( whichVtx==NULL ) {
            ToplRaiseException( TOPL_EX_INVALID_VERTEX );
        }
    }
    if( numColorVtx<2 ) {
        ToplRaiseException( TOPL_EX_COLOR_VTX_ERROR );
    }
    CheckAllMultiEdges( g );

    InitColoredVertices( g, colorVtx, numColorVtx, whichVtx );


    /******************************************************************************
     * Phase I: Run Dijkstra's algorithm, and build up a list of internal edges,
     * which are just really shortest-paths connecting colored vertices. 
     ******************************************************************************/
    RtlInitializeGenericTable( &internalEdges, EdgeCompare, TableAlloc, TableFree, NULL );

    /* Process all edge sets */
    cEdgeSet = DynArrayGetCount( &g->edgeSets );
    for( iEdgeSet=0; iEdgeSet<cEdgeSet; iEdgeSet++ ) {

        /* Setup the graph to use the edges from edge set iEdgeSet */
        edgeType = SetupEdges( g, iEdgeSet );
        
        /* Run Dijkstra's algorithm with just the red vertices as the roots */
        Dijkstra( g, edgeType, FALSE );
        
        /* Process the minimum-spanning forest built by Dijkstra, and add any
         * inter-tree edges to our list of internal edges */
        ProcessEdgeSet( g, (int) iEdgeSet, &internalEdges );
        
        /* Run Dijkstra's algorithm with Union(redVtx,blackVtx) as the root vertices */
        Dijkstra( g, edgeType, TRUE );
        
        /* Process the minimum-spanning forest built by Dijkstra, and add any
         * inter-tree edges to our list of internal edges */
        ProcessEdgeSet( g, (int) iEdgeSet, &internalEdges );
    }

    /* Process the implicit empty edge set */
    SetupVertices( g );
    ProcessEdgeSet( g, EMPTY_EDGE_SET, &internalEdges );


    /******************************************************************************
     * Phase II: Run Kruskal's Algorithm on the internal edges. 
     ******************************************************************************/
    DynArrayInit( &outputEdges, sizeof(PTOPL_MULTI_EDGE) );
    Kruskal( g, &internalEdges, numTreeEdges, &outputEdges );


    /******************************************************************************
     * Phase III: Post-process the output.
     *  - Traverse tree structure to find one-way black-black edges
     *  - Determine the component structure
     ******************************************************************************/
    CalculateDistToRed( g, &outputEdges );
    ConstructComponents( g, whichVtx, pComponents );
    stEdgeList = CopyOutputEdges( g, &outputEdges, whichVtx, numStEdges );

    /* Clean up */
    ClearInternalEdges( &internalEdges );
    DynArrayDestroy( &outputEdges );

    return stEdgeList;
}


/***** ToplDeleteSpanningTreeEdges *****/
/* After finding the spanning-tree edges, this function should be used to
 * free their memory. */
VOID
ToplDeleteSpanningTreeEdges(
    PTOPL_MULTI_EDGE *stEdgeList,
    DWORD numStEdges )
{
    DWORD i;

    if( stEdgeList==NULL ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }

    for( i=0; i<numStEdges; i++ ) {
        if( stEdgeList[i]==NULL ) {
            ToplRaiseException( TOPL_EX_NULL_POINTER );
        }
        /* Todo: Could check that the number of vertices is 2 */
        FreeMultiEdge( stEdgeList[i] );
    }
    ToplFree( stEdgeList );
}


/***** ToplDeleteComponents *****/
/* After finding the spanning-tree edges, this function should be used to
 * free the data about the components */
VOID
ToplDeleteComponents(
    PTOPL_COMPONENTS pComponents
    )
{
    DWORD iComp, cComp;

    if( NULL==pComponents || NULL==pComponents->pComponent ) {
        ToplRaiseException( TOPL_EX_NULL_POINTER );
    }

    cComp = pComponents->numComponents;
    for( iComp=0; iComp<cComp; iComp++ ) {
        ASSERT( NULL!=pComponents->pComponent[iComp].vertexNames );
        ToplFree( pComponents->pComponent[iComp].vertexNames );
        pComponents->pComponent[iComp].vertexNames = NULL;
        pComponents->pComponent[iComp].numVertices = 0; 
    }

    ToplFree( pComponents->pComponent );
    pComponents->pComponent = NULL;
    pComponents->numComponents = 0;
}


/***** ToplDeleteGraphState *****/
/* After the ToplGraphState object is not needed any more, this function
 * should be used to free its memory. */
VOID
ToplDeleteGraphState(
    PTOPL_GRAPH_STATE G
    )
{
    ToplGraphState *g;
    PTOPL_MULTI_EDGE e;
    DWORD i, cEdge;

    g = CheckGraphState( G );
    g->vertexNames = NULL;              /* Should be freed by user */

    /* Destroy vertices */
    for( i=0; i<g->numVertices; i++ ) {
        DynArrayDestroy( &g->vertices[i].edgeList );
    }
    ToplFree( g->vertices );
    g->vertices = NULL;

    /* Destroy the edges */
    cEdge = DynArrayGetCount( &g->masterEdgeList );
    for( i=0; i<cEdge; i++ ) {
        e = *((PTOPL_MULTI_EDGE*) DynArrayRetrieve( &g->masterEdgeList, i ));
        CheckMultiEdge(e);
        FreeMultiEdge(e);
    }

    /* The edges and the edge sets should be freed by user */
    DynArrayDestroy( &g->masterEdgeList );
    DynArrayDestroy( &g->edgeSets );

    ToplFree( g );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\stda.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    stda.h

Abstract:

    This file provides the interfaces for using dynamic arrays. A 'DynArray' is
    similar to a DYNAMIC_ARRAY, but differs in that objects can be stored, instead
    of pointers to objects. This can reduce the number of allocations we have to
    make.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    19-6-2000   NickHar   Created
    
--*/

#ifndef DYNARRAY_H
#define DYNARRAY_H

/***** Constants *****/
#define DYN_ARRAY_NOT_FOUND             (-1)

/***** DynArray *****/
typedef struct {
    DWORD       elementSize;            /* Size of a single element in bytes */
    DWORD       logicalElements;        /* The number of elements stored in the array */
    DWORD       physicalElements;       /* The number of elements we have allocated space for */
    PBYTE       data;                   /* Pointer to array data */
    BOOLEAN     fSorted;                /* Is this array in sorted order? */
} DynArray;
typedef DynArray *PDynArray;

typedef int (__cdecl *DynArrayCompFunc)(const void*, const void*);

/***** DynArrayInit *****/
/* Initialize a dynamic array. The 'allocationChunk' indicates how many new elements will
 * be allocated at a time when we allocate new memory. If this parameter is 0, a default
 * value will be used. */
VOID
DynArrayInit(
    DynArray    *d,
    DWORD       elementSize
    );

/***** DynArrayClear *****/
/* Clear all the entries from an array. The array must have been
 * initialized before calling this function. */
VOID
DynArrayClear(
    DynArray    *d
    );

/***** DynArrayDestroy *****/
VOID
DynArrayDestroy(
    DynArray    *d
    );

/***** DynArrayGetCount *****/
DWORD
DynArrayGetCount(
    DynArray    *d
    );

/***** DynArrayAppend *****/
/* Increase the size of the array, making room for (at least) one new element.
 * If newElementData is non-NULL, copy this data into the new spot.
 * Return a pointer to the memory for the newly allocated element. */
PVOID
DynArrayAppend(
    DynArray    *d,
    PVOID       newElementData
    );

/***** DynArrayRetrieve *****/
/* Retrieve the element at location index in array d. index _must_ be
 * between 0 and logicalSize-1.
 * Note: This function returns a pointer to the item which was inserted
 * into the array, and will never return NULL. */
PVOID
DynArrayRetrieve(
    DynArray    *d,
    DWORD       index
    );

/***** DynArraySort *****/
VOID
DynArraySort(
    DynArray    *d,
    DynArrayCompFunc cmp
    );

/***** DynArraySearch *****/
/* Search an array for an element. If the element is not found, returns
 * DYN_ARRAY_NOT_FOUND, otherwise returns the index of the element in
 * the array. The array must be in sorted order for this to work. */
int
DynArraySearch(
    DynArray    *d,
    PVOID       key,
    DynArrayCompFunc cmp
    );

#endif  /* DYNARRAY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\toplgrph.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplgrph.c

Abstract:

    This routine defines the private edge, list and graph routines.  

Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>

typedef unsigned long DWORD;


#include <w32topl.h>
#include <w32toplp.h>

#include <dynarray.h>
#include <topllist.h>
#include <toplgrph.h>

PEDGE
ToplpEdgeCreate(
    PEDGE Edge OPTIONAL
    )        

/*++                                                                           

Routine Description:

    This routine creates an edge object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.


--*/
{    
    PEDGE pEdge = Edge;

    if (!pEdge) {
        pEdge = ToplAlloc(sizeof(EDGE));
    }

    memset(pEdge, 0, sizeof(EDGE));

    pEdge->ObjectType = eEdge;

    return pEdge;
}

VOID
ToplpEdgeDestroy(
    PEDGE   pEdge,
    BOOLEAN fFree
    )
/*++                                                                           

Routine Description:

    This routine frees a PEDGE object.

Parameters:

    Edge  : a non-NULL PEDGE object
    
    fFree : this free the object if TRUE

--*/
{    


    //
    // Mark the object to prevent accidental reuse
    //
    pEdge->ObjectType = eInvalidObject;

    if (fFree) {
        ToplFree(pEdge);
    }

    return;
}

VOID
ToplpEdgeSetToVertex(
    PEDGE   pEdge,
    PVERTEX ToVertex
    )

/*++                                                                           

Routine Description:

    This routine sets the ToVertex field of the edge.

Parameters:
    
    pEdge     : a non-NULL PEDGE object
    ToVertex : if non-NULL points to a PVERTEX object
    
--*/
{    

    pEdge->EdgeData.To = ToVertex;

    return;
}

PVERTEX
ToplpEdgeGetToVertex(
    PEDGE   pEdge
    )
/*++                                                                           

Routine Description:

    This routine returns the ToVertex field

Parameters:
                                      
    pEdge     : a non-NULL PEDGE object

--*/
{    
    return pEdge->EdgeData.To;
}

VOID
ToplpEdgeSetFromVertex(
    PEDGE   pEdge,
    PVERTEX FromVertex
    )
/*++                                                                           

Routine Description:

    This routine sets the FromVertex of the Edge. 

Parameters:

    pEdge       : a non-NULL PEDGE object
    FromVertex : if non-NULL should refer to a PVERTEX object
    

--*/
{    
    pEdge->EdgeData.From = FromVertex;

    return;
}


PVERTEX
ToplpEdgeGetFromVertex(
    PEDGE pEdge
    )
/*++                                                                           

Routine Description:

    This routine returns the from vertex associated with Edge.

Parameters:

    pEdge should refer to a PEDGE object
    
Return Values:

    A PVERTEX object or NULL

--*/
{    
    return pEdge->EdgeData.From;
}

DWORD
ToplpEdgeGetWeight(
    PEDGE pEdge
    )
/*++                                                                           

Routine Description:

    This routine returns the weight associated with Edge.

Parameters:

    pEdge should refer to a PEDGE object
    
Return Values:
    
    DWORD

--*/
{    
    return pEdge->EdgeData.Weight;
}

VOID
ToplpEdgeSetWeight(
    PEDGE pEdge,
    DWORD Weight
    )
/*++                                                                           

Routine Description:

    This routine sets the weight associated with Edge.

Parameters:

    pEdge should refer to a PEDGE object
    
Return Values:
    
    None

--*/
{    
    pEdge->EdgeData.Weight = Weight;
}


VOID
ToplpEdgeAssociate(
    PEDGE pEdge
    )
/*++                                                                           

Routine Description:

    This routines adds the edges in question to edge lists of the 
    To and From vertices.

Parameters:

    Edge should refer to a PEDGE object

Return Values:

    None.
    
Throws:

    TOPL_EX_INVALID_VERTEX if either of the vertices don't point to valid
    vertices


--*/
{    
    if (!ToplpIsVertex(pEdge->EdgeData.To)) {
        ToplRaiseException(TOPL_EX_INVALID_VERTEX);
    }

    if (!ToplpIsVertex(pEdge->EdgeData.From)) {
        ToplRaiseException(TOPL_EX_INVALID_VERTEX);
    }

    ToplpVertexAddEdge(pEdge->EdgeData.To, pEdge);
    ToplpVertexAddEdge(pEdge->EdgeData.From, pEdge);

    return;
}

VOID
ToplpEdgeDisassociate(
    PEDGE pEdge
    )
/*++                                                                           

Routine Description:

    This routine sets the FromVertex of the Edge. 

Parameters:

    pEdge       : a non-NULL PEDGE object

--*/
{    

    if (!ToplpIsVertex(pEdge->EdgeData.To)) {
        ToplRaiseException(TOPL_EX_INVALID_VERTEX);
    }

    if (!ToplpIsVertex(pEdge->EdgeData.From)) {
        ToplRaiseException(TOPL_EX_INVALID_VERTEX);
    }

    ToplpVertexRemoveEdge(pEdge->EdgeData.To, pEdge);
    ToplpVertexRemoveEdge(pEdge->EdgeData.From, pEdge);

    return;
}

//
// Vertex object routines
//

PVERTEX
ToplpVertexCreate(
    PVERTEX Vertex OPTIONAL
    )
/*++                                                                           

Routine Description:

    This routine creates a vertex object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.


--*/
{    
    PVERTEX pVertex = Vertex;

    if (!pVertex) {
        pVertex = ToplAlloc(sizeof(VERTEX));
    }

    memset(pVertex, 0, sizeof(VERTEX));

    pVertex->ObjectType = eVertex;

    DynamicArrayInit(&pVertex->VertexData.InEdges);
    DynamicArrayInit(&pVertex->VertexData.OutEdges);

    return pVertex;

}

VOID
ToplpVertexDestroy(
    PVERTEX pVertex,
    BOOLEAN fFree
    )

/*++                                                                           

Routine Description:

    This routine releases the resources of a vertex object.

Parameters:

    pVertex    : a non-NULL PVERTEX object
    fFree      : this free the object if TRUE

--*/
{    

    //
    // Mark the object to prevent accidental reuse
    //
    DynamicArrayDestroy(&pVertex->VertexData.InEdges);
    DynamicArrayDestroy(&pVertex->VertexData.OutEdges);

    pVertex->ObjectType = eInvalidObject;

    if (fFree) {
        ToplFree(pVertex);
    }

    return;
}

//
// Property manipulation routines
//
VOID
ToplpVertexSetId(
    PVERTEX   pVertex,
    DWORD     Id
    )
/*++                                                                           

Routine Description:

    This routine sets the Id of Vertex

Parameters:

    pVertex : a non-NULL PVERTEX object

--*/
{   
    pVertex->VertexData.Id = Id;

    return;
}

DWORD
ToplpVertexGetId(
    PVERTEX pVertex
    )

/*++                                                                           

Routine Description:

    This routine returns the Id associated with this vertex.

Parameters:

    pVertex : a non-NULL PVERTEX object
    
    
Returns:

    The id of the vertex
    
--*/
{  
    return pVertex->VertexData.Id;
}

VOID
ToplpVertexSetParent(
    PVERTEX   pVertex,
    PVERTEX   pParent
    )
/*++                                                                           

Routine Description:

    This routine sets the parent of Vertex

Parameters:

    pVertex : a non-NULL PVERTEX object
    
    pParent : a PVERTEX object

--*/
{   
    pVertex->VertexData.Parent = pParent;

    return;
}

PVERTEX
ToplpVertexGetParent(
    PVERTEX pVertex
    )

/*++                                                                           

Routine Description:

    This routine returns the parent associated with this vertex.

Parameters:

    pVertex : a non-NULL PVERTEX object
    
    
Returns:

    The parent of the vertex
    
--*/
{  
    return pVertex->VertexData.Parent;
}
//
// Edge manipulation routines
//


DWORD
ToplpVertexNumberOfInEdges(
    PVERTEX   pVertex
    )
/*++                                                                           

Routine Description:


Parameters:

    pVertex : a non-NULL PVERTEX object

Raises:

    TOPL_EX_INVALID_EDGE
    
--*/
{
    return DynamicArrayGetCount(&pVertex->VertexData.InEdges);
}

PEDGE
ToplpVertexGetInEdge(
    PVERTEX   pVertex,
    DWORD     Index
    )
/*++                                                                           

Routine Description:


Parameters:

    pVertex : a non-NULL PVERTEX object

Raises:

    TOPL_EX_INVALID_EDGE
    
--*/
{
    if (((signed)Index < 0) || Index >= DynamicArrayGetCount(&pVertex->VertexData.InEdges)) {
        ToplRaiseException(TOPL_EX_INVALID_INDEX);
    }

    return DynamicArrayRetrieve(&pVertex->VertexData.InEdges, Index);
}

DWORD
ToplpVertexNumberOfOutEdges(
    PVERTEX   pVertex
    )

/*++                                                                           

Routine Description:


Parameters:

    pVertex : a non-NULL PVERTEX object

Raises:

--*/
{
    return DynamicArrayGetCount(&pVertex->VertexData.OutEdges);
}

PEDGE
ToplpVertexGetOutEdge(
    PVERTEX   pVertex,
    DWORD     Index
    )

/*++                                                                           

Routine Description:


Parameters:

    pVertex : a non-NULL PVERTEX object

Raises:

    TOPL_EX_INVALID_EDGE
    
--*/
{

    if (((signed)Index < 0) || Index >= DynamicArrayGetCount(&pVertex->VertexData.OutEdges)) {
        ToplRaiseException(TOPL_EX_INVALID_INDEX);
    }

    return DynamicArrayRetrieve(&pVertex->VertexData.OutEdges, Index);

}

VOID
ToplpVertexAddEdge(
    PVERTEX pVertex,
    PEDGE   pEdge
    )

/*++                                                                           

Routine Description:

    This routine adds Edge to the edge list associated with Vertex.  EdgeToAdd
    must have its FromVertex or ToVertex set to Vertex.

Parameters:

    pVertex : a non-NULL PVERTEX object
    pEdge   : a non-NULL PEDGE object

Raises:

    TOPL_EX_INVALID_EDGE
    
--*/
{   


    if (ToplpEdgeGetFromVertex(pEdge) == pVertex) {

        DynamicArrayAdd(&pVertex->VertexData.OutEdges, pEdge);
         
    } else if (ToplpEdgeGetToVertex(pEdge)  == pVertex) {

        DynamicArrayAdd(&pVertex->VertexData.InEdges, pEdge);

    } else {

        //
        // Adding an edge whose from vertex is not the vertex
        // that is passed in
        //
        ToplRaiseException(TOPL_EX_INVALID_EDGE);

    }

    return;
}

VOID
ToplpVertexRemoveEdge(
    PVERTEX pVertex,
    PEDGE   pEdge
    )
/*++                                                                           

Routine Description:

    This routine removes EdgeToRemove from Vertex's edge list.
Parameters:

    pVertex : a non-NULL PVERTEX object
    pEdge   : if non-NULL, a PEDGE object

Returns:

    PEDGE object if found
    
Raises:

    TOPL_EX_INVALID_EDGE if the edge to be deleted does not have a from vertex
    of the vertex begin acted on.    

--*/
{   

    ASSERT(pVertex);
    ASSERT(pEdge);

    if (ToplpEdgeGetFromVertex(pEdge) == pVertex) {

        DynamicArrayRemove(&pVertex->VertexData.OutEdges, pEdge, 0);
         
    } else if (ToplpEdgeGetToVertex(pEdge)  == pVertex) {

        DynamicArrayRemove(&pVertex->VertexData.InEdges, pEdge, 0);

    } else {

        //
        // Adding an edge whose from vertex is not the vertex
        // that is passed in
        //
        ToplRaiseException(TOPL_EX_INVALID_EDGE);

    }
}

//
// Graph object routines
//

PGRAPH
ToplpGraphCreate(
    PGRAPH Graph OPTIONAL
    )
/*++                                                                           

Routine Description:

    This routine creates a graph object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.

--*/
{    

    PGRAPH pGraph = Graph;

    if (!pGraph) {
        pGraph = ToplAlloc(sizeof(GRAPH));
    }

    memset(pGraph, 0, sizeof(GRAPH));

    pGraph->ObjectType = eGraph;
    pGraph->VertexList.ObjectType = eList;
    return pGraph;

}

VOID
ToplpGraphDestroy(
    PGRAPH   pGraph,
    BOOLEAN  fFree,
    BOOLEAN  fRecursive
    )
/*++                                                                           

Routine Description:

    This routine frees a graph object.

Parameters:

    pGraph  : a non-NULL PGRAPH object
    fFree   : this frees the objects if TRUE
    fRecursive : TRUE implies to free all edges and vertices associated with
                 the graph

--*/
{   

    if (fRecursive) {
    
        PVERTEX pVertex;
    
        while (pVertex = ToplpListRemoveElem(&(pGraph->VertexList), NULL)) {
            //
            // Recursive delete the vertices, too
            // 
            ToplpVertexDestroy(pVertex, fFree);
        }

    }

    //
    // Mark the object to prevent accidental reuse
    //
    pGraph->ObjectType = eInvalidObject;

    if (fFree) {
        ToplFree(pGraph);
    }

    return;
}

VOID
ToplpGraphAddVertex(
    PGRAPH  pGraph,
    PVERTEX pVertex
    )
/*++                                                                           

Routine Description:

    This routine adds VertexToAdd to Graph.

Parameters:

    pGraph  : a non-NULL PGRAPH object
    pVertex : a non-NULL PVERTEX object

Return Values:

--*/
{    
    ToplpListAddElem(&(pGraph->VertexList), pVertex);
    
    return;
}

PVERTEX
ToplpGraphRemoveVertex(
    PGRAPH  pGraph,
    PVERTEX pVertex
    )
/*++                                                                           

Routine Description:

    This routine removes and returns VertexToRemove from Graph if VertexToRemove
    is in Graph; returns NULL otherwise.
    If VertexToRemove is NULL, the first vertex in Graph's vertex list is
    removed.

Parameters:
    
    pGraph  : a non-NULL PGRAPH object
    pVertex : should be NULL or refer to a PVERTEX object

--*/
{   
    return ToplpListRemoveElem(&(pGraph->VertexList), pVertex);
}
      
VOID
ToplpGraphSetVertexIter(
    PGRAPH    pGraph,
    PITERATOR pIter
    )
/*++                                                                           

Routine Description:

    This routine sets Iter to point to the beginning of Graph's vertex list.

Parameters:

    pGraph  : a non-NULL PGRAPH object
    pIter   : a non-NULL PTIERATOR object

--*/
{   
    ToplpListSetIter(&(pGraph->VertexList), pIter);

    return;
}


DWORD
ToplpGraphNumberOfVertices(
    PGRAPH    pGraph
)
/*++                                                                           

Routine Description:

    This routine returns the number of vertices in Graph's vertex list.

Parameters:

    pGraph  : a non-NULL PGRAPH object

--*/
{   
    return  ToplpListNumberOfElements(&pGraph->VertexList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\toplgrph.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplgrph.h

Abstract:

    This file define the basic graph functions

Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#ifndef __TOPLGRPH_H
#define __TOPLGRPH_H

//
// Used a sentinel for the edge weight in mst functions
//
#define DWORD_INFINITY  ((DWORD)~0)

PEDGE
ToplpEdgeCreate(
    PEDGE Edge OPTIONAL
    );

VOID
ToplpEdgeDestroy(
    PEDGE    Edge,
    BOOLEAN  fFree
    );

VOID
ToplpEdgeSetToVertex(
    PEDGE   Edge,
    PVERTEX ToVertex
    );

PVERTEX
ToplpEdgeGetToVertex(
    PEDGE   Edge
    );

VOID
ToplpEdgeSetFromVertex(
    PEDGE   Edge,
    PVERTEX FromVertex
    );

PVERTEX
ToplpEdgeGetFromVertex(
    PEDGE pEdge
    );

VOID
ToplpEdgeSetWeight(
    PEDGE   Edge,
    DWORD   Weight
    );

DWORD
ToplpEdgeGetWeight(
    PEDGE pEdge
    );

VOID
ToplpEdgeAssociate(
    PEDGE pEdge
    );

VOID
ToplpEdgeDisassociate(
    PEDGE pEdge
    );

PVERTEX
ToplpVertexCreate(
    PVERTEX Vertex OPTIONAL
    );

VOID
ToplpVertexDestroy(
    PVERTEX    pVertex,
    BOOLEAN    fFree
    );

VOID
ToplpVertexSetId(
    PVERTEX   pVertex,
    DWORD     Id
    );

DWORD
ToplpVertexGetId(
    PVERTEX pVertex
    );

VOID
ToplpVertexSetParent(
    PVERTEX   pVertex,
    PVERTEX   pParent
    );

PVERTEX
ToplpVertexGetParent(
    PVERTEX pVertex
    );

VOID
ToplpVertexAddEdge(
    PVERTEX Vertex,
    PEDGE   pEdge
    );

VOID
ToplpVertexRemoveEdge(
    PVERTEX pVertex,
    PEDGE   pEdge
    );

DWORD
ToplpVertexNumberOfInEdges(
    PVERTEX   pVertex
    );

PEDGE
ToplpVertexGetInEdge(
    PVERTEX   pVertex,
    DWORD     Index
    );

DWORD
ToplpVertexNumberOfOutEdges(
    PVERTEX   pVertex
    );

PEDGE
ToplpVertexGetOutEdge(
    PVERTEX   pVertex,
    DWORD     Index
    );

PGRAPH
ToplpGraphCreate(
    PGRAPH Graph OPTIONAL
    );

VOID
ToplpGraphDestroy(
    PGRAPH   Graph,
    BOOLEAN  fFree,
    BOOLEAN  fRecursive
    );

VOID
ToplpGraphAddVertex(
    PGRAPH  pGraph,
    PVERTEX pVertex
    );

PVERTEX
ToplpGraphRemoveVertex(
    PGRAPH  pGraph,
    PVERTEX pVertex
    );
      
VOID
ToplpGraphSetVertexIter(
    PGRAPH    pGraph,
    PITERATOR pIter
    );


DWORD
ToplpGraphNumberOfVertices(
    PGRAPH    pGraph
    );


TOPL_COMPONENTS*
ToplpGraphFindEdgesForMST(
    IN  PGRAPH  Graph,
    IN  PVERTEX RootVertex,
    IN  PVERTEX VertexOfInterest,
    OUT PEDGE**  pEdges,
    OUT ULONG*  cEdges
    );

#endif // __TOPLGRPH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\stheap.c ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    stheap.h

Abstract:

    This file implements a binary heap. This heap supports the
    'cost reduced' operation, as required by Dijkstra's algorithm.

Notes:
    The first element in the heap is at index 1. Index 0 is not used.
    The nextFreeSpot gives the index of where the next element would
    be inserted in the heap. This should always be <= maxSize+1. The
    heap is full when nextFreeSpot == maxSize+1.
    The number of empty spots is thus maxSize-nextFreeSpot+1.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    20-6-2000   NickHar   Created
    
--*/

/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <w32topl.h>
#include "w32toplp.h"
#include "stheap.h"


/***** Macros *****/
#define ELEMENT_MOVED(x)    heap->SetLocn(heap->data[x],x,heap->extra);


/***** ToplSTHeapInit *****/
PSTHEAP
ToplSTHeapInit(
    DWORD                   maxSize,
    STHEAP_COMPARE_FUNC     Compare,
    STHEAP_GET_LOCN_FUNC    GetLocn,
    STHEAP_SET_LOCN_FUNC    SetLocn,
    PVOID                   extra
    )
{
    PSTHEAP heap;
    DWORD size;

    /* Check parameters */
    ASSERT( maxSize>0 );
    ASSERT( Compare!=NULL && GetLocn!=NULL && SetLocn!=NULL );

    heap = ToplAlloc( sizeof(STHEAP) );
    heap->nextFreeSpot = 1;
    heap->maxSize=maxSize;
    heap->Comp=Compare;
    heap->GetLocn=GetLocn;
    heap->SetLocn=SetLocn;
    heap->extra = extra;

    __try {
        size = sizeof(PVOID)*(maxSize+2);
        heap->data = ToplAlloc( size );
        RtlZeroMemory( heap->data, size );
    } __finally {
        if( AbnormalTermination() ) {
            ToplFree( heap );
        }
    }

    ASSERT( heap && heap->data );
    return heap;
}


/***** HeapNumEmptySpots *****/
int
static HeapNumEmptySpots(
    PSTHEAP heap
    )
{
    int empty = heap->maxSize-heap->nextFreeSpot+1;
    ASSERT( 1<=heap->nextFreeSpot );
    ASSERT( empty>=0 );
    return empty;
}


/***** ToplSTHeapDestroy *****/
/* Destroy a heap after it is no longer needed */
VOID
ToplSTHeapDestroy(
    PSTHEAP heap
    )
{
    ASSERT( heap && heap->data );
    ASSERT( HeapNumEmptySpots(heap)>=0 );
    ToplFree( heap->data );
    RtlZeroMemory( heap, sizeof(STHEAP) );
    ToplFree( heap );
}


/***** HeapBubbleUp *****/
/* Bubble an element up to its appropriate spot */
static VOID
HeapBubbleUp(
    PSTHEAP heap,
    DWORD bubbleFrom
    )
{
    int cmp;
    DWORD currentSpot, parent;
    PVOID temp;

    ASSERT( 1<=bubbleFrom && bubbleFrom<heap->nextFreeSpot );

    currentSpot = bubbleFrom;
    while( currentSpot>1 ) {
        parent = currentSpot / 2;
        ASSERT( 1<=parent && parent<bubbleFrom );

        ASSERT( heap->data[parent] );
        ASSERT( heap->data[currentSpot] );
        cmp = heap->Comp( heap->data[parent], heap->data[currentSpot], heap->extra );
        if( cmp<=0 ) {
            /* Parent is less or equal: new element is in the right spot */
            break;
        }

        /* Parent is smaller -- must move 'currentSpot' up */
        temp = heap->data[parent];
        heap->data[parent] = heap->data[currentSpot];
        heap->data[currentSpot] = temp;
        ELEMENT_MOVED( parent );
        ELEMENT_MOVED( currentSpot );

        currentSpot = parent;
    }
}


/***** HeapBubbleDown *****/
/* Bubble an element down to its appropriate spot */
static VOID
HeapBubbleDown(
    PSTHEAP heap,
    DWORD bubbleFrom
    )
{
    DWORD currentSpot, newSpot, left, right;
    int cmp;
    PVOID temp;

    currentSpot = bubbleFrom; 
    for(;;) {
        newSpot = currentSpot;
        left = 2*currentSpot;
        right = left+1;
        ASSERT( heap->GetLocn(heap->data[currentSpot],heap->extra)==(int)currentSpot );

        /* Check to see if the left child is less than the current spot */
        if( left<heap->nextFreeSpot ) {
            ASSERT( heap->data[left] );
            cmp = heap->Comp( heap->data[left], heap->data[currentSpot], heap->extra );
            if( cmp<0 ) {
                newSpot = left;
            }
        }

        /* Check to see if the right child is less than the new spot */
        if( right<heap->nextFreeSpot ) {
            ASSERT( heap->data[right] );
            cmp = heap->Comp( heap->data[right], heap->data[newSpot], heap->extra );
            if( cmp<0 ) {
                newSpot = right;
            }
        }

        /* newSpot is element with minimum cost in the set
         *  { heap[currentSpot], heap[left], heap[right] } */
        if( newSpot!=currentSpot ) {
            /* newSpot is smaller -- must move currentSpot down */
            temp = heap->data[newSpot];
            heap->data[newSpot] = heap->data[currentSpot];
            heap->data[currentSpot] = temp;
            ELEMENT_MOVED( newSpot );
            ELEMENT_MOVED( currentSpot );
        } else {
            /* The element is now in place */
            break;
        }

        ASSERT( newSpot>=currentSpot );
        currentSpot = newSpot;
    }

}


/***** ToplSTHeapAdd *****/
/* Add an element to the heap. The element must not be null, and
 * must be able to support the functions GetCost, etc. */
VOID
ToplSTHeapAdd(
    PSTHEAP heap,
    PVOID element
    )
{
    DWORD insertionPoint;
    
    /* Check that pointers are okay */
    ASSERT( heap && heap->data );
    ASSERT( element );
    /* Ensure element is not already in the heap */
    ASSERT( heap->GetLocn(element,heap->extra)==STHEAP_NOT_IN_HEAP );
    /* Ensure at least one spot is free */
    ASSERT( HeapNumEmptySpots(heap)>=1 );

    /* Find the insertion point and put the new element there */
    insertionPoint = heap->nextFreeSpot;
    heap->data[insertionPoint] = element;
    ELEMENT_MOVED( insertionPoint );

    heap->nextFreeSpot++;
    ASSERT( 1<heap->nextFreeSpot && HeapNumEmptySpots(heap)>=0 );

    HeapBubbleUp( heap, insertionPoint );
}


/***** ToplSTHeapExtractMin *****/
/* Extract the object with minimum cost from the heap. When the heap
 * is empty, returns NULL. */
PVOID
ToplSTHeapExtractMin(
    PSTHEAP heap
    )
{
    PVOID result;

    /* Check that pointers are okay */
    ASSERT( heap && heap->data );
    ASSERT( (DWORD)HeapNumEmptySpots(heap)<=heap->maxSize );

    /* If the heap is empty, just return NULL */
    if( heap->nextFreeSpot==1 ) {
        return NULL;
    }

    /* Grab the top element and reduce the heap size */
    result = heap->data[1];
    ASSERT( result );
    heap->SetLocn( result, STHEAP_NOT_IN_HEAP, heap->extra );

    /* Decrease the heap size */
    heap->nextFreeSpot--;
    if( heap->nextFreeSpot==1 ) {
        /* The heap is now empty -- we can return immediately */
        return result;
    }
    
    /* Move the last element in the heap to the top */
    heap->data[1] = heap->data[ heap->nextFreeSpot ];
    ASSERT( heap->data[1] );
    ASSERT( heap->GetLocn(heap->data[1],heap->extra)==(int)heap->nextFreeSpot );
    ELEMENT_MOVED( 1 );
    HeapBubbleDown( heap, 1 );

    return result;
}


/***** ToplSTHeapCostReduced *****/
/* Notify the heap that an element's cost has just been reduced.
 * The heap will be (efficiently) shuffled so that the heap property
 * is maintained */
VOID
ToplSTHeapCostReduced(
    PSTHEAP heap,
    PVOID element
    )
{
    DWORD child;
    int locn;

    /* Check that pointers are okay */
    ASSERT( heap && heap->data );
    ASSERT( element );
    /* Ensure element is already in the heap */
    locn = heap->GetLocn( element, heap->extra );
    ASSERT( 1<=locn && locn<(int)heap->nextFreeSpot );
    /* Ensure at least one spot is in use */
    ASSERT( (DWORD)HeapNumEmptySpots(heap)<heap->maxSize );
    
    /* Check that the heap property is still okay between this element
     * and its children (if they exist) */
    child = 2*locn;
    if( child<heap->nextFreeSpot ) {
        ASSERT( heap->Comp(heap->data[locn],heap->data[child],heap->extra) <= 0 );
    }
    child++;
    if( child<heap->nextFreeSpot ) {
        ASSERT( heap->Comp(heap->data[locn],heap->data[child],heap->extra) <= 0 );
    }

    HeapBubbleUp( heap, locn );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\stheap.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    stheap.h

Abstract:

    This file provides an interface to a binary heap. This heap supports the
    'cost reduced' operation, as required by Dijkstra's algorithm. Elements
    which can be inserted must support three operations:
        - Comparing two elements
        - Getting an integer value called 'location'
        - Setting the value of 'location'
    The location value is used to find elements in the heap. This value must
    be initialized to STHEAP_NOT_IN_HEAP.
    The 'extra' parameter is not used by the heap code -- it is just
    passed back to the comparison/location functions.
    For 'deterministic' behavior, no elements should have equal keys.

Author:

    Nick Harvey    (NickHar)
    
Revision History

    20-6-2000   NickHar   Created
    
--*/

#ifndef STHEAP_H
#define STHEAP_H

/***** Constants *****/
#define STHEAP_NOT_IN_HEAP  -1


/***** Function Type Definitions *****/
typedef int (*STHEAP_COMPARE_FUNC)( PVOID el1, PVOID el2, PVOID extra );
typedef int (*STHEAP_GET_LOCN_FUNC)( PVOID el1, PVOID extra );
typedef VOID (*STHEAP_SET_LOCN_FUNC)( PVOID el1, int l, PVOID extra ); 


/***** Heap *****/
typedef struct {
    DWORD                   nextFreeSpot, maxSize;
    PVOID                   *data;
    STHEAP_COMPARE_FUNC     Comp;
    STHEAP_GET_LOCN_FUNC    GetLocn;
    STHEAP_SET_LOCN_FUNC    SetLocn;
    PVOID                   extra;
} STHEAP;
typedef STHEAP *PSTHEAP;


/***** ToplSTHeapInit *****/
/* Allocate and initialize a heap object. This object should be destroyed
 * using the STHeapDestroy() function after it is no longer needed.
 * Throws an exception if any error occurs.
 * Parameters:
 *   maxSize        Maximum number of elements that will be stored in heap
 *   Comp           Pointer to a comparison function to compare heap elements
 *   GetLocn        Pointer to a function to get the 'location' field, as
 *                  described above
 *   SetLocn        Pointer to a function which sets the field 'location', as
 *                  described above
 *   extra          An extra parameter which is passed to the comparison
 *                  function, for the sake of convenience. Use is optional.
 */
PSTHEAP
ToplSTHeapInit(
    DWORD                   maxSize,
    STHEAP_COMPARE_FUNC     Comp,
    STHEAP_GET_LOCN_FUNC    GetLocn,
    STHEAP_SET_LOCN_FUNC    SetLocn,
    PVOID                   extra
    );

/***** ToplSTHeapDestroy *****/
/* Destroy a heap after it is no longer needed */
VOID
ToplSTHeapDestroy(
    PSTHEAP heap
    );

/***** ToplSTHeapAdd *****/
/* Add an element to the heap. The element must not be null, and
 * must be able to support the functions GetCost, etc. You must not
 * insert more elements than the maximum size.
 * The element must not already be in the heap, and it must have its
 * heap location set to STHEAP_NOT_IN_HEAP. */
VOID
ToplSTHeapAdd(
    PSTHEAP heap,
    PVOID element
    );

/***** ToplSTHeapExtractMin *****/
/* Extract the object with minimum cost from the heap. When the heap
 * is empty, returns NULL. */
PVOID
ToplSTHeapExtractMin(
    PSTHEAP heap
    );

/***** ToplSTHeapCostReduced *****/
/* Notify the heap that an element's cost has just been reduced.
 * The heap will be (efficiently) shuffled so that the heap property
 * is maintained */
VOID
ToplSTHeapCostReduced(
    PSTHEAP heap,
    PVOID element
    );


#endif /* STHEAP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\toplheap.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplheap.h

Abstract:

    This files exports the simple ADT of a heap.
               
Author:

    Colin Brace  (ColinBr)
    
Revision History

    12-5-97   ColinBr    Created
    
--*/

#ifndef __TOPLHEAP_H
#define __TOPLHEAP_H

typedef struct _TOPL_HEAP_INFO
{       
    PVOID* Array;
    ULONG cArray;
    DWORD (*pfnKey)( VOID *p ); 
    ULONG MaxElements;

} TOPL_HEAP_INFO, *PTOPL_HEAP_INFO;


BOOLEAN
ToplHeapCreate(
    OUT PTOPL_HEAP_INFO Heap,
    IN  ULONG           cArray,
    IN  DWORD          (*pfnKey)( VOID *p )
    );

VOID
ToplHeapDestroy(
    IN OUT PTOPL_HEAP_INFO Heap
    );

PVOID
ToplHeapExtractMin(
    IN PTOPL_HEAP_INFO Heap
    );

VOID
ToplHeapInsert(
    IN PTOPL_HEAP_INFO Heap,
    IN PVOID           Element
    );

BOOLEAN
ToplHeapIsEmpty(
    IN PTOPL_HEAP_INFO Heap
    );

BOOLEAN
ToplHeapIsElementOf(
    IN PTOPL_HEAP_INFO Heap,
    IN PVOID           Element
    );

#endif // __TOPLHEAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\topllist.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    topllist.h

Abstract:

    This file contains the routines for the list and iterator.

Author:

    Colin Brace  (ColinBr)
    
Revision History

    3-12-97   ColinBr    Created
    
--*/

#ifndef __TOPLLIST_H
#define __TOPLLIST_H

//
// List routines
//

PLIST
ToplpListCreate(
    VOID
    );

VOID 
ToplpListFree(
    PLIST pList,
    BOOLEAN   fRecursive   // TRUE implies free the elements contained 
                           // in the list
    );

VOID
ToplpListFreeElem(
    PLIST_ELEMENT pElem
    );

VOID
ToplpListSetIter(
    PLIST     pList,
    PITERATOR pIterator
    );

PLIST_ELEMENT
ToplpListRemoveElem(
    PLIST         pList,
    PLIST_ELEMENT Elem
    );

VOID
ToplpListAddElem(
    PLIST         pList,
    PLIST_ELEMENT Elem
    );

DWORD
ToplpListNumberOfElements(
    PLIST         pList
    );

//
// Iterator object routines
//
PITERATOR
ToplpIterCreate(
    VOID
    );

VOID 
ToplpIterFree(
    PITERATOR pIterator
    );

PLIST_ELEMENT
ToplpIterGetObject(
    PITERATOR pIterator
    );

VOID
ToplpIterAdvance(
    PITERATOR pIterator
    );

#endif // __TOPLLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\toplmst.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplmst.c

Abstract:

    This file contains the definition for ToplGraphFindMST

    This implementation is based on Prim's algorithm presented in
    
    _Introduction To Algorithms_ by Cormen, Leiserson, Rivest 1993.
    
    Chapter 24.
    
    
Author:

    Colin Brace    (ColinBr)
    
Revision History

    12-5-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <search.h>
#include <stdio.h>

typedef unsigned long DWORD;


#include <w32topl.h>
#include <w32toplp.h>
#include <topllist.h>
#include <toplgrph.h>

#include <toplheap.h>


//
// These two functions help build a dynamically growing list
// of PEDGE's and are defined in toplring.c
//
extern void EdgeArrayInit(
    PEDGE **array,
    ULONG *count
    );

extern void EdgeArrayAdd(
    PEDGE **array,
    ULONG *count,
    PEDGE edge
    );

TOPL_COMPONENTS* 
ToplMST_Prim(
    PGRAPH  Graph,
    PVERTEX RootVertex
    );


TOPL_COMPONENTS*
InitComponents(VOID)
//
// Initialize a set of components. This set initially contains no components.
//
{
    TOPL_COMPONENTS *pComponents;
    pComponents = (TOPL_COMPONENTS*) ToplAlloc( sizeof(TOPL_COMPONENTS) );
    pComponents->numComponents = 0;
    pComponents->pComponent = NULL;
    return pComponents;
}

TOPL_COMPONENT*
AddNewComponent(
    TOPL_COMPONENTS *pComponents
    )
//
// Add a new component to the set of components and return a pointer to it.
//
{
    TOPL_COMPONENT *pComponent;
    DWORD newComponentID;

    ASSERT( pComponents );
    newComponentID = pComponents->numComponents;
    
    // Increase the size of the component array
    pComponents->numComponents++;
    if( pComponents->pComponent ) {
        pComponents->pComponent = (TOPL_COMPONENT*) ToplReAlloc(
            pComponents->pComponent,
            pComponents->numComponents * sizeof(TOPL_COMPONENT) );
    } else {
        pComponents->pComponent = (TOPL_COMPONENT*) ToplAlloc(
            pComponents->numComponents * sizeof(TOPL_COMPONENT) );
    }

    // Add a new empty component to the array
    pComponent = &(pComponents->pComponent[newComponentID]);
    pComponent->numVertices = 0;
    pComponent->vertexNames = NULL;

    return pComponent;
}

VOID
AddVertexToComponent(
    TOPL_COMPONENT* pComponent,
    PVERTEX u
    )
//
// Add vertex u to pComponent. It is not the PVERTEX pointer itself but
// rather u's "vertex name" that is stored in the component.
//
{
    DWORD newVtxID;

    ASSERT( pComponent );
    newVtxID = pComponent->numVertices;

    // Increase the size of the vertex array
    pComponent->numVertices++;
    if( pComponent->vertexNames ) {
        pComponent->vertexNames = (PVOID*) ToplReAlloc(
            pComponent->vertexNames,
            pComponent->numVertices * sizeof(PVOID) );
    } else {
        pComponent->vertexNames = (PVOID*) ToplAlloc(
            pComponent->numVertices * sizeof(PVOID) );
    }

    // Add the vertex name to the array
    pComponent->vertexNames[newVtxID] = u->VertexData.VertexName;
}

VOID
MoveInterestingComponentToFront(
    TOPL_COMPONENTS *pComponents,
    PVERTEX VertexOfInterest
    )
//
// Swaps the components in pComponents such that the component
// containing VertexOfInterest is the first component.
//
{
    TOPL_COMPONENT *pComponent, temp;
    DWORD i,j,ComponentOfInterest;
    PVOID VtxNameOfInterest;
    BOOLEAN foundIt=FALSE;

    ASSERT(VertexOfInterest);
    VtxNameOfInterest = VertexOfInterest->VertexData.VertexName;

    // Search for the component which contains 'VertexOfInterest'
    for( i=0; i<pComponents->numComponents; i++ ) {
        pComponent = &(pComponents->pComponent[i]);
        ASSERT( pComponent->numVertices>0 );
        ASSERT( NULL!=pComponent->vertexNames );
        for( j=0; j<pComponent->numVertices; j++ ) {
            if( pComponent->vertexNames[j]==VtxNameOfInterest ) {
                ComponentOfInterest = i;
                foundIt=TRUE;
                break;
            }
        }
        if(foundIt) break;
    }
    ASSERT(foundIt);

    // Swap component 0 and component ComponentOfInterest if necessary
    if(ComponentOfInterest>0) {
        temp = pComponents->pComponent[0];
        pComponents->pComponent[0] = pComponents->pComponent[ComponentOfInterest];
        pComponents->pComponent[ComponentOfInterest] = temp;
    }
}

TOPL_COMPONENTS*
ToplpGraphFindEdgesForMST(
    IN  PGRAPH  Graph,
    IN  PVERTEX RootVertex,
    IN  PVERTEX VertexOfInterest,
    OUT PEDGE**  pEdges,
    OUT ULONG*  cEdges
    )
/*++

Routine Description:

    This function finds the least cost tree of connecting
    the nodes in Graph.  It is assumed that graph contains some vertices
    and some edges already.
    
    In addition, this function will then return the edges that
    contain VertexOfInterest.
        

Parameters:

    Graph: a valid graph object
    
    RootVertex: an arbitrary vertex at which to start the tree
    
    VertexOfInterest: the vertex that returned edges should contain
    
    pEdges: an array of edges that contain VertexOfInterest in the determined 
            tree
            
    cEdge: the number of elements in pEdges            
                                                                                    
Returns:

    TRUE if all the nodes in Graph could be connected in a tree; FALSE otherwise

--*/
{
    TOPL_COMPONENTS *pComponents;
    BOOLEAN   fStatus;
    PITERATOR VertexIterator;
    PVERTEX   Vertex, Parent;
    ULONG     iEdge, cEdge;
    PEDGE     e;


    ASSERT( Graph );
    ASSERT( RootVertex );
    ASSERT( VertexOfInterest );
    ASSERT( pEdges );
    ASSERT( cEdges );

    EdgeArrayInit(pEdges, cEdges);


    //
    // Make the best effort at find a spanning tree
    //
    pComponents = ToplMST_Prim( Graph, RootVertex );
    ASSERT( NULL!=pComponents );
    MoveInterestingComponentToFront( pComponents, VertexOfInterest );

    //
    // Now determine if a spanning tree was really possible
    // and find which edges we need for VertexOfOfInterest
    //
    VertexIterator = ToplpIterCreate();
    for ( ToplpGraphSetVertexIter(Graph, VertexIterator);
            Vertex = (PVERTEX) ToplpIterGetObject(VertexIterator);
                ToplpIterAdvance(VertexIterator) ) {

        //
        //
        // Since we only want the edges that contain VertexOfInterest
        // we are only interested in vertices whose parent is VertexOfInterest
        // and VertexOfInterest itself.  
        //

        ASSERT( ToplpIsVertex( Vertex ) );

        Parent = ToplpVertexGetParent( Vertex );

        if ( Vertex == VertexOfInterest )
        {
            //
            // Get the edge from this vertex up to its parent
            //
            for ( iEdge = 0, cEdge = ToplpVertexNumberOfInEdges( Vertex ); 
                    iEdge < cEdge; 
                        iEdge++) {
    
                e = ToplpVertexGetInEdge( Vertex, iEdge );
    
                ASSERT( ToplpIsEdge( e ) );
                ASSERT( ToplpEdgeGetToVertex( e ) == Vertex );

                if ( ToplpEdgeGetFromVertex( e ) == Parent )
                {
                    EdgeArrayAdd(pEdges, cEdges, e);
                }

            }
        }

        if ( Parent == VertexOfInterest )
        {
            //
            // Get the edge's to sites that are children
            //
            for ( iEdge = 0, cEdge = ToplpVertexNumberOfInEdges( VertexOfInterest ); 
                    iEdge < cEdge; 
                        iEdge++) {
    
                e = ToplpVertexGetInEdge( VertexOfInterest, iEdge );
    
                ASSERT( ToplpIsEdge( e ) );
                ASSERT( ToplpEdgeGetToVertex( e ) == VertexOfInterest );

                if ( ToplpEdgeGetFromVertex( e ) == Vertex )
                {
                    EdgeArrayAdd( pEdges, cEdges, e );
                }
            }
        }
    }
    ToplpIterFree( VertexIterator );

    return pComponents;
}

DWORD
GetVertexKey(
    VOID *p
    )
{
    PVERTEX pv = (PVERTEX)p;

    ASSERT( pv );

    return ToplpVertexGetId( pv );
}

TOPL_COMPONENTS*
ToplMST_Prim( 
    IN PGRAPH  Graph,
    IN PVERTEX RootVertex
    )
{

    TOPL_HEAP_INFO Q;
    PITERATOR      VertexIterator;
    ULONG          cVertices;
    PVERTEX        Vertex;
    TOPL_COMPONENTS *pComponents;
    TOPL_COMPONENT *curComponent;

    ASSERT( Graph );
    ASSERT( RootVertex );

    //
    // Set up the priority queue
    //
    cVertices = ToplpGraphNumberOfVertices( Graph );

    ToplHeapCreate( &Q,
                    cVertices,
                    GetVertexKey );


    VertexIterator = ToplIterCreate();
    for ( ToplpGraphSetVertexIter(Graph, VertexIterator);
   