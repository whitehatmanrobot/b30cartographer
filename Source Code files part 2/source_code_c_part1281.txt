f(dntUnMangled),
                    NULL);
        if ( FAILED(result) ) {
            XDBG1("Error <%x>: failed to get good named dnt\n", result);
            goto CleanUp;
        }

        // is it a phantom?
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZGUID,
                    &UnMangledGuid,
                    sizeof(MangledGuid),
                    NULL);
        if ( SUCCEEDED(result)  && !fNullUuid(&UnMangledGuid)) {
            XDBG1("Error <%x>: non mangled name has guid\n", result);
            result = E_FAIL;
            goto CleanUp;
        }

        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZOBJ,
                    &bVal,
                    sizeof(bVal),
                    NULL);
        if ( FAILED(result)  || bVal) {
            // phantom's have the object byte set to 0.
            XDBG2("Error <%x>: non mangled name isn't a phantom (%d)\n",
                                                            result, bVal);
            result = E_FAIL;
            goto CleanUp;
        }


        // Cool, it is a phantom, we can fix it up.

        XDBG4("Ready to reparent\n\tfrom %S (%d)\n\tto %S (%d).\n",
                pDn, dntUnMangled, pMangledDn, MangledDnt);

        //
        // move non-mangled children to mangled parent
        //

        result = ReParentChildren(
                    DbState,
                    TableState,
                    MangledDnt,
                    dntUnMangled);
        if ( FAILED(result)) {
            XDBG1("Error <%x>: Failed to reparent object\n", result);
            goto CleanUp;
        }

        //
        // Mangle phantom (non-mangled, non-guided) object
        //

        result = DitSeekToDnt(
                        DbState,
                        TableState,
                        dntUnMangled);
        if ( FAILED(result) ) {
            XDBG1("Error: failed to seek to MangledDnt %d\n",
                                    MangledDnt );
            goto CleanUp;
        }

        // we must create the guid here since we assume above
        // that the non-mangled object doesn't have a guid.
        result = UuidCreate(&UnMangledGuid);
        if ( RPC_S_OK != result ) {
            XDBG1("Error <%x>: Failed to create Uuid\n", result);
            result = E_UNEXPECTED;
            goto CleanUp;
        }

        pBuffer = MangleRdn(
                    pRdn,
                    L"CNF",
                    UnMangledGuid);


        cbBuffer = wcslen(pBuffer);

    #if CNF_NC_DBG
        if ( !IsRdnMangled(pBuffer,cbBuffer,&UnMangledGuid) ) {
            // sanity
            XDBG2("Error: Failed to mangle dn %S. Mangle = %S\n",
                        pDn, pBuffer);
            result = E_UNEXPECTED;
            goto CleanUp;
        }
        else {
            XDBG1(" DBG: verified mangled rdn <<%S>>\n", pBuffer);
        }
    #endif

        result = DitSeekToDnt(
                        DbState,
                        TableState,
                        dntUnMangled);
        if ( FAILED(result) ) {
            XDBG2("Error <0x%X>: failed to seek to dntUnMangled %d\n",
                                    result, dntUnMangled );
            goto CleanUp;
        }

        //
        // Set column rdn (excluding terminating \0)
        //
        result = DitSetColumnByName(
                        DbState,
                        TableState,
                        SZRDNATT,
                        pBuffer,
                        cbBuffer*sizeof(WCHAR),
                        FALSE );
        if ( FAILED(result) ) {
            XDBG2("Error <0x%x>: Failed to mangle phantom %S\n",
                                result, pBuffer);
            goto CleanUp;
        }


        XDBG1("Successfully converted Mangled phantom <<%S>>\n", pBuffer);


        //
        // Retry unmangling the cnf object again for the last
        // time.
        //
        // first seek back again to our object
        result = DitSeekToDnt(
                        DbState,
                        TableState,
                        MangledDnt);
        if ( FAILED(result) ) {
            XDBG1("Error: failed to seek to MangledDnt %d\n",
                                    MangledDnt );
            goto CleanUp;
        }

        //
        // Set column rdn (excluding terminating \0)
        //
        result = DitSetColumnByName(
                        DbState,
                        TableState,
                        SZRDNATT,
                        pRdn,
                        cLen*sizeof(WCHAR),
                        FALSE );
        if ( SUCCEEDED(result) ) {
            //
            // Tell user we fixed his domain
            //
            XDBG1("Successfully recovered mangled Naming Context %S\n", pRdn);
        }
        else {
            XDBG2("Error <0x%x>: Failed to Unmangle conflicted name %S\n",
                                result, pRdn);
        }

CleanUp:;
    }
    __finally {

        if ( pBuffer ) {
            DitFree(pBuffer);
        }

        if ( fInTransaction ) {
            //
            // Jet transaction mgmt
            //
            if ( SUCCEEDED(result) ) {
                XDBG(" DBG: Commiting transaction\n");
                jErr = JetCommitTransaction(DbState->sessionId, 0);
                if ( jErr != JET_errSuccess ) {
                    //"Failed to commit transaction: %ws.\n"
                    RESOURCE_PRINT1(IDS_JETCOMMITTRANSACTION_ERR, GetJetErrString(jErr));
                    if ( SUCCEEDED(result) ) {
                        result = E_UNEXPECTED;
                    }
                }
            }
            else {
                // failed fixup-- rollback
                XDBG1(" DBG: Rolling back transaction due to error %x.\n", result);
                jErr = JetRollback(DbState->sessionId, JET_bitRollbackAll);
                if ( jErr != JET_errSuccess ) {
                    //"Failed to rollback transaction: %ws.\n"
                    RESOURCE_PRINT1(IDS_JETROLLBACK_ERR, GetJetErrString(jErr));
                    if ( SUCCEEDED(result) ) {
                        result = E_UNEXPECTED;
                    }
                }
            }
        }

    }   // finally

    return result;
}

HRESULT
ReParent(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD dntKid,
    IN DWORD dntNew,
    IN DWORD dntOld
    )
/*++

Routine Description:

    Reparent a single kid from old parent to
    new parent. Reparenting consiste of:
      - Change kid's pdnt
      - Change kid's ancestors list
      - Decrement old parent's refcount
      - Increment new parent's refcount


Arguments:
    IN *DbState, -- opened database
    IN *TableState -- opened table
    IN dntKid --  current child to reparent
    IN dntNew -- new parent dnt
    IN dntOld -- old parent dnt

Return Value:

    Success: S_OK
    Error: HRESULT space

Remarks:
    This is called w/in inside a jet transaction.


--*/
{
    HRESULT result = S_OK;
    BOOL fStatus;
    DWORD pdnt;
    DWORD dwRefCount;
    DWORD dwActual, dwActual2;
    DWORD *pAnc = NULL;
    DWORD cAnc = 0;
    DWORD i;

    XDBG3(" > Reparenting kid %d from %d to %d\n",
                dntKid, dntOld, dntNew);

    result = DitSeekToDnt(
                DbState,
                TableState,
                dntKid);
    if ( FAILED(result) ) {
        XDBG2("Error <%x>: can't seek to %d\n", result, dntKid);
        goto CleanUp;
    }

    XDBG1(" DBG: Getting pdnt of %d\n", dntKid);

    // extra precaution. get pdnt & compare w/ expected
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZPDNT,
                &pdnt,
                sizeof(pdnt),
                NULL);
    if ( FAILED(result) ) {
        XDBG1("Error <%x>: failed to get partitions SZPDNT\n", result);
        goto CleanUp;
    }
    else if ( pdnt != dntOld ) {
        XDBG2("Error: expected old parent %d but found %d\n",
                        dntOld, pdnt);
        result = E_UNEXPECTED;
        goto CleanUp;
    }

    XDBG2(" DBG: Setting pdnt of %d to %d\n", dntKid, dntNew);
    XDBG1(" DBG: current pdnt is %d\n", pdnt);
    //
    // Set pdnt
    //
    result = DitSetColumnByName(
                DbState,
                TableState,
                SZPDNT,
                &dntNew,
                sizeof(dntNew),
                FALSE );
    if ( FAILED(result) ) {
        XDBG1("Error <%x>: failed to set new parent col SZPDNT \n", result);
        goto CleanUp;
    }


    XDBG1(" DBG: Getting Ancestors of %d (size)\n", dntKid);
    // Replace ancestors:
    //  1. get ancestors of new parent
    //  2. allocate room for ancestor list + the to-be-child
    //     (we're reparenting now).
    //  3. read in new parent ancestor list
    //  4. concat current child dnt
    //  5. write to child
    //

    result = DitSeekToDnt(
                DbState,
                TableState,
                dntNew);
    if ( FAILED(result) ) {
        XDBG2("Error <%x>: can't seek to %d\n", result, dntNew);
        goto CleanUp;
    }

    // get size of ancestors blob
    dwActual = 0;
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZANCESTORS,
                &pAnc,
                0,
                &dwActual);
    if ( S_FALSE != result ) {
        XDBG1("Error <%x>: failed to get ancestors size\n", result);
        goto CleanUp;
    }

    XDBG1(" DBG: Allocating %d bytes for ancestor list\n", dwActual+sizeof(DWORD));

    // allocate for one more dnt
    result = DitAlloc(&pAnc, dwActual+sizeof(DWORD));
    if (FAILED(result)) {
        XDBG("Error: not enough memory in ReParent\n");
        goto CleanUp;
    }
    ZeroMemory(pAnc, dwActual+sizeof(DWORD));

    XDBG1(" DBG: Getting Ancestors\n", dwActual);
    // get ancestors
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZANCESTORS,
                &pAnc[0],
                dwActual,
                NULL);
    if ( FAILED(result) ) {
        XDBG1("Error <%x>: failed to get ancestors \n", result);
        goto CleanUp;
    }

    cAnc = dwActual/sizeof(DWORD);
    // concat dntKid to ancestor list & then write
    pAnc[cAnc] = dntKid;
    // now we can increment the dwActual for the write
    dwActual += sizeof(DWORD);
    XDBG(" DBG: Setting Ancestor list\n");

    //
    // seek to new kid & set Ancestors
    //
    result = DitSeekToDnt(
                DbState,
                TableState,
                dntKid);
    if ( FAILED(result) ) {
        XDBG2("Error <%x>: can't seek to %d\n", result, dntKid);
        goto CleanUp;
    }

    result = DitSetColumnByName(
                DbState,
                TableState,
                SZANCESTORS,
                pAnc,
                dwActual,
                FALSE );
    if ( FAILED(result) ) {
        XDBG1("Error <%x>: failed to set new ancestor list\n", result);
        goto CleanUp;
    }


#if CNF_NC_DBG
    XDBG(" DBG: Verifying Proper set of Ancestors\n");
    // get ancestors
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZANCESTORS,
                &pAnc[0],
                dwActual,
                NULL);
    if ( FAILED(result) ) {
        XDBG1("Error <%x>: failed to get ancestors \n", result);
        goto CleanUp;
    }

    cAnc = dwActual/sizeof(DWORD);
    //
    // Replace old parent w/ new parent
    //
    XDBG1("Ancestors list (%d):\n", cAnc);
    fStatus = FALSE;
    for (i=0; i<cAnc; i++) {
        XDBG2(" %d> %d\n", i, pAnc[i]);
    }
    XDBG("---\n");
#endif

    //
    // Fix ref of old parent (--)
    //

    XDBG(" DBG: Seeking to old parent\n");
    result = DitSeekToDnt(
                DbState,
                TableState,
                dntOld);
    if ( FAILED(result) ) {
        XDBG2("Error <%x>: can't seek to old folk %d\n", result, dntOld);
        goto CleanUp;
    }

    XDBG(" DBG: Getting old parent refCount\n");
    dwRefCount = 0;
    // get old ref count
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZCNT,
                &dwRefCount,
                sizeof(dwRefCount),
                NULL);
    if ( FAILED(result) ) {
        XDBG1("Error <%x>: failed to get old folk refcount\n", result);
        goto CleanUp;
    }

    XDBG2(" DBG: Old parent (%d) refCount = %d\n",
                    dntOld, dwRefCount);

    // decrement due to move
    dwRefCount--;

    XDBG1(" DBG: Setting old parent refCount to %d\n", dwRefCount);
    //
    // Set refcount
    //
    result = DitSetColumnByName(
                DbState,
                TableState,
                SZCNT,
                &dwRefCount,
                sizeof(dwRefCount),
                FALSE );
    if ( FAILED(result) ) {
        XDBG1("Error <%x>: failed to set old parent refCount \n", result);
        goto CleanUp;
    }


    //
    // Fix ref of new parent (++)
    //

    XDBG(" DBG: Seeking to new parent\n");
    result = DitSeekToDnt(
                DbState,
                TableState,
                dntNew);
    if ( FAILED(result) ) {
        XDBG2("Error <%x>: can't seek to new folk %d\n", result, dntNew);
        goto CleanUp;
    }

    XDBG(" DBG: Getting new parent refCount\n");
    dwRefCount = 0;
    // get old ref count
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZCNT,
                &dwRefCount,
                sizeof(dwRefCount),
                NULL);
    if ( FAILED(result) ) {
        XDBG1("Error <%x>: failed to get new folk refcount\n", result);
        goto CleanUp;
    }

    XDBG2(" DBG: New parent (%d) refCount = %d\n",
                    dntNew, dwRefCount);

    // Increment due to move
    dwRefCount++;

    XDBG1(" DBG: Setting new parent refCount to %d\n", dwRefCount);
    //
    // Set refcount
    //
    result = DitSetColumnByName(
                DbState,
                TableState,
                SZCNT,
                &dwRefCount,
                sizeof(dwRefCount),
                FALSE );
    if ( FAILED(result) ) {
        XDBG1("Error <%x>: failed to set new parent refCount \n", result);
        goto CleanUp;
    }


    goto CleanUp;

CleanUp:

    if ( pAnc ) {
        DitFree(pAnc);
    }
    return result;
}


HRESULT
ReParentChildren(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD dntNew,
    IN DWORD dntOld
    )
/*++

Routine Description:

    Traverse all children of object given by dntOld & move them
    over to be children of dntNew

Arguments:

    DbState -- opened database
    TableState -- opened tabel
    dntNew -- new parent dnt
    dntOld -- current parent dnt

Return Value:

    HRESULT error space

Remark:
    This isn't very efficient implementation (see code). If you end up
    re-using this heavily, you should do some optimization work below such
    as single index walk rather then twice.

--*/
{

    HRESULT result = S_OK;
    DWORD *pKidDnts = NULL;
    DWORD dnt, pdnt;
    DWORD cDnts, cbDnts;
    DWORD i, j;
    JET_ERR jErr;

    //
    // traverse pdnt index to cycle through all partition kids.
    //

    result = DitSetIndex(DbState, TableState, SZPDNTINDEX, FALSE);
    if ( FAILED(result) ) {
        goto CleanUp;
    }

    result = DitSeekToFirstChild(DbState, TableState, dntOld);
    if ( FAILED(result) ) {
        goto CleanUp;
    }


    //
    // Count kids
    //


    pdnt = dnt = dntOld;
    cDnts = 0;
    while ( pdnt == dntOld ) {

        // get kid dnt
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZDNT,
                    &dnt,
                    sizeof(dnt),
                    NULL);
        if ( FAILED(result) ) {
            XDBG1("Error <%x>: failed to get obj dnt\n", result);
            goto CleanUp;
        }


        // get parent dnt
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZPDNT,
                    &pdnt,
                    sizeof(pdnt),
                    NULL);
        if ( FAILED(result) ) {
            XDBG1("Error <%x>: failed to get parent SZPDNT\n", result);
            goto CleanUp;
        }

        if ( pdnt == dntOld ) {
            // proceed until we got a diff parent
            cDnts++;
        }
        else{
            XDBG1(" DBG: Found %d kids\n", cDnts);
            break;
        }

        // find next one
        jErr = JetMove(
                    DbState->sessionId,
                    TableState->tableId,
                    JET_MoveNext,
                    0);
    }

    //
    // Populate dnt array
    //
    cbDnts = sizeof(DWORD)*cDnts;
    result = DitAlloc(&pKidDnts, cbDnts);
    if ( FAILED(result) ) {
        goto CleanUp;
    }

    result = DitSeekToFirstChild(DbState, TableState, dntOld);
    if ( FAILED(result) ) {
        goto CleanUp;
    }

    pdnt = dnt = 0;
    i = 0;
    for ( i=0; i<cDnts; i++ ) {

        // get dnt for consistency & loop termination
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZDNT,
                    &dnt,
                    sizeof(dnt),
                    NULL);
        if ( FAILED(result) ) {
            XDBG1("Error <%x>: failed to get partitions DNT \n", result);
            goto CleanUp;
        }


        // get parent dnt
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZPDNT,
                    &pdnt,
                    sizeof(pdnt),
                    NULL);
        if ( FAILED(result) ) {
            XDBG1("Error <%x>: failed to get partitions SZPDNT\n", result);
            goto CleanUp;
        }

        pKidDnts[i] = dnt;

        // find next one
        jErr = JetMove(
                    DbState->sessionId,
                    TableState->tableId,
                    JET_MoveNext,
                    0);
    }

    //
    // We got the array of kids.
    // Resent index to main & reparent each.
    //

    result = DitSetIndex(DbState, TableState, SZDNTINDEX, FALSE);
    if ( FAILED(result) ) {
        goto CleanUp;
    }

    for ( i=0; i<cDnts; i++) {
        result = ReParent(
                    DbState,
                    TableState,
                    pKidDnts[i],
                    dntNew,
                    dntOld);
        if ( FAILED(result) ) {
            XDBG2("Error<0x%x>: Failed ot reparent dnt %d\n",
                            result, pKidDnts[i]);
            goto CleanUp;
        }
    }

    goto CleanUp;

CleanUp:

    if ( pKidDnts ) {
        DitFree(pKidDnts);
    }
    return result;
}

HRESULT
UnmangleDn(
    IN  OUT LPWSTR pDn
    )
/*++

Routine Description:

    Takes a mangled name & unmangle it inplace

Arguments:

    pDn -- name to unmangle

Return Value:

    error in HRESULT error space

--*/
{
    LPWSTR pNxtRdn, pBadChar;
    DWORD len;

    // seek to bad char
    pBadChar = wcsrchr(pDn, BAD_NAME_CHAR);
    if ( !pBadChar ) {
        XDBG1(" DBG: Logic Error: Failed to find bad char in %S\n",
                                pDn );
        return E_UNEXPECTED;
    }
    // seek to next rdn
    pNxtRdn = wcschr(pBadChar, L',');
    if ( !pNxtRdn ) {
        XDBG1(" DBG: Logic Error: Failed to find comma in %S\n", pBadChar );
        return E_UNEXPECTED;
    }
    // move to skip mangle
    len = wcslen(pNxtRdn);
    MoveMemory(pBadChar, pNxtRdn, len*sizeof(WCHAR) );
    // add term char. note that we should be safe here
    // w/ a valid cnf name since original name was
    // larget by at least the mangle string (guid etc)
    pBadChar[len] = '\0';
    XDBG1(" DBG: Unmangled DN = %S\n", pDn);

    return S_OK;
}

LPWSTR
MangleRdn(
    IN  LPWSTR  pRdn,
    IN  LPWSTR  szTag,
    IN  GUID    guid
    )
/*++

Routine Description:

    Allocates & Creates a mangled RDN of the form

Arguments:

    pRdn -- rdn to mangle
    szTag -- tag to mangle with (typically "DEL" or "CNF")
    guid -- guid to add to mangle

Return Value:

    success: newly allocated mangled name
    failure: NULL

Remarks:
    Allocates memory. Need to free().

--*/
{

    DWORD cbBuffer;
    LPWSTR pBuffer = NULL;
    LPWSTR pszGuid = NULL;
    RPC_STATUS rpcErr;
    HRESULT result = S_OK;

    // convert guid to string form
    rpcErr = UuidToStringW(&guid, &pszGuid);
    if (RPC_S_OK != rpcErr ) {
        XDBG("Error: Failed to convert UuidToString\n");
        return NULL;
    }

    // buffer len = strings + bad char + ':' + '\0'
    cbBuffer = sizeof(WCHAR) * (wcslen(pRdn) + wcslen(szTag) + wcslen(pszGuid) + 3);

    // alloc string
    result = DitAlloc(&pBuffer, cbBuffer);
    if (FAILED(result)) {
        XDBG("Error: failed to allocate memory in MangleRdn\n");
        pBuffer = NULL;
        goto CleanUp;
    }

    // format mangled string
    wsprintfW(pBuffer, L"%s%c%s:%s",
                        pRdn, BAD_NAME_CHAR, szTag, pszGuid);

CleanUp:

    if (pszGuid) {
        RpcStringFreeW(&pszGuid);
    }

    return pBuffer;
}

VOID
SFixupCnfNc(
    VOID
    )
/*++

Routine Description:


    This routine walks the partitions container seeking conflicted
    NC names pointed by crossrefs via the nCName property.
    For each conflict, it will attempt to fix it by calling
    FixMangledNC.
    Phases:
    a) get to the configuration container, then the partitions one
    b) get all cross-ref's nCName (NC's w/ potentional conflict)
    c) Call FixMangledNC for each NC.

Remark:
    This isn't very efficient implementation (see code). If you end up
    re-using this heavily, you should do some optimization work below such
    as single index walk rather then twice.


--*/
{

    // return
    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jErr;
    BOOL  fStatus;

    // database & jet
    DB_STATE *dbState = NULL;
    TABLE_STATE *tableState = NULL;
    TABLE_STATE *linkTableState = NULL;
    // various local helpers
    DWORD dnt, pdnt = 0, dntPartitions = 0;
    LPWSTR pBuffer = NULL;
    DWORD  cbBuffer = 0;
    GUID  guid;
    struct _PARTITION_DATA {
        DWORD   dntCR;
        DWORD   dntNC;
    } *pPartitions = NULL;
    INT iPartitions, i, j;
    WCHAR szRDN[MAX_RDN_SIZE];
    INT cch;


    //
    // Open database/tables
    //

    RESOURCE_PRINT (IDS_AR_OPEN_DB_DIT);

    __try{

        result = DitOpenDatabase(&dbState);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        //"done.\n"
        RESOURCE_PRINT (IDS_DONE);


        result = DitOpenTable(dbState, SZDATATABLE, SZDNTINDEX, &tableState);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        // SZLINKALLINDEX includes both present and absent link values
        result = DitOpenTable(dbState, SZLINKTABLE, SZLINKALLINDEX, &linkTableState);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }



        result = FindPartitions(
                    dbState,
                    tableState,
                    linkTableState,
                    &dntPartitions);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }


        //
        // traverse pdnt index to cycle through all partition kids.
        //

        result = DitSetIndex(dbState, tableState, SZPDNTINDEX, FALSE);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        result = DitSeekToFirstChild(dbState, tableState, dntPartitions);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }


        //
        // Count kids
        //


        pdnt = dntPartitions;
        dnt = dntPartitions;
        iPartitions = 0;
        while ( pdnt == dntPartitions ) {

            // get kid dnt
            result = DitGetColumnByName(
                        dbState,
                        tableState,
                        SZDNT,
                        &dnt,
                        sizeof(dnt),
                        NULL);
            if ( FAILED(result) ) {
                XDBG1("Error <%x>: failed to get partitions DNT \n", result);
                returnValue = result;
                goto CleanUp;
            }


            // get parent dnt
            result = DitGetColumnByName(
                        dbState,
                        tableState,
                        SZPDNT,
                        &pdnt,
                        sizeof(pdnt),
                        NULL);
            if ( FAILED(result) ) {
                XDBG1("Error <%x>: failed to get partitions SZPDNT\n", result);
                returnValue = result;
                goto CleanUp;
            }

            if ( pdnt == dntPartitions ) {
                // proceed until we got a diff parent
                iPartitions++;
            }
            else{
                XDBG1(" DBG: Found %d partitions\n", iPartitions);
                break;
            }

            // find next one
            jErr = JetMove(
                        dbState->sessionId,
                        tableState->tableId,
                        JET_MoveNext,
                        0);
        }

        //
        // Populate dnt index
        //
        cbBuffer = sizeof(struct _PARTITION_DATA)*iPartitions;
        result = DitAlloc(&pPartitions, cbBuffer);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        result = DitSeekToFirstChild(dbState, tableState, dntPartitions);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        pdnt = dnt = 0;
        i = 0;
        for ( i=0; i<iPartitions; i++ ) {

            // get dnt for consistency & loop termination
            result = DitGetColumnByName(
                        dbState,
                        tableState,
                        SZDNT,
                        &dnt,
                        sizeof(dnt),
                        NULL);
            if ( FAILED(result) ) {
                XDBG1("Error <%x>: failed to get partitions DNT \n", result);
                returnValue = result;
                goto CleanUp;
            }


            // get link base for sanity (not realy used).
            result = DitGetColumnByName(
                        dbState,
                        tableState,
                        SZPDNT,
                        &pdnt,
                        sizeof(pdnt),
                        NULL);
            if ( FAILED(result) ) {
                XDBG1("Error <%x>: failed to get partitions SZPDNT\n", result);
                returnValue = result;
                goto CleanUp;
            }

            if ( pdnt == dntPartitions ) {
                XDBG2(" DBG: dnt = %d; pdnt = %d\n", dnt, pdnt);
                pPartitions[i].dntCR = dnt;
            }
            else{
                XDBG3(" DBG: end of partition kids (dnt%d;pdnt=%d)\n",
                                result, dnt, pdnt);
                break;
            }

            // find next one
            jErr = JetMove(
                        dbState->sessionId,
                        tableState->tableId,
                        JET_MoveNext,
                        0);
        }


        result = DitSetIndex(dbState, tableState, SZDNTINDEX, FALSE);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

    #if CNF_NC_DBG
        // read in dn
        XDBG(" DBG: Partition DNT list:\n");
        for (i = 0; i < iPartitions; i ++) {
            pBuffer = GetDN(dbState, tableState, pPartitions[i].dntCR, TRUE);
            if ( pBuffer ) {
                DitFree(pBuffer); pBuffer = NULL;
            }
        }
    #endif


        //
        // We've got the partition dnt list.
        //  - for each partition, get to the NC dnt
        //

        XDBG("Scanning NCs:\n");

        for ( i = 0; i < iPartitions; i++ ) {

            result = DitSeekToDnt(
                            dbState,
                            tableState,
                            pPartitions[i].dntCR);
            if ( FAILED(result) ) {
                returnValue = result;
                goto CleanUp;
            }


            result = DitGetColumnByName(
                        dbState,
                        tableState,
                        SZNCNAME,
                        &dnt,
                        sizeof(dnt),
                        NULL);
            if ( FAILED(result) ) {
                XDBG1("Error <%x>: failed to get NCNAME\n", result);
                returnValue = result;
                goto CleanUp;
            }


            // verify it's there & accessible (sanity)
            result = DitSeekToDnt(
                            dbState,
                            tableState,
                            dnt);
            if ( FAILED(result) ) {
                XDBG1("Skipping %d\n", dnt);
                continue;
            }

    #if CNF_NC_DBG
            pBuffer = GetDN(dbState, tableState, dnt, TRUE);
            if ( pBuffer ) {
                DitFree(pBuffer); pBuffer = NULL;
            }
    #endif

            pPartitions[i].dntNC = dnt;

        }



        //
        // Finally do the work:
        //  - for each NC:
        //      - read name
        //      - see if name is mangled
        //      - modify/fix it if needed
        //      - rm old name
        //
        //

        XDBG("Scanning for conflicts:\n");
        for (i=0; i<iPartitions; i++) {
            if (pPartitions[i].dntNC != 0) {
                // we have this NC
                //  - read & eval fix

                result = DitSeekToDnt(
                                dbState,
                                tableState,
                                pPartitions[i].dntNC);
                if ( FAILED(result) ) {
                    XDBG1("Error: failed to seek to nc dnt %d\n",
                                            pPartitions[i].dntNC );
                    returnValue = result;
                    goto CleanUp;
                }


                result = DitGetColumnByName(
                            dbState,
                            tableState,
                            SZRDNATT,
                            &szRDN,
                            sizeof(szRDN),
                            &cbBuffer);
                if ( FAILED(result) ) {
                    fprintf(stderr, "Error <%x>: failed to get RDN\n", result);
                    returnValue = result;
                    goto CleanUp;
                }

                cch = cbBuffer/2;
                ASSERT(cch < MAX_RDN_SIZE);
                szRDN[cch] = '\0';
                fStatus = IsRdnMangled(szRDN,cbBuffer/sizeof(WCHAR),&guid);

                if ( fStatus ) {
                    XDBG1(" DBG: Got Mangled rdn \t<<%S>>\n", szRDN);

                    //
                    // Fix mangled rdn
                    //
                    result = FixMangledNC(
                                    dbState,
                                    tableState,
                                    pPartitions[i].dntNC,
                                    szRDN );
                    if ( FAILED(result) ) {
                        XDBG(" [DBG] Can't fix Mangled NC\n");
                        // remember failure but proceed
                        returnValue = result;
                        // continue trying other names.
                        continue;
                    }   // Fix failed
                }       // name is mangled
            }           // non-zero partition dnt
        }               // cycle partitions


CleanUp:;

    } __finally {


        if ( SUCCEEDED(returnValue) ) {
            RESOURCE_PRINT(IDS_DONE);
        } else {
            RESOURCE_PRINT(IDS_FAILED);
        }

        if ( pBuffer ) {
            DitFree(pBuffer);
        }

        if ( pPartitions ) {
            DitFree(pPartitions);
        }

        if ( tableState != NULL ) {
            result = DitCloseTable(dbState, &tableState);
            if ( FAILED(result) ) {
                if ( SUCCEEDED(returnValue) ) {
                    returnValue = result;
                }
            }
        }

        if ( tableState != NULL ) {
            result = DitCloseTable(dbState, &linkTableState);
            if ( FAILED(result) ) {
                if ( SUCCEEDED(returnValue) ) {
                    returnValue = result;
                }
            }
        }


        if ( dbState != NULL ) {
            result = DitCloseDatabase(&dbState);
            if ( FAILED(result) ) {
                if ( SUCCEEDED(returnValue) ) {
                    returnValue = result;
                }
            }
        }

    }

//    return returnValue;
} // SFixupCnfNc


HRESULT
FindPartitions(
    IN  DB_STATE *dbState,
    IN  TABLE_STATE *tableState,
    IN  TABLE_STATE *linkTableState,
    OUT PDWORD  pDnt
    )
/*++

Routine Description:

    Retrieves the dnt of the partitions container

Arguments:

    dbState -- opened table
    tableState -- opened table
    pDnt -- a pointer to accept found partitions container



Return Value:

    error in HRESULT space

--*/
{
    HRESULT result = S_OK;
    JET_ERR jErr;

    DWORD dnt, dntDsa, dntBackLink, dntConfig = 0;
    LPWSTR pBuffer = NULL;
    DWORD  cbBuffer = 0;
    LPWSTR pDn = NULL;
    JET_COLUMNDEF coldef;

    // from mkdit.ini has-master-ncs Link-ID=76
    const DWORD hasMasterLinkId = 76;
    const DWORD hasMasterLinkBase = MakeLinkBase(hasMasterLinkId);


    //
    // Get backlinks in has-master-ncs
    //

    XDBG(" >Getting DsaDnt. .");
    result = DitGetDsaDnt(dbState, &dntDsa);
    if ( FAILED(result) ) {
        goto CleanUp;
    }

    XDBG1(" . %lu\n", dntDsa);



#if CNF_NC_DBG

    // debug:
    // Seek to DSA & print DN
    pBuffer = GetDN(dbState, tableState, dntDsa, TRUE);
    if(pBuffer){
        DitFree(pBuffer); pBuffer = NULL;
    }
#endif

    XDBG2("Seeking to link %d base %d\n",
                dntDsa, hasMasterLinkBase);

    result = DitSetIndex(
                dbState,
                linkTableState,
                SZLINKALLINDEX,
                TRUE);
    if ( FAILED(result) ) {
        XDBG1("Error <0x%x>: failed to set index \n", result);
        goto CleanUp;
    }


    result = DitSeekToLink(
                dbState,
                linkTableState,
                dntDsa,
                hasMasterLinkBase);

    if (FAILED(result)) {
        XDBG1("Error <0x%x>: failed to seek link\n", result);
        goto CleanUp;
    }


    //
    // Look for configuration container
    //



    jErr = JET_errSuccess;

    dnt = dntDsa;

    while ( jErr == JET_errSuccess &&
            dnt == dntDsa ) {

        // get dnt for consistency & loop termination
        result = DitGetColumnByName(
                    dbState,
                    linkTableState,
                    SZLINKDNT,
                    &dnt,
                    sizeof(dnt),
                    NULL);
        if ( FAILED(result) ) {
            XDBG1("Error <%x>: failed to get configuration (link)\n", result);
            goto CleanUp;
        }

        // get back link dnt -- this is what we want.
        result = DitGetColumnByName(
                    dbState,
                    linkTableState,
                    SZBACKLINKDNT,
                    &dntBackLink,
                    sizeof(dntBackLink),
                    NULL);
        if ( FAILED(result) ) {
            XDBG1("Error <%x>: failed to get configuration (back link)\n", result);
            goto CleanUp;
        }

        // read in dn
        pBuffer = GetDN(dbState, tableState, dntBackLink, FALSE);

        if ( pBuffer ) {
            // is it our config?
            if ( 0 == _wcsnicmp(SZCONFIG_W, pBuffer, wcslen(SZCONFIG_W)) ) {
                // got it.
               XDBG1("Got Config: %S\n", pBuffer);
               dntConfig = dntBackLink;
               break;
            }
            else {
                DitFree(pBuffer); pBuffer = NULL;
            }
        }
        else {
            XDBG1("Error: found an empty DN with DNT %d\n", dntBackLink);
        }

        // find next one
        jErr = JetMove(
                    dbState->sessionId,
                    linkTableState->tableId,
                    JET_MoveNext,
                    0);
    }



    if ( !pBuffer ) {
        XDBG("Inconsistency Error: failed to find Configuration NC.\n");
        result = E_UNEXPECTED;
        goto CleanUp;
    }

    cbBuffer = wcslen(pBuffer) +
               wcslen(SZPARTITIONS_W) +
               + 2;     // room for ',' & '\0'
    cbBuffer *= 2;

    result = DitAlloc(&pDn, cbBuffer);
    if ( FAILED(result) ) {
        XDBG("Error: memory allocation failed for partitions\n");
        goto CleanUp;
    }

    wsprintfW(pDn, L"%s,%s", SZPARTITIONS_W, pBuffer);
    DitFree(pBuffer); pBuffer = NULL;

    XDBG1("Partitions = %S\n", pDn);


    //
    // Get Partitions
    //

    result = DitSeekToDn(
                dbState,
                tableState,
                pDn);
    if ( FAILED(result) ) {
        XDBG1("Error <%x>: failed to get partitions\n", result);
        goto CleanUp;
    }
    DitFree(pDn); pDn = NULL;


    result = DitGetColumnByName(
                dbState,
                tableState,
                SZDNT,
                pDnt,
                sizeof(DWORD),
                NULL);
    if ( FAILED(result) ) {
        XDBG1("Error <%x>: failed to get partitions dnt\n", result);
        goto CleanUp;
    }

    XDBG1("Got partitions dnt %d\n", *pDnt);

CleanUp:

    if ( pBuffer ) {
        DitFree(pBuffer);
    }

    if ( pDn ) {
        DitFree(pDn);
    }

    return result;
}






VOID SetJetParameters (JET_INSTANCE *JetInst)
{
    // DaveStr - 5/21/99 - This routine used to cache knowledge of whether
    // Jet parameters had ever been set and be a no-op if they had under the
    // assumption that setting Jet parameters is expensive.  However, this
    // causes confusion after a DB move, so caching is permanently disabled.

    DBSetRequiredDatabaseSystemParameters (JetInst);
}


DWORD OpenJet(
    IN const char * pszFileName
    )
/*
    Opens Jet Database.
    If supplied filename is Null, then uses default filename.

    returns S_OK on success, S_FALSE on error.
*/

{
    JET_ERR err;

    RESOURCE_PRINT1 (IDS_JET_OPEN_DATABASE, "[Current]");

    SetJetParameters (&jetInstance);

    //
    // Do JetInit, BeginSession, Attach/OpenDatabase
    //

    err = DBInitializeJetDatabase(&jetInstance, &sesid, &dbid, pszFileName, FALSE);
    if (err != JET_errSuccess) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "DBInitializeJetDatabase", GetJetErrString(err));
        return S_FALSE;
    }

    return S_OK;
}

DWORD
OpenTable (
    IN BOOL fWritable,
    IN BOOL fCountRecords
    )
{
    JET_ERR err;


    fprintf(stderr,".");
    if (err = JetOpenTable(sesid,
                           dbid,
                           SZDATATABLE,
                           NULL,
                           0,
                           (fWritable?
                            (JET_bitTableUpdatable | JET_bitTableDenyRead):
                            JET_bitTableReadOnly),
                           &tblid)) {
        tblid = -1;
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetOpenTable",
                SZDATATABLE, GetJetErrString(err));
        return 0;
    }

    fprintf(stderr,".");
    if (err =  JetSetCurrentIndex(sesid, tblid, szIndex)) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetCurrentIndex",
                szIndex, GetJetErrString(err));
        return 0;
    }

    //
    // link table
    //

    fprintf(stderr,".");
    if (err = JetOpenTable(sesid,
                           dbid,
                           SZLINKTABLE,
                           NULL,
                           0,
                           (fWritable?
                            (JET_bitTableUpdatable | JET_bitTableDenyRead):
                            JET_bitTableReadOnly),
                           &linktblid)) {
        linktblid = -1;
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetOpenTable",
                SZLINKTABLE, GetJetErrString(err));
        return 0;
    }

    fprintf(stderr,".");
    if (err =  JetSetCurrentIndex(sesid, linktblid, SZLINKINDEX)) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetCurrentIndex",
                SZLINKINDEX, GetJetErrString(err));
        return 0;
    }

    {
        JET_COLUMNDEF coldef;

        err = JetGetTableColumnInfo(sesid,
                                    linktblid,
                                    SZBACKLINKDNT,
                                    &coldef,
                                    sizeof(coldef),
                                    0);

        if ( err ) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetGetTableColumnInfo",
                    GetJetErrString(err));
            return 0;
        }

        blinkid = coldef.columnid;
    }


    RESOURCE_PRINT (IDS_DONE);
    if ( !fCountRecords ) {
        return -1;
    }

    RESOURCE_PRINT (IDS_SCHECK_GET_REC_COUNT1);

    if ( IndexCount == 0 ) {
        JetMove(sesid, tblid, JET_MoveFirst, 0);
        JetIndexRecordCount( sesid, tblid, &IndexCount, 0xFFFFFFFF );
    }
    //"%u records"
    RESOURCE_PRINT1 (IDS_SCHECK_GET_REC_COUNT2,IndexCount);

    return IndexCount;
} // OpenTables


VOID
CloseJet(
    VOID
    )
{
    JET_ERR err;

    //
    // Close all tables
    //

    if ( linktblid != JET_tableidNil ) {
        JetCloseTable(sesid,linktblid);
        linktblid = JET_tableidNil;
    }

    if ( tblid != JET_tableidNil ) {
        JetCloseTable(sesid,tblid);
        tblid = JET_tableidNil;
    }

    if (sesid != JET_sesidNil ) {
        if(dbid != JET_dbidNil) {
            // JET_bitDbForceClose not supported in Jet600.
            if ((err = JetCloseDatabase(sesid, dbid, 0)) != JET_errSuccess) {
                RESOURCE_PRINT2 (IDS_JET_GENERIC_WRN, "JetCloseDatabase", GetJetErrString(err));
            }
            dbid = JET_dbidNil;
        }

        if ((err = JetEndSession(sesid, JET_bitForceSessionClosed)) != JET_errSuccess) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_WRN, "JetEndSession", GetJetErrString(err));
        }
        sesid = JET_sesidNil;

        JetTerm(jetInstance);
        jetInstance = 0;
    }
} // CloseJet



BOOL
GetLogFileName2(
    IN PCHAR Name
    )
{
    DWORD i;
    WIN32_FIND_DATA w32Data;
    HANDLE hFile;
    DWORD err;

    //
    // ok, add a suffix
    //

    for (i=0;i<500000;i++) {

        sprintf(Name,"dsdit.dmp.%u",i);

        hFile = FindFirstFile(Name, &w32Data);
        if ( hFile == INVALID_HANDLE_VALUE ) {
            if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
                break;
            }
            //"*** Error: %d(%ws) Cannot open log file %hs\n"
            err = GetLastError();
            RESOURCE_PRINT3 (IDS_SCHECK_OPEN_LOG_ERR, err, GetW32Err(err), Name );
            return FALSE;
        } else {
            FindClose(hFile);
        }
    }

    return TRUE;

} // GetLogFileName2


VOID
CloseLogFile(
    VOID
    )
{
    if ( hsLogFile != INVALID_HANDLE_VALUE ) {
        CloseHandle(hsLogFile);
        hsLogFile = INVALID_HANDLE_VALUE;
    }
    return;
}


BOOL
OpenLogFile(
    VOID
    )
{
    BOOL ret = TRUE;
    CHAR LogFileName[1024];
    DWORD err;

    //
    // Get Name to open
    //

    if (!GetLogFileName2(LogFileName)) {
        ret = FALSE;
        goto exit;
    }

    hsLogFile = CreateFileA( LogFileName,
                            GENERIC_WRITE|GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

    if ( hsLogFile == INVALID_HANDLE_VALUE ) {
        //"*** Error: %d(%ws) Cannot open log file %hs\n"
        err = GetLastError();
        RESOURCE_PRINT3 (IDS_SCHECK_OPEN_LOG_ERR, err, GetW32Err(err), LogFileName );
        ret=FALSE;
        goto exit;
    }

    //"\nWriting summary into log file %s\n"
    RESOURCE_PRINT1 (IDS_SCHECK_WRITING_LOG, LogFileName);
exit:

    return ret;

} // OpenLogFile



BOOL
Log(
    IN BOOL     fLog,
    IN LPSTR    Format,
    ...
    )

{
    va_list arglist;

    if ( !fLog ) {
        return TRUE;
    }

    //
    // Simply change arguments to va_list form and call DsPrintRoutineV
    //

    va_start(arglist, Format);

    PrintRoutineV( Format, arglist );

    va_end(arglist);

    return TRUE;
} // ScLog


VOID
PrintRoutineV(
    IN LPSTR Format,
    va_list arglist
    )
// Must be called with DsGlobalLogFileCritSect locked

{
    static LPSTR logFileOutputBuffer = NULL;
    ULONG length;
    DWORD BytesWritten;
    static BeginningOfLine = TRUE;
    static LineCount = 0;
    static TruncateLogFileInProgress = FALSE;
    static LogProblemWarned = FALSE;

    //
    // Allocate a buffer to build the line in.
    //  If there isn't already one.
    //

    length = 0;

    if ( logFileOutputBuffer == NULL ) {
        logFileOutputBuffer = LocalAlloc( 0, MAX_PRINTF_LEN );

        if ( logFileOutputBuffer == NULL ) {
            return;
        }
    }

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // Never print empty lines.
        //

        if ( Format[0] == '\n' && Format[1] == '\0' ) {
            return;
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    length += (ULONG) vsprintf(&logFileOutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && logFileOutputBuffer[length-1] == '\n' );
    if ( BeginningOfLine ) {
        logFileOutputBuffer[length-1] = '\r';
        logFileOutputBuffer[length] = '\n';
        logFileOutputBuffer[length+1] = '\0';
        length++;
    }

    if ( hsLogFile == INVALID_HANDLE_VALUE ) {

        fprintf(stderr, "%s", logFileOutputBuffer);
        return;
    }

    //
    // Write the debug info to the log file.
    //

    if ( !WriteFile( hsLogFile,
                     logFileOutputBuffer,
                     length,
                     &BytesWritten,
                     NULL ) ) {

        if ( !LogProblemWarned ) {
            fprintf(stderr, "[DSLOGS] Cannot write to log file error %ld\n",
                             GetLastError() );
            LogProblemWarned = TRUE;
        }
    }

} // PrintRoutineV

static WCHAR jetdesc[MAX_JET_ERROR_LENGTH+1];

PWCHAR
GetJetErrString(
    IN JET_ERR JetError
    )
/*++

Routine Description:

    This function takes a JET_ERR and writes the description of it
    into a global variable which is returned.

Arguments:

    JetError - Supplies the Jet error code.

Return Value:

    None

--*/
{

    CONST WCHAR *description = NULL;


    switch ( JetError ) {

    case JET_errBackupInProgress:
        description = READ_STRING(IDS_JET_ERRBACKUPINPROGRESS);
        break;

    case JET_errBufferTooSmall:
        description = READ_STRING(IDS_JET_ERRBUFFERTOOSMALL);
        break;

    case JET_errColumnDoesNotFit:
        description = READ_STRING(IDS_JET_ERRCOLUMNDOESNOTFIT);
        break;

    case JET_errColumnIllegalNull:
        description = READ_STRING(IDS_JET_ERRCOLUMNILLEGALNULL);
        break;

    case JET_errColumnNotFound:
        description = READ_STRING(IDS_JET_ERRCOLUMNNOTFOUND);
        break;

    case JET_errColumnNotUpdatable:
        description = READ_STRING(IDS_JET_ERRCOLUMNNOTUPDATABLE);
        break;

    case JET_errColumnTooBig:
        description = READ_STRING(IDS_JET_ERRCOLUMNTOOBIG);
        break;

    case JET_errDatabaseInconsistent:
        description = READ_STRING(IDS_JET_ERRDATABASEINCONSISTENT);
        break;

    case JET_errDatabaseInUse:
        description = READ_STRING(IDS_JET_ERRDATABASEINUSE);
        break;

    case JET_errDatabaseNotFound:
        description = READ_STRING(IDS_JET_ERRDATABASENOTFOUND);
        break;

    case JET_errFileAccessDenied:
        description = READ_STRING(IDS_JET_ERRFILEACCESSDENIED);
        break;

    case JET_errFileNotFound:
        description = READ_STRING(IDS_JET_ERRFILENOTFOUND);
        break;

    case JET_errInvalidBufferSize:
        description = READ_STRING(IDS_JET_ERRINVALIDBUFFERSIZE);
        break;

    case JET_errInvalidDatabaseId:
        description = READ_STRING(IDS_JET_ERRINVALIDDATABASEID);
        break;

    case JET_errInvalidName:
        description = READ_STRING(IDS_JET_ERRINVALIDNAME);
        break;

    case JET_errInvalidParameter:
        description = READ_STRING(IDS_JET_ERRINVALIDPARAMETER);
        break;

    case JET_errInvalidSesid:
        description = READ_STRING(IDS_JET_ERRINVALIDSESID);
        break;

    case JET_errInvalidTableId:
        description = READ_STRING(IDS_JET_ERRINVALIDTABLEID);
        break;

    case JET_errKeyDuplicate:
        description = READ_STRING(IDS_JET_ERRKEYDUPLICATE);
        break;

    case JET_errKeyIsMade:
        description = READ_STRING(IDS_JET_ERRKEYISMADE);
        break;

    case JET_errKeyNotMade:
        description = READ_STRING(IDS_JET_ERRKEYNOTMADE);
        break;

    case JET_errNotInitialized:
        description = READ_STRING(IDS_JET_ERRNOTINITIALIZED);
        break;

    case JET_errNoCurrentIndex:
        description = READ_STRING(IDS_JET_ERRNOCURRENTINDEX);
        break;

    case JET_errNoCurrentRecord:
        description = READ_STRING(IDS_JET_ERRNOCURRENTRECORD);
        break;

    case JET_errNotInTransaction:
        description = READ_STRING(IDS_JET_ERRNOTINTRANSACTION);
        break;

    case JET_errNullKeyDisallowed:
        description = READ_STRING(IDS_JET_ERRNULLKEYDISALLOWED);
        break;

    case JET_errObjectNotFound:
        description = READ_STRING(IDS_JET_ERROBJECTNOTFOUND);
        break;

    case JET_errPermissionDenied:
        description = READ_STRING(IDS_JET_ERRPERMISSIONDENIED);
        break;

    case JET_errSuccess:
        description = READ_STRING(IDS_JET_ERRSUCCESS);
        break;

    case JET_errTableInUse:
        description = READ_STRING(IDS_JET_ERRTABLEINUSE);
        break;

    case JET_errTableLocked:
        description = READ_STRING(IDS_JET_ERRTABLELOCKED);
        break;

    case JET_errTooManyActiveUsers:
        description = READ_STRING(IDS_JET_ERRTOOMANYACTIVEUSERS);
        break;

    case JET_errTooManyOpenDatabases:
        description = READ_STRING(IDS_JET_ERRTOOMANYOPENDATABASES);
        break;

    case JET_errTooManyOpenTables:
        description = READ_STRING(IDS_JET_ERRTOOMANYOPENTABLES);
        break;

    case JET_errTransTooDeep:
        description = READ_STRING(IDS_JET_ERRTRANSTOODEEP);
        break;

    case JET_errUpdateNotPrepared:
        description = READ_STRING(IDS_JET_ERRUPDATENOTPREPARED);
        break;

    case JET_errWriteConflict:
        description = READ_STRING(IDS_JET_ERRWRITECONFLICT);
        break;

    case JET_wrnBufferTruncated:
        description = READ_STRING(IDS_JET_WRNBUFFERTRUNCATED);
        break;

    case JET_wrnColumnNull:
        description = READ_STRING(IDS_JET_WRNCOLUMNNULL);
        break;

    default:
        {
            const WCHAR * msg;
            if ( JetError > 0 ) {
                msg = READ_STRING (IDS_JET_WARNING);
                swprintf(jetdesc, msg, JetError);
            } else {
                msg = READ_STRING (IDS_JET_ERROR);
                swprintf(jetdesc, msg, JetError);
            }
        }
    }

    if ( description != NULL ) {
        wcscpy(jetdesc, description);
    }

    return jetdesc;

} // GetJetErrorDescription
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\select.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"
#include "ntdsapip.h"
extern "C" {
#include "utilc.h"
}

#include "resource.h"

CParser selectParser;
BOOL    fSelectQuit;
BOOL    fSelectParserInitialized = FALSE;

// Build a table which defines our language.

LegalExprRes selectLanguage[] = 
{
    CONNECT_SENTENCE_RES

    {   L"?",
        SelectHelp,
        IDS_HELP_MSG, 0  },

    {   L"Help",
        SelectHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit",
        SelectQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"List current selections",
        SelectListCurrentSelections,
        IDS_SELECT_LIST_MSG, 0 },

    {   L"List sites",
        SelectListSites,
        IDS_SELECT_LIST_SITES_MSG, 0 },

    {   L"List roles for connected server",
        SelectListRoles,
        IDS_SELECT_LIST_ROLES_MSG, 0 },

    {   L"List servers in site",
        SelectListServersInSite,
        IDS_SELECT_LIST_SERVERS_MSG, 0 },

    {   L"List Naming Contexts",
        SelectListNamingContexts,
        IDS_SELECT_LIST_NCS_MSG, 0 },

    {   L"List domains",
        SelectListDomains,
        IDS_SELECT_LIST_DOMAINS_CR_MSG, 0 },

    {   L"List domains in site",
        SelectListDomainsInSite,
        IDS_SELECT_LIST_DOMAINS_MSG, 0 },

    {   L"List servers for domain in site",
        SelectListServersForDomainInSite,
        IDS_SELECT_LIST_DOMAIN_SRV_MSG, 0 },

    {   L"Select site %d",
        SelectSelectSite,
        IDS_SELECT_SITE_MSG, 0 },
        
    {   L"Select Naming Context %d",
        SelectSelectNamingContext,
        IDS_SELECT_NC_MSG, 0 },

    {   L"Select domain %d",
        SelectSelectDomain,
        IDS_SELECT_DOMAIN_MSG, 0 },

    {   L"Select server %d",
        SelectSelectServer,
        IDS_SELECT_SERVER_MSG, 0 }
};

HRESULT
SelectMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !fSelectParserInitialized )
    {
        cExpr = sizeof(selectLanguage) / sizeof(LegalExprRes);
    

        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (selectLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }

        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = selectParser.AddExpr(selectLanguage[i].expr,
                                                  selectLanguage[i].func,
                                                  selectLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fSelectParserInitialized = TRUE;
    fSelectQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_SELECT);

    hr = selectParser.Parse(gpargc,
                            gpargv,
                            stdin,
                            stdout,
                            prompt,
                            &fSelectQuit,
                            FALSE,               // timing info
                            FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }

    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}

HRESULT SelectHelp(CArgs *pArgs)
{
    return(selectParser.Dump(stdout,L""));
}

HRESULT SelectQuit(CArgs *pArgs)
{
    fSelectQuit = TRUE;
    return(S_OK);
}

#define INVALID_INDEX (-1)

DS_NAME_RESULTW *gServers = NULL;
DS_NAME_RESULTW *gServerInfo = NULL;
DS_NAME_RESULTW *gSites = NULL;
DS_NAME_RESULTW *gDomains = NULL;
DS_NAME_RESULTW *gNamingContexts = NULL;
int             giCurrentServer = INVALID_INDEX;
int             giCurrentSite = INVALID_INDEX;
int             giCurrentDomain = INVALID_INDEX;
int             giCurrentNamingContext = INVALID_INDEX;

WCHAR * SelectGetCurrentSite()
{
    if ( CHECK_IF_NOT_CONNECTED )
    {
        return(NULL);
    }

    if ( INVALID_INDEX == giCurrentSite )
    {
        //"No current site - use \"Select operation target\"\n"
        RESOURCE_PRINT (IDS_SELECT_NO_SITE1);
        
        return(NULL);
    }

    return(gSites->rItems[giCurrentSite].pName);
}

WCHAR * SelectGetCurrentNamingContext()
{
    if ( CHECK_IF_NOT_CONNECTED )
    {
        return(NULL);
    }

    if ( INVALID_INDEX == giCurrentNamingContext )
    {
        //"No current Naming Context - use \"Select operation target\"\n"
        RESOURCE_PRINT (IDS_SELECT_NO_NC1);
        return(NULL);
    }

    return(gNamingContexts->rItems[giCurrentNamingContext].pName);
}

WCHAR * SelectGetCurrentDomain()
{
    if ( CHECK_IF_NOT_CONNECTED )
    {
        return(NULL);
    }

    if ( INVALID_INDEX == giCurrentDomain )
    {
        //"No current domain - use \"Select operation target\"\n"
        RESOURCE_PRINT (IDS_SELECT_NO_DOMAIN1);
        return(NULL);
    }

    return(gDomains->rItems[giCurrentDomain].pName);
}

WCHAR * SelectGetCurrentServer()
{
    if ( CHECK_IF_NOT_CONNECTED )
    {
        return(NULL);
    }

    if ( INVALID_INDEX == giCurrentServer )
    {
        //"No current server - use \"Select operation target\"\n"
        RESOURCE_PRINT (IDS_SELECT_NO_SERVER1);

        return(NULL);
    }

    return(gServers->rItems[giCurrentServer].pName);
}

VOID
SelectCleanupGlobals()
{
    if ( ghDS )
    {
        DsUnBindW(&ghDS);
        ghDS = NULL;
    }

    if ( gServers ) 
    {
        DsFreeNameResultW(gServers);
        gServers = NULL;
    }

    if ( gServerInfo )
    {
        DsFreeNameResultW(gServerInfo);
        gServerInfo = NULL;
    }

    if ( gSites )
    {
        DsFreeNameResultW(gSites);
        gSites = NULL;
    }

    if ( gDomains )
    {
        DsFreeNameResultW(gDomains);
        gDomains = NULL;
    }
    
    if ( gNamingContexts )
    {
        DsFreeNameResultW(gNamingContexts);
        gNamingContexts = NULL;
    }

    giCurrentServer = INVALID_INDEX;
    giCurrentSite = INVALID_INDEX;
    giCurrentDomain = INVALID_INDEX;
    giCurrentNamingContext = INVALID_INDEX;
}

HRESULT
SelectListCurrentSelections(
    CArgs   *pArgs
    )
{
    DWORD   i;

    RETURN_IF_NOT_CONNECTED;

    if ( INVALID_INDEX == giCurrentSite )
    {
        //"No current site\n"
        RESOURCE_PRINT (IDS_SELECT_NO_SITE2);
    }
    else
    {
       //"Site - %ws\n"
       RESOURCE_PRINT1 (IDS_SELECT_PRINT_SITE,
               gSites->rItems[giCurrentSite].pName);
    }

    if ( INVALID_INDEX == giCurrentDomain )
    {
        //"No current domain\n"
        RESOURCE_PRINT (IDS_SELECT_NO_DOMAIN2);
    }
    else
    {
        //"Domain - %ws\n"
        RESOURCE_PRINT1 (IDS_SELECT_PRINT_DOMAIN,
               gDomains->rItems[giCurrentDomain].pName);
    }

    if ( INVALID_INDEX == giCurrentServer )
    {
        //"No current server\n"
        RESOURCE_PRINT (IDS_SELECT_NO_SERVER2);
    }
    else
    {
        //"Server - %ws\n"
        RESOURCE_PRINT1 (IDS_SELECT_PRINT_SERVER,
                  gServers->rItems[giCurrentServer].pName);

        if ( gServerInfo )
        {
            if (    (gServerInfo->cItems > DS_LIST_DSA_OBJECT_FOR_SERVER)
                 && (i = DS_LIST_DSA_OBJECT_FOR_SERVER,
                     DS_NAME_NO_ERROR == gServerInfo->rItems[i].status) )
            {
               //"\tDSA object - %ws\n"
               RESOURCE_PRINT1 (IDS_SELECT_PRINT_DSA,
                          gServerInfo->rItems[i].pName);
            }

            if (    (gServerInfo->cItems > DS_LIST_DNS_HOST_NAME_FOR_SERVER)
                 && (i = DS_LIST_DNS_HOST_NAME_FOR_SERVER,
                     DS_NAME_NO_ERROR == gServerInfo->rItems[i].status) )
            {
                //\tDNS host name - %ws\n"
                RESOURCE_PRINT1 (IDS_SELECT_PRINT_DNS,
                            gServerInfo->rItems[i].pName);
            }

            if (    (gServerInfo->cItems > DS_LIST_ACCOUNT_OBJECT_FOR_SERVER)
                 && (i = DS_LIST_ACCOUNT_OBJECT_FOR_SERVER,
                     DS_NAME_NO_ERROR == gServerInfo->rItems[i].status) )
            {
                //"\tComputer object - %ws\n"
                RESOURCE_PRINT1 (IDS_SELECT_PRINT_COMPUTER,
                           gServerInfo->rItems[i].pName);
            }
        }
    }

    if ( INVALID_INDEX == giCurrentNamingContext )
    {
        //"No current Naming Context\n"
        RESOURCE_PRINT (IDS_SELECT_NO_NC2);
    }
    else
    {
        //"Naming Context - %ws\n"
        RESOURCE_PRINT1 (IDS_SELECT_PRINT_NC,
               gNamingContexts->rItems[giCurrentNamingContext].pName);
    }

    return(S_OK);
}

HRESULT
SelectListRoles(
    CArgs   *pArgs
    )
{
    DWORD           dwErr;
    DWORD           i;
    DS_NAME_RESULTW *roles;

    RETURN_IF_NOT_CONNECTED;

    if ( dwErr = DsListRolesW(ghDS, &roles) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListRolesW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Server \"%ws\" knows about %d roles\n"
    RESOURCE_PRINT2 (IDS_SELECT_SERVER_ROLES, gpwszServer, roles->cItems);

    for ( i = 0; i < roles->cItems; i++ )
    {

        // DsListRoles should return no error or error_not_found (handled below)
        if (   DS_NAME_NO_ERROR != roles->rItems[i].status 
            && DS_NAME_ERROR_NOT_FOUND != roles->rItems[i].status )
        {
            //"Role item[%d] error 0x%x\n",
            RESOURCE_PRINT2 (IDS_SELECT_ROLE_ITEM_ERR, i, roles->rItems[i].status);
            continue;
        }

        switch ( i )
        {
        case DS_ROLE_INFRASTRUCTURE_OWNER:

            if (   DS_NAME_ERROR_NOT_FOUND == roles->rItems[i].status )
            {
                //"Infrastructure role owner cannot be found\n"
                RESOURCE_PRINT(IDS_SELECT_ROLE_INFRASTRUCTURE_NOT_FOUND);
            } else
            {
                //"Infrastructure - %ws\n"
                RESOURCE_PRINT1 (IDS_SELECT_PRINT_INFRASTR, roles->rItems[i].pName);
            }
            break;

        case DS_ROLE_SCHEMA_OWNER:

            if (   DS_NAME_ERROR_NOT_FOUND == roles->rItems[i].status )
            {
                //"Schema role owner cannot be found\n"
                RESOURCE_PRINT(IDS_SELECT_ROLE_SCHEMA_NOT_FOUND);
            } else
            {
                //"Schema - %ws\n"
                RESOURCE_PRINT1(IDS_SELECT_PRINT_SCHEMA, roles->rItems[i].pName);
            }
            break;
            
        case DS_ROLE_DOMAIN_OWNER:

            if (   DS_NAME_ERROR_NOT_FOUND == roles->rItems[i].status )
            {
                //"Domain role owner cannot be found\n"
                RESOURCE_PRINT(IDS_SELECT_ROLE_DOMAIN_NOT_FOUND);
            } else
            {
                //"Domain - %ws\n"
                RESOURCE_PRINT1 (IDS_SELECT_PRINT_DOMAIN, roles->rItems[i].pName);
            }
            break;

        case DS_ROLE_PDC_OWNER:

            if (   DS_NAME_ERROR_NOT_FOUND == roles->rItems[i].status )
            {
                //"PDC role owner cannot be found\n"
                RESOURCE_PRINT(IDS_SELECT_ROLE_PDC_NOT_FOUND);
            } else
            {
                //"PDC - %ws\n"
                RESOURCE_PRINT1 (IDS_SELECT_PRINT_PDC, roles->rItems[i].pName);
            }
            break;

        case DS_ROLE_RID_OWNER:

            if (   DS_NAME_ERROR_NOT_FOUND == roles->rItems[i].status )
            {
                //"RID role owner cannot be found\n"
                RESOURCE_PRINT(IDS_SELECT_ROLE_RID_NOT_FOUND);
            } else
            {
                //"RID - %ws\n"
                RESOURCE_PRINT1 (IDS_SELECT_PRINT_RID, roles->rItems[i].pName);
            }
            break;

        default:
            //"Unknown item %d\n"
            RESOURCE_PRINT1 (IDS_SELECT_PRINT_UNKNOWN,  i);
            break;
        }
    }

    DsFreeNameResultW(roles);
    return(S_OK);
}

HRESULT
SelectListSites(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;

    RETURN_IF_NOT_CONNECTED;

    if ( gSites )
    {
        DsFreeNameResultW(gSites);
        gSites = NULL;
        giCurrentSite = INVALID_INDEX;
    }

    if ( dwErr = DsListSitesW(ghDS, &gSites) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListSitesW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d site%s\n"
    RESOURCE_PRINT1 (IDS_SELECT_PRINT_FOUND_SITES, gSites->cItems );
           

    for ( i = 0; i < gSites->cItems; i++ )
    {
        printf("%d - %ws\n", i, gSites->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
SelectListServersInSite(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;

    RETURN_IF_NOT_CONNECTED;

    if ( !gSites )
    {
        //"No active site list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_SITE_LIST);
        return(S_OK);
    }

    if ( INVALID_INDEX == giCurrentSite )
    {
        //"No current site\n");
        RESOURCE_PRINT (IDS_SELECT_NO_SITE2);
        SelectListCurrentSelections(NULL);
        return(S_OK);
    }

    if ( gServers )
    {
        DsFreeNameResultW(gServers);
        gServers = NULL;
        giCurrentServer = INVALID_INDEX;
    }

    // Providing empty string for domain parameter returns all Servers with 
    // NTDS-DSA objects in the site.

    if ( dwErr = DsListServersForDomainInSiteW(
                                ghDS, 
                                NULL,
                                gSites->rItems[giCurrentSite].pName,
                                &gServers) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListServersForDomainInSiteW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d server%s\n"
    RESOURCE_PRINT1 (IDS_SELECT_PRINT_FOUND_SERVERS, gServers->cItems);

    for ( i = 0; i < gServers->cItems; i++ )
    {
        printf("%d - %ws\n", i, gServers->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
SelectListDomainsInSite(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;

    RETURN_IF_NOT_CONNECTED;

    if ( !gSites )
    {
        //"No active site list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_SITE_LIST);
        return(S_OK);
    }

    if ( INVALID_INDEX == giCurrentSite )
    {
        //"No current site\n");
        RESOURCE_PRINT (IDS_SELECT_NO_SITE2);
        SelectListCurrentSelections(NULL);
        return(S_OK);
    }

    if ( gDomains )
    {
        DsFreeNameResultW(gDomains);
        gDomains = NULL;
        giCurrentDomain = INVALID_INDEX;
    }

    if ( dwErr = DsListDomainsInSiteW(
                                ghDS, 
                                gSites->rItems[giCurrentSite].pName,
                                &gDomains) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListDomainsInSiteW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d domain%s\n"
    RESOURCE_PRINT1 (IDS_SELECT_PRINT_FOUND_DOMAINS, gDomains->cItems);

    for ( i = 0; i < gDomains->cItems; i++ )
    {
        printf("%d - %ws\n", i, gDomains->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
SelectListNamingContexts(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;
    LPCWSTR dummy = L"dummy";

    RETURN_IF_NOT_CONNECTED;

    if ( gNamingContexts )
    {
        DsFreeNameResultW(gNamingContexts);
        gNamingContexts = NULL;
        giCurrentNamingContext = INVALID_INDEX;
    }

    if ( dwErr = DsCrackNamesW(ghDS,
                               DS_NAME_NO_FLAGS,
                               (DS_NAME_FORMAT)DS_LIST_NCS,
                               DS_FQDN_1779_NAME,
                               1,
                               &dummy,
                               &gNamingContexts) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsCrackNamesW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d Naming Context(s)\n"
    RESOURCE_PRINT1 (IDS_SELECT_PRINT_FOUND_NCS, gNamingContexts->cItems);

    for ( i = 0; i < gNamingContexts->cItems; i++ )
    {
        printf("%d - %S\n", i, gNamingContexts->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
SelectListDomains(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;

    RETURN_IF_NOT_CONNECTED;

    if ( gDomains )
    {
        DsFreeNameResultW(gDomains);
        gDomains = NULL;
        giCurrentDomain = INVALID_INDEX;
    }

    if ( dwErr = DsListDomainsInSiteW(
                                ghDS, 
                                NULL, 
                                &gDomains) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListDomainsInSiteW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d domain%s\n"
    RESOURCE_PRINT1 (IDS_SELECT_PRINT_FOUND_DOMAINS, gDomains->cItems);

    for ( i = 0; i < gDomains->cItems; i++ )
    {
        printf("%d - %ws\n", i, gDomains->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
SelectListServersForDomainInSite(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;

    RETURN_IF_NOT_CONNECTED;

    if ( !gSites )
    {
        //"No active site list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_SITE_LIST);
        return(S_OK);
    }

    if ( INVALID_INDEX == giCurrentSite )
    {
        //"No current site\n");
        RESOURCE_PRINT (IDS_SELECT_NO_SITE2);
        SelectListCurrentSelections(NULL);
        return(S_OK);
    }

    if ( !gDomains )
    {
        //"No active domain list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_DOMAIN_LIST);
        return(S_OK);
    }

    if ( INVALID_INDEX == giCurrentDomain )
    {
        // "No current domain\n"
        RESOURCE_PRINT (IDS_SELECT_NO_DOMAIN2);
        SelectListCurrentSelections(NULL);
        return(S_OK);
    }

    if ( gServers )
    {
        DsFreeNameResultW(gServers);
        gServers = NULL;
        giCurrentServer = INVALID_INDEX;
    }

    if ( dwErr = DsListServersForDomainInSiteW(
                                ghDS, 
                                gDomains->rItems[giCurrentDomain].pName,
                                gSites->rItems[giCurrentSite].pName,
                                &gServers) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListServersForDomainInSiteW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d server%s\n"
    RESOURCE_PRINT1 (IDS_SELECT_PRINT_FOUND_SERVERS, gServers->cItems);


    for ( i = 0; i < gServers->cItems; i++ )
    {
        printf("%d - %ws\n", i, gServers->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
SelectSelectSite(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    DWORD   num;

    if ( !gSites )
    {
        //"No active site list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_SITE_LIST);
        return(S_OK);
    }

    if ( FAILED(hr = pArgs->GetInt(0, (int *) &num)) )
    {
        return(hr);
    }

    if ( num >= gSites->cItems )
    {
        //"Selection out of range\n"
        RESOURCE_PRINT (IDS_SELECT_SEL_OUT_OF_RANGE);
        return(S_OK);
    }

    giCurrentSite = num;
    SelectListCurrentSelections(NULL);
    return(S_OK);
}

HRESULT
SelectSelectServer(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    DWORD   num;
    DWORD   dwErr;

    if ( !gServers )
    {
        //"No active server list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_SERVER_LIST);
        return(S_OK);
    }

    if ( FAILED(hr = pArgs->GetInt(0, (int *) &num)) )
    {
        return(hr);
    }

    if ( num >= gServers->cItems )
    {
        //"Selection out of range\n"
        RESOURCE_PRINT (IDS_SELECT_SEL_OUT_OF_RANGE);
        return(S_OK);
    }

    giCurrentServer = num;

    if ( dwErr = DsListInfoForServerW(
                                ghDS, 
                                gServers->rItems[giCurrentServer].pName,
                                &gServerInfo) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListInfoForServerW", dwErr, GetW32Err(dwErr));
        
        //"Continuing ...\n"
        RESOURCE_PRINT (IDS_CONTINUING);
    }

    SelectListCurrentSelections(NULL);
    return(S_OK);
}

HRESULT
SelectSelectNamingContext(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    DWORD   num;

    if ( !gNamingContexts )
    {
        //"No active domain list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_NC_LIST);
        return(S_OK);
    }

    if ( FAILED(hr = pArgs->GetInt(0, (int *) &num)) )
    {
        return(hr);
    }

    if ( num >= gNamingContexts->cItems )
    {
        //"Selection out of range\n"
        RESOURCE_PRINT (IDS_SELECT_SEL_OUT_OF_RANGE);
        return(S_OK);
    }

    giCurrentNamingContext = num;
    SelectListCurrentSelections(NULL);
    return(S_OK);
}

HRESULT
SelectSelectDomain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    DWORD   num;

    if ( !gDomains )
    {
        //"No active domain list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_DOMAIN_LIST);
        return(S_OK);
    }

    if ( FAILED(hr = pArgs->GetInt(0, (int *) &num)) )
    {
        return(hr);
    }

    if ( num >= gDomains->cItems )
    {
        //"Selection out of range\n"
        RESOURCE_PRINT (IDS_SELECT_SEL_OUT_OF_RANGE);
        return(S_OK);
    }

    giCurrentDomain = num;
    SelectListCurrentSelections(NULL);
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\setpath.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include <accctrl.h>
#include <aclapi.h>

#include "ntdsutil.hxx"
#include "dsconfig.h"
#include "connect.hxx"

#include "resource.h"


HRESULT
SetPathSecurity(
    char            *pszPath
    )

/*++

Routine Description:

    Update the security on the new path

    This code is taken from the MSDN example "Modifying an Object's ACL's"

Arguments:

    pszPath - 

Return Value:

    HRESULT - 

--*/

{
    DWORD dwErr;
    PACL pOldDACL = NULL, pNewDACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    EXPLICIT_ACCESS ea;
    PSID pSid = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;

    if (NULL == pszPath) 
        return ERROR_INVALID_PARAMETER;

    // Initialize the Sid we will need
    if (AllocateAndInitializeSid(&SIDAuth, 1,
                                 SECURITY_NETWORK_SERVICE_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &pSid) == 0) {
        dwErr = GetLastError();
        RESOURCE_PRINT2 (IDS_ERR_GET_SECURITY_INFO,
                dwErr, GetW32Err(dwErr) );
        goto Cleanup; 
    }

// Get a pointer to the existing DACL.

    dwErr = GetNamedSecurityInfo(
        pszPath, SE_FILE_OBJECT, 
        DACL_SECURITY_INFORMATION,
        NULL, NULL, &pOldDACL, NULL, &pSD);
    if (ERROR_SUCCESS != dwErr) {
        RESOURCE_PRINT2 (IDS_ERR_GET_SECURITY_INFO,
                dwErr, GetW32Err(dwErr) );
        goto Cleanup; 
    }  

// Initialize an EXPLICIT_ACCESS structure for the new ACE. 
// Note that we do not use the TRUSTEE_IS_NAME form because the
// name will be different in each language

    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea.grfAccessPermissions = FILE_ADD_SUBDIRECTORY;
    ea.grfAccessMode = SET_ACCESS;
    ea.grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea.Trustee.ptstrName = (LPSTR) pSid;

// Create a new ACL that merges the new ACE
// into the existing DACL.

    dwErr = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);
    if (ERROR_SUCCESS != dwErr)  {
        RESOURCE_PRINT2 (IDS_ERR_SET_ENTRIES_ACL,
                dwErr, GetW32Err(dwErr) );
        goto Cleanup; 
    }  

// Attach the new ACL as the object's DACL.

    dwErr = SetNamedSecurityInfo(pszPath, SE_FILE_OBJECT, 
                                 DACL_SECURITY_INFORMATION,
                                 NULL, NULL, pNewDACL, NULL);
    if (ERROR_SUCCESS != dwErr)  {
        RESOURCE_PRINT2 (IDS_ERR_SET_SECURITY_INFO,
                dwErr, GetW32Err(dwErr) );
        goto Cleanup; 
    }  

Cleanup:

    if(pSD != NULL) 
        LocalFree((HLOCAL) pSD); 
    if (pSid) {
        FreeSid( pSid );
    }   
    if(pNewDACL != NULL) 
        LocalFree((HLOCAL) pNewDACL); 

    return HRESULT_FROM_WIN32( dwErr );

} /* SetPathSecurity */

HRESULT
SetPathAny(
    CArgs   *pArgs,
    char    *label
    )
/*++

  Routine Description: 

    Sets any value under the ...\Services\NTDS\Parameters registry key.
    All values are assumed to be REG_SZ.

  Parameters: 

    pArgs - Pointer to argument from original "set path ..." call.

    label - Name of value to update.

  Return Values:

    Always S_OK unless reading original arguments fails.

--*/
{
    const WCHAR     *pwszVal;
    char            *pszVal;
    HRESULT         hr;
    DWORD           cb;
    DWORD           dwErr;
    HKEY            hKey;

    if ( FAILED(hr = pArgs->GetString(0, &pwszVal)) )
    {
        return(hr);
    }

    // Convert arguments from WCHAR to CHAR.

    cb = wcslen(pwszVal) + 1;
    pszVal = (char *) alloca(cb);
    memset(pszVal, 0, cb);
    wcstombs(pszVal, pwszVal, wcslen(pwszVal));

    // Open the DS parameters key.

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, 
                        DSA_CONFIG_SECTION, 
                        &hKey);

    if ( ERROR_SUCCESS != dwErr )
    {
        //"%d(%s) opening registry key \"%s\"\n"
        RESOURCE_PRINT3 (IDS_ERR_OPENING_REGISTRY,
                dwErr, GetW32Err(dwErr),
                DSA_CONFIG_SECTION);

        return(S_OK);
    }
    else
    {
        dwErr = RegSetValueEx(  hKey, 
                                label, 
                                0, 
                                REG_SZ, 
                                (BYTE *) pszVal, 
                                strlen(pszVal) + 1);

        if ( ERROR_SUCCESS != dwErr )
        {
            //"%d(%s) writing \"%s\" to \"%s\"\n"

            RESOURCE_PRINT4 (IDS_ERR_WRITING_REG_KEY,
                    dwErr, GetW32Err(dwErr),
                    pszVal,
                    label);
        }
    }

    RegCloseKey(hKey);

    hr = SetPathSecurity( pszVal );
    // Ignore error, already logged

    return(S_OK);
}

HRESULT
SetPathDb(
    CArgs   *pArgs)
{
    return(SetPathAny(pArgs, FILEPATH_KEY));
}

HRESULT
SetPathBackup(
    CArgs   *pArgs)
{
    return(SetPathAny(pArgs, BACKUPPATH_KEY));
}

HRESULT
SetPathLogs(
    CArgs   *pArgs)
{
    return(SetPathAny(pArgs, LOGPATH_KEY));
}

HRESULT
SetPathSystem(
    CArgs   *pArgs)
{
    return(SetPathAny(pArgs, JETSYSTEMPATH_KEY));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\util.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "file.hxx"

extern "C" {
#include "windows.h"
#include "dsconfig.h"
#include "mxsutil.h"
#include "ntdsbcli.h"
#include "jetbp.h"
#include "safeboot.h"
#include "winldap.h"
#include "utilc.h"
}


#include "resource.h"


void
FormatDiskSpaceString(
    LARGE_INTEGER   *pli,
    DiskSpaceString buf
    )
/*++

  Routine Description: 

    Formats a LARGE_INTEGER as a string representing either Kb/Mb/Gb/Tb.

  Parameters: 

    pli - Pointer to LARGE_INTEGER to format.

    buf - Buffer of type DiskSpaceString which holds the formatted result.

  Return Values:

    None.

--*/
{
    // Estimate to the nearest Kb/Mb/Gb/Tb with 1 decimal point precision.

    LARGE_INTEGER   liTmp;
    LARGE_INTEGER   liWholePart;
    LARGE_INTEGER   liFraction;
    LARGE_INTEGER   li100;
    char            *pszUnits;
    char            pszFraction[40];

    li100.QuadPart = 100;

    if ( liTmp.QuadPart = (pli->QuadPart / gliOneKb.QuadPart),
         liTmp.QuadPart < gliOneKb.QuadPart )
    {
        liWholePart.QuadPart = (pli->QuadPart / gliOneKb.QuadPart);
        liFraction.QuadPart = (pli->QuadPart % gliOneKb.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart * li100.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart / gliOneKb.QuadPart);
        pszUnits = "Kb";
    }
    else if ( liTmp.QuadPart = (pli->QuadPart / gliOneMb.QuadPart),
              liTmp.QuadPart < gliOneKb.QuadPart )
    {
        liWholePart.QuadPart = (pli->QuadPart / gliOneMb.QuadPart);
        liFraction.QuadPart = (pli->QuadPart % gliOneMb.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart * li100.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart / gliOneMb.QuadPart);
        pszUnits = "Mb";
    }
    else if ( liTmp.QuadPart = (pli->QuadPart / gliOneGb.QuadPart),
              liTmp.QuadPart < gliOneKb.QuadPart )
    {
        liWholePart.QuadPart = (pli->QuadPart / gliOneGb.QuadPart);
        liFraction.QuadPart = (pli->QuadPart % gliOneGb.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart * li100.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart / gliOneGb.QuadPart);
        pszUnits = "Gb";
    }
    else 
    {
        liWholePart.QuadPart = (pli->QuadPart / gliOneTb.QuadPart);
        liFraction.QuadPart = (pli->QuadPart % gliOneTb.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart * li100.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart / gliOneTb.QuadPart);
        pszUnits = "Tb";
    }
    
    pszFraction[0] = '\0';
    sprintf(pszFraction, "%d", liFraction.LowPart);
    pszFraction[1] = '\0';
    sprintf(buf, "%d.%s %s", liWholePart.LowPart, pszFraction, pszUnits);
}

BOOL
FindExecutable(
    char            *pszExeName,
    ExePathString   pszExeFullPathName
    )
/*++

  Routine Description: 

    Searches for an executable and returns its full path.

  Parameters: 

    pszExeName - Name of executable to find.

    pszExeFullPathName - Buffer of type ExePathString which receives result.

  Return Values:

    TRUE/FALSE indicating whether the executable was found.

--*/
{
    DWORD   dwErr;
    char    *pDontCare;

    dwErr = SearchPath( NULL, 
                        pszExeName, 
                        NULL, 
                        sizeof(ExePathString), 
                        pszExeFullPathName, 
                        &pDontCare);

    if ( (0 == dwErr) || (dwErr > sizeof(ExePathString)) )
    {
        if ( dwErr > sizeof(ExePathString) )
        {
            RESOURCE_PRINT1 (IDS_BUFFER_OVERFLOW, pszExeName );
        }

        RESOURCE_PRINT1 (IDS_CANNOT_FIND_EXECUTABLE, pszExeName );
        
        return(FALSE);
    }

    return(TRUE);
}

BOOL
SpawnCommandWindow(
    char    *title,
    char    *whatToRun
    )
/*++

  Routine Description: 

    Start a command window to run the specified exe/cmd file.  
    The command window uses the same window as the parent process,
    and exits as soon as the execution terminates.
    Current process waits until child process terminates.

  Parameters: 

    title - String for the window's title bar.

    whaToRun - Name of exe/cmd file to run

  Return Values:

    TRUE on success, FALSE on error.

--*/
{
    char                *commandLine;
//  char                *shellArgs = "cmd.exe /K";
    char                *shellArgs = "cmd.exe /C";
    DWORD               dwErr;
    PROCESS_INFORMATION processInfo;
    STARTUPINFO         startupInfo;

    commandLine = (char *) alloca(strlen(shellArgs) + strlen(whatToRun) + 10);
    sprintf(commandLine, "%s \"%s\"", shellArgs, whatToRun);

    memset(&startupInfo, 0, sizeof(startupInfo));
    startupInfo.cb = sizeof(startupInfo);
    startupInfo.lpTitle = title;
    startupInfo.dwXCountChars = 80;
    startupInfo.dwYCountChars = 9999;
    startupInfo.dwFlags = STARTF_USECOUNTCHARS;

    // use this only when cmd /K
    //RESOURCE_PRINT (IDS_SPAWN_EXTERNAL_COMMAND);

    if ( !CreateProcess(
                    NULL,               // image name
                    commandLine,        // command line
                    NULL,               // process security attributes
                    NULL,               // primary thread security attributes
                    TRUE,               // inherit handles
//                    HIGH_PRIORITY_CLASS | CREATE_NEW_CONSOLE,
                    HIGH_PRIORITY_CLASS,
                    NULL,               // environment block pointer
                    NULL,               // initial current drive:\directory
                    &startupInfo,
                    &processInfo) )
    {
        dwErr = GetLastError();
        
        RESOURCE_PRINT3 (IDS_CREATING_WINDOW,
                dwErr, 
                GetW32Err(dwErr),
                commandLine);
        
        return(FALSE);
    }

    // Wait until child process exits.
    WaitForSingleObject( processInfo.hProcess, INFINITE );


    return(TRUE);
}


BOOL SpawnCommand( 
    char *commandLine, 
    LPCSTR lpCurrentDirectory, 
    WCHAR *successMsg )
/*++

  Routine Description: 

    Executes a new process in the same window. Current process waits until child process terminates.

  Parameters: 

    commandLine - Name of exe/cmd file to run
    
    lpCurrentDirectory - directory where the process should start executing
    
    successMsg - a message that should be printed after the process execution (possibly NULL)

  Return Values:

    TRUE on success, FALSE on error.

--*/

{
    DWORD               dwErr;
    DWORD               exitCode;
    PROCESS_INFORMATION processInfo;
    STARTUPINFO         startupInfo;

    memset(&startupInfo, 0, sizeof(startupInfo));
    startupInfo.cb = sizeof(startupInfo);
    

    if ( !CreateProcess(
                    NULL,               // image name
                    commandLine,        // command line
                    NULL,               // process security attributes
                    NULL,               // primary thread security attributes
                    TRUE,               // inherit handles
                    HIGH_PRIORITY_CLASS,
                    NULL,               // environment block pointer
                    lpCurrentDirectory, // initial current drive:\directory
                    &startupInfo,       // startuo info
                    &processInfo) )
    {
        dwErr = GetLastError();
        
        RESOURCE_PRINT3 (IDS_CREATING_WINDOW,
                dwErr, 
                GetW32Err(dwErr),
                commandLine);
        
        return(FALSE);
    }

    // Wait until child process exits.
    WaitForSingleObject( processInfo.hProcess, INFINITE );


    if (GetExitCodeProcess ( processInfo.hProcess, &exitCode )) {
        RESOURCE_PRINT2 (IDS_SPAWN_PROC_EXIT_CODE, exitCode, exitCode);

        if (successMsg) {
            wprintf (successMsg);
        }
    }

    return(TRUE);
}



BOOL
ExistsFile(
    char    *pszFile,
    BOOL    *pfIsDir
    )
/*++

  Routine Description: 

    Checks whether a given file exists.

  Parameters: 

    pszFile - Name of file to find.

    pfIsDir - Pointer to BOOL which identifies if found file is a directory.

  Return Values:

    TRUE if file exists, FALSE otherwise.

--*/
{
    WIN32_FIND_DATA findData;
    HANDLE          hFile;
    DWORD           dwErr;

    hFile = FindFirstFile(pszFile, &findData);

    if ( INVALID_HANDLE_VALUE == hFile ) 
    {
        return(FALSE);
    }

    FindClose(hFile);
    *pfIsDir = (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
    return(TRUE);
}

FILE *
OpenScriptFile(
    SystemInfo      *pInfo, 
    ExePathString   pszScript
    )
/*++

  Routine Description: 

    Opens a script file and returns an open FILE* to it.

  Parameters: 

    pInfo - Pointer to a SystemInfo from which is taken the initial
        location for the script file if possible.

    pszScript - Buffer of type ExePathString which receives the resulting
        script full path.

  Return Values:

    FILE pointer on success, NULL otherwise.

--*/
{
    FILE    *fp = NULL;
    DWORD   cbScript;
    int     i;
    char    *key;

    // Try to open ntds-scr.cmd in %tmp% and %temp%.

    for ( i = 0; i <= 1; i++ )
    {
        key =  ((0 == i)
                    ? "%tmp%\\ntds-scr.cmd"
                    : "%temp%\\ntds-scr.cmd");

        cbScript = ExpandEnvironmentStrings(
                                key,
                                pszScript, 
                                sizeof(ExePathString));

        if (    cbScript 
             && (cbScript <= sizeof(ExePathString))
             && _stricmp(key, pszScript) )
        {
            fp = fopen(pszScript, "w+");

            if ( fp )
            {
                return(fp);
            }
        }
    }

    // If we got here we were unable to open any script file.

    RESOURCE_PRINT (IDS_OPEN_SCRIPT_ERROR);        

    return(NULL);
}

BOOL
IsSafeMode(
    )
/*++

  Routine Description: 

    Determines if the server is booted in safe mode or not where
    safe mode == directory service repair.

  Parameters: 

    None.

  Return Values:

    TRUE if in safe mode, FALSE otherwise.

--*/
{
    DWORD   cbData;
    char    data[100];
    char    *key = "%SAFEBOOT_OPTION%";

    cbData = ExpandEnvironmentStrings(key, data, sizeof(data));

    if (    cbData 
         && (cbData <= sizeof(data))
         && !_stricmp(data, SAFEBOOT_DSREPAIR_STR_A) )
    {
        return(TRUE);
    }

    
    RESOURCE_PRINT1 (IDS_SAFE_MODE_ERROR, SAFEBOOT_DSREPAIR_STR_A );
    
    return(FALSE);
}

BOOL 
CheckIfRestored(
    )
/*++

  Routine Description: 

    Determines if the server is in the restored but not yet recovered state.

  Parameters: 

    None.

  Return Values:

    TRUE  - if we're sitting on restored files which have not been recovered 
            yet OR we get an error while determining this.
    FALSE - otherwise

--*/
{
    HKEY    hKey;
    DWORD   dwErr;
    DWORD   type;
    DWORD   cBuffer = 0;
    BOOL    fRestored = TRUE;

    // Open the DS parameters key.

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE,
                        DSA_CONFIG_SECTION,
                        &hKey);

    if ( ERROR_SUCCESS == dwErr )
    {
        dwErr = RegQueryValueExW(   hKey,
                                    RESTORE_IN_PROGRESS,
                                    NULL,
                                    &type,
                                    NULL,
                                    &cBuffer);

        if ( ERROR_FILE_NOT_FOUND == dwErr )
        {
            fRestored = FALSE;
        }
        else if ( ERROR_SUCCESS == dwErr )
        {
            // leave (fRestored == TRUE) but alert user.
        
            RESOURCE_PRINT (IDS_RESTORE_CHK1);        
        }
        else
        {
            // leave (fRestored == TRUE) but alert user.
           RESOURCE_PRINT3 (IDS_ERR_READING_REGISTRY,
                     dwErr, 
                     GetW32Err(dwErr),
                     RESTORE_IN_PROGRESS);
        }
            
        RegCloseKey(hKey);
    }
    else
    {
        // leave (fRestored == TRUE) but alert user.
       RESOURCE_PRINT3 (IDS_ERR_OPENING_REGISTRY,
                  dwErr, 
                  GetW32Err(dwErr),
                  DSA_CONFIG_SECTION);
    }

    return(fRestored);
}


void SetConsoleAttrs (void)
{
    HANDLE hdlCons = GetStdHandle (STD_ERROR_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO scrInfo;
    HWINSTA hWindowStation;
    char WinStationName[1024];
    DWORD dwNameSize;
    BOOL fSkip;

    // SetConsoleScreenBufferSize() will mess up the telnet screen,
    // here we try to detect if the ntdsutil is in a telnet session,
    // if yes, we will skip SetConsoleScreenBufferSize()

    hWindowStation = GetProcessWindowStation();
    
    fSkip = GetUserObjectInformation(hWindowStation, 
                                     UOI_NAME, 
                                     WinStationName,
                                     1024, 
                                     &dwNameSize)
            && 
            !strcmp("TelnetSrvWinSta",WinStationName);
    
    if (   hdlCons != INVALID_HANDLE_VALUE && !fSkip ) {
            
        if (GetConsoleScreenBufferInfo (hdlCons, &scrInfo)) {
            scrInfo.dwMaximumWindowSize.Y = 9999;
            scrInfo.dwMaximumWindowSize.X = 80;
            
            SetConsoleScreenBufferSize (hdlCons, scrInfo.dwMaximumWindowSize);

        }
    } 
    // set buffers to NULL so as to be able to work under remote
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\parser\cargs.cxx ===
#include <NTDSpchX.h>
#pragma hdrstop
#include "parser.hxx"

CArgs::CArgs()
{
   _cArgs = 0;
   _cMax = 0;
   _rArgs = NULL;
}

CArgs::~CArgs()
{
   if ( _rArgs != NULL )
   {
      ASSERT(_cArgs > 0);

      for ( int i = 0; i < _cArgs; i++ )
      {
         if ( ARG_STRING == _rArgs[i].argType )
         {
            delete [] (void *) _rArgs[i].pwsz;
         }
      }

      delete [] _rArgs;
   }
}

#if DBG == 1
#define ARG_INCREMENT 1
#else
#define ARG_INCREMENT 10
#endif

HRESULT CArgs::MakeSpace()
{
   ASSERT(_cArgs <= _cMax);

   if ( _cArgs == _cMax )
   {
      _cMax += ARG_INCREMENT;

      Argument *tmp = new Argument [_cMax];

      if ( tmp == NULL )
      {
         return(E_OUTOFMEMORY);
      }

      if ( _cArgs > 0 )
      {
         memcpy(tmp,_rArgs,(_cArgs * sizeof(Argument)));
         delete [] _rArgs;
      }

      memset(&(tmp[_cArgs]),0,(ARG_INCREMENT * sizeof(Argument)));

      _rArgs = tmp;
   }

   return(S_OK);
}

HRESULT CArgs::Add(int i)
{
   HRESULT hr = MakeSpace();

   if ( FAILED(hr) )
      return(hr);

   _rArgs[_cArgs].argType = ARG_INTEGER;
   _rArgs[_cArgs].i = i;
   _cArgs++;

   return(S_OK);
}

HRESULT CArgs::Add(const WCHAR *pwsz)
{
   if ( (NULL == pwsz) || (0 == wcslen(pwsz)) )
      return(E_INVALIDARG);

   HRESULT hr = MakeSpace();

   if ( FAILED(hr) )
      return(hr);

   DWORD cBytes = sizeof(WCHAR) * (wcslen(pwsz) + 1);
   const WCHAR *p = (const WCHAR *) new BYTE [ cBytes ];

   if ( NULL == p )
      return(E_OUTOFMEMORY);

   wcscpy((WCHAR *) p,pwsz);
   _rArgs[_cArgs].argType = ARG_STRING;
   _rArgs[_cArgs].pwsz = p;
   _cArgs++;

   return(S_OK);
}

int CArgs::Count()
{
   return(_cArgs);
}

HRESULT CArgs::GetString(int i, const WCHAR **ppValue)
{
   if ( (i >= _cArgs) || (ARG_STRING != _rArgs[i].argType) )
   {
      return(E_INVALIDARG);
   }

   *ppValue = _rArgs[i].pwsz;

   return(S_OK);
}

HRESULT CArgs::GetInt(int i, int *pValue)
{
   if ( (i >= _cArgs) || (ARG_INTEGER != _rArgs[i].argType) )
   {
      return(E_INVALIDARG);
   }

   *pValue = _rArgs[i].i;

   return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\utilc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    utilc.c

Abstract:

    This module contains error management routines.  Takes an LDAP or
    Win32 error, and produces a string error message.

Author:

    Dave Straube (DaveStr) Long Ago

Environment:

    User Mode.

Revision History:

    16-Aug-2000     BrettSh
                Added this comment block, and allowed the DisplayErr()]
                and GetLdapErrorMessage to handle a variable LDAP handle.
        

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <assert.h>

#include "windows.h"
#include "winldap.h"
#include "reshdl.h"
#include "resource.h"

// GetWinErrorMessage assumes ntdsutil.exe is single threaded.
// Thus we can use a globally variable.

const WCHAR *pDefaultMsg = NULL;
const WCHAR *pExtComment = NULL;
const WCHAR *pW32Comment = NULL;
const WCHAR *pSuccessMsg = NULL;
PWCHAR pWinErrorMsg = NULL;

PWCHAR pLdapErrorMsg = NULL;
DWORD LdapErrLen = 0;
BOOL            fPopups = TRUE;

LDAP* gldapDS = NULL;


void InitErrorMessages ()
{
    pDefaultMsg = READ_STRING (IDS_NO_ERROR_MAPPING);
    pExtComment = READ_STRING (IDS_LDAP_EXT_ERROR);
    pW32Comment = READ_STRING (IDS_W32_ERROR);
    pSuccessMsg = READ_STRING (IDS_SUCCESS);
}

void FreeErrorMessages ()
{
    RESOURCE_STRING_FREE (pDefaultMsg);
    RESOURCE_STRING_FREE (pExtComment);
    RESOURCE_STRING_FREE (pW32Comment);
    RESOURCE_STRING_FREE (pSuccessMsg);

    if ( pWinErrorMsg )
    {
        LocalFree(pWinErrorMsg);
        pWinErrorMsg = NULL;
    }
    
    if ( pLdapErrorMsg != NULL ) {
        LocalFree(pLdapErrorMsg);
        pLdapErrorMsg = NULL;
        LdapErrLen = 0;
    }
}


const WCHAR * 
GetWinErrorMessage(
    DWORD winError
    )
{
    ULONG   len;
    DWORD   flags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;

    // Lazy dealloc of the message buffer.

    if ( pWinErrorMsg )
    {
        LocalFree(pWinErrorMsg);
        pWinErrorMsg = NULL;
    }

    len = FormatMessageW(   flags,
                            NULL,           // resource DLL
                            winError,
                            0,              // use caller's language
                            (LPWSTR) &pWinErrorMsg,
                            0,
                            NULL);

    if ( !pWinErrorMsg )
    {
        return(pDefaultMsg);
    }

    // Truncate cr/lf.

    pWinErrorMsg[len-2] = L'\0';
    return(pWinErrorMsg);
}

const WCHAR *
GetLdapErrorMessage(
    LDAP *     pLdap,
    DWORD      LdapError
    )
{
    DWORD err = 0;
    WCHAR *pmsg = NULL;
    ULONG   len = 0;
    HINSTANCE hwldap;
    static WCHAR strBuff[MAX_PATH];

    hwldap = LoadLibrary("wldap32.dll");
    if ( hwldap == NULL ) {
        goto output_default;
    }

    len = LoadStringW(hwldap, LdapError+1000, strBuff, MAX_PATH);
    if ( len == 0 ) {
        strBuff[0] = '\0';
    }

    // ldap_get_option can return success but without allocating memory for the 
    // error, so we have to check for this too.
    if ( ldap_get_optionW(pLdap, LDAP_OPT_SERVER_ERROR, &pmsg) == LDAP_SUCCESS ) {
        len += wcslen(pExtComment) + 16;
        if (pmsg) {
            len += wcslen(pmsg);
        }
    }

    if ( ldap_get_optionW(pLdap, LDAP_OPT_SERVER_EXT_ERROR, &err) == LDAP_SUCCESS ) {
        len += wcslen(pW32Comment) + 32 + wcslen(GetWinErrorMessage(err));
    }

    if ( len > 0 ) {

        INT i;
        len += 64;  // fudge

        if ( LdapErrLen < len ) {

            if ( pLdapErrorMsg != NULL ) {
                LocalFree(pLdapErrorMsg);
                pLdapErrorMsg = NULL;
                LdapErrLen = 0;
            }

            pLdapErrorMsg = LocalAlloc(LPTR, len * sizeof (WCHAR));
            if ( pLdapErrorMsg == NULL ) {
                goto output_default;
            }

            LdapErrLen = len;
        }


        if ( strBuff[0] != L'\0' ) {
            i = swprintf(pLdapErrorMsg, L"%d (%ws).\n", LdapError, strBuff);
        } else {
            i = swprintf(pLdapErrorMsg, L"%d.\n", LdapError);
        }

        if ( i <= 0 ) {
            goto output_default;
        }
        len = i;

        if ( pmsg != NULL ) {
            i = swprintf(pLdapErrorMsg + len, L"%ws %ws\n", pExtComment, pmsg);
            if ( i <= 0 ) {
                goto output_default;
            }
            len += i;
        }

        if ( err != ERROR_SUCCESS ) {
            i = swprintf(pLdapErrorMsg + len, L"%ws 0x%x(%ws)\n", 
                        pW32Comment, err, GetWinErrorMessage(err));

            if ( i <= 0 ) {
                goto output_default;
            }
        }

    } else {

output_default:
        if ( pmsg != NULL ) {
            ldap_memfreeW(pmsg);
        }
        (VOID) swprintf(strBuff,L"%d\n", LdapError);
        return strBuff;
    }

    if ( pmsg != NULL ) {
        ldap_memfreeW(pmsg);
    }

    return pLdapErrorMsg;
}


const WCHAR *
DisplayErr(
    IN LDAP *   pLdap,
    IN DWORD    Win32Err,
    IN DWORD    LdapErr
    )
{
    if ( Win32Err != ERROR_SUCCESS ) {
        return GetWinErrorMessage(Win32Err);
    } else if ( LdapErr != LDAP_SUCCESS ) {
        assert(pLdap);
        return GetLdapErrorMessage(pLdap, LdapErr);
    } else {
        return pSuccessMsg;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ntdsutil\utilc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    utilc.h

Abstract:

    This module contains error management routines.  Takes an LDAP or
    Win32 error, and produces a string error message.

Author:

    Dave Straube (DaveStr) Long Ago

Environment:

    User Mode.

Revision History:

    16-Aug-2000     BrettSh
                Added this comment block, also added the GetLdapErrEx()
                function to handle a variable LDAP handle.

--*/

#ifndef _UTILC_H_
#define _UTILC_H_

extern LDAP* gldapDS;
extern BOOL  fPopups;

const WCHAR *
DisplayErr(
    IN LDAP *   pLdap,
    IN DWORD Win32Err,
    IN DWORD LdapErr
    );

// from refc.c
BOOL
IsRdnMangled(
    IN  WCHAR * pszRDN,
    IN  DWORD   cchRDN,
    OUT GUID *  pGuid
    );


#define GetW32Err(_e)   DisplayErr(NULL, _e,0)
#define GetLdapErr(_e)  DisplayErr(gldapDS, 0,_e)
#define GetLdapErrEx(_ld, _e)  DisplayErr(_ld, 0, _e)

extern void InitErrorMessages ();
extern void FreeErrorMessages ();


#endif // _UTILC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\oid\oid.c ===
/********************************************************************/
/**               Copyright(c) Microsoft Corp., 1996               **/
/**                     All Rights Reserverd                       **/
/**                                                                **/
/** Author: DonH                                                   **/
/** Description: Tool to BER encode and decode OIDs                **/
/**                                                                **/
/********************************************************************/

#include <ntdspch.h>
#pragma hdrstop
#include <assert.h>

#define MAX_OID_VALS 15		// who knows?

typedef struct _OID {
    int cVal;
    unsigned Val[MAX_OID_VALS];
} OID;

/*++ EncodeOID
 *
 * Takes an OID in structure format and constructs a BER encoded octet
 * string representing that OID.
 *
 * INPUT:
 *    pOID     - Pointer to an OID structure to be encoded
 *    pEncoded - Pointer to a *preallocated* buffer that will hold the
 *               encoded octet string.  Sould be at least 4*MAX_OID_VALS long
 *
 * OUTPUT:
 *    pEncoded - Buffer holds the encoded OID
 *
 * RETURN VALUE:
 *    0        - Value could not be encoded (bad OID)
 *    non-0    - Length of resulting octet string, in bytes
 */
unsigned EncodeOID(OID *pOID, unsigned char * pEncoded){
    int i;
    unsigned len;
    unsigned val;

    // check for obviously invalid OIDs

    if (pOID->cVal <= 2 ||
	pOID->Val[0] > 2 ||
	pOID->Val[1] > 40) {
	return 0;		// error
    }

    // The first two values in the OID are encoded into a single octet
    // by a really appalling rule, as shown here.

    *pEncoded = (pOID->Val[0] * 40) + pOID->Val[1];
    len = 1;

    // For all subsequent values, each is encoded across multiple bytes
    // in big endian order (MSB first), seven bits per byte, with the
    // high bit being clear on the last byte, and set on all others.

    for (i=2; i<pOID->cVal; i++) {
	val = pOID->Val[i];

	if (val > ((0x7f << 14) | (0x7f << 7)| 0x7f)) {
	    // Do we need 4 octets to represent the value?
	    // Make sure it's not 5
	    assert(0 == (val & ~((0x7f << 21) | (0x7f << 14) | (0x7f << 7) | 0x7f)));
	    if (val & ~((0x7f << 21) | (0x7f << 14) | (0x7f << 7) | 0x7f)) {
		return 0;	// we can't encode things this big
	    }
	    pEncoded[len++] = 0x80 | ((val >> 21) & 0x7f);
	}
	if (val > ((0x7f << 7)| 0x7f)) {
	    // Do we need 3 octets to represent the value?
	    pEncoded[len++] = 0x80 | ((val >> 14) & 0x7f);
	}
	if (val > 0x7f) {
	    // Do we need 2 octets to represent the value?
	    pEncoded[len++] = 0x80 | ((val >> 7) & 0x7f);
	}
	// Encode the low 7 bits into the last octet for this value
	pEncoded[len++] = val & 0x7f;
    }

    return len;		
}

/*++ DecodeOID
 *
 * Takes a BER encoded OID as an octet string and returns the OID in 
 * structure format.
 *
 * INPUT:
 *    pEncoded - Pointer to a buffer holding the encoded octet string.
 *    len      - Length of the encoded OID
 *    pOID     - Pointer to a *preallocated* OID structure that will
 *               be filled in with the decoded OID.
 *
 * OUTPUT:
 *    pOID     - Structure is filled in with the decoded OID
 *
 * RETURN VALUE:
 *    0        - value could not be decoded (bad OID)
 *    non-0    - OID decoded successfully
 */
BOOL DecodeOID(unsigned char *pEncoded, int len, OID *pOID) {
    unsigned cval;
    unsigned val;
    int i, j;

    if (len <=2) {
	return FALSE;
    }

    // The first two values are encoded in the first octet.

    pOID->Val[0] = pEncoded[0] / 40;
    pOID->Val[1] = pEncoded[0] % 40;
    cval = 2;
    i = 1;

    while (i < len) {
	j = 0;
	val = pEncoded[i] & 0x7f;
	while (pEncoded[i] & 0x80) {
	    val <<= 7;
	    ++i;
	    if (++j > 4 || i >= len) {
		// Either this value is bigger than we can handle (we
		// don't handle values that span more than four octets)
		// -or- the last octet in the encoded string has its
		// high bit set, indicating that it's not supposed to 
		// be the last octet.  In either case, we're sunk.
		return FALSE;
	    }
	    val |= pEncoded[i] & 0x7f;
	}
	assert(i < len);
	pOID->Val[cval] = val;
	++cval;
	++i;
    }
    pOID->cVal = cval;

    return TRUE;
}



#define iswdigit(x) ((x) >= '0' && (x) <= '9')

OidStringToStruct( char * pString, unsigned len, OID * pOID)
{
    int i;
    unsigned val;
    char * pCur = pString;
    char * pEnd = pString + len;

    if ((*pCur != 'O' && *pCur != 'o') ||
	(*++pCur != 'I' && *pCur != 'i') ||
	(*++pCur != 'D' && *pCur != 'd') ||
	(*++pCur != '.')) {
	return 1;
    }

    pOID->cVal = 0;

    while (++pCur < pEnd) {
	if (!iswdigit(*pCur)) {
	    return 2;
	}
	val = *pCur - '0';
	++pCur;
	while (pCur < pEnd && *pCur != '.') {
	    if (!iswdigit(*pCur)) {
		return 3;
	    }
	    val = 10*val + *pCur - '0';
	    ++pCur;
	}
	pOID->Val[pOID->cVal] = val;
	pOID->cVal++;
    }

    return 0;
}

unsigned OidStructToString(OID *pOID, char *pOut)
{
    int i;
    char *pCur = pOut;

    *pCur++ = 'O';
    *pCur++ = 'I';
    *pCur++ = 'D';

    for (i=0; i<pOID->cVal; i++) {
	*pCur++ = '.';
	_ultoa(pOID->Val[i], pCur, 10);
	while (*pCur) {
	    ++pCur;
	}
    }
    return pCur - pOut;
}

#define HexToC(x) (((x) >= '0' && (x) <= '9') ? (x) - '0' : tolower((x)) - 'a' + 10)

void __cdecl main(int argc, char ** argv)
{
    OID oid;
    unsigned char buf[128];
    int i, len;
    char * p;

    if (argc != 2) {
	printf("usage: %s <oid>\nwhere <oid> is either "
	       "encoded ('550403') or not ('OID.2.5.4.3')\n", 
	       argv[0]);
	exit(__LINE__);
    }

    if (argv[1][0] == 'O' || argv[1][0] == 'o') {
	OidStringToStruct(argv[1], strlen(argv[1]), &oid);
	len = EncodeOID(&oid, buf);
	printf("encoded oid is: 0x");
	for (i=0; i<len; i++) {
	    printf("%02X", buf[i]);
	}
	printf("\n");
    }
    else {
	len = strlen(argv[1]);
	if (len % 2) {
	    printf("odd length string?\n");
	    exit(__LINE__);
	}

	p = argv[1];
	if ((p[0] == '\\' || p[0] == '0') &&
	    (p[1] == 'x')) {
	    len -= 2;
	    p += 2;
	}

	for (i=0; i<len; i+=2) {
	    buf[i/2] = HexToC(p[i]) * 16 + HexToC(p[i+1]);
	}

	DecodeOID(buf, len/2, &oid);
	i = OidStructToString(&oid, buf);
	buf[i] = '\0';
	printf("decoded oid is: %s\n", buf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\parser\cparser.cxx ===
#include <NTDSpchX.h>
#pragma hdrstop
#include <conio.h>
#include "parser.hxx"
#include "ctimer.hxx"

static WCHAR *pwszDelimiters = L" ";  // input delimiters - used by wcstok

#define MIN(x,y) ((x < y) ? x : y )
#define COMMENT_ESCAPE_STRING       "//"

//+-------------------------------------------------------------------
//
//  Member:    mywcstok
//
//  Synopsis:  A wrapper around the C library wcstok() to provide quoted token
//             support in a primitive fashion.
//
//  Effects:   None
//
//  Arguments: [pString] - pointer to string to be parsed, or NULL
//             [pDelim]  - pointer to string of delimiters
//
//  Algorithm: Replaces embedded spaces with FUNKY_WCHAR on first call, and
//             converts them back after wcstok has parsed the space-delimited
//             string.
//
//  History:   14-Dec-93	DaveStr		Genesis
//
//--------------------------------------------------------------------

#define FUNKY_WCHAR ((WCHAR) 0xffff)    // non-printable character used as
                                    // embedded space marker

static WCHAR *mywcstok(
	WCHAR *pString,
	WCHAR *pDelim)
{
   if ( pString != NULL )
   {
      BOOL fQuotes = FALSE;

      for ( WCHAR *p = pString; *p != L'\0'; p++ )
      {
         if ( *p == L'\"' )
         {
            fQuotes = !fQuotes;
            *p = ' ';
            continue;
         }

         if ( fQuotes == TRUE && *p == L' ' )
         {
            *p = FUNKY_WCHAR;
         }
      }
   }

   WCHAR *pRetVal = wcstok(pString,pDelim);

   if ( pRetVal != NULL )
   {
      for ( WCHAR *p = pRetVal; *p != L'\0'; p++ )
      {
         if ( *p == FUNKY_WCHAR )
         {
            *p = L' ';
         }
      }
   }

   return(pRetVal);
}

//+-------------------------------------------------------------------
//
//  Member:    CompareParseNode
//
//  Synopsis:  Compares two ParseNodes based on their pwszToken field.
//             Comparison is case-insensitive.
//             Passed as argument to qsort() and bsearch().
//
//  Effects:   None
//
//  Arguments: [pVoid1] pointer to first ParseNode
//             [pVoid2] pointer to second ParseNode
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:     None
//
//--------------------------------------------------------------------

int _cdecl CompareParseNode(const void *pVoid1,
                            const void *pVoid2)
{
   ParseNode *p1 = (ParseNode *) pVoid1;
   ParseNode *p2 = (ParseNode *) pVoid2;

   return(_wcsicmp(p1->pwszToken,p2->pwszToken));
}

//+-------------------------------------------------------------------
//
//  Member:    CompareParseNodePrefix
//
//  Synopsis:  Compares two ParseNodes based on their common pwszToken prefixes.
//             Comparison is case-insensitive.
//             Passed as argument to bsearch().
//
//  Effects:   None
//
//  Arguments: [pVoid1] pointer to first ParseNode
//             [pVoid2] pointer to second ParseNode
//
//  Algorithm: Calls wcsnicmp().
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:     None
//
//--------------------------------------------------------------------

int _cdecl CompareParseNodePrefix(const void *pVoid1,
                                   const void *pVoid2)
{
   ParseNode *p1 = (ParseNode *) pVoid1;
   ParseNode *p2 = (ParseNode *) pVoid2;

   int l1 = wcslen(p1->pwszToken);
   int l2 = wcslen(p2->pwszToken);

   return(_wcsnicmp(p1->pwszToken,p2->pwszToken,MIN(l1,l2)));
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::CParser
//
//  Synopsis:  Constructor
//
//  Effects:   None
//
//  Arguments: None
//
//  Algorithm: Zeros all member variables.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:     None
//
//--------------------------------------------------------------------

CParser::CParser()
{
   _cNodes = 0;
   _cMax = 0;
   _rNodes = NULL;
   _pExprChain = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::~CParser
//
//  Synopsis:  Destructor
//
//  Effects:   None
//
//  Arguments: None
//
//  Algorithm: "delete"s all pointers alocated by "new".
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:     None
//
//--------------------------------------------------------------------

CParser::~CParser()
{
   for ( int i = 0; i < _cNodes; i++ )
   {
      if ( _rNodes[i].pChild != NULL )
      {
         delete _rNodes[i].pChild;
      }
   }

   if ( _cNodes > 0 )
   {
      delete [] _rNodes;
   }

   while ( NULL != _pExprChain )
   {
      ParserExpr *px = _pExprChain;

      _pExprChain = _pExprChain->pNext;
      delete [] px;
   }
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::_FindToken
//
//  Synopsis:  Finds a token and adds it it to the CArgs argument.
//             CArgs pointer may be NULL.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::_FindToken(WCHAR *pwszToken,
                            int *pIndex,
                            CArgs *pArgs,
                            int matchType,
                            int *pStatus)
{
   HRESULT hr;

   ASSERT((matchType == FULL_MATCH) || (matchType == PREFIX_MATCH));
   ASSERT(pwszToken);

   ParseNode testNode;
   ParseNode *pFoundNode;

   BOOL prefixMatched = FALSE;

   
   if ( wcslen(pwszToken) >= TOKEN_LENGTH )
   {
      // definitely won't match any real tokens but might still match %d or %s

      goto PatternMatch;
   }

   // first search for literal token

   wcscpy(testNode.pwszToken,pwszToken);

   if ( matchType == FULL_MATCH )
   {
      pFoundNode = (ParseNode *) bsearch((void *) &testNode,
                                         (void *) _rNodes,
                                         (size_t) _cNodes,
                                         (size_t) sizeof(ParseNode),
                                         CompareParseNode);

      if ( pFoundNode != NULL )
      {
         *pIndex = (INT)(pFoundNode - _rNodes);
         *pStatus = TOKEN_FOUND;
         return(S_OK);
      }
   }
   else
   {
      pFoundNode = (ParseNode *) bsearch((void *) &testNode,
                                         (void *) _rNodes,
                                         (size_t) _cNodes,
                                         (size_t) sizeof(ParseNode),
                                         CompareParseNodePrefix);
      // PREFIX: 'testNode' may be used without being initialized if 
      // pwszToken==0.  However, the callers of this function will never call
      // with pwszToken==0.

      if ( pFoundNode != NULL )
      {
         // A match was found.  But we don't know if pwszToken is shorter
         // than the node value or the other way around.  pwszToken needs
         // to be a prefix of the node for a valid match.

         int i = (INT)(pFoundNode - _rNodes);

         int len = wcslen(pwszToken);

         if ( len <= (int) wcslen(_rNodes[i].pwszToken) )
         {
            // make sure no neighbors have the same prefix

            if ( ( (i == 0) ||
                   _wcsnicmp(pwszToken,_rNodes[i-1].pwszToken,len) )
                 &&
                 ( (i == (_cNodes-1)) ||
                   _wcsnicmp(pwszToken,_rNodes[i+1].pwszToken,len) ) )
            {
               *pIndex = i;
               *pStatus = TOKEN_FOUND;
               return(S_OK);
            }
            else
            {
               // we had an ambiguous prefix match - save for later
               // error reporting

               prefixMatched = TRUE;
            }
         }
      }
   }

PatternMatch:

   // next try for %d
   // do this before matching against %s since any string will match it

   wcscpy(testNode.pwszToken,L"%d");

   pFoundNode = (ParseNode *) bsearch((void *) &testNode,
                                      (void *) _rNodes,
                                      (size_t) _cNodes,
                                      (size_t) sizeof(ParseNode),
                                      CompareParseNode);

   if ( pFoundNode != NULL )
   {
      WCHAR tmp[MAX_PATH];
      int i;

      // following swscanf insures we don't accept numbers with trailing garbage

      if ( swscanf(pwszToken,L"%d%s",&i,tmp) == 1 )
      {
         if ( pArgs != NULL )
         {
            hr = pArgs->Add(i);

            if ( FAILED(hr) )
               return(hr);
         }

         *pIndex = (INT)(pFoundNode - _rNodes);
         *pStatus = TOKEN_INTEGER;
         return(S_OK);
      }
   }

   // next try for %s

   wcscpy(testNode.pwszToken,L"%s");

   pFoundNode = (ParseNode *) bsearch((void *) &testNode,
                                      (void *) _rNodes,
                                      (size_t) _cNodes,
                                      (size_t) sizeof(ParseNode),
                                      CompareParseNode);

   if ( pFoundNode != NULL )
   {
      if ( pArgs != NULL )
      {
         hr = pArgs->Add(pwszToken);

         if ( FAILED(hr) )
            return(hr);
      }

      *pIndex = (INT)(pFoundNode - _rNodes);
      *pStatus = TOKEN_STRING;
      return(S_OK);
   }

   if ( prefixMatched == TRUE )
   {
      *pStatus = PREFIX_NOT_UNIQUE;
   }
   else
   {
      *pStatus = TOKEN_NOT_FOUND;
   }

   return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::_InsertToken
//
//  Synopsis:  Insert a new token and return its index.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::_InsertToken(WCHAR *pwszToken,
                              int *pIndex)
{
   HRESULT hr;

   if ( (NULL == pwszToken) || (0 == wcslen(pwszToken)) )
     return(E_INVALIDARG);

   if ( wcslen(pwszToken) >= TOKEN_LENGTH )
      return(E_INVALIDARG);

   int result;

   if ( FAILED(hr = _FindToken(pwszToken,pIndex,NULL,FULL_MATCH,&result)) )
      return(hr);

   if ( TOKEN_FOUND == result )
      return(E_INVALIDARG);

   if ( FAILED(hr = MakeSpace()) )
      return(hr);

   wcscpy(_rNodes[_cNodes++].pwszToken,pwszToken);

   qsort((void *) _rNodes,
         (size_t) _cNodes,
         (size_t) sizeof(ParseNode),
         CompareParseNode);

   // qsort may have moved the index - find it again

   if ( FAILED(hr = _FindToken(pwszToken,pIndex,NULL,FULL_MATCH,&result)) )
      return(hr);

   ASSERT(result == TOKEN_FOUND);

   return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::AddExpr
//
//  Synopsis:  Add an entire expression (sentence) to the parser.
//
//  History:   01-Sep-93	DaveStr		Genesis
//             04-Aug-95    DaveStr     read-only data segment workaround
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::AddExpr(WCHAR *pwszExpr,
                         HRESULT (*pFunc)(CArgs *pArgs),
                         const WCHAR *pwszHelp)
{
   if ( (NULL == pwszExpr) ||
        (0 == wcslen(pwszExpr)) ||
        (NULL == pFunc) )
   {
      return(E_INVALIDARG);
   }

   ULONG cBytes = sizeof(ParserExpr) +
                  (sizeof(WCHAR) * (1 + wcslen(pwszExpr)));

   ParserExpr *px = (ParserExpr *) new BYTE [ cBytes ];

   if ( NULL == px )
      return(E_OUTOFMEMORY);

   wcscpy(px->expr, pwszExpr);
   px->pNext = _pExprChain;
   _pExprChain = px;

   WCHAR *pwszToken = mywcstok(px->expr,pwszDelimiters);

   if ( pwszToken == NULL )
   {
      // Attempt to add expression with no tokens.

      return(E_INVALIDARG);
   }

   return(this->_AddToken(pwszToken,pFunc,pwszHelp));
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::_AddToken
//
//  Synopsis:  Add a single token to the parser.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::_AddToken(WCHAR *pwszToken,
                           HRESULT (*pFunc)(CArgs *pArgs),
                           const WCHAR *pwszHelp)
{
   HRESULT hr;

   // Args should have been checked in AddExpr().

   WCHAR *pwszNextToken = mywcstok(NULL,pwszDelimiters);

   int i, result;

   if ( FAILED(hr = _FindToken(pwszToken,&i,NULL,FULL_MATCH,&result)) )
      return(hr);

   if ( result != TOKEN_FOUND )
   {
      hr = _InsertToken(pwszToken,&i);

      if ( FAILED(hr) )
         return(hr);
   }

   if ( pwszNextToken == NULL )
   {
      if ( _rNodes[i].pFunc == NULL )
      // PREFIX: 'i' may be used uninitialized.
      // The complaint is: when above _FindToken() fails, the _InsertToken() call may
      // succeed with 'i' uninitialized.  This is impossible. In function _InsertToken(), 
      // the second _FindToken() call is after the new token is inserted and qsort(), 
      // it must succeed with a valid 'pIndex'. Therefore, 'i' must be given a value 
      // in above _InsertToken() call.
      {
         _rNodes[i].pFunc = pFunc;
         _rNodes[i].pwszHelp = pwszHelp;
         return(S_OK);
      }
      else
      {
         // Duplicate expression/function definition.

         return(E_INVALIDARG);
      }
   }
   else
   {
      if ( _rNodes[i].pChild == NULL )
      {
         _rNodes[i].pChild = new CParser;

         if ( NULL == _rNodes[i].pChild )
            return(E_OUTOFMEMORY);
      }

      return(_rNodes[i].pChild->_AddToken(pwszNextToken,pFunc,pwszHelp));
   }

   return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::Dump
//
//  Synopsis:  Dumps all tokens with the given prefix.  Prefix of "" OK.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::Dump(FILE *pFile,
                      WCHAR *pwszPrefix)
{
   if ( (NULL == pFile) || (NULL == pwszPrefix) )
      return(E_INVALIDARG);

   if ( _cNodes == 0 )
   {
      fwprintf(pFile,L"No language defined\n");
      return(S_OK);;
   }

   fprintf(pFile,"\n");
   HRESULT hr = this->_Dump(pFile,pwszPrefix);
   fprintf(pFile,"\n");

   return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::_Dump
//
//  Synopsis:
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::_Dump(FILE *pFile,
                       WCHAR *pwszPrefix)
{
   WCHAR *pwszExpr = new WCHAR [ wcslen(pwszPrefix) + TOKEN_LENGTH + 2 ];

   if ( NULL == pwszExpr )
      return(E_OUTOFMEMORY);

   for ( int i = 0; i < _cNodes; i++ )
   {
      swprintf(pwszExpr,L"%s %s",pwszPrefix,_rNodes[i].pwszToken);

      if ( _rNodes[i].pFunc != NULL )
      {
         const WCHAR *pwszHelp;

         if ( _rNodes[i].pwszHelp != NULL )
         {
            pwszHelp = _rNodes[i].pwszHelp;
         }
         else
         {
            pwszHelp = L"(no description)";
         }
         fwprintf(pFile,L"%-30s - %s\n",pwszExpr,pwszHelp);
      }

      if ( _rNodes[i].pChild != NULL )
      {
         _rNodes[i].pChild->_Dump(pFile,pwszExpr);
      }
   }

   delete pwszExpr;

   return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::_ParseToken
//
//  Synopsis:
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::_ParseToken(WCHAR *pwszToken,
                             CArgs *pArgs)
{
   HRESULT hr;

   if ( _IsPattern(pwszToken,NULL) == TRUE )
   {
      return(E_INVALIDARG);
   }

   int i, result;

   hr = _FindToken(pwszToken,&i,pArgs,PREFIX_MATCH,&result);

   if ( FAILED(hr) )
      return(hr);

   if ( result == PREFIX_NOT_UNIQUE )
   {
      return(E_INVALIDARG);
   }

   if ( result == TOKEN_NOT_FOUND )
   {
      return(E_INVALIDARG);
   }

   WCHAR *pwszNextToken = mywcstok(NULL,pwszDelimiters);

   if ( pwszNextToken == NULL )
   {
      if ( _rNodes[i].pFunc == NULL )
      {
         return(E_INVALIDARG);
      }
      else
      {
         __try
         {
            hr = (*_rNodes[i].pFunc)(pArgs);
         }
         __except(EXCEPTION_EXECUTE_HANDLER)
         {
            hr = HRESULT_FROM_NT(GetExceptionCode());
         }

         return(hr);
      }
   }
   else
   {
      if ( _rNodes[i].pChild == NULL )
      {
         return(E_INVALIDARG);
      }
      else
      {
         return(_rNodes[i].pChild->_ParseToken(pwszNextToken,pArgs));
      }
   }

   // should never get here ...

   return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::Parse
//
//  Synopsis:  Parse and execute an expression.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::Parse(WCHAR *pwszExpr,
                       TimingInfo *pInfo)
{
   HRESULT hr;

   CTimer timer;

   if ( pwszExpr == NULL )
   {
      hr = E_INVALIDARG;
   }
   else
   {
      WCHAR *pwszToken = mywcstok(pwszExpr,pwszDelimiters);

      if ( pwszToken == NULL )
      {
         // empty expression is OK - return warning

         hr = (S_OK | ERROR_SEVERITY_WARNING);
      }
      else
      {
         CArgs args;

         hr = this->_ParseToken(pwszToken,&args);
      }
   }

   if ( NULL != pInfo )
      timer.ReportElapsedTime(pInfo);

   return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::_IsPattern
//
//  Synopsis:  Determine if a string is a pattern or not.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

BOOL CParser::_IsPattern(WCHAR *pwsz,
                         int *pPatternType)
{
   if ( 0 == _wcsicmp(L"%s",pwsz) )
   {
      if ( pPatternType != NULL )
      {
         *pPatternType = PATTERN_STRING;
      }
      return(TRUE);
   }

   if ( 0 == _wcsicmp(L"%d",pwsz) )
   {
      if ( pPatternType != NULL )
      {
         *pPatternType = PATTERN_INTEGER;
      }
      return(TRUE);
   }

   return(FALSE);
}

#ifdef DEBUG
#define TOKEN_INCREMENT 1
#else
#define TOKEN_INCREMENT 10
#endif

//+-------------------------------------------------------------------
//
//  Member:    CParser::MakeSpace
//
//  Synopsis:  Grow a parse node to hold more tokens.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::MakeSpace()
{
   ASSERT(_cNodes <= _cMax);

   if ( _cNodes == _cMax )
   {
      _cMax += TOKEN_INCREMENT;

      ParseNode *tmp = new ParseNode [_cMax];

      if ( tmp == NULL )
      {
         return(E_OUTOFMEMORY);
      }

      if ( _cNodes > 0 )
      {
         memcpy(tmp,_rNodes,(_cNodes * sizeof(ParseNode)));
         delete [] _rNodes;
      }

      memset(&(tmp[_cNodes]),0,(TOKEN_INCREMENT * sizeof(ParseNode)));

      _rNodes = tmp;
   }

   return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::Parse
//
//  Synopsis:  Parse console input and any command line arguments.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::Parse(int  *pargc,
                       CHAR **pargv[],
                       FILE *pFileIn,
                       FILE *pFileOut,
                       const WCHAR *pPrompt,
                       BOOL *pfQuit,
                       BOOL fTiming,
                       BOOL fQuitOnError)
{
   HRESULT hr;

   if ( (NULL == pFileIn) || (NULL == pFileOut) )
      return(E_INVALIDARG);

   // main() may be invoked with multiple arguments, each of which is considered
   // a command to be executed.  If the last agument in the sequence is "quit",
   // the program exits.  If not, the program executes all the command line
   // supplied commands and then hangs out in interactive mode.

   // Note that commands with spaces in them should be quoted.  For example:
   //
   //	foo.exe "bind x:\gc.sc" "dump gt" quit

   while ( !*pfQuit )
   {
      CHAR Expr[1000];
      WCHAR wExpr[1000];
      CHAR *p;

      if ( NULL != pPrompt )
         fprintf(pFileOut,"%ws ", pPrompt);

      if ( pargc && *pargc && pargv && *pargv && **pargv)
      {
         // next expression is in *argv

         strncpy(Expr,**pargv,1000);
         Expr[999] = '\0';
         (*pargc)--;
         (*pargv)++;

         if ( NULL != pPrompt )
            fprintf(pFileOut,"%s\n",Expr);
      }
      else
      {
         // argv[] expressions exhausted.  Start reading from pFileIn.

         if ( NULL == (p = fgets(Expr,1000,pFileIn)) )
         {
            hr = S_OK;
            int error = ferror(pFileIn);

            if ( 0 != error )
            {
               hr = HRESULT_FROM_WIN32(error);

               if ( NULL != pPrompt )
                  fprintf(pFileOut, "Error %08lx reading input\n", hr);
            }

            return(hr);
         }

         int len = strlen(Expr);

         if ( len > 0 )
         {
            //
            // find first occurance of comment escape & repl by '\0'
            //
            LPTSTR pComment = strstr(Expr, COMMENT_ESCAPE_STRING);
            if(pComment){
               // terminate to ignore comment
               *pComment = '\0';
               // recalc new len
               len = (Expr[0] == '\0') ? 0 : strlen(Expr);
            }
            else if ( Expr[len-1] == '\n' ){
            // Strip off trailing new line.
               Expr[len-1] = '\0';
            }

         }
         //
         // re-present cmd prompt on empty input
         //
         if(len == 0 || Expr[0] == '\0'){
            continue;
         }
      }

      // Expr now holds next expression to parse.

      mbstowcs(wExpr,Expr,1000);
      wExpr[999] = L'\0';

      TimingInfo info;

      hr = Parse(wExpr,&info);

      if ( FAILED(hr) && (NULL != pPrompt) )
      {
         fprintf(pFileOut,"Error %08lx parsing input - illegal syntax?\n", hr);

         if ( fQuitOnError )
            return(hr);
      }

      if ( fTiming  && (NULL != pPrompt) )
      {
         fprintf(pFileOut,"\n");

         if ( info.msUser.HighPart == 0 )
            fprintf(pFileOut,"\tuser:          %lu ms\n",info.msUser.LowPart);
         else
            fprintf(pFileOut,"\tuser:          *** out of range ***\n");

         if ( info.msKernel.HighPart == 0 )
            fprintf(pFileOut,"\tkernel:        %lu ms\n", info.msKernel.LowPart);
         else
            fprintf(pFileOut,"\tkernel:        *** out of range ***\n");

         if ( info.msTotal.HighPart == 0 )
            fprintf(pFileOut,"\tuser + kernel: %lu ms\n\n",info.msTotal.LowPart);
         else
            fprintf(pFileOut,"\tuser + kernel: *** out of range ***\n\n");
      }
   }

   return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\parser\utest\main.cxx ===
#include <NTDSpch.h>
#pragma hdrstop
#include "parser.hxx"

CParser parser;
BOOL fQuit;

// Expression 1: "What time is it"

HRESULT Expr1Implementation(CArgs *pArgs)
{
    SYSTEMTIME sysTime;

    GetLocalTime(&sysTime);

    printf("The time is: %02d/%02d/%04d @ %02d:%02d:%02d:%04d\n",
           sysTime.wDay,
           sysTime.wMonth,
           sysTime.wYear,
           sysTime.wHour,
           sysTime.wMinute,
           sysTime.wMinute,
           sysTime.wMilliseconds);

    return(S_OK);
}

// Expression 2: "What is %d x %d"

HRESULT Expr2Implementation(CArgs *pArgs)
{
    int i0,i1;
    HRESULT hr;

    if ( FAILED(hr = pArgs->GetInt(0,&i0)) )
        return(hr);

    if ( FAILED(hr = pArgs->GetInt(1,&i1)) )
        return(hr);

    printf("%d x %d --> %d\n", 
           i0, 
           i1, 
           i0 * i1);
    
    return(S_OK);
}

// Expression 3: "Reverse the string %s"

HRESULT Expr3Implementation(CArgs *pArgs)
{
    const WCHAR *p;
    HRESULT hr;

    if ( FAILED(hr = pArgs->GetString(0,&p)) )
        return(hr);

    int l = wcslen(p);

    WCHAR *pReverse = new WCHAR [ l + 1 ];

    if ( NULL == pReverse )
        return(E_OUTOFMEMORY);

    for ( int i = 0; i < l; i++ )
    {
        WCHAR c = p[i];
        pReverse[i]  = p[l-i-1];
        pReverse[l-i-1] = c;
    }

    pReverse[l] = L'\0';

    printf("%ws <--> %ws\n",
           p,
           pReverse);

    delete [] pReverse;

    return(S_OK);
}

// Expression 4: "Help"

HRESULT Expr4Implementation(CArgs *pArgs)
{
    return(parser.Dump(stdout,L""));
}

// Expression 5: "Quit"

HRESULT Expr5Implementation(CArgs *pArgs)
{
    fQuit = TRUE;
    return(S_OK);
}

// Build a table which defines our language.

typedef struct _LegalExpr {
   WCHAR       *expr;
   HRESULT    (*func)(CArgs *pArgs);
   WCHAR       *help;
} LegalExpr;

LegalExpr language[] = 
{
    {   L"What time is it",
        Expr1Implementation,
        L"Prints the current date and time" },

    {   L"What is %d x %d",
        Expr2Implementation,
        L"Multiplies two integers" },

    {   L"Reverse the string %s",
        Expr3Implementation,
        L"Reverses the specified string" },

    {   L"Help",
        Expr4Implementation,
        L"Prints this help information" },

    {   L"?",
        Expr4Implementation,
        L"Prints this help information" },

    {   L"Quit",
        Expr5Implementation,
        L"Ends parsing" }
};

int _cdecl main(int argc, char *argv[])
{
    HRESULT hr;

    int cExpr = sizeof(language) / sizeof(LegalExpr);

    for ( int i = 0; i < cExpr; i++ )
    {
        if ( FAILED(hr = parser.AddExpr(language[i].expr,
                                        language[i].func,
                                        language[i].help)) )
        {
            printf("AddExpr error %08lx\n", hr);
            return(hr);
        }
    }

    fQuit = FALSE;

    // advance past program name
    argc -= 1;
    argv += 1;

    hr = parser.Parse(&argc,
                      &argv,
                      stdin,
                      stdout,
                      "Parser unit test:",
                      &fQuit,
                      TRUE,                 // timing info
                      FALSE);               // quit on error

    if ( FAILED(hr) )
        printf("Unit test error %08lx\n", hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\parser\ctimer.cxx ===
#include <NTDSpchX.h>
#pragma hdrstop

#include "parser.hxx"
#include "ctimer.hxx"

CTimer::CTimer()
{
   _hProcess = GetCurrentProcess();

   FILETIME ftCreate, ftExit;

   _fGoodProcInfo = GetProcessTimes(_hProcess,
					&ftCreate,
					&ftExit,
					&_ftKernel0,
					&_ftUser0);
}

void CTimer::ReportElapsedTime(TimingInfo *pInfo)
{
   if ( NULL == pInfo )
      return;

   pInfo->msUser.LowPart = 0xBAD;
   pInfo->msUser.HighPart = 0xBAD;
   pInfo->msKernel.LowPart = 0xBAD;
   pInfo->msKernel.HighPart = 0xBAD;
   pInfo->msTotal.LowPart = 0xBAD;
   pInfo->msTotal.HighPart = 0xBAD;

   FILETIME ftCreate, ftExit, ftKernel1, ftUser1;

   if ( _fGoodProcInfo )
   {
      _fGoodProcInfo = GetProcessTimes(_hProcess,
					&ftCreate,
					&ftExit,
					&ftKernel1,
					&ftUser1);

      if ( _fGoodProcInfo )
      {
         LARGE_INTEGER *pliKernel0 = (LARGE_INTEGER *) &_ftKernel0;
         LARGE_INTEGER *pliKernel1 = (LARGE_INTEGER *) &ftKernel1;
         LARGE_INTEGER *pliUser0 = (LARGE_INTEGER *) &_ftUser0;
         LARGE_INTEGER *pliUser1 = (LARGE_INTEGER *) &ftUser1;

         LARGE_INTEGER liKernel;
         liKernel.QuadPart = pliKernel1->QuadPart - pliKernel0->QuadPart;
         LARGE_INTEGER liUser;
         liUser.QuadPart = pliUser1->QuadPart - pliUser0->QuadPart;
         LARGE_INTEGER liTotal;
         liTotal.QuadPart = liKernel.QuadPart - liUser.QuadPart;

         LARGE_INTEGER liPercentUser = { 0, 0 };
         LARGE_INTEGER liPercentKernel = { 0, 0 };

         if ( liTotal.QuadPart != 0 )
         {
            liPercentKernel = RtlExtendedIntegerMultiply(liKernel,100);

            liPercentKernel.QuadPart = liPercentKernel.QuadPart / liTotal.QuadPart;

            liPercentUser = RtlExtendedIntegerMultiply(liUser,100);

            liPercentUser.QuadPart = liPercentUser.QuadPart / liTotal.QuadPart;
         }

         // convert all times to ms

         ULONG ulRemainder;
         liKernel = RtlExtendedLargeIntegerDivide(liKernel,10000,&ulRemainder);
         liUser = RtlExtendedLargeIntegerDivide(liUser,10000,&ulRemainder);

         // package it up

         pInfo->msUser = liUser;
         pInfo->msKernel = liKernel;
         pInfo->msTotal.QuadPart = liKernel.QuadPart + liUser.QuadPart;

      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\perfdsa\perftest.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       perftest.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <conio.h>
#include "ntdsctr.h"

TCHAR szMappedObject[] = TEXT("MICROSOFT_DSA_COUNTER_BLOCK");
//PPERF_COUNTER_BLOCK     pCounterBlock;  // data structure for counter values
unsigned long *     pCounterBlock;  // data structure for counter values


void _cdecl main()
{
    HANDLE hMappedObject;
    int c, fRun = 1;
    
    /*
     *  create named section for the performance data
     */
    hMappedObject = CreateFileMapping(
        (HANDLE) (-1),
	NULL,
	PAGE_READWRITE,
	0,
	4096,
	szMappedObject);
    if (hMappedObject == NULL) {
	/* Should put out an EventLog error message here */
	printf("DSA: Could not Create Mapped Object for Counters %x",
	    GetLastError());
	pCounterBlock = NULL;
    }
    else {
	/* Mapped object created okay
	 *
         * map the section and assign the counter block pointer
         * to this section of memory
         */
	pCounterBlock = (unsigned long *) MapViewOfFile(hMappedObject,
	    FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if (pCounterBlock == NULL) {
	    /* Failed to Map View of file */
	    printf("DSA: Failed to Map View of File %x",
		GetLastError());
	}
    }

    /*
     * Ok, now sit around in a loop reading keystrokes
     */
    do {
	c = _getch();
	printf("Incrementing ");
	switch (c) {
	case 'v':
	case 'V':
	    pCounterBlock[(ACCVIOL >> 1) - 1]++;
	    printf("access violation");
	    break;
	case 'b':
	case 'B':
	    pCounterBlock[(BROWSE >> 1) - 1]++;
	    printf("browse");
	    break;
	case 'd':
	case 'D':
	    pCounterBlock[(ABREAD >> 1) - 1]++;
	    printf("AB details");
	    break;
	case 'r':
	case 'R':
	    pCounterBlock[(DSREAD >> 1) - 1]++;
	    printf("ds_read");
	    break;
	case 'e':
	case 'E':
	    pCounterBlock[(REPL >> 1) - 1]++;
	    printf("replication");
	    break;
	case 't':
	case 'T':
	    pCounterBlock[(THREAD >> 1) - 1]++;
	    printf("thread count");
	    break;
	case 'w':
	case 'W':
	    pCounterBlock[(ABWRITE >> 1) - 1]++;
	    printf("AB write");
	    break;
	case 'm':
	case 'M':
	    pCounterBlock[(DSWRITE >> 1) - 1]++;
	    printf("ds_modify, add, or remove");
	    break;
	case 'q':
	case 'Q':
	    printf("nothing, quiting now\n");
	    fRun = 0;
	    break;
	default:
	    printf("\rWhat the heck does '%c' mean?\n", c);
	    continue;
	};
	printf("\n");
    } while (fRun);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\perfdsa\datadsa.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       datadsa.h
//
//--------------------------------------------------------------------------

/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

      datadsa.h

Abstract:

    Header file for the DSA Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

   Don Hacherl 25 June 1993

Revision History:


--*/

#ifndef _DATADSA_H_
#define _DATADSA_H_

/****************************************************************************\
                                                                April 21, 1998
                                                                wlees

           Adding a Counter to the Extensible Objects Code

Note that the order or position of counters is significant.
There are two orders which are important, the order of counters indexes for
names and help, and the order of data in the shared data block for passing
your values.
You want to maintain consistent counter order, and consistent data layout,
across all five files to be modified.

You want to make sure that your binary matches the .h/.ini file on the target,
which gets loaded in to the registry.

1. nt\private\ds\src\dsamain\include\ntdsctr.h
This file is copied to the system32 directory of the target along with the
ntdsctrs.ini file.
a. Add your counter offset at the end of the counter name list. Order
significant.  If your counter is the last one, change DSA_LAST_COUNTER_INDEX
accordingly.
b. Add an extern reference for the pointer which the actual code will use
to set the measured value. Order doesn't matter.
c. Change the ntds peformance counter version number so the counters will
be reloaded on the next reboot.

2. nt\private\ds\src\perfdsa\ntdsctrs.ini
This file is also copied to the system32 directory of the target and is read
by the lodctr/unlodctr program to copy the counters in the registry
a. Supply your counter visible name and help.  These are used by the perfmon
program. Order doesn't matter.

3. nt\private\ds\src\perfdsa\datadsa.h (this file)
a. Add your data offset definition. Order significant.
b. Add a field to the DSA_DATA_DEFINITION for your counter. Order significant.

4. \nt\private\ds\src\perfdsa\perfdsa.c
This is the dll which perfmon uses to learn about your counters, and to read
them out of the shared data area.
a. Update the huge initializer for the DsaDataDefinition array of counters to
   include your new counter (defined in 3b). Order important.

5. \nt\private\ds\src\dsamain\src\dsamain.c
This file initializes the ds.  It loads the shared memory block and initializes
pointers to the counter fields.  It also loads/reloads the registry counters
as necessary according the version field.
a. Declare the pointer to the data in your counter. Order does not matter.
b. Initialize the pointer to the right location in the shared data block.
   Order of assignments doesn't matter.
c. Initialize your pointer to the dummy value on error

6. yourfile.c
This is the file in the ntdsa where the measured counter is changed.
Use ISET/IADJUST operations in ntdsctr.h on the pointer to your data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to Get<object>PerfomanceData
on return from that routine.

\****************************************************************************/

//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define DSA_NUM_PERF_OBJECT_TYPES 1

//----------------------------------------------------------------------------

//
//  DSA Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//
//  The first counter (ACCVIOL) follows immediately after the
//  PERF_COUNTER_BLOCK, and subsequent counters follow immediately
//  after.  Thus the offest of any counter in the block is <offset of
//  previous counter> + <size of previous counter>

typedef struct _DSA_COUNTER_DATA {
    PERF_COUNTER_BLOCK  cb;    
    DWORD               dwPad;
} DSA_COUNTER_DATA;

#define NUM_DRA_IN_PROPS_OFFSET        sizeof(DSA_COUNTER_DATA)
#define NUM_BROWSE_OFFSET       NUM_DRA_IN_PROPS_OFFSET + sizeof(DWORD)
#define NUM_REPL_OFFSET         NUM_BROWSE_OFFSET + sizeof(DWORD)
#define NUM_THREAD_OFFSET       NUM_REPL_OFFSET + sizeof(DWORD)
#define NUM_ABCLIENT_OFFSET     NUM_THREAD_OFFSET + sizeof(DWORD)
#define NUM_PENDSYNC_OFFSET     NUM_ABCLIENT_OFFSET + sizeof(DWORD)
#define NUM_REMREPUPD_OFFSET    NUM_PENDSYNC_OFFSET + sizeof(DWORD)
#define NUM_SDPROPS_OFFSET      NUM_REMREPUPD_OFFSET + sizeof(DWORD)
#define NUM_SDEVENTS_OFFSET     NUM_SDPROPS_OFFSET + sizeof(DWORD)
#define NUM_LDAPCLIENTS_OFFSET  NUM_SDEVENTS_OFFSET + sizeof(DWORD)
#define NUM_LDAPACTIVE_OFFSET   NUM_LDAPCLIENTS_OFFSET + sizeof(DWORD)
#define NUM_LDAPWRITE_OFFSET    NUM_LDAPACTIVE_OFFSET + sizeof(DWORD)
#define NUM_LDAPSEARCH_OFFSET   NUM_LDAPWRITE_OFFSET + sizeof(DWORD)
#define NUM_DRAOBJSHIPPED_OFFSET                        NUM_LDAPSEARCH_OFFSET + sizeof(DWORD)
#define NUM_DRAPROPSHIPPED_OFFSET                       NUM_DRAOBJSHIPPED_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_VALUES_OFFSET                        NUM_DRAPROPSHIPPED_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCREQUESTMADE_OFFSET                   NUM_DRA_IN_VALUES_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCREQUESTSUCCESSFUL_OFFSET             NUM_DRASYNCREQUESTMADE_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCREQUESTFAILEDSCHEMAMISMATCH_OFFSET   NUM_DRASYNCREQUESTSUCCESSFUL_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCOBJRECEIVED_OFFSET                   NUM_DRASYNCREQUESTFAILEDSCHEMAMISMATCH_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCPROPUPDATED_OFFSET                   NUM_DRASYNCOBJRECEIVED_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCPROPSAME_OFFSET                      NUM_DRASYNCPROPUPDATED_OFFSET + sizeof(DWORD)
#define NUM_MONLIST_OFFSET         NUM_DRASYNCPROPSAME_OFFSET + sizeof(DWORD)
#define NUM_NOTIFYQ_OFFSET         NUM_MONLIST_OFFSET + sizeof(DWORD)
#define NUM_LDAPUDPCLIENTS_OFFSET  NUM_NOTIFYQ_OFFSET + sizeof(DWORD)
#define NUM_SUBSEARCHOPS_OFFSET    NUM_LDAPUDPCLIENTS_OFFSET + sizeof(DWORD)
#define NUM_NAMECACHEHIT_OFFSET    NUM_SUBSEARCHOPS_OFFSET +  sizeof(DWORD)
#define NUM_NAMECACHETRY_OFFSET    NUM_NAMECACHEHIT_OFFSET +  sizeof(DWORD)
#define NUM_HIGHESTUSNISSUEDLO_OFFSET       NUM_NAMECACHETRY_OFFSET + sizeof(DWORD)
#define NUM_HIGHESTUSNISSUEDHI_OFFSET       NUM_HIGHESTUSNISSUEDLO_OFFSET + sizeof(DWORD)
#define NUM_HIGHESTUSNCOMMITTEDLO_OFFSET    NUM_HIGHESTUSNISSUEDHI_OFFSET + sizeof(DWORD)
#define NUM_HIGHESTUSNCOMMITTEDHI_OFFSET    NUM_HIGHESTUSNCOMMITTEDLO_OFFSET + sizeof(DWORD)
#define NUM_SAMWRITES_OFFSET                NUM_HIGHESTUSNCOMMITTEDHI_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES1_OFFSET             NUM_SAMWRITES_OFFSET + sizeof(DWORD)
#define NUM_DRAWRITES_OFFSET                NUM_TOTALWRITES1_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES2_OFFSET             NUM_DRAWRITES_OFFSET + sizeof(DWORD)
#define NUM_LDAPWRITES_OFFSET               NUM_TOTALWRITES2_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES3_OFFSET             NUM_LDAPWRITES_OFFSET + sizeof(DWORD)
#define NUM_LSAWRITES_OFFSET                NUM_TOTALWRITES3_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES4_OFFSET             NUM_LSAWRITES_OFFSET + sizeof(DWORD)
#define NUM_KCCWRITES_OFFSET                NUM_TOTALWRITES4_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES6_OFFSET             NUM_KCCWRITES_OFFSET + sizeof(DWORD)
#define NUM_NSPIWRITES_OFFSET               NUM_TOTALWRITES6_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES7_OFFSET             NUM_NSPIWRITES_OFFSET + sizeof(DWORD)
#define NUM_OTHERWRITES_OFFSET              NUM_TOTALWRITES7_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES8_OFFSET             NUM_OTHERWRITES_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES_OFFSET              NUM_TOTALWRITES8_OFFSET + sizeof(DWORD)

#define NUM_SAMSEARCHES_OFFSET              NUM_TOTALWRITES_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES1_OFFSET           NUM_SAMSEARCHES_OFFSET + sizeof(DWORD)
#define NUM_DRASEARCHES_OFFSET              NUM_TOTALSEARCHES1_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES2_OFFSET           NUM_DRASEARCHES_OFFSET + sizeof(DWORD)
#define NUM_LDAPSEARCHES_OFFSET             NUM_TOTALSEARCHES2_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES3_OFFSET           NUM_LDAPSEARCHES_OFFSET + sizeof(DWORD)
#define NUM_LSASEARCHES_OFFSET              NUM_TOTALSEARCHES3_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES4_OFFSET           NUM_LSASEARCHES_OFFSET + sizeof(DWORD)
#define NUM_KCCSEARCHES_OFFSET              NUM_TOTALSEARCHES4_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES6_OFFSET           NUM_KCCSEARCHES_OFFSET + sizeof(DWORD)
#define NUM_NSPISEARCHES_OFFSET             NUM_TOTALSEARCHES6_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES7_OFFSET           NUM_NSPISEARCHES_OFFSET + sizeof(DWORD)
#define NUM_OTHERSEARCHES_OFFSET            NUM_TOTALSEARCHES7_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES8_OFFSET           NUM_OTHERSEARCHES_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES_OFFSET            NUM_TOTALSEARCHES8_OFFSET + sizeof(DWORD)

#define NUM_SAMREADS_OFFSET                 NUM_TOTALSEARCHES_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS1_OFFSET              NUM_SAMREADS_OFFSET + sizeof(DWORD)
#define NUM_DRAREADS_OFFSET                 NUM_TOTALREADS1_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS2_OFFSET              NUM_DRAREADS_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_DN_VALUES_OFFSET         NUM_TOTALREADS2_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_OBJS_FILTERED_OFFSET     NUM_DRA_IN_DN_VALUES_OFFSET + sizeof(DWORD)
#define NUM_LSAREADS_OFFSET                 NUM_DRA_IN_OBJS_FILTERED_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS4_OFFSET              NUM_LSAREADS_OFFSET + sizeof(DWORD)
#define NUM_KCCREADS_OFFSET                 NUM_TOTALREADS4_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS6_OFFSET              NUM_KCCREADS_OFFSET + sizeof(DWORD)
#define NUM_NSPIREADS_OFFSET                NUM_TOTALREADS6_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS7_OFFSET              NUM_NSPIREADS_OFFSET + sizeof(DWORD)
#define NUM_OTHERREADS_OFFSET               NUM_TOTALREADS7_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS8_OFFSET              NUM_OTHERREADS_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS_OFFSET               NUM_TOTALREADS8_OFFSET + sizeof(DWORD)

#define NUM_LDAPBINDSUCCESSFUL_OFFSET       NUM_TOTALREADS_OFFSET + sizeof(DWORD)
#define NUM_LDAPBINDTIME_OFFSET             NUM_LDAPBINDSUCCESSFUL_OFFSET + sizeof(DWORD)
#define NUM_CREATEMACHINESUCCESSFUL_OFFSET  NUM_LDAPBINDTIME_OFFSET + sizeof(DWORD)
#define NUM_CREATEMACHINETRIES_OFFSET       NUM_CREATEMACHINESUCCESSFUL_OFFSET + sizeof(DWORD)
#define NUM_CREATEUSERSUCCESSFUL_OFFSET     NUM_CREATEMACHINETRIES_OFFSET + sizeof(DWORD)
#define NUM_CREATEUSERTRIES_OFFSET          NUM_CREATEUSERSUCCESSFUL_OFFSET + sizeof(DWORD)
#define NUM_PASSWORDCHANGES_OFFSET          NUM_CREATEUSERTRIES_OFFSET + sizeof(DWORD)
#define NUM_MEMBERSHIPCHANGES_OFFSET        NUM_PASSWORDCHANGES_OFFSET + sizeof(DWORD)
#define NUM_QUERYDISPLAYS_OFFSET            NUM_MEMBERSHIPCHANGES_OFFSET + sizeof(DWORD)
#define NUM_ENUMERATIONS_OFFSET             NUM_QUERYDISPLAYS_OFFSET + sizeof(DWORD)

#define NUM_MEMBEREVALTRANSITIVE_OFFSET     NUM_ENUMERATIONS_OFFSET + sizeof(DWORD)
#define NUM_MEMBEREVALNONTRANSITIVE_OFFSET  NUM_MEMBEREVALTRANSITIVE_OFFSET + sizeof(DWORD)
#define NUM_MEMBEREVALRESOURCE_OFFSET       NUM_MEMBEREVALNONTRANSITIVE_OFFSET + sizeof(DWORD)
#define NUM_MEMBEREVALUNIVERSAL_OFFSET      NUM_MEMBEREVALRESOURCE_OFFSET + sizeof(DWORD)
#define NUM_MEMBEREVALACCOUNT_OFFSET        NUM_MEMBEREVALUNIVERSAL_OFFSET + sizeof(DWORD)
#define NUM_MEMBEREVALASGC_OFFSET           NUM_MEMBEREVALACCOUNT_OFFSET + sizeof(DWORD)
#define NUM_AS_REQUESTS_OFFSET              NUM_MEMBEREVALASGC_OFFSET + sizeof(DWORD)
#define NUM_TGS_REQUESTS_OFFSET             NUM_AS_REQUESTS_OFFSET + sizeof(DWORD)
#define NUM_KERBEROS_AUTHENTICATIONS_OFFSET NUM_TGS_REQUESTS_OFFSET + sizeof(DWORD)
#define NUM_MSVAUTHENTICATIONS_OFFSET       NUM_KERBEROS_AUTHENTICATIONS_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCFULLREM_OFFSET           NUM_MSVAUTHENTICATIONS_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_TOTAL_RATE_OFFSET       NUM_DRASYNCFULLREM_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_NOT_COMP_RATE_OFFSET    NUM_DRA_IN_BYTES_TOTAL_RATE_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_COMP_PRE_RATE_OFFSET    NUM_DRA_IN_BYTES_NOT_COMP_RATE_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_COMP_POST_RATE_OFFSET   NUM_DRA_IN_BYTES_COMP_PRE_RATE_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_TOTAL_RATE_OFFSET      NUM_DRA_IN_BYTES_COMP_POST_RATE_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_NOT_COMP_RATE_OFFSET   NUM_DRA_OUT_BYTES_TOTAL_RATE_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_COMP_PRE_RATE_OFFSET   NUM_DRA_OUT_BYTES_NOT_COMP_RATE_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_COMP_POST_RATE_OFFSET  NUM_DRA_OUT_BYTES_COMP_PRE_RATE_OFFSET + sizeof(DWORD)
#define NUM_DS_CLIENT_BIND_OFFSET           NUM_DRA_OUT_BYTES_COMP_POST_RATE_OFFSET + sizeof(DWORD)
#define NUM_DS_SERVER_BIND_OFFSET           NUM_DS_CLIENT_BIND_OFFSET + sizeof(DWORD)
#define NUM_DS_CLIENT_NAME_TRANSLATE_OFFSET NUM_DS_SERVER_BIND_OFFSET + sizeof(DWORD)
#define NUM_DS_SERVER_NAME_TRANSLATE_OFFSET NUM_DS_CLIENT_NAME_TRANSLATE_OFFSET + sizeof(DWORD)
#define NUM_SDPROP_RUNTIME_QUEUE_OFFSET     NUM_DS_SERVER_NAME_TRANSLATE_OFFSET + sizeof(DWORD)
#define NUM_SDPROP_WAIT_TIME_OFFSET         NUM_SDPROP_RUNTIME_QUEUE_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_OBJS_FILTERED_OFFSET    NUM_SDPROP_WAIT_TIME_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_VALUES_OFFSET           NUM_DRA_OUT_OBJS_FILTERED_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_DN_VALUES_OFFSET        NUM_DRA_OUT_VALUES_OFFSET + sizeof(DWORD)
#define NUM_NSPI_ANR_OFFSET                 NUM_DRA_OUT_DN_VALUES_OFFSET + sizeof(DWORD)
#define NUM_NSPI_PROPERTY_READS_OFFSET      NUM_NSPI_ANR_OFFSET + sizeof(DWORD)
#define NUM_NSPI_OBJECT_SEARCH_OFFSET       NUM_NSPI_PROPERTY_READS_OFFSET + sizeof(DWORD)
#define NUM_NSPI_OBJECT_MATCHES_OFFSET      NUM_NSPI_OBJECT_SEARCH_OFFSET + sizeof(DWORD)
#define NUM_NSPI_PROXY_LOOKUP_OFFSET        NUM_NSPI_OBJECT_MATCHES_OFFSET + sizeof(DWORD)
#define NUM_ATQ_THREADS_TOTAL_OFFSET        NUM_NSPI_PROXY_LOOKUP_OFFSET + sizeof(DWORD)
#define NUM_ATQ_THREADS_LDAP_OFFSET         NUM_ATQ_THREADS_TOTAL_OFFSET + sizeof(DWORD)
#define NUM_ATQ_THREADS_OTHER_OFFSET        NUM_ATQ_THREADS_LDAP_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_TOTAL_OFFSET       NUM_ATQ_THREADS_OTHER_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_NOT_COMP_OFFSET    NUM_DRA_IN_BYTES_TOTAL_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_COMP_PRE_OFFSET    NUM_DRA_IN_BYTES_NOT_COMP_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_COMP_POST_OFFSET   NUM_DRA_IN_BYTES_COMP_PRE_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_TOTAL_OFFSET      NUM_DRA_IN_BYTES_COMP_POST_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_NOT_COMP_OFFSET   NUM_DRA_OUT_BYTES_TOTAL_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_COMP_PRE_OFFSET   NUM_DRA_OUT_BYTES_NOT_COMP_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_COMP_POST_OFFSET  NUM_DRA_OUT_BYTES_COMP_PRE_OFFSET + sizeof(DWORD)
#define NUM_LDAP_NEW_CONNS_PER_SEC_OFFSET   NUM_DRA_OUT_BYTES_COMP_POST_OFFSET + sizeof(DWORD)
#define NUM_LDAP_CLS_CONNS_PER_SEC_OFFSET   NUM_LDAP_NEW_CONNS_PER_SEC_OFFSET + sizeof(DWORD)
#define NUM_LDAP_SSL_CONNS_PER_SEC_OFFSET   NUM_LDAP_CLS_CONNS_PER_SEC_OFFSET + sizeof(DWORD)
#define NUM_LDAP_THREADS_IN_NETLOG_OFFSET   NUM_LDAP_SSL_CONNS_PER_SEC_OFFSET + sizeof(DWORD)
#define NUM_LDAP_THREADS_IN_AUTH_OFFSET     NUM_LDAP_THREADS_IN_NETLOG_OFFSET + sizeof(DWORD)
#define NUM_LDAP_THREADS_IN_DRA_OFFSET      NUM_LDAP_THREADS_IN_AUTH_OFFSET + sizeof(DWORD)
#define NUM_DRA_REPL_QUEUE_OPS_OFFSET       NUM_LDAP_THREADS_IN_DRA_OFFSET + sizeof(DWORD)
#define NUM_DRA_TDS_IN_GETCHNGS_OFFSET      NUM_DRA_REPL_QUEUE_OPS_OFFSET + sizeof(DWORD)
#define NUM_DRA_TDS_IN_GETCHNGS_W_SEM_OFFSET     NUM_DRA_TDS_IN_GETCHNGS_OFFSET + sizeof(DWORD)
#define NUM_DRA_REM_REPL_UPD_LNK_OFFSET     NUM_DRA_TDS_IN_GETCHNGS_W_SEM_OFFSET + sizeof(DWORD)
#define NUM_DRA_REM_REPL_UPD_TOT_OFFSET     NUM_DRA_REM_REPL_UPD_LNK_OFFSET + sizeof(DWORD)
#define NUM_NTDSAPIWRITES_OFFSET            NUM_DRA_REM_REPL_UPD_TOT_OFFSET + sizeof(DWORD)
#define NUM_NTDSAPISEARCHES_OFFSET          NUM_NTDSAPIWRITES_OFFSET + sizeof(DWORD)
#define NUM_NTDSAPIREADS_OFFSET             NUM_NTDSAPISEARCHES_OFFSET + sizeof(DWORD)

// <-- insert new NUM_*_OFFSET's here, and update SIZE_OF_... #define below.
#define SIZE_OF_DSA_PERFORMANCE_DATA_IN_USE NUM_NTDSAPIREADS_OFFSET + sizeof(DWORD)

// The total size of the structure must be a multiple of 8 (see perflib Event 1016).
// This will adjust the total size if the total number of counters (DWORD each) is odd.
// We don't really care about 4 extra bytes at the end of the buffer since all data
// is defined by the DSA_DATA_DEFINITION struct. No one will look at this extra DWORD
// at the end of the buffer.
#define SIZE_OF_DSA_PERFORMANCE_DATA ((SIZE_OF_DSA_PERFORMANCE_DATA_IN_USE + 0x07) & ~0x07)                                                                    

//
//  This is the counter structure presently returned by Dsa for
//  each Resource.  Each Resource is an Instance, named by its number.
//

typedef struct _DSA_DATA_DEFINITION {
    PERF_OBJECT_TYPE            DsaObjectType;
    PERF_COUNTER_DEFINITION     NumDRAInProps;
    PERF_COUNTER_DEFINITION     NumBrowse;
    PERF_COUNTER_DEFINITION     NumRepl;
    PERF_COUNTER_DEFINITION     NumThread;
    PERF_COUNTER_DEFINITION     NumABClient;
    PERF_COUNTER_DEFINITION     NumPendSync;
    PERF_COUNTER_DEFINITION     NumRemRepUpd;
    PERF_COUNTER_DEFINITION     NumSDProp;
    PERF_COUNTER_DEFINITION     NumSDEvents;
    PERF_COUNTER_DEFINITION     NumLDAPClients;
    PERF_COUNTER_DEFINITION     NumLDAPActive;
    PERF_COUNTER_DEFINITION     NumLDAPWrite;
    PERF_COUNTER_DEFINITION     NumLDAPSearch;
    PERF_COUNTER_DEFINITION     NumDRAObjShipped;
    PERF_COUNTER_DEFINITION     NumDRAPropShipped;
    PERF_COUNTER_DEFINITION     NumDRAInValues;
    PERF_COUNTER_DEFINITION     NumDRASyncRequestMade;
    PERF_COUNTER_DEFINITION     NumDRASyncRequestSuccessful;
    PERF_COUNTER_DEFINITION     NumDRASyncRequestFailedSchemaMismatch;
    PERF_COUNTER_DEFINITION     NumDRASyncObjReceived;
    PERF_COUNTER_DEFINITION     NumDRASyncPropUpdated;
    PERF_COUNTER_DEFINITION     NumDRASyncPropSame;
    PERF_COUNTER_DEFINITION     NumMonList;
    PERF_COUNTER_DEFINITION     NumNotifyQ;
    PERF_COUNTER_DEFINITION     NumLDAPUDPClients;
    PERF_COUNTER_DEFINITION     NumSubSearchOps;
    PERF_COUNTER_DEFINITION     NameCacheHit;
    PERF_COUNTER_DEFINITION     NameCacheTry;
    PERF_COUNTER_DEFINITION     HighestUsnIssuedLo;
    PERF_COUNTER_DEFINITION     HighestUsnIssuedHi;
    PERF_COUNTER_DEFINITION     HighestUsnCommittedLo;
    PERF_COUNTER_DEFINITION     HighestUsnCommittedHi;
    PERF_COUNTER_DEFINITION     SAMWrites;
    PERF_COUNTER_DEFINITION     TotalWrites1;
    PERF_COUNTER_DEFINITION     DRAWrites;
    PERF_COUNTER_DEFINITION     TotalWrites2;
    PERF_COUNTER_DEFINITION     LDAPWrites;
    PERF_COUNTER_DEFINITION     TotalWrites3;
    PERF_COUNTER_DEFINITION     LSAWrites;
    PERF_COUNTER_DEFINITION     TotalWrites4;
    PERF_COUNTER_DEFINITION     KCCWrites;
    PERF_COUNTER_DEFINITION     TotalWrites6;
    PERF_COUNTER_DEFINITION     NSPIWrites;
    PERF_COUNTER_DEFINITION     TotalWrites7;
    PERF_COUNTER_DEFINITION     OtherWrites;
    PERF_COUNTER_DEFINITION     TotalWrites8;
    PERF_COUNTER_DEFINITION     TotalWrites;
    PERF_COUNTER_DEFINITION     SAMSearches;
    PERF_COUNTER_DEFINITION     TotalSearches1;
    PERF_COUNTER_DEFINITION     DRASearches;
    PERF_COUNTER_DEFINITION     TotalSearches2;
    PERF_COUNTER_DEFINITION     LDAPSearches;
    PERF_COUNTER_DEFINITION     TotalSearches3;
    PERF_COUNTER_DEFINITION     LSASearches;
    PERF_COUNTER_DEFINITION     TotalSearches4;
    PERF_COUNTER_DEFINITION     KCCSearches;
    PERF_COUNTER_DEFINITION     TotalSearches6;
    PERF_COUNTER_DEFINITION     NSPISearches;
    PERF_COUNTER_DEFINITION     TotalSearches7;
    PERF_COUNTER_DEFINITION     OtherSearches;
    PERF_COUNTER_DEFINITION     TotalSearches8;
    PERF_COUNTER_DEFINITION     TotalSearches;
    PERF_COUNTER_DEFINITION     SAMReads;
    PERF_COUNTER_DEFINITION     TotalReads1;
    PERF_COUNTER_DEFINITION     DRAReads;
    PERF_COUNTER_DEFINITION     TotalReads2;
    PERF_COUNTER_DEFINITION     DRAInDNValues;
    PERF_COUNTER_DEFINITION     DRAInObjsFiltered;
    PERF_COUNTER_DEFINITION     LSAReads;
    PERF_COUNTER_DEFINITION     TotalReads4;
    PERF_COUNTER_DEFINITION     KCCReads;
    PERF_COUNTER_DEFINITION     TotalReads6;
    PERF_COUNTER_DEFINITION     NSPIReads;
    PERF_COUNTER_DEFINITION     TotalReads7;
    PERF_COUNTER_DEFINITION     OtherReads;
    PERF_COUNTER_DEFINITION     TotalReads8;
    PERF_COUNTER_DEFINITION     TotalReads;
    PERF_COUNTER_DEFINITION     LDAPBindSuccessful;
    PERF_COUNTER_DEFINITION     LDAPBindTime;
    PERF_COUNTER_DEFINITION     CreateMachineSuccessful;
    PERF_COUNTER_DEFINITION     CreateMachineTries;
    PERF_COUNTER_DEFINITION     CreateUserSuccessful;
    PERF_COUNTER_DEFINITION     CreateUserTries;
    PERF_COUNTER_DEFINITION     PasswordChanges;
    PERF_COUNTER_DEFINITION     MembershipChanges;
    PERF_COUNTER_DEFINITION     QueryDisplays;
    PERF_COUNTER_DEFINITION     Enumerations;
    PERF_COUNTER_DEFINITION     MemberEvalTransitive;
    PERF_COUNTER_DEFINITION     MemberEvalNonTransitive;
    PERF_COUNTER_DEFINITION     MemberEvalResource;
    PERF_COUNTER_DEFINITION     MemberEvalUniversal;
    PERF_COUNTER_DEFINITION     MemberEvalAccount;
    PERF_COUNTER_DEFINITION     MemberEvalAsGC;
    PERF_COUNTER_DEFINITION     AsRequests;
    PERF_COUNTER_DEFINITION     TgsRequests;
    PERF_COUNTER_DEFINITION     KerberosAuthentications;
    PERF_COUNTER_DEFINITION     MsvAuthentications;
    PERF_COUNTER_DEFINITION     NumDRASyncFullRemaining;
    PERF_COUNTER_DEFINITION     NumDRAInBytesTotalRate;
    PERF_COUNTER_DEFINITION     NumDRAInBytesNotCompRate;
    PERF_COUNTER_DEFINITION     NumDRAInBytesCompPreRate;
    PERF_COUNTER_DEFINITION     NumDRAInBytesCompPostRate;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesTotalRate;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesNotCompRate;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesCompPreRate;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesCompPostRate;
    PERF_COUNTER_DEFINITION     NumDsClientBind;
    PERF_COUNTER_DEFINITION     NumDsServerBind;
    PERF_COUNTER_DEFINITION     NumDsClientNameTranslate;
    PERF_COUNTER_DEFINITION     NumDsServerNameTranslate;
    PERF_COUNTER_DEFINITION     SDPropRuntimeQueue;
    PERF_COUNTER_DEFINITION     SDPropWaitTime;
    PERF_COUNTER_DEFINITION     NumDRAOutObjsFiltered;
    PERF_COUNTER_DEFINITION     NumDRAOutValues;
    PERF_COUNTER_DEFINITION     NumDRAOutDNValues;
    PERF_COUNTER_DEFINITION     NumNspiANR;
    PERF_COUNTER_DEFINITION     NumNspiPropertyReads;
    PERF_COUNTER_DEFINITION     NumNspiObjectSearch;
    PERF_COUNTER_DEFINITION     NumNspiObjectMatches;
    PERF_COUNTER_DEFINITION     NumNspiProxyLookup;
    PERF_COUNTER_DEFINITION     AtqThreadsTotal;
    PERF_COUNTER_DEFINITION     AtqThreadsLDAP;
    PERF_COUNTER_DEFINITION     AtqThreadsOther;
    PERF_COUNTER_DEFINITION     NumDRAInBytesTotal;
    PERF_COUNTER_DEFINITION     NumDRAInBytesNotComp;
    PERF_COUNTER_DEFINITION     NumDRAInBytesCompPre;
    PERF_COUNTER_DEFINITION     NumDRAInBytesCompPost;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesTotal;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesNotComp;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesCompPre;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesCompPost;
    PERF_COUNTER_DEFINITION     LdapNewConnsPerSec;
    PERF_COUNTER_DEFINITION     LdapClosedConnsPerSec;
    PERF_COUNTER_DEFINITION     LdapSSLConnsPerSec;
    PERF_COUNTER_DEFINITION     LdapThreadsInNetlogon;
    PERF_COUNTER_DEFINITION     LdapThreadsInAuth;
    PERF_COUNTER_DEFINITION     LdapThreadsInDra;
    PERF_COUNTER_DEFINITION     DRAReplQueueOps;
    PERF_COUNTER_DEFINITION     DRATdsInGetChngs;
    PERF_COUNTER_DEFINITION     DRATdsInGetChngsWSem;
    PERF_COUNTER_DEFINITION     DRARemReplUpdLnk;
    PERF_COUNTER_DEFINITION     DRARemReplUpdTot;
    PERF_COUNTER_DEFINITION     NTDSAPIWrites;
    PERF_COUNTER_DEFINITION     NTDSAPISearches;
    PERF_COUNTER_DEFINITION     NTDSAPIReads;
} DSA_DATA_DEFINITION;

#pragma pack ()

#endif //_DATADSA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\perfdsa\perfmsg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       perfmsg.h
//
//--------------------------------------------------------------------------

/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (C) Microsoft Corporation, 1992 - 1996

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "vgactrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\perfdsa\perfdsa.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1993 - 1999
//
//  File:       perfdsa.c
//
//--------------------------------------------------------------------------

/*

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    perfdsa.c

Abstract:

    This file implements the Extensible Objects for the DSA object type

Created:

    Don Hacherl 25 June 1993

Revision History
*/

//
//  Include Files
//
#include <NTDSpch.h>
#pragma hdrstop

#include <wchar.h>
#include <winperf.h>

#ifndef MessageId               /* used in mdcodes */
#define MessageId   ULONG
#endif

#include <mdcodes.h>            /* error message definitions */
#include "perfmsg.h"
#include "perfutil.h"
#include "datadsa.h"
#include "ntdsctr.h"
#include <dsconfig.h>
#include <align.h>

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK

//
// DSA counter data structures

HANDLE hDsaSharedMemory;                 // Handle of Dsa Shared Memory
PDWORD pCounterBlock;
extern DSA_DATA_DEFINITION DsaDataDefinition;

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC            OpenDsaPerformanceData;
PM_COLLECT_PROC         CollectDsaPerformanceData;
PM_CLOSE_PROC           CloseDsaPerformanceData;




DWORD
OpenDsaPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open and map the memory used by the DSA to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (DSA), which
    seems to be totally unused, just as it was in the sample code
    from which this is stolen.


Return Value:

    None.

--*/
{
    LONG_PTR status;
    HKEY hKeyDriverPerf;
    DWORD size, type, dwFirstCounter, dwFirstHelp;
    PERF_COUNTER_DEFINITION * pCtrDef;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //
    /* DebugBreak() */
    if (!dwOpenCount) {
        // open shared memory used by device driver to pass performance values
        hDsaSharedMemory = OpenFileMapping(FILE_MAP_READ,
                                        FALSE,
                                        DSA_PERF_COUNTER_BLOCK);
        pCounterBlock = NULL;   // initialize pointer to memory

        // log error if unsuccessful

        if (hDsaSharedMemory == NULL) {

            // this is fatal, if we can't get data then there's no
            // point in continuing.
            status = GetLastError(); // return error
            LogPerfEvent( DIRLOG_PERF_FAIL_OPEN_MEMORY, 1, &status);
            goto OpenExitPoint;
        } else {

            // if opened ok, then map pointer to memory
            pCounterBlock = (PDWORD) MapViewOfFile(hDsaSharedMemory,
                                            FILE_MAP_READ,
                                            0,
                                            0,
                                            0);
            if (pCounterBlock == NULL) {
                // this is fatal, if we can't get data then there's no
                // point in continuing.
                status = GetLastError(); // return error
                LogPerfEvent( DIRLOG_PERF_FAIL_MAP_MEMORY, 1, &status);
                CloseHandle(hDsaSharedMemory);
                hDsaSharedMemory = NULL;
                goto OpenExitPoint;
            }
        }

        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data strucutures by adding base to
        //          offset value in structure.

        status = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Services\\" SERVICE_NAME "\\Performance",
            0L,
            KEY_READ,
            &hKeyDriverPerf);

        if (status != ERROR_SUCCESS) {
            LPTSTR apsz[2];

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            apsz[0] = (LPTSTR)status;
            apsz[1] = "SYSTEM\\CurrentControlSet\\Services\\" SERVICE_NAME "\\Performance";
            LogPerfEvent( DIRLOG_PERF_FAIL_OPEN_REG, 2, (LONG_PTR *)apsz);
            UnmapViewOfFile (pCounterBlock);
            pCounterBlock = NULL;
            CloseHandle(hDsaSharedMemory);
            hDsaSharedMemory = NULL;
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf,
                    "First Counter",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstCounter,
                    &size);

        if (status != ERROR_SUCCESS) {
            LPTSTR apsz[2];

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            apsz[0] = (LPTSTR)status;
            apsz[1] = "First Counter";
            LogPerfEvent( DIRLOG_PERF_FAIL_QUERY_REG, 2, (LONG_PTR *)apsz);
            RegCloseKey (hKeyDriverPerf);
            UnmapViewOfFile (pCounterBlock);
            pCounterBlock = NULL;
            CloseHandle(hDsaSharedMemory);
            hDsaSharedMemory = NULL;
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf,
                    "First Help",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstHelp,
                    &size);

        if (status != ERROR_SUCCESS) {
            LPTSTR apsz[2];

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            apsz[0] = (LPTSTR)status;
            apsz[1] = "First Help";
            LogPerfEvent( DIRLOG_PERF_FAIL_QUERY_REG, 2, (LONG_PTR *)apsz);
            RegCloseKey (hKeyDriverPerf);
            UnmapViewOfFile (pCounterBlock);
            pCounterBlock = NULL;
            CloseHandle(hDsaSharedMemory);
            hDsaSharedMemory = NULL;
            goto OpenExitPoint;
        }

        //
        //  NOTE: the initialization program could also retrieve
        //      LastCounter and LastHelp if they wanted to do
        //      bounds checking on the new number. e.g.
        //
        //      counter->CounterNameTitleIndex += dwFirstCounter;
        //      if (counter->CounterNameTitleIndex > dwLastCounter) {
        //          LogErrorToEventLog (INDEX_OUT_OF_BOUNDS);
        //      }

        DsaDataDefinition.DsaObjectType.ObjectNameTitleIndex += dwFirstCounter;
        DsaDataDefinition.DsaObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        for (pCtrDef = &DsaDataDefinition.NumDRAInProps;
             (BYTE *) pCtrDef < (BYTE *) &DsaDataDefinition + sizeof(DsaDataDefinition);
             pCtrDef++) {
            pCtrDef->CounterNameTitleIndex += dwFirstCounter;
            pCtrDef->CounterHelpTitleIndex += dwFirstCounter;
        }

        RegCloseKey (hKeyDriverPerf); // close key to registry

        bInitOK = TRUE; // ok to use this function
    }
    dwOpenCount++;  // increment OPEN counter
//    LogPerfEvent( DIRLOG_PERF_OPEN, 1, &dwOpenCount);
    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return (DWORD)status;
}



DWORD
CollectDsaPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the DSA counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

    ULONG SpaceNeeded;
    PDWORD pdwCounter;
    DSA_COUNTER_DATA *pPerfCounterBlock;
    DSA_DATA_DEFINITION *pDsaDataDefinition;

    // variables used for error logging

    DWORD                               dwQueryType;

    int i;          //loop variable

//    DebugBreak();
    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK) {
        // unable to continue because open failed.
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN || QUERY_COSTLY == dwQueryType) {
        // this routine does not service requests for data from
        // Non-NT computers, nor do we have any costly counters.
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS){
        if ( !(IsNumberInUnicodeList (DsaDataDefinition.DsaObjectType.ObjectNameTitleIndex, lpValueName))) {

            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pDsaDataDefinition = (DSA_DATA_DEFINITION *) *lppData;

    SpaceNeeded = sizeof(DSA_DATA_DEFINITION) +
                  SIZE_OF_DSA_PERFORMANCE_DATA;

    if ( *lpcbTotalBytes < SpaceNeeded ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove(pDsaDataDefinition,
           &DsaDataDefinition,
           sizeof(DSA_DATA_DEFINITION));

    //  Format and collect DSA data from shared memory

    // The counter block is to immediately follow the data definition,
    // so obtain a pointer to that space
    pPerfCounterBlock = (DSA_COUNTER_DATA *) &pDsaDataDefinition[1];

    // The byte length is of the counter block header and all following data
    pPerfCounterBlock->cb.ByteLength = SIZE_OF_DSA_PERFORMANCE_DATA;

    // Compute a pointer to the buffer immediately following the counter
    // block header
    pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

    // copy the counter data from shared memory block into the counter block
    for( i = 0; i < DSA_LAST_COUNTER_INDEX/2; i++ )
    {
        pdwCounter[i] = pCounterBlock[(i+1)*COUNTER_ADDRESS_INCREMENT_IN_DWORD];
    }

    // Tell caller where the next available byte is
    *lppData = (PVOID) ((PBYTE)pdwCounter + SIZE_OF_DSA_PERFORMANCE_DATA - sizeof(DSA_COUNTER_DATA));

    // update arguments before return

    *lpNumObjectTypes = 1;

    *lpcbTotalBytes = (DWORD)((PBYTE) *lppData - (PBYTE) pDsaDataDefinition);

    ASSERT ((sizeof(DSA_COUNTER_DATA) & 0x7) == 0);

    return ERROR_SUCCESS;
}


DWORD
CloseDsaPerformanceData(
)
/*++
Routine Description:
    This routine closes the open handles to DSA device performance counters

Arguments:
    None.

Return Value:
    ERROR_SUCCESS
--*/
{
// DebugBreak();
    if (!(--dwOpenCount)) {                 // when this is the last thread...
        
        UnmapViewOfFile (pCounterBlock);
        CloseHandle(hDsaSharedMemory);
        pCounterBlock = NULL;
        hDsaSharedMemory = NULL;
    }
//    LogPerfEvent( DIRLOG_PERF_CLOSE, 1, &dwOpenCount);
    return ERROR_SUCCESS;
}


//
// Data for this whole thing to work on
//

DSA_DATA_DEFINITION DsaDataDefinition = {

    {   sizeof(DSA_DATA_DEFINITION) + SIZE_OF_DSA_PERFORMANCE_DATA, // TotLen
        sizeof(DSA_DATA_DEFINITION),            // DefinitionLength
        sizeof(PERF_OBJECT_TYPE),               // HeaderLength
        DSAOBJ,                                 // ObjectNameTitleIndex
        0,                                      // ObjectNameTitle
        DSAOBJ + 1,                                 // ObjectHelpTitleIndex
        0,                                      // ObjectHelpTitle
        PERF_DETAIL_NOVICE,                     // DetailLevel
        (sizeof(DSA_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
          sizeof(PERF_COUNTER_DEFINITION),      // NumCounters
        0,                                      // DefaultCounter
        -1,                                     // NumInstances
        0                                       // CodePage (0=Unicode)
      },

    /* DRA Inbound Properties Total/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DRA_IN_PROPS,                           // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DRA_IN_PROPS + 1,                           // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        NUM_DRA_IN_PROPS_OFFSET                 // CounterOffset
    },

    /* AB browse ops */
    {   sizeof(PERF_COUNTER_DEFINITION),
        BROWSE,
        0,
        BROWSE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_BROWSE_OFFSET
      },

    /* DRA Inbound Object Updates Total/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        REPL,
        0,
        REPL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_REPL_OFFSET
      },

    /* live client threads in server */
    {   sizeof(PERF_COUNTER_DEFINITION),
        THREAD,
        0,
        THREAD + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_THREAD_OFFSET
      },

    /* count of bound AB clients */
    {   sizeof(PERF_COUNTER_DEFINITION),
        ABCLIENT,
        0,
        ABCLIENT + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_ABCLIENT_OFFSET
      },

    /* DRA Pending Replication Synchronizations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        PENDSYNC,
        0,
        PENDSYNC + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_PENDSYNC_OFFSET
      },

    /* DRA Inbound Object Updates Remaining in Packet */
    {   sizeof(PERF_COUNTER_DEFINITION),
        REMREPUPD,
        0,
        REMREPUPD + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_REMREPUPD_OFFSET
      },

    /* Number of Security descriptor propagations per second. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SDPROPS,
        0,
        SDPROPS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_SDPROPS_OFFSET
    },
    /* Number of Security descriptor propagations Events in the queue. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SDEVENTS,
        0,
        SDEVENTS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_SDEVENTS_OFFSET
    },
    /* Number of bound LDAP clients. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPCLIENTS,
        0,
        LDAPCLIENTS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_LDAPCLIENTS_OFFSET
    },
    /* Number of active LDAP threads. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPACTIVE,
        0,
        LDAPACTIVE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_LDAPACTIVE_OFFSET
    },
    /* Number of LDAP writes per second. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPWRITE,
        0,
        LDAPWRITE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAPWRITE_OFFSET
    },
    /* Number of LDAP searches per second. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPSEARCH,
        0,
        LDAPSEARCH + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAPSEARCH_OFFSET
    },
    /* DRA Outbound Objects/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRAOBJSHIPPED,
        0,
        DRAOBJSHIPPED + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRAOBJSHIPPED_OFFSET
    },
    /* DRA Outbound Properties/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRAPROPSHIPPED,
        0,
        DRAPROPSHIPPED + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRAPROPSHIPPED_OFFSET
    },
    /* DRA Inbound Values Total/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_VALUES,
        0,
        DRA_IN_VALUES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_VALUES_OFFSET
    },
    /* Number of replication sync requests made - # of GetNCChanges() calls made */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCREQUESTMADE,
        0,
        DRASYNCREQUESTMADE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRASYNCREQUESTMADE_OFFSET
    },
    /* Number of successful replication syncs - # of GetNCChanges() that returned successfully. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCREQUESTSUCCESSFUL,
        0,
        DRASYNCREQUESTSUCCESSFUL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRASYNCREQUESTSUCCESSFUL_OFFSET
    },
    /* Number of GetNCChanges() that failed due to a schema mismatch between the source and destination servers */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCREQUESTFAILEDSCHEMAMISMATCH,
        0,
        DRASYNCREQUESTFAILEDSCHEMAMISMATCH + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRASYNCREQUESTFAILEDSCHEMAMISMATCH_OFFSET
    },
    /* DRA Inbound Objects/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCOBJRECEIVED,
        0,
        DRASYNCOBJRECEIVED + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRASYNCOBJRECEIVED_OFFSET
    },
    /* DRA Inbound Properties Applied/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCPROPUPDATED,
        0,
        DRASYNCPROPUPDATED + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRASYNCPROPUPDATED_OFFSET
    },
    /* DRA Inbound Properties Filtered/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCPROPSAME,
        0,
        DRASYNCPROPSAME + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRASYNCPROPSAME_OFFSET
    },

    /* The size of the monitor list (see DirNotifyRegister) */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MONLIST,
        0,
        MONLIST + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_MONLIST_OFFSET
    },

    /* The size of the dir notify queue (see DirNotifyRegister) */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NOTIFYQ,
        0,
        NOTIFYQ + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_NOTIFYQ_OFFSET
    },
        /* The number of UDP connections per second for LDAP */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPUDPCLIENTS,
        0,
        LDAPUDPCLIENTS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAPUDPCLIENTS_OFFSET
    },
        /* The number of search sub operations per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SUBSEARCHOPS,
        0,
        SUBSEARCHOPS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_SUBSEARCHOPS_OFFSET
    },

    /* The hit rate of the DN read cache (with the next counter) */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NAMECACHEHIT,
        0,
        NAMECACHEHIT + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NAMECACHEHIT_OFFSET
    },

    /* The lookup rate of the DN read cache (should be invisible) */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NAMECACHETRY,
        0,
        NAMECACHETRY + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_NAMECACHETRY_OFFSET
    },

    /* LowOrder 32 bit of the Highest USN Issued */
    {   sizeof(PERF_COUNTER_DEFINITION),
        HIGHESTUSNISSUEDLO,
        0,
        HIGHESTUSNISSUEDLO + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_HIGHESTUSNISSUEDLO_OFFSET
    },

    /* HighOrder 32 bit of the Highest USN Issued */
    {   sizeof(PERF_COUNTER_DEFINITION),
        HIGHESTUSNISSUEDHI,
        0,
        HIGHESTUSNISSUEDHI + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_HIGHESTUSNISSUEDHI_OFFSET
    },

    /* LowOrder 32 bit of the Highest USN Committed */
    {   sizeof(PERF_COUNTER_DEFINITION),
        HIGHESTUSNCOMMITTEDLO,
        0,
        HIGHESTUSNCOMMITTEDLO + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_HIGHESTUSNCOMMITTEDLO_OFFSET
    },

    /* HighOrder 32 bit of the Highest USN Committed */
    {   sizeof(PERF_COUNTER_DEFINITION),
        HIGHESTUSNCOMMITTEDHI,
        0,
        HIGHESTUSNCOMMITTEDHI + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_HIGHESTUSNCOMMITTEDHI_OFFSET
    },

    /* SAM Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SAMWRITES,
        0,
        SAMWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_SAMWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES1,
        0,
        TOTALWRITES1 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* DRA Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRAWRITES,
        0,
        DRAWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_DRAWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES2,
        0,
        TOTALWRITES2 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* LDAP Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPWRITES,
        0,
        LDAPWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_LDAPWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES3,
        0,
        TOTALWRITES3 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* LSA Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LSAWRITES,
        0,
        LSAWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_LSAWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES4,
        0,
        TOTALWRITES4 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* KCC Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        KCCWRITES,
        0,
        KCCWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_KCCWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES6,
        0,
        TOTALWRITES6 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* NSPI Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPIWRITES,
        0,
        NSPIWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NSPIWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES7,
        0,
        TOTALWRITES7 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* Other Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        OTHERWRITES,
        0,
        OTHERWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_OTHERWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES8,
        0,
        TOTALWRITES8 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* Total Writes /sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES,
        0,
        TOTALWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* SAM Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SAMSEARCHES,
        0,
        SAMSEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_SAMSEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES1,
        0,
        TOTALSEARCHES1 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* DRA Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASEARCHES,
        0,
        DRASEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_DRASEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES2,
        0,
        TOTALSEARCHES2 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* LDAP Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPSEARCHES,
        0,
        LDAPSEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_LDAPSEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES3,
        0,
        TOTALSEARCHES3 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* LSA Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LSASEARCHES,
        0,
        LSASEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_LSASEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES4,
        0,
        TOTALSEARCHES4 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* KCC Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        KCCSEARCHES,
        0,
        KCCSEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_KCCSEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES6,
        0,
        TOTALSEARCHES6 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* NSPI Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPISEARCHES,
        0,
        NSPISEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NSPISEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES7,
        0,
        TOTALSEARCHES7 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* Other Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        OTHERSEARCHES,
        0,
        OTHERSEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_OTHERSEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES8,
        0,
        TOTALSEARCHES8 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* Total Searches /sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES,
        0,
        TOTALSEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* SAM Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SAMREADS,
        0,
        SAMREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_SAMREADS_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS1,
        0,
        TOTALREADS1 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },

    /* DRA Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRAREADS,
        0,
        DRAREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_DRAREADS_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS2,
        0,
        TOTALREADS2 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },

    /* DRA Inbound Values (DNs only)/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_DN_VALUES,
        0,
        DRA_IN_DN_VALUES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_DN_VALUES_OFFSET
    },

    /* DRA Inbound Objects Filtered/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_OBJS_FILTERED,
        0,
        DRA_IN_OBJS_FILTERED + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_OBJS_FILTERED_OFFSET
    },

    /* LSA Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LSAREADS,
        0,
        LSAREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_LSAREADS_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS4,
        0,
        TOTALREADS4 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },


    /* KCC Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        KCCREADS,
        0,
        KCCREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_KCCREADS_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS6,
        0,
        TOTALREADS6 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },

    /* NSPI Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPIREADS,
        0,
        NSPIREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NSPIREADS_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS7,
        0,
        TOTALREADS7 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },

    /* Other Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        OTHERREADS,
        0,
        OTHERREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_OTHERREADS_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS8,
        0,
        TOTALREADS8 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },

    /* Total Reads /sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS,
        0,
        TOTALREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },

    /* LDAP Binds */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPBINDSUCCESSFUL,
        0,
        LDAPBINDSUCCESSFUL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAPBINDSUCCESSFUL_OFFSET
    },

    /* LDAP Bind Times */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPBINDTIME,
        0,
        LDAPBINDTIME + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_LDAPBINDTIME_OFFSET
    },

    /* Create Machine Successful */
    {   sizeof(PERF_COUNTER_DEFINITION),
        CREATEMACHINESUCCESSFUL,
        0,
        CREATEMACHINESUCCESSFUL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_CREATEMACHINESUCCESSFUL_OFFSET
    },

    /* Create Machine Attempts */
    {   sizeof(PERF_COUNTER_DEFINITION),
        CREATEMACHINETRIES,
        0,
        CREATEMACHINETRIES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_CREATEMACHINETRIES_OFFSET
    },

    /* Create User Successful */
    {   sizeof(PERF_COUNTER_DEFINITION),
        CREATEUSERSUCCESSFUL,
        0,
        CREATEUSERSUCCESSFUL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_CREATEUSERSUCCESSFUL_OFFSET
    },

    /* Create User Attempts */
    {   sizeof(PERF_COUNTER_DEFINITION),
        CREATEUSERTRIES,
        0,
        CREATEUSERTRIES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_CREATEUSERTRIES_OFFSET
    },

    /* Password Changes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        PASSWORDCHANGES,
        0,
        PASSWORDCHANGES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_PASSWORDCHANGES_OFFSET
    },

    /* Group Membership Changes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBERSHIPCHANGES,
        0,
        MEMBERSHIPCHANGES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBERSHIPCHANGES_OFFSET
    },

    /* Query Displays */
    {   sizeof(PERF_COUNTER_DEFINITION),
        QUERYDISPLAYS,
        0,
        QUERYDISPLAYS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_QUERYDISPLAYS_OFFSET
    },

    /* Enumerations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        ENUMERATIONS,
        0,
        ENUMERATIONS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_ENUMERATIONS_OFFSET
    },

    /* Transitive Evaluations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBEREVALTRANSITIVE,
        0,
        MEMBEREVALTRANSITIVE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBEREVALTRANSITIVE_OFFSET
    },

    /* Non Transitive Evaluations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBEREVALNONTRANSITIVE,
        0,
        MEMBEREVALNONTRANSITIVE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBEREVALNONTRANSITIVE_OFFSET
    },

    /* Resource Group Evaluations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBEREVALRESOURCE,
        0,
        MEMBEREVALRESOURCE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBEREVALRESOURCE_OFFSET
    },

    /* Universal Group Evaluations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBEREVALUNIVERSAL,
        0,
        MEMBEREVALUNIVERSAL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBEREVALUNIVERSAL_OFFSET
    },

    /* Account Group Evaluations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBEREVALACCOUNT,
        0,
        MEMBEREVALACCOUNT + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBEREVALACCOUNT_OFFSET
    },

    /* GC Evaluations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBEREVALASGC,
        0,
        MEMBEREVALASGC + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBEREVALASGC_OFFSET
    },

    /* Kerberos Logons */
    {   sizeof(PERF_COUNTER_DEFINITION),
        ASREQUESTS,
        0,
        ASREQUESTS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_AS_REQUESTS_OFFSET
    },

    /* KDC TGS Requests/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TGSREQUESTS,
        0,
        TGSREQUESTS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_TGS_REQUESTS_OFFSET
    },

    /* Kerberos Authentications/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        KERBEROSAUTHENTICATIONS,
        0,
        KERBEROSAUTHENTICATIONS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_KERBEROS_AUTHENTICATIONS_OFFSET
     },

    /* NTLM Authentications/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MSVAUTHENTICATIONS,
        0,
        MSVAUTHENTICATIONS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MSVAUTHENTICATIONS_OFFSET
     },

    /* DRA Inbound Full Sync Remaining Objects */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCFULLREM,
        0,
        DRASYNCFULLREM + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRASYNCFULLREM_OFFSET
    },

    /* DRA Inbound Bytes Total/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_TOTAL_RATE,
        0,
        DRA_IN_BYTES_TOTAL_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_TOTAL_RATE_OFFSET
    },

    /* DRA Inbound Bytes Not Compressed/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_NOT_COMP_RATE,
        0,
        DRA_IN_BYTES_NOT_COMP_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_NOT_COMP_RATE_OFFSET
    },

    /* DRA Inbound Compressed Bytes Before Compression/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_COMP_PRE_RATE,
        0,
        DRA_IN_BYTES_COMP_PRE_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_COMP_PRE_RATE_OFFSET
    },

    /* DRA Inbound Compressed Bytes After Compression/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_COMP_POST_RATE,
        0,
        DRA_IN_BYTES_COMP_POST_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_COMP_POST_RATE_OFFSET
    },

    /* DRA Outbound Bytes Total/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_TOTAL_RATE,
        0,
        DRA_OUT_BYTES_TOTAL_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_TOTAL_RATE_OFFSET
    },

    /* DRA Outbound Bytes Not Compressed/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_NOT_COMP_RATE,
        0,
        DRA_OUT_BYTES_NOT_COMP_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_NOT_COMP_RATE_OFFSET
    },

    /* DRA Outbound Compressed Bytes Before Compression/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_COMP_PRE_RATE,
        0,
        DRA_OUT_BYTES_COMP_PRE_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_COMP_PRE_RATE_OFFSET
    },

    /* DRA Outbound Compressed Bytes After Compression/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_COMP_POST_RATE,
        0,
        DRA_OUT_BYTES_COMP_POST_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_COMP_POST_RATE_OFFSET
    },

        /* The number of ntdsapi.dll originated IDL_DRSBind per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DS_CLIENT_BIND,
        0,
        DS_CLIENT_BIND + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DS_CLIENT_BIND_OFFSET
    },

        /* The number of DC-to-DC originated IDL_DRSBind per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DS_SERVER_BIND,
        0,
        DS_SERVER_BIND + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DS_SERVER_BIND_OFFSET
    },

        /* The number of ntdsapi.dll originated name translations per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DS_CLIENT_NAME_XLATE,
        0,
        DS_CLIENT_NAME_XLATE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DS_CLIENT_NAME_TRANSLATE_OFFSET
    },

        /* The number of DC-to-DC originated name translations per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DS_SERVER_NAME_XLATE,
        0,
        DS_SERVER_NAME_XLATE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DS_SERVER_NAME_TRANSLATE_OFFSET
    },
    /* Size of the runtime queue for the SD propagator. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SDPROP_RUNTIME_QUEUE,
        0,
        SDPROP_RUNTIME_QUEUE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_SDPROP_RUNTIME_QUEUE_OFFSET
    },
    /* Size of the runtime queue for the SD propagator. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SDPROP_WAIT_TIME,
        0,
        SDPROP_WAIT_TIME + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_SDPROP_WAIT_TIME_OFFSET
    },

    /* DRA Outbound Objects Filtered/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_OBJS_FILTERED,
        0,
        DRA_OUT_OBJS_FILTERED + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_OBJS_FILTERED_OFFSET
    },

    /* DRA Outbound Values Total/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_VALUES,
        0,
        DRA_OUT_VALUES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_VALUES_OFFSET
    },

    /* DRA Outbound Values (DNs only)/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_DN_VALUES,
        0,
        DRA_OUT_DN_VALUES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_DN_VALUES_OFFSET
    },

    /* AB ANR/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPI_ANR,
        0,
        NSPI_ANR + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_NSPI_ANR_OFFSET
    },

    /* AB Property Reads/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPI_PROPERTY_READS,
        0,
        NSPI_PROPERTY_READS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_NSPI_PROPERTY_READS_OFFSET
    },

    /* AB Searches/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPI_OBJECT_SEARCH,
        0,
        NSPI_OBJECT_SEARCH + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_NSPI_OBJECT_SEARCH_OFFSET
    },

    /* AB Matches/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPI_OBJECT_MATCHES,
        0,
        NSPI_OBJECT_MATCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_NSPI_OBJECT_MATCHES_OFFSET
    },

    /* Proxy Lookups/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPI_PROXY_LOOKUP,
        0,
        NSPI_PROXY_LOOKUP + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_NSPI_PROXY_LOOKUP_OFFSET
    },
    /* ATQ Threads in use */
    {   sizeof(PERF_COUNTER_DEFINITION),
        ATQ_THREADS_TOTAL,
        0,
        ATQ_THREADS_TOTAL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_ATQ_THREADS_TOTAL_OFFSET
    },
    /* ATQ Threads used by LDAP */
    {   sizeof(PERF_COUNTER_DEFINITION),
        ATQ_THREADS_LDAP,
        0,
        ATQ_THREADS_LDAP + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_ATQ_THREADS_LDAP_OFFSET
    },
    /* ATQ Threads used by other services i.e. Kerberos */
    {   sizeof(PERF_COUNTER_DEFINITION),
        ATQ_THREADS_OTHER,
        0,
        ATQ_THREADS_OTHER + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_ATQ_THREADS_OTHER_OFFSET
    },

    /* DRA Inbound Bytes Total */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_TOTAL,
        0,
        DRA_IN_BYTES_TOTAL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_TOTAL_OFFSET
    },

    /* DRA Inbound Bytes Not Compressed */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_NOT_COMP,
        0,
        DRA_IN_BYTES_NOT_COMP + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_NOT_COMP_OFFSET
    },

    /* DRA Inbound Compressed Bytes Before Compression */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_COMP_PRE,
        0,
        DRA_IN_BYTES_COMP_PRE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_COMP_PRE_OFFSET
    },

    /* DRA Inbound Compressed Bytes After Compression */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_COMP_POST,
        0,
        DRA_IN_BYTES_COMP_POST + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_COMP_POST_OFFSET
    },

    /* DRA Outbound Bytes Total */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_TOTAL,
        0,
        DRA_OUT_BYTES_TOTAL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_TOTAL_OFFSET
    },

    /* DRA Outbound Bytes Not Compressed */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_NOT_COMP,
        0,
        DRA_OUT_BYTES_NOT_COMP + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_NOT_COMP_OFFSET
    },

    /* DRA Outbound Compressed Bytes Before Compression */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_COMP_PRE,
        0,
        DRA_OUT_BYTES_COMP_PRE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_COMP_PRE_OFFSET
    },

    /* DRA Outbound Compressed Bytes After Compression */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_COMP_POST,
        0,
        DRA_OUT_BYTES_COMP_POST + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_COMP_POST_OFFSET
    },

    /* Incoming LDAP connections per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAP_NEW_CONNS_PER_SEC,
        0,
        LDAP_NEW_CONNS_PER_SEC + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAP_NEW_CONNS_PER_SEC_OFFSET
    },

    /* Closed LDAP connections per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAP_CLS_CONNS_PER_SEC,
        0,
        LDAP_CLS_CONNS_PER_SEC + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAP_CLS_CONNS_PER_SEC_OFFSET
    },

    /* New SSL/TLS LDAP connections per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAP_SSL_CONNS_PER_SEC,
        0,
        LDAP_SSL_CONNS_PER_SEC + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAP_SSL_CONNS_PER_SEC_OFFSET
    },

    /* LDAP Active threads currently in Netlogon code */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAP_THREADS_IN_NETLOG,
        0,
        LDAP_THREADS_IN_NETLOG + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_LDAP_THREADS_IN_NETLOG_OFFSET
    },

    /* LDAP Active threads currently in Auth code */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAP_THREADS_IN_AUTH,
        0,
        LDAP_THREADS_IN_AUTH + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_LDAP_THREADS_IN_AUTH_OFFSET
    },

    /* LDAP Active threads currently in DRA code */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAP_THREADS_IN_DRA,
        0,
        LDAP_THREADS_IN_DRA + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_LDAP_THREADS_IN_DRA_OFFSET
    },
    
    /* Replication Operations in the queue */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_REPL_QUEUE_OPS,
        0,
        DRA_REPL_QUEUE_OPS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_REPL_QUEUE_OPS_OFFSET
    },

    /* Number of Threads in IDL_DRSGetNCChanges*/
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_TDS_IN_GETCHNGS,
        0,
        DRA_TDS_IN_GETCHNGS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_TDS_IN_GETCHNGS_OFFSET
    },

    /* Number of Threads in IDL_DRSGetNCChanges which aquired the Semaphore*/
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_TDS_IN_GETCHNGS_W_SEM,
        0,
        DRA_TDS_IN_GETCHNGS_W_SEM + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_TDS_IN_GETCHNGS_W_SEM_OFFSET
    },

    /* Number of Remaining Replication Updates for Link Values*/
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_REM_REPL_UPD_LNK,
        0,
        DRA_REM_REPL_UPD_LNK + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_REM_REPL_UPD_LNK_OFFSET
    },
	
    /* Number of Remaining Replication Updates for Total (objects + link values)*/
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_REM_REPL_UPD_TOT,
        0,
        DRA_REM_REPL_UPD_TOT + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_REM_REPL_UPD_TOT_OFFSET
    },

    /* NTDSAPI Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NTDSAPIWRITES,
        0,
        NTDSAPIWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NTDSAPIWRITES_OFFSET
    },

    /* NTDSAPI Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NTDSAPISEARCHES,
        0,
        NTDSAPISEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NTDSAPISEARCHES_OFFSET
    },

    /* NTDSAPI Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NTDSAPIREADS,
        0,
        NTDSAPIREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NTDSAPIREADS_OFFSET
    },
};

int APIENTRY _CRT_INIT(
        HANDLE hInstance,
        DWORD ulReasonBeingCalled,
        LPVOID lpReserved);


int __stdcall LibMain(
        HANDLE hInstance,
        DWORD ulReasonBeingCalled,
        LPVOID lpReserved)
{
    return (_CRT_INIT(hInstance, ulReasonBeingCalled,lpReserved));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\perfdsa\perfutil.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       perfutil.c
//
//--------------------------------------------------------------------------

/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (C) Microsoft Corporation, 1992 - 1998

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
	common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Russ Blake  07/30/92

Revision History:

--*/
//
//  include files
//
#include <NTDSpch.h>
#pragma hdrstop

#include <winperf.h>
#include "mdcodes.h"	 // error message definition
#include <dsconfig.h>
#include "perfmsg.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}


BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList


#define DS_EVENT_CAT_PERFORMANCE	10   /* also in dsevent.h */
/*********************************************\
Log a Performance-category event.

Input
    midEvent	Event message identifier, as defined in mdcodes.mc
    cArgs	Count of arguments in aArgs.
    aArgs	Array of arguments.  First is a number, to be converted to a
		string for output.  The rest are LPCTSTR.

Returns nothing.
\*********************************************/
void LogPerfEvent( ULONG midEvent, UINT	cArgs, LONG_PTR * aArgs)
{
    TCHAR	szBuf[12];
    WORD	eventType;
    HANDLE	hEventSource;

    if( cArgs)
	aArgs[0] = (LONG_PTR)_ultoa( (ULONG)aArgs[0], szBuf, 10);

    switch((midEvent >> 30) & 0xFF) {	    /* map DS event type to sys type */
      case DIR_ETYPE_SECURITY:
	eventType = EVENTLOG_AUDIT_FAILURE;
	break;

      case DIR_ETYPE_WARNING:
	eventType = EVENTLOG_WARNING_TYPE;
	break;

      case DIR_ETYPE_INFORMATIONAL:
	eventType = EVENTLOG_INFORMATION_TYPE;
	break;

      case DIR_ETYPE_ERROR:
      default:
	eventType = EVENTLOG_ERROR_TYPE;
	break;
    }
				    /* open log, write, and close */
    if ((hEventSource = RegisterEventSource( NULL, "NTDS General"))) {
	ReportEvent( hEventSource, eventType, DS_EVENT_CAT_PERFORMANCE,
			midEvent, NULL, (WORD)cArgs, 0, (LPTSTR *)aArgs, NULL);
	DeregisterEventSource( hEventSource);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\perfdsa\perfutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       perfutil.h
//
//--------------------------------------------------------------------------

/*
Copyright (C) Microsoft Corporation, 1992 - 1998

Module Name:
    perfutil.h

Abstract:
    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:
    Russ Blake  7/30/92

Revision History:
    11/1/95	Dave Van Horn	Trim out unused.

--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

/*
 * The definition of the routines in perfutil.c,
 */

DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);
void LogPerfEvent( ULONG midEvent, UINT cArgs, LONG_PTR * aArgs);

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\quicksync\clogfile.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:  clogfile.cxx
//
//  Contents:  Implementation for the LogFile object used in quicksync.
//
//  History:   02-11-01  AjayR   Created.
//
//-----------------------------------------------------------------------------
#include "quicksync.hxx"
#pragma hdrstop


CLogFile::CLogFile():
    _hFile(INVALID_HANDLE_VALUE)
{
}

CLogFile::~CLogFile()
{
    if (INVALID_HANDLE_VALUE != _hFile) {
        //
        // CloseFile.
        //
        CloseHandle(_hFile);
    }
}

HRESULT
CLogFile::CreateLogFile(
    LPCWSTR pszFileName,
    CLogFile **ppLogFile,
    DWORD dwCreateDisposition // defaulted to CREATE_NEW
    )
{
    HRESULT hr = S_OK;
    DWORD dwErr = 0;
    WCHAR szSection[5];
    CLogFile *pLogFile = NULL;
    DWORD dwBytesWritten;

    pLogFile = new CLogFile();
    if (!pLogFile) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pLogFile->_hFile = CreateFile(
                           pszFileName,
                           GENERIC_WRITE | GENERIC_READ,
                           0,
                           NULL,
                           dwCreateDisposition,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL
                           );

    if (pLogFile->_hFile == INVALID_HANDLE_VALUE) {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
        BAIL_ON_FAILURE(hr);
    }

    if (CREATE_NEW == dwCreateDisposition ) {
        //
        // We want to write the unicode beginning file of marker now.
        //
        szSection[0] = 0xFEFF;
        if (!WriteFile(
                 pLogFile->_hFile,
                 szSection,
                 sizeof(WCHAR),
                 &dwBytesWritten,
                 NULL)
            ) {
            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
            BAIL_ON_FAILURE(hr);
        }

    }
    else {
        //
        // Move past the BOM marker and in ready to read mode.
        //
        hr = pLogFile->Reset();
        BAIL_ON_FAILURE(hr);
    }

    *ppLogFile = pLogFile;
    return hr;

error:

    delete pLogFile;
    return hr;
}

HRESULT
CLogFile::LogEntry(
    DWORD dwEntryType,
    HRESULT hr,
    LPCWSTR pszMsg1,
    LPCWSTR pszMsg2,
    LPCWSTR pszMsg3,
    LPCWSTR pszMsg4
    )
{
    DWORD dwLen = 0;
    LPWSTR pszStr = NULL;

    //
    // Calculate the total length of the strings.
    //
    if (pszMsg1) {
        dwLen += wcslen(pszMsg1);
    }
    if (pszMsg2) {
        dwLen += wcslen(pszMsg2);
    }
    if (pszMsg3) {
        dwLen += wcslen(pszMsg3);
    }
    if (pszMsg4) {
        dwLen += wcslen(pszMsg4);
    }
    //
    // Add 25 for, 10 for hr, 5 for spaces(maximum), 1 for \0 and
    // rest for the header (either ERROR | SUCCESS).
    //
    dwLen += 25;

    pszStr = (LPWSTR) AllocADsMem(dwLen * sizeof(WCHAR));

    if (!pszStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (dwEntryType == ENTRY_SUCCESS) {
        swprintf(pszStr, L"%S 0x%X:", L"SUCCESS:", hr); 
 
    } 
    else {
        swprintf(pszStr, L"%S 0x%X:", L"ERROR:", hr);
    }

    if (pszMsg1) {
        wcscat(pszStr, pszMsg1);
    }

    if (pszMsg2) {
        wcscat(pszStr, L" ");
        wcscat(pszStr, pszMsg2);
    }

    if (pszMsg3) {
        wcscat(pszStr, L" ");
        wcscat(pszStr, pszMsg3);
    }

    if (pszMsg4) {
        wcscat(pszStr, L" ");
        wcscat(pszStr, pszMsg4);
    }

    hr = WriteEntry(pszStr);
    BAIL_ON_FAILURE(hr);

error:

   if (pszStr) {
       FreeADsStr(pszStr);
   }

   return hr;
}

//
// Attribute pszAttributeName on object with pszMailNicknameSrc,
// had dwNumVals values that need to set on the target object in the
// second pass.
//
HRESULT
CLogFile::LogRetryRecord(
    LPCWSTR pszAttributeName,
    LPCWSTR pszMailNicknameSrc,
    ADS_SEARCH_COLUMN *pCol
    )
{
    HRESULT hr = S_OK;
    DWORD dwNumVals = 0;
    DWORD dwLen = 0;
    DWORD dwCtr;
    LPWSTR *pszDNs = NULL;
    LPWSTR pszStrVal = 0;
    WCHAR szVals[10];

    if (!pCol
        || pCol->dwADsType != ADSTYPE_DN_STRING
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    dwNumVals = pCol->dwNumValues;

    if (!dwNumVals
        || !pszAttributeName
        || !pszMailNicknameSrc
        || !pCol->pADsValues
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    dwLen = wcslen(pszAttributeName) + wcslen(pszMailNicknameSrc);

    //
    // Add for 2 ;'s one \0 and integer values
    //
    dwLen += 8;

    pszStrVal = (LPWSTR) AllocADsMem(dwLen * sizeof(WCHAR));
    if (!pszStrVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Format of record is going to be 
    // attribName;pszMailNicknamesrc;dwNumVals <nextnLines>
    // pszDNVals
    //
    dwCtr = wsprintf(szVals, L"%d", dwNumVals);
    if (!dwCtr) {
        printf("Printf failed !\n");
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    wcscpy(pszStrVal, pszAttributeName);
    wcscat(pszStrVal, L";");
    wcscat(pszStrVal, pszMailNicknameSrc);
    wcscat(pszStrVal, L";");
    wcscat(pszStrVal, szVals);

    //
    // Build the array of dn strings.
    //
    pszDNs = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * dwNumVals);
    if (!pszDNs) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwCtr = 0; dwCtr < dwNumVals; dwCtr++) {
        pszDNs[dwCtr] = AllocADsStr(pCol->pADsValues[dwCtr].DNString);
        if (!pszDNs[dwCtr]) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    hr = WriteEntry(pszStrVal);
    BAIL_ON_FAILURE(hr);

    for (dwCtr = 0; dwCtr < dwNumVals; dwCtr++) {
        hr = WriteEntry(pszDNs[dwCtr]);
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pszStrVal) {
        FreeADsStr(pszStrVal);
    }

    if (pszDNs) {
        for (dwCtr = 0; dwCtr < dwNumVals; dwCtr++) {
            if (pszDNs[dwCtr]) {
                FreeADsStr(pszDNs[dwCtr]);
            }
        }
        FreeADsMem(pszDNs);
    }

    return hr;
}

//
// Returns the next retry recrod in the appropriate format.
// If no more records S_FALSE is returned, S_OK on success
// and any other appropriate failure error code otherwise.
//
HRESULT
CLogFile::GetRetryRecord(
    LPWSTR *ppszAttrname,
    LPWSTR *ppszNickname,
    ADS_SEARCH_COLUMN *pCol
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszNextLine = NULL;
    LPWSTR pszTemp = NULL;
    LPWSTR pszStart = NULL;
    DWORD dwCtr = 0;
    DWORD dwNumVals = 0;
    PADSVALUE pVals = NULL;

    *ppszAttrname = NULL;
    *ppszNickname = NULL;
    memset(pCol, 0, sizeof(ADS_SEARCH_COLUMN));

    hr = GetNextLine(&pszNextLine);
    if (hr == S_FALSE) {
        return S_FALSE;
    }
    BAIL_ON_FAILURE(hr);

    pszStart = pszNextLine;
    //
    // Get the attribute name.
    // 
    pszTemp = pszNextLine;
    while (pszNextLine 
           && *pszNextLine
           && *pszNextLine != L';'
           ) {
        pszNextLine++;
    }

    if (!pszNextLine
        || !*pszNextLine
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    } 
    else {
        *pszNextLine = L'\0';
        *ppszAttrname = AllocADsStr(pszTemp);
        if (!*ppszAttrname) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        pszNextLine++;
    }

    //
    // Get the mailNickname.
    // 
    pszTemp = pszNextLine;
    while (pszNextLine 
           && *pszNextLine
           && *pszNextLine != L';'
           ) {
        pszNextLine++;
    }

    if (!pszNextLine
        || !*pszNextLine
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    } 
    else {
        *pszNextLine = L'\0';
        *ppszNickname = AllocADsStr(pszTemp);
        if (!*ppszNickname) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        pszNextLine++;
    }

    if (!pszNextLine
        || !*pszNextLine) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    dwCtr = swscanf(pszNextLine, L"%d", &dwNumVals);

    if (dwCtr != 1
        || !dwNumVals
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    pVals = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE) * dwNumVals);
    if (!pVals) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }


    for (dwCtr = 0; dwCtr < dwNumVals; dwCtr++) {
        hr = GetNextLine(&(pVals[dwCtr].DNString));
        BAIL_ON_FAILURE(hr);
    }

    pCol->pszAttrName = AllocADsStr(*ppszAttrname);
    if (!pCol->pszAttrName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // If we got here we have all the info we need.
    //
    pCol->dwADsType = ADSTYPE_DN_STRING;
    pCol->dwNumValues = dwNumVals;
    pCol->pADsValues = pVals;

error:

    if (FAILED(hr)) {
        if (*ppszAttrname) {
            FreeADsStr(*ppszAttrname);
            *ppszAttrname = NULL;
        }

        if (*ppszNickname) {
            FreeADsStr(*ppszAttrname);
        }

        if (pCol->pszAttrName) {
            FreeADsStr(pCol->pszAttrName);
            pCol->pszAttrName = NULL;
        }

        if (pVals) {
            //
            // Go through and free the entries.
            //
            for (dwCtr = 0; dwCtr < dwNumVals; dwCtr++) {
                if (pVals[dwCtr].DNString) {
                    FreeADsStr(pVals[dwCtr].DNString);
                    pVals[dwCtr].DNString = NULL;
                }
            }
            FreeADsMem(pVals);
            pVals = NULL;
        }
    }

    //
    // Always free the first line.
    //
    if (pszStart) {
        FreeADsStr(pszStart);
    }

    return hr;
}

//
// Set to beginning of file past the unicode marker.
//
HRESULT
CLogFile::Reset()
{
    HRESULT hr = S_OK;

    if (!SetFilePointer(
             _hFile,
             sizeof(WCHAR), // want to go past the BOM char.
             0,
             FILE_BEGIN
             )
        ) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

HRESULT
CLogFile::WriteEntry(LPWSTR pszString)
{
    HRESULT hr = S_OK;
    DWORD dwLen = 0;
    DWORD dwNumWritten = 0;
    WCHAR szEndOfLine[3] = L"\n\r";

    szEndOfLine[0] = 0x000D;
    szEndOfLine[1] = 0x000A;

    dwLen = wcslen(pszString);

    //
    // Write the string and then add the \n.
    //
    if (!WriteFile(
             _hFile,
             pszString,
             dwLen * sizeof(WCHAR),
             &dwNumWritten,
             NULL
             )
        ) {
        //
        // We could not write to the file.
        //
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (!WriteFile(
             _hFile,
             szEndOfLine,
             sizeof(WCHAR) * 2,
             &dwNumWritten,
             NULL)
        ) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

error:

    return hr;
}

//
// S_FALSE if there are no more lines or any other error code.
//
HRESULT
CLogFile::GetNextLine(LPWSTR *pszLine)
{
    HRESULT hr = S_OK;
    LPWSTR pszStr = NULL;
    BOOL fDone = FALSE;
    WCHAR wChar;
    DWORD dwCtr = 0;

    *pszLine = NULL;
    //
    // Line should not be more than 5k long.
    //
    pszStr = (LPWSTR) AllocADsMem(sizeof(WCHAR) * 5000);

    if (!pszStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    while (!fDone) {
        wChar = GetNextChar();

        if (0x000D == wChar) {
            if (GetNextChar() == 0x000A) {
                //
                // We have reached the end of the line.
                //
                pszStr[dwCtr] = L'\0';
                break;
            } else {
                PushBackChar();
            }
        } 
        else if (WEOF == wChar) {
            //
            // EOF, send back string if there is a string,
            // if not just break.
            //
            if (dwCtr) {
                pszStr[dwCtr] = L'\0';
            } 
            else {
                hr = S_FALSE;
            }
            break;
        }

        pszStr[dwCtr] = wChar;
        dwCtr++;
    }

    if (dwCtr) {
        *pszLine = pszStr;
    }

error:

   if ((hr != S_OK)
       && pszStr) {
       FreeADsStr(pszStr);
   }

   return hr;
}

HRESULT
CLogFile::PushBackChar()
{
    LONG lBack = sizeof(WCHAR);
    lBack *= -1;

    if (!SetFilePointer(
             _hFile,
             lBack,
             0,
             FILE_CURRENT
             )
        ) {
        return (HRESULT_FROM_WIN32(GetLastError()));
    }
    return S_OK;
}

WCHAR
CLogFile::GetNextChar()
{
    DWORD dwNumRead = 0;
    WCHAR wChar;

    if (!ReadFile(
             _hFile,
             &wChar,
             sizeof(WCHAR),
             &dwNumRead,
             NULL
             )
        ) {
        printf("ERROR ******** Cannot proceed read file error *****\n");
        wChar = EOF;
    }

    if (dwNumRead == 0) {
        //
        // EOF cause otherwise we would have hit the failure.
        //
        wChar = WEOF;
    }
    
    return wChar;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rendom\inc\dclistparser.h ===
// Dclistparser.h: interface for the MyContent class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _DCLISTPARSER_H
#define _DCLISTPARSER_H

//#include "rendom.h"
#include "SAXContentHandlerImpl.h"

#define DCSCRIPT_DCLIST           L"DcList"
#define DCSCRIPT_HASH             L"Hash"
#define DCSCRIPT_SIGNATURE        L"Signature"
#define DCSCRIPT_DC               L"DC"
#define DCSCRIPT_DC_NAME          L"Name"
#define DCSCRIPT_DC_STATE         L"State"
#define DCSCRIPT_DC_PASSWORD      L"Password"
#define DCSCRIPT_DC_LASTERROR     L"LastError"
#define DCSCRIPT_DC_LASTERRORMSG  L"LastErrorMsg"
#define DCSCRIPT_DC_FATALERRORMSG L"FatalErrorMsg"

//
// NTDSContent
//
// Implements the SAX Handler interface
// 
class CXMLDcListContentHander : public SAXContentHandlerImpl  
{
public:
    enum DcAttType {

        DC_ATT_TYPE_NONE = 0,
        DC_ATT_TYPE_NAME,
        DC_ATT_TYPE_STATE,
        DC_ATT_TYPE_PASSWORD,
        DC_ATT_TYPE_LASTERROR,
        DC_ATT_TYPE_LASTERRORMSG,
        DC_ATT_TYPE_FATALERRORMSG
                                 
    };
    
    // the order of the enumeration is important
    enum DcParsingStatus {

        SCRIPT_STATUS_WAITING_FOR_DCLIST = 0,
        SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT,
        SCRIPT_STATUS_PARSING_DCLIST_ATT,
        SCRIPT_STATUS_PARSING_HASH,
        SCRIPT_STATUS_PARSING_SIGNATURE
    };

    CXMLDcListContentHander(CEnterprise *p_Enterprise);
    virtual ~CXMLDcListContentHander();
    
    virtual HRESULT STDMETHODCALLTYPE startElement( 
        /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
        /* [in] */ int cchNamespaceUri,
        /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
        /* [in] */ int cchLocalName,
        /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
        /* [in] */ int cchRawName,
        /* [in] */ ISAXAttributes __RPC_FAR *pAttributes);
    
    virtual HRESULT STDMETHODCALLTYPE endElement( 
        /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
        /* [in] */ int cchNamespaceUri,
        /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
        /* [in] */ int cchLocalName,
        /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
        /* [in] */ int cchRawName);

    virtual HRESULT STDMETHODCALLTYPE startDocument();

    virtual HRESULT STDMETHODCALLTYPE characters( 
        /* [in] */ const wchar_t __RPC_FAR *pwchChars,
        /* [in] */ int cchChars);

private:

    inline
    DcParsingStatus 
    CurrentDcParsingStatus() {return m_eDcParsingStatus;}

    inline
    DcAttType
    CurrentDcAttType()       {return m_eDcAttType;}

    inline
    VOID
    SetDcParsingStatus(DcParsingStatus p_status) {m_eDcParsingStatus = p_status;}

    inline
    VOID
    SetCurrentDcAttType(DcAttType p_AttType) {m_eDcAttType = p_AttType;}

    CRenDomErr                   *m_Error;

    DcParsingStatus              m_eDcParsingStatus; 
    DcAttType                    m_eDcAttType;

    CDcList                      *m_DcList;

    CDc                          *m_dc;
    WCHAR                        *m_Name;
    DWORD                         m_State;
    WCHAR                        *m_Password;
    DWORD                         m_LastError;
    WCHAR                        *m_LastErrorMsg;
    WCHAR                        *m_FatalErrorMsg;
    
};

#endif // _DCLISTPARSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\quicksync\ctgtmgr.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:  ctgtmgr.cxx
//
//  Contents:  Implementation of the Target Manager object for quicksync.
//
//  History:   02-12-01  AjayR   Created.
//
//-----------------------------------------------------------------------------
#include "quicksync.hxx"
#pragma hdrstop


//
// Standard constructor.
//
CTargetMgr::CTargetMgr():
    _pSrchSource(NULL),
    _pSrchBaseTgt(NULL),
    _pTgtContainer(NULL),
    _pszFilterTemplate(NULL),
    _pLogFileSuccess(NULL),
    _pLogFileFailures(NULL),
    _pPathname(NULL)
{
}

//
// Standard destructor.
//
CTargetMgr::~CTargetMgr()
{
    if (_pSrchSource) {
        _pSrchSource->Release();
    }
    
    if (_pSrchBaseTgt) {
        _pSrchBaseTgt->Release();
    }

    if (_pTgtContainer) {
        _pTgtContainer->Release();
    }

    if (_pPathname) {
        _pPathname->Release();
    }

    if (_pszFilterTemplate) {
        FreeADsStr(_pszFilterTemplate);
    }
    //
    // Do not delete as this is managed by session.
    //
    _pLogFileSuccess = _pLogFileFailures = NULL;
}


HRESULT
CTargetMgr::CreateTargetMgr(
        IDirectorySearch *pSrchSource,
        IDirectorySearch *pSrchBaseTgt,
        IDirectoryObject *pTgtContainer,
        LPWSTR pszFilterTemplate,
        CLogFile *pLogFileSuccess,
        CLogFile *pLogFileFailures,
        CTargetMgr **ppMgr
        )
{
    HRESULT hr = S_OK;
    CTargetMgr *pMgr = NULL;

    pMgr = new CTargetMgr();

    if (!pMgr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // This is used when we need to map dn attributes.
    //
    hr = pSrchSource->QueryInterface(
             IID_IDirectorySearch,
             (void **) &pMgr->_pSrchSource
             );
    BAIL_ON_FAILURE(hr);

    //
    // Used to locate the object on the target.
    //
    hr = pSrchBaseTgt->QueryInterface(
             IID_IDirectorySearch,
             (void **) &pMgr->_pSrchBaseTgt
             );
    BAIL_ON_FAILURE(hr);

    hr = pTgtContainer->QueryInterface(
             IID_IDirectoryObject,
             (void **) &pMgr->_pTgtContainer
             );
    BAIL_ON_FAILURE(hr);

    hr = CoCreateInstance(
             CLSID_Pathname,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsPathname,
             (void **) &pMgr->_pPathname
             );
    BAIL_ON_FAILURE(hr);
                          
    pMgr->_pLogFileSuccess  = pLogFileSuccess;
    pMgr->_pLogFileFailures = pLogFileFailures;

    *ppMgr = pMgr;

    return hr;
error:

    if (pMgr) {
        delete pMgr;
    }

    return hr;
}

//
// Locates target that has mailNickname=pszMailNickName and
// deletes it. If more than one entry is found, an error is logged.
// We do not do a tombstone search for the target as we do not need
// to do anything if the object is already deleted.
//
HRESULT
CTargetMgr::DelTargetObject(
    LPWSTR pszSrcADsPath,
    LPWSTR pszMailNickname
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszFilter = NULL;
    LPWSTR pszTgtADsPath = NULL;
    IADsContainer *pIADsCont = NULL;
    IADs          *pIADs = NULL;
    BSTR bstrName = NULL;
    BSTR bstrParent = NULL;

    //
    // The filter or name is not going to be 5k long
    //
    pszFilter = (LPWSTR) AllocADsMem(5000 * sizeof(WCHAR));
    if (!pszFilter) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

     hr = LocateTarget(
             TRUE, // return the ADsPath
             pszMailNickname,
             &pszTgtADsPath
             );
    if (FAILED(hr)) {
        //
        // Means we could not find the target, so nothing to delete.
        //
        wcscpy(pszFilter, L"No matching entry found on target no delete for:");
        wcscat(pszFilter, pszSrcADsPath);
        _pLogFileSuccess->LogEntry(
            ENTRY_SUCCESS,
            hr,
            pszFilter
            );
        BAIL_ON_FAILURE(E_FAIL);
    }

    //
    // Bind to the value of ADsPath, get its parent and name
    //
    hr = ADsOpenObject(
             pszMailNickname,
             g_pszUserNameTarget,
             g_pszUserPwdTarget,
             ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
             IID_IADs,
             (void **) &pIADs
             );

    if (FAILED(hr)) {
        wcscpy(pszFilter, L"Could not bind to target object for :");
        wcscat(pszFilter, pszSrcADsPath);

        _pLogFileFailures->LogEntry(
            ENTRY_FAILURE,
            hr,
            pszFilter
            );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Make a common error string.
    //
    wcscpy(
        pszFilter,
        L"Failed deleting object:"
        );
    wcscat(pszFilter, pszSrcADsPath);
    
    hr = pIADs->get_Name(&bstrName);
    if (SUCCEEDED(hr)) {
        hr = pIADs->get_Parent(&bstrParent);
        if (SUCCEEDED(hr)) {
            hr = ADsOpenObject(
                     bstrParent,
                     g_pszUserNameTarget,
                     g_pszUserPwdTarget,
                     ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                     IID_IADsContainer,
                     (void **) &pIADsCont
                     );
            if (SUCCEEDED(hr)) {
                hr = pIADsCont->Delete(
                         L"Contact",
                         bstrName
                         );
            }            
        }
    }

    //
    // If we failed in one of the above operations, log error.
    //
    if (hr == E_ADS_BAD_PARAMETER) {
        //
        // Log entry saying this is probably because the target is not
        // a contact but likely a user or mailbox.
        //
        _pLogFileFailures->LogEntry(
            ENTRY_FAILURE,
            hr,
            pszFilter,
            L" the failure was likely because target was not a contact."
            );
        BAIL_ON_FAILURE(hr);
    }
    else if (FAILED(hr)) {
        _pLogFileFailures->LogEntry(
            ENTRY_FAILURE,
            hr,
            pszFilter
            );
        BAIL_ON_FAILURE(hr);
    }
    else {
        //
        // Log Success Entry.
        //
        wcscpy(pszFilter, L"Deleted target entry :");
        wcscat(pszFilter, pszTgtADsPath);
        wcscat(pszFilter, L" for source :");
        wcscat(pszFilter, pszSrcADsPath);
        _pLogFileSuccess->LogEntry(
            ENTRY_SUCCESS,
            hr,
            pszFilter
            );
    }

error:
    //
    // Cleanup, all logging should be complete by now.
    //
    if (pszFilter) {
        FreeADsStr(pszFilter);
    }

    if (pszTgtADsPath) {
        FreeADsStr(pszTgtADsPath);
    }

    if (pIADsCont) {
        pIADsCont->Release();
    }

    if (pIADs) {
        pIADs->Release();
    }
    
    if (bstrName) {
        SysFreeString(bstrName);
    }

    if (bstrParent) {
        SysFreeString(bstrParent);
    }
    
    return hr;
}


HRESULT
CTargetMgr::UpdateTarget(
    LPCWSTR pszADsPath,
    PADS_ATTR_INFO pAttribsToSet,
    DWORD dwCount
    )
{
    HRESULT hr = S_OK;
    IDirectoryObject *pDirObj = NULL;
    DWORD dwNumMod = 0;

    hr = ADsOpenObject(
             pszADsPath,
             g_pszUserNameTarget,
             g_pszUserPwdTarget,
             ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
             IID_IDirectoryObject,
             (void **) &pDirObj
             );
    BAIL_ON_FAILURE(hr);

    hr = pDirObj->SetObjectAttributes(
             pAttribsToSet,
             dwCount,
             &dwNumMod
             );
    BAIL_ON_FAILURE(hr);

error:

    if (pDirObj) {
        pDirObj->Release();
    }

    return hr;
}


HRESULT
CTargetMgr::CreateTarget(
    LPWSTR pszCN,
    PADS_ATTR_INFO pAttribsToSet,
    DWORD dwCount
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispObj = NULL;
    DWORD dwNumMod = 0;
    LPWSTR pszCNVal = NULL;
    BSTR bstrInString = NULL;
    BSTR bstrCNString = NULL;
    
    pszCNVal = (LPWSTR) AllocADsMem(
        (wcslen(pszCN) + wcslen(L"cn=") + 1) * sizeof(WCHAR)
        );

    if (!pszCNVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wcscpy(pszCNVal, L"cn=");
    wcscat(pszCNVal, pszCN);

    bstrInString = SysAllocString(pszCNVal);
    if (!bstrInString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = _pPathname->GetEscapedElement(
             0,
             bstrInString,
             &bstrCNString
             );
    BAIL_ON_FAILURE(hr);

    hr = _pTgtContainer->CreateDSObject(
             bstrCNString,
             pAttribsToSet,
             dwCount,
             &pDispObj
             );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispObj) {
            pDispObj->Release();
    }

    if (pszCNVal) {
        FreeADsStr(pszCNVal);
    }

    if (bstrCNString) {
        SysFreeString(bstrCNString);
    }

    if (bstrInString) {
        SysFreeString(bstrInString);
    }

    return hr;
}


//
// Maps the incoming DN to the appropriate new DN.
//
HRESULT
CTargetMgr::MapDNAttribute(
    LPCWSTR pszSrcServer,
    LPCWSTR pszSrcDN,
    LPWSTR *ppszTgtDN
    )
{
    HRESULT hr = S_OK;
    ADS_SEARCHPREF_INFO adsSearchPrefInfo[1];
    IDirectoryObject *pDirObjSrc = NULL;
    LPWSTR pszTempStr = NULL;
    LPWSTR pszNickname = NULL;
    LPWSTR szAttrsSrc[] = { L"mailNickname" };
    LPWSTR szAttrsTgt[] = { L"distinguishedName" };
    DWORD dwNum;
    PADS_ATTR_INFO pAttrInfo = NULL;
    ADS_SEARCH_HANDLE hSrchTgt = NULL;
    ADS_SEARCH_COLUMN colDN;

    memset(&colDN, 0, sizeof(ADS_SEARCH_COLUMN));
    *ppszTgtDN = NULL;
    //
    // Has to hold LDAP://<pszSrcServer>/<pszSrcDn>.
    // so len of both variables + 9 (LDAP:// / and \0.
    //
    dwNum = 9 + wcslen(pszSrcServer) + wcslen(pszSrcDN);

    pszTempStr = (LPWSTR) AllocADsMem(dwNum * sizeof(WCHAR));

    if (!pszTempStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wcscpy(pszTempStr, L"LDAP://");
    wcscat(pszTempStr, pszSrcServer);
    wcscat(pszTempStr, L"/");
    wcscat(pszTempStr, pszSrcDN);

    //
    // Need the mailNickName to search on the target.
    //
    hr = ADsOpenObject(
             pszTempStr,
             g_pszUserNameSource,
             g_pszUserPwdSource,
             ADS_FAST_BIND | ADS_SECURE_AUTHENTICATION,
             IID_IDirectoryObject,
             (void **) &pDirObjSrc
             );
    BAIL_ON_FAILURE(hr);

    hr = pDirObjSrc->GetObjectAttributes(
             szAttrsSrc,
             1,
             &pAttrInfo,
             &dwNum
             );
    BAIL_ON_FAILURE(hr);

    if ((dwNum != 1)
        || !pAttrInfo->pADsValues
        || pAttrInfo->dwNumValues != 1
        || !pAttrInfo->pADsValues[0].CaseExactString
        || !pAttrInfo->pszAttrName
        || (_wcsicmp(szAttrsSrc[0], pAttrInfo->pszAttrName))
        ) {
        //
        // Need the list to be 1 precisely and also the right attr.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    } 
    else {
        pszNickname = pAttrInfo->pADsValues[0].CaseExactString;
    }

    if (pszTempStr) {
        FreeADsStr(pszTempStr);
        pszTempStr = NULL;
    }

    //
    // Allocate memory for filter
    // (mailNickName=<pszNickname>
    //
    dwNum = wcslen(L"(mailNickname=)") + wcslen(pszNickname) + 1;

    pszTempStr = (LPWSTR) AllocADsMem(dwNum * sizeof(WCHAR));

    if (!pszTempStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wcscpy(pszTempStr, L"(mailNickname=");
    wcscat(pszTempStr, pszNickname);
    wcscat(pszTempStr, L")");

    //
    // Now we ca

    adsSearchPrefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    adsSearchPrefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    adsSearchPrefInfo[0].vValue.Integer = ADS_SCOPE_SUBTREE;

    hr = _pSrchBaseTgt->SetSearchPreference(
             adsSearchPrefInfo,
             1
             );

    if (S_OK != hr) {
        //
        // Force a bail here cause we cannot proceed with any certainity.
        //
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PATHNAME);
    }

    //
    // All set to locate the target.
    //
    hr = _pSrchBaseTgt->ExecuteSearch(
             pszTempStr,
             szAttrsTgt,
             1,
             &hSrchTgt
             );
    BAIL_ON_FAILURE(hr);

    hr = _pSrchBaseTgt->GetNextRow(hSrchTgt);
    if (hr != S_OK) {
        //
        // No mathing record was found.
        //
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PATHNAME);
    }

    //
    // Should find only one row.
    //
    hr = _pSrchBaseTgt->GetNextRow(hSrchTgt);
    if (S_OK == hr) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PATHNAME);
    }

    hr = _pSrchBaseTgt->GetFirstRow(hSrchTgt);
    if (S_OK != hr) {
        //
        // Should log failure and go on to next record.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = _pSrchBaseTgt->GetColumn(
             hSrchTgt,
             L"distinguishedName",
             &colDN
             );
    BAIL_ON_FAILURE(hr);

    if (ADSTYPE_DN_STRING != colDN.dwADsType
        || !colDN.pADsValues
        || !colDN.dwNumValues
        || !colDN.pADsValues[0].DNString
        || !colDN.pszAttrName
        || _wcsicmp(colDN.pszAttrName, szAttrsTgt[0])
        ) {
        //
        // Wrong type or bad data.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    *ppszTgtDN = AllocADsStr(colDN.pADsValues[0].DNString);

    if (!*ppszTgtDN) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }


error:

    if (hSrchTgt) {
        _pSrchBaseTgt->CloseSearchHandle(hSrchTgt);
    }

    if (pDirObjSrc) {
        pDirObjSrc->Release();
    }

    _pSrchBaseTgt->FreeColumn(&colDN);

    //
    // pAttrInfo, needs to be freed.
    //
    if (pAttrInfo) {
        FreeADsMem(pAttrInfo);
    }

    //
    // pszNickname is not freed as it is just a pointer.
    //

    if (pszTempStr) {
        FreeADsStr(pszTempStr);
    }

    return hr;
}


//
// Tries to locate the object on the target that has the
// matching mailNickname.
// If fExtraInfo is valid, then we will try and see if the
// matched target object can have targetAddress updated or not.
//
HRESULT
CTargetMgr::LocateTarget(
    BOOL fADsPath, // set to true means return path not dn
    LPCWSTR pszMailNickname,
    LPWSTR  *ppszRetVal,
    PBOOL pfExtraInfo // defaulted to NULL
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszFilter = NULL;
    DWORD dwNum = 0;
    ADS_SEARCHPREF_INFO adsSearchPrefInfo[1];
    LPWSTR szAttrsTgt[] = { L"distinguishedName", L"ADsPath"};
    LPWSTR szAttrsTgtExt[] = { 
                            L"distinguishedName",
                            L"ADsPath",
                            L"homeMDB",
                            L"mailNickname",
                            L"mail"
                            };
    ADS_SEARCH_HANDLE hSrchTgt = NULL;
    ADS_SEARCH_COLUMN colDN;
    ADS_SEARCH_COLUMN colMail;
    ADS_SEARCH_COLUMN colHomeMDB;
    BOOL fNeedExtraInfo = FALSE;
    BOOL fMail = FALSE;
    BOOL fMDB = FALSE;

    if (pfExtraInfo != NULL) {
        fNeedExtraInfo = TRUE;
        //
        // Return value is true for this by default.
        //
        *pfExtraInfo = FALSE;
    }

    //
    // Set all the returnparams appropriately.
    //
    *ppszRetVal = NULL;

    memset(&colDN, 0, sizeof(ADS_SEARCH_COLUMN));
    memset(&colMail, 0, sizeof(ADS_SEARCH_COLUMN));
    memset(&colHomeMDB, 0, sizeof(ADS_SEARCH_COLUMN));

    //
    // Filter is (mailNickname=<pszMailNickname)
    //
    dwNum = wcslen(L"(mailNickname=)") + wcslen(pszMailNickname) + 1;

    pszFilter = (LPWSTR) AllocADsMem(dwNum * sizeof(WCHAR));

    if (!pszFilter) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wcscpy(pszFilter, L"(mailNickname=");
    wcscat(pszFilter, pszMailNickname);
    wcscat(pszFilter, L")");

    //
    // Now we can do the search and make sure that there is only
    // one and precisely one match.
    //
    adsSearchPrefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    adsSearchPrefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    adsSearchPrefInfo[0].vValue.Integer = ADS_SCOPE_SUBTREE;

    hr = _pSrchBaseTgt->SetSearchPreference(
             adsSearchPrefInfo,
             1
             );

    if (S_OK != hr) {
        //
        // Force a bail here cause we cannot proceed with any certainity.
        //
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PATHNAME);
    }

    //
    // All set to locate the target.
    //
    hr = _pSrchBaseTgt->ExecuteSearch(
             pszFilter,
             fNeedExtraInfo ? szAttrsTgtExt : szAttrsTgt,
             fNeedExtraInfo ? 5 : 2, // 2 attrs always, path and dn
             &hSrchTgt
             );
    BAIL_ON_FAILURE(hr);

    hr = _pSrchBaseTgt->GetNextRow(hSrchTgt);
    if (hr != S_OK) {
        //
        // No mathing record was found.
        //
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PATHNAME);
    }

    //
    // Should find only one row.
    //
    hr = _pSrchBaseTgt->GetNextRow(hSrchTgt);
    if (S_OK == hr) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }

    //
    // No reason why this should fail but if it does go on.
    //
    hr = _pSrchBaseTgt->GetFirstRow(hSrchTgt);
    if (S_OK != hr) {
        //
        // Should log failure and go on to next record.
        //
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PATHNAME);
    }

    hr = _pSrchBaseTgt->GetColumn(
             hSrchTgt,
             fADsPath ? szAttrsTgt[1] : szAttrsTgt[0],
             &colDN
             );
    BAIL_ON_FAILURE(hr);

    //
    // It has to be a string, either dn or caseIgnore.
    //
    if (ADSTYPE_DN_STRING != colDN.dwADsType
        && ADSTYPE_CASE_IGNORE_STRING != colDN.dwADsType) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Now for the rest of the sanity check.
    //
    if (!colDN.pADsValues
        || !colDN.dwNumValues
        || !colDN.pADsValues[0].DNString
        || !colDN.pszAttrName
        || _wcsicmp(
               colDN.pszAttrName, 
               fADsPath ? szAttrsTgt[1] : szAttrsTgt[0]
               )
        ) {
        //
        // Wrong type or bad data.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    if (fNeedExtraInfo) {
        //
        // Need to see if homeMDB/or mail are present.
        //
        hr = _pSrchBaseTgt->GetColumn(
                 hSrchTgt,
                 L"mail",
                 &colMail
                 );
        if (FAILED(hr)) {
            memset(&colMail, 0, sizeof(ADS_SEARCH_COLUMN));
        } 
        else {
            fMail = TRUE;
        }

        hr = _pSrchBaseTgt->GetColumn(
                 hSrchTgt,
                 L"homeMDB",
                 &colHomeMDB
                 );
        if (FAILED(hr)) {
            memset(&colHomeMDB, 0, sizeof(ADS_SEARCH_COLUMN));
        } 
        else {
            fMDB = TRUE;
        }

        //
        // Both flags should have appropriate values at this point.
        //
        if (!fMDB && fMail) {
            *pfExtraInfo = TRUE;
        }

        hr = S_OK;

    }
    *ppszRetVal = AllocADsStr(colDN.pADsValues[0].DNString);

    if (!*ppszRetVal) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

error:

    _pSrchBaseTgt->FreeColumn(&colDN);
    _pSrchBaseTgt->FreeColumn(&colMail);
    _pSrchBaseTgt->FreeColumn(&colHomeMDB);

    if (hSrchTgt) {
        _pSrchBaseTgt->CloseSearchHandle(hSrchTgt);
    }

    if (pszFilter) {
        FreeADsStr(pszFilter);
    }

    //
    // If we could not find the object logging will take plac
    // by the caller of this method.
    //
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\quicksync\main.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:  main.cxx
//
//  Contents:  QuickSync tool wmain routine.
//
//
//  History:   02-09-01  AjayR   Created.
//
//---------------------------------------- ------------------------------------

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//    Include header files                                              //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#include <quicksync.hxx>
#pragma  hdrstop

const LPWSTR szAttributesToMap[] = {
        L"sAMAccountName",
        L"mailNickName",
        L"displayName",
        L"givenName",
        L"sn",
        L"manager",
        L"telephoneNumber",
        L"physicalDeliveryOfficeName",
        L"title",
        L"department",
        L"company",
        L"targetAddress",
        L"ADsPath",
        L"isDeleted",
        L"objectClass",
        L"cn",
        L"mail",
        L"mailAddress",
        L"msExchALObjectVersion",
        L"msExchHideFromAddressLists",
        L"mAPIRecipient",
        L"proxyAddresses",
        L"textEncodedORAddress",
        L"legacyExchangeDN",
//        L"showInAddressBook",
        L"extensionAttribute5"

//        L"directReports"
};

const DWORD g_dwAttribCount = sizeof(szAttributesToMap)/sizeof(LPWSTR);

//
// Global variable declarations.
//
LPWSTR g_pszUserNameSource  = NULL;
LPWSTR g_pszUserPwdSource   = NULL;
LPWSTR g_pszUserNameTarget  = NULL;
LPWSTR g_pszUserPwdTarget   = NULL;
LPWSTR g_pszInputFileName   = L".\\quicksync.ini";
LPWSTR g_pszUSN             = L"0";

typedef struct _sessiondetails {
    LPWSTR pszSourceServerName;
    LPWSTR pszSourceContainer;
    LPWSTR pszTargetServer;
    LPWSTR pszTargetContainer;
    LPWSTR pszUSN;
    DWORD  dwNumABVals;
    LPWSTR *ppszABVals;
} SESSION_DETAILS, *PSESSION_DETAILS;

void 
PrintUsage()
{
    printf("\nUsage for quickSync Tool\n");
    printf("quikcSync <iniFileName> <usn> [tgtUserName] [tgtPassword]");
    printf(" [srcUserName] [srcPassword]\n");
    printf("\n");
}

HRESULT
ProcessInputArgs(
    int cArgs,
    LPWSTR *pArgs
    )
{
    HRESULT hr = S_OK;

    //
    // Either 2, 4 or 6 params.
    // Minimum is 2 - the ini file name and the USN.
    // If there are 4 then the next 2 are the tgt userName and pwd.
    // If there are 6 then the next 2 are the src userName and pwd.
    //
    switch (cArgs) {

    case 7:
        g_pszUserNameSource = pArgs[5];
        g_pszUserPwdSource  = pArgs[6];
        //
        // We will fall through by design.
        //
    case 5:
        g_pszUserNameTarget = pArgs[3];
        g_pszUserPwdTarget  = pArgs[4];
        //
        // Again fall through by design.
        //
    case 3:

        //
        // This is what is expected in most cases.
        //
        g_pszInputFileName = pArgs[1];
        g_pszUSN           = pArgs[2];
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }


    if (!g_pszInputFileName || !g_pszUSN) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);        
    } 

error:

    return hr;
}

void 
FreeSessionDetails(PSESSION_DETAILS pSessionDetails)
{
    DWORD dwCtr = 0;

    if (pSessionDetails->pszSourceServerName) {
        FreeADsStr(pSessionDetails->pszSourceServerName);
    }
    if (pSessionDetails->pszSourceContainer) {
        FreeADsStr(pSessionDetails->pszSourceContainer);
    }
    if (pSessionDetails->pszTargetServer){
        FreeADsStr(pSessionDetails->pszTargetServer);
    }
    if (pSessionDetails->pszTargetContainer) {
        FreeADsStr(pSessionDetails->pszTargetContainer);
    }

    if (pSessionDetails->pszUSN) {
        FreeADsStr(pSessionDetails->pszUSN);
    }

    for (dwCtr = 0; dwCtr < pSessionDetails->dwNumABVals; dwCtr++) {
        if (pSessionDetails->ppszABVals[dwCtr]) {
            FreeADsStr(pSessionDetails->ppszABVals[dwCtr]);
        }
    }

    
    if (pSessionDetails->ppszABVals) {
        FreeADsMem(pSessionDetails->ppszABVals);
    }

    memset(pSessionDetails, 0, sizeof(SESSION_DETAILS));
}

//
// While there are more lines, in the input file, keep reading one line 
// and return the contents parsed into the SessionDetails struct.
// Return Values:
//      S_OK            -   parsed the next entry correctly.
//      S_FALSE         -   no more entries.
//      Any other ecode - Failed parsing/reading the entry.
//
HRESULT 
GetSessionDetails(
    CLogFile *pcLogFile,
    PSESSION_DETAILS pSessionDetails
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszNumVals = NULL;
    DWORD dwNumVals = 0;
    
    //
    // The ini file has the format of sourceServer, sourceContainer,
    // targetServer, targetContainer, number of values and then the values.
    //

    //
    // Get the source server and conatiner.
    //
    hr = pcLogFile->GetNextLine(&(pSessionDetails->pszSourceServerName));
    if (FAILED(hr) || hr == S_FALSE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    hr = pcLogFile->GetNextLine(&(pSessionDetails->pszSourceContainer));
    if (FAILED(hr) || hr == S_FALSE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Target server and container.
    //
    hr = pcLogFile->GetNextLine(&(pSessionDetails->pszTargetServer));
    if (FAILED(hr) || hr == S_FALSE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    hr = pcLogFile->GetNextLine(&(pSessionDetails->pszTargetContainer));
    if (FAILED(hr) || hr == S_FALSE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }
    
    pSessionDetails->pszUSN = AllocADsStr(g_pszUSN);
    if (!pSessionDetails->pszUSN) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Need to get the number of show in address book values and then,
    // read all of them.
    //
    hr = pcLogFile->GetNextLine(&pszNumVals);
    if (FAILED(hr) || hr == S_FALSE || !pszNumVals || !*pszNumVals) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    if (swscanf(pszNumVals, L"%d", &dwNumVals) != 1) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    pSessionDetails->ppszABVals = (LPWSTR *) 
        AllocADsMem(sizeof(LPWSTR) * dwNumVals);

    if (!pSessionDetails->ppszABVals) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (DWORD dwCtr = 0; dwCtr < dwNumVals; dwCtr++) {
        hr = pcLogFile->GetNextLine(&(pSessionDetails->ppszABVals[dwCtr]));
        if (FAILED(hr)
            || (S_FALSE == hr)
            || !(pSessionDetails->ppszABVals[dwCtr])
            ) {
            hr = E_INVALIDARG;
            BAIL_ON_FAILURE(hr);
        }
        pSessionDetails->dwNumABVals = dwCtr + 1;
    }


error:

    if (FAILED(hr)) {
        FreeSessionDetails(pSessionDetails);
        printf("Could not process the input file\n");
    }

    if (pszNumVals) {
        FreeADsStr(pszNumVals);
    }

    return hr;
}

//
// This function 
//
int
__cdecl wmain(
    int      cArgs, 
    LPWSTR * pArgs
    )
{
    DWORD dwRetCode=0;
    HRESULT hr = S_OK;
    SESSION_DETAILS sDetails;
    CLogFile *pcIniFile = NULL;
    CSyncSession *pSession = NULL;
    DWORD dwNumRead = 0;
    WCHAR wChar, wChar2;
    BOOL fCoInit = FALSE;

    memset(&sDetails, 0, sizeof(SESSION_DETAILS));

    hr = CoInitialize(NULL);
    if (SUCCEEDED(hr)) {
        fCoInit = TRUE;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Get the input file name and the usn from the input args.
    //
    hr = ProcessInputArgs(cArgs, pArgs);
    if (hr == E_INVALIDARG) {
        PrintUsage();
    }
    BAIL_ON_FAILURE(hr);

    //
    // Input file has to be present in the current directory.
    //
    hr = CLogFile::CreateLogFile(
             g_pszInputFileName,
             &pcIniFile,
             OPEN_EXISTING
             );
    BAIL_ON_FAILURE(hr);
    

    //
    // Read the next session details from the ini file and then process the
    // session until there are no more sessions.
    //
    while (S_OK == hr) {
        memset(&sDetails, 0, sizeof(SESSION_DETAILS));
        hr = GetSessionDetails(pcIniFile, &sDetails);

        if (S_OK != hr) {
            printf("Could not get session info form file\n");
            goto error;
        }

        //
        // We can now process the session.
        //
        printf("Processing session \n");
        printf("Source server %S, source container %S\n",
               sDetails.pszSourceServerName, sDetails.pszSourceContainer
               );
        printf("Target server %S, target conatiner %S\n",
               sDetails.pszTargetServer, sDetails.pszTargetContainer);

        hr = CSyncSession::CreateSession(
                 sDetails.pszSourceServerName,
                 sDetails.pszSourceContainer,
                 sDetails.pszTargetServer,
                 sDetails.pszTargetContainer,
                 sDetails.pszUSN,
                 sDetails.ppszABVals,
                 sDetails.dwNumABVals,
                 (LPWSTR *)szAttributesToMap,
                 g_dwAttribCount,
                 &pSession
                 );
        if (SUCCEEDED(hr)) {
            //
            // Execute the session.
            // 
            hr = pSession->Execute();
        } 

        if (FAILED(hr)) {
            printf("Session failed %x going to next session", hr);
        }

        FreeSessionDetails(&sDetails);

        if (pSession) {
            delete pSession;
            pSession = NULL;
        }

        BAIL_ON_FAILURE(hr);
    }

error :

   FreeSessionDetails(&sDetails);

   if (pcIniFile) {
       delete pcIniFile;
   }

   if (fCoInit) {
       CoUninitialize();
   }
   return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\quicksync\csession.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:  csession.cxx
//
//  Contents:  Implementation of the Session object for quicksync.
//
//  History:   02-11-01  AjayR   Created.
//
//-----------------------------------------------------------------------------
#include "quicksync.hxx"
#pragma hdrstop

CSyncSession::CSyncSession() :
    _pszSourceServer(NULL),
    _pSrchObjSrc(NULL),
    _pSrchObjSrcContainer(NULL),
    _pSrchObjTgt(NULL),
    _hSessionSearch(NULL),
    _pcLogFileSuccess(NULL),
    _pcLogFileFailures(NULL),
    _pcLogFile2ndPass(NULL),
    _pTgtMgr(NULL),
    _pszUSN(NULL),
    _ppszABVals(NULL),
    _dwABValsCount(0),
    _ppszAttributes(NULL),
    _dwAttribCount(NULL)
{
}

CSyncSession::~CSyncSession()
{
    //
    // Watch the order in which things are released, cause somethings
    // rely on other piecs of the object existing.
    //
    if (_pTgtMgr) {
        delete _pTgtMgr;
    }

    if (_hSessionSearch) {
        _pSrchObjTgt->CloseSearchHandle(_hSessionSearch);
    }

    if (_pSrchObjSrc) {
        _pSrchObjSrc->Release();
    }

    if (_pSrchObjTgt) {
        _pSrchObjTgt->Release();
    }

    if (_pSrchObjSrcContainer) {
        _pSrchObjSrcContainer->Release();
    }

    //
    // Deleting the log file ptrs, will save and close them.
    //
    if (_pcLogFileSuccess) {
        delete _pcLogFileSuccess;
    }

    if (_pcLogFileFailures) {
        delete _pcLogFileFailures;
    }
    
    if (_pcLogFile2ndPass) {
        delete _pcLogFile2ndPass;
    }

    if (_ppszAttributes) {
        for (DWORD dwCtr = 0; dwCtr < _dwAttribCount; dwCtr++) {
            if (_ppszAttributes[dwCtr]) {
                FreeADsStr(_ppszAttributes[dwCtr]);
            }
        }
        FreeADsMem(_ppszAttributes);
    }

    if (_pszSourceServer) {
        FreeADsStr(_pszSourceServer);
    }
}

//
// Static initialize routine.
//
HRESULT 
CSyncSession::CreateSession(
    LPCWSTR pszSourceServer,
    LPCWSTR pszSourceContainer,
    LPCWSTR pszTargetServer,
    LPCWSTR pszTargetContainer,
    LPCWSTR pszUSN,
    LPWSTR  *ppszABVals,
    DWORD   dwABValsCount,
    LPWSTR  *ppszAttributes,
    DWORD   dwAttribCount,
    CSyncSession **ppSyncSession
    )
{
    HRESULT hr = S_OK;
    CSyncSession *pSession = NULL;
    LPWSTR  pszTempStr = NULL;
    DWORD dwLenTgt = 0;
    DWORD dwLenSrc = 0;
    IDirectoryObject *pDirObjTgt = NULL;

    *ppSyncSession = NULL;
    if (!pszSourceServer
        || !pszSourceContainer
        || !pszTargetServer
        || !pszTargetContainer
        || !dwAttribCount
        || !ppszAttributes
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    dwLenSrc = wcslen(pszSourceServer) + wcslen(pszSourceContainer);
    dwLenTgt = wcslen(pszTargetServer) + wcslen(pszTargetContainer);

    pszTempStr = (LPWSTR) AllocADsMem(
        (dwLenSrc + dwLenTgt + 25) * sizeof(WCHAR)
        );

    if (!pszTempStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pSession = new CSyncSession();

    if (!pSession) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pSession->_pszSourceServer = AllocADsStr(pszSourceServer);
    if (!pSession->_pszSourceServer) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    //
    // Connect upto the target server and have a srch ptr there.
    //
    wcscpy(pszTempStr, L"LDAP://");
    wcscat(pszTempStr, pszSourceServer);

    hr = ADsOpenObject(
             pszTempStr,
             g_pszUserNameSource,
             g_pszUserPwdSource,
             ADS_SECURE_AUTHENTICATION,
             IID_IDirectorySearch,
             (void **) &(pSession->_pSrchObjSrc)
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get ptr to source container.
    //
    wcscat(pszTempStr, L"/");
    wcscat(pszTempStr, pszSourceContainer);

    hr = ADsOpenObject(
             pszTempStr,
             g_pszUserNameSource,
             g_pszUserPwdSource,
             ADS_SECURE_AUTHENTICATION,
             IID_IDirectorySearch,
             (void **) &(pSession->_pSrchObjSrcContainer)
             );
    BAIL_ON_FAILURE(hr);

    //
    // Now we need to pick up the target search pointer.
    //
    wcscpy(pszTempStr, L"LDAP://");
    wcscat(pszTempStr, pszTargetServer);

    hr = ADsOpenObject(
             pszTempStr,
             g_pszUserNameTarget,
             g_pszUserPwdTarget,
             ADS_SECURE_AUTHENTICATION,
             IID_IDirectorySearch,
             (void **) &(pSession->_pSrchObjTgt)
             );
    BAIL_ON_FAILURE(hr);

    //
    // Success log file will be source.success.log.
    // 
    wcscpy(pszTempStr, pszSourceServer);
    wcscat(pszTempStr, L".success.log");

    hr = CLogFile::CreateLogFile(pszTempStr, &pSession->_pcLogFileSuccess);
    BAIL_ON_FAILURE(hr);

    //
    // Failure log file will be source.failure.log.
    // 
    wcscpy(pszTempStr, pszSourceServer);
    wcscat(pszTempStr, L".failure.log");

    hr = CLogFile::CreateLogFile(pszTempStr, &pSession->_pcLogFileFailures);
    BAIL_ON_FAILURE(hr);

    //
    // Temp file used for pass 2 will be source.temp.log
    //
    wcscpy(pszTempStr, pszSourceServer);
    wcscat(pszTempStr, L".temp.log");

    hr = CLogFile::CreateLogFile(pszTempStr, &pSession->_pcLogFile2ndPass);
    BAIL_ON_FAILURE(hr);

    //
    // Before we can create the target manager object,
    // we need a pointer to the target container.
    //
    if ((dwLenTgt + wcslen(pszTargetContainer) + 10) > 2048) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    wcscpy(pszTempStr, L"LDAP://");
    wcscat(pszTempStr, pszTargetServer);
    wcscat(pszTempStr, L"/");
    wcscat(pszTempStr, pszTargetContainer);

    hr = ADsOpenObject(
             pszTempStr,
             g_pszUserNameTarget,
             g_pszUserPwdTarget,
             ADS_SECURE_AUTHENTICATION,
             IID_IDirectoryObject,
             (void **) &pDirObjTgt
             );
    BAIL_ON_FAILURE(hr);

    hr = CTargetMgr::CreateTargetMgr(
             pSession->_pSrchObjSrc,
             pSession->_pSrchObjTgt,
             pDirObjTgt,
             L"FilterTemplate",
             pSession->_pcLogFileSuccess,
             pSession->_pcLogFileFailures,
             &(pSession->_pTgtMgr)
             );

    BAIL_ON_FAILURE(hr);

    //
    // USN to use for filter.
    //
    pSession->_pszUSN = AllocADsStr(pszUSN);
    if (!pSession->_pszUSN) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Copy over the attribute list.
    //
    pSession->_ppszAttributes = 
        (LPWSTR *) AllocADsMem(dwAttribCount * sizeof(LPWSTR));

    if (!pSession->_ppszAttributes) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    for (dwLenTgt = 0; dwLenTgt < dwAttribCount; dwLenTgt++) {
        pSession->_ppszAttributes[dwLenTgt] = 
            AllocADsStr(ppszAttributes[dwLenTgt]);

        if (!pSession->_ppszAttributes[dwLenTgt]) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        //
        // This way if we hit an error we will clean up nicely.
        //
        pSession->_dwAttribCount = dwLenTgt + 1;
    }

    //
    // Copy over the address book values.
    //
    pSession->_ppszABVals = 
        (LPWSTR *) AllocADsMem(dwABValsCount * sizeof(LPWSTR));
    
    if (!pSession->_ppszABVals) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    for (dwLenTgt = 0; dwLenTgt < dwABValsCount; dwLenTgt++) {
        pSession->_ppszABVals[dwLenTgt] = 
            AllocADsStr(ppszABVals[dwLenTgt]);

        if (!pSession->_ppszABVals[dwLenTgt]) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        pSession->_dwABValsCount = dwLenTgt + 1;
    }


    *ppSyncSession = pSession;


error:

    if (FAILED(hr)) {
        if (pSession) {
            delete pSession;
        }
    }

    if (pDirObjTgt) {
        pDirObjTgt->Release();
    }

    if (pszTempStr) {
        FreeADsStr(pszTempStr);
    }

    return hr;
}

HRESULT
CSyncSession::Execute()
{
    HRESULT hr = S_OK;

    //
    // First we need to search the source container.
    //
    hr = this->ExecuteSearch();
    BAIL_ON_FAILURE(hr);

    //
    // The first pass will make sure we create all the objects.
    //
    hr = this->PerformFirstPass();
    BAIL_ON_FAILURE(hr);

    //
    // Need to go through and fix the DN's
    //
    hr = this->PerformSecondPass();
    BAIL_ON_FAILURE(hr);

error:

    return hr;
}

//
// This method sets the search preferences, executes the search
// and updates the underlying searchandle accordingly.
//
HRESULT
CSyncSession::ExecuteSearch()
{
    HRESULT hr = S_OK;

    ADS_SEARCHPREF_INFO adsSearchPrefInfo[10];
    ADSVALUE vValue[5];
    DWORD dwNumPrefs = 5;
    DWORD dwLen = 0;
    LPWSTR pszFilter = NULL;
    
    //
    // Pagesize to 100 records
    //
    adsSearchPrefInfo[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    adsSearchPrefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    adsSearchPrefInfo[0].vValue.Integer = 500;

    //
    // Need the tombstone control.
    //
    adsSearchPrefInfo[1].dwSearchPref = ADS_SEARCHPREF_TOMBSTONE;
    adsSearchPrefInfo[1].vValue.dwType = ADSTYPE_BOOLEAN;
    adsSearchPrefInfo[1].vValue.Boolean = TRUE;

    adsSearchPrefInfo[2].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    adsSearchPrefInfo[2].vValue.dwType = ADSTYPE_INTEGER;
    adsSearchPrefInfo[2].vValue.Integer = ADS_SCOPE_SUBTREE;

    adsSearchPrefInfo[3].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
    adsSearchPrefInfo[3].vValue.dwType = ADSTYPE_BOOLEAN;
    adsSearchPrefInfo[3].vValue.Boolean = FALSE;

    hr = _pSrchObjSrcContainer->SetSearchPreference(
             adsSearchPrefInfo, 
             4
             );
    if (S_ADS_ERRORSOCCURRED == hr) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }
    BAIL_ON_FAILURE(hr);

    //
    // Filter will be the constant string + usnChanged>=<pszUSNVal) + \0
    //
    dwLen += wcslen(L"(&(|(objectCategory=person)(objectCategory=group))");
    dwLen += wcslen(L"(mailNickname=*)(usnChanged>= ))");
    dwLen += wcslen(_pszUSN) + 1;

    pszFilter = (LPWSTR) AllocADsMem(dwLen * sizeof(WCHAR));
    if (!pszFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(pszFilter, L"(&(|(objectCategory=person)(objectCategory=group))");
    wcscat(pszFilter, L"(mailNickname=*)");

    if (!_wcsicmp(_pszUSN, L"0")) {
        //
        // We need to leave out the USN from the filter cause we want
        // all entires, probably for a first run.
        //
        wcscat (pszFilter, L")");
    } 
    else {
        wcscat(pszFilter, L"(usnChanged>=");
        wcscat(pszFilter, _pszUSN);
        wcscat(pszFilter, L"))");
    }

    hr = this->_pSrchObjSrcContainer->ExecuteSearch(
             pszFilter,
             _ppszAttributes,
             _dwAttribCount,
             &_hSessionSearch
             );
    BAIL_ON_FAILURE(hr);

error:

   if (pszFilter) {
       FreeADsStr(pszFilter);
   }

   return hr;
}

//
// The first pass will attempt to go through and create all objects
// with attributes as needed. If the object already exists,
// all attributes that can be mapped are written. Dn attributes, may
// need to be processed on the second pass.
//
HRESULT
CSyncSession::PerformFirstPass()
{
    HRESULT hr = S_OK;
    DWORD dwCount = 0;
    ADS_SEARCH_COLUMN colADsPath;
    ADS_SEARCH_COLUMN colObjClass;
    ADS_SEARCH_COLUMN colNickName;
    ADS_SEARCH_COLUMN colIsDeleted;
    LPWSTR pszErrStr = NULL;
    DWORD dwExtErr = 0;
    WCHAR szError[1024];
    WCHAR szProvNameBuffer[16];
    BOOL fDelEntry;
    BOOL fNickname;

    memset(&colADsPath, 0, sizeof(ADS_SEARCH_COLUMN));
    memset(&colObjClass, 0, sizeof(ADS_SEARCH_COLUMN));
    memset(&colNickName, 0, sizeof(ADS_SEARCH_COLUMN));
    memset(&colIsDeleted, 0, sizeof(ADS_SEARCH_COLUMN));

    //
    // Making the bold assumption that the error string will
    // never be bigger than 5000 chars.
    //
    pszErrStr = (LPWSTR) AllocADsMem(5000 * sizeof(WCHAR));
    if (!pszErrStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    while (hr == S_OK) {
        //
        // Free all the columns and then continue.
        //
        _pSrchObjSrc->FreeColumn(&colADsPath);
        _pSrchObjSrc->FreeColumn(&colObjClass);
        _pSrchObjSrc->FreeColumn(&colNickName);
        _pSrchObjSrc->FreeColumn(&colIsDeleted);
                
        //
        // Reset all as we will free all as in the next iteration,
        // we mind end up calling free for a column that we never got.
        //
        memset(&colADsPath, 0, sizeof(ADS_SEARCH_COLUMN));
        memset(&colObjClass, 0, sizeof(ADS_SEARCH_COLUMN));
        memset(&colNickName, 0, sizeof(ADS_SEARCH_COLUMN));
        memset(&colIsDeleted, 0, sizeof(ADS_SEARCH_COLUMN));


        fDelEntry = FALSE;
        fNickname = FALSE;
        dwCount++;
        if (!(dwCount % 0x100)) {
            printf("Processed %d records\n", dwCount);
        }
        
        //
        // GetNextRow should always succeed.
        //
        hr = S_ADS_NOMORE_ROWS;
        while (hr == S_ADS_NOMORE_ROWS) {
            //
            // We need to keep calling getNext row until we hit the
            // end of the result set. Sometimes when there are no more
            // rows, we might need to call GetNextRow again depending on
            // the extended error code. ADSI docs for details.
            //
            hr = _pSrchObjSrc->GetNextRow(_hSessionSearch);
            if (hr == S_ADS_NOMORE_ROWS) {
                //
                // See if we need to call GetNextRow again.
                //
                hr = ADsGetLastError(
                         &dwExtErr,
                         szError,
                         sizeof(szError),
                         szProvNameBuffer,
                         sizeof(szProvNameBuffer)
                         );
                if (SUCCEEDED(hr)) {
                    if (ERROR_MORE_DATA == dwExtErr) {
                        hr = S_ADS_NOMORE_ROWS;
                    } 
                    else {
                        //
                        // Finish and get out of while.
                        //
                        hr = S_ADS_NOMORE_ROWS;
                        break;
                    }
                }
            }
        } // while getLastError indicates there are more records.
        
        if (FAILED(hr)) {
            _pcLogFileFailures->LogEntry(
                ENTRY_FAILURE,
                hr,
                L"GetNextRow from source failed"
                );
            BAIL_ON_FAILURE(hr);
        } 
        else if (S_ADS_NOMORE_ROWS == hr) {
            //
            // Reached the end of the records.
            //
            break;
        }
        
        //
        // See if entry is deleted and mark fDelete accordingly.
        //
        hr = _pSrchObjSrc->GetColumn(
                 _hSessionSearch,
                 L"isDeleted",
                 &colIsDeleted
                 );
        if (SUCCEEDED(hr)) {
            //
            // Then we need to delete this on the target.
            //
            fDelEntry = TRUE;
        } else {
            //
            // ADSI error where the name field has a value but is not
            // pointing to a valid result in the error path.
            //
            memset(&colIsDeleted, 0, sizeof(ADS_SEARCH_COLUMN));
        }
        
        //
        // Need the ADsPath, dn, objectClass and mailNickName to proceed.
        //
        hr = _pSrchObjSrc->GetColumn(
                 _hSessionSearch,
                 L"ADsPath",
                 &colADsPath
                 );
        if (FAILED(hr)) {
            memset(&colADsPath, 0, sizeof(ADS_SEARCH_COLUMN));

            _pcLogFileFailures->LogEntry(
                ENTRY_FAILURE,
                hr,
                L"GetColumn for ADsPath failed - cannot recover"
                );
            BAIL_ON_FAILURE(hr);
        }

        hr = _pSrchObjSrc->GetColumn(
                 _hSessionSearch,
                 L"objectClass",
                 &colObjClass
                 );
        if (FAILED(hr)) {
            memset(&colObjClass, 0, sizeof(ADS_SEARCH_COLUMN));
            wcscpy(pszErrStr, L"GetColumn objectClass failed for ");
            wcscat(pszErrStr, colADsPath.pADsValues[0].CaseIgnoreString);
            
            _pcLogFileFailures->LogEntry(
                ENTRY_FAILURE,
                hr,
                pszErrStr
                );
            continue;
        }

        hr = _pSrchObjSrc->GetColumn(
                 _hSessionSearch,
                 L"mailNickname",
                 &colNickName
                 );
        if (FAILED(hr)) {
            memset(&colNickName, 0, sizeof(ADS_SEARCH_COLUMN));
            wcscpy(pszErrStr, L"GetColumn objectClass failed for ");
            wcscat(pszErrStr, colADsPath.pADsValues[0].CaseIgnoreString);
            
            _pcLogFileFailures->LogEntry(
                ENTRY_FAILURE,
                hr,
                pszErrStr
                );
            continue;
        }

        if (fDelEntry) {
            hr = _pTgtMgr->DelTargetObject(
                     colADsPath.pADsValues[0].CaseIgnoreString,
                     colNickName.pADsValues[0].CaseIgnoreString
                     );
            //
            // DelTarget will upate the log files accordingly.
            //
            hr = S_OK;
            continue;
        }

        //
        // Normal entry, we need to create and update as appropriate.
        // This routine will update the log files appropriately.
        //
        hr = UpdateTargetObject(
                 colADsPath.pADsValues[0].CaseExactString,
                 colNickName.pADsValues[0].CaseExactString,
                 &colObjClass
                 );

        //
        // Must be critical failure
        //
        if (FAILED(hr)) {
            BAIL_ON_FAILURE(hr);
        }

    } // while we have more records to process.



error:

    if (!dwCount) {
        _pcLogFileFailures->LogEntry(
            ENTRY_FAILURE,
            hr,
            L"Did not get any matching rows"
            );
    } 
    else {
        _pcLogFileSuccess->LogEntry(
            ENTRY_SUCCESS,
            hr,
            L"First pass complete"
            );

    }

    
    if (pszErrStr) {
        FreeADsStr(pszErrStr);
    }

    //
    // Calling free on the columns again - will do no harm in the
    // most comomon case but will be useful if there was some error.
    //
    _pSrchObjSrc->FreeColumn(&colADsPath);
    _pSrchObjSrc->FreeColumn(&colObjClass);
    _pSrchObjSrc->FreeColumn(&colNickName);
    _pSrchObjSrc->FreeColumn(&colIsDeleted);

    if (hr == S_ADS_NOMORE_ROWS) {
        hr = S_OK;
    }

    if (hr != E_FAIL 
        || hr != E_OUTOFMEMORY) {
        hr = S_OK;
    }
    
    return hr;
}


//
// We use the temp file and keep reading records from the temp
// file and updating target objects based on the records.
//

HRESULT
CSyncSession::PerformSecondPass()
{
    HRESULT hr = S_OK;
    DWORD dwCount = 0;
    ADS_SEARCH_COLUMN colCur;
    LPWSTR pszNickname = NULL;
    LPWSTR pszAttr = NULL;
    LPWSTR pszADsPathTgt = NULL;
    ADS_ATTR_INFO attrInfo;
    DWORD dwCtr;

    memset(&colCur, 0, sizeof(ADS_SEARCH_COLUMN));
    memset(&attrInfo, 0, sizeof(ADS_ATTR_INFO));

    hr = _pcLogFile2ndPass->Reset();
    BAIL_ON_FAILURE(hr);


    while (hr == S_OK) {

        _pSrchObjSrc->FreeColumn(&colCur);

        if (attrInfo.pszAttrName) {
            FreeADsStr(attrInfo.pszAttrName);
            attrInfo.pszAttrName = NULL;
        }

        if (attrInfo.pADsValues) {
            for (dwCtr = 0; dwCtr < attrInfo.dwNumValues; dwCtr++) {
                if (attrInfo.pADsValues[dwCtr].DNString) {
                    FreeADsStr(attrInfo.pADsValues[dwCtr].DNString);
                    attrInfo.pADsValues[dwCtr].DNString = NULL;
                }
            }
            FreeADsMem(attrInfo.pADsValues);
            attrInfo.pADsValues = NULL;
        }
        attrInfo.dwNumValues = 0;

        if (pszNickname) {
            FreeADsStr(pszNickname);
            pszNickname = NULL;
        }

        if (pszAttr) {
            FreeADsStr(pszAttr);
            pszAttr = NULL;
        }

        if (pszADsPathTgt) {
            FreeADsStr(pszADsPathTgt);
            pszADsPathTgt = NULL;
        }

        hr = _pcLogFile2ndPass->GetRetryRecord(
                 &pszAttr,
                 &pszNickname,
                 &colCur
                 );
        if (FAILED(hr)) {
            _pcLogFileFailures->LogEntry(
                ENTRY_FAILURE,
                hr,
                L"2nd pass error reading record no further info"
                );
            BAIL_ON_FAILURE(hr);
        }

        //
        // No more records.
        //
        if (hr == S_FALSE) {
            _pcLogFileSuccess->LogEntry(
                ENTRY_SUCCESS,
                hr,
                L"2nd pass complete"
                );
            break;
        }

        hr = _pTgtMgr->LocateTarget(
                 TRUE,
                 pszNickname,
                 &pszADsPathTgt
                 );

        if (hr == E_OUTOFMEMORY
            || hr == E_FAIL) {
            //
            // Nothing we can do.
            //
            _pcLogFileFailures->LogEntry(
                ENTRY_FAILURE,
                hr,
                L"Catastrophic failure locating target with mailNickname",
                pszNickname,
                L"cannot proceed further"
                );
            BAIL_ON_FAILURE(hr);
        }

        if (FAILED(hr)) {
            _pcLogFileFailures->LogEntry(
                ENTRY_FAILURE,
                hr,
                L"Could not locate target record for mailNickname",
                pszNickname
                );
            hr = S_OK;
            continue;
        }
        //
        // Need to map to adsAttrInfo.
        //
        hr = MapADsColumnToAttrInfo(
                 &colCur,
                 &attrInfo
                 );

        if (hr != S_OK) {
            _pcLogFileFailures->LogEntry(
                ENTRY_FAILURE,
                hr,
                L"Could not map dn attr, mailNickname tgt:",
                pszNickname,
                L"First dn string value",
                colCur.pADsValues[0].DNString
                );
            if (hr == E_OUTOFMEMORY) {
                BAIL_ON_FAILURE(hr);
            } 
            else {
                hr = S_OK;
            }
            continue;
        }

        hr = _pTgtMgr->UpdateTarget(
                 pszADsPathTgt,
                 &attrInfo,
                 1
                 );
        if (S_OK == hr) {
            _pcLogFileSuccess->LogEntry(
                ENTRY_SUCCESS,
                hr,
                L"Updated object in tgt container for source mailNickname:",
                pszNickname
                );
        }

        dwCount++;
    }
    
error:

    if (!dwCount) {
        if (hr == E_FAIL
            || hr == E_OUTOFMEMORY) {
            _pcLogFileFailures->LogEntry(
                ENTRY_FAILURE,
                hr,
                L"No records updated on second pass"
                );
        } 
        else if (hr == S_FALSE) {
            _pcLogFileSuccess->LogEntry(
                ENTRY_SUCCESS,
                0,
                L"No records to update on second pass"
                );
        }
    } 
    else {
        if (hr == S_FALSE) {
            _pcLogFileSuccess->LogEntry(
                ENTRY_SUCCESS,
                S_FALSE,
                L"All 2nd pass records processed."
                );
        } 
        else {
            _pcLogFileFailures->LogEntry(
                ENTRY_FAILURE,
                hr,
                L"Some 2nd pass records processed not all"
                );
        }
    }


    if (pszADsPathTgt) {
        FreeADsStr(pszADsPathTgt);
    }

    if (pszNickname) {
        FreeADsStr(pszNickname);
    }

    if (pszAttr) {
        FreeADsStr(pszAttr);
    }

    _pSrchObjSrc->FreeColumn(&colCur);
    return hr;
}

//
// Returns S_OK unless there was a catastrophic failure.
//
HRESULT
CSyncSession::UpdateTargetObject(
    LPCWSTR pszADsPath,
    LPCWSTR pszNickname,
    PADS_SEARCH_COLUMN colObjClass
    )
{
    HRESULT hr = S_OK;
    PADS_ATTR_INFO pAttrInfo = NULL;
    DWORD dwCtr;
    DWORD dwAttribsToSet = 0;
    BOOL fParent = FALSE;
    ADS_SEARCH_COLUMN curColumn;
    ADS_SEARCH_COLUMN colCN;
    ADS_SEARCH_COLUMN colLegDN;
    ADS_SEARCH_COLUMN colMail;
    LPWSTR pszTgtADsPath = NULL;
    BOOL fNew = FALSE;
    BOOL fLegacyDN = FALSE;
    BOOL fColMail = FALSE;
    BOOL fNoTargetAddress = FALSE;
    BOOL fExtendedInfo = FALSE;

    memset(&colCN, 0, sizeof(ADS_SEARCH_COLUMN));
    memset(&colLegDN, 0, sizeof(ADS_SEARCH_COLUMN));
    memset(&colMail, 0, sizeof(ADS_SEARCH_COLUMN));

    //
    // First we need to locate the target object.
    //
    hr = _pTgtMgr->LocateTarget(
             TRUE, // want the ADsPath back
             pszNickname,
             &pszTgtADsPath,
             &fExtendedInfo // will tell us if we need to set tgtAddr
             );
    if (E_ADS_BAD_PATHNAME == hr) {
        //
        // This means that we have no matching object and need
        // to create the new object.
        //
        fNew = TRUE;
        hr = S_OK;
    }
    
    if (FAILED(hr)) {
        _pcLogFileFailures->LogEntry(
            ENTRY_FAILURE,
            hr,
            pszADsPath
            );
        BAIL_ON_FAILURE(hr);
    }

    //
    // We will have utmost _dwAttribCount attributes to set.
    //
    pAttrInfo = (PADS_ATTR_INFO) AllocADsMem(
        _dwAttribCount * sizeof(ADS_ATTR_INFO)
        );

    if (!pAttrInfo) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Want to get hold of the legacyDN before going through all
    // the attributes as that needs to be tagged on to the list of
    // proxyAddresses. This code however is not smart enough to
    // handle the case where the legacyDN is set but there is no
    // value for the proxyAddresses.
    //
    hr = _pSrchObjSrc->GetColumn(
             _hSessionSearch,
             L"legacyExchangeDN",
             &colLegDN
             );
    if ((S_OK != hr)
        || (ADSTYPE_CASE_IGNORE_STRING != colLegDN.dwADsType)
        || (1 != colLegDN.dwNumValues)
        ) {
        fLegacyDN = FALSE;
    } 
    else {
        fLegacyDN = TRUE;
    }

    //
    // See if the mail attribute is set. If it is, we might need to
    // this down the road if targetAddress is not set.
    //
    hr = _pSrchObjSrc->GetColumn(
             _hSessionSearch,
             L"mail",
             &colMail
             );
    if ((S_OK != hr)) {
        fColMail = FALSE;
        memset(&colMail, 0, sizeof(ADS_SEARCH_COLUMN));
    }
    else {
        fColMail = TRUE;
    }

    if (!fLegacyDN) {
        memset(&colLegDN, 0, sizeof(ADS_SEARCH_COLUMN));
    }

    for (dwCtr = 0; dwCtr < _dwAttribCount; dwCtr++) {
        fNoTargetAddress = FALSE;
        memset(&curColumn, 0, sizeof(ADS_SEARCH_HANDLE));

        if (!_wcsicmp(_ppszAttributes[dwCtr], L"cn")
            || !_wcsicmp(_ppszAttributes[dwCtr], L"ADsPath")
            || !_wcsicmp(_ppszAttributes[dwCtr], L"sAMAccountName")
            || !_wcsicmp(_ppszAttributes[dwCtr], L"isDeleted")
            || !_wcsicmp(_ppszAttributes[dwCtr], L"legacyExchangeDN")
            ) {
            //
            // Do not want to send this across.
            //
            hr = S_OK;
            continue;
        }

        if (!fNew
            && (!_wcsicmp(_ppszAttributes[dwCtr], L"objectClass")
               || (!_wcsicmp(_ppszAttributes[dwCtr], L"mAPIRecipient"))
                )
            ) {
            //
            // Do not want this either but only for the old ones.
            //
            hr = S_OK;
            continue;
        }

        if (!fNew
            && !fExtendedInfo
            && (!_wcsicmp(_ppszAttributes[dwCtr], L"targetAddress"))
            ) {
            //
            // Do not want to set the target address in this case.
            //
            hr = S_OK;
            continue;
        }

        //
        // Get the column and then map it accordingly.
        //
        hr = _pSrchObjSrc->GetColumn(
                 _hSessionSearch,
                 _ppszAttributes[dwCtr],
                 &curColumn
                 );
        if ((E_ADS_COLUMN_NOT_SET == hr)
            && fColMail
            && !_wcsicmp(_ppszAttributes[dwCtr], L"targetAddress")
            ) {
            fNoTargetAddress = TRUE;
            memset(&curColumn, 0, sizeof(ADS_SEARCH_COLUMN));
        } 
        else if (FAILED(hr) || hr != S_OK) {
            hr = S_OK;
            memset(&curColumn, 0, sizeof(ADS_SEARCH_COLUMN));
            continue;
        }

        //
        // objectClass is special cased to return contact in the map call.
        //
        if (fLegacyDN
            && !_wcsicmp(_ppszAttributes[dwCtr], L"proxyAddresses")
            ) {
            //
            // We need to do this as a special mapping.
            //
            hr = MapADsColumnToAttrInfo(
                     &curColumn,
                     &(pAttrInfo[dwAttribsToSet]),
                     colLegDN.pADsValues[0].CaseExactString
                     );
            //
            // If this succeeded and it is an old object, we
            // need to add values to the proxyAddresses rather than
            // update them. This is because we end up pulling entries
            // from another server using a script and do not want to
            // stomp those.
            //
            if (!fNew && SUCCEEDED(hr)) {
                pAttrInfo[dwAttribsToSet].dwControlCode = ADS_ATTR_APPEND;
            }
        }
        else if (fNoTargetAddress && fColMail) {
            //
            // If we have mail we need to map it to targetAddress.
            //
            hr = MapADsColumnToAttrInfo(
                     &colMail,
                     &(pAttrInfo[dwAttribsToSet]),
                     NULL,
                     TRUE // means we do a special mapping
                     );
        }
        else {
                     
            hr = MapADsColumnToAttrInfo(
                     &curColumn,
                     &(pAttrInfo[dwAttribsToSet])
                     );
        }
        
        if (SUCCEEDED(hr)) {
            dwAttribsToSet++;
        }
        else {
            if (curColumn.dwADsType = ADSTYPE_DN_STRING) {
                //
                // Need to add this to the retry list.
                //
                hr = _pcLogFile2ndPass->LogRetryRecord(
                         curColumn.pszAttrName,
                         pszNickname,
                         &curColumn
                         );
                BAIL_ON_FAILURE(hr);
            }
        }
        _pSrchObjSrc->FreeColumn(&curColumn);
        hr = S_OK;
    }

    //
    // We have mapped all the attributes now need to update
    // the target object.
    //
    if (fNew) {
        //
        // Need the cn to create the target.
        //
        hr = _pSrchObjSrc->GetColumn(
                 _hSessionSearch,
                 L"cn",
                 &colCN
                 );
        if (hr != S_OK
            || (colCN.dwNumValues != 1)
            || (!colCN.pADsValues)
            || (!colCN.pADsValues[0].CaseExactString)
            ) {
            //
            // Could not get cn, that is needed to create the new object.
            //
            _pcLogFileFailures->LogEntry(
                ENTRY_FAILURE,
                hr,
                L"Could not get cn to create target for source",
                pszADsPath
                );
            BAIL_ON_FAILURE(hr);
        }

        hr = _pTgtMgr->CreateTarget(
                 colCN.pADsValues[0].CaseExactString,
                 pAttrInfo,
                 dwAttribsToSet
                 );
        if (S_OK == hr) {
            _pcLogFileSuccess->LogEntry(
                ENTRY_SUCCESS,
                hr,
                L"Created new object in tgt container with cn=",
                colCN.pADsValues[0].CaseExactString,
                L"for source object with mailNicknam",
                pszNickname
                );
        }
    }
    else {
        //
        // Object exists, just update the attributes.
        //
        hr = _pTgtMgr->UpdateTarget(
                 pszTgtADsPath,
                 pAttrInfo,
                 dwAttribsToSet
                 );
        if (S_OK == hr) {
            _pcLogFileSuccess->LogEntry(
                ENTRY_SUCCESS,
                hr,
                L"Updated object in tgt container for source mailNickname:",
                pszNickname
                );
        }
    }

    if (FAILED(hr)) {
        _pcLogFileFailures->LogEntry(
            ENTRY_FAILURE,
            hr,
            fNew ? 
                L"Could not create new object on target for source" :
                L"Could not update object on target for source",
            pszADsPath
            );
    }


error:

    if (FAILED(hr) && hr != E_OUTOFMEMORY) {
        //
        // Reset so we can continue processing other entries.
        //
        hr = S_OK;
    }

    //
    // Column is valid only if this is a new object.
    //
    if (fNew) {
        hr = _pSrchObjSrc->FreeColumn(&colCN);
    }

    _pSrchObjSrc->FreeColumn(&colLegDN);
    _pSrchObjSrc->FreeColumn(&colMail);

    //
    // Free the ADsAttrInfo.
    //
    if (pAttrInfo) {
        for (dwCtr = 0; dwCtr < _dwAttribCount; dwCtr++) {
            if (pAttrInfo[dwCtr].pADsValues) {
                AdsFreeAdsValues(
                    pAttrInfo[dwCtr].pADsValues,
                    pAttrInfo[dwCtr].dwNumValues
                    );
                FreeADsMem(pAttrInfo[dwCtr].pADsValues);
            }

            if (pAttrInfo[dwCtr].pszAttrName) {
                FreeADsStr(pAttrInfo[dwCtr].pszAttrName);
            }
        }

        FreeADsMem(pAttrInfo);
    }

    if (pszTgtADsPath) {
        FreeADsStr(pszTgtADsPath);
    }

    return hr;
}

HRESULT 
CSyncSession::MapADsColumnToAttrInfo(
    PADS_SEARCH_COLUMN pCol,
    PADS_ATTR_INFO pAttrInfo,
    LPWSTR pszExtraStrVal, // defaulted to NULL only valid for proxyAddresses
    BOOL fMailAttrib // defaulted to FALSE, only used for mail to targetAddress

    )
{
    HRESULT hr = S_OK;
    DWORD dwType = ADSTYPE_INVALID;
    DWORD dwNumValues = 0;
    PADSVALUE pVals = NULL;
    LPWSTR pszMappedDN = NULL;
    LPWSTR pszTmpExtraVal = NULL;
    BOOL fObjClass = FALSE;
    BOOL fProxyAddresses = FALSE;
    BOOL fShowInAB = FALSE;
    DWORD dwCtr = 0;
    DWORD dwLen = 0;

    memset(pAttrInfo, 0, sizeof(ADS_ATTR_INFO));

    //
    // Determine type and convert each of the values appropriately.
    //
    dwType = pCol->dwADsType;

    dwNumValues = pCol->dwNumValues;

    //
    // Special cases for objectClass, only for new objects.
    //
    if (!_wcsicmp(pCol->pszAttrName, L"objectClass")) {
        dwNumValues = 1;
        fObjClass = TRUE;
    } 
    else {
        dwNumValues = pCol->dwNumValues;
    }

    if (!_wcsicmp(pCol->pszAttrName, L"proxyAddresses")) {
        fProxyAddresses = TRUE;
    }

    if (pszExtraStrVal) {
        dwLen = wcslen(pszExtraStrVal) + wcslen(L"X500:") + 1;
        pszTmpExtraVal = (LPWSTR) AllocADsMem(dwLen * sizeof(WCHAR));
        if (!pszTmpExtraVal) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        wcscpy(pszTmpExtraVal, L"X500:");
        wcscat(pszTmpExtraVal, pszExtraStrVal);
    }

    if (pszTmpExtraVal && !fProxyAddresses) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    if (pszTmpExtraVal && fProxyAddresses) {
        //
        // If the extra string is set, then we need to add one more value.
        //
        dwNumValues++;
    }

    if (!_wcsicmp(pCol->pszAttrName, L"showInAddressBook")) {
        fShowInAB = TRUE;
        dwNumValues = this->_dwABValsCount;
    }

    pVals = (PADSVALUE) AllocADsMem(sizeof(ADSVALUE) * dwNumValues);
    if (!pVals) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // mail is mapped to targetAddress if the fMailAttrib is TRUE
    //
    if (fMailAttrib) {
        pAttrInfo->pszAttrName = AllocADsStr(L"targetAddress");
    }
    else {
        pAttrInfo->pszAttrName = AllocADsStr(pCol->pszAttrName);
    }
    
    if (!pAttrInfo->pszAttrName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    
    pAttrInfo->pADsValues = pVals;
    pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
    pAttrInfo->dwNumValues = dwNumValues;
    pAttrInfo->dwADsType = (ADSTYPE) dwType;

    if (fObjClass) {
        //
        // Just set the value to contact and return.
        //
        pVals[0].CaseExactString = AllocADsStr(L"contact");
        if (!pVals[0].CaseExactString) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        pVals[0].dwType = (ADSTYPE) dwType;
        goto error;
    }

    if (fMailAttrib) {
        //
        // Set to value in the column prepended with SMTP:
        //
        dwLen = wcslen(L"SMTP:") 
               + wcslen(pCol->pADsValues[dwCtr].CaseExactString)
               + 1;

        pVals[0].CaseExactString = (LPWSTR)AllocADsMem(dwLen * sizeof(WCHAR));
        if (!pVals[0].CaseExactString) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(pVals[0].CaseExactString, L"SMTP:");
        wcscat(
            pVals[0].CaseExactString,
            pCol->pADsValues[dwCtr].CaseExactString
            );

        pVals[0].dwType = (ADSTYPE) dwType;

        goto error;
    }

    if (fShowInAB) {
        //
        // Need to copy over the AB values.
        //
        for (dwCtr = 0; dwCtr < dwNumValues; dwCtr++) {
            pVals[dwCtr].CaseExactString = AllocADsStr(_ppszABVals[dwCtr]);
            if (!pVals[dwCtr].CaseExactString) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
            pVals[dwCtr].dwType = (ADSTYPE) dwType;
        }
        goto error;
    }

    /* *******************
      this stuff is not needed anymore
    if (fLegacyDN) {
        //
        // Need to add the value as one of the proxyAddresses.
        //
        DWORD dwLenDN = wcslen(pCol->pADsValues[0].CaseExactString)
                       + wcslen(L"X500:") + 1;
        pAttrInfo->dwControlCode = ADS_ATTR_APPEND;

        pVals[0].CaseExactString = 
            (LPWSTR) AllocADsMem(dwLenDN * sizeof(WCHAR));

        if (!pVals[0].CaseExactString) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(pVals[0].CaseExactString, L"X500:");
        wcscat(pVals[0].CaseExactString, pCol->pADsValues[0].CaseExactString);
        pVals[dwCtr].dwType = (ADSTYPE) dwType;

        goto error;
    }
    **************** */

    //
    // More special casing.
    // 
    if (fProxyAddresses && pszTmpExtraVal) {
        dwNumValues--;
    }
 
    for (dwCtr = 0; dwCtr < dwNumValues; dwCtr++) {
        if (pszMappedDN) {
            FreeADsStr(pszMappedDN);
            pszMappedDN = NULL;
        }

        //
        // Type of pVals is similar to that of the column.
        //
        pVals[dwCtr].dwType = (ADSTYPE) dwType;

        switch (dwType) {
        case ADSTYPE_INVALID :
            hr = E_FAIL;
            break;

        case ADSTYPE_DN_STRING :
            //
            // We need to map the source dn to that of the target.
            //
            hr = _pTgtMgr->MapDNAttribute(
                     _pszSourceServer,
                     pCol->pADsValues[dwCtr].DNString,
                     &pVals[dwCtr].DNString
                     );
            BAIL_ON_FAILURE(hr);
            break;

        //
        // All of these are just strings.
        //
        case ADSTYPE_CASE_EXACT_STRING :
        case ADSTYPE_CASE_IGNORE_STRING :
        case ADSTYPE_PRINTABLE_STRING :
        case ADSTYPE_NUMERIC_STRING :
            //  
            // All of these are just strings.
            //
            pVals[dwCtr].CaseExactString =
                AllocADsStr(pCol->pADsValues[dwCtr].CaseExactString);

            if (!pVals[dwCtr].CaseExactString) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            //
            // See if the extra value is already there in the proxyAddr.
            //
            if (fProxyAddresses
                && pszTmpExtraVal
                && !_wcsicmp(pVals[dwCtr].CaseExactString, pszTmpExtraVal)
                ) {
                //
                // Free and set string to NULL, so that we do not process
                // further, decrement count on attrinfo.
                //
                FreeADsStr(pszTmpExtraVal);
                pszTmpExtraVal = NULL;
                (pAttrInfo->dwNumValues)--;                
            }

            break;

        case ADSTYPE_BOOLEAN :
            pVals[dwCtr].Boolean = pCol->pADsValues[dwCtr].Boolean;
            break;

        case ADSTYPE_INTEGER :
            pVals[dwCtr].Integer = pCol->pADsValues[dwCtr].Integer;
            break;

        //
        // All of these are really just OctetStrings.
        //
        case ADSTYPE_OCTET_STRING :
        case ADSTYPE_PROV_SPECIFIC :
        case ADSTYPE_NT_SECURITY_DESCRIPTOR :

            LPVOID pVoid;
            dwLen = pCol->pADsValues[dwCtr].OctetString.dwLength;
            pVoid = AllocADsMem(dwLen);

            if (dwLen && !pVoid) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            memcpy(
                pVoid,
                pCol->pADsValues[dwCtr].OctetString.lpValue, 
                dwLen
                );

            pVals[dwCtr].OctetString.lpValue = (LPBYTE) pVoid;
            pVals[dwCtr].OctetString.dwLength = dwLen;
            break;

        case ADSTYPE_UTC_TIME :
            pVals[dwCtr].UTCTime = pCol->pADsValues[dwCtr].UTCTime;
            break;

        case ADSTYPE_LARGE_INTEGER :
            pVals[dwCtr].LargeInteger = pCol->pADsValues[dwCtr].LargeInteger;
            break;

            //
            // These attribute types are not supported.
            //
        case ADSTYPE_OBJECT_CLASS :
        case ADSTYPE_CASEIGNORE_LIST :
        case ADSTYPE_OCTET_LIST :
        case ADSTYPE_PATH :
        case ADSTYPE_POSTALADDRESS :
        case ADSTYPE_TIMESTAMP :
        case ADSTYPE_BACKLINK :
        case ADSTYPE_TYPEDNAME :
        case ADSTYPE_HOLD :
        case ADSTYPE_NETADDRESS :
        case ADSTYPE_REPLICAPOINTER :
        case ADSTYPE_FAXNUMBER :
        case ADSTYPE_EMAIL :
        case ADSTYPE_UNKNOWN :
        case ADSTYPE_DN_WITH_BINARY :
        case ADSTYPE_DN_WITH_STRING :
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            break;

        default:
            hr = E_ADS_CANT_CONVERT_DATATYPE;
        break;

        } // end of switch
        BAIL_ON_FAILURE(hr);
    } // end of for.

    //
    // Finally if this is still the special case, then we need to add
    // the extra str value.
    //
    if (pszTmpExtraVal && fProxyAddresses) {
        pVals[dwCtr].CaseExactString = (LPWSTR) AllocADsStr(pszTmpExtraVal);
        if (!pVals[dwCtr].CaseExactString) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pVals[dwCtr].dwType = ADSTYPE_CASE_IGNORE_STRING;
    }

error:

    if (pszMappedDN) {
        FreeADsStr(pszMappedDN);
        pszMappedDN = NULL;
    }

    if (pszTmpExtraVal) {
        FreeADsStr(pszTmpExtraVal);
        pszTmpExtraVal = NULL;
    }
    
    //
    // Free the attrinfo if we failed.
    //
    if (!SUCCEEDED(hr)) {
        if (pAttrInfo->pszAttrName) {
            FreeADsStr(pAttrInfo->pszAttrName);
            pAttrInfo->pszAttrName = NULL;
        }

        if (pVals) {
            AdsFreeAdsValues(pVals, dwCtr);
            FreeADsMem(pVals);
            pAttrInfo->pADsValues = NULL;
        }
        pAttrInfo->dwNumValues = 0;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rendom\inc\rendom.h ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    rendom.h

ABSTRACT:

    This is the header for the globally useful data structures for the entire
    rendom.exe utility.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/

#ifndef _RENDOM_H_
#define _RENDOM_H_

#include <Winldap.h>
#include <rpc.h>

#define RENDOM_BUFFERSIZE 2048

    
    
class CDomain;
class CEnterprise;
class CDcList;
class CDc;

//This is an error class used in this module.  It will be used
//for all the error reporting in all of the class define below
class CRenDomErr {
public:
    VOID SetErr(DWORD  p_Win32Err,
                WCHAR* p_ErrStr,
                ...);
    VOID PrintError();
    BOOL isError();
    VOID SetMemErr();
    VOID AppendErr(WCHAR*,
                   ...);
    DWORD GetErr();
private:
    static DWORD m_Win32Err;
    static WCHAR *m_ErrStr;
    static BOOL  m_AlreadyPrinted;
};

class CXMLAttributeBlock {
public:
    CXMLAttributeBlock(const WCHAR *p_Name,
                       WCHAR *p_Value);
    ~CXMLAttributeBlock();
    WCHAR* GetName();
    WCHAR* GetValue();
private:
    CXMLAttributeBlock(const CXMLAttributeBlock&);
    WCHAR* m_Name;
    WCHAR* m_Value;
    CRenDomErr *m_Error;
};

//This is a Class for generating instructions in XML
class CXMLGen {
public:
    CXMLGen();
    ~CXMLGen();
    BOOL StartDcList();
    BOOL EndDcList();
    BOOL DctoXML(CDc *dc);
    BOOL StartDomainList();
    BOOL WriteHash(WCHAR*);
    BOOL WriteSignature(WCHAR*);
    BOOL EndDomainList();
    BOOL AddDomain(CDomain *d);
    BOOL StartScript();
    BOOL EndScript();
    BOOL StartAction(WCHAR *Actionname,BOOL Preprocess);
    BOOL EndAction();
    BOOL Move(WCHAR *FromPath,
              WCHAR *ToPath);
    BOOL Update(WCHAR *Object,
                CXMLAttributeBlock **attblock);
    BOOL ifInstantiated(WCHAR *guid);
    BOOL EndifInstantiated();
    BOOL Not();
    BOOL EndNot();
    BOOL Instantiated(WCHAR *path,
                      WCHAR *returnCode);
    BOOL Compare(WCHAR *path,
                 WCHAR *Attribute,
                 WCHAR *value,
                 WCHAR *returnCode);
    BOOL Cardinality(WCHAR *path,
                     WCHAR *cardinality);
    BOOL WriteScriptToFile(WCHAR* filename);
    BOOL UploadScript(LDAP *hLdapConn,
                      PWCHAR ObjectDN,
                      CDcList *dclist);
    VOID DumpScript();

private:
    CRenDomErr *m_Error;
    WCHAR*     m_xmldoc;
    DWORD      m_ErrorNum;
};

//This
class CDsName {
public:
    CDsName(WCHAR *p_Guid, //= 0
            WCHAR *p_DN, //= 0
            WCHAR *p_ObjectSid); //= 0
    ~CDsName();
    //CDsName(CDsName*);
    //BOOL   SetDNNamefromDNSName(const WCHAR*);
    //BOOL   ReplaceDNRoot(const WCHAR*);
    WCHAR* ReplaceRDN(const WCHAR*);
    BOOL   ReplaceDN(const WCHAR*);
    BOOL   CompareByObjectGuid(const WCHAR*);
    VOID   DumpCDsName();
    WCHAR* GetDNSName();
    WCHAR* GetDN();
    WCHAR* GetGuid();
    WCHAR* GetSid();
    BOOL  ErrorOccurred();   
    DWORD GetError();
private:
    WCHAR *m_ObjectGuid;
    WCHAR *m_DistName;
    WCHAR *m_ObjectSid;
    CRenDomErr *m_Error;
};

class CTrust {
public:
    CTrust(CDsName *p_Object,
           CDomain *p_TrustPartner);
    ~CTrust();
    inline CTrust* GetNext();
    inline BOOL SetNext(CTrust *);
    VOID DumpTrust();
    inline CDsName* GetTrustDsName();
    inline CDomain* GetTrustPartner();

protected:
    CDsName *m_Object;
    CDomain *m_TrustPartner;
    CTrust *m_next;
    CRenDomErr *m_Error;
    
};

class CTrustedDomain : public CTrust {
public:
    CTrustedDomain(CDsName *p_Object,
                   CDomain *p_TrustPartner,
                   DWORD    p_TrustType):CTrust(p_Object,
                                                   p_TrustPartner),m_TrustType(p_TrustType) {}
    inline VOID            SetTrustType(DWORD type) {m_TrustType = type;}
    inline DWORD           GetTrustType()           {return m_TrustType;}
    VOID DumpTrust();
private:
    DWORD m_TrustType;   
};
        
class CInterDomainTrust : public CTrust {
public:     
    CInterDomainTrust(CDsName *p_Object,
                      CDomain *p_TrustPartner):CTrust(p_Object,
                                                      p_TrustPartner) {}
    
};

class CDomain {
public:
    CDomain(CDsName *Crossref,
            CDsName *DNSObject,
            WCHAR *DNSroot,
            WCHAR *netbiosName,
            BOOL  p_isDomain,
            WCHAR *DcName);
    ~CDomain();
    VOID    DumpCDomain();
    BOOL    isDomain();
    BOOL    isDnsNameRenamed();
    BOOL    isNetBiosNameRenamed();
    WCHAR*  GetParentDnsRoot();
    WCHAR*  GetDnsRoot(BOOL ShouldAllocate = TRUE);
    WCHAR*  GetNetBiosName();
    WCHAR*  GetGuid();
    WCHAR*  GetSid();
    WCHAR*  GetPrevNetBiosName();
    WCHAR*  GetPrevDnsRoot(BOOL ShouldAllocate = TRUE);
    WCHAR*  GetDcToUse();
    CDsName* GetDomainCrossRef();
    CDsName* GetDomainDnsObject();
    CDomain* LookupByDnsRoot(const WCHAR*);
    CDomain* LookupByNetbiosName(const WCHAR*);
    CDomain* LookupByPrevDnsRoot(const WCHAR*);
    CDomain* LookupByPrevNetbiosName(const WCHAR*);
    CDomain* LookupByGuid(const WCHAR*);
    CDomain* LookupbySid(const WCHAR*);
    BOOL     Merge(CDomain *domain);
    BOOL     SetParent(CDomain*);
    BOOL     SetLeftMostChild(CDomain*);
    BOOL     SetRightSibling(CDomain*);
    BOOL     SetNextDomain(CDomain*);
    BOOL     AddDomainTrust(CTrustedDomain *);
    BOOL     AddInterDomainTrust(CInterDomainTrust *);
    CDomain* GetParent();
    CDomain* GetLeftMostChild();
    CDomain* GetRightSibling();
    CDomain* GetNextDomain();
    CTrustedDomain* GetTrustedDomainList();
    CInterDomainTrust* GetInterDomainTrustList();

private:
    WCHAR* Tail(WCHAR*);
    CDsName *m_CrossRefObject;
    CDsName *m_DomainDNSObject;
    BOOL   m_isDomain;
    WCHAR  *m_dnsRoot;
    WCHAR  *m_NetBiosName;
    WCHAR  *m_PrevDnsRoot;
    WCHAR  *m_PrevNetBiosName;
    WCHAR  *m_DcName;
    CTrustedDomain *m_tdoList;
    CInterDomainTrust *m_itaList;
    CDomain *m_next;
    CDomain *m_parent;
    CDomain *m_lChild;
    CDomain *m_rSibling;
    CRenDomErr *m_Error;
};

class CReadOnlyEntOptions {
public:
    CReadOnlyEntOptions():m_MinimalInfo(FALSE),
                          m_StateFile(L"DcList.xml"),
                          pCreds(NULL),
                          m_DomainlistFile(L"Domainlist.xml"),
                          m_InitalConnection(NULL),
                          m_UpLoadScript(FALSE),
                          m_Cleanup(FALSE),
                          m_ExecuteScript(FALSE),
                          m_PrepareScript(FALSE) {}
    inline BOOL IsMinimalInfo() {return m_MinimalInfo;}
    inline BOOL ShouldUpLoadScript() {return m_UpLoadScript;}
    inline BOOL ShouldExecuteScript() {return m_ExecuteScript;}
    inline BOOL ShouldPrepareScript() {return m_PrepareScript;}
    inline BOOL ShouldCleanup() {return m_Cleanup;}
    inline WCHAR* GetStateFileName() {return m_StateFile;}
    inline WCHAR* GetDomainlistFileName() {return m_DomainlistFile;}
    inline WCHAR* GetInitalConnectionName() {return m_InitalConnection;}

    SEC_WINNT_AUTH_IDENTITY_W * pCreds;

protected:
    BOOL m_MinimalInfo;
    WCHAR *m_StateFile;
    WCHAR *m_DomainlistFile;
    WCHAR *m_InitalConnection;
    BOOL m_UpLoadScript;
    BOOL m_ExecuteScript;
    BOOL m_PrepareScript;
    BOOL m_Cleanup;
};

//Options that can be pass to the construstor
class CEntOptions : public CReadOnlyEntOptions {
public:
    CEntOptions():CReadOnlyEntOptions() {}
    inline VOID SetMinimalInfo() {m_MinimalInfo = TRUE;}
    inline VOID SetShouldUpLoadScript() {m_UpLoadScript = TRUE;}
    inline VOID SetShouldExecuteScript() {m_ExecuteScript = TRUE;}
    inline VOID SetShouldPrepareScript() {m_PrepareScript = TRUE;}
    inline VOID SetStateFileName(WCHAR *p_FileName) {m_StateFile = p_FileName;}
    inline VOID SetDomainlistFile(WCHAR *p_FileName) {m_DomainlistFile = p_FileName;}
    inline VOID SetCleanup() {m_Cleanup = TRUE;}
    inline VOID SetInitalConnectionName(WCHAR *p_InitalConnection) {m_InitalConnection = p_InitalConnection;}
};

#define DC_STATE_INITIAL  0
#define DC_STATE_PREPARED 1
#define DC_STATE_DONE     2
#define DC_STATE_ERROR    3

#define DC_STATE_STRING_INITIAL  L"Initial"
#define DC_STATE_STRING_PREPARED L"Prepared"
#define DC_STATE_STRING_DONE     L"Done"
#define DC_STATE_STRING_ERROR    L"Error"

class CDc {
public:
    CDc(WCHAR *NetBiosName,
        DWORD State,
        BYTE  *Password,
        DWORD cbPassword,
        DWORD LastError,
        WCHAR *FatalErrorMsg,
        WCHAR *LastErrorMsg,
        PVOID data
        );
    CDc(WCHAR *NetBiosName,
        DWORD State,
        WCHAR *Password,
        DWORD LastError,
        WCHAR *FatalErrorMsg,
        WCHAR *LastErrorMsg,
        PVOID data
        );
    ~CDc();
    //This will create an entry into the DCList.xml file expressing information about this DC.
    BOOL   CreateXmlDest();
    BOOL   SetNextDC(CDc *dc);
    CDc*   GetNextDC() {return m_nextDC;}
    BOOL   SetPassword(BYTE *password,
                     DWORD cbpassword);
    BOOL   SetPassword(WCHAR *password);
    BOOL   SetLastErrorMsg(WCHAR *Error);
    BOOL   SetFatalErrorMsg(WCHAR *Error);
    VOID   SetLastError(DWORD Error) {m_LastError = Error;}
    VOID   SetState(DWORD State) {m_State = State;}
    WCHAR* GetName() {return m_Name;}
    BYTE*  GetPassword() {return m_Password;}
    DWORD  GetPasswordSize() {return m_cbPassword;}
    WCHAR* GetLastErrorMsg() {return m_LastErrorMsg;}
    DWORD  GetLastError() {return m_LastError;}
    WCHAR* GetLastFatalErrorMsg() {return m_FatalErrorMsg;}
    DWORD  GetState() {return m_State;}
    
    PVOID        m_Data;
    DWORD        m_RPCReturn;
    DWORD        m_RPCVersion;
private:
    DWORD        m_State;
    DWORD        m_LastError;
    WCHAR        *m_Name;
    WCHAR        *m_FatalErrorMsg;
    WCHAR        *m_LastErrorMsg;
    BYTE         *m_Password;
    DWORD        m_cbPassword;
    //Pointer to the next DC on the list
    CDc          *m_nextDC;
    CRenDomErr   *m_Error;
    
};

class CDcList {
public:
    enum ExecuteType {
        ePrepare,
        eExecute
    };
    CDcList(CReadOnlyEntOptions *opts);
    ~CDcList();
    CDc* GetFirstDc() {return m_dclist;}
    BOOL AddDcToList(CDc *dc);
    //This will create a list of dc that will be stored to a File
    BOOL GenerateDCListFromEnterprise(LDAP *hldap,
                                      WCHAR *ConfigurationDN);
    //will call xml parser to look through file to fill the dcList with DCs from file.
    BOOL PopulateDCListFromFile();
    //will begin async Rpc calls to ExecuteScript all the DCs.  The Flags Will indicate if the Test or Action part of the script should run.
    BOOL ExecuteScript(CDcList::ExecuteType);
    BOOL HashstoXML(CXMLGen *xmlgen);
    BOOL SetbodyHash(BYTE *Hash,
                     DWORD cbHash);
    BOOL SetbodyHash(WCHAR *Hash);
    BOOL SetSignature(BYTE *Signature,
                      DWORD cbSignature);
    BOOL SetSignature(WCHAR *Signature);
    BOOL GetHashAndSignature(DWORD *cbhash, 
                             BYTE  **hash,
                             DWORD *cbSignature,
                             BYTE  **Signature);

private:
    //Pointer to the first DC on the list
    CDc                 *m_dclist;
    BYTE                *m_hash;
    DWORD                m_cbhash;
    BYTE                *m_Signature;
    DWORD                m_cbSignature;
    CRenDomErr          *m_Error;
    CReadOnlyEntOptions *m_Opts;


}; 

class CEnterprise {
public:
    CEnterprise(CReadOnlyEntOptions *opts);
    ~CEnterprise();
    BOOL WriteScriptToFile(WCHAR *filename);
    VOID DumpEnterprise();
    VOID DumpScript();
    BOOL ReadDomainInformation();
    BOOL ReadForestChanges();
    BOOL ReadStateFile();
    BOOL GetTrustsInfo();
    BOOL BuildForest();
    BOOL MergeForest();
    BOOL RemoveDNSAliasAndScript();
    BOOL UploadScript();
    BOOL ExecuteScript();
    BOOL CheckConsistency();
    BOOL GenerateDomainList();
    BOOL GenerateDcList();
    BOOL GenerateReNameScript();
    BOOL EnumeratePartitions();
    BOOL GetInfoFromRootDSE();
    BOOL GetReplicationEpoch();
    BOOL LdapConnectandBindToServer(WCHAR *Server);
    BOOL LdapConnectandBind(CDomain *domain = NULL);  
    BOOL LdapConnectandBindToDomainNamingFSMO();
    BOOL TearDownForest();
    BOOL FixMasterCrossrefs();
    BOOL EnsureValidTrustConfiguration();
    BOOL HandleNDNCCrossRef(CDomain *d);
    BOOL AddDomainToDomainList(CDomain *d);
    BOOL AddDomainToDescList(CDomain *d);
    BOOL ClearLinks(CDomain *d);
    BOOL ScriptTreeFlatting(CDomain *d);
    BOOL ScriptDomainRenaming(CDomain *d);
    BOOL ScriptFixCrossRefs(CDomain *d);
    BOOL ScriptFixTrustedDomains(CDomain *d);
    BOOL ScriptAdvanceReplicationEpoch();
    BOOL DomainToXML(CDomain *d);
    BOOL Error();
    BOOL WriteTest();
    BOOL TestTrusts(CDomain *domain);
    CDcList* GetDcList() {return &m_DcList;}
    
private:
    WCHAR* DNSRootToDN(WCHAR *DNSRoot);
    BOOL LdapGetGuid(WCHAR *LdapValue,
                     WCHAR **Guid);
    BOOL LdapGetSid(WCHAR *LdapValue,
                    WCHAR **Sid);
    BOOL LdapGetDN(WCHAR *LdapValue,
                   WCHAR **DN);
    // This is a helper to the constructor
    BOOL CreateChildBeforeParentOrder();
    // SetAction must be called before calling one of the 
    // Traverse functions.
    BOOL SetAction(BOOL (CEnterprise::*m_Action)(CDomain *));
    BOOL ClearAction();
    // should only be called when m_Action is set
    BOOL TraverseDomainsParentBeforeChild();
    // should only be called when m_Action is set
    BOOL TraverseDomainsChildBeforeParent();
    //BOOL ReadConfig();
    //BOOL ReadSchema();
    //BOOL ReadForestRootNC();
    BOOL (CEnterprise::*m_Action)(CDomain *);
    BOOL fReadConfig();
    BOOL fReadSchema();
    BOOL fReadForestRootNC();
    inline CReadOnlyEntOptions* GetOpts();
    CDsName *m_ConfigNC;
    CDsName *m_SchemaNC;
    CDsName *m_ForestRootNC;
    CDomain *m_DomainList;
    CDomain *m_ForestRoot;
    CDomain *m_descList;
    DWORD  m_maxReplicationEpoch;
    CXMLGen *m_xmlgen;
    CRenDomErr *m_Error;
    LDAP *m_hldap;
    CReadOnlyEntOptions *m_Opts;
    CDcList m_DcList;
};

  


#endif  // _RENDOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rendom\inc\renutil.h ===
#ifndef RENUTIL_H
#define RENUTIL_H

VOID
AddModOrAdd(
    IN PWCHAR  AttrType,
    IN PWCHAR  AttrValue,
    IN ULONG  mod_op,
    IN OUT LDAPModW ***pppMod
    );

VOID
AddModMod(
    IN PWCHAR  AttrType,
    IN PWCHAR  AttrValue,
    IN OUT LDAPMod ***pppMod
    );

VOID
FreeMod(
    IN OUT LDAPMod ***pppMod
    );

ULONG 
RemoveRootofDn(
    IN WCHAR *DN
    );

DWORD
GetRDNWithoutType(
       WCHAR *pDNSrc,
       WCHAR **pDNDst
       );

DWORD
TrimDNBy(
       WCHAR *pDNSrc,
       ULONG cava,
       WCHAR **pDNDst
       );

INT
GetPassword(
    WCHAR *     pwszBuf,
    DWORD       cchBufMax,
    DWORD *     pcchBufUsed
    );

int
PreProcessGlobalParams(
    IN OUT    INT *    pargc,
    IN OUT    LPWSTR** pargv,
    SEC_WINNT_AUTH_IDENTITY_W *& gpCreds      
    );

WCHAR *
Convert2WChars(
    char * pszStr
    );

CHAR * 
Convert2Chars(
    LPCWSTR lpWideCharStr
    );

BOOLEAN
ValidateNetbiosName(
    IN  PWSTR Name,
    IN  ULONG Length
    );

#endif // RENUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rendom\inc\domainlistparser.h ===
// Domainlistparser.h: interface for the MyContent class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _DOMAINLISTPARSER_H
#define _DOMAINLISTPARSER_H

//#include "rendom.h"
#include "SAXContentHandlerImpl.h"

#define DOMAINSCRIPT_FOREST           L"Forest"
#define DOMAINSCRIPT_DOMAIN           L"Domain"
#define DOMAINSCRIPT_GUID             L"Guid"
#define DOMAINSCRIPT_DNSROOT          L"DNSname"
#define DOMAINSCRIPT_NETBIOSNAME      L"NetBiosName"
#define DOMAINSCRIPT_DCNAME           L"DcName"

// These are only need for testing the rendom.exe util
#define DOMAINSCRIPT_ENTERPRISE_INFO  L"EnterpriseInfo"
#define DOMAINSCRIPT_CONFIGNC         L"ConfigurationNC"
#define DOMAINSCRIPT_SCHEMANC         L"SchemaNC"
#define DOMAINSCRIPT_DN               L"DN"
#define DOMAINSCRIPT_SID              L"SID"
#define DOMAINSCRIPT_FORESTROOT       L"ForestRootGuid"


//
// NTDSContent
//
// Implements the SAX Handler interface
// 
class CXMLDomainListContentHander : public SAXContentHandlerImpl  
{
public:
    enum DomainAttType {

        DOMAIN_ATT_TYPE_NONE = 0,
        DOMAIN_ATT_TYPE_GUID,
        DOMAIN_ATT_TYPE_DNSROOT,
        DOMAIN_ATT_TYPE_NETBIOSNAME,
        DOMAIN_ATT_TYPE_DCNAME,
        DOMAIN_ATT_TYPE_SID,
        DOMAIN_ATT_TYPE_DN,
        DOMAIN_ATT_TYPE_FORESTROOTGUID,
        
    };
    
    // the order of the enumeration is important
    enum DomainParsingStatus {

        SCRIPT_STATUS_WAITING_FOR_FOREST = 0,
        SCRIPT_STATUS_WAITING_FOR_DOMAIN,
        SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT,
        SCRIPT_STATUS_PARSING_DOMAIN_ATT,
        SCRIPT_STATUS_WAITING_FOR_ENTERPRISE_INFO,
        SCRIPT_STATUS_PARSING_CONFIGURATION_NC,
        SCRIPT_STATUS_PARSING_SCHEMA_NC,
        SCRIPT_STATUS_PARSING_FOREST_ROOT_GUID

    };

    CXMLDomainListContentHander(CEnterprise *p_Enterprise);
    virtual ~CXMLDomainListContentHander();
    
    virtual HRESULT STDMETHODCALLTYPE startElement( 
        /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
        /* [in] */ int cchNamespaceUri,
        /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
        /* [in] */ int cchLocalName,
        /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
        /* [in] */ int cchRawName,
        /* [in] */ ISAXAttributes __RPC_FAR *pAttributes);
    
    virtual HRESULT STDMETHODCALLTYPE endElement( 
        /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
        /* [in] */ int cchNamespaceUri,
        /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
        /* [in] */ int cchLocalName,
        /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
        /* [in] */ int cchRawName);

    virtual HRESULT STDMETHODCALLTYPE startDocument();

    virtual HRESULT STDMETHODCALLTYPE characters( 
        /* [in] */ const wchar_t __RPC_FAR *pwchChars,
        /* [in] */ int cchChars);

private:

    inline
    DomainParsingStatus 
    CurrentDomainParsingStatus() {return m_eDomainParsingStatus;}

    inline
    DomainAttType
    CurrentDomainAttType()       {return m_eDomainAttType;}

    inline
    VOID
    SetDomainParsingStatus(DomainParsingStatus p_status) {m_eDomainParsingStatus = p_status;}

    inline
    VOID
    SetCurrentDomainAttType(DomainAttType p_AttType) {m_eDomainAttType = p_AttType;}

    DomainParsingStatus           m_eDomainParsingStatus; 
    DomainAttType                 m_eDomainAttType;
                                
    CEnterprise                  *m_enterprise;
    CDomain                      *m_Domain;
    CRenDomErr                   *m_Error;
    CDsName                      *m_DsName;
    CDsName                      *m_CrossRef;
    CDsName                      *m_ConfigNC;
    CDsName                      *m_SchemaNC;
                                
    WCHAR                        *m_DcToUse;
    WCHAR                        *m_NetBiosName;
    WCHAR                        *m_Dnsname;
    WCHAR                        *m_Guid;
    WCHAR                        *m_Sid;
    WCHAR                        *m_DN;
    WCHAR                        *m_DomainRootGuid;
    
};

#endif // _DOMAINLISTPARSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rendom\inc\saxcontenthandlerimpl.h ===
// SAXContentHandlerImpl.h: interface for the SAXContentHandlerImpl class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _SAXCONTENTHANDLERIMPL_H
#define _SAXCONTENTHANDLERIMPL_H

#include "ole2.h"
#include "msxml2.h"

HRESULT GetClassFactory( REFCLSID clsid, IClassFactory ** ppFactory);


class SAXContentHandlerImpl : public ISAXContentHandler  
{
public:
    SAXContentHandlerImpl();
    virtual ~SAXContentHandlerImpl();

public: // IUnknown
        long __stdcall QueryInterface(const struct _GUID &,void ** );
        unsigned long __stdcall AddRef(void);
        unsigned long __stdcall Release(void);

public: // ISAXContentHandler
            virtual HRESULT STDMETHODCALLTYPE putDocumentLocator( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator);
        
        virtual HRESULT STDMETHODCALLTYPE startDocument( void);
        
        virtual HRESULT STDMETHODCALLTYPE endDocument( void);
        
        virtual HRESULT STDMETHODCALLTYPE startPrefixMapping(
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri);
        
        virtual HRESULT STDMETHODCALLTYPE endPrefixMapping(
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix);
        
        virtual HRESULT STDMETHODCALLTYPE startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes);
        
        virtual HRESULT STDMETHODCALLTYPE endElement(
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName);
        
        virtual HRESULT STDMETHODCALLTYPE characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars);
        
        virtual HRESULT STDMETHODCALLTYPE ignorableWhitespace( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars);
        
        virtual HRESULT STDMETHODCALLTYPE processingInstruction( 
            /* [in] */ const wchar_t __RPC_FAR *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ const wchar_t __RPC_FAR *pwchData,
            /* [in] */ int cchData);
        
        virtual HRESULT STDMETHODCALLTYPE skippedEntity( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName);

private:
    long    _cRef;
};

#endif //  _SAXCONTENTHANDLERIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rendom\src\main.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "rendom.h"
#include <locale.h>
#include <stdio.h>

#include "renutil.h"

INT __cdecl
wmain (
    INT                argc,
    LPWSTR *           argv,
    LPWSTR *           envp
    )
{
    CEntOptions Opts;

    INT iArg = 0;
    BOOL bFound = FALSE;
    BOOL bOutFileSet = FALSE;
    UINT Codepage;
    WCHAR *pszTemp = NULL;
    BOOL MajorOptSet = FALSE;
    BOOL ExtraMajorSet = FALSE;
    
    char achCodepage[12] = ".OCP";

    //
    // Set locale to the default
    //
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%u", Codepage);
    }
    setlocale(LC_ALL, achCodepage);

    //parse the command line
    PreProcessGlobalParams(&argc, &argv, Opts.pCreds);

    for (iArg = 1; iArg < argc ; iArg++)
    {
        bFound = FALSE;
        if (*argv[iArg] == L'-')
        {
            *argv[iArg] = L'/';
        }
        if (*argv[iArg] != L'/')
        {
            wprintf (L"Invalid Syntax: Use rendom.exe /h for help.\n");
            return -1;
        }
        else if (_wcsicmp(argv[iArg],L"/list") == 0)
        {
            Opts.SetMinimalInfo();
            bFound = TRUE;
            if (MajorOptSet) {
                ExtraMajorSet = TRUE;
            }
            MajorOptSet = TRUE;
        }
        else if (_wcsicmp(argv[iArg],L"/UpLoad") == 0)
        {
            Opts.SetShouldUpLoadScript();
            bFound = TRUE;
            if (MajorOptSet) {
                ExtraMajorSet = TRUE;
            }
            MajorOptSet = TRUE;
        }
        else if (_wcsicmp(argv[iArg],L"/Execute") == 0)
        {
            Opts.SetShouldExecuteScript();
            bFound = TRUE;
            if (MajorOptSet) {
                ExtraMajorSet = TRUE;
            }
            MajorOptSet = TRUE;
        }
        else if (_wcsicmp(argv[iArg],L"/Prepare") == 0)
        {
            Opts.SetShouldPrepareScript();
            bFound = TRUE;
            if (MajorOptSet) {
                ExtraMajorSet = TRUE;
            }
            MajorOptSet = TRUE;
        }
        else if (_wcsnicmp(argv[iArg],L"/DC:",wcslen(L"/DC:")) == 0)
        {
            pszTemp = &argv[iArg][wcslen(L"/DC:")];

            if (*pszTemp == L'\0')
            {
                wprintf(L"Syntax Error: must use /DC:<file Name>\n");
                return -1;
            }
            Opts.SetInitalConnectionName(pszTemp);
            bFound = TRUE;
        }
        else if (_wcsnicmp(argv[iArg],L"/Clean",wcslen(L"/Clean")) == 0){
            Opts.SetCleanup();
            bFound = TRUE;
            if (MajorOptSet) {
                ExtraMajorSet = TRUE;
            }
            MajorOptSet = TRUE;
        }

        else if (_wcsnicmp(argv[iArg],L"/listfile:",wcslen(L"/listfile:")) == 0)
        {
            pszTemp = &argv[iArg][wcslen(L"/listfile:")];

            if (*pszTemp == L'\0')
            {
                wprintf(L"Syntax Error: must use /listfile:<file Name>\n");
                return -1;
            }
            Opts.SetDomainlistFile(pszTemp);
            bFound = TRUE;
        }
        else if (_wcsnicmp(argv[iArg],L"/statefile:",wcslen(L"/statefile:")) == 0)
        {
            pszTemp = &argv[iArg][wcslen(L"/statefile:")];

            if (*pszTemp == L'\0')
            {
                wprintf(L"Syntax Error: must use /statefile:<file Name>\n");
                return -1;
            }

            Opts.SetStateFileName(pszTemp);
            bOutFileSet = TRUE;
            bFound = TRUE;
        }
        else if ((_wcsnicmp(argv[iArg],L"/h",wcslen(L"/h")) == 0) ||
                 (_wcsnicmp(argv[iArg],L"/?",wcslen(L"/?")) == 0) ) {

                //   "============================80 char ruler======================================="
            wprintf(L"rendom:  perform various actions necessary for a domain rename operation\n\n");
            wprintf(L"Usage:  rendom </list | /upload | /prepare | /execute | /clean>\n");
            wprintf(L"      [/user:USERNAME] [/pwd:{PASSWORD|*}]\n");
            wprintf(L"      [/dc:{DCNAME | DOMAIN}]\n");
            wprintf(L"      [/listfile:LISTFILE] [/statefile:STATEFILE] [/?]\n\n");
            wprintf(L"/dc:{DCNAME | DOMAIN}\n");
            wprintf(L"      Connect to the DC with name DCNAME. If DOMAIN is specified instead, then\n");
            wprintf(L"      connect to a DC in that domain. [Default: connect to a DC in the domain\n");
            wprintf(L"      to which the current computer belongs]\n\n");
            wprintf(L"/user:USERNAME	Connect as USERNAME [Default: the logged in user]\n\n");
            wprintf(L"/pwd:{PASSWORD | *}\n");
            wprintf(L"      Password for the user USERNAME [if * is specified instead of a password,\n");
            wprintf(L"      then prompt for password]\n\n");
            wprintf(L"/list\n");
            wprintf(L"      List the naming contexts in the forest (forest desc) into a file as text\n");
            wprintf(L"      description using a XML format\n\n");
            wprintf(L"/upload\n");
            wprintf(L"      Upload the auto-generated script into the directory that will perform the\n");
            wprintf(L"      domain rename related directory changes on all domain controllers\n\n");
            wprintf(L"/prepare\n");
            wprintf(L"      Prepare for domain rename by verifying authorization, successful\n");
            wprintf(L"      replication of the uploaded script and network connectivity\n\n");
            wprintf(L"/execute\n");
            wprintf(L"      Execute the uploaded script on all domain controllers to actually perform\n"); 
            wprintf(L"      the domain rename operation\n\n");
            wprintf(L"/clean\n");
            wprintf(L"      Clean up all state left behind in the directory by the domain rename\n");
            wprintf(L"      operation\n\n");
            wprintf(L"/listfile:LISTFILE\n");
            wprintf(L"      Use LISTFILE as the name of the file used to hold the list of naming\n"); 
            wprintf(L"      contexts in the forest (forest desc). This file is created by the\n");
            wprintf(L"      /list command and is used as input for the /upload command. [Default:\n");
            wprintf(L"      file DOMAINLIST.XML in the current dir]\n\n");
            wprintf(L"/statefile:STATEFILE\n");
            wprintf(L"      Use STATEFILE as the name of the file used to keep track of the state of\n");
            wprintf(L"      the domain rename operation on each DC in the forest. This file is\n");
            wprintf(L"      created by the /upload command. [Default: file DCLIST.XML in the current\n");
            wprintf(L"      dir]\n");
            return 0;
        }
        if(!bFound)
        {
            wprintf (L"Syntax Error: %s.  Use rendom.exe /h for help.\n", argv[iArg]);
            return 1;
        }
    }
    
    if (ExtraMajorSet || !MajorOptSet ) 
    {
        wprintf (L"Usage: must have one and only one of the Following [/list | /upload | /prepare | /execute | /clean]");    
        return 1;
    }

    CEnterprise *enterprise = new CEnterprise(&Opts);
    if (!enterprise) {
        wprintf (L"Failed to execute out of memory.\n");
        return 1;
    }
    if (enterprise->Error()) {
        goto Exit;
    }

    if (Opts.ShouldCleanup()) {
        enterprise->RemoveDNSAliasAndScript();
        if (enterprise->Error()) {
            goto Exit;
        }
    }

    if (Opts.ShouldExecuteScript() || Opts.ShouldPrepareScript()) {

        enterprise->ReadStateFile();
        if (enterprise->Error()) {
            goto Exit;
        }

        enterprise->ExecuteScript();
        if (enterprise->Error()) {
            goto Exit;
        }

    }
    
    if (Opts.IsMinimalInfo()) {

        enterprise->GenerateDomainList();
        if (enterprise->Error()) {
            goto Exit;
        }

        enterprise->WriteScriptToFile(Opts.GetDomainlistFileName());
        if (enterprise->Error()) {
            goto Exit;
        }


    }

    //enterprise->DumpScript();
    //if (enterprise->Error()) {
    //    goto Exit;
    //}

    if (Opts.ShouldUpLoadScript()) {
        enterprise->MergeForest();
        if (enterprise->Error()) {
            goto Exit;
        }
    
        enterprise->GenerateReNameScript();
        if (enterprise->Error()) {
            goto Exit;
        }

#ifdef DBG
        enterprise->WriteScriptToFile(L"rename.xml");
        if (enterprise->Error()) {
            goto Exit;
        }
#endif

        enterprise->UploadScript();
        if (enterprise->Error()) {
            goto Exit;
        }
        
    }

    if (Opts.ShouldExecuteScript() ||
        Opts.ShouldPrepareScript() ||
        Opts.ShouldUpLoadScript() ) 
    {
        enterprise->GenerateDcList();
        if (enterprise->Error()) {
            goto Exit;
        }

        enterprise->WriteScriptToFile(Opts.GetStateFileName());
        if (enterprise->Error()) {
            goto Exit;
        }
    }
    
    Exit:

    if (enterprise->Error()) {
        delete enterprise;
        return 1;
    }

    delete enterprise;

    wprintf(L"\r\nThe operation completed successfully.\r\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rendom\util\renutil.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winldap.h>
#include <stdio.h>
#include <stdlib.h>                          
#include <rpc.h>
#include <windns.h>
#include <wtypes.h>

#define CR        0xD
#define BACKSPACE 0x8

//From ds\ds\src\sam\server\utility.c
WCHAR InvalidDownLevelChars[] = TEXT("\"/\\[]:|<>+=;?,*")
                                TEXT("\001\002\003\004\005\006\007")
                                TEXT("\010\011\012\013\014\015\016\017")
                                TEXT("\020\021\022\023\024\025\026\027")
                                TEXT("\030\031\032\033\034\035\036\037");
DWORD
AddModOrAdd(
    IN PWCHAR  AttrType,
    IN PWCHAR  AttrValue,
    IN ULONG  mod_op,
    IN OUT LDAPModW ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    mod_op          - LDAP_MOD_ADD/REPLACE
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD    NumMod;     // Number of entries in the Mod array
    LDAPModW **ppMod;    // Address of the first entry in the Mod array
    LDAPModW *Attr;      // An attribute structure
    PWCHAR   *Values;    // An array of pointers to bervals

    if (AttrValue == NULL)
        return ERROR_INVALID_PARAMETER;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        if (!*pppMod) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);
    if (!*pppMod) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PWCHAR  *)malloc(sizeof (PWCHAR ) * 2);
    if (!Values) {
        free(*pppMod);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Values[0] = _wcsdup(AttrValue);
    if (!Values[0]) {
        free(*pppMod);
        free(Values);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    if (!Attr) {
        free(*pppMod);
        free(Values);
        free(Values[0]);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    Attr->mod_values = Values;
    Attr->mod_type = _wcsdup(AttrType);
    if (!Attr->mod_type) {
        free(*pppMod);
        free(Values);
        free(Values[0]);
        free(Attr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    Attr->mod_op = mod_op;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;

    return ERROR_SUCCESS;

} 
 
VOID
AddModMod(
    IN PWCHAR  AttrType,
    IN PWCHAR  AttrValue,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_modify() function to change an object in the DS.
    The null-terminated array referenced by pppMod grows with each call
    to this routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    AddModOrAdd(AttrType, AttrValue, LDAP_MOD_REPLACE, pppMod);
}

VOID
FreeMod(
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Free the structure built by successive calls to AddMod().

Arguments:
    pppMod  - Address of a null-terminated array.

Return Value:
    *pppMod set to NULL.
--*/
{
    DWORD   i, j;
    LDAPMod **ppMod;

    if (!pppMod || !*pppMod) {
        return;
    }

    // For each attibute
    ppMod = *pppMod;
    for (i = 0; ppMod[i] != NULL; ++i) {
        //
        // For each value of the attribute
        //
        for (j = 0; (ppMod[i])->mod_values[j] != NULL; ++j) {
            // Free the value
            if (ppMod[i]->mod_op & LDAP_MOD_BVALUES) {
                free(ppMod[i]->mod_bvalues[j]->bv_val);
            }
            free((ppMod[i])->mod_values[j]);
        }
        free((ppMod[i])->mod_values);   // Free the array of pointers to values
        free((ppMod[i])->mod_type);     // Free the string identifying the attribute
        free(ppMod[i]);                 // Free the attribute
    }
    free(ppMod);        // Free the array of pointers to attributes
    *pppMod = NULL;     // Now ready for more calls to AddMod()
}

ULONG RemoveRootofDn(WCHAR *DN) 
{
    WCHAR **DNParts=0;
    DWORD i = 0;
    ULONG err = 0;
    
    DNParts = ldap_explode_dnW(DN,
                               0);
    
    //set the String to empty.  The new string will
    //be shorter than the old so we don't need to 
    //allocate new memory.
    DN[0] = L'\0';

    wcscpy(DN,DNParts[i++]);
    while(0 != DNParts[i]) {
        wcscat(DN,L",");
        if (wcsstr(DNParts[i],L"DC=")) {
            break;
        }
        wcscat(DN,DNParts[i++]);
    }
        
    if( err = ldap_value_freeW(DNParts) )
    {
        return err;
    }
    
    return ERROR_SUCCESS;
}

DWORD
GetRDNWithoutType(
       WCHAR *pDNSrc,
       WCHAR **pDNDst
       )
/*++

Routine Description:

    Takes in a DN and Returns the RDN.
    
Arguments:

    pDNSrc - the source DN

    pDNDst - the destination for the RDN

Return Values:

    0 if all went well

 --*/
{
    WCHAR **DNParts=0;

    if (!pDNSrc) {
        return ERROR_INVALID_PARAMETER;
    }

    DNParts = ldap_explode_dnW(pDNSrc,
                               TRUE);
    if (DNParts) {
        DWORD size = wcslen(DNParts[0])+1;
        *pDNDst = new WCHAR[size];
        if (!*pDNDst) {
           return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(*pDNDst,DNParts[0]);
        
        if( ULONG err = ldap_value_freeW(DNParts) )
        {
            return LdapMapErrorToWin32(err);
        }
    }

    
    return ERROR_SUCCESS;
}


DWORD
TrimDNBy(
       WCHAR *pDNSrc,
       ULONG cava,
       WCHAR **pDNDst
       )
/*++

Routine Description:

    Takes in a dsname and copies the first part of the dsname to the
    dsname it returns.  The number of AVAs to remove are specified as an
    argument.

Arguments:

    pDNSrc - the source Dsname

    cava - the number of AVAs to remove from the first name

    pDNDst - the destination Dsname

Return Values:

    0 if all went well, the number of AVAs we were unable to remove if not

 N.B. This routine is exported to in-process non-module callers
--*/
{
    if (!pDNSrc) {
        return ERROR_INVALID_PARAMETER;
    }

    WCHAR **DNParts=0;
    DNParts = ldap_explode_dnW(pDNSrc,
                               0);
    if (DNParts) {
        DWORD size = wcslen(pDNSrc)+1;
        *pDNDst = new WCHAR[size];
        if (!*pDNDst) {
           return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(*pDNDst,DNParts[cava]);
        DWORD i = cava+1;
        while(0 != DNParts[i]){
            wcscat(*pDNDst,L",");
            wcscat(*pDNDst,DNParts[i++]);
        }
            
        if( ULONG err = ldap_value_freeW(DNParts) )
        {
            return LdapMapErrorToWin32(err);
        }
    }

    
    return ERROR_SUCCESS;
}

INT
GetPassword(
    WCHAR *     pwszBuf,
    DWORD       cchBufMax,
    DWORD *     pcchBufUsed
    )
/*++

Routine Description:

    Retrieve password from command line (without echo).
    Code stolen from LUI_GetPasswdStr (net\netcmd\common\lui.c).

Arguments:

    pwszBuf - buffer to fill with password
    cchBufMax - buffer size (incl. space for terminating null)
    pcchBufUsed - on return holds number of characters used in password

Return Values:

    DRAERR_Success - success
    other - failure

--*/
{
    WCHAR   ch;
    WCHAR * bufPtr = pwszBuf;
    DWORD   c;
    INT     err;
    INT     mode;

    cchBufMax -= 1;    /* make space for null terminator */
    *pcchBufUsed = 0;               /* GP fault probe (a la API's) */
    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), (LPDWORD)&mode)) {
        return GetLastError();
    }
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
        if (!err || c != 1)
            ch = 0xffff;

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
            break;

        if (ch == BACKSPACE) {  /* back up one or two */
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != pwszBuf) {
                bufPtr--;
                (*pcchBufUsed)--;
            }
        }
        else {

            *bufPtr = ch;

            if (*pcchBufUsed < cchBufMax)
                bufPtr++ ;                   /* don't overflow buf */
            (*pcchBufUsed)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = L'\0';         /* null terminate the string */
    putchar('\n');

    if (*pcchBufUsed > cchBufMax)
    {
        wprintf(L"Password too long!\n");
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}

int
PreProcessGlobalParams(
    IN OUT    INT *    pargc,
    IN OUT    LPWSTR** pargv,
    SEC_WINNT_AUTH_IDENTITY_W *& gpCreds      
    )
/*++

Routine Description:

    Scan command arguments for user-supplied credentials of the form
        [/-](u|user):({domain\username}|{username})
        [/-](p|pw|pass|password):{password}
    Set credentials used for future DRS RPC calls and LDAP binds appropriately.
    A password of * will prompt the user for a secure password from the console.

    Also scan args for /async, which adds the DRS_ASYNC_OP flag to all DRS RPC
    calls.

    CODE.IMPROVEMENT: The code to build a credential is also available in
    ntdsapi.dll\DsMakePasswordCredential().

Arguments:

    pargc
    pargv


Return Values:

    ERROR_SUCCESS - success
    other - failure

--*/
{
    INT     ret = 0;
    INT     iArg;
    LPWSTR  pszOption;

    DWORD   cchOption;
    LPWSTR  pszDelim;
    LPWSTR  pszValue;
    DWORD   cchValue;

    static SEC_WINNT_AUTH_IDENTITY_W  gCreds = { 0 };

    for (iArg = 1; iArg < *pargc; ){
        if (((*pargv)[iArg][0] != L'/') && ((*pargv)[iArg][0] != L'-')){
            // Not an argument we care about -- next!
            iArg++;
        } else {
            pszOption = &(*pargv)[iArg][1];
            pszDelim = wcschr(pszOption, L':');

        cchOption = (DWORD)(pszDelim - (*pargv)[iArg]);

        if (    (0 == _wcsnicmp(L"p:",        pszOption, cchOption))
            || (0 == _wcsnicmp(L"pw:",       pszOption, cchOption))
            || (0 == _wcsnicmp(L"pwd:",      pszOption, cchOption))
            || (0 == _wcsnicmp(L"pass:",     pszOption, cchOption))
            || (0 == _wcsnicmp(L"password:", pszOption, cchOption)) ){
            // User-supplied password.
          //            char szValue[ 64 ] = { '\0' };

        pszValue = pszDelim + 1;
        cchValue = 1 + wcslen(pszValue);

        if ((2 == cchValue) && (L'*' == pszValue[0])){
            // Get hidden password from console.
            cchValue = 64;

            gCreds.Password = new WCHAR[cchValue];

            if (NULL == gCreds.Password){
                wprintf( L"No memory.\n" );
            return ERROR_NOT_ENOUGH_MEMORY;
            }

            wprintf( L"Password: ");

            ret = GetPassword(gCreds.Password, cchValue, &cchValue);
        } else {
            // Get password specified on command line.
            gCreds.Password = new WCHAR[cchValue];

            if (NULL == gCreds.Password){
                wprintf( L"No memory.\n");
            return ERROR_NOT_ENOUGH_MEMORY;
            }
            wcscpy(gCreds.Password, pszValue); //, cchValue);

        }

        // Next!
        memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
        --(*pargc);
        } else if (    (0 == _wcsnicmp(L"u:",    pszOption, cchOption))
               || (0 == _wcsnicmp(L"user:", pszOption, cchOption)) ){


            // User-supplied user name (and perhaps domain name).
            pszValue = pszDelim + 1;
        cchValue = 1 + wcslen(pszValue);

        pszDelim = wcschr(pszValue, L'\\');

        if (NULL == pszDelim){
            // No domain name, only user name supplied.
            wprintf( L"User name must be prefixed by domain name.\n");
            return ERROR_INVALID_PARAMETER;
        }

        gCreds.Domain = new WCHAR[cchValue];
        gCreds.User = gCreds.Domain + (int)(pszDelim+1 - pszValue);

        if (NULL == gCreds.Domain){
            wprintf( L"No memory.\n");
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcsncpy(gCreds.Domain, pszValue, cchValue);
        // wcscpy(gCreds.Domain, pszValue); //, cchValue);
        gCreds.Domain[ pszDelim - pszValue ] = L'\0';

        // Next!
        memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
            sizeof(**pargv)*(*pargc-(iArg+1)));
        --(*pargc);
        } else {
            iArg++;
        }
    }
    }

    if (NULL == gCreds.User){
        if (NULL != gCreds.Password){
        // Password supplied w/o user name.
        wprintf( L"Password must be accompanied by user name.\n" );
            ret = ERROR_INVALID_PARAMETER;
        } else {
        // No credentials supplied; use default credentials.
        ret = ERROR_SUCCESS;
        }
        gpCreds = NULL;
    } else {
        gCreds.PasswordLength = gCreds.Password ? wcslen(gCreds.Password) : 0;
        gCreds.UserLength   = wcslen(gCreds.User);
        gCreds.DomainLength = gCreds.Domain ? wcslen(gCreds.Domain) : 0;
        gCreds.Flags        = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        // CODE.IMP: The code to build a SEC_WINNT_AUTH structure also exists
        // in DsMakePasswordCredentials.  Someday use it

        // Use credentials in DsBind and LDAP binds
        gpCreds = &gCreds;
    }

    return ret;
}

BOOLEAN
ValidateNetbiosName(
    IN  PWSTR Name,
    IN  ULONG Length
    )

/*++

Routine Description:

    Determines whether a computer name is valid or not

Arguments:

    Name    - pointer to zero terminated wide-character computer name
    Length  - of Name in characters, excluding zero-terminator

Return Value:

    BOOLEAN
        TRUE    Name is valid computer name
        FALSE   Name is not valid computer name

--*/

{

    if (0==DnsValidateName_W(Name,DnsNameHostnameFull))
    {
        //
        // O.K if it is a DNS name
        //

        return(TRUE);
    }

    //
    // Fall down to netbios name validation
    //

    if (Length > MAX_COMPUTERNAME_LENGTH || Length < 1) {
        return FALSE;
    }

    //
    // Don't allow leading or trailing blanks in the computername.
    //

    if ( Name[0] == ' ' || Name[Length-1] == ' ' ) {
        return(FALSE);
    }

    return (BOOLEAN)((ULONG)wcscspn(Name, InvalidDownLevelChars) == Length);
}

int
MyStrToOleStrN(LPOLESTR pwsz, int cchWideChar, LPCSTR psz)
{
    int i;
    i=MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cchWideChar);
    if (!i)
    {
        //DBG_WARN("MyStrToOleStrN string too long; truncated");
        pwsz[cchWideChar-1]=0;
    }
    else
    {
        ZeroMemory(pwsz+i, sizeof(OLECHAR)*(cchWideChar-i));
    }
    return i;
}

WCHAR *
Convert2WChars(char * pszStr)
{
    WCHAR * pwszStr = (WCHAR *)LocalAlloc(LMEM_FIXED, ((sizeof(WCHAR))*(strlen(pszStr) + 2)));
    if (pwszStr)
    {
        HRESULT hr = MyStrToOleStrN(pwszStr, (strlen(pszStr) + 1), pszStr);
        if (FAILED(hr))
        {
            LocalFree(pwszStr);
            pwszStr = NULL;
        }
    }
    return pwszStr;
}

CHAR * 
Convert2Chars(LPCWSTR lpWideCharStr)
{
	int cWchar;
	if ( !lpWideCharStr ){
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

	cWchar= wcslen(lpWideCharStr)+1;
	LPSTR lpMultiByteStr = ( CHAR * ) LocalAlloc(LMEM_FIXED, cWchar * sizeof ( CHAR ) );
    if ( !lpMultiByteStr )
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

	int Chars = WideCharToMultiByte(  
                            CP_ACP,			    // code page
                            0,					// character-type options
                            lpWideCharStr,		// address of string to map
                            -1,					// number of bytes in string
                            lpMultiByteStr,	    // address of wide-character buffer
                            cWchar*sizeof(CHAR) ,// size of buffer
                            NULL,
                            NULL
                            );

    if (Chars == 0) {
        return NULL;
    }

     return lpMultiByteStr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rendom\util\clsfactory.cxx ===
#include <ntdspchx.h>
#pragma  hdrstop

#include "debug.h"
#define DEBSUB "CLSFACTORY:"


#include "ole2.h"

#include <tchar.h>



////////////////////////////
// helpers

HRESULT
FindDllPathFromCLSID( LPCTSTR pszCLSID, LPTSTR pBuf, DWORD cbBuf)
{
    HRESULT hr = S_OK;

    HKEY hCatalog   = NULL;
    HKEY hCLSID     = NULL;
    HKEY hInProc    = NULL;
    DWORD dwType;
    DWORD cbSize;

    if (ERROR_SUCCESS != ::RegOpenKeyEx( HKEY_CLASSES_ROOT, _T("CLSID"), 0, KEY_READ, &hCatalog))
    {
        DPRINT (0, "Unable to access registry\n");
        goto Fail;
    }

    if (ERROR_SUCCESS != ::RegOpenKeyEx( hCatalog, pszCLSID, 0, KEY_READ, &hCLSID))
    {
        DPRINT1 (0, "Unable to access registry key HKCR\\CLSID\\%s\n", pszCLSID);
        goto Fail;
    }

    if (ERROR_SUCCESS != ::RegOpenKeyEx( hCLSID, _T("InProcServer32"), 0, KEY_READ, &hInProc))
    {
        DPRINT1 (0, "Unable to access registry key HKCR\\CLSID\\%s\\InProcServer32 \n", pszCLSID);
        goto Fail;
    }

    cbSize = cbBuf;
    if (ERROR_SUCCESS != ::RegQueryValueEx( hInProc, NULL, NULL, &dwType, (LPBYTE)pBuf, &cbSize))
    {
        DPRINT1 (0, "Unable to read registry key HKCR\\CLSID\\%s\\InProcServer32 \n", pszCLSID);
        goto Fail;
    }

    switch (dwType)
    {
    case REG_EXPAND_SZ:
        {
            TCHAR rgchTemp[1024];
            memcpy( rgchTemp, pBuf, cbSize*sizeof(TCHAR));
            ExpandEnvironmentStrings( rgchTemp, pBuf, sizeof(rgchTemp)/sizeof(rgchTemp[0]));
        }
        break;

    case REG_SZ:
        break;

    default:
        DPRINT1 (0, "Unable to understand registry key HKCR\\CLSID\\%s\\InProcServer32 \n", pszCLSID);
        goto Fail;
    }

    goto Cleanup;

Fail:
    ::RegCloseKey( hCatalog);
    ::RegCloseKey( hCLSID);
    ::RegCloseKey( hInProc);

    hr = E_FAIL;

Cleanup:
    return hr;
}


HRESULT
FindDllPathFromPROGID( LPCTSTR pszPROGID, LPTSTR pBuf, DWORD cbBuf)
{
    HRESULT hr = S_OK;

    HKEY hPROGID   = NULL;
    HKEY hCLSID     = NULL;
    TCHAR rgchCLSID[128];
    DWORD dwType;
    DWORD cbSize;

    if (ERROR_SUCCESS != ::RegOpenKeyEx( HKEY_CLASSES_ROOT, pszPROGID, 0, KEY_READ, &hPROGID))
    {
        DPRINT1 (0, "Unable to access registry key HKCR\\%s \n", pszPROGID);
        goto Fail;
    }

    if (ERROR_SUCCESS != ::RegOpenKeyEx( hPROGID, _T("CLSID"), 0, KEY_READ, &hCLSID))
    {
        DPRINT1 (0, "Unable to access registry key HKCR\\%s\\CLSID\n", pszPROGID);
        goto Fail;
    }

    cbSize = sizeof(rgchCLSID)/sizeof(rgchCLSID[0]);
    if (ERROR_SUCCESS != ::RegQueryValueEx( hCLSID, NULL, NULL, &dwType, (LPBYTE)rgchCLSID, &cbSize))
    {
        DPRINT1 (0, "Unable to read registry key HKCR\\%s\\CLSID \n", pszPROGID);
        goto Fail;
    }

    if (dwType != REG_SZ)
    {
        DPRINT1 (0, "Unable to understand registry key HKCR\\%s\\CLSID\n", pszPROGID);
        goto Fail;
    }

    hr = FindDllPathFromCLSID( rgchCLSID, pBuf, cbBuf);

    goto Cleanup;

Fail:
    ::RegCloseKey( hCLSID);
    ::RegCloseKey( hPROGID);

    hr = E_FAIL;

Cleanup:
    return hr;
}


class CClassFactoryWrapper : public IClassFactory
{
private:
    ULONG _ulRefs;
    HINSTANCE _hLibrary;
    IClassFactory * _pWrapped;

public:
    CClassFactoryWrapper( HINSTANCE hLibrary, IClassFactory * pWrap)
        : _ulRefs( 1), _hLibrary( hLibrary), _pWrapped( pWrap)
    {
    }

    ~CClassFactoryWrapper()
    {
        if (_pWrapped)
            _pWrapped->Release();
        ::FreeLibrary( _hLibrary);
    }

public:
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void ** ppv)
    {
        if (iid == IID_IUnknown || iid == IID_IClassFactory) 
        {
            *ppv = this;
            AddRef();
            return S_OK;    
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (ULONG)InterlockedIncrement((LPLONG)&_ulRefs);
    }

    ULONG STDMETHODCALLTYPE Release()
    {
        ULONG ul = (ULONG)InterlockedDecrement((LPLONG)&_ulRefs);
        if (0 == ul)
            delete this;
        return ul;
    }

    // IClassFactory methods
    HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock)
    {
        if (_pWrapped)
            return _pWrapped->LockServer( fLock);
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE CreateInstance(
            IUnknown *pUnkOuter,
            REFIID iid,
            void **ppvObj)
    {
        if (_pWrapped)
            return _pWrapped->CreateInstance( pUnkOuter, iid, ppvObj);
        return E_FAIL;
    }
};

typedef HRESULT (__stdcall *FN_DLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID FAR*);

HRESULT GetClassFactory( REFCLSID clsid, IClassFactory ** ppFactory)
{
    HRESULT hr;
    TCHAR rgchDllPath[1024];
#ifdef UNICODE
    WCHAR rgszCLSID[128];
#else
    WCHAR rgwszCLSID[128];
    TCHAR rgszCLSID[128];
#endif

    HINSTANCE hLibrary = NULL;
    FN_DLLGETCLASSOBJECT fnDllGetClassObject = NULL;
    IClassFactory * pFactory = NULL;


#ifdef UNICODE
    StringFromGUID2( clsid, rgszCLSID, sizeof(rgszCLSID)/sizeof(rgszCLSID[0]));
#else
    StringFromGUID2( clsid, rgwszCLSID, sizeof(rgwszCLSID)/sizeof(rgwszCLSID[0]));
    ::WideCharToMultiByte( CP_ACP, NULL, rgwszCLSID, -1, rgszCLSID, sizeof(rgszCLSID)/sizeof(rgszCLSID[0]), NULL, NULL);
#endif

    if (FAILED(hr = FindDllPathFromCLSID( rgszCLSID, rgchDllPath, sizeof(rgchDllPath)/sizeof(rgchDllPath[0]))))
    {
        goto Failed;
    }

    hLibrary = ::LoadLibrary( rgchDllPath);
    if ( !hLibrary)
    {
        DPRINT1 (0, "failed to load dll: %s\n", rgchDllPath);
        hr = E_FAIL;
        goto Failed;
    }

    fnDllGetClassObject = (FN_DLLGETCLASSOBJECT)::GetProcAddress( hLibrary, "DllGetClassObject");
    if ( !fnDllGetClassObject)
    {
        DPRINT1 (0, "Unable to find \"DllGetClassObject\" export in dll: %s\n", rgchDllPath);
        hr = E_FAIL;
        goto Failed;
    }

    if (FAILED(hr = (*fnDllGetClassObject)( clsid, IID_IClassFactory, (void**)&pFactory)))
    {
        goto Failed;
    }

    *ppFactory = new CClassFactoryWrapper( hLibrary, pFactory);
    hr = S_OK;

    goto Cleanup;

Failed:
    if (hLibrary)
    {
        if (pFactory)
        {
            pFactory->Release();
            pFactory = NULL;
        }

        ::FreeLibrary( hLibrary);
        hLibrary = NULL;
    }

Cleanup:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rendom\util\ldap.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include "rendom.h"
#include <wchar.h>
#include <sddl.h>
#include <lmcons.h>
#include <lmerr.h>
#include <Dsgetdc.h>
#include <Lmapibuf.h>
#include <ntldap.h>
extern "C"
{
#include <mappings.h>
}
#include <ntlsa.h>
#include <ntdsadef.h>

#include "renutil.h"

BOOL CEnterprise::LdapGetGuid(WCHAR *LdapValue,
                              WCHAR **Guid)
{
    BOOL  ret = TRUE;
    WCHAR *p = NULL;
    WCHAR *Uuid = NULL;
    DWORD size = 0;
    DWORD i = 0;
    PBYTE buf = NULL;
    RPC_STATUS err = RPC_S_OK;

    *Guid = NULL;

    p = wcsstr(LdapValue, L"<GUID=");
    if (!p) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"The String passed into LdapGetGuid is in an invalid format");
        ret = FALSE;
        goto Cleanup;
    }
    p+=wcslen(L"<GUID=");
    while ( ((L'>' != *(p+size)) && (L'\0' != *(p+size))) && (size < RENDOM_BUFFERSIZE) ) 
    {
        size++;
    }
    
    buf = new BYTE[size];
    if (!buf) {
        m_Error->SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    // convert the string into byte form so that we
    // can pass a binary to UuidToStringW() so that we
    // can have a properly formated GUID string.
    for (i = 0; i<size; i++) {
        WCHAR *a = NULL;
        WCHAR bytestr[3];
        bytestr[0] = *p;
        bytestr[1] = *(p+1);
        bytestr[2] = L'\0';
        
        buf[i] = (BYTE)wcstol( bytestr, &a, 16 );

        p+=2;
    }

    err = UuidToStringW(((UUID*)buf),&Uuid);
    if (RPC_S_OK != err) {
        m_Error->SetErr(err,
                        L"Failed to convert Guid to string");
        ret = FALSE;
        goto Cleanup;
    }

    // the +5 is for 4 L'-' and one L'\0'
    *Guid = new WCHAR[size+5];
    if (!Guid) {
        m_Error->SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    // We don't want to return a Buffer that was allocated
    // by anything other than new.  It becomes too difficult
    // to track what the proper free for it is.
    CopyMemory(*Guid,Uuid,(size+5)*sizeof(WCHAR));

    Cleanup:

    if (buf) {
        delete buf;
    }

    err = RpcStringFreeW(&Uuid);
    if (RPC_S_OK != err) {
        m_Error->SetErr(err,
                        L"Failed to Free Guid String");
        ret = FALSE;
    }
    if (FALSE == ret) {
        if (*Guid) {
            delete *Guid;
        }
    }
    
    return ret;
}

BOOL CEnterprise::LdapGetSid(WCHAR *LdapValue,
                             WCHAR **rSid)
{

    WCHAR *p = NULL;
    BOOL  ret = TRUE;
    DWORD size = 0;
    WCHAR *Sid = NULL;
    DWORD i = 0;
    PBYTE buf = NULL;
    DWORD err = ERROR_SUCCESS;

    p = wcsstr(LdapValue, L"<SID=");
    if (!p) {
        return TRUE;
    }

    *rSid = NULL;

    p+=wcslen(L"<SID=");
    while ( ((L'>' != *(p+size)) && (L'\0' != *(p+size))) && (size < RENDOM_BUFFERSIZE) ) 
    {
        size++;
    }
    size/=2;
    
    buf = new BYTE[size+1];
    if (!buf) {
        m_Error->SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    for (i = 0; i<size; i++) {
        WCHAR *a = NULL;
        WCHAR bytestr[3];
        bytestr[0] = *p;
        bytestr[1] = *(p+1);
        bytestr[2] = L'\0';
        
        buf[i] = (BYTE)wcstol( bytestr, &a, 16 );

        p+=2;
    }
        
    
    if (! ConvertSidToStringSidW((PSID)buf,
                                 &Sid))
    {
        m_Error->SetErr(GetLastError(),
                        L"Failed to convert Sid to Sid String");
        ret = FALSE;
        goto Cleanup;
    }

    //Commented code below show the way ldp converts SIDs
    //into string.  This function will use the advapi32
    //api ConvertSidToStringSidW().
    /*
    {
        char subAuth[1000];
        int authCount = *GetSidSubAuthorityCount((PSID)buf);

        Sid = new char[1000];
    
        strcpy(Sid,"S-");
    
        for (i=0; i<authCount; i++)
        {
            DWORD dwAuth = *GetSidSubAuthority((PSID)buf,
                                               i);

            sprintf(subAuth,"%X", dwAuth);
            if (i < authCount-1)
            {
                strcat(subAuth,"-");
            }
            strcat(Sid,subAuth);
        }                     
    } */

    *rSid = new WCHAR[wcslen(Sid)+1];
    if (!*rSid) {
        m_Error->SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }


    //ret = StringToWideString(Sid);
               
    wcscpy(*rSid,Sid);

    Cleanup:

    if (buf) 
    {
        delete buf;
    }
    
    if (LocalFree(Sid))
    {
        m_Error->SetErr(GetLastError(),
                        L"Failed to Free resource");
        ret = FALSE;
        return NULL;
    }

    if (FALSE == ret) {
        if (*rSid) {
            delete rSid;
        }
    }

    return ret;
}

BOOL CEnterprise::LdapGetDN(WCHAR *LdapValue,
                            WCHAR **DN)
{

    WCHAR *p = NULL;
    DWORD size = 0;

    p = wcschr(LdapValue, L';');
    if (!p) {
        return NULL;
    } else if ( L'<' == *(p+1) ) {
        p = wcschr(p+1, L';');
        if (!p) {                                             
            return NULL;
        } 
    }

    // move to the char passed the L';'
    p++;
    while ( ((L';' != *(p+size)) && (L'\0' != *(p+size))) && (size < RENDOM_BUFFERSIZE) ) 
    {
        size++;
    }
    *DN = new WCHAR[size+1];
    if (!*DN) {
        m_Error->SetMemErr();
        return FALSE;
    }
    wcsncpy(*DN,p,size+1);

    return TRUE;
}

BOOL CEnterprise::LdapConnectandBind(CDomain *domain) // = NULL
{
    DWORD Win32Err = ERROR_SUCCESS;
    NET_API_STATUS NetapiStatus = NERR_Success;
    ULONG ldapErr = LDAP_SUCCESS;
    PDOMAIN_CONTROLLER_INFOW DomainControllerInfo = NULL;
    WCHAR *DcName = NULL;
    WCHAR *DomainNetBios = NULL;

    if (m_hldap) {
        ldapErr = ldap_unbind(m_hldap);
        m_hldap = NULL;
        if ( LDAP_SUCCESS != ldapErr) {
            m_Error->SetErr(LdapMapErrorToWin32(ldapErr),
                            L"Failed to close the old Ldap session");
            return FALSE;
        }
    }

    if (domain) {
        DcName = domain->GetDcToUse();
        if ((!DcName) && (!m_Error->isError())) 
        {
            DomainNetBios = domain->GetNetBiosName();
            if (!DomainNetBios && !domain->isDomain()) {
                BOOL ret;
                WCHAR *DNSroot = domain->GetDnsRoot();
                if (DNSroot) {
                    ret = LdapConnectandBindToServer(DNSroot);
                    delete DNSroot;
                    DNSroot = NULL;
                }
                return ret;
            } else if (!DomainNetBios) {
                m_Error->SetMemErr();
                return FALSE;
            }
        } else if (m_Error->isError()) {
            return FALSE;
        } else {
            BOOL ret;
            ret = LdapConnectandBindToServer(DcName);
            delete DcName;
            return ret;
        } 
    }

    if (m_Opts->GetInitalConnectionName() && !domain) {
        BOOL ret;
        ret = LdapConnectandBindToServer(m_Opts->GetInitalConnectionName());
        return ret;
    }
    
    Win32Err =  DsGetDcNameW(NULL,
                             DomainNetBios,
                             NULL,
                             NULL,
                             0,
                             &DomainControllerInfo
                             );
    if (ERROR_SUCCESS != Win32Err) {
        if (!domain) {
            m_Error->SetErr(Win32Err,
                        L"Couldn't Find a DC for the current Domain");
        } else {
            m_Error->SetErr(Win32Err,
                            L"Couldn't Find a DC for the Domain %s",
                            DomainNetBios);
        }

        
        if (DomainNetBios) {
            delete DomainNetBios;
        }
        return false;
    }
    
    m_hldap = ldap_openW((DomainControllerInfo->DomainControllerName)+2,
                         LDAP_PORT
                         );

    if (NULL == m_hldap) {
        NetapiStatus = NetApiBufferFree(DomainControllerInfo);
        if (NERR_Success != NetapiStatus) {
            m_Error->SetErr(NetapiStatus,
                            L"This is a failed Free in ReadDomain Information");
            if (DomainNetBios) {
                delete DomainNetBios;
            }
            return false;
        }
    }

    while (NULL == m_hldap) {

        Win32Err =  DsGetDcNameW(NULL,
                                 DomainNetBios,
                                 NULL,
                                 NULL,
                                 DS_FORCE_REDISCOVERY,
                                 &DomainControllerInfo
                                 );
        if (ERROR_SUCCESS != Win32Err) {
            if (!domain) {
            m_Error->SetErr(Win32Err,
                            L"Couldn't Find a DC for the current Domain");
            } else {
                m_Error->SetErr(Win32Err,
                                L"Couldn't Find a DC for the Domain %s",
                                DomainNetBios);
            }
            return false;
        }
        
    
        m_hldap = ldap_openW((DomainControllerInfo->DomainControllerName)+2,
                             LDAP_PORT
                             );
    
        if (NULL == m_hldap) {
            NetapiStatus = NetApiBufferFree(DomainControllerInfo);
            if (NERR_Success != NetapiStatus) {
                m_Error->SetErr(NetapiStatus,
                                L"This is a failed Free in ReadDomain Information");
                if (DomainNetBios) {
                    delete DomainNetBios;
                }
                return false;
            }
        }

    }
    if (DomainNetBios) {
        delete DomainNetBios;
        DomainNetBios = NULL;
    }

    ldapErr = ldap_bind_s(m_hldap,
                          NULL,
                          (PWCHAR)m_Opts->pCreds,
                          LDAP_AUTH_SSPI
                          );

    if ( LDAP_SUCCESS != ldapErr) {
        m_Error->SetErr(LdapMapErrorToWin32(ldapErr),
                        L"Failed to Bind to Ldap session on %s\n",
                        (DomainControllerInfo->DomainControllerName)+2 );
        NetapiStatus = NetApiBufferFree(DomainControllerInfo);
        if (NERR_Success != NetapiStatus) {
            m_Error->SetErr(NetapiStatus,
                            L"This is a failed Free in ReadDomain Information");
            return false;
        }
        return false;
    }

    NetapiStatus = NetApiBufferFree(DomainControllerInfo);
    if (NERR_Success != NetapiStatus) {
        m_Error->SetErr(NetapiStatus,
                        L"This is a failed Free in ReadDomain Information");
        return false;
    }

    return true;
}

BOOL CEnterprise::GetReplicationEpoch()
{
    if (!m_hldap) 
    {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Call to GetInfoFromRootDSE without having a valid handle to an ldap server");
        return false;
    }

    DWORD WinError = ERROR_SUCCESS;

    ULONG         LdapError = LDAP_SUCCESS;

    LDAPMessage   *SearchResult = NULL;
    ULONG         NumberOfEntries;

    WCHAR         *Attr = NULL;
    BerElement    *pBerElement = NULL;

    WCHAR         *AttrsToSearch[4];

    WCHAR         *BaseTemplate = L"CN=NTDS Settings,%s";

    WCHAR         *Base = NULL;
    
    WCHAR         *DefaultFilter = L"objectClass=*";

    ULONG         Length;
    WCHAR         **Values = NULL;

    AttrsToSearch[0] = L"serverName";
    AttrsToSearch[1] = NULL;

    // Get the ReplicationEpoch from the NC head.
    LdapError = ldap_search_sW( m_hldap,
                                NULL,
                                LDAP_SCOPE_BASE,
                                L"ObjectClass=*",
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {
        
        m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                        L"Search to find Trusted Domain Objects Failed");
        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries(m_hldap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(m_hldap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement) )
            {                                 
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {
    
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Base = new WCHAR[wcslen(Values[0])+
                                         wcslen(BaseTemplate)+1];
                        if (!Base) {
                            m_Error->SetMemErr();
                            goto Cleanup;
                        }

                        wsprintf(Base,
                                 BaseTemplate,
                                 Values[0]);
                        
                        LdapError = ldap_value_freeW(Values);
                        Values = NULL;
                        if (LDAP_SUCCESS != LdapError) 
                        {
                            m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                                            L"Failed to Free values from a ldap search");
                            goto Cleanup;
                        }
                    }

                }
                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
            }
            
            
        }
        
    }
    if (Values) {
        ldap_value_freeW(Values);
        Values = NULL;    
    }

    ldap_msgfree(SearchResult);
    SearchResult = NULL;

    AttrsToSearch[0] = L"msDS-ReplicationEpoch";
    AttrsToSearch[1] = NULL;

    // Get the ReplicationEpoch from the NC head.
    LdapError = ldap_search_sW( m_hldap,
                                Base,
                                LDAP_SCOPE_BASE,
                                L"ObjectClass=*",
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {
        
        m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                        L"Search to find Trusted Domain Objects Failed");
        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries(m_hldap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(m_hldap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement) )
            {                                 
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {
    
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        DWORD temp = 0;
                        temp = _wtoi(Values[0]);
                        if (temp > m_maxReplicationEpoch) {
                            m_maxReplicationEpoch = temp;
                        }
                        
                        LdapError = ldap_value_freeW(Values);
                        Values = NULL;
                        if (LDAP_SUCCESS != LdapError) 
                        {
                            m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                                            L"Failed to Free values from a ldap search");
                            goto Cleanup;
                        }
                    }

                }
                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
            }
            
            
        }
        
    }

    Cleanup:

    if (Values) 
    {
        ldap_value_freeW(Values);
        Values = NULL;
    }
    if (SearchResult) 
    {
        ldap_msgfree(SearchResult);    
        SearchResult = NULL;
    }
    if (Base) {
        delete Base;
    }

    if (m_Error->isError()) {
        return FALSE;
    }
    return TRUE;

}

BOOL CEnterprise::GetInfoFromRootDSE()
{
    if (!m_hldap) 
    {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Call to GetInfoFromRootDSE without having a valid handle to an ldap server");
        return false;
    }

    DWORD WinError = ERROR_SUCCESS;

    ULONG         LdapError = LDAP_SUCCESS;

    LDAPMessage   *SearchResult = NULL;
    PLDAPControlW ServerControls[2];
    LDAPControlW  ExtDNcontrol;
    ULONG         NumberOfEntries;

    WCHAR         *Attr = NULL;
    BerElement    *pBerElement = NULL;

    WCHAR         *AttrsToSearch[4];

    WCHAR         *DefaultFilter = L"objectClass=*";

    ULONG         Length;
    WCHAR         **Values;

    WCHAR         *Guid = NULL;
    WCHAR         *DN = NULL;
    WCHAR         *Sid = NULL;

    
    AttrsToSearch[0] = L"configurationNamingContext";
    AttrsToSearch[1] = L"rootDomainNamingContext";
    AttrsToSearch[2] = L"schemaNamingContext";
    AttrsToSearch[3] = NULL;

    // Set up the extended DN control.
    ExtDNcontrol.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    ExtDNcontrol.ldctl_iscritical = TRUE;
    ExtDNcontrol.ldctl_value.bv_len = 0;
    ExtDNcontrol.ldctl_value.bv_val = NULL;
    ServerControls[0] = &ExtDNcontrol;
    ServerControls[1] = NULL;


    LdapError = ldap_search_ext_sW( m_hldap,
                                    NULL,
                                    LDAP_SCOPE_BASE,
                                    DefaultFilter,
                                    AttrsToSearch,
                                    FALSE,
                                    (PLDAPControlW *)&ServerControls,
                                    NULL,
                                    NULL,
                                    0,
                                    &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {
        
        m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                        L"Search to find Configuration container failed");
        goto Cleanup;
    }
    
    NumberOfEntries = ldap_count_entries(m_hldap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(m_hldap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {
    
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        if (!LdapGetGuid(Values[0],
                                         &Guid)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetDN(Values[0],
                                       &DN)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetSid(Values[0],
                                        &Sid)) 
                        {
                            goto Cleanup;
                        }
                        
                        m_ConfigNC = new CDsName(Guid,
                                                 DN,
                                                 Sid);
                        if (!m_ConfigNC) {
                            m_Error->SetMemErr();
                            goto Cleanup;
                        }

                        Guid = DN = Sid = NULL;
                    }
                }

                if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                {
    
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        if (!LdapGetGuid(Values[0],
                                         &Guid)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetDN(Values[0],
                                       &DN)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetSid(Values[0],
                                        &Sid)) 
                        {
                            goto Cleanup;
                        }
                        
                        m_ForestRootNC = new CDsName(Guid,
                                                     DN,
                                                     Sid);
                        if (!m_ForestRootNC) {
                            m_Error->SetMemErr();
                            goto Cleanup;
                        }

                        Guid = DN = Sid = NULL;   
                    }
                }
                if ( !_wcsicmp( Attr, AttrsToSearch[2] ) )
                {
    
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        if (!LdapGetGuid(Values[0],
                                         &Guid)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetDN(Values[0],
                                       &DN)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetSid(Values[0],
                                        &Sid)) 
                        {
                            goto Cleanup;
                        }
                        
                        m_SchemaNC = new CDsName(Guid,
                                                 DN,
                                                 Sid);
                        if (!m_SchemaNC) {
                            m_Error->SetMemErr();
                            goto Cleanup;
                        }

                        Guid = DN = Sid = NULL;   
                    }
                }

                LdapError =  ldap_value_freeW(Values);
                Values = NULL;
                if (LDAP_SUCCESS != LdapError) 
                {
                    m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                                    L"Failed to Free Values\n");
                    goto Cleanup;
                }

                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
            }
        }
    }

    Cleanup:


    if (Attr) {
        ldap_memfree(Attr);
    }
    if (Values) {
        ldap_value_freeW(Values);
    }
    if (Guid) 
    {
        delete Guid;
    }
    if (Sid) 
    {
        delete Sid;
    }
    if (DN) 
    {
        delete DN;
    }
    if (SearchResult) {
        ldap_msgfree( SearchResult );
        SearchResult = NULL;
    }
    if ( m_Error->isError() ) 
    {
        return false;
    }
    return true;




}

BOOL CEnterprise::GetTrustsInfo()
{
    CDomain *d = m_DomainList;

    DWORD WinError = ERROR_SUCCESS;

    ULONG         LdapError = LDAP_SUCCESS;
    
    LDAPMessage   *SearchResult = NULL;
    PLDAPControlW ServerControls[2];
    LDAPControlW  ExtDNcontrol;
    ULONG         NumberOfEntries;
    WCHAR         *Attr = NULL;
    
    WCHAR         *AttrsToSearch[5];
    WCHAR         SamTrustAccount[32];
    
    WCHAR         *DefaultFilter = L"objectCategory=trustedDomain";
    WCHAR         *Filter = NULL;
    
    WCHAR         *PartitionsRdn = L"CN=System,";
    
    ULONG         Length;
    BerElement    *pBerElement = NULL;
    
    WCHAR         *SystemDn = NULL;
    WCHAR         *DomainDN = NULL;
    WCHAR         **Values = NULL;
    struct berval **ppSid = NULL;
    
    WCHAR         *Guid = NULL;
    WCHAR         *DN = NULL;
    WCHAR         *Sid = NULL;

    WCHAR         *pzSecurityID = NULL;
    CDsName       *Trust = NULL;
    CDsName       *DomainDns = NULL;
    BOOL          RecordTrust = FALSE;
    DWORD         TrustType = 0;
    WCHAR         *DomainDn = NULL;
    WCHAR         *TrustpartnerNetbiosName = NULL;
    CDomain       *Trustpartner = NULL;
    CTrustedDomain *NewTrust = NULL;
    CInterDomainTrust *NewInterTrust = NULL;

    wsprintf(SamTrustAccount,L"%d",SAM_TRUST_ACCOUNT);

    Length = wcslen(L"samAccountType=") + 
             wcslen(SamTrustAccount) + 1;

    Filter = new WCHAR[Length];
    if (!Filter) {
        m_Error->SetMemErr();
        goto Cleanup;
    }

    wcscpy(Filter,L"samAccountType=");
    wcscat(Filter,SamTrustAccount);

    // Set up the extended DN control.
    ExtDNcontrol.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    ExtDNcontrol.ldctl_iscritical = TRUE;
    ExtDNcontrol.ldctl_value.bv_len = 0;
    ExtDNcontrol.ldctl_value.bv_val = NULL;
    ServerControls[0] = &ExtDNcontrol;
    ServerControls[1] = NULL;

    while (d) 
    {
        //Connect to the current domain.
        if (!LdapConnectandBind(d))
        {
            //BUGBUG:  I believe this should Fail!
            if ((m_Error->GetErr() == ERROR_NO_SUCH_DOMAIN) ||
                (m_Error->GetErr() ==ERROR_BAD_NET_RESP)) {
                m_Error->SetErr(0,
                                L"No Error");
                d = d->GetNextDomain();
                continue;
            }
            return FALSE;
        }

        if (!d->isDomain()) 
        {
            //since this is not a Domain
            //There will be no trust objects
            //Just continue on to the next domain
            d = d->GetNextDomain();
            continue;
        }

        DomainDn = d->GetDomainDnsObject()->GetDN();
        if (m_Error->isError()) 
        {
            goto Cleanup;
        }

        //Get Info Dealing with Domain Trust Objects
        AttrsToSearch[0] = L"securityIdentifier";
        AttrsToSearch[1] = L"distinguishedName";
        AttrsToSearch[2] = L"trustType";
        AttrsToSearch[3] = L"trustPartner";
        AttrsToSearch[4] = NULL;
        
        Length =  (wcslen( DomainDn )
                + wcslen( PartitionsRdn )   
                + 1);
        
        SystemDn = new WCHAR[Length];

        wcscpy( SystemDn, PartitionsRdn );
        wcscat( SystemDn, DomainDn );    
        LdapError = ldap_search_ext_sW( m_hldap,
                                        SystemDn,
                                        LDAP_SCOPE_ONELEVEL,
                                        DefaultFilter,
                                        AttrsToSearch,
                                        FALSE,
                                        (PLDAPControlW *)&ServerControls,
                                        NULL,
                                        NULL,
                                        0,
                                        &SearchResult);
        
        if ( LDAP_SUCCESS != LdapError )
        {
            
            m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                            L"Search to find Trusted Domain Objects Failed");
            goto Cleanup;
        }
        
        NumberOfEntries = ldap_count_entries( m_hldap, SearchResult );
        if ( NumberOfEntries > 0 )
        {
            LDAPMessage *Entry;
            
            for ( Entry = ldap_first_entry(m_hldap, SearchResult);
                      Entry != NULL;
                          Entry = ldap_next_entry(m_hldap, Entry))
            {
                TrustType = 0;

                for( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                      Attr != NULL;
                          Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement))
                {
                    if ( !_wcsicmp( Attr, AttrsToSearch[2] ) )
                    {
        
                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //
                            TrustType = _wtoi(Values[0]);
                        
                        }
        
                    }
                    if ( !_wcsicmp( Attr, AttrsToSearch[3] ) )
                    {
        
                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //
                            TrustpartnerNetbiosName = new WCHAR[wcslen(Values[0])+1];
                            if (!TrustpartnerNetbiosName) 
                            {
                                m_Error->SetMemErr();
                                goto Cleanup;
                            }
                            wcscpy(TrustpartnerNetbiosName,Values[0]);
                        
                        }
        
                    }

                    if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                    {
        
                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //
                            if (!LdapGetGuid(Values[0],
                                             &Guid)) 
                            {
                                goto Cleanup;
                            }
                            if (!LdapGetDN(Values[0],
                                           &DN)) 
                            {
                                goto Cleanup;
                            }
                            if (!LdapGetSid(Values[0],
                                            &Sid)) 
                            {
                                goto Cleanup;
                            }
        
                            
                            Trust = new CDsName(Guid,
                                                DN,
                                                Sid);
                            if (!Trust) {
                                m_Error->SetMemErr();
                                goto Cleanup;
                            }
        
                            Guid = DN = Sid = NULL; 
        
                        }
        
                    }
                    if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                    {
        
                        ppSid = ldap_get_values_lenW( m_hldap, Entry, Attr );
                        if ( ppSid && ppSid[0] )
                        {
                            //
                            // Found it
                            //
                            
                            if (! ConvertSidToStringSidW((*ppSid)->bv_val,
                                                         &pzSecurityID))
                            {
                                m_Error->SetErr(GetLastError(),
                                                L"Failed to convert Sid to Sid String");
                                LocalFree(pzSecurityID);
                                goto Cleanup;
                            }
                            Trustpartner = m_DomainList->LookupbySid(pzSecurityID);
                            LocalFree(pzSecurityID);
                            
                            if (Trustpartner)
                            {

                                RecordTrust = TRUE;

                            } else {

                                Trustpartner = NULL;

                            } 
                            
                        }
        
                    }
                    
                    if (ppSid) {
                        LdapError = ldap_value_free_len(ppSid);
                        ppSid = NULL;
                        if (LDAP_SUCCESS != LdapError) 
                        {
                            m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                                            L"Failed to Free values from a ldap search");
                            goto Cleanup;
                        }
                    }

                    if (Values) {
                        LdapError = ldap_value_freeW(Values);
                        Values = NULL;
                        if (LDAP_SUCCESS != LdapError) 
                        {
                            m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                                            L"Failed to Free values from a ldap search");
                            goto Cleanup;
                        }
                    }
                    if (Attr) {
                        ldap_memfree(Attr);
                        Attr = NULL;
                    }
                }

                if ( TRUST_TYPE_DOWNLEVEL == TrustType ) {

                    Trustpartner = m_DomainList->LookupByPrevNetbiosName(TrustpartnerNetbiosName);
                    if (Trustpartner)
                    {

                        RecordTrust = TRUE;

                    } else {

                        Trustpartner = NULL;

                    }

                }

                if (RecordTrust) 
                {
        
                    NewTrust = new CTrustedDomain(Trust,
                                                  Trustpartner,
                                                  TrustType);
                    Trust = NULL;
                    Trustpartner = NULL;
                    if (!NewTrust) 
                    {
                        m_Error->SetMemErr();
                        goto Cleanup;
                    }
        
                    if (!d->AddDomainTrust(NewTrust))
                    {
                        Trust = NULL;
                        Trustpartner = NULL;
                        goto Cleanup;
                    }
                    NewTrust = NULL;
                    RecordTrust = FALSE;
        
                } else {
        
                    if (Trust) 
                    {
                        delete Trust;
                        Trust = NULL;
                    }
                    if (Trustpartner) 
                    {
                        Trustpartner = NULL;
                    }
        
                }

                if (TrustpartnerNetbiosName) 
                {
                    delete TrustpartnerNetbiosName;
                    TrustpartnerNetbiosName = NULL;
                }
            
            }

        }

        if (Values) {
            ldap_value_freeW(Values);
            Values = NULL;
        }


        ldap_msgfree(SearchResult);
        SearchResult = NULL;

        //Get information Dealing with InterDomain Trust Objects

        AttrsToSearch[0] = L"samAccountName";
        AttrsToSearch[1] = L"distinguishedName";
        AttrsToSearch[2] = NULL;

        LdapError = ldap_search_ext_sW( m_hldap,
                                        DomainDn,
                                        LDAP_SCOPE_SUBTREE,
                                        Filter,
                                        AttrsToSearch,
                                        FALSE,
                                        (PLDAPControlW *)&ServerControls,
                                        NULL,
                                        NULL,
                                        0,
                                        &SearchResult);
        
        if ( LDAP_SUCCESS != LdapError )
        {
            
            m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                            L"Search to find InterDomain Trusts Failed");
            goto Cleanup;
        }

        BOOL MyTrust = FALSE;
        NumberOfEntries = ldap_count_entries( m_hldap, SearchResult );
        if ( NumberOfEntries > 0 )
        {
            LDAPMessage *Entry;
            
            for ( Entry = ldap_first_entry(m_hldap, SearchResult);
                      Entry != NULL;
                          Entry = ldap_next_entry(m_hldap, Entry))
            {
                for( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                      Attr != NULL;
                          Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement))
                {
                    if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                    {
        
                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //
                            WCHAR *p = NULL;
                            if (!LdapGetGuid(Values[0],
                                             &Guid)) 
                            {
                                goto Cleanup;
                            }
                            if (!LdapGetDN(Values[0],
                                           &DN)) 
                            {
                                goto Cleanup;
                            }
                            DomainDN = d->GetDomainDnsObject()->GetDN();
                            if (m_Error->isError()) 
                            {
                                goto Cleanup;
                            }
                            // need to make sure that this trust
                            // does belong to this domain and not
                            // a child.
                            p = wcsstr(DN,L"DC=");
                            if (0 == _wcsicmp(p,DomainDN))
                            {
                                MyTrust = TRUE;            
                            }
                            if (DomainDN) {
                                delete DomainDN;
                                DomainDN = NULL;
                            }
                            if (!LdapGetSid(Values[0],
                                            &Sid)) 
                            {
                                goto Cleanup;
                            }
        
                            
                            Trust = new CDsName(Guid,
                                                DN,
                                                Sid);
                            
                            if (!Trust) {
                                m_Error->SetMemErr();
                                goto Cleanup;
                            }
        
                            Guid = DN = Sid = NULL; 
        
                        }
        
                    }
                    if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                    {
                        //
                        // Found it - these are NULL-terminated strings
                        //

                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //
                            //one for L'$' and one for L'\0'
                            WCHAR MachineName[MAX_COMPUTERNAME_LENGTH+2];
                            wcscpy(MachineName,Values[0]);
                            //remove the trailing $
                            MachineName[wcslen(MachineName)-1] = L'\0';
                            Trustpartner = m_DomainList->LookupByNetbiosName(MachineName);
                            if (Trustpartner)
                            {
    
                                RecordTrust = TRUE;
    
                            } 
        
                        }
                    }
                    
                    LdapError = ldap_value_freeW(Values);
                    Values = NULL;
                    if (LDAP_SUCCESS != LdapError) 
                    {
                        m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                                        L"Failed to Free values from a ldap search");
                        goto Cleanup;
                    }

                    if (Attr) {
                        ldap_memfree(Attr);
                        Attr = NULL;
                    }
                }

                if (RecordTrust && MyTrust) 
                {
        
                    NewInterTrust = new CInterDomainTrust(Trust,
                                                          Trustpartner);
                    Trust = NULL;
                    Trustpartner = NULL;
                    if (!NewInterTrust) 
                    {
                        m_Error->SetMemErr();
                        goto Cleanup;
                    }
        
                    if (!d->AddInterDomainTrust(NewInterTrust))
                    {
                        Trust = NULL;
                        Trustpartner = NULL;
                        goto Cleanup;
                    }
                    RecordTrust = FALSE;
                    MyTrust = FALSE;
        
                } else {
        
                    if (Trust) 
                    {
                        delete Trust;
                        Trust = NULL;
                    }
                    if (Trustpartner) 
                    {
                        Trustpartner = NULL;
                    }
                    RecordTrust = FALSE;
                    MyTrust = FALSE;
                
                }
        
            }

        }
        
        if (ppSid) 
        {
            ldap_value_free_len(ppSid);
            ppSid = NULL;
        }
        if (SystemDn) 
        {
            delete SystemDn;
            SystemDn = NULL;
        }
        if (TrustpartnerNetbiosName) 
        {
            delete TrustpartnerNetbiosName;
            TrustpartnerNetbiosName = NULL;
        }
        if (Values) 
        {
            ldap_value_freeW(Values);
            Values = NULL;
        }
        if (Guid) 
        {
            delete Guid;
            Guid = NULL;
        }
        if (SearchResult) 
        {
            ldap_msgfree(SearchResult);    
            SearchResult = NULL;
        }
        if (DN)
        {
            delete DN;
            DN = NULL; 
        }
        if (Sid)
        {
            delete Sid;
            Sid = NULL;
        }
        if (DomainDn)
        {
            delete DomainDn;
            DomainDn = NULL;
        }
        // Move on to the next Domain
        d = d->GetNextDomain();
    }

    Cleanup:

    if (Attr) {
        ldap_memfree(Attr);
    }
    if (DomainDN) {
        delete DomainDN;
    }
    if (ppSid) 
    {
        ldap_value_free_len(ppSid);
    }
    if (TrustpartnerNetbiosName) 
    {
        delete TrustpartnerNetbiosName;
    }
    if (SystemDn) 
    {
        delete SystemDn;
    }
    if (Filter) 
    {
        delete Filter;
    }
    if (Values) 
    {
        ldap_value_freeW(Values);
    }
    if (Guid) 
    {
        delete Guid;
    }
    if (SearchResult) 
    {
        ldap_msgfree(SearchResult);    
    }
    if (DN)
    {
        delete DN;
    }
    if (Sid)
    {
        delete Sid;
    }
    if (DomainDn)
    {
        delete DomainDn;
    }
    if (m_Error->isError()) {
        return FALSE;
    }
    if (NewTrust) {
        delete NewTrust;
    }
    
    //Connect back to the Domain Naming FSMO
    if (!LdapConnectandBindToDomainNamingFSMO())
    {
        return FALSE;
    }

    return TRUE;
}


BOOL CEnterprise::LdapConnectandBindToServer(WCHAR *Server)
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG ldapErr = LDAP_SUCCESS;
    PDOMAIN_CONTROLLER_INFOW DomainControllerInfo = NULL;

    if (m_hldap) {
        ldapErr = ldap_unbind(m_hldap);
        m_hldap = NULL;
        if ( LDAP_SUCCESS != ldapErr) {
            m_Error->SetErr(LdapMapErrorToWin32(ldapErr),
                            L"Failed to close the old Ldap session");
            return false;
        }
    }

    m_hldap = ldap_openW(Server,
                         LDAP_PORT
                         );

    if (NULL == m_hldap) {
        ldapErr = LdapGetLastError();
        m_Error->SetErr(ldapErr?LdapMapErrorToWin32(ldapErr):ERROR_BAD_NET_RESP,
                        L"Failed to open a ldap connection to %s",
                        Server);
        return false;
    }

    ldapErr = ldap_bind_s(m_hldap,
                          NULL,
                          (PWCHAR)m_Opts->pCreds,
                          LDAP_AUTH_SSPI
                          );
    if ( LDAP_SUCCESS != ldapErr) {
        m_Error->SetErr(LdapMapErrorToWin32(ldapErr),
                        L"Failed to Bind to Ldap session on %s",
                        Server);
        return false;
    }

    return true;
}

BOOL CEnterprise::LdapConnectandBindToDomainNamingFSMO()
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];
    WCHAR        *Attr = NULL;
    BerElement   *pBerElement = NULL;

    WCHAR        *PartitionsRdn = L"CN=Partitions,";

    WCHAR        *PartitionsDn = NULL;
    WCHAR        *FSMORoleOwnerAttr = L"fSMORoleOwner";
    WCHAR        *DnsHostNameAttr = L"dNSHostName";

    WCHAR        *DomainNamingFSMOObject = NULL;
    WCHAR        *DomainNamingFSMODsa = NULL;
    WCHAR        *DomainNamingFSMOServer = NULL;
    WCHAR        *DomainNamingFSMODnsName = NULL;

    WCHAR        **Values;

    WCHAR        *ConfigurationDN = NULL;

    WCHAR        *DefaultFilter = L"objectClass=*";

    ULONG         Length;

    BOOL          found = false;

    if (!m_hldap) {
        if (!LdapConnectandBind())
        {
           return FALSE;
        }
    }

    //
    // Read the reference to the fSMORoleOwner
    //
    AttrsToSearch[0] = L"configurationNamingContext";
    AttrsToSearch[1] = NULL;
    
    LdapError = ldap_search_sW( m_hldap,
                                NULL,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {
        
        m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                        L"Search to find Configuration container failed");
        goto Cleanup;
    }
    
    NumberOfEntries = ldap_count_entries(m_hldap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
            
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(m_hldap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {
    
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ConfigurationDN = new WCHAR[wcslen(Values[0])+1];
                        if (!ConfigurationDN) {
                            m_Error->SetMemErr();
                            goto Cleanup;
                        }
                        wcscpy( ConfigurationDN, Values[0] );
                        found = true;
                    }

                    LdapError = ldap_value_freeW(Values);
                    Values = NULL;
                    if (LDAP_SUCCESS != LdapError) 
                    {
                        m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                                        L"Failed to Free values from a ldap search");
                        goto Cleanup;
                    }

                 }
                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
            }

            
        }
    }
    
    if ( SearchResult ) {
        ldap_msgfree( SearchResult );
        SearchResult = NULL;
    }
    if (!found) {

        m_Error->SetErr( ERROR_DS_CANT_RETRIEVE_ATTS,
                         L"Could not find the configurationNamingContext attribute on the RootDSE object" );
        goto Cleanup;

    }

    
    Length =  (wcslen( ConfigurationDN )
            + wcslen( PartitionsRdn )
            + 1);

    PartitionsDn = new WCHAR[Length];

    wcscpy( PartitionsDn, PartitionsRdn );
    wcscat( PartitionsDn, ConfigurationDN );
    //
    // Next get the role owner
    //
    AttrsToSearch[0] = FSMORoleOwnerAttr;
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( m_hldap,
                                PartitionsDn,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries(m_hldap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
                 Entry != NULL;
                     Entry = ldap_next_entry(m_hldap, Entry) )
        {
            for( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                     Attr != NULL;
                        Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, FSMORoleOwnerAttr ) ) {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW(m_hldap, Entry, Attr);
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        DomainNamingFSMODsa = new WCHAR[Length+1];
                        if (!DomainNamingFSMODsa) {
                            m_Error->SetMemErr();
                            goto Cleanup;
                        }
                        wcscpy( DomainNamingFSMODsa, Values[0] );
                    }

                    LdapError = ldap_value_freeW(Values);
                    Values = NULL;
                    if (LDAP_SUCCESS != LdapError) 
                    {
                        m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                                        L"Failed to Free values from a ldap search");
                        goto Cleanup;
                    }
                }
                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
             }

            
         }
    }

    ldap_msgfree( SearchResult );
    SearchResult = NULL;

    if ( !DomainNamingFSMODsa )
    {
        m_Error->SetErr(ERROR_DS_MISSING_FSMO_SETTINGS,
                        L"Could not find the DN of the Domain naming FSMO");
        goto Cleanup;
    }

    //
    // Ok, we now have the domain naming object; find its dns name
    //
    DomainNamingFSMOServer = new WCHAR[wcslen( DomainNamingFSMODsa ) + 1];
    if (!DomainNamingFSMOServer) {
        m_Error->SetMemErr();
        goto Cleanup;
    }
    if ( ERROR_SUCCESS != TrimDNBy( DomainNamingFSMODsa ,1 ,&DomainNamingFSMOServer) )
    {
        // an error! The name must be mangled, somehow
        delete DomainNamingFSMOServer;
        DomainNamingFSMOServer = NULL;
        m_Error->SetErr(ERROR_DS_MISSING_FSMO_SETTINGS,
                        L"The DomainNaming FSMO is missing");
        goto Cleanup;
    }

    AttrsToSearch[0] = DnsHostNameAttr;
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW(m_hldap,
                               DomainNamingFSMOServer,
                               LDAP_SCOPE_BASE,
                               L"objectClass=*",
                               AttrsToSearch,
                               FALSE,
                               &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                        L"ldap_search_sW for rid fsmo dns name failed\n");
        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries( m_hldap, SearchResult );
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
                  Entry != NULL;
                      Entry = ldap_next_entry(m_hldap, Entry))
        {
            for( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                  Attr != NULL;
                      Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement))
            {
                if ( !_wcsicmp( Attr, DnsHostNameAttr ) )
                {

                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                         //
                         // Found it - these are NULL-terminated strings
                         //
                         Length = wcslen( Values[0] );
                         DomainNamingFSMODnsName = new WCHAR[Length+1];
                         if (!DomainNamingFSMODnsName) {
                             m_Error->SetMemErr();
                             goto Cleanup;
                         }
                         wcscpy( DomainNamingFSMODnsName, Values[0] );
                    }

                    LdapError = ldap_value_freeW(Values);
                    Values = NULL;
                    if (LDAP_SUCCESS != LdapError) 
                    {
                        m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                                        L"Failed to Free values from a ldap search");
                        goto Cleanup;
                    }
                }
                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
            }

            
        }
    }

    ldap_msgfree( SearchResult );
    SearchResult = NULL;

    if ( !DomainNamingFSMODnsName )
    {
        m_Error->SetErr(ERROR_DS_MISSING_FSMO_SETTINGS,
                        L"Unable to find DnsName of the Domain naming fsmo");
        goto Cleanup;
    }

    if ( !LdapConnectandBindToServer(DomainNamingFSMODnsName) )
    {
        m_Error->AppendErr(L"Cannot connect and bind to the Domain Naming FSMO.  Cannot Continue.");
        goto Cleanup;
    }



Cleanup:

    if (Attr) {
        ldap_memfree(Attr);
        Attr = NULL;
    }
    if (Values) {
        ldap_value_free(Values);
    }
    if ( PartitionsDn ) 
    {
        delete PartitionsDn;
    }
    if ( DomainNamingFSMOObject ) 
    {
        delete DomainNamingFSMOObject;
    }
    if ( DomainNamingFSMODsa )
    {
        delete DomainNamingFSMODsa;
    }
    if ( DomainNamingFSMOServer) 
    {
        delete DomainNamingFSMOServer;
    }
    if ( DomainNamingFSMODnsName ) 
    {
        delete DomainNamingFSMODnsName;
    }
    if ( ConfigurationDN )
    {
        delete ConfigurationDN;
    }
    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }
    if ( m_Error->isError() ) 
    {
        return false;
    }
    return true;
}


BOOL CEnterprise::EnumeratePartitions()
{
    if (!m_hldap) 
    {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Call to EnumeratePartitions without having a valid handle to an ldap server\n");
        return false;
    }

    if (!m_ConfigNC) 
    {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Call to EnumeratePartitions without having a valid ConfigNC\n");
        return false;
    }

    DWORD WinError = ERROR_SUCCESS;

    ULONG         LdapError = LDAP_SUCCESS;

    LDAPMessage   *SearchResult = NULL;
    PLDAPControlW ServerControls[2];
    LDAPControlW  ExtDNcontrol;
    ULONG         NumberOfEntries;
    WCHAR         *Attr = NULL;
    BerElement    *pBerElement = NULL;
    WCHAR         **Result = NULL;
    DWORD         BehaviorVerison = 0;

    WCHAR         *AttrsToSearch[6];

    WCHAR         *DefaultFilter = L"objectClass=*";

    WCHAR         *PartitionsRdn = L"CN=Partitions,";

    WCHAR         *ConfigurationDN = m_ConfigNC->GetDN(); 

    ULONG         Length;

    WCHAR         *PartitionsDn = NULL;
    WCHAR         **Values = NULL;
    LDAPMessage   *Entry = NULL;

    WCHAR         *Guid = NULL;
    WCHAR         *DN = NULL;
    WCHAR         *Sid = NULL;

    CDsName       *Crossref = NULL;
    CDsName       *DomainDns = NULL;
    BOOL          isDomain = FALSE;
    DWORD         systemflags = 0;
    WCHAR         *dnsRoot = NULL;
    WCHAR         *NetBiosName = NULL;

    //check the forest behavior version if less that 2 Fail.
    AttrsToSearch[0] = L"msDS-Behavior-Version";
    AttrsToSearch[1] = NULL;

    Length =  (wcslen( ConfigurationDN )
            + wcslen( PartitionsRdn )   
            + 1);

    PartitionsDn = new WCHAR[Length];

    wcscpy( PartitionsDn, PartitionsRdn );
    wcscat( PartitionsDn, ConfigurationDN );

    LdapError = ldap_search_sW( m_hldap,
                                PartitionsDn,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                        L"Search to find the partitions container failed");
        goto Cleanup;
    }

    Entry = ldap_first_entry(m_hldap, SearchResult);
    if (!Entry) {
        m_Error->SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                        L"The Behavior version of the Forest has not been set to 2 or greater");
        goto Cleanup;
    }

    Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
    if (!Attr) {
        m_Error->SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                        L"The Behavior version of the Forest has not been set to 2 or greater");
        goto Cleanup;
    }

    Result = ldap_get_valuesW (m_hldap,
                               Entry,
                               Attr
                               );
    if (!Result) {                
        m_Error->SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                        L"The Behavior version of the Forest has not been set to 2 or greater");
        goto Cleanup;
    }

    BehaviorVerison = (DWORD)_wtoi(*Result);

    if (BehaviorVerison < 2) {
        m_Error->SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                        L"The Behavior version of the Forest is %d it must be 2 or greater to perform a domain rename");
        goto Cleanup;    
    }

    if (Result) {
        LdapError = ldap_value_freeW(Result);
        Result = NULL;
        if ( LDAP_SUCCESS != LdapError )
        {
            m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                            L"Failed to free memory");
            goto Cleanup;
        }
    }

    if (Result) {
        ldap_value_free(Result);
    }
    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }

    SearchResult = NULL;
    Entry = NULL;
    Attr  = NULL;
    
    AttrsToSearch[0] = L"systemFlags";
    AttrsToSearch[1] = L"nCName";
    AttrsToSearch[2] = L"dnsRoot";
    AttrsToSearch[3] = L"nETBIOSName";
    AttrsToSearch[4] = L"distinguishedName";
    AttrsToSearch[5] = NULL;

    // Set up the extended DN control.
    ExtDNcontrol.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    ExtDNcontrol.ldctl_iscritical = TRUE;
    ExtDNcontrol.ldctl_value.bv_len = 0;
    ExtDNcontrol.ldctl_value.bv_val = NULL;
    ServerControls[0] = &ExtDNcontrol;
    ServerControls[1] = NULL;

    LdapError = ldap_search_ext_sW( m_hldap,
                                    PartitionsDn,
                                    LDAP_SCOPE_ONELEVEL,
                                    DefaultFilter,
                                    AttrsToSearch,
                                    FALSE,
                                    (PLDAPControlW *)&ServerControls,
                                    NULL,
                                    NULL,
                                    0,
                                    &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {
        
        m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                        L"Search to find the partitions container failed");
        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries( m_hldap, SearchResult );
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
                  Entry != NULL;
                      Entry = ldap_next_entry(m_hldap, Entry))
        {
            for( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                  Attr != NULL;
                      Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement))
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[4] ) )
                {

                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //
                        // Found it - these are NULL-terminated strings
                        //
                        if (!LdapGetGuid(Values[0],
                                         &Guid)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetDN(Values[0],
                                       &DN)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetSid(Values[0],
                                        &Sid)) 
                        {
                            goto Cleanup;
                        }

                        
                        Crossref = new CDsName(Guid,
                                               DN,
                                               Sid);
                        if (!Crossref) {
                            m_Error->SetMemErr();
                            goto Cleanup;
                        }

                        Guid = DN = Sid = NULL; 

                    }

                }
                if ( !_wcsicmp( Attr, AttrsToSearch[2] ) )
                {

                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //
                        // Found it - these are NULL-terminated strings
                        //
                        dnsRoot = new WCHAR[wcslen(Values[0])+1];
                        if (!dnsRoot) {
                            m_Error->SetMemErr();
                            goto Cleanup;
                        }
                        wcscpy(dnsRoot,Values[0]);
                    }

                }
                if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                {

                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //
                        // Found it - these are NULL-terminated strings
                        //
                        if (!LdapGetGuid(Values[0],
                                         &Guid)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetDN(Values[0],
                                       &DN)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetSid(Values[0],
                                        &Sid)) 
                        {
                            goto Cleanup;
                        }

                        
                        DomainDns = new CDsName(Guid,
                                                DN,
                                                Sid);
                        if (!DomainDns) {
                            m_Error->SetMemErr();
                            goto Cleanup;
                        }

                        Guid = DN = Sid = NULL;

                    }

                }
                if ( !_wcsicmp( Attr, AttrsToSearch[3] ) )
                {

                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                         //
                         // Found it - these are NULL-terminated strings
                         //
                        NetBiosName = new WCHAR[wcslen(Values[0])+1];
                        if (!NetBiosName) {
                            m_Error->SetMemErr();
                            goto Cleanup;
                        }
                        wcscpy(NetBiosName,Values[0]);

                    }

                }
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //
                        // Found it - these are NULL-terminated strings
                        //
                        systemflags=_wtoi(Values[0]);

                        if ( !(systemflags & FLAG_CR_NTDS_NC) ) 
                        {
                            // If systemflags doesn't have the FLAG_CR_NTDS_NC
                            // Flag set then we are going to ignor this entry
                            // and move on to the next one.  We don't have to
                            // free anything because this is the first attribute that
                            // we get back and we haven't allocated anything for it
                            // as of yet.  Therefore we can just break to move on
                            // to the next entry.  This is not an error.
                            break;
                        }

                        if ( systemflags & FLAG_CR_NTDS_DOMAIN ) {
                            isDomain = TRUE;
                        } else {
                            isDomain = FALSE;
                        }

                        systemflags = 0;
                    
                    }

                }

                LdapError = ldap_value_freeW(Values);
                Values = NULL;
                if (LDAP_SUCCESS != LdapError) 
                {
                    m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                                    L"Failed to Free values from a ldap search");
                    goto Cleanup;
                }

                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
            }

            Guid = DomainDns->GetGuid();

            if ( (TRUE == m_ConfigNC->CompareByObjectGuid(Guid)) ||
                 (TRUE == m_SchemaNC->CompareByObjectGuid(Guid)) ) 
            {
                // This is the crossref for the Configuration or
                // the schema. Therefore we are going to ignore it. 
                if (Crossref)
                {
                    delete Crossref;
                    Crossref = NULL;
                }
                if (DomainDns) 
                {
                    delete DomainDns;
                    DomainDns = NULL;
                }
                if (dnsRoot)
                {
                    delete dnsRoot;
                    dnsRoot = NULL;
                }
                if (NetBiosName) 
                {
                    delete NetBiosName;
                    NetBiosName = NULL;
                }
                
                delete Guid;
                Guid = NULL;
                continue;
                   
            }
            delete Guid;
            Guid = NULL;

            //after we have read all of the attributes
            //we are going to create a new domain using the information
            //gathered and we are going to add this domain to the domain
            //list that we keep.
            CDomain *d = new CDomain(Crossref,
                                     DomainDns,
                                     dnsRoot,
                                     NetBiosName,
                                     isDomain,
                                     NULL);
            if (m_Error->isError()) {
                goto Cleanup;
            }
            if (!d) {
                m_Error->SetMemErr();
                goto Cleanup;
            }
            Crossref = NULL;
            DomainDns = NULL;
            dnsRoot = NULL;
            NetBiosName = NULL;
            if (!AddDomainToDomainList(d))
            {
                delete d;
                d = NULL;
                return false;
            }
            // if this domain is the forest root we should mark
            // have a pointer to it.
            WCHAR *dGuid = m_ForestRootNC->GetGuid();
            if ( d->GetDomainDnsObject()->CompareByObjectGuid( dGuid ) )
            {
                delete dGuid;
                dGuid = NULL;
                m_ForestRoot = d;
            }
            

        }
    }

    Cleanup:

    if (Attr) {
        ldap_memfree(Attr);
    }
    if (Values) {
        ldap_value_free(Values);
    }
    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }
    if (ConfigurationDN) {
        delete ConfigurationDN;
    }
    if (PartitionsDn) {
        delete PartitionsDn;
    }
    if (Guid) {
        delete Guid;
    }
    if (DN) {
        delete DN;
    }
    if (Sid) {
        delete Sid;
    }
    if (!m_ForestRootNC) {
        m_Error->SetErr(ERROR_GEN_FAILURE,
                        L"There is an inconsitancy in the Forest.  A crossref could not be found for the forest root.");
    }
    if (Result) {
        ldap_value_free(Result);
    }
    if ( m_Error->isError() ) 
    {
        return false;
    }
    return true;

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rendom\util\saxcontenthandlerimpl.cxx ===
#include "SAXContentHandlerImpl.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


SAXContentHandlerImpl::SAXContentHandlerImpl()
{
    _cRef = 1;
}

SAXContentHandlerImpl::~SAXContentHandlerImpl()
{
}


//+-----------------------------------------------------------------------------
//
// ISAXContentHandler implementation
//
//------------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::putDocumentLocator( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator
            )
{
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::startDocument()
{
    return S_OK;
}
        

        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::endDocument( void)
{
    return S_OK;
}
        
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::startPrefixMapping( 
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri)
{
    return S_OK;
}
        
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::endPrefixMapping( 
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix)
{
    return S_OK;
}
        

        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes)
{
    return S_OK;
}
        
       
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::endElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName)
{
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    return S_OK;
}
        

HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::ignorableWhitespace( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    return S_OK;
}
        

HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::processingInstruction( 
            /* [in] */ const wchar_t __RPC_FAR *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ const wchar_t __RPC_FAR *pwchData,
            /* [in] */ int cchData)
{
    return S_OK;
}
        
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::skippedEntity( 
            /* [in] */ const wchar_t __RPC_FAR *pwchVal,
            /* [in] */ int cchVal)
{
    return S_OK;
}


//+-----------------------------------------------------------------------------
//
// IUnknown implementation
//
//------------------------------------------------------------------------------

long __stdcall SAXContentHandlerImpl::QueryInterface(const struct _GUID &riid,void ** ppvObject)
{
    if (riid == IID_IUnknown || riid == IID_ISAXContentHandler)
    {
        *ppvObject = static_cast<ISAXContentHandler *>(this);
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

unsigned long __stdcall SAXContentHandlerImpl::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

unsigned long __stdcall SAXContentHandlerImpl::Release()
{
    if (InterlockedDecrement(&_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return _cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rendom\src\rendom.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "rendom.h"

#include <mdcommsg.h>
#include <wchar.h>
#include <ntlsa.h>
#include <Ntdsapi.h> // for DsCrackNames()

extern "C"
{
#include <ntdsapip.h>
}

#include <windns.h>
#include <drs_w.h>
#include <base64.h>

#include "Domainlistparser.h"
#include "Dclistparser.h"

#include "renutil.h"

//Callback functions prototypes for ASyncRPC
VOID ExecuteScriptCallback(struct _RPC_ASYNC_STATE *pAsync,
                           void *Context,
                           RPC_ASYNC_EVENT Event);

VOID PrepareScriptCallback(struct _RPC_ASYNC_STATE *pAsync,
                           void *Context,
                           RPC_ASYNC_EVENT Event);

WCHAR* CRenDomErr::m_ErrStr = NULL;
DWORD  CRenDomErr::m_Win32Err = 0;
BOOL   CRenDomErr::m_AlreadyPrinted = 0;


// This is a contructor for the class CEnterprise.  This Constructor will
// read its information for the DS and build the forest from that using
// the domain that the machine that it is run on is joined to and the
// creds of the logged on user.   
CEnterprise::CEnterprise(CReadOnlyEntOptions *opts):m_DcList(opts)
{
    m_DomainList = NULL;
    m_descList = NULL;
    m_maxReplicationEpoch = 0;
    m_hldap = NULL;
    m_ConfigNC = NULL;
    m_SchemaNC = NULL;
    m_ForestRootNC = NULL;
    m_ForestRoot = NULL;
    m_Action = NULL;

    m_Error = new CRenDomErr;
    if (!m_Error) {
        m_Error->SetMemErr();
    }

    if (!opts) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Failed to create Enterprise Discription opts must be passed to CEnterprise");
    }
    m_Opts = opts;
    
    m_xmlgen = new CXMLGen;
    if (!m_xmlgen) {
        m_Error->SetMemErr();
        return;
    }
    
    if (!m_Opts->ShouldExecuteScript() && !m_Opts->ShouldPrepareScript())  {

        if(!ReadDomainInformation()) 
        {
            if (!m_Error->isError())
            {
                m_Error->SetErr(ERROR_GEN_FAILURE,
                                L"Failed to read information from the Forest");
            }
        }
    
        
        if (!BuildForest()) 
        {
            if (!m_Error->isError()) 
            {
                m_Error->SetErr(ERROR_GEN_FAILURE,
                                L"Failed to build a forest from the information read in from the active directory");
            }
        }

    }
    
        

}

// This is the distructor for CEnterprise.
CEnterprise::~CEnterprise()
{
    if (m_hldap) {
        ldap_unbind(m_hldap);
    }
    if (m_ConfigNC) {
        delete m_ConfigNC;
    }
    if (m_SchemaNC) {
        delete m_SchemaNC;
    }
    if (m_ForestRootNC) {
        delete m_ForestRootNC;
    }
    while (NULL != m_DomainList) {
        CDomain *p = m_DomainList->GetNextDomain();
        delete m_DomainList;
        m_DomainList = p;
    }
    while (NULL != m_descList) {
        CDomain *p = m_descList->GetNextDomain();
        delete m_descList;
        m_descList = p;
    }
    if (m_xmlgen) {
        delete m_xmlgen;
    }
    if (m_Error) {
        delete m_Error;
    }
}

BOOL CEnterprise::WriteScriptToFile(WCHAR *outfile)
{
    return m_xmlgen->WriteScriptToFile(outfile);
}
    
BOOL CEnterprise::ExecuteScript()
{
    if (!m_hldap)
    {
        if (!LdapConnectandBindToDomainNamingFSMO())
        {
            return FALSE;
        }
    }

    if (m_Opts->ShouldExecuteScript()) {
        if (!m_DcList.ExecuteScript(CDcList::eExecute))
        {
            return FALSE;
        }
    } else if (m_Opts->ShouldPrepareScript()) {
        if (!m_DcList.ExecuteScript(CDcList::ePrepare))
        {
            return FALSE;
        }    
    }

    return TRUE;

}         

BOOL CEnterprise::RemoveDNSAliasAndScript()
{
    DWORD         Length = 0;
    ULONG         dwErr = LDAP_SUCCESS;
    WCHAR         *ObjectDN = NULL;

    if (!m_hldap) 
    {
        if(!LdapConnectandBindToDomainNamingFSMO())
        {
            goto Cleanup;
        }
    }

    //delete the msDS-DNSRootAlias atributes on the crossref objects
    LDAPModW         *pLdapMod[2] = {0,0};

    pLdapMod[0] = new LDAPModW;
    if (!pLdapMod[0]) {
        m_Error->SetMemErr();
        goto Cleanup;
    }

    pLdapMod[0]->mod_type = L"msDS-DNSRootAlias";
    pLdapMod[0]->mod_op   = LDAP_MOD_DELETE;
    pLdapMod[0]->mod_vals.modv_strvals = NULL;
    
    for (CDomain *d = m_DomainList; d;d = d->GetNextDomain()) {

        ObjectDN = d->GetDomainCrossRef()->GetDN();
        if (m_Error->isError()) {
            goto Cleanup;
        }
    
        dwErr = ldap_modify_sW (m_hldap, ObjectDN, pLdapMod);
    
        //It is possiable for the error LDAP_NO_SUCH_ATTRIBUTE.
        //This is not an Error in our case.
        if(dwErr != LDAP_SUCCESS && LDAP_NO_SUCH_ATTRIBUTE != dwErr) {
            m_Error->SetErr(LdapMapErrorToWin32(dwErr),
                            L"Failed to delete Dns Root alias on the DN: %s, on host %S: %S",
                            ObjectDN,
                            m_hldap->ld_host,
                            ldap_err2stringW(dwErr));
            goto Cleanup;
        }

        if (ObjectDN) {
            delete ObjectDN;
            ObjectDN = NULL;
        }
    
     
    }

    //delete the script

    WCHAR *PartitionsRDN = L"CN=Partitions,";
    WCHAR *PartitionsDN = NULL;

    pLdapMod[0]->mod_type = L"msDS-UpdateScript";
    pLdapMod[0]->mod_op   = LDAP_MOD_DELETE;
    pLdapMod[0]->mod_vals.modv_strvals = NULL;

    ObjectDN = m_ConfigNC->GetDN();
    if (m_Error->isError()) {
        goto Cleanup;
    }

    PartitionsDN = new WCHAR[wcslen(ObjectDN)+
                             wcslen(PartitionsRDN)+1];
    if (!PartitionsDN) {
        m_Error->SetMemErr();
        goto Cleanup;
    }

    wcscpy(PartitionsDN,PartitionsRDN);
    wcscat(PartitionsDN,ObjectDN);


    dwErr = ldap_modify_sW (m_hldap, PartitionsDN, pLdapMod);

    //It is possiable for the error LDAP_NO_SUCH_ATTRIBUTE.
    //This is not an Error in our case.
    if(dwErr != LDAP_SUCCESS && LDAP_NO_SUCH_ATTRIBUTE != dwErr) {
        m_Error->SetErr(LdapMapErrorToWin32(dwErr),
                        L"Failed to delete rename script on the DN: %s, on host %S: %S",
                        PartitionsDN,
                        m_hldap->ld_host,
                        ldap_err2stringW(dwErr));
    }

    if (ObjectDN) {
        delete ObjectDN;
        ObjectDN = NULL;
    }

    Cleanup:

    if (pLdapMod[0]) {
        delete pLdapMod[0];
    }
    if (PartitionsDN) {
        delete PartitionsDN;
    }
    if (ObjectDN) {
        delete ObjectDN;
    }

    if (m_Error->isError()) {
        return FALSE;
    }

    return TRUE;

}
       
BOOL CEnterprise::UploadScript()
{
    DWORD         Length = 0;
    ULONG         LdapError = LDAP_SUCCESS;
    WCHAR         *DefaultFilter = L"objectClass=*";
    WCHAR         *PartitionsRdn = L"CN=Partitions,";
    WCHAR         *ConfigurationDN = NULL;
    WCHAR         *PartitionsDn = NULL;
    WCHAR         *AliasName = NULL;
    WCHAR         *ObjectDN = NULL;
    
    if (!m_hldap) 
    {
        if(!LdapConnectandBindToDomainNamingFSMO())
        {
            goto Cleanup;
        }
    }

    //update the msDS-DNSRootAlias atributes on the crossref objects
    LDAPModW         **pLdapMod = NULL;

    for (CDomain *d = m_DomainList; d;d = d->GetNextDomain()) {

        DWORD dwErr = ERROR_SUCCESS;

        if (!d->isDnsNameRenamed()) {
            continue;
        }

        AliasName = d->GetDnsRoot();
        ObjectDN = d->GetDomainCrossRef()->GetDN();
        if (m_Error->isError()) {
            goto Cleanup;
        }
    
        AddModMod (L"msDS-DNSRootAlias", AliasName, &pLdapMod);
        
        dwErr = ldap_modify_sW (m_hldap, ObjectDN, pLdapMod);
    
        if(dwErr != LDAP_SUCCESS) {
            m_Error->SetErr(LdapMapErrorToWin32(dwErr),
                            L"Failed to upload Dns Root alias on the DN: %s, on host %S: %S",
                            ObjectDN,
                            m_hldap->ld_host,
                            ldap_err2stringW(dwErr));
        }
    
        FreeMod (&pLdapMod);
        delete (AliasName);
        AliasName = NULL;
        delete (ObjectDN);
        ObjectDN = NULL;

    }

    ConfigurationDN = m_ConfigNC->GetDN();
    if (m_Error->isError()) {
        goto Cleanup;
    }
    
    Length =  (wcslen( ConfigurationDN )
            + wcslen( PartitionsRdn )   
            + 1);
                                                          
    PartitionsDn = new WCHAR[Length];
    if (!PartitionsDn) {
        m_Error->SetMemErr();
        goto Cleanup;
    }

    wcscpy( PartitionsDn, PartitionsRdn );
    wcscat( PartitionsDn, ConfigurationDN );

    if(!m_xmlgen->UploadScript(m_hldap,
                               PartitionsDn,
                               &m_DcList))
    {
        goto Cleanup;
    }



    Cleanup:

    if (PartitionsDn) {
        delete PartitionsDn;
    }
    if (ConfigurationDN) {
        delete ConfigurationDN;
    }
    if (AliasName) {
        delete AliasName;
    }
    if (ObjectDN) {
        delete ObjectDN;
    }

    if (m_Error->isError()) {
        return FALSE;
    }
    return TRUE;
}       

// This function is for debugging only.  Will dump out the 
// Compelete description of you enterprise onto the screen
VOID CEnterprise::DumpEnterprise()
{
    wprintf(L"Dump Enterprise****************************************\n");
    if (m_ConfigNC) {
        wprintf(L"ConfigNC:\n");
        m_ConfigNC->DumpCDsName();
    } else {
        wprintf(L"ConfigNC: (NULL)\n");
    }

    if (m_SchemaNC) {
        wprintf(L"m_SchemaNC:\n");
        m_SchemaNC->DumpCDsName();
    } else {
        wprintf(L"m_SchemaNC: (NULL)\n");
    }

    if (m_ForestRootNC) {
        wprintf(L"m_ForestRootNC:\n");
        m_ForestRootNC->DumpCDsName();
    } else {
        wprintf(L"m_ForestRootNC: (NULL)\n");
    }

    wprintf(L"maxReplicationEpoch: %d\n",m_maxReplicationEpoch);

    wprintf(L"ERROR: %d\n",m_Error->GetErr());

    wprintf(L"DomainList::\n");
    
    CDomain *p = m_DomainList;
    while (NULL != p) {
        p->DumpCDomain();
        p = p->GetNextDomain();
    }

    wprintf(L"descList::\n");
    
    p = m_descList;
    while (NULL != p) {
        p->DumpCDomain();
        p = p->GetNextDomain();
    }

    wprintf(L"Dump Enterprise****************************************\n");

}

BOOL CEnterprise::ReadStateFile()
{
    HRESULT                             hr;
    ISAXXMLReader *                     pReader    = NULL;
    CXMLDcListContentHander*            pHandler   = NULL; 
    IClassFactory *                     pFactory   = NULL;

    VARIANT                             varText;
    CHAR                               *pszText;
    WCHAR                              *pwszText;

    HANDLE                             fpScript;
    DWORD                              dwFileLen;

    BSTR                               bstrText    = NULL;

    
    VariantInit(&varText);
    varText.vt = VT_BYREF|VT_BSTR;


    fpScript = CreateFile(m_Opts->GetStateFileName(),   // file name
                          GENERIC_READ,                // access mode
                          FILE_SHARE_READ,             // share mode
                          NULL,                        // SD
                          OPEN_EXISTING,               // how to create
                          0,                           // file attributes
                          NULL                        // handle to template file
                          );
    if (INVALID_HANDLE_VALUE == fpScript) {
        m_Error->SetErr(GetLastError(),
                        L"Failed Could not open file %s.",
                        m_Opts->GetStateFileName());
        goto CleanUp;
    }

    dwFileLen = GetFileSize(fpScript,           // handle to file
                            NULL  // high-order word of file size
                            );

    if (dwFileLen == -1) {
        m_Error->SetErr(GetLastError(),
                        L"Could not get the file size of %s.",
                        m_Opts->GetStateFileName());
        CloseHandle(fpScript);
        goto CleanUp;
    }

    pwszText = new WCHAR[(dwFileLen+2)/sizeof(WCHAR)];
    if (!pwszText) {
        m_Error->SetMemErr();
        CloseHandle(fpScript);
        goto CleanUp;
    }

    if (!ReadFile(fpScript,                // handle to file
                  (LPVOID)pwszText,        // data buffer
                  dwFileLen,               // number of bytes to read
                  &dwFileLen,              // number of bytes read
                  NULL                     // overlapped buffer
                  ))
    {
        m_Error->SetErr(GetLastError(),
                        L"Failed to read file %s",
                        m_Opts->GetStateFileName());
        goto CleanUp;

    }

    if (!CloseHandle(fpScript))
    {
        m_Error->SetErr(GetLastError(),
                        L"Failed to Close the file %s.",
                        m_Opts->GetStateFileName());
    }
    
    //skip Byte-Order-Mark
    
    pwszText[dwFileLen/sizeof(WCHAR)] = 0;
    bstrText = SysAllocString(  ++pwszText );
    
    varText.pbstrVal = &bstrText; 

    delete (--pwszText); pwszText = NULL;

    
    // 
    //

    GetClassFactory( CLSID_SAXXMLReader, &pFactory);
	
	hr = pFactory->CreateInstance( NULL, __uuidof(ISAXXMLReader), (void**)&pReader);

	if(!FAILED(hr)) 
	{
		pHandler = new CXMLDcListContentHander(this);
		hr = pReader->putContentHandler(pHandler);
        if(FAILED(hr)) 
	    {
            m_Error->SetErr(HRESULTTOWIN32(hr),
                            L"Failed to set a Content handler for the parser");

            goto CleanUp;
        }
        
        hr = pReader->parse(varText);
        if(FAILED(hr)) 
	    {
            if (m_Error->isError()) {
                goto CleanUp;
            }
            m_Error->SetErr(HRESULTTOWIN32(hr),
                            L"Failed to parser the File %s",
                            m_Opts->GetStateFileName());
            goto CleanUp;
        }
		

    }
	else 
	{
		m_Error->SetErr(HRESULTTOWIN32(hr),
                        L"Failed to parse document");
    }

CleanUp:

    if (pReader) {
        pReader->Release();
    }

    if (pHandler) {
        delete pHandler;
    }

    if (pFactory) {
        pFactory->Release();
    }

    if (bstrText) {
        SysFreeString(bstrText);   
    }

    if (m_Error->isError()) {
        return FALSE;
    }


    return TRUE;
}

BOOL CEnterprise::ReadForestChanges()
{
    HRESULT                             hr;
    ISAXXMLReader *                     pReader    = NULL;
    CXMLDomainListContentHander*        pHandler   = NULL; 
    IClassFactory *                     pFactory   = NULL;

    VARIANT                             varText;
    CHAR                               *pszText;
    WCHAR                              *pwszText;

    HANDLE                             fpScript;
    DWORD                              dwFileLen;

    BSTR                               bstrText    = NULL;

    
    VariantInit(&varText);
    varText.vt = VT_BYREF|VT_BSTR;


    fpScript = CreateFile(m_Opts->GetDomainlistFileName(),   // file name
                          GENERIC_READ,                // access mode
                          FILE_SHARE_READ,             // share mode
                          NULL,                        // SD
                          OPEN_EXISTING,               // how to create
                          0,                           // file attributes
                          NULL                        // handle to template file
                          );
    if (INVALID_HANDLE_VALUE == fpScript) {
        m_Error->SetErr(GetLastError(),
                        L"Failed Could not open file %s.",
                        m_Opts->GetDomainlistFileName());
        goto CleanUp;
    }

    dwFileLen = GetFileSize(fpScript,           // handle to file
                            NULL  // high-order word of file size
                            );

    if (dwFileLen == -1) {
        m_Error->SetErr(GetLastError(),
                        L"Could not get the file size of %s.",
                        m_Opts->GetDomainlistFileName());
        CloseHandle(fpScript);
        goto CleanUp;
    }

    pwszText = new WCHAR[(dwFileLen+2)/sizeof(WCHAR)];
    if (!pwszText) {
        m_Error->SetMemErr();
        CloseHandle(fpScript);
        goto CleanUp;
    }

    if (!ReadFile(fpScript,                // handle to file
                  (LPVOID)pwszText,        // data buffer
                  dwFileLen,               // number of bytes to read
                  &dwFileLen,              // number of bytes read
                  NULL                     // overlapped buffer
                  ))
    {
        m_Error->SetErr(GetLastError(),
                        L"Failed to read file %s",
                        m_Opts->GetDomainlistFileName());
        goto CleanUp;

    }

    if (!CloseHandle(fpScript))
    {
        m_Error->SetErr(GetLastError(),
                        L"Failed to Close the file %s.",
                        m_Opts->GetDomainlistFileName());
    }
    
    //skip Byte-Order-Mark
    
    pwszText[dwFileLen/sizeof(WCHAR)] = 0;
    bstrText = SysAllocString(  ++pwszText );
    
    varText.pbstrVal = &bstrText; 

    delete (--pwszText); pwszText = NULL;

    
    // 
    //

    GetClassFactory( CLSID_SAXXMLReader, &pFactory);
	
	hr = pFactory->CreateInstance( NULL, __uuidof(ISAXXMLReader), (void**)&pReader);

	if(!FAILED(hr)) 
	{
		pHandler = new CXMLDomainListContentHander(this);
		hr = pReader->putContentHandler(pHandler);
        if(FAILED(hr)) 
	    {
            m_Error->SetErr(HRESULTTOWIN32(hr),
                            L"Failed to set a Content handler for the parser");

            goto CleanUp;
        }
        
        hr = pReader->parse(varText);
        if(FAILED(hr)) 
	    {
            if (m_Error->isError()) {
                goto CleanUp;
            }
            m_Error->SetErr(HRESULTTOWIN32(hr),
                            L"Failed to parser the File %s",
                            m_Opts->GetDomainlistFileName());
            goto CleanUp;
        }
		

    }
	else 
	{
		m_Error->SetErr(HRESULTTOWIN32(hr),
                        L"Failed to parse document");
    }

CleanUp:

    if (pReader) {
        pReader->Release();
    }

    if (pHandler) {
        delete pHandler;
    }

    if (pFactory) {
        pFactory->Release();
    }

    if (bstrText) {
        SysFreeString(bstrText);   
    }

    if (m_Error->isError()) {
        return FALSE;
    }


    return TRUE;
    
       
}


// This will add a domain to the list of domains in the enterprise.
// All domains should be add to the enterprise before the forest structure is
// built using BuildForest().  If you try to pass a blank domain to the 
// list the function will fail.
BOOL CEnterprise::AddDomainToDomainList(CDomain *d)
{
    if (!d) 
    {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"An Empty Domain was passed to AddDomainToDomainList");
        return false;
    }
    
    d->SetNextDomain(m_DomainList);
    m_DomainList = d;
    return true;
    

}

BOOL CEnterprise::AddDomainToDescList(CDomain *d)
{
    if (!d) 
    {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"An Empty Domain was passed to AddDomainToDescList");
        return false;
    }
    
    d->SetNextDomain(m_descList);
    m_descList = d;
    return true;
}

BOOL CEnterprise::ClearLinks(CDomain *d)
{
    if (!d->SetParent(NULL))
    {
        return FALSE;
    }
    if (!d->SetLeftMostChild(NULL))
    {
        return FALSE;
    }
    if (!d->SetRightSibling(NULL))
    {
        return FALSE;
    }

    return TRUE;
}


// This function will gather all information nessary for domain restucturing
// expect for the new name of the domains.
BOOL CEnterprise::ReadDomainInformation() 
{
    if (!LdapConnectandBindToDomainNamingFSMO())
    {
        return FALSE;
    }
    if (!GetInfoFromRootDSE()) 
    {
        return FALSE;
    }
    if (!EnumeratePartitions()) 
    {
        return FALSE;
    }
    if (GetOpts()->ShouldUpLoadScript()) 
    {
        if (!GetReplicationEpoch())
        {
            return FALSE;
        }
        if (!GetTrustsInfo()) 
        {
            return FALSE;
        }
        if (!ReadForestChanges()) 
        {
            return FALSE;
        }
        if (!CheckConsistency()) 
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL CEnterprise::MergeForest()
{
    for (CDomain *desc = m_descList; desc; desc = desc->GetNextDomain() ) 
    {
        WCHAR *Guid = desc->GetGuid();
        if (!Guid) {
            return FALSE;
        }
        CDomain *domain = m_DomainList->LookupByGuid(Guid);
        if (!domain) {
            m_Error->SetErr(ERROR_OBJECT_NOT_FOUND,
                            L"Could not find the Guid %s\n",
                            Guid);
                           
            return FALSE;
        }
        delete Guid;
        if (!domain->Merge(desc))
        {
            return FALSE;
        }
                
    }

    if (!TearDownForest()) 
    {
        return FALSE;
    }
    
    if (!BuildForest())
    {
        return FALSE;
    }

    while (NULL != m_descList) {
        CDomain *p = m_descList->GetNextDomain();
        delete m_descList;
        m_descList = p;
    }

    if (!EnsureValidTrustConfiguration()) 
    {
        return FALSE;
    }

    return TRUE;
}

// This functions will Build the forest stucture.
BOOL CEnterprise::BuildForest()
{
    //link each domain to its parent and siblings, if any
    for (CDomain *domain = m_DomainList; domain; domain=domain->GetNextDomain() ) {
        WCHAR *pDNSRoot = domain->GetParentDnsRoot();
        CDomain *domainparent = m_DomainList->LookupByDnsRoot(pDNSRoot);
        if(domainparent)
        {
            domain->SetParent(domainparent);
            domain->SetRightSibling(domainparent->GetLeftMostChild());
            domainparent->SetLeftMostChild(domain);
        }
        delete pDNSRoot;
    }

    //link the roots together
    for (CDomain *domain = m_DomainList; domain; domain=domain->GetNextDomain() ) {
        if ( (NULL == domain->GetParent()) && (domain != m_ForestRoot) ) {
            domain->SetRightSibling(m_ForestRoot->GetRightSibling());
            m_ForestRoot->SetRightSibling(domain);
        }
    }

    if (!CreateChildBeforeParentOrder()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CEnterprise::TraverseDomainsParentBeforeChild()
{
    if (NULL == m_Action) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"TraverseDomainsParentBeforeChild called with a action defined");
        return FALSE;
    }

    CDomain *n = m_ForestRoot;
    
    while (NULL != n) {
        if (!(this->*m_Action)(n)) {
            return FALSE;
        }
        if (NULL != n->GetLeftMostChild()) {

            n = n->GetLeftMostChild();

        } else if (NULL != n->GetRightSibling()) {

            n = n->GetRightSibling();

        } else {

            for (n = n->GetParent(); n; n = n->GetParent()) {

                if (n->GetRightSibling()) {

                    n = n->GetRightSibling();
                    break;

                }
            }
        }
    }

    return TRUE;
}

BOOL CEnterprise::TraverseDomainsChildBeforeParent()
{
    if (NULL == m_Action) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"TraverseDomainsChildBeforeParent called with a action defined");
        return FALSE;
    }

    for (CDomain *n = m_DomainList; n; n = n->GetNextDomain()) {
        if (!(this->*m_Action)(n)) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL CEnterprise::SetAction(BOOL (CEnterprise::*p_Action)(CDomain *))
{                                                                         
    if (!p_Action) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"SetAction was called without a Action specified");
        return FALSE;
    }
    m_Action = p_Action;

    return TRUE;

}

CReadOnlyEntOptions* CEnterprise::GetOpts()
{
    return m_Opts;
}
    

BOOL CEnterprise::ClearAction()
{
    m_Action = NULL;
    return TRUE;
}

BOOL CEnterprise::CreateChildBeforeParentOrder()
{
    m_DomainList = NULL;

    if (!SetAction(&CEnterprise::AddDomainToDomainList)) {
        return FALSE;
    }
    if (!TraverseDomainsParentBeforeChild()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    }
    return TRUE;
}

BOOL CEnterprise::EnsureValidTrustConfiguration()
{
    CDomain         *d            = NULL;
    CDomain         *ds           = NULL;
    CDomain         *dc           = NULL;
    CTrustedDomain  *tdo          = NULL;
    BOOL            Trustfound    = FALSE;

    for (d = m_DomainList; d != NULL ; d = d->GetNextDomain()) {
        if ( NULL != d->GetParent() ) {
            //This is a child Domain
            tdo = d->GetTrustedDomainList();
            while (tdo) {
                if ( tdo->GetTrustPartner() == d->GetParent() ) 
                {
                    Trustfound = TRUE;
                    break;
                }
                tdo = (CTrustedDomain*)tdo->GetNext();
            }
            if (!Trustfound) {
                if (!m_Error->isError()) {
                    m_Error->SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                                    L"Missing shortcut trust from %ws to %ws. Create the trust and try the operation again",
                                    d->GetPrevDnsRoot(FALSE),
                                    d->GetParent()->GetPrevDnsRoot(FALSE));
                } else {
                    m_Error->AppendErr(L"Missing shortcut trust from %ws to %ws. Create the trust and try the operation again",
                                       d->GetPrevDnsRoot(FALSE),
                                       d->GetParent()->GetPrevDnsRoot(FALSE));
                }
            }

            Trustfound = FALSE;
            
        } else {
            //This is a root of a domain tree
            if (d == m_ForestRoot) {
                for ( ds = d->GetLeftMostChild(); ds != NULL; ds = ds->GetRightSibling() ) {
                    // d is the forest root and ds is another root
                    tdo = d->GetTrustedDomainList();
                    while (tdo) {
                        if ( tdo->GetTrustPartner() == ds ) 
                        {
                            Trustfound = TRUE;
                            break;
                        }
                        tdo = (CTrustedDomain*)tdo->GetNext();
                    }
                    if (!Trustfound) {
                        if (!m_Error->isError()) {
                            m_Error->SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                                            L"Missing shortcut trust from %ws to %ws. Create the trust and try the operation again",
                                            d->GetPrevDnsRoot(FALSE),
                                            ds->GetPrevDnsRoot(FALSE));
                        } else {
                            m_Error->AppendErr(L"Missing shortcut trust from %ws to %ws. Create the trust and try the operation again",
                                               d->GetPrevDnsRoot(FALSE),
                                               ds->GetPrevDnsRoot(FALSE));
                        }
                    }
        
                    Trustfound = FALSE;
                
                }
            } else {
                //d is a root but not the forest root
                tdo = d->GetTrustedDomainList();
                while (tdo) {
                    if ( tdo->GetTrustPartner() == m_ForestRoot ) 
                    {
                        Trustfound = TRUE;
                        break;
                    }
                    tdo = (CTrustedDomain*)tdo->GetNext();
                }
                if (!Trustfound) {
                    if (!m_Error->isError()) {
                        m_Error->SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                                        L"Missing shortcut trust from %ws to %ws. Create the trust and try the operation again",
                                        d->GetPrevDnsRoot(FALSE),
                                        m_ForestRoot->GetPrevDnsRoot(FALSE));
                    } else {
                        m_Error->AppendErr(L"Missing shortcut trust from %ws to %ws. Create the trust and try the operation again",
                                           d->GetPrevDnsRoot(FALSE),
                                           m_ForestRoot->GetPrevDnsRoot(FALSE));
                    }
                }
    
                Trustfound = FALSE;

            }
        }
        for (dc = d->GetLeftMostChild(); dc != NULL; dc = dc->GetRightSibling()) {
            // d is parent, dc is one of its children
            tdo = d->GetTrustedDomainList();
            while (tdo) {
                if ( tdo->GetTrustPartner() == dc ) 
                {
                    Trustfound = TRUE;
                    break;
                }
                tdo = (CTrustedDomain*)tdo->GetNext();
            }
            if (!Trustfound) {
                if (!m_Error->isError()) {
                    m_Error->SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                                    L"Missing shortcut trust from %ws to %ws. Create the trust and try the operation again",
                                    d->GetPrevDnsRoot(FALSE),
                                    dc->GetPrevDnsRoot(FALSE));
                } else {
                    m_Error->AppendErr(L"Missing shortcut trust from %ws to %ws. Create the trust and try the operation again",
                                       d->GetPrevDnsRoot(FALSE),
                                       dc->GetPrevDnsRoot(FALSE));
                }
            }

            Trustfound = FALSE;

        }
    }

    if (m_Error->isError()) {
        return FALSE;
    }

    return TRUE;

}

BOOL CEnterprise::TearDownForest()
{
    if (!SetAction(&CEnterprise::ClearLinks)) {
        return FALSE;
    }
    if (!TraverseDomainsChildBeforeParent()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    }
    return TRUE;
}

BOOL CEnterprise::ScriptDomainRenaming(CDomain *d)
{
    BOOL ret = TRUE;
    WCHAR *Path = NULL;
    WCHAR *Guid = NULL;
    WCHAR *DNSRoot = NULL;
    WCHAR *ToPath = NULL;
    WCHAR *PathTemplate = L"DC=%s,DC=INVALID";
    WCHAR *ToPathTemplate = L"DC=%s,"; 

    if (!d) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"ScriptTreeFlatting did not recieve a valid domain");
    }
    Guid = d->GetDomainDnsObject()->GetGuid();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    Path = new WCHAR[wcslen(PathTemplate)+
                     wcslen(Guid)+1];
    if (!Path) {
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(Path,
             PathTemplate,
             Guid);

    DNSRoot = d->GetDnsRoot();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    ToPath = DNSRootToDN(DNSRoot);
    if (!ToPath) {
        ret = FALSE;
        goto Cleanup;
    }


    m_xmlgen->Move(Path,ToPath);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    Cleanup:

    if (DNSRoot) {
        delete DNSRoot;
    }

    if (ToPath) {
        delete ToPath;
    }
    if (Path) {
        delete Path;
    }
    if (Guid) {
        delete Guid;
    }

    return ret;

}

WCHAR* CEnterprise::DNSRootToDN(WCHAR *DNSRoot)
{
    if (!DNSRoot) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"A NULL was passed to DNSRoot\n");
        return NULL;
    }

    WCHAR *buf = new WCHAR[1];
    if (!buf) {
        m_Error->SetMemErr();
        return NULL;
    }
    buf[0] = L'\0';

    WCHAR *pbuf = NULL;
    WCHAR *p = DNSRoot;
    WCHAR *q = DNSRoot;
    DWORD size = 0;

    while ((*p != L'.') && (*p != L'\0')) {
        size++;
        p++;
    }
    pbuf = buf;
    buf = new WCHAR[size+5];
    wcscpy(buf,pbuf);
    delete pbuf;

    wcscat(buf,L"DC=");
    wcsncat(buf,q,size);
    
    if (*p) {
        p++;
        q=p;
    }

    while (*p) {
        size = 0;
        while ((*p != L'.') && (*p != L'\0')) {
            p++;
            size++;
        }
        pbuf = buf;
        buf = new WCHAR[wcslen(pbuf)+size+5];
        wcscpy(buf,pbuf);
        delete pbuf;

        wcscat(buf,L",DC=");
        wcsncat(buf,q,size);
        
        if (*p){
            p++;
            q=p;
        }
        
    }

    return buf;
    
}

BOOL CEnterprise::CheckConsistency() 
{
    WCHAR *Guid = NULL;
    WCHAR *DNSname = NULL;
    BOOL res = TRUE;

    CDomain *d = m_DomainList;
    CDomain *p = NULL;
    WCHAR   *NetBiosName = NULL;
    DWORD   Win32Err = ERROR_SUCCESS;

    //For every Guid in the current forest make sure there is a entry in
    //the descList
    while (d) {

        Guid = d->GetGuid();
        if (m_Error->isError()) {
            return FALSE;
        }
        if (!m_descList->LookupByGuid(Guid))
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Domain Guid %s from current forest missing from forest description.",
                            Guid);
            res = FALSE;
            goto Cleanup;
        }
    
        if (Guid) {
            delete Guid;
            Guid = NULL;
        }


        d = d->GetNextDomain();
    }

    //for every Guid in the forest description Make sure it is 
    //1. syntactically correct
    //2. Has an entry in the current forest list
    //3. Only occurs once in the list
    //4. If a NDNC the make sure there is no NetbiosName in the description.
    //5. If is a Domain NC make sure that there is a NetbiosName in the description


    d = m_descList;

    while (d) {

        UUID Uuid;
        DWORD Result = ERROR_SUCCESS;

        Guid = d->GetGuid();
        if (m_Error->isError()) {
            return FALSE;
        }

        Result = UuidFromStringW(Guid,
                                 &Uuid
                                 );
        if (RPC_S_INVALID_STRING_UUID == Result) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Domain Guid %s from the forest description is not in a valid format",
                            Guid);

        }

        p = m_DomainList->LookupByGuid(Guid);
        if (!p)
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Domain Guid %s from the forest description does not exist in current forest.",
                            Guid);
            res = FALSE;
            goto Cleanup;
        }
        if (!p->isDomain()) {
            NetBiosName = d->GetNetBiosName();
            if (NetBiosName) {
                m_Error->SetErr(ERROR_GEN_FAILURE,
                                L"NetBIOS name not allowed in application on Guid %s in the forest Description",
                                Guid);
                res = FALSE;
                delete NetBiosName;
                goto Cleanup;  
            }
        }

        if (p->isDomain()) {
            NetBiosName = d->GetNetBiosName();
            //now that we have our netbios name lets do
            //our checking of it.

            //1. Check to see if the netbios name is syntactically correct
            //2. make sure the netbios is not being traded with another domain
            //3. Make sure that the netbiosname is in the forest description.
            if (!NetBiosName) {
                m_Error->SetErr(ERROR_GEN_FAILURE,
                                L"NetBIOS name required on Guid %s in the forest Description",
                                Guid);
                res = FALSE;
                goto Cleanup;  
            }

            if ( !ValidateNetbiosName(NetBiosName,wcslen(NetBiosName)) )
            {
                m_Error->SetErr(ERROR_GEN_FAILURE,
                                L"%s is not a valid NetBIOS name");
                res = FALSE;
                goto Cleanup;

            }

            if (CDomain *Tempdomain = m_DomainList->LookupByPrevNetbiosName(NetBiosName))
            {
                WCHAR *TempGuid = Tempdomain->GetGuid();
                if (TempGuid && Guid && wcscmp(TempGuid,Guid) != 0) {

                    m_Error->SetErr(ERROR_GEN_FAILURE,
                                    L"NetBIOS domain name %s in the forest description "
                                    L"names a different domain in the current forest. "
                                    L"You can't reassign a NetBIOS domain name in a single"
                                    L"forest restructuring.",
                                    NetBiosName);
                    delete TempGuid;
                    res = FALSE;
                    goto Cleanup;

                }
                if (TempGuid) {
                    delete TempGuid;
                }
            }

            CDomain *Tempdomain = m_descList->LookupByNetbiosName(NetBiosName);
            Tempdomain = Tempdomain->GetNextDomain();
            if (Tempdomain && Tempdomain->LookupByNetbiosName(NetBiosName)) {
                m_Error->SetErr(ERROR_GEN_FAILURE,
                                L"NetBIOS domain name %s occurs twice in the forest description. "
                                L"NetBIOS domain names must be unique.",
                                NetBiosName);
                res = FALSE;
                goto Cleanup;
            }
            
        }

        p = p->GetNextDomain();
    
        if (p && p->LookupByGuid(Guid)) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Domain Guid %s occurs twice in the forest description",
                            Guid);
            res = FALSE;
            goto Cleanup;
        }

        if (Guid) {
            delete Guid;
        }

        // Now lets check the DNS name
        //1. Make sure the name's syntax is correct
        //2. If Dns name is in the forest then it must match the one in the
        // forest description.
        //3. The Dns name must only occure once in the forest description.
        //4. Make sure that there are no gaps in the dns names.
        //5. Make sure that NDNC's are not parents
        //6. Make sure that the root domain is not a child of another domain.
        DNSname = d->GetPrevDnsRoot();
        if (m_Error->isError()) {
            res = FALSE;
            goto Cleanup;
        }

        Win32Err =  DnsValidateName_W(DNSname,
                                      DnsNameDomain);
        
        if (STATUS_SUCCESS         != Win32Err &&
            DNS_ERROR_NON_RFC_NAME != Win32Err)
        {
            m_Error->SetErr(Win32Err,
                            L"Syntax error in DNS domain name %s.",
                            DNSname);
            res = FALSE;
            goto Cleanup;
        }

        Guid = d->GetGuid();
        WCHAR *DomainGuid = NULL;
        if (p = m_DomainList->LookupByPrevDnsRoot(DNSname)) {
            DomainGuid = p->GetGuid();
        }
        
        if (DomainGuid && wcscmp(Guid,DomainGuid)!=0) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"DNS domain name %s in the forest description "
                            L"names a different domain in the current forest. "
                            L"You can't reassign a DNS domain name in a single"
                            L"forest restructuring.",
                            DNSname);
            res = FALSE;
            goto Cleanup;
        }

        if (DomainGuid) {
            delete DomainGuid;
        }


    
        if (Guid) {
            delete Guid;
            Guid = NULL;
        }
        if (NetBiosName) {
            delete NetBiosName;
            NetBiosName = NULL;
        }
        if (DNSname) {
            delete DNSname;
            DNSname = NULL;
        }

        d = d->GetNextDomain();

    }




    
    Cleanup:
    if (Guid) {
        delete Guid;
    } 
    if (NetBiosName) {
        delete NetBiosName;
    }
    if (DNSname) {
        delete DNSname;
    }
    
    return res;

}

BOOL CEnterprise::DomainToXML(CDomain *d)
{
    return m_xmlgen->AddDomain(d);
}


BOOL CEnterprise::ScriptTreeFlatting(CDomain *d)
{
    BOOL ret = TRUE;
    WCHAR *Path = NULL;
    WCHAR *Guid = NULL;
    WCHAR *ToPath = NULL;
    WCHAR *ToPathTemplate = L"DC=%s,DC=INVALID";

    if (!d) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"ScriptTreeFlatting did not recieve a valid domain");
    }

    Path = d->GetDomainDnsObject()->GetDN();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    Guid = d->GetDomainDnsObject()->GetGuid();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    
    ToPath = new WCHAR[wcslen(ToPathTemplate)+
                              wcslen(Guid)+1];
    if (!ToPath) {
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(ToPath,
             ToPathTemplate,
             Guid);
    
    m_xmlgen->Move(Path,ToPath);
    if (m_Error->isError()) {
        ret = FALSE;
    }

    Cleanup:

    if (ToPath) {
        delete ToPath;
    }
    if (Path) {
        delete Path;
    }
    if (Guid) {
        delete Guid;
    }
    
    return ret;
}

BOOL CEnterprise::GenerateDcList()
{
    if (m_Opts->ShouldUpLoadScript()) 
    {
        if (!m_DcList.GenerateDCListFromEnterprise(m_hldap,
                                                   m_ConfigNC->GetDN())) 
        {
            return FALSE;
        }
    }

    if (!m_xmlgen->StartDcList()) {
        return FALSE;
    }

    if (!m_DcList.HashstoXML(m_xmlgen)) {
        return FALSE;
    }

    CDc *dc = m_DcList.GetFirstDc();

    while (dc) 
    {
        if (!m_xmlgen->DctoXML(dc)) {
            return FALSE;
        }

        dc = dc->GetNextDC();
    }

    if (!m_xmlgen->EndDcList()) {
        return FALSE;
    }

    return TRUE;

}

BOOL CEnterprise::GenerateDomainList()
{
    if (!m_xmlgen->StartDomainList()) {
        return FALSE;
    }

    if (!SetAction(&CEnterprise::DomainToXML)) {
        return FALSE;
    }
    if (!TraverseDomainsChildBeforeParent()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    }

    if (!m_xmlgen->EndDomainList()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CEnterprise::TestTrusts(CDomain *domain)
{
    CTrustedDomain    *TDO = domain->GetTrustedDomainList();
    CInterDomainTrust *ITA = domain->GetInterDomainTrustList();

    WCHAR *DomainGuid = domain->GetGuid();

    BOOL  ret = TRUE;
    WCHAR *Guidprefix = L"guid:";
    WCHAR *Guid = NULL;
    WCHAR *GuidPath = NULL;
    WCHAR *Sid = NULL;
    WCHAR *DNprefix = NULL;
    WCHAR *DomainDNS = NULL;
    WCHAR *DNRoot = NULL;
    WCHAR *DomainDN = NULL;
    WCHAR *DNSRoot = NULL;
    WCHAR *TrustPath = NULL;
    WCHAR *NetBiosName = NULL;
    WCHAR *samAccountName = NULL;
    WCHAR *TDOTempate = L"CN=%ws,CN=System,%ws";
    WCHAR *TDODN      = NULL;
    WCHAR errMessage[1024] = {0};

    //run test only if DC host the domain
    //we are testing.
    m_xmlgen->ifInstantiated(DomainGuid);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    DNSRoot = domain->GetDnsRoot();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    DNRoot = DNSRootToDN(DNSRoot);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    //Do all nessary tests for Trusted domains
    while (TDO) {
        
        Guid = TDO->GetTrustDsName()->GetGuid();
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
    
        GuidPath = new WCHAR[wcslen(Guidprefix)+
                             wcslen(Guid)+1];
        if (!GuidPath) {
            ret = FALSE;
            goto Cleanup;
        }
    
        wcscpy(GuidPath,Guidprefix);
        wcscat(GuidPath,Guid);

        wsprintf(errMessage,
                 L"The object %ws was not found",
                 Guid);
    
        if (!m_xmlgen->Instantiated(GuidPath,
                                    errMessage))
        {
            ret = FALSE;
            goto Cleanup;
        }
    
        Sid = TDO->GetTrustPartner()->GetDomainDnsObject()->GetSid();
        if (m_Error->isError()) 
        {
            ret = FALSE;
            goto Cleanup;
        }

        /*if (!m_xmlgen->Not())
        {
            ret = FALSE;
            goto Cleanup;
        } */

        wsprintf(errMessage,
                 L"The securityIdentifier attribute on object %ws does not have the expect value of %ws",
                 Guid,
                 Sid);
                                              
        if (!m_xmlgen->Compare(GuidPath,
                               L"securityIdentifier",
                               Sid,
                               errMessage))
        {
            ret = FALSE;
            goto Cleanup;
        }

        /*if (!m_xmlgen->EndNot()) 
        {
            ret = FALSE;
            goto Cleanup;
        } */
    
        if (TDO->GetTrustPartner()->isDnsNameRenamed()) {

            DomainDNS = TDO->GetTrustPartner()->GetDnsRoot();
            if (m_Error->isError()) {
                ret = FALSE;
                goto Cleanup;
            }
        
            DomainDN = DNSRootToDN(DomainDNS);
            if (m_Error->isError()) {
                ret = FALSE;
                goto Cleanup;
            }
    
            TDODN = new WCHAR[wcslen(TDOTempate)+
                              wcslen(DomainDNS)+
                              wcslen(DomainDN)+1];
            if (!TDODN) {
                ret = FALSE;
                goto Cleanup;
            }
    
            wsprintf(TDODN,
                     TDOTempate,
                     DomainDNS,
                     DomainDN);

            if (!m_xmlgen->Not()) {
                ret = FALSE;
                goto Cleanup;
            }

            wsprintf(errMessage,
                     L"The object %ws already exists",
                     Guid);
    
            if (!m_xmlgen->Instantiated(TDODN,
                                        errMessage))
            {
                ret = FALSE;
                goto Cleanup;
            }

            if (!m_xmlgen->EndNot()) {
                ret = FALSE;
                goto Cleanup;
            }
    
    
        }

        if (DomainDNS) {
            delete DomainDNS;
            DomainDNS = NULL;
        }
        if (DomainDN) {
            delete DomainDN;
            DomainDN = NULL;
        }
    
        if (GuidPath) {
            delete GuidPath;
            GuidPath = NULL;
        }
        if (Guid) {
            delete Guid;
            Guid = NULL;
        }
        if (Sid) {
            delete Sid;
            Sid = NULL;
        }
        if (DomainDNS) {
            delete DomainDNS;
            DomainDNS = NULL;
        }
        if (DomainGuid) {
            delete DomainGuid;
            DomainGuid = NULL;
        }
        if (TDODN) {
            delete TDODN;
            TDODN = NULL;
        }
        
        TDO = (CTrustedDomain*)TDO->GetNext();
    }

    //do all test for interdomain trusted 
    while (ITA) {

        Guid = ITA->GetTrustDsName()->GetGuid();
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
    
        GuidPath = new WCHAR[wcslen(Guidprefix)+
                             wcslen(Guid)+1];
        if (!GuidPath) {
            ret = FALSE;
            goto Cleanup;
        }
    
        wcscpy(GuidPath,Guidprefix);
        wcscat(GuidPath,Guid);

        wsprintf(errMessage,
                 L"The object %ws was not found",
                 Guid);

        if (!m_xmlgen->Instantiated(GuidPath,
                                    errMessage))
        {
            ret = FALSE;
            goto Cleanup;
        }

        NetBiosName = ITA->GetTrustPartner()->GetPrevNetBiosName();
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        // +2 for the L'$' and the L'\0'
        samAccountName = new WCHAR[wcslen(NetBiosName)+2];
        if (!samAccountName) {
            ret = FALSE;
            goto Cleanup;
        }

        wcscpy(samAccountName,NetBiosName);
        wcscat(samAccountName,L"$");

        wsprintf(errMessage,
                 L"The samAccountName attribute on object %ws does not have the expect value of %ws",
                 Guid,
                 samAccountName);

        if (!m_xmlgen->Compare(GuidPath,
                               L"samAccountName",
                               samAccountName,
                               errMessage)) 
        {
            ret = FALSE;
            goto Cleanup;
        }

        if (ITA->GetTrustPartner()->isNetBiosNameRenamed()) {
            
            DNprefix = ITA->GetTrustDsName()->GetDN();
            if (m_Error->isError()) {
                ret = FALSE;
                goto Cleanup;
            }
    
            if (ULONG err = RemoveRootofDn(DNprefix)) {
                m_Error->SetErr(LdapMapErrorToWin32(err),
                                ldap_err2stringW(err));
                ret = FALSE;
                goto Cleanup;
            }

            TrustPath = new WCHAR[wcslen(DNprefix)+
                                  wcslen(DNRoot)+1];
            if (!TrustPath) {
                ret = FALSE;
                goto Cleanup;
            }
    
            wcscpy(TrustPath,DNprefix);
            wcscat(TrustPath,DNRoot);

            if (!m_xmlgen->Not()) 
            {
                ret = FALSE;
                goto Cleanup;
            }

            wsprintf(errMessage,
                     L"The object %ws already exists",
                     TrustPath);

            if (!m_xmlgen->Instantiated(TrustPath,
                                        errMessage))
            {
                ret = FALSE;
                goto Cleanup;    
            }

            if (!m_xmlgen->EndNot()) 
            {
                ret = FALSE;
                goto Cleanup;
            }

        }

        if (NetBiosName) {
            delete NetBiosName;
            NetBiosName = NULL;
        }

        if (TrustPath) {
            delete TrustPath;
            TrustPath = NULL;
        }

        if (samAccountName) {
            delete samAccountName;
            samAccountName = NULL;
        }

        if (DNprefix) {
            delete DNprefix;
            DNprefix = NULL;
        }

        if (GuidPath) {
            delete GuidPath;
            GuidPath = NULL;
        }
        if (Guid) {
            delete Guid;
            Guid = NULL;
        }

        ITA = (CInterDomainTrust*)ITA->GetNext();
    
    }

    if (!m_xmlgen->EndifInstantiated()) 
    {
        ret = FALSE;
        goto Cleanup;
    }
    
    Cleanup:

    if (NetBiosName) {
        delete NetBiosName;
        NetBiosName = NULL;
    }

    if (GuidPath) {
        delete GuidPath;
        GuidPath = NULL;
    }
    if (DNRoot) {
        delete DNRoot;
        DNRoot = NULL;
    }
    if (Guid) {
        delete Guid;
        Guid = NULL;
    }
    if (Sid) {
        delete Sid;
        Sid = NULL;
    }
    if (TrustPath) {
        delete TrustPath;
        TrustPath = NULL;
    }
    if (DomainDNS) {
        delete DomainDNS;
        DomainDNS = NULL;
    }
    if (DomainGuid) {
        delete DomainGuid;
        DomainGuid = NULL;
    }
    if (TDODN) {
        delete TDODN;
        TDODN = NULL;
    }
    if (DNprefix) {
        delete DNprefix;
        DNprefix = NULL;
    }
    if (DNSRoot) {
        delete DNSRoot;
        DNSRoot = NULL;
    }
    if (DomainDNS) {
        delete DomainDNS;
    }
    if (DomainDN) {
        delete DomainDN;
    }

    if (m_Error->isError()) {
        ret = FALSE;
    }

    return ret;
    
}

BOOL CEnterprise::WriteTest()
{

    DWORD ret = ERROR_SUCCESS;
    WCHAR *ConfigDN = NULL;
    WCHAR *PartitionsRDN = L"CN=Partitions,";
    WCHAR *Guidprefix = L"guid:";
    WCHAR *Guid = NULL;
    WCHAR *GuidPath = NULL;
    WCHAR *Path = NULL;
    WCHAR *NetBiosName = NULL;
    WCHAR *CrossrefTemplate = L"CN=%ws,%ws";
    WCHAR *newCrossref = NULL;
    WCHAR *DN =NULL;
    DWORD NumCrossrefs = 0;
    WCHAR wsNumCrossrefs[20] = {0};
    CDomain *d = NULL;
    WCHAR errMessage[1024] = {0};

    Guid = m_ConfigNC->GetGuid();
    if (m_Error->isError()) 
    {
        ret = FALSE;
        goto Cleanup;
    }

    GuidPath = new WCHAR[wcslen(Guidprefix)+
                         wcslen(Guid)+1];
    if (!GuidPath) {
        ret = FALSE;
        goto Cleanup;
    }

    wcscpy(GuidPath,Guidprefix);
    wcscat(GuidPath,Guid);

    if (!m_xmlgen->Instantiated(GuidPath,
                                L"The Configuration container does not exist")) 
    {
        ret = FALSE;
        goto Cleanup;
    }

    if (Guid) {
        delete Guid;
    }
    if (GuidPath) {
        delete GuidPath;
    }
    
    WCHAR *ReplicationEpoch = new WCHAR[9];
    if (!ReplicationEpoch) {
        m_Error->SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    wsprintf(ReplicationEpoch,
             L"%d",
             m_maxReplicationEpoch+1);

    if (!m_xmlgen->Not()) 
    {
        ret = FALSE;
        goto Cleanup;
    }

    if (!m_xmlgen->Compare(L"$LocalNTDSSettingsObjectDN$",
                  L"msDS-ReplicationEpoch",
                  ReplicationEpoch,
                  L"Action already performed"))
    {
        ret = FALSE;
        goto Cleanup;
    }

    if (!m_xmlgen->EndNot()) 
    {
        ret = FALSE;
        goto Cleanup;
    }
    
    ConfigDN = m_ConfigNC->GetDN();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    Path = new WCHAR[wcslen(PartitionsRDN)+
                     wcslen(ConfigDN)+1];
    if (!Path) {
        m_Error->SetMemErr();
        ret = FALSE;
    }
    
    wcscpy(Path,PartitionsRDN);
    wcscat(Path,ConfigDN);

    d = m_DomainList;

    //for every crossref assert that it still exists.
    while (d) {

        if (d->isDomain()) {
            NumCrossrefs++;
        }

        Guid = d->GetDomainCrossRef()->GetGuid();
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
    
        GuidPath = new WCHAR[wcslen(Guidprefix)+
                             wcslen(Guid)+1];
        if (!GuidPath) {
            ret = FALSE;
            goto Cleanup;
        }

        wcscpy(GuidPath,Guidprefix);
        wcscat(GuidPath,Guid);

        DN = d->GetDomainDnsObject()->GetDN();
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        wsprintf(errMessage,
                 L"The object %ws was not found",
                 Guid);

        if (!m_xmlgen->Instantiated(GuidPath,
                                    errMessage)) 
        {
            ret = FALSE;
            goto Cleanup;
        }

        wsprintf(errMessage,
                 L"The ncName Attribute on object %ws does not have the expected value of %ws",
                 Guid,
                 DN);
    
        if (!m_xmlgen->Compare(GuidPath,
                              L"NcName",
                              DN,
                              errMessage))
        {
            ret = FALSE;
            goto Cleanup;
        }

        //If the netbiosname is being renamed then make sure that 
        //there will not be a naming confict.
        if (d->isDomain() && d->isNetBiosNameRenamed()) {

            NetBiosName = d->GetNetBiosName();
            if (m_Error->isError()) 
            {
                ret = FALSE;
                goto Cleanup;
            }

            newCrossref = new WCHAR[wcslen(CrossrefTemplate)+
                                    wcslen(NetBiosName)+
                                    wcslen(Path)+1];

            wsprintf(newCrossref,
                     CrossrefTemplate,
                     NetBiosName,
                     Path);

            if (!m_xmlgen->Not()) 
            {
                ret = FALSE;
                goto Cleanup;
            }

            wsprintf(errMessage,
                     L"The object %ws already exists",
                     newCrossref);

            if (!m_xmlgen->Instantiated(newCrossref,
                                        errMessage))
            {
                ret = FALSE;
                goto Cleanup;
            }

            if (!m_xmlgen->EndNot()) 
            {
                ret = FALSE;
                goto Cleanup;
            }
        
        } 

        if (!TestTrusts(d))
        {
            ret = FALSE;
            goto Cleanup;
        }

        if (newCrossref) {
            delete newCrossref;
            newCrossref = NULL;
        }
        if (NetBiosName) {
            delete NetBiosName;
            NetBiosName = NULL;
        }

        if (GuidPath) {
            delete GuidPath;
            GuidPath = NULL;
        }
        if (Guid) {
            delete Guid;
            Guid = NULL;
        }
        if (DN) {
            delete DN;
            DN = NULL;
        }

        d = d->GetNextDomain();

    }
    
    _itow(NumCrossrefs,wsNumCrossrefs,10);

    if (!m_xmlgen->Cardinality(Path,
                               wsNumCrossrefs)) 
    {
        ret = FALSE;
        goto Cleanup;
    }

    Cleanup:

    if (Path) {
        delete Path;
    }
    if (newCrossref) {
        delete newCrossref;
    }
    if (NetBiosName) {
        delete NetBiosName;
    }

    if (ConfigDN) {
        delete ConfigDN;
    }

    if (GuidPath) {
        delete GuidPath;
    }
    if (Guid) {
        delete Guid;
    }

    if (ReplicationEpoch) {
        delete ReplicationEpoch;
    }

    if (m_Error->isError()) {
        ret=FALSE;
    }

    return ret;
}  

BOOL CEnterprise::GenerateReNameScript()
{

    m_xmlgen->StartScript();

    //write the initial test.
    m_xmlgen->StartAction(L"Test Enterprise State",TRUE);

    WriteTest();

    m_xmlgen->EndAction();

    //generate the instructions to flatten the trees
    m_xmlgen->StartAction(L"Flatten Trees",FALSE);

    if (!SetAction(&CEnterprise::ScriptTreeFlatting)) {
        return FALSE;
    }
    if (!TraverseDomainsChildBeforeParent()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    }

    m_xmlgen->EndAction();

    //generate the instruction to build the new trees.
    m_xmlgen->StartAction(L"Rename Domains",FALSE);

    if (!SetAction(&CEnterprise::ScriptDomainRenaming)) {
        return FALSE;
    }
    if (!TraverseDomainsParentBeforeChild()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    }

    m_xmlgen->EndAction();

    m_xmlgen->StartAction(L"Fix Crossrefs",FALSE);

    if (!FixMasterCrossrefs()) {
        return FALSE;
    }

    if (!SetAction(&CEnterprise::ScriptFixCrossRefs)) {
        return FALSE;
    }
    if (!TraverseDomainsParentBeforeChild()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    } 

    m_xmlgen->EndAction();

    m_xmlgen->StartAction(L"Fix Trusted Domains",FALSE);

    if (!SetAction(&CEnterprise::ScriptFixTrustedDomains)) {
        return FALSE;
    }
    if (!TraverseDomainsParentBeforeChild()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    } 

    m_xmlgen->EndAction();

    m_xmlgen->StartAction(L"Advance ReplicationEpoch",FALSE);

    if (!ScriptAdvanceReplicationEpoch()) {
        return FALSE;
    }
    
    m_xmlgen->EndAction();

    m_xmlgen->EndScript();

    return TRUE;

}

BOOL CEnterprise::HandleNDNCCrossRef(CDomain *d)
{
    BOOL ret = TRUE;
    DWORD err = ERROR_SUCCESS;
    WCHAR *DNSRoot = NULL;
    WCHAR *Path = NULL;
    WCHAR *Guid = NULL;
    WCHAR *CrossrefDN = NULL;
    WCHAR *newForestRootDN = NULL;
    WCHAR *PathTemplate = L"CN=%s,CN=Partitions,CN=Configuration,%s";

    DNSRoot = m_ForestRoot->GetDnsRoot();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    CrossrefDN = d->GetDomainCrossRef()->GetDN();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    err = GetRDNWithoutType(CrossrefDN,
                            &Guid);
    if (err)
    {
        ret = FALSE;
        m_Error->SetErr(err,
                        L"Could not get the RDN for the NDNC Crossref\n");
        goto Cleanup;
    }

    //get the Guid out of the DN name 
    
    CXMLAttributeBlock *atts[2];
    atts[0] = NULL;
    atts[1] = NULL;

    atts[0] = new CXMLAttributeBlock(L"DnsRoot",
                                     d->GetDnsRoot());
    if (!atts[0] || m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    atts[1] = NULL;

    newForestRootDN = DNSRootToDN(DNSRoot);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    //change the DNSRoot attribute of the configuration crossref.
    Path = new WCHAR[wcslen(PathTemplate)+
                     wcslen(Guid)+
                     wcslen(newForestRootDN)+1];
    if (!Path) {
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(Path,
             PathTemplate,
             Guid,
             newForestRootDN);

    m_xmlgen->Update(Path,
                     atts);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    Cleanup:

    if (DNSRoot) {
        delete DNSRoot;
    }
    if (Path) {
        delete Path;
    }
    if (CrossrefDN) {
        delete CrossrefDN;
    }
    if (newForestRootDN) {
        delete newForestRootDN;
    }
    if (atts[0]) {
        delete atts[0];
    }
    if (Guid) {
        delete Guid;
    }

    return ret;
}

BOOL CEnterprise::ScriptAdvanceReplicationEpoch()
{
    BOOL ret = TRUE;
    WCHAR *ReplicationEpoch = NULL;
    CXMLAttributeBlock *atts[2];
    atts[0] = NULL;
    atts[1] = NULL;

    //I am assume no more than (1*(10^9))-1 changes of this type will be made.
    ReplicationEpoch = new WCHAR[9];
    if (!ReplicationEpoch) {
        m_Error->SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    wsprintf(ReplicationEpoch,
             L"%d",
             m_maxReplicationEpoch+1);
    
    atts[0] = new CXMLAttributeBlock(L"msDS-ReplicationEpoch",
                                     ReplicationEpoch);
    if (!atts[0] || m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    atts[1] = NULL;

    m_xmlgen->Update(L"$LocalNTDSSettingsObjectDN$",
                     atts);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    Cleanup:

    if (atts[0]) {
        delete atts[0];
    }

    return ret;

}

BOOL CEnterprise::ScriptFixTrustedDomains(CDomain *d)
{
    if (!d->isDomain()) {
        //This is an NDNC no action needs to 
        //be taken
        return TRUE;
    }

    BOOL ret = TRUE;
    WCHAR *Guid = NULL;
    CTrustedDomain *td = NULL;
    CInterDomainTrust *idt = NULL;
    WCHAR *PathTemplate = L"CN=%s,CN=System,%s";
    WCHAR *ToPathTemplate = L"CN=%s,%s";

    WCHAR *RootPath = NULL;
    WCHAR *ToPath = NULL;
    WCHAR *DNSRoot = NULL;
    WCHAR *OldTrustRDN = NULL;
    WCHAR *newTrustRDN = NULL;
    WCHAR *newRootDN = NULL; 
    WCHAR *NewPathSuffex = NULL;
    CXMLAttributeBlock *atts[3];
    atts[0] = NULL;
    atts[1] = NULL;
    atts[2] = NULL;

    WCHAR *DNprefix = NULL;
    WCHAR *DNRoot = NULL;
    WCHAR *TrustPath = NULL;
    WCHAR *samAccountName = NULL;
    WCHAR *NetBiosName = NULL;

    Guid = d->GetDomainDnsObject()->GetGuid();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    m_xmlgen->ifInstantiated(Guid);

    td = d->GetTrustedDomainList();
    while (td) {
        
        atts[0] = new CXMLAttributeBlock(L"flatName",
                                         td->GetTrustPartner()->GetNetBiosName());
        if (!atts[0] || m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        atts[1] = new CXMLAttributeBlock(L"trustPartner",
                                         td->GetTrustPartner()->GetDnsRoot());
        if (!atts[1] || m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        atts[2] = NULL;

        if ( TRUST_TYPE_DOWNLEVEL == td->GetTrustType()) {
            OldTrustRDN = td->GetTrustPartner()->GetPrevNetBiosName();
        } else {
            OldTrustRDN = td->GetTrustPartner()->GetPrevDnsRoot();    
        } 
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        DNSRoot = d->GetDnsRoot();
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
    
        newRootDN = DNSRootToDN(DNSRoot);
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        RootPath = new WCHAR[wcslen(OldTrustRDN)+
                             wcslen(PathTemplate)+
                             wcslen(newRootDN)+1];
        if (!RootPath) {
            ret = FALSE;
            goto Cleanup;
        }

        wsprintf(RootPath,
                 PathTemplate,
                 OldTrustRDN,
                 newRootDN);

        
        m_xmlgen->Update(RootPath,
                         atts);
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        if ( TRUST_TYPE_DOWNLEVEL == td->GetTrustType()) {
            newTrustRDN = td->GetTrustPartner()->GetNetBiosName();
        } else {
            newTrustRDN = td->GetTrustPartner()->GetDnsRoot();
        }
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        ToPath = new WCHAR[wcslen(newTrustRDN)+
                           wcslen(PathTemplate)+
                           wcslen(newRootDN)+1];
        if (!ToPath) {
            ret = FALSE;
            goto Cleanup;
        }
    
        
        wsprintf(ToPath,
                 PathTemplate,
                 newTrustRDN,
                 newRootDN);

        m_xmlgen->Move(RootPath,
                       ToPath);
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        if (RootPath) {
            delete RootPath;
            RootPath = NULL;
        }
        if (ToPath) {
            delete ToPath;
            ToPath = NULL;
        }
        if (DNSRoot) {
            delete DNSRoot;
            DNSRoot = NULL;
        }
        if (newTrustRDN) {
            delete newTrustRDN;
            newTrustRDN = NULL;
        }
        if (OldTrustRDN) {
            delete OldTrustRDN;
            OldTrustRDN = NULL;
        }
        if (newRootDN) {
            delete newRootDN;
            newRootDN = NULL;
        }
        if (atts[0]) {
            delete atts[0];
            atts[0] = NULL;
        }
        if (atts[1]) {
            delete atts[1];
            atts[1] = NULL;
        }
        
        td = (CTrustedDomain*)td->GetNext();
    }

    idt = d->GetInterDomainTrustList();
    while (idt) {

        NetBiosName = idt->GetTrustPartner()->GetNetBiosName();
        if (m_Error->isError()) {
            goto Cleanup;
        }

        // +2 for the L'$' and the L'\0'
        samAccountName = new WCHAR[wcslen(NetBiosName)+2];
        if (!samAccountName) {
            m_Error->SetMemErr();
            goto Cleanup;
        }

        wcscpy(samAccountName,NetBiosName);
        wcscat(samAccountName,L"$");

        //samAccountName should not be freed this will be handled
        //by CXMLAttributeBlock.  It is important not to use samAccountName
        //after it has be Freed by CXMLAttributeBlock
        atts[0] = new CXMLAttributeBlock(L"samAccountName",
                                         samAccountName);
        if (!atts[0] || m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        atts[1] = NULL;


        DNprefix = idt->GetTrustDsName()->GetDN();
        if (m_Error->isError()) {
            goto Cleanup;
        }

        if (ULONG err = RemoveRootofDn(DNprefix)) {
            m_Error->SetErr(LdapMapErrorToWin32(err),
                                ldap_err2stringW(err));
            goto Cleanup;
        }

        DNSRoot = d->GetDnsRoot();
        if (m_Error->isError()) {
            goto Cleanup;
        }

        DNRoot = DNSRootToDN(DNSRoot);

        TrustPath = new WCHAR[wcslen(DNprefix)+
                              wcslen(DNRoot)+1];

        wcscpy(TrustPath,DNprefix);
        wcscat(TrustPath,DNRoot);

        m_xmlgen->Update(TrustPath,
                         atts);
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        DWORD err = TrimDNBy(TrustPath,
                             1,
                             &NewPathSuffex);
        if (ERROR_SUCCESS != err) {
            m_Error->SetErr(err,
                            L"Failed to Trim DN %s",
                            TrustPath);
            goto Cleanup;
        }

        ToPath = new WCHAR[wcslen(samAccountName)+
                           wcslen(ToPathTemplate)+
                           wcslen(NewPathSuffex)+1];
        if (!ToPath) {
            goto Cleanup;
        }

        wsprintf(ToPath,
                 ToPathTemplate,
                 samAccountName,
                 NewPathSuffex);

        
        m_xmlgen->Move(TrustPath,
                       ToPath);
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        if (DNprefix) {
            delete DNprefix;
            DNprefix = NULL;
        }
        if (DNRoot) {
            delete DNRoot;
            DNRoot = NULL;
        }
        if (TrustPath) {
            delete TrustPath;
            TrustPath = NULL;
        }
        if (NetBiosName) {
            delete NetBiosName;
            NetBiosName = NULL;
        }
        if (DNSRoot) {
            delete DNSRoot;
            DNSRoot = NULL;
        }
        if (ToPath) {
            delete ToPath;
            ToPath = NULL;
        }
        if (NewPathSuffex) {
            delete NewPathSuffex;
            NewPathSuffex = NULL;
        }
        if (atts[0]) {
            delete atts[0];
            atts[0] = NULL;
        }
        if (samAccountName) {
            samAccountName = NULL;
        }
        
        idt = (CInterDomainTrust*)idt->GetNext();
    }
    
    m_xmlgen->EndifInstantiated();

    Cleanup:

    if (Guid) {
        delete Guid;
    }
    if (RootPath) {
        delete RootPath;
        RootPath = NULL;
    }
    if (ToPath) {
        delete ToPath;
        ToPath = NULL;
    }
    if (DNSRoot) {
        delete DNSRoot;
        DNSRoot = NULL;
    }
    if (newTrustRDN) {
        delete newTrustRDN;
        newTrustRDN = NULL;
    }
    if (OldTrustRDN) {
        delete OldTrustRDN;
        OldTrustRDN = NULL;
    }
    if (newRootDN) {
        delete newRootDN;
        newRootDN = NULL;
    }
    if (DNprefix) {
        delete DNprefix;
        DNprefix = NULL;
    }
    if (DNRoot) {
        delete DNRoot;
        DNRoot = NULL;
    }
    if (TrustPath) {
        delete TrustPath;
        TrustPath = NULL;
    }
    if (NetBiosName) {
        delete NetBiosName;
        NetBiosName = NULL;
    }
    if (NewPathSuffex) {
        delete NewPathSuffex;
        NewPathSuffex = NULL;
    }
    if (atts[0]) {
        delete atts[0];
        atts[0] = NULL;
    }
    
    return ret;
    
}

BOOL CEnterprise::ScriptFixCrossRefs(CDomain *d)
{
    //if the domain passed in is the Forest Root
    //We will skip it since it is handled elsewhere
    if (m_ForestRoot == d) {
        return TRUE;
    }
    if (!d->isDomain()) {
        //This is a NDNC We need to handle this
        //differently from the other crossrefs
        return HandleNDNCCrossRef(d);
    }

    BOOL ret = TRUE;
    WCHAR *DNSRoot = NULL;
    WCHAR *PrevNetBiosName = NULL;
    WCHAR *RootPath = NULL;
    WCHAR *newRootDN = NULL;
    WCHAR *ParentNetBiosName = NULL;
    WCHAR *ParentCrossRef = NULL;
    WCHAR *forestRootNetBiosName = NULL;
    WCHAR *forestRootCrossRef = NULL;
    WCHAR *forestRootDNS = NULL;
    WCHAR *forestRootDN = NULL;
    WCHAR *ToPath = NULL;
    WCHAR *NetBiosName = NULL;
    WCHAR *PathTemplate = L"CN=%s,CN=Partitions,CN=Configuration,%s";

    CXMLAttributeBlock *atts[6];
    atts[0] = NULL;
    atts[1] = NULL;
    atts[2] = NULL;
    atts[3] = NULL;
    atts[4] = NULL;
    atts[5] = NULL;
    

    DNSRoot = m_ForestRoot->GetDnsRoot();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    newRootDN = DNSRootToDN(DNSRoot);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    PrevNetBiosName = d->GetPrevNetBiosName();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }


    RootPath = new WCHAR[wcslen(PrevNetBiosName)+
                         wcslen(PathTemplate)+
                         wcslen(newRootDN)+1];
    if (!RootPath) {
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(RootPath,
             PathTemplate,
             PrevNetBiosName,
             newRootDN);

    if (d->GetParent()) {
        //This is a child Domain therefore we need to setup
        //the TrustParent for this crossref
        ParentNetBiosName = d->GetParent()->GetNetBiosName();
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        ParentCrossRef = new WCHAR[wcslen(ParentNetBiosName)+
                                   wcslen(newRootDN)+
                                   wcslen(PathTemplate)+1];
        if ((!ParentCrossRef) || m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        wsprintf(ParentCrossRef,
                 PathTemplate,
                 ParentNetBiosName,
                 newRootDN);
        
    } else {
        //this is a Root of a tree but not the forest root
        //setup the RootTrust
        forestRootNetBiosName = m_ForestRoot->GetNetBiosName();
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        forestRootDNS = m_ForestRoot->GetDnsRoot();
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        forestRootDN = DNSRootToDN(forestRootDNS);
        if (m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        forestRootCrossRef = new WCHAR[wcslen(forestRootNetBiosName)+
                                   wcslen(forestRootDN)+
                                   wcslen(PathTemplate)+1];
        if ((!forestRootCrossRef) || m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        wsprintf(forestRootCrossRef,
                 PathTemplate,
                 forestRootNetBiosName,
                 forestRootDN);

    }


    atts[0] = new CXMLAttributeBlock(L"DnsRoot",
                                     d->GetDnsRoot());
    if (!atts[0] || m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    atts[1] = new CXMLAttributeBlock(L"NetBiosName",
                                     d->GetNetBiosName());
    if (!atts[1] || m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    atts[2] = new CXMLAttributeBlock(L"TrustParent",
                                     ParentCrossRef);
    if (!atts[2] || m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    atts[3] = new CXMLAttributeBlock(L"RootTrust",
                                     forestRootCrossRef);
    if (!atts[3] || m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    if (d->isDnsNameRenamed()) {
        atts[4] = new CXMLAttributeBlock(L"msDS-DnsRootAlias",
                                         d->GetPrevDnsRoot());
        if (!atts[4] || m_Error->isError()) {
            ret = FALSE;
            goto Cleanup;
        }
    } else {
        atts[4] = NULL;
    }
    atts[5] = NULL;

    m_xmlgen->Update(RootPath,
                     atts);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    NetBiosName = d->GetNetBiosName();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    ToPath = new WCHAR[wcslen(NetBiosName)+
                       wcslen(PathTemplate)+
                       wcslen(newRootDN)+1];
    if (!ToPath) {
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(ToPath,
             PathTemplate,
             NetBiosName,
             newRootDN);

    m_xmlgen->Move(RootPath,
                   ToPath);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    Cleanup:

    if (DNSRoot) {
        delete DNSRoot;
    }
    if (NetBiosName) {
        delete NetBiosName;
    }
    if (ToPath) {
        delete ToPath;
    }
    if (PrevNetBiosName) {
        delete PrevNetBiosName;
    }
    if (RootPath) {
        delete RootPath;
    }
    if (newRootDN) {
        delete newRootDN;
    }
    if (ParentNetBiosName) {
        delete ParentNetBiosName;
    }
    if (forestRootNetBiosName) {
        delete ParentNetBiosName;
    }
    if (forestRootDNS) {
        delete forestRootDNS;
    }
    if (forestRootDN) {
        delete forestRootDN;
    }
    if (atts[0]) {
        delete atts[0];
    }
    if (atts[1]) {
        delete atts[1];
    }
    if (atts[2]) {
        delete atts[2];
    }
    if (atts[3]) {
        delete atts[3];
    }
    if (atts[4]) {
        delete atts[4];
    }
    
    return ret;

}

BOOL CEnterprise::FixMasterCrossrefs()
{
    BOOL ret = TRUE;
    WCHAR *ConfigPath = NULL;
    WCHAR *SchemaPath = NULL;
    WCHAR *ForestRootPath = NULL;
    WCHAR *DNSRoot = NULL;
    WCHAR *PrevNetBiosName = NULL;
    WCHAR *NetBiosName = NULL;
    WCHAR *newForestRootDN = NULL;
    WCHAR *ToPath = NULL;
    WCHAR *ConfigPathTemplate = L"CN=Enterprise Configuration,CN=Partitions,CN=Configuration,%s";
    WCHAR *SchemaPathTemplate = L"CN=Enterprise Schema,CN=Partitions,CN=Configuration,%s";
    WCHAR *ForestRootPathTemplate = L"CN=%s,CN=Partitions,CN=Configuration,%s";

    DNSRoot = m_ForestRoot->GetDnsRoot();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    CXMLAttributeBlock *atts[4];
    atts[0] = NULL;
    atts[1] = NULL;
    atts[2] = NULL;
    atts[3] = NULL;
    
    atts[0] = new CXMLAttributeBlock(L"DnsRoot",
                                     m_ForestRoot->GetDnsRoot());
    if (!atts[0] || m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    atts[1] = NULL;

    newForestRootDN = DNSRootToDN(DNSRoot);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    //change the DNSRoot attribute of the configuration crossref.
    ConfigPath = new WCHAR[wcslen(ConfigPathTemplate)+
                           wcslen(newForestRootDN)+1];
    if (!ConfigPath) {
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(ConfigPath,
             ConfigPathTemplate,
             newForestRootDN);

    m_xmlgen->Update(ConfigPath,
                     atts);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }


    //change the DNSRoot attribute of the schema crossref.
    SchemaPath = new WCHAR[wcslen(SchemaPathTemplate)+
                           wcslen(newForestRootDN)+1];
    if (!ConfigPath) {
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(SchemaPath,
             SchemaPathTemplate,
             newForestRootDN);

    
    m_xmlgen->Update(SchemaPath,
                     atts);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    //Fixup the Forest Root Crossref

    PrevNetBiosName = m_ForestRoot->GetPrevNetBiosName();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    atts[1] = new CXMLAttributeBlock(L"msDS-DnsRootAlias",
                                     m_ForestRoot->GetPrevDnsRoot());
    if (!atts[1] || m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    atts[2] = new CXMLAttributeBlock(L"NetBiosName",
                                     m_ForestRoot->GetNetBiosName());
    if (!atts[2] || m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    atts[3] = NULL;

    ForestRootPath = new WCHAR[wcslen(ForestRootPathTemplate)+
                               wcslen(PrevNetBiosName)+
                               wcslen(newForestRootDN)+1];
    if (!ConfigPath) {
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(ForestRootPath,
             ForestRootPathTemplate,
             PrevNetBiosName,
             newForestRootDN);


    m_xmlgen->Update(ForestRootPath,
                     atts);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    NetBiosName = m_ForestRoot->GetNetBiosName();
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    ToPath = new WCHAR[wcslen(ForestRootPathTemplate)+
                       wcslen(NetBiosName)+
                       wcslen(newForestRootDN)+1];

    wsprintf(ToPath,
             ForestRootPathTemplate,
             NetBiosName,
             newForestRootDN);

    m_xmlgen->Move(ForestRootPath,
                   ToPath);
    if (m_Error->isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    Cleanup:

    if (newForestRootDN) {
        delete newForestRootDN;
    }
    if (PrevNetBiosName) {
        delete PrevNetBiosName;
    }
    if (NetBiosName) {
        delete NetBiosName;
    }
    if (DNSRoot) {
        delete DNSRoot;
    }
    if (ForestRootPath) {
        delete ForestRootPath;
    }
    if (ConfigPath) {
        delete ConfigPath;
    }
    if (SchemaPath) {
        delete SchemaPath;
    }
    if (ToPath) {
        delete ToPath;
    }
    if (atts[0]) {
        delete atts[0];
    }
    if (atts[1]) {
        delete atts[1];
    }
    if (atts[2]) {
        delete atts[2];
    }
    
    return ret;

}

VOID CEnterprise::DumpScript()
{
    m_xmlgen->DumpScript();
}

BOOL CEnterprise::Error()
{
    if (m_Error->isError()) {
        m_Error->PrintError();
        return TRUE;
    }

    return FALSE;
}

VOID CRenDomErr::SetErr(DWORD p_Win32Err,
                        WCHAR* p_ErrStr,
                        ...) {

    WCHAR Errmsg[RENDOM_BUFFERSIZE];
    DWORD count = 0;

    va_list arglist;

    va_start(arglist, p_ErrStr);

    _vsnwprintf(Errmsg,RENDOM_BUFFERSIZE,p_ErrStr,arglist);

    m_Win32Err = p_Win32Err;
    if (m_ErrStr) {
        delete m_ErrStr;
    }
    m_ErrStr = new WCHAR[wcslen(Errmsg)+1];
    if (m_ErrStr) {
        wcscpy(m_ErrStr,Errmsg);
    }

    va_end(arglist);

}

VOID CRenDomErr::AppendErr(WCHAR* p_ErrStr,
                           ...)
{
    if (!m_ErrStr) {
        wprintf(L"Failed to append error due to no error being set.\n");
    }
    WCHAR Errmsg[RENDOM_BUFFERSIZE];
    WCHAR Newmsg[RENDOM_BUFFERSIZE];
    DWORD count = 0;

    va_list arglist;

    va_start(arglist, p_ErrStr);

    _vsnwprintf(Errmsg,RENDOM_BUFFERSIZE,p_ErrStr,arglist);

    wcscpy(Newmsg,m_ErrStr);
    wcscat(Newmsg,L".  \n");
    wcscat(Newmsg,Errmsg);

    if (m_ErrStr) {
        delete m_ErrStr;
    }
    m_ErrStr = new WCHAR[wcslen(Newmsg)+1];
    if (m_ErrStr) {
        wcscpy(m_ErrStr,Newmsg);
    }

    

    va_end(arglist);       
}

VOID CRenDomErr::PrintError() {

    if (m_AlreadyPrinted) {
        return;
    }
    if ((ERROR_SUCCESS != m_Win32Err) && (NULL == m_ErrStr)) {
        wprintf(L"Failed to set error message: %d\r\n",
                m_Win32Err);
    }
    if (ERROR_SUCCESS == m_Win32Err) {
        wprintf(L"Successful\r\n");
    } else {
        wprintf(L"%s: %d\r\n",
                m_ErrStr,
                m_Win32Err);
    }

    m_AlreadyPrinted = TRUE;
}

BOOL CRenDomErr::isError() {
    return ERROR_SUCCESS!=m_Win32Err;
}

VOID CRenDomErr::SetMemErr() {
    SetErr(ERROR_NOT_ENOUGH_MEMORY,
           L"An operation has failed due to lack of memory.\n");
}

DWORD CRenDomErr::GetErr() {
    return m_Win32Err;
}


CDsName::CDsName(WCHAR* p_Guid = 0,
                 WCHAR* p_DN = 0, 
                 WCHAR* p_ObjectSid = 0)
{
    m_ObjectGuid = p_Guid;
    m_DistName = p_DN;
    m_ObjectSid = p_ObjectSid;
    m_Error = new CRenDomErr;
} 

CDsName::~CDsName() 
{
    if (m_ObjectGuid) {
        delete m_ObjectGuid;
    }
    if (m_DistName) {
        delete m_DistName;
    }
    if (m_ObjectSid) {
        delete m_ObjectSid;
    }
    if (m_Error) {
        delete m_Error;
    }
}

/*
CDsName::CDsName(CDsName* dsname)
{
    if (dsname->m_ObjectGuid) {
        m_ObjectGuid = new WCHAR[wcslen(dsname->m_ObjectGuid)+1];
        if (!m_ObjectGuid) {
            throw ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy(m_ObjectGuid,dsname->m_ObjectGuid);
    }
    if (dsname->m_DistName) {
        m_DistName = new WCHAR[wcslen(dsname->m_DistName)+1];
        if (!m_DistName) {
            throw ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy(m_DistName,dsname->m_DistName);
    }
    if (dsname->m_ObjectSid) {
        m_ObjectSid = new WCHAR[wcslen(dsname->m_ObjectSid)+1];
        if (!m_ObjectSid) {
            throw ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy(m_ObjectSid,dsname->m_ObjectSid);
    }
    m_Error = new CRenDomErr();
    if (!m_Error) {
        throw ERROR_NOT_ENOUGH_MEMORY;
    }
    
} */

VOID CDsName::DumpCDsName()
{
    wprintf(L"**************************************\n");
    if (m_ObjectGuid) {
        wprintf(L"Guid: %ws\n",m_ObjectGuid);
    } else {
        wprintf(L"Guid: (NULL)\n");
    }
    
    if (m_DistName) {
        wprintf(L"DN: %ws\n",m_DistName);
    } else {
        wprintf(L"DN: (NULL)\n");
    }

    if (m_ObjectSid) {
        wprintf(L"Sid: %ws\n",m_ObjectSid);
    } else {
        wprintf(L"Sid: (NULL)\n");
    }
    
    wprintf(L"ERROR: %d\n",m_Error->GetErr());
    wprintf(L"**************************************\n");

}

WCHAR* CDsName::ReplaceRDN(const WCHAR *NewRDN) 
{
    WCHAR *ret;

    if (!NewRDN) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER, 
                        L"A NULL was passed to ReplaceRDN");
    }

    if (!m_DistName) {
        if (m_Error) {
            delete m_Error;
        }
        m_Error->SetErr(ERROR_GEN_FAILURE,
                        L"Can not replace the RDN on objects without DN's");
        return NULL;
    }
    WCHAR **DNParts=0;
    
    if (DNParts) {
        if (m_DistName) {
            DNParts = ldap_explode_dnW(m_DistName,
                                       0);
            DWORD size = wcslen(m_DistName);
            size -= wcslen(DNParts[0]);
            size += wcslen(NewRDN) + 2; 
            // the +2 is for the ',' and '\0' that will be added
            ret = new WCHAR[size];
            if (!ret) {
                m_Error->SetMemErr();
            }

            wcscpy(ret,NewRDN);
            DWORD i = 1;
            while(0 != DNParts[i]){
                wcscat(m_DistName,L",");
                wcscat(m_DistName,DNParts[i++]);
            }
            
        }

        if( ULONG err = ldap_value_freeW(DNParts) )
        {
            m_Error->SetErr(LdapMapErrorToWin32(err),
                            ldap_err2stringW(err));
            return NULL;
        }
    }

    
    return ret;
}

BOOL CDsName::ReplaceDN(const WCHAR *NewDN) {
    if (!NewDN) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"A Null use passed to ReplaceDN");
        return false;
    }

    if (m_DistName) {
        delete m_DistName;
    }

    m_DistName = new WCHAR[wcslen(NewDN)+1];
    if (!m_DistName) {
        m_Error->SetMemErr();
    }
    wcscpy(m_DistName,NewDN);

    return true;
   
}

BOOL CDsName::CompareByObjectGuid(const WCHAR *Guid){
    if (!Guid) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"A Null use passed to CompareByObjectGuid");
        return false;
    }
    if (!m_ObjectGuid) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"CompareByObjectGuid called on function that has no Guid specified");
        return false;
    }
    return 0==wcscmp(m_ObjectGuid,Guid)?true:false;
}

WCHAR* CDsName::GetDNSName() {
    if (!m_DistName) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"GetDNSName called on object without DN specified");
    }
    DS_NAME_RESULTW *res=0;

    DWORD err = DsCrackNamesW(NULL,
                              DS_NAME_FLAG_SYNTACTICAL_ONLY,
                              DS_FQDN_1779_NAME,
                              DS_CANONICAL_NAME,
                              1,
                              &m_DistName,
                              &res
                              );
    if (ERROR_SUCCESS != err) {
        m_Error->SetErr(err,
                        L"Failed to get the DNS name for object.");
        return 0;
    }

    if (DS_NAME_NO_ERROR != res->rItems[0].status) {
        m_Error->SetErr(ERROR_GEN_FAILURE,
                        L"Failed to get the DNS name for object.");
        return 0;
    }

    WCHAR* ret = new WCHAR[wcslen(res->rItems[0].pDomain+1)];
    if (!ret) {
        m_Error->SetMemErr();
    }
    wcscpy(ret,res->rItems[0].pDomain);

    if (res) {
        DsFreeNameResultW(res);
    }

    return ret;
               
}

WCHAR* CDsName::GetDN() 
{
    if (!m_DistName) {
        return 0;
    }

    WCHAR *ret = new WCHAR[wcslen(m_DistName)+1];
    if (!ret) {
        m_Error->SetMemErr();
        return 0;
    }
    wcscpy(ret,m_DistName);
    return ret;
}

WCHAR* CDsName::GetGuid() 
{
    if (!m_ObjectGuid) {
        return 0;
    }

    WCHAR *ret = new WCHAR[wcslen(m_ObjectGuid)+1];
    if (!ret) {
        m_Error->SetMemErr();
        return 0;
    }
    wcscpy(ret,m_ObjectGuid);
    return ret;    
}

WCHAR* CDsName::GetSid() 
{
    if (!m_ObjectSid) {
        return 0;
    }

    WCHAR *ret = new WCHAR[wcslen(m_ObjectSid)+1];
    if (!ret) {
        m_Error->SetMemErr();
        return 0;
    }
    wcscpy(ret,m_ObjectSid);
    return ret;    
}

DWORD CDsName::GetError() 
{
    if ( (!m_Error) || (!m_Error->isError()) ) {
        return ERROR_SUCCESS;
    }
    return m_Error->GetErr();
        
}

CDomain::CDomain(CDsName *Crossref,
                 CDsName *DNSObject,
                 WCHAR *DNSroot,
                 WCHAR *netbiosName,
                 BOOL  p_isDomain,
                 WCHAR *DcName) 
{
    m_CrossRefObject = Crossref;
    m_DomainDNSObject = DNSObject;
    m_dnsRoot = DNSroot;
    m_NetBiosName = netbiosName;
    m_isDomain = p_isDomain;
    m_PrevDnsRoot = 0;
    m_PrevNetBiosName = 0;
    m_DcName = DcName;
    m_tdoList = 0;
    m_itaList = 0;
    m_next = m_parent = m_lChild = m_rSibling = 0;
    
    m_Error = new CRenDomErr;

}

CDomain::~CDomain() {
    if (m_CrossRefObject) {
        delete m_CrossRefObject;
    }
    if (m_DomainDNSObject) {
        delete m_DomainDNSObject;
    }
    if (m_dnsRoot) {
        delete m_dnsRoot;
    }
    if (m_NetBiosName) {
        delete m_NetBiosName;
    }
    if (m_PrevDnsRoot) {
        delete m_PrevDnsRoot;
    }
    if (m_PrevNetBiosName) {
        delete m_PrevNetBiosName;
    }
    if (m_DcName) {
        delete m_DcName;
    }
    if (m_tdoList) {
        delete m_tdoList;
    }
    if (m_itaList) {
        delete m_itaList;
    }
    if (m_Error) {
        delete m_Error;
    }
}

VOID CDomain::DumpCDomain()
{
    wprintf(L"Domain Dump****************************\n");

    if (m_CrossRefObject) {
        wprintf(L"CrossRef:\n");
        m_CrossRefObject->DumpCDsName();
    } else {
        wprintf(L"CrossRef: (NULL)\n");
    }

    if (m_DomainDNSObject) {
        wprintf(L"DomainDNS:\n");
        m_DomainDNSObject->DumpCDsName();
    } else {
        wprintf(L"DomainDNS: (NULL)\n");
    }
    
    wprintf(L"Is Domain: %ws\n",m_isDomain?L"TRUE":L"FALSE");

    if (m_dnsRoot) {
        wprintf(L"dnsRoot: %ws\n",m_dnsRoot);
    } else {
        wprintf(L"dnsRoot: (NULL)\n");
    }

    if (m_NetBiosName) {
        wprintf(L"NetBiosName: %ws\n",m_NetBiosName);
    } else {
        wprintf(L"NetBiosName: (NULL)\n");
    }
    
    if (m_PrevDnsRoot) {
        wprintf(L"PrevDnsRoot: %ws\n",m_PrevDnsRoot);
    } else {
        wprintf(L"PrevDnsRoot: (NULL)\n");
    }

    if (m_PrevNetBiosName) {
        wprintf(L"PrevNetBiosName: %ws\n",m_PrevNetBiosName);
    } else {
        wprintf(L"PrevNetBiosName: (NULL)\n");
    }

    if (m_DcName) {
        wprintf(L"DcName: %ws\n",m_DcName);
    } else {
        wprintf(L"DcName: (NULL)\n");
    }
    
    if (m_parent) {
        wprintf(L"Parent Domain: %ws\n",m_parent->m_dnsRoot);
    } else {
        wprintf(L"Parent Domain: none\n");
    }
    
    if (m_lChild) {
        wprintf(L"Left Child: %ws\n",m_lChild->m_dnsRoot);
    } else {
        wprintf(L"Left Child: none\n");
    }
    
    if (m_rSibling) {
        wprintf(L"Right Sibling: %ws\n",m_rSibling->m_dnsRoot);
    } else {
        wprintf(L"Right Sibling: none\n");
    }

    wprintf(L"Trusted Domain Objects\n");
    if (m_tdoList) {
        CTrustedDomain* t = m_tdoList;
        while (t) {
            t->DumpTrust();
            t = (CTrustedDomain*)t->GetNext();
        }
    } else {
        wprintf(L"!!!!!!!!No Trusts\n");
    }

    wprintf(L"Interdomain Trust Objects\n");
    if (m_itaList) {
        CInterDomainTrust* t = m_itaList;
        while (t) {
            t->DumpTrust();
            t = (CInterDomainTrust*)t->GetNext();
        }
    } else {
        wprintf(L"!!!!!!!!No Trusts\n");
    }

    wprintf(L"ERROR: %d\n",m_Error->GetErr());
    wprintf(L"End Domain Dump ************************\n");

}

BOOL CDomain::isDomain()
{
    return m_isDomain;
}

WCHAR* CDomain::GetParentDnsRoot() 
{
    //Tail will return a point to newly allocated memory
    //with the information that we need.
    return Tail(m_dnsRoot);
}

WCHAR* CDomain::GetDnsRoot(BOOL ShouldAllocate /*= TRUE*/)
{
    if (ShouldAllocate) {
        WCHAR *ret = new WCHAR[wcslen(m_dnsRoot)+1];
        if (!ret) {
            m_Error->SetMemErr();
            return 0;
        }
    
        wcscpy(ret,m_dnsRoot);
    
        return ret;
    }

    return m_dnsRoot;
}

WCHAR* CDomain::GetDcToUse()
{
    if (!m_DcName) {
        return NULL;
    }
    WCHAR *ret = new WCHAR[wcslen(m_DcName)+1];
    if (!ret) {
        m_Error->SetMemErr();
        return 0;
    }

    wcscpy(ret,m_DcName);

    return ret;    
}

BOOL CDomain::Merge(CDomain *domain)
{
    m_PrevDnsRoot = m_dnsRoot;
    m_dnsRoot = domain->GetDnsRoot();
    if (m_Error->isError()) 
    {
        return FALSE;
    }
    m_PrevNetBiosName = m_NetBiosName;
    m_NetBiosName = domain->GetNetBiosName();
    if (m_Error->isError()) {
        return FALSE;
    }
    m_DcName = domain->GetDcToUse();
    if (m_Error->isError()) 
    {
        return FALSE;
    }

    return TRUE;
}

WCHAR* CDomain::GetPrevDnsRoot(BOOL ShouldAllocate /*= TRUE*/)
{
    if (!m_PrevDnsRoot) {
        return GetDnsRoot(ShouldAllocate);
    }

    if (ShouldAllocate) {
        WCHAR *ret = new WCHAR[wcslen(m_PrevDnsRoot)+1];
        if (!ret) {
            m_Error->SetMemErr();
            return 0;
        }
    
        wcscpy(ret,m_PrevDnsRoot);
        
        return ret;
    }

    return m_PrevDnsRoot;

}

WCHAR* CDomain::GetNetBiosName() 
{
    if (!m_NetBiosName) {
        return NULL;
    }
    WCHAR *ret = new WCHAR[wcslen(m_NetBiosName)+1];
    if (!ret) {
        m_Error->SetMemErr();
        return 0;
    }

    wcscpy(ret,m_NetBiosName);

    return ret;
}

WCHAR* CDomain::GetPrevNetBiosName() 
{
    if (!m_PrevNetBiosName) {
        return GetNetBiosName();
    }

    WCHAR *ret = new WCHAR[wcslen(m_PrevNetBiosName)+1];
    if (!ret) {
        m_Error->SetMemErr();
        return 0;
    }

    wcscpy(ret,m_PrevNetBiosName);

    return ret;
}

/*
CDsName* CDomain::GetDomainCrossRef()
{
    CDsName *ret = new CDsName(m_CrossRefObject);
    if (!ret)
    {
        m_Error->SetMemErr();
    }

    return ret;
} */

CDsName* CDomain::GetDomainCrossRef()
{
    return m_CrossRefObject;
}

/*
CDsName* CDomain::GetDomainDnsObject()
{
    CDsName *ret = new CDsName(m_DomainDNSObject);
    if (!ret)
    {
        m_Error->SetMemErr();
    }

    return ret;
} */

CDsName* CDomain::GetDomainDnsObject()
{
    return m_DomainDNSObject;
}

CDomain* CDomain::LookupByNetbiosName(const WCHAR* NetBiosName)
{
    if (!NetBiosName) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Parameter passed into LookupByNetBiosName is NULL");
    }
    if( m_NetBiosName && (0 == _wcsicmp(m_NetBiosName,NetBiosName)) )
    {
        return this;
    }

    CDomain *domain = GetNextDomain();
    while ( domain ) {
        WCHAR *TempNetbiosName = domain->GetNetBiosName();
        if (TempNetbiosName) 
        {
            if( 0 == _wcsicmp(NetBiosName,TempNetbiosName) )
            {
                delete TempNetbiosName;
                return domain;
            }
            delete TempNetbiosName;
        }

        domain = domain ->GetNextDomain();
    }

    return 0;
}

CDomain* CDomain::LookupByPrevNetbiosName(const WCHAR* NetBiosName)
{
    if (!NetBiosName) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Parameter passed into LookupByPrevNetBiosName is NULL");
    }
    
    if( m_PrevNetBiosName && (0 == _wcsicmp(m_PrevNetBiosName,NetBiosName)) )
    {
        return this;
    }

    CDomain *domain = GetNextDomain();
    while ( domain ) {
        WCHAR *TempNetbiosName = domain->GetPrevNetBiosName();
        if (TempNetbiosName) 
        {
            if( 0 == _wcsicmp(NetBiosName,TempNetbiosName) )
            {
                delete TempNetbiosName;
                return domain;
            }
            delete TempNetbiosName;
        }

        domain = domain->GetNextDomain();
    }

    return 0;
}

CDomain* CDomain::LookupByGuid(const WCHAR* Guid)
{
    WCHAR *TempGuid = 0;
    if (!Guid) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Parameter passed into LookupByGuid is NULL");
    }
    TempGuid = m_DomainDNSObject->GetGuid();
    if (!TempGuid) {
        m_Error->SetMemErr();
        return 0;
    }
    if( 0 == _wcsicmp(TempGuid,Guid) )
    {
        delete TempGuid;
        return this;             
    }
    delete TempGuid;

    CDomain *domain = GetNextDomain();
    while ( domain ) {
        TempGuid = domain->GetGuid();
        if (!TempGuid) {
            m_Error->SetMemErr();
            return 0;   
        }
        if( 0 == _wcsicmp(Guid,TempGuid) )
        {
            delete TempGuid;
            return domain;
        }
        delete TempGuid;
        domain = domain->GetNextDomain();
    }

    return 0;
}

CDomain* CDomain::LookupbySid(const WCHAR* Sid)
{
    WCHAR *TempSid = 0;
    if (!Sid) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Parameter passed into LookupBySid is NULL");
    }
    TempSid = m_DomainDNSObject->GetSid();
    if (m_Error->isError()) {
        return NULL;
    }
    if( 0 == _wcsicmp(TempSid,Sid) )
    {
        delete TempSid;
        return this;             
    }
    delete TempSid;

    CDomain *domain = GetNextDomain();
    while ( domain ) {
        TempSid = domain->GetSid();
        if (m_Error->isError()) {
            return NULL;   
        }
        if (TempSid) 
        {
            if( 0 == _wcsicmp(Sid,TempSid) )
            {
                delete TempSid;
                return domain;
            }
            delete TempSid;
        }
        domain = domain->GetNextDomain();
    }

    return 0;

}

BOOL CDomain::isNetBiosNameRenamed()
{
    if (!m_PrevNetBiosName) {
        return FALSE;
    }
    if (_wcsicmp(m_PrevNetBiosName,m_NetBiosName) == 0) {
        return FALSE;
    }
    return TRUE;
}

BOOL CDomain::isDnsNameRenamed()
{  
    if (!m_PrevDnsRoot) {
        return FALSE;
    }
    if (_wcsicmp(m_PrevDnsRoot,m_dnsRoot) == 0) {
        return FALSE;
    }
    return TRUE;
}

CDomain* CDomain::LookupByDnsRoot(const WCHAR* DNSRoot)
{
    WCHAR* TempDnsRoot = GetDnsRoot();
    if (!TempDnsRoot) {
        m_Error->SetMemErr();
        return 0;
    }
    if( 0 == _wcsicmp(DNSRoot,TempDnsRoot) )
    {
        delete TempDnsRoot;
        return this;
    }
    delete TempDnsRoot;

    CDomain *domain = GetNextDomain();
    while( domain ) {
        TempDnsRoot = domain->GetDnsRoot();
        if (!TempDnsRoot) {
            m_Error->SetMemErr();
            return 0;   
        }
        if( 0 == _wcsicmp(DNSRoot,TempDnsRoot) )
        {
            delete TempDnsRoot;
            return domain;
        }
        delete TempDnsRoot;

        domain = domain->GetNextDomain();
    }


    return 0;
}

CDomain* CDomain::LookupByPrevDnsRoot(const WCHAR* DNSRoot)
{
    WCHAR* TempDnsRoot = GetPrevDnsRoot();
    if (!TempDnsRoot) {
        m_Error->SetMemErr();
        return 0;
    }
    if( 0 == _wcsicmp(DNSRoot,TempDnsRoot) )
    {
        delete TempDnsRoot;
        return this;
    }
    delete TempDnsRoot;

    CDomain *domain = GetNextDomain();
    while( domain ) {
        TempDnsRoot = domain->GetPrevDnsRoot();
        if (!TempDnsRoot) {
            m_Error->SetMemErr();
            return 0;   
        }
        if( 0 == _wcsicmp(DNSRoot,TempDnsRoot) )
        {
            delete TempDnsRoot;
            return domain;
        }
        delete TempDnsRoot;

        domain = domain ->GetNextDomain();
    }


    return 0;
}

WCHAR* CDomain::GetGuid()
{
    WCHAR *Guid = m_DomainDNSObject->GetGuid() ;
    if ( !Guid )
    {
        m_Error->SetErr(m_DomainDNSObject->GetError(),
                        L"Failed to get the Guid for the domain");
        return NULL;
    }
    return Guid;
}

WCHAR* CDomain::GetSid()
{
    return m_DomainDNSObject->GetSid();
}

BOOL CDomain::SetParent(CDomain *Parent)
{
    m_parent = Parent;
    return true;
}

BOOL CDomain::SetLeftMostChild(CDomain *LeftChild)
{
    m_lChild = LeftChild;
    return true;
}

BOOL CDomain::SetRightSibling(CDomain *RightSibling)
{
    m_rSibling = RightSibling;
    return true;
}

BOOL CDomain::SetNextDomain(CDomain *Next)
{
    m_next = Next;
    return true;
}

CDomain* CDomain::GetParent()
{
    return m_parent;
}

CDomain* CDomain::GetLeftMostChild()
{
    return m_lChild;
}

CDomain* CDomain::GetRightSibling()
{
    return m_rSibling;
}

CDomain* CDomain::GetNextDomain()
{
    return m_next;
}

CTrustedDomain* CDomain::GetTrustedDomainList()
{
    return m_tdoList;
}

CInterDomainTrust* CDomain::GetInterDomainTrustList()
{
    return m_itaList;
}

WCHAR* CDomain::Tail(WCHAR *dnsName)
{
    WCHAR *pdnsName = dnsName;
    while (*pdnsName != L'.') {
        pdnsName++;
    }
    pdnsName++;

    WCHAR *ret = new WCHAR[wcslen(pdnsName)+1];
    if (!ret) {
        m_Error->SetMemErr();
        return 0;
    }

    wcscpy(ret,pdnsName);

    return ret;
}

BOOL CDomain::AddDomainTrust(CTrustedDomain *tdo)
{
    if (!tdo->SetNext(m_tdoList))
    {
        return FALSE;
    }
    m_tdoList = tdo;

    return TRUE;
}

BOOL CDomain::AddInterDomainTrust(CInterDomainTrust *ita)
{
    if (!ita->SetNext(m_itaList)) 
    {
        return FALSE;
    }
    m_itaList = ita;

    return TRUE;
}

inline CDomain* CTrust::GetTrustPartner()
{
    return m_TrustPartner;
}

inline CDsName* CTrust::GetTrustDsName()
{
    return m_Object;
}

BOOL CTrust::SetNext(CTrust *Trust)
{
    m_next = Trust;
    return TRUE;
}

CTrust* CTrust::GetNext()
{
    return m_next;
}

CTrust::CTrust(CDsName *p_Object,
               CDomain *p_TrustPartner)
{
    m_Object = p_Object;
    m_TrustPartner = p_TrustPartner;
}

CTrust::~CTrust()
{
    if (m_Object) {
        delete m_Object;
    }
}

VOID CTrust::DumpTrust()
{
    if (m_Object) 
    {
        m_Object->DumpCDsName();
    }
    if (m_TrustPartner)
    {
        m_TrustPartner->GetDomainDnsObject()->DumpCDsName();
    }
}

VOID CTrustedDomain::DumpTrust()
{
    if (m_Object) 
    {
        m_Object->DumpCDsName();
    }
    if (m_TrustPartner)
    {
        m_TrustPartner->GetDomainDnsObject()->DumpCDsName();
    }
    wprintf(L"TrustType: %d\n",
            m_TrustType);
}

CDc::CDc(WCHAR *NetBiosName,
         DWORD State,
         BYTE  *Password,
         DWORD cbPassword,
         DWORD LastError,
         WCHAR *FatalErrorMsg,
         WCHAR *LastErrorMsg,
         PVOID Data)
{
    m_Name =  NetBiosName;
    m_State = State;
    m_LastError = LastError;
    m_FatalErrorMsg = FatalErrorMsg;
    m_LastErrorMsg = LastErrorMsg;
    m_nextDC = NULL;
    m_Error = new CRenDomErr;
    m_Data  = Data;
    m_RPCReturn = 0;
    m_RPCVersion = 0;
    m_Password = NULL;
    m_cbPassword = 0;

    if (Password) {
        SetPassword(Password,
                    cbPassword);
    }
}

CDc::CDc(WCHAR *NetBiosName,
         DWORD State,
         WCHAR *Password,
         DWORD LastError,
         WCHAR *FatalErrorMsg,
         WCHAR *LastErrorMsg,
         PVOID Data)
{
    m_Name =  NetBiosName;
    m_State = State;
    m_LastError = LastError;
    m_FatalErrorMsg = FatalErrorMsg;
    m_LastErrorMsg = LastErrorMsg;
    m_nextDC = NULL;
    m_Error = new CRenDomErr;
    m_Data  = Data;
    m_RPCReturn = 0;
    m_RPCVersion = 0;
    m_Password = NULL;
    m_cbPassword = 0;

    if (Password) {
        SetPassword(Password);
    }
}

CDc::~CDc()
{
    if (m_Name) {
        delete m_Name;
    }
    if (m_FatalErrorMsg) {
        delete m_FatalErrorMsg;
    }
    if (m_LastErrorMsg) {
        delete m_LastErrorMsg;
    }
    if (m_Password) {
        delete m_Password;
    }
    if (m_nextDC) {
        delete m_nextDC;
    }
    if (m_Error) {
        delete m_Error;
    }

}

BOOL CDc::SetPassword(BYTE *password,
                      DWORD cbpassword)
{
    if (!password) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Null was passed to SetPassword"); 
        return FALSE;
    } 

    m_Password = new BYTE[cbpassword];
    if (!m_Password) {
        m_Error->SetMemErr();
        return FALSE;
    }

    memcpy(m_Password,password,cbpassword);
    m_cbPassword = cbpassword;

    return TRUE;
}

BOOL CDc::SetPassword(WCHAR *password)
{
    if (!password) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Null was passed to SetPassword"); 
        return FALSE;
    } 

    BYTE     decodedbytes[100];
    DWORD    dwDecoded = 0;
    NTSTATUS dwErr = STATUS_SUCCESS;
    CHAR     *szPassword = NULL;

    szPassword = Convert2Chars(password);
    if (!szPassword) {
        m_Error->SetErr(GetLastError(),
                        L"Failed to Convert charaters");
        return FALSE;
    }

    dwErr = base64decode((LPSTR)szPassword, 
                         (PVOID)decodedbytes,
                         sizeof (decodedbytes),
                         &dwDecoded);

    if (szPassword) {
        LocalFree(szPassword);
    }

    ASSERT( dwDecoded <= 100 );

    if (STATUS_SUCCESS != dwErr) {
        m_Error->SetErr(RtlNtStatusToDosError(dwErr),
                        L"Failed to decode Password");
        return FALSE;
    }

    if (!SetPassword(decodedbytes,
                     dwDecoded)) 
    {
        return FALSE;
    }
    
    return TRUE;
}

BOOL CDc::SetFatalErrorMsg(WCHAR *Error)
{
    DWORD size=0;

    if (!Error) {
        return TRUE;
    }

    size = wcslen(Error);
    m_FatalErrorMsg = new WCHAR[size+1];
    if (!m_FatalErrorMsg) {
        m_Error->SetMemErr();
        return FALSE;
    }

    wcscpy(m_FatalErrorMsg,Error);

    return TRUE;
}

BOOL CDc::SetLastErrorMsg(WCHAR *Error)
{
    DWORD size=0;

    if (!Error) {
        return TRUE;
    }

    size = wcslen(Error);
    m_LastErrorMsg = new WCHAR[size+1];
    if (!m_LastErrorMsg) {
        m_Error->SetMemErr();
        return FALSE;
    }

    wcscpy(m_LastErrorMsg,Error);

    return TRUE;
}

CDcList::CDcList(CReadOnlyEntOptions *opts)
{
    m_dclist    = NULL;
    m_hash      = NULL;
    m_Signature = NULL;
    m_cbhash    = 0;
    m_cbSignature = 0;

    m_Error = new CRenDomErr;

    m_Opts = opts;
}

CDcList::~CDcList()
{
    if (m_dclist) {
        delete m_dclist;
    }
    if (m_hash) {
        delete m_hash;
    }
    if (m_Signature) {
        delete m_Signature;
    }
}

BOOL CDcList::SetbodyHash(WCHAR *Hash)
{
    if (!Hash) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Null was passed to SetbodyHash"); 
        return FALSE;
    } 

    BYTE  decodedbytes[100];
    DWORD dwDecoded = 0;
    NTSTATUS dwErr = STATUS_SUCCESS;
    CHAR  *szHash = NULL;

    szHash = Convert2Chars(Hash);
    if (!szHash) {
        m_Error->SetErr(GetLastError(),
                        L"Failed to Convert charaters");
        return FALSE;
    }

    dwErr = base64decode((LPSTR)szHash, 
                         (PVOID)decodedbytes,
                         sizeof (decodedbytes),
                         &dwDecoded);

    if (szHash) {
        LocalFree(szHash);
    }

    ASSERT( dwDecoded <= 100 );

    if (STATUS_SUCCESS != dwErr) {
        m_Error->SetErr(RtlNtStatusToDosError(dwErr),
                        L"Failed to decode Hash");
        return FALSE;
    }

    if (!SetbodyHash(decodedbytes,
                     dwDecoded)) 
    {
        return FALSE;
    }
    
    return TRUE;

}

BOOL CDcList::SetbodyHash(BYTE *Hash,
                          DWORD cbHash)
{
    if (!Hash) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Null was passed to SetbodyHash"); 
        return FALSE;
    } 

    m_hash = new BYTE[cbHash];
    if (!m_hash) {
        m_Error->SetMemErr();
        return FALSE;
    }

    memcpy(m_hash,Hash,cbHash);
    m_cbhash = cbHash;

    return TRUE;
    
}

BOOL CDcList::SetSignature(WCHAR *Signature)
{
    if (!Signature) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Null was passed to SetSignature"); 
        return FALSE;
    } 

    BYTE  decodedbytes[100];
    DWORD dwDecoded = 0;
    NTSTATUS dwErr = STATUS_SUCCESS;
    CHAR  *szSignature = NULL;

    szSignature = Convert2Chars(Signature);
    if (!szSignature) {
        m_Error->SetErr(GetLastError(),
                        L"Failed to Convert charaters");
        return FALSE;
    }

    dwErr = base64decode((LPSTR)szSignature, 
                         (PVOID)decodedbytes,
                         sizeof (decodedbytes),
                         &dwDecoded);

    if (szSignature) {
        LocalFree(szSignature);
    }

    ASSERT( dwDecoded <= 100 );

    if (STATUS_SUCCESS != dwErr) {
        m_Error->SetErr(RtlNtStatusToDosError(dwErr),
                        L"Failed to decode Signature");
        return FALSE;
    }

    if (!SetSignature(decodedbytes,
                      dwDecoded)) 
    {
        return FALSE;
    }
    
    return TRUE;
}

BOOL CDcList::SetSignature(BYTE *Signature,
                           DWORD cbSignature)
{
    if (!Signature) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Null was passed to SetSignature"); 
        return FALSE;
    } 

    m_Signature = new BYTE[cbSignature];
    if (!m_Signature) {
        m_Error->SetMemErr();
        return FALSE;
    }

    memcpy(m_Signature,Signature,cbSignature);
    m_cbSignature = cbSignature;

    return TRUE;

}

BOOL CDcList::GetHashAndSignature(DWORD *cbhash, 
                                  BYTE  **hash,
                                  DWORD *cbSignature,
                                  BYTE  **Signature)
{
    *cbhash      = m_cbhash;
    *cbSignature = m_cbSignature;
    *hash         = m_hash;
    *Signature    = m_Signature;

    return TRUE;
}


BOOL CDcList::HashstoXML(CXMLGen *xmlgen)
{
    BYTE encodedbytes[100];
    WCHAR *wszHash      = NULL;
    WCHAR *wszSignature = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    
    
    if (dwErr = base64encode(m_hash, 
                             m_cbhash, 
                             (LPSTR)encodedbytes,
                             100,
                             NULL)) {

        m_Error->SetErr(RtlNtStatusToDosError(dwErr),
                        L"Error encoding Hash");
        
        goto Cleanup;
    }

    wszHash = Convert2WChars((LPSTR)encodedbytes);

    if (!xmlgen->WriteHash(wszHash))
    {
        goto Cleanup;
    }

    if (wszHash) {
        LocalFree(wszHash);
        wszHash = NULL;
    }

    if (dwErr = base64encode(m_Signature, 
                             m_cbSignature, 
                             (LPSTR)encodedbytes,
                             100,
                             NULL)) {

        m_Error->SetErr(RtlNtStatusToDosError(dwErr),
                        L"Error encoding signature");
        
        goto Cleanup;
    }

    wszSignature = Convert2WChars((LPSTR)encodedbytes);

    if (!xmlgen->WriteSignature(wszSignature))
    {
        goto Cleanup;
    }


    Cleanup:

    if (wszHash) {
        LocalFree(wszHash);
    }

    if (wszSignature) {
        LocalFree(wszSignature);
    }

    if (m_Error->isError()) {
        return FALSE;
    }
    
    return TRUE;

}

BOOL CDcList::GenerateDCListFromEnterprise(LDAP  *hldap,
                                           WCHAR *ConfigurationDN)
{
    if (!hldap) 
    {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Call to GenerateDCListFromEnterprise without having a valid handle to an ldap server\n");
        return false;
    }

    DWORD WinError = ERROR_SUCCESS;

    ULONG         LdapError = LDAP_SUCCESS;

    LDAPMessage   *SearchResult = NULL;
    ULONG         NumberOfEntries;
    WCHAR         *Attr = NULL;
    BerElement    *pBerElement = NULL;

    WCHAR         *AttrsToSearch[6];

    WCHAR         *DefaultFilter = L"objectCategory=nTDSDSA";

    WCHAR         *SitesRdn = L"CN=Sites,";

    ULONG         Length;

    WCHAR         *SitesDn = NULL;
    WCHAR         **Values = NULL;

    WCHAR         **ExplodedDN = NULL;
    
    WCHAR         *NetBiosName = NULL;

    AttrsToSearch[0] = L"distinguishedName";
    AttrsToSearch[1] = NULL;

    Length =  (wcslen( ConfigurationDN )
            + wcslen( SitesRdn )   
            + 1);

    SitesDn = new WCHAR[Length];

    wcscpy( SitesDn, SitesRdn );
    wcscat( SitesDn, ConfigurationDN );    
    LdapError = ldap_search_sW( hldap,
                                SitesDn,
                                LDAP_SCOPE_SUBTREE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {
        
        m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                        L"Search to find Configuration container failed");
        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries( hldap, SearchResult );
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        
        for ( Entry = ldap_first_entry(hldap, SearchResult);
                  Entry != NULL;
                      Entry = ldap_next_entry(hldap, Entry))
        {
            for( Attr = ldap_first_attributeW(hldap, Entry, &pBerElement);
                  Attr != NULL;
                      Attr = ldap_next_attributeW(hldap, Entry, pBerElement))
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    Values = ldap_get_valuesW( hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //
                        // Found it - these are NULL-terminated strings
                        //
                        ExplodedDN = ldap_explode_dn(Values[0],
                                                     TRUE );
                        if (!ExplodedDN) {
                            m_Error->SetMemErr();
                            goto Cleanup;
                        }

                        //the secound value of the exploded DN is the machineName
                        NetBiosName = new WCHAR[wcslen(ExplodedDN[1])+1];
                        if (!NetBiosName) {
                            m_Error->SetMemErr();
                            goto Cleanup;    
                        }

                        wcscpy(NetBiosName,ExplodedDN[1]);

                        LdapError = ldap_value_free(ExplodedDN);
                        ExplodedDN = NULL;
                        if (LDAP_SUCCESS != LdapError) 
                        {
                            m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                                            L"Failed to Free values from a ldap search");
                            goto Cleanup;
                        }

                    }

                }
                LdapError = ldap_value_freeW(Values);
                Values = NULL;
                if (LDAP_SUCCESS != LdapError) 
                {
                    m_Error->SetErr(LdapMapErrorToWin32(LdapError),
                                    L"Failed to Free values from a ldap search");
                    goto Cleanup;
                }

                if (!AddDcToList(new CDc(NetBiosName,
                                         0,
                                         NULL,
                                         0,
                                         0,
                                         NULL,
                                         NULL,
                                         NULL)))
                {
                    goto Cleanup;
                }
            
            }
        }
    }

    Cleanup:

    if (Values) {
        ldap_value_free(Values);
    }
    if (SitesDn) {
        delete SitesDn;
    }
    if (ExplodedDN) {
        ldap_value_free(ExplodedDN);
    }
    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }
    if ( m_Error->isError() ) 
    {
        return FALSE;
    }
    return TRUE;

}

BOOL CDc::SetNextDC(CDc *dc)
{
    m_nextDC = dc;

    return TRUE;
}

BOOL CDcList::AddDcToList(CDc *dc)
{
    if (!dc->SetNextDC(m_dclist))
    {
        return FALSE;
    }

    m_dclist = dc;

    return TRUE;
}

//Global to see if need to wait for more Calls
DWORD gCallsReturned = 0;
//Global For the hash and Signature
BYTE  *gHash = NULL;
DWORD gcbHash = 0;
BYTE *gSignature = NULL;
DWORD gcbSignature = 0;

BOOL CDcList::ExecuteScript(CDcList::ExecuteType executetype)
{
    
    DWORD                        dwErr = ERROR_SUCCESS;
    RPC_STATUS                   rpcStatus  = RPC_S_OK;
    RPC_ASYNC_STATE              AsyncState[64];
    DSA_MSG_PREPARE_SCRIPT_REPLY preparereply[64];
    DSA_MSG_EXECUTE_SCRIPT_REPLY executereply[64];
    RPC_BINDING_HANDLE           hDS[64];
    DWORD                        CallsMade = 0;
    BOOL                         NeedPrepare = FALSE;

    //zero out all of the handles
    memset(hDS,0,sizeof(hDS));

    if (!GetHashAndSignature(&gcbHash, 
                             &gHash,
                             &gcbSignature,
                             &gSignature))
    {
        return FALSE;
    }

    CDc *dc = m_dclist;

    if (executetype==eExecute) {
        while (dc) {
            if ( 1 > dc->GetState()) {
                m_Error->SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                                L"Not all servers have been prepared");
                goto Cleanup;
            }
            dc = dc->GetNextDC();
        }
    }

    if (executetype==ePrepare) {
        while (dc) {
            if ( 0 == dc->GetState()) {
                NeedPrepare = TRUE;
            }
            dc = dc->GetNextDC();
        }
        if (!NeedPrepare) {
            m_Error->SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                            L"All servers have been prepared");
            goto Cleanup;
        }
    }

    dc = m_dclist;

    while (dc) {

        if (2 == dc->GetState()) {
            wprintf(L"%ws has already been renamed\n",
                    dc->GetName());
            dc = dc->GetNextDC();
            continue;
        }
        if (3 == dc->GetState()) {
            wprintf(L"%ws has a fatal error cannot recover\n",
                    dc->GetName());
            dc = dc->GetNextDC();
            continue;
        }
    
        memset(&preparereply[CallsMade],0,sizeof(preparereply[CallsMade]));
        memset(&executereply[CallsMade],0,sizeof(executereply[CallsMade]));

        dc->m_Data = executetype==eExecute?(PVOID)&executereply[CallsMade]:(PVOID)&preparereply[CallsMade];   //NOTE need different data for execute
        
        rpcStatus =  RpcAsyncInitializeHandle(&AsyncState[CallsMade],
                                              sizeof( RPC_ASYNC_STATE ) );
        if (RPC_S_OK != rpcStatus) {
            m_Error->SetErr(rpcStatus,
                            L"Failed to initialize Async State");
            goto Cleanup;
        }
    
        AsyncState[CallsMade].NotificationType      =     RpcNotificationTypeApc;
        AsyncState[CallsMade].u.APC.NotificationRoutine = executetype==eExecute?ExecuteScriptCallback:PrepareScriptCallback;
        AsyncState[CallsMade].u.APC.hThread             = NULL;
        AsyncState[CallsMade].UserInfo                  = (PVOID)dc;
    
        if ( m_Opts->pCreds ) {
            
            dwErr = DsaopBindWithCred(dc->GetName(), 
                                      NULL, 
                                      m_Opts->pCreds,
                                      executetype==ePrepare?RPC_C_AUTHN_GSS_KERBEROS:RPC_C_AUTHN_NONE, 
                                      executetype==ePrepare?RPC_C_PROTECT_LEVEL_PKT_PRIVACY:RPC_C_PROTECT_LEVEL_NONE,
                                      &hDS[CallsMade]);
        }
        else {
                                                              
            dwErr = DsaopBind(dc->GetName(), 
                              NULL,
                              executetype!=eExecute?RPC_C_AUTHN_GSS_KERBEROS:RPC_C_AUTHN_NONE, 
                              executetype!=eExecute?RPC_C_PROTECT_LEVEL_PKT_PRIVACY:RPC_C_PROTECT_LEVEL_NONE,
                              &hDS[CallsMade]);
        }
    
        
        if (dwErr) {
            if (dc->GetName()) {
                m_Error->SetErr(dwErr,
                                L"Failed to Bind to server %s",
                                dc->GetName());
            } else {
                m_Error->SetErr(dwErr,
                                L"Failed to Bind to the Active Directory");
            }
    
            goto Cleanup;
        }
    
        __try {
            if (executetype==eExecute) {

                dwErr = DsaopExecuteScript ((PVOID)&AsyncState[CallsMade],
                                            hDS[CallsMade], 
                                            dc->GetPasswordSize(),
                                            dc->GetPassword(),
                                            &dc->m_RPCVersion,
                                            dc->m_Data);

            } else {
            
                dwErr = DsaopPrepareScript ((PVOID)&AsyncState[CallsMade],
                                            hDS[CallsMade],
                                            &dc->m_RPCVersion,
                                            dc->m_Data
                                            );

            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            if (executetype==eExecute) {
                m_Error->SetErr(dwErr,
                                L"Failed to execute script");
            } else {
                m_Error->SetErr(dwErr,
                                L"Failed to prepare script");
            }
            goto Cleanup;
        }
    
        if (ERROR_SUCCESS != dwErr) {
            if (executetype==eExecute) {
                m_Error->SetErr(dwErr,
                                L"Failed to execute script");
            } else {
                m_Error->SetErr(dwErr,
                                L"Failed to prepare script");
            }
            goto Cleanup;
        }

        //next server
        CallsMade++;
        dc = dc->GetNextDC();

        if (!dc || (CallsMade == 64)) {
            if (CallsMade > 0) {
                while (CallsMade > gCallsReturned) {
                    SleepEx(INFINITE,  // time-out interval
                            TRUE        // early completion option
                            );
                }
            }

            for (DWORD i = 0 ;i<64; i++) {
                if (hDS[i]) {
                    dwErr = DsaopUnBind(&hDS[i]);
                    if (ERROR_SUCCESS != dwErr) {
                        m_Error->SetErr(dwErr,
                                        L"Failed to unbind handle");
                    }
                }
            }
            
            CallsMade = 0;
            gCallsReturned = 0;

        }

    }

    Cleanup:

    for (DWORD i = 0 ;i<64; i++) {
        if (hDS[i]) {
            dwErr = DsaopUnBind(&hDS[i]);
            if (ERROR_SUCCESS != dwErr) {
                m_Error->SetErr(dwErr,
                                L"Failed to unbind handle");
            }
        }
    }

    if (m_Error->isError()) {
        return FALSE;
    }
    
    return TRUE;



}


VOID PrepareScriptCallback(struct _RPC_ASYNC_STATE *pAsync,
                           void *Context,
                           RPC_ASYNC_EVENT Event)
{
    RPC_STATUS      rpcStatus  = RPC_S_OK;

    gCallsReturned++;

    RpcTryExcept 
    {
        rpcStatus =  RpcAsyncCompleteCall(pAsync,
                                          &(((CDc*)(pAsync->UserInfo))->m_RPCReturn)
                                          );

    }
    RpcExcept(1)
    {
        ((CDc*)(pAsync->UserInfo))->m_RPCReturn = RpcExceptionCode();
    }
    RpcEndExcept;

    if (0 != rpcStatus) {
        ((CDc*)(pAsync->UserInfo))->m_RPCReturn = rpcStatus;
    }

    if ( 0 == (((CDc*)(pAsync->UserInfo)))->m_RPCReturn ) {
        if ( 1 != (((CDc*)(pAsync->UserInfo)))->m_RPCVersion ) {
            (((CDc*)(pAsync->UserInfo)))->m_RPCReturn = RPC_S_INTERNAL_ERROR;
            (((CDc*)(pAsync->UserInfo)))->SetFatalErrorMsg(L"Incorrect RPC version expected 1");
        } else {
            BOOL WrongScript = FALSE;
            if (((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.cbHashSignature != gcbSignature)
            {
                WrongScript = TRUE;
            } 
            else if(memcmp((PVOID)gSignature,(PVOID)(((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pbHashSignature) ,gcbSignature) != 0)
            {
                WrongScript = TRUE;
            } 
            else if (((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.cbHashBody != gcbHash)
            {
                WrongScript = TRUE;
            }
            else if(memcmp((PVOID)gHash,(PVOID)(((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pbHashBody) ,gcbHash) != 0)
            {
                WrongScript = TRUE;
            }
            if (WrongScript) 
            {
                (((CDc*)(pAsync->UserInfo)))->m_RPCVersion = ERROR_DS_INVALID_SCRIPT;
                ((CDc*)(pAsync->UserInfo))->SetLastErrorMsg(L"DC has an incorrect Script");
                wprintf(L"\r\n%ws has incorrect Script : %d",
                    ((CDc*)(pAsync->UserInfo))->GetName(),
                    ((CDc*)(pAsync->UserInfo))->m_RPCReturn);
                return;
            }

            (((CDc*)(pAsync->UserInfo))->m_RPCReturn) = ((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.dwOperationStatus;
            ((CDc*)(pAsync->UserInfo))->SetLastErrorMsg(((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
            ((CDc*)(pAsync->UserInfo))->SetPassword(((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pbPassword,
                                                    ((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.cbPassword);
        }
    }


    if ( 0 == ((CDc*)(pAsync->UserInfo))->m_RPCReturn ) 
    {
        ((CDc*)(pAsync->UserInfo))->SetState(1);
        wprintf(L"\r\n%ws was prepared successfully",
                ((CDc*)(pAsync->UserInfo))->GetName());
    } else {
        ((CDc*)(pAsync->UserInfo))->SetLastError(((CDc*)(pAsync->UserInfo))->m_RPCReturn);
        ((CDc*)(pAsync->UserInfo))->SetState(0);
        if (((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage) {
            wprintf(L"\r\nFailed to prepare %ws : %d\r\n%ws",
                    ((CDc*)(pAsync->UserInfo))->GetName(),
                    ((CDc*)(pAsync->UserInfo))->m_RPCReturn,
                    ((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
        } else {
            wprintf(L"\r\nFailed to prepare %ws : %d",
                    ((CDc*)(pAsync->UserInfo))->GetName(),
                    ((CDc*)(pAsync->UserInfo))->m_RPCReturn);
        }
    }

    if (((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage ) {
        LocalFree (((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
        ((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage = NULL;
    }

    
}

VOID ExecuteScriptCallback(struct _RPC_ASYNC_STATE *pAsync,
                           void *Context,
                           RPC_ASYNC_EVENT Event)
{
    RPC_STATUS      rpcStatus  = RPC_S_OK;

    gCallsReturned++;

    RpcTryExcept 
    {
        rpcStatus =  RpcAsyncCompleteCall(pAsync,
                                          &(((CDc*)(pAsync->UserInfo))->m_RPCReturn)
                                          );

    }
    RpcExcept(1)
    {
        ((CDc*)(pAsync->UserInfo))->m_RPCReturn = RpcExceptionCode();
    }
    RpcEndExcept;

    if (0 != rpcStatus) {
        ((CDc*)(pAsync->UserInfo))->m_RPCReturn = rpcStatus;
    }

    if ( 0 == (((CDc*)(pAsync->UserInfo)))->m_RPCReturn ) {
        if ( 1 != (((CDc*)(pAsync->UserInfo)))->m_RPCVersion ) {
            (((CDc*)(pAsync->UserInfo)))->m_RPCReturn = RPC_S_INTERNAL_ERROR;
            (((CDc*)(pAsync->UserInfo)))->SetFatalErrorMsg(L"Incorrect RPC version %d, expected 1");
        } else {
            ((CDc*)(pAsync->UserInfo))->m_RPCReturn = ((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.dwOperationStatus;
            ((CDc*)(pAsync->UserInfo))->SetLastErrorMsg(((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
        }
    }


    if ( 0 == ((CDc*)(pAsync->UserInfo))->m_RPCReturn ) 
    {
        ((CDc*)(pAsync->UserInfo))->SetState(2);
        wprintf(L"\r\nThe script was executed successfully on %ws",
                ((CDc*)(pAsync->UserInfo))->GetName());
    } else {
        ((CDc*)(pAsync->UserInfo))->SetLastError(((CDc*)(pAsync->UserInfo))->m_RPCReturn);
        ((CDc*)(pAsync->UserInfo))->SetState(3);
        if (((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage) {
            ((CDc*)(pAsync->UserInfo))->SetLastErrorMsg(((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
            wprintf(L"\r\nFailed to execute script on %ws : %d\r\n%ws",
                    ((CDc*)(pAsync->UserInfo))->GetName(),
                    ((CDc*)(pAsync->UserInfo))->m_RPCReturn,
                    ((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
        } else {
            wprintf(L"\r\nFailed to execute script on %ws : %d",
                    ((CDc*)(pAsync->UserInfo))->GetName(),
                    ((CDc*)(pAsync->UserInfo))->m_RPCReturn);
        }
    }

    if (((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage ) {
        LocalFree (((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
        ((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage = NULL;
    }

    
}

#undef DSAOP_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rendom\util\xml.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wchar.h>
#include <wincrypt.h>
#include <base64.h>

#define DEBSUB "RENDOM:"

#include "debug.h"

#include "rendom.h"
#include "DomainListparser.h"
#include "DcListparser.h"
#include "renutil.h"

#define INT_SIZE_LENGTH 20;


CXMLAttributeBlock::CXMLAttributeBlock(const WCHAR *p_Name,
                                       WCHAR *p_Value)
{

    m_Error = new CRenDomErr;
    m_Name = new WCHAR[wcslen(p_Name)+1];
    if (!m_Name) {
        m_Error->SetMemErr();
        return;
    }
    if (!p_Name) {
        m_Error->SetMemErr();
    } else {
        Assert(m_Name);
        Assert(p_Name);
        wcscpy(m_Name,p_Name);
    }
    m_Value = p_Value;
    
}

CXMLAttributeBlock::~CXMLAttributeBlock()
{
    if (m_Name) {
        delete m_Name;
    }
    if (m_Value) {
        delete m_Value;
    }
    if (m_Error) {
        delete m_Error;
    }
}

//returns a copy of the Name value of
//the CXMLAttributeBlock
WCHAR* CXMLAttributeBlock::GetName()
{
    WCHAR *ret = new WCHAR[wcslen(m_Name)+1];
    wcscpy(ret,m_Name);
    return ret;
}

//returns a copy of the value of
//the CXMLAttributeBlock
WCHAR* CXMLAttributeBlock::GetValue()
{
    if (!m_Value) {
        return NULL;
    }
    WCHAR *ret = new WCHAR[wcslen(m_Value)+1];
    if (!ret) {
        m_Error->SetMemErr();
        return NULL;
    }
    wcscpy(ret,m_Value);
    return ret;    
}

CXMLGen::CXMLGen()
{
    m_ErrorNum = 30000;  //starting error number
    m_xmldoc = NULL;
}

CXMLGen::~CXMLGen()
{
    if (m_Error) {
        delete m_Error;
    }
    if (m_xmldoc) {
        delete m_xmldoc;
    }
}

BOOL CXMLGen::WriteScriptToFile(WCHAR* filename)
{
    HANDLE hFile = NULL;
    DWORD bufsize = wcslen(m_xmldoc)*sizeof(WCHAR);
    DWORD bytesWritten = 0;
    WCHAR ByteOrderMark = (WCHAR)0xFEFF;
    BOOL  bsuccess = TRUE;

    hFile =  CreateFile(filename,               // file name
                        GENERIC_WRITE,          // access mode
                        0,                      // share mode
                        NULL,                   // SD
                        CREATE_ALWAYS,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL                    // handle to template file
                        );
    if (INVALID_HANDLE_VALUE == hFile) {
        m_Error->SetErr(GetLastError(),
                        L"Could not create File %s",
                        filename);
        return FALSE;
    }

    bsuccess = WriteFile(hFile,                    // handle to file
                         &ByteOrderMark,            // data buffer
                         sizeof(WCHAR),            // number of bytes to write
                         &bytesWritten,            // number of bytes written
                         NULL                      // overlapped buffer
                         );
    if (!bsuccess)
    {
        m_Error->SetErr(GetLastError(),
                        L"Could not Write to File %s",
                        filename);
        CloseHandle(hFile);
        return FALSE;
    }


    bsuccess = WriteFile(hFile,                          // handle to file
                         m_xmldoc,                       // data buffer
                         wcslen(m_xmldoc)*sizeof(WCHAR), // number of bytes to write
                         &bytesWritten,                  // number of bytes written
                         NULL                            // overlapped buffer
                         );
    CloseHandle(hFile);
    if (!bsuccess)
    {
        m_Error->SetErr(GetLastError(),
                        L"Could not Write to File %s",
                        filename);
        return FALSE;
    }

    return TRUE;

}

BOOL CXMLGen::StartDcList()
{
    if (m_xmldoc) {
        delete m_xmldoc;
        m_xmldoc = NULL;
    }
    const WCHAR* XmlDocStart = L"<?xml version =\"1.0\"?>\r\n<DcList>";

    m_Error = new CRenDomErr;

    m_xmldoc = new WCHAR[wcslen(XmlDocStart)+1];
    if (!m_xmldoc) {
        m_Error->SetMemErr();
    } else {
        wcscpy(m_xmldoc,XmlDocStart);
    }

    return TRUE;    
}

BOOL CXMLGen::EndDcList()
{
    WCHAR *buf = NULL;

    const WCHAR* XmlDocEnd = L"\r\n</DcList>";

    if (m_Error->isError()) {
        goto Cleanup;
    }

    buf = new WCHAR[wcslen(m_xmldoc)+
                    wcslen(XmlDocEnd)+1];
    if (!buf) {
        m_Error->SetMemErr();
        goto Cleanup;
    }
    wcscpy(buf,m_xmldoc);
    wcscat(buf,XmlDocEnd);
    
    delete m_xmldoc;
    m_xmldoc = buf;
    
    Cleanup:
    
    return TRUE;    
}

BOOL CXMLGen::WriteSignature(WCHAR *signature)
{
    WCHAR *buf = NULL;
    
    const WCHAR *ActionTemplate = 
        L"\r\n\t<Signature>%ws</Signature>";

    if (m_Error->isError()) {
        goto Cleanup;
    }

    buf = new WCHAR[wcslen(m_xmldoc)+
                    wcslen(ActionTemplate)+
                    wcslen(signature)+1];
    if (!buf) {
        m_Error->SetMemErr();
        goto Cleanup;
    }
    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),
             ActionTemplate,
             signature);

    delete m_xmldoc;
    m_xmldoc = buf;
    
    Cleanup:
    
    return TRUE;

}

BOOL CXMLGen::DctoXML(CDc *dc)
{
    if (!dc) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"NULL passed to DctoXML");
    }

    WCHAR *EmptyString = L"\0";
    WCHAR *buf = NULL;
    WCHAR *Password = NULL;
    WCHAR Error[20];
    WCHAR *LastError = dc->GetLastErrorMsg();
    WCHAR *FatalError = dc->GetLastFatalErrorMsg();
    BYTE  encodedbytes[100];
    WCHAR *State;
    DWORD dwErr = ERROR_SUCCESS;

    switch(dc->GetState()){
    case 0:
        State = L"Initial";
        break;
    case 1:
        State = L"Prepared";
        break;
    case 2:
        State = L"Done";
        break;
    case 3:
        State = L"Error";
        break;
    }

    _itow(dc->GetLastError(),Error,10);

    if (!LastError) {
        LastError = EmptyString;
    }
    if (!FatalError) {
        FatalError = EmptyString;
    }

    if (dc->GetPasswordSize() != 0) {
        if (dwErr = base64encode(dc->GetPassword(), 
                                 dc->GetPasswordSize(), 
                                 (LPSTR)encodedbytes,
                                 100,
                                 NULL)) {
    
            m_Error->SetErr(RtlNtStatusToDosError(dwErr),
                            L"Error encoding Password");
            
            return FALSE;
        }
    
        Password = Convert2WChars((LPSTR)encodedbytes);
    } else  {
        Password = EmptyString;
    }


    
    const WCHAR *ActionTemplate = 
        L"\r\n\t<DC>\r\n\t\t<Name>%ws</Name>\r\n\t\t<State>%ws</State>\r\n\t\t<Password>%ws</Password>\r\n\t\t<LastError>%ws</LastError>\r\n\t\t<LastErrorMsg>%ws</LastErrorMsg>\r\n\t\t<FatalErrorMsg>%ws</FatalErrorMsg>\r\n\t</DC>";

    if (m_Error->isError()) {
        goto Cleanup;
    }

    buf = new WCHAR[wcslen(m_xmldoc)+
                    wcslen(ActionTemplate)+
                    wcslen(dc->GetName())+
                    wcslen(LastError)+
                    wcslen(Error)+
                    wcslen(FatalError)+
                    wcslen(State)+
                    wcslen(Password)+1];
    if (!buf) {
        m_Error->SetMemErr();
        goto Cleanup;
    }
    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),
             ActionTemplate,
             dc->GetName(),
             State,
             Password,
             Error,
             LastError,
             FatalError);

    delete m_xmldoc;
    m_xmldoc = buf;
    
    Cleanup:
    if (Password && *Password != L'\0') {
        LocalFree(Password);
    }

    return TRUE;
}

BOOL CXMLGen::WriteHash(WCHAR *hash)
{
    WCHAR *buf = NULL;
    
    const WCHAR *ActionTemplate = 
        L"\r\n\t<Hash>%ws</Hash>";

    if (m_Error->isError()) {
        goto Cleanup;
    }

    buf = new WCHAR[wcslen(m_xmldoc)+
                    wcslen(ActionTemplate)+
                    wcslen(hash)+1];
    if (!buf) {
        m_Error->SetMemErr();
        goto Cleanup;
    }
    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),
             ActionTemplate,
             hash);

    delete m_xmldoc;
    m_xmldoc = buf;
    
    Cleanup:
    
    return TRUE;

}

BOOL CXMLGen::StartDomainList()
{
    if (m_xmldoc) {
        delete m_xmldoc;
        m_xmldoc = NULL;
    }
    const WCHAR* XmlDocStart = L"<?xml version =\"1.0\"?>\r\n<Forest>";

    m_Error = new CRenDomErr;

    m_xmldoc = new WCHAR[wcslen(XmlDocStart)+1];
    if (!m_xmldoc) {
        m_Error->SetMemErr();
    } else {
        wcscpy(m_xmldoc,XmlDocStart);
    }

    return TRUE;
}

BOOL CXMLGen::StartScript()
{
    if (m_xmldoc) {
        delete m_xmldoc;
        m_xmldoc = NULL;
    }
    const WCHAR* XmlDocStart = L"<?xml version =\"1.0\"?>\r\n<NTDSAscript>";

    m_Error = new CRenDomErr;

    m_xmldoc = new WCHAR[wcslen(XmlDocStart)+1];
    if (!m_xmldoc) {
        m_Error->SetMemErr();
    } else {
        wcscpy(m_xmldoc,XmlDocStart);
    }

    return TRUE;
}

BOOL CXMLGen::EndDomainList()
{
    const WCHAR *ActionTemplate = L"\r\n</Forest>";
    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(ActionTemplate)+1];
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }
    wcscpy(buf,m_xmldoc);
    wcscat(buf,ActionTemplate);
    
    delete m_xmldoc;
    m_xmldoc = buf;

    return TRUE;
}

BOOL CXMLGen::EndScript()
{
    const WCHAR *ActionTemplate = L"\r\n</NTDSAscript>";
    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(ActionTemplate)+1];
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }
    wcscpy(buf,m_xmldoc);
    wcscat(buf,ActionTemplate);
    
    delete m_xmldoc;
    m_xmldoc = buf;

    return TRUE;
} 

BOOL CXMLGen::StartAction(WCHAR *Actionname,BOOL Preprocess)
{
    if (!Actionname) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Actionname passed to StartAction was NULL");
        return FALSE;
    }

    WCHAR *ActionTemplate = NULL;

    if (Preprocess) {
        ActionTemplate = L"\r\n\t<action name=\"%s\" stage=\"preprocess\">";
    } else {
        ActionTemplate = L"\r\n\t<action name=\"%s\">";
    }
    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(Actionname)+
                           wcslen(ActionTemplate)+1];
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }
    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),ActionTemplate,Actionname);

    delete m_xmldoc;
    m_xmldoc = buf;

    return TRUE;
}

BOOL CXMLGen::EndAction()
{
    const WCHAR *ActionTemplate = L"\r\n\t</action>";
    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(ActionTemplate)+1];
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }
    wcscpy(buf,m_xmldoc);
    wcscat(buf,ActionTemplate);

    delete m_xmldoc;
    m_xmldoc = buf; 

    return TRUE;
}

BOOL CXMLGen::AddDomain(CDomain *d)
{
    WCHAR *buf = NULL;
    WCHAR *Guid = d->GetGuid();
    WCHAR *DnsRoot = d->GetDnsRoot();
    WCHAR *NetBiosName = d->GetNetBiosName();

    const WCHAR *ActionTemplate = 
        L"\r\n\t<Domain>\r\n\t\t<Guid>%s</Guid>\r\n\t\t<DNSname>%s</DNSname>\r\n\t\t<NetBiosName>%s</NetBiosName>\r\n\t\t<DcName></DcName>\r\n\t</Domain>";

    if (m_Error->isError()) {
        goto Cleanup;
    }

    if (!NetBiosName) {
        NetBiosName = new WCHAR[1];
        if (!NetBiosName) {
            m_Error->SetMemErr();
            goto Cleanup;
        }
        NetBiosName[0] = L'\0';
    }
    
    buf = new WCHAR[wcslen(m_xmldoc)+
                    wcslen(ActionTemplate)+
                    wcslen(Guid)+
                    wcslen(DnsRoot)+
                    wcslen(NetBiosName)+1];
    if (!buf) {
        m_Error->SetMemErr();
        goto Cleanup;
    }
    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),
             ActionTemplate,
             Guid,
             DnsRoot,
             NetBiosName);

    delete m_xmldoc;
    m_xmldoc = buf;
    
    Cleanup:
    if (Guid) {
        delete Guid;
    }
    if (DnsRoot) {
        delete DnsRoot;
    }
    if (NetBiosName) {
        delete NetBiosName;
    }
    return TRUE;
}

BOOL CXMLGen::Move(WCHAR *FromPath,
                   WCHAR *ToPath)
{
    if (!FromPath || !ToPath) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Move was passed a NULL");
        return FALSE;
    }

    const WCHAR *ActionTemplate = 
        L"\r\n\t\t<move path=\"dn:%s\" metadata=\"0\">\r\n\t\t\t<to path=\"dn:%s\"/>\r\n\t\t</move>";
    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(ActionTemplate)+
                           wcslen(FromPath)+
                           wcslen(ToPath)+1];
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }
    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),
             ActionTemplate,
             FromPath,
             ToPath);

    delete m_xmldoc;
    m_xmldoc = buf; 

    return TRUE;
}

BOOL CXMLGen::EndifInstantiated()
{
    const WCHAR *ActionTemplate = 
        L"\r\n\t\t\t</action>\r\n\t\t\t</then>\r\n\t\t</condition>";
    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(ActionTemplate)+1];
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }
    wcscpy(buf,m_xmldoc);
    wcscat(buf,ActionTemplate);

    delete m_xmldoc;
    m_xmldoc = buf;

    return TRUE;

}

BOOL CXMLGen::Cardinality(WCHAR *path,
                          WCHAR *cardinality)
{
    const WCHAR *ActionTemplate = 
        L"\r\n\t\t<predicate test=\"cardinality\" type=\"subTree\" path=\"%ws\" filter=\"COUNT_DOMAINS_FILTER\" cardinality=\"%ws\" errMessage=\"A domain has been added or remove\" returnCode=\"%d\"/>";

    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(ActionTemplate)+
                           wcslen(cardinality)+
                           wcslen(path)+6];  //6 to have space for the int error code.
                                             //1 for the L'\0'
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }

    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),
             ActionTemplate,
             path,
             cardinality,
             m_ErrorNum++);

    delete m_xmldoc;
    m_xmldoc = buf;

    return TRUE;
}

BOOL CXMLGen::Compare(WCHAR *path,
                      WCHAR *Attribute,
                      WCHAR *value,
                      WCHAR *errMessage)
{
    const WCHAR *ActionTemplate = 
        L"\r\n\t\t<predicate test=\"compare\" path=\"%ws\" attribute=\"%ws\" attrval=\"%ws\" defaultvalue=\"0\" type=\"base\" errMessage=\"%ws\" returnCode=\"%d\"/>";
        
    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(ActionTemplate)+
                           wcslen(Attribute)+
                           wcslen(value)+
                           wcslen(errMessage)+
                           wcslen(path)+6];  //6 to have space for the int error code.
                                             //1 for the L'\0'
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }

    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),
             ActionTemplate,
             path,
             Attribute,
             value,
             errMessage,
             m_ErrorNum++);

    delete m_xmldoc;
    m_xmldoc = buf;

    return TRUE;

}

BOOL CXMLGen::Not()
{
    const WCHAR *ActionTemplate = 
         L"\r\n\t\t<predicate test=\"not\">";

    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(ActionTemplate)+1];
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }

    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),
             ActionTemplate);

    delete m_xmldoc;
    m_xmldoc = buf;

    return TRUE;
}

BOOL CXMLGen::EndNot()
{
    const WCHAR *ActionTemplate = 
         L"\r\n\t\t</predicate>";

    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(ActionTemplate)+1];
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }

    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),
             ActionTemplate);

    delete m_xmldoc;
    m_xmldoc = buf;

    return TRUE;
}

BOOL CXMLGen::Instantiated(WCHAR *path,
                           WCHAR *errMessage)
{
    if (!path) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Instantiated was passed a NULL");
        return FALSE;
    }

    const WCHAR *ActionTemplate = 
         L"\r\n\t\t<predicate test=\"instantiated\" path=\"%ws\" type=\"base\" errMessage=\"%ws\" returnCode=\"%d\"/>";

    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(ActionTemplate)+
                           wcslen(errMessage)+
                           wcslen(path)+6]; //6 to have space for the int error code.
                                             //1 for the L'\0'
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }

    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),
             ActionTemplate,
             path,
             errMessage,
             m_ErrorNum++);

    delete m_xmldoc;
    m_xmldoc = buf;

    return TRUE;

}

BOOL CXMLGen::ifInstantiated(WCHAR *guid)
{
    if (!guid) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"ifInstantiated was passed a NULL");
        return FALSE;
    }

    const WCHAR *ActionTemplate = 
        L"\r\n\t\t<condition>\r\n\t\t\t<if>\r\n\t\t\t\t<predicate test=\"instantiated\" path=\"guid:%ws\" type=\"base\"/>\r\n\t\t\t</if>\r\n\t\t\t<then>\r\n\t\t\t<action>";
    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(ActionTemplate)+
                           wcslen(guid)+1];
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }

    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),
             ActionTemplate,
             guid);

    delete m_xmldoc;
    m_xmldoc = buf;

    return TRUE;
}

BOOL CXMLGen::Update(WCHAR *Object,
                     CXMLAttributeBlock **attblock)
{
    if (!Object) {
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Move was passed a NULL");
        return FALSE;
    }

    WCHAR *ActionTemplate = NULL;

    BOOL bReplace = TRUE;

    if (Object[0] == L'$') {
        //this is a macro use a different action template
        ActionTemplate = 
            L"\r\n\t\t<update path=\"%s\" metadata=\"0\">";
    } else {
        ActionTemplate = 
            L"\r\n\t\t<update path=\"dn:%s\" metadata=\"0\">";
    }

    
    const WCHAR *AttributeReplace =
        L"\r\n\t\t\t<%s op=\"replace\">%s</%s>";
    const WCHAR *AttributeDelete =
        L"\r\n\t\t\t<%s op=\"delete\">%s</%s>";
    const WCHAR *ActionClose = 
        L"\r\n\t\t</update>";
    WCHAR *buf = new WCHAR[wcslen(m_xmldoc)+
                           wcslen(ActionTemplate)+
                           wcslen(Object)+1];
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }
    wcscpy(buf,m_xmldoc);
    swprintf(buf+wcslen(buf),
             ActionTemplate,
             Object);

    delete m_xmldoc;
    m_xmldoc = buf;

    for (DWORD i = 0 ;attblock[i]; i ++) 
    {
        bReplace = TRUE;
        WCHAR *Name = attblock[i]->GetName();
        if (!Name) {
            m_Error->SetMemErr();
            return FALSE;
        }
        WCHAR *Value = attblock[i]->GetValue();
        if (m_Error->isError()) {
            return FALSE;
        }
        if (!Value) {
            Value = new WCHAR[1];
            if (!Value) {
                m_Error->SetMemErr();
                return FALSE;
            }
            wcscpy(Value,L"");
            bReplace = FALSE;
        }
        buf = new WCHAR[wcslen(m_xmldoc)+
                        wcslen(bReplace?AttributeReplace:AttributeDelete)+
                        (wcslen(Name)*2)+
                        wcslen(Value)+1];
        if (!buf) {
            m_Error->SetMemErr();
            return FALSE;
        } 

        wcscpy(buf,m_xmldoc);
        swprintf(buf+wcslen(buf),
                 bReplace?AttributeReplace:AttributeDelete,
                 Name,
                 Value,
                 Name);

        delete Name;
        delete Value;
    
        delete m_xmldoc;
        m_xmldoc = buf;

    }

    buf = new WCHAR[wcslen(m_xmldoc)+
                    wcslen(ActionClose)+1];
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }
    wcscpy(buf,m_xmldoc);
    wcscat(buf,ActionClose);
    
    delete m_xmldoc;
    m_xmldoc = buf;

    
    return TRUE;
}

VOID CXMLGen::DumpScript()
{
    wprintf(m_xmldoc);
}

// {0916C8E3-3431-4586-AF77-44BD3B16F961}
static const GUID guidDomainRename = 
{ 0x916c8e3, 0x3431, 0x4586, { 0xaf, 0x77, 0x44, 0xbd, 0x3b, 0x16, 0xf9, 0x61 } };

BOOL CXMLGen::UploadScript(LDAP *hLdapConn,PWCHAR ObjectDN, CDcList *dclist)
{
    LDAPModW         **pLdapMod = NULL;
    DWORD             dwErr = ERROR_SUCCESS;
    FILE             *fpScript;
    DWORD             dwFileLen, dwEncoded, dwDecoded;
    CHAR             *pScript, *pEndScript;
    WCHAR            *pwScript;
    WCHAR            *buf = NULL;
    BYTE              encodedbytes[100];

    HCRYPTPROV        hCryptProv = (HCRYPTPROV) NULL; 
    HCRYPTHASH        hHash = (HCRYPTHASH)NULL;
    HCRYPTHASH        hDupHash = (HCRYPTHASH)NULL;
    BYTE              *pbHashBody = NULL;
    DWORD             cbHashBody = 0;
    BYTE              *pbSignature = NULL;
    DWORD             cbSignature = 0;
    
    //MD5_CTX           Md5Context;

    pbHashBody =  new BYTE[20];
    if (!pbHashBody) {
        m_Error->SetMemErr();
        return FALSE;
    }
    pbSignature = new BYTE[20];
    if (!pbSignature) {
        m_Error->SetMemErr();
        return FALSE;
    } 
    cbSignature = cbHashBody = 20;

    __try {
        // Get a handle to the default PROV_RSA_FULL provider.

        if(!CryptAcquireContext(&hCryptProv, 
                                NULL, 
                                NULL, 
                                PROV_RSA_FULL, 
                                CRYPT_SILENT /*| CRYPT_MACHINE_KEYSET*/)) {

            dwErr = GetLastError();

            if (dwErr == NTE_BAD_KEYSET) {

                dwErr = 0;

                if(!CryptAcquireContext(&hCryptProv, 
                                        NULL, 
                                        NULL, 
                                        PROV_RSA_FULL, 
                                        CRYPT_SILENT | /*CRYPT_MACHINE_KEYSET |*/ CRYPT_NEWKEYSET)) {

                    dwErr = GetLastError();

                }

            }
            else {
                __leave;
            }
        }

        // Create the hash object.

        if(!CryptCreateHash(hCryptProv, 
                            CALG_SHA1, 
                            0, 
                            0, 
                            &hHash)) {
            dwErr = GetLastError();
            __leave;
        }


        // Compute the cryptographic hash of the buffer.

        if(!CryptHashData(hHash, 
                         (BYTE *)m_xmldoc,
                         wcslen (m_xmldoc) * sizeof (WCHAR),
                         0)) {
            dwErr = GetLastError();
            __leave;
        }

        // we have the common part of the hash ready (H(buf), now duplicate it
        // so as to calc the H (buf + guid)

        if (!CryptDuplicateHash(hHash, 
                               NULL, 
                               0, 
                               &hDupHash)) {
            dwErr = GetLastError();
            __leave;
        }


        if (!CryptGetHashParam(hHash,    
                               HP_HASHVAL,
                               pbHashBody,
                               &cbHashBody,
                               0)) {
            dwErr = GetLastError();
            __leave;
        }

        ASSERT (cbHashBody == 20);

        
        if(!CryptHashData(hDupHash, 
                         (BYTE *)&guidDomainRename,
                         sizeof (GUID),
                         0)) {
            dwErr = GetLastError();
            __leave;
        }
        
        if (!CryptGetHashParam(hDupHash,    
                               HP_HASHVAL,
                               pbSignature,
                               &cbSignature,
                               0)) {
            dwErr = GetLastError();
            __leave;
        }

        ASSERT (cbSignature == 20);

    }
    __finally {

        if (hDupHash)
            CryptDestroyHash(hDupHash);

        if(hHash) 
            CryptDestroyHash(hHash);

        if(hCryptProv) 
            CryptReleaseContext(hCryptProv, 0);

    }

    dclist->SetbodyHash(pbHashBody,
                        cbHashBody);

    dclist->SetSignature(pbSignature,
                         cbSignature);

    if (0 != dwErr) {
        m_Error->SetErr(dwErr,
                        L"Failed to encrypt the script");
        return FALSE;
    }

    if (dwErr = base64encode(pbSignature, 
                             cbSignature, 
                             (LPSTR)encodedbytes,
                             100,
                             NULL)) {

        m_Error->SetErr(RtlNtStatusToDosError(dwErr),
                        L"Error encoding signature");
        
        return FALSE;
    }

    pwScript = Convert2WChars((LPSTR)encodedbytes);
    
    buf = new WCHAR[wcslen(m_xmldoc)+
                    wcslen(pwScript)+1];
    if (!buf) {
        m_Error->SetMemErr();
        return FALSE;
    }
    wcscpy(buf,m_xmldoc);
    wcscat(buf,pwScript);
    
    LocalFree(pwScript);

    delete m_xmldoc;
    m_xmldoc = buf;

    AddModMod (L"msDS-UpdateScript", m_xmldoc, &pLdapMod);
    
    dwErr = ldap_modify_s (hLdapConn, ObjectDN, pLdapMod);

    if(dwErr != LDAP_SUCCESS) {
        m_Error->SetErr(LdapMapErrorToWin32(dwErr),
                        L"Failed to upload rename instructions to %S, Ldap error %d, %S",
                        hLdapConn->ld_host,
                        dwErr,
                        ldap_err2stringW(dwErr));
    }
    
    FreeMod (&pLdapMod);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                        parser implementation                                   //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

CXMLDomainListContentHander::CXMLDomainListContentHander(CEnterprise *p_enterprise)
{                          
	m_eDomainParsingStatus = SCRIPT_STATUS_WAITING_FOR_FOREST;
    m_eDomainAttType       = DOMAIN_ATT_TYPE_NONE;

    m_enterprise           = p_enterprise;
    m_Domain               = NULL;
    m_Error                = new CRenDomErr;

    m_DcToUse              = NULL;
    m_NetBiosName          = NULL;
    m_Dnsname              = NULL;
    m_Guid                 = NULL;
    m_Sid                  = NULL;
    m_DN                   = NULL;
    
    m_CrossRef             = NULL;
    m_ConfigNC             = NULL;
    m_SchemaNC             = NULL;
    
}

CXMLDomainListContentHander::~CXMLDomainListContentHander()
{
    if (m_DcToUse) {
        delete m_DcToUse;         
    }
    if (m_Dnsname) {
        delete m_Dnsname;
    }
    if (m_NetBiosName) {
        delete m_NetBiosName;
    }
    if (m_Guid) {
        delete m_Guid;
    }
}


HRESULT STDMETHODCALLTYPE CXMLDomainListContentHander::startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes)
{
    if (_wcsnicmp(DOMAINSCRIPT_FOREST, pwchLocalName, cchLocalName) == 0) {

        // we accept only one, at the start
        if (SCRIPT_STATUS_WAITING_FOR_FOREST != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Encountered <Forest> tag in the middle of a another <Forest> tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN);
        }
    }
    else if (_wcsnicmp(DOMAINSCRIPT_ENTERPRISE_INFO, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_ENTERPRISE_INFO);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_CONFIGNC, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_ENTERPRISE_INFO != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_CONFIGURATION_NC);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_SCHEMANC, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_ENTERPRISE_INFO != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_SCHEMA_NC);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_DOMAIN, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Domain> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_GUID, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT   != CurrentDomainParsingStatus()) &&
            (SCRIPT_STATUS_PARSING_CONFIGURATION_NC != CurrentDomainParsingStatus()) && 
            (SCRIPT_STATUS_PARSING_SCHEMA_NC        != CurrentDomainParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Guid> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_GUID);
        }
    }
    else if (_wcsnicmp(DOMAINSCRIPT_SID, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT   != CurrentDomainParsingStatus()) &&
            (SCRIPT_STATUS_PARSING_CONFIGURATION_NC != CurrentDomainParsingStatus()) && 
            (SCRIPT_STATUS_PARSING_SCHEMA_NC        != CurrentDomainParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Guid> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_SID);
        }
    }
    else if (_wcsnicmp(DOMAINSCRIPT_DN, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT   != CurrentDomainParsingStatus()) &&
            (SCRIPT_STATUS_PARSING_CONFIGURATION_NC != CurrentDomainParsingStatus()) && 
            (SCRIPT_STATUS_PARSING_SCHEMA_NC        != CurrentDomainParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Guid> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_DN);
        }
    }
    else if (_wcsnicmp(DOMAINSCRIPT_DNSROOT, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <DNSName> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_DNSROOT);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_NETBIOSNAME, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <NetBiosName> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NETBIOSNAME);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_DCNAME, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <DCName> Tag.");
            return E_FAIL;
        }                   
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_DCNAME);
        }

    } else {
        WCHAR temp[100] = L"";
        wcsncpy(temp,pwchLocalName,cchLocalName);
        temp[cchLocalName] = L'\0';
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Unknown Tag <%ws>",
                        temp);
        return E_FAIL;
    }
    
    if (m_Error->isError()) {
        return E_FAIL;
    }

    return S_OK;
}
        
       
HRESULT STDMETHODCALLTYPE CXMLDomainListContentHander::endElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName)
{
	if (_wcsnicmp(DOMAINSCRIPT_FOREST, pwchLocalName, cchLocalName) == 0) {

        // we accept only one, at the start
        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Encountered <Forest> tag in the middle of a another <Forest> tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_FOREST);
        }
    }
    else if (_wcsnicmp(DOMAINSCRIPT_DOMAIN, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Domain> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN);
            if (!m_Guid) {
                m_Error->SetErr(ERROR_GEN_FAILURE,
                                L"Failed parsing script.  A Guid was not specified for the domain.");
            }
            if (!m_Dnsname) {
                m_Error->SetErr(ERROR_GEN_FAILURE,
                                L"Failed parsing script.  A Dnsname was not specified for the domain.");
            }

            //set up a domain
            CDsName *GuidDsName = new CDsName(m_Guid,
                                              NULL,
                                              NULL);
            if (!GuidDsName) {
                m_Error->SetMemErr();
                return E_FAIL;
            }

            if (m_Error->isError()) {
                return E_FAIL;
            }
            m_Domain = new CDomain(NULL,
                                   GuidDsName,
                                   m_Dnsname,
                                   m_NetBiosName,
                                   0,
                                   m_DcToUse);
            if (!m_Domain) {
                m_Error->SetMemErr();
                return E_FAIL;
            }

            if (m_Error->isError()) {
                return E_FAIL;
            }

            //place domain on descList
            m_enterprise->AddDomainToDescList(m_Domain);
            if (m_Error->isError()) {
                return E_FAIL;
            }

            //set all info to NULL
            m_Domain               = NULL;
            m_DcToUse              = NULL;
            m_NetBiosName          = NULL;
            m_Dnsname              = NULL;
            m_Guid                 = NULL;
            m_Sid                  = NULL;
            m_DN                   = NULL;
         
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_GUID, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Guid> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }
    }
    else if (_wcsnicmp(DOMAINSCRIPT_DNSROOT, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <DNSName> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_NETBIOSNAME, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <NetBiosName> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_DCNAME, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <DCName> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_DN, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_SID, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_ENTERPRISE_INFO, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }

    } else {
        WCHAR temp[100] = L"";
        wcsncpy(temp,pwchLocalName,cchLocalName);
        temp[cchLocalName] = L'\0';
        m_Error->SetErr(ERROR_INVALID_PARAMETER,
                        L"Unknown Tag <%ws>",
                        temp);
        return E_FAIL;
    }

    if (m_Error->isError()) {  
        return E_FAIL;         
    }
    
    
    /*DOMAINSCRIPT_ENTERPRISE_INFO 
    DOMAINSCRIPT_CONFIGNC        
    DOMAINSCRIPT_SCHEMANC        
    DOMAINSCRIPT_FORESTROOT      */

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CXMLDomainListContentHander::characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    switch(CurrentDomainAttType()) {
    case DOMAIN_ATT_TYPE_NONE:
        break;
    case DOMAIN_ATT_TYPE_GUID:
        m_Guid = new WCHAR[cchChars+1];
        if (!m_Guid) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_Guid,pwchChars,cchChars);
        m_Guid[cchChars] = 0;
        break;
    case DOMAIN_ATT_TYPE_DNSROOT:
        m_Dnsname = new WCHAR[cchChars+1];
        if (!m_Dnsname) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_Dnsname,pwchChars,cchChars);
        m_Dnsname[cchChars] = 0;
        break;
    case DOMAIN_ATT_TYPE_NETBIOSNAME:
        m_NetBiosName = new WCHAR[cchChars+1];
        if (!m_NetBiosName) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_NetBiosName,pwchChars,cchChars);
        m_NetBiosName[cchChars] = 0;
        for (int i = 0; i < cchChars; i++) {
            m_NetBiosName[i] = towupper(m_NetBiosName[i]);
        }
        break;
    case DOMAIN_ATT_TYPE_DCNAME:
        m_DcToUse = new WCHAR[cchChars+1];
        if (!m_DcToUse) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_DcToUse,pwchChars,cchChars);
        m_DcToUse[cchChars] = 0;
        break;
    case DOMAIN_ATT_TYPE_SID:
        m_Sid = new WCHAR[cchChars+1];
        if (!m_Sid) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_Sid,pwchChars,cchChars);
        m_Sid[cchChars] = 0;
        break;
    case DOMAIN_ATT_TYPE_DN:
        m_DN = new WCHAR[cchChars+1];
        if (!m_DN) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_DN,pwchChars,cchChars);
        m_DN[cchChars] = 0;
        break;
    case DOMAIN_ATT_TYPE_FORESTROOTGUID:
        m_DomainRootGuid = new WCHAR[cchChars+1];
        if (!m_DomainRootGuid) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_DomainRootGuid,pwchChars,cchChars);
        m_DomainRootGuid[cchChars] = 0;
        break;
    default:
        m_Error->SetErr(ERROR_GEN_FAILURE,
                        L"Failed This should not be possible.");
        return E_FAIL;
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CXMLDomainListContentHander::startDocument()
{
    m_eDomainParsingStatus = SCRIPT_STATUS_WAITING_FOR_FOREST;
    m_eDomainAttType       = DOMAIN_ATT_TYPE_NONE;

    m_Domain               = NULL;
    m_DcToUse              = NULL;
    m_NetBiosName          = NULL;
    m_Dnsname              = NULL;
    m_Guid                 = NULL;
    m_Sid                  = NULL;
    m_DN                   = NULL;
    m_CrossRef             = NULL;
    m_ConfigNC             = NULL;
    m_SchemaNC             = NULL;
    m_DomainRootGuid       = NULL;

    return S_OK;
}

CXMLDcListContentHander::CXMLDcListContentHander(CEnterprise *enterprise)
{
    m_Error                 = new CRenDomErr;
    m_eDcParsingStatus      = SCRIPT_STATUS_WAITING_FOR_DCLIST;  
    m_eDcAttType            = DC_ATT_TYPE_NONE;

    m_DcList                = enterprise->GetDcList();

    m_dc                    = NULL;
    m_Name                  = NULL;
    m_State                 = NULL;
    m_Password              = NULL;
    m_LastError             = NULL;
    m_LastErrorMsg          = NULL;
    m_FatalErrorMsg         = NULL; 
}

CXMLDcListContentHander::~CXMLDcListContentHander()
{
    if (m_Error) {
        delete m_Error;
    }
}

HRESULT STDMETHODCALLTYPE CXMLDcListContentHander::startDocument()
{
    m_eDcParsingStatus      = SCRIPT_STATUS_WAITING_FOR_DCLIST;  
    m_eDcAttType            = DC_ATT_TYPE_NONE;

    m_dc                    = NULL;
    m_Name                  = NULL;
    m_State                 = NULL;
    m_Password              = NULL;
    m_LastError             = NULL;
    m_LastErrorMsg          = NULL;
    m_FatalErrorMsg         = NULL;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CXMLDcListContentHander::startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes)
{
    if ((wcslen(DCSCRIPT_DCLIST) == cchLocalName) && _wcsnicmp(DCSCRIPT_DCLIST, pwchLocalName, cchLocalName) == 0) {

        // we accept only one, at the start
        if (SCRIPT_STATUS_WAITING_FOR_DCLIST != CurrentDcParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Encountered <DcList> tag in the middle of a another <DcList> tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT);
        }
    }
    else if ((wcslen(DCSCRIPT_HASH) == cchLocalName) && _wcsnicmp(DCSCRIPT_HASH, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT != CurrentDcParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Hash> Tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_PARSING_HASH);
        }

    }
    else if ((wcslen(DCSCRIPT_SIGNATURE) == cchLocalName) && _wcsnicmp(DCSCRIPT_SIGNATURE, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT != CurrentDcParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Signature> Tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_PARSING_SIGNATURE);
        }

    }
    else if ((wcslen(DCSCRIPT_DC) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <DC> Tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_PARSING_DCLIST_ATT);
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_NAME) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_NAME, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Name> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NAME);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_STATE) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_STATE, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <State> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_STATE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_PASSWORD) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_PASSWORD, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Password> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_PASSWORD);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_LASTERROR) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_LASTERROR, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <LastError> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_LASTERROR);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_LASTERRORMSG) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_LASTERRORMSG, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <LastErrorMsg> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_LASTERRORMSG);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_FATALERRORMSG) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_FATALERRORMSG, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <FatalErrorMsg> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_FATALERRORMSG);
        }
    }

    
    
    if (m_Error->isError()) {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CXMLDcListContentHander::endElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName)
{
	if ((wcslen(DCSCRIPT_DCLIST) == cchLocalName) && _wcsnicmp(DCSCRIPT_DCLIST, pwchLocalName, cchLocalName) == 0) {

        // we accept only one, at the start
        if (SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT != CurrentDcParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Encountered </DcList> tag in the middle of a another <Forest> tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_WAITING_FOR_DCLIST);
        }
    }
    else if ((wcslen(DCSCRIPT_HASH) == cchLocalName) && _wcsnicmp(DCSCRIPT_HASH, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_PARSING_HASH != CurrentDcParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </Hash> Tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT);
        }

    }
    else if ((wcslen(DCSCRIPT_SIGNATURE) == cchLocalName) && _wcsnicmp(DCSCRIPT_SIGNATURE, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_PARSING_SIGNATURE != CurrentDcParsingStatus()) {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </Signature> Tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT);
        }

    }
    else if ((wcslen(DCSCRIPT_DC) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </DC> Tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT);
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
            if (!m_Name) {
                m_Error->SetErr(ERROR_GEN_FAILURE,
                                L"Failed parsing script.  A Name was not specified for the DC.");
            }
            
            //set up a domain
            CDc *dc = new CDc(m_Name,
                              m_State,
                              m_Password,
                              m_LastError,
                              m_FatalErrorMsg,
                              m_LastErrorMsg,
                              NULL);
            if (!dc) {
                m_Error->SetMemErr();
                return E_FAIL;
            }

            if (m_Error->isError()) {
                return E_FAIL;
            }
            
            //place dc on dcList
            m_DcList->AddDcToList(dc);
            if (m_Error->isError()) {
                return E_FAIL;
            }

            //set all info to NULL
            m_dc                  = NULL;
            m_Name                = NULL;
            m_State               = 0;
            if (m_Password) {
                delete m_Password;
            }
            m_Password            = NULL;
            m_LastError           = 0;
            m_LastErrorMsg        = NULL;
            m_FatalErrorMsg       = NULL;
        }
    }
    else if ((wcslen(DCSCRIPT_DC_NAME) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_NAME, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </Name> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_STATE) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_STATE, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </State> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_PASSWORD) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_PASSWORD, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </Password> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_LASTERROR) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_LASTERROR, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </LastError> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_LASTERRORMSG) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_LASTERRORMSG, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </LastErrorMsg> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_FATALERRORMSG) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_FATALERRORMSG, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error->SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </FatalErrorMsg> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }

    if (m_Error->isError()) {  
        return E_FAIL;         
    }
    
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CXMLDcListContentHander::characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    WCHAR error[20+1] = {0};


    if (CurrentDcParsingStatus() == SCRIPT_STATUS_PARSING_HASH) {
        WCHAR *temp = new WCHAR[cchChars+1];
        if (!temp) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(temp,pwchChars,cchChars);
        temp[cchChars] = 0;

        m_DcList->SetbodyHash(temp);

        delete temp;
    }
    if (CurrentDcParsingStatus() == SCRIPT_STATUS_PARSING_SIGNATURE) {
        WCHAR *temp = new WCHAR[cchChars+1];
        if (!temp) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(temp,pwchChars,cchChars);
        temp[cchChars] = 0;

        m_DcList->SetSignature(temp);

        delete temp;
    }
    switch(CurrentDcAttType()) {
    case DC_ATT_TYPE_NONE:
        break;
    case DC_ATT_TYPE_NAME:
        m_Name = new WCHAR[cchChars+1];
        if (!m_Name) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_Name,pwchChars,cchChars);
        m_Name[cchChars] = 0;
        break;
    case DC_ATT_TYPE_STATE:
        if (0 == _wcsnicmp(DC_STATE_STRING_INITIAL,pwchChars,cchChars)) {
            m_State = DC_STATE_INITIAL;
        }
        if (0 == _wcsnicmp(DC_STATE_STRING_PREPARED,pwchChars,cchChars)) {
            m_State = DC_STATE_PREPARED;
        }
        if (0 == _wcsnicmp(DC_STATE_STRING_DONE,pwchChars,cchChars)) {
            m_State = DC_STATE_DONE;
        }
        if (0 == _wcsnicmp(DC_STATE_STRING_ERROR,pwchChars,cchChars)) {
            m_State = DC_STATE_ERROR;
        }
        break;
    case DC_ATT_TYPE_PASSWORD:
        m_Password = new WCHAR[cchChars+1];
        if (!m_Password) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_Password,pwchChars,cchChars);
        m_Password[cchChars] = 0;
        break;
    case DC_ATT_TYPE_LASTERROR:
        wcsncpy(error,pwchChars,cchChars);
        error[cchChars] = 0;
        m_LastError = _wtoi(error);
        break;
    case DC_ATT_TYPE_LASTERRORMSG:
        m_LastErrorMsg = new WCHAR[cchChars+1];
        if (!m_LastErrorMsg) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_LastErrorMsg,pwchChars,cchChars);
        m_LastErrorMsg[cchChars] = 0;
        break;
    case DC_ATT_TYPE_FATALERRORMSG:
        m_FatalErrorMsg = new WCHAR[cchChars+1];
        if (!m_FatalErrorMsg) {
            m_Error->SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_FatalErrorMsg,pwchChars,cchChars);
        m_FatalErrorMsg[cchChars] = 0;
        break;
    default:
        m_Error->SetErr(ERROR_GEN_FAILURE,
                        L"Failed This should not be possible.");
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\repadmin.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

    Rsraghav has been in here too

    Will Lees    wlees   Feb 11, 1998
         Converted code to use ntdsapi.dll functions

    Aaron Siegel t-asiege 18 June 1998
	 Added support for DsReplicaSyncAll

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#define INCLUDE_OPTION_TRANSLATION_TABLES
#include <mdglobal.h>
#undef INCLUDE_OPTION_TRANSLATION_TABLES
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>
#include <locale.h>

#include "ReplRpcSpoof.hxx"
#include "repadmin.h"
#include "resource.h"

// Global credentials.
SEC_WINNT_AUTH_IDENTITY_W   gCreds = { 0 };
SEC_WINNT_AUTH_IDENTITY_W * gpCreds = NULL;

// Global DRS RPC call flags.  Should hold 0 or DRS_ASYNC_OP.
ULONG gulDrsFlags = 0;

// An zero-filled filetime to compare against
FILETIME ftimeZero = { 0 };


int PreProcessGlobalParams(int * pargc, LPWSTR ** pargv);
int GetPassword(WCHAR * pwszBuf, DWORD cchBufMax, DWORD * pcchBufUsed);

int ExpertHelp(int argc, LPWSTR argv[]) {
    PrintHelp( TRUE /* expert */ );
    return 0;
}

typedef int (REPADMIN_FN)(int argc, LPWSTR argv[]);

struct {
    UINT            uNameID;
    REPADMIN_FN *   pfFunc;
} rgCmdTable[] = {
    { IDS_CMD_ADD,                           Add             },
    { IDS_CMD_DEL,                           Del             },
    { IDS_CMD_SYNC,                          Sync            },
    { IDS_CMD_SYNC_ALL,                      SyncAll         },
    { IDS_CMD_SHOW_REPS,                     ShowReps        },
    { IDS_CMD_SHOW_VECTOR,                   ShowVector      },
    { IDS_CMD_SHOW_META,                     ShowMeta        },
    { IDS_CMD_ADD_REPS_TO,                   AddRepsTo       },
    { IDS_CMD_UPD_REPS_TO,                   UpdRepsTo       },
    { IDS_CMD_DEL_REPS_TO,                   DelRepsTo       },
    { IDS_CMD_SHOW_TIME,                     ShowTime        },
    { IDS_CMD_SHOW_MSG,                      ShowMsg         },
    { IDS_CMD_OPTIONS,                       Options         },
//  { IDS_CMD_FULL_SYNC_ALL,                 FullSyncAll     }, // removed
    { IDS_CMD_RUN_KCC,                       RunKCC          },
    { IDS_CMD_BIND,                          Bind            },
    { IDS_CMD_QUEUE,                         Queue           },
    { IDS_CMD_PROPCHECK,                     PropCheck       },
    { IDS_CMD_FAILCACHE,                     FailCache       },
    { IDS_CMD_SHOW_ISM,                      ShowIsm         },
    { IDS_CMD_GETCHANGES,                    GetChanges      },
    { IDS_CMD_SHOWSIG,                       ShowSig         },
    { IDS_CMD_SHOWCTX,                       ShowCtx         },
    { IDS_CMD_SHOW_CONN,                     ShowConn        },
    { IDS_CMD_EXPERT_HELP,                   ExpertHelp      },
    { IDS_CMD_SHOW_CERT,                     ShowCert        },
    { IDS_CMD_SHOW_VALUE,                    ShowValue       },
    { IDS_CMD_MOD,                           Mod             },
    { IDS_CMD_LATENCY,                       Latency         },
    { IDS_CMD_ISTG,                          Istg            },
    { IDS_CMD_BRIDGEHEADS,                   Bridgeheads     },
    { IDS_CMD_TESTHOOK,                      TestHook        },
    { IDS_CMD_DSAGUID,                       DsaGuid         },
    { IDS_CMD_SITEOPTIONS,                   SiteOptions     },
    { IDS_CMD_SHOWPROXY,                     ShowProxy       },
    { IDS_CMD_REMOVELINGERINGOBJECTS,        RemoveLingeringObjects },
};


int
__cdecl wmain( int argc, LPWSTR argv[] )
{
    int     ret = 0;
    WCHAR   szCmdName[64];
    DWORD   i;
    HMODULE hMod = GetModuleHandle(NULL);
    UINT               Codepage;
                       // ".", "uint in decimal", null
    char               achCodepage[12] = ".OCP";
    
    //
    // Set locale to the default
    //
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%u", Codepage);
    }
    setlocale(LC_ALL, achCodepage);

    // Initialize debug library.
    DEBUGINIT(0, NULL, "repadmin");

    if (argc < 2) {
       PrintHelp( FALSE /* novice help */ );
    }
    else if (!(ret = PreProcessGlobalParams(&argc, &argv))) {
        for (i=0; i < ARRAY_SIZE(rgCmdTable); i++) {
            raLoadString(rgCmdTable[i].uNameID,
                         ARRAY_SIZE(szCmdName),
                         szCmdName);
            
            if (((argv[1][0] == L'-') || (argv[1][0] == L'/'))
                && (0 == _wcsicmp(argv[1]+1, szCmdName))) {
                // Execute requested command.
                ret = (*rgCmdTable[i].pfFunc)(argc, argv);
                break;
            }
        }

        if (i == ARRAY_SIZE(rgCmdTable)) {
            // Invalid command.
            PrintHelp( FALSE /* novice help */ );
            ret = ERROR_INVALID_FUNCTION;
        }
    }

    DEBUGTERM();
    
    return ret;
}

void PrintHelp(
    BOOL fExpert
    )
{
//
// Commands that are safe for the average admin to do should go here
//
    PrintMsg( REPADMIN_NOVICE_HELP );

    if (!fExpert) {
        return;
    }

//
// Command that could hose a user's enterprise should go here
//

    PrintMsg( REPADMIN_EXPERT_HELP );
}


#define CR        0xD
#define BACKSPACE 0x8

int
GetPassword(
    WCHAR *     pwszBuf,
    DWORD       cchBufMax,
    DWORD *     pcchBufUsed
    )
/*++

Routine Description:

    Retrieve password from command line (without echo).
    Code stolen from LUI_GetPasswdStr (net\netcmd\common\lui.c).

Arguments:

    pwszBuf - buffer to fill with password
    cchBufMax - buffer size (incl. space for terminating null)
    pcchBufUsed - on return holds number of characters used in password

Return Values:

    DRAERR_Success - success
    other - failure

--*/
{
    WCHAR   ch;
    WCHAR * bufPtr = pwszBuf;
    DWORD   c;
    int     err;
    int     mode;

    cchBufMax -= 1;    /* make space for null terminator */
    *pcchBufUsed = 0;               /* GP fault probe (a la API's) */
    
    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode)) {
        err = GetLastError();
        PrintMsg(REPADMIN_FAILED_TO_READ_CONSOLE_MODE);
        return err;
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
        if (!err || c != 1)
            ch = 0xffff;

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
            break;

        if (ch == BACKSPACE) {  /* back up one or two */
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != pwszBuf) {
                bufPtr--;
                (*pcchBufUsed)--;
            }
        }
        else {

            *bufPtr = ch;

            if (*pcchBufUsed < cchBufMax)
                bufPtr++ ;                   /* don't overflow buf */
            (*pcchBufUsed)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = L'\0';         /* null terminate the string */
    PrintMsg(REPADMIN_PRINT_CR);

    if (*pcchBufUsed > cchBufMax)
    {
        //printf("Password too long!\n");
        PrintMsg( REPADMIN_PASSWORD_TOO_LONG );
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}

int
PreProcessGlobalParams(
    int *    pargc,
    LPWSTR **pargv
    )
/*++

Routine Description:

    Scan command arguments for user-supplied credentials of the form
        [/-](u|user):({domain\username}|{username})
        [/-](p|pw|pass|password):{password}
    Set credentials used for future DRS RPC calls and LDAP binds appropriately.
    A password of * will prompt the user for a secure password from the console.

    Also scan args for /async, which adds the DRS_ASYNC_OP flag to all DRS RPC
    calls.

    CODE.IMPROVEMENT: The code to build a credential is also available in
    ntdsapi.dll\DsMakePasswordCredential().

Arguments:

    pargc
    pargv

Return Values:

    ERROR_Success - success
    other - failure

--*/
{
    int     ret = 0;
    int     iArg;
    LPWSTR  pszOption;
    DWORD   cchOption;
    LPWSTR  pszDelim;
    LPWSTR  pszValue;
    DWORD   cchValue;

    for (iArg = 1; iArg < *pargc; )
    {
        if (((*pargv)[iArg][0] != L'/') && ((*pargv)[iArg][0] != L'-'))
        {
            // Not an argument we care about -- next!
            iArg++;
        }
        else
        {
            pszOption = &(*pargv)[iArg][1];
            pszDelim = wcschr(pszOption, L':');

            if (NULL == pszDelim)
            {
                if (0 == _wcsicmp(L"async", pszOption))
                {
                    // This constant is the same for all operations
                    gulDrsFlags |= DS_REPADD_ASYNCHRONOUS_OPERATION;

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else if (0 == _wcsicmp(L"ldap", pszOption))
                {
                    _DsBindSpoofSetTransportDefault( TRUE /* use LDAP */ );

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else if (0 == _wcsicmp(L"rpc", pszOption))
                {
                    _DsBindSpoofSetTransportDefault( FALSE /* use RPC */ );

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else
                {
                    // Not an argument we care about -- next!
                    iArg++;
                }
            }
            else
            {
                cchOption = (DWORD)(pszDelim - (*pargv)[iArg]);

                if (    (0 == _wcsnicmp(L"p:",        pszOption, cchOption))
                     || (0 == _wcsnicmp(L"pw:",       pszOption, cchOption))
                     || (0 == _wcsnicmp(L"pass:",     pszOption, cchOption))
                     || (0 == _wcsnicmp(L"password:", pszOption, cchOption)) )
                {
                    // User-supplied password.
                    pszValue = pszDelim + 1;
                    cchValue = 1 + wcslen(pszValue);

                    if ((2 == cchValue) && ('*' == pszValue[0]))
                    {
                        // Get hidden password from console.
                        cchValue = 64;

                        gCreds.Password = malloc(sizeof(WCHAR) * cchValue);

                        if (NULL == gCreds.Password)
                        {
                            PrintMsg(REPADMIN_PRINT_STRING_ERROR, 
                                     Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }

                        PrintMsg(REPADMIN_PASSWORD_PROMPT);

                        ret = GetPassword(gCreds.Password, cchValue, &cchValue);
                    }
                    else
                    {
                        // Get password specified on command line.
                        gCreds.Password = pszValue;
                    }

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else if (    (0 == _wcsnicmp(L"u:",    pszOption, cchOption))
                          || (0 == _wcsnicmp(L"user:", pszOption, cchOption)) )
                {
                    // User-supplied user name (and perhaps domain name).
                    pszValue = pszDelim + 1;
                    cchValue = 1 + wcslen(pszValue);

                    pszDelim = wcschr(pszValue, L'\\');

                    if (NULL == pszDelim)
                    {
                        // No domain name, only user name supplied.
                        //printf("User name must be prefixed by domain name.\n");
                        PrintMsg( REPADMIN_DOMAIN_BEFORE_USER );
                        return ERROR_INVALID_PARAMETER;
                    }

                    *pszDelim = L'\0';
                    gCreds.Domain = pszValue;
                    gCreds.User = pszDelim + 1;

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else
                {
                    iArg++;
                }
            }
        }
    }

    if (NULL == gCreds.User)
    {
        if (NULL != gCreds.Password)
        {
            // Password supplied w/o user name.
            //printf( "Password must be accompanied by user name.\n" );
            PrintMsg( REPADMIN_PASSWORD_NEEDS_USERNAME );
            ret = ERROR_INVALID_PARAMETER;
        }
        else
        {
            // No credentials supplied; use default credentials.
            ret = ERROR_SUCCESS;
        }
    }
    else
    {
        gCreds.PasswordLength = gCreds.Password ? wcslen(gCreds.Password) : 0;
        gCreds.UserLength   = wcslen(gCreds.User);
        gCreds.DomainLength = gCreds.Domain ? wcslen(gCreds.Domain) : 0;
        gCreds.Flags        = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        // CODE.IMP: The code to build a SEC_WINNT_AUTH structure also exists
        // in DsMakePasswordCredentials.  Someday use it

        // Use credentials in DsBind and LDAP binds
        gpCreds = &gCreds;
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\repadmin.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    repadmin.h

Abstract:

    abstract

Author:

    Will Lees (wlees) 02-Jul-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _REPADMIN_
#define _REPADMIN_

#include "msg.h"

// Global credentials.
extern SEC_WINNT_AUTH_IDENTITY_W   gCreds;
extern SEC_WINNT_AUTH_IDENTITY_W * gpCreds;

// Global DRS RPC call flags.  Should hold 0 or DRS_ASYNC_OP.
extern ULONG gulDrsFlags;

// An zero-filled filetime to compare against
extern FILETIME ftimeZero;

void PrintHelp(
    BOOL fExpert
    );

int Add(int argc, LPWSTR argv[]);
int Del(int argc, LPWSTR argv[]);
int Sync(int argc, LPWSTR argv[]);
int SyncAll(int argc, LPWSTR argv[]);
int ShowReps(int argc, LPWSTR argv[]);
int ShowVector(int argc, LPWSTR argv[]);
int ShowMeta(int argc, LPWSTR argv[]);
int ShowTime(int argc, LPWSTR argv[]);
int ShowMsg(int argc, LPWSTR argv[]);
int Options(int argc, LPWSTR argv[]);
int FullSyncAll(int argc, LPWSTR argv[]);
int RunKCC(int argc, LPWSTR argv[]);
int Bind(int argc, LPWSTR argv[]);
int Queue(int argc, LPWSTR argv[]);
int PropCheck(int argc, LPWSTR argv[]);
int FailCache(int argc, LPWSTR argv[]);
int ShowIsm(int argc, LPWSTR argv[]);
int GetChanges(int argc, LPWSTR argv[]);
int ShowSig(int argc, LPWSTR argv[]);
int ShowCtx(int argc, LPWSTR argv[]);
int ShowConn(int argc, LPWSTR argv[]);
int ShowCert(int argc, LPWSTR argv[]);
int UpdRepsTo(int argc, LPWSTR argv[]);
int AddRepsTo(int argc, LPWSTR argv[]);
int DelRepsTo(int argc, LPWSTR argv[]);
int ShowValue(int argc, LPWSTR argv[]);
int Mod(int argc, LPWSTR argv[]);
int Latency(int argc, LPWSTR argv[]);
int Istg(int argc, LPWSTR argv[]);
int Bridgeheads(int argc, LPWSTR argv[]);
int TestHook(int argc, LPWSTR argv[]);
int DsaGuid(int argc, LPWSTR argv[]);
int SiteOptions(int argc, LPWSTR argv[]);
int ShowProxy(int argc, LPWSTR argv[]);
int RemoveLingeringObjects(int argc, LPWSTR argv[]);


#define IS_REPS_FROM    ( TRUE )
#define IS_REPS_TO      ( FALSE )

#define DEFAULT_PAGED_SEARCH_PAGE_SIZE   (1000)

void
ShowNeighbor(
    DS_REPL_NEIGHBORW * pNeighbor,
    BOOL                fRepsFrom,
    BOOL                fVerbose
    );

LPWSTR GetNtdsDsaDisplayName(LPWSTR pszDsaDN);
LPWSTR GetNtdsSiteDisplayName(LPWSTR pszSiteDN);

int GetSiteOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszSiteDN,
    OUT int *   pnOptions
    );

LPWSTR GetTransportDisplayName(LPWSTR pszTransportDN);

int
GetRootDomainDNSName(
    IN  LPWSTR   pszDSA,
    OUT LPWSTR * ppszRootDomainDNSName
    );

#define AllocConvertWide(a,w) AllocConvertWideEx(CP_ACP,a,w)

DWORD
AllocConvertWideEx(
    IN  INT     nCodePage,
    IN  LPCSTR  StringA,
    OUT LPWSTR *pStringW
    );

LPSTR GetDsaOptionsString(int nOptions);
LPSTR GetSiteOptionsString(int nOptions);
LPWSTR
GetDsaDnsName(
    PLDAP       hld,
    LPWSTR      pwszDsa
    );

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(*(x)))

#define CHK_LD_STATUS( x )                        \
{                                                 \
    ULONG err;                                    \
    if ( LDAP_SUCCESS != (x) )                    \
    {                                             \
        err = LdapMapErrorToWin32(x);             \
        PrintMsg(REPADMIN_GENERAL_LDAP_ERR,       \
                __FILE__,                         \
                __LINE__,                         \
                (x),                              \
                ldap_err2stringW( x ),            \
                err );                            \
        return( x );                              \
    }                                             \
}

#define REPORT_LD_STATUS( x )                     \
{                                                 \
    if ( LDAP_SUCCESS != (x) )                    \
    {                                             \
        PrintMsg(REPADMIN_GENERAL_LDAP_ERR,       \
                __FILE__,                         \
                __LINE__,                         \
                (x),                              \
                ldap_err2stringW( x ) );          \
    }                                             \
}

#define CHK_ALLOC(x) {                            \
    if (NULL == (x)) {                            \
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);     \
        exit(ERROR_OUTOFMEMORY);                  \
    }                                             \
}

#define PrintErrEnd(err)                PrintMsg(REPADMIN_GENERAL_ERR, err, err, Win32ErrToString(err));

#define PrintTabErrEnd(tab, err)        { PrintMsg(REPADMIN_GENERAL_ERR_NUM, err, err); \
                                          PrintTabMsg(tab, REPADMIN_PRINT_STR, Win32ErrToString(err)); }
                                          
#define PrintFuncFailed(pszFunc, err)   { PrintMsg(REPADMIN_GENERAL_FUNC_FAILED, pszFunc);  \
                                          PrintErrEnd(err); }
                                          
#define PrintFuncFailedArgs(pszFunc, args, err)   { PrintMsg(REPADMIN_GENERAL_FUNC_FAILED_ARGS, pszFunc, args);  \
                                          PrintErrEnd(err); }
                                          
#define PrintBindFailed(pszHost, err)   { PrintMsg(REPADMIN_BIND_FAILED, pszHost);  \
                                          PrintErrEnd(err); }
                                          
#define PrintUnBindFailed(err)          { PrintMsg(REPADMIN_BIND_UNBIND_FAILED);  \
                                          PrintErrEnd(err); }


// Define Assert for the free build
#if !DBG
#undef Assert
#define Assert( exp )   { if (!(exp)) PrintMsg(REPADMIN_GENERAL_ASSERT, #exp, __FILE__, __LINE__ ); }
#endif

// reputil.c

typedef struct _GUID_CACHE_ENTRY {
    GUID    Guid;
    WCHAR   szDisplayName[132];
} GUID_CACHE_ENTRY;

LPWSTR
Win32ErrToString(
    IN  ULONG   dwMsgId
    );

LPWSTR
NtdsmsgToString(
    IN  ULONG   dwMsgId
    );

int
BuildGuidCache(
    IN  LDAP *  hld
    );

LPWSTR
GetGuidDisplayName(
    IN  GUID *  pGuid
    );

ULONG
GetPublicOptionByNameW(
    OPTION_TRANSLATION * Table,
    LPWSTR pszPublicOption
    );

LPWSTR
GetOptionsString(
    IN  OPTION_TRANSLATION *  Table,
    IN  ULONG                 PublicOptions
    );

LPWSTR
GetStringizedGuid(
    IN  GUID *  pGuid
    );

void
printBitField(
    DWORD BitField,
    WCHAR **ppszBitNames
    );

void
printSchedule(
    PBYTE pSchedule,
    DWORD cbSchedule
    );

void
totalScheduleUsage(
    PVOID *ppContext,
    PBYTE pSchedule,
    DWORD cbSchedule,
    DWORD cNCs
    );

void
raLoadString(
    IN  UINT    uID,
    IN  DWORD   cchBuffer,
    OUT LPWSTR  pszBuffer
    );

// repldap.c
int
SetDsaOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszDsaDN,
    IN  int     nOptions
    );

int
GetDsaOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszDsaDN,
    OUT int *   pnOptions
    );

void
PrintTabMsg(
    IN  DWORD   dwTabs,
    IN  DWORD   dwMessageCode,
    IN  ...
    );

void
PrintMsg(
    IN  DWORD   dwMessageCode,
    IN  ...
    );

DWORD
GeneralizedTimeToSystemTime(
    LPWSTR IN                   szTime,
    PSYSTEMTIME OUT             psysTime);

void
InitDSNameFromStringDn(
    LPWSTR pszDn,
    PDSNAME pDSName
    );

DWORD
CountNamePartsStringDn(
    LPWSTR pszDn
    );

DWORD
WrappedTrimDSNameBy(
           IN  WCHAR *                          InString,
           IN  DWORD                            NumbertoCut,
           OUT WCHAR **                         OutString
           );

// API for replctrl.c
// Move this to ntdsapi.h someday
DWORD
DsMakeReplCookieForDestW(
    DS_REPL_NEIGHBORW *pNeighbor,
    DS_REPL_CURSORS * pCursors,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    );
DWORD
DsFreeReplCookie(
    PBYTE pCookie
    );
DWORD
DsGetSourceChangesW(
    LDAP *m_pLdap,
    LPWSTR m_pSearchBase,
    LPWSTR pszSourceFilter,
    DWORD dwReplFlags,
    PBYTE pCookieCurr,
    DWORD dwCookieLenCurr,
    LDAPMessage **ppSearchResult,
    BOOL *pfMoreData,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    PWCHAR *ppAttListArray
    );

int
FindConnections(
    LDAP *          hld,
    LPWSTR          pszBaseSearchDn,
    LPWSTR          pszFrom,
    BOOL            fShowConn,
    BOOL            fVerbose,
    BOOL            fIntersite
    );

PWCHAR *
ConvertAttList(
    LPWSTR pszAttList
    );

#endif /* _REPADMIN_ */

/* end repadmin.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\repdsrep.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repdsrep.c - DS Replica functions

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "ReplRpcSpoof.hxx"
#include "repadmin.h"

int Bind(int argc, LPWSTR argv[])
{
    // Keep this in sync with ntdsa.h
    const struct {
        DWORD ID;
        LPSTR psz;
    } rgKnownExts[] = {
        { DRS_EXT_BASE,                         "BASE"                         },
        { DRS_EXT_ASYNCREPL,                    "ASYNCREPL"                    },
        { DRS_EXT_REMOVEAPI,                    "REMOVEAPI"                    },
        { DRS_EXT_MOVEREQ_V2,                   "MOVEREQ_V2"                   },
        { DRS_EXT_GETCHG_COMPRESS,              "GETCHG_COMPRESS"              },
        { DRS_EXT_DCINFO_V1,                    "DCINFO_V1"                    },
        { DRS_EXT_RESTORE_USN_OPTIMIZATION,     "RESTORE_USN_OPTIMIZATION"     },
        // DRS_EXT_ADDENTRY not interesting
        { DRS_EXT_KCC_EXECUTE,                  "KCC_EXECUTE"                  },
        { DRS_EXT_ADDENTRY_V2,                  "ADDENTRY_V2"                  },
        { DRS_EXT_LINKED_VALUE_REPLICATION,     "LINKED_VALUE_REPLICATION"     },
        { DRS_EXT_DCINFO_V2,                    "DCINFO_V2"                    },
        { DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD, "INSTANCE_TYPE_NOT_REQ_ON_MOD" },
        { DRS_EXT_CRYPTO_BIND,                  "CRYPTO_BIND"                  },
        { DRS_EXT_GET_REPL_INFO,                "GET_REPL_INFO"                },
        { DRS_EXT_STRONG_ENCRYPTION,            "STRONG_ENCRYPTION"            },
        { DRS_EXT_DCINFO_VFFFFFFFF,             "DCINFO_VFFFFFFFF"             },
        { DRS_EXT_TRANSITIVE_MEMBERSHIP,        "TRANSITIVE_MEMBERSHIP"        },
        { DRS_EXT_ADD_SID_HISTORY,              "ADD_SID_HISTORY"              },
        { DRS_EXT_POST_BETA3,                   "POST_BETA3"                   },
        // DRS_EXT_GETCHGREQ_V5 not interesting
        { DRS_EXT_GETMEMBERSHIPS2,              "GET_MEMBERSHIPS2"             },
        { DRS_EXT_GETCHGREQ_V6,                 "GETCHGREQ_V6 (WHISTLER PREVIEW)" },
        { DRS_EXT_NONDOMAIN_NCS,                "NONDOMAIN_NCS"                },
        { DRS_EXT_GETCHGREQ_V8,                 "GETCHGREQ_V8 (WHISTLER BETA 1)"  },
        { DRS_EXT_GETCHGREPLY_V5,               "GETCHGREPLY_V5 (WHISTLER BETA 2)"  },
        { DRS_EXT_GETCHGREPLY_V6,               "GETCHGREPLY_V6 (WHISTLER BETA 2)"  },
        { DRS_EXT_ADDENTRYREPLY_V3,             "ADDENTRYREPLY_V3 (WHISTLER BETA 3)" },
        { DRS_EXT_GETCHGREPLY_V7,               "GETCHGREPLY_V7 (WHISTLER BETA 3) " },
        { DRS_EXT_VERIFY_OBJECT,                "VERIFY_OBJECT (WHISTLER BETA 3)" },
        { DRS_EXT_XPRESS_COMPRESSION,           "XPRESS_COMPRESSION"  },
    };

    ULONG       ret = 0;
    ULONG       secondary;
    ULONG       ulOptions = 0;
    int         iArg;
    LPWSTR      pszOnDRA = NULL;
    HANDLE      hDS;
    BindState * pBindState;
    DWORD       iExt;
    GUID *      pSiteGuid;
    DWORD       dwReplEpoch;

    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszOnDRA) {
            pszOnDRA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszOnDRA) {
        pszOnDRA = L"localhost";
    }

    ret = DsBindWithCredW(pszOnDRA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    // Crack DS handle to retrieve extensions of the target DSA.
    pBindState = (BindState *) hDS;

    PrintMsg(REPADMIN_BIND_SUCCESS, pszOnDRA);

    PrintMsg(REPADMIN_BIND_EXT_SUPPORTED_HDR);
    for (iExt = 0; iExt < ARRAY_SIZE(rgKnownExts); iExt++) {
        if(IS_DRS_EXT_SUPPORTED(pBindState->pServerExtensions,
                                    rgKnownExts[iExt].ID)){
            PrintMsg(REPADMIN_BIND_EXT_SUPPORTED_LINE_YES, 
                     rgKnownExts[iExt].psz);
        } else {
            PrintMsg(REPADMIN_BIND_EXT_SUPPORTED_LINE_NO,
                     rgKnownExts[iExt].psz);
        }
    }

    pSiteGuid = SITE_GUID_FROM_DRS_EXT(pBindState->pServerExtensions);
    if (NULL != pSiteGuid) {
        PrintMsg(REPADMIN_BIND_SITE_GUID, GetStringizedGuid(pSiteGuid));
    }

    dwReplEpoch = REPL_EPOCH_FROM_DRS_EXT(pBindState->pServerExtensions);
    PrintMsg(REPADMIN_BIND_REPL_EPOCH, dwReplEpoch);

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    return 0;
}

int Add(int argc, LPWSTR argv[])
{
    ULONG ret = 0, secondary;
    ULONG ulOptions =
        DS_REPADD_WRITEABLE |
        DS_REPADD_INITIAL |
        DS_REPADD_PERIODIC |
        DS_REPADD_USE_COMPRESSION |
        gulDrsFlags;
    UCHAR buffer[sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES];
    PSCHEDULE pSchedule = (PSCHEDULE) &buffer;
    int i = 0;
    BOOL fLocal = FALSE;
    int iArg;
    LPWSTR pszNC;
    LPWSTR pszOnDRA;
    LPWSTR pszSrcDsa;
    LPWSTR DsaDN = NULL;
    LPWSTR TransportDN = NULL;
    HANDLE hDS;


    // assume all the parameters are available and syntactically correct
    if (argc < 5)
    {
        PrintHelp( TRUE /* expert */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments

    pszNC     = argv[ 2 ];
    pszOnDRA  = argv[ 3 ];
    pszSrcDsa = argv[ 4 ];

    // Construct schedule with every 15 minute interval selected

    pSchedule->Size = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    pSchedule->Bandwidth = 0;
    pSchedule->NumberOfSchedules = 1;
    pSchedule->Schedules[0].Type = SCHEDULE_INTERVAL;
    pSchedule->Schedules[0].Offset = sizeof( SCHEDULE );

    memset( buffer + sizeof(SCHEDULE), 0x0f, SCHEDULE_DATA_ENTRIES );

    // Optional arguments

    for ( iArg = 5; iArg < argc; iArg++ )
    {
        if (!_wcsicmp(argv[iArg], L"/syncdisable"))
            ulOptions |= (DS_REPADD_DISABLE_NOTIFICATION |
                          DS_REPADD_DISABLE_PERIODIC);
        else if (!_wcsicmp(argv[iArg], L"/readonly"))
            ulOptions &= ~DS_REPADD_WRITEABLE;
        else if (!_wcsicmp(argv[iArg], L"/mail")) {
            ulOptions |= DS_REPADD_INTERSITE_MESSAGING;
        }
        else if (!_wcsicmp(argv[iArg], L"/asyncrep")) {
            ulOptions |= DS_REPADD_ASYNCHRONOUS_REPLICA;
        }
        else if (!_wcsnicmp(argv[iArg], L"/dsadn:", sizeof("/dsadn:")-1)) {
            DsaDN = argv[iArg] + sizeof("/dsadn:") - 1;
        }
        else if (!_wcsnicmp(argv[iArg], L"/transportdn:",
                            sizeof("/transportdn:")-1)) {
            TransportDN = argv[iArg] + sizeof("/transportdn:") - 1;
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    ret = DsBindWithCredW(pszOnDRA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaAddW(hDS,
                        pszNC,
                        DsaDN,
                        TransportDN,
                        pszSrcDsa,
                        pSchedule,
                        ulOptions);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaAdd", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
        if (ulOptions & DS_REPADD_ASYNCHRONOUS_OPERATION) {
            PrintMsg(REPADMIN_ADD_ENQUEUED_ONE_WAY_REPL, 
                   pszSrcDsa, pszOnDRA);
        }
        else {
            PrintMsg(REPADMIN_ADD_ONE_WAY_REPL_ESTABLISHED,
                     pszSrcDsa, pszOnDRA);
        }
    }

    return ret;
}

int Mod(int argc, LPWSTR argv[])
/*

These are the modifications we support:

DS_REPMOD_UPDATE_FLAGS     - Yes
DS_REPMOD_UPDATE_ADDRESS   - Yes
DS_REPMOD_UPDATE_SCHEDULE  - Is possible from client, but not implemented.
DS_REPMOD_UPDATE_RESULT    - Not possible from client.
DS_REPMOD_UPDATE_TRANSPORT - Not possible from client.

 */

{
    ULONG ret = 0, secondary;
    int i = 0;
    int iArg;
    UUID uuid;
    LPWSTR pszNC;
    LPWSTR pszOnDRA;
    LPWSTR pszUUID;
    LPWSTR pszSrcDsa = NULL;
    LPWSTR DsaDN = NULL;
    LPWSTR TransportDN = NULL;
    PSCHEDULE pSchedule = NULL;
    HANDLE hDS;
    ULONG ulOptions = gulDrsFlags;
    ULONG ulReplicaFlags = 0, ulSetFlags = 0, ulClearFlags = 0;
    ULONG ulModifyFields = 0;
    DS_REPL_NEIGHBORSW *  pNeighbors;
    DS_REPL_NEIGHBORW *   pNeighbor;

    // assume all the parameters are available and syntactically correct
    if (argc < 5)
    {
        PrintHelp( TRUE /* expert */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments

    pszNC     = argv[ 2 ];
    pszOnDRA  = argv[ 3 ];
    pszUUID   = argv[ 4 ];

    // TODO: Provide the ability to specify and modify the schedule

    ret = UuidFromStringW(pszUUID, &uuid);
    if (ret != ERROR_SUCCESS) {
        PrintMsg(REPADMIN_MOD_GUID_CONVERT_FAILED, pszUUID);
        PrintErrEnd(ret);
        return ret;
    }

    ret = DsBindWithCredW(pszOnDRA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    // Verify that the reps-from exists, and read the old flags
    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, pszNC, &uuid,
                            &pNeighbors);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        return ret;
    }

    Assert( pNeighbors );
    pNeighbor = &pNeighbors->rgNeighbor[0];
    ulReplicaFlags = pNeighbor->dwReplicaFlags;
    PrintMsg(REPADMIN_MOD_CUR_REPLICA_FLAGS, 
                    GetOptionsString( RepNbrOptionToDra, ulReplicaFlags ) );

    PrintMsg(REPADMIN_MOD_CUR_SRC_ADDRESS, pNeighbor->pszSourceDsaAddress);

    // Optional arguments

    for ( iArg = 5; iArg < argc; iArg++ )
    {
        if (!_wcsnicmp(argv[iArg], L"/srcdsaaddr:", sizeof("/srcdsaaddr:")-1)) {
            pszSrcDsa = argv[iArg] + sizeof("/srcdsaaddr:") - 1;
            ulModifyFields |= DS_REPMOD_UPDATE_ADDRESS;
        }
        // This is for future use
        else if (!_wcsnicmp(argv[iArg], L"/transportdn:",
                            sizeof("/transportdn:")-1)) {
            TransportDN = argv[iArg] + sizeof("/transportdn:") - 1;
            ulModifyFields |= DS_REPMOD_UPDATE_TRANSPORT;
        }
        else if (*argv[iArg] == L'+') {
            ulSetFlags |=
                GetPublicOptionByNameW( RepNbrOptionToDra, (argv[iArg] + 1) );
        }
        else if (*argv[iArg] == L'-') {
            ulClearFlags |=
                GetPublicOptionByNameW( RepNbrOptionToDra, (argv[iArg] + 1) );
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (ulSetFlags | ulClearFlags) {
        ULONG ulBadFlags = ( (ulSetFlags | ulClearFlags) &
                             (~DS_REPL_NBR_MODIFIABLE_MASK) );
        if (ulBadFlags) {
            PrintMsg( REPADMIN_MOD_FLAGS_NOT_MODABLE, 
                    GetOptionsString( RepNbrOptionToDra, ulBadFlags ) );
        } else {
            ulReplicaFlags |= ulSetFlags;
            ulReplicaFlags &= ~ulClearFlags;
            ulModifyFields |= DS_REPMOD_UPDATE_FLAGS;
        }
    }

    ret = DsReplicaModifyW(hDS,             // hDS
                           pszNC,           // pNameContext
                           &uuid,           // pUuidSourceDsa
                           TransportDN,     // pTransportDn
                           pszSrcDsa,       // pSourceDsaAddress
                           pSchedule,       // pSchedule (NULL)
                           ulReplicaFlags,  // ReplicaFlags
                           ulModifyFields,  // ModifyFields
                           ulOptions        // Options
                           );
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaModify", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
        PrintMsg(REPADMIN_MOD_REPL_LINK_MODIFIED, pszUUID, pszOnDRA);
        if (ulModifyFields & DS_REPMOD_UPDATE_ADDRESS) {
            PrintMsg(REPADMIN_MOD_SRC_ADDR_SET, pszSrcDsa);
        }
        if (ulModifyFields & DS_REPMOD_UPDATE_TRANSPORT) {
            PrintMsg(REPADMIN_MOD_TRANSPORT_DN_SET, TransportDN);
        }
        if (ulModifyFields & DS_REPMOD_UPDATE_FLAGS) {
            PrintMsg(REPADMIN_MOD_REPLICA_FLAGS_SET, 
                    GetOptionsString( RepNbrOptionToDra, ulReplicaFlags ) );
        }
    }

    DsReplicaFreeInfo(DS_REPL_INFO_REPSTO, pNeighbors);

    return ret;
}

int Del(int argc, LPWSTR argv[])
{
    ULONG ret = 0, secondary;
    ULONG ulOptions = DS_REPDEL_WRITEABLE | gulDrsFlags;
    DWORD cLen = 0;
    int iArg;
    LPWSTR pszNC;
    LPWSTR pszOnDRA;
    LPWSTR pszRepsTo = NULL; // aka pszDsaSrc
    HANDLE hDS;

    // assume all the parameters are available and syntactically correct
    if (argc < 5) {
        PrintHelp( TRUE /* expert */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments

    pszNC    = argv[ 2 ];
    pszOnDRA = argv[ 3 ];

    // Optional arguments

    for (iArg = 4; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/localonly")) {
            ulOptions |= DS_REPDEL_LOCAL_ONLY;
        }
        else if (!_wcsicmp(argv[iArg], L"/nosource")) {
            ulOptions |= DS_REPDEL_NO_SOURCE;
        }
        else if (NULL == pszRepsTo) {
            pszRepsTo = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (    ((NULL == pszRepsTo) && !(ulOptions & DS_REPDEL_NO_SOURCE))
         || ((NULL != pszRepsTo) && (ulOptions & DS_REPDEL_NO_SOURCE)) ) {
        PrintMsg(REPADMIN_DEL_ONE_REPSTO);
        return ERROR_INVALID_PARAMETER;
    }

    ret = DsBindWithCredW(pszOnDRA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaDelW(hDS,
                        pszNC,
                        pszRepsTo,
                        ulOptions);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaDel", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
        if (ulOptions & DS_REPDEL_ASYNCHRONOUS_OPERATION) {
            PrintMsg(REPADMIN_DEL_ENQUEUED_ONE_WAY_REPL_DEL,
                   pszRepsTo, pszOnDRA);
        }
        else {
            PrintMsg(REPADMIN_DEL_DELETED_REPL_LINK,
                   pszRepsTo, pszOnDRA);
        }
    }

    return ret;
}

int UpdRefs(int argc, LPWSTR argv[], ULONG ulOptions)
{
    ULONG       ret = 0, secondary;
    LPWSTR      pszNC;
    LPWSTR      pszOnDRA;
    LPWSTR      pszRepsToDRA;
    LPWSTR      pszUUID;
    UUID        uuid;
    int         iArg;
    HANDLE hDS;

    // assume all the parameters are available and syntactically correct
    if (argc < 6) {
        PrintHelp( TRUE /* expert */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments

    pszNC        = argv[ 2 ];
    pszOnDRA     = argv[ 3 ];
    pszRepsToDRA = argv[ 4 ];   // aka pszDsaSrc
    pszUUID      = argv[ 5 ];

    // Optional arguments

    ulOptions |= DS_REPUPD_WRITEABLE | gulDrsFlags;
    for (iArg = 6; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/readonly")) {
            ulOptions &= ~DS_REPUPD_WRITEABLE;
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    ret = UuidFromStringW(pszUUID, &uuid);
    if (ret != ERROR_SUCCESS) {
        PrintMsg(REPADMIN_MOD_GUID_CONVERT_FAILED, pszUUID);
        PrintErrEnd(ret);
        return ret;
    }

    ret = DsBindWithCredW( pszOnDRA,
                           NULL,
                           (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                           &hDS );
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaUpdateRefsW(hDS,
                               pszNC,
                               pszRepsToDRA,
                               &uuid,
                               ulOptions);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaUpdateRefs", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
        if (ulOptions & DS_REPUPD_ASYNCHRONOUS_OPERATION) {
            PrintMsg(REPADMIN_UPDREFS_ENQUEUED_UPDATE_NOTIFICATIONS,
                     pszRepsToDRA, pszOnDRA);
        }
        else {
            PrintMsg(REPADMIN_UPDREFS_UPDATED_NOTIFICATIONS,
                     pszRepsToDRA, pszOnDRA);
        }
    }

    return ret;
}

int UpdRepsTo(int argc, LPWSTR argv[]) {
    return UpdRefs(argc,
                   argv,
                   DS_REPUPD_ADD_REFERENCE | DS_REPUPD_DELETE_REFERENCE);
}

int AddRepsTo(int argc, LPWSTR argv[]) {
    return UpdRefs(argc, argv, DS_REPUPD_ADD_REFERENCE);
}

int DelRepsTo(int argc, LPWSTR argv[]) {
    return UpdRefs(argc, argv, DS_REPUPD_DELETE_REFERENCE);
}

int RunKCC(int argc, LPWSTR argv[])
{
    ULONG   ret = 0;
    ULONG   secondary;
    ULONG   ulOptions = 0;
    int     iArg;
    LPWSTR  pszOnDRA = NULL;
    HANDLE  hDS;

    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszOnDRA) {
            pszOnDRA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszOnDRA) {
        pszOnDRA = L"localhost";
    }

    if (gulDrsFlags & DS_REPADD_ASYNCHRONOUS_OPERATION) {
        ulOptions |= DS_KCC_FLAG_ASYNC_OP;
    }

    ret = DsBindWithCredW(pszOnDRA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaConsistencyCheck(hDS,
                                    DS_KCC_TASKID_UPDATE_TOPOLOGY,
                                    ulOptions);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaConsistencyCheck", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
        if (ulOptions & DS_KCC_FLAG_ASYNC_OP) {
            PrintMsg(REPADMIN_KCC_ENQUEUED_KCC, pszOnDRA);
        }
        else {
            PrintMsg(REPADMIN_KCC_KCC_SUCCESS, pszOnDRA);
        }
    }

    return ret;
}

int Sync(int argc, LPWSTR argv[])
{
    ULONG ulOptions = DS_REPSYNC_WRITEABLE | gulDrsFlags;
    ULONG ret = 0, secondary;
    int iArg;
    UUID uuid = {0};
    HANDLE hDS;

    LPWSTR pszNC;
    LPWSTR pszOnDRA;
    LPWSTR pszUuid;

    // assume all the parameters are available and syntactically correct
    if (argc < 5) {
        PrintHelp( FALSE /* novice */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments
    pszNC    = argv[ 2 ];
    pszOnDRA = argv[ 3 ];
    pszUuid  = argv[ 4 ];

    iArg = 5;

    // Was UUID specified?
    ret = UuidFromStringW(pszUuid, &uuid);
    if (ret != ERROR_SUCCESS) {
        pszUuid = NULL;
        --iArg;
    }

    // Optional arguments
    for (; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/Force")) {
            ulOptions |= DS_REPSYNC_FORCE;
        }
        else if (!_wcsicmp(argv[iArg], L"/ReadOnly")) {
            ulOptions &= ~DS_REPSYNC_WRITEABLE;
        }
        else if (!_wcsicmp(argv[iArg], L"/mail")) {
            ulOptions |= DS_REPSYNC_INTERSITE_MESSAGING;
        }
        else if (!_wcsicmp(argv[iArg], L"/Full")) {
            ulOptions |= DS_REPSYNC_FULL;
        }
        else if (!_wcsicmp(argv[iArg], L"/addref")) {
            ulOptions |= DS_REPSYNC_ADD_REFERENCE;
        }
        else if (!_wcsicmp(argv[iArg], L"/allsources")) {
            ulOptions |= DS_REPSYNC_ALL_SOURCES;
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (((NULL == pszUuid) && !(ulOptions & DS_REPSYNC_ALL_SOURCES))
        || ((NULL != pszUuid) && (ulOptions & DS_REPSYNC_ALL_SOURCES))) {
        PrintMsg(REPADMIN_SYNC_SRC_GUID_OR_ALLSRC);
        return ERROR_INVALID_FUNCTION;
    }

    ret = DsBindWithCredW(pszOnDRA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaSyncW(hDS, pszNC, &uuid, ulOptions);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaSync", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
        if (ulOptions & DS_REPUPD_ASYNCHRONOUS_OPERATION) {
            if(pszUuid){
                PrintMsg(REPADMIN_SYNC_ENQUEUED_SYNC,
                       pszUuid,
                       pszOnDRA);
            } else {
                PrintMsg(REPADMIN_SYNC_ENQUEUED_SYNC_ALL_NEIGHBORS,
                       pszOnDRA);
            }
        } else {
            if(pszUuid){
                PrintMsg(REPADMIN_SYNC_SYNC_SUCCESS,
                       pszUuid,
                       pszOnDRA);
            } else {
                PrintMsg(REPADMIN_SYNC_SYNC_SUCCESS_ALL_NEIGHBORS,
                       pszOnDRA);
            }
        }
    }

    return ret;
}

int RemoveLingeringObjects(int argc, LPWSTR argv[])
{
    ULONG   ret = 0;
    ULONG   secondary;
    int     iArg;
    LPWSTR  pszNC = NULL;
    HANDLE  hDS;
    LPWSTR  pszSourceInput = NULL;
    LPWSTR  pszDestinationInput = NULL;
    UUID    uuidSource;
    ULONG   ulOptions = 0;
    RPC_STATUS rpcStatus = RPC_S_OK;

    // input should be 
    // <computer-name-of-destiniation>
    //      <computer-guid-of-source>
    //      <NC>
    //      [/ADVISORY_MODE]
    if (argc<4) {
	PrintMsg(REPADMIN_GENERAL_INVALID_ARGS);
	return ERROR_INVALID_FUNCTION;
    }

    for (iArg = 2; iArg < argc; iArg++) { 
        if (iArg==2) {
            pszDestinationInput = argv[iArg];
        }
	else if (iArg==3) {
	    pszSourceInput = argv[iArg];
	}
	else if (iArg==4) {
	    pszNC = argv[iArg];
	}
	else if ((iArg==5) && (!_wcsicmp(argv[iArg],L"/ADVISORY_MODE"))) {
	    ulOptions = DS_EXIST_ADVISORY_MODE;  
	} 
    }

    ret = DsBindWithCredW(pszDestinationInput,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszDestinationInput, ret);
        return ret;
    }

    // currently input is <dns or netbios name> <guid> <NC>
    rpcStatus = UuidFromStringW(pszSourceInput, &uuidSource);	
    if (rpcStatus!=RPC_S_OK) {
	PrintMsg(REPADMIN_GENERAL_INVALID_ARGS);
	return ERROR_INVALID_FUNCTION;
    }

    ret = DsReplicaVerifyObjectsW(hDS, 
				  pszNC,
				  &uuidSource,
				  ulOptions);

    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaVerifyObjectsW", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
	PrintMsg(REPADMIN_REMOVELINGERINGOBJECTS_SUCCESS, pszDestinationInput);
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\repgtchg.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repgtchg.c - get changes command

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#undef LDAP_UNICODE
#define LDAP_UNICODE 1

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "ReplRpcSpoof.hxx"
#include "repadmin.h"

//
// LDAP names
//
const WCHAR g_szObjectGuid[]        = L"objectGUID";
const WCHAR g_szParentGuid[]        = L"parentGUID";
const WCHAR g_szObjectClass[]       = L"objectClass";
const WCHAR g_szIsDeleted[]         = L"isDeleted";
const WCHAR g_szRDN[]               = L"name";
const WCHAR g_szProxiedObjectName[] = L"proxiedObjectName";

#define OBJECT_UNKNOWN              0
#define OBJECT_ADD                  1
#define OBJECT_MODIFY               2
#define OBJECT_DELETE               3
#define OBJECT_MOVE                 4
#define OBJECT_UPDATE               5
#define OBJECT_INTERDOMAIN_MOVE     6
#define OBJECT_MAX                  7

static LPSTR szOperationNames[] = {
    "unknown",
    "add",
    "modify",
    "delete",
    "move",
    "update",
    "interdomain move"
};

#define NUMBER_BUCKETS 5
#define BUCKET_SIZE 250

typedef struct _STAT_BLOCK {
    DWORD dwPackets;
    DWORD dwObjects;
    DWORD dwOperations[OBJECT_MAX];
    DWORD dwAttributes;
    DWORD dwValues;
// dn-value performance monitoring
    DWORD dwDnValuedAttrOnAdd[NUMBER_BUCKETS];
    DWORD dwDnValuedAttrOnMod[NUMBER_BUCKETS];
    DWORD dwDnValuedAttributes;
    DWORD dwDnValuesMaxOnAttr;
    WCHAR szMaxObjectName[1024];
    WCHAR szMaxAttributeName[256];
} STAT_BLOCK, *PSTAT_BLOCK;


void
printStatistics(
    ULONG ulTitle,
    PSTAT_BLOCK pStatistics
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PrintMsg(ulTitle);
    PrintMsg(REPADMIN_GETCHANGES_PRINT_STATS_1,
             pStatistics->dwPackets,
             pStatistics->dwObjects,
             pStatistics->dwOperations[OBJECT_ADD],
             pStatistics->dwOperations[OBJECT_MODIFY],
             pStatistics->dwOperations[OBJECT_DELETE],
             (pStatistics->dwOperations[OBJECT_MOVE] +
                pStatistics->dwOperations[OBJECT_UPDATE] +
                pStatistics->dwOperations[OBJECT_INTERDOMAIN_MOVE]) );
    PrintMsg(REPADMIN_GETCHANGES_PRINT_STATS_2,
             pStatistics->dwAttributes,
             pStatistics->dwValues,
             pStatistics->dwDnValuedAttributes,
             pStatistics->dwDnValuesMaxOnAttr,
             pStatistics->szMaxObjectName,
             pStatistics->szMaxAttributeName ); 
    PrintMsg(REPADMIN_GETCHANGES_PRINT_STATS_3,
             pStatistics->dwDnValuedAttrOnAdd[0],
             pStatistics->dwDnValuedAttrOnAdd[1],
             pStatistics->dwDnValuedAttrOnAdd[2],
             pStatistics->dwDnValuedAttrOnAdd[3],
             pStatistics->dwDnValuedAttrOnAdd[4],
             pStatistics->dwDnValuedAttrOnMod[0],
             pStatistics->dwDnValuedAttrOnMod[1],
             pStatistics->dwDnValuedAttrOnMod[2],
             pStatistics->dwDnValuedAttrOnMod[3],
             pStatistics->dwDnValuedAttrOnMod[4] );
}

DWORD
GetSourceOperation(
    LDAP *pLdap,
    LDAPMessage *pLdapEntry
    )

/*++

THIS ROUTINE TAKEN FROM DIRSYNC\DSSERVER\ADREAD\UTILS.CPP

Routine Description:

    Depending on the attributes found in the entry, this function determines
    what changes were done on the DS to cause us to read this entry. For
    example, this funciton whether the entry was Added, Deleted, Modified,
    or Moved since we last read changes from the DS.

Arguments:

    pLdap - Pointer to LDAP session
    pLdapEntry - Pointer to the LDAP entry

Return Value:

    Source operation performed on the entry

--*/

{
    BerElement *pBer = NULL;
    PWSTR attr;
    BOOL fModify = FALSE;
    DWORD dwSrcOp = OBJECT_UNKNOWN;

    for (attr = ldap_first_attribute(pLdap, pLdapEntry, &pBer);
         attr != NULL;
         attr = ldap_next_attribute(pLdap, pLdapEntry, pBer))
    {
        //
        // Check if we have an Add operation
        //

        if (wcscmp(attr, g_szObjectClass) == 0)
        {
            //
            // Delete takes higher priority
            //

            if (dwSrcOp != OBJECT_DELETE)
                dwSrcOp = OBJECT_ADD;
         }

        //
        // Check if we have a delete operation
        //

        else if (wcscmp(attr, g_szIsDeleted) == 0)
        {
            //
            // Inter-domain move takes highest priority
            //

            if (dwSrcOp != OBJECT_INTERDOMAIN_MOVE)
            {
                //
                // Check if the value of the attribute is "TRUE"
                //

                PWCHAR *ppVal;

                ppVal = ldap_get_values(pLdap, pLdapEntry, attr);

                if (ppVal &&
                    ppVal[0] &&
                    wcscmp(ppVal[0], L"TRUE") == 0) {
                    dwSrcOp = OBJECT_DELETE;
                }

                ldap_value_free(ppVal);
            }
        }

        //
        // Check if we have a move operation
        //

        else if (wcscmp(attr, g_szRDN) == 0)
        {
            //
            // Add and delete both get RDN and take higher priority
            //

            if (dwSrcOp == OBJECT_UNKNOWN)
                dwSrcOp = OBJECT_MOVE;
        }

        //
        // Check if we have an interdomain object move
        //

        else if (wcscmp(attr, g_szProxiedObjectName) == 0)
        {
            dwSrcOp = OBJECT_INTERDOMAIN_MOVE;
            break;      // Has highest priority
        }

        //
        // Everything else is a modification
        //

        else
            fModify = TRUE;

    }

    if (fModify)
    {
        //
        // A move can be combined with a modify, if so mark as such
        //

        if (dwSrcOp == OBJECT_MOVE)
            dwSrcOp = OBJECT_UPDATE;

        //
        // Check if it is a vanilla modify
        //

        else if (dwSrcOp == OBJECT_UNKNOWN)
            dwSrcOp = OBJECT_MODIFY;
    }


    //
    // If all went well, the entry cannot be unknown anymore
    //

    ASSERT(dwSrcOp != OBJECT_UNKNOWN);

    return dwSrcOp;
}


void
printValue(
    LPWSTR pwzAttr,
    PBYTE pbValue,
    DWORD cbValue
    )

/*++

Routine Description:

Try to infer what datatype an LDAP binary value is and print it out

Arguments:

    pwzAttr - Attribute name
    pbValue -
    cbValue -

Return Value:

    None

--*/

{
    DWORD status;

    if ( ( (wcsstr( pwzAttr, L"guid" ) != NULL) ||
           (wcsstr( pwzAttr, L"GUID" ) != NULL) ) &&
         (cbValue == sizeof( GUID ) ) ) {
        LPSTR pszGuid = NULL;

        // Guid valued

        status = UuidToString( (GUID *) pbValue, &pszGuid );
        if (status == ERROR_SUCCESS) {
            PrintMsg( REPADMIN_PRINT_SHORT_STR_NO_CR, pszGuid);
            RpcStringFree( &pszGuid );
        } else {
            PrintMsg(REPADMIN_GETCHANGES_INVALID_GUID_NO_CR);
        }
    } else if (strncmp( pbValue, "<GUID=", 6) == 0 ) {
        LPSTR p1, p2;
        // Parse extended dn (fyi guid and sid in here if we need it)
        p1 = strstr( pbValue, ">;" );
        if (p1) {
            p1 += 2;
            p2 = strstr( p1, ">;" );
            if (p2) {
                p1 = p2 + 2;
            }
            PrintMsg(REPADMIN_PRINT_SHORT_STR_NO_CR, p1);
        } else {
            PrintMsg(REPADMIN_GETCHANGES_INVALID_DN_NO_CR);
        }
    } else {
        BOOL fVisible = TRUE;
        DWORD i;
        PBYTE p;
        for( i = 0, p = pbValue; i < cbValue; i++, p++ ) {
            if (!isalpha(*p) &&
                !isspace(*p) &&
                !isdigit(*p) &&
                !isgraph(*p) &&
                *p != 0               // accept Null terminated strings
                )
            {
                fVisible = FALSE;
                break;
            }
        }

        if (fVisible) {
            PrintMsg(REPADMIN_PRINT_SHORT_STR_NO_CR, pbValue);
        } else {
            // Unrecognized datatype
            // todo: sids, timevals
            PrintMsg(REPADMIN_GETCHANGES_BYTE_BLOB_NO_CR, cbValue);
        }
    }
} /* printValue */


void
displayChangeEntries(
    LDAP *pLdap,
    LDAPMessage *pSearchResult,
    BOOL fVerbose,
    PSTAT_BLOCK pStatistics
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD i;
    DWORD dwObjects = 0, dwAttributes = 0, dwValues = 0;
    PWSTR pszLdapDN, pszActualDN;
    LDAPMessage *pLdapEntry;
    BerElement *pBer = NULL;
    PWSTR attr;
    LPWSTR p1, p2;
    DWORD dwSrcOp, bucket;

    dwObjects = ldap_count_entries(pLdap, pSearchResult);
    if (dwObjects == 0) {
        PrintMsg(REPADMIN_GETCHANGES_NO_CHANGES);
        return;
    }

    if (fVerbose) {
        PrintMsg(REPADMIN_GETCHANGES_OBJS_RET, dwObjects);
    }

    i=0;
    pLdapEntry = ldap_first_entry( pLdap, pSearchResult );
    while ( i < dwObjects ) {

        pszLdapDN = ldap_get_dnW(pLdap, pLdapEntry);
        if (pszLdapDN == NULL) {
            PrintMsg(REPADMIN_GETCHANGES_DN_MISSING);
            goto next_entry;
        }

        // What kind of operation is it?
        dwSrcOp = GetSourceOperation( pLdap, pLdapEntry );
        pStatistics->dwOperations[dwSrcOp]++;

        // Parse extended dn (fyi guid and sid in here if we need it)
        p1 = wcsstr( pszLdapDN, L">;" );
        if (p1) {
            p1 += 2;
            p2 = wcsstr( p1, L">;" );
            if (p2) {
                p1 = p2 + 2;
            }
            if (fVerbose) {
                PrintMsg(REPADMIN_GETCHANGES_DATA_1, i,
                        szOperationNames[dwSrcOp], p1 );
            }
        } else {
            PrintMsg(REPADMIN_GETCHANGES_INVALID_DN_2, i);
        }

        // List attributes in object
        for (attr = ldap_first_attributeW(pLdap, pLdapEntry, &pBer);
             attr != NULL;
             attr = ldap_next_attributeW(pLdap, pLdapEntry, pBer))
        {
            struct berval **ppBerVal = NULL;
            DWORD cValues, i;

            ppBerVal = ldap_get_values_lenW(pLdap, pLdapEntry, attr);
            if (ppBerVal == NULL) {
                goto loop_end;
            }
            cValues = ldap_count_values_len( ppBerVal );
            if (!cValues) {
                goto loop_end;
            }

            dwAttributes++;
            dwValues += cValues;

            // Detect dn-valued attributes
            if ( (cValues) &&
                 (strncmp( ppBerVal[0]->bv_val, "<GUID=", 6) == 0 )) {

                pStatistics->dwDnValuedAttributes++;
                if (cValues > pStatistics->dwDnValuesMaxOnAttr) {
                    pStatistics->dwDnValuesMaxOnAttr = cValues;
                    lstrcpynW( pStatistics->szMaxObjectName, p1, 1024 );
                    lstrcpynW( pStatistics->szMaxAttributeName, attr, 256 );
                }

                bucket = (cValues - 1) / BUCKET_SIZE;
                if (bucket >= NUMBER_BUCKETS) {
                    bucket = NUMBER_BUCKETS - 1;
                }
                if (dwSrcOp == OBJECT_ADD) {
                    pStatistics->dwDnValuedAttrOnAdd[bucket]++;
                } else {
                    pStatistics->dwDnValuedAttrOnMod[bucket]++;
                }
            }

            if (fVerbose) {
                PrintMsg(REPADMIN_GETCHANGES_DATA_2_NO_CR, cValues, attr );

                printValue( attr, ppBerVal[0]->bv_val, ppBerVal[0]->bv_len );
                for( i = 1; i < min( cValues, 1000 ); i++ ) {
                    PrintMsg(REPADMIN_GETCHANGES_SEMICOLON_NO_CR);
                    printValue( attr, ppBerVal[i]->bv_val, ppBerVal[i]->bv_len );
                }
                PrintMsg(REPADMIN_PRINT_CR);
            }

        loop_end:
            ldap_value_free_len(ppBerVal);
        }

    next_entry:
        if (pszLdapDN)
            ldap_memfreeW(pszLdapDN);
        i++;
        pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    }

    pStatistics->dwPackets++;
    pStatistics->dwObjects += dwObjects;
    pStatistics->dwAttributes += dwAttributes;
    pStatistics->dwValues += dwValues;
}

int GetChanges(int argc, LPWSTR argv[])
{
    DWORD                 ret, lderr;
    int                   iArg;
    BOOL                  fVerbose = FALSE;
    BOOL                  fStatistics = FALSE;
    LPWSTR                pszDSA = NULL;
    UUID *                puuid = NULL;
    UUID                  uuid;
    LPWSTR                pszNC = NULL;
    LPWSTR                pszCookieFile = NULL;
    LPWSTR                pszAttList = NULL;
    LPWSTR                pszSourceFilter = NULL;

    PBYTE                 pCookie = NULL;
    DWORD                 dwCookieLength = 0;
    LDAP *                hld = NULL;
    BOOL                  fMoreData = TRUE;
    LDAPMessage *         pChangeEntries = NULL;
    HANDLE                hDS = NULL;
    DS_REPL_NEIGHBORSW *  pNeighbors = NULL;
    DS_REPL_NEIGHBORW *   pNeighbor;
    DWORD                 i;
    DS_REPL_CURSORS * pCursors = NULL;
    DWORD             iCursor;
    PWCHAR                *ppAttListArray = NULL;
#define INITIAL_COOKIE_BUFFER_SIZE (8 * 1024)
    BYTE              bCookie[INITIAL_COOKIE_BUFFER_SIZE];
    BOOL              fCookieAllocated = FALSE;
    STAT_BLOCK        statistics;
    DWORD             dwReplFlags = DRS_DIRSYNC_INCREMENTAL_VALUES;
    ULONG             ulOptions;

    memset( &statistics, 0, sizeof( STAT_BLOCK ) );

    // TODO TODO TODO TODO
    // Provide a way to construct customized cookies.  For example, setting
    // the usn vector to zero results in a full sync.  This may be done by
    // specifying no or an empty cookie file. Setting the attribute filter usn
    // itself to zero results in changed objects with all attributes.  Specifying
    // a usn vector without an UTD results in all objects not received by the dest
    // from the source, even throught the source may have gotten them through other
    // neighbors.
    // TODO TODO TODO TODO

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/v")
            || !_wcsicmp(argv[ iArg ], L"/verbose")) {
            fVerbose = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/s")
            || !_wcsicmp(argv[ iArg ], L"/statistics")) {
            fStatistics = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/ni")
            || !_wcsicmp(argv[ iArg ], L"/noincremental")) {
            dwReplFlags &= ~DRS_DIRSYNC_INCREMENTAL_VALUES;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/a")
            || !_wcsicmp(argv[ iArg ], L"/ancestors")) {
            dwReplFlags |= DRS_DIRSYNC_ANCESTORS_FIRST_ORDER;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/os")
            || !_wcsicmp(argv[ iArg ], L"/objectsecurity")) {
            dwReplFlags |= DRS_DIRSYNC_OBJECT_SECURITY;
        }
        else if (!_wcsnicmp(argv[ iArg ], L"/cookie:", 8)) {
            pszCookieFile = argv[ iArg ] + 8;
        }
        else if (!_wcsnicmp(argv[ iArg ], L"/atts:", 6)) {
            pszAttList = argv[ iArg ] + 6;
        }
        else if (!_wcsnicmp(argv[ iArg ], L"/filter:", 8)) {
            pszSourceFilter = argv[ iArg ] + 8;
        }
        else if ((NULL == pszNC) && (NULL != wcschr(argv[iArg], L','))) {
            pszNC = argv[iArg];
        }
        else if ((NULL == puuid)
                 && (0 == UuidFromStringW(argv[iArg], &uuid))) {
            puuid = &uuid;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (pszNC == NULL) {
        //
        PrintMsg(REPADMIN_PRINT_NO_NC);
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    // Default is stream
    if ( (!fVerbose) && (!fStatistics) ) {
        fVerbose = TRUE;
    }

    if (NULL != pszAttList) {
        ppAttListArray = ConvertAttList(pszAttList);
    }

    /**********************************************************************/
    /* Compute the initial cookie */
    /**********************************************************************/

    if (puuid == NULL) {
        FILE *stream = NULL;
        DWORD size;
        if ( (pszCookieFile) &&
             (stream = _wfopen( pszCookieFile, L"rb" )) ) {
            size = fread( bCookie, 1/*bytes*/,INITIAL_COOKIE_BUFFER_SIZE/*items*/, stream );
            if (size) {
                pCookie = bCookie;
                dwCookieLength = size;
                PrintMsg(REPADMIN_GETCHANGES_USING_COOKIE_FILE,
                        pszCookieFile, size );
            } else {
                PrintMsg(REPADMIN_GETCHANGES_COULDNT_READ_COOKIE, pszCookieFile );
            }
            fclose( stream );
        } else {
            PrintMsg(REPADMIN_GETCHANGES_EMPTY_COOKIE);
        }
    } else {
        PrintMsg(REPADMIN_GETCHANGES_BUILDING_START_POS, pszDSA);
        ret = DsBindWithCredW(pszDSA,
                              NULL,
                              (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                              &hDS);
        if (ERROR_SUCCESS != ret) {
            PrintBindFailed(pszDSA, ret);
            goto error;
        }

        //
        // Display replication state associated with inbound neighbors.
        //

        ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, pszNC, puuid,
                                &pNeighbors);
        if (ERROR_SUCCESS != ret) {
            PrintFuncFailed(L"DsReplicaGetInfo", ret);
            goto error;
        }

        Assert( pNeighbors->cNumNeighbors == 1 );

        pNeighbor = &pNeighbors->rgNeighbor[0];
        PrintMsg(REPADMIN_GETCHANGES_SRC_NEIGHBOR, pNeighbor->pszNamingContext);

        ShowNeighbor(pNeighbor, IS_REPS_FROM, TRUE);

        // Get Up To Date Vector

        ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_CURSORS_FOR_NC, pszNC, NULL,
                                &pCursors);
        if (ERROR_SUCCESS != ret) {
            PrintFuncFailed(L"DsReplicaGetInfo", ret);
            goto error;
        }

        
        PrintMsg(REPADMIN_GETCHANGES_DST_UTD_VEC);
        for (iCursor = 0; iCursor < pCursors->cNumCursors; iCursor++) {
            PrintMsg(REPADMIN_GETCHANGES_DST_UTD_VEC_ONE_USN, 
                   GetGuidDisplayName(&pCursors->rgCursor[iCursor].uuidSourceDsaInvocationID),
                   pCursors->rgCursor[iCursor].usnAttributeFilter);
        }

        // Get the changes

        ret = DsMakeReplCookieForDestW( pNeighbor, pCursors, &pCookie, &dwCookieLength );
        if (ERROR_SUCCESS != ret) {
            PrintFuncFailed(L"DsGetReplCookieFromDest", ret);
            goto error;
        }
        fCookieAllocated = TRUE;
        pszDSA = pNeighbor->pszSourceDsaAddress;
    }

    /**********************************************************************/
    /* Get the changes using the cookie */
    /**********************************************************************/

    //
    // Connect to source
    //

    PrintMsg(REPADMIN_GETCHANGES_SRC_DSA_HDR, pszDSA);
    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        ret = ERROR_DS_SERVER_DOWN;
        goto error;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    //
    // Bind
    //

    lderr = ldap_bind_sA(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(lderr);

    //
    // Check filter syntax
    //
    if (pszSourceFilter) {
        lderr = ldap_check_filterW( hld, pszSourceFilter );
        CHK_LD_STATUS(lderr);
    }

    //
    // Loop getting changes untl done or error
    //

    ZeroMemory( &statistics, sizeof( STAT_BLOCK ) );

    ret = ERROR_SUCCESS;
    while (fMoreData) {
        PBYTE pCookieNew;
        DWORD dwCookieLengthNew;

        ret = DsGetSourceChangesW(
            hld,
            pszNC,
            pszSourceFilter,
            dwReplFlags,
            pCookie,
            dwCookieLength,
            &pChangeEntries,
            &fMoreData,
            &pCookieNew,
            &dwCookieLengthNew,
            ppAttListArray
            );
        if (ret != ERROR_SUCCESS) {
            // New cookie will not be allocated
            break;
        }

        // Display changes
        displayChangeEntries(
            hld, pChangeEntries, fVerbose,
            &statistics );

        if (fStatistics) {
            printStatistics( REPADMIN_GETCHANGES_PRINT_STATS_HDR_CUM_TOT,
                             &statistics );
        }

        // Release changes
        ldap_msgfree(pChangeEntries);

        // get rid of old cookie
        if ( fCookieAllocated && pCookie ) {
            DsFreeReplCookie( pCookie );
        }
        // Make new cookie the current cookie
        pCookie = pCookieNew;
        dwCookieLength = dwCookieLengthNew;
        fCookieAllocated = TRUE;
    }

    if (fStatistics) {
        printStatistics( REPADMIN_GETCHANGES_PRINT_STATS_HDR_GRD_TOT,
                         &statistics );
    }

    /**********************************************************************/
    /* Write out new cookie */
    /**********************************************************************/

    // If we have a cookie and cookie file was specified, write out the new cookie
    if (pCookie && pszCookieFile) {
        FILE *stream = NULL;
        DWORD size;
        if (stream = _wfopen( pszCookieFile, L"wb" )) {
            size = fwrite( pCookie, 1/*bytes*/, dwCookieLength/*items*/, stream );
            if (size == dwCookieLength) {
                PrintMsg(REPADMIN_GETCHANGES_COOKIE_FILE_WRITTEN,
                         pszCookieFile, size );
            } else {
                PrintMsg(REPADMIN_GETCHANGES_COULDNT_WRITE_COOKIE, pszCookieFile );
            }
            fclose( stream );
        } else {
            PrintMsg(REPADMIN_GETCHANGES_COULDNT_OPEN_COOKIE, pszCookieFile );
        }
    }
error:
    if (hDS) {
        DsUnBind(&hDS);
    }

    if (hld) {
        ldap_unbind(hld);
    }

    // Free replica info

    if (pNeighbors) {
        DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
    }
    if (pCursors) {
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors);
    }
    // Close DS handle

    if ( fCookieAllocated && pCookie) {
        DsFreeReplCookie( pCookie );
    }

    if (ppAttListArray) {
        free(ppAttListArray);
    }

    return ret;
}


PWCHAR *
ConvertAttList(
    LPWSTR pszAttList
    )
/*++

Routine Description:

    Converts a comma delimitted list of attribute names into a NULL terminated
    array of attribute names suitable to be passed to one of the ldap_* functions.

Arguments:

    pszAttList - The comma delimitted list of attribute names.

Return Value:

    On success the function returns a pointer to the NULL terminated
    array of attribute names.  This should be free'd by free().

    On failure the function returns NULL.

--*/
{
    DWORD    i;
    DWORD    dwAttCount;
    PWCHAR   *ppAttListArray;
    PWCHAR   ptr;

    // Count the comma's to get an idea of how many attributes we have.
    // Ignore any leading comma's.  There shouldn't be any, but you never
    // know.

    if (pszAttList[0] == L',') {
        while (pszAttList[0] == L',') {
            pszAttList++;
        }
    }

    // Check to see if there is anything besides commas.
    if (pszAttList[0] == L'\0') {
        // there are no att names here.
        return NULL;
    }

    // Start the main count of commas.
    for (i = 0, dwAttCount = 1; pszAttList[i] != L'\0'; i++) {
        if (pszAttList[i] == L',') {
            dwAttCount++;
            // skip any following adjacent commas.
            while (pszAttList[i] == L',') {
                i++;
            }
            if (pszAttList[i] == L'\0') {
                break;
            }
        }
    }
    // See if there was a trailing comma.
    if (pszAttList[i-1] == L',') {
        dwAttCount--;
    }

    // Alloc the array of pointers with an extra element for the NULL
    // termination.
    ppAttListArray = (PWCHAR *)malloc(sizeof(PWCHAR) * (dwAttCount + 1));
    if (!ppAttListArray) {
        // no memory.
        return NULL;
    }

    // Now begin filling in the array.
    // fill in the first element.
    if (pszAttList[0] != L'\0') {
        ppAttListArray[0] = pszAttList;
    } else {
        ppAttListArray[0] = NULL;
    }

    // Start the main loop.
    for (i = 0, dwAttCount = 1; pszAttList[i] != L'\0'; i++) {
        if (pszAttList[i] == L',') {
            // Null terminate this attribute name.
            pszAttList[i++] = L'\0';
            if (pszAttList[i] == L'\0') {
                break;
            }

            // skip any following adjacent commas.
            while (pszAttList[i] == L',') {
                i++;
            }
            // If we aren't at the end insert this pointer into the list.
            if (pszAttList[i] == L'\0') {
                break;
            }
            ppAttListArray[dwAttCount++] = &pszAttList[i];
        }
    }
    ppAttListArray[dwAttCount] = NULL;

    return ppAttListArray;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\repinfo.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repinfo.c - commands that get information

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

    10/12/2000    Greg Johnson (gregjohn)

        Added support for /latency in ShowVector to order the UTD Vector by repl latencies.
   

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "ReplRpcSpoof.hxx"
#include "repadmin.h"

int Queue(int argc, LPWSTR argv[])
{
    ULONG                   ret = 0;
    ULONG                   secondary;
    int                     iArg;
    LPWSTR                  pszOnDRA = NULL;
    HANDLE                  hDS;
    DS_REPL_PENDING_OPSW *  pPendingOps;
    DS_REPL_OPW *           pOp;
    CHAR                    szTime[SZDSTIME_LEN];
    DSTIME                  dsTime;
    DWORD                   i;
    LPSTR                   pszOpType;
    OPTION_TRANSLATION *    pOptionXlat;

    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszOnDRA) {
            pszOnDRA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszOnDRA) {
        pszOnDRA = L"localhost";
    }

    ret = DsBindWithCredW(pszOnDRA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_PENDING_OPS, NULL, NULL,
                            &pPendingOps);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        // keep going
    }
    else {
        PrintMsg(REPADMIN_QUEUE_CONTAINS, pPendingOps->cNumPendingOps);
        if (pPendingOps->cNumPendingOps) {
            if (memcmp( &pPendingOps->ftimeCurrentOpStarted, &ftimeZero,
                    sizeof( FILETIME ) ) == 0) {
                PrintMsg(REPADMIN_QUEUE_MAIL_TH_EXEC);
                PrintMsg(REPADMIN_PRINT_CR);
            } else {
                DSTIME dsTimeNow = GetSecondsSince1601();
                int dsElapsed;

                FileTimeToDSTime(pPendingOps->ftimeCurrentOpStarted, &dsTime);

                PrintMsg(REPADMIN_QUEUE_CUR_TASK_EXEC,
                       DSTimeToDisplayString(dsTime, szTime));

                dsElapsed = (int) (dsTimeNow - dsTime);
                PrintMsg(REPADMIN_QUEUE_CUR_TASK_EXEC_TIME, 
                        dsElapsed / 60, dsElapsed % 60 );
            }
        }

        pOp = &pPendingOps->rgPendingOp[0];
        for (i = 0; i < pPendingOps->cNumPendingOps; i++, pOp++) {
            FileTimeToDSTime(pOp->ftimeEnqueued, &dsTime);

            PrintMsg(REPADMIN_QUEUE_ENQUEUED_DATA_ITEM_HDR,
                   pOp->ulSerialNumber,
                   DSTimeToDisplayString(dsTime, szTime),
                   pOp->ulPriority);

            switch (pOp->OpType) {
            case DS_REPL_OP_TYPE_SYNC:
                pszOpType = "SYNC FROM SOURCE";
                pOptionXlat = RepSyncOptionToDra;
                break;

            case DS_REPL_OP_TYPE_ADD:
                pszOpType = "ADD NEW SOURCE";
                pOptionXlat = RepAddOptionToDra;
                break;

            case DS_REPL_OP_TYPE_DELETE:
                pszOpType = "DELETE SOURCE";
                pOptionXlat = RepDelOptionToDra;
                break;

            case DS_REPL_OP_TYPE_MODIFY:
                pszOpType = "MODIFY SOURCE";
                pOptionXlat = RepModOptionToDra;
                break;

            case DS_REPL_OP_TYPE_UPDATE_REFS:
                pszOpType = "UPDATE CHANGE NOTIFICATION";
                pOptionXlat = UpdRefOptionToDra;
                break;

            default:
                pszOpType = "UNKNOWN";
                pOptionXlat = NULL;
                break;
            }

            PrintMsg(REPADMIN_QUEUE_ENQUEUED_DATA_ITEM_DATA,
                     pszOpType,
                     pOp->pszNamingContext,
                     (pOp->pszDsaDN
                         ? GetNtdsDsaDisplayName(pOp->pszDsaDN)
                         : L"(null)"),
                     GetStringizedGuid(&pOp->uuidDsaObjGuid),
                     (pOp->pszDsaAddress
                         ? pOp->pszDsaAddress
                         : L"(null)") );
            if (pOptionXlat) {
                PrintTabMsg(2, REPADMIN_PRINT_STR,
                            GetOptionsString(pOptionXlat, pOp->ulOptions));
            }
        }
    }

    DsReplicaFreeInfo(DS_REPL_INFO_PENDING_OPS, pPendingOps);

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    return ret;
}


void ShowFailures(
    IN  DS_REPL_KCC_DSA_FAILURESW * pFailures
    )
{
    DWORD i;

    if (0 == pFailures->cNumEntries) {
        PrintMsg(REPADMIN_FAILCACHE_NONE);
        return;
    }

    for (i = 0; i < pFailures->cNumEntries; i++) {
        DS_REPL_KCC_DSA_FAILUREW * pFailure = &pFailures->rgDsaFailure[i];

        PrintTabMsg(2, REPADMIN_PRINT_STR, 
                    GetNtdsDsaDisplayName(pFailure->pszDsaDN));
        PrintTabMsg(4, REPADMIN_PRINT_DSA_OBJ_GUID,
                    GetStringizedGuid(&pFailure->uuidDsaObjGuid));

        if (0 == pFailure->cNumFailures) {
            PrintTabMsg(4, REPADMIN_PRINT_NO_FAILURES);
        }
        else {
            DSTIME dsTime;
            CHAR   szTime[SZDSTIME_LEN];

            FileTimeToDSTime(pFailure->ftimeFirstFailure, &dsTime);

            PrintMsg(REPADMIN_FAILCACHE_FAILURES_LINE,
                     pFailure->cNumFailures,
                     DSTimeToDisplayString(dsTime, szTime));

            if (0 != pFailure->dwLastResult) {
                PrintTabMsg(4, REPADMIN_FAILCACHE_LAST_ERR_LINE);
                PrintTabErrEnd(6, pFailure->dwLastResult);
            }
        }
    }
}

int FailCache(int argc, LPWSTR argv[])
{
    ULONG   ret = 0;
    ULONG   secondary;
    int     iArg;
    LPWSTR  pszOnDRA = NULL;
    HANDLE  hDS;
    DS_REPL_KCC_DSA_FAILURESW * pFailures;
    DWORD   dwVersion;
    CHAR    szTime[SZDSTIME_LEN];

    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszOnDRA) {
            pszOnDRA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszOnDRA) {
        pszOnDRA = L"localhost";
    }

    ret = DsBindWithCredW(pszOnDRA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,
                            NULL, NULL, &pFailures);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        // keep going
    }
    else {
        PrintMsg(REPADMIN_FAILCACHE_CONN_HDR);
        ShowFailures(pFailures);
        DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pFailures);

        ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                                NULL, NULL, &pFailures);
        if (ret != ERROR_SUCCESS) {
            PrintFuncFailed(L"DsReplicaGetInfo", ret);
            // keep going
        }
        else {
            PrintMsg(REPADMIN_PRINT_CR);
            PrintMsg(REPADMIN_FAILCACHE_LINK_HDR);
            ShowFailures(pFailures);
            DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pFailures);
        }
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    return ret;
}


int ShowReps(int argc, LPWSTR argv[])
{
    int                   ret = 0;
    LPWSTR                pszDSA = NULL;
    BOOL                  fVerbose = FALSE;
    BOOL                  fLdapOnly = FALSE;
    int                   iArg;
    HANDLE                hDS;
    LDAP *                hld;
    LPWSTR                rgpszRootAttrsToRead[] = {L"dsServiceName",L"isGlobalCatalogReady", NULL};
    LPWSTR *              ppszServerNames;
    LPWSTR                pszServerName;
    LPWSTR                pszSiteName;
    LDAPMessage *         pldmRootResults;
    LDAPMessage *         pldmRootEntry;
    LDAPMessage *         pldmServerResults;
    LDAPMessage *         pldmServerEntry;
    LPWSTR                rgpszServerAttrsToRead[] = {L"options", L"objectGuid", L"invocationId", NULL};
    LPWSTR *              ppszOptions;
    LPWSTR                pszSiteSpecDN;
    LPWSTR *              ppszIsGlobalCatalogReady;
    int                   nOptions = 0;
    struct berval **      ppbvGuid;
    DS_REPL_NEIGHBORSW *  pNeighbors;
    DS_REPL_NEIGHBORW *   pNeighbor;
    LPWSTR                pszNC = NULL;
    LPWSTR                pszLastNC;
    DWORD                 i;
    BOOL                  fShowRepsFrom = TRUE;
    BOOL                  fShowRepsTo = FALSE;
    BOOL                  fShowConn = FALSE;
    UUID *                puuid = NULL;
    UUID                  uuid;
    ULONG                 ulOptions;
    static WCHAR          wszSiteSettingsRdn[] = L"CN=NTDS Site Settings,";

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/v")
            || !_wcsicmp(argv[ iArg ], L"/verbose")) {
            fVerbose = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/to")
            || !_wcsicmp(argv[ iArg ], L"/repsto")) {
            fShowRepsTo = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/conn")) {
            fShowConn = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/all")) {
            fShowRepsTo = TRUE;
            fShowConn = TRUE;
        }
        else if ((NULL == pszNC) && (NULL != wcschr(argv[iArg], L','))) {
            pszNC = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else if ((NULL == puuid)
                 && (0 == UuidFromStringW(argv[iArg], &uuid))) {
            puuid = &uuid;
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    if (!fShowRepsFrom && !fShowRepsTo) {
        // Neither repsFrom nor repsTo selected -- show them both.
        fShowRepsFrom = fShowRepsTo = TRUE;
    }

    //
    // Connect
    //

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return ERROR_DS_SERVER_DOWN;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    //
    // Bind
    //

    ret = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ret);


    //
    // Display DSA info.
    //

    ret = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)", NULL,
                         0, &pldmRootResults);
    CHK_LD_STATUS(ret);

    pldmRootEntry = ldap_first_entry(hld, pldmRootResults);
    Assert(NULL != pldmRootEntry);

    ppszServerNames = ldap_get_valuesW(hld, pldmRootEntry, L"dsServiceName");
    Assert(NULL != ppszServerNames);

    // Display ntdsDsa.
    pszServerName = ppszServerNames[ 0 ];
    PrintMsg(REPADMIN_PRINT_STR, GetNtdsDsaDisplayName(pszServerName));

    ret = ldap_search_sW(hld, pszServerName, LDAP_SCOPE_BASE, L"(objectClass=*)",
                         rgpszServerAttrsToRead, 0, &pldmServerResults);
    CHK_LD_STATUS(ret);

    pldmServerEntry = ldap_first_entry(hld, pldmServerResults);
    Assert(NULL != pldmServerEntry);

    // Display options.
    ppszOptions = ldap_get_valuesW(hld, pldmServerEntry, L"options");
    if (NULL == ppszOptions) {
        nOptions = 0;
    }
    else {
        nOptions = wcstol(ppszOptions[0], NULL, 10);
    }

    PrintMsg(REPADMIN_SHOWREPS_DSA_OPTIONS, GetDsaOptionsString(nOptions));

    //check if nOptions has is_gc and if yes, check if dsa is advertising as gc
    //if is_gc is set and not advertising as gc, then display warning message
    if (nOptions & NTDSDSA_OPT_IS_GC) {
	ppszIsGlobalCatalogReady = ldap_get_valuesW(hld, pldmRootEntry, L"isGlobalCatalogReady");
	Assert(NULL != ppszIsGlobalCatalogReady);
	if (!_wcsicmp(*ppszIsGlobalCatalogReady,L"FALSE")) {
            PrintMsg(REPADMIN_SHOWREPS_WARN_GC_NOT_ADVERTISING);
	}
	if (ppszIsGlobalCatalogReady) {
	    ldap_value_freeW(ppszIsGlobalCatalogReady);
	}
    }
    
    //get site options
    ret = WrappedTrimDSNameBy(ppszServerNames[0],3,&pszSiteSpecDN); 
    Assert(!ret);

    pszSiteName = malloc((wcslen(pszSiteSpecDN) + 1)*sizeof(WCHAR) + sizeof(wszSiteSettingsRdn));
    CHK_ALLOC(pszSiteName);
    wcscpy(pszSiteName,wszSiteSettingsRdn);
    wcscat(pszSiteName,pszSiteSpecDN);
    
    ret = GetSiteOptions(hld, pszSiteName, &nOptions);
    if (!ret) {
	    PrintMsg(REPADMIN_SHOWREPS_SITE_OPTIONS, GetSiteOptionsString(nOptions));  
    }

    // Display ntdsDsa objectGuid.
    ppbvGuid = ldap_get_values_len(hld, pldmServerEntry, "objectGuid");
    Assert(NULL != ppbvGuid);
    if (NULL != ppbvGuid) {
        PrintMsg(REPADMIN_PRINT_DSA_OBJ_GUID, 
                 GetStringizedGuid((GUID *) ppbvGuid[0]->bv_val));
    }
    ldap_value_free_len(ppbvGuid);

    // Display ntdsDsa invocationID.
    ppbvGuid = ldap_get_values_len(hld, pldmServerEntry, "invocationID");
    Assert(NULL != ppbvGuid);
    if (NULL != ppbvGuid) {
        PrintTabMsg(0, REPADMIN_PRINT_INVOCATION_ID, 
                    GetStringizedGuid((GUID *) ppbvGuid[0]->bv_val));
    }
    ldap_value_free_len(ppbvGuid);

    if (pldmServerResults) {
	ldap_msgfree(pldmServerResults);
    }
    if (pldmRootResults) {
	ldap_msgfree(pldmRootResults);
    }
    if (pszSiteName) {
	free(pszSiteName);
    }

    PrintMsg(REPADMIN_PRINT_CR);

    ret = DsBindWithCredW(pszDSA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDSA, ret);
        return ret;
    }


    //
    // Display replication state associated with inbound neighbors.
    //

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, pszNC, puuid,
                            &pNeighbors);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        return ret;
    }

    PrintMsg(REPADMIN_SHOWREPS_IN_NEIGHBORS_HDR);

    pszLastNC = NULL;
    for (i = 0; i < pNeighbors->cNumNeighbors; i++) {
        pNeighbor = &pNeighbors->rgNeighbor[i];

        if ((NULL == pszLastNC)
            || (0 != wcscmp(pszLastNC, pNeighbor->pszNamingContext))) {
            PrintMsg(REPADMIN_PRINT_CR);
            PrintMsg(REPADMIN_PRINT_STR, pNeighbor->pszNamingContext);
            pszLastNC = pNeighbor->pszNamingContext;
        }

        ShowNeighbor(pNeighbor, IS_REPS_FROM, fVerbose);
    }

    DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);

    //
    // Display replication state associated with outbound neighbors.
    //

    if (fShowRepsTo) {
        ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_REPSTO, pszNC, puuid,
                                &pNeighbors);
        if (ERROR_SUCCESS != ret) {
            PrintFuncFailed(L"DsReplicaGetInfo", ret);
            return ret;
        }

        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_SHOWREPS_OUT_NEIGHBORS_HDR);

        pszLastNC = NULL;
        for (i = 0; i < pNeighbors->cNumNeighbors; i++) {
            pNeighbor = &pNeighbors->rgNeighbor[i];

            if ((NULL == pszLastNC)
                || (0 != wcscmp(pszLastNC, pNeighbor->pszNamingContext))) {
                PrintMsg(REPADMIN_PRINT_CR);
                PrintMsg(REPADMIN_PRINT_STR, pNeighbor->pszNamingContext);
                pszLastNC = pNeighbor->pszNamingContext;
            }

            ShowNeighbor(pNeighbor, IS_REPS_TO, fVerbose);
        }

        DsReplicaFreeInfo(DS_REPL_INFO_REPSTO, pNeighbors);
    }

    //
    // Look for missing neighbors
    //

    if (fShowConn) {
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_SHOWREPS_KCC_CONN_OBJS_HDR);
    }
    ret = FindConnections( hld, pszServerName, NULL, fShowConn, fVerbose, FALSE );

    //
    // Close LDAP.
    //

    ldap_unbind(hld);

    DsUnBind(&hDS);

    return 0;
}


void
ShowNeighbor(
    DS_REPL_NEIGHBORW * pNeighbor,
    BOOL                fRepsFrom,
    BOOL                fVerbose
    )
{
    const UUID uuidNull = {0};
    DWORD   status;
    LPSTR   pszTransportName = "RPC";
    CHAR    szTime[ SZDSTIME_LEN ];
    DSTIME  dsTime;

    // Display server name.
    PrintMsg(REPADMIN_SHOWNEIGHBOR_DISP_SERVER, 
           GetNtdsDsaDisplayName(pNeighbor->pszSourceDsaDN),
           GetTransportDisplayName(pNeighbor->pszAsyncIntersiteTransportDN));

    PrintTabMsg(4, REPADMIN_PRINT_DSA_OBJ_GUID,
                GetStringizedGuid(&pNeighbor->uuidSourceDsaObjGuid));
    // Only display deleted sources if Verbose
    if ( (!fVerbose) &&
         (DsIsMangledDnW( pNeighbor->pszSourceDsaDN, DS_MANGLE_OBJECT_RDN_FOR_DELETION )) ) {
        return;
    }

    if (fVerbose) {
        PrintTabMsg(4, REPADMIN_GENERAL_ADDRESS_COLON_STR,
                    pNeighbor->pszSourceDsaAddress);

        if (fRepsFrom) {
            // Display DSA invocationId.
            PrintTabMsg(4, REPADMIN_PRINT_INVOCATION_ID, 
                        GetStringizedGuid(&pNeighbor->uuidSourceDsaInvocationID));
        }

        if (0 != memcmp(&pNeighbor->uuidAsyncIntersiteTransportObjGuid,
                        &uuidNull, sizeof(UUID))) {
            // Display transport objectGuid.
            PrintTabMsg(6, REPADMIN_PRINT_INTERSITE_TRANS_OBJ_GUID,
                   GetStringizedGuid(&pNeighbor->uuidAsyncIntersiteTransportObjGuid));
        }


        //
        // Display replica flags.
        //

        PrintTabMsg(4, REPADMIN_PRINT_STR, 
                GetOptionsString( RepNbrOptionToDra, pNeighbor->dwReplicaFlags ) );

        if ( fRepsFrom )
        {
            //
            // Display USNs.
            //

            PrintMsg(REPADMIN_SHOWNEIGHBOR_USNS,
                     pNeighbor->usnLastObjChangeSynced);
            PrintMsg(REPADMIN_SHOWNEIGHBOR_USNS_HACK2,
                     pNeighbor->usnAttributeFilter);
        }
    }

    //
    // Display time of last successful replication (for Reps-From),
    // or time Reps-To was added.
    //

    if (fRepsFrom) {
        // Display status and time of last replication attempt/success.
        if (0 == pNeighbor->dwLastSyncResult) {
            FileTimeToDSTime(pNeighbor->ftimeLastSyncSuccess, &dsTime);
            PrintMsg(REPADMIN_SHOWNEIGHBOR_LAST_ATTEMPT_SUCCESS,
                     DSTimeToDisplayString(dsTime, szTime));
        }
        else {
            FileTimeToDSTime(pNeighbor->ftimeLastSyncAttempt, &dsTime);

            if (0 == pNeighbor->cNumConsecutiveSyncFailures) {
                // A non-zero success status
                PrintMsg(REPADMIN_SHOWNEIGHBOR_LAST_ATTEMPT_DELAYED, 
                         DSTimeToDisplayString(dsTime, szTime));
                PrintErrEnd(pNeighbor->dwLastSyncResult);
            } else {
                // A non-zero failure status
                PrintTabMsg(4, REPADMIN_SHOWNEIGHBOR_LAST_ATTEMPT_FAILED,
                         DSTimeToDisplayString(dsTime, szTime));
                PrintMsg(REPADMIN_GENERAL_ERR_NUM, 
                            pNeighbor->dwLastSyncResult, 
                            pNeighbor->dwLastSyncResult);
                PrintTabMsg(6, REPADMIN_PRINT_STR, 
                            Win32ErrToString(pNeighbor->dwLastSyncResult));

                PrintMsg(REPADMIN_SHOWNEIGHBOR_N_CONSECUTIVE_FAILURES,
                         pNeighbor->cNumConsecutiveSyncFailures);
            }

            FileTimeToDSTime(pNeighbor->ftimeLastSyncSuccess, &dsTime);
            PrintMsg(REPADMIN_SHOWNEIGHBOR_LAST_SUCCESS,
                     DSTimeToDisplayString(dsTime, szTime));

        }
    }
    else if (fVerbose) {
        FileTimeToDSTime(pNeighbor->ftimeLastSyncSuccess, &dsTime);
        PrintMsg(REPADMIN_SHOWNEIGHBOR_ADDED,
                 DSTimeToDisplayString(dsTime, szTime));
    }
}


int
__cdecl
ftimeCompare(
    IN const void *elem1,
    IN const void *elem2
    )
/*++

Description:

    This function is used as the comparison for qsort in the function
    ShowVector().

Parameters:

    elem1 - This is the first element and is a pointer to a 
    elem2 - This is the second element and is a pointer to a

Return Value:
  

  --*/
{
    return(       	
	(int) CompareFileTime(
	    (FILETIME *) &(((DS_REPL_CURSOR_2 *)elem1)->ftimeLastSyncSuccess),
	    (FILETIME *) &(((DS_REPL_CURSOR_2 *)elem2)->ftimeLastSyncSuccess)
	    )
    );
                  
}

int
ShowVector(
    int     argc,
    LPWSTR  argv[]
    )
{
    int                 ret = 0;
    LPWSTR              pszNC = NULL;
    LPWSTR              pszDSA = NULL;
    int                 iArg;
    LDAP *              hld;
    BOOL                fCacheGuids = TRUE;
    BOOL                fLatencySort = FALSE;
    int                 ldStatus;
    HANDLE              hDS;
    DS_REPL_CURSORS *   pCursors1;
    DS_REPL_CURSORS_3W *pCursors3;
    DWORD               iCursor;
    ULONG               ulOptions;
    DSTIME              dsTime;
    CHAR                szTime[SZDSTIME_LEN];

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/n")
            || !_wcsicmp(argv[ iArg ], L"/nocache")) {
            fCacheGuids = FALSE;
        }
	else if (!_wcsicmp(argv[ iArg ], L"/latency")
		 || !_wcsicmp(argv[ iArg ], L"/l")) {
	    fLatencySort = TRUE;
	}
        else if (NULL == pszNC) {
            pszNC = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        } 
	else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszNC) {
        PrintMsg(REPADMIN_PRINT_NO_NC);
        return ERROR_INVALID_FUNCTION;
    }

    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    ret = DsBindWithCredW(pszDSA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDSA, ret);
        return ret;
    }

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_CURSORS_3_FOR_NC, pszNC, NULL, &pCursors3);
    if (ERROR_SUCCESS == ret) {
        //check for latency sort
        if (fLatencySort) {
            qsort(pCursors3->rgCursor,
                  pCursors3->cNumCursors, 
                  sizeof(pCursors3->rgCursor[0]), 
                  ftimeCompare); 
        } 
	
        for (iCursor = 0; iCursor < pCursors3->cNumCursors; iCursor++) {
            LPWSTR pszDsaName;

            FileTimeToDSTime(pCursors3->rgCursor[iCursor].ftimeLastSyncSuccess,
                             &dsTime);

            if (!fCacheGuids // want raw guids displayed
                || (NULL == pCursors3->rgCursor[iCursor].pszSourceDsaDN)) {
                pszDsaName = GetStringizedGuid(&pCursors3->rgCursor[iCursor].uuidSourceDsaInvocationID);
            } else {
                pszDsaName = GetNtdsDsaDisplayName(pCursors3->rgCursor[iCursor].pszSourceDsaDN);
            }
            PrintMsg(REPADMIN_SHOWVECTOR_ONE_USN, 
                     pszDsaName,
                     pCursors3->rgCursor[iCursor].usnAttributeFilter);
            PrintMsg(REPADMIN_SHOWVECTOR_ONE_USN_HACK2,
                     dsTime ? DSTimeToDisplayString(dsTime, szTime) : "(unknown)");
        }
    
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_3_FOR_NC, pCursors3);
    } else if (ERROR_NOT_SUPPORTED == ret) {
        if (fCacheGuids) {
            // Connect
            hld = ldap_initW(pszDSA, LDAP_PORT);
            if (NULL == hld) {
                PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
                return LDAP_SERVER_DOWN;
            }
    
            // use only A record dns name discovery
            ulOptions = PtrToUlong(LDAP_OPT_ON);
            (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );
    
            // Bind
            ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
            CHK_LD_STATUS(ldStatus);
    
            // Populate the guid cache
            BuildGuidCache(hld);
    
            ldap_unbind(hld);
        }
    
        ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_CURSORS_FOR_NC, pszNC, NULL,
                                &pCursors1);
        if (ERROR_SUCCESS == ret) {
            for (iCursor = 0; iCursor < pCursors1->cNumCursors; iCursor++) {
                PrintMsg(REPADMIN_GETCHANGES_DST_UTD_VEC_ONE_USN,
                       GetGuidDisplayName(&pCursors1->rgCursor[iCursor].uuidSourceDsaInvocationID),
                       pCursors1->rgCursor[iCursor].usnAttributeFilter);
            }
        
            DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors1);
        }
    }

    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
    }

    DsUnBind(&hDS);

    return ret;
}

int
ShowMeta(
    int     argc,
    LPWSTR  argv[]
    )
{
    int                         ret = 0;
    int                         iArg;
    BOOL                        fCacheGuids = TRUE;
    LPWSTR                      pszObject = NULL;
    LPWSTR                      pszDSA = NULL;
    LDAP *                      hld;
    int                         ldStatus;
    DS_REPL_OBJ_META_DATA *     pObjMetaData1 = NULL;
    DS_REPL_OBJ_META_DATA_2 *   pObjMetaData2 = NULL;
    DWORD                       iprop;
    HANDLE                      hDS;
    DWORD                       dwInfoFlags = 0;
    ULONG                       ulOptions;
    DWORD                       cNumEntries;

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/n")
            || !_wcsicmp(argv[ iArg ], L"/nocache")) {
            fCacheGuids = FALSE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/l")
            || !_wcsicmp(argv[ iArg ], L"/linked")) {
            dwInfoFlags |= DS_REPL_INFO_FLAG_IMPROVE_LINKED_ATTRS;
        }
        else if (NULL == pszObject) {
            pszObject = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszObject) {
        PrintMsg(REPADMIN_SHOWMETA_NO_OBJ_SPECIFIED);
        return ERROR_INVALID_FUNCTION;
    }

    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    ret = DsBindWithCredW(pszDSA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDSA, ret);
        return ret;
    }
    
    ret = DsReplicaGetInfo2W(hDS,
                             DS_REPL_INFO_METADATA_2_FOR_OBJ,
                             pszObject,
                             NULL, // puuid
                             NULL, // pszattributename
                             NULL, // pszvaluedn
                             dwInfoFlags,
                             0, // dwEnumeration Context
                             &pObjMetaData2);
    
    if (ERROR_NOT_SUPPORTED == ret) {
        if (fCacheGuids) {
            // Connect
            hld = ldap_initW(pszDSA, LDAP_PORT);
            if (NULL == hld) {
                PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
                return LDAP_SERVER_DOWN;
            }
    
            // use only A record dns name discovery
            ulOptions = PtrToUlong(LDAP_OPT_ON);
            (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );
    
            // Bind
            ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
            CHK_LD_STATUS(ldStatus);
    
            // Populate the guid cache
            BuildGuidCache(hld);
    
            ldap_unbind(hld);
        }
        
        ret = DsReplicaGetInfo2W(hDS,
                                 DS_REPL_INFO_METADATA_FOR_OBJ,
                                 pszObject,
                                 NULL, // puuid
                                 NULL, // pszattributename
                                 NULL, // pszvaluedn
                                 dwInfoFlags,
                                 0, // dwEnumeration Context
                                 &pObjMetaData1);
    }
    
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        return ret;
    }

    cNumEntries = pObjMetaData2 ? pObjMetaData2->cNumEntries : pObjMetaData1->cNumEntries;
    PrintMsg(REPADMIN_PRINT_CR);
    PrintMsg(REPADMIN_SHOWMETA_N_ENTRIES, cNumEntries);

    PrintMsg(REPADMIN_SHOWMETA_DATA_HDR);

    for (iprop = 0; iprop < cNumEntries; iprop++) {
        CHAR   szTime[ SZDSTIME_LEN ];
        DSTIME dstime;

        if (pObjMetaData2) {
            LPWSTR pszDsaName;

            if (!fCacheGuids // want raw guids displayed
                || (NULL == pObjMetaData2->rgMetaData[iprop].pszLastOriginatingDsaDN)) {
                pszDsaName = GetStringizedGuid(&pObjMetaData2->rgMetaData[iprop].uuidLastOriginatingDsaInvocationID);
            } else {
                pszDsaName = GetNtdsDsaDisplayName(pObjMetaData2->rgMetaData[iprop].pszLastOriginatingDsaDN);
            }

            FileTimeToDSTime(pObjMetaData2->rgMetaData[ iprop ].ftimeLastOriginatingChange,
                             &dstime);

            // BUGBUG if anyone fixes how the message file handles ia64 qualifiers,
            // then we can combine these message strings into one.
            PrintMsg(REPADMIN_SHOWMETA_DATA_LINE,
                     pObjMetaData2->rgMetaData[ iprop ].usnLocalChange
                     );
            PrintMsg(REPADMIN_SHOWMETA_DATA_LINE_HACK2,
                     pszDsaName,
                     pObjMetaData2->rgMetaData[ iprop ].usnOriginatingChange
                     );
            PrintMsg(REPADMIN_SHOWMETA_DATA_LINE_HACK3,
                     DSTimeToDisplayString(dstime, szTime),
                     pObjMetaData2->rgMetaData[ iprop ].dwVersion,
                     pObjMetaData2->rgMetaData[ iprop ].pszAttributeName
                     );
        } else {
            FileTimeToDSTime(pObjMetaData1->rgMetaData[ iprop ].ftimeLastOriginatingChange,
                             &dstime);
    
            PrintMsg(REPADMIN_SHOWMETA_DATA_LINE,
                     pObjMetaData1->rgMetaData[ iprop ].usnLocalChange
                     );
            PrintMsg(REPADMIN_SHOWMETA_DATA_LINE_HACK2,
                     GetGuidDisplayName(&pObjMetaData1->rgMetaData[iprop].uuidLastOriginatingDsaInvocationID),
                     pObjMetaData1->rgMetaData[ iprop ].usnOriginatingChange
                     );
            PrintMsg(REPADMIN_SHOWMETA_DATA_LINE_HACK3,
                     DSTimeToDisplayString(dstime, szTime),
                     pObjMetaData1->rgMetaData[ iprop ].dwVersion,
                     pObjMetaData1->rgMetaData[ iprop ].pszAttributeName
                     );
        }
    }

    if (pObjMetaData2) {
        DsReplicaFreeInfo(DS_REPL_INFO_METADATA_2_FOR_OBJ, pObjMetaData2);
    } else {
        DsReplicaFreeInfo(DS_REPL_INFO_METADATA_FOR_OBJ, pObjMetaData1);
    }

    DsUnBind(&hDS);

    return ret;
}

int
ShowValue(
    int     argc,
    LPWSTR  argv[]
    )
{
    int                     ret = 0;
    int                     iArg;
    BOOL                    fCacheGuids = TRUE;
    LPWSTR                  pszObject = NULL;
    LPWSTR                  pszDSA = NULL;
    LPWSTR                  pszAttributeName = NULL;
    LPWSTR                  pszValue = NULL;
    LDAP *                  hld;
    int                     ldStatus;
    DS_REPL_ATTR_VALUE_META_DATA * pAttrValueMetaData1 = NULL;
    DS_REPL_ATTR_VALUE_META_DATA_2 * pAttrValueMetaData2 = NULL;
    DWORD                   iprop;
    HANDLE                  hDS;
    DWORD                   context;
    ULONG                   ulOptions;
    BOOL                    fGuidsAlreadyCached = FALSE;
    DWORD                   cNumEntries;

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/n")
            || !_wcsicmp(argv[ iArg ], L"/nocache")) {
            fCacheGuids = FALSE;
        }
        else if (NULL == pszObject) {
            pszObject = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else if (NULL == pszAttributeName) {
            pszAttributeName = argv[iArg];
        }
        else if (NULL == pszValue) {
            pszValue = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszObject) {
        PrintMsg(REPADMIN_SHOWMETA_NO_OBJ_SPECIFIED);
        return ERROR_INVALID_FUNCTION;
    }

    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    ret = DsBindWithCredW(pszDSA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDSA, ret);
        return ret;
    }

    // Context starts at zero
    context = 0;
    while (1) {
        ret = DsReplicaGetInfo2W(hDS,
                                 DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE,
                                 pszObject,
                                 NULL /*guid*/,
                                 pszAttributeName,
                                 pszValue,
                                 0 /*flags*/,
                                 context,
                                 &pAttrValueMetaData2);
        if (ERROR_NOT_SUPPORTED == ret) {
            if (fCacheGuids && !fGuidsAlreadyCached) {
                // Connect
                hld = ldap_initW(pszDSA, LDAP_PORT);
                if (NULL == hld) {
                    PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
                    return LDAP_SERVER_DOWN;
                }
        
                // use only A record dns name discovery
                ulOptions = PtrToUlong(LDAP_OPT_ON);
                (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );
        
                // Bind
                ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
                CHK_LD_STATUS(ldStatus);
        
                // Populate the guid cache
                BuildGuidCache(hld);
        
                ldap_unbind(hld);

                fGuidsAlreadyCached = TRUE;
            }
        
            ret = DsReplicaGetInfo2W(hDS,
                                     DS_REPL_INFO_METADATA_FOR_ATTR_VALUE,
                                     pszObject,
                                     NULL /*guid*/,
                                     pszAttributeName,
                                     pszValue,
                                     0 /*flags*/,
                                     context,
                                     &pAttrValueMetaData1);
        }

        if (ERROR_NO_MORE_ITEMS == ret) {
            // This is the successful path out of the loop
            PrintMsg(REPADMIN_SHOWVALUE_NO_MORE_ITEMS);
            ret = ERROR_SUCCESS;
            goto cleanup;
        } else if (ERROR_SUCCESS != ret) {
            PrintFuncFailed(L"DsReplicaGetInfo", ret);
            goto cleanup;
        }

        cNumEntries = pAttrValueMetaData2 ? pAttrValueMetaData2->cNumEntries : pAttrValueMetaData1->cNumEntries;
        
        PrintMsg(REPADMIN_SHOWMETA_N_ENTRIES, cNumEntries);

        PrintMsg(REPADMIN_SHOWVALUE_DATA_HDR);

        for (iprop = 0; iprop < cNumEntries; iprop++) {
            if (pAttrValueMetaData2) {
                DS_REPL_VALUE_META_DATA_2 *pValueMetaData = &(pAttrValueMetaData2->rgMetaData[iprop]);
                CHAR   szTime1[ SZDSTIME_LEN ], szTime2[ SZDSTIME_LEN ];
                DSTIME dstime1, dstime2;
                BOOL fPresent =
                    (memcmp( &pValueMetaData->ftimeDeleted, &ftimeZero, sizeof( FILETIME )) == 0);
                BOOL fLegacy = (pValueMetaData->dwVersion == 0);
                LPWSTR pszDsaName;
    
                if (!fCacheGuids // want raw guids displayed
                    || (NULL == pValueMetaData->pszLastOriginatingDsaDN)) {
                    pszDsaName = GetStringizedGuid(&pValueMetaData->uuidLastOriginatingDsaInvocationID);
                } else {
                    pszDsaName = GetNtdsDsaDisplayName(pValueMetaData->pszLastOriginatingDsaDN);
                }
    
                FileTimeToDSTime(pValueMetaData->ftimeCreated, &dstime1);
                
                if(fLegacy){
                    // Windows 2000 Legacy value.
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_LEGACY);
                } else if (fPresent) {
                    // Windows XP Present value.
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_PRESENT);
                } else {
                    // Windows XP Absent value.
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_ABSENT);
                }
                
                PrintMsg(REPADMIN_SHOWVALUE_DATA_BASIC,
                         pValueMetaData->pszAttributeName
                         );

                if (!fLegacy) {
                    // We'll need the last mod time.
                    FileTimeToDSTime(pValueMetaData->ftimeLastOriginatingChange,
                                     &dstime2);
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_VALUE_META_DATA,
                             DSTimeToDisplayString(dstime2, szTime2),
                             pszDsaName,
                             pValueMetaData->usnLocalChange);
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_VALUE_META_DATA_HACK2,
                             pValueMetaData->usnOriginatingChange);
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_VALUE_META_DATA_HACK3,
                             pValueMetaData->dwVersion);
                } else {
                    PrintMsg(REPADMIN_PRINT_CR);
                }

                PrintTabMsg(4, REPADMIN_PRINT_STR,
                            pValueMetaData->pszObjectDn);

            } else {
                DS_REPL_VALUE_META_DATA *pValueMetaData = &(pAttrValueMetaData1->rgMetaData[iprop]);
                CHAR   szTime1[ SZDSTIME_LEN ], szTime2[ SZDSTIME_LEN ];
                DSTIME dstime1, dstime2;
                BOOL fPresent =
                    (memcmp( &pValueMetaData->ftimeDeleted, &ftimeZero, sizeof( FILETIME )) == 0);
                BOOL fLegacy = (pValueMetaData->dwVersion == 0);
    
                FileTimeToDSTime(pValueMetaData->ftimeCreated, &dstime1);
                if (fPresent) {
                    if(fLegacy){
                        PrintMsg(REPADMIN_SHOWVALUE_DATA_LINE_LEGACY,
                                 pValueMetaData->pszAttributeName,
                                 pValueMetaData->pszObjectDn,
                                 pValueMetaData->cbData,
                                 DSTimeToDisplayString(dstime1, szTime1) );
                    } else {
                        PrintMsg(REPADMIN_SHOWVALUE_DATA_LINE_PRESENT,
                                 pValueMetaData->pszAttributeName,
                                 pValueMetaData->pszObjectDn,
                                 pValueMetaData->cbData,
                                 DSTimeToDisplayString(dstime1, szTime1) );
                    }
                } else {
                    FileTimeToDSTime(pValueMetaData->ftimeDeleted, &dstime2);
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_LINE_ABSENT,
                             pValueMetaData->pszAttributeName,
                             pValueMetaData->pszObjectDn,
                             pValueMetaData->cbData,
                             DSTimeToDisplayString(dstime1, szTime1),
                             DSTimeToDisplayString(dstime2, szTime2) );
                }
    
                if (!fLegacy) {
                    FileTimeToDSTime(pValueMetaData->ftimeLastOriginatingChange,
                                     &dstime2);
    
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_LINE, 
                             pValueMetaData->usnLocalChange);
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_LINE_HACK2, 
                             GetGuidDisplayName(&pValueMetaData->uuidLastOriginatingDsaInvocationID),
                             pValueMetaData->usnOriginatingChange);
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_LINE_HACK3, 
                             DSTimeToDisplayString(dstime2, szTime2),
                             pValueMetaData->dwVersion );
                }
            }
        }
        
        if (pAttrValueMetaData2) {
            context = pAttrValueMetaData2->dwEnumerationContext;
            DsReplicaFreeInfo(DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE, pAttrValueMetaData2);
            pAttrValueMetaData2 = NULL;
        } else {
            context = pAttrValueMetaData1->dwEnumerationContext;
            DsReplicaFreeInfo(DS_REPL_INFO_METADATA_FOR_ATTR_VALUE, pAttrValueMetaData1);
            pAttrValueMetaData1 = NULL;
        }

        // When requesting a single value, we are done
        // The context will indicate if all values returned
        if ( (pszValue) || (context == 0xffffffff) ) {
            break;
        }
    }

cleanup:
    DsUnBind(&hDS);

    return ret;
}

int
ShowCtx(
    int     argc,
    LPWSTR  argv[]
    )
{
    int                       ret = 0;
    LPWSTR                    pszDSA = NULL;
    int                       iArg;
    LDAP *                    hld;
    BOOL                      fCacheGuids = TRUE;
    int                       ldStatus;
    HANDLE                    hDS;
    DS_REPL_CLIENT_CONTEXTS * pContexts;
    DS_REPL_CLIENT_CONTEXT  * pContext;
    DWORD                     iCtx;
    LPWSTR                    pszClient;
    const UUID                uuidNtDsApiClient = NtdsapiClientGuid;
    char                      szTime[SZDSTIME_LEN];
    ULONG                     ulOptions;

    // Parse command-line arguments.
    // Default to local DSA, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/n")
            || !_wcsicmp(argv[ iArg ], L"/nocache")) {
            fCacheGuids = FALSE;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (fCacheGuids) {
        // Connect
        if (NULL == pszDSA) {
            pszDSA = L"localhost";
        }

        hld = ldap_initW(pszDSA, LDAP_PORT);
        if (NULL == hld) {
            PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
            return LDAP_SERVER_DOWN;
        }

        // use only A record dns name discovery
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

        // Bind
        ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
        CHK_LD_STATUS(ldStatus);

        // Populate the guid cache
        BuildGuidCache(hld);

        ldap_unbind(hld);
    }

    ret = DsBindWithCredW(pszDSA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDSA, ret);
        return ret;
    }

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_CLIENT_CONTEXTS, NULL, NULL,
                            &pContexts);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        return ret;
    }

    PrintMsg(REPADMIN_SHOWCTX_OPEN_CONTEXT_HANDLES, pContexts->cNumContexts);

    for (iCtx = 0; iCtx < pContexts->cNumContexts; iCtx++) {
        pContext = &pContexts->rgContext[iCtx];

        if (0 == memcmp(&pContext->uuidClient, &uuidNtDsApiClient, sizeof(GUID))) {
            pszClient = L"NTDSAPI client";
        }
        else {
            pszClient = GetGuidDisplayName(&pContext->uuidClient);
        }

        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_SHOWCTX_DATA_1, 
               pszClient,
               inet_ntoa(*((IN_ADDR *) &pContext->IPAddr)),
               pContext->pid,
               pContext->hCtx);
        if(pContext->fIsBound){
            PrintMsg(REPADMIN_SHOWCTX_DATA_2, 
               pContext->lReferenceCount,
               DSTimeToDisplayString(pContext->timeLastUsed, szTime));
        } else {
            PrintMsg(REPADMIN_SHOWCTX_DATA_2_NOT, 
               pContext->lReferenceCount,
               DSTimeToDisplayString(pContext->timeLastUsed, szTime));
        }
    }

    DsReplicaFreeInfo(DS_REPL_INFO_CLIENT_CONTEXTS, pContexts);
    DsUnBind(&hDS);

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\repcrypt.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repcrypt.c - CRYPT API related commands

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <wincrypt.h>
#include <certca.h>
#include <cryptui.h>

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "repadmin.h"

/* External */

/* Static */

/* Forward */
/* End Forward */

// Fake out the core environment enough for this routine to compile

CERT_ALT_NAME_ENTRY *
draGetCertAltNameEntry(
    IN  THSTATE *       pTHS,
    IN  PCCERT_CONTEXT  pCertContext,
    IN  DWORD           dwAltNameChoice,
    IN  LPSTR           pszOtherNameOID     OPTIONAL
    )
/*++

Routine Description:

THIS CODE SHAMELESSLY STOLEN FROM DRACRYPT.C

    Retrieve a specific alt subject name entry from the given certificate.

Arguments:

    pCertContext (IN) - Certificate from which info is to be derived.
    
    dwAltNameChoice (IN) - The CERT_ALT_NAME_* for the desired alternate name.
    
    pszOtherNameOID (IN) - If retrieving CERT_ALT_NAME_OTHER_NAME, an OID
        specifying the specific "other name" desired.  Must be NULL for other
        values of dwAltNameChoice.
        
Return Values:

    A pointer to the CERT_ALT_NAME_ENTRY (success) or NULL (failure).
    
--*/
{
    CERT_EXTENSION *      pCertExtension;
    CERT_ALT_NAME_INFO *  pCertAltNameInfo;
    DWORD                 cbCertAltNameInfo = 0;
    CERT_ALT_NAME_ENTRY * pCertAltNameEntry = NULL;
    BOOL                  ok;
    DWORD                 winError;
    DWORD                 i;
    
    Assert((CERT_ALT_NAME_OTHER_NAME == dwAltNameChoice)
           || (NULL == pszOtherNameOID));

    // Find the cert extension containing the alternate subject names.
    pCertExtension = CertFindExtension(szOID_SUBJECT_ALT_NAME2,
                                       pCertContext->pCertInfo->cExtension,
                                       pCertContext->pCertInfo->rgExtension);
    if (NULL == pCertExtension) {
	PrintMsg(REPADMIN_SHOWCERT_CERT_NO_ALT_SUBJ);
        return NULL;
    }
        
    // Decode the list of alternate subject names.
    ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                           X509_ALTERNATE_NAME,
                           pCertExtension->Value.pbData,
                           pCertExtension->Value.cbData,
                           0,
                           NULL,
                           &cbCertAltNameInfo);
    if (!ok || (0 == cbCertAltNameInfo)) {
        winError = GetLastError();
        PrintMsg(REPADMIN_SHOWCERT_CANT_DECODE_CERT,
                 winError, Win32ErrToString(winError));
        return NULL;
    }
    
    pCertAltNameInfo = malloc(cbCertAltNameInfo);
    
    if (NULL == pCertAltNameInfo) {
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
        return NULL;
    }
        
    ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                           X509_ALTERNATE_NAME,
                           pCertExtension->Value.pbData,
                           pCertExtension->Value.cbData,
                           0,
                           pCertAltNameInfo,
                           &cbCertAltNameInfo);
    if (!ok) {
        winError = GetLastError();
        PrintMsg(REPADMIN_SHOWCERT_CANT_DECODE_CERT,
                 winError, Win32ErrToString(winError));
        return NULL;
    }
    
    // Grovel through the alternate names to find the one the caller asked for.
    for (i = 0; i < pCertAltNameInfo->cAltEntry; i++) {
        if ((dwAltNameChoice
             == pCertAltNameInfo->rgAltEntry[i].dwAltNameChoice)
            && ((NULL == pszOtherNameOID)
                || (0 == strcmp(pszOtherNameOID,
                                pCertAltNameInfo->rgAltEntry[i]
                                    .pOtherName->pszObjId)))) {
            pCertAltNameEntry = &pCertAltNameInfo->rgAltEntry[i];
            break;
        }
    }

    return pCertAltNameEntry;
}

PCCERT_CONTEXT
getDCCert(
    IN  THSTATE *   pTHS,
    IN  HCERTSTORE  hCertStore,
    IN  BOOL        fRequestV2Certificate
    )
/*++

THIS CODE SHAMELESSLY STOLEN FROM DRACRYPT.C

Note that dracrypt.c can be built as a standalone module outside of the
core. We may consider building the entire file in if we have need of more
of its functions.

Routine Description:

    Retrieve the "DomainController" type certificate associated with the local
    machine.

Arguments:

    hCertStore (IN) - Handle to the cert store to search.
    fRequestV2Certificate - Whether we should only accept a V2 certificate    

Return Values:

    Handle to the certificate.  Throws DRA exception if not found or on other
    error.

--*/
{
    PCCERT_CONTEXT          pCertContext = NULL;
    BOOL                    ok = FALSE;
    BOOL                    fCertFound = FALSE;
    CERT_EXTENSION *        pCertExtension;
    DWORD                   cbCertTypeMax;
    DWORD                   cbCertType;
    CERT_NAME_VALUE *       pCertType;
    HRESULT                 hr;
    HCERTTYPE               hCertType;
    LPWSTR *                ppszCertTypePropertyList;
    CERT_ALT_NAME_ENTRY *   pBadStyleToLeakMem = NULL;

    // Allocate buffer to hold cert type extension.
    cbCertTypeMax = 512;
    pCertType = malloc(cbCertTypeMax);
    CHK_ALLOC(pCertType);
    
    // Grovel through each of our certificates, looking for the one of type DC.
    for (pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext);
         (NULL != pCertContext);
         pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext)) {

        if (fRequestV2Certificate) {
            // A V2 certificate has a CERTIFICATE_TEMPLATE extension, but
            // no ENROLL_CERTTYPE extension.
            if (!CertFindExtension(szOID_CERTIFICATE_TEMPLATE,
                                   pCertContext->pCertInfo->cExtension,
                                   pCertContext->pCertInfo->rgExtension)) {
                continue;
            }
            // A certificate suitable for mail-based replication will have our
            // OID in it, by definition.
            // BUGBUG This returns a pointer into the middle of some allocated
            // memory, so it can't be freed from this pointer.  This used to be
            // THAlloc'd in the DS so it was auto freed.  Since repadmin is a
            // run once tool we'll let it slide.
            pBadStyleToLeakMem = draGetCertAltNameEntry(pTHS,
                                        pCertContext,
                                        CERT_ALT_NAME_OTHER_NAME,
                                        szOID_NTDS_REPLICATION);
            if (!pBadStyleToLeakMem) {
                continue;
            }

            // We found one!
            break;
        }

        // Find the cert type.
        pCertExtension = CertFindExtension(szOID_ENROLL_CERTTYPE_EXTENSION,
                                           pCertContext->pCertInfo->cExtension,
                                           pCertContext->pCertInfo->rgExtension);

        if (NULL != pCertExtension) {
            // Decode the cert type.
            cbCertType = cbCertTypeMax;
            ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                                   X509_UNICODE_ANY_STRING,
                                   pCertExtension->Value.pbData,
                                   pCertExtension->Value.cbData,
                                   0,
                                   (void *) pCertType,
                                   &cbCertType);
            
            if (!ok && (ERROR_MORE_DATA == GetLastError())) {
                // Our buffer isn't big enough to hold this cert; realloc and
                // try again.
                pCertType =  realloc(pCertType, cbCertType);
                cbCertTypeMax = cbCertType;
            
                ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                                       X509_UNICODE_ANY_STRING,
                                       pCertExtension->Value.pbData,
                                       pCertExtension->Value.cbData,
                                       0,
                                       (void *) pCertType,
                                       &cbCertType);
            }
            
            if (ok && (0 != cbCertType)) {
                LPWSTR pszCertTypeName = (LPWSTR) pCertType->Value.pbData;

                hCertType = NULL;
                ppszCertTypePropertyList = NULL;

                // Get a handle to the cert type
                hr = CAFindCertTypeByName( 
                    pszCertTypeName,
                    NULL, // hCAInfo
                    CT_FIND_LOCAL_SYSTEM | CT_ENUM_MACHINE_TYPES, // dwFlags
                    &hCertType
                    );

                if (FAILED(hr)) {
                    PrintMsg(REPADMIN_SHOWCERT_CAFINDCERTTYPEBYNAME_FAILURE, hr);
                } else {

                    // Get the base name property of the cert type object
                    hr = CAGetCertTypeProperty( hCertType,
                                                CERTTYPE_PROP_CN,
                                                &ppszCertTypePropertyList
                        );
                    if (FAILED(hr)) {
                        PrintMsg(REPADMIN_SHOWCERT_CAGETCERTTYPEPROPERTY_FAILURE, hr);
                    } else {
                        Assert( ppszCertTypePropertyList[1] == NULL );

                        if (0 == _wcsicmp(ppszCertTypePropertyList[0],
                                          wszCERTTYPE_DC )) {
                            // We found our DC certificate; we're done!
                            fCertFound = TRUE;
                        }
                    } // if failed
                } // if failed

                if (ppszCertTypePropertyList != NULL) {
                    hr = CAFreeCertTypeProperty( hCertType,
                                                 ppszCertTypePropertyList );
                    if (FAILED(hr)) {
                        PrintMsg(REPADMIN_SHOWCERT_CAFREECERTTYPEPROPERTY_FAILURE, hr);
                    }
                }
                if (hCertType != NULL) {
                    hr = CACloseCertType( hCertType );
                    if (FAILED(hr)) {
                        PrintMsg(REPADMIN_SHOWCERT_CACLOSECERTTYPE_FAILURE, hr);
                    }
                }

                if (fCertFound) {
                    // leave loop after freeing resources
                    break;
                }
            } // if ok
        } // if null == cert extension
    } // for

    if (NULL != pCertType) {
        free(pCertType);
    }
// Someone put this in here, but I didn't like the idea of freeing memory
// in the middle of an allocated chunk, so I disabled this code.
//    if (NULL != pBadStyleToLeakMem) {
//        free(pBadStyleToLeakMem);
//    }

    return pCertContext;
}


int
ShowCert(
    int argc,
    LPWSTR argv[]
    )

/*++

Routine Description:

Check whether the DC cert is present on the named DSA

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL fVerbose = FALSE;
    LPWSTR pszDSA = NULL;
    int iArg;
    HCERTSTORE hRemoteStore = NULL;
    WCHAR wszStorePath[MAX_PATH];
    DWORD status = ERROR_SUCCESS;
    PCCERT_CONTEXT pDcCert = NULL;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if ( (_wcsicmp( argv[iArg], L"/v" ) == 0) ||
             (_wcsicmp( argv[iArg], L"/verbose" ) == 0) ) {
            fVerbose = TRUE;
        } else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        } else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (pszDSA) {
        _snwprintf(wszStorePath, ARRAY_SIZE(wszStorePath),
                   L"\\\\%ls\\MY", pszDSA);
    } else {
        wcscpy( wszStorePath, L"MY" );
    }

    PrintMsg(REPADMIN_SHOWCERT_STATUS_CHECKING_DC_CERT, wszStorePath);

    hRemoteStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        0, //X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        0,
        CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_LOCAL_MACHINE,
        (LPVOID) wszStorePath
        );
    if (NULL == hRemoteStore) {
        status = GetLastError();
        if (status == ERROR_ACCESS_DENIED) {
            PrintMsg(REPADMIN_SHOWCERT_STORE_ACCESS_DENIED);
        } else {
            PrintMsg(REPADMIN_SHOWCERT_CERTOPENSTORE_FAILED, Win32ErrToString(status));
        }
        goto cleanup;
    }

    pDcCert = getDCCert( NULL, hRemoteStore, TRUE /* v2 */  );
    if (pDcCert) {
        PrintMsg(REPADMIN_SHOWCERT_DC_V2_CERT_PRESENT);
    } else {
        pDcCert = getDCCert( NULL, hRemoteStore, FALSE /* v1 */  );
        if (pDcCert) {
            PrintMsg(REPADMIN_SHOWCERT_DC_V1_CERT_PRESENT);
        } else {
            PrintMsg(REPADMIN_SHOWCERT_DC_CERT_NOT_FOUND);
            status = ERROR_NOT_FOUND;
        }
    }

cleanup:
    if (NULL != pDcCert) {
        CertFreeCertificateContext(pDcCert);
    }
    if (NULL != hRemoteStore) {
        CertCloseStore(hRemoteStore, 0);
    }

    return status;

}

/* end repcrypt.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\repism.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repism.c - ISM command functions

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "repadmin.h"


int
ShowBridgeHelp(
    LPWSTR pwzTransportDn,
    LPWSTR pwzSiteDn
    )

/*++

Routine Description:

    Description

Arguments:

    pwzTransportDn -
    pwzSiteDn -

Return Value:

    int -

--*/

{
    ISM_SERVER_LIST * pServerList = NULL;
    DWORD iServer, err;

    err = I_ISMGetTransportServers(pwzTransportDn, pwzSiteDn, &pServerList);

    if (NO_ERROR != err) {
        PrintFuncFailed(L"I_ISMGetTransportServers", err);
        goto cleanup;
    }

    // All this is supposed to be heiarchically printed out under the data for
    // a site.  The CR's seemed unnecessary.
    if (NULL == pServerList) {
//        PrintMsg(REPADMIN_PRINT_CR);
        PrintTabMsg(2, REPADMIN_SHOWISM_ALL_DCS_BRIDGEHEAD_CANDIDATES, pwzSiteDn);
    }
    else {
        for (iServer = 0; iServer < pServerList->cNumServers; iServer++) {
//            PrintMsg(REPADMIN_PRINT_CR);
            PrintTabMsg(2, REPADMIN_SHOWISM_N_SERVERS_ARE_BRIDGEHEADS,
                        pServerList->cNumServers, 
                        pwzTransportDn,  
                        pwzSiteDn);
//            PrintMsg(REPADMIN_PRINT_CR);
            PrintTabMsg(4, REPADMIN_SHOWISM_N_SERVERS_ARE_BRIDGEHEADS_DATA,
                        iServer,
                        pServerList->ppServerDNs[iServer]);
        }
    }

cleanup:
    if (pServerList) {
        I_ISMFree( pServerList );
    }
    return err;
} /* ShowBridgeHelp */


int
ShowIsmHelp(
    LPWSTR pwzTransportDn,
    BOOL fVerbose
    )

/*++

Routine Description:

    Description

Arguments:

    pwzTransportDn -

Return Value:

    int -

--*/

{
    ISM_CONNECTIVITY * pSiteConnect = NULL;
    DWORD iSite1, iSite2, err;


    err = I_ISMGetConnectivity(pwzTransportDn, &pSiteConnect);

    if (NO_ERROR != err) {
        PrintFuncFailedArgs(L"I_ISMGetConnectivity", pwzTransportDn, err);
        goto cleanup;
    }
    if (pSiteConnect == NULL) {
        PrintMsg(REPADMIN_SHOWISM_SITE_CONNECTIVITY_NULL);
        err = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    PrintMsg(REPADMIN_SHOWISM_TRANSPORT_CONNECTIVITY_HDR, 
           pwzTransportDn, pSiteConnect->cNumSites);


    for (iSite2 = 0; iSite2 < pSiteConnect->cNumSites; iSite2++) {
        PrintMsg(REPADMIN_SHOWISM_SITES_HDR, iSite2 ? L", " : L"     ", iSite2);
    }
    PrintMsg(REPADMIN_PRINT_CR);
    for (iSite1 = 0; iSite1 < pSiteConnect->cNumSites; iSite1++) {

        // First print out the site we are working on
        PrintMsg(REPADMIN_SHOWISM_SITES_HDR_2, iSite1, pSiteConnect->ppSiteDNs[iSite1]);

        // Print out some obscure number iSite times ??? :)
        for (iSite2 = 0; iSite2 < pSiteConnect->cNumSites; iSite2++) {
            PISM_LINK pLink = &(pSiteConnect->pLinkValues[iSite1 * pSiteConnect->cNumSites + iSite2]);

            PrintMsg(REPADMIN_SHOWISM_SITES_DATA, iSite2 ? L", " : L"    ",
                     pLink->ulCost, pLink->ulReplicationInterval, pLink->ulOptions );

        }
        PrintMsg(REPADMIN_PRINT_CR);

        // Print out information about which servers can be bridgeheads.
        err = ShowBridgeHelp( pwzTransportDn, pSiteConnect->ppSiteDNs[iSite1] );

        // If verbose print out the schedule for kicks.
        if (fVerbose) {

            for (iSite2 = 0; iSite2 < pSiteConnect->cNumSites; iSite2++) {
                PISM_LINK pLink = &(pSiteConnect->pLinkValues[iSite1 * pSiteConnect->cNumSites + iSite2]);

                if(iSite1 == iSite2){
                    // Doesn't make much sense to check against our own site, it 
                    // just comes up as 0 cost, connection always available.
                    continue;
                }

                if (pLink->ulCost != 0xffffffff) {
                    ISM_SCHEDULE * pSchedule = NULL;
                    PrintTabMsg(2, REPADMIN_SHOWISM_SCHEDULE_DATA, 
                            pSiteConnect->ppSiteDNs[iSite1],
                            pSiteConnect->ppSiteDNs[iSite2],
                            pLink->ulCost, pLink->ulReplicationInterval );

                    err = I_ISMGetConnectionSchedule(
                        pwzTransportDn,
                        pSiteConnect->ppSiteDNs[iSite1],
                        pSiteConnect->ppSiteDNs[iSite2],
                        &pSchedule);

                    if (NO_ERROR == err) {
                        if (NULL == pSchedule) {
                            PrintTabMsg(4, REPADMIN_SHOWISM_CONN_ALWAYS_AVAIL);
                        }
                        else {
                            printSchedule( pSchedule->pbSchedule, pSchedule->cbSchedule );
                            I_ISMFree( pSchedule );
                            pSchedule = NULL;
                        }
                    }
                    else {
                        PrintFuncFailed(L"I_ISMGetTransportServers", err);
                    }
                }
                
            } // for site 2

        } // if verbose

        // Finally, print out a line return to seperate the sites.
        PrintMsg(REPADMIN_PRINT_CR);

    } // for site 1

cleanup:
    if (pSiteConnect) {
        I_ISMFree( pSiteConnect );
    }

    return err;
} /* ShowIsmHelp */


int
ShowIsm(
    int     argc,
    LPWSTR  argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    LPWSTR          pwzTransportDn = NULL;
    DWORD           err;
    LDAP *          hld = NULL;
    int             ldStatus;
    LDAPMessage *   pRootResults = NULL;
    LPSTR           rgpszRootAttrsToRead[] = {"configurationNamingContext", NULL};
    LPWSTR *        ppwzConfigNC = NULL;
    WCHAR           wzTransportDn[256];
    BOOL            fVerbose = FALSE;

    if (argc > 2) {
        if ( (_wcsicmp( argv[argc-1], L"/v" ) == 0) ||
             (_wcsicmp( argv[argc-1], L"/verbose" ) == 0) ) {
            fVerbose = TRUE;
            argc--;
        }
    }

    if (argc == 2) {
        // Connect & bind to target DSA.
        hld = ldap_initW(L"localhost", LDAP_PORT);
        if (NULL == hld) {
            PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE_LOCALHOST);
            return ERROR_DS_UNAVAILABLE;
        }
        ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
        CHK_LD_STATUS(ldStatus);

        // What's the DN of the config NC?
        ldStatus = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
                                 rgpszRootAttrsToRead, 0, &pRootResults);
        CHK_LD_STATUS(ldStatus);

        ppwzConfigNC = ldap_get_valuesW(hld, pRootResults,
                                        L"configurationNamingContext");
        Assert(NULL != ppwzConfigNC);
        wcscpy( wzTransportDn, L"CN=IP,CN=Inter-Site Transports,CN=Sites," );
        wcscat( wzTransportDn, *ppwzConfigNC );
        err = ShowIsmHelp( wzTransportDn, fVerbose );
        wcscpy( wzTransportDn, L"CN=SMTP,CN=Inter-Site Transports,CN=Sites," );
        wcscat( wzTransportDn, *ppwzConfigNC );
        err = ShowIsmHelp( wzTransportDn, fVerbose );
        // Add new inter-site transport here
        // As an improvement, we could enumerate through the whole container.
    } else if (argc == 3 ) {
        pwzTransportDn = argv[2];
        err = ShowIsmHelp( pwzTransportDn, fVerbose );
    } else {
        PrintMsg(REPADMIN_SHOWISM_SUPPLY_TRANS_DN_HELP);
        return ERROR_INVALID_FUNCTION;
    }

    if (ppwzConfigNC) {
        ldap_value_freeW(ppwzConfigNC);
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    if (hld) {
        ldap_unbind(hld);
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\repfull.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repfull.c - full sync all command functions

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "ReplRpcSpoof.hxx"
#include "repadmin.h"

typedef struct _DSA_INFO {
    LDAP *  hld;
    HANDLE  hDs;
    HKEY    hKey;
    LPWSTR  pszDN;
    WCHAR   szDisplayName[80];
} DSA_INFO;

int
FullSyncAll(
    IN  int     argc,
    IN  LPWSTR  argv[]
    )
{
    int             ret = 0;
    LPWSTR          pszNC = NULL;
    LPWSTR          pszDSA = NULL;
    WCHAR *         pszTemp = NULL;
    int             iArg;
    LDAP *          hld;
    BOOL            fCacheGuids = TRUE;
    int             ldStatus;
    LDAPMessage *   pRootResults;
    LDAPSearch *    pSearch = NULL;
    LDAPMessage *   pResults;
    LDAPMessage *   pDsaEntry;
    LPSTR           rgpszRootAttrsToRead[] = {"configurationNamingContext", NULL};
    LPWSTR          rgpszDsaAttrs[] = {L"objectGuid", NULL};
    LPWSTR *        ppszConfigNC;
    WCHAR           szFilter[1024];
    WCHAR           szGuidDNSName[256];
    DWORD           iDsa;
    DWORD           cNumDsas;
    DSA_INFO *      pDsaInfo;
    LPWSTR          pszRootDomainDNSName;
    int             nOptions;
    BOOL            fLeaveOff = FALSE;
    ULONG           ulTotalEstimate;
    ULONG           ulOptions;

    // Parse command-line arguments.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/n")
            || !_wcsicmp(argv[iArg], L"/nocache")) {
            fCacheGuids = FALSE;
        }
        else if (!_wcsicmp(argv[iArg], L"/l")
                 || !_wcsicmp(argv[iArg], L"/leaveoff")) {
            fLeaveOff = TRUE;
        }
        else if (NULL == pszNC) {
            pszNC = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszNC) {
        PrintMsg(REPADMIN_PRINT_NO_NC);
        return ERROR_INVALID_FUNCTION;
    }

    if (NULL == pszDSA) {
        // This is here as a safeguard -- it's not really required.
        // Wouldn't want someone accidentally running this against the wrong
        // enterprise....
        PrintMsg(REPADMIN_SYNCALL_NO_DSA);
        return ERROR_INVALID_FUNCTION;
    }


    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( LdapHandle, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );



    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);


    if (fCacheGuids) {
        // Populate GUID cache (DSA GUIDs to display names).
        BuildGuidCache(hld);
    }

    // What's the DNS name of the enterprise root domain?
    ret = GetRootDomainDNSName(pszDSA, &pszRootDomainDNSName);
    if (ret) {
        PrintFuncFailed(L"GetRootDomainDNSName", ret);
        return ret;
    }


    // What's the DN of the config NC?
    ldStatus = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
                             rgpszRootAttrsToRead, 0, &pRootResults);
    CHK_LD_STATUS(ldStatus);

    ppszConfigNC = ldap_get_valuesW(hld, pRootResults,
                                    L"configurationNamingContext");
    Assert(NULL != ppszConfigNC);


    // Find all DCs that hold a writeable copy of the target NC.
    swprintf(szFilter, L"(& (objectCategory=ntdsDsa) (hasMasterNCs=%ls))", pszNC);

    // Do paged search ...
    pSearch = ldap_search_init_pageW(hld,
				    *ppszConfigNC,
				    LDAP_SCOPE_SUBTREE,
				    szFilter,
				    rgpszDsaAttrs,
				    FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
	ldStatus = LdapGetLastError();
	CHK_LD_STATUS(ldStatus);
    }
		
    ldStatus = ldap_get_next_page_s(hld,
				     pSearch,
				     0,
				     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
				     &ulTotalEstimate,
				     &pResults);
    if(ldStatus == LDAP_NO_RESULTS_RETURNED){
        PrintMsg(REPADMIN_SYNCALL_NO_INSTANCES_OF_NC);
        return ERROR_NOT_FOUND;
    }

    iDsa = 0;

    // Connect to each writeable DC,
    PrintMsg(REPADMIN_SYNCALL_CONNECTING_TO_DCS);

    while(ldStatus == LDAP_SUCCESS){

	pDsaInfo = realloc(pDsaInfo,
			   (ldap_count_entries(hld, pResults) + iDsa)
			   * sizeof(*pDsaInfo));
	if(pDsaInfo == NULL){
	    //printf("Error not enough memory, asked for %d\n",
            //       (ldap_count_entries(hld, pResults) + iDsa) * sizeof(*pDsaInfo));
            PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
	    return(ERROR_NOT_ENOUGH_MEMORY);
	}
	for (pDsaEntry = ldap_first_entry(hld, pResults);
	     NULL != pDsaEntry;
	     iDsa++, pDsaEntry = ldap_next_entry(hld, pDsaEntry)) {
	    struct berval **  ppbvGuid;
	    LPSTR             pszGuid;
	    RPC_STATUS        rpcStatus;
	    HKEY              hKLM;

	    // Cache DSA DN.
	    pDsaInfo[iDsa].pszDN = ldap_get_dnW(hld, pDsaEntry);
	    Assert(NULL != pDsaInfo[iDsa].pszDN);

	    // Cache DSA display name (e.g., "Site\Server").
	    lstrcpynW(pDsaInfo[iDsa].szDisplayName,
		      GetNtdsDsaDisplayName(pDsaInfo[iDsa].pszDN),
		      ARRAY_SIZE(pDsaInfo[iDsa].szDisplayName));

	    // Derive DSA's GUID-based DNS name.
	    ppbvGuid = ldap_get_values_len(hld, pDsaEntry, "objectGuid");
	    Assert(NULL != ppbvGuid);
	    Assert(1 == ldap_count_values_len(ppbvGuid));

	    rpcStatus = UuidToStringA((GUID *) (*ppbvGuid)->bv_val,
				      (UCHAR **) &pszGuid);

	    swprintf(szGuidDNSName, L"%hs._msdcs.%ls", pszGuid, pszRootDomainDNSName);

	    RpcStringFree((UCHAR **) &pszGuid);
	    ldap_value_free_len(ppbvGuid);

	    // Cache LDAP handle.
	    pDsaInfo[iDsa].hld = ldap_initW(szGuidDNSName, LDAP_PORT);
	    if (NULL == hld) {
                PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE_2,
                         szGuidDNSName, pDsaInfo[iDsa].szDisplayName);
		return LDAP_SERVER_DOWN;
	    }

        // use only A record dns name discovery
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        (void)ldap_set_optionW( LdapHandle, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


	    ldStatus = ldap_bind_s(pDsaInfo[iDsa].hld, NULL, (char *) gpCreds,
				   LDAP_AUTH_SSPI);
	    CHK_LD_STATUS(ldStatus);

	    // Cache replication handle.
	    ret = DsBindWithCredW(szGuidDNSName, NULL,
				  (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
				  &pDsaInfo[iDsa].hDs);
	    if (ret != ERROR_SUCCESS) {
                PrintBindFailed(pDsaInfo[iDsa].szDisplayName, ret);
		return ret;
	    }

	    // Cache registry handle.
	    ret = RegConnectRegistryW(szGuidDNSName, HKEY_LOCAL_MACHINE, &hKLM);
	    if (ERROR_SUCCESS != ret) {
                PrintMsg(REPADMIN_SYNCALL_REGISTRY_BIND_FAILED,
		       pDsaInfo[iDsa].szDisplayName);
                PrintErrEnd(ret);
		return ret;
	    }

	    ret = RegOpenKeyEx(hKLM,
			       "System\\CurrentControlSet\\Services\\NTDS\\Parameters",
			       0, KEY_ALL_ACCESS, &pDsaInfo[iDsa].hKey);
	    if (ERROR_SUCCESS != ret) {
                PrintMsg(REPADMIN_SYNCALL_OPEN_DS_REG_KEY_FAILED, 
		         pDsaInfo[iDsa].szDisplayName);
                PrintErrEnd(ret);
		return ret;
	    }

	    RegCloseKey(hKLM);
	} // end of _one_ page of results

	ldap_msgfree(pResults);
	pResults = NULL;

	ldStatus = ldap_get_next_page_s(hld,
					 pSearch,
					 0,
					 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					 &ulTotalEstimate,
					 &pResults);
    } // end of paged results
    if(ldStatus != LDAP_NO_RESULTS_RETURNED){
	CHK_LD_STATUS(ldStatus);
    }
    ldStatus = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(ldStatus);

    cNumDsas = iDsa;

    PrintMsg(REPADMIN_SYNCALL_DISABLING_REPL);
    for (iDsa = 0; iDsa < cNumDsas; iDsa++) {
        LDAPMessage *     pNCResults;
        LDAPMessage *     pNCEntry;
        LPWSTR            rgpszNCAttrsToRead[] = {L"repsFrom", L"whenChanged", NULL};
        struct berval **  ppbvReps;
        int               cReps;
        int               iReps;
        LDAPModW          ModOpt = {LDAP_MOD_DELETE, L"replUpToDateVector", NULL};
        LDAPModW *        rgpMods[] = {&ModOpt, NULL};
        DWORD             dwAllowSysOnlyChange;
        DWORD             cbAllowSysOnlyChange;
        REPLICA_LINK *    prl;

        
        PrintMsg(REPADMIN_SYNCALL_DSA_LINE, pDsaInfo[iDsa].szDisplayName);

        // Turn off inbound/outbound replication.
        ldStatus = GetDsaOptions(pDsaInfo[iDsa].hld, pDsaInfo[iDsa].pszDN,
                                 &nOptions);
        CHK_LD_STATUS(ldStatus);

        if (!(nOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL)
            || !(nOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL)) {
            nOptions |= NTDSDSA_OPT_DISABLE_INBOUND_REPL
                        | NTDSDSA_OPT_DISABLE_OUTBOUND_REPL;

            ldStatus = SetDsaOptions(pDsaInfo[iDsa].hld, pDsaInfo[iDsa].pszDN,
                                     nOptions);
            CHK_LD_STATUS(ldStatus);

            PrintMsg(REPADMIN_SYNCALL_REPL_DISABLED);
        }

        // Remove the replUpToDateVector for this NC.
        // Requires adding the extra-special flag to allow modification of
        // system-only attributes.
        PrintMsg(REPADMIN_SYNCALL_REMOVING_UTD_VEC);

        dwAllowSysOnlyChange = 1;
        cbAllowSysOnlyChange = sizeof(dwAllowSysOnlyChange);
        ret = RegSetValueEx(pDsaInfo[iDsa].hKey, "Allow System Only Change",
                            0, REG_DWORD, (BYTE *) &dwAllowSysOnlyChange,
                            cbAllowSysOnlyChange);
        if (ERROR_SUCCESS != ret) {
            PrintMsg(REPADMIN_SYNCALL_COULDNT_SET_REGISTRY);
            PrintErrEnd(ret);
            return ret;
        }

        ldStatus = ldap_modify_sW(pDsaInfo[iDsa].hld, pszNC, rgpMods);
        CHK_LD_STATUS(ldStatus);

        dwAllowSysOnlyChange = 0;
        cbAllowSysOnlyChange = sizeof(dwAllowSysOnlyChange);
        ret = RegSetValueEx(pDsaInfo[iDsa].hKey, "Allow System Only Change",
                            0, REG_DWORD, (BYTE *) &dwAllowSysOnlyChange,
                            cbAllowSysOnlyChange);
        if (ERROR_SUCCESS != ret) {
            PrintMsg(REPADMIN_SYNCALL_COULDNT_SET_REGISTRY);
            PrintErrEnd(ret);
            return ret;
        }

        // Enumerate and delete all repsFrom's for this NC.
        ldStatus = ldap_search_sW(pDsaInfo[iDsa].hld, pszNC, LDAP_SCOPE_BASE,
                                  L"(objectClass=*)", rgpszNCAttrsToRead, 0,
                                  &pNCResults);
        CHK_LD_STATUS(ldStatus);

        pNCEntry = ldap_first_entry(hld, pNCResults);
        Assert(NULL != pNCEntry);

        if (NULL == pNCEntry) {
            PrintMsg(REPADMIN_SYNCALL_NO_INBOUND_REPL_PARTNERS);
        }
        else {
            ppbvReps = ldap_get_values_len(hld, pNCEntry, "repsFrom");
            cReps = ldap_count_values_len(ppbvReps);

            for (iReps = 0; iReps < cReps; iReps++) {
                LPWSTR pwszSrcDsaAddr = NULL;

                prl = (REPLICA_LINK *) ppbvReps[iReps]->bv_val;
                PrintMsg(REPADMIN_SYNCALL_REMOVE_LINK,
                         GetGuidDisplayName(&prl->V1.uuidDsaObj));

                ret = AllocConvertWideEx(CP_UTF8,
                                         RL_POTHERDRA(prl)->mtx_name,
                                         &pwszSrcDsaAddr);
                if (!ret) {
                    ret = DsReplicaDelW(pDsaInfo[iDsa].hDs,
                                        pszNC,
                                        pwszSrcDsaAddr,
                                        DS_REPDEL_WRITEABLE | DS_REPDEL_IGNORE_ERRORS);
                }

                if (NULL != pwszSrcDsaAddr) {
                    LocalFree(pwszSrcDsaAddr);
                }

                if (ERROR_SUCCESS != ret) {
                    PrintMsg(REPADMIN_SYNCALL_DEL_REPLICA_LINK_FAILED);
                    PrintErrEnd(ret);
                    return ret;
                }
            }

            ldap_value_free_len(ppbvReps);
        }

        ldap_msgfree(pNCResults);
    }

    // Now all replication bookmarks have been wiped from DCs on which this NC
    // is writeable.
    if (!fLeaveOff) {
        PrintMsg(REPADMIN_SYNCALL_RE_ENABLING_REPL);
        for (iDsa = 0; iDsa < cNumDsas; iDsa++) {
            PrintMsg(REPADMIN_SYNCALL_DSA_LINE, pDsaInfo[iDsa].szDisplayName);

            // Turn on inbound/outbound replication.
            ldStatus = GetDsaOptions(pDsaInfo[iDsa].hld, pDsaInfo[iDsa].pszDN,
                                     &nOptions);
            CHK_LD_STATUS(ldStatus);

            nOptions &= ~(NTDSDSA_OPT_DISABLE_INBOUND_REPL
                          | NTDSDSA_OPT_DISABLE_OUTBOUND_REPL);

            ldStatus = SetDsaOptions(pDsaInfo[iDsa].hld, pDsaInfo[iDsa].pszDN,
                                     nOptions);
            CHK_LD_STATUS(ldStatus);
        }
    }
    else {
        PrintMsg(REPADMIN_SYNCALL_NOTE_DISABLED_REPL);
    }

    // Clean up.
    for (iDsa = 0; iDsa < cNumDsas; iDsa++) {
        ldap_memfreeW(pDsaInfo[iDsa].pszDN);
        ldap_unbind(pDsaInfo[iDsa].hld);
        DsUnBind(&pDsaInfo[iDsa].hDs);
        RegCloseKey(pDsaInfo[iDsa].hKey);
    }

    ldap_msgfree(pRootResults);

    ldap_unbind(hld);

    PrintMsg(REPADMIN_SYNCALL_SUCCESS);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\replctrl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    replctrl.c

Abstract:

    Callable api to the ldap replication control

    Use the dirsync replication control to get changes from a
    source and nc given a usn and utd

    This code derived from
    \nt\private\dirsync\dsserver\adread\read.cpp:
        GetMoreDataFromDS()

    The source is essentially stateless for change positioning. The caller
    (destination) records where he was last.  A change position is represented
    by a opaque data structure called a cookie.

    The is no support at the moment to explode and construct cookies, so that
    one could build an arbitrary one.  Instead, you may either duplicate a cookie
    from a reps-from, or you can start with no cookie, and iterate sequentially 
    through all the changes, and then proceeding incrementally from there.

Author:

    Will Lees (wlees) 30-Apr-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <ntldap.h>
#include <winber.h>

#include "msg.h"

// Someone should make the repadmin.h includeable here, by making the repadmin.h 
// macros work with this piece of code.  Since it's late in the product stage, I'm
// going with the low impact method of making PrintMsg() work in this file, and
// including it here.
void
PrintMsg(
    IN  DWORD   dwMessageCode,
    IN  ...
    );


#define CHK_LD_STATUS( x )                        \
{                                                 \
    if ( LDAP_SUCCESS != (x) )                    \
    {                                             \
        err = LdapMapErrorToWin32(x);             \
        PrintMsg(REPADMIN_GENERAL_LDAP_ERR,        \
                __FILE__,                         \
                __LINE__,                         \
                (x),                              \
                ldap_err2stringW( x ),            \
                err );                            \
       goto error;                                \
    }                                             \
}

#define MemAlloc( x ) malloc( x )
#define MemFree( x ) free( x )

#define BAIL() \
PrintMsg(REPADMIN_REPLCTRL_BAIL, __LINE__, __FILE__); \
goto error;
#define BAIL_ON_NULL(x) if (!(x)) { \
PrintMsg(REPADMIN_REPLCTRL_BAIL_ON_NULL, #x, __LINE__, __FILE__ ); \
err = ERROR_NOT_ENOUGH_MEMORY; \
goto error; \
}
#define BAIL_ON_FAILURE(x) if (x) { \
PrintMsg(REPADMIN_REPLCTRL_BAIL_ON_FAILURE, #x, __LINE__, __FILE__ ); \
goto error; \
}

// Read 100 objects at a time
#define DIRSYNC_SIZE_LIMIT 100
// Maximum attrs to return
// sic
#define MAX_ATTIBUTES        1048576

// The following is from  dsamain/ldap/const.hxx

//
// version of the repl dirsync control cookie structure
//
// structure for v1
//   REPL VERSION
//   vector To
//   UTD Vector
//
// structure for v2
//   REPL VERSION
//   cb UTD vector
//   vectorTo
//   invocation ID
//   UTD Vector
//
// structure for v3
//   REPL_SIGNATURE
//   REPL_VERSION
//   TIMESTAMP
//   RESERVED
//   cb UTD vector
//   vectorTo
//   invocation ID
//   UTD Vector
//

#define REPL_VERSION        3
#define REPL_SIGNATURE      'SDSM'
#define LDAP_VALID_DIRSYNC_CONTROL_FLAGS    (DRS_GET_ANC)

//
// minimum size of a repl control cookie
//

#define MIN_REPL_CONTROL_BLOB_LENGTH    (sizeof(DWORD) + sizeof(DWORD) + sizeof(FILETIME) + \
                                        sizeof(LARGE_INTEGER) + sizeof(DWORD) + \
                                        sizeof(USN_VECTOR) + sizeof(UUID))

#define ASCII_TO_INT(x)    ((x)<='9' ? (x)-'0' : ((x) <='F' ? (x)-'A' + 10 : (x)-'a' + 10))
#define ASCII_TO_INTW(x)    ((x)<=L'9' ? (x)-L'0' : ((x) <=L'F' ? (x)-L'A' + 10 : (x)-L'a' + 10))

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Mon May 03 15:25:45 1999 */

DWORD
BerEncodeReplicationControl(
    DWORD dwReplFlags,
    PBYTE pCookie,
    DWORD dwLen,
    PBERVAL *ppBerVal
    );

DWORD
BerDecodeReplicationCookie(
    LDAP *m_pLdap,
    LDAPMessage *m_pSearchResult,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    BOOL *pfMoreData
    );

void
displayResults(
    LDAP *pLdap,
    LDAPMessage *pSearchResult,
    BOOL fVerbose
    );

void
dumpCookie(
    PBYTE pCookieNext,
    DWORD dwCookieLenNext
    );

DWORD
packCookie(
    USN_VECTOR *pUsnVec,
    GUID *puuidInvocationId,
    UPTODATE_VECTOR *pUtdvecV1,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    );

/* End Forward */


DWORD
DsMakeReplCookieForDestW(
    DS_REPL_NEIGHBORW *pNeighbor,
    DS_REPL_CURSORS * pCursors,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    )

/*++

Routine Description:

A Cookie represents a position in the changes stream for a particular source.

Build a cookie from neighbor and cursor information representing the
position of a destination with respect to some source

Cookie is output on success, otherwise not returned.

Arguments:

    pNeighbor - 
    pCursors - 
    ppCookieNext - 
    pdwCookieLenNext - 

Return Value:

    DWORD - 

--*/

{
    DWORD err, i;
    USN_VECTOR usnVec;
    UPTODATE_VECTOR *pUTD = NULL;
    DWORD cbUTD = 0;

    // Initialize out parameters
    *ppCookieNext = NULL;
    *pdwCookieLenNext = 0;

    // Construct USN VECTOR
    ZeroMemory( &usnVec, sizeof( USN_VECTOR ) );
    usnVec.usnHighObjUpdate = pNeighbor->usnLastObjChangeSynced;
    usnVec.usnHighPropUpdate = pNeighbor->usnAttributeFilter;

    // Construct UPTODATE VECTOR
    cbUTD = UpToDateVecV1SizeFromLen( pCursors->cNumCursors );
    pUTD = malloc( cbUTD );
    if (pUTD == NULL) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    ZeroMemory( pUTD, cbUTD );
    pUTD->dwVersion = 1;
    pUTD->V1.cNumCursors = pCursors->cNumCursors;
    for( i = 0; i < pCursors->cNumCursors; i++ ) {
        pUTD->V1.rgCursors[i].uuidDsa = pCursors->rgCursor[i].uuidSourceDsaInvocationID;
        pUTD->V1.rgCursors[i].usnHighPropUpdate = pCursors->rgCursor[i].usnAttributeFilter;
    }

    // Build the initial cookie
    err = packCookie(
        &usnVec,
        &(pNeighbor->uuidSourceDsaInvocationID),
        pUTD,
        ppCookieNext,
        pdwCookieLenNext
        );
    if (err != ERROR_SUCCESS) {
        goto error;
    }

    err = ERROR_SUCCESS;
error:

    if (pUTD) {
        free(pUTD);
    }

    return err;
} /* DsMakeReplCookieForDest */


DWORD
DsFreeReplCookie(
    PBYTE pCookie
    )

/*++

Routine Description:

Free a cookie returned by DsMakeReplCookie

Arguments:

    pCookie - pointer to cookie

Return Value:

    DWORD - errors if cookie not valid

--*/

{
    DWORD dwSignature;

    if (pCookie == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the Signature.
    //
    dwSignature = *((PDWORD)pCookie);

    if (dwSignature != REPL_SIGNATURE) {
        return ERROR_INVALID_PARAMETER;
    }

    MemFree( pCookie );

    return ERROR_SUCCESS;
} /* DsFreeReplCookie */


DWORD
DsGetSourceChangesW(
    LDAP *m_pLdap,
    LPWSTR m_pSearchBase,
    LPWSTR pszSourceFilter,
    DWORD dwReplFlags,
    PBYTE pCookieCurr,
    DWORD dwCookieLenCurr,
    LDAPMessage **ppSearchResult,
    BOOL *pfMoreData,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    PWCHAR *ppAttListArray
    )

/*++

Return a packet of changes given position information in "current cookie".

If successful, an updated position will be returned in "next cookie".

Cookies are self describing and position independent: they may be saved to long
term storage and retrieved later as a kind of bookmark.  Cookies are specific to
the source server and naming context they were created for.

The caller is responsible for deallocating the cookies himself.  The "next
cookie" in particular must be deallocated using DsFreeReplCookie.  The current
cookie may come from a file or other long term storage.

The changes are returned as an LDAP message of entries, attributes and values.
Secret data will have been supressed.

Arguments:

The out parameters are initialized to null at the start.

    m_pLdap - ldap handle to source server.
    m_pSearchBase - The dn of the nc head to search
    pszSourceFilter - Ldap search filter, if any
    dwReplFlags - Replication flags, DRS_GET_ANC, etc
    pCookieCurr - null, or cookie previously returned by DsGetSourceChanges.
          The cookie must have come from a call with the same source server and
          same naming context.
    dwCookieLenCurr - cookie length, or zero
    ppSearchResult - pointer to pointer, to receive ldap message
    pfMoreData - Indication whether there is more data and this call should be made
        again with the updated cookie.  This is independent of whether the current
        call returned data.
    ppCookieNext - Newly allocated cookie for the updated position
    pdwCookieLenNext - Length of new cookie
    ppAttListArray - A Null terminated list of pointers to attributes to return

The out parameters are not allocated on error.

Even if there are no changes (entries in result are zero), the cookie may
have been updated with the latest positioning information.

Return Value:

    DWORD - 

--*/

{
    PBERVAL pBerVal = NULL;
    LDAPControlW replControl;
    LDAPControlW extDNControl;
    PLDAPControlW controlArray[3];
    int lderr, err;
    LDAP_TIMEVAL TimeVal;

    // Initialize out parameters
    *ppSearchResult = NULL;
    *pfMoreData = FALSE;
    *ppCookieNext = NULL;
    *pdwCookieLenNext = 0;

    //
    // The replication control has the USN that specifies where to
    // continue from. This can be treated as opaque information by us.
    //

    err = BerEncodeReplicationControl(dwReplFlags,
                                      pCookieCurr, dwCookieLenCurr,
                                      &pBerVal);
    BAIL_ON_FAILURE( err );

    replControl.ldctl_oid = LDAP_SERVER_DIRSYNC_OID_W;
    replControl.ldctl_iscritical = TRUE;
    replControl.ldctl_value.bv_len = pBerVal->bv_len;
    replControl.ldctl_value.bv_val = (PCHAR)(pBerVal->bv_val);
    extDNControl.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    extDNControl.ldctl_iscritical = TRUE;
    extDNControl.ldctl_value.bv_len = 0;
    extDNControl.ldctl_value.bv_val = NULL;

    controlArray[0] = &replControl;
    controlArray[1] = &extDNControl;
    controlArray[2] = NULL;

    //
    // Adding in timeout so that we can recover if the server do not respond
    //
    TimeVal.tv_usec = 0;
    TimeVal.tv_sec = LDAP_TIMEOUT;

//    dumpCookie( *ppCookieNext, *pdwCookieLenNext );

    lderr = ldap_search_ext_sW(m_pLdap,
                               m_pSearchBase,
                               LDAP_SCOPE_SUBTREE, // m_pSessionData->SourceScope
                               pszSourceFilter,
                               ppAttListArray,
                               0,
                               (PLDAPControlW *) &controlArray,
                               NULL,
                               &TimeVal,
                               DIRSYNC_SIZE_LIMIT,
                               ppSearchResult);

    CHK_LD_STATUS( lderr );

    if ( (*ppSearchResult) == NULL )
    {
        // Let caller know there is no search result or cookie
        err = ERROR_DS_PROTOCOL_ERROR;
        goto error;
    }

    //
    // Save the returned cookie value
    //

    err = BerDecodeReplicationCookie(
        m_pLdap,
        *ppSearchResult,
        ppCookieNext,
        pdwCookieLenNext,
        pfMoreData
        );
    BAIL_ON_FAILURE( err );

    err = ERROR_SUCCESS;

error:

    // On error, return the same cookie that came in

    // Release results on error
    if ( (err != ERROR_SUCCESS) && (*ppSearchResult) )
    {
        ldap_msgfree(*ppSearchResult);
        *ppSearchResult = NULL;
    }

    if (pBerVal)
        ber_bvfree(pBerVal);

    return err;

} /* DsGetSourceChanges */


DWORD
BerEncodeReplicationControl(
    DWORD dwReplFlags,
    PBYTE pCookie,
    DWORD dwLen,
    PBERVAL *ppBerVal
    )

/*++

Routine Description:

    This encodes the replication cookie into a BERVAL that can be put in
    an LDAP control.

Arguments:

    dwReplFlags - Replication flags
    pCookie - Pointer to replication cookie
    dwLen - Length of cookie
    ppBerVal - Pointer that received the BERVAL structure. Called needs to
               free this using ber_bvfree().

Return Value:

    S_OK on success, error code otherwise

--*/

{
    DWORD err = ERROR_INVALID_PARAMETER;
    BerElement *pBer = NULL;

    pBer = ber_alloc_t(LBER_USE_DER);
    BAIL_ON_NULL(pBer);

    //
    // flag - set to zero, so order of parent & child objects is not important
    //

    if (ber_printf(pBer, "{iio}", dwReplFlags, MAX_ATTIBUTES, pCookie, dwLen) == -1)
    {
        err = ERROR_INTERNAL_ERROR;
        PrintMsg(REPADMIN_REPLCTRL_ERROR_IN_BER_PRINTF);
        BAIL();
    }

    //
    // Pull data from the BerElement into a BERVAL struct.
    // Caller needs to free ppBerVal.
    //

    if (ber_flatten(pBer, ppBerVal) != 0)
    {
        err = ERROR_INTERNAL_ERROR;
        PrintMsg(REPADMIN_REPLCTRL_ERROR_IN_BER_FLATTEN);
        BAIL();
    }

    err = ERROR_SUCCESS;

error:
    if (pBer)
    {
        ber_free(pBer,1);
    }

    return err;

}



DWORD
BerDecodeReplicationCookie(
    LDAP *m_pLdap,
    LDAPMessage *m_pSearchResult,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    BOOL *pfMoreData
    )

/*++

Routine Description:

    This saves the replication cookie that came back from the server so that
    it can be used for the next call

Arguments:

    m_pLdap - 
    m_pSearchResult - 
    ppCookieNext - 
    pdwCookieLenNext - 
    pfMoreData - 

Return Value:

    DWORD - 

--*/

{
    PLDAPControlW *ppServerControl = NULL;
    BERVAL berVal;
    DWORD err = ERROR_INVALID_PARAMETER;
    ULONG lderr;
    BerElement *pBer = NULL;
    PBERVAL pbv = NULL;
    DWORD size;
    DWORD i;

    lderr = ldap_parse_resultW(m_pLdap,
                               m_pSearchResult,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               &ppServerControl,
                               FALSE);
    CHK_LD_STATUS( lderr );

    //
    // Find the replication control
    //

    i = 0;
    while (ppServerControl[i] &&
           wcscmp(ppServerControl[i]->ldctl_oid,LDAP_SERVER_DIRSYNC_OID_W) != 0)
    {
        i++;
    }

    if (!ppServerControl[i])
    {
        err = ERROR_NOT_FOUND;
        PrintMsg(REPADMIN_REPLCTRL_NO_REPL_SERVER_CONTROL_RET);
        BAIL();
    }

    berVal.bv_len = ppServerControl[i]->ldctl_value.bv_len;
    berVal.bv_val = ppServerControl[i]->ldctl_value.bv_val;
    pBer = ber_init(&berVal);

    ber_scanf(pBer, "{iiO}", pfMoreData, &size, &pbv);

    *pdwCookieLenNext = pbv->bv_len;
    *ppCookieNext = (PBYTE)MemAlloc(pbv->bv_len);
    BAIL_ON_NULL(*ppCookieNext);

    memcpy(*ppCookieNext, pbv->bv_val, *pdwCookieLenNext);

    err = ERROR_SUCCESS;

error:
    if (pbv)
        ber_bvfree(pbv);
    if (pBer)
        ber_free(pBer, 1);
    if (ppServerControl)
        ldap_controls_freeW(ppServerControl);

    return err;
} /* BerDecodeReplicationCookie */


#if DBG


void
dumpCookie(
    PBYTE pCookieNext,
    DWORD dwCookieLenNext
    )

/*++

Routine Description:

    //
    // If the cookie is available, this debug code will dump out the cookie
    // value to the debugger
    //

Arguments:

    None

Return Value:

    None

--*/

{
    PUCHAR p;
    DWORD dwVersion, dwSignature;
    DWORD cbVecSize;
    USN_VECTOR usnVec;

    if (!pCookieNext)  {
        PrintMsg(REPADMIN_GETCHANGES_COOKIE_NULL);
    }

    p = pCookieNext;

    //
    // Get the Signature.
    //
    dwSignature = *((PDWORD)p);
    p += sizeof(DWORD);

    //
    // Get the Version.
    //
    dwVersion = *((PDWORD)p);
    p += sizeof(DWORD);

    // Skip filetime
    p += sizeof(FILETIME);

    // Skip reserved
    p += sizeof(LARGE_INTEGER);

    //
    // Get the size of the up to date vector
    //
    cbVecSize = *((PDWORD)p);
    p += sizeof(DWORD);

    // Usnvec
    memcpy(&usnVec,p,sizeof(USN_VECTOR));

    // todo: invocation uuid
    // todo: uptodatevec

    PrintMsg(REPADMIN_GETCHANGES_COOKIE_DATA,
           dwVersion, usnVec.usnHighObjUpdate);
    PrintMsg(REPADMIN_GETCHANGES_COOKIE_DATA_HACK2,
             usnVec.usnHighPropUpdate);
}
#endif


DWORD
packCookie(
    USN_VECTOR *pUsnVec,
    GUID *puuidInvocationId,
    UPTODATE_VECTOR *pUtdvecV1,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    )

/*++

Routine Description:

The following logic is taken from
    dsamain\ldap\ldapconv.cxx:LDAP_PackReplControl

Arguments:

    pUsnVec - 
    puuidInvocationId - 
    pUtdvecV1 - 
    ppCookieNext - 
    pdwCookieLenNext - 

Return Value:

    DWORD - 

--*/

{
    DWORD cbCookie = MIN_REPL_CONTROL_BLOB_LENGTH;
    DWORD cbVecSize = 0;
    PBYTE p, pbCookie = NULL;

    // todo: deal with not having a utd

    Assert( pUtdvecV1 != NULL );
    Assert(IS_VALID_UPTODATE_VECTOR(pUtdvecV1));

    if (pUtdvecV1->V1.cNumCursors > 0) {      
        cbVecSize = UpToDateVecV1Size(pUtdvecV1);
        cbCookie += cbVecSize;
    }

    pbCookie = MemAlloc( cbCookie );
    if (pbCookie == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( pbCookie, cbCookie );

    p = pbCookie;

    //
    // Pack the signature
    //

    *((PDWORD)p) = REPL_SIGNATURE;
    p += sizeof(DWORD);

    //
    // Pack the Version. 
    //

    *((PDWORD)p) = REPL_VERSION;    
    p += sizeof(DWORD);

    //
    // Set the current time
    //

    GetSystemTimeAsFileTime((PFILETIME)p);
    p += sizeof(FILETIME);

    //
    // reserved for now
    //

    p += sizeof(LARGE_INTEGER);

    //
    // Pack the size of the up to date vector
    //

    *((PDWORD)p) = cbVecSize;
    p += sizeof(DWORD);

    //
    // Copy the usnvecTo. 
    //

    CopyMemory( p,pUsnVec, sizeof(USN_VECTOR));
    p += sizeof(USN_VECTOR);

    //
    // Copy the invocation UUID
    //

    CopyMemory( p, puuidInvocationId, sizeof(UUID));

    p += sizeof(UUID);

    //
    // Copy the UPTODATE_VECTOR if it exists
    //

    if( cbVecSize > 0 ) {
        CopyMemory( p,
                    pUtdvecV1, 
                    cbVecSize);
    }

    *pdwCookieLenNext = cbCookie;
    *ppCookieNext = pbCookie;

    return ERROR_SUCCESS;
} /* packCookie */

/* end dirsync.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\reprsa.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   reprsa.c - replica sync all command

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "ReplRpcSpoof.hxx"
#include "repadmin.h"

VOID SyncAllPrintError (
    PDS_REPSYNCALL_ERRINFOW	pErrInfo
    )
{
    switch (pErrInfo->error) {

	case DS_REPSYNCALL_WIN32_ERROR_CONTACTING_SERVER:
            PrintMsg(REPADMIN_SYNCALL_CONTACTING_SERVER_ERR, pErrInfo->pszSvrId);
            PrintErrEnd(pErrInfo->dwWin32Err);
	    break;

	case DS_REPSYNCALL_WIN32_ERROR_REPLICATING:
	    if (pErrInfo->dwWin32Err == ERROR_CANCELLED){
                PrintMsg(REPADMIN_SYNCALL_REPL_SUPPRESSED);
            } else {
                PrintMsg(REPADMIN_SYNCALL_ERR_ISSUING_REPL);
                PrintErrEnd(pErrInfo->dwWin32Err);
            }

            PrintMsg(REPADMIN_SYNCALL_FROM_TO, pErrInfo->pszSrcId, pErrInfo->pszSvrId);

	    break;

	case DS_REPSYNCALL_SERVER_UNREACHABLE:
            PrintMsg(REPADMIN_SYNCALL_SERVER_BAD_TOPO_INCOMPLETE, pErrInfo->pszSvrId);
	    break;

	default:
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_ERROR);
	    break;

    }
}

BOOL __stdcall SyncAllFnCallBack (
    LPVOID			pDummy,
    PDS_REPSYNCALL_UPDATEW	pUpdate
    )
{
    PrintMsg(REPADMIN_SYNCALL_CALLBACK_MESSAGE);

    switch (pUpdate->event) {

	case DS_REPSYNCALL_EVENT_SYNC_STARTED:
            PrintMsg(REPADMIN_SYNCALL_REPL_IN_PROGRESS);
            PrintMsg(REPADMIN_SYNCALL_FROM_TO,
                     pUpdate->pSync->pszSrcId,
                     pUpdate->pSync->pszDstId );
	    break;

	case DS_REPSYNCALL_EVENT_SYNC_COMPLETED:
            PrintMsg(REPADMIN_SYNCALL_REPL_COMPLETED);
            PrintMsg(REPADMIN_SYNCALL_FROM_TO, 
                    pUpdate->pSync->pszSrcId,
                    pUpdate->pSync->pszDstId );
	    break;

	case DS_REPSYNCALL_EVENT_ERROR:
	    SyncAllPrintError (pUpdate->pErrInfo);
	    break;

	case DS_REPSYNCALL_EVENT_FINISHED:
            PrintMsg(REPADMIN_SYNCALL_FINISHED);
	    break;

	default:
            PrintMsg(REPADMIN_SYNCALL_UNKNOWN);
	    break;

    }

    return TRUE;
}

BOOL __stdcall SyncAllFnCallBackInfo (
    LPVOID			pDummy,
    PDS_REPSYNCALL_UPDATEW	pUpdate
    )
{
    LPWSTR pszGuidSrc = NULL, pszGuidDst = NULL;
    DWORD ret;
    LPWSTR argv[10];
    BOOL result;

    if (pUpdate->event != DS_REPSYNCALL_EVENT_SYNC_STARTED) {
        return TRUE;
    }

    ret = UuidToStringW( pUpdate->pSync->pguidSrc, &pszGuidSrc );
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"UuidToString", ret);
        result = FALSE;
        goto cleanup;
    }
    ret = UuidToStringW( pUpdate->pSync->pguidDst, &pszGuidDst );
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"UuidToString", ret);
        result = FALSE;
        goto cleanup;
    }

    PrintMsg(REPADMIN_PRINT_CR);
    PrintMsg(REPADMIN_SYNCALL_SHOWREPS_CMDLINE, 
             pszGuidDst,
             pUpdate->pSync->pszNC,
             pszGuidSrc );
    argv[0] = L"repadmin";
    argv[1] = L"/showreps";
    argv[2] = pszGuidDst;
    argv[3] = pUpdate->pSync->pszNC;
    argv[4] = pszGuidSrc;
    argv[5] = NULL;

    ret = ShowReps( 5, argv );
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"repadmin:ShowReps", ret);
        result = FALSE;
        goto cleanup;
    }

    result = TRUE;

cleanup:

    if (pszGuidSrc) {
        RpcStringFreeW( &pszGuidSrc );
    }
    if (pszGuidDst) {
        RpcStringFreeW( &pszGuidDst );
    }

    return result;
}

BOOL __stdcall SyncAllFnCallBackPause (
    LPVOID			pDummy,
    PDS_REPSYNCALL_UPDATEW	pUpdate
    )
{
    BOOL			bContinue;

    SyncAllFnCallBack (pDummy, pUpdate);
    if (pUpdate->event == DS_REPSYNCALL_EVENT_FINISHED)
	bContinue = TRUE;
    else {
        PrintMsg(REPADMIN_SYNCALL_Q_OR_CONTINUE_PROMPT);
	bContinue = (toupper (_getch ()) != 'Q');
    }
    return bContinue;
}

int SyncAll (int argc, LPWSTR argv[])
{
    ULONG                       ret;
    HANDLE			hDS;
    DWORD			dwWin32Err;
    ULONG			ulFlags;
    LPWSTR                      pszNameContext;
    LPWSTR                      pszServer;
    PDS_REPSYNCALL_ERRINFOW *	apErrInfo;
    BOOL			bPause;
    BOOL			bQuiet;
    BOOL			bVeryQuiet;
    BOOL			bIterate;
    BOOL                        bInfo;
    ULONG			ulIteration;
    ULONG			ul;
    INT				i;
    BOOL (__stdcall *		pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEW);

    ulFlags = 0L;
    pszNameContext = pszServer = NULL;
    bPause = bQuiet = bVeryQuiet = bIterate = bInfo = FALSE;
    pFnCallBack = NULL;

    // Parse commandline.

    for (i = 2; i < argc; i++) {
	if (argv[i][0] == L'/')
	    for (ul = 1; ul < wcslen (argv[i]); ul++)
		switch (argv[i][ul]) {
		    case 'a':
			ulFlags |= DS_REPSYNCALL_ABORT_IF_SERVER_UNAVAILABLE;
			break;
		    case 'd':
			ulFlags |= DS_REPSYNCALL_ID_SERVERS_BY_DN;
			break;
		    case 'e':
			ulFlags |= DS_REPSYNCALL_CROSS_SITE_BOUNDARIES;
			break;
		    case 'h':
                    case '?':
                        PrintMsg(REPADMIN_SYNCALL_HELP);
			return 0;
		    case 'i':
			bIterate = TRUE;
			break;
                    case 'I':
                        bInfo = TRUE;
			ulFlags |= DS_REPSYNCALL_DO_NOT_SYNC |
                            DS_REPSYNCALL_SKIP_INITIAL_CHECK |
                            DS_REPSYNCALL_ID_SERVERS_BY_DN;
                        break;
		    case 'j':
			ulFlags |= DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY;
			break;
		    case 'p':
			bPause = TRUE;
			break;
		    case 'P':
			ulFlags |= DS_REPSYNCALL_PUSH_CHANGES_OUTWARD;
			break;
		    case 'q':
			bQuiet = TRUE;
			break;
		    case 'Q':
			bVeryQuiet = TRUE;
			break;
		    case 's':
			ulFlags |= DS_REPSYNCALL_DO_NOT_SYNC;
			break;
		    case 'S':
			ulFlags |= DS_REPSYNCALL_SKIP_INITIAL_CHECK;
			break;
		    default:
			break;
		}
	else if (pszServer == NULL) pszServer = argv[i];
	else if (pszNameContext == NULL) pszNameContext = argv[i];
    }

    if (bQuiet || bVeryQuiet) {
        pFnCallBack = NULL;
    } else if (bPause) {
        pFnCallBack = SyncAllFnCallBackPause;
    } else if (bInfo) {
        pFnCallBack = SyncAllFnCallBackInfo;
    } else {
        pFnCallBack = SyncAllFnCallBack;
    }

    if (pszServer == NULL)
        PrintMsg(REPADMIN_SYNCALL_INVALID_CMDLINE);

    else {

        ret = DsBindWithCredW(pszServer,
                              NULL,
                              (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                              &hDS);
        if (ERROR_SUCCESS != ret) {
            PrintBindFailed(pszServer, ret);
            return ret;
        }

	ulIteration = 0;
	do {

	    if (ulIteration % 100L == 1L) {
                PrintMsg(REPADMIN_SYNCALL_ANY_KEY_PROMPT);
		_getch ();
	    }
	    if (dwWin32Err = DsReplicaSyncAllW(
		    hDS,
		    pszNameContext,
		    ulFlags,
                    pFnCallBack,
		    NULL,
		    &apErrInfo)) {

                PrintMsg(REPADMIN_PRINT_CR);
		if (dwWin32Err == ERROR_CANCELLED){
                    PrintMsg(REPADMIN_SYNCALL_USER_CANCELED);
		} else {
                    PrintMsg(REPADMIN_SYNCALL_EXITED_FATALLY_ERR);
                    PrintErrEnd(dwWin32Err);
                }
		return -1;
	    }

	    if (!bVeryQuiet) {
		if (apErrInfo) {
                   PrintMsg(REPADMIN_PRINT_CR);
                   PrintMsg(REPADMIN_SYNCALL_ERRORS_HDR);
                   for (i = 0; apErrInfo[i] != NULL; i++)
                       SyncAllPrintError (apErrInfo[i]);
		} else {
                    PrintMsg(REPADMIN_SYNCALL_TERMINATED_WITH_NO_ERRORS);
                }
	    }
	    if (apErrInfo){
                LocalFree (apErrInfo);
            }
	    if (bIterate) {
                PrintMsg(REPADMIN_SYNCALL_PRINT_ITER, ++ulIteration);
            } else {
                PrintMsg(REPADMIN_PRINT_CR);
            }

	} while (bIterate);

	DsUnBind (&hDS);

    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\resource.h ===
#define IDS_CMD_ADD                          (1000)
#define IDS_CMD_DEL                          (1001)
#define IDS_CMD_SYNC                         (1002)
#define IDS_CMD_SYNC_ALL                     (1003)
#define IDS_CMD_SHOW_REPS                    (1004)
#define IDS_CMD_SHOW_VECTOR                  (1005)
#define IDS_CMD_SHOW_META                    (1006)
#define IDS_CMD_ADD_REPS_TO                  (1007)
#define IDS_CMD_UPD_REPS_TO                  (1008)
#define IDS_CMD_DEL_REPS_TO                  (1009)
#define IDS_CMD_SHOW_TIME                    (1010)
#define IDS_CMD_SHOW_MSG                     (1011)
#define IDS_CMD_OPTIONS                      (1012)
#define IDS_CMD_FULL_SYNC_ALL                (1013)
#define IDS_CMD_RUN_KCC                      (1014)
#define IDS_CMD_BIND                         (1015)
#define IDS_CMD_SHOW_VALUE                   (1016)
#define IDS_CMD_QUEUE                        (1017)
#define IDS_CMD_PROPCHECK                    (1018)
#define IDS_CMD_FAILCACHE                    (1019)
#define IDS_CMD_SHOW_ISM                     (1020)
#define IDS_CMD_GETCHANGES                   (1021)
#define IDS_CMD_SHOWSIG                      (1022)
#define IDS_CMD_SHOWCTX                      (1023)
#define IDS_CMD_SHOW_CONN                    (1024)
#define IDS_CMD_EXPERT_HELP                  (1025)
#define IDS_CMD_SHOW_CERT                    (1026)
#define IDS_CMD_MOD                          (1027)
#define IDS_CMD_LATENCY                      (1028)
#define IDS_CMD_ISTG                         (1029)
#define IDS_CMD_BRIDGEHEADS                  (1030)
#define IDS_CMD_TESTHOOK                     (1031)
#define IDS_CMD_DSAGUID                      (1032)
#define IDS_CMD_SITEOPTIONS                  (1033)
#define IDS_CMD_SHOWPROXY                    (1034)
#define IDS_CMD_REMOVELINGERINGOBJECTS       (1035)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\repmisc.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repmisc.c - misc command functions

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "repadmin.h"

int
ShowMsg(
    int     argc,
    LPWSTR  argv[]
    )
{
    DWORD dwMsgID = 0;
    BOOL fWin32Msg = TRUE;
    int iArg;

    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/ntdsmsg")) {
            fWin32Msg = FALSE;
        } else if (0 == dwMsgID) {
            if ((argv[iArg][0] == L'0') && (tolower(argv[iArg][1]) == L'x')) {
                dwMsgID = wcstoul(&argv[iArg][2], NULL, 16);
            }
            else {
                dwMsgID = wcstoul(&argv[iArg][0], NULL, 10);
            }

            if (0 == dwMsgID) {
                PrintMsg(REPADMIN_SHOWMSG_INVALID_MSG_ID, argv[iArg]);
                return ERROR_INVALID_PARAMETER;
            }
        } else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_PARAMETER;
        }
    }

    PrintMsg(REPADMIN_SHOWMSG_DATA, 
             dwMsgID,
             dwMsgID,
             fWin32Msg ? Win32ErrToString(dwMsgID) : NtdsmsgToString(dwMsgID));
    
    return 0;
}



int
ShowTime(
    int     argc,
    LPWSTR  argv[]
    )
{
    int         ret = 0;
    DSTIME      time = 0;
    SYSTEMTIME  systime;
    CHAR        szLocalTime[ SZDSTIME_LEN ];
    CHAR        szUtcTime[ SZDSTIME_LEN ];

    if (argc < 3) {
        time = GetSecondsSince1601();
    }
    else if ((argv[2][0] == L'0') && (towlower(argv[2][1]) == L'x')) {
        swscanf(&argv[2][2], L"%I64x", &time);
    }
    else {
        swscanf(&argv[2][0], L"%I64d", &time);
    }

    DSTimeToDisplayString(time, szLocalTime);

    if (0 == time) {
        strcpy(szUtcTime, "(never)");
    }
    else {
        DSTimeToUtcSystemTime(time, &systime);

        sprintf(szUtcTime,
                "%02d-%02d-%02d %02d:%02d.%02d",
                systime.wYear % 100,
                systime.wMonth,
                systime.wDay,
                systime.wHour,
                systime.wMinute,
                systime.wSecond);
    }
    PrintMsg(REPADMIN_SHOWTIME_TIME_DATA, 
             time);
    PrintMsg(REPADMIN_SHOWTIME_TIME_DATA_HACK2, 
             time);
    PrintMsg(REPADMIN_SHOWTIME_TIME_DATA_HACK3, 
             szUtcTime, szLocalTime);

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\repldap.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repldap.c - ldap based utility functions

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

    09 14 1999 - BrettSh added paged

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>   // byte order funtions
#include <ntldap.h>     // SHOW_DELETED_OID

#include "repadmin.h"

// Use this macro when the results may be null and you want a result
// consistent with the result being present but empty
#define SAFE_LDAP_FIRST_ENTRY(h, r) (r ? ldap_first_entry( h, r ) : NULL)

// Connection Option Names
// Keep these in sync with ntdsa.h
static WCHAR * ppszNtdsConnOptionNames[] = {
    L"isGenerated",
    L"twowaySync",
    L"overrideNotifyDefault",
    L"useNotify",
    NULL
};

// Kcc Reason Names
// Keep these in sync with kccconn.hxx
static WCHAR * ppszKccReasonNames[] = {
    L"GCtopology",
    L"RingTopology",
    L"MinimizeHopsTopology",
    L"StaleServersTopology",
    NULL
};

// Guid cache
static GUID_CACHE_ENTRY grgCachedGuids[1000];
static DWORD gcCachedGuids = 0;

// ShowIstg function types
typedef enum _SHOW_ISTG_FUNCTION_TYPE {
    SHOW_ISTG_PRINT,
    SHOW_ISTG_LATENCY,
    SHOW_ISTG_BRIDGEHEADS
} SHOW_ISTG_FUNCTION_TYPE;

void
CacheDsaGuid(
    IN  GUID *  pGuid,
    IN  LPWSTR  pszSite,
    IN  LPWSTR  pszServer
    )
{
    if (gcCachedGuids < ARRAY_SIZE(grgCachedGuids)) {
        grgCachedGuids[gcCachedGuids].Guid = *pGuid;
        _snwprintf(grgCachedGuids[gcCachedGuids].szDisplayName,
                   ARRAY_SIZE(grgCachedGuids[gcCachedGuids].szDisplayName),
                   L"%ls\\%ls",
                   pszSite,
                   pszServer);
        grgCachedGuids[gcCachedGuids].szDisplayName[
            ARRAY_SIZE(grgCachedGuids[gcCachedGuids].szDisplayName) - 1] = '\0';

        gcCachedGuids++;
    }
}


void
CacheTransportGuid(
    IN  GUID *  pGuid,
    IN  LPWSTR  pszTransport
    )
{
    if (gcCachedGuids < ARRAY_SIZE(grgCachedGuids)) {
        grgCachedGuids[gcCachedGuids].Guid = *pGuid;
        _snwprintf(grgCachedGuids[gcCachedGuids].szDisplayName,
                   ARRAY_SIZE(grgCachedGuids[gcCachedGuids].szDisplayName),
                   L"%ls",
                   pszTransport);
        gcCachedGuids++;
    }
}


LPWSTR
GetStringizedGuid(
    IN  GUID *  pGuid
    )
{
    LPWSTR        pszDisplayName = NULL;
    static WCHAR  szDisplayName[40];
    RPC_STATUS    rpcStatus;

    rpcStatus = UuidToStringW(pGuid, &pszDisplayName);
    Assert(0 == rpcStatus);

    if (pszDisplayName) {
        wcscpy(szDisplayName, pszDisplayName);
        RpcStringFreeW(&pszDisplayName);
    } else {
        swprintf(szDisplayName, L"Err%d", rpcStatus);
    }

    return szDisplayName;
}

LPWSTR
GetGuidDisplayName(
    IN  GUID *  pGuid
    )
{
    LPWSTR  pszDisplayName = NULL;
    DWORD   i;

    for (i = 0; (NULL == pszDisplayName) && (i < gcCachedGuids); i++) {
        if (!memcmp(&grgCachedGuids[i].Guid, pGuid, sizeof(GUID))) {
            pszDisplayName = grgCachedGuids[i].szDisplayName;
            break;
        }
    }

    if (NULL == pszDisplayName) {
        pszDisplayName = GetStringizedGuid(pGuid);
    }

    return pszDisplayName;
}


int
BuildGuidCache(
    IN  LDAP *  hld
    )
{
    static LPWSTR rgpszDsaAttrs[] = {L"objectGuid", L"invocationId", NULL};
    static LPWSTR rgpszTransportAttrs[] = {L"objectGuid", NULL};

    int                 lderr;
    LDAPSearch *        pSearch;
    LDAPMessage *       pRootResults = NULL;
    LDAPMessage *       pResults = NULL;
    LDAPMessage *       pEntry;
    LPWSTR *            ppszConfigNC = NULL;
    LPWSTR              pszDN;
    LPWSTR *            ppszRDNs;
    LPWSTR              pszSite;
    LPWSTR              pszServer;
    LPWSTR              pszTransport;
    struct berval **    ppbvGuid;
    GUID *              pGuid;
    ULONG               ulTotalEstimate;

    PrintMsg(REPADMIN_GUIDCACHE_CACHING);

    lderr = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)", NULL,
                          0, &pRootResults);
    CHK_LD_STATUS(lderr);
    if (NULL == pRootResults) {
        lderr = LDAP_NO_RESULTS_RETURNED;
        REPORT_LD_STATUS(lderr);
        goto cleanup;
    }

    ppszConfigNC = ldap_get_valuesW(hld, pRootResults,
                                    L"configurationNamingContext");
    if (ppszConfigNC == NULL) {
        lderr = LDAP_NO_RESULTS_RETURNED;
        REPORT_LD_STATUS(lderr);
        goto cleanup;
    }

    // Cache ntdsDsa guids.
    pSearch = ldap_search_init_pageW(hld,
				     *ppszConfigNC,
				     LDAP_SCOPE_SUBTREE,
				     L"(objectCategory=ntdsDsa)",
				     rgpszDsaAttrs,
				     FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
        REPORT_LD_STATUS(LdapGetLastError());
        goto cleanup;
    }

    lderr = ldap_get_next_page_s(hld,
				 pSearch,
				 0,
				 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
				 &ulTotalEstimate,
				 &pResults);

    while(lderr == LDAP_SUCCESS){
        PrintMsg(REPADMIN_PRINT_DOT_NO_CR);

        for (pEntry = SAFE_LDAP_FIRST_ENTRY(hld, pResults);
	     NULL != pEntry;
	     pEntry = ldap_next_entry(hld, pEntry)) {

	    // Get site & server names.
	    pszDN = ldap_get_dnW(hld, pEntry);
            if (pszDN == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }

	    ppszRDNs = ldap_explode_dnW(pszDN, 1);
            if (ppszRDNs == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                ldap_memfreeW(pszDN);
                continue;
            }
	    Assert(4 < ldap_count_valuesW(ppszRDNs));

	    pszSite = ppszRDNs[3];
	    pszServer = ppszRDNs[1];

	    // Associate objectGuid with this DSA.
	    ppbvGuid = ldap_get_values_len(hld, pEntry, "objectGuid");
            if (ppbvGuid != NULL) {
                Assert(1 == ldap_count_values_len(ppbvGuid));
                pGuid = (GUID *) ppbvGuid[0]->bv_val;
                CacheDsaGuid(pGuid, pszSite, pszServer);
                ldap_value_free_len(ppbvGuid);
            } else {
                Assert( !"objectGuid should be present" );
            }
            // Associate invocationId with this DSA.
            ppbvGuid = ldap_get_values_len(hld, pEntry, "invocationId");
            if (ppbvGuid != NULL) {
                Assert(1 == ldap_count_values_len(ppbvGuid));
                pGuid = (GUID *) ppbvGuid[0]->bv_val;
                CacheDsaGuid(pGuid, pszSite, pszServer);
                ldap_value_free_len(ppbvGuid);
            } else {
                Assert( !"invocationId should be present" );
            }
	    ldap_value_freeW(ppszRDNs);
	    ldap_memfreeW(pszDN);
	}

	ldap_msgfree(pResults);
	pResults = NULL;

	lderr = ldap_get_next_page_s(hld,
                                     pSearch,
                                     0,
                                     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                     &ulTotalEstimate,
                                     &pResults);
    } // end while more pages to search.
    if(lderr != LDAP_NO_RESULTS_RETURNED){
        REPORT_LD_STATUS(lderr);
        goto cleanup;
    }

    lderr = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(lderr);

    PrintMsg(REPADMIN_PRINT_DOT_NO_CR);
    
    // Cache interSiteTransport guids.
    lderr = ldap_search_sW(hld, *ppszConfigNC, LDAP_SCOPE_SUBTREE,
                           L"(objectCategory=interSiteTransport)",
                           rgpszTransportAttrs, 0,
                           &pResults);
    CHK_LD_STATUS(lderr);
    if (NULL == pResults) {
        lderr = LDAP_NO_RESULTS_RETURNED;
	REPORT_LD_STATUS(lderr);	
        goto cleanup;
    }

    for (pEntry = ldap_first_entry(hld, pResults);
         NULL != pEntry;
         pEntry = ldap_next_entry(hld, pEntry)) {
        // Get transport name.
        pszDN = ldap_get_dnW(hld, pEntry);
        if (pszDN == NULL) {
            REPORT_LD_STATUS(LdapGetLastError());	
            continue;
        }

        ppszRDNs = ldap_explode_dnW(pszDN, 1);
        if (ppszRDNs == NULL) {
            REPORT_LD_STATUS(LdapGetLastError());	
            ldap_memfreeW(pszDN);
            continue;
        }
        pszTransport = ppszRDNs[0];

        // Associate objectGuid with this transport.
        ppbvGuid = ldap_get_values_len(hld, pEntry, "objectGuid");
        if (NULL != ppbvGuid) {
            Assert(1 == ldap_count_values_len(ppbvGuid));
            pGuid = (GUID *) ppbvGuid[0]->bv_val;
            CacheTransportGuid(pGuid, pszTransport);
            ldap_value_free_len(ppbvGuid);
        } else {
            Assert( !"objectGuid should have been present" );
        }

        ldap_value_freeW(ppszRDNs);
        ldap_memfreeW(pszDN);
    }

cleanup:

    if (ppszConfigNC) {
        ldap_value_freeW(ppszConfigNC);
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    
    PrintMsg(REPADMIN_PRINT_CR);

    return lderr;
}

int PropCheck(int argc, LPWSTR argv[])
{
    int             iArg;
    LPWSTR          pszNC = NULL;
    LPWSTR          pszInvocID = NULL;
    LPWSTR          pszOrigUSN = NULL;
    LPWSTR          pszTargetDSA = NULL;
    UUID            uuidInvocID;
    USN             usnOrig;
    LDAP *          hld;
    LDAPMessage *   pRootResults = NULL;
    LDAPSearch *    pSearch = NULL;
    LDAPMessage *   pResults;
    LDAPMessage *   pDsaEntry;
    int             ldStatus;
    DWORD           ret;
    LPWSTR          pszRootDomainDNSName;
    LPWSTR          rgpszRootAttrsToRead[] = {L"configurationNamingContext", NULL};
    LPWSTR          rgpszDsaAttrs[] = {L"objectGuid", NULL};
    LPWSTR *        ppszConfigNC = NULL;
    LPWSTR          pszFilter;
    LPWSTR          pszGuidBasedDNSName;
    DWORD           cNumDsas;
    ULONG           ulTotalEstimate;
    ULONG           ulOptions;

    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszNC) {
            pszNC = argv[iArg];
        }
        else if (NULL == pszInvocID) {
            pszInvocID = argv[iArg];
        }
        else if (NULL == pszOrigUSN) {
            pszOrigUSN = argv[iArg];
        }
        else if (NULL == pszTargetDSA) {
            pszTargetDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if ((NULL == pszNC)
        || (NULL == pszInvocID)
        || (NULL == pszOrigUSN)
        || UuidFromStringW(pszInvocID, &uuidInvocID)
        || (1 != swscanf(pszOrigUSN, L"%I64d", &usnOrig))) {
        PrintMsg(REPADMIN_GENERAL_INVALID_ARGS);
        return ERROR_INVALID_FUNCTION;
    }

    if (NULL == pszTargetDSA) {
        pszTargetDSA = L"localhost";
    }


    // Connect & bind to target DSA.
    hld = ldap_initW(pszTargetDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszTargetDSA);
        return ERROR_DS_UNAVAILABLE;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);


    // What's the DNS name of the enterprise root domain?
    ret = GetRootDomainDNSName(pszTargetDSA, &pszRootDomainDNSName);
    if (ret) {
        PrintFuncFailed(L"GetRootDomainDNSName", ret);
        return ret;
    }

    // What's the DN of the config NC?
    ldStatus = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)",
                              rgpszRootAttrsToRead, 0, &pRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    ppszConfigNC = ldap_get_valuesW(hld, pRootResults,
                                    L"configurationNamingContext");
    if (NULL == ppszConfigNC) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }

    // Find all DCs that hold a read-only or writeable copy of the target NC.
    pszFilter = malloc(sizeof(WCHAR) * (100 + 2*wcslen(pszNC)));
    if (NULL == pszFilter) {
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    swprintf(pszFilter, L"(& (objectCategory=ntdsDsa) (|(hasMasterNCs=%ls) (hasPartialReplicaNCs=%ls)))",
             pszNC, pszNC);

    CHK_LD_STATUS(ldStatus);
    pSearch = ldap_search_init_pageW(hld,
				    *ppszConfigNC,
				    LDAP_SCOPE_SUBTREE,
				    pszFilter,
				    rgpszDsaAttrs,
				    FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
	REPORT_LD_STATUS(LdapGetLastError());
        goto cleanup;
    }
		
    pszGuidBasedDNSName = malloc(sizeof(WCHAR) * (100 + wcslen(pszRootDomainDNSName)));
    if (NULL == pszGuidBasedDNSName) {
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ldStatus = ldap_get_next_page_s(hld,
				     pSearch,
				     0,
				     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
				     &ulTotalEstimate,
				     &pResults);
    if(ldStatus == LDAP_NO_RESULTS_RETURNED){
        PrintMsg(REPADMIN_SYNCALL_NO_INSTANCES_OF_NC);
        return ERROR_NOT_FOUND;
    }

    while(ldStatus == LDAP_SUCCESS){

	for (pDsaEntry = SAFE_LDAP_FIRST_ENTRY(hld, pResults);
	     NULL != pDsaEntry;
	     pDsaEntry = ldap_next_entry(hld, pDsaEntry)) {
	    struct berval **  ppbvGuid;
	    LPWSTR            pszGuid;
	    LPWSTR            pszDsaDN;
	    HANDLE            hDS;
	    DS_REPL_CURSORS * pCursors;
	    DWORD             iCursor;
	
	    // Display DSA name (e.g., "Site\Server").
	    pszDsaDN = ldap_get_dnW(hld, pDsaEntry);
            if (pszDsaDN) {
                PrintMsg(REPADMIN_PROPCHECK_DSA_COLON_NO_CR,
                         GetNtdsDsaDisplayName(pszDsaDN));
                ldap_memfreeW(pszDsaDN);
            }

	    // Derive DSA's GUID-based DNS name.
	    ppbvGuid = ldap_get_values_len(hld, pDsaEntry, "objectGuid");
	    if (NULL != ppbvGuid) {
                Assert(1 == ldap_count_values_len(ppbvGuid));

                UuidToStringW((GUID *) (*ppbvGuid)->bv_val,
                              &pszGuid);
                swprintf(pszGuidBasedDNSName, L"%ls._msdcs.%ls",
                         pszGuid, pszRootDomainDNSName);

                RpcStringFreeW(&pszGuid);
                ldap_value_free_len(ppbvGuid);
            } else {
                Assert( !"objectGuid should have been present" );
            }

	    // DsBind() to DSA.
	    ret = DsBindWithCredW(pszGuidBasedDNSName, NULL,
				  (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
				  &hDS);
	    if (ret) {
                PrintBindFailed(pszGuidBasedDNSName, ret);
		continue;
	    }

	    // Retrieve up-to-dateness vector.
	    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_CURSORS_FOR_NC, pszNC, NULL,
				    &pCursors);
	    if (ERROR_SUCCESS != ret) {
                PrintFuncFailed(L"DsReplicaGetInfo", ret);
		DsUnBind(&hDS);
		continue;
	    }

	    // Check cursor for propagation.
	    for (iCursor = 0; iCursor < pCursors->cNumCursors; iCursor++) {
            if (0 == memcmp(&pCursors->rgCursor[iCursor].uuidSourceDsaInvocationID,
				&uuidInvocID,
				sizeof(UUID))) {
                    if(pCursors->rgCursor[iCursor].usnAttributeFilter >= usnOrig){
                        PrintMsg(REPADMIN_PRINT_YES);
                    } else {
                        PrintMsg(REPADMIN_PRINT_NO_NO);
                    }
                    PrintMsg(REPADMIN_PROPCHECK_USN, 
                             pCursors->rgCursor[iCursor].usnAttributeFilter);
                    break;
            }
        }

	    if (iCursor == pCursors->cNumCursors) {
                PrintMsg(REPADMIN_PRINT_NO_NO);
                PrintMsg(REPADMIN_PRINT_SPACE);
                PrintMsg(REPADMIN_PROPCHECK_NO_CURSORS_FOUND);
	    }

	    DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors);
	    DsUnBind(&hDS);
	} // end for each entry in a single results page.

	ldap_msgfree(pResults);
	pResults = NULL;
	
	ldStatus = ldap_get_next_page_s(hld,
					 pSearch,
					 0,
					 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					 &ulTotalEstimate,
					 &pResults);
    }
    if(ldStatus != LDAP_NO_RESULTS_RETURNED){
	REPORT_LD_STATUS(ldStatus);
        goto cleanup;
    }

    ldStatus = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(ldStatus);

cleanup:

    if (ppszConfigNC) {
        ldap_value_freeW(ppszConfigNC);
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    ldap_unbind(hld);

    return 0;
}

int
GetDsaOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszDsaDN,
    OUT int *   pnOptions
    )
{
    int             ldStatus;
    LDAPMessage *   pldmServerResults;
    LDAPMessage *   pldmServerEntry;
    LPWSTR          rgpszServerAttrsToRead[] = {L"options", NULL};
    LPSTR *         ppszOptions;
    int             nOptions;

    ldStatus = ldap_search_sW(hld,
                              pszDsaDN,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgpszServerAttrsToRead,
                              0,
                              &pldmServerResults);
    if (ldStatus) {
        REPORT_LD_STATUS(LdapGetLastError());	
        return ldStatus;
    }
    if (NULL == pldmServerResults) {
        REPORT_LD_STATUS(LDAP_NO_RESULTS_RETURNED);	
        return LDAP_NO_RESULTS_RETURNED;
    }

    pldmServerEntry = ldap_first_entry(hld, pldmServerResults);
    Assert(NULL != pldmServerEntry);

    // Parse current options.
    ppszOptions = ldap_get_values(hld, pldmServerEntry, "options");
    if (NULL == ppszOptions) {
        *pnOptions = 0;
    }
    else {
        *pnOptions = atoi(ppszOptions[0]);
        ldap_value_free(ppszOptions);
    }

    ldap_msgfree(pldmServerResults);

    return 0;
}

int
SetDsaOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszDsaDN,
    IN  int     nOptions
    )
{
    int         ldStatus;
    WCHAR       szOptionsValue[20];
    LPWSTR      rgpszOptionsValues[] = {szOptionsValue, NULL};
    LDAPModW    ModOpt = {LDAP_MOD_REPLACE, L"options", rgpszOptionsValues};
    LDAPModW *  rgpMods[] = {&ModOpt, NULL};

    swprintf(szOptionsValue, L"%d", nOptions);

    ldStatus = ldap_modify_sW(hld, pszDsaDN, rgpMods);

    return ldStatus;
}

int
Options(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    LPWSTR          pszDSA = NULL;
    LDAP *          hld;
    int             iArg;
    int             ldStatus;
    LDAPMessage *   pldmRootResults = NULL;
    LDAPMessage *   pldmRootEntry;
    LPSTR           rgpszRootAttrsToRead[] = {"dsServiceName", NULL};
    LPWSTR *        ppszServerNames;
    int             nOptions;
    int             nAddOptions = 0;
    int             nRemoveOptions = 0;
    int             nBit;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if ((argv[iArg][0] == '+') || (argv[iArg][0] == '-')) {
            // Options to change.
            if (!_wcsicmp(&argv[iArg][1], L"IS_GC")) {
                nBit = NTDSDSA_OPT_IS_GC;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"DISABLE_INBOUND_REPL")) {
                nBit = NTDSDSA_OPT_DISABLE_INBOUND_REPL;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"DISABLE_OUTBOUND_REPL")) {
                nBit = NTDSDSA_OPT_DISABLE_OUTBOUND_REPL;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"DISABLE_NTDSCONN_XLATE")) {
                nBit = NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE;
            }
            else {
                PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
                return ERROR_INVALID_FUNCTION;
            }

            if (argv[iArg][0] == '+') {
                nAddOptions |= nBit;
            }
            else {
                nRemoveOptions |= nBit;
            }
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (0 != (nAddOptions & nRemoveOptions)) {
        PrintMsg(REPADMIN_OPTIONS_CANT_ADD_REMOVE_SAME_OPTION);
        return ERROR_INVALID_FUNCTION;
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Retrieve dsServiceName DN.
    ldStatus = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
                             rgpszRootAttrsToRead, 0, &pldmRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pldmRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    pldmRootEntry = ldap_first_entry(hld, pldmRootResults);
    if (NULL != pldmRootEntry) {
        ppszServerNames = ldap_get_valuesW(hld, pldmRootEntry, L"dsServiceName");

        if (NULL != ppszServerNames) {
            Assert(1 == ldap_count_valuesW(ppszServerNames));

            // Read options attribute from ntdsDsa object.
	    ldStatus = GetDsaOptions(hld, ppszServerNames[0], &nOptions);
            CHK_LD_STATUS(ldStatus);

            // Display current options.
            PrintMsg(REPADMIN_PRINT_CURRENT_NO_CR);
            PrintMsg(REPADMIN_SHOWREPS_DSA_OPTIONS, GetDsaOptionsString(nOptions));

            if (nAddOptions || nRemoveOptions) {
                nOptions |= nAddOptions;
                nOptions &= ~nRemoveOptions;
                PrintMsg(REPADMIN_PRINT_NEW_NO_CR);
                PrintMsg(REPADMIN_SHOWREPS_DSA_OPTIONS, GetDsaOptionsString(nOptions));

                ldStatus = SetDsaOptions(hld, ppszServerNames[0], nOptions);
                CHK_LD_STATUS(ldStatus);
            }
            ldap_value_freeW(ppszServerNames);
        } else {
            Assert( !"Service name should have been present" );
        }
    }

cleanup:

    if (pldmRootResults) {
        ldap_msgfree(pldmRootResults);
    }

    ldap_unbind(hld);

    return ret;
}

int
GetSiteOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszSiteDN,
    OUT int *   pnOptions
    )
{
    int             ldStatus;
    LDAPMessage *   pldmSiteResults;
    LDAPMessage *   pldmSiteEntry;
    LPWSTR          rgpszSiteAttrsToRead[] = {L"options", L"whenChanged", NULL};
    LPSTR *         ppszOptions;
    int             nOptions;

    ldStatus = ldap_search_sW(hld,
                              pszSiteDN,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgpszSiteAttrsToRead,
                              0,
                              &pldmSiteResults);
    if (ldStatus) {
        REPORT_LD_STATUS(LdapGetLastError());	
        return ldStatus;
    }
    if (NULL == pldmSiteResults) {
        REPORT_LD_STATUS(LDAP_NO_RESULTS_RETURNED);	
        return LDAP_NO_RESULTS_RETURNED;
    }

    pldmSiteEntry = ldap_first_entry(hld, pldmSiteResults);
    Assert(NULL != pldmSiteEntry);

    // Parse current options.
    ppszOptions = ldap_get_values(hld, pldmSiteEntry, "options");
    if (NULL == ppszOptions) {
        *pnOptions = 0;
    }
    else {
        *pnOptions = atoi(ppszOptions[0]);
        ldap_value_free(ppszOptions);
    }

    ldap_msgfree(pldmSiteResults);

    return 0;
}

int
SetSiteOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszSiteDN,
    IN  int     nOptions
    )
{
    int         ldStatus;
    WCHAR       szOptionsValue[20];
    LPWSTR      rgpszOptionsValues[] = {szOptionsValue, NULL};
    LDAPModW    ModOpt = {LDAP_MOD_REPLACE, L"options", rgpszOptionsValues};
    LDAPModW *  rgpMods[] = {&ModOpt, NULL};

    swprintf(szOptionsValue, L"%d", nOptions);

    ldStatus = ldap_modify_sW(hld, pszSiteDN, rgpMods);

    return ldStatus;
}

int
SiteOptions(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    LPWSTR          pszDSA = NULL;
    LPWSTR          pszSite = NULL;
    LPWSTR          pszSiteDN = NULL;
    LPWSTR          pszSiteSpecDN = NULL;
    LDAP *          hld;
    int             iArg;
    int             ldStatus;
    LDAPMessage *   pldmRootResults = NULL;
    LDAPMessage *   pldmRootEntry;
    LDAPMessage *   pldmCheckSiteResults = NULL;
    LPWSTR          rgpszRootAttrsToRead[] = {L"dsServiceName", L"configurationNamingContext", NULL};
    static WCHAR    wszSitesRdn[] = L",CN=Sites,";
    static WCHAR    wszSiteSettingsRdn[] = L"CN=NTDS Site Settings,";
    static WCHAR    wszCNEquals[] = L"CN=";
    LPWSTR *        ppszServiceName = NULL;
    LPWSTR *        ppszConfigNC = NULL;
    LPWSTR          pszSiteName = NULL;
    int             nOptions;
    int             nAddOptions = 0;
    int             nRemoveOptions = 0;
    int             nBit;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if ((argv[iArg][0] == '+') || (argv[iArg][0] == '-')) {
            // Options to change.
            if (!_wcsicmp(&argv[iArg][1], L"IS_AUTO_TOPOLOGY_DISABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"IS_TOPL_CLEANUP_DISABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"IS_TOPL_MIN_HOPS_DISABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED;
            }
	    else if (!_wcsicmp(&argv[iArg][1], L"IS_TOPL_DETECT_STALE_DISABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED;
            }
	    else if (!_wcsicmp(&argv[iArg][1], L"IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED;
            }
	    else if (!_wcsicmp(&argv[iArg][1], L"IS_GROUP_CACHING_ENABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"FORCE_KCC_WHISTLER_BEHAVIOR")) {
                nBit = NTDSSETTINGS_OPT_FORCE_KCC_WHISTLER_BEHAVIOR;
            }
            else {
                PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
                return ERROR_INVALID_FUNCTION;
            }

            if (argv[iArg][0] == '+') {
                nAddOptions |= nBit;
            }
            else {
                nRemoveOptions |= nBit;
            }
        }  
	else if (!_wcsnicmp(argv[ iArg ], L"/site:", 6)) {
            pszSite = argv[ iArg ] + 6;
        } 
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (0 != (nAddOptions & nRemoveOptions)) {
        PrintMsg(REPADMIN_OPTIONS_CANT_ADD_REMOVE_SAME_OPTION);
        return ERROR_INVALID_FUNCTION;
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Retrieve dsServiceName DN and the configuration NC DN
    ldStatus = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)",
			     rgpszRootAttrsToRead, 0, &pldmRootResults);

    CHK_LD_STATUS(ldStatus);
    if (NULL == pldmRootResults) {
	ret = ERROR_DS_OBJ_NOT_FOUND;
	Assert( !ret );
	goto cleanup;
    }

    pldmRootEntry = ldap_first_entry(hld, pldmRootResults);
    if (NULL != pldmRootEntry) { 
	
	ppszConfigNC = ldap_get_valuesW(hld, pldmRootEntry, L"configurationNamingContext");
	ppszServiceName = ldap_get_valuesW(hld, pldmRootEntry, L"dsServiceName");
	Assert(ppszConfigNC);
	Assert(ppszServiceName);

       	//if user inputed a site name on the command line, use it.
	if (pszSite) { 
	    pszSiteDN = malloc((wcslen(pszSite) 
					+ wcslen(*ppszConfigNC) + 1) * sizeof(WCHAR) + sizeof(wszCNEquals) + sizeof(wszSitesRdn) + sizeof(wszSiteSettingsRdn));
	    wcscpy(pszSiteDN,wszSiteSettingsRdn);
	    wcscat(pszSiteDN,wszCNEquals);
	    wcscat(pszSiteDN,pszSite);
	    wcscat(pszSiteDN,wszSitesRdn);
	    wcscat(pszSiteDN,*ppszConfigNC);

	    //verify that this is a real site name.
	    ldStatus = ldap_search_sW(hld,
                              pszSiteDN,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              NULL,
                              0,
                              &pldmCheckSiteResults);
	    if (ldStatus==LDAP_NO_SUCH_OBJECT) {
            PrintMsg(REPADMIN_GENERAL_SITE_NOT_FOUND, pszSite);
            ret = LdapMapErrorToWin32(ldStatus);
            goto cleanup;  
	    } 
	}
	else { 
	    //default to local site name
	    if (ppszServiceName) {

		//get the site name of this server from the server DN, should be 3rd in order  
		ret = WrappedTrimDSNameBy(*ppszServiceName,3,&pszSiteSpecDN);
		if (ret) {  
		    Assert(!ret);
		    goto cleanup;
		}
		pszSiteDN = malloc((wcslen(pszSiteSpecDN) + 1)*sizeof(WCHAR) + sizeof(wszSiteSettingsRdn));
		wcscpy(pszSiteDN,wszSiteSettingsRdn);
		wcscat(pszSiteDN,pszSiteSpecDN);  
	    }
	    else{
		Assert( !"Service name should have been present" ); 
	    }
	}
    }
    else {
	//error, set ret and goto cleanup
    }

    //now read the attribute from the ntds settings object
    ldStatus = GetSiteOptions(hld, pszSiteDN, &nOptions);    
    CHK_LD_STATUS(ldStatus);

    // Display current options.
    PrintMsg(REPADMIN_PRINT_STR, GetNtdsSiteDisplayName(pszSiteDN));
    PrintMsg(REPADMIN_PRINT_CURRENT_NO_CR);
    PrintMsg(REPADMIN_SHOWREPS_SITE_OPTIONS, GetSiteOptionsString(nOptions));

    if (nAddOptions || nRemoveOptions) {
        nOptions |= nAddOptions;
        nOptions &= ~nRemoveOptions;
        
        PrintMsg(REPADMIN_PRINT_NEW_NO_CR);
        PrintMsg(REPADMIN_SHOWREPS_SITE_OPTIONS, GetSiteOptionsString(nOptions));

        ldStatus = SetSiteOptions(hld, pszSiteDN, nOptions);
        CHK_LD_STATUS(ldStatus);
    }


 cleanup:
     if (ppszServiceName) {
	 ldap_value_freeW(ppszServiceName);
     }
     if (ppszConfigNC) {
	 ldap_value_freeW(ppszConfigNC);
     }
     if (pldmRootResults) {
	 ldap_msgfree(pldmRootResults);
     }
     if (pldmCheckSiteResults) {
	 ldap_msgfree(pldmCheckSiteResults);
     }
     if (pszSiteDN) {
	 free(pszSiteDN);
     }
    ldap_unbind(hld);

    return ret;
}

int
ShowSig(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    LPWSTR          pszDSA = NULL;
    LDAP *          hld;
    int             iArg;
    int             ldStatus;
    LDAPMessage *   pldmRootResults = NULL;
    LDAPMessage *   pldmRootEntry;
    LDAPMessage *   pldmDsaResults = NULL;
    LDAPMessage *   pldmDsaEntry;
    LPSTR           rgpszRootAttrsToRead[] = {"dsServiceName", NULL};
    LPWSTR          rgpszDsaAttrsToRead[] = {L"invocationId", L"retiredReplDsaSignatures", NULL};
    LPWSTR *        ppszServerNames = NULL;
    struct berval **ppbvRetiredIDs;
    struct berval **ppbvInvocID;
    CHAR            szTime[SZDSTIME_LEN];
    DWORD           i;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Retrieve dsServiceName DN.
    ldStatus = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
                             rgpszRootAttrsToRead, 0, &pldmRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pldmRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    pldmRootEntry = ldap_first_entry(hld, pldmRootResults);
    if (NULL == pldmRootEntry) {
        ret = ERROR_INTERNAL_ERROR;
        Assert( !ret );
        goto cleanup;
    }

    ppszServerNames = ldap_get_valuesW(hld, pldmRootEntry, L"dsServiceName");
    if (NULL == ppszServerNames) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    Assert(1 == ldap_count_valuesW(ppszServerNames));

    PrintMsg(REPADMIN_PRINT_STR, GetNtdsDsaDisplayName(*ppszServerNames));
    PrintMsg(REPADMIN_PRINT_CR);

    // Read current and retired DSA signatures from DSA object.
    ldStatus = ldap_search_sW(hld, *ppszServerNames, LDAP_SCOPE_BASE,
                              L"(objectClass=*)", rgpszDsaAttrsToRead, 0,
                              &pldmDsaResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pldmDsaResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    pldmDsaEntry = ldap_first_entry(hld, pldmDsaResults);
    if (NULL == pldmDsaEntry) {
        ret = ERROR_INTERNAL_ERROR;
        Assert( !ret );
        goto cleanup;
    }

    ppbvInvocID = ldap_get_values_len(hld, pldmDsaEntry, "invocationId");
    if (NULL != ppbvInvocID) {
        Assert(1 == ldap_count_values_len(ppbvInvocID));
        PrintMsg(REPADMIN_PRINT_CURRENT_NO_CR);
        PrintTabMsg(0, REPADMIN_PRINT_INVOCATION_ID, 
               GetStringizedGuid((GUID *) ppbvInvocID[0]->bv_val));
        ldap_value_free_len(ppbvInvocID);
    } else {
        Assert( !"invocationId should have been returned" );
    }

    ppbvRetiredIDs = ldap_get_values_len(hld, pldmDsaEntry, "retiredReplDsaSignatures");
    if (NULL != ppbvRetiredIDs) {
        REPL_DSA_SIGNATURE_VECTOR * pVec;
        REPL_DSA_SIGNATURE_V1 *     pEntry;
            
        Assert(1 == ldap_count_values_len(ppbvRetiredIDs));

        pVec = (REPL_DSA_SIGNATURE_VECTOR *) ppbvRetiredIDs[0]->bv_val;

        if (ReplDsaSignatureVecV1Size(pVec) != ppbvRetiredIDs[0]->bv_len) {
            PrintMsg(REPADMIN_PRINT_CR);
            PrintMsg(REPADMIN_SHOWSIG_RETIRED_SIGS_UNRECOGNIZED);
        }
        else {
            for (i = 0; i < pVec->V1.cNumSignatures; i++) {
                pEntry = &pVec->V1.rgSignature[pVec->V1.cNumSignatures - i - 1];

                PrintMsg(REPADMIN_SHOWSIG_RETIRED_INVOC_ID,
                         GetStringizedGuid(&pEntry->uuidDsaSignature),
                         DSTimeToDisplayString(pEntry->timeRetired, szTime),
                         pEntry->usnRetired);
            }
        }
            
        ldap_value_free_len(ppbvRetiredIDs);
    }
    else {
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_SHOWSIG_NO_RETIRED_SIGS);
    }

cleanup:

    if (ppszServerNames) {
        ldap_value_freeW(ppszServerNames);
    }
    if (pldmDsaResults) {
        ldap_msgfree(pldmDsaResults);
    }
    if (pldmRootResults) {
        ldap_msgfree(pldmRootResults);
    }

    ldap_unbind(hld);

    return ret;
}

LPSTR
GetSiteOptionsString(
    IN  int nOptions
    )
{
    static CHAR szOptions[204];

    if (0 == nOptions) {
        strcpy(szOptions, "(none)");
    }
    else {
        *szOptions = '\0';

	if (nOptions & NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED) {
            strcat(szOptions, "IS_AUTO_TOPOLOGY_DISABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED) {
            strcat(szOptions, "IS_TOPL_CLEANUP_DISABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED) {
            strcat(szOptions, "IS_TOPL_MIN_HOPS_DISABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED) {
            strcat(szOptions, "IS_TOPL_DETECT_STALE_DISABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED) {
            strcat(szOptions, "IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED) {
            strcat(szOptions, "IS_GROUP_CACHING_ENABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_FORCE_KCC_WHISTLER_BEHAVIOR) {
            strcat(szOptions, "FORCE_KCC_WHISTLER_BEHAVIOR ");
        }
    }

    return szOptions;
}


LPSTR
GetDsaOptionsString(
    IN  int nOptions
    )
{
    static CHAR szOptions[128];

    if (0 == nOptions) {
        strcpy(szOptions, "(none)");
    }
    else {
        *szOptions = '\0';

        if (nOptions & NTDSDSA_OPT_IS_GC) {
            strcat(szOptions, "IS_GC ");
        }
        if (nOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL) {
            strcat(szOptions, "DISABLE_INBOUND_REPL ");
        }
        if (nOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL) {
            strcat(szOptions, "DISABLE_OUTBOUND_REPL ");
        }
        if (nOptions & NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE) {
            strcat(szOptions, "DISABLE_NTDSCONN_XLATE ");
        }
    }

    return szOptions;
}


LPWSTR
GetDsaDnsName(
    PLDAP       hld,
    LPWSTR      pwszDsa
    )
/*++

Routine Description:

    Returns (allocated) dns name of the DSA represented
    by the DN of the ntdsDsa object.

Arguments:

    hld - ldap handle
    pwszDsa - the DN of the server's ntdsDsa object

Return Value:

    Success: a ptr to ldap allocated dns name
    Failure: NULL


Remarks:

    - hld is an active (connected/authenticated connection)
    - Caller must free returned string w/ free()




--*/
{

    LPWSTR pServer = NULL;
    ULONG ulErr = ERROR_SUCCESS;
    LPWSTR attrs[] = { L"dNSHostName", NULL };
    PLDAPMessage res = NULL, entry = NULL;
    LPWSTR *ppVals = NULL;
    LPWSTR pDnsName = NULL;


    Assert(hld && pwszDsa);

    //
    // compute the server DN from the child ntdsDsa DN
    //
    ulErr = WrappedTrimDSNameBy(pwszDsa,1, &pServer);
    if ( ulErr ) {
        Assert( !ulErr );
        return NULL;
    }

    //
    // Retrieve the data from server
    //
    ulErr = ldap_search_sW(
                hld,
                pServer,
                LDAP_SCOPE_BASE,
                L"objectclass=*",
                attrs,
                FALSE,
                &res);

    if ( ERROR_SUCCESS != ulErr ) {
        REPORT_LD_STATUS(LdapGetLastError());	
        return NULL;
    }

    // initialization worked: from here, failures go thru cleanup

    entry = ldap_first_entry(hld, res);
    if (!entry) {
        Assert( !"entry should have been returned" );
        goto cleanup;
    }

    ppVals = ldap_get_valuesW(hld, entry, attrs[0]);
    if (!ppVals || !ppVals[0]) {
        Assert( !"value should have been returned" );
        REPORT_LD_STATUS(LdapGetLastError());	
        goto cleanup;
    }

    pDnsName = malloc((wcslen(ppVals[0])+1)*sizeof(WCHAR));
    if (!pDnsName) {
        CHK_ALLOC(pDnsName);
        goto cleanup;
    }

    // copy dns name to returned buffer
    wcscpy(pDnsName, ppVals[0]);

cleanup:

    if (pServer) {
        free(pServer);
    }
    if (ppVals) {
        ldap_value_freeW(ppVals);
    }
    if ( res ) {
        ldap_msgfree(res);
    }

    return pDnsName;
}


void
printLdapTime(
    LPSTR pszTime
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PrintMsg(REPADMIN_PRINT_SHORT_STR, pszTime);
}


BOOL
decodeLdapDistnameBinary(
    LPWSTR pszLdapDistnameBinaryValue,
    PVOID *ppvData,
    LPDWORD pcbLength,
    LPWSTR *ppszDn
    )

/*++

Routine Description:

    Description

Arguments:

    pszLdapDistnameBinaryValue - Incoming ldap encoded distname binary value
    ppvData - Newly allocated data. Caller must deallocate
    pcbLength - length of returned data
    ppszDn - pointer to dn within incoming buffer, do not deallocate

Return Value:

    BOOL -

--*/

{
    LPWSTR pszColon, pszData;
    DWORD length, i;

    // Check for 'B'
    if (*pszLdapDistnameBinaryValue != L'B') {
        return FALSE;
    }

    // Check for 1st :
    pszLdapDistnameBinaryValue++;
    if (*pszLdapDistnameBinaryValue != L':') {
        return FALSE;
    }

    // Get the length
    pszLdapDistnameBinaryValue++;
    length = wcstol(pszLdapDistnameBinaryValue, NULL, 10);
    if (length & 1) {
        // Length should be even
        return FALSE;
    }
    *pcbLength = length / 2;

    // Check for 2nd :
    pszColon = wcschr(pszLdapDistnameBinaryValue, L':');
    if (!pszColon) {
        return FALSE;
    }

    // Make sure length is correct
    pszData = pszColon + 1;
    if (pszData[length] != L':') {
        return FALSE;
    }
    pszColon = wcschr(pszData, L':');
    if (!pszColon) {
        return FALSE;
    }
    if (pszColon != pszData + length) {
        return FALSE;
    }

    // Decode the data
    *ppvData = malloc( *pcbLength );
    CHK_ALLOC(*ppvData);

    for( i = 0; i < *pcbLength; i++ ) {
        WCHAR szHexString[3];
        szHexString[0] = *pszData++;
        szHexString[1] = *pszData++;
        szHexString[2] = L'\0';
        ((PCHAR) (*ppvData))[i] = (CHAR) wcstol(szHexString, NULL, 16);
    }

    Assert( pszData == pszColon );

    // Return pointer to dn
    *ppszDn = pszColon + 1;

    return TRUE;
} /* decodeLdapDistnameBinary */

BOOL
showMatchingFailure(
    IN  DS_REPL_KCC_DSA_FAILURESW * pFailures,
    IN  LPWSTR pszDn,
    IN  BOOL fErrorsOnly
    )
{
    DWORD i;
    BOOL fFound = FALSE;
    LPWSTR *ppszRDNs;

    if ( (!pFailures) || (0 == pFailures->cNumEntries) ) {
        return FALSE;
    }

    ppszRDNs = ldap_explode_dnW(pszDn, 1);
    if (ppszRDNs == NULL) {
        REPORT_LD_STATUS(LdapGetLastError());	
        return FALSE;
    }

    for (i = 0; i < pFailures->cNumEntries; i++) {
        DS_REPL_KCC_DSA_FAILUREW * pFailure = &pFailures->rgDsaFailure[i];

        if ( (pFailure->pszDsaDN) &&
             (!wcscmp( pszDn, pFailure->pszDsaDN)) &&
             (pFailure->cNumFailures) ) {
            DSTIME dsTime;
            CHAR   szTime[SZDSTIME_LEN];

            FileTimeToDSTime(pFailure->ftimeFirstFailure, &dsTime);

            if (fErrorsOnly) {
                PrintMsg(REPADMIN_PRINT_CR);
                PrintMsg(REPADMIN_SHOW_MATCH_FAIL_SRC,  ppszRDNs[3], ppszRDNs[1] );
            }
            PrintMsg(REPADMIN_SHOW_MATCH_FAIL_N_CONSECUTIVE_FAILURES, 
                   pFailure->cNumFailures,
                   DSTimeToDisplayString(dsTime, szTime));

            if (0 != pFailure->dwLastResult) {
                PrintMsg(REPADMIN_FAILCACHE_LAST_ERR_LINE);
                PrintTabErrEnd(6, pFailure->dwLastResult);
            }
            fFound = TRUE;
            break;
        }
    } // end for...

//cleanup:
    ldap_value_freeW(ppszRDNs);
    return fFound;
}

BOOL
findFailure(
    IN  DS_REPL_KCC_DSA_FAILURESW * pFailures,
    IN  LPWSTR pszDn,
    OUT DSTIME *pdsFirstFailure,
    OUT DWORD *pcNumFailures,
    OUT DWORD *pdwLastResult
    )
{
    DWORD i;
    BOOL fFound = FALSE;

    if ( (!pFailures) || (0 == pFailures->cNumEntries) ) {
        return FALSE;
    }

    for (i = 0; i < pFailures->cNumEntries; i++) {
        DS_REPL_KCC_DSA_FAILUREW * pFailure = &pFailures->rgDsaFailure[i];

        if ( (pFailure->pszDsaDN) &&
             (!wcscmp( pszDn, pFailure->pszDsaDN)) &&
             (pFailure->cNumFailures) ) {

            FileTimeToDSTime(pFailure->ftimeFirstFailure, pdsFirstFailure);
            *pcNumFailures = pFailure->cNumFailures;
            *pdwLastResult = pFailure->dwLastResult;
            fFound = TRUE;
            break;
        }
    } // end for...

//cleanup:
    return fFound;
}

void
showMissingNeighbor(
    DS_REPL_NEIGHBORSW *pNeighbors,
    LPWSTR pszNc,
    LPWSTR pszSourceDsaDn,
    BOOL fErrorsOnly
    )
{
    DWORD i;
    DS_REPL_NEIGHBORW *   pNeighbor;
    BOOL fFound = FALSE;

    if (!pNeighbors) {
        return;
    }

    for (i = 0; i < pNeighbors->cNumNeighbors; i++) {
        pNeighbor = &pNeighbors->rgNeighbor[i];

        if ( (!wcscmp( pNeighbor->pszNamingContext, pszNc )) &&
             (!wcscmp( pNeighbor->pszSourceDsaDN, pszSourceDsaDn )) ) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound) {
        if (!fErrorsOnly) {
            PrintMsg(REPADMIN_SHOW_MISSING_NEIGHBOR_REPLICA_ADDED);
        }
    } else {
        if (fErrorsOnly) {
            LPWSTR *ppszRDNs;

            PrintMsg(REPADMIN_PRINT_CR);
#ifdef DISPLAY_ABBREV_NC
            ppszRDNs = ldap_explode_dnW(pszNc, 1);
            if (ppszRDNs != NULL) {
                // Display more of the nc name to disambiguate?
                PrintMsg(REPADMIN_PRINT_NAMING_CONTEXT_NO_CR, ppszRDNs[0]);
                ldap_value_freeW(ppszRDNs);
            } else {
                REPORT_LD_STATUS(LdapGetLastError());	
            }
#else
            PrintMsg(REPADMIN_PRINT_NAMING_CONTEXT_NO_CR, pszNc);
#endif

            ppszRDNs = ldap_explode_dnW(pszSourceDsaDn, 1);
            if (ppszRDNs != NULL) {
                PrintMsg(REPADMIN_SHOW_MATCH_FAIL_SRC, ppszRDNs[3], ppszRDNs[1] );
                ldap_value_freeW(ppszRDNs);
            } else {
                REPORT_LD_STATUS(LdapGetLastError());	
            }
        }
        PrintMsg(REPADMIN_SHOW_MISSING_NEIGHBOR_WARN_KCC_COULDNT_ADD_REPLICA_LINK);
    }
}

int
ShowBridgeheadNeighbor(
    LDAP *hldHome,
    BOOL fPrintTitle,
    LPWSTR pszBridgeheadDsaDn,
    LPWSTR pszNcDn,
    LPWSTR pszFromServerDsaDn
    )
/*
 */
{
    int             ret = 0;
    int             ldStatus;
    ULONG           secondary;
    HANDLE          hDS = NULL;
    LPWSTR          rgpszFromAttrsToRead[] = {L"objectGuid",
                                              NULL };
    LDAPMessage *   pBaseResults = NULL;
    LDAPMessage *   pFromResults = NULL;
    LPWSTR *        ppszDnsHostName = NULL;
    LPWSTR          pszDSA = NULL;
    struct berval **    ppbvGuid = NULL;
    GUID            * pGuidFromDsa;
    DS_REPL_NEIGHBORSW *pNeighbors = NULL;
    DS_REPL_NEIGHBORW *pNeighbor = NULL;
    CHAR    szTime[ SZDSTIME_LEN ];
    CHAR    szTime2[ SZDSTIME_LEN ];
    DSTIME  dsTime;
    LPWSTR *ppszNcRDNs = NULL;

    if (fPrintTitle) {
        PrintMsg( REPADMIN_SHOW_BRIDGEHEADS_HDR );
    }

    ppszNcRDNs = ldap_explode_dnW(pszNcDn, 1);
    if (NULL == ppszNcRDNs) {
        REPORT_LD_STATUS(LdapGetLastError());	
        ret = ERROR_DS_DRA_BAD_DN;
        goto cleanup;
    }

    // What's the dns host name of this object?
    pszDSA = GetDsaDnsName(hldHome, pszBridgeheadDsaDn);
    Assert(NULL != pszDSA);

    // What's the guid of the from server dsa
    ldStatus = ldap_search_sW(hldHome, pszFromServerDsaDn, LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgpszFromAttrsToRead, 0, &pFromResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pFromResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    ppbvGuid = ldap_get_values_len(hldHome, pFromResults, "objectGuid");
    if (NULL == ppbvGuid) {
        REPORT_LD_STATUS(LdapGetLastError());	
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        goto cleanup;
    }
    Assert(1 == ldap_count_values_len(ppbvGuid));
    pGuidFromDsa = (GUID *) ppbvGuid[0]->bv_val;

    // Get a DS Handle too
    ret = DsBindWithCredW(pszDSA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszDSA, ret);
        goto cleanup;
    }

    // *******************************************

    // Display more of the nc name to disambiguate?
    PrintMsg( REPADMIN_SHOW_BRIDGEHEADS_DATA_1, ppszNcRDNs[0] );
    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS,
                            pszNcDn /* pszNc*/, pGuidFromDsa /* puuid */,
                            &pNeighbors);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        goto cleanup;
    }

    // When asking for a specific source guid that is not present, get
    // neighbors may return an empty structure.
    if ( (!pNeighbors) || (pNeighbors->cNumNeighbors == 0) ) {
        goto cleanup;
    }

    pNeighbor = &(pNeighbors->rgNeighbor[0]);

    // Display status and time of last replication attempt/success.
    FileTimeToDSTime(pNeighbor->ftimeLastSyncAttempt, &dsTime);
    DSTimeToDisplayString(dsTime, szTime);
    FileTimeToDSTime(pNeighbor->ftimeLastSyncSuccess, &dsTime);
    DSTimeToDisplayString(dsTime, szTime2);
    PrintMsg(REPADMIN_SHOW_BRIDGEHEADS_DATA_2, 
             szTime, szTime2, 
             pNeighbor->cNumConsecutiveSyncFailures,
             Win32ErrToString(pNeighbor->dwLastSyncResult) );

    DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
    pNeighbors = NULL;

    // *******************************************

cleanup:

    if (pszDSA) {
        free(pszDSA);
    }
    if (ppszNcRDNs) {
        ldap_value_freeW(ppszNcRDNs);
    }
    if (ppszDnsHostName) {
        ldap_value_freeW(ppszDnsHostName);
    }
    if (ppbvGuid) {
        ldap_value_free_len(ppbvGuid);
    }
    if (pBaseResults) {
        ldap_msgfree(pBaseResults);
    }
    if (pFromResults) {
        ldap_msgfree(pFromResults);
    }
    if (hDS) {
        secondary = DsUnBindW(&hDS);
        if (secondary != ERROR_SUCCESS) {
            PrintUnBindFailed(secondary);
            // keep going
        }
    }

    return ret;
}

int
FindConnections(
    LDAP *          hld,
    LPWSTR          pszBaseSearchDn,
    LPWSTR          pszFrom,
    BOOL            fShowConn,
    BOOL            fVerbose,
    BOOL            fIntersite
    )
{
    int             ret = 0;
    LPWSTR          pszServerRdn = NULL;
    int             ldStatus, ldStatus1;
    LDAPSearch *    pSearch = NULL;
    LDAPMessage *   pldmConnResults;
    LDAPMessage *   pldmConnEntry;
    LPWSTR          rgpszConnAttrsToRead[] = {L"enabledConnection", L"fromServer", L"mS-DS-ReplicatesNCReason", L"options", L"schedule", L"transportType", L"whenChanged", L"whenCreated", NULL};
    CHAR            szTime[SZDSTIME_LEN];
    DWORD           i, cConn = 0;
    ULONG           ulTotalEstimate;
    WCHAR           pszServerRDN[MAX_RDN_SIZE + 1];
    DS_REPL_KCC_DSA_FAILURESW * pConnFailures = NULL, * pLinkFailures = NULL;
    DS_REPL_NEIGHBORSW *pNeighbors = NULL;
    HANDLE hDS = NULL;
    LPWSTR          pwszDnsName = NULL;
    LPWSTR pNtdsDsa = NULL;
    PVOID pvScheduleTotalContext = NULL;

    *pszServerRDN = L'\0';

    // Retrieve all the connections under the given base

    pSearch = ldap_search_init_pageW(hld,
                                     pszBaseSearchDn,
                                     LDAP_SCOPE_SUBTREE,
                                     L"(objectClass=nTDSConnection)",
                                     rgpszConnAttrsToRead,
                                     FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
        CHK_LD_STATUS(LdapGetLastError());
    }

    ldStatus = ldap_get_next_page_s(hld,
                                     pSearch,
                                     0,
                                     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                     &ulTotalEstimate,
                                     &pldmConnResults);

    while (ldStatus == LDAP_SUCCESS) {

        for (pldmConnEntry = SAFE_LDAP_FIRST_ENTRY(hld, pldmConnResults);
            NULL != pldmConnEntry;
            pldmConnEntry = ldap_next_entry(hld, pldmConnEntry)) {
            LPWSTR pszDn;
            LPWSTR *ppszRDNs, *ppszFromRDNs;
            LPSTR  *ppszEnabledConnection;
            LPWSTR *ppszFromServer;
            LPWSTR *ppszTransportType;
            LPSTR  *ppszOptions;
            LPSTR  *ppszTime;
            DWORD  dwOptions, i, cNCs = 3;
            struct berval **ppbvSchedule;
            LPWSTR *ppszNcReason;

            // fromServer filter
            ppszFromServer = ldap_get_valuesW(hld, pldmConnEntry, L"fromServer");
            if (NULL == ppszFromServer) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            Assert(1 == ldap_count_valuesW(ppszFromServer));
            ppszFromRDNs = ldap_explode_dnW(*ppszFromServer, 1);
            if (ppszFromRDNs == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            Assert(NULL != ppszFromRDNs);
            Assert(6 < ldap_count_valuesW(ppszFromRDNs));
            // NTDS settings,<server>,Servers,<site>,Sites,<Config NC>
            if ( pszFrom && (_wcsicmp( ppszFromRDNs[1], pszFrom ))) {
                ldap_value_freeW(ppszFromRDNs);
                continue;
            }


            // Connection object dn filter
            pszDn = ldap_get_dnW(hld, pldmConnEntry);
            if (NULL == pszDn) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }

            // get ntdsdsa name (& free previously allocated)
            if ( pNtdsDsa ) {
                free(pNtdsDsa);
            }
            ret = WrappedTrimDSNameBy( pszDn, 1, &pNtdsDsa );
            Assert(pNtdsDsa && !ret);

            // Get dns name (free previously allocated)
            if (pwszDnsName) {
                free(pwszDnsName);
            }
            pwszDnsName = GetDsaDnsName(hld, pNtdsDsa);
            Assert(pwszDnsName);

            // explode to RDNs
            ppszRDNs = ldap_explode_dnW(pszDn, 1);
            if (ppszRDNs == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            ldap_memfreeW(pszDn);
            Assert(NULL != ppszRDNs);
            Assert(6 < ldap_count_valuesW(ppszRDNs));
            // <conn>,ntds settings,<server>,Servers,<site>,Sites,Config NC
            if (fIntersite && (!wcscmp( ppszFromRDNs[3], ppszRDNs[4] ))) {
                continue;
            }

            // Connection object dn
            if (fShowConn) {
                PrintMsg(REPADMIN_SHOWCONN_DATA,
                       ppszRDNs[0],
                       pwszDnsName,
                       pNtdsDsa);
                cConn++;
            }

            // Dump failure counts for each unique server
            if (wcscmp( pszServerRDN, ppszRDNs[2] ) ) {
                wcscpy( pszServerRDN, ppszRDNs[2] );

                if (pConnFailures) {
                    DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pConnFailures);
                    pConnFailures = NULL;
                }
                if (pLinkFailures) {
                    DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pLinkFailures);
                    pLinkFailures = NULL;
                }
                if (pNeighbors) {
                    DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
                    pNeighbors = NULL;
                }
                if (hDS) {
                    ret = DsUnBindW(&hDS);
                    if (ret != ERROR_SUCCESS) {
                        PrintUnBindFailed(ret);
                        // keep going
                    }
                    hDS = NULL;
                }

                ret = DsBindWithCredW(pwszDnsName,
                                      NULL,
                                      (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                                      &hDS);
                if (ret != ERROR_SUCCESS) {
                    // This means the destination is down
                    PrintBindFailed(pszServerRDN, ret);
                }

                if (hDS) {
                    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,
                                            NULL, NULL, &pConnFailures);
                    if (ret != ERROR_SUCCESS) {
                        PrintFuncFailed(L"DsReplicaGetInfo", ret);
                        // keep going
                    }

                    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                                            NULL, NULL, &pLinkFailures);
                    if (ret != ERROR_SUCCESS) {
                        PrintFuncFailed(L"DsReplicaGetInfo", ret);
                        // keep going
                    }

                    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS,
                                            NULL /* pszNc*/, NULL /* puuid */,
                                            &pNeighbors);
                    if (ERROR_SUCCESS != ret) {
                        PrintFuncFailed(L"DsReplicaGetInfo", ret);
                        // keep going
                    }
                }
            }
            ldap_value_freeW(ppszRDNs);
            if ( pNtdsDsa ) {
                free(pNtdsDsa);
                pNtdsDsa = NULL;
            }

            // fromServer
            if (fShowConn) {
                PrintTabMsg(4, REPADMIN_SHOW_MATCH_FAIL_SRC,
                            ppszFromRDNs[3], ppszFromRDNs[1]);
            }
            if ( (!showMatchingFailure( pConnFailures, *ppszFromServer, !fShowConn )) &&
                 (!showMatchingFailure( pLinkFailures, *ppszFromServer, !fShowConn )) ) {
                if (fShowConn) {
                    PrintTabMsg(8, REPADMIN_PRINT_NO_FAILURES);
                }
            }
            ldap_value_freeW(ppszFromRDNs);

            // transportType
            ppszTransportType = ldap_get_valuesW(hld, pldmConnEntry, L"transportType");
            // Not present on intra-site connections
            if (ppszTransportType != NULL) {
                Assert(1 == ldap_count_valuesW(ppszTransportType));
                ppszRDNs = ldap_explode_dnW(*ppszTransportType, 1);
                if (ppszRDNs != NULL) {
                    Assert(4 < ldap_count_valuesW(ppszRDNs));
                    // <transport>,Intersite Transports,Sites,<Config NC>
                    if (fShowConn) {
                        PrintMsg(REPADMIN_SHOWCONN_TRANSPORT_TYPE, ppszRDNs[0] );
                    }
                    ldap_value_freeW(ppszRDNs);
                } else {
                    REPORT_LD_STATUS(LdapGetLastError());	
                }
                ldap_value_freeW(ppszTransportType);
            } else {
                if (fShowConn) {
                    PrintMsg(REPADMIN_SHOWCONN_TRANSPORT_TYPE_INTRASITE_RPC);
                }
            }

            // options
            ppszOptions = ldap_get_values( hld, pldmConnEntry, "options" );
            if (NULL != ppszOptions) {
                Assert(1 == ldap_count_values(ppszOptions));
                dwOptions = atol( *ppszOptions );
                if (dwOptions) {
                    if (fShowConn) {
                        PrintMsg(REPADMIN_SHOWCONN_OPTIONS);
                        printBitField( dwOptions, ppszNtdsConnOptionNames );
                    }
                }
                ldap_value_free(ppszOptions);
            }

            // ms-DS-ReplicatesNCReason
            ppszNcReason = ldap_get_valuesW(hld, pldmConnEntry, L"mS-DS-ReplicatesNCReason");
            // See if new attribute written by post-b3 server
            if (ppszNcReason) {
                DWORD dwReason, cbLength;
                PVOID pvData;

                cNCs = ldap_count_valuesW(ppszNcReason);

                for ( i = 0; i < cNCs; i++ ) {
                    if (!decodeLdapDistnameBinary(
                                                 ppszNcReason[i], &pvData, &cbLength, &pszDn)) {
                        PrintMsg(REPADMIN_SHOWCONN_INVALID_DISTNAME_BIN_VAL, ppszNcReason[i]);
                        break;
                    }
                    if (fShowConn) {
                        PrintTabMsg(4, REPADMIN_SHOWCONN_REPLICATES_NC, pszDn);
                        if (cbLength != sizeof(DWORD)) {
                            PrintMsg(REPADMIN_SHOWCONN_INVALID_DISTNAME_BIN_LEN, cbLength);
                            break;
                        }
                        dwReason = ntohl( *((LPDWORD) pvData) );
                        if (dwReason) {
                            PrintMsg(REPADMIN_SHOWCONN_REASON);
                            printBitField( dwReason, ppszKccReasonNames );
                        }
                    }
                    free( pvData );
                    showMissingNeighbor( pNeighbors, pszDn, *ppszFromServer, !fShowConn );
                }
                ldap_value_freeW(ppszNcReason);
            }
            ldap_value_freeW(ppszFromServer);

            // All other attributes are considered verbose
            if (!(fShowConn && fVerbose)) {
                continue;
            }

            // enabledConnection
            ppszEnabledConnection = ldap_get_values(hld, pldmConnEntry, "enabledConnection");
            if (NULL != ppszEnabledConnection) {
                Assert(1 == ldap_count_values(ppszEnabledConnection));
                PrintMsg(REPADMIN_SHOWCONN_ENABLED_CONNECTION, *ppszEnabledConnection);
                ldap_value_free(ppszEnabledConnection);
            }

            // whenChanged
            ppszTime = ldap_get_values( hld, pldmConnEntry, "whenChanged" );
            if (NULL != ppszTime) {
                Assert(1 == ldap_count_values(ppszTime));
                PrintMsg(REPADMIN_SHOWCONN_WHEN_CHANGED);
                printLdapTime( *ppszTime );
                ldap_value_free(ppszTime);
            }

            // whenCreated
            ppszTime = ldap_get_values( hld, pldmConnEntry, "whenCreated" );
            if (NULL != ppszTime) {
                Assert(1 == ldap_count_values(ppszTime));
                PrintMsg(REPADMIN_SHOWCONN_WHEN_CREATED);
                printLdapTime( *ppszTime );
                ldap_value_free(ppszTime);
            }

            // schedule
            ppbvSchedule = ldap_get_values_len( hld, pldmConnEntry, "schedule" );
            if (NULL != ppbvSchedule ) {
                Assert(1 == ldap_count_values_len(ppbvSchedule));
                PrintMsg(REPADMIN_SHOWCONN_SCHEDULE);
                printSchedule( (*ppbvSchedule)->bv_val, (*ppbvSchedule)->bv_len );
                totalScheduleUsage( &pvScheduleTotalContext, 
                                    (*ppbvSchedule)->bv_val, (*ppbvSchedule)->bv_len,
                                    cNCs);
                ldap_value_free_len( ppbvSchedule );
            }

        } // end for more entries in a single page


        ldap_msgfree(pldmConnResults);
        pldmConnResults = NULL;

        ldStatus = ldap_get_next_page_s(hld,
                                         pSearch,
                                         0,
                                         DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                         &ulTotalEstimate,
                                         &pldmConnResults);
    } // End while more pages to search
    if (ldStatus != LDAP_NO_RESULTS_RETURNED) {
        CHK_LD_STATUS(ldStatus);
    }

    if (fShowConn && cConn) {
        PrintMsg(REPADMIN_SHOWCONN_N_CONNECTIONS_FOUND, cConn);
        // Dump schedule totals
        if (fVerbose) {
            totalScheduleUsage( &pvScheduleTotalContext, NULL, 0, 0 );
        }
    }

    if (pConnFailures) {
        DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pConnFailures);
        pConnFailures = NULL;
    }
    if (pLinkFailures) {
        DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pLinkFailures);
        pLinkFailures = NULL;
    }
    if (pNeighbors) {
        DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
        pNeighbors = NULL;
    }
    if (hDS) {
        ret = DsUnBindW(&hDS);
        if (ret != ERROR_SUCCESS) {
            PrintUnBindFailed(ret);
            // keep going
        }
        hDS = NULL;
    }

    ldStatus1 = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(ldStatus1);

    // free dns name
    if (pwszDnsName) {
        free(pwszDnsName);
    }


    return LdapMapErrorToWin32( ldStatus );
}

int
ShowConn(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    LPWSTR          pszDSA = NULL;
    LPWSTR          pszFrom = NULL;
    LDAP *          hld;
    BOOL            fVerbose = FALSE;
    BOOL            fIntersite = FALSE;
    LPWSTR          pszBaseSearchDn = NULL;
    LPWSTR          pszServerRdn = NULL;
    UUID *          puuid = NULL;
    UUID            uuid;
    LPWSTR          pszGuid = NULL;
    int             iArg;
    int             ldStatus;
    LPWSTR          rgpszRootAttrsToRead[] = {L"serverName", L"configurationNamingContext", NULL};
    WCHAR           szGuidDn[50];
    LDAPMessage *   pRootResults = NULL;
    BOOL            fBaseAlloced = FALSE;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/v")
            || !_wcsicmp(argv[iArg], L"/verbose")) {
            fVerbose = TRUE;
        }
        else if (!_wcsicmp(argv[iArg], L"/i")
            || !_wcsicmp(argv[iArg], L"/bridge")
            || !_wcsicmp(argv[iArg], L"/brideheads")
            || !_wcsicmp(argv[iArg], L"/inter")
            || !_wcsicmp(argv[iArg], L"/intersite")) {
            fIntersite = TRUE;
        }
        else if (!_wcsnicmp(argv[iArg], L"/from:", 6)) {
            pszFrom = argv[iArg] + 6;
        }
        else if ((NULL == pszBaseSearchDn) &&
                 ( CountNamePartsStringDn( argv[iArg] ) > 1 ) ) {
            pszBaseSearchDn = argv[iArg];
        }
        else if ((NULL == puuid)
                 && (0 == UuidFromStringW(argv[iArg], &uuid))) {
            puuid = &uuid;
            pszGuid = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else if (NULL == pszServerRdn) {
            pszServerRdn = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // What's the DN of the server?
    ldStatus = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)",
                             rgpszRootAttrsToRead, 0, &pRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    // Construct the base dn for search
    if (puuid) {
        // Guid was specified
        if (pszBaseSearchDn || pszServerRdn) {
            PrintMsg(REPADMIN_SHOWCONN_SPECIFY_RDN_DN_OR_GUID);
            return ERROR_INVALID_PARAMETER;
        }
        swprintf(szGuidDn, L"<GUID=%ls>", pszGuid);
        pszBaseSearchDn = szGuidDn;
    } else if (pszServerRdn) {
        // Computer the dn of the server object from the server rdn
        LPWSTR *ppszConfigNc;
        WCHAR szFilter[100];
        LPWSTR rgpszServerAttrsToRead[] = {L"invalid", NULL};  // just want dn
        LDAPMessage *pServerResults;
        LDAPMessage *pldmServerEntry;

        ppszConfigNc = ldap_get_valuesW(hld, pRootResults, L"configurationNamingContext");
        if (NULL == ppszConfigNc) {
            ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
            Assert( !ret );
            goto cleanup;
        }

        swprintf( szFilter, L"(& (objectClass=server) (cn=%ls))", pszServerRdn );

        ldStatus = ldap_search_sW(hld, *ppszConfigNc, LDAP_SCOPE_SUBTREE, szFilter,
                                 rgpszServerAttrsToRead, 0, &pServerResults);
        CHK_LD_STATUS(ldStatus);
        if (NULL == pServerResults) {
            ret = ERROR_DS_OBJ_NOT_FOUND;
            Assert( !ret );
            goto cleanup;
        }

        pldmServerEntry = ldap_first_entry(hld, pServerResults);
        Assert( pldmServerEntry );

        if (1 == ldap_count_entries(hld, pServerResults)) {
            pszBaseSearchDn = ldap_get_dnW(hld, pldmServerEntry);
            if ( pszBaseSearchDn == NULL ) {
                REPORT_LD_STATUS(LdapGetLastError());	
                return ERROR_DS_DRA_BAD_DN;
            }
        } else {
            PrintMsg(REPADMIN_SHOWCONN_AMBIGUOUS_NAME, pszServerRdn);
            return ERROR_DUP_NAME;
        }

        ldap_value_freeW(ppszConfigNc);
        ldap_msgfree(pServerResults);

    } else if (!pszBaseSearchDn) {
        // No explicit dn was specified, Construct the site container name
        LPWSTR *        ppszServerDn;

        ppszServerDn = ldap_get_valuesW(hld, pRootResults, L"serverName");
        if (NULL != ppszServerDn) {

            // Trim two dn's for the local site
            ret = WrappedTrimDSNameBy( *ppszServerDn, 2, &pszBaseSearchDn );
            Assert( !ret );
            fBaseAlloced = TRUE;

            ldap_value_freeW(ppszServerDn);
        } else {
            Assert( !"serverName should have been returned" );
        }
    }

    PrintMsg(REPADMIN_SHOWCONN_BASE_DN, pszBaseSearchDn);
    PrintMsg(REPADMIN_SHOWCONN_KCC_CONN_OBJS_HDR);

    ret = FindConnections( hld, pszBaseSearchDn, pszFrom,
                           TRUE /*showconn*/, fVerbose, fIntersite );

cleanup:

    ldap_unbind(hld);

    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }

    if (fBaseAlloced) {
        free( pszBaseSearchDn );
    }

    return ret;
}

int
ShowSiteLatency(
    LDAP *          hld,
    HANDLE          hDS,
    BOOL            fVerbose,
    LPWSTR          pszSitesContainer
    )
/*
One possible enhancement is to check whether the latency exceeds some threshold.
If so, report that replication is taking too long. A related check would be to
check whether the last local update occurred a long time ago in the past. If
current time - local time > threshold, report an error for an overdue update.

 */
{
    int ret = 0;
    int             ldStatus;
    DWORD           status;
    BOOL            result;
    static LPWSTR   rgpszSSAttrs[] = {L"whenChanged", NULL};
    LDAPSearch *    pSearch;
    LDAPMessage *   pResults;
    LDAPMessage *   pEntry;
    ULONG           ulTotalEstimate;
    SYSTEMTIME      stTime;
    FILETIME        ftTime, ftTimeCurrent;
    DSTIME          dsTimeLocal, dsTimeOrig, dsTimeCurrent;
    CHAR            szTime[SZDSTIME_LEN];
    CHAR            szTime2[SZDSTIME_LEN];
    DWORD           hours, mins, secs, ver;

    GetSystemTimeAsFileTime( &ftTimeCurrent );
    FileTimeToDSTime(ftTimeCurrent, &dsTimeCurrent);

    // Search for all Site Settings Objects

    pSearch = ldap_search_init_pageW(hld,
				    pszSitesContainer,
				    LDAP_SCOPE_SUBTREE,
				    L"(objectCategory=ntdsSiteSettings)",
				    rgpszSSAttrs,
				    FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
	CHK_LD_STATUS(LdapGetLastError());	
    }

    ldStatus = ldap_get_next_page_s(hld,
				     pSearch,
				     0,
				     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
				     &ulTotalEstimate,
				     &pResults);
    if (ldStatus == LDAP_SUCCESS) {
        PrintMsg(REPADMIN_LATENCY_HDR);
    }
    while(ldStatus == LDAP_SUCCESS){

        for (pEntry = SAFE_LDAP_FIRST_ENTRY(hld, pResults);
	     NULL != pEntry;
	     pEntry = ldap_next_entry(hld, pEntry)) {

            LPWSTR          pszDN;
            LPWSTR *        ppszRDNs;
            LPWSTR *        ppszWhenChanged;
            DS_REPL_OBJ_META_DATA * pObjMetaData;
            DWORD iprop;
            LPWSTR pszSite;

	    pszDN = ldap_get_dnW(hld, pEntry);
	    if (NULL == pszDN) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }

	    ppszRDNs = ldap_explode_dnW(pszDN, 1);
            if (ppszRDNs == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
	    pszSite = ppszRDNs[1];

            ppszWhenChanged = ldap_get_valuesW(hld, pEntry,
                                    L"whenChanged");
            if (ppszWhenChanged == NULL) {
                continue;
            }

            status = GeneralizedTimeToSystemTime( *ppszWhenChanged, &stTime );
            Assert( status == 0 );
            result = SystemTimeToFileTime( &stTime, &ftTime );
            Assert( result );
            FileTimeToDSTime(ftTime, &dsTimeLocal);

            ret = DsReplicaGetInfoW(hDS,
                                    DS_REPL_INFO_METADATA_FOR_OBJ,
                                    pszDN,
                                    NULL, // puuid
                                    &pObjMetaData);
            if (ERROR_SUCCESS != ret) {
                PrintFuncFailed(L"DsReplicaGetInfo", ret);
                return ret;
            }

            // TODO: lookup entry in metadata vector using bsearch()
            for (iprop = 0; iprop < pObjMetaData->cNumEntries; iprop++) {
                if (wcscmp( pObjMetaData->rgMetaData[iprop].pszAttributeName,
                             L"interSiteTopologyGenerator" ) == 0) {
                    FileTimeToDSTime(pObjMetaData->rgMetaData[iprop].ftimeLastOriginatingChange, &dsTimeOrig);
                    ver = pObjMetaData->rgMetaData[iprop].dwVersion;
                    break;
                }
            }
            Assert( iprop < pObjMetaData->cNumEntries );

            if (dsTimeLocal >= dsTimeOrig) {
                secs = (DWORD)(dsTimeLocal - dsTimeOrig);
            } else {
                secs = 0;
            }
            mins = secs / 60;
            secs %= 60;
            hours = mins / 60;
            mins %= 60;

            PrintMsg(REPADMIN_LATENCY_DATA_1,
                     pszSite, ver,
                     DSTimeToDisplayString(dsTimeLocal, szTime),
                     DSTimeToDisplayString(dsTimeOrig, szTime2) );
            PrintMsg(REPADMIN_PRINT_STR_NO_CR, L" ");
            PrintMsg(REPADMIN_PRINT_HH_MM_SS_TIME,
                     hours, mins, secs );
                     
            if (dsTimeCurrent >= dsTimeLocal) {
                secs = (DWORD)(dsTimeCurrent - dsTimeLocal);
            } else {
                secs = 0;
            }
            mins = secs / 60;
            secs %= 60;
            hours = mins / 60;
            mins %= 60;

            PrintMsg(REPADMIN_PRINT_STR_NO_CR, L"  ");
            PrintMsg(REPADMIN_PRINT_HH_MM_SS_TIME,
                     hours, mins, secs );
            PrintMsg(REPADMIN_PRINT_CR);

            DsReplicaFreeInfo(DS_REPL_INFO_METADATA_FOR_OBJ, pObjMetaData);
            ldap_memfreeW(pszDN);
	    ldap_value_freeW(ppszRDNs);
            ldap_value_freeW(ppszWhenChanged);
        }

	ldap_msgfree(pResults);
	pResults = NULL;

	ldStatus = ldap_get_next_page_s(hld,
                                     pSearch,
                                     0,
                                     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                     &ulTotalEstimate,
                                     &pResults);
    } // end while more pages to search.
    if(ldStatus != LDAP_NO_RESULTS_RETURNED){
        CHK_LD_STATUS(ldStatus);
    }

    ldStatus = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(ldStatus);

    // Cleanup

    return ret;
}

int
ShowSiteBridgeheads(
    LDAP *          hld,
    HANDLE          hDS,
    BOOL            fVerbose,
    LPWSTR          pszSiteDn
    )
/*
It is helpful to understand how failures are cached. Failures are added to a server's
cache as follows:
1. A connection failure is added when the KCC's DsReplicaAdd fails. It is added in
   the destination's cache on behalf of the source.
2. A link failure is added if there are any replica link errors on that server. This
   is refreshed each time the KCC runs.  It is added on the destination's cache on
   behalf of whichever link source failed.
3. The ISTG adds a connection failure for each bridgehead it cannot contact.
4. The ISTG merge's each bridgehead's cache into its own.

Thus, a bridgehead (or any destination) has cached entries on behalf of sources
it talks to.  An ISTG has cached connection failures for bridgeheads it cannot
reach, and cached entries for remote bridgeheads which the local bridgeheads
can't reach.
 */

{
    int             ret = 0;
    int             ldStatus, ldStatus1;
    LDAPSearch *    pSearch = NULL;
    LDAPMessage *   pldmConnResults;
    LDAPMessage *   pldmConnEntry;
    LPWSTR          rgpszConnAttrsToRead[] = {L"fromServer", L"mS-DS-ReplicatesNCReason", L"transportType", NULL};
    CHAR            szTime[SZDSTIME_LEN];
    DWORD           i;
    ULONG           ulTotalEstimate;
    DS_REPL_KCC_DSA_FAILURESW * pConnFailures = NULL, * pLinkFailures = NULL;
    DSTIME dsFirstFailure;
    DWORD cNumFailures, dwLastResult;

    // Dump failure counts for each unique server
    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,
                            NULL, NULL, &pConnFailures);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        // keep going
    }

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                            NULL, NULL, &pLinkFailures);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        // keep going
    }

    // Retrieve all the connections under the given base

    pSearch = ldap_search_init_pageW(hld,
                                     pszSiteDn,
                                     LDAP_SCOPE_SUBTREE,
                                     L"(objectClass=nTDSConnection)",
                                     rgpszConnAttrsToRead,
                                     FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
        CHK_LD_STATUS(LdapGetLastError());
    }

    ldStatus = ldap_get_next_page_s(hld,
                                     pSearch,
                                     0,
                                     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                     &ulTotalEstimate,
                                     &pldmConnResults);

    if (ldStatus == LDAP_SUCCESS) {
        PrintMsg(REPADMIN_BRIDGEHEADS_HDR);
    }
    while (ldStatus == LDAP_SUCCESS) {

        for (pldmConnEntry = SAFE_LDAP_FIRST_ENTRY(hld, pldmConnResults);
            NULL != pldmConnEntry;
            pldmConnEntry = ldap_next_entry(hld, pldmConnEntry)) {
            LPWSTR pszDn;
            LPWSTR *ppszRDNs, *ppszFromRDNs;
            LPWSTR *ppszFromServer;
            LPWSTR *ppszTransportType;
            DWORD  dwOptions, i;
            LPWSTR *ppszNcReason;
            LPWSTR pszBridgeheadDn;

            // fromServer filter
            ppszFromServer = ldap_get_valuesW(hld, pldmConnEntry, L"fromServer");
            if (NULL == ppszFromServer) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            Assert(1 == ldap_count_valuesW(ppszFromServer));
            ppszFromRDNs = ldap_explode_dnW(*ppszFromServer, 1);
            if (ppszFromRDNs == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            Assert(6 < ldap_count_valuesW(ppszFromRDNs));
            // NTDS settings,<server>,Servers,<site>,Sites,<Config NC>

            // Connection object dn filter
            pszDn = ldap_get_dnW(hld, pldmConnEntry);
            if (NULL == pszDn) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            ppszRDNs = ldap_explode_dnW(pszDn, 1);
            if (ppszRDNs == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            Assert(6 < ldap_count_valuesW(ppszRDNs));
            // <conn>,ntds settings,<server>,Servers,<site>,Sites,Config NC
            // Only want destination and source which are in different sites
            if (!wcscmp( ppszFromRDNs[3], ppszRDNs[4] )) {
                ldap_value_freeW(ppszRDNs);
                ldap_value_freeW(ppszFromRDNs);
                ldap_value_freeW(ppszFromServer);
                ldap_memfreeW(pszDn);
                continue;
            }
            PrintMsg(REPADMIN_BRIDGEHEADS_DATA_1,
                     ppszFromRDNs[3], ppszRDNs[2] );

            ldap_value_freeW(ppszRDNs);
            ldap_value_freeW(ppszFromRDNs);

            // transportType
            ppszTransportType = ldap_get_valuesW(hld, pldmConnEntry, L"transportType");
            // Not present on intra-site connections
            if (ppszTransportType != NULL) {
                Assert(1 == ldap_count_valuesW(ppszTransportType));
                ppszRDNs = ldap_explode_dnW(*ppszTransportType, 1);
                if (ppszRDNs != NULL) {
                    Assert(6 < ldap_count_valuesW(ppszRDNs));
                    // <transport>,Intersite Transports,Sites,<Config NC>
                    PrintMsg(REPADMIN_BRIDGEHEADS_DATA_2, ppszRDNs[0] );
                    ldap_value_freeW(ppszRDNs);
                } else {
                    REPORT_LD_STATUS(LdapGetLastError());	
                }
                ldap_value_freeW(ppszTransportType);
            } else {
                PrintMsg(REPADMIN_BRIDGEHEADS_DATA_2, L"RPC");
            }

            // Look for failures. The failures that can be displayed are either that
            // we can't reach the bridgehead, or that the bridgehead can't reach
            // the remote source.

            // Trim name by one part
            ret = WrappedTrimDSNameBy( pszDn, 1, &pszBridgeheadDn );
            Assert( !ret );
            if ( (!findFailure( pConnFailures, pszBridgeheadDn, &dsFirstFailure, &cNumFailures, &dwLastResult )) &&
                 (!findFailure( pConnFailures, *ppszFromServer, &dsFirstFailure, &cNumFailures, &dwLastResult )) &&
                 (!findFailure( pLinkFailures, *ppszFromServer, &dsFirstFailure, &cNumFailures, &dwLastResult )) ) {
                dsFirstFailure = 0;
                cNumFailures = 0;
                dwLastResult = 0;
            }
            PrintMsg(REPADMIN_BRIDGEHEADS_DATA_3, 
                     DSTimeToDisplayString(dsFirstFailure, szTime), cNumFailures, Win32ErrToString(dwLastResult) );
            PrintMsg(REPADMIN_PRINT_CR);

            // ms-DS-ReplicatesNCReason
            ppszNcReason = ldap_get_valuesW(hld, pldmConnEntry, L"mS-DS-ReplicatesNCReason");
            // See if new attribute written by post-b3 server
            if (ppszNcReason) {
                DWORD dwReason, cbLength;
                PVOID pvData;
                LPWSTR pszNcDn;

                if (!fVerbose) { PrintMsg(REPADMIN_PRINT_STR_NO_CR, L"                " ); } // end of line
                for ( i = 0; i < ldap_count_valuesW(ppszNcReason); i++ ) {
                    if (!decodeLdapDistnameBinary(
                                                 ppszNcReason[i], &pvData, &cbLength, &pszNcDn)) {
                        PrintMsg(REPADMIN_SHOWCONN_INVALID_DISTNAME_BIN_VAL,
                                ppszNcReason[i] );
                        break;
                    }
                    if (!fVerbose) {
                        ppszRDNs = ldap_explode_dnW(pszNcDn, 1);
                        if (NULL != ppszRDNs) {
                            PrintMsg(REPADMIN_PRINT_STR_NO_CR, L" ");
                            PrintMsg(REPADMIN_PRINT_STR_NO_CR, ppszRDNs[0] );
                            ldap_value_freeW(ppszRDNs);
                        } else {
                            REPORT_LD_STATUS(LdapGetLastError());	
                        }
                    } else {
                        ShowBridgeheadNeighbor( hld, (i == 0),
                                                pszBridgeheadDn, pszNcDn, *ppszFromServer );
                    }

                    free( pvData );
                }

                if(fVerbose){
                    // After we show the bridghead neighbors info, we need
                    // to reprint the header, because otherwise the output
                    // is very confusing.
                    PrintMsg(REPADMIN_BRIDGEHEADS_HDR);
                }

                ldap_value_freeW(ppszNcReason);
                if (!fVerbose) { PrintMsg(REPADMIN_PRINT_CR); } // end of line
            }

            ldap_memfreeW(pszDn);
            ldap_value_freeW(ppszFromServer);
            free( pszBridgeheadDn );

        } // end for more entries in a single page


        ldap_msgfree(pldmConnResults);
        pldmConnResults = NULL;

        ldStatus = ldap_get_next_page_s(hld,
                                         pSearch,
                                         0,
                                         DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                         &ulTotalEstimate,
                                         &pldmConnResults);
    } // End while more pages to search
    if (ldStatus != LDAP_NO_RESULTS_RETURNED) {
        CHK_LD_STATUS(ldStatus);
    }

    if (pConnFailures) {
        DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pConnFailures);
        pConnFailures = NULL;
    }
    if (pLinkFailures) {
        DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pLinkFailures);
        pLinkFailures = NULL;
    }

    ldStatus1 = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(ldStatus1);

    ret = LdapMapErrorToWin32( ldStatus );

    return ret;
}

int
ShowIstgSite(
    LDAP *          hld,
    HANDLE          hDS,
    SHOW_ISTG_FUNCTION_TYPE eFunc,
    BOOL fVerbose
    )
{
    int ret = 0;
    int             ldStatus;
    LPWSTR          rgpszRootAttrsToRead[] = {L"configurationNamingContext",
                                              L"dsServiceName",
                                              L"dnsHostName",
                                              NULL};
    static WCHAR    wszSitesRdn[] = L"CN=Sites,";
    LDAPMessage *   pRootResults = NULL;
    LPWSTR *        ppszConfigNC = NULL;
    LPWSTR *        ppszDsServiceName = NULL;
    LPWSTR *        ppszServiceRDNs = NULL;
    LPWSTR *        ppszDnsHostName = NULL;
    LPWSTR          pszSitesContainer = NULL;

    // What's the DN of the config NC?
    ldStatus = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)",
                              rgpszRootAttrsToRead, 0, &pRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    ppszConfigNC = ldap_get_valuesW(hld, pRootResults,
                                    L"configurationNamingContext");
    if (NULL == ppszConfigNC) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    ppszDsServiceName = ldap_get_valuesW(hld, pRootResults,
                                    L"dsServiceName");
    if (NULL == ppszDsServiceName) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    ppszDnsHostName = ldap_get_valuesW(hld, pRootResults,
                                    L"dnsHostName");
    if (NULL == ppszDnsHostName) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }

    // Build the Sites Container DN
    pszSitesContainer = malloc( ( wcslen( *ppszConfigNC ) * sizeof( WCHAR ) ) +
                                sizeof( wszSitesRdn ) );
    CHK_ALLOC( pszSitesContainer );
    wcscpy( pszSitesContainer, wszSitesRdn );
    wcscat( pszSitesContainer, *ppszConfigNC );

    // Get the site name
    ppszServiceRDNs = ldap_explode_dnW(*ppszDsServiceName, 1);
    if (ppszServiceRDNs == NULL) {
        REPORT_LD_STATUS(LdapGetLastError());	
        ret = ERROR_DS_DRA_BAD_DN;
        goto cleanup;
    }

    switch(eFunc) {
    case SHOW_ISTG_LATENCY:
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_LATENCY_FOR_SITE, 
                ppszServiceRDNs[3], *ppszDnsHostName );
        ret = ShowSiteLatency( hld, hDS, fVerbose, pszSitesContainer );
        break;
    case SHOW_ISTG_BRIDGEHEADS:
    {
        LPWSTR pszSiteDn;
        // Trim name by 3 parts
        // Remove NTDS Settings, <server>, Servers
        ret = WrappedTrimDSNameBy( *ppszDsServiceName, 3, &pszSiteDn );
        Assert( !ret );

        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_SHOWISTG_BRDIGEHEADS,
                ppszServiceRDNs[3], *ppszDnsHostName );
        ret = ShowSiteBridgeheads( hld, hDS, fVerbose, pszSiteDn );
        free( pszSiteDn );
        break;
    }
    }

    // Cleanup
cleanup:

    if (ppszConfigNC) {
        ldap_value_freeW(ppszConfigNC);
    }
    if (ppszServiceRDNs) {
        ldap_value_freeW(ppszServiceRDNs);
    }
    if (ppszDsServiceName) {
        ldap_value_freeW(ppszDsServiceName);
    }
    if (ppszDnsHostName) {
        ldap_value_freeW(ppszDnsHostName);
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    if (pszSitesContainer) {
        free( pszSitesContainer );
    }

    return ret;
}

int
ShowIstgServerToSite(
    LDAP *hldHome,
    SHOW_ISTG_FUNCTION_TYPE eFunc,
    BOOL fVerbose,
    LPWSTR pszISTG
    )
{
    int ret = 0;
    int             ldStatus;
    ULONG           secondary;
    LDAP *          hld = NULL;
    HANDLE          hDS;
    LPWSTR          rgpszBaseAttrsToRead[] = {L"dnsHostName",
                                              NULL };
    LDAPMessage *   pBaseResults;
    LPWSTR *        ppszDnsHostName;
    LPWSTR          pszDSA;
    ULONG           ulOptions;

    // What's the dns host name of this object?
    ldStatus = ldap_search_sW(hldHome, pszISTG, LDAP_SCOPE_BASE, L"(objectClass=*)",
                              rgpszBaseAttrsToRead, 0, &pBaseResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pBaseResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    ppszDnsHostName = ldap_get_valuesW(hldHome, pBaseResults,
                                    L"dnsHostName");
    if (NULL == ppszDnsHostName) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    pszDSA = *ppszDnsHostName;

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Get a DS Handle too
    ret = DsBindWithCredW(pszDSA,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                          &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszDSA, ret);
        return ret;
    }

    ret = ShowIstgSite( hld, hDS, eFunc, fVerbose );

    ldap_value_freeW(ppszDnsHostName);
    ldap_msgfree(pBaseResults);

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

cleanup:

    if (hld != NULL) {
        ldap_unbind(hld);
    }

    return ret;
}

int
ShowIstg(
    LDAP *hld,
    SHOW_ISTG_FUNCTION_TYPE eFunc,
    BOOL fVerbose
    )
{
    int ret = 0;
    int             ldStatus;
    DWORD           status;
    BOOL            result;
    LPWSTR          rgpszRootAttrsToRead[] = {L"configurationNamingContext",
                                              L"dsServiceName",
                                              L"dnsHostName",
                                              NULL};
    static WCHAR    wszSitesRdn[] = L"CN=Sites,";
    static LPWSTR   rgpszSSAttrs[] = {L"interSiteTopologyGenerator", NULL};
    LDAPMessage *   pRootResults = NULL;
    LPWSTR *        ppszConfigNC = NULL;
    LPWSTR *        ppszDsServiceName = NULL;
    LPWSTR *        ppszServiceRDNs = NULL;
    LPWSTR *        ppszDnsHostName = NULL;
    LPWSTR          pszSitesContainer = NULL;
    LDAPSearch *    pSearch;
    LDAPMessage *   pResults;
    LDAPMessage *   pEntry;
    ULONG           ulTotalEstimate;

    // What's the DN of the config NC?
    ldStatus = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)",
                              rgpszRootAttrsToRead, 0, &pRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    ppszConfigNC = ldap_get_valuesW(hld, pRootResults,
                                    L"configurationNamingContext");
    if (NULL == ppszConfigNC) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    ppszDsServiceName = ldap_get_valuesW(hld, pRootResults,
                                    L"dsServiceName");
    if (NULL == ppszDsServiceName) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    ppszDnsHostName = ldap_get_valuesW(hld, pRootResults,
                                    L"dnsHostName");
    if (NULL == ppszDnsHostName) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }

    // Build the Sites Container DN
    pszSitesContainer = malloc( ( wcslen( *ppszConfigNC ) * sizeof( WCHAR ) ) +
                                sizeof( wszSitesRdn ) );
    CHK_ALLOC( pszSitesContainer );
    wcscpy( pszSitesContainer, wszSitesRdn );
    wcscat( pszSitesContainer, *ppszConfigNC );

    // Get the site name
    ppszServiceRDNs = ldap_explode_dnW(*ppszDsServiceName, 1);
    if (NULL == ppszServiceRDNs) {
        REPORT_LD_STATUS(LdapGetLastError());	
        ret = ERROR_DS_DRA_BAD_DN;
        goto cleanup;
    }

    PrintMsg(REPADMIN_SHOWISTG_GATHERING_TOPO, 
            ppszServiceRDNs[3], *ppszDnsHostName );

    // Search for all Site Settings Objects

    pSearch = ldap_search_init_pageW(hld,
				    pszSitesContainer,
				    LDAP_SCOPE_SUBTREE,
				    L"(objectCategory=ntdsSiteSettings)",
				    rgpszSSAttrs,
				    FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
	CHK_LD_STATUS(LdapGetLastError());	
    }

    ldStatus = ldap_get_next_page_s(hld,
				     pSearch,
				     0,
				     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
				     &ulTotalEstimate,
				     &pResults);
    if (ldStatus == LDAP_SUCCESS) {
        if (eFunc == SHOW_ISTG_PRINT) {
            PrintMsg(REPADMIN_SHOWISTG_HDR);
        }
    }
    while(ldStatus == LDAP_SUCCESS){

        for (pEntry = SAFE_LDAP_FIRST_ENTRY(hld, pResults);
	     NULL != pEntry;
	     pEntry = ldap_next_entry(hld, pEntry)) {

            LPWSTR          pszDN;
            LPWSTR *        ppszRDNs1, * ppszRDNs2;
            LPWSTR *        ppszISTG;
            LPWSTR          pszSiteRDN;

	    pszDN = ldap_get_dnW(hld, pEntry);
	    if (NULL == pszDN) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }

	    ppszRDNs1 = ldap_explode_dnW(pszDN, 1);
            if (ppszRDNs1 == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                ldap_memfreeW(pszDN);
                continue;
            }
	    pszSiteRDN = ppszRDNs1[1];

            ppszISTG = ldap_get_valuesW(hld, pEntry,
                                    L"interSiteTopologyGenerator");

            if (ppszISTG) {
                LPWSTR pszISTGRDN;
                LPWSTR pszISTG;

                // Trim name by one part, remove NTDS Settings
                ret = WrappedTrimDSNameBy( *ppszISTG, 1, &pszISTG );
                Assert( !ret );

                switch (eFunc) {
                case SHOW_ISTG_PRINT:
                    ppszRDNs2 = ldap_explode_dnW(*ppszISTG, 1);
                    if (NULL != ppszRDNs2) {
                        pszISTGRDN = ppszRDNs2[1];
                        PrintMsg(REPADMIN_SHOWISTG_DATA_1, pszSiteRDN, pszISTGRDN );
                        ldap_value_freeW(ppszRDNs2);
                    } else {
                        REPORT_LD_STATUS(LdapGetLastError());	
                    }
                    break;
                case SHOW_ISTG_LATENCY:
                    (void) ShowIstgServerToSite( hld, eFunc, fVerbose, pszISTG );
                    break;
                case SHOW_ISTG_BRIDGEHEADS:
                    (void) ShowIstgServerToSite( hld, eFunc, fVerbose, pszISTG );
                    break;
                }

                ldap_value_freeW(ppszISTG);
                free( pszISTG );
            }

            ldap_memfreeW(pszDN);
	    ldap_value_freeW(ppszRDNs1);
        }

	ldap_msgfree(pResults);
	pResults = NULL;

	ldStatus = ldap_get_next_page_s(hld,
                                     pSearch,
                                     0,
                                     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                     &ulTotalEstimate,
                                     &pResults);
    } // end while more pages to search.
    if(ldStatus != LDAP_NO_RESULTS_RETURNED){
        CHK_LD_STATUS(ldStatus);
    }

    ldStatus = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(ldStatus);

    // Cleanup
cleanup:

    if (ppszConfigNC) {
        ldap_value_freeW(ppszConfigNC);
    }
    if (ppszServiceRDNs) {
        ldap_value_freeW(ppszServiceRDNs);
    }
    if (ppszDsServiceName) {
        ldap_value_freeW(ppszDsServiceName);
    }
    if (ppszDnsHostName) {
        ldap_value_freeW(ppszDnsHostName);
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    if (pszSitesContainer) {
        free( pszSitesContainer );
    }

    return ret;

}

int
Latency(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    ULONG           secondary;
    LPWSTR          pszDSA = NULL;
    BOOL            fVerbose = FALSE;
    LDAP *          hld;
    HANDLE          hDS;
    int             iArg;
    int             ldStatus;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/v")
            || !_wcsicmp(argv[iArg], L"/verbose")) {
            fVerbose = TRUE;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    PrintMsg(REPADMIN_LATENCY_DISCLAIMER);

    ret = ShowIstg( hld, SHOW_ISTG_LATENCY, fVerbose );

    ldap_unbind(hld);

    return ret;
}

int
Istg(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    ULONG           secondary;
    LPWSTR          pszDSA = NULL;
    BOOL            fVerbose = FALSE;
    LDAP *          hld;
    HANDLE          hDS;
    int             iArg;
    int             ldStatus;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/v")
            || !_wcsicmp(argv[iArg], L"/verbose")) {
            fVerbose = TRUE;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    ret = ShowIstg( hld, SHOW_ISTG_PRINT, fVerbose );

    ldap_unbind(hld);

    return ret;
}

int
Bridgeheads(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    ULONG           secondary;
    LPWSTR          pszDSA = NULL;
    BOOL            fVerbose = FALSE;
    LDAP *          hld;
    HANDLE          hDS;
    int             iArg;
    int             ldStatus;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/v")
            || !_wcsicmp(argv[iArg], L"/verbose")) {
            fVerbose = TRUE;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    ret = ShowIstg( hld, SHOW_ISTG_BRIDGEHEADS, fVerbose );

    ldap_unbind(hld);

    return ret;
}

int
TestHook(
    int     argc,
    LPWSTR  argv[]
    )
{
    int         ret = 0;
    ULONG       secondary;
    LPWSTR      pszDSA = NULL;
    LDAP *      hld;
    HANDLE      hDS;
    int         iArg;
    int         ldStatus;
    LPWSTR      pszValue = NULL;
    ULONG       ulValue = 2048;
    LPWSTR      rgpszValues[2];
    LDAPModW    ModOpt = {LDAP_MOD_REPLACE, L"replTestHook", rgpszValues};
    LDAPModW *  rgpMods[] = {&ModOpt, NULL};
    ULONG       ulOptions;

    pszValue = malloc(ulValue * sizeof(WCHAR));
    if (pszValue==NULL) {
	return ERROR_NOT_ENOUGH_MEMORY; 
    }
    wcscpy(pszValue, L"");
    // Parse command-line arguments.
    // Default to local DSA.

    // the first (only the first) argument can be a DSA
    iArg = 2;
    if ((argv[iArg][0]!=L'+') && (argv[iArg][0]!=L'-')) {
	// assume it's a DSA
	pszDSA = argv[iArg++];
    }


    for (; iArg < argc; iArg++) {
        if ((wcslen(pszValue) + 1 + wcslen(argv[iArg]) + 1)
                >= ulValue) { 
	    // allocate a bigger array and copy in contents
	    WCHAR * pszNewValue = NULL;
	    
	    ulValue = ulValue*2;
	    pszNewValue = realloc(pszNewValue, ulValue*sizeof(WCHAR));  
	    if (pszNewValue==NULL) {
		return ERROR_NOT_ENOUGH_MEMORY;
	    }

	    memcpy(pszNewValue, pszValue, ulValue*sizeof(WCHAR));
	    free(pszValue);
	    pszValue = pszNewValue; 

	    // return and re-loop
	    iArg--;
	    continue;
	}
	if (pszValue[0]) {
	    wcscat(pszValue, L" ");
	}  
	wcscat(pszValue, argv[iArg]); 
    }

    rgpszValues[0] = pszValue;
    rgpszValues[1] = NULL;

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Modify.
    ldStatus = ldap_modify_sW(hld, NULL, rgpMods);
    CHK_LD_STATUS(ldStatus);

    PrintMsg(REPADMIN_TESTHOOK_SUCCESSFULLY_INVOKED, pszValue);
    free(pszValue);

    return 0;
}

int
DsaGuid(
    int     argc,
    LPWSTR  argv[]
    )
{
    int     ret = 0;
    LDAP *  hld;
    int     iArg;
    int     ldStatus;
    LPWSTR  pszDSA;
    LPWSTR  pszUuid;
    UUID    invocationID;
    ULONG   ulOptions;

    if (argc < 3) {
        PrintMsg(REPADMIN_DSAGUID_NEED_INVOC_ID);
        return ERROR_INVALID_PARAMETER;
    } else if (argc == 3) {
        pszUuid = argv[2];
        pszDSA = L"localhost";
    } else {
        pszDSA = argv[2];
        pszUuid = argv[3];
    }

    ret = UuidFromStringW(pszUuid, &invocationID);
    if (ret) {
        PrintFuncFailed(L"UuidFromString", ret);
        return ret;
    }

    // Connect.
    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Translate DSA invocationID / objectGuid.
    BuildGuidCache(hld);
    PrintMsg(REPADMIN_DSAGUID_DATA_LINE, pszUuid, GetGuidDisplayName(&invocationID));

    return 0;
}

int
ShowProxy(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             iArg;
    LPWSTR          pszNC = NULL;
    LPWSTR          pszDSA = NULL;
    LPWSTR          pszMatch = NULL; 
    LDAP *          hld;
    ULONG           ulOptions;
    int             ldStatus;
    LDAPMessage *   pRootResults = NULL;
    int             ret = 0;
    LPWSTR          *ppszDefaultNc = NULL;
    LDAPSearch *    pSearch = NULL;
    LPWSTR          pszContainer = NULL;
#define INFRASTRUCTURE_CONTAINER_W L"cn=Infrastructure,"
    LPWSTR          pszSearchBase;
    DWORD           dwSearchScope;
    LPWSTR          rgpszUpdateAttrsToRead[] = {
        // Code below depends on this order
        L"objectGuid", L"proxiedObjectName", NULL };
    LDAPControlW     ctrlShowDeleted = { LDAP_SERVER_SHOW_DELETED_OID_W };
    LDAPControlW *   rgpctrlServerCtrls[] = { &ctrlShowDeleted, NULL };
    LDAPMessage *   pldmUpdateResults = NULL;
    LDAPMessage *   pldmUpdateEntry;
    BOOL            fVerbose = FALSE;
    BOOL            fMovedObjectSearch = FALSE;
    LPWSTR          pszLdapHostList = NULL;

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/v")
            || !_wcsicmp(argv[iArg], L"/verbose")) {
            fVerbose = TRUE;
        } else if (!_wcsicmp(argv[iArg], L"/m")
            || !_wcsicmp(argv[iArg], L"/moved")
            || !_wcsicmp(argv[iArg], L"/movedobject")) {
            fMovedObjectSearch = TRUE;
        }
        else if ((NULL == pszNC) && (NULL != wcschr(argv[iArg], L'='))) {
            pszNC = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else if (NULL == pszMatch) {
            pszMatch = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Select our target server
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }
    // Bind on the GC port first if available
    pszLdapHostList = (LPWSTR) malloc(
        (wcslen(pszDSA) * 2 + 15) * sizeof( WCHAR ) );
    if (pszLdapHostList == NULL) {
        ret = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    swprintf( pszLdapHostList, L"%s:%d %s:%d",
              pszDSA, LDAP_GC_PORT,
              pszDSA, LDAP_PORT );

    hld = ldap_initW(pszLdapHostList, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return ERROR_DS_UNAVAILABLE;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    // Don't follow referrals.
    ulOptions = PtrToUlong(LDAP_OPT_OFF);
    (void)ldap_set_optionW( hld, LDAP_OPT_REFERRALS, &ulOptions );

    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // If NC not specified, get default nc for this server
    if (NULL == pszNC) {
        LPWSTR rgpszRootAttrsToRead[] = {L"defaultNamingContext", NULL};

        ldStatus = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)",
                                  rgpszRootAttrsToRead, 0, &pRootResults);
        CHK_LD_STATUS(ldStatus);
        if (NULL == pRootResults) {
            ret = ERROR_DS_OBJ_NOT_FOUND;
            goto cleanup;
        }

        ppszDefaultNc = ldap_get_valuesW(hld, pRootResults, rgpszRootAttrsToRead[0] );
        if (NULL == ppszDefaultNc) {
            ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
            goto cleanup;
        }
        pszNC = *ppszDefaultNc;
        PrintMsg(REPADMIN_SHOWPROXY_SEARCHING_NC, pszNC);
    }

    // Construct the search container
    if (fMovedObjectSearch) {
        pszSearchBase = pszNC;
        dwSearchScope = LDAP_SCOPE_BASE;
    } else {
        pszContainer = malloc( ( wcslen( INFRASTRUCTURE_CONTAINER_W ) +
                                 wcslen( pszNC ) +
                                 1) * sizeof( WCHAR ) );
        if (pszContainer == NULL) {
            ret = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        wcscpy( pszContainer, INFRASTRUCTURE_CONTAINER_W );
        wcscat( pszContainer, pszNC );

        pszSearchBase = pszContainer;
        dwSearchScope = LDAP_SCOPE_ONELEVEL;
    }

    // Search for proxy objects on this server under the container
    //
    // ***************************************************************************************
    //

    pSearch = ldap_search_init_pageW(hld,
                                     pszSearchBase,
                                     dwSearchScope,
                                     L"(proxiedObjectName=*)",  // this is indexed
                                     rgpszUpdateAttrsToRead,
                                     FALSE,
                                     rgpctrlServerCtrls, NULL,
                                     0, 0, NULL);
    if(pSearch == NULL){
        CHK_LD_STATUS(LdapGetLastError());
    }

    ldStatus = ldap_get_next_page_s(hld,
                                    pSearch,
                                    0,
                                    DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                    NULL,
                                    &pldmUpdateResults);

    while (ldStatus == LDAP_SUCCESS) {

        for (pldmUpdateEntry = SAFE_LDAP_FIRST_ENTRY(hld, pldmUpdateResults);
            NULL != pldmUpdateEntry;
            pldmUpdateEntry = ldap_next_entry(hld, pldmUpdateEntry))
        {
            LPWSTR *ppszProxiedObjectName;
            DWORD cbLength = 0;
            PVOID pvData = NULL;
            LPWSTR pszTargetDn = NULL;

            ppszProxiedObjectName = ldap_get_valuesW(hld, pldmUpdateEntry,
                                                     rgpszUpdateAttrsToRead[1] );
            // By virtue of search filter, this attr should be present
            if (!decodeLdapDistnameBinary(
                *ppszProxiedObjectName, &pvData, &cbLength, &pszTargetDn)) {
                PrintMsg(REPADMIN_SHOWCONN_INVALID_DISTNAME_BIN_VAL,
                        *ppszProxiedObjectName );
                goto loop_cleanup;
            }

            if ( pszMatch &&
                 pszTargetDn &&
                 !wcsstr( pszTargetDn, pszMatch ) ) {
                // No match, skip
                goto loop_cleanup;
            }

            PrintMsg(REPADMIN_PRINT_CR);
            // DN
            if (fVerbose || fMovedObjectSearch) {
                LPWSTR pszDn;
                pszDn = ldap_get_dnW(hld, pldmUpdateEntry);
                if (NULL == pszDn) {
                    REPORT_LD_STATUS(LdapGetLastError());	
                    continue;
                }
                if (fMovedObjectSearch)
                    PrintMsg(REPADMIN_SHOWPROXY_OBJECT_DN, pszDn);
                else
                    PrintMsg(REPADMIN_SHOWPROXY_PROXY_DN, pszDn);
                ldap_memfreeW(pszDn);
            }

            // objectGuid
            if (fVerbose || fMovedObjectSearch) {
                struct berval **ppbvGuid = NULL;
                GUID *pGuid;

                ppbvGuid = ldap_get_values_lenW(hld, pldmUpdateEntry, rgpszUpdateAttrsToRead[0]);
                if (NULL == ppbvGuid) {
                    REPORT_LD_STATUS(LdapGetLastError());	
                    continue;
                }
                pGuid = (GUID *) ppbvGuid[0]->bv_val;
                PrintMsg(REPADMIN_SHOWPROXY_OBJECT_GUID, GetStringizedGuid( pGuid ));
                ldap_value_free_len(ppbvGuid);
            }

            // proxiedObjectName
            if (fMovedObjectSearch)
                PrintMsg(REPADMIN_SHOWPROXY_MOVED_FROM_NC, pszTargetDn);
            else
                PrintMsg(REPADMIN_SHOWPROXY_MOVED_TO_DN, pszTargetDn );
            if (cbLength >= 2 * sizeof(DWORD)) {
                DWORD dwProxyType, dwProxyEpoch;

                dwProxyType = ntohl( *( (LPDWORD) (pvData) ) );
                dwProxyEpoch = ntohl( *( (LPDWORD) ( ((PBYTE)pvData) + sizeof(DWORD)) ) );
                PrintMsg(REPADMIN_SHOWPROXY_PROXY_TYPE, dwProxyType);
                switch (dwProxyType) {
                case 0: 
                    PrintMsg(REPADMIN_SHOWPROXY_PROXY_TYPE_MOVED_OBJ);
                    break;
                case 1:
                    PrintMsg(REPADMIN_SHOWPROXY_PROXY_TYPE_PROXY);
                    break;
                default:
                    PrintMsg(REPADMIN_SHOWPROXY_PROXY_TYPE_UNKNOWN);
                    break;
                }
                PrintMsg(REPADMIN_PRINT_CR);
                PrintMsg(REPADMIN_SHOWPROXY_PROXY_EPOCH, dwProxyEpoch);
            }

        loop_cleanup:

            if (pvData) {
                free( pvData );
            }
            ldap_value_freeW(ppszProxiedObjectName);

        } // end for more entries in a single page

        ldap_msgfree(pldmUpdateResults);
        pldmUpdateResults = NULL;

        ldStatus = ldap_get_next_page_s(hld,
                                        pSearch,
                                        0,
                                        DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                        NULL,
                                        &pldmUpdateResults);
    } // End while more pages to search
    if (ldStatus != LDAP_NO_RESULTS_RETURNED) {
        CHK_LD_STATUS(ldStatus);
    }

cleanup:

    ldap_unbind(hld);

    if (ppszDefaultNc) {
        ldap_value_freeW(ppszDefaultNc);
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    if (pszContainer) {
        free( pszContainer );
    }
    if (pszLdapHostList) {
        free( pszLdapHostList );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\repadmin\reputil.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   reputil.c - utility routines

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

    Rsraghav has been in here too

    Will Lees    wlees   Feb 11, 1998
         Converted code to use ntdsapi.dll functions

    Aaron Siegel t-asiege 18 June 1998
         Added support for DsReplicaSyncAll

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "repadmin.h"

LPWSTR
Win32ErrToString(
    IN  ULONG   dwMsgId
    )
{
    static WCHAR szError[4096];

    DWORD       cch;

    cch = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
                          | FORMAT_MESSAGE_IGNORE_INSERTS,
                         NULL,
                         dwMsgId,
                         GetSystemDefaultLangID(),
                         szError,
                         ARRAY_SIZE(szError),
                         NULL);
    if (0 != cch) {
        // Chop off trailing \r\n.
        Assert(L'\r' == szError[wcslen(szError)-2]);
        Assert(L'\n' == szError[wcslen(szError)-1]);
        szError[wcslen(szError)-2] = L'\0';
    }
    else {
        swprintf(szError, L"Can't retrieve message string %d (0x%x), error %d.",
                 dwMsgId, dwMsgId, GetLastError());
    }

    return szError;
}

LPWSTR
NtdsmsgToString(
    IN  ULONG   dwMsgId
    )
{
    static WCHAR szError[4096];
    static HMODULE hmodNtdsmsg = NULL;

    DWORD       cch;

    if (NULL == hmodNtdsmsg) {
        hmodNtdsmsg = LoadLibrary("ntdsmsg.dll");
    }
    
    if (NULL == hmodNtdsmsg) {
        swprintf(szError, L"Can't load ntdsmsg.dll, error %d.",
                 GetLastError());
    } else {
        DWORD iTry;
        
        for (iTry = 0; iTry < 4; iTry++) {
            DWORD dwTmpMsgId = dwMsgId;

            switch (iTry) {
            case 0:
                dwTmpMsgId = dwMsgId;
                break;

            case 1:
                dwTmpMsgId = (dwMsgId & 0x3FFFFFFF) | 0x40000000;
                break;

            case 2:
                dwTmpMsgId = (dwMsgId & 0x3FFFFFFF) | 0x80000000;
                break;

            case 3:
                dwTmpMsgId = (dwMsgId & 0x3FFFFFFF) | 0xC0000000;
                break;
            }

            cch = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE
                                  | FORMAT_MESSAGE_IGNORE_INSERTS,
                                 hmodNtdsmsg,
                                 dwTmpMsgId,
                                 GetSystemDefaultLangID(),
                                 szError,
                                 ARRAY_SIZE(szError),
                                 NULL);
            if (0 != cch) {
                // Chop off trailing \r\n.
                Assert(L'\r' == szError[wcslen(szError)-2]);
                Assert(L'\n' == szError[wcslen(szError)-1]);
                szError[wcslen(szError)-2] = L'\0';
                break;
            }
        }

        if (0 == cch) {
            swprintf(szError, L"Can't retrieve message string %d (0x%x), error %d.",
                     dwMsgId, dwMsgId, GetLastError());
        }
    }

    return szError;
}

LPWSTR
GetNtdsDsaDisplayName(
    IN  LPWSTR pszDsaDN
    )
{
    static WCHAR  szDisplayName[2 + 2*MAX_RDN_SIZE + 20];
    LPWSTR *      ppszRDNs;
    LPWSTR        pszSite;
    LPWSTR        pszServer;

    if (NULL == pszDsaDN) {
        return L"(null)";
    }

    ppszRDNs = ldap_explode_dnW(pszDsaDN, 1);
    
    if ((NULL == ppszRDNs)
        || (4 > ldap_count_valuesW(ppszRDNs))) {
        // No memory or bad DN -- return what we have.
        lstrcpynW(szDisplayName, pszDsaDN, ARRAY_SIZE(szDisplayName));
    } else {
        pszSite = ppszRDNs[3];
        pszServer = ppszRDNs[1];
    
        // Check for deleted NTDS-DSA object
        wsprintfW(szDisplayName, L"%ls\\%ls", pszSite, pszServer);
        if (DsIsMangledRdnValueW( ppszRDNs[0], wcslen(ppszRDNs[0]),
                                 DS_MANGLE_OBJECT_RDN_FOR_DELETION )) {
            wcscat( szDisplayName, L" (deleted DSA)" );
        }
    
        ldap_value_freeW(ppszRDNs);
    }

    return szDisplayName;
}

LPWSTR
GetNtdsSiteDisplayName(
    IN  LPWSTR pszSiteDN
    )
{
    static WCHAR  szDisplayName[2 + 2*MAX_RDN_SIZE + 20];
    LPWSTR *      ppszRDNs;
    LPWSTR        pszSite;

    if (NULL == pszSiteDN) {
        return L"(null)";
    }

    ppszRDNs = ldap_explode_dnW(pszSiteDN, 1);
    Assert(NULL != ppszRDNs);
    Assert(2 < ldap_count_valuesW(ppszRDNs));

    pszSite = ppszRDNs[1];

    // Check for deleted NTDS-Site object
    wsprintfW(szDisplayName, L"%ls", pszSite);
    if (DsIsMangledRdnValueW( ppszRDNs[0], wcslen(ppszRDNs[0]),
                             DS_MANGLE_OBJECT_RDN_FOR_DELETION)) {
        wcscat( szDisplayName, L" (deleted Site)" );
    }

    ldap_value_freeW(ppszRDNs);

    return szDisplayName;
}

LPWSTR
GetTransportDisplayName(
    IN  LPWSTR pszTransportDN   OPTIONAL
    )
{
    static WCHAR  szDisplayName[1 + MAX_RDN_SIZE];
    LPWSTR *      ppszRDNs;

    if (NULL == pszTransportDN) {
        return L"RPC";
    }

    ppszRDNs = ldap_explode_dnW(pszTransportDN, 1);
    if (NULL == ppszRDNs) {
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
        exit(ERROR_OUTOFMEMORY);
    }

    wcscpy(szDisplayName, ppszRDNs[0]);

    ldap_value_freeW(ppszRDNs);

    return szDisplayName;
}

ULONG
GetPublicOptionByNameW(
    OPTION_TRANSLATION * Table,
    LPWSTR pwszPublicOption
    )
{
    while (Table->pwszPublicOption) {
        if (_wcsicmp( pwszPublicOption, Table->pwszPublicOption ) == 0) {
            return Table->PublicOption;
        }
        Table++;
    }

    PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, pwszPublicOption);
    return 0;
}

LPWSTR
GetOptionsString(
    IN  OPTION_TRANSLATION *  Table,
    IN  ULONG                 PublicOptions
    )
{
    static WCHAR wszOptions[1024];
    DWORD i, publicOptions;
    BOOL fFirstOption = TRUE;

    if (0 == PublicOptions) {
        wcscpy(wszOptions, L"(no options)");
    }
    else {
        *wszOptions = L'\0';

        for(i = 0; 0 != Table[i].InternalOption; i++) {
            if (PublicOptions & Table[i].PublicOption) {
                if (!fFirstOption) {
                    wcscat(wszOptions, L" ");
                }
                else {
                    fFirstOption = FALSE;
                }

                wcscat(wszOptions, Table[i].pwszPublicOption);
                PublicOptions &= ~Table[i].PublicOption;
            }
        }

        if (0 != PublicOptions) {
            // A new public option has been added that this incarnation of
            // repadmin doesn't understand.  Display its hex value.
            if (!fFirstOption) {
                wcscat(wszOptions, L" ");
            }

            swprintf(wszOptions+wcslen(wszOptions), L"0x%x", PublicOptions);
        }
    }

    return wszOptions;
}


int
GetRootDomainDNSName(
    IN  LPWSTR   pszDSA,
    OUT LPWSTR * ppszRootDomainDNSName
    )
{
    NTSTATUS                    ntStatus;
    LSA_OBJECT_ATTRIBUTES       oa;
    LSA_HANDLE                  hPolicy;
    POLICY_DNS_DOMAIN_INFO *    pDnsDomainInfo;
    DWORD                       cchRootDomainDNSName;
    DWORD                       cbDSA;
    UNICODE_STRING              strDSA;
    UNICODE_STRING *            pstrDSA = NULL;

    // Ideally this should derive the enterprise root domain DNS name from the
    // NC names on the root DSE and DsCrackNames().  The method below won't work
    // in many cases where alternate credentials are supplied.  This function is
    // called only by the relatively rarely used /propcheck and /fullsyncall
    // functions, however.

    memset(&oa, 0, sizeof(oa));

    if ((NULL != pszDSA) && (0 != wcscmp(pszDSA, L"localhost"))) {
        cbDSA = sizeof(WCHAR) * wcslen(pszDSA);
        strDSA.Buffer = pszDSA;
        strDSA.Length = (USHORT) cbDSA;
        strDSA.MaximumLength = (USHORT) cbDSA;
        pstrDSA = &strDSA;
    }

    // Cache the DNS name of the root domain.
    ntStatus = LsaOpenPolicy(pstrDSA, &oa,
                             POLICY_VIEW_LOCAL_INFORMATION, &hPolicy);
    if (!NT_SUCCESS(ntStatus)) {
        PrintFuncFailed(L"LsaOpenPolicy", ntStatus);
        return ntStatus;
    }

    ntStatus = LsaQueryInformationPolicy(hPolicy, PolicyDnsDomainInformation,
                                         &pDnsDomainInfo);
    if (!NT_SUCCESS(ntStatus)) {
        PrintFuncFailed(L"LsaQueryInformationPolicy", ntStatus);
        return ntStatus;
    }

    cchRootDomainDNSName = pDnsDomainInfo->DnsForestName.Length/sizeof(WCHAR);
    *ppszRootDomainDNSName = (LPWSTR) malloc(sizeof(WCHAR) * (1 + cchRootDomainDNSName));

    if (NULL == *ppszRootDomainDNSName) {
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
        return STATUS_NO_MEMORY;
    }

    wcsncpy(*ppszRootDomainDNSName,
            pDnsDomainInfo->DnsForestName.Buffer,
            cchRootDomainDNSName);
    (*ppszRootDomainDNSName)[cchRootDomainDNSName] = L'\0';

    return STATUS_SUCCESS;
}


void
printBitField(
    DWORD BitField,
    WCHAR **ppszBitNames
    )

/*++

Routine Description:

Utility routine to stringize a bit mask with readable names

Arguments:

    BitField - Value to be decoded
    ppszBitNames - Table mapping bit position to string name

Return Value:

    None

--*/

{
    DWORD bit, mask;
    for( bit = 0, mask = 1; bit < 32; bit++, mask <<= 1 ) {
        if (!ppszBitNames[bit] ) {
            // That's all the fields we know about
            break;
        }
        if (BitField & mask) {
            PrintMsg(REPADMIN_PRINT_SPACE);
            PrintMsg(REPADMIN_PRINT_STR_NO_CR, ppszBitNames[bit]);
        }
    }
    PrintMsg(REPADMIN_PRINT_CR);
} /* printBitField */


DWORD
AllocConvertWideEx(
    IN  INT     nCodePage,
    IN  LPCSTR  StringA,
    OUT LPWSTR *pStringW
    )

/*++

Routine Description:

Stolen from ntdsapi\util.c
Helper routine to convert a narrow string to a newly allocated wide one

Arguments:

    StringA -
    pStringW -

Return Value:

    DWORD -

--*/

{
    DWORD numberWideChars, numberConvertedChars, status;
    LPWSTR stringW;

    if (pStringW == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (StringA == NULL) {
        *pStringW = NULL;
        return ERROR_SUCCESS;
    }

    // Get the needed length
    numberWideChars = MultiByteToWideChar(
        nCodePage,
        MB_PRECOMPOSED,
        StringA,
        -1,
        NULL,
        0);

    if (numberWideChars == 0) {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the new buffer
    stringW = LocalAlloc( LPTR, (numberWideChars + 1) * sizeof( WCHAR ) );
    if (stringW == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Do the conversion into the new buffer
    numberConvertedChars = MultiByteToWideChar(
        nCodePage,
        MB_PRECOMPOSED,
        StringA,
        -1,
        stringW,
        numberWideChars + 1);
    if (numberConvertedChars == 0) {
        LocalFree( stringW );
        return ERROR_INVALID_PARAMETER;
    }

    // return user parameter
    *pStringW = stringW;

    return ERROR_SUCCESS;
} /* allocConvertWide */


void
printSchedule(
    PBYTE pSchedule,
    DWORD cbSchedule
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE data = (PBYTE) (header + 1);
    DWORD day, hour;
    ULONG dow[] = { REPADMIN_SUN, REPADMIN_MON, REPADMIN_TUE,
                    REPADMIN_WED, REPADMIN_THU, REPADMIN_FRI,
                    REPADMIN_SAT };

    Assert( header->Size == cbSchedule );
    Assert( header->NumberOfSchedules == 1 );
    Assert( header->Schedules[0].Type == SCHEDULE_INTERVAL );

    PrintMsg(REPADMIN_SCHEDULE_HOUR_HDR);
    for( day = 0; day < 7; day++ ) {
        PrintMsg(dow[day]);
        PrintMsg(REPADMIN_PRINT_STR_NO_CR, L": ");
        for( hour = 0; hour < 24; hour++ ) {
            PrintMsg(REPADMIN_PRINT_HEX_NO_CR, (*data & 0xf));
            data++;
        }
        PrintMsg(REPADMIN_PRINT_CR);
    }
}


void
totalScheduleUsage(
    PVOID *ppContext,
    PBYTE pSchedule,
    DWORD cbSchedule,
    DWORD cNCs
    )

/*++

Routine Description:

Helper routine to total many usages of a schedule.  The counts for each quarter hour
are totaled. The final tally can also be printed.

Arguments:

    ppContext - Opaque context block
    if *ppContext = NULL, allocate a context block
    if *ppContext != NULL, use preallocated context block

    pSchedule - Schedule structure on a connection
    if pSchedule = NULL, print report and free context
    if pSchedule != NULL, add to totals

    cbSchedule - Schedule length

    cNCs - Number of NC's using this schedule

Return Value:

    None

--*/

{
    DWORD day, hour, quarter;
    PBYTE pbCounts = (PBYTE) *ppContext;
    ULONG dow[] = { REPADMIN_SUN, REPADMIN_MON, REPADMIN_TUE,
                    REPADMIN_WED, REPADMIN_THU, REPADMIN_FRI,
                    REPADMIN_SAT };

    if (!pbCounts) {
        *ppContext = pbCounts = calloc( 7 * 24 * 4, 1 ) ;
    }
    if (!pbCounts) {
        // No context, fail
        Assert( FALSE );
        return;
    }

    if (pSchedule) {
        PSCHEDULE header = (PSCHEDULE) pSchedule;
        PBYTE data = (PBYTE) (header + 1);

        Assert( header->Size == cbSchedule );
        Assert( header->NumberOfSchedules == 1 );
        Assert( header->Schedules[0].Type == SCHEDULE_INTERVAL );

        for( day = 0; day < 7; day++ ) {
            for( hour = 0; hour < 24; hour++ ) {
                if (*data & 0x1) (*pbCounts) += (BYTE) cNCs;
                pbCounts++;
                if (*data & 0x2) (*pbCounts) += (BYTE) cNCs;
                pbCounts++;
                if (*data & 0x4) (*pbCounts) += (BYTE) cNCs;
                pbCounts++;
                if (*data & 0x8) (*pbCounts) += (BYTE) cNCs;
                pbCounts++;

                data++;
            }
        }
    } else {

        PrintMsg(REPADMIN_SCHEDULE_LOADING);
        PrintMsg(REPADMIN_PRINT_STR, L"     ");
        for( hour = 0; hour < 12; hour++ ) {
            PrintTabMsg(3, REPADMIN_SCHEDULE_DATA_HOUR, hour);
        }
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_PRINT_STR, L"     ");
        for( hour = 0; hour < 12; hour++ ) {
            for( quarter = 0; quarter < 4; quarter++ ) {
                PrintMsg(REPADMIN_SCHEDULE_DATA_QUARTER, quarter);
            }
        }
        PrintMsg(REPADMIN_PRINT_CR);
        for( day = 0; day < 7; day++ ) {
            PrintMsg(dow[day]);
            PrintMsg(REPADMIN_PRINT_STR_NO_CR, L": ");
            for( hour = 0; hour < 12; hour++ ) {
                for( quarter = 0; quarter < 4; quarter++ ) {
                    PrintMsg(REPADMIN_SCHEDULE_DATA_HOUR, *pbCounts);
                    pbCounts++;
                }
            }
            PrintMsg(REPADMIN_PRINT_CR);
            PrintMsg(dow[day]);
            PrintMsg(REPADMIN_PRINT_STR_NO_CR, L": ");
            for( hour = 12; hour < 24; hour++ ) {
                for( quarter = 0; quarter < 4; quarter++ ) {
                    PrintMsg(REPADMIN_SCHEDULE_DATA_HOUR, *pbCounts);
                    pbCounts++;
                }
            }
            PrintMsg(REPADMIN_PRINT_CR);
        }

        free( *ppContext );
        *ppContext = NULL;
    }

} /* totalScheduleUsage */


void
raLoadString(
    IN  UINT    uID,
    IN  DWORD   cchBuffer,
    OUT LPWSTR  pszBuffer
    )
/*++

Routine Description:

    Load the string resource corresponding to the given ID into a buffer.

Arguments:

    uID (IN) - ID of string resource to load.

    cchBuffer (IN) - size in characters of pszBuffer.

    pszBuffer (OUT) - buffer to receive string.

Return Values:

    None.  Loads the null string on error.

--*/
{
    static HMODULE s_hMod = NULL;
    int cch;
    DWORD err;

    if (NULL == s_hMod) {
        s_hMod = GetModuleHandle(NULL);
    }

    cch = LoadStringW(s_hMod, uID, pszBuffer, cchBuffer);
    if (0 == cch) {
        err = GetLastError();
        wprintf(L"** Cannot load string resource %d, error %d:\n"
                L"**     %ls\n",
                uID, err, Win32ErrToString(err));
        Assert(!"Cannot load string resource!");
        *pszBuffer = L'\0';
    }
}

void
formatMsgHelp(
    IN  DWORD   dwWidth,
    IN  LPWSTR  pszBuffer,
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwMessageCode,
    IN  va_list *vaArgList
    )

/*++

Routine Description:

Print a message where the format comes from a message file. The message in the
message file does not use printf-style formatting. Use %1, %2, etc for each
argument. Use %<arg>!printf-format! for non string inserts.

Note that this routine also forces each line to be the current indention width.
Also, each line is printed at the right indentation.

Arguments:

    dwWidth - Maximum width of line
    pszBuffer - Buffer to write formatted text into
    dwBufferSize - Maximum size of buffer
    dwMessageCode - Message code to be formatted
    vaArgList - Arguments

Return Value:

--*/

{
    UINT nBuf;

    // Format message will store a multi-line message in the buffer
    nBuf = FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE | dwWidth,
        0,
        dwMessageCode,
        0,
        pszBuffer,
        dwBufferSize,
        vaArgList );
    if (nBuf == 0) {
        nBuf = swprintf( pszBuffer, L"Message 0x%x not found. Error %d.\n",
                         dwMessageCode, GetLastError() );
    }
    Assert(nBuf < dwBufferSize);
} /* formatMsgHelp */

void
PrintMsgInternal(
    IN  DWORD   dwMessageCode,
    IN  WCHAR * wszSpaces,
    IN  va_list *vaArgList
    )

/*++

Routine Description:

Wrapper around PrintMsgHelp with width restrictions.
This is the usual routine to use.

Arguments:

    dwMessageCode - Message code
    Args - Variable length argument list, if any

Return Value:

--*/

{
    static WCHAR s_szBuffer[4096];

    formatMsgHelp( 0,          // Width restriction, not used
                   s_szBuffer,
                   ARRAY_SIZE( s_szBuffer ),
                   dwMessageCode,
                   vaArgList );


    wprintf( L"%ws%ws", (wszSpaces) ? wszSpaces : L"", s_szBuffer );

} /* PrintMsg */

void
PrintMsg(
    IN  DWORD   dwMessageCode,
    IN  ...
    )
/*++

Routine Description:

	Wrapper for PrintMsgInternal, doesn't add tabs.

Arguments:

    dwMessageCode - Message code
    Args - Variable length argument list, if any

Return Value:

--*/
{
    va_list args;

    va_start(args, dwMessageCode);

    PrintMsgInternal(dwMessageCode, NULL, &args );

    va_end(args);
}

void
PrintTabMsg(
    IN  DWORD   dwTabs,
    IN  DWORD   dwMessageCode,
    IN  ...
    )

/*++

Routine Description:

    Wrapper around PrintMsgInternal() to proceed the message printed with
    a certain number of tabs.

Arguments:

    dwTabs - Number of tabs, tab size is 2, often used in multiples of 2 for
	tab spaces of 4.
    dwMessageCode - Message code
    Args - Variable length argument list, if any

Return Value:

--*/

{
    va_list args;
    static WCHAR s_szSpaces[] = L"                                                                                               ";
    ULONG  cNumSpaces;
    ULONG  iSpace;

    cNumSpaces = dwTabs * 2;
    Assert( cNumSpaces < ARRAY_SIZE(s_szSpaces) );
    iSpace = ARRAY_SIZE(s_szSpaces) - cNumSpaces - 1;
    
    va_start(args, dwMessageCode);

    PrintMsgInternal(dwMessageCode, &s_szSpaces[iSpace], &args );

    va_end(args);

} /* PrintMsg */


INT
MemWtoi(WCHAR *pb, ULONG cch)
/*++

Routine Description:

    This function will take a string and a length of numbers to convert.

Parameters:
    pb - [Supplies] The string to convert.
    cch - [Supplies] How many characters to convert.

Return Value:

    The value of the integers.

  --*/
{
    int res = 0;
    int fNeg = FALSE;

    if (*pb == L'-') {
        fNeg = TRUE;
        pb++;
    }


    while (cch--) {
        res *= 10;
        res += *pb - L'0';
        pb++;
    }
    return (fNeg ? -res : res);
}

DWORD
GeneralizedTimeToSystemTime(
    LPWSTR IN                   szTime,
    PSYSTEMTIME OUT             psysTime)
/*++

Routine Description:

    Converts a generalized time string to the equivalent system time.

Parameters:
    szTime - [Supplies] This is string containing generalized time.
    psysTime - [Returns] This is teh SYSTEMTIME struct to be returned.

Return Value:

    Win 32 Error code, note could only result from invalid parameter.

  --*/
{
   DWORD       status = ERROR_SUCCESS;
   ULONG       cch;
   ULONG       len;

    //
    // param sanity
    //
    if (!szTime || !psysTime)
    {
       return STATUS_INVALID_PARAMETER;
    }

    len = wcslen(szTime);

    if( len < 15 || szTime[14] != '.')
    {
       return STATUS_INVALID_PARAMETER;
    }

    // initialize
    memset(psysTime, 0, sizeof(SYSTEMTIME));

    // Set up and convert all time fields

    // year field
    cch=4;
    psysTime->wYear = (USHORT)MemWtoi(szTime, cch) ;
    szTime += cch;
    // month field
    psysTime->wMonth = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // day of month field
    psysTime->wDay = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // hours
    psysTime->wHour = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // minutes
    psysTime->wMinute = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // seconds
    psysTime->wSecond = (USHORT)MemWtoi(szTime, (cch=2));

    return status;

}

void
InitDSNameFromStringDn(
    LPWSTR pszDn,
    PDSNAME pDSName
    )
/*
 Initialize a preallocated, maximally sized DSNAME.
 */
{
    memset( pDSName, 0, sizeof( DSNAME ) );
    pDSName->NameLen = wcslen( pszDn );
    pDSName->structLen = DSNameSizeFromLen( pDSName->NameLen );
    wcscpy( pDSName->StringName, pszDn );
}

DWORD
CountNamePartsStringDn(
    LPWSTR pszDn
    )
{
    DWORD count = 0;
    PDSNAME pDSName;

    // alloc dsname buff temporarily
    pDSName = malloc( DSNameSizeFromLen( wcslen( pszDn ) ) );
    if (!pDSName) {
        return 0;
    }

    // fill in dsname
    InitDSNameFromStringDn( pszDn, pDSName );

    // count parts
    if (CountNameParts( pDSName, &count )) {
        count = 0; // error occurred
    }

    // free allocated name
    Assert(pDSName != NULL);
    free(pDSName);

    return count;
}

DWORD
WrappedTrimDSNameBy(
           IN  WCHAR *                          InString,
           IN  DWORD                            NumbertoCut,
           OUT WCHAR **                         OutString
           )
/*++

Routine Description:

    This Function is wrapping TrimDSNameBy to hanndle the
    DSNAME struct.  Usage is the same as TrimDSNameBy except
    that you send WCHAR instead of DSNAME.

    Callers: make sure that you send InString as a DN
             make sure to free OutString when done

Arguments:

    InString - A WCHAR that is a DN that we need to trim
    NumbertoCut - The number of parts to take off the front of the DN
    OutString - The Machine Reference in DN form

Return Value:

    A WinError is return to indicate if there were any problems.

--*/

{
    ULONG  Size;
    DSNAME *src, *dst, *QuotedSite;
    DWORD  WinErr=NO_ERROR;

    if ( *InString == L'\0' )
    {
        *OutString=NULL;
        return ERROR_INVALID_PARAMETER;
    }

    Size = (ULONG)DSNameSizeFromLen( wcslen(InString) );

    src = alloca(Size);
    RtlZeroMemory(src, Size);
    src->structLen = Size;

    dst = alloca(Size);
    RtlZeroMemory(dst, Size);
    dst->structLen = Size;

    src->NameLen = wcslen(InString);
    wcscpy(src->StringName, InString);

    WinErr = TrimDSNameBy(src, NumbertoCut, dst);
    if ( WinErr != NO_ERROR )
    {
        *OutString=NULL;
        return WinErr;
    }

    *OutString = malloc((dst->NameLen+1)*sizeof(WCHAR));
    if (NULL == *OutString) {
        return ERROR_OUTOFMEMORY;
    }

    wcscpy(*OutString,dst->StringName);

    return NO_ERROR;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\replmsdnex\msdnldapex.cxx ===
#include <windows.h>
#include <stdio.h>
#include <winldap.h> // Ldap functions
#include <rpc.h>
#include <rpcdce.h>
#include <ntdsapi.h> // Repl structure definitions

void
sample(PWCHAR AuthIdentity,
       LPWSTR szDomain,
       LPWSTR szDns,
       LPWSTR szBase,
       LPWSTR szGroup)
{
    LDAP * pLdap;
    PWCHAR szFilter = L"(objectclass=*)";
    DWORD err;
    ULONG ulOptions;

    // Open an LDAP session and see if replication information via LDAP is supported
    pLdap = ldap_initW(szDns, LDAP_PORT);
    if (NULL == pLdap) {
        printf("Cannot open LDAP connection to %ls.\n", szDns);
        return;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( pLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind
    err = ldap_bind_sW(pLdap, szDns, AuthIdentity, LDAP_AUTH_SSPI);
    if (LDAP_SUCCESS != err)
    {
        err = LdapMapErrorToWin32(err);
        return;
    }

    // Test for LDPA support for replication information
    {
        LDAPMessage * pRes;
        PWCHAR attrs[2] = { L"ms-DS-NC-ReplPendingOpsBinary", NULL };

        err = ldap_search_sW(pLdap, NULL, LDAP_SCOPE_BASE, szFilter, attrs, TRUE, &pRes);
        if (LDAP_SUCCESS == err)
        {
            wprintf(L"Replication information via LDAP support found.\n");
            ldap_msgfree(pRes);
        }
        else
        {
            wprintf(L"Replication information via LDAP not supported.\n");
            return;
        }
    }

    // Get non root attributes in binary blob format
    LDAPMessage * pBinNRAttrs = NULL;
    LPWSTR SomeBinaryNonRootAttributes[] = {
        L"msDS-NCReplInboundNeighbors;binary;range=0-*",
        L"msDS-NCReplOutboundNeighbors;binary;Range=0-*",
        L"msDS-NCReplCursors;Binary;Range=0-*",
        L"msDS-ReplAttributeMetaData;Binary;Range=0-*",
        NULL
    };
    err = ldap_search_sW(pLdap, szDomain, LDAP_SCOPE_BASE, szFilter,
        SomeBinaryNonRootAttributes , FALSE, &pBinNRAttrs);

    // Get non root attributes in xml format
    LDAPMessage * pXmlNRAttrs = NULL;
    LPWSTR SomeXmlNonRootAttributes[] = {
        L"msDS-NCReplInboundNeighbors;Range=0-*",
        L"msDS-NCReplOutboundNeighbors;Range=0-*",
        L"msDS-NCReplCursors;Range=0-*",
        L"msDS-ReplAttributeMetaData;Range=0-*",
        NULL
    };
    err = ldap_search_sW(pLdap, szDomain, LDAP_SCOPE_BASE, szFilter,
        SomeXmlNonRootAttributes, FALSE, &pXmlNRAttrs);

    // Get root attributes in binary blob format
    LDAPMessage * pBinRAttrs = NULL;
    LPWSTR SomeBinaryRootAttributes[] = {
        L"msDS-ReplConnectionFailuresBinary",
        L"msDS-ReplLinkFailuresBinary",
        L"msDS-ReplAllInboundNeighborsBinary",
        L"msDS-ReplAllOutboundNeighborsBinary",
        L"msDS-ReplQueueStatisticsBinary",
        NULL
    };
    err = ldap_search_sW(pLdap, NULL, LDAP_SCOPE_BASE, szFilter,
        SomeBinaryRootAttributes , FALSE, &pBinRAttrs);

    // Get root attributes in xml format
    LDAPMessage * pXmlRAttrs = NULL;
    LPWSTR SomeXmlRootAttributes[] = {
        L"msDS-ReplConnectionFailuresXml",
        L"msDS-ReplLinkFailuresXml",
        L"msDS-ReplAllInboundNeighborsXml",
        L"msDS-ReplAllOutboundNeighborsXml",
        L"msDS-ReplQueueStatisticsXml",
        NULL
    };
    err = ldap_search_sW(pLdap, NULL, LDAP_SCOPE_BASE, szFilter,
        SomeXmlRootAttributes , FALSE, &pXmlRAttrs);

    // Prepare to retreive values
    WCHAR ** ppXml;
    berval ** ppBerval;
    PWCHAR szRetAttribute;
    berelement * pCookie;

    // Print out all the XML values for non root attributes
    szRetAttribute = ldap_first_attributeW(pLdap, pXmlNRAttrs, &pCookie);
    while(szRetAttribute)
    {
        ppXml = ldap_get_valuesW(pLdap, pXmlNRAttrs, szRetAttribute);
        wprintf(L"szRetAttribute %ws = {\n", szRetAttribute);
        while(*ppXml)
        {
            wprintf(L"   %ws \n", *ppXml);
            ppXml ++;
        }
        wprintf(L"}\n");
        ldap_memfreeW(szRetAttribute);
        szRetAttribute = ldap_next_attributeW(pLdap, pXmlNRAttrs, pCookie);
    }
    ldap_memfreeW(szRetAttribute);

    // Print out all the XML values for root attributes
    szRetAttribute = ldap_first_attributeW(pLdap, pXmlRAttrs, &pCookie);
    while(szRetAttribute)
    {
        ppXml = ldap_get_valuesW(pLdap, pXmlRAttrs, szRetAttribute);
        wprintf(L"szRetAttribute %ws = {\n", szRetAttribute);
        while(*ppXml)
        {
            wprintf(L"   %ws \n", *ppXml);
            ppXml ++;
        }
        wprintf(L"}\n");
        ldap_memfreeW(szRetAttribute);
        szRetAttribute = ldap_next_attributeW(pLdap, pXmlRAttrs, pCookie);
    }
    ldap_memfreeW(szRetAttribute);

    // Print out binary blob neighbors structure
    szRetAttribute = ldap_first_attributeW(pLdap, pBinNRAttrs, &pCookie);
    while(szRetAttribute)
    {
        if (wcsstr(szRetAttribute,L"Neighbors"))
        {

            CHAR * pReplBlob;
            ppBerval = ldap_get_values_lenW(pLdap, pBinNRAttrs, szRetAttribute);

            wprintf(L"szRetAttribute %ws = {\n", szRetAttribute);
            while(*ppBerval)
            {
                pReplBlob = (*ppBerval)->bv_val;
                DS_REPL_NEIGHBORW_BLOB * pReplNeighborBlob =
                    (DS_REPL_NEIGHBORW_BLOB *)pReplBlob;

                LPWSTR pszAsyncIntersiteTransportDN = pReplNeighborBlob->oszAsyncIntersiteTransportDN ?
                    (LPWSTR)(pReplBlob + pReplNeighborBlob->oszAsyncIntersiteTransportDN) : NULL;
                LPWSTR pszNamingContext = pReplNeighborBlob->oszNamingContext ?
                    (LPWSTR)(pReplBlob + pReplNeighborBlob->oszNamingContext) : NULL;

                // Print out a couple fields
                wprintf(L"{AsyncInterSiteTransportDN=%ws}, {NamingContext=%ws}, {LastSyncResult=%d}, {ReplicaFlags=%d}\n",
                    pszAsyncIntersiteTransportDN,
                    pszNamingContext,
                    pReplNeighborBlob->dwLastSyncResult,
                    pReplNeighborBlob->dwReplicaFlags);
                ppBerval ++;
            }
            wprintf(L"}\n");
        }

        ldap_memfreeW(szRetAttribute);
        szRetAttribute = ldap_next_attributeW(pLdap, pBinNRAttrs, pCookie);
    }
    ldap_memfreeW(szRetAttribute);

    // Get attribute value metadata for a group of users
    LDAPMessage * pBinValueAttrs = NULL;
    WCHAR buf[255];
    DWORD dwPageSize = 2;   // number of users requested at once
    DWORD dwBaseIndex = 0;  // index to start retreiving users from
    DWORD dwUpperRetIndex;

    LPWSTR ValueMetaData[] = {
        buf,
        NULL
    };

    do {
        // Prepare the range syntax
        wsprintfW(buf, L"msDS-ReplValueMetaData;binary;range=%d-%d",
            dwBaseIndex, dwBaseIndex + dwPageSize - 1);

        // Preform the search
        err = ldap_search_sW(pLdap, szGroup, LDAP_SCOPE_BASE, szFilter,
            ValueMetaData, FALSE, &pBinValueAttrs);

        // Examin results
        szRetAttribute = ldap_first_attributeW(pLdap, pBinValueAttrs, &pCookie);
        if (!szRetAttribute)
        {
            // Either the attribute name does not exist or the base index
            // is beyond the last possible index
            dwUpperRetIndex = -1;
            wprintf(L"Error!");
        }
        else if (!swscanf(wcsstr(szRetAttribute, L"ange="), L"ange=%*d-%d", &dwUpperRetIndex))
        {
            // The number of values returned is equal to or less than the requested page size
            // and there are no more valeus to be returned
            dwUpperRetIndex = -1; // range=?-*
            wprintf(L"All values returned.\n");
        }
        else
        {
            // The requested number of values have been returned and more are available
            wprintf(L"%d values returned.\n", dwUpperRetIndex - dwBaseIndex + 1);
        }

        ldap_memfreeW(szRetAttribute);
        dwBaseIndex += dwPageSize;
    } while (dwUpperRetIndex != -1);

    ldap_memfreeW((PUSHORT)pCookie);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\replstruct\repldemarshal.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:
    ReplDeMarshal.cxx

Abstract:
    De-marshals a repl blob. See ReplMarshalBlob.cxx for an explination of the 
    marshaling algorithm.

Author:

    Chris King          [t-chrisk]    July-2000
    
Revision History:

--*/
#include <NTDSpchx.h>
#pragma hdrstop

#include <align.h>

#include <ntdsa.h>
#include <winldap.h>
#include <debug.h>

#define ARGUMENT_PRESENT(ArgumentPointer) (  (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"

DWORD
Repl_DeMarshalBerval(DS_REPL_STRUCT_TYPE structId, 
                     berval * ldapValue[], OPTIONAL
                     DWORD dwNumValues,
                     puReplStructArray pReplStructArray, OPTIONAL
                     PDWORD pdwReplStructArrayLen)
/*++
Routine Description:

  Translates a berval to a replication array container.

Arguments:

  dwReplInfoType - the replication information type used by RPC
  ldapValues - the berval returned by LDAP representing the dwReplInfoType multivalue, may be NULL if
    dwNumValues == 0;
  dwNumValues - the number of multivalues in the berval
  pReplStructArray - location to construct the replication array container.
  pdwReplStructArrayLen -
    Address of a DWORD value of the signature data length. Upon function entry, 
    this DWORD value contains the number of bytes allocated for the pReplStructArray buffer. 
    Upon exit, it is set to the number of bytes required for the pReplStructArray buffer. 
    May return zero if the repl struct is w/o array container (see ROOT_DSE_ATT_MS_DS_REPL_QUEUE_STATISTICS)
    in which case no repl struct was returned.
    
Return values
    If memory allocated for the pbSignature buffer is not large enough to hold the signature, 
    the ERROR_MORE_DATA error code is returned. The required buffer size is returned in pdwReplStructArrayLen. 
    If this function fails with any error code other than ERROR_MORE_DATA, zero is returned in pdwReplStructArrayLen. 
--*/
{   
    DWORD dwElemSize        = Repl_GetElemSize(structId);
    PCHAR rDSRepl           = NULL;
    DWORD i, err = 0, dwReplStructArrayLen;
    signed long ulNumValues = (signed long)dwNumValues;

    Assert(ARGUMENT_PRESENT(ldapValue) || !dwNumValues);

    // Check memory enviornment
    dwReplStructArrayLen = Repl_GetArrayContainerSize(structId) + 
        (ulNumValues - 1) * // the ArrayContainer has a repl element in it already
        Repl_GetElemSize(structId);
    if (!pReplStructArray)
    {
        *pdwReplStructArrayLen = dwReplStructArrayLen;
        return 0;
    }
    else if (*pdwReplStructArrayLen < dwReplStructArrayLen)
    {
        *pdwReplStructArrayLen = dwReplStructArrayLen;
        return ERROR_MORE_DATA;
    }
    *pdwReplStructArrayLen = 0;
    
    // Set container length
    Repl_SetArrayLength(structId, pReplStructArray, dwNumValues);
    
    // Fill in array
    Repl_GetElemArray(structId, pReplStructArray, &rDSRepl);
    for (i = 0; i < dwNumValues; i ++)
    {
        err = Repl_DeMarshalValue(
            structId,
            ldapValue[i]->bv_val,           // a binary blob containing a single marshaled structure
            ldapValue[i]->bv_len,           // single blob value length
            rDSRepl + (i * dwElemSize));    // a structure to demarshal the blob into
    }

    *pdwReplStructArrayLen = dwReplStructArrayLen;
    return err;
}


DWORD
Repl_DeMarshalValue(DS_REPL_STRUCT_TYPE structId, 
                    IN PCHAR pValue,
                    IN DWORD dwValueLen,
                    OUT PCHAR pStruct)  
/*++ 

Routine Description:

  Demarshals a replication blob into its orig structure. The blob structure
  contains a head and a body. The head maps to the origional structure by 
  transforming the pointers into 32bit offsets into the body of the blob. This
  demarshaling routine transforms the head of the blob back into a structure
  by transforming the offsets into pointers which point back into the body
  of the blob.

  The marshaled blob can not be demarshaled into the same memory.

  The extensibility rules of the structures allow for them to grow in the
  future. Thus, the incoming value may have more or fewer fields than the
  struct we are trying to populate.

Arguments:

  pValue - A pointer to the blob
  dwValueLen - The length of the blob
  pStruct - A pointer to the orig struct

Return value
  Currently no error codes are returned (return 0).
  
--*/
{
    Assert(ARGUMENT_PRESENT(pValue) &&
           ARGUMENT_PRESENT(pStruct));

    DWORD dwFieldIndex, dwPtrIndex;
    DWORD dwFieldCount = Repl_GetFieldCount(structId);
    DWORD dwPtrCount = Repl_GetPtrCount(structId);
    DWORD dwStructLen = Repl_GetElemSize(structId);
    DWORD * rPtrOffset = Repl_GetPtrOffsets(structId);
    psReplStructField aReplStructField = Repl_GetFieldInfo(structId);

    // No overlap should exist between the marshaled structure and the
    // demarshaled location
    Assert(pValue < pStruct || pValue > pStruct + dwStructLen);

    // Without pointer case is easy
    if (!dwPtrCount) {
        if (dwStructLen <= dwValueLen) {
            // Native structure is smaller: truncate
            memcpy(pStruct, pValue, dwStructLen );
        } else {
            // Native structure is bigger: zero fill
            memcpy(pStruct, pValue, dwValueLen );
            memset(pStruct + dwValueLen, 0, dwStructLen - dwValueLen );
        }

        return 0;
    }
    
    // Copy the fields one at a time
    for (dwFieldIndex = 0, dwPtrIndex = 0; dwFieldIndex < dwFieldCount; dwFieldIndex++)
    {

        psReplStructField pField = aReplStructField + dwFieldIndex;
        PCHAR from = pValue + pField->dwBlobOffset;
        PCHAR to = pStruct + pField->dwOffset;
        DWORD dwSize = Repl_GetTypeSize(pField->eType);

        if (pField->dwBlobOffset >= dwValueLen) {
            // Native structure is bigger: zero fill
            Assert( (pField->dwOffset + dwSize) < dwStructLen );
            memset( to, 0, dwSize );
            
        } else if ( (pField->eType == dsReplString) || (pField->eType == dsReplBinary) ) {

            DWORD length;
            Assert( pField->dwOffset == rPtrOffset[dwPtrIndex] );

            Assert( POINTER_IS_ALIGNED( from, ALIGN_DWORD ) );
            length = *((PDWORD)from);

            // set pointer
            Assert( POINTER_IS_ALIGNED( to, ALIGN_LPVOID ) );
            if (length) {
                *(PCHAR*)to = (pValue + length);
            } else {
                *(PCHAR*)to = NULL;
            }

            dwPtrIndex++;

        } else {
            Assert( (pField->dwBlobOffset + dwSize - 1) < dwValueLen );
            Assert( (pField->dwOffset + dwSize - 1) < dwStructLen );
            memcpy( to, from, dwSize );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\replstruct\replmarshalxml.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:
    ReplMarshalXml.cxx

Abstract:
    Function to convert repl structs to XML.

Author:

    Chris King          [t-chrisk]    July-2000
    
Revision History:

--*/

#include <NTDSpchx.h>
#pragma hdrstop

#include <ntdsa.h>
#include <debug.h>
#include <dsutil.h>

#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplTables.hxx"


DWORD
Repl_XmlTemplateLength(ReplStructInfo * pRow)
/*++
Routine Description:

  Calculate the lenght of the XML representation if all the data fileds were empty. This function
  is called during the creation of a table and the result is stored as a field in that table.
  
Arguments:

  pRow - the row of the table.
  
Return values:

  The length of the xml template.
  
--*/
{
    DWORD dwXmlStrLength = 0, i;

    dwXmlStrLength += wcslen(pRow->szStructName) * 2 + wcslen(L"<></>\n\n");
    for (i = 0; i < pRow->dwFieldCount; i ++)
    {
        dwXmlStrLength += 
            wcslen(pRow->aReplTypeInfo[i].szFieldName) * 2 +
            wcslen(L"\t<></>\n");
    }
    return (dwXmlStrLength + 1) * 2;
}

DWORD
Repl_TypeToString(DS_REPL_DATA_TYPE typeId, PVOID pData, PCHAR pBuf, PDWORD pdwBufSize)
/*++
Routine Description:

  Converts a field in a replication structure into its XML string representation.
  
Arguments:

  typeId - the id of the type
  pData - the value to convert
  pBuf - the location to put the data, NULL to see how much memory is needed
  pdwBufSize - the size of the buffer or the amount of memory needed to hold the data
  
Return values:

    If memory allocated for the xml representation buffer is not large enough to hold the XML, 
    the ERROR_MORE_DATA error code is returned. The required buffer size is returned in pdwBufSize. 
    If this function fails with any error code other than ERROR_MORE_DATA, zero is returned in pdwBufSize. 
  
--*/
{
    Assert(ARGUMENT_PRESENT(pdwBufSize));
    Assert(ARGUMENT_PRESENT(pData));

    DWORD dwLength, dwStrLength, err = 0;
    LPWSTR szStr;
    WCHAR wbuf[256];
    SYSTEMTIME sysTime;

    // Calculate the number of characters in the string representation of the data
    // type w/o the terminating null character
    switch (typeId)
    {
    case dsReplDWORD:
    case dsReplLONG:
    case dsReplOPTYPE:
        dwStrLength = wcslen(_itow(*(PDWORD)pData, wbuf, 10));
        break;

    case dsReplUSN:
        dwStrLength = wcslen(_i64tow(*(PLONGLONG)pData, wbuf, 10));
        break;

    case dsReplString:
        if (*(LPWSTR*)pData) {
            dwStrLength = wcslen(*(LPWSTR*)pData);
        }
        else {
            dwStrLength = 0;
        }
        break;

    case dsReplUUID:
        err = UuidToStringW((UUID *)pData, &szStr);
        if (err != RPC_S_OK) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        dwStrLength = wcslen(szStr);
        RpcStringFreeW(&szStr);
        break;

    case dsReplFILETIME:
        // Generate XML datetime syntaxed value -- date in a subset of ISO 8601
        // format, with optional time and no optional zone.  For example,
        // "1988-04-07T18:39:09".  Z is appended to denote UTC time (to
        // differentiate from unadorned local time).
        if (FileTimeToSystemTime((FILETIME *) pData, &sysTime)) {
            dwStrLength = swprintf(wbuf,
                                   L"%04d-%02d-%02dT%02d:%02d:%02dZ",
                                   sysTime.wYear % 10000,
                                   sysTime.wMonth,
                                   sysTime.wDay,
                                   sysTime.wHour,
                                   sysTime.wMinute,
                                   sysTime.wSecond);
        } else {
            Assert(!"Invalid FILETIME!");
            dwStrLength = 0;
        }
        break;        
        
    case dsReplPadding:
    case dsReplBinary:
        dwStrLength = 0;
        break;
    }

    // Convert from the number of characters to the number of bytes needed to represent
    // the string version of the type
    dwLength = sizeof(WCHAR) * dwStrLength;
    if(requestLargerBuffer((PCHAR)pBuf, pdwBufSize, dwLength, &err)) {
        return err;
    }

    if (!dwLength) {
        goto exit;
    }

    switch (typeId)
    {
    case dsReplDWORD:
    case dsReplLONG:
    case dsReplOPTYPE:
    case dsReplUSN:
        memcpy(pBuf, (PVOID)wbuf, dwLength);
        break;
       
    case dsReplUUID:
        err = UuidToStringW((UUID *)pData, &szStr);
        if (err != RPC_S_OK) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        memcpy(pBuf, (PVOID)szStr, dwLength);
        RpcStringFreeW(&szStr);
        break;

    case dsReplString:
        memcpy(pBuf, *(PVOID *)pData, dwLength);
        break;

    case dsReplFILETIME:
        memcpy(pBuf, wbuf, dwLength);
        break;

    case dsReplPadding:
    case dsReplBinary:
        break;
    }

    *pdwBufSize = dwLength;

exit:
    return err;
}

DWORD
Repl_MarshalXml(IN puReplStruct pReplStruct, 
                IN ATTRTYP attrId,
                IN OUT LPWSTR szXmlBuf, OPTIONAL
                IN OUT PDWORD pdwXmlLength)
/*++
Routine Description:

  Calculate how much memory is needed to transform a replication structure into the XML 
  representation and preform the transform a replication stucture into an XML string.

  The transform from struct to XML is simple. The struct is converted into a string with
  the following format:

  <STRUCT_NAME>
        <FIELD_NAME>[value]<\FIELD_NAME>
        ...
  <\STRUCT_NAME>
  
Arguments:
  pReplStruct - a pointer to a union of suppored replication structures
  attrId - indentifies a replication attributes
  szXML - 
  pdwXMLLen -
    Address of a DWORD value of the signature data length. Upon function entry, 
    this DWORD value contains the number of bytes allocated for the szXML buffer. 
    Upon exit, it is set to the number of bytes required for the szXML buffer. 

  
Return values:

    If memory allocated for the pbSignature buffer is not large enough to hold the signature, 
    the ERROR_MORE_DATA error code is returned. The required buffer size is returned in pdwXMLLen. 
    If this function fails with any error code other than ERROR_MORE_DATA, zero is returned in pdwXMLLen. 
  
--*/
{
    Assert(pdwXmlLength);
    Assert(Repl_IsConstructedReplAttr(attrId));
    
    DWORD i, err;
    LPWSTR szXml = szXmlBuf;
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);
    DWORD dwXmlLength = Repl_GetXmlTemplateLength(structId);
    DWORD dwFieldCount = Repl_GetFieldCount(structId);
    psReplStructField aReplStructField = Repl_GetFieldInfo(structId);
    LPCWSTR szStructName = Repl_GetStructName(structId);

    // Calculate how much memory is needed
    for (i = 0; i < dwFieldCount; i ++)
    {
        DWORD dwSize;
        err = Repl_TypeToString(
                aReplStructField[i].eType, 
                ((PCHAR)pReplStruct + aReplStructField[i].dwOffset),
                NULL,
                &dwSize);
        if (err) {
            goto exit;
        }
        dwXmlLength += dwSize;
    }

    if(requestLargerBuffer((PCHAR)szXmlBuf, pdwXmlLength, dwXmlLength, &err)) {
        goto exit;
    }
    

    // Construct string
    szXml += wsprintfW(szXml, L"<%ws>\n", szStructName);
    for (i = 0; i < dwFieldCount; i ++)
    {
        DWORD dwSize = dwXmlLength - (DWORD)(szXml - szXmlBuf);
        szXml += wsprintfW(szXml, L"\t<%ws>", aReplStructField[i].szFieldName);
        err = Repl_TypeToString(
            aReplStructField[i].eType, 
            ((PCHAR)pReplStruct + aReplStructField[i].dwOffset),
            (PCHAR)szXml,
            &dwSize);
        if (err) {
            goto exit;
        }
        szXml = (PWCHAR)((PCHAR)szXml + dwSize);
        szXml += wsprintfW(szXml, L"</%ws>\n", aReplStructField[i].szFieldName);
    }
    szXml += wsprintfW(szXml, L"</%ws>\n", szStructName);

    *pdwXmlLength = (wcslen(szXmlBuf) + 1) * 2;
    Assert(*pdwXmlLength == dwXmlLength);

exit:
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\replstruct\replmarshalblob.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:
    ReplMarshalBlob.cxx

Abstract:
    Takes a structure and marshals it into a blob.

    The marshaling protocol does not support marshaling of structures containing arrays or
    pointers to arrays of structures containing pointers. Currently, the DS_REPL_XXX structures contain
    pointers to strings or binary blobs containing no pointers. Here is an explanation of how the 
    structures are marshaled:

	The un-marshaled structure will not be converted network byte order. 

    Each pointer in the unmarshaled structure has been replaced with a 32bit offset value 
    in its corresponding marshaled structure. Thus marshaled structures will be the same size 
    on either 32 or 64 bit architectures.
	
        If the pointer is NULL in the unmarshaled structure its offset is zero in the marshaled structure.
	    So a an EMPTY string, as opposed to a NULL string, is represented by a NON-NULL offset to a 
        single character containing a zero. '\0'

        If the pointer is non-NULL the data it referenced can be located by adding the address of the
        marshaled structure to its corresponding offset. 

	    The first non-zero offset value in the marshaled structure is guaranteed to be the size of the 
        corresponding unmarshaled structure.

        The version of the marshaled structure can be inferred from its size which can be calculated, 
        given only the unmarshaled structure as follows:

        	The blob containing a marshaled structure with no offset fields or zero value offset 
            fields is the size of the un-marshaled structure on a 32-bit computer.
	        Else the size of the unmarshaled structure is equal to the value of the first non-zero
            offset on a 32-bit computer.

	If a pointer points to another structure, that structure will also have a marshaled data structure and 
    its offsets will be calculated relative to its own base and not that of the parent structure. Its offsets
    are subject to the same constraints listed above. Currently there are no structures that require this type of
    recursive marshaling and there is no support for such marshaling.
    This point is included for future extensions of the API.
  

Author:

    Chris King          [t-chrisk]    July-2000
    
Revision History:

--*/
#include <NTDSpchx.h>
#pragma hdrstop

#include <align.h>

#include <ntdsa.h>
#include <debug.h>

#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
DWORD
Repl_MarshalBlob(IN DS_REPL_STRUCT_TYPE structId,
                 IN PCHAR pStruct, 
                 IN DWORD dwStructLen, 
                 IN DWORD dwPtrOffset[],
                 IN DWORD dwPtrLen[],
                 IN DWORD dwPtrCount, 
                 IN OUT PCHAR pBinBlob, OPTIONAL
                 IN OUT PDWORD pdwBlobLen)
/*++
Routine Description:

  Marshals a structure into a blob. The structure may contain pointers to data without any pointers.
  The structure is copied to the begining of the blob. Pointer data is appended to the blob in 
  the order the pointers appeared in the structure. The pointer fields are replaced with offsets
  from the start of the blob into the appended data section. NULL pointers map to zero valued
  offset fields.

Arguments:

  pStruct - the structure to marshal
  dwStructLen - the lenght of the pStruct
  dwPtrOffset - array of pointer offsets from pStruct
  dwPtrLen - array indicating the range of data each pointer refers to 
  dwPtrCount - number of pointers in the pStruct
  pBinBlob - memory to hold marshaled pStruct
  pdwBlobLen -
    Address of a DWORD value of the signature data length. Upon function entry, 
    this DWORD value contains the number of bytes allocated for the pBinBlob buffer. 
    Upon exit, it is set to the number of bytes required for the pBinBlob buffer. 

Return values:

    If memory allocated for the pbSignature buffer is not large enough to hold the blob, 
    the ERROR_MORE_DATA error code is returned. The required buffer size is returned in pdwBlobLen. 
    If this function fails with any error code other than ERROR_MORE_DATA, zero is returned in pdwBlobLen. 

--*/
{
    Assert(ARGUMENT_PRESENT(pdwBlobLen) && dwStructLen);
    Assert(IMPLIES(dwPtrCount && ARGUMENT_PRESENT(pBinBlob), 
                   ARGUMENT_PRESENT(dwPtrOffset) && ARGUMENT_PRESENT(dwPtrLen)));

    DWORD dwBlobHeadLen = Repl_GetElemBlobSize(structId);
    DWORD dwFieldCount = Repl_GetFieldCount(structId);
    psReplStructField aReplStructField = Repl_GetFieldInfo(structId);
    PCHAR pMarshal;
    DWORD dwTotalPtrLen, dwTotalBlobLen;
    DWORD i, dwFieldIndex, dwPtrIndex, ret;
    
    for (i = 0, dwTotalPtrLen = 0; i < dwPtrCount; i ++) {
        dwTotalPtrLen += dwPtrLen[i];
    }
    dwTotalBlobLen = ROUND_UP_COUNT( dwBlobHeadLen + dwTotalPtrLen, ALIGN_DWORD );

    if(requestLargerBuffer(pBinBlob, pdwBlobLen, dwTotalBlobLen, &ret))
    {
        return ret;
    }
    
    // A structure without pointer case is easy
    if (!dwPtrCount) {
        memcpy(pBinBlob, pStruct, dwStructLen);
        *pdwBlobLen = dwStructLen;
        Assert( COUNT_IS_ALIGNED( dwStructLen, ALIGN_DWORD ) );
        return 0;
    }
    
    pMarshal = pBinBlob + dwBlobHeadLen;

    for (dwFieldIndex = 0, dwPtrIndex = 0; dwFieldIndex < dwFieldCount; dwFieldIndex++)
    {
        psReplStructField pField = aReplStructField + dwFieldIndex;
        DWORD dwSize = Repl_GetTypeSize(pField->eType);
        PCHAR from = pStruct + pField->dwOffset;
        PCHAR to = pBinBlob + pField->dwBlobOffset;

        Assert( pField->dwOffset < dwStructLen );
        Assert( pField->dwBlobOffset < dwBlobHeadLen );

        if ( (pField->eType == dsReplString) || (pField->eType == dsReplBinary) ) {

            DWORD length = dwPtrLen[dwPtrIndex];

            Assert( pField->dwOffset == dwPtrOffset[dwPtrIndex] );

            if (length) {
                Assert( POINTER_IS_ALIGNED( to, ALIGN_DWORD ) );
                *(PDWORD)(to) = (DWORD)(pMarshal - pBinBlob); 

                Assert( POINTER_IS_ALIGNED( from, ALIGN_LPVOID ) );
                memcpy(pMarshal, *(LPWSTR *)(from), length);
                pMarshal += length;
            }
            else {
                *(PDWORD)(to) = 0; 
            }
            dwPtrIndex++;
        } else {
            memcpy( to, from, dwSize );

            Assert( to + dwSize - 1 < pBinBlob + dwBlobHeadLen );
        }

    }

    // Pointer data should not exceed buffer
    Assert( pMarshal <= (pBinBlob + dwTotalBlobLen) );

    *pdwBlobLen = dwTotalBlobLen;
    return 0; 
};


DWORD
Repl_StructArray2Attr(IN DS_REPL_STRUCT_TYPE structId,
                      IN puReplStructArray pReplStructArray,
                      IN OUT PDWORD pdwBufferSize,
                      IN PCHAR pBuffer, OPTIONAL
                      OUT ATTR * pAttr)
/*++

Routine Description:

  Replication information stored in repl structures containted in repl array containers ==>
  Replication information stored in marshaled format containted in a pAttrs

  Initialize a ATTR structure.

  For every elment in the array container the function, marshal the element by 
  calling draReplStruct2Attr.

Arguments:

  pTHS - thread state used to allocate memory for the blobs and garbage collect
  attrId - the type of replication information requested
  puReplStructArray - the repl struct containing the structure to be marshaled
  pAttr - returned structure representing a single attribute. 
  pBuffer - memory to construct the pAttr links with
  pdwBufferSize - size of buffer or requested buffer size

Return Values:

  pAttr
    pAttr->AttrTyp ~ not modified or read
    pAttr->AttrVal.valCount = number of elements in replication array container
    pAttr->AttrVal.pAVals[i].pVal = contains the marshaled i'th replication structure
    pAttr->AttrVal.pAVals[i].valLen = the size of the marshaled i'th replication structure

  returns any errors generated by Repl_MarshalBlob or returns zero to indicate no error.
  ERROR_MORE_DATA if pdwBufferSize is NonNULL and too small. See requestLargerBuffer().
--*/
{
    PCHAR rDSRepl = NULL, pAlloc = NULL;
    DWORD err = 0, dwBufferSize = 0, dwReplStructSize, dwReplNumValues = 0;
    DWORD dwPtrCount;
    DWORD * pgdwPtrOffsets;
    DWORD * pdwPtrLengths;
    DWORD dwSumPtrLengths;

    Assert(ARGUMENT_PRESENT(pAttr));
    Assert(IMPLIES(ARGUMENT_PRESENT(pBuffer),ARGUMENT_PRESENT(pReplStructArray)));

    // Gather Parameters
    dwReplNumValues = Repl_GetArrayLength(structId, pReplStructArray);
    if (dwReplNumValues)
    {
        dwPtrCount = Repl_GetPtrCount(structId);
        dwReplStructSize = Repl_GetElemSize(structId);
        // dwReplStructSize = Repl_GetElemSize(structId);
        Repl_GetElemArray(structId, pReplStructArray, &rDSRepl);
    }

    // Set the number of values
    pAttr->AttrVal.valCount = dwReplNumValues;

    if (dwReplNumValues)
    {
        DWORD i;
        uReplStruct * pReplStruct;

        // Calculate the amount of memory needed, store the result in dwBufferSize
        // Memory to store blob pointer and blob lenght
        dwBufferSize = dwReplNumValues * sizeof(ATTRVAL);

        // Memory to store pointer lengths
        dwBufferSize += sizeof(PDWORD) * dwPtrCount;
        
        // Memory to store the blob
        for (i = 0; i < pAttr->AttrVal.valCount; i ++)
        {
            DWORD dwBlobSize;
            pReplStruct = (puReplStruct)(rDSRepl + (i * dwReplStructSize));
            Repl_GetPtrLengths(structId, pReplStruct, NULL, 0, &dwSumPtrLengths);
            err = Repl_MarshalBlob(structId, NULL, dwReplStructSize, NULL, &dwSumPtrLengths, 1, NULL, &dwBlobSize);
            if (err) {
                goto exit;
            }
            dwBufferSize += dwBlobSize;
        }

        // See if enough memory is available
        if (requestLargerBuffer(pBuffer, pdwBufferSize, dwBufferSize, &err)) {
            goto exit;
        }

        // Distribute memory
        pAlloc = pBuffer;
        
        // Store pointer lenghts here
        pdwPtrLengths = (PDWORD)pAlloc;
        pAlloc += sizeof(PDWORD) * dwPtrCount;

        // Store the blob pointer and blob length here
        pAttr->AttrVal.pAVal = (ATTRVAL *)pAlloc;
        pAlloc += dwReplNumValues * sizeof(ATTRVAL);

        // Enough memory is available so preform the transform from
        // replication structure to attr vals
        for (i = 0; i < pAttr->AttrVal.valCount; i ++)
        {
            // Locate the next repl structure in the container array
            pReplStruct = (puReplStruct)(rDSRepl + (i * dwReplStructSize));
            Repl_GetPtrLengths(structId, pReplStruct, pdwPtrLengths, dwPtrCount, NULL);
            pgdwPtrOffsets = Repl_GetPtrOffsets(structId);
            
            pAttr->AttrVal.pAVal[i].pVal = (PUCHAR)pAlloc;
            pAttr->AttrVal.pAVal[i].valLen = dwBufferSize - (DWORD)(pAlloc - pBuffer);
            err = Repl_MarshalBlob(
                structId,
                (PCHAR)pReplStruct, 
                dwReplStructSize, 
                pgdwPtrOffsets, 
                pdwPtrLengths, 
                dwPtrCount, 
                (PCHAR)pAttr->AttrVal.pAVal[i].pVal,       // Destination
                &pAttr->AttrVal.pAVal[i].valLen);          // Destination length
            if (err) {
                goto exit;
            }
            
            pAlloc += pAttr->AttrVal.pAVal[i].valLen;
        }
        // The buffer was lager enough
        Assert(dwBufferSize - (pAlloc - pBuffer) < dwBufferSize);
    }

exit:
    if (!err) {
        *pdwBufferSize = dwBufferSize;
    }
    return err;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\replstruct\replstructinfo.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:
    replStructInfo.cxx

Abstract:
    This file contains a set of tables which can be indexed and cross-referanced with
    each other to provide access to data about replication structures. To understand how
    these tables relate, examin their definitions. The tables are accesed via functions
    to hide the class structure from .c files.

    Note on dynamic memory allocation during table construction: The tables are implemented
    as a link list. The links are allocated with the new operator. The tables exist until the
    process ends and thus the links are reclaimed during process termination.

    * How do I add another replication structure?

        Update the rows of the tables to included the new replication structure.
        Updating the DS_REPL_STRUCT_TYPE enumeration to include the new structure.
        Include the structure in the _uReplStruct union.
        If there is an array wrapper struct, include it in the _uReplStructArray union.
        If the attribute is a ROOT_DSE attribute, #define an ATTRTYP following the convention
            for ROOT_DSE_MS_DS_REPL_PENDING_OPS and the others.

        There are a few functions which are not driven by the tables which will have to be
        updated by hand.

            Repl_MarshalXML - repl struct -> XML string
            Repl_GetPtrLengths - repl struct -> length of its pointers
            Repl_TypeToString - repl struct field -> XML string
            draGetReplStruct in drainfo.c - replication id -> populated replication structure
            examine locations where draGetLdapReplInfo is called from to ensure that control
            is passed to it when appropriate.

        If there are any code paths that are specific to the new replication structure, such as
        aquiring mutexes, add those where appropriate. See draGetLdapReplInfo and note how
        a critical section is aquired for ROOT_DSE_MS_DS_REPL_PENDING_OPS and
        ROOT_DSE_MS_DS_REPL_QUEUE_STATISTICS.

        Recompile replStruct, ntdsa.dll, ldp.exe and repadmin.exe.

Author:

    Chris King          [t-chrisk]    July-2000

Revision History:

--*/

#include <NTDSpchx.h>
#pragma hdrstop

#include <drs.h>            // ATTRTYP
#include <attids.h>
#include <debug.h>
#include <dsexcept.h>

#include "ReplStructInfo.hxx"
#include "ReplTables.hxx"

#define DEBSUB "ReplStructInfo:"               /* define the subsystem for debugging */
#define FILENO FILENO_REPLSTRUCT

template<class Index, class Type>
cTable<Index,Type>::cTable()
{
    m_root.next = NULL;
    m_dwRowCount = 0;
}

template<class Index, class Type>
Type &
cTable<Index,Type>::findRow(Index I)
/*++

Routine Description:
    Given the "primary key" return the corrisponding "row" or structure and assert if
    the structure is not found.

Arguments:
    index - the index used as the "primary key" for the table (ie the key to the map)

Return Values:
    a referance to the "row" (ie the structure associated with the primary key.

--*/
{
    sLink<Index, Type> *pLink = &m_root;

    while(pLink->next)
    {
        pLink = pLink->next;
        if (pLink->I == I)
            return pLink->T;
        Assert(pLink->next);
    }

    Assert(0);
    exit(-1);
}

template<class Index, class Type>
Type &
cTable<Index,Type>::getRow(DWORD rowNum)
/*++

Routine Description:
    Allows for simple enumeration of the rows in the table. Indexes start at zero and any
    request for non-existent rows result in assertions. Use getNumRows to discover how many
    rows are in the table.

Arguments:
    rowNum - the row numbers start at zero.

Return Values:
    a referance to the requested row

--*/
{
    sLink<Index, Type> *pLink = &m_root;
    DWORD i;

    for(i = 0; i < rowNum + 1; i++)
    {
        Assert(pLink->next);
        pLink = pLink->next;
    }

    return pLink->T;
}

template<class Index, class Type>
BOOL
cTable<Index,Type>::indexExists(Index I)
/*++

Routine Description:
    Discover if a given index exists in the table.

Arguments:
    I - the index in question

Return Values:
    TRUE/FALSE depending on whether or not the index exists

--*/
{
    sLink<Index, Type> *pLink = &m_root;

    while(pLink->next)
    {
        pLink = pLink->next;
        if (pLink->I == I)
            return TRUE;
    }

    return FALSE;
}

template<class Index, class Type>
DWORD
cTable<Index,Type>::getNumRows()
    {
        return m_dwRowCount;
    }

template<class Index, class Type>
void
cTable<Index,Type>::insert(Index I, Type T)
/*++
Routine Description:
    Inserts a row with values T in the table under index I

Arguments:
    I - index of the new row, must be unique in the table
    T - the value of the row

Return Values:
    none

--*/
{
    sLink<Index, Type> *pLink = &m_root;

    while(pLink->next)
    {
        pLink = pLink->next;
        /* When the tables are constructed in my user land test program this
           assertion does not fire and the test program works properly. When
           the tables are constructed during boot up as part of ntdsa.dll removal
           of this assertion allowed the boot up to complete. The tests still
           ran and visual inspection showed no duplicate rows so I don't know
           why this assertion caused the boot up to fail.
        */
//            Assert(pLink->I != I);
    }

    pLink->next = new sLink<Index, Type>;
    if (pLink->next == NULL) {
/* ISSUE JeffParh/Wlees Sept 27, 2000.  Yeah, in general I think it's questionable
form to have anything in a constructor that can fail.  If you do you have to define
some way for those failures to be communicated back to the caller.  If it's a global
it's even harder to define what should happen.  Hmm.  Ideally I think we'd make
the initialization explicit and have it return an error if unsuccessful.  */
        RaiseException( DSA_MEM_EXCEPTION, 0, 0, NULL );
    }
    m_dwRowCount++;
    Assert(pLink->next);
    pLink = pLink->next;
    pLink->next = NULL;
    pLink->I = I;
    pLink->T = T;
}


//
// add "rows" to the ReplMetaInfoAttrType "table"
/////////////////////////////////////////////////////////////////////////////////////
class cReplMetaInfoAttrTyp : public tReplMetaInfoAttrTyp {
public:
    cReplMetaInfoAttrTyp() {
        insert(DS_REPL_INFO_NEIGHBORS,                  ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS);
        insert((DS_REPL_INFO_TYPE)DS_REPL_INFO_REPSTO,  ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS);
        insert(DS_REPL_INFO_CURSORS_3_FOR_NC,           ATT_MS_DS_NC_REPL_CURSORS);
        insert(DS_REPL_INFO_METADATA_2_FOR_OBJ,         ATT_MS_DS_REPL_ATTRIBUTE_META_DATA);
        insert(DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE,  ATT_MS_DS_REPL_VALUE_META_DATA);
        insert(DS_REPL_INFO_PENDING_OPS,                ROOT_DSE_MS_DS_REPL_PENDING_OPS);
        insert(DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,   ROOT_DSE_MS_DS_REPL_CONNECTION_FAILURES);
        insert(DS_REPL_INFO_KCC_DSA_LINK_FAILURES,      ROOT_DSE_MS_DS_REPL_LINK_FAILURES);
    }
} gmReplMetaInfoAttrTyp;

// add "rows" to the ReplTypeInfo "table"
/////////////////////////////////////////////////////////////////////////////////////
class cReplTypeInfo : public tReplTypeInfo {
public:
    cReplTypeInfo() {
        ReplTypeInfo row;

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(DWORD);
        insert(dsReplDWORD, row);

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(LONG);
        insert(dsReplLONG, row);

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(FILETIME);
        insert(dsReplFILETIME, row);

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(UUID);
        insert(dsReplUUID, row);

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(USN);
        insert(dsReplUSN, row);

        row.bIsPointer                  = TRUE;
        row.dwSizeof                    = sizeof(LPCSTR);
        insert(dsReplString, row);

        row.bIsPointer                  = TRUE;
        row.dwSizeof                    = sizeof(PVOID);
        insert(dsReplBinary, row);

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(DWORD);
        insert(dsReplPadding, row);

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(OpType);
        insert(dsReplOPTYPE, row);
    }
} gmReplTypeInfo;

// add "rows" to the ReplLdapInfo "table"
/////////////////////////////////////////////////////////////////////////////////////
class cReplLdapInfo : public tReplLdapInfo {
public:
    cReplLdapInfo() {
        ReplLdapInfo row;

        row.eReplStructIndex                                = dsReplNeighbor;
        row.pszLdapCommonNameBinary                         = L"msDS-NCReplInboundNeighbors;binary";
        row.pszLdapCommonNameXml                            = L"msDS-NCReplInboundNeighbors";
        row.bIsRootDseAttribute                             = FALSE;
        insert(ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS, row);

        row.eReplStructIndex                                = dsReplNeighbor;
        row.pszLdapCommonNameBinary                         = L"msDS-NCReplOutboundNeighbors;binary";
        row.pszLdapCommonNameXml                            = L"msDS-NCReplOutboundNeighbors";
        row.bIsRootDseAttribute                             = FALSE;
        insert(ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS, row);

        row.eReplStructIndex                                = dsReplCursor;
        row.pszLdapCommonNameBinary                         = L"msDS-NCReplCursors;binary";
        row.pszLdapCommonNameXml                            = L"msDS-NCReplCursors";
        row.bIsRootDseAttribute                             = FALSE;
        insert(ATT_MS_DS_NC_REPL_CURSORS, row);

        row.eReplStructIndex                                = dsReplAttrMetaData;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplAttributeMetaData;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplAttributeMetaData";
        row.bIsRootDseAttribute                             = FALSE;
        insert(ATT_MS_DS_REPL_ATTRIBUTE_META_DATA, row);

        row.eReplStructIndex                                = dsReplAttrValueMetaData;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplValueMetaData;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplValueMetaData";
        row.bIsRootDseAttribute                             = FALSE;
        insert(ATT_MS_DS_REPL_VALUE_META_DATA, row);

        row.eReplStructIndex                                = dsReplOp;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplPendingOps;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplPendingOps";
        row.bIsRootDseAttribute                             = TRUE;
        insert(ROOT_DSE_MS_DS_REPL_PENDING_OPS, row);

        row.eReplStructIndex                                = dsReplKccDsaFailure;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplConnectionFailures;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplConnectionFailures";
        row.bIsRootDseAttribute                             = TRUE;
        insert(ROOT_DSE_MS_DS_REPL_CONNECTION_FAILURES, row);

        row.eReplStructIndex                                = dsReplKccDsaFailure;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplLinkFailures;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplLinkFailures";
        row.bIsRootDseAttribute                             = TRUE;
        insert(ROOT_DSE_MS_DS_REPL_LINK_FAILURES, row);

        row.eReplStructIndex                                = dsReplNeighbor;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplAllInboundNeighbors;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplAllInboundNeighbors";
        row.bIsRootDseAttribute                             = TRUE;
        insert(ROOT_DSE_MS_DS_REPL_ALL_INBOUND_NEIGHBORS, row);

        row.eReplStructIndex                                = dsReplNeighbor;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplAllOutboundNeighbors;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplAllOutboundNeighbors";
        row.bIsRootDseAttribute                             = TRUE;
        insert(ROOT_DSE_MS_DS_REPL_ALL_OUTBOUND_NEIGHBORS, row);

        row.eReplStructIndex                                = dsReplQueueStatistics;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplQueueStatistics;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplQueueStatistics";
        row.bIsRootDseAttribute                             = TRUE;
        insert(ROOT_DSE_MS_DS_REPL_QUEUE_STATISTICS, row);
    }
} gmReplLdapInfo;




// add "rows" to the ReplStructInfo "table"
/////////////////////////////////////////////////////////////////////////////////////

#define REPL_STRUCT_INFO(field,type) { \
      L#field,\
      offsetof(CURRENT_REPL_STRUCT,field),\
      offsetof(CURRENT_REPL_STRUCT_BLOB,field),\
      type }
#define REPL_STRUCT_INFO1(field,blobField,type) { \
      L#field,\
      offsetof(CURRENT_REPL_STRUCT,field),\
      offsetof(CURRENT_REPL_STRUCT_BLOB,blobField),\
      type }

#define CURRENT_REPL_STRUCT DS_REPL_NEIGHBORW
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_NEIGHBORW_BLOB
sReplStructField aDsReplNeighbor[] = {
    REPL_STRUCT_INFO1(pszNamingContext, oszNamingContext,                dsReplString),
    REPL_STRUCT_INFO1(pszSourceDsaDN, oszSourceDsaDN,                    dsReplString),
    REPL_STRUCT_INFO1(pszSourceDsaAddress, oszSourceDsaAddress,          dsReplString),
    REPL_STRUCT_INFO1(pszAsyncIntersiteTransportDN, oszAsyncIntersiteTransportDN, dsReplString),
    REPL_STRUCT_INFO(dwReplicaFlags,                    dsReplDWORD),
    REPL_STRUCT_INFO(uuidNamingContextObjGuid,          dsReplUUID),
    REPL_STRUCT_INFO(uuidSourceDsaObjGuid,              dsReplUUID),
    REPL_STRUCT_INFO(uuidSourceDsaInvocationID,         dsReplUUID),
    REPL_STRUCT_INFO(uuidAsyncIntersiteTransportObjGuid,dsReplUUID),
    REPL_STRUCT_INFO(usnLastObjChangeSynced,            dsReplUSN),
    REPL_STRUCT_INFO(usnAttributeFilter,                dsReplUSN),
    REPL_STRUCT_INFO(ftimeLastSyncSuccess,              dsReplFILETIME),
    REPL_STRUCT_INFO(ftimeLastSyncAttempt,              dsReplFILETIME),
    REPL_STRUCT_INFO(dwLastSyncResult,                  dsReplDWORD),
    REPL_STRUCT_INFO(cNumConsecutiveSyncFailures,       dsReplDWORD)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#define CURRENT_REPL_STRUCT DS_REPL_CURSOR_3W
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_CURSOR_BLOB
sReplStructField aDsReplCursor[] = {
    REPL_STRUCT_INFO(uuidSourceDsaInvocationID,         dsReplUUID),
    REPL_STRUCT_INFO(usnAttributeFilter,                dsReplUSN),
    REPL_STRUCT_INFO(ftimeLastSyncSuccess,              dsReplFILETIME),
    REPL_STRUCT_INFO1(pszSourceDsaDN, oszSourceDsaDN, dsReplString)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#define CURRENT_REPL_STRUCT DS_REPL_ATTR_META_DATA_2
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_ATTR_META_DATA_BLOB
sReplStructField aDsReplAttrMetaData[] = {
    REPL_STRUCT_INFO1(pszAttributeName, oszAttributeName, dsReplString),
    REPL_STRUCT_INFO(dwVersion,                         dsReplDWORD),
    REPL_STRUCT_INFO(ftimeLastOriginatingChange,        dsReplFILETIME),
    REPL_STRUCT_INFO(uuidLastOriginatingDsaInvocationID,dsReplUUID),
    REPL_STRUCT_INFO(usnOriginatingChange,              dsReplUSN),
    REPL_STRUCT_INFO(usnLocalChange,                    dsReplUSN),
    REPL_STRUCT_INFO1(pszLastOriginatingDsaDN, oszLastOriginatingDsaDN, dsReplString)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#define CURRENT_REPL_STRUCT DS_REPL_VALUE_META_DATA_2
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_VALUE_META_DATA_BLOB
sReplStructField aDsReplAttrValueMetaData[] = {
    REPL_STRUCT_INFO1(pszAttributeName, oszAttributeName, dsReplString),
    REPL_STRUCT_INFO1(pszObjectDn, oszObjectDn,         dsReplString),
    REPL_STRUCT_INFO(cbData,                            dsReplDWORD),
    REPL_STRUCT_INFO1(pbData, obData,                   dsReplBinary),
    REPL_STRUCT_INFO(ftimeDeleted,                      dsReplFILETIME),
    REPL_STRUCT_INFO(ftimeCreated,                      dsReplFILETIME),
    REPL_STRUCT_INFO(dwVersion,                         dsReplDWORD),
    REPL_STRUCT_INFO(ftimeLastOriginatingChange,        dsReplFILETIME),
    REPL_STRUCT_INFO(uuidLastOriginatingDsaInvocationID,dsReplUUID),
    REPL_STRUCT_INFO(usnOriginatingChange,              dsReplUSN),
    REPL_STRUCT_INFO(usnLocalChange,                    dsReplUSN),
    REPL_STRUCT_INFO1(pszLastOriginatingDsaDN, oszLastOriginatingDsaDN, dsReplString)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#define CURRENT_REPL_STRUCT DS_REPL_OPW
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_OPW_BLOB
sReplStructField aDsReplOp[] = {
    REPL_STRUCT_INFO(ftimeEnqueued,                     dsReplFILETIME),
    REPL_STRUCT_INFO(ulSerialNumber,                    dsReplLONG),
    REPL_STRUCT_INFO(ulPriority,                        dsReplLONG),
    REPL_STRUCT_INFO(OpType,                            dsReplOPTYPE),
    REPL_STRUCT_INFO(ulOptions,                         dsReplLONG),
    REPL_STRUCT_INFO1(pszNamingContext, oszNamingContext, dsReplString),
    REPL_STRUCT_INFO1(pszDsaDN, oszDsaDN,               dsReplString),
    REPL_STRUCT_INFO1(pszDsaAddress, oszDsaAddress, dsReplString),
    REPL_STRUCT_INFO(uuidNamingContextObjGuid,          dsReplUUID),
    REPL_STRUCT_INFO(uuidDsaObjGuid,                    dsReplUUID)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#define CURRENT_REPL_STRUCT DS_REPL_KCC_DSA_FAILUREW
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_KCC_DSA_FAILUREW_BLOB
sReplStructField aDsReplKccDsaFailure[] = {
    REPL_STRUCT_INFO1(pszDsaDN, oszDsaDN,               dsReplString),
    REPL_STRUCT_INFO(uuidDsaObjGuid,                    dsReplUUID),
    REPL_STRUCT_INFO(ftimeFirstFailure,                 dsReplFILETIME),
    REPL_STRUCT_INFO(cNumFailures,                      dsReplDWORD),
    REPL_STRUCT_INFO(dwLastResult,                      dsReplDWORD)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#define CURRENT_REPL_STRUCT DS_REPL_QUEUE_STATISTICSW
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_QUEUE_STATISTICSW_BLOB
sReplStructField aDsReplQueueStatistics[] = {
    REPL_STRUCT_INFO(ftimeCurrentOpStarted,             dsReplFILETIME),
    REPL_STRUCT_INFO(cNumPendingOps,                    dsReplDWORD),
    REPL_STRUCT_INFO(ftimeOldestSync,                   dsReplFILETIME),
    REPL_STRUCT_INFO(ftimeOldestAdd,                    dsReplFILETIME),
    REPL_STRUCT_INFO(ftimeOldestDel,                    dsReplFILETIME),
    REPL_STRUCT_INFO(ftimeOldestMod,                    dsReplFILETIME),
    REPL_STRUCT_INFO(ftimeOldestUpdRefs,                dsReplFILETIME)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#undef REPL_STRUCT_INFO
#undef REPL_STRUCT_INFO1

DWORD
Repl_XmlTemplateLength(ReplStructInfo * pRow);

class cReplStructInfo : public tReplStructInfo {
public:

    cReplStructInfo() {
        ReplStructInfo row;
        // dsReplNeighbor
        row.szStructName                                    = L"DS_REPL_NEIGHBOR"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_NEIGHBORW);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_NEIGHBORW_BLOB);
        row.aReplTypeInfo                                   = aDsReplNeighbor;
        row.dwFieldCount                                    = sizeof(aDsReplNeighbor)/sizeof(sReplStructField);
        row.bHasContainerArray                              = TRUE;
        calcRow(&row);
        insert(dsReplNeighbor,row);

        // dsReplCursor
        row.szStructName                                    = L"DS_REPL_CURSOR"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_CURSOR_3W);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_CURSOR_BLOB);
        row.aReplTypeInfo                                   = aDsReplCursor;
        row.dwFieldCount                                    = sizeof(aDsReplCursor)/sizeof(sReplStructField);
        row.bHasContainerArray                              = TRUE;
        calcRow(&row);
        insert(dsReplCursor,row);

        // dsReplAttrMetaData
        row.szStructName                                    = L"DS_REPL_ATTR_META_DATA"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_ATTR_META_DATA_2);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_ATTR_META_DATA_BLOB);
        row.aReplTypeInfo                                   = aDsReplAttrMetaData;
        row.dwFieldCount                                    = sizeof(aDsReplAttrMetaData)/sizeof(sReplStructField);
        row.bHasContainerArray                              = TRUE;
        calcRow(&row);
        insert(dsReplAttrMetaData,row);

        // dsReplAttrValueMetaData
        row.szStructName                                    = L"DS_REPL_VALUE_META_DATA"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_VALUE_META_DATA_2);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_VALUE_META_DATA_BLOB);
        row.aReplTypeInfo                                   = aDsReplAttrValueMetaData;
        row.dwFieldCount                                    = sizeof(aDsReplAttrValueMetaData)/sizeof(sReplStructField);
        row.bHasContainerArray                              = TRUE;
        calcRow(&row);
        insert(dsReplAttrValueMetaData,row);

        // dsReplOp
        row.szStructName                                    = L"DS_REPL_OP"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_OPW);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_OPW_BLOB);
        row.aReplTypeInfo                                   = aDsReplOp;
        row.dwFieldCount                                    = sizeof(aDsReplOp)/sizeof(sReplStructField);
        row.bHasContainerArray                              = TRUE;
        calcRow(&row);
        insert(dsReplOp,row);

        // dsReplKccDsaFailure
        row.szStructName                                    = L"DS_REPL_KCC_DSA_FAILURE"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_KCC_DSA_FAILUREW);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_KCC_DSA_FAILUREW_BLOB);
        row.aReplTypeInfo                                   = aDsReplKccDsaFailure;
        row.dwFieldCount                                    = sizeof(aDsReplKccDsaFailure)/sizeof(sReplStructField);
        row.bHasContainerArray                              = TRUE;
        calcRow(&row);
        insert(dsReplKccDsaFailure,row);

        // dsReplQueueStatistics
        row.szStructName                                    = L"DS_REPL_QUEUE_STATISTICS"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_QUEUE_STATISTICSW);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_QUEUE_STATISTICSW_BLOB);
        row.aReplTypeInfo                                   = aDsReplQueueStatistics;
        row.dwFieldCount                                    = sizeof(aDsReplQueueStatistics)/sizeof(sReplStructField);
        row.bHasContainerArray                              = FALSE;
        calcRow(&row);
        insert(dsReplQueueStatistics,row);
    }

    void
    calcRow(ReplStructInfo * pRow) {
        DWORD i;
        DWORD dwSizeof = 0;

        Assert(ARGUMENT_PRESENT(pRow));
        Assert(ARGUMENT_PRESENT(pRow->aReplTypeInfo));

        // Count the number of pointers
        pRow->dwPtrCount = 0;
        for (i = 0; i < pRow->dwFieldCount; i++)
        {
            dwSizeof += Repl_GetTypeSize(pRow->aReplTypeInfo[i].eType);
            if (Repl_IsPointerType(pRow->aReplTypeInfo[i].eType)) {
                pRow->dwPtrCount ++;
            }
        }

        // Gather the pointer offsets into an array
        pRow->pdwPtrOffsets = NULL;
        if (pRow->dwPtrCount)
        {
            DWORD j;
            pRow->pdwPtrOffsets = (PDWORD) new DWORD[ pRow->dwPtrCount ];
            if (pRow->pdwPtrOffsets == NULL) {
                // ISSUE Jeffparh/Wlees Sept 27, 2000 Memory alloc in constructors
                RaiseException( DSA_MEM_EXCEPTION, 0, 0, NULL );
            }
            for (i = 0, j = 0; j < pRow->dwPtrCount && i < pRow->dwFieldCount; i ++)
            {
                if (Repl_IsPointerType(pRow->aReplTypeInfo[i].eType)) {
                    pRow->pdwPtrOffsets[j] = pRow->aReplTypeInfo[i].dwOffset;
                    j ++;
                }
            }
        }

        // Figure out the lenght of the xml template
        pRow->dwXmlTemplateLength = Repl_XmlTemplateLength(pRow);

        Assert(dwSizeof <= pRow->dwSizeof);
    }

} gmReplStructInfo;

// add "rows" to the ReplContainerArrayInfo "table"
/////////////////////////////////////////////////////////////////////////////////////
class cReplContainerArrayInfo : public tReplContainerArrayInfo {
public:
    cReplContainerArrayInfo() {
        ReplContainerArrayInfo row;

        // dsReplNeighbor
        row.dwOffsetArrayLength                             = offsetof(DS_REPL_NEIGHBORSW,cNumNeighbors);
        row.dwOffsetArray                                   = offsetof(DS_REPL_NEIGHBORSW,rgNeighbor);
        row.dwContainerSize                                 = sizeof(DS_REPL_NEIGHBORSW);
        insert(dsReplNeighbor,row);

        // dsReplCursor
        row.dwOffsetArrayLength                             = offsetof(DS_REPL_CURSORS_3W,cNumCursors);
        row.dwOffsetArray                                   = offsetof(DS_REPL_CURSORS_3W,rgCursor);
        row.dwContainerSize                                 = sizeof(DS_REPL_CURSORS_3W);
        insert(dsReplCursor,row);

        // dsReplAttrMetaData
        row.dwOffsetArrayLength                             = offsetof(DS_REPL_OBJ_META_DATA_2,cNumEntries);
        row.dwOffsetArray                                   = offsetof(DS_REPL_OBJ_META_DATA_2,rgMetaData);
        row.dwContainerSize                                 = sizeof(DS_REPL_OBJ_META_DATA_2);
        insert(dsReplAttrMetaData,row);

        // dsReplAttrValueMetaData
        row.dwOffsetArrayLength                             = offsetof(DS_REPL_ATTR_VALUE_META_DATA_2,cNumEntries);
        row.dwOffsetArray                                   = offsetof(DS_REPL_ATTR_VALUE_META_DATA_2,rgMetaData);
        row.dwContainerSize                                 = sizeof(DS_REPL_ATTR_VALUE_META_DATA_2);
        insert(dsReplAttrValueMetaData,row);

        // dsReplOp
        row.dwOffsetArrayLength                             = offsetof(DS_REPL_PENDING_OPSW,cNumPendingOps);
        row.dwOffsetArray                                   = offsetof(DS_REPL_PENDING_OPSW,rgPendingOp);
        row.dwContainerSize                                 = sizeof(DS_REPL_PENDING_OPSW);
        insert(dsReplOp,row);

        // dsReplKccDsaFailure
        row.dwOffsetArrayLength                             = offsetof(DS_REPL_KCC_DSA_FAILURESW,cNumEntries);
        row.dwOffsetArray                                   = offsetof(DS_REPL_KCC_DSA_FAILURESW,rgDsaFailure);
        row.dwContainerSize                                 = sizeof(DS_REPL_KCC_DSA_FAILURESW);
        insert(dsReplKccDsaFailure,row);
    }
} gmReplContainerArrayInfo;

ATTRTYP
Repl_Info2AttrTyp(DS_REPL_INFO_TYPE infoType)
/*++
Routine Description:
    Maps the replication type identifier used by the RPC functions
    to the attribute id used internally. The function is one to one
    but not onto.

Arguments:
    infoType - repl type id used by RPC

Return Values:
    the attrId used internally

--*/
{
    return gmReplMetaInfoAttrTyp.findRow(infoType);
}

LPCWSTR
Repl_GetLdapCommonName(ATTRTYP attrId, BOOL bBinary)
/*++
Routine Description:
    Returns the attribute name of the attrId which should be used during
    ldap queries.

Arguments:
    attrId - the internal attribute identifier
    bBinary - specifies the binary or XML format.

Return Values:
    The attribute name sutible for use by ldap queires.

--*/
{
    LPCWSTR szCn;

    if (bBinary)
    {
        szCn = gmReplLdapInfo.findRow(attrId).pszLdapCommonNameBinary;
    }
    else
    {
        szCn = gmReplLdapInfo.findRow(attrId).pszLdapCommonNameXml;
    }

    return szCn;
}

BOOL
Repl_IsRootDseAttr(ATTRTYP attrId)
{
    return gmReplLdapInfo.findRow(attrId).bIsRootDseAttribute;
}

BOOL
Repl_IsConstructedReplAttr(ATTRTYP index)
/*++
Routine Description:
    Discovers if an attrId specifies a replication attribute.

Arguments:
    index - the attrId

Return Values:
    TRUE if the attrId is a repl attrId, FALSE otherwise.

--*/
{
    return gmReplLdapInfo.indexExists(index);
}

DS_REPL_STRUCT_TYPE
Repl_Attr2StructTyp(ATTRTYP attrId)
/*++
Routine Description:
    Maps an attrId to the replication structure. This function is
    onto but not one to one.

Arguments:
    attrId - the attrId

Return Values:
    the structId sutible for indexing gmReplStructInfo

--*/
{
    return gmReplLdapInfo.findRow(attrId).eReplStructIndex;
}

DWORD
Repl_GetArrayContainerSize(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    The replication structures come in wrapper array structures. This function
    returns the sizeof that strucutre. Some repl structs have no array container
    structs explicity but that fact is hidden by this function. The size of a
    container array for a struct without one is the size of the struct. This makes
    sense because the container arrays have one struct inside the array struct along
    with the DWORD length field.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    size of the repl struct container array

--*/
{
    DWORD dwSize;
    ReplStructInfo & replStructInfo = gmReplStructInfo.findRow(structId);
    if (replStructInfo.bHasContainerArray)
    {
        ReplContainerArrayInfo & replContainerArrayInfo =
            gmReplContainerArrayInfo.findRow(structId);
        dwSize = replContainerArrayInfo.dwContainerSize;
    }
    else
    {
        dwSize = replStructInfo.dwSizeof;
    }

    return dwSize;
}

DWORD
Repl_GetArrayLength(DS_REPL_STRUCT_TYPE structId, puReplStructArray pStructArray)
/*++
Routine Description:
    Returns the lenght of the repl struct array.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp
    pStructArray - a pointer to the replication structure array. This union includes
        uReplStruct to include those structs without wrapper array structs.

Return Values:
    Returns the lenght of the replication array if the struct has a repl array struct
    wrapper. If there is no array wrapper struct then 1 is returned unless pStructArray
    is NULL in which case zero is returned.


--*/
{
    DWORD dwLen;
    ReplStructInfo & replStructInfo = gmReplStructInfo.findRow(structId);
    if (replStructInfo.bHasContainerArray)
    {
        ReplContainerArrayInfo & replContainerArrayInfo =
            gmReplContainerArrayInfo.findRow(structId);
        // Note that dwLen is a misnomer, since it is a count of elements in the array
        dwLen = *((LPDWORD)((PCHAR)pStructArray + replContainerArrayInfo.dwOffsetArrayLength));
    }
    else
    {
        dwLen = pStructArray ? 1 : 0;
    }

    return dwLen;
}

DWORD
Repl_SetArrayLength(DS_REPL_STRUCT_TYPE structId, puReplStructArray pStructArray, DWORD dwLength)
/*++
Routine Description:
    Sets the array length field in the array wrapper struct if there is one or does nothing if
    there is no array wrapper sturct.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp
    pStructArray - a pointer to the replication structure array. This union includes
        uReplStruct to include those structs without wrapper array structs.
    dwLength - the length of the array

Return Values:

--*/
{
    ReplStructInfo & replStructInfo = gmReplStructInfo.findRow(structId);
    if (replStructInfo.bHasContainerArray)
    {
        ReplContainerArrayInfo & replContainerArrayInfo =
            gmReplContainerArrayInfo.findRow(structId);

        *(PDWORD)((PCHAR)pStructArray + replContainerArrayInfo.dwOffsetArrayLength) = dwLength;
    }
    else
    {
        Assert((dwLength == 1 && pStructArray) ||
               (dwLength == 0 && !pStructArray));
    }

    return 0;
}

void
Repl_GetElemArray(DS_REPL_STRUCT_TYPE structId, puReplStructArray pStructArray, PCHAR *ppElemArray)
/*++
Routine Description:
    Returns a pointer to an array or replication structures given the array wrapper struct.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp
    pStructArray - a pointer to the replication structure array. This union includes
        uReplStruct to include those structs without wrapper array structs.
    ppElemArray - the pointer to the array of replication structures.

Return Values:

--*/
{
    ReplStructInfo & replStructInfo = gmReplStructInfo.findRow(structId);
    if (replStructInfo.bHasContainerArray)
    {
        ReplContainerArrayInfo & replContainerArrayInfo =
            gmReplContainerArrayInfo.findRow(structId);
        *ppElemArray = ((PCHAR)pStructArray + replContainerArrayInfo.dwOffsetArray);
    }
    else
    {
        *ppElemArray = (PCHAR)&pStructArray->singleReplStruct;
    }
}

DWORD
Repl_GetElemSize(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Gets the size of the replication strucure

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    The sizeof the replication structure

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.dwSizeof;
}

DWORD
Repl_GetElemBlobSize(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Gets the size of the replication strucure

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    The sizeof the replication structure

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.dwBlobSizeof;
}

PDWORD
Repl_GetPtrOffsets(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Used to locate the pointers in a replication structure.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    Returns an array of the offsets of pointers in the replication structure
    in acending order.


--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.pdwPtrOffsets;
}

DWORD
Repl_GetPtrCount(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Get the number of pointers in a replication structure.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    Returns the number of pointers in a replication structure

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.dwPtrCount;
}

DWORD
Repl_GetFieldCount(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Get the number of fields in a replication structure.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    Returns the number of fields in a replication structure

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.dwFieldCount;
}

psReplStructField
Repl_GetFieldInfo(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Return information on the fields in a structure.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    Return information on the fields in a structure.

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.aReplTypeInfo;
}


LPCWSTR
Repl_GetStructName(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Yet another access function.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    Returns the name of the structure.

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.szStructName;
}

DWORD
Repl_GetXmlTemplateLength(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Yet another access function.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    Returns the length of the Xml template w/o any data in it.

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.dwXmlTemplateLength;
}

BOOL
Repl_IsPointerType(DS_REPL_DATA_TYPE typeId)
/*++
Routine Description:
    Is the type a pointer.

Arguments:
    typeId - the type id

Return Values:
    TRUE if the type is a pointer, false otherwise

--*/
{
    ReplTypeInfo & replTypeInfo =
        gmReplTypeInfo.findRow(typeId);

    return replTypeInfo.bIsPointer;
}

DWORD
Repl_GetTypeSize(DS_REPL_DATA_TYPE typeId)
/*++
Routine Description:
    Sizeof the field.

Arguments:
    typeId - the type id

Return Values:
    The size of the field

--*/
{
    ReplTypeInfo & replTypeInfo =
        gmReplTypeInfo.findRow(typeId);

    return replTypeInfo.dwSizeof;
}

#define REPL_TOTAL_WCSLEN(repl,str) (repl.str ? wcslen(repl.str) * 2 + 2 : 0)
#define REPL_LOG_STRING(index,repl,str) \
    { if (aPtrLengths) { aPtrLengths[(index)] = (REPL_TOTAL_WCSLEN(repl,str)); } \
      if (pdwSum) { *(pdwSum) += (DWORD)(REPL_TOTAL_WCSLEN(repl,str)); } }
#define REPL_LOG_BLOB(index,len) \
    { if (aPtrLengths) { (aPtrLengths)[(index)] = (len); } \
      if (pdwSum) { *(pdwSum) += (len); } }

void
Repl_GetPtrLengths(DS_REPL_STRUCT_TYPE structId,
                   puReplStruct pReplStruct,
                   DWORD aPtrLengths[],
                   DWORD dwArrLength,
                   PDWORD pdwSum)
/*++
Routine Description:
    Returns the length of the data pointed to by pointers in a replication structure.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp
    pReplStruct - a pointer to the replication structure in question
    aPtrLenghts - an array to hold the pointer lenghts
    dwArrLenght - the lenght of aPtrLenghts. Must be >= the number of pointers
        in the replication structure.

Return Values:


--*/
{
    DWORD dwPtrCount = Repl_GetPtrCount(structId);
    DS_REPL_STRUCT_TYPE structIndex = structId;

    Assert(IMPLIES(aPtrLengths, dwArrLength >= dwPtrCount));

    if (pdwSum) {
        *pdwSum = 0;
    }

    if (0 == dwPtrCount) {
        return;
    }

    switch (structIndex)
    {
    case dsReplNeighbor:
        REPL_LOG_STRING(0, pReplStruct->neighborw, pszNamingContext);
        REPL_LOG_STRING(1, pReplStruct->neighborw, pszSourceDsaDN)
        REPL_LOG_STRING(2, pReplStruct->neighborw, pszSourceDsaAddress)
        REPL_LOG_STRING(3, pReplStruct->neighborw, pszAsyncIntersiteTransportDN)
        break;

    case dsReplAttrMetaData:
        REPL_LOG_STRING(0, pReplStruct->attrMetaData, pszAttributeName)
        REPL_LOG_STRING(1, pReplStruct->attrMetaData, pszLastOriginatingDsaDN);
        break;

    case dsReplAttrValueMetaData:	
        REPL_LOG_STRING(0, pReplStruct->valueMetaData, pszAttributeName);
        REPL_LOG_STRING(1, pReplStruct->valueMetaData, pszObjectDn);
        REPL_LOG_BLOB(2, pReplStruct->valueMetaData.cbData); // All this work for this!
        REPL_LOG_STRING(3, pReplStruct->valueMetaData, pszLastOriginatingDsaDN);
        break;

    case dsReplOp:
        REPL_LOG_STRING(0, pReplStruct->op, pszNamingContext);
        REPL_LOG_STRING(1, pReplStruct->op, pszDsaDN);
        REPL_LOG_STRING(2, pReplStruct->op, pszDsaAddress);
        break;

    case dsReplKccDsaFailure:
        REPL_LOG_STRING(0, pReplStruct->kccFailure, pszDsaDN);
        break;

    case dsReplCursor:
        REPL_LOG_STRING(0, pReplStruct->cursor, pszSourceDsaDN);
        break;

    default:
        Assert(0);
    }
}

BOOL
/*++
Routine Description:
    Inorder to decouple an algorithm from a memory allocation scheme many replication
    functions require the user to allocate any memory and pass it to the algorithm as
    a buffer (pBuffer). The function will return by referance in pdwBufferSize the
    amount of memory it needs unless an error code other than ERROR_MORE_DATA is returned
    in which case zero is returned by referance in pdwBufferSize.

    If NULL is passed in place of the buffer no error code will be returned from the
    replication function. If the buffer is too small then ERROR_MORE_DATA will be returned
    from the replication function.

    This function:

        1. Returns true if the replication function has enough memory to continue or
           false if it should request more memory.
        2. If false is returned then the return code from the replication function should
           return is returned by referance (in pRet) from this function and will either be
           ERROR_SUCCESS if pBuffer is NULL or ERROR_MORE_DATA if pBuffer is too small.
           If true is returned pRet should be ignored and pdwBufferSize is set to 0. The
           replication function should set pdwBufferSize to dwRequired size before returing
           if the function was successful and should leave it as zero if an error occures.
        3. pdwBufferSize is set to dwRequiredSize.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp
    pReplStruct - a pointer to the replication structure in question
    aPtrLenghts - an array to hold the pointer lenghts
    dwArrLenght - the lenght of aPtrLenghts. Must be >= the number of pointers
        in the replication structure.

Return Values:


--*/
requestLargerBuffer(PCHAR pBuffer, PDWORD pdwBufferSize, DWORD dwRequiredSize, PDWORD pRet)
{
    Assert(ARGUMENT_PRESENT(pRet));
    Assert(ARGUMENT_PRESENT(pdwBufferSize));

    *pRet = ERROR_SUCCESS;
    if (!pBuffer) {
        *pdwBufferSize = dwRequiredSize;
        *pRet = ERROR_SUCCESS;
        return TRUE;
    }
    else if(*pdwBufferSize < dwRequiredSize) {
        *pdwBufferSize = dwRequiredSize;
        *pRet = ERROR_MORE_DATA;
        return TRUE;
    }
    *pdwBufferSize = 0;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rpcspoof\replrpcimpl.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:
    ReplRpcImpl.cxx

Abstract:
    Calls to _DsReplicaGetInfo and _DsReplicatGetInfo2W are functionally
    equivilant to calls to DsReplicaGetInfo and DsReplicaGetInfo2W but use
    LDAP to retrieve the data instead of RPC when possible.

    See ReplRpcSpoofState.cxx.

    The following functions are spoofed in this file:
    _DsReplicaGetInfo

    ISSUE Sep 22, 2000 wlees
    The _DsReplicatGetInfo2W is not spoofed. The 2 version of this case differs in
    the arguments that may be passed to the server. Unfortunately, the additional
    arguments do not fit into the ldap model, and thus would have to be simulated at
    the client side. The primary purpose for the 2 version is to allow the rpc
    interface to do paging. If we were to spoof this call, we should map the paging
    state context into range syntax and back again.

Author:

    Chris King          [t-chrisk]    July-2000
    
Revision History:

--*/

#include <NTDSpchx.h>
#pragma hdrstop

#include <winldap.h>
#include <ntldap.h>
#include <drs.h>
#include <debug.h>

#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplRPCSpoofState.hxx"
#include "ReplRpcSpoofProto.hxx"

#define RANGE_OPTION L"range="
#define RANGE_OPTION_LENGTH  (sizeof(RANGE_OPTION) - sizeof(WCHAR))

DWORD
Repl_DeMarshalBerval(DS_REPL_STRUCT_TYPE dsReplStructType, 
                     berval * ldapValue[], OPTIONAL
                     DWORD dwNumValues,
                     puReplStructArray pReplStructArray, OPTIONAL
                     PDWORD pdwReplStructArrayLen);


DWORD
WINAPI
_DsReplicaGetInfo2W(
    IN  HANDLE              hRpc,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  LPCWSTR             pszObject OPTIONAL,
    IN  UUID *              puuidForSourceDsaObjGuid OPTIONAL,
    IN  LPCWSTR             pszAttributeName OPTIONAL,
    IN  LPCWSTR             pszValueDN OPTIONAL,
    IN  DWORD               dwFlags,
    IN  DWORD               dwEnumerationContext,
    OUT VOID **             ppInfo
    )

/*++

  Routine Descriptions:
    Functional equivilant to the RPC version this function gets data via LDAP
    when it can. The RPC interface is more functional than the LDAP interface.
    When an RPC call is made which can not be implemented in a straightforward
    manner via LDAP, this function defaults to making a DsReplicatGetInfoW call.
    Under these conditions DsReplicatGetInfo2W is called:

    * the Active Directory does not support replication via LDAP or the handle was retrieved 
      from DsBindWithCredW
    * ppuidForSourceDsaObjGuid is non-NULL

  Arguments:
    hRpc - Handle returned by _DsBindWithCredW or DsBindWithCredW
    InfoType - The replication information type
    pszObject - The object assocated with the replication attribute
    ppInfo - Resulting replication array container structure

  Return values:
    Various LDAP errors.
    
--*/ 
{
    DWORD err;
    LDAP * phLdap = NULL;
    phLdap = getBindings(hRpc);
    puReplStructArray pReplStructArray;
    // Emulate RPC interface. Make deleted objects visible.
    LDAPControlW     ctrlShowDeleted = { LDAP_SERVER_SHOW_DELETED_OID_W };
    LDAPControlW *   rgpctrlServerCtrls[] = { &ctrlShowDeleted,
                                              NULL };

    // Check for reasons to fallback
    // 1. Ldap connection could not be made
    // 2. Feature of rpc interface used, and ldap does not support yet
    // 3. Item code is obsolete
    if (!phLdap ||
        puuidForSourceDsaObjGuid ||
        pszAttributeName ||
        pszValueDN ||
        dwFlags ||
        (DS_REPL_INFO_CURSORS_FOR_NC == InfoType) ||
        (DS_REPL_INFO_CURSORS_2_FOR_NC == InfoType) ||
        (DS_REPL_INFO_METADATA_FOR_OBJ == InfoType) ||
        (DS_REPL_INFO_METADATA_FOR_ATTR_VALUE == InfoType) ||
	(DS_REPL_INFO_CLIENT_CONTEXTS == InfoType))
    {
        // Fallback to RPC
        return DsReplicaGetInfo2W(
            hRpc,
            InfoType,
            pszObject,
            puuidForSourceDsaObjGuid,
            pszAttributeName,
            pszValueDN,
            dwFlags,
            dwEnumerationContext,
            ppInfo);
    }

    LDAPMessage * pLDAPMsg = NULL; 
    ATTRTYP attrId;
    LPCWSTR aAttributes[2] = {
        NULL, 
        NULL,
    };

    if (DS_REPL_INFO_NEIGHBORS == InfoType && !pszObject)
    {
        attrId = ROOT_DSE_MS_DS_REPL_ALL_INBOUND_NEIGHBORS;
    }
    else if (DS_REPL_INFO_REPSTO == InfoType && !pszObject)
    {
        attrId = ROOT_DSE_MS_DS_REPL_ALL_OUTBOUND_NEIGHBORS;
    }
    else
    {
        attrId = Repl_Info2AttrTyp(InfoType);
    }


    // Construct a range limited attribute
    LPCWSTR pszBase = Repl_GetLdapCommonName(attrId, TRUE);
    LPWSTR pszName = (LPWSTR) alloca( (wcslen( pszBase ) + 1 +
                                       RANGE_OPTION_LENGTH + 15 +
                                       1 + 1) * sizeof(WCHAR) );
    swprintf( pszName, L"%s;%s%d-*",
              pszBase, RANGE_OPTION, dwEnumerationContext );
    aAttributes[0] = pszName;

    struct berval** ppBerval = NULL;
    DWORD dwNumValues = 0;

    // Search
    err = ldap_search_ext_sW(
        phLdap,
        (PWCHAR)pszObject,
        LDAP_SCOPE_BASE,
        L"(objectclass=*)",
        (LPWSTR*)aAttributes ,
        0,                         // attrs only
        rgpctrlServerCtrls,        // server ctrls
        NULL,                      // client ctrls
        NULL,                      // timeout
        0,                         // size limit
        &pLDAPMsg);
    if (err != LDAP_SUCCESS) {
        return LdapMapErrorToWin32(err);
    }
    if (!pLDAPMsg)
        return 1;

    // Get values
    PWCHAR szRetAttribute;
    berelement * pCookie;
    DWORD dwRangeLower = 0, dwRangeUpper = 0xffffffff;
    szRetAttribute = ldap_first_attributeW(phLdap, pLDAPMsg, &pCookie);
    if (szRetAttribute) {
        LPWSTR p1;

        // Decode returned range, if any
        p1 = wcsstr( szRetAttribute, RANGE_OPTION );
        if (p1) {
            p1 += RANGE_OPTION_LENGTH / 2;
            dwRangeLower = _wtoi( p1 );
            Assert( dwRangeLower == dwEnumerationContext );
            p1 = wcschr( p1, L'-' );
            if (p1) {
                p1++;
                if (*p1 == L'*') {
                    dwRangeUpper = 0xffffffff;
                } else {
                    dwRangeUpper = _wtoi( p1 );
                }
            }
        }

        ppBerval = ldap_get_values_lenW(phLdap, pLDAPMsg, szRetAttribute);
        ldap_memfreeW(szRetAttribute);
        dwNumValues = ldap_count_values_len(ppBerval);
    }
    // It is legit for szRetAttribute or dwNumValues to be zero. It indicates
    // that there were not any values on this constructed attribute.

    // Demarshal blob
    DWORD dwInfoSize;
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId); 
    err = Repl_DeMarshalBerval(structId, ppBerval, dwNumValues, NULL, &dwInfoSize);
    Assert(!err);
    if (err) {
        return ERROR_INTERNAL_ERROR;
    }

    *ppInfo = (void *)malloc(dwInfoSize);
    if (*ppInfo == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pReplStructArray = (puReplStructArray)*ppInfo;
    err = Repl_DeMarshalBerval(structId, ppBerval, dwNumValues, pReplStructArray, &dwInfoSize);
    Assert(!err);
    if (err) {
        return ERROR_INTERNAL_ERROR;
    }

    if (ROOT_DSE_MS_DS_REPL_PENDING_OPS == attrId) {
        // ISSUE: Need to fill this in using the queue statistics attribute
        memset( &(((DS_REPL_PENDING_OPSW *)pReplStructArray)->ftimeCurrentOpStarted), 0, sizeof( FILETIME ) );
    } else if (DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE == InfoType) {
        if (dwRangeUpper == 0xffffffff) {
            ((DS_REPL_ATTR_VALUE_META_DATA_2 *)pReplStructArray)->dwEnumerationContext =
                dwRangeUpper;
        } else {
            // The enumeration context is defined to be the next available item
            ((DS_REPL_ATTR_VALUE_META_DATA_2 *)pReplStructArray)->dwEnumerationContext =
                dwRangeUpper + 1;
        }
    }

    logPointer(*ppInfo, ppBerval, pLDAPMsg);

    return 0;
}

DWORD
WINAPI
_DsReplicaGetInfoW(
    HANDLE              hRpc,                       // in
    DS_REPL_INFO_TYPE   InfoType,                   // in
    LPCWSTR             pszObject,                  // in
    UUID *              puuidForSourceDsaObjGuid,   // in
    VOID **             ppInfo)                     // out
{
    return _DsReplicaGetInfo2W(
        hRpc,
        InfoType,
        pszObject,
        puuidForSourceDsaObjGuid,
        NULL, // pszAttributeName
        NULL, // pszValueDn
        0, // dwFlags
        0, // dwEnumerationContext
        ppInfo
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\rpcspoof\replrpcspoofstate.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:
    ReplRpcSpoofState.cxx

Abstract:
    To spoof the replication RPC calls an RPC and LDAP connection
    need to be associated with the handle passed back to the user
    and pointers returend from RPC and LDAP need to be associated
    with their appropreate clean up functions. To make these associations
    STL map class is used.

    The spoofed _ functions are functionally the same as their RPC
    counter parts. They interoperate in the same way. The RPC handle
    returned by _DsBindWithCredW can be used by non spoofed RPC functions.
    If an RPC handle returned from DsBindWithCredW is passed to any
    spoofed RPC functions the spoofed functions will place calls to the
    non spoofed RPC functions.

    The following functions are spoofed in this file:

    _DsBindWithCredW
    _DsUnBind
    _DsReplicaFreeInfo

Author:

    Chris King          [t-chrisk]    July-2000

Revision History:

--*/
#include <NTDSpchx.h>
#pragma hdrstop

#include <ntdsa.h>
#include <drs.h>
#include <winldap.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles

#include <map>
using namespace std;

#include "ReplRpcSpoofProto.hxx"
#include "ReplRpcSpoofState.hxx"

typedef struct _memoryLog {
    berval ** ppBerval;
    LDAPMessage * pLDAPMsg;
} memoryLog;

typedef map<HANDLE, LDAP *, less<HANDLE> > mBindings; // f:HANDLE->LDAP *
typedef map<PVOID, memoryLog, less<PVOID> > mBervalPtr;  // f:pvoid->berval **

// Note, these global structures should be protected by a synchronization
// mechanism if we ever use this library for multi-threaded clients.
mBindings gmBindings;
mBervalPtr gmBervalPtrs;
// Process-wide default data provider
BOOL gfUseLdap = TRUE;

DWORD
WINAPI
_DsBindWithCredW(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    HANDLE          *phDS)
/*++

  Routine Descriptions:
    Functional equivilant to the RPC version this function also opens an LDAP session if
    support is discovered for returning replication information via LDAP. A mapping between
    the RPC and LDAP handle is established.

  Arguments:
    DomainControllerName - DC
    DnsDomainName - DNS name
    AuthIdentity - Auth object
    phDS - an RPC handle which could be used by non spoofed RPC functions

  Return values:
    Various LDAP errors.

--*/
{
    DWORD ret;
    LDAP * phLdap = NULL;
    HANDLE hRpc;
    ULONG  ulOptions;
    LPWSTR pszTargetName;
    LDAPMessage * pRes = NULL;
    LPWSTR pszLdapHostList = NULL;
    PWCHAR szFilter = L"(objectclass=*)";
    PWCHAR attrs[2] = { L"supportedExtension", NULL };
    LPWSTR *ppszExtensions = NULL;
    BOOL fServerSupportsLdapReplInfo;
    BindState * pBindState;

    ret = DsBindWithCredW(DomainControllerName,
                          DnsDomainName,
                          AuthIdentity,
                          &hRpc);
    if (ret != NO_ERROR) {
        return ret;
    }

    // Crack DS handle to retrieve extensions of the target DSA.
    pBindState = (BindState *) hRpc;

    // Check for GETCHGREPLY_V5 (WHISTLER BETA 2)
    // We now require Whistler beta 2 since the name and range parsing for
    // RootDSE replication attributes has changed.
    fServerSupportsLdapReplInfo =
        IS_DRS_EXT_SUPPORTED(pBindState->pServerExtensions,
                             DRS_EXT_GETCHGREPLY_V5 );

    // Open an LDAP session and see if replication information via LDAP is supported
    if (gfUseLdap && fServerSupportsLdapReplInfo) {
        if (DomainControllerName){
            pszTargetName = (LPWSTR)DomainControllerName;
        } else {
            pszTargetName = (LPWSTR)DnsDomainName;
        }

        // Ldap supports a list of host:port pairs to try in order.
        // We try to connect to the GC port first if we can, since that allows us
        // to lookup readonly objects.  Ldap will make writeable objects on the GC
        // look like readonly objects, but that shouldn't matter for our
        // constructed attributes.
        pszLdapHostList = (LPWSTR) malloc(
            (wcslen(pszTargetName) * 2 + 15) * sizeof( WCHAR ) );
        if (pszLdapHostList == NULL) {
            // DsBindWithCred succeeded !? Go with it.
            // phLdap already NULL - Fall back
            goto cleanup;
        }
        swprintf( pszLdapHostList, L"%s:%d %s:%d",
                  pszTargetName, LDAP_GC_PORT,
                  pszTargetName, LDAP_PORT );

        // Init connection block
        phLdap = ldap_initW(pszLdapHostList, 0);
        if (NULL == phLdap) {
            // This routine does not connect and should not fail
            // DsBindWithCred succeeded !? Go with it.
            // phLdap already NULL - Fall back
            goto cleanup;
        }

        // use only A record dns name discovery
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        (void)ldap_set_optionW( phLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );
        // Don't follow referrals. The RPC interface doesn't.
        ulOptions = PtrToUlong(LDAP_OPT_OFF);
        (void)ldap_set_optionW( phLdap, LDAP_OPT_REFERRALS, &ulOptions );

        // Bind
        ret = ldap_bind_sW(phLdap, pszTargetName, (PWCHAR)AuthIdentity, LDAP_AUTH_SSPI);
        if (ret != LDAP_SUCCESS)
        {
            printf("Cannot connect or bind LDAP connection to %ls.\n", pszTargetName);
            // Fall back
            ldap_unbind(phLdap);
            phLdap = NULL; // Fall back
            goto cleanup;
        }
        printf( "Replication information via LDAP support found.\n" );
    }

cleanup:
    if (pszLdapHostList) {
        free( pszLdapHostList );
    }
    if (ppszExtensions) {
        ldap_value_freeW( ppszExtensions );
    }
    if (pRes) {
        ldap_msgfree(pRes);
    }

    gmBindings[hRpc] = phLdap;
    *phDS = hRpc;
    return 0;
}

DWORD
_DsUnBind(HANDLE *phRpc)
/*++

  Routine Descriptions:
    Functional equivilant to the RPC version this function closes the associated
    RPC session and LDAP session if one was established.

  Arguments:
    phDS - opaque session handle

  Return values:
    None.

--*/
{
    LDAP * phLdap = getBindings(*phRpc);
    if (phLdap)
        ldap_unbind(phLdap);

    DsUnBind(phRpc);

    return 0;
}

LDAP *
getBindings(HANDLE hRpc)
/*++

  Routine Descriptions:
    Maps the RPC session handle to the LDAP handle.

  Arguments:
    hRpc - an RPC handle

  Return values:
    Returns LDAP handle if one is associated with the hRpc handle.

--*/
{
    LDAP * phLdap = NULL;

    mBindings::iterator itr;
    itr = gmBindings.find(hRpc);
    if (itr != gmBindings.end())
        phLdap = (*itr).second;

    return phLdap;
}

void
logPointer(void * pReplStruct, berval ** ppBerval, LDAPMessage * pLDAPMsg)
/*++

  Routine Descriptions:
    This function associates pointers to replication
    structures returned by _DsReplicaGetInfoW and 2W to the berval and ldap
    message the data came in on.

  Arguments:
    pReplStruct - pointer to replication structure returned by _DsReplicaGetInfoW
    ppBerval - pointer to the berval associated with the pLDAPMsg
    pLDAPMsg - the LDAP message will contain only the ppBerval

--*/
{
    memoryLog memLog = {
        ppBerval, pLDAPMsg
    };
    gmBervalPtrs[pReplStruct] = memLog;
}

VOID
WINAPI
_DsReplicaFreeInfo(
    DS_REPL_INFO_TYPE   InfoType,
    VOID *              pInfo
    )
/*++

  Routine Descriptions:
    Searches for an association between pInfo and any LDAP structures. If no association
    is found then the pInfo was returned by DsReplicaGetInfo and should be freed with
    DsReplicaFreeInfo. If an association was found then LDAP memory functions are used
    to free the associated LDAP structures.

  Arguments:
    InfoType - type of information pointed to by pInfo
    pInfo - pointer to replication structure returned by _DsReplicaGetInfoW

--*/
{
    mBervalPtr::iterator itr;
    itr = gmBervalPtrs.find(pInfo);
    if (itr == gmBervalPtrs.end())
    {
        // This pointer belongs to the RPC interface
        DsReplicaFreeInfo(InfoType, pInfo);
    }
    else
    {
        memoryLog memLog = (*itr).second;

        // pInfo pointer refers to a de-marshaled repl structure
        if (memLog.ppBerval)
            ldap_value_free_len(memLog.ppBerval);
        if (memLog.pLDAPMsg)
            ldap_msgfree(memLog.pLDAPMsg);
        free(pInfo);

        gmBervalPtrs.erase(itr);
    }
}


BOOL
_DsBindSpoofSetTransportDefault(
    BOOL fUseLdap
    )

/*++

Routine Description:

    Change the default data provider for the spoofing library.
    This is a process-wide default.
    At process initialization, the spoofing library uses Ldap.

Arguments:

    fUseLdap - TRUE to use LDAP, false to use DsBind/RPC

Return Value:

    BOOL - Old value

--*/

{
    BOOL fOldValue = gfUseLdap;
    gfUseLdap = fUseLdap;
    return fOldValue;
} /* _DsBindSpoofSetTransportDefault */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\schemard\base64.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    base64.c

ABSTRACT:

    Base64 encoding and decoding functions.

DETAILS:
    
CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#include "debug.h"


NTSTATUS
base64encode(
      VOID    *pDecodedBuffer,
      DWORD   cbDecodedBufferSize,
      UCHAR   *pszEncodedString,
      DWORD   cchEncodedStringSize,
      DWORD   *pcchEncoded   
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pDecodedBuffer (IN) - buffer to encode.
    cbDecodedBufferSize (IN) - size of buffer to encode.
    cchEncodedStringSize (IN) - size of the buffer for the encoded string.
    pszEncodedString (OUT) = the encoded string.
    pcchEncoded (OUT) - size in characters of the encoded string.

Return Values:

    0 - success.
    STATUS_INVALID_PARAMETER
    STATUS_BUFFER_TOO_SMALL

--*/
{
    static char rgchEncodeTable[64] = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    DWORD   ib;
    DWORD   ich;
    DWORD   cchEncoded;
    BYTE    b0, b1, b2;
    BYTE *  pbDecodedBuffer = (BYTE *) pDecodedBuffer;

    // Calculate encoded string size.
    cchEncoded = 1 + (cbDecodedBufferSize + 2) / 3 * 4;

    if (NULL != pcchEncoded) {
        *pcchEncoded = cchEncoded;
    }

    if (cchEncodedStringSize < cchEncoded) {
        // Given buffer is too small to hold encoded string.
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Encode data byte triplets into four-byte clusters.
    ib = ich = 0;
    while (ib < cbDecodedBufferSize) {
        b0 = pbDecodedBuffer[ib++];
        b1 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;
        b2 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;

        pszEncodedString[ich++] = rgchEncodeTable[b0 >> 2];
        pszEncodedString[ich++] = rgchEncodeTable[((b0 << 4) & 0x30) | ((b1 >> 4) & 0x0f)];
        pszEncodedString[ich++] = rgchEncodeTable[((b1 << 2) & 0x3c) | ((b2 >> 6) & 0x03)];
        pszEncodedString[ich++] = rgchEncodeTable[b2 & 0x3f];
    }

    // Pad the last cluster as necessary to indicate the number of data bytes
    // it represents.
    switch (cbDecodedBufferSize % 3) {
      case 0:
        break;
      case 1:
        pszEncodedString[ich - 2] = '=';
        // fall through
      case 2:
        pszEncodedString[ich - 1] = '=';
        break;
    }

    // Null-terminate the encoded string.
    pszEncodedString[ich++] = '\0';

    //Assert(ich == cchEncoded);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\schupgr\schupgr.h ===
#include <winldap.h>
#include <drs.h>
#include <dsconfig.h>

// Message header file
#include "msg.h"

// Maximum characters to search for a token. Should fit in
// the max-length token that we are interested in, currently
// defaultObjectCategory

#define MAX_TOKEN_LENGTH  25

// Max length of a line to be read or written out
#define MAX_BUFFER_SIZE   10000


#define LDIF_STRING  L"sch"
#define LDIF_SUFFIX  L".ldf"

// Logging/Printing options
#define LOG_ONLY 0
#define LOG_AND_PRT 1


// Some internal error codes
#define  UPG_ERROR_CANNOT_OPEN_FILE     1
#define  UPG_ERROR_BAD_CONFIG_DN        2
#define  UPG_ERROR_LINE_READ            3 

// Registry Keys
#define SCHEMADELETEALLOWED "Schema Delete Allowed"
#define SYSTEMONLYALLOWED   "Allow System Only Change"


// Function prototype
void LogMessage(ULONG options, DWORD msgID, WCHAR *pWArg1, WCHAR *pWArg2);
WCHAR *LdapErrToStr(DWORD LdapErr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\schemard\cache.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <schemard.h>


// Global Prefix Table pointer
PVOID PrefixTable = NULL;

// Global variable indicating next index to assign to a new prefix
ULONG DummyNdx = 1;

//Internal debug function
void PrintOid(PVOID Oid, ULONG len);


///////////////////////////////////////////////////////
//     Functions for hashing by Id and by name
//////////////////////////////////////////////////////

__inline ULONG IdHash(ULONG hkey, ULONG count)
{
    return((hkey << 3) % count);
}

__inline ULONG NameHash( ULONG size, PUCHAR pVal, ULONG count )
{
    ULONG val=0;
    while(size--) {
        // Map A->a, B->b, etc.  Also maps @->', but who cares.
        val += (*pVal | 0x20);
        pVal++;
    }
    return (val % count);
}


/*++
Routine Description:

    Find an attcache given its attribute id.

Arguments:
    SCPtr  - Pointer to the schema cache to search in
    attrid - the attribute id to look up.
    ppAttcache - the attribute cache returned

Return Value:
    Returns non-zero on error (non-find), 0 otherwise.
--*/

int __fastcall GetAttById( SCHEMAPTR *SCPtr, ULONG attrid, 
                           ATT_CACHE** ppAttcache )

{
    register ULONG  i;
    HASHCACHE      *ahcId    =  SCPtr->ahcId;
    ULONG           ATTCOUNT = SCPtr->ATTCOUNT;

    for (i=IdHash(attrid,ATTCOUNT);
         (ahcId[i].pVal && (ahcId[i].hKey != attrid)); i++){
        if (i >= ATTCOUNT) {
            i=0;
        }
    }
    *ppAttcache = (ATT_CACHE*)ahcId[i].pVal;
    return (!ahcId[i].pVal);
}


/*++
Routine Description:

    Find an attcache given its MAPI property id.

Arguments:
    SCPtr  - Pointer to the schema cache to search in
    ulPropID - the jet column id to look up.
    ppAttcache - the attribute cache returned

Return Value:
    Returns non-zero on error (non-find), 0 otherwise.
--*/
int __fastcall GetAttByMapiId( SCHEMAPTR *SCPtr, ULONG ulPropID, 
                               ATT_CACHE** ppAttcache )

{
    register ULONG  i;
    HASHCACHE      *ahcMapi  = SCPtr->ahcMapi;
    ULONG           ATTCOUNT = SCPtr->ATTCOUNT;

    for (i=IdHash(ulPropID,ATTCOUNT);
         (ahcMapi[i].pVal && (ahcMapi[i].hKey != ulPropID)); i++){
        if (i >= ATTCOUNT) {
            i=0;
        }
    }
    *ppAttcache = (ATT_CACHE*)ahcMapi[i].pVal;
    return (!ahcMapi[i].pVal);
}


/*++
Routine Description:

    Find an attcache given its name.

Arguments:
    SCPtr  - Pointer to schema cache to search in
    ulSize - the num of chars in the name.
    pVal - the chars in the name
    ppAttcache - the attribute cache returned

Return Value:
    Returns non-zero on error (non-find), 0 otherwise.

--*/
int __fastcall GetAttByName( SCHEMAPTR *SCPtr, ULONG ulSize, 
                             PUCHAR pVal, ATT_CACHE** ppAttcache )
{
    register ULONG i;
    HASHCACHESTRING* ahcName = SCPtr->ahcName;
    ULONG ATTCOUNT = SCPtr->ATTCOUNT;

    for (i=NameHash(ulSize,pVal,ATTCOUNT);
         (ahcName[i].pVal &&            // this hash spot refers to an object,
            (ahcName[i].length != ulSize || // but the size is wrong
              _memicmp(ahcName[i].value,pVal,ulSize))); // or the value is wrong
             i++){
          if (i >= ATTCOUNT) {
               i=0;
          }
     }

    *ppAttcache = (ATT_CACHE*)ahcName[i].pVal;
    return (!ahcName[i].pVal);
}


/*++
Routine Description:

    Find a classcache given its class id

Arguments:
    SCPtr  - Pointer to the schema cache to search in
    classid - class id to look up
    ppClasscache - the class cache returned

Return Value:
    Returns non-zero on error (non-find), 0 otherwise.
--*/
int __fastcall GetClassById( SCHEMAPTR *SCPtr, ULONG classid, 
                             CLASS_CACHE** ppClasscache )
{
    register ULONG i;
    HASHCACHE*  ahcClass     = SCPtr->ahcClass;
    ULONG CLSCOUNT = SCPtr->CLSCOUNT;

    for (i=IdHash(classid,CLSCOUNT);
         (ahcClass[i].pVal && (ahcClass[i].hKey != classid)); i++){
        if (i >= CLSCOUNT) {
            i=0;
        }
    }
    *ppClasscache = (CLASS_CACHE*)ahcClass[i].pVal;
    return (!ahcClass[i].pVal);
}


/*++
Routine Description:

    Find a classcache given its name.

Arguments:
    SCPtr  - Pointer to schema cache to search in
    ulSize - the num of chars in the name.
    pVal - the chars in the name
    ppClasscache - the class cache returned

Return Value:
    Returns non-zero on error (non-find), 0 otherwise.

--*/

int __fastcall GetClassByName( SCHEMAPTR *SCPtr, ULONG ulSize, 
                               PUCHAR pVal, CLASS_CACHE** ppClasscache )
{
    register ULONG i;
    HASHCACHESTRING* ahcClassName = SCPtr->ahcClassName;
    ULONG CLSCOUNT = SCPtr->CLSCOUNT;

    int Retry=0;
    UCHAR newname[MAX_RDN_SIZE];

    for (i=NameHash(ulSize,pVal,CLSCOUNT);
          (ahcClassName[i].pVal &&       // this hash spot refers to an object,
            (ahcClassName[i].length != ulSize || // but the size is wrong
              _memicmp(ahcClassName[i].value,pVal,ulSize))); // or value is wrong
             i++){
            if (i >= CLSCOUNT) {
                i=0;
            }
        }

    *ppClasscache = (CLASS_CACHE*)ahcClassName[i].pVal;
    return (!ahcClassName[i].pVal);
}


/*++
Routine Description: 
      Creates the different hash tables in the schema cache

Arguments: 
      SCPtr - Pointer to schema cache

Return Value: 
      0 if no error, non-0 if error
--*/

int CreateHashTables( SCHEMAPTR *CurrSchemaPtr )
{  
    PVOID ptr;
    ULONG i;

    ptr = CurrSchemaPtr->ahcId 
          = calloc( CurrSchemaPtr->ATTCOUNT, sizeof(HASHCACHE) );
    if ( ptr == NULL ) return( 1 ); 

    ptr = CurrSchemaPtr->ahcMapi 
          = calloc( CurrSchemaPtr->ATTCOUNT, sizeof(HASHCACHE) );
    if ( ptr == NULL ) return (1 );

    ptr = CurrSchemaPtr->ahcName 
          = calloc( CurrSchemaPtr->ATTCOUNT, sizeof(HASHCACHESTRING) );
    if ( ptr == NULL ) return( 1 );

    ptr = CurrSchemaPtr->ahcClass 
          = calloc( CurrSchemaPtr->CLSCOUNT, sizeof(HASHCACHE) );
    if ( ptr == NULL ) return( 1 );

    ptr = CurrSchemaPtr->ahcClassName 
          = calloc( CurrSchemaPtr->CLSCOUNT, sizeof(HASHCACHESTRING) );
    if ( ptr == NULL ) return( 1 );

      // Initialize the hash tables 
      //(Needed? calloc seems to initialize mem to 0 anyway)

    for ( i = 0; i < CurrSchemaPtr->ATTCOUNT; i++ ) {
           CurrSchemaPtr->ahcName[i].pVal = NULL;
           CurrSchemaPtr->ahcId[i].pVal   = NULL;
           CurrSchemaPtr->ahcMapi[i].pVal = NULL;
        }

    for ( i = 0; i < CurrSchemaPtr->CLSCOUNT; i++ ) {
           CurrSchemaPtr->ahcClassName[i].pVal = NULL;
           CurrSchemaPtr->ahcClass[i].pVal = NULL;
        }
   
    return( 0 );
}



// Define the mappings to map from a LDAP display name of an attribute
// (in the attribute schema and class schema entries) to an internal
// constant (we have used the ids defined in attids.h, though this
// is not necessary. This mapping is only so that we can use a switch
// statement based on the attribute, and hence what values we map to
// is irrelevent as long as they are distinct
// The ;binary s are added to the names of those attributes whose
// values are returned in binary, since the binary option also
// appends the ;binary to the attribute name in addition to
// transforming the value
   

typedef struct _AttributeMappings {
       char      *attribute_name;
       ATTRTYP   type;
 } AttributeMappings;

AttributeMappings LDAPMapping[] = {
       { "ldapDisplayName",              ATT_LDAP_DISPLAY_NAME },
       { "adminDisplayName",             ATT_ADMIN_DISPLAY_NAME },
       { "distinguishedName",            ATT_OBJ_DIST_NAME },
       { "adminDescription",             ATT_ADMIN_DESCRIPTION },
       { "attributeID;binary",           ATT_ATTRIBUTE_ID },
       { "attributeSyntax;binary",       ATT_ATTRIBUTE_SYNTAX },
       { "isSingleValued",               ATT_IS_SINGLE_VALUED },
       { "rangeLower",                   ATT_RANGE_LOWER },
       { "rangeUpper",                   ATT_RANGE_UPPER },
       { "mapiID",                       ATT_MAPI_ID },
       { "linkID",                       ATT_LINK_ID },
       { "schemaIDGUID",                 ATT_SCHEMA_ID_GUID },
       { "attributeSecurityGUID",        ATT_ATTRIBUTE_SECURITY_GUID },
       { "isMemberOfPartialAttributeSet",ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET },
       { "systemFlags",                  ATT_SYSTEM_FLAGS },
       { "defaultHidingValue",           ATT_DEFAULT_HIDING_VALUE },
       { "showInAdvancedViewOnly",       ATT_SHOW_IN_ADVANCED_VIEW_ONLY },
       { "defaultSecurityDescriptor",    ATT_DEFAULT_SECURITY_DESCRIPTOR },
       { "defaultObjectCategory",        ATT_DEFAULT_OBJECT_CATEGORY },
       { "nTSecurityDescriptor",         ATT_NT_SECURITY_DESCRIPTOR },
       { "OMObjectClass",                ATT_OM_OBJECT_CLASS },
       { "OMSyntax",                     ATT_OM_SYNTAX },
       { "searchFlags",                  ATT_SEARCH_FLAGS },
       { "systemOnly",                   ATT_SYSTEM_ONLY },
       { "extendedCharsAllowed",         ATT_EXTENDED_CHARS_ALLOWED },
       { "governsID;binary",             ATT_GOVERNS_ID },
       { "rDNAttID;binary",              ATT_RDN_ATT_ID },
       { "objectClassCategory",          ATT_OBJECT_CLASS_CATEGORY },
       { "subClassOf;binary",            ATT_SUB_CLASS_OF },
       { "systemAuxiliaryClass;binary",  ATT_SYSTEM_AUXILIARY_CLASS },
       { "auxiliaryClass;binary",        ATT_AUXILIARY_CLASS },
       { "systemPossSuperiors;binary",   ATT_SYSTEM_POSS_SUPERIORS },
       { "possSuperiors;binary",         ATT_POSS_SUPERIORS },
       { "systemMustContain;binary",     ATT_SYSTEM_MUST_CONTAIN },
       { "mustContain;binary",           ATT_MUST_CONTAIN },
       { "systemMayContain;binary",      ATT_SYSTEM_MAY_CONTAIN },
       { "mayContain;binary",            ATT_MAY_CONTAIN },
 };

int cLDAPMapping = sizeof(LDAPMapping) / sizeof(LDAPMapping[0]);


ATTRTYP StrToAttr( char *attr_name )
{
    int i;
      
    for ( i = 0; i < cLDAPMapping; i++)
        {
          if ( _stricmp( attr_name, LDAPMapping[i].attribute_name ) == 0 ) {
             return( LDAPMapping[i].type );
          }
        };
    return( -1 );
};
      


////////////////////////////////////////////////////////////////
// The next few functions are used to implement a mapping table 
// to map BER Encoded OID string prefixes to internal Ids. An 
// arbitrary, but unique, id is assigned to each prefix. The
// tables are implemented using the generic table packages
// defined in ntrtl.h
//////////////////////////////////////////////////////////////////


PVOID PrefixToNdxAllocate( RTL_GENERIC_TABLE *Table, CLONG ByteSize )
{
   return( malloc(ByteSize) );
}

VOID PrefixToNdxFree( RTL_GENERIC_TABLE *Table, PVOID Buffer )
{
   free( Buffer );
}


RTL_GENERIC_COMPARE_RESULTS
PrefixToNdxCompare( RTL_GENERIC_TABLE   *Table,
                    PVOID               FirstStruct,
                    PVOID               SecondStruct )
{

    PPREFIX_MAP PrefixMap1 = (PPREFIX_MAP) FirstStruct;
    PPREFIX_MAP PrefixMap2 = (PPREFIX_MAP) SecondStruct;
    int diff;

    // Compare the prefix parts
    if ( ( 0 == (diff = (PrefixMap1->Prefix).length 
                             - (PrefixMap2->Prefix).length)) &&
            (0 == (diff = memcmp( (PrefixMap1->Prefix).elements, (PrefixMap2->Prefix).elements, (PrefixMap1->Prefix).length))))
          { return( GenericEqual ); }
    else if ( diff > 0 )
          { return( GenericGreaterThan ); }
    return ( GenericLessThan );
}


void PrefixToNdxTableAdd( PVOID *Table, PPREFIX_MAP PrefixMap )
{
    PVOID ptr;
    
    if ( *Table == NULL ) {
        *Table = malloc( sizeof(RTL_GENERIC_TABLE) );
        if( *Table == NULL) {
          // malloc failed
          printf("ERROR: PrefixToNdxTableAdd: Malloc failed\n");
          return;
        }
        RtlInitializeGenericTable(
                    (RTL_GENERIC_TABLE *) *Table,
                    PrefixToNdxCompare,
                    PrefixToNdxAllocate,
                    PrefixToNdxFree,
                    NULL );
     }

    ptr = RtlInsertElementGenericTable(
                        (RTL_GENERIC_TABLE *) *Table,
                        PrefixMap,
                        sizeof(PREFIX_MAP), 
                        NULL );         
   
}

    
PPREFIX_MAP PrefixToNdxTableLookup( PVOID *Table, PPREFIX_MAP PrefixMap )
{
    if ( *Table == NULL ) return( NULL );
    return(RtlLookupElementGenericTable(
                            (RTL_GENERIC_TABLE *) *Table,
                            PrefixMap) );
}

ULONG AssignNdx()
{

    // Assign the next index from DummyNdx
    return (DummyNdx++);

}


/*++
Routine Description:
    Converts a BEREncoded OID to an Internal Id

Arguments:
    OidStr - BER Encoded OID
    oidLen - Length of OidStr

Return Value:
    The internal id generated
--*/

ULONG OidToId(UCHAR *OidStr, ULONG oidLen)
{
    PREFIX_MAP PrefixMap;
    PPREFIX_MAP Result;
    ULONG length;
    ULONG PrefixLen, longID = 0;
    PVOID Oid;
    ULONG Ndx, Id, TempId=0;

    OID oidStruct;

    length = oidLen;
    Oid = OidStr;

    // Convert to Prefix here
    if ( (length > 2) &&
       (((unsigned char *)Oid)[length - 2] & 0x80)) {
      PrefixLen = length - 2;
      if ( (((unsigned char *)Oid)[length - 3] & 0x80)) {
        // Last decimal encoded took three or more octets. Will need special
        // encoding while creating the internal id to enable proper
        // decoding
        longID = 1;
      }
      // no special encoding in attrtyp needed
      else {
        longID = 0;
      }
    }
    else {
        PrefixLen = length - 1;
    }

    if (length == PrefixLen + 2) {
      TempId = ( ((unsigned char *)Oid)[length - 2] & 0x7f) << 7;
    }
    TempId += ((unsigned char *)Oid)[length - 1];
    if (longID) {
      TempId |= 0x8000;
    }
    
    PrefixMap.Prefix.length = PrefixLen;
    PrefixMap.Prefix.elements = malloc( PrefixLen );
    if (PrefixMap.Prefix.elements == NULL) {
       printf("OidToId: Error allocating memory\n");
       Id = 0xffffffff;
       return Id;
    }
    memcpy( PrefixMap.Prefix.elements, Oid, PrefixLen );


    // See if prefix is already in table. If so, return the 
    // corresponding index, else assign a new index to the Prefix

    if ( (Result = PrefixToNdxTableLookup(&PrefixTable, &PrefixMap)) != NULL ) {
        Ndx = Result->Ndx;
    }
    else {
       // Not in table, assign a new index and add to table
       PrefixMap.Ndx = AssignNdx(); 
       PrefixToNdxTableAdd( &PrefixTable, &PrefixMap );
       Ndx = PrefixMap.Ndx;
    }


    // Now form the internal Id from the Index


    Id = (Ndx << 16);
    Id = (Id | TempId);
    return Id;
}
       
    
/*++
Routine Description:
    Convert an internal Id to a dotted decimal OID

Arguments:
    Id - Id to convert

Return Values:
    Pointer to dotted decimal OID string on success, NULL on failure
--*/

UCHAR *IdToOid(ULONG Id )
{
    PPREFIX_MAP ptr;
    OID_t Oid;
    OID oidStruct;
    unsigned             len;
    BOOL                 fOK;
    UCHAR  *pOutBuf;
    ULONG Ndx;


    Ndx = ( Id & 0xFFFF0000 ) >> 16;

    if (PrefixTable == NULL) {
        printf("IdToOid: No prefix table\n");
        return NULL;
    }
   
    // This function uses a simple linear search of the table. This
    // is used instead of RtlGenericLookupElement... as it seems that
    // the created table can be searched only by one key, and we have 
    // searched it by OID string while creating the table

    ptr = RtlEnumerateGenericTable( (PRTL_GENERIC_TABLE) PrefixTable, TRUE );
    while( ptr != NULL ) {
      if ( ptr->Ndx == Ndx ) break;
      ptr = RtlEnumerateGenericTable( (PRTL_GENERIC_TABLE) PrefixTable, FALSE );
    }

    if (ptr == NULL) {
      printf("IdToOid: No prefix found for Id %x\n", Id);
      return NULL;
    }

    if ((Id & 0xFFFF ) < 0x80) {
       Oid.length = ptr->Prefix.length + 1;
       Oid.elements = malloc(Oid.length);
       if (Oid.elements == NULL) {
          // malloc failed
          printf("IdToOid: malloc failed\n");
          return NULL;
       }
       memcpy (Oid.elements, ptr->Prefix.elements,Oid.length);
       (( unsigned char *)Oid.elements)[ Oid.length - 1 ] =
          ( unsigned char ) (Id  & 0x7F );
    }
    else {
       Oid.length = ptr->Prefix.length + 2;
       Oid.elements = malloc(Oid.length);
       if (Oid.elements == NULL) {
          // malloc failed
          printf("IdToOid: malloc failed\n");
          return NULL;
       }
       memcpy (Oid.elements, ptr->Prefix.elements,Oid.length);

      (( unsigned char *)Oid.elements)[ Oid.length - 1 ] =
          ( unsigned char ) (Id  & 0x7F );
      (( unsigned char *)Oid.elements)[ Oid.length - 2 ] =
          ( unsigned char )  (( (Id & 0xFF80) >> 7 ) | 0x80 );

    }

    // Now Oid contains the BER Encoded string. Convert to
    // dotted decimal

    oidStruct.Val = (unsigned *) alloca( (1 + Oid.length)*(sizeof(unsigned)) );

    fOK = MyDecodeOID(Oid.elements, Oid.length, &oidStruct);
    free(Oid.elements);
    if(!fOK) {
        printf("IdToOid: error Decoding Id %x\n", Id);
        return NULL;
    }

    // Allocate memory for output. Assume all oid strings less than 512 chars
    pOutBuf = (UCHAR *)malloc(512);
    if (NULL == pOutBuf) {
        printf("Memory allocation error\n");
        return NULL;
    }

    // Now, turn the OID to a string
    len = MyOidStructToString(&oidStruct,pOutBuf);

    return pOutBuf;

}


///////////////////////////////////////////////////
// Routine Description:
//      Add all attribute schema entries to the attribute caches.
//
// Arguments: 
//      ld -  LDAP connection 
//      res -  LDAP message containing all attribute schema entries,
//      SCPtr - Pointer to schema cache to add attributes to
//
// Output: 0 if no errors, non-0 if error
//////////////////////////////////////////////////

int AddAttributesToCache( LDAP *ld, LDAPMessage *res, SCHEMAPTR *SCPtr )
{
	int             i, count=0;
    LDAPMessage     *e;
	char            *a, *dn;
	void            *ptr;
	struct berval   **vals;
    ATTRTYP         attr_type;
    ATT_CACHE        *pac;

	  // step through each schema entry returned 

	for ( e = ldap_first_entry( ld, res );
	      e != NULL;
	      e = ldap_next_entry( ld, e )) {


	     // Create an ATT_CACHE structure and initialize it

       pac = (ATT_CACHE *) malloc( sizeof(ATT_CACHE) );
       if (NULL == pac) {
           printf("Memory allocation error\n");
           return 1;
       }
       memset( pac,0,sizeof(ATT_CACHE) );
       count++; 

          // For each attribute of the entry, get the value(s),
          // check attribute type, and fill in the appropriate field
          // of the ATTCACHE structure

       for ( a = ldap_first_attribute( ld, e,
		      			               (struct berelement**)&ptr);
		         a != NULL;
		         a = ldap_next_attribute( ld, e,
				    	                  (struct berelement*)ptr ) ) {

		   vals = ldap_get_values_len( ld, e, a );
           attr_type = StrToAttr( a );
           switch ( attr_type ) {
             case ATT_ATTRIBUTE_ID :
                  { 
                    pac->id = OidToId(vals[0]->bv_val,vals[0]->bv_len);
                    break;
                  };
             case ATT_LDAP_DISPLAY_NAME :
                  { 
                    pac->nameLen = vals[0]->bv_len;
                    pac->name = (UCHAR *)calloc(pac->nameLen+1, sizeof(UCHAR));
                    if( pac->name == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pac->name, vals[0]->bv_val, vals[0]->bv_len); 
                    pac->name[pac->nameLen] = '\0';
                    break;
                  };
             case ATT_OBJ_DIST_NAME :
                  { 
                    pac->DNLen = vals[0]->bv_len;
                    pac->DN = (UCHAR *)calloc(pac->DNLen+1, sizeof(UCHAR));
                    if( pac->DN == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pac->DN, vals[0]->bv_val, vals[0]->bv_len); 
                    pac->DN[pac->DNLen] = '\0';
                    break;
                  };
             case ATT_ADMIN_DISPLAY_NAME :
                  { 
                    pac->adminDisplayNameLen = vals[0]->bv_len;
                    pac->adminDisplayName 
                      = (UCHAR *)calloc(pac->adminDisplayNameLen+1, sizeof(UCHAR));
                    if( pac->adminDisplayName == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pac->adminDisplayName, vals[0]->bv_val, vals[0]->bv_len); 
                    pac->adminDisplayName[pac->adminDisplayNameLen] = '\0';
                    break;
                  };
             case ATT_ADMIN_DESCRIPTION :
                  { 
                    pac->adminDescrLen = vals[0]->bv_len;
                    pac->adminDescr 
                      = (UCHAR *)calloc(pac->adminDescrLen+1, sizeof(UCHAR));
                    if( pac->adminDescr == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pac->adminDescr, vals[0]->bv_val, vals[0]->bv_len); 
                    pac->adminDescr[pac->adminDescrLen] = '\0';
                    break;
                  };
             case ATT_NT_SECURITY_DESCRIPTOR :
                  { pac->NTSDLen = (DWORD) vals[0]->bv_len;
                    pac->pNTSD = malloc(pac->NTSDLen);
                    if ( pac->pNTSD == NULL )
                       { printf("Memory allocation error\n"); return(1);};
                    memcpy(pac->pNTSD, vals[0]->bv_val, vals[0]->bv_len);
                    break;
                  };
             case ATT_ATTRIBUTE_SYNTAX :
                  { if ( vals[0]->bv_val != NULL )
                       pac->syntax = OidToId(vals[0]->bv_val, vals[0]->bv_len); 
                    break; 
                  };
             case ATT_IS_SINGLE_VALUED :
                  { if ( _stricmp(vals[0]->bv_val, "TRUE") == 0 )
                       pac->isSingleValued = TRUE;
                    else pac->isSingleValued = FALSE;
                    pac->bisSingleValued = TRUE;
                    break;
                  };
             case ATT_RANGE_LOWER :
                  { pac->rangeLowerPresent = TRUE;
                    pac->rangeLower = (unsigned) atol(vals[0]->bv_val);
                    break;
                  };
             case ATT_RANGE_UPPER :
                  { pac->rangeUpperPresent = TRUE;
                    pac->rangeUpper = (unsigned) atol(vals[0]->bv_val);
                    break;
                  };
             case ATT_MAPI_ID :
                  { pac->ulMapiID = (unsigned) atol(vals[0]->bv_val);
                    break;
                  };
             case ATT_LINK_ID :
                  { pac->ulLinkID = (unsigned) atol(vals[0]->bv_val); 
                    break;
                  };
             case ATT_SCHEMA_ID_GUID :
                  { memcpy(&pac->propGuid, vals[0]->bv_val, sizeof(GUID));
                    break; 
                  };
             case ATT_ATTRIBUTE_SECURITY_GUID :
                  { memcpy(&pac->propSetGuid, vals[0]->bv_val, sizeof(GUID));
                    pac->bPropSetGuid = TRUE;
                    break; 
                  };
             case ATT_OM_OBJECT_CLASS :
                  { pac->OMObjClass.length = vals[0]->bv_len;
                    pac->OMObjClass.elements = malloc(vals[0]->bv_len);
                    if( pac->OMObjClass.elements == NULL ) 
                      {printf("Memory Allocation error\n"); return(1);};
                    memcpy(pac->OMObjClass.elements, vals[0]->bv_val,vals[0]->bv_len);
                    break;
                  };
             case ATT_OM_SYNTAX :
                  { pac->OMsyntax = atoi(vals[0]->bv_val);
                    break;
                  };
             case ATT_SEARCH_FLAGS :
                  { pac->SearchFlags = atoi(vals[0]->bv_val);
                    pac->bSearchFlags = TRUE;
                    break;
                  }
             case ATT_SYSTEM_ONLY :
                  { if ( _stricmp(vals[0]->bv_val, "TRUE" ) == 0)
                       pac->SystemOnly = TRUE;
                    else pac->SystemOnly = FALSE;
                    pac->bSystemOnly = TRUE;
                    break;
                  }
             case ATT_SHOW_IN_ADVANCED_VIEW_ONLY:
                  { if ( _stricmp(vals[0]->bv_val, "TRUE" ) == 0)
                       pac->HideFromAB = TRUE;
                    else pac->HideFromAB = FALSE;
                    pac->bHideFromAB = TRUE;
                    break;
                  }
             case ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET :
                  { if ( _stricmp(vals[0]->bv_val, "TRUE" ) == 0)
                       pac->MemberOfPartialSet = TRUE;
                    else pac->MemberOfPartialSet = FALSE;
                    pac->bMemberOfPartialSet = TRUE;
                    break;
                  }
             case ATT_EXTENDED_CHARS_ALLOWED:
                  { if ( _stricmp(vals[0]->bv_val, "TRUE") == 0 )
                       pac->ExtendedChars = TRUE;
                    else pac->ExtendedChars = FALSE;
                    pac->bExtendedChars = TRUE;
                    break;
                  }
             case ATT_SYSTEM_FLAGS :
                  { pac->sysFlags = atoi(vals[0]->bv_val);
                    pac->bSystemFlags = TRUE;
                    break;
                  };
           }   // End of Switch  
        
            // Free the structure holding the values

          ldap_value_free_len( vals );

      }  // End of for loop to read all atrributes of one entry

         // Add ATTCACHE structure to cache
     
       if( AddAttcacheToTables( pac, SCPtr ) != 0 ) {
           printf("Error adding ATTCACHE in AddAttcacheToTables\n");
           return( 1 );
         };

	}  // end of for loop to read all entries
    printf("No. of attributes read = %d\n", count);

    return( 0 );
}




//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Add all class schema entries to the class caches.
//
// Arguments:
//      ld -  LDAP connection
//      res -  LDAP message containing all class schema entries,
//      SCPtr - Pointer to schema cache to add attributes to
//
// Return Value: 0 if no errors, non-0 if error
//////////////////////////////////////////////////////////////////////

int AddClassesToCache( LDAP *ld, LDAPMessage *res, SCHEMAPTR *SCPtr )
{
	int             i, count;
    LDAPMessage     *e;
	char            *a, *dn;
	void            *ptr;
	struct berval   **vals;
    ATTRTYP         attr_type;
    CLASS_CACHE      *pcc;
    

    // Step through each class schema entry returned 

	for ( e = ldap_first_entry( ld, res );
	      e != NULL;
	      e = ldap_next_entry( ld, e ) ) {


         // Create a CLASS_CACHE structure and initialize it 

        pcc = (CLASS_CACHE *) malloc( sizeof(CLASS_CACHE) );
        if ( pcc == NULL ) {
            printf("Error Allocating Classcache\n");
            return(1);
         };
        memset( pcc, 0, sizeof(CLASS_CACHE) );

         // For each attribute of the entry, get the value(s),
         // check attribute type, and fill in the appropriate field
         // of the CLASSCACHE structure

		for ( a = ldap_first_attribute( ld, e,
						                (struct berelement**)&ptr);
		      a != NULL;
		      a = ldap_next_attribute( ld, e,
					                   (struct berelement*)ptr ) ) {
		    vals = ldap_get_values_len( ld, e, a );
            attr_type = StrToAttr( a );
            switch (attr_type) {
              case ATT_LDAP_DISPLAY_NAME :
                  { 
                    pcc->nameLen = vals[0]->bv_len;
                    pcc->name = (UCHAR *)calloc(pcc->nameLen+1, sizeof(UCHAR));
                    if( pcc->name == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pcc->name, vals[0]->bv_val, vals[0]->bv_len); 
                    pcc->name[pcc->nameLen] = '\0';
                    break;
                  };
              case ATT_OBJ_DIST_NAME :
                  {
                    pcc->DNLen = vals[0]->bv_len;
                    pcc->DN = (UCHAR *)calloc(pcc->DNLen+1, sizeof(UCHAR));
                    if( pcc->DN == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pcc->DN, vals[0]->bv_val, vals[0]->bv_len);
                    pcc->DN[pcc->DNLen] = '\0';
                    break;
                  };
              case ATT_ADMIN_DISPLAY_NAME :
                  {
                    pcc->adminDisplayNameLen = vals[0]->bv_len;
                    pcc->adminDisplayName
                      = (UCHAR *)calloc(pcc->adminDisplayNameLen+1, sizeof(UCHAR
));
                    if( pcc->adminDisplayName == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pcc->adminDisplayName, vals[0]->bv_val, vals[0]->bv_len);
                    pcc->adminDisplayName[pcc->adminDisplayNameLen] = '\0';
                    break;
                  };
              case ATT_ADMIN_DESCRIPTION :
                  {
                    pcc->adminDescrLen = vals[0]->bv_len;
                    pcc->adminDescr
                      = (UCHAR *)calloc(pcc->adminDescrLen+1, sizeof(UCHAR));
                    if( pcc->adminDescr == NULL )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pcc->adminDescr, vals[0]->bv_val, vals[0]->bv_len);
                    pcc->adminDescr[pcc->adminDescrLen] = '\0';
                    break;
                  };
              case ATT_GOVERNS_ID :
                  { pcc->ClassId = OidToId(vals[0]->bv_val,vals[0]->bv_len);
                    break;
                  };
              case ATT_DEFAULT_SECURITY_DESCRIPTOR :
                  { pcc->SDLen = (DWORD) vals[0]->bv_len;
                    pcc->pSD = malloc(pcc->SDLen + 1);
                    if ( pcc->pSD == NULL )
                       { printf("Memory allocation error\n"); return(1);};
                    memcpy(pcc->pSD, vals[0]->bv_val, vals[0]->bv_len);
                    pcc->pSD[pcc->SDLen] = '\0';
                    break;
                  };
              case ATT_DEFAULT_OBJECT_CATEGORY :
                  {
                    pcc->DefaultObjCatLen = vals[0]->bv_len;
                    pcc->pDefaultObjCat = (UCHAR *)calloc(pcc->DefaultObjCatLen+1, sizeof(UCHAR));
                    if ( NULL == pcc->pDefaultObjCat )
                        { printf("Memory allocation error\n"); return(1);};
                    memcpy( pcc->pDefaultObjCat, vals[0]->bv_val, vals[0]->bv_len);
                    pcc->pDefaultObjCat[pcc->DefaultObjCatLen] = '\0';
                    break;
    
                  }
              case ATT_NT_SECURITY_DESCRIPTOR :
                  { pcc->NTSDLen = (DWORD) vals[0]->bv_len;
                    pcc->pNTSD = malloc(pcc->NTSDLen);
                    if ( pcc->pNTSD == NULL )
                       { printf("Memory allocation error\n"); return(1);};
                    memcpy(pcc->pNTSD, vals[0]->bv_val, vals[0]->bv_len);
                    break;
                  };
              case ATT_RDN_ATT_ID : 
                  { pcc->RDNAttIdPresent = TRUE;
                    pcc->RDNAttId = OidToId(vals[0]->bv_val,vals[0]->bv_len);
                    break;
                  };
              case ATT_OBJECT_CLASS_CATEGORY :
                  { pcc->ClassCategory = atoi(vals[0]->bv_val);
                    break;
                  };
              case ATT_SUB_CLASS_OF : 
                  { 
                    AddToList(&pcc->SubClassCount, &pcc->pSubClassOf, vals);
                    break;
                  }; 
              case ATT_SYSTEM_AUXILIARY_CLASS : 
                  { 
                    AddToList(&pcc->SysAuxClassCount, &pcc->pSysAuxClass, vals);
                    break;
                  } 
              case ATT_AUXILIARY_CLASS:
                  { 
                    AddToList(&pcc->AuxClassCount, &pcc->pAuxClass, vals);
                    break;
                  } 
              case ATT_SYSTEM_POSS_SUPERIORS : 
                  {
                    AddToList(&pcc->SysPossSupCount, &pcc->pSysPossSup, vals);
                    break;
                  }
              case ATT_POSS_SUPERIORS : 
                  { 
                    AddToList(&pcc->PossSupCount, &pcc->pPossSup, vals);
                    break;
                  };
              case ATT_SYSTEM_MUST_CONTAIN:
                  {
                    AddToList(&pcc->SysMustCount, &pcc->pSysMustAtts, vals);
                    break;
                  }
              case ATT_MUST_CONTAIN : 
                  {
                    AddToList(&pcc->MustCount, &pcc->pMustAtts, vals);
                    break;
                  };
              case ATT_SYSTEM_MAY_CONTAIN:
                  {
                    AddToList(&pcc->SysMayCount, &pcc->pSysMayAtts, vals);
                    break;
                  }
              case ATT_MAY_CONTAIN : 
                  {
                    AddToList(&pcc->MayCount, &pcc->pMayAtts, vals);
                    break;
                  };
              case ATT_SCHEMA_ID_GUID :
                  { memcpy(&pcc->propGuid, vals[0]->bv_val, sizeof(GUID));
                    break;
                  };
              case ATT_SYSTEM_ONLY :
                  { if ( _stricmp(vals[0]->bv_val, "TRUE") == 0 )
                       pcc->SystemOnly = TRUE;
                    else pcc->SystemOnly = FALSE;
                    pcc->bSystemOnly = TRUE;
                    break;
                  }
             case ATT_SHOW_IN_ADVANCED_VIEW_ONLY :
                  { if ( _stricmp(vals[0]->bv_val, "TRUE" ) == 0)
                       pcc->HideFromAB = TRUE;
                    else pcc->HideFromAB = FALSE;
                    pcc->bHideFromAB = TRUE;
                    break;
                  }
              case ATT_DEFAULT_HIDING_VALUE :
                  { if ( _stricmp(vals[0]->bv_val, "TRUE") == 0 )
                       pcc->DefHidingVal = TRUE;
                    else pcc->DefHidingVal = FALSE;
                    pcc->bDefHidingVal = TRUE;
                    break;
                  }   
              case ATT_SYSTEM_FLAGS :
                  { pcc->sysFlags = atoi(vals[0]->bv_val);
                    pcc->bSystemFlags = TRUE;
                    break;
                  };
            }   // End of Switch 

           // Free the structure holding the values

		 ldap_value_free_len( vals );

		} // end of for loop to read all attributes of a class

 
         // Add CLASSCACHE structure to cache

       if ( AddClasscacheToTables( pcc, SCPtr ) != 0 ) {
           printf("Error adding CLASSCACHE in AddClasscacheToTables\n");
           return( 1 );
         };

 	 } // End of for loop to read all class-schema entries
    return( 0 );
}



//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Adds an ATT_CACHE structure to the different attribute cache tables
//
// Arguments: 
//      pAC -  Pointer to an ATT_CACHE structure
//      SCPtr - Pointer to schema cache 
//
// Return Value: 0 if no errors, non-0 if error
/////////////////////////////////////////////////////////////////////

int AddAttcacheToTables( ATT_CACHE *pAC, SCHEMAPTR *SCPtr )
{

    ULONG i;
    int err;
    ATTRTYP aid;

    ULONG       ATTCOUNT  = SCPtr->ATTCOUNT; 
    HASHCACHE*  ahcId     = SCPtr->ahcId;
    HASHCACHE*  ahcMapi   = SCPtr->ahcMapi; 
    HASHCACHESTRING* ahcName = SCPtr->ahcName; 


    aid = pAC->id;

    for ( i = IdHash(aid,ATTCOUNT);
          ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY); i++ ) {
           if ( i >= ATTCOUNT ) { i = 0; }
       }
     ahcId[i].hKey = aid;
     ahcId[i].pVal = pAC;


    if ( pAC->ulMapiID ) {
        // if this att is MAPI visible, add it to MAPI cache 

        for ( i = IdHash(pAC->ulMapiID, ATTCOUNT);
              ahcMapi[i].pVal && (ahcMapi[i].pVal != FREE_ENTRY); i++ ) {
            if ( i >= ATTCOUNT ) { i = 0; }
        }
        ahcMapi[i].hKey = pAC->ulMapiID;
        ahcMapi[i].pVal = pAC;
    }

    if ( pAC->name ) {
        // if this att has a name, add it to the name cache 

        for ( i = NameHash(pAC->nameLen, pAC->name, ATTCOUNT);
              ahcName[i].pVal && (ahcName[i].pVal!= FREE_ENTRY); i++ ) {
            if ( i >= ATTCOUNT ) { i = 0; }
        }

        ahcName[i].length = pAC->nameLen;
        ahcName[i].value = malloc(pAC->nameLen);
        if (NULL == ahcName[i].value) {
            printf("Memory allocation error\n");
            return 1;
        }
        memcpy(ahcName[i].value,pAC->name,pAC->nameLen);
        ahcName[i].pVal = pAC;
    }

    return( 0 );
}


//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Adds a CLASS_CACHE structure to the different class cache tables
//
// Arguments:
//      pCC -  Pointer to an CLASS_CACHE structure
//      SCPtr - Pointer to schema cache
//
// Return Value: 0 if no errors, non-0 if error
/////////////////////////////////////////////////////////////////////

int AddClasscacheToTables( CLASS_CACHE *pCC, SCHEMAPTR *SCPtr )
{
    ULONG       CLSCOUNT  = SCPtr->CLSCOUNT;
    HASHCACHE*  ahcClass  = SCPtr->ahcClass;
    HASHCACHESTRING* ahcClassName = SCPtr->ahcClassName;

    int i,start;

    // add to class cache

    start=i=IdHash(pCC->ClassId,CLSCOUNT);


    do {
        if (ahcClass[i].pVal==NULL || (ahcClass[i].pVal== FREE_ENTRY))
        {
            break;
        }
        i=(i+1)%CLSCOUNT;

    }while(start!=i);

    ahcClass[i].hKey = pCC->ClassId;
    ahcClass[i].pVal = pCC;

    if (pCC->name) {
        /* if this class has a name, add it to the name cache */

        start=i=NameHash(pCC->nameLen, pCC->name, CLSCOUNT);
        do
        {
          if (ahcClassName[i].pVal==NULL || (ahcClassName[i].pVal== FREE_ENTRY))
           {
              break;
           }
          i=(i+1)%CLSCOUNT;

        }while(start!=i);

        ahcClassName[i].length = pCC->nameLen;
        ahcClassName[i].value = malloc(pCC->nameLen);
        if (NULL == ahcClassName[i].value) {
            printf("Memory allocation error\n");
            return 1;
        }
        memcpy(ahcClassName[i].value,pCC->name,pCC->nameLen);
        ahcClassName[i].pVal = pCC;
    }

    return 0;
}




//////////////////////////////////////////////////////////////////
// Routine Description:
//     Free all allocated memory in a schema cache 
//
// Arguments: 
//     SCPtr - Pointer to the schema cache
//
// Return Value: None
/////////////////////////////////////////////////////////////////

void FreeCache(SCHEMAPTR *SCPtr)
{
    if (SCPtr==NULL) return;

  {
    ULONG            ATTCOUNT      = SCPtr->ATTCOUNT ;
    ULONG            CLSCOUNT      = SCPtr->CLSCOUNT ;
    HASHCACHE        *ahcId        = SCPtr->ahcId ;
    HASHCACHE        *ahcMapi      = SCPtr->ahcMapi ;
    HASHCACHESTRING  *ahcName      = SCPtr->ahcName ;
    HASHCACHE        *ahcClass     = SCPtr->ahcClass ;
    HASHCACHESTRING  *ahcClassName = SCPtr->ahcClassName ;

    ULONG        i;
    ATT_CACHE   *pac;
    CLASS_CACHE *pcc;
   

    for ( i = 0; i < ATTCOUNT; i++ ) {
       if ( ahcId[i].pVal && (ahcId[i].pVal != FREE_ENTRY) ) {
            pac = (ATT_CACHE *) ahcId[i].pVal;
            FreeAttcache( pac );
         };
      }

    for ( i = 0; i < CLSCOUNT; i++ ) {
       if ( ahcClass[i].pVal && (ahcClass[i].pVal != FREE_ENTRY) ) {
           pcc = (CLASS_CACHE *) ahcClass[i].pVal;
           FreeClasscache( pcc );
         };
      }

      // Free the Cache tables themselves

    free( ahcId );
    free( ahcName );
    free( ahcMapi );
    free( ahcClass );
    free( ahcClassName );
  }
}

////////////////////////////////////////////////////////////////////////
// Routine Description:
//     Remove an att_cache from all hash tables
//
// Arguments: 
//     SCPtr - Pointer to schema cache 
//     pAC - Att_cache structure to remove
//
// Return Value: None
//////////////////////////////////////////////////////////////////////// 

void FreeAttPtrs ( SCHEMAPTR *SCPtr, ATT_CACHE *pAC )
{
    ULONG    ATTCOUNT  = SCPtr->ATTCOUNT ;
    HASHCACHE*  ahcId     = SCPtr->ahcId ;
    HASHCACHE*  ahcMapi   = SCPtr->ahcMapi ;
    HASHCACHESTRING* ahcName   = SCPtr->ahcName ;

    register ULONG i;

 
    for ( i = IdHash(pAC->id,ATTCOUNT);
          (ahcId[i].pVal && (ahcId[i].hKey != pAC->id)); 
          i++ ) {
        if ( i >= ATTCOUNT ) {
        i = 0;
        }
    }
    ahcId[i].pVal = FREE_ENTRY;
    ahcId[i].hKey = 0;


    if ( pAC->ulMapiID ) {
        for ( i = IdHash(pAC->ulMapiID,ATTCOUNT);
              (ahcMapi[i].pVal && (ahcMapi[i].hKey != pAC->ulMapiID)); 
              i++ ) {
        if ( i >= ATTCOUNT ) {
            i = 0;
        }
        }
        ahcMapi[i].pVal = FREE_ENTRY;
        ahcMapi[i].hKey = 0;
    }

    if (pAC->name) {
        for ( i = NameHash(pAC->nameLen,pAC->name,ATTCOUNT);

         // this hash spot refers to an object, but the size or the
         // value is wrong

              (ahcName[i].pVal &&
               (ahcName[i].length != pAC->nameLen ||
                _memicmp(ahcName[i].value,pAC->name,pAC->nameLen)));
              i++ ) {
        if ( i >= ATTCOUNT ) {
            i = 0;
        }
        }
        ahcName[i].pVal = FREE_ENTRY;
        free(ahcName[i].value);
        ahcName[i].value = NULL;
        ahcName[i].length = 0;
    }

}

////////////////////////////////////////////////////////////////////////
// Routine Description:
//     Remove an class_cache from all hash tables
//
// Arguments:
//     SCPtr - Pointer to schema cache
//     pAC - class_cache structure to remove
//
// Return Value: None
////////////////////////////////////////////////////////////////////////

void FreeClassPtrs (SCHEMAPTR * SCPtr, CLASS_CACHE *pCC )
{
    register ULONG i;
    ULONG    CLSCOUNT  = SCPtr->CLSCOUNT ;
    HASHCACHE*  ahcClass   = SCPtr->ahcClass ;
    HASHCACHESTRING* ahcClassName   = SCPtr->ahcClassName ;


    for (i=IdHash(pCC->ClassId,CLSCOUNT);
         (ahcClass[i].pVal && (ahcClass[i].hKey != pCC->ClassId)); i++){
        if (i >= CLSCOUNT) {
        i=0;
        }
    }
    ahcClass[i].pVal = FREE_ENTRY;
    ahcClass[i].hKey = 0;

    if (pCC->name) {
        for (i=NameHash(pCC->nameLen,pCC->name,CLSCOUNT);
         // this hash spot refers to an object, but the size is
         // wrong or the value is wrong
         (ahcClassName[i].pVal &&
          (ahcClassName[i].length != pCC->nameLen ||
           _memicmp(ahcClassName[i].value,pCC->name,pCC->nameLen)));
         i++) {
        if (i >= CLSCOUNT) {
            i=0;
        }
        }
        ahcClassName[i].pVal = FREE_ENTRY;
        free(ahcClassName[i].value);
        ahcClassName[i].value = NULL;
        ahcClassName[i].length = 0;
    }



}


// Frees an att_cache structure

void FreeAttcache(ATT_CACHE *pac)
{
    if ( pac->name ) free( pac->name );
    if ( pac->DN ) free( pac->DN );
    if ( pac->adminDisplayName ) free( pac->adminDisplayName );
    if ( pac->adminDescr ) free( pac->adminDescr );
    free( pac );
}

// Frees a class_cache structure

void FreeClasscache(CLASS_CACHE *pcc)
{
    if ( pcc->name ) free( pcc->name );
    if ( pcc->DN ) free( pcc->DN );
    if ( pcc->adminDisplayName ) free( pcc->adminDisplayName );
    if ( pcc->adminDescr ) free( pcc->adminDescr );
    if ( pcc->pSD )  free( pcc->pSD );
    if ( pcc->pSubClassOf ) free( pcc->pSubClassOf );
    if ( pcc->pAuxClass ) free( pcc->pAuxClass );
    if ( pcc->pSysAuxClass ) free( pcc->pSysAuxClass );
    if ( pcc->pSysMustAtts ) free( pcc->pSysMustAtts );
    if ( pcc->pMustAtts ) free( pcc->pMustAtts );
    if ( pcc->pSysMayAtts ) free( pcc->pSysMayAtts );
    if ( pcc->pMayAtts ) free( pcc->pMayAtts );
    if ( pcc->pSysPossSup ) free( pcc->pSysPossSup );
    if ( pcc->pPossSup ) free( pcc->pPossSup );
}

// Frees the Oid strings malloced by us that are pointed at from
// the PREFIX_MAP structures in the table. The table entries themselves
// cannot be freed by us

void FreeTable(PVOID Table)
{
    
    PPREFIX_MAP ptr;

    if (Table == NULL) {
        return;
    }

    for (ptr = RtlEnumerateGenericTable((PRTL_GENERIC_TABLE) Table, TRUE);
         ptr != NULL;
         ptr = RtlEnumerateGenericTable((PRTL_GENERIC_TABLE) Table, FALSE))
     {
       if ( ptr->Prefix.elements != NULL ) free( ptr->Prefix.elements );
     }
}


// Debug routines


void PrintPrefix(ULONG length, PVOID Prefix)
{
    BYTE *pb;
    ULONG ib;
    UCHAR temp[512];

       pb = (LPBYTE) Prefix;
       if (pb != NULL) {
         for ( ib = 0; ib <length; ib++ )
          {
             sprintf( &temp[ ib * 2 ], "%.2x", *(pb++) );
          }
         temp[2*length]='\0';
         printf("Prefix is %s\n", temp);
       }
}

void PrintOid(PVOID Oid, ULONG len)
{
    BYTE *pb;
    ULONG ib;
    UCHAR temp[512];

       pb = (LPBYTE) Oid;
       if (pb != NULL) {
         for ( ib = 0; ib < len; ib++ )
          {
             sprintf( &temp[ ib * 2 ], "%.2x", *(pb++) );
          }
         temp[2*len]='\0';
         printf("Oid is %s\n", temp);
        }
}

      
void PrintTable(PVOID PrefixTable)
{
    PPREFIX_MAP ptr;      
    int count = 0;
    BYTE *pb;
    ULONG ib;
    UCHAR temp[512];
   
    if (PrefixTable == NULL) {
        printf("PrintTable: Null Table Pointer Passed\n");
        return;
    }

    printf("     ***********Table Print**************\n");

    for (ptr = RtlEnumerateGenericTable((PRTL_GENERIC_TABLE) PrefixTable, TRUE);
         ptr != NULL;
         ptr = RtlEnumerateGenericTable((PRTL_GENERIC_TABLE) PrefixTable, FALSE)) 
    { 
       pb = (LPBYTE) ptr->Prefix.elements;
       if (pb != NULL) {
         for ( ib = 0; ib < ptr->Prefix.length; ib++ )
          {
             sprintf( &temp[ ib * 2 ], "%.2x", *(pb++) );
          }
         temp[2*ptr->Prefix.length]='\0';
         printf("Ndx=%-4d Length=%-3d Prefix=%s\n",ptr->Ndx,ptr->Prefix.length, temp);
        }

      } 
    printf("         ***End Table print*************\n");
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\schemard\schematools.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <schemard.h>

#define iswdigit(x) ((x) >= '0' && (x) <= '9')

/*++
 * Walk an LDAP berval structure and adds all the unsigned values into an array
 * puCount && pauVal are in/out parameters
 ++*/
void AddToList(ULONG * puCount, ULONG **pauVal, struct berval  **vals)
{
    ULONG   i;
    ULONG   *pau;
    ULONG   NewCount = ldap_count_values_len(vals);

    *puCount = NewCount;
    pau = calloc(1,(*puCount)*sizeof(ULONG));
    if ( !pau ) {
        printf("Memeory Allocation error\n");
        *puCount = 0;
        *pauVal = NULL;
        return;
    }

    *pauVal = pau;

    for ( i = 0; i < NewCount; i++ ) {
        *pau = OidToId( vals[i]->bv_val,vals[i]->bv_len );
        ++pau;
    }

    return;
}



unsigned
MyOidStringToStruct (
        UCHAR * pString,
        unsigned len,
        OID * pOID
        )
/*++
Routine Description:
    A stripped down version of the OidStringToStruct in oidconv.c
    Translates a string of the format "X.Y.Z"
    to an oid structure of the format {count=3, val[]={X,Y,Z}}
    No checks performed as we expect the OID values in the directory
    to be already correct

Arguments
    pString - the string format oid.
    pLen - the length of pString in characters.
    pOID - pointer to an OID structure to fill in.  Note: the value field must
    be pre-allocated and the len field should hold the number of values
    pre-allocated.

Return Values
    0 if successfull, non-0 if a failure occurred.
--*/
{
    int i;
    int numVals = pOID->cVal;
    unsigned val;
    UCHAR * pCur = pString;
    UCHAR * pEnd = pString + len;


    // Must have non-zero length
    if (len == 0) {
        return 1;
    }

    // pCur is now positioned on the first character in the
    // first decimal in the string 

    pOID->cVal = 0;

    while (pCur < pEnd) {
        if (!iswdigit(*pCur)) {
            return 2;
        }
        val = *pCur - '0';
        ++pCur;
        while (pCur < pEnd && *pCur != '.') {
            if (!iswdigit(*pCur)) {
                return 3;
            }
            val = 10*val + *pCur - '0';
            ++pCur;
        }
        // Keep track of whether we found a dot for the last character.
        if(pOID->cVal >= numVals) {
            return 4;
        }
        pOID->Val[pOID->cVal] = val;
        pOID->cVal++;
        ++pCur;
    }
    return 0;
}

unsigned
MyOidStructToString (
        OID *pOID,
        UCHAR *pOut
        )
/*++
Routine Description:
    Translates a structure in the format
         {count=3, val[]={X,Y,Z}}
    to a string of the format "X.Y.Z".

Arguments
    pOID - pointer to an OID structure to translate from.
    pOut - preallocated string to fill in.

Return Values
    the number of characters in the resulting string.
--*/
{
    int i;
    UCHAR *pCur = pOut;

    for (i=0; i<pOID->cVal; i++) {
      _ultoa(pOID->Val[i], pCur, 10);
  
      while (*pCur) {
          ++pCur;
      }
      if (i != (pOID->cVal - 1)) {
        *pCur++ = '.';
      }
    }
    return (UINT)(pCur - pOut);
}

/*++ DecodeOID
 *
 * Takes a BER encoded OID as an octet string and returns the OID in
 * structure format.
 *
 * INPUT:
 *    pEncoded - Pointer to a buffer holding the encoded octet string.
 *    len      - Length of the encoded OID
 *    pOID     - Pointer to a *preallocated* OID structure that will
 *               be filled in with the decoded OID.
 *
 * OUTPUT:
 *    pOID     - Structure is filled in with the decoded OID
 *
 * RETURN VALUE:
 *    0        - value could not be decoded (bad OID)
 *    non-0    - OID decoded successfully
 */
BOOL MyDecodeOID(unsigned char *pEncoded, int len, OID *pOID) {
    unsigned cval;
    unsigned val;
    int i, j;

    if (len <=2) {
    return FALSE;
    }

    // The first two values are encoded in the first octet.

    pOID->Val[0] = pEncoded[0] / 40;
    pOID->Val[1] = pEncoded[0] % 40;
    cval = 2;
    i = 1;

    while (i < len) {
    j = 0;
    val = pEncoded[i] & 0x7f;
    while (pEncoded[i] & 0x80) {
        val <<= 7;
        ++i;
        if (++j > 4 || i >= len) {
        // Either this value is bigger than we can handle (we
        // don't handle values that span more than four octets)
        // -or- the last octet in the encoded string has its
        // high bit set, indicating that it's not supposed to
        // be the last octet.  In either case, we're sunk.
        return FALSE;
        }
        val |= pEncoded[i] & 0x7f;
    }
    pOID->Val[cval] = val;
    ++cval;
    ++i;
    }
    pOID->cVal = cval;

    return TRUE;
}

/*++ EncodeOID
 *
 * Takes an OID in structure format and constructs a BER encoded octet
 * string representing that OID.
 *
 * INPUT:
 *    pOID     - Pointer to an OID structure to be encoded
 *    pEncoded - Pointer to a *preallocated* buffer that will hold the
 *               encoded octet string.  Sould be at least 4*MAX_OID_VALS long
 *
 * OUTPUT:
 *    pEncoded - Buffer holds the encoded OID
 *
 * RETURN VALUE:
 *    0        - Value could not be encoded (bad OID)
 *    non-0    - Length of resulting octet string, in bytes
 */
unsigned MyEncodeOID(OID *pOID, unsigned char * pEncoded){
    int i;
    unsigned len;
    unsigned val;

    // The first two values in the OID are encoded into a single octet
    // by a really appalling rule, as shown here.

    *pEncoded = (pOID->Val[0] * 40) + pOID->Val[1];
    len = 1;

    // For all subsequent values, each is encoded across multiple bytes
    // in big endian order (MSB first), seven bits per byte, with the
    // high bit being clear on the last byte, and set on all others.

    // PERFHINT - The checks below are pretty inelegant. The value can be
    // directly checked against the hex value instead of building up the
    // bit patterns in a strange way. Should clean up later. However, test
    // thoroughly after changing.

    for (i=2; i<pOID->cVal; i++) {
    val = pOID->Val[i];
    if (val > ((0x7f << 14) | (0x7f << 7) | 0x7f) ) {
        // Do we need 4 octets to represent the value?
        // Make sure it's not 5
        // Assert(0 == (val & ~((0x7f << 21) | (0x7f << 14) | (0x7f << 7) | 0x7f)));
        if (val & ~((0x7f << 21) | (0x7f << 14) | (0x7f << 7) | 0x7f)) {
          return 0;   // we can't encode things this big
        }
        pEncoded[len++] = 0x80 | ((val >> 21) & 0x7f);
    }
    if (val > ((0x7f << 7) | 0x7f) ) {
        // Do we need 3 octets to represent the value?
        pEncoded[len++] = 0x80 | ((val >> 14) & 0x7f);
    }
    if (val > 0x7f) {
        // Do we need 2 octets to represent the value?
        pEncoded[len++] = 0x80 | ((val >> 7) & 0x7f);
    }
    // Encode the low 7 bits into the last octet for this value
    pEncoded[len++] = val & 0x7f;
    }

    return len;
}


void ChangeDN( char *oldDN, char **newDN, char *targetSchemaDN )
{
   char  rdn[MAX_RDN_SIZE];
   int   i, j = 0;

   // find the rdn
   // Position at the beginning
   i = 3;
   while ( oldDN[i] != ',' ) {
     rdn[j++] = oldDN[i++];
   }
   rdn[j++] = ',';
   rdn[j]='\0';
   *newDN = MallocExit(j + 4 + strlen(targetSchemaDN));   
   strcpy( *newDN,"CN=" );
   strcat( *newDN,rdn );
   strcat( *newDN, targetSchemaDN );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\schupgr\util.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include "schupgr.h"

extern FILE *logfp;


// Table of Ldap mesages for error to message translation

typedef struct _LdapMsg {
    DWORD  err;
    WCHAR  *msg;
} LdapMsg;

LdapMsg LdapMsgTable[] =
{
   { LDAP_SUCCESS,                     L"Success" },
   { LDAP_OPERATIONS_ERROR,            L"Operations Error" },
   { LDAP_UNAVAILABLE_CRIT_EXTENSION,  L"Unavailable Crit Extension" },
   { LDAP_NO_SUCH_ATTRIBUTE,           L"No Such Attribute" },
   { LDAP_UNDEFINED_TYPE,              L"Undefined Type" },
   { LDAP_CONSTRAINT_VIOLATION,        L"Constraint Violation" },
   { LDAP_ATTRIBUTE_OR_VALUE_EXISTS,   L"Attribute Or Value Exists" },
   { LDAP_INVALID_SYNTAX,              L"Invalid Syntax" }, 
   { LDAP_NO_SUCH_OBJECT,              L"No Such Object" },
   { LDAP_INVALID_DN_SYNTAX,           L"Invalid DN Syntax" },
   { LDAP_INVALID_CREDENTIALS,         L"Invalid Credentials" },
   { LDAP_INSUFFICIENT_RIGHTS,         L"Insufficient Rights" },
   { LDAP_BUSY,                        L"Busy" },
   { LDAP_UNAVAILABLE,                 L"Unavailable" },
   { LDAP_UNWILLING_TO_PERFORM,        L"Unwilling To Perform" },
   { LDAP_NAMING_VIOLATION,            L"Naming Violation" },
   { LDAP_OBJECT_CLASS_VIOLATION,      L"Object Class Violation" },
   { LDAP_NOT_ALLOWED_ON_NONLEAF,      L"Not Allowed on Non-Leaf" },
   { LDAP_NOT_ALLOWED_ON_RDN,          L"Not Allowed On Rdn" },
   { LDAP_ALREADY_EXISTS,              L"Already Exists" },
   { LDAP_NO_OBJECT_CLASS_MODS,        L"No Object Class Mods" },
   { LDAP_OTHER,                       L"Other" },
   { LDAP_SERVER_DOWN,                 L"Server Down" },
   { LDAP_LOCAL_ERROR,                 L"Local error" },
   { LDAP_TIMEOUT,                     L"TimeOut" },
   { LDAP_FILTER_ERROR,                L"Filter Error" },
   { LDAP_CONNECT_ERROR,               L"Connect Error" },
   { LDAP_NO_MEMORY,                   L"No Memory" },
   { LDAP_NOT_SUPPORTED,               L"Not Supported" },
};

ULONG cNumMessages = sizeof(LdapMsgTable)/sizeof(LdapMsgTable[0]);

// Global for message for all other ldap errors (i.e., not in above table)

WCHAR *LdapUnknownErrMsg = L"Unknown Ldap Error";
  

////////////////////////////////////////////////////////////////////
//
// Routine Description:
//     Helper function to print out and log error messages
//     Takes two string arguments. The message is picked up
//     from a message file
//
// Arguments:
//     options: Log only or both log and print
//     msgID: Id of message to print
//     pArg1, pArg2: string arguments for the message string
//
// Return Values:
//    None
//
////////////////////////////////////////////////////////////////////

// Max chars in the message
#define MAX_MSG_SIZE 2000

void 
LogMessage(
    ULONG options, 
    DWORD msgID, 
    WCHAR *pWArg1, 
    WCHAR *pWArg2 
)
{
    WCHAR msgStr[MAX_MSG_SIZE];
    WCHAR *argArray[3];
    ULONG err=0;

    argArray[0] = pWArg1;
    argArray[1] = pWArg2;
    argArray[2] = NULL; // sentinel

    // Format the message
    err = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE | 
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         NULL,
                         msgID,
                         0,
                         msgStr,
                         MAX_MSG_SIZE,
                         (va_list *) &(argArray[0]));
    
    if ( err == 0 ) {
       // Heck, we cannot even format the message, just do a plain printf
       // to say something is wrong
       printf("LogMessage: Couldn't format message with Id %d\n", msgID);
       return;
    }
    

    // print to log  file
    fwprintf(logfp, L"%s", msgStr);
    fflush(logfp);

    if (options & LOG_AND_PRT) {
        // write to screen also
        wprintf(L"%s", msgStr);
    }

    return;
}

    


////////////////////////////////////////////////////////////////////
//
// Routine Decsription:
//       Converts most ldap errors to string messages
//
//
// Arguments:
//        LdapErr - input ldap error value
//
// Return Value:
//        pointer to char string with message
//
////////////////////////////////////////////////////////////////////

WCHAR *LdapErrToStr(DWORD LdapErr)
{
    ULONG i;

    // search the table of Ldap Errors
    
    for (i=0; i<cNumMessages; i++) {
        if (LdapMsgTable[i].err == LdapErr) {
           // found the error. return the pointer to the string
           return (LdapMsgTable[i].msg);
        }
    }

    // didn't find any message. Return the generic "Unknown error"
    return (LdapUnknownErrMsg);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\schemard\schemard.c ===
////////////////////////////////////////////////////////////////////////
//
// Utility to read schemas from two running DSA's, load them into internal
// schema caches, and compare them for omissions and conflicts.
// Assumes the domains are named dc=<domainname>,dc=dbsd-tst,dc=microsoft,
// dc=com,o=internet
// Requires null administrator password on the PDC's running the DSA
// 
// Usage: schemard <1stMachineName> <1stDomainName> <2ndMachineName>
//                  <2ndDomainName>
// Example: schemard arob200 myworld kingsx sydney
//
// Currently uses the same static prefix table and functions in oidconv.c
// for OID to Id mapping. Will use dynamic tables later.
//
///////////////////////////////////////////////////////////////////////


#include <NTDSpch.h>
#pragma hdrstop

#include <schemard.h>


// Globals
SCHEMAPTR *CurrSchemaPtr, *SchemaPtr1 = NULL, *SchemaPtr2 = NULL;

char  *pOutFile = NULL;

char  *pSrcServer = NULL;
char  *pSrcDomain = NULL;
char  *pSrcUser   = NULL;
char  *pSrcPasswd = NULL;

char  *pTargetServer = NULL;
char  *pTargetDomain = NULL;
char  *pTargetUser   = NULL;
char  *pTargetPasswd = NULL;

char  *pSrcSchemaDN    = NULL;
char  *pTargetSchemaDN = NULL;

FILE  *logfp;
FILE  *OIDfp;

ULONG NoOfMods = 0;

extern PVOID PrefixTable;


extern void PrintOid(PVOID Oid, ULONG len);

extern NTSTATUS 
base64encode(
     VOID    *pDecodedBuffer,
     DWORD   cbDecodedBufferSize,
     UCHAR   *pszEncodedString,
     DWORD   cchEncodedStringSize,
     DWORD   *pcchEncoded       
    );

// Internal functions
void CreateFlagBasedAttModStr( MY_ATTRMODLIST *pModList,
                               ATT_CACHE *pSrcAtt,
                               ATT_CACHE *pTargetAtt,
                               ATTRTYP attrTyp );
void CreateFlagBasedClsModStr( MY_ATTRMODLIST *pModList,
                               CLASS_CACHE *pSrcAtt,
                               CLASS_CACHE *pTargetAtt,
                               ATTRTYP attrTyp );
BOOL IsMemberOf( ULONG id, ULONG *pList, ULONG cList );
void AddToModStruct( MY_ATTRMODLIST *pModList, 
                     USHORT         choice, 
                     ATTRTYP        attrType, 
                     int            type, 
                     ULONG          valCount, 
                     ATTRVAL        *pAVal
                   );
int CompareUlongList( ULONG      *pList1, 
                      ULONG      cList1, 
                      ULONG      *pList2, 
                      ULONG      cList2, 
                      ULONGLIST  **pL1, 
                      ULONGLIST  **pL2 
                    );
void AddToModStructFromLists( MODIFYSTRUCT *pModStr, 
                              ULONG        *pCount, 
                              ULONGLIST    *pL1, 
                              ULONGLIST    *pL2, 
                              ATTRTYP      attrTyp
                            );

void FileWrite_AttAdd( FILE *fp, ATT_CACHE **pac, ULONG  cnt );
void FileWrite_ClsAdd( FILE *fp, CLASS_CACHE **pcc, ULONG cnt );
void FileWrite_AttDel( FILE *fp, ATT_CACHE **pac, ULONG  cnt );
void FileWrite_ClsDel( FILE *fp, CLASS_CACHE **pcc, ULONG  cnt );
void FileWrite_Mod( FILE *fp, char  *pDN, MODIFYSTRUCT *pMod );

void GenWarning( char c, ULONG attrTyp, char *name);


///////////////////////////////////////////////////////////////
// Routine Description:
//      exit if out of memory
//
// Arguments:
//      nBytes - number of bytes to malloc
//
// Return Value:
//      address of allocated memory. Otherwise, calls exit
///////////////////////////////////////////////////////////////
PVOID
MallocExit(
    DWORD nBytes
    )
{
    PVOID Buf;

    Buf = malloc(nBytes);
    if (!Buf) {
        printf("Error, out of memory\n");
        exit(1);
    }
    return Buf;
}

///////////////////////////////////////////////////////////////
// Routine Description:
//      Processes command line arguments and loads into appropriate
//      globals
//
// Arguments:
//      argc - no. of command line arguments
//      argv - pointer to command line arguments
//
// Return Value:
//      0 on success, non-0 on error
///////////////////////////////////////////////////////////////

int ProcessCommandLine(int argc, char **argv)
{
   BOOL fFoundServer = FALSE;
   BOOL fFoundDomain = FALSE;
   BOOL fFoundUser = FALSE;
   BOOL fFoundPasswd = FALSE;
   int i;
   
   // Must have at least output file name, the two server names, and the
   // associated /f, /source and /target

   if (argc < 7) return 1;
  
   // First argument must be the /f followed by the output file name
   if (_stricmp(argv[1],"/f")) {
      printf("Missing Output file name\n");
      return 1;
   }
   pOutFile = argv[2];

   
   // Must be followed by /source for source dc arguments
   if (_stricmp(argv[3],"/source")) return 1;

   // ok, so we are now processing the source parameters

   i = 4;
   
   while( _stricmp(argv[i], "/target") && (i<12) ) {
     if (!_stricmp(argv[i],"/s")) {
       // server name 
       if (fFoundServer)  return 1;
       fFoundServer = TRUE; 
       pSrcServer = argv[++i];
     }
     if (!_stricmp(argv[i],"/d")) {
       // domain name
       if (fFoundDomain) return 1;
       fFoundDomain = TRUE;
       pSrcDomain = argv[++i];
     }
     if (!_stricmp(argv[i],"/u")) {
       // user name
       if (fFoundUser)  return 1;
       fFoundUser = TRUE;
       pSrcUser = argv[++i];
     }
     if (!_stricmp(argv[i],"/p")) {
       // server name
       if (fFoundPasswd)  return 1;
       fFoundPasswd = TRUE;
       pSrcPasswd = argv[++i];
     }
     i++;
   }

   if (!fFoundServer || !fFoundDomain) {
     printf("No Source server or domain specified\n");
     return 1;
   }

   if (_stricmp(argv[i++], "/target")) return 1;

   fFoundServer = FALSE;
   fFoundDomain = FALSE;
   fFoundUser = FALSE;
   fFoundPasswd = FALSE;

   while( i<argc) {
     if (!_stricmp(argv[i],"/s")) {
       // server name
       if (fFoundServer)  return 1;
       fFoundServer = TRUE;
       pTargetServer = argv[++i];
     }
     if (!_stricmp(argv[i],"/d")) {
       // domain name
       if (fFoundDomain) return 1;
       fFoundDomain = TRUE;
       pTargetDomain = argv[++i];
     }
     if (!_stricmp(argv[i],"/u")) {
       // user name
       if (fFoundUser)  return 1;
       fFoundUser = TRUE;
       pTargetUser = argv[++i];
     }
     if (!_stricmp(argv[i],"/p")) {
       // server name
       if (fFoundPasswd)  return 1;
       fFoundPasswd = TRUE;
       pTargetPasswd = argv[++i];
     }
     i++;
   }
   if (!fFoundServer || !fFoundDomain) {
     printf("No Target server or domain specified\n");
     return 1;
   }

   return 0;

}



void UsagePrint()
{
   printf("Command line errored\n");
   printf("Usage: Schemard /f <OutFile> /source /s <SrcServer> /d <SrcDomain> /u <SrcUser> /p <SrcPasswd> /target /s <TrgServer> /d <TrgDomain> /u <TrgUser> /p <TrgPasswd>\n");
   printf("OutFile:  Output file name (mandatory)\n");
   printf("SrcServer:  Server name for source schema (mandatory)\n");
   printf("SrcDomain:  Domain name in server for source schema (mandatory)\n");
   printf("SrcUser:   User name to authenticate with in source server (optional, default is administrator)\n");
   printf("SrcPasswd:   User passwd to authenticate with in source server (optional, default is NULL)\n");
   printf("TrgServer:  Server name for target schema (mandatory)\n");
   printf("TrgDomain:  Domain name in server for target schema (mandatory)\n");
   printf("TrgUser:   User name to authenticate with in target server (optional, default is administrator)\n");
   printf("TrgPasswd:   User passwd to authenticate with in target server (optional, default is NULL)\n");
}


void __cdecl main( int argc, char **argv )
{
    ULONG   i, Id;
    ULONG   CLSCOUNT;
    ULONG   ATTCOUNT;
    FILE   *fp;
 

    if ( ProcessCommandLine(argc, argv)) 
      {
         UsagePrint();
         exit( 1 );
      };

    // open log file
    logfp = fopen( "Schemard.log","w" );

    // open OID list file
    OIDfp = fopen( "schemard.OID","w" );

      // Create and initialize the Schema Pointer that will point 
      // to the schema cache of the first machine, then create the 
      // hashtables in the cache

    SchemaPtr1 = (SCHEMAPTR *) calloc( 1, sizeof(SCHEMAPTR) );
    if ( SchemaPtr1 == NULL ) { 
          printf("Cannot allocate schema pointer\n");
          exit( 1 );
       };
    SchemaPtr1->ATTCOUNT = MAX_ATTCOUNT;
    SchemaPtr1->CLSCOUNT = MAX_CLSCOUNT;
 
    if ( CreateHashTables( SchemaPtr1 ) != 0 ) {
       printf("Error creating hash tables\n");
       exit( 1 );
      };

 
    CLSCOUNT = SchemaPtr1->CLSCOUNT;
    ATTCOUNT = SchemaPtr1->ATTCOUNT;

      // Read the first Schema and add it to the Schema Cache

    if ( SchemaRead( pSrcServer, 
                     pSrcDomain, 
                     pSrcUser, 
                     pSrcPasswd, 
                     &pSrcSchemaDN, 
                     SchemaPtr1) != 0 )
          { 
            printf("Schema Read error\n");
            exit(1);
          };

    printf("End of first schema read\n"); 


     // Repeat the same steps to load the schema from the second machine

    SchemaPtr2 = (SCHEMAPTR *) calloc( 1, sizeof(SCHEMAPTR) );
    if ( SchemaPtr2 == NULL ) {
       printf("Cannot allocate schema pointer\n");
       exit( 1 );
     };
    SchemaPtr2->ATTCOUNT = MAX_ATTCOUNT;
    SchemaPtr2->CLSCOUNT = MAX_CLSCOUNT;

    if ( CreateHashTables(SchemaPtr2) != 0 ) {
        printf("Error creating hash tables\n");
        exit( 1 );
     };

    CLSCOUNT = SchemaPtr2->CLSCOUNT;
    ATTCOUNT = SchemaPtr2->ATTCOUNT;

    if ( SchemaRead( pTargetServer, 
                     pTargetDomain, 
                     pTargetUser, 
                     pTargetPasswd, 
                     &pTargetSchemaDN, 
                     SchemaPtr2 ) != 0 )
       { 
         printf("Schema Read error\n");
         exit( 1 );
       };


    printf("End of second schema read\n"); 


    // At this point, we have the two schemas loaded in two schema caches,
    // the schema in the source server pointed to by SchemaPtr1 and the 
    // the schema in the target server  by SchemaPtr2. 
    // Now look for adds. deletes, and mods between the target and the 
    // source schemas. Note that the order of Add/Modify/Delete is important
    // to take care of possible dependencies between schema operations

    fp = fopen( pOutFile,"w" );
    FindAdds( fp, SchemaPtr1, SchemaPtr2 );
    FindModify( fp, SchemaPtr1, SchemaPtr2 );
    FindDeletes( fp, SchemaPtr1, SchemaPtr2 );
    fclose( fp );
    fclose( logfp );
    fclose( OIDfp );
     

         // Free all allocated memory 
    printf("freeing memory\n");

    FreeCache( SchemaPtr1 );
    FreeCache( SchemaPtr2 );

    free( SchemaPtr1 );
    free( SchemaPtr2 );

    free( pSrcSchemaDN );
    free( pTargetSchemaDN );
   

};


// Define the list of attributes of an attribute-schema and a 
// class-schema object that we are interested in. Basically,
// we will read all attributes, but read the OID-syntaxed ones
// in binary to get back the BER-encoded strings for them

char *AttrSchList[] = {
       "attributeId;binary",
       "ldapDisplayName",
       "distinguishedName",
       "adminDisplayName",
       "adminDescription",
       "attributeSyntax;binary",
//       "nTSecurityDescriptor",
       "isSingleValued",
       "rangeLower",
       "rangeUpper",
       "mapiID",
       "linkID",
       "schemaIDGuid",
       "attributeSecurityGuid",
       "omObjectClass",
       "omSyntax",
       "searchFlags",
       "systemOnly",
       "showInAdvancedViewOnly",
       "isMemberOfPartialAttributeSet",
       "extendedCharsAllowed",
       "systemFlags",
     };

int cAttrSchList = sizeof(AttrSchList) / sizeof(AttrSchList[0]);

char *ClsSchList[] = {
       "governsId;binary",
       "ldapDisplayName",
       "distinguishedName",
       "adminDisplayName",
       "adminDescription",
       "defaultSecurityDescriptor",
//       "nTSecurityDescriptor",
       "defaultObjectCategory",
       "rDNAttId;binary",
       "objectClassCategory",
       "subClassOf;binary",
       "systemAuxiliaryClass;binary",
       "auxiliaryClass;binary",
       "systemPossSuperiors;binary",
       "possSuperiors;binary",
       "systemMustContain;binary",
       "mustContain;binary",
       "systemMayContain;binary",
       "mayContain;binary",
       "schemaIDGuid",
       "systemOnly",
       "systemFlags",
       "showInAdvancedViewOnly",
       "defaultHidingValue",
     }; 

int cClsSchList = sizeof(ClsSchList) / sizeof(ClsSchList[0]);

///////////////////////////////////////////////////////////////
// Routine Description:
//      Read the schema from the schema NC in the machine
//      pServerName, and load it in the cache tables. 
//      If no user name is specified, default is "administrator"
//      If no password is specified, defualt is "no password"
//
// Arguments: 
//      pServerName - Server Name
//      pDomainName - Domain name
//      pUserName   - User name (NULL if no user specified)
//      pPasswd     - Passwd (NULL if o passwd speciifed)
//      ppSchemaDN   - Pointer to store newly allocated schema NC DN should be freed 
//                     by caller
//      SCPtr       - Pointer to schema cache to load
//
// Return Value: 
//      0 if no errors, non-0 if error
///////////////////////////////////////////////////////////////

int SchemaRead( char *pServerName, 
                char *pDomainName, 
                char *pUserName, 
                char *pPasswd, 
                char **ppSchemaDN, 
                SCHEMAPTR *SCPtr)
{
   SEC_WINNT_AUTH_IDENTITY Credentials;
	LDAP            *ld;
	LDAPMessage     *res, *e;
    LDAPSearch      *pSearchPage = NULL;
    void            *ptr;
    char            *a;
    struct berval  **vals;
    ULONG            status;
    ULONG            version = 3;
    char *temp;

    struct l_timeval    strTimeLimit={ 600,0 };
    ULONG               ulDummyCount=0;
    const               cSize=100;


    char            **attrs = NULL;
    int              i;
    int              err;

    int count = 1;

    // open a connection to machine named MachineName
    if ( (ld = ldap_open( pServerName, LDAP_PORT )) == NULL ) {
        printf("Failed to open connection to %s\n", pServerName);
        return(1);
    }

    printf("Opened connection to %s\n", pServerName); 

    // Set version to 3
    ldap_set_option( ld, LDAP_OPT_VERSION, &version );


    attrs = MallocExit(2 * sizeof(char *));
    attrs[0] = _strdup("schemaNamingContext"); 
    attrs[1] = NULL;
    if ( ldap_search_s( ld,
                        "",
                        LDAP_SCOPE_BASE,
                        "(objectclass=*)",
                        attrs,
                        0,
                        &res ) != LDAP_SUCCESS ) {
          printf("Root DSE search failed\n");
          return( 1 );
      }

    for ( e = ldap_first_entry( ld, res );
          e != NULL;
          e = ldap_next_entry( ld, e ) ) {

       for ( a = ldap_first_attribute( ld, e,
                                      (struct berelement**)&ptr);
             a != NULL;
             a = ldap_next_attribute( ld, e, (struct berelement*)ptr ) ) {
  
             vals = ldap_get_values_len( ld, e, a );

             if ( !_stricmp(a,"schemaNamingContext") ) {
                    *ppSchemaDN = MallocExit(vals[0]->bv_len + 1);
                    memcpy( *ppSchemaDN, vals[0]->bv_val, vals[0]->bv_len );
                    (*ppSchemaDN)[vals[0]->bv_len] = '\0';
             }
             ldap_value_free_len( vals );
       }
    }
    ldap_msgfree( res );
    free( attrs[0] );
    free( attrs ); attrs = NULL;



/************
    // do simple bind

    if ( pUserName == NULL ) {
       // No user specified, bind as administrator
        strcpy( pszBuffer, "CN=Administrator,CN=Users," );
    }
    else {
        strcpy( pszBuffer,"CN=" );
        strcat( pszBuffer,pUserName );
        strcat( pszBuffer,",CN=Users," );
    }
    strcat( pszBuffer, DomainDN );


    if ( (err = ldap_simple_bind_s( ld, pszBuffer, pPasswd))
                    != LDAP_SUCCESS ) {
           printf("Simple bind to server %s, domain %s with user %s failed, error is %d\n", pServerName, DomainDN, pszBuffer, err);
           return( 1 );
       }

    printf("Successfully bound to %s\n", pServerName);
***********/


    // Do SSPI bind
    memset(&Credentials, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));
    Credentials.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;    
    
    // Domain name must be there. If User Name is not supplied,
    // use "administrator". If no password is supplied, use null

    Credentials.Domain = pDomainName;
    Credentials.DomainLength = strlen(pDomainName);
    if ( pUserName == NULL ) {    
      Credentials.User = "Administrator";
      Credentials.UserLength = strlen("Administrator");
    }
    else {
      Credentials.User = pUserName;
      Credentials.UserLength = strlen(pUserName);
    }
    if ( pPasswd == NULL ) {
      Credentials.Password = "";
      Credentials.PasswordLength = 0;
    }
    else {
      Credentials.Password = pPasswd;
      Credentials.PasswordLength = strlen(pPasswd); 
    }


    err = ldap_bind_s(ld,
              NULL,  // use credentials instead
              (VOID*) &Credentials,
              LDAP_AUTH_SSPI);

    if (err != LDAP_SUCCESS) {
         printf("SSPI bind failed %d\n", err);
         return (1);
    }

    printf( "SSPI bind succeeded\n");






      // Select the attributes of an attribute schema object to 
      // search for. We want all attributes 

    attrs = MallocExit((cAttrSchList + 1) * sizeof(char *));
    for ( i = 0; i < cAttrSchList; i++ ) {
       
       attrs[i] = _strdup(AttrSchList[i]);
    }
    attrs[i] = NULL;


	  // Search for  attribute schema entries, return all attrs  
      // Since no. of attributes is large, we need to do paged search

      // initialize the paged search
      pSearchPage = ldap_search_init_page( ld,
                                           *ppSchemaDN,
                                           LDAP_SCOPE_ONELEVEL, 
                                           "(objectclass=attributeSchema)",
                                           attrs,
                                           0,
                                           NULL,
                                           NULL,
                                           600,
                                           0,
                                           NULL
                                         );


      if ( !pSearchPage )
         {
            printf("SchemaRead: Error initializing paged Search\n");
            return 1;
         }  


      while( TRUE )
          {
             status = ldap_get_next_page_s( ld,
                                            pSearchPage,
                                            &strTimeLimit,
                                            cSize,
                                            &ulDummyCount,
                                            &res
                                          );

             if ( status == LDAP_TIMEOUT )
             {
                printf("timeout: continuing\n");
                continue;

             }

             if ( status == LDAP_SUCCESS )
             {
               printf("Got Page %d\n", count++);
               if ( AddAttributesToCache( ld, res, SCPtr ) != 0 ) {
                 printf("Error adding attribute schema objects in AddAttributestoCache\n");
                 return( 1 );
                };

                continue;

             }

             if ( status == LDAP_NO_RESULTS_RETURNED )
             {
                 printf("End Page %d\n", count);
                 // these are signs that our paged search is done
                 status = LDAP_SUCCESS;
                 break;
             }
             else {
               printf("SchemaRead: Unknown error in paged search: %d\n", status);
               return 1;
             }

          }// while 


      // Free the attrs array entries

    for( i = 0; i < cAttrSchList; i++ )
      { free( attrs[i] ); }
    free( attrs ); attrs = NULL;
	  // free the search results

    ldap_msgfree( res );


     // Now search for class schema objects. Select the attributes 
     // to search for. We want all attributes, but we want the values 
     // of governsId, RDNAttId, subClassof, systemAuxiliaryClass, 
     // systemPossSuperiors, systemMayContain and systemMustContain 
     // in binary (as dotted decimal OID strings)
    attrs = MallocExit((cClsSchList + 1) * sizeof(char *));
    for ( i = 0; i < cClsSchList; i++ ) {
       attrs[i] = _strdup(ClsSchList[i]);
    }
    attrs[i] = NULL;


      // Now search for all class schema entries and get all attributes 

	if ( ldap_search_s( ld,
                        *ppSchemaDN,
			            LDAP_SCOPE_ONELEVEL,
			            "(objectclass=classSchema)",
			            attrs,
		        	    0,
			            &res ) != LDAP_SUCCESS ) {
		  ldap_perror( ld, "ldap_search_s" );
		  printf("Insuccess");
		  return( 1 );
	  }
	else
		printf("Success\n");

      //  Find all class schema entries and add to class cache structure 

    if ( AddClassesToCache( ld, res, SCPtr ) != 0 ) {  
         printf("Error adding class schema objects in AddClasstoCache\n");
         return( 1 );
       };  

      // Free the attrs array entries

     for( i = 0; i < cClsSchList; i++ ) { free( attrs[i] ); }
     free( attrs ); attrs = NULL;
	  // Free the search results 

	ldap_msgfree( res );   

	// End of schema read. Close and free connection resources 

	ldap_unbind( ld );

    return(0);
}




///////////////////////////////////////////////////////////////////////
// Routine Description:
//     Find all schema objects that occur in source schema but not in the
//     target, and  write them out in a ldif file so that they will
//     be added to the target schema
//
// Arguments: 
//     fp     -- File pointer to (opened) ldif output file
//     SCPtr1 - Pointer to the source schema
//     SCPtr2 - Pointer to the target schema
//
// Retuen Value: None
///////////////////////////////////////////////////////////////////////

void FindAdds( FILE *fp, SCHEMAPTR *SCPtr1, SCHEMAPTR *SCPtr2 )
{
    ATT_CACHE    *pac, *p1;
    CLASS_CACHE  *pcc, *p2;
    HASHCACHE    *ahcId, *ahcClass; 
    HASHCACHESTRING *ahcName, *ahcClassName;
    ULONG         ATTCOUNT, CLSCOUNT;
    ATT_CACHE    *ppAttAdds[MAX_ATT_CHANGE]; 
    CLASS_CACHE  *ppClsAdds[MAX_CLS_CHANGE]; 
    ULONG         Id;
    ULONG         i, j, cnt = 0;

    // First find all objects that appear in source schema but
    // not in target. These will be adds to the target schema

    ahcId    = SCPtr1->ahcId;
    ahcClass = SCPtr1->ahcClass ;
    ahcName  = SCPtr1->ahcName;
    ahcClassName = SCPtr1->ahcClassName ;
    ATTCOUNT = SCPtr1->ATTCOUNT;
    CLSCOUNT = SCPtr1->CLSCOUNT;

    for ( i = 0; i < ATTCOUNT; i++ )
        { if ( (ahcName[i].pVal != NULL) && (ahcName[i].pVal != FREE_ENTRY) ) {
          pac = (ATT_CACHE *) ahcName[i].pVal;
          if( GetAttByName(SCPtr2, pac->nameLen, pac->name, &p1) != 0 )
             { 
               ppAttAdds[cnt++] = pac;
             }
          }
     }
    FileWrite_AttAdd( fp, ppAttAdds, cnt );
   
    cnt = 0;
    for ( i = 0; i < CLSCOUNT; i++ )
        { if ( (ahcClassName[i].pVal != NULL) 
                  && (ahcClassName[i].pVal != FREE_ENTRY) ) {
          pcc = (CLASS_CACHE *) ahcClassName[i].pVal;
          if( GetClassByName(SCPtr2, pcc->nameLen, pcc->name, &p2) != 0 )
            { 
              ppClsAdds[cnt++] = pcc;
            }
          }
     }

     // Ok, now we got the list of classes to be added. Now do a 
     // dependency analysis to add the classes in the right order

     for ( i = 0; i < cnt; i++ ) {

        for( j = i+1; j < cnt; j++ ) {
           p2 = ppClsAdds[i];
           Id = ppClsAdds[j]->ClassId;
           if ( IsMemberOf( Id, p2->pSubClassOf, p2->SubClassCount )
                  || IsMemberOf( Id, p2->pAuxClass, p2->AuxClassCount )
                  || IsMemberOf( Id, p2->pSysAuxClass, p2->SysAuxClassCount )
                  || IsMemberOf( Id, p2->pPossSup, p2->PossSupCount )
                  || IsMemberOf( Id, p2->pSysPossSup, p2->SysPossSupCount )
              ) {
             ppClsAdds[i] = ppClsAdds[j];
             ppClsAdds[j] = p2;
           }
        }
     }
     FileWrite_ClsAdd( fp, ppClsAdds, cnt );
}


///////////////////////////////////////////////////////////////////////
// Routine Description:
//     Find all schema objects that occur in the target schema but not 
//     in the source schema, and wirte out to the ldif file so that
//     they will be deleted from the target schema
//
// Arguments:
//     fp     - File pointer to (opened) ldif output file
//     SCPtr1 - Pointer to the source schema
//     SCPtr2 - Pointer to the target schema
//
// Retuen Value: None
///////////////////////////////////////////////////////////////////////

void FindDeletes( FILE *fp, SCHEMAPTR *SCPtr1, SCHEMAPTR *SCPtr2 )
{
    ATT_CACHE    *pac, *p1;
    CLASS_CACHE  *pcc, *p2;
    HASHCACHE    *ahcId, *ahcClass;
    HASHCACHESTRING *ahcName, *ahcClassName;
    ULONG         ATTCOUNT, CLSCOUNT;
    ATT_CACHE    *ppAttDels[MAX_ATT_CHANGE];
    CLASS_CACHE  *ppClsDels[MAX_CLS_CHANGE];
    ULONG         Id;
    ULONG         i, j, cnt = 0;
    

    // Find the objects that
    // needs to be deleted on the target schema
    
    ahcId    = SCPtr2->ahcId;
    ahcClass = SCPtr2->ahcClass ;
    ahcName  = SCPtr2->ahcName;
    ahcClassName = SCPtr2->ahcClassName ;
    ATTCOUNT = SCPtr2->ATTCOUNT;
    CLSCOUNT = SCPtr2->CLSCOUNT;


    for ( i = 0; i < CLSCOUNT; i++ )
        { if ( (ahcClassName[i].pVal != NULL) 
                   && (ahcClassName[i].pVal != FREE_ENTRY) ) {
          pcc = (CLASS_CACHE *) ahcClassName[i].pVal;
          if( GetClassByName(SCPtr1, pcc->nameLen, pcc->name, &p2) != 0 )
             { 
               ppClsDels[cnt++] = pcc;
             }
          }
     }

    // Now order the deletes to take care of dependencies

     for ( i = 0; i < cnt; i++ ) {
        for( j = i+1; j < cnt; j++ ) {
           p2 = ppClsDels[j];
           Id = ppClsDels[i]->ClassId;
           if ( IsMemberOf( Id, p2->pSubClassOf, p2->SubClassCount )
                  || IsMemberOf( Id, p2->pAuxClass, p2->AuxClassCount )
                  || IsMemberOf( Id, p2->pSysAuxClass, p2->SysAuxClassCount )
                  || IsMemberOf( Id, p2->pPossSup, p2->PossSupCount )
                  || IsMemberOf( Id, p2->pSysPossSup, p2->SysPossSupCount )
              ) {
             ppClsDels[j] = ppClsDels[i];
             ppClsDels[i] = p2;
           }
        }
     }
    FileWrite_ClsDel(fp, ppClsDels, cnt);

    cnt = 0;
    p1 = (ATT_CACHE *) MallocExit( sizeof(ATT_CACHE) );
    for ( i = 0; i < ATTCOUNT; i++ )
        { if ( (ahcName[i].pVal != NULL) && (ahcName[i].pVal != FREE_ENTRY) ) {
          pac = (ATT_CACHE *) ahcName[i].pVal;
          if( GetAttByName(SCPtr1, pac->nameLen, pac->name, &p1) != 0 )
             {
               ppAttDels[cnt++] = pac;
             }
          }
     }
    FileWrite_AttDel( fp, ppAttDels, cnt );

}




///////////////////////////////////////////////////////////////////////
// Routine Description:
//     Find and write out to an ldif file all schema objects in target
//     schema that needs to be modified because they are different from 
//     the same object in the source schema (same = same OID)
//
// Arguments:
//     fp     -- File pointer to (opened) ldif output file
//     SCPtr1 - Pointer to the source schema
//     SCPtr2 - Pointer to the target schema
//
// Retuen Value: None
///////////////////////////////////////////////////////////////////////


void FindModify( FILE *fp, SCHEMAPTR *SCPtr1, SCHEMAPTR *SCPtr2 )
{
    ATT_CACHE    *pac, *p1;
    CLASS_CACHE  *pcc, *p2;
    ULONG         i;
    HASHCACHE    *ahcId    = SCPtr1->ahcId ;
    HASHCACHE    *ahcClass = SCPtr1->ahcClass ;
    ULONG         ATTCOUNT = SCPtr1->ATTCOUNT;
    ULONG         CLSCOUNT = SCPtr1->CLSCOUNT;

      // Find and write attribute modifications

    for ( i = 0; i < ATTCOUNT; i++ )
      { if ( (ahcId[i].pVal != NULL ) && (ahcId[i].pVal != FREE_ENTRY) ) {
          pac = (ATT_CACHE *) ahcId[i].pVal;
          FindAttModify( fp, pac, SCPtr2 );
        };
      }

    printf("No. of attributes modified %d\n", NoOfMods);
    NoOfMods = 0;
        
      // Find and write class modifications

    for ( i = 0; i < CLSCOUNT; i++)
      { if ( (ahcClass[i].pVal != NULL) 
                 && (ahcClass[i].pVal != FREE_ENTRY) ) {
          pcc = (CLASS_CACHE *) ahcClass[i].pVal;
          FindClassModify( fp, pcc, SCPtr2 );
        };
      }
    printf("No. of classes modified %d\n", NoOfMods);

}




///////////////////////////////////////////////////////////////////////
// Routine Descrpition:
//     Given an attribute schema object, find any/all  modifications
//     that need to be made to it because it is different from
//     the same attribute schema object in the source schema. 
//     Modifications to non-system-only attributeas are written out
//     to an ldif files, warnings are generated in the log file
//     if any system-only attribute needs to be modified. 
//
// Arguments: 
//     fp  - File pointer to (opened) ldif output file
//     pac - ATT_CACHE to compare
//     SCPtr - Pointer to source schema to look up
//
// Return Value: None
////////////////////////////////////////////////////////////////////////

void FindAttModify( FILE *fp, ATT_CACHE *pac, SCHEMAPTR *SCPtr )
{
    ULONG          i;
    ULONG          ATTCOUNT = SCPtr->ATTCOUNT;
    ATT_CACHE     *p;
    
    MODIFYSTRUCT   ModStruct;
    ULONG          modCount = 0;
    ULONGLIST     *pL1, *pL2;
    ATTRVAL       *pAVal;


     // Do a dummy LogConflict to reset the static flag in that
     // routine. This is done to print out only attributes for which
     // conflicts have been found
     
    if( GetAttByName( SCPtr, pac->nameLen, pac->name, &p ) == 0 ) {

      // There exists an attribute schema object with the same AttId.
      // Now compare the two objects and look for changes

           // ldap-diplay-name (every schema obj. has one, so if
           // they don't match, simply replace with the one in
           // source schema)

       if ( _stricmp( pac->name,p->name ) != 0 )  {
           pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
           pAVal->valLen = pac->nameLen;
           pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
           memcpy( pAVal->pVal, pac->name, pAVal->valLen + 1 ); 
           AddToModStruct( &(ModStruct.ModList[modCount]), 
                           AT_CHOICE_REPLACE_ATT, 
                           ATT_LDAP_DISPLAY_NAME, 
                           STRING_TYPE, 
                           1, 
                           pAVal);
           modCount++;
       }

            // admin-display-name (same logic as ldap-display-name)

       if ( _stricmp( pac->adminDisplayName,p->adminDisplayName ) != 0 )  {
           pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
           pAVal->valLen = pac->adminDisplayNameLen;
           pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
           memcpy( pAVal->pVal, pac->adminDisplayName, pAVal->valLen + 1 );
           AddToModStruct( &(ModStruct.ModList[modCount]), 
                           AT_CHOICE_REPLACE_ATT, 
                           ATT_ADMIN_DISPLAY_NAME, 
                           STRING_TYPE, 
                           1, 
                           pAVal);
           modCount++;
       }

           // admin-description (no action necessary if not present
           // in both the given attribute and the matching attribute in
           // source schema, or if present in both but same. Otherwise,
           // need to modify) 

       if ( (pac->adminDescr || p->adminDescr) &&
                ( !(pac->adminDescr)  ||
                  !(p->adminDescr)  ||
                  ( _stricmp(pac->adminDescr,p->adminDescr) != 0) 
                )   // End &&
          )  {
              pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
              if ( pac->adminDescr ) {

                 // present in source schema. So replace with source value
                 // if also present in given attribute, else add the source
                 // value to the given attribute

                 pAVal->valLen = pac->adminDescrLen;
                 pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
                 memcpy( pAVal->pVal, pac->adminDescr, pAVal->valLen + 1 ); 
                 if ( p->adminDescr ) {
                     AddToModStruct( &(ModStruct.ModList[modCount]), 
                                     AT_CHOICE_REPLACE_ATT, 
                                     ATT_ADMIN_DESCRIPTION, 
                                     STRING_TYPE, 
                                     1, 
                                     pAVal);
                 }
                 else {
                     AddToModStruct( &(ModStruct.ModList[modCount]), 
                                     AT_CHOICE_ADD_VALUES, 
                                     ATT_ADMIN_DESCRIPTION, 
                                     STRING_TYPE, 
                                     1, 
                                     pAVal);
                 }
              }
              else {
                 // not present in source schema, so remove the
                 // value from the given attribute

                 pAVal->valLen = p->adminDescrLen;
                 pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
                 memcpy( pAVal->pVal, p->adminDescr, pAVal->valLen + 1 ); 
                 AddToModStruct( &(ModStruct.ModList[modCount]), 
                                 AT_CHOICE_REMOVE_VALUES, 
                                 ATT_ADMIN_DESCRIPTION, 
                                 STRING_TYPE, 
                                 1, 
                                 pAVal);
              }

              modCount++;
          }

              // range-lower (similar logic as admin-description above)

      if ( (pac->rangeLowerPresent != p->rangeLowerPresent)
             || ( (pac->rangeLowerPresent && p->rangeLowerPresent)  &&
                    (pac->rangeLower != p->rangeLower) ) // end of ||
         ) {
          
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                     pac, p, ATT_RANGE_LOWER );

           modCount++;
       }

             // range-upper

      if ( (pac->rangeUpperPresent != p->rangeUpperPresent)
             || ( (pac->rangeUpperPresent && p->rangeUpperPresent)  &&
                    (pac->rangeUpper != p->rangeUpper) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_RANGE_UPPER );
           modCount++;
       }

            // Search-Flags

      if ( (pac->bSearchFlags != p->bSearchFlags)
             || ( (pac->bSearchFlags && p->bSearchFlags)  &&
                    (pac->SearchFlags != p->SearchFlags) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_SEARCH_FLAGS );
           modCount++;
       }


          // System-Flags

      if ( (pac->bSystemFlags != p->bSystemFlags)
             || ( (pac->bSystemFlags && p->bSystemFlags)  &&
                    (pac->sysFlags != p->sysFlags) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_SYSTEM_FLAGS );
           modCount++;
       }


           // Hide-From-Address-Book

      if ( (pac->bHideFromAB != p->bHideFromAB)
             || ( (pac->bHideFromAB && p->bHideFromAB)  &&
                    (pac->HideFromAB != p->HideFromAB) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_SHOW_IN_ADVANCED_VIEW_ONLY );
           modCount++;
       }


           // System-Only

      if ( (pac->bSystemOnly != p->bSystemOnly)
             || ( (pac->bSystemOnly && p->bSystemOnly)  &&
                    (pac->SystemOnly != p->SystemOnly) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_SYSTEM_ONLY );
           modCount++;
       }
       
           // Is-Single-Valued

      if ( (pac->bisSingleValued != p->bisSingleValued)
             || ( (pac->bisSingleValued && p->bisSingleValued)  &&
                    (pac->isSingleValued != p->isSingleValued) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_IS_SINGLE_VALUED );
           modCount++;
       }

         // Member-Of-Partial-Attribute-Set

      if ( (pac->bMemberOfPartialSet != p->bMemberOfPartialSet)
             || ( (pac->bMemberOfPartialSet && p->bMemberOfPartialSet)  &&
                    (pac->MemberOfPartialSet != p->MemberOfPartialSet) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, 
                                    ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET );
           modCount++;
       }

          // Attribute-Security-Guid

      if ( (pac->bPropSetGuid != p->bPropSetGuid)
             || ( (pac->bPropSetGuid && p->bPropSetGuid)  &&
                     (memcmp(&(pac->propSetGuid), &(p->propSetGuid), sizeof(GUID)) != 0 ) ) // end of ||
         ) {
           CreateFlagBasedAttModStr( &(ModStruct.ModList[modCount]),
                                    pac, p, ATT_ATTRIBUTE_SECURITY_GUID );
           modCount++;
       }

          // NT-Security-Descriptor

       if ( (pac->NTSDLen != p->NTSDLen)  ||
               (memcmp(pac->pNTSD, p->pNTSD, pac->NTSDLen) != 0) 
          ) {
           pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
           pAVal->valLen = pac->NTSDLen;
           pAVal->pVal = (UCHAR *) MallocExit(pac->NTSDLen);
           memcpy( pAVal->pVal, pac->pNTSD, pac->NTSDLen );
           AddToModStruct( &(ModStruct.ModList[modCount]),
                           AT_CHOICE_REPLACE_ATT,
                           ATT_NT_SECURITY_DESCRIPTOR,
                           BINARY_TYPE,
                           1,
                           pAVal);
           modCount++;
       }

       if (modCount != 0) {
          // at least one attribute needs to be modified,
          // so write out to ldif file
           NoOfMods++;
           ModStruct.count = modCount;
           FileWrite_Mod( fp, p->DN, &ModStruct );
       }

       // Check for modifications to System-Only Attributes. We will 
       // only generate warnings for these

       if ( pac->syntax != p->syntax ) 
             GenWarning( 'a', ATT_ATTRIBUTE_SYNTAX, pac->name );
       if ( pac->OMsyntax != p->OMsyntax ) 
             GenWarning( 'a', ATT_OM_SYNTAX, pac->name );
#if 0
Nope, a schema upgrade required modifications
       if ( pac->isSingleValued != p->isSingleValued ) 
             GenWarning( 'a', ATT_IS_SINGLE_VALUED, pac->name );
#endif 0
       if ( pac->ulMapiID != p->ulMapiID )
             GenWarning( 'a', ATT_MAPI_ID, pac->name );
#if 0
Nope, a schema upgrade required modifications
       if ( pac->bSystemOnly != p->bSystemOnly )
             GenWarning( 'a', ATT_SYSTEM_ONLY, pac->name );
#endif 0
       if ( pac->bExtendedChars != p->bExtendedChars )
             GenWarning( 'a', ATT_EXTENDED_CHARS_ALLOWED, pac->name );
       if ( memcmp(&(pac->propGuid), &(p->propGuid), sizeof(GUID)) != 0 )
             GenWarning( 'a', ATT_SCHEMA_ID_GUID, pac->name);
       if ( memcmp(&pac->propSetGuid, &p->propSetGuid, sizeof(GUID)) != 0 )
             GenWarning( 'a', ATT_ATTRIBUTE_SECURITY_GUID, pac->name );
      }
  
}


///////////////////////////////////////////////////////////////////////
// Routine Descrpition:
//     Given an class schema object, find any/all  modifications
//     that need to be made to it because it is different from
//     the same class schema object in the source schema.
//     Modifications to non-system-only attributeas are written out
//     to an ldif files, warnings are generated in the log file
//     if any system-only attribute needs to be modified.
//
// Arguments:
//     fp  - File pointer to (opened) ldif output file
//     pac - CLASS_CACHE to compare
//     SCPtr - Pointer to source schema to look up
//
// Return Value: None
////////////////////////////////////////////////////////////////////////

void FindClassModify( FILE *fp, CLASS_CACHE *pcc, SCHEMAPTR *SCPtr )
{
    ULONG         i;
    ULONG         CLSCOUNT = SCPtr->CLSCOUNT;
    CLASS_CACHE  *p;

    MODIFYSTRUCT  ModStruct;
    ULONG         modCount = 0, tempCount;
    ULONGLIST    *pL1, *pL2;
    ATTRVAL      *pAVal;

    if ( GetClassByName( SCPtr, pcc->nameLen, pcc->name, &p ) == 0 ) {

      // There exists a class schema object with the same ClassId.
      // Now compare the two objects and look for changes

           // ldap-diplay-name (every schema obj. has one, so if
           // they don't match, simply replace with the one in
           // source schema)

       if ( _stricmp( pcc->name,p->name ) != 0 ) {
           pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
           pAVal->valLen = pcc->nameLen;
           pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
           memcpy( pAVal->pVal, pcc->name, pAVal->valLen + 1 ); 
           AddToModStruct( &(ModStruct.ModList[modCount]), 
                           AT_CHOICE_REPLACE_ATT, 
                           ATT_LDAP_DISPLAY_NAME, 
                           STRING_TYPE, 
                           1, 
                           pAVal);
           modCount++;       
       }

           // admin-display-name (same logic as ldap-display-name)

       if ( _stricmp( pcc->adminDisplayName,p->adminDisplayName ) != 0 )  {
           pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
           pAVal->valLen = pcc->adminDisplayNameLen;
           pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
           memcpy( pAVal->pVal, pcc->adminDisplayName, pAVal->valLen + 1 );
           AddToModStruct( &(ModStruct.ModList[modCount]), 
                           AT_CHOICE_REPLACE_ATT, 
                           ATT_ADMIN_DISPLAY_NAME, 
                           STRING_TYPE, 
                           1, 
                           pAVal);
           modCount++;
       }
          // System-Flags

      if (pcc->ClassCategory != p->ClassCategory) {
          pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
          pAVal->pVal = (UCHAR *) MallocExit(16);
          _ultoa(pcc->ClassCategory, pAVal->pVal, 10 );
          pAVal->valLen = strlen(pAVal->pVal);
          AddToModStruct( &(ModStruct.ModList[modCount]), 
                          AT_CHOICE_REPLACE_ATT, 
                          ATT_OBJECT_CLASS_CATEGORY,
                          STRING_TYPE, 
                          1, 
                          pAVal);
           modCount++;
       }

           // NT-Security-Descriptor

       if ( (pcc->NTSDLen != p->NTSDLen)  ||
               (memcmp(pcc->pNTSD, p->pNTSD, pcc->NTSDLen) != 0)
          ) {
           pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
           pAVal->valLen = pcc->NTSDLen;
           pAVal->pVal = (UCHAR *) MallocExit(pcc->NTSDLen);
           memcpy( pAVal->pVal, pcc->pNTSD, pcc->NTSDLen );
           AddToModStruct( &(ModStruct.ModList[modCount]),
                           AT_CHOICE_REPLACE_ATT,
                           ATT_NT_SECURITY_DESCRIPTOR,
                           BINARY_TYPE,
                           1,
                           pAVal);
           modCount++;
       }

          // admin-description (no action necessary if not present
          // in both the given class and the matching class in
          // source schema, or if present in both but same. Otherwise,
          // need to modify)

       if ( (pcc->adminDescr || p->adminDescr) &&
               ( !(pcc->adminDescr)  ||
                 !(p->adminDescr)  ||
                 ( _stricmp(pcc->adminDescr,p->adminDescr) != 0) 
               )   /* && */
          )  {
              pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));
              if (pcc->adminDescr) {
                 pAVal->valLen = pcc->adminDescrLen;
                 pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
                 memcpy( pAVal->pVal, pcc->adminDescr, pAVal->valLen + 1 ); 
                 if ( p->adminDescr ) {
                     AddToModStruct( &(ModStruct.ModList[modCount]), 
                                     AT_CHOICE_REPLACE_ATT, 
                                     ATT_ADMIN_DESCRIPTION, 
                                     STRING_TYPE, 
                                     1, 
                                     pAVal);
                 }
                 else {
                     AddToModStruct( &(ModStruct.ModList[modCount]), 
                                     AT_CHOICE_ADD_VALUES, 
                                     ATT_ADMIN_DESCRIPTION, 
                                     STRING_TYPE, 
                                     1, 
                                     pAVal);
                 }
              }
              else {
                 pAVal->valLen = p->adminDescrLen;
                 pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen + 1);
                 memcpy( pAVal->pVal, p->adminDescr, pAVal->valLen + 1 ); 
                 AddToModStruct( &(ModStruct.ModList[modCount]), 
                                 AT_CHOICE_REMOVE_VALUES, 
                                 ATT_ADMIN_DESCRIPTION, 
                                 STRING_TYPE, 
                                 1, 
                                 pAVal);
              }
              
              modCount++;
          }

         // default-security-descriptor (similar logic as 
         // admin-description above)

      if ( (pcc->SDLen || p->SDLen ) &&
              ( (pcc->SDLen != p->SDLen) ||
                   (memcmp(pcc->pSD, p->pSD, pcc->SDLen) != 0)
              )  // &&
         ) {
              CreateFlagBasedClsModStr( &(ModStruct.ModList[modCount]),
                                        pcc, p, 
                                        ATT_DEFAULT_SECURITY_DESCRIPTOR);
              modCount++;
       } 

         // Hide-From-Address-Book

      if ( (pcc->bHideFromAB != p->bHideFromAB)
             || ( (pcc->bHideFromAB && p->bHideFromAB)  &&
                    (pcc->HideFromAB != p->HideFromAB) ) // end of ||
         ) {
           CreateFlagBasedClsModStr( &(ModStruct.ModList[modCount]),
                                    pcc, p, ATT_SHOW_IN_ADVANCED_VIEW_ONLY );
           modCount++;
       }

        // Default-Hiding-Value

      if ( (pcc->bDefHidingVal != p->bDefHidingVal)
             || ( (pcc->bDefHidingVal && p->bDefHidingVal)  &&
                    (pcc->DefHidingVal != p->DefHidingVal) ) // end of ||
         ) {
           CreateFlagBasedClsModStr( &(ModStruct.ModList[modCount]),
                                    pcc, p, ATT_DEFAULT_HIDING_VALUE );
           modCount++;
       }
     

        // And finally the mays, musts, possSups, and auxClasses

      if ( CompareUlongList( pcc->pMayAtts, pcc->MayCount,  
                             p->pMayAtts, p->MayCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_MAY_CONTAIN);
       }

      if ( CompareUlongList( pcc->pSysMayAtts, pcc->SysMayCount,  
                             p->pSysMayAtts, p->SysMayCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_SYSTEM_MAY_CONTAIN);
       }

      if ( CompareUlongList( pcc->pMustAtts, pcc->MustCount,  
                             p->pMustAtts, p->MustCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_MUST_CONTAIN);
       }

      if ( CompareUlongList( pcc->pSysMustAtts, pcc->SysMustCount,  
                             p->pSysMustAtts, p->SysMustCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_SYSTEM_MUST_CONTAIN);
       }

      if ( CompareUlongList( pcc->pPossSup, pcc->PossSupCount,  
                             p->pPossSup, p->PossSupCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_POSS_SUPERIORS);
       }

      if ( CompareUlongList( pcc->pSysPossSup, pcc->SysPossSupCount,  
                             p->pSysPossSup, p->SysPossSupCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_SYSTEM_POSS_SUPERIORS);
       }

      if ( CompareUlongList( pcc->pSysAuxClass, pcc->SysAuxClassCount, 
                             p->pSysAuxClass, p->SysAuxClassCount, 
                             &pL1, &pL2) != 0 ) {
           AddToModStructFromLists( &ModStruct, &modCount, 
                                    pL1, pL2, ATT_SYSTEM_AUXILIARY_CLASS);
       }

       if (modCount != 0) {
          // at least one attribute needs to be modified
          // so write out to ldif file
           NoOfMods++;
           ModStruct.count = modCount;
           FileWrite_Mod( fp, p->DN, &ModStruct ); 
       }


       // For system-only attributes, we do not write to the ldif file,
       // just generate a warning in the log file

       if ( pcc->SDLen != p->SDLen ) {
           GenWarning( 'c', ATT_DEFAULT_SECURITY_DESCRIPTOR, pcc->name );
       }
       else { if( memcmp( pcc->pSD, p->pSD, p->SDLen) !=0 )
                GenWarning( 'c', ATT_DEFAULT_SECURITY_DESCRIPTOR, pcc->name );
         };
       if ( pcc->RDNAttIdPresent != p->RDNAttIdPresent ) {
           GenWarning( 'c', ATT_RDN_ATT_ID, pcc->name );
        }
       if ( pcc->RDNAttIdPresent && p->RDNAttIdPresent ) {
         if ( pcc->RDNAttId != p->RDNAttId )
              GenWarning( 'c', ATT_RDN_ATT_ID, pcc->name );
       }
       if ( pcc->bSystemOnly != p->bSystemOnly ) {
            GenWarning( 'c', ATT_SYSTEM_ONLY, pcc->name );
       }
       if ( memcmp(&(pcc->propGuid), &(p->propGuid), sizeof(GUID)) ) {
            GenWarning( 'c', ATT_SCHEMA_ID_GUID, p->name );
       }
       if ( pcc->SubClassCount != p->SubClassCount ) {
            GenWarning( 'c', ATT_SUB_CLASS_OF, pcc->name );
       }
       else {
           tempCount = p->SubClassCount;
           if ( CompareList( pcc->pSubClassOf, p->pSubClassOf,tempCount ) )
               GenWarning( 'c', ATT_SUB_CLASS_OF, pcc->name );
       }

      // system-may-contain, system-must-contain, system-poss-superiors,
      // and system-auxiliary-class are also added through the ldif file
      // to take care of of schema.ini changes. This warning is generated
      // in addition

       if ( pcc->SysAuxClassCount != p->SysAuxClassCount )  {
            GenWarning( 'c', ATT_SYSTEM_AUXILIARY_CLASS, pcc->name );
       }
       else {
           tempCount = p->SysAuxClassCount;
           if ( CompareList( pcc->pSysAuxClass, p->pSysAuxClass, tempCount ) )
               GenWarning( 'c', ATT_SYSTEM_AUXILIARY_CLASS, pcc->name );
       }
       if ( pcc->SysMustCount != p->SysMustCount )  {
            GenWarning( 'c', ATT_SYSTEM_MUST_CONTAIN, pcc->name );
       }
       else {
           tempCount = p->SysMustCount;
           if ( CompareList( pcc->pSysMustAtts, p->pSysMustAtts, tempCount ) )
               GenWarning( 'c', ATT_SYSTEM_MUST_CONTAIN, pcc->name );
       }
       if ( pcc->SysMayCount != p->SysMayCount )  {
            GenWarning( 'c', ATT_SYSTEM_MAY_CONTAIN,pcc->name );
       }
       else {
           tempCount = p->SysMayCount;
           if ( CompareList( pcc->pSysMayAtts, p->pSysMayAtts, tempCount ) )
               GenWarning( 'c', ATT_SYSTEM_MAY_CONTAIN, pcc->name );
       }
       if ( pcc->SysPossSupCount != p->SysPossSupCount)  {
            GenWarning( 'c', ATT_SYSTEM_POSS_SUPERIORS, pcc->name );
       }
       else {
           tempCount = p->SysPossSupCount;
           if ( CompareList( pcc->pSysPossSup, p->pSysPossSup, tempCount) )
               GenWarning( 'c', ATT_SYSTEM_POSS_SUPERIORS, pcc->name);
       }
    }


}

////////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//      Helper routine that takes in adds to a given attribute modlist
//      structure based on the given attribute. Reduces some code
//      duplication.
//
//  Arguments:
//      pModList - pointer to ATTR_MODLIST to fill up
//      pSrcAtt - ATT_CACHE from source schema
//      pTargetAtt - ATT_CACHE from target schema
//      attrTyp - attribute type of interest
//
//  Return Value: None
/////////////////////////////////////////////////////////////////////// 

void CreateFlagBasedAttModStr( MY_ATTRMODLIST *pModList,
                               ATT_CACHE *pSrcAtt,
                               ATT_CACHE *pTargetAtt,
                               ATTRTYP attrTyp)
{
    ATTRVAL    *pAVal;
    BOOL        fInSrc = FALSE, fInTarget = FALSE;
    int         printType = 0;
    ATT_CACHE  *pac = pSrcAtt;
    ATT_CACHE  *p = pTargetAtt;

    pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));

    switch (attrTyp) {

       case ATT_RANGE_LOWER:
           fInSrc = pac->rangeLowerPresent;
           fInTarget = p->rangeLowerPresent;
           printType = STRING_TYPE;

           pAVal->pVal = (UCHAR *) MallocExit(sizeof(ULONG)+1);
           if ( !(pac->rangeLowerPresent) ) {
             // No range lower in source, target value needs to be deleted
              _ultoa( p->rangeLower, pAVal->pVal, 10 );
           }
           else { _ultoa( pac->rangeLower, pAVal->pVal, 10 );}
           pAVal->valLen = strlen(pAVal->pVal);
           break;

       case ATT_RANGE_UPPER:
          fInSrc = pac->rangeUpperPresent;
          fInTarget = p->rangeUpperPresent;
           printType = STRING_TYPE;

          pAVal->pVal = (UCHAR *) MallocExit(sizeof(ULONG)+1);
          if ( !(pac->rangeUpperPresent) ) {
            // No range upper in source, target value needs to be deleted
             _ultoa( p->rangeUpper, pAVal->pVal, 10 );
          }
          else { _ultoa( pac->rangeUpper, pAVal->pVal, 10 );}
          pAVal->valLen = strlen(pAVal->pVal);
          break;
       case ATT_SEARCH_FLAGS:
          fInSrc = pac->bSearchFlags;
          fInTarget = p->bSearchFlags;
          printType = STRING_TYPE;
          pAVal->pVal = (UCHAR *) MallocExit(sizeof(ULONG)+1);
          if ( !(pac->bSearchFlags) ) {
             // No search flag in source, target value needs to be deleted
              _ultoa( p->SearchFlags, pAVal->pVal, 10 );
           }
           else { _ultoa( pac->SearchFlags, pAVal->pVal, 10 );}
           pAVal->valLen = strlen(pAVal->pVal);
           break;

       case ATT_SYSTEM_FLAGS:
          fInSrc = pac->bSystemFlags;
          fInTarget = p->bSystemFlags;
          printType = STRING_TYPE;

          pAVal->pVal = (UCHAR *) MallocExit(sizeof(ULONG)+1);
          if ( !(pac->bSystemFlags) ) {
            // No system-flag in source, target value needs to be deleted
             _ultoa( p->sysFlags, pAVal->pVal, 10 );
          }
          else { _ultoa( pac->sysFlags, pAVal->pVal, 10 );}
          pAVal->valLen = strlen(pAVal->pVal);
          break;

       case ATT_ATTRIBUTE_SECURITY_GUID:
          fInSrc = pac->bPropSetGuid;
          fInTarget = p->bPropSetGuid;
          printType = BINARY_TYPE;

          pAVal->pVal = (UCHAR *) MallocExit(sizeof(GUID));
          if ( !(pac->bPropSetGuid) ) {
            // No system-flag in source, target value needs to be deleted
             memcpy(pAVal->pVal, &(p->propSetGuid), sizeof(GUID) );
          }
          else { memcpy(pAVal->pVal, &(pac->propSetGuid), sizeof(GUID));}
          pAVal->valLen = sizeof(GUID);
          break;

       case ATT_SHOW_IN_ADVANCED_VIEW_ONLY:
           fInSrc = pac->bHideFromAB;
           fInTarget = p->bHideFromAB;
           printType = STRING_TYPE;
           pAVal->pVal = (UCHAR *) MallocExit(strlen("FALSE")+1); // TRUE or FALSE
           if ( !(pac->bHideFromAB) ) {
             if ( p->HideFromAB ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           else {
             if ( pac->HideFromAB ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           pAVal->valLen = strlen(pAVal->pVal);
           break;

       case ATT_SYSTEM_ONLY:
           fInSrc = pac->bSystemOnly;
           fInTarget = p->bSystemOnly;
           printType = STRING_TYPE;
           pAVal->pVal = (UCHAR *) MallocExit(strlen("FALSE")+1); // TRUE or FALSE
           if ( !(pac->bSystemOnly) ) {
             if ( p->SystemOnly ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           else {
             if ( pac->SystemOnly ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           pAVal->valLen = strlen(pAVal->pVal);
           break;

       case ATT_IS_SINGLE_VALUED:
           fInSrc = pac->bisSingleValued;
           fInTarget = p->bisSingleValued;
           printType = STRING_TYPE;
           pAVal->pVal = (UCHAR *) MallocExit(strlen("FALSE")+1); // TRUE or FALSE
           if ( !(pac->bisSingleValued) ) {
             if ( p->isSingleValued ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           else {
             if ( pac->isSingleValued ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           pAVal->valLen = strlen(pAVal->pVal);
           break;

       case ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET:
           fInSrc = pac->bMemberOfPartialSet;
           fInTarget = p->bMemberOfPartialSet;
           printType = STRING_TYPE;
           pAVal->pVal = (UCHAR *) MallocExit(strlen("FALSE")+1); // TRUE or FALSE
           if ( !(pac->bMemberOfPartialSet) ) {
             if ( p->MemberOfPartialSet ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           else {
             if ( pac->MemberOfPartialSet ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           pAVal->valLen = strlen(pAVal->pVal);
           break;
       default:
           printf("Error, don't understand attrTyp 0x%08x\n", attrTyp);
           exit(1);
     }  /* Switch */


     if ( !fInSrc ) {
         // not in source, delete from target
               AddToModStruct( pModList,
                               AT_CHOICE_REMOVE_VALUES,
                               attrTyp,
                               printType,
                               1,
                               pAVal);
      }
      else {
           if ( !fInTarget ) {
            // in source but not in target, add to target
               AddToModStruct( pModList,
                               AT_CHOICE_ADD_VALUES,
                               attrTyp,
                               printType,
                               1,
                               pAVal);
            }
            else {
               // in both source and target, so replace in target
               AddToModStruct( pModList,
                               AT_CHOICE_REPLACE_ATT,
                               attrTyp,
                               printType,
                               1,
                               pAVal);
            }
       }
}


////////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//      Helper routine that takes in adds to a given attribute modlist
//      structure based on the given attribute. Reduces some code
//      duplication.
//
//  Arguments:
//      pModList - pointer to ATTR_MODLIST to fill up
//      pSrcAtt - CLASS_CACHE from source schema
//      pTargetAtt - CLASS_CACHE from target schema
//      attrTyp - attribute type of interest
//
//  Return Value: None
///////////////////////////////////////////////////////////////////////

void CreateFlagBasedClsModStr( MY_ATTRMODLIST *pModList,
                               CLASS_CACHE *pSrcCls,
                               CLASS_CACHE *pTargetCls,
                               ATTRTYP attrTyp)
{
    ATTRVAL      *pAVal;
    BOOL          fInSrc = FALSE, fInTarget = FALSE;
    int           printType = 0;
    CLASS_CACHE  *pcc = pSrcCls;
    CLASS_CACHE  *p = pTargetCls;

    pAVal = (ATTRVAL *) MallocExit (sizeof(ATTRVAL));

    switch (attrTyp) {

       case ATT_DEFAULT_SECURITY_DESCRIPTOR:
           fInSrc = (pcc->SDLen ? 1 : 0);
           fInTarget = (p->SDLen ? 1 : 0);
           printType = STRING_TYPE;

           if ( pcc->SDLen ) {
               pAVal->valLen = pcc->SDLen+1;
               pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen);
               memcpy( pAVal->pVal, pcc->pSD, pAVal->valLen );
           }
           else {
              pAVal->valLen = p->SDLen+1;
              pAVal->pVal = (UCHAR *) MallocExit(pAVal->valLen);
              memcpy( pAVal->pVal, p->pSD, pAVal->valLen );
           }
           break;

       case ATT_SHOW_IN_ADVANCED_VIEW_ONLY:
           fInSrc = pcc->bHideFromAB;
           fInTarget = p->bHideFromAB;
           printType = STRING_TYPE;

           pAVal->pVal = (UCHAR *) MallocExit(strlen("FALSE")+1); // TRUE or FALSE
           if ( !(pcc->bHideFromAB) ) {
             if ( p->HideFromAB ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           else {
             if ( pcc->HideFromAB ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           pAVal->valLen = strlen(pAVal->pVal);
           break;

       case ATT_DEFAULT_HIDING_VALUE:
           fInSrc = pcc->bDefHidingVal;
           fInTarget = p->bDefHidingVal;
           printType = STRING_TYPE;

           pAVal->pVal = (UCHAR *) MallocExit(strlen("FALSE")+1); // TRUE or FALSE
           if ( !(pcc->bDefHidingVal) ) {
             if ( p->DefHidingVal ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           else {
             if ( pcc->DefHidingVal ) strcpy (pAVal->pVal, "TRUE");
             else strcpy (pAVal->pVal, "FALSE");
           }
           pAVal->valLen = strlen(pAVal->pVal);
           break;
       default:
           printf("Error, don't understand attrTyp 0x%08x\n", attrTyp);
           exit(1);
     }

     if ( !fInSrc ) {
          // not in source, so delete from target
               AddToModStruct( pModList,
                               AT_CHOICE_REMOVE_VALUES,
                               attrTyp,
                               printType,
                               1,
                               pAVal);
      }
      else {
            if ( !fInTarget ) {
              // in source but not in target, so add to target
               AddToModStruct( pModList,
                               AT_CHOICE_ADD_VALUES,
                               attrTyp,
                               printType,
                               1,
                               pAVal);
            }
            else {
               // in both source and target, so replace in target
               AddToModStruct( pModList,
                               AT_CHOICE_REPLACE_ATT,
                               attrTyp,
                               printType,
                               1,
                               pAVal);
            }
      }

}

/////////////////////////////////////////////////////////////////
// Helper routine to fill up an ATTR_MODLIST structure given all
// the values
/////////////////////////////////////////////////////////////////

void AddToModStruct( MY_ATTRMODLIST *pModList, 
                     USHORT choice, 
                     ATTRTYP attrType, 
                     int type, 
                     ULONG valCount, 
                     ATTRVAL *pAVal)
{
    pModList->choice = choice;
    pModList->type = type;
    pModList->AttrInf.attrTyp = attrType;
    pModList->AttrInf.AttrVal.valCount = valCount;
    pModList->AttrInf.AttrVal.pAVal = pAVal;
}

//////////////////////////////////////////////////////////////////
// Finds if a given ULONG is in agiven list of ULONGs
/////////////////////////////////////////////////////////////////

BOOL IsMemberOf( ULONG id, ULONG *pList, ULONG cList )
{
    ULONG i;

    for ( i = 0; i < cList; i++ ) {
       if ( id == pList[i] ) {
          return TRUE;
       }
    }
    return FALSE;
}

int __cdecl auxsort( const void * pv1, const void * pv2 )
/*
 * Cheap function needed by qsort
 */
{
    return (*(int *)pv1 - *(int *)pv2);
}

/////////////////////////////////////////////////////////////////
//
//  Routine Description:
//     Takes in two list of ULONGs, and returns two lists with
//     (1) things in list 1 but not in list 2, and (2) things in list 2
//     but not in list 1. Null lists are returns if the two lists
//     are identical
//
//  Arguments:
//     pList1 - pointer to List 1
//     cList1 - no.of elements in List 1
//     pList2 - pointer to List 2
//     cList2 - no. of elements in List 2
//     pL1 - return list for elements in List 1 but not in List 2
//     pL2 - return list for elements in List 2 but not in List 1
//
//  Return Value:
//     0 if List 1 and List 2 are identical, 1 otherwise
//////////////////////////////////////////////////////////////////

int CompareUlongList( ULONG *pList1, ULONG cList1, 
                      ULONG *pList2, ULONG cList2,
                      ULONGLIST **pL1, ULONGLIST **pL2 )
{
    ULONG       i, j;
    ULONGLIST  *temp1, *temp2;

    *pL1 = *pL2 = NULL;

    if ( (cList1 == 0) && (cList2 == 0) ) {
        // both lists empty
        return 0;
    }

    // at least one list is non empty
    if ( cList1 == 0 ) {
       // First list empty, just return the List 2 in *pL2
       temp1 = (ULONGLIST *) MallocExit(sizeof(ULONGLIST));
       temp1->count = cList2;
       temp1->List = (ULONG *) MallocExit(cList2*sizeof(ULONG));
       memcpy( temp1->List, pList2, cList2*sizeof(ULONG) );
       *pL2 = temp1;
       return 1;
    }
    if ( cList2 == 0 ) {
       // Second list empty, just return List 1 in *pL1
       temp1 = (ULONGLIST *) MallocExit(sizeof(ULONGLIST));
       temp1->count = cList1;
       temp1->List = (ULONG *) MallocExit(cList1*sizeof(ULONG));
       memcpy( temp1->List, pList1, cList1*sizeof(ULONG) );
       *pL1 = temp1;
       return 1;
    }

    // else, both lists non-empty

    qsort( pList1, cList1, sizeof(ULONG), auxsort );
    qsort( pList2, cList2, sizeof(ULONG), auxsort );

    // In most cases, the lists will be same. So take a chance
    // and do a memcmp and return if equal
    if ( cList1 == cList2 ) {
       // equal size, may be same
       if ( memcmp(pList1, pList2, cList1*sizeof(ULONG)) == 0 ) {
            return 0;
       }
    }

    // They are not the same. So find differences. We do a 
    // a simple O(n^2) linear search since the lists are 
    // usually small 

    (*pL1) = temp1 = (ULONGLIST *) MallocExit(sizeof(ULONGLIST));
    (*pL2) = temp2 = (ULONGLIST *) MallocExit(sizeof(ULONGLIST));
    temp1->count = 0;
    temp2->count = 0;

    // Allocate maximum space that may be needed

    temp1->List = (ULONG *) MallocExit(cList1*sizeof(ULONG));
    temp2->List = (ULONG *) MallocExit(cList2*sizeof(ULONG));
    for ( i = 0; i < cList1; i++ ) {
        if ( !IsMemberOf( pList1[i], pList2, cList2 ) ) {
           temp1->List[temp1->count++] = pList1[i];
         }
    }

    for ( j = 0; j < cList2; j++ ) {
        if ( !IsMemberOf(pList2[j], pList1, cList1 ) ) {
           temp2->List[temp2->count++] = pList2[j];
         }
    }

    if ( temp1->count == 0 ) {
       // nothing to send back  in *pL1
       free( temp1->List );
       free( temp1 );
       *pL1 = NULL;
    }
    if ( temp2->count == 0 ) {
       // nothing to send back in *pL2
       free( temp2->List );
       free( temp2 );
       *pL2 = NULL;
    }

    return 1;
}

//////////////////////////////////////////////////////////////////
// 
//  Routine Description:
//      Helper routine to fill up  ATTR_MODLISTis appropriately
//      given two lists. The routine adds ATTR_MODLISTs for 
//      adds for things in pL1, and ATTR_MODLISTs for deletes
//      for things in pL2. The input lists pL1 and pL2 are
//      freed after being used.
//
//  Arguments:
//      pModStruct - Pointer to ModifyStruct
//      pCount - Pointer to start index inside MODIFYSTRUCT to put 
//               ATTR_MODLISTs in. This is incremented on every
//               ATTR_MODLIST add, and contains the final value on return
//      pL1 - Pointer to list of ULONGs to add ATTR_MODLISTs with
//            "add values" choice 
//      pL2 - Pointer to list of ULONGs to add ATTR_MODLISTs with
//            "remove values" choice 
//      attrTyp  - attribute type whose values are added/removed
//
//  Return Values - None
/////////////////////////////////////////////////////////////////////

void AddToModStructFromLists( MODIFYSTRUCT *pModStr, 
                              ULONG *pCount, 
                              ULONGLIST *pL1, 
                              ULONGLIST *pL2, 
                              ATTRTYP attrTyp)
{
    ATTRVAL *pAVal;
    ULONG    i;


    if ( pL1 != NULL ) {
        // things in list 1 but not in list 2. These are value adds
        pAVal = (ATTRVAL *) MallocExit((pL1->count)*sizeof(ATTRVAL));
        for ( i = 0; i < pL1->count; i++ ) {
           pAVal[i].pVal = IdToOid( pL1->List[i] );
           pAVal[i].valLen = strlen( pAVal[i].pVal );
        }
        AddToModStruct( &(pModStr->ModList[*pCount]), 
                        AT_CHOICE_ADD_VALUES, 
                        attrTyp, 
                        STRING_TYPE, 
                        pL1->count, 
                        pAVal);
        free( pL1->List );
        free( pL1 );
        (*pCount)++;
     }
     if ( pL2 != NULL ) {

         // things in list 2 but not in list 1. These are value deletes
         pAVal = (ATTRVAL *) MallocExit((pL2->count)*sizeof(ATTRVAL));
         for ( i = 0; i < pL2->count; i++ ) {
              pAVal[i].pVal = IdToOid( pL2->List[i] );
              pAVal[i].valLen = strlen( pAVal[i].pVal );
         }
         AddToModStruct( &(pModStr->ModList[*pCount]), 
                         AT_CHOICE_REMOVE_VALUES, 
                         attrTyp, 
                         STRING_TYPE, 
                         pL2->count, 
                         pAVal);
         (*pCount)++;
         free( pL2->List );
         free( pL2 );
     }
}


//////////////////////////////////////////////////////////////////////
// Routine Description:
//   Compares two equal sized arrays of ULONGs to see if they are the same
//   (Difference from CompareUlongLists is that no diff lists are returned)
//
// Arguments: List1, List2 - pointers to the two lists
//            Length       - length of the lists
//
// Return value: 0 if equal, non-0 if not
///////////////////////////////////////////////////////////////////////

int CompareList( ULONG *List1, ULONG *List2, ULONG Length )
{
    ULONG i;

    // This could have been checked before calling this function
    // Just checked it here to avoid checking it in every place
    // we call and avoid bugs if we forget.  

    if ( Length == 0 ) return ( 0 );

    qsort( List1, Length, sizeof(ULONG), auxsort );
    qsort( List2, Length, sizeof(ULONG), auxsort );
    for ( i = 0; i < Length; i++ )
      {
        if ( List1[i] != List2[i] ) return( 1 );
      };
    return( 0 );
}


/////////////////////////////////////////////////////////////////////
// Routine to convert bool value to appropriate string
/////////////////////////////////////////////////////////////////////

char *BoolToStr( unsigned x )
{
   if ( x ) {
     return ("TRUE");
   }
   else { 
     return ("FALSE");
   }
}

/////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//     Takes in an array of att_caches and writes out to ldif file to
//     add them to the target schema
//
//  Arguments:
//      fp - File pointer to (opened) ldif file
//      ppac - pointer to att_cache array
//      cnt - no. of elements in the array
//
//  Return Values: None
//////////////////////////////////////////////////////////////////////

void FileWrite_AttAdd( FILE *fp, ATT_CACHE **ppac, ULONG cnt )
{
   char        *newDN = NULL;
   ULONG       i;
   ATT_CACHE  *pac;
   NTSTATUS    status;
   UCHAR       EncodingString[512];
   DWORD       cCh;

   printf("No. of attributes to add %d\n", cnt);
   fprintf(OIDfp,"\n\n------------------- New Attribute OIDs----------------------\n\n");
   for ( i = 0; i < cnt; i++ ) {
      pac = ppac[i];

      // write ldapDisplayName and OID out to OID file
      fprintf(OIDfp, "%25s : %s\n", pac->name, IdToOid(pac->id));
      fflush(OIDfp);
      
      // Change DN to target schema 
      ChangeDN( pac->DN, &newDN, pTargetSchemaDN );

      // Now write out all attributes of interest, converting binary
      // ones to base64 strings

      fprintf( fp, "dn: %s\n", newDN );
      free(newDN); newDN = NULL;

      fprintf( fp, "changetype: ntdsSchemaAdd\n" );
      fprintf( fp, "objectClass: attributeSchema\n" );
      fprintf( fp, "ldapDisplayName: %s\n", pac->name );
      fprintf( fp, "adminDisplayName: %s\n", pac->adminDisplayName );
      if ( pac->adminDescr) {
        fprintf( fp, "adminDescription: %s\n", pac->adminDescr );
      }
      fprintf( fp, "attributeId: %s\n", IdToOid( pac->id ) );
      fprintf( fp, "attributeSyntax: %s\n", IdToOid( pac->syntax ) );
      fprintf( fp, "omSyntax: %d\n", pac->OMsyntax );
      fprintf( fp, "isSingleValued: %s\n", BoolToStr( pac->isSingleValued ) );
      if (pac->bSystemOnly) {
         fprintf( fp, "systemOnly: %s\n", BoolToStr( pac->SystemOnly ) );
      }
      if (pac->bExtendedChars) {
      fprintf( fp, "extendedCharsAllowed: %s\n", BoolToStr( pac->ExtendedChars) );
      }
      if (pac->bSearchFlags) {
        fprintf( fp, "searchFlags: %d\n", pac->SearchFlags );
      }
      if ( pac->rangeLowerPresent ) {
        fprintf( fp, "rangeLower: %d\n", pac->rangeLower );
      }
      if ( pac->rangeUpperPresent ) {
        fprintf( fp, "rangeUpper: %d\n", pac->rangeUpper );
      }

      if (pac->OMObjClass.length) {
          status = base64encode( pac->OMObjClass.elements,
                                 pac->OMObjClass.length,
                                 EncodingString,
                                 512, &cCh );
          if (status == STATUS_SUCCESS ) {
            fprintf( fp, "omObjectClass:: %s\n", EncodingString );
          }
          else {
            // log a warning
            fprintf(logfp, "WARNING: unable to convert omObjectClass for attribute %s\n", pac->name);
          }
      }
      else {
         // if OM_S_OBJECT syntax, log a warning
         if (pac->OMsyntax == 127) {
            fprintf(logfp, "Attribute %s has om-syntax=127 but no om-object-class\n", pac->name);
         }
      }

      status = base64encode( &pac->propGuid, 
                             sizeof(GUID), 
                             EncodingString, 
                             512, &cCh );
      if (status == STATUS_SUCCESS ) {
        fprintf( fp, "schemaIdGuid:: %s\n", EncodingString );
      }
      else {
        // log a warning
        fprintf(logfp, "WARNING: unable to convert schemaIdGuid for attribute %s\n", pac->name);
      }

      if (pac->bPropSetGuid) {
          status = base64encode( &pac->propSetGuid, 
                                 sizeof(GUID), 
                                 EncodingString, 
                                 512, &cCh );
          if (status == STATUS_SUCCESS ) {
            fprintf( fp, "attributeSecurityGuid:: %s\n", EncodingString );
          }
          else {
            // log a warning
            fprintf(logfp, "WARNING: unable to convert attribute-security-guid for attribute %s\n", pac->name);
          }
      }
      if (pac->NTSDLen) {
         status = base64encode( pac->pNTSD, 
                                pac->NTSDLen,
                                EncodingString, 
                                512, &cCh );
         if (status == STATUS_SUCCESS ) {
           fprintf( fp, "nTSecurityDescriptor:: %s\n", EncodingString );
         }
 else { printf("Error converting NTSD in Att\n");}
      }
      if ( pac->ulLinkID ) {
        fprintf( fp,"linkID: %d\n", pac->ulLinkID );
      }
      if ( pac->ulMapiID ) {
        fprintf( fp,"mapiID: %d\n", pac->ulMapiID );
      } 
      if (pac->bHideFromAB) {
        fprintf( fp, "showInAdvancedViewOnly: %s\n", BoolToStr( pac->HideFromAB ) );
      }
      if (pac->bMemberOfPartialSet) {
        fprintf( fp, "isMemberOfPartialAttributeSet: %s\n", BoolToStr( pac->MemberOfPartialSet ) );
      }
      if ( pac->sysFlags ) {
        // The attribute has a system-flag. System-Flags is a
        // reserved attribute and cannot n general be added by an user call.
        // we will allow adding if a registry key is set to take care of
        // upcoming schema changes. 
        fprintf( fp, "systemFlags: %d\n", pac->sysFlags );
      } 
      fprintf( fp, "\n" );
      fflush(fp);
   }
}

/////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//     Takes in an array of class_caches and writes out to ldif file to
//     add them to the target schema
//
//  Arguments:
//      fp - File pointer to (opened) ldif file
//      ppcc - pointer to class_cache array
//      cnt - no. of elements in the array
//
//  Return Values: None
//////////////////////////////////////////////////////////////////////

void FileWrite_ClsAdd( FILE *fp, CLASS_CACHE **ppcc, ULONG cnt )
{
   // Need to change the DN
   char          *newDN = NULL;
   CLASS_CACHE  *pcc;
   ULONG         i, j, guidSize = sizeof(GUID);
   UCHAR        *pGuid;
   NTSTATUS      status;
   UCHAR         EncodingString[512];
   DWORD         cCh;

   printf("No. of classes to add %d\n", cnt);

   fprintf(OIDfp,"\n\n--------------------- New  Class OIDs---------------------\n\n");

   for ( i = 0; i < cnt; i++ ) {
     pcc = ppcc[i];

      // write ldapDisplayName and OID out to OID file
      fprintf(OIDfp, "%25s : %s\n", pcc->name, IdToOid(pcc->ClassId));
      fflush(OIDfp);

     // change DN to that of target schema
     ChangeDN( pcc->DN, &newDN, pTargetSchemaDN );

     // Now write out all attributes of interest, converting binary
     // values to base64 string

     fprintf( fp, "dn: %s\n", newDN );
     free(newDN); newDN = NULL;

     fprintf( fp, "changetype: ntdsSchemaAdd\n" );
     fprintf( fp, "objectClass: classSchema\n" );
     fprintf( fp, "ldapDisplayName: %s\n", pcc->name );
     fprintf( fp, "adminDisplayName: %s\n", pcc->adminDisplayName );
     if ( pcc->adminDescr ) {
       fprintf( fp, "adminDescription: %s\n", pcc->adminDescr );
     }
     fprintf( fp, "governsId: %s\n", IdToOid(pcc->ClassId) );
     fprintf( fp, "objectClassCategory: %d\n", pcc->ClassCategory );
     if ( pcc->RDNAttIdPresent ) {
       fprintf( fp, "rdnAttId: %s\n", IdToOid(pcc->RDNAttId) );
     }
     fprintf( fp, "subClassOf: %s\n", IdToOid(*(pcc->pSubClassOf)) );
     if ( pcc->AuxClassCount ) {
        for ( j = 0; j < pcc->AuxClassCount; j++ ) {
          fprintf( fp, "auxiliaryClass: %s\n",IdToOid((pcc->pAuxClass)[j]) ); 
        }
     }
     if ( pcc->SysAuxClassCount ) {
        for ( j = 0; j < pcc->SysAuxClassCount; j++ ) {
          fprintf( fp, "systemAuxiliaryClass: %s\n",IdToOid((pcc->pSysAuxClass)[j]) ); 
        }
     }
     if ( pcc->MustCount ) {
        for ( j = 0; j < pcc->MustCount; j++ ) {
          fprintf( fp, "mustContain: %s\n",IdToOid((pcc->pMustAtts)[j]) ); 
        }
     }
     if ( pcc->SysMustCount ) {
        for ( j = 0; j < pcc->SysMustCount; j++ ) {
          fprintf( fp, "systemMustContain: %s\n",IdToOid((pcc->pSysMustAtts)[j]) ); 
        }
     }
     if ( pcc->MayCount ) {
        for ( j = 0; j < pcc->MayCount; j++ ) {
          fprintf( fp, "mayContain: %s\n",IdToOid((pcc->pMayAtts)[j]) ); 
        }
     }
     if ( pcc->SysMayCount ) {
        for ( j = 0; j < pcc->SysMayCount; j++ ) {
          fprintf( fp, "systemMayContain: %s\n",IdToOid((pcc->pSysMayAtts)[j]) ); 
        }
     }
     if ( pcc->PossSupCount ) {
        for ( j = 0; j < pcc->PossSupCount; j++ ) {
          fprintf( fp, "possSuperiors: %s\n",IdToOid((pcc->pPossSup)[j]) ); 
        }
     }
     if ( pcc->SysPossSupCount ) {
        for ( j = 0; j < pcc->SysPossSupCount; j++ ) {
          fprintf( fp, "systemPossSuperiors: %s\n",IdToOid((pcc->pSysPossSup)[j]) ); 
        }
     }

     status = base64encode( &pcc->propGuid, 
                            sizeof(GUID), 
                            EncodingString, 
                            512, &cCh );
     if ( status == STATUS_SUCCESS ) {
        fprintf( fp, "schemaIdGuid:: %s\n", EncodingString );
     }
     else {
        // log a warning
        fprintf(logfp, "WARNING: unable to convert schemaIdGuid for class %s\n", pcc->name);
     }

/********
     if (pcc->NTSDLen) {
        status = base64encode(  pcc->pNTSD, 
                                pcc->NTSDLen,
                                EncodingString, 
                                512, &cCh );
        if (status == STATUS_SUCCESS ) {
           fprintf( fp, "nTSecurityDescriptor:: %s\n", EncodingString );
        }
 else { printf("Error converting NTSD in Cls\n");}
     }
*******/

     if (pcc->SDLen) {
           fprintf( fp, "defaultSecurityDescriptor: %s\n", pcc->pSD );
     }

     if (pcc->bHideFromAB) {
           fprintf( fp, "showInAdvancedViewOnly: %s\n", BoolToStr(pcc->HideFromAB));
     }
     if (pcc->bDefHidingVal) {
           fprintf( fp, "defaultHidingValue: %s\n", BoolToStr(pcc->DefHidingVal));
     }
     if (pcc->bSystemOnly) {
           fprintf( fp, "systemOnly: %s\n", BoolToStr(pcc->SystemOnly));
     }
     if (pcc->pDefaultObjCat) {
           ChangeDN( pcc->pDefaultObjCat, &newDN, pTargetSchemaDN );
           fprintf( fp, "defaultObjectCategory: %s\n", newDN);
           free(newDN); newDN = NULL;
     }
     if ( pcc->sysFlags ) {
        // The attribute has a system-flag. System-Flags is a
        // reserved attribute and cannot n general be added by an user call.
        // we will allow adding if a registry key is set to take care of
        // upcoming schema changes. 
        fprintf( fp, "systemFlags: %d\n", pcc->sysFlags );
     }

     fprintf( fp, "\n" );
     fflush(fp);
   } /* for */
}


/////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//     Takes in an array of att_caches and writes out to ldif file to
//     delete them from the target schema
//
//  Arguments:
//      fp - File pointer to (opened) ldif file
//      ppac - pointer to att_cache array
//      cnt - no. of elements in the array
//
//  Return Values: None
//////////////////////////////////////////////////////////////////////

void FileWrite_AttDel( FILE *fp, ATT_CACHE **ppac, ULONG cnt )
{
   ULONG i;

   printf("No. of attributes to delete %d\n", cnt);

   fprintf(OIDfp,"\n\n --------------Deleted Attribute OIDs---------------\n\n");
   for ( i = 0; i < cnt; i++ ) {
     
      // write ldapDisplayName and OID out to OID file
      fprintf(OIDfp, "%25s : %s\n", ppac[i]->name, IdToOid(ppac[i]->id));
      fflush(OIDfp);

     fprintf( fp, "dn: %s\n", (ppac[i])->DN );
     fprintf( fp, "changetype: ntdsSchemaDelete\n\n" );
     fflush(fp);
   }
}

/////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//     Takes in an array of class_caches and writes out to ldif file to
//     delete them from the target schema
//
//  Arguments:
//      fp - File pointer to (opened) ldif file
//      ppcc - pointer to class_cache array
//      cnt - no. of elements in the array
//
//  Return Values: None
//////////////////////////////////////////////////////////////////////

void FileWrite_ClsDel( FILE *fp, CLASS_CACHE **ppcc, ULONG cnt )
{
   ULONG i;

   printf("No. of classes to delete %d\n", cnt);

   fprintf(OIDfp,"\n\n----------------------- Deleted Class OIDs-------------------------\n\n");
   for ( i = 0; i < cnt; i++ ) {

      // write ldapDisplayName and OID out to OID file
      fprintf(OIDfp, "%25s : %s\n", ppcc[i]->name, IdToOid(ppcc[i]->ClassId));
      fflush(OIDfp);

     fprintf( fp, "dn: %s\n", (ppcc[i])->DN );
     fprintf( fp, "changetype: ntdsSchemaDelete\n\n" );
     fflush(fp);
   }
}


// Define attrtype to ldapDisplayName string mappings for
// modify printings

typedef struct _attrtoStr {
   ULONG attrTyp;
   char  *strName;
} ATTRTOSTR;

ATTRTOSTR AttrToStrMappings[] = {
     { ATT_LDAP_DISPLAY_NAME ,           "ldapDisplayName" },
     { ATT_ADMIN_DISPLAY_NAME,           "adminDisplayName" },
     { ATT_OBJ_DIST_NAME,                "distinguishedName" }, 
     { ATT_ADMIN_DESCRIPTION,            "adminDescription" },
     { ATT_ATTRIBUTE_ID,                 "attributeId" },
     { ATT_ATTRIBUTE_SYNTAX,             "attributeSyntax" },
     { ATT_IS_SINGLE_VALUED,             "isSingleValued" },
     { ATT_RANGE_LOWER,                  "rangeLower" },
     { ATT_RANGE_UPPER,                  "rangeUpper" },
     { ATT_MAPI_ID,                      "mapiId" },
     { ATT_LINK_ID,                      "linkId" },
     { ATT_SCHEMA_ID_GUID,               "schemaIdGuid" },
     { ATT_ATTRIBUTE_SECURITY_GUID,      "attributeSecurityGuid" },
     { ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET, "isMemberOfPartialAttributeSet" },
     { ATT_SYSTEM_FLAGS,                 "systemFlags" },
     { ATT_SHOW_IN_ADVANCED_VIEW_ONLY,   "showInAdvancedViewOnly" },
     { ATT_DEFAULT_SECURITY_DESCRIPTOR,  "defaultSecurityDescriptor" },
     { ATT_DEFAULT_OBJECT_CATEGORY,      "defaultObjectCategory" },
     { ATT_DEFAULT_HIDING_VALUE,         "defaultHidingValue" },
     { ATT_NT_SECURITY_DESCRIPTOR,       "nTSecurityDescriptor" },
     { ATT_OM_OBJECT_CLASS,              "oMObjectClass" },
     { ATT_OM_SYNTAX,                    "oMSyntax" },
     { ATT_SEARCH_FLAGS,                 "searchFlags" },
     { ATT_SYSTEM_ONLY,                  "systemOnly" },
     { ATT_EXTENDED_CHARS_ALLOWED,       "extendedCharsAllowed" },
     { ATT_GOVERNS_ID,                   "governsId" },
     { ATT_RDN_ATT_ID,                   "rdnAttId" },
     { ATT_OBJECT_CLASS_CATEGORY,        "objectClassCategory" },
     { ATT_SUB_CLASS_OF,                 "subClassOf" },
     { ATT_SYSTEM_AUXILIARY_CLASS,       "systemAuxiliaryClass" },
     { ATT_AUXILIARY_CLASS,              "auxiliaryClass" },
     { ATT_SYSTEM_POSS_SUPERIORS,        "systemPossSuperiors" },
     { ATT_POSS_SUPERIORS,               "possSuperiors" },
     { ATT_SYSTEM_MUST_CONTAIN,          "systemMustContain" },
     { ATT_MUST_CONTAIN,                 "mustContain" },
     { ATT_SYSTEM_MAY_CONTAIN,           "systemMayContain" },
     { ATT_MAY_CONTAIN,                  "mayContain" },
};
int cAttrToStrMappings = sizeof(AttrToStrMappings) / sizeof(AttrToStrMappings[0]);

char *AttrToStr( ULONG attrTyp )
{
    int i;

    for ( i = 0; i < cAttrToStrMappings; i++ )
        {
          if ( attrTyp == AttrToStrMappings[i].attrTyp )
             return( AttrToStrMappings[i].strName );
        };
    return( NULL );
};


/////////////////////////////////////////////////////////////////////
//
//  Routine Description:
//     Takes in the DN of an object (attribute or class) and a 
//     modifystruct and writes out to ldif file to make the modification
//     to the object in the target schema
//
//  Arguments:
//      fp - File pointer to (opened) ldif file
//      pDN - Pointer to DN of the object to be modified in target schema
//      pMod - Pointer to modifystruct
//
//  Return Values: None
//////////////////////////////////////////////////////////////////////

void FileWrite_Mod( FILE *fp, char  *pDN, MODIFYSTRUCT *pMod )
{
    ULONG     i, j;
    char     *pAttrStr;
    ATTRVAL  *pAVal;
    NTSTATUS  status;
    UCHAR     EncodingString[512];
    DWORD     cCh;
 
    fprintf( fp, "dn: %s\n", pDN );
    fprintf( fp, "changetype: ntdsSchemaModify\n" );
    
    // print out all the ATTR_MODLISTs in the MODIFYSTRUCT

    for ( i = 0; i < pMod->count; i++ ) {
        pAVal = pMod->ModList[i].AttrInf.AttrVal.pAVal;
        pAttrStr = AttrToStr( pMod->ModList[i].AttrInf.attrTyp );
        if ( pAttrStr == NULL ) {
          printf("Unknown attribute %x\n", pMod->ModList[i].AttrInf.attrTyp);
          return;
        }
        switch ( pMod->ModList[i].choice ) {
           case AT_CHOICE_ADD_VALUES:
              fprintf( fp,"add: %s\n", pAttrStr );
              break;
           case AT_CHOICE_REMOVE_VALUES:
              fprintf( fp,"delete: %s\n", pAttrStr );
              break;
           case AT_CHOICE_REPLACE_ATT:
              fprintf( fp,"replace: %s\n", pAttrStr );
              break;
           default:
              printf("Undefined choice for attribute %s\n", pAttrStr);
         } /* switch */
    
        // Now print out the values
        switch ( pMod->ModList[i].type ) {
           case STRING_TYPE:
             for ( j = 0; j < pMod->ModList[i].AttrInf.AttrVal.valCount; j++ ) {
               fprintf( fp, "%s: %s\n", pAttrStr, pAVal[j].pVal );
             }
             break;
           case BINARY_TYPE:
             for ( j = 0; j < pMod->ModList[i].AttrInf.AttrVal.valCount; j++ ) {
                status = base64encode( pAVal[j].pVal,
                                       pAVal[j].valLen,
                                       EncodingString,
                                       512, &cCh );
                if (status == STATUS_SUCCESS ) {
                  fprintf( fp, "%s:: %s\n", pAttrStr, EncodingString );
                }
                else {
                  printf("Error converting binary value for attribute %s\n", pAttrStr);
                }
              }
             break;
           default:
             printf("ERROR: unknown type for attribute %s\n", pAttrStr);
        } /* switch */
        fprintf( fp, "-\n" );
    }
    fprintf( fp, "\n" );
}     
           
void GenWarning( char c, ULONG attrTyp, char *name)
{
   switch( c ) {
      case 'a':
         fprintf( logfp, "MOD-WARNING: system-only mod (%s) for attribute %s\n", AttrToStr(attrTyp), name );
         break;
      case 'c':            
         fprintf( logfp, "MOD-WARNING: system-only mod (%s) for class %s\n", AttrToStr(attrTyp), name );
    }
}














     

////////////////////////////////////////////////////////////////////////
// Debug routines for printing, and changing schema cache randomly 
// for testing
// These will be taken off before checkin
/////////////////////////////////////////////////////////////////////

int Schemaprint1(SCHEMAPTR *SCPtr)
{
   ULONG i;
   ATT_CACHE *p;
   int count=0;

   HASHCACHE*         ahcId    = SCPtr->ahcId ;
   HASHCACHESTRING*   ahcName  = SCPtr->ahcName ;
   ULONG              ATTCOUNT = SCPtr->ATTCOUNT;
   ULONG              CLSCOUNT = SCPtr->CLSCOUNT;

   for(i=0; i < ATTCOUNT; i++)
    { if ((ahcId[i].pVal !=NULL) && (ahcId[i].pVal != FREE_ENTRY)) {
      p = (ATT_CACHE *) ahcId[i].pVal;
      printf("********************************************************\n");
      printf("Name = %s, AdDisName=%s, AdDesc=%s, DN=%s, Id = %x\n", p->name, p
->adminDisplayName, p->adminDescr, p->DN, p->id);
      printf("syntax = %d\n", p->syntax);
      printf("Is SingleValued = %d\n", p->isSingleValued);
      printf("Range Lower = %d, indicator = %d\n", p->rangeLower, p->rangeLowerPresent);
      printf("Range Upper = %d, Indicator = %d\n", p->rangeUpper, p->rangeUpperPresent);
      printf("MapiID = %d\n", p->ulMapiID);
      printf("LinkID = %d\n", p->ulLinkID);
      printf("Schema-ID-GUID = %d,%d,%d\n", p->propGuid.Data1, p->propGuid.Data2, p->propGuid.Data3);
      printf("OM Object Class = %s\n", (char *) p->OMObjClass.elements);
      printf("OM Syntax = %d\n", p->OMsyntax);
      printf("Search Flags = %d\n", p->SearchFlags);
      printf("System Only = %d\n",p->bSystemOnly);
      printf("Is Single Valued = %d\n",p->bisSingleValued);
      printf("Extended Chars = %d\n", p->bExtendedChars);
      count++;
    };
   };
  return(count);
};


int Schemaprint2(SCHEMAPTR *SCPtr)
{
   ULONG i, j;
   int count = 0;
   CLASS_CACHE *p;
   HASHCACHE*         ahcClass     = SCPtr->ahcClass ;
   HASHCACHESTRING*   ahcClassName = SCPtr->ahcClassName ;
   ULONG              ATTCOUNT     = SCPtr->ATTCOUNT;
   ULONG              CLSCOUNT     = SCPtr->CLSCOUNT;

   printf("in print2\n");
   for(i=0; i < CLSCOUNT; i++)
    { if ((ahcClass[i].pVal !=NULL) && (ahcClass[i].pVal != FREE_ENTRY))  {
      p = (CLASS_CACHE *) ahcClass[i].pVal;
      printf("********************************************************\n");
      printf("Name = %s, AdDisName=%s, AdDesc=%s, DN=%s, Id = %x\n", p->name, p->adminDisplayName, p->adminDescr, p->DN, p->ClassId);

/**********
      printf("Class Category = %d, System Only = %d\n", p->ClassCategory, p->bSystemOnly);
      if (p->RDNAttIdPresent)
         printf("RDN Att Id is %x\n", p->RDNAttId);
      printf("Sub Class count = %u\n", p->SubClassCount);
      if(p->SubClassCount > 0)
        { printf("Sub Class Of: ");
          for(j=0;j<p->SubClassCount;j++)
             printf("%x, ", p->pSubClassOf[j]);
           printf("\n");
         };
      printf("Aux Class count = %u\n", p->AuxClassCount);
      if(p->AuxClassCount > 0)
        { printf("System Auxiliary Class: ");
          for(j=0;j<p->AuxClassCount;j++)
             printf("%x, ", p->pAuxClass[j]);
           printf("\n");
         };
      printf("Superior count = %u, System Sup Count = %u\n", p->SysPossSupCount,p->PossSupCount);
      if(p->SysPossSupCount > 0)
        { printf("System Possible Superiors: ");
          for(j=0;j<p->SysPossSupCount;j++)
             printf("%x, ", p->pSysPossSup[j]);
           printf("\n");
         };
      if(p->PossSupCount > 0)
        { printf(" Possible Superiors: ");
          for(j=0;j<p->PossSupCount;j++)
             printf("%x, ", p->pPossSup[j]);
           printf("\n");
         };
      printf("Must count = %u, System Must Count = %u\n", p->SysMustCount, p->MustCount);
      if(p->SysMustCount > 0)
        { printf("Must Contain: ");
          for(j=0;j<p->SysMustCount;j++)
             printf("%x, ", p->pSysMustAtts[j]);
           printf("\n");
         };
      if(p->MustCount > 0)
        { printf("System Must Contain: ");
          for(j=0;j<p->MustCount;j++)
             printf("%x, ", p->pMustAtts[j]);
           printf("\n");
         };
      printf("May count = %u, System may Count = %u\n", p->SysMayCount, p->MayCount);
      if(p->SysMayCount > 0)
        { printf("May Contain: ");
          for(j=0;j<p->SysMayCount;j++)
             printf("%x, ", p->pSysMayAtts[j]);
           printf("\n");
         };
      if(p->MayCount > 0)
        { printf("System May Contain: ");
          for(j=0;j<p->MayCount;j++)
             printf("%x, ", p->pMayAtts[j]);
           printf("\n");
         };
      count++;
**************/
    };
   };
   return(count);
};


void ChangeSchema(SCHEMAPTR *SCPtr)
{
 
    HASHCACHE*         ahcId    = SCPtr->ahcId ;
    HASHCACHE*         ahcClass = SCPtr->ahcClass ;
    ULONG              ATTCOUNT = SCPtr->ATTCOUNT;
    ULONG              CLSCOUNT = SCPtr->CLSCOUNT;
    ATT_CACHE *pac;
    CLASS_CACHE *pcc;

    FILE *fp;
    int i, j, k;

    //pTHStls->CurrSchemaPtr = SCPtr;

    fp = fopen("Modfile","a");

    srand((unsigned) time(NULL));

    // First, delete a few schema objects from schema 1
    //
    // Do not delete object with id 0 (objectClass), as
    // if this is deleted, and then searched for in the cache,
    // SCGetAttById will still find it 

    for ( i = 0; i < 5; i++ ) {
        j = rand() % ATTCOUNT;
        while ( (ahcId[j].pVal == NULL) || (ahcId[j].pVal == FREE_ENTRY) ) 
          j = rand() % ATTCOUNT; 
        pac = ahcId[j].pVal;
        if ( pac->id == 0 )
          { fprintf(fp, "Not deleting Id 0 attribute object: %s\n", pac->name);
            continue;
          };
        fprintf(fp,"Deleted Attribute %s\n", pac->name);
        FreeAttPtrs(SCPtr,pac);
        FreeAttcache(pac);
     };
    fprintf(fp,"\n");

    for ( i = 0; i < 5; i++ ) {
        j = rand() % CLSCOUNT;
        while ( (ahcClass[j].pVal == NULL) || (ahcClass[j].pVal == FREE_ENTRY)) 
          j = rand() % CLSCOUNT; 
        pcc = ahcClass[j].pVal;
        if ( pcc->ClassId == 0 )
          { fprintf(fp, "Not deleting Id 0 class object: %s\n", pcc->name);
            continue;
          };
        fprintf(fp,"Deleted Class %s\n", pcc->name);
        FreeClassPtrs(SCPtr, pcc);
        FreeClasscache(pcc);
     };

    fprintf(fp,"\n");

    // Next, modify a few attribute and class schema objects
    
    for(i=0; i <5; i++) {
       j = rand() % ATTCOUNT;
       while ((ahcId[j].pVal==NULL) || (ahcId[j].pVal==FREE_ENTRY))
            j=rand() % ATTCOUNT;
       pac = ahcId[j].pVal;
       fprintf(fp,"Modified Attribute %s\n", pac->name);
       if(pac->rangeLowerPresent==0) pac->rangeLowerPresent=1;
       else pac->rangeLower = 1000;
       if(pac->isSingleValued) pac->isSingleValued = FALSE;
       else pac->isSingleValued = TRUE;
       pac->propGuid.Data2 = 1000;
      };

    fprintf(fp,"\n");

       
    for(i=0; i <5; i++) {
       j = rand() % CLSCOUNT;
       while ((ahcClass[j].pVal==NULL) || (ahcClass[j].pVal==FREE_ENTRY))
           j=rand() % CLSCOUNT;
       pcc = ahcClass[j].pVal;
       fprintf(fp,"Modified Class %s\n", pcc->name);
       if (pcc->RDNAttIdPresent) pcc->RDNAttId=100;
       if (pcc->SubClassCount==0) pcc->SubClassCount=1;
       else pcc->SubClassCount = 0;
       if (pcc->SysMayCount!=0) {
         k = rand() % pcc->SysMayCount;
         pcc->pSysMayAtts[k]=2000;
         fprintf(fp,"   Changed MyMay list element %d\n", k);
         }
       if (pcc->SysMustCount!=0)  {
         k = rand() % pcc->SysMustCount;
         pcc->pSysMustAtts[k]=1000;
         fprintf(fp,"   Changed MyMust list element %d\n", k);
         }
       if (pcc->SysPossSupCount!=0)  {
         k = rand() % pcc->SysPossSupCount;
         pcc->pSysPossSup[k]=1000;
         fprintf(fp,"   Changed MyPossSup list element %d\n", k);
         }
      };
    fprintf(fp,"*********************************************\n");
    fclose(fp);

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\schemard\schemard.h ===
#include <ntdspch.h>
#include <winldap.h>

#include <attids.h>
#include <objids.h>
#include <drs.h>
#include <mdcodes.h>
#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>

#define MAX_ATTCOUNT 4096
#define MAX_CLSCOUNT 1024

#define MAX_ATT_CHANGE 2000
#define MAX_CLS_CHANGE 200

// typedefs for structures to be stored in Oid to id mapping tables

typedef struct _PREFIX_MAP {
    ULONG                 Ndx;
    OID_t                 Prefix;
} PREFIX_MAP;

typedef PREFIX_MAP *PPREFIX_MAP;

// My own definitions for CLASSCACHE and ATTCACHE, since they are
// somewhat different from the ones used by DS

typedef struct _att_cache
{
    ATTRTYP    id;                    /* Attribute Id */
    UCHAR      *name;                 /* ldapDisplay name (null terminated) */
    ULONG      nameLen;               /* strlen(name) (doesn't include NULL) */
    UCHAR      *DN;                   /* DN */
    ULONG      DNLen;                 /* DN length */      
    UCHAR      *adminDisplayName;     /* Admin Display Name */
    ULONG      adminDisplayNameLen;   /* Admin Display Name length */      
    UCHAR      *adminDescr;           /* Admin Description */
    ULONG      adminDescrLen;         /* Admin Description length */      
    PSECURITY_DESCRIPTOR pNTSD;       /* NT SD on the attribute-schema obj */
    DWORD      NTSDLen;               /* Length of NT SD. */
    int        syntax;                /* Syntax */
    BOOL       isSingleValued;        /* Single Valued or Multi-valued? */
    BOOL       rangeLowerPresent;     /* Lower range present */
    ULONG      rangeLower;            /* Optional - Lower range */
    BOOL       rangeUpperPresent;     /* Upper range present */ 
    ULONG      rangeUpper;            /* Optional - Upper range */
    ULONG      ulMapiID;              /* MAPI PropID (not PropTag) */
    ULONG      ulLinkID;              /* unique link/backlink id */
    GUID       propGuid;              /* Guid of this att for security */
    GUID       propSetGuid;           /* Guid of the property set of this */
    OID_t      OMObjClass;            /* class of OM object referenced */
    int        OMsyntax;              /* OM syntax */
    ULONG      sysFlags;              /* System-Flags */
    DWORD      SearchFlags;           /* 1=indexed, 2=and use it for ANR*/
    BOOL       HideFromAB;            /* HideFromAB value */
    BOOL       MemberOfPartialSet;    /* Member-of-partial-set or not */
    BOOL       SystemOnly;            /* System-Only attr? */
    BOOL       ExtendedChars;         /* skip character set checking? */
    unsigned   bPropSetGuid:1;        /* Is attribute-security guid present? */
    unsigned   bSystemFlags:1;        /* Is system flags present? */
    unsigned   bSearchFlags:1;        /* Is search flag present? */
    unsigned   bHideFromAB:1;         /* Is Hide-from-AB present? */
    unsigned   bMemberOfPartialSet:1; /* Is mem-of-Par-att-set value present */
    unsigned   bSystemOnly:1;         /* Is system-only present? */
    unsigned   bExtendedChars:1;      /* Is Extended-Chars present?  */
    unsigned   bDefunct:1;            /* Attribute is already deleted? */
    unsigned   bisSingleValued:1;     /* is is-single-valued present? */
} ATT_CACHE;

typedef struct _class_cache
{
    UCHAR     *name;                 /* Class name (ldapDisplayName) 
                                         (null terminated)   UTF8 */
    ULONG     nameLen;               /* strlen(name) (doesn't include NULL) */
    UCHAR     *DN;                   /* DN */
    ULONG     DNLen;                 /* DN length */      
    UCHAR     *adminDisplayName;     /* Admin Display Name */
    ULONG     adminDisplayNameLen;   /* Admin Display Name length */
    UCHAR     *adminDescr;           /* Admin Description */
    ULONG     adminDescrLen;         /* Admin Description length */
    ULONG     ClassId;               /* Class ID */
    UCHAR     *pSD;                  /* Default SD for this class */
    DWORD     SDLen;                 /* Length of default SD. */
    PSECURITY_DESCRIPTOR pNTSD;      /* NT SD on the class-schema obj */
    DWORD     NTSDLen;               /* Length of NT SD. */
    BOOL      RDNAttIdPresent;       /* RDN Att Id present? */
    ULONG     RDNAttId;              /* Naming attribute for this class */
    ULONG     ClassCategory;         /* X.500 object type for this class */
    UCHAR     *pDefaultObjCat;       /* Default search category 
                                          to put on instances */
    ULONG     DefaultObjCatLen;    /* Default search category length */ 
    ULONG     SubClassCount;         /* count of superclasses */
    ULONG     *pSubClassOf;          /* ptr to array of superclasses */
    ULONG     AuxClassCount;         /* count of auxiliary classes */
    ULONG     *pAuxClass;            /* ptr to array of aux classes */
    ULONG     SysAuxClassCount;      /* count of Sys aux classes */
    ULONG     *pSysAuxClass;         /* ptr to array of Sys aux classes*/
    ULONG     sysFlags;              /* System-Flags */
    GUID      propGuid;              /* Guid of this class for security */

    unsigned  PossSupCount;          /* Possible superior count */
    unsigned  MustCount;             /* Count of Must Atts */
    unsigned  MayCount;              /* Count of May Atts */

    ATTRTYP   *pPossSup;             /* ptr to array of poss supis */
    ATTRTYP   *pMustAtts;            /* Pointer to array of Must Atts */
    ATTRTYP   *pMayAtts;             /* Pointer to array of May Atts */

    unsigned  SysMustCount;          /* Count of System Must Atts */
    unsigned  SysMayCount;           /* Count of System May Atts */
    unsigned  SysPossSupCount;       /* Count of System PossSup */

    ATTRTYP   *pSysMustAtts;         /* Pointer to array of System MustAtts */
    ATTRTYP   *pSysMayAtts;          /* Pointer to array of System MayAtts */
    ULONG     *pSysPossSup;          /* Pointer to array of System PossSup */

    BOOL       HideFromAB;            /* Hide-From-AB val for the 
                                         class-schema object */
    BOOL       DefHidingVal;          /* default ATT_HIDE_FROM_ADDRESS_BOOK 
                                         value for newly created instances 
                                         of this class */
    BOOL      SystemOnly;            /* System-only class? */
    unsigned  bDefHidingVal:1;       /* Is DefHidingVal present? */
    unsigned  bHideFromAB:1;         /* Is HideFromAB present? */ 
    unsigned  bSystemOnly:1;         /* Is system-only present? */ 
    unsigned  bSystemFlags:1;        /* Is system flags present? */
    unsigned  bDefunct:1;            /* Class is already deleted? */
} CLASS_CACHE;

#define STRING_TYPE 1
#define BINARY_TYPE 2

typedef struct _MY_ATTRMODLIST
{

    USHORT      choice;                 /* modification type:
                                         *  Valid values:
                                         *    - AT_CHOICE_ADD_ATT
                                         *    - AT_CHOICE_REMOVE_ATT
                                         *    - AT_CHOICE_ADD_VALUES
                                         *    - AT_CHOICE_REMOVE_VALUES
                                         *    - AT_CHOICE_REPLACE_ATT
                                         */
    int    type;       // Type = string or binary. User fr printing
    ATTR AttrInf;                       /* information about the attribute  */
} MY_ATTRMODLIST;


// List of attributes to modify. 
typedef struct _ModifyStruct {
    ULONG count;            // No. of attributes
    MY_ATTRMODLIST ModList[30];  // At most 30 attributes for a class/attribute  
} MODIFYSTRUCT;

typedef struct _ulongList {
    ULONG count;
    ULONG *List;
} ULONGLIST;

PVOID
MallocExit(
    DWORD nBytes
    );

// Table functions to map Oids to Ids and vice-versa

PVOID        PrefixToNdxAllocate( RTL_GENERIC_TABLE *Table, CLONG ByteSize );
void         PrefixToIdFree( RTL_GENERIC_TABLE *Table, PVOID Buffer );
RTL_GENERIC_COMPARE_RESULTS 
             PrefixToNdxCompare( RTL_GENERIC_TABLE   *Table,
                                 PVOID   FirstStruct,
                                 PVOID   SecondStruct );
void         PrefixToNdxTableAdd( PVOID *Table, PPREFIX_MAP PrefixMap );
PPREFIX_MAP  PrefixToNdxTableLookup( PVOID *Table, PPREFIX_MAP PrefixMap );
ULONG        AssignNdx(); 
ULONG        OidToId( UCHAR *Oid, ULONG length );
UCHAR        *IdToOid( ULONG Id );
unsigned     MyOidStringToStruct ( UCHAR * pString, unsigned len, OID * pOID );
unsigned     MyOidStructToString ( OID *pOID, UCHAR *pOut );
BOOL         MyDecodeOID(unsigned char *pEncoded, int len, OID *pOID);
unsigned     MyEncodeOID(OID *pOID, unsigned char * pEncoded);



// Functions to load schema into schema cache
int __fastcall   GetAttById( SCHEMAPTR *SCPtr, ULONG attrid, 
                             ATT_CACHE** ppAttcache);
int __fastcall   GetAttByMapiId( SCHEMAPTR *SCPtr, ULONG ulPropID, 
                                 ATT_CACHE** ppAttcache );
int __fastcall   GetAttByName( SCHEMAPTR *SCPtr, ULONG ulSize, 
                               PUCHAR pVal, ATT_CACHE** ppAttcache );
int __fastcall   GetClassById( SCHEMAPTR *SCPtr, ULONG classid, 
                               CLASS_CACHE** ppClasscache );
int __fastcall   GetClassByName( SCHEMAPTR *SCPtr, ULONG ulSize, 
                                 PUCHAR pVal, CLASS_CACHE** ppClasscache );

int      CreateHashTables( SCHEMAPTR *SCPtr );
int      SchemaRead( char *pServerName, char *pDomainName, char *pUserName,
                     char *pPasswd, char **ppSchemaDN, SCHEMAPTR *SCPtr );
int      AddAttributesToCache( LDAP *ld, LDAPMessage *res, SCHEMAPTR *SCPtr); 
int      AddClassesToCache( LDAP *ld, LDAPMessage *res, SCHEMAPTR *SCPtr); 
int      AddAttcacheToTables( ATT_CACHE *p, SCHEMAPTR *SCPtr );
int      AddClasscacheToTables( CLASS_CACHE *p, SCHEMAPTR *SCPtr );
ATTRTYP  StrToAttr( char *attr_name );
void     AddToList(ULONG * puCount, ULONG **pauVal, struct berval **vals);



// Functions used to find and list conflicts between two schemas

void     ChangeDN(char *oldDN, char **newDN, char *targetSchemaDN);
void     FindAdds( FILE *fp, SCHEMAPTR *SCPtr1, SCHEMAPTR * SCPtr2 );
void     FindDeletes( FILE *fp, SCHEMAPTR *SCPtr1, SCHEMAPTR * SCPtr2 );
void     FindModify( FILE *fp, SCHEMAPTR *SCPtr1, SCHEMAPTR * SCPtr2 );
void     FindAttModify( FILE *fp, ATT_CACHE *pac, SCHEMAPTR * SCPtr );
void     FindClassModify( FILE *fp, CLASS_CACHE *pcc, SCHEMAPTR * SCPtr );
int      CompareList( ULONG *List1, ULONG *List2, ULONG Length );
void     LogConflict( char objType, char *s, 
                      UCHAR *name, ATTRTYP id );
void     LogOmission( char objType, UCHAR *name, 
                      ATTRTYP id);



// Functions to free schema cach memory and mapping tables at the end

void     FreeCache( SCHEMAPTR *SCPtr );
void     FreeAttPtrs( SCHEMAPTR *SCPtr, ATT_CACHE *pac );
void     FreeClassPtrs( SCHEMAPTR *SCPtr, CLASS_CACHE *pcc );
void     FreeAttcache( ATT_CACHE *pac );
void     FreeClasscache( CLASS_CACHE *pcc );
void     FreeTable( PVOID OidTable );


// Debug functions to change schema and prints

void     ChangeSchema(SCHEMAPTR *SCPtr);
int      Schemaprint1(SCHEMAPTR *SCPtr);
int      Schemaprint2(SCHEMAPTR *SCPtr);
void     PrintTable(PVOID OidTable);
void     PrintPrefix(ULONG lenght, PVOID Prefix);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\sdcheck\main.c ===
/*++

Copyright (c) 1987-1999 Microsoft Corporation

Module Name:

    sdcheck - main.c

Abstract:

    This program verifies and dumps security descriptors (SDs) of
    objects in the active directory.

Author:

    Dave Straube (davestr) 1/22/98

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windows.h>
#include <winldap.h>
#include <ntldap.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>             // alloca()
#include <rpc.h>                // RPC defines
#include <rpcdce.h>             // RPC_AUTH_IDENTITY_HANDLE
#include <sddl.h>               // ConvertSidToStringSid
#include <ntdsapi.h>            // DS APIs
#include <permit.h>             // DS_GENERIC_MAPPING
#include <checkacl.h>           // CheckAclInheritance()

//
// Typedefs
//

typedef struct ClassCache
{
    struct ClassCache   *pNext;
    GUID                guid;
    CHAR                name[1];
} ClassCache;

typedef struct SdHistory
{
    DWORD               cTime;
    SYSTEMTIME          rTime[5];
} SdHistory;

typedef struct MetaData
{
    SYSTEMTIME          stLastOriginatingWrite;
    DWORD               dwVersion;
    UUID                uuidInvocation;
    CHAR                *pszInvocation;
} MetaData;

typedef struct ClassInfo
{   DWORD               cClasses;
    CHAR                **rClasses;
} ClassInfo;

typedef struct DumpObject
{
    CHAR                *name;          // name of object
    DWORD               cbSD;           // SD byte count
    SECURITY_DESCRIPTOR *pSD;           // SD itself
    ClassInfo           classInfo;      // object class(es)
    SdHistory           history;        // SD propagator history
    MetaData            metaData;       // repl metadata for SD property
} DumpObject;

//
// Globals
//

UUID        gNullUuid = { 0 };              // for comparisons
CHAR        *gpszServer = NULL;             // required arg
CHAR        *gpszObject = NULL;             // required arg
CHAR        *gpszDomain = NULL;             // optional arg - creds
CHAR        *gpszUser = NULL;               // optional arg - creds
CHAR        *gpszPassword = NULL;           // optional arg - creds
CHAR        gpszNullPassword[] = { 0 };     // for RPC_AUTH_IDENTITY_HANDLE
HANDLE      ghDS = NULL;                    // DsBind handle
LDAP        *gldap = NULL;                  // LDAP handle
DWORD       cObjects = 0;                   // count of objects to root of NC
DumpObject  *rObjects = NULL;               // array of objects to root of NC
BOOL        gfDumpOne = FALSE;              // optional arg
BOOL        gfDumpAll = FALSE;              // optional arg
BOOL        gfVerbose = FALSE;              // optional arg
ClassCache  *gClassCache = NULL;            // class name <==> GUID cache

//
// Private (de)alloc routines
//

void *
MyAlloc(
    DWORD cBytes
    )
{
    void *p;

    if ( p = LocalAlloc(LPTR, cBytes) )
        return(p);

    printf("*** Error: Failed to allocate %d bytes\n", cBytes);
    exit(1);
    return NULL;
}

void
MyFree(
    VOID *p
    )
{
    if ( p )
        LocalFree(p);
}

//
// Cleanup globals routine
//

void
CleanupGlobals()
{
    DWORD       i, j;
    ClassCache  *p;

    if ( gldap ) ldap_unbind(gldap);
    if ( ghDS ) DsUnBindA(&ghDS);

    for ( i = 0; i < cObjects; i++ )
    {
        MyFree(rObjects[i].name);
        MyFree(rObjects[i].pSD);
        MyFree(rObjects[i].metaData.pszInvocation);
        for ( j = 0; j < rObjects[i].classInfo.cClasses; j++ )
            MyFree(rObjects[i].classInfo.rClasses[j]);
        MyFree(rObjects[i].classInfo.rClasses);
    }

    while ( gClassCache )
    {
        p = gClassCache->pNext;
        MyFree(gClassCache);
        gClassCache = p;
    }
}

//
// Add a class name/guid pair to the cache.
//

void
AddClassToCache(
    GUID    *pGuid,
    CHAR    *name
    )
{
    ClassCache  *p, *pTmp;

    for ( p = gClassCache; NULL != p; p = p->pNext )
    {
        if ( !_stricmp(p->name, name) )
        {
            return;
        }
    }

    p = (ClassCache *) MyAlloc(sizeof(ClassCache) + strlen(name));
    p->guid = *pGuid;
    strcpy(p->name, name);
    p->pNext = gClassCache;
    gClassCache = p;
}

//
// Map a class name to a GUID.
//

GUID *
ClassNameToGuid(
    CHAR    *name
    )
{
    PLDAPMessage            ldap_message = NULL;
    PLDAPMessage            entry = NULL;
    CHAR                    *attrs[2];
    PSTR                    *values = NULL;
    DWORD                   dwErr;
    DWORD                   i, cVals;
    ClassCache              *p;
    CHAR                    *schemaNC;
    CHAR                    filter[1024];
    PLDAP_BERVAL            *sd_value = NULL;

    for ( p = gClassCache; NULL != p; p = p->pNext )
    {
        if ( !_stricmp(p->name, name) )
        {
            return(&p->guid);
        }
    }

    // OK - Go get it the hard way.

    attrs[0] = "schemaNamingContext";
    attrs[1] = NULL;

    dwErr = ldap_search_ext_sA(gldap,
                               "",
                               LDAP_SCOPE_BASE,
                               "(objectClass=*)",
                               attrs,
                               0,
                               NULL,
                               NULL,
                               NULL,
                               10000,
                               &ldap_message);

    if ( LDAP_SUCCESS != dwErr )
    {
        printf("*** Error: Read of schemaNamingContext failed with 0x%x\n",
               dwErr);
        return(NULL);
    }

    if (    !(entry = ldap_first_entry(gldap, ldap_message))
         || !(values = ldap_get_valuesA(gldap, entry, attrs[0]))
         || !(cVals = ldap_count_valuesA(values))
         || !(sd_value = ldap_get_values_lenA(gldap, ldap_message, attrs[0])) )
    {
        printf("*** Error: No values returned for schemaNamingContext\n");
        ldap_msgfree(ldap_message);
        return(NULL);
    }

    schemaNC = (CHAR *) MyAlloc((*sd_value)->bv_len + 1);
    memset(schemaNC, 0, (*sd_value)->bv_len + 1);
    memcpy(schemaNC, (BYTE *) (*sd_value)->bv_val, (*sd_value)->bv_len);
    ldap_value_free_len(sd_value);
    ldap_value_freeA(values);
    ldap_msgfree(ldap_message);
    sd_value = NULL;
    values = NULL;
    ldap_message = NULL;

    // Now go find the right classSchema object.

    attrs[0] = "schemaIDGUID";
    attrs[1] = NULL;
    sprintf(filter,
            "(&(objectClass=classSchema)(ldapDisplayName=%s))",
            name);

    dwErr = ldap_search_ext_sA(gldap,
                               schemaNC,
                               LDAP_SCOPE_SUBTREE,
                               filter,
                               attrs,
                               0,
                               NULL,
                               NULL,
                               NULL,
                               10000,
                               &ldap_message);
    MyFree(schemaNC);

    if ( LDAP_SUCCESS != dwErr )
    {
        printf("*** Error: Read of schema ID GUID for %s failed with 0x%x\n",
               name, dwErr);
        return(NULL);
    }

    if (    !(entry = ldap_first_entry(gldap, ldap_message))
         || !(values = ldap_get_valuesA(gldap, entry, attrs[0]))
         || !(cVals = ldap_count_valuesA(values))
         || !(sd_value = ldap_get_values_lenA(gldap, ldap_message, attrs[0])) )
    {
        printf("*** Error: No values returned for schema ID GUID for %s\n",
               name);
        ldap_msgfree(ldap_message);
        return(NULL);
    }

    AddClassToCache((GUID *) (*sd_value)->bv_val, name);
    ldap_value_free_len(sd_value);
    ldap_value_freeA(values);
    ldap_msgfree(ldap_message);
    return(&gClassCache->guid);
}

//
// Convert SYSTEMTIME from GMT to local time.
//

void
GmtSystemTimeToLocalSystemTime(
    SYSTEMTIME  *psTime
    )
{
    TIME_ZONE_INFORMATION   tz;
    SYSTEMTIME              localTime;
    DWORD                   dwErr;

    dwErr = GetTimeZoneInformation(&tz);

    if (    (TIME_ZONE_ID_INVALID != dwErr)
         && (TIME_ZONE_ID_UNKNOWN != dwErr) )
    {
        if ( SystemTimeToTzSpecificLocalTime(&tz, psTime, &localTime) )
        {
            *psTime = localTime;
            return;
        }
    }

    printf("*** Error: Couldn't convert time from GMT to local\n");
}

//
// Convert generalized time to SYSTEMTIME.
//

void
GeneralizedTimeToSystemTime(
    CHAR        *pszTime,               // IN
    BOOL        fConvertToLocalTime,    // IN
    SYSTEMTIME  *psTime                 // OUT
    )
{
    ULONG       cb;
    CHAR        buff[10];

    memset(psTime, 0, sizeof(SYSTEMTIME));

    // year field
    cb=4;
    strncpy(buff, pszTime, cb);
    buff[cb] = L'\0';
    psTime->wYear = (USHORT) atoi(buff);
    pszTime += cb;

    // month field
    cb=2;
    strncpy(buff, pszTime, cb);
    buff[cb] = L'\0';
    psTime->wMonth = (USHORT) atoi(buff);
    pszTime += cb;

    // day of month field
    cb=2;
    strncpy(buff, pszTime, cb);
    buff[cb] = L'\0';
    psTime->wDay = (USHORT) atoi(buff);
    pszTime += cb;

    // hours
    cb=2;
    strncpy(buff, pszTime, cb);
    buff[cb] = L'\0';
    psTime->wHour = (USHORT) atoi(buff);
    pszTime += cb;

    // minutes
    cb=2;
    strncpy(buff, pszTime, cb);
    buff[cb] = L'\0';
    psTime->wMinute = (USHORT) atoi(buff);
    pszTime += cb;

    // seconds
    cb=2;
    strncpy(buff, pszTime, cb);
    buff[cb] = L'\0';
    psTime->wSecond = (USHORT) atoi(buff);

    if ( fConvertToLocalTime )
        GmtSystemTimeToLocalSystemTime(psTime);
}

//
// Lookup a schema GUID in the DS via DsMapSchemaGuids.  Always
// returns valid data, though we may just end up sprintf-ing the input.
//

void
LookupGuid(
    GUID    *pg,            // IN
    CHAR    **ppName,       // OUT
    CHAR    **ppLabel,      // OUT
    BOOL    *pfIsClass      // OUT
    )
{
    static CHAR         name[1024];
    static CHAR         label[1024];
    DWORD               dwErr;
    DS_SCHEMA_GUID_MAPA *pMap;
    BOOL                fLame = FALSE;
    DWORD               i;

    *pfIsClass = FALSE;
    *ppName = name;
    *ppLabel = label;

    dwErr = DsMapSchemaGuidsA(ghDS, 1, pg, &pMap);

    if ( dwErr )
    {
        fLame = TRUE;
    }
    else
    {
        switch ( pMap->guidType )
        {
        case DS_SCHEMA_GUID_ATTR:
            strcpy(label, "Attr"); break;
        case DS_SCHEMA_GUID_ATTR_SET:
            strcpy(label, "Attr set"); break;
        case DS_SCHEMA_GUID_CLASS:
            strcpy(label, "Class"); *pfIsClass = TRUE; break;
        case DS_SCHEMA_GUID_CONTROL_RIGHT:
            strcpy(label, "Control right"); break;
        default:
            fLame = TRUE; break;
        }

        if ( !pMap->pName )
        {
            fLame = TRUE;
        }
        else
        {
            strcpy(name, pMap->pName);

            if ( *pfIsClass )
            {
                AddClassToCache(pg, pMap->pName);
            }
        }
    }

    if ( fLame )
    {
        *pfIsClass = FALSE;
        strcpy(label, "???");
        sprintf(name,
                "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                pg->Data1,
                pg->Data2,
                pg->Data3,
                pg->Data4[0],
                pg->Data4[1],
                pg->Data4[2],
                pg->Data4[3],
                pg->Data4[4],
                pg->Data4[5],
                pg->Data4[6],
                pg->Data4[7]);
        printf("*** Warning: Unable to map schema GUID %s - analysis may be compromised\n", name);
    }

    if ( !dwErr )
        DsFreeSchemaGuidMapA(pMap);
}

//
// Map an object SID to a text representation.  Always returns valid
// data, though we may just end up sprintf-ing the input.
//

CHAR *
LookupSid(
    PSID    pSID        // IN
    )
{
    static CHAR     retVal[2048];
    SID_NAME_USE    snu;
    CHAR            user[64];
    CHAR            domain[64];
    DWORD           cUser = sizeof(user);
    DWORD           cDomain = sizeof(domain);
    CHAR            *pszTmp;
    DWORD           i;

    if ( !pSID )
    {
        strcpy(retVal, "<NULL>");
        return(retVal);
    }
    else if ( !RtlValidSid(pSID) )
    {
        strcpy(retVal, "Not an RtlValidSid()");
        return(retVal);
    }
    else if ( LookupAccountSid(NULL, pSID, user, &cUser,
                               domain, &cDomain, &snu) )
    {
        if ( cDomain )
        {
            strcpy(retVal, domain);
            strcat(retVal, "\\");
            strcat(retVal, user);
        }
        else
        {
            strcpy(retVal, user);
        }

        strcat(retVal, " ");
    }
    else
    {
        retVal[0] = L'\0';
    }

    // Always concatenate S-xxx form of SID for reference.

    if ( ConvertSidToStringSidA(pSID, &pszTmp) )
    {
        strcat(retVal, pszTmp);
        LocalFree(pszTmp);
    }

    if ( L'\0' != retVal[0] )
    {
        // Already have symbolic name, S-xxx form, or both - done.
        return(retVal);
    }

    // Dump binary as a last resort.

    for ( i = 0; i < RtlLengthSid(pSID); i++ )
    {
        sprintf(&retVal[2*i], "%02x", ((CHAR *) pSID)[i]);
    }

    retVal[2*i] = '\0';
    return(retVal);
}



//
// Get an object's classes from the directory.  Note that these class
// names are the LDAP display names which in turn are the same names
// as those returned bu DsMapSchemaGuid - at least when the GUID
// represents a class or attribute.
//

void
ReadClasses(
    DumpObject          *pdo        // IN
    )
{
    CHAR                    *pDN = pdo->name;
    PLDAPMessage            ldap_message = NULL;
    PLDAPMessage            entry = NULL;
    CHAR                    *attrs[2];
    PSTR                    *values = NULL;
    DWORD                   dwErr;
    DWORD                   i, cVals;

    dwErr = 1;

    _try
    {
        attrs[0] = "objectClass";
        attrs[1] = NULL;

        dwErr = ldap_search_ext_sA(gldap,
                                   pDN,
                                   LDAP_SCOPE_BASE,
                                   "(objectClass=*)",
                                   attrs,
                                   0,
                                   NULL,
                                   NULL,
                                   NULL,
                                   10000,
                                   &ldap_message);

        if ( LDAP_SUCCESS != dwErr )
        {
            printf("*** Error: Read of objectClass on %s failed with 0x%x\n",
                   pDN, dwErr);
            _leave;
        }

        if (    !(entry = ldap_first_entry(gldap, ldap_message))
             || !(values = ldap_get_valuesA(gldap, entry, attrs[0]))
             || !(cVals = ldap_count_valuesA(values)) )
        {
            printf("*** Error: No values returned for objectClass on %s\n",
                   pDN);
            _leave;
        }

        pdo->classInfo.rClasses =
                (CHAR **) MyAlloc(cVals * sizeof(CHAR *));

        for ( i = 0; i < cVals; i++ )
        {
            pdo->classInfo.rClasses[i] =
                            (CHAR *) MyAlloc(strlen(values[i]) + 1);
            strcpy(pdo->classInfo.rClasses[i], values[i]);
            pdo->classInfo.cClasses += 1;
        }
    }
    _finally
    {
        if ( values )
            ldap_value_freeA(values);

        if ( ldap_message )
            ldap_msgfree(ldap_message);
    }
}

//
// Read on object's SD propagation history from the directory.
//

void
ReadSdHistory(
    DumpObject  *pdo        // IN
    )
{
    CHAR                    *pDN = pdo->name;
    SdHistory               *pHistory = &pdo->history;
    PLDAPMessage            ldap_message = NULL;
    PLDAPMessage            entry = NULL;
    CHAR                    *attrs[2];
    PSTR                    *values = NULL;
    DWORD                   dwErr;
    DWORD                   i, cVals;

    dwErr = 1;
    memset(pHistory, 0, sizeof(SdHistory));

    _try
    {
        attrs[0] = "dSCorePropagationData";
        attrs[1] = NULL;

        dwErr = ldap_search_ext_sA(gldap,
                                   pDN,
                                   LDAP_SCOPE_BASE,
                                   "(objectClass=*)",
                                   attrs,
                                   0,
                                   NULL,
                                   NULL,
                                   NULL,
                                   10000,
                                   &ldap_message);

        if ( LDAP_SUCCESS != dwErr )
        {
            printf("*** Error: Read of dSCorePropagationData on %s failed with 0x%x\n",
                   pDN, dwErr);
            _leave;
        }

        if (    !(entry = ldap_first_entry(gldap, ldap_message))
             || !(values = ldap_get_valuesA(gldap, entry, attrs[0]))
             || !(cVals = ldap_count_valuesA(values)) )
        {
            printf("*** Warning: No values returned for dSCorePropagationData on %s\n",
                   pDN);
            _leave;
        }

        for ( i = 0; i < cVals; i++ )
        {
            // Don't convert last value to local time as it
            // is the flags field - not a real time.

            GeneralizedTimeToSystemTime(values[i],
                                        (i != (cVals - 1)),
                                        &pHistory->rTime[i]);
            pHistory->cTime += 1;
        }
    }
    _finally
    {
        if ( values )
            ldap_value_freeA(values);

        if ( ldap_message )
            ldap_msgfree(ldap_message);
    }
}

//
// Read an objects security descriptor from the directory.
//

void
ReadSD(
    DumpObject  *pdo        // IN
    )
{
    CHAR                    *pDN = pdo->name;
    SECURITY_DESCRIPTOR     **ppSD = &pdo->pSD;
    PLDAPMessage            ldap_message = NULL;
    PLDAPMessage            entry = NULL;
    CHAR                    *attrs[2];
    PSTR                    *values = NULL;
    PLDAP_BERVAL            *sd_value = NULL;
    SECURITY_INFORMATION    seInfo =   DACL_SECURITY_INFORMATION
                                     | GROUP_SECURITY_INFORMATION
                                     | OWNER_SECURITY_INFORMATION
                                     | SACL_SECURITY_INFORMATION;
    BYTE                    berValue[2*sizeof(ULONG)];
    LDAPControlA            seInfoControl = { LDAP_SERVER_SD_FLAGS_OID,
                                              { 5,
                                                (PCHAR) berValue },
                                              TRUE };
    PLDAPControlA           serverControls[2] = { &seInfoControl, NULL };
    DWORD                   dwErr;
    DWORD                   cRetry = 0;

    *ppSD = NULL;
    dwErr = 1;

    // initialize the ber val
    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE) (seInfo & 0xF);

    _try
    {

RetryReadSD:

        if ( cRetry )
        {
            seInfo &= ~SACL_SECURITY_INFORMATION;
            berValue[4] = (BYTE) (seInfo & 0xF);
            printf("*** Warning: Retrying read w/o SACL_SECURITY_INFORMATION set\n");
        }

        attrs[0] = "nTSecurityDescriptor";
        attrs[1] = NULL;

        dwErr = ldap_search_ext_sA(gldap,
                                   pDN,
                                   LDAP_SCOPE_BASE,
                                   "(objectClass=*)",
                                   attrs,
                                   0,
                                   (PLDAPControlA *) &serverControls,
                                   NULL,
                                   NULL,
                                   10000,
                                   &ldap_message);

        if ( LDAP_SUCCESS != dwErr )
        {
            printf("*** Error: Read of nTSecurityDescriptor on %s failed with 0x%x\n",
                   pDN, dwErr);
            _leave;
        }

        if (    !(entry = ldap_first_entry(gldap, ldap_message))
             || !(values = ldap_get_valuesA(gldap, entry, attrs[0]))
             || !(sd_value = ldap_get_values_lenA(gldap, ldap_message, attrs[0])) )
        {
            printf("*** Error: No values returned for nTSecurityDescriptor on %s\n",
                   pDN);

            if ( 0 == cRetry++ )
            {
                goto RetryReadSD;
            }

            _leave;
        }

        *ppSD = (SECURITY_DESCRIPTOR *) MyAlloc((*sd_value)->bv_len);

        if ( !*ppSD )
        {
            printf("Memory allocation error\n");
            _leave;
        }

        memcpy(*ppSD, (BYTE *) (*sd_value)->bv_val, (*sd_value)->bv_len);
        pdo->cbSD = (*sd_value)->bv_len;
    }
    _finally
    {
        if ( sd_value )
            ldap_value_free_len(sd_value);

        if ( values )
            ldap_value_freeA(values);

        if ( ldap_message )
            ldap_msgfree(ldap_message);
    }
}

void
CheckAcls()
{
    DWORD   i;
    DWORD   iClassName;
    CHAR    *pClassName;
    DWORD   dwLastError;
    DWORD   iChild;
    DWORD   iParent;

    if ( cObjects < 2 )
        return;

    // Process parent down to leaf.

    for ( i = (cObjects-1); i > 0; i-- )
    {
        iParent = i;
        iChild = i-1;

        printf("\nChecking ACL inheritance ...\n");
        printf("\tParent: %d - %s\n", iParent, rObjects[iParent].name);
        printf("\tChild:  %d - %s\n", iChild, rObjects[iChild].name);

        if ( !rObjects[iParent].pSD )
        {
            printf("*** Error: Skipping because no ACL for parent\n");
            continue;
        }

        if ( !rObjects[iChild].pSD )
        {
            printf("*** Error: Skipping because no ACL for child\n");
            continue;
        }

        iClassName = rObjects[iChild].classInfo.cClasses - 1;
        pClassName = rObjects[iChild].classInfo.rClasses[iClassName];

        if ( AclErrorNone != CheckAclInheritance(
                                    rObjects[iParent].pSD,
                                    rObjects[iChild].pSD,
                                    ClassNameToGuid(pClassName),
                                    printf,             // print function ptr
                                    TRUE,               // fContinueOnError
                                    gfVerbose,          // fVerbose
                                    &dwLastError) )
        {
            // Nothing to do as errors have been dumped to screen.
        }
    }
}

//
// Map invocation ID to name.
//

void
InvocationIdToName(
    DumpObject      *pdo
    )
{
    static CHAR pszConfigNC[2048] = { 0 };     // config NC buffer
    static CHAR pszFilter[4096] = { 0 };       // invocation ID search filter
    static CHAR pszServer[4096] = { 0 };       // server object DN
    DWORD       dwErr;
    CHAR        *attrs[2] = { NULL, NULL };
    LDAPMessage *ldap_message = NULL, *entry;
    PSTR        *values = NULL;
    DWORD       i, cBytes, cVals;
    DWORD       depth;
    CHAR        *pszRoot;
    CHAR        *pszFormat;
    BYTE        *rb;
    CHAR        *psz;

    pdo->metaData.pszInvocation = NULL;

    // See if we've translated it once before.

    for ( i = 0; i < cObjects; i++ )
    {
        if (    !memcmp(&rObjects[i].metaData.uuidInvocation,
                        &pdo->metaData.uuidInvocation,
                        sizeof(GUID))
             && rObjects[i].metaData.pszInvocation )
        {
            cBytes = strlen(rObjects[i].metaData.pszInvocation) + 1;

            if ( pdo->metaData.pszInvocation = (CHAR *) MyAlloc(cBytes) )
            {
                strcpy(pdo->metaData.pszInvocation,
                       rObjects[i].metaData.pszInvocation);
            }

            return;
        }
    }

    for ( i = 0; i < 3; i++ )
    {
        if ( 0 == i )
        {
            // First pass to read config container.
            if ( pszConfigNC[0] )
                continue;
            attrs[0] = "configurationNamingContext";
            pszRoot = "";
            depth = LDAP_SCOPE_BASE;
            strcpy(pszFilter, "(objectClass=*)");
            pszFormat = "Read of configurationNamingContext";
        }
        else if ( 1 == i )
        {
            // Second pass to find NTDS-DSA object.
            attrs[0] = "distinguishedName";
            pszRoot = pszConfigNC;
            depth = LDAP_SCOPE_SUBTREE;
            rb = (BYTE *) &pdo->metaData.uuidInvocation;
            sprintf(
                pszFilter,
                "(&(objectCategory=ntdsDsa)(invocationId=\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x\\%02x))",
                rb[0],  rb[1],  rb[2],  rb[3],
                rb[4],  rb[5],  rb[6],  rb[7],
                rb[8],  rb[9],  rb[10], rb[11],
                rb[12], rb[13], rb[14], rb[15]);
            pszFormat = "Search by invocationID";
        }
        else
        {
            // Third pass to read dnsHostName off server.
            attrs[0] = "dnsHostName";
            pszRoot = pszServer;
            depth = LDAP_SCOPE_BASE;
            strcpy(pszFilter, "(objectClass=*)");
            pszFormat = "Read of dnsHostName";
        }

        if ( LDAP_SUCCESS != (dwErr = ldap_search_sA(
                                            gldap,
                                            pszRoot,
                                            depth,
                                            pszFilter,
                                            attrs,
                                            0,
                                            &ldap_message)) )
        {
            printf("*** Warning: %s failed with 0x%x\n", pszFormat, dwErr);
            goto Bail;
        }

        if (    !(entry = ldap_first_entry(gldap, ldap_message))
             || !(values = ldap_get_valuesA(gldap, entry, attrs[0]))
             || !(cVals = ldap_count_valuesA(values)) )
        {
            printf("*** Warning: %s failed with 0x%x\n",
                   pszFormat, LDAP_NO_RESULTS_RETURNED);
            goto Bail;
        }

        if ( 0 == i )
        {
            strcpy(pszConfigNC, values[0]);
        }
        else if ( 1 == i )
        {
            if ( psz = strchr(values[0], (int) ',') )
            {
                strcpy(pszServer, ++psz);
            }
            else
            {
                goto Bail;
            }
        }
        else
        {
            cBytes = strlen(values[0]) + 1;

            if ( pdo->metaData.pszInvocation = (CHAR *) MyAlloc(cBytes) )
            {
                strcpy(pdo->metaData.pszInvocation, values[0]);
            }
        }

        ldap_value_freeA(values);
        values = NULL;
        ldap_msgfree(ldap_message);
        ldap_message = NULL;
    }

Bail:

    if ( values )
        ldap_value_freeA(values);

    if ( ldap_message )
        ldap_msgfree(ldap_message);
}

//
// Read the replication metadata for the SD property.
//

void
ReadMeta(
    DumpObject  *pdo        // IN
    )
{
    CHAR                    *pDN = pdo->name;
    MetaData                *pmd = &pdo->metaData;
    WCHAR                   *pwszDN;
    DWORD                   dwErr;
    DS_REPL_OBJ_META_DATA   *pInfo;
    DWORD                   i;
    GUID                    *pg;
    SYSTEMTIME              sTime;

    memset(pmd, 0, sizeof(MetaData));
    pwszDN = (WCHAR *) alloca(sizeof(WCHAR) * (strlen(pDN) + 1));
    mbstowcs(pwszDN, pDN, strlen(pDN) + 1);
    dwErr = DsReplicaGetInfoW(ghDS, DS_REPL_INFO_METADATA_FOR_OBJ,
                              pwszDN, NULL, &pInfo);
    if ( dwErr )
    {
        printf("Error: DsReplicaGetInfoW ==> 0x%x for %s\n",
               dwErr, pDN);
        return;
    }

    for ( i = 0; i < pInfo->cNumEntries; i++ )
    {
        if ( !_wcsicmp(pInfo->rgMetaData[i].pszAttributeName,
                       L"ntSecurityDescriptor") )
        {
            pmd->dwVersion = pInfo->rgMetaData[i].dwVersion;
            memcpy(&pmd->uuidInvocation,
                   &pInfo->rgMetaData[i].uuidLastOriginatingDsaInvocationID,
                   sizeof(UUID));
            FileTimeToSystemTime(
                   &pInfo->rgMetaData[i].ftimeLastOriginatingChange,
                   &pmd->stLastOriginatingWrite);
            GmtSystemTimeToLocalSystemTime(&pmd->stLastOriginatingWrite);
            DsReplicaFreeInfo(DS_REPL_INFO_METADATA_FOR_OBJ, (PVOID) pInfo);
            InvocationIdToName(pdo);
            return;
        }
    }

    DsReplicaFreeInfo(DS_REPL_INFO_METADATA_FOR_OBJ, (PVOID) pInfo);
    printf("*** Error: %s has no metadata for ntSecurityDescriptor\n", pDN);
}

//
// indentation routine for pretty-printing ACL dump.
//

void Indent(
    DWORD   n       // IN
    )
{
    int i = (int) (2 * n);

    while ( i-- > 0 )
        printf(" ");
}

//
// Grind through all objects and dump/analyse as indicated by args.
//

void
ProcessObjects(
    )
{
    DWORD       i;
    int         j;
    SdHistory   history;
    SYSTEMTIME  *pst;
    GUID        *pg;
    FILETIME    ft;
    UCHAR       *rFlags;
    LONGLONG    dsTime, tempTime;
    DWORD       cTime;
    SYSTEMTIME  *rTime;

    for ( i = 0; i < cObjects; i++ )
    {
        ReadMeta(&rObjects[i]);
        ReadSdHistory(&rObjects[i]);
        ReadSD(&rObjects[i]);
        ReadClasses(&rObjects[i]);
    }

    for ( i = 0; i < cObjects; i++ )
    {
        // Object name

        printf("\n");
        Indent(i);
        printf("Object:   %s\n", rObjects[i].name);

        // Object's class(es)

        if ( rObjects[i].classInfo.cClasses )
        {
            Indent(i);
            printf("Classes:  ", rObjects[i].classInfo.cClasses);

            for ( j = 0; j < (int) rObjects[i].classInfo.cClasses; j++ )
            {
                printf("%s ", rObjects[i].classInfo.rClasses[j]);
                if ( j == (int) (rObjects[i].classInfo.cClasses - 1) )
                    printf("\n");
            }
        }

        // SD size

        if ( rObjects[i].cbSD )
        {
            Indent(i);
            printf("SD:       %d bytes\n", rObjects[i].cbSD);
        }

        // Meta data

        if ( memcmp(&gNullUuid,
                    &rObjects[i].metaData.uuidInvocation,
                    sizeof(UUID)) )
        {
            pst = &rObjects[i].metaData.stLastOriginatingWrite;
            Indent(i);
            printf("Metadata: ");
            printf("%02d/%02d/%02d %02d:%02d:%02d @ ",
                   pst->wMonth, pst->wDay, pst->wYear,
                   pst->wHour, pst->wMinute, pst->wSecond);
            if ( rObjects[i].metaData.pszInvocation )
            {
                printf("%s", rObjects[i].metaData.pszInvocation);
            }
            else
            {
                pg = &rObjects[i].metaData.uuidInvocation;
                printf("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                       pg->Data1,
                       pg->Data2,
                       pg->Data3,
                       pg->Data4[0],
                       pg->Data4[1],
                       pg->Data4[2],
                       pg->Data4[3],
                       pg->Data4[4],
                       pg->Data4[5],
                       pg->Data4[6],
                       pg->Data4[7]);
            }
            printf(" ver: %d\n", rObjects[i].metaData.dwVersion);
        }

        // SD history

        cTime = rObjects[i].history.cTime;
        rTime = rObjects[i].history.rTime;

        if ( 0 != cTime )
        {
            if ( 1 == cTime )
            {
                Indent(i);
                printf("History:  Invalid single element SD history\n");
            }
            else
            {
                // See private\ds\src\dsamain\dblayer\dbprop.c:DBAddSDPropTime
                // for an explanation of how the SD propagator log works.

                SystemTimeToFileTime(&rTime[cTime-1], &ft);
                dsTime = (LONGLONG) ft.dwLowDateTime;
                tempTime = (LONGLONG) ft.dwHighDateTime;
                dsTime |= (tempTime << 32);
                dsTime = dsTime / (10*1000*1000L);
                rFlags = (UCHAR *) &dsTime;

                Indent(i);
                printf("History:  ");
                for ( j = cTime-2; j >= 0; j-- )
                {
                    if ( j != (int) cTime-2 )
                    {
                        Indent(i);
                        printf("          ");
                    }

                    printf("%02d/%02d/%02d %02d:%02d:%02d flags(0x%x)",
                           rTime[j].wMonth, rTime[j].wDay, rTime[j].wYear,
                           rTime[j].wHour, rTime[j].wMinute, rTime[j].wSecond,
                          rFlags[j]);
                    if ( rFlags[j] & 0x1 ) printf(" SD propagation");
                    if ( rFlags[j] & 0x2 ) printf(" Ancestry propagation");
                    if ( rFlags[j] & 0x4 ) printf(" propagate to leaves");
                    printf("\n");
                }
            }
        }
    }

    // Always check ACLs.

    CheckAcls();

    // Dump SDs if requested.

    for ( i = 0; i < cObjects; i++ )
    {
        if (    (    ((0 == i) && gfDumpOne)
                  || gfDumpAll)
             && (rObjects[i].pSD) )
        {
            printf("\n\nSD for %s\n", rObjects[i].name);
            DumpSD(rObjects[i].pSD, printf, LookupGuid, LookupSid);
        }
    }
}

//
// Find the object specified and all its parents up to the NC root.
// N.B. Does not handle non-domain NCs correctly.
//

DWORD
FindObjects()
{
    DWORD           dwErr = 0;
    DS_NAME_RESULTA *pObject = NULL;
    DS_NAME_RESULTA *pDomain = NULL;
    CHAR            *pszTmp = NULL;
    DWORD           i, j, cChar;
    DWORD           cPartsObject;
    DWORD           cPartsDomain;

    __try
    {
        // First crack input name and make sure it exists.

        dwErr = DsCrackNamesA(  ghDS,
                                DS_NAME_NO_FLAGS,
                                DS_UNKNOWN_NAME,
                                DS_FQDN_1779_NAME,
                                1,
                                &gpszObject,
                                &pObject);

        if ( dwErr )
        {
            printf("DsCrackNamesA(%s) returned 0x%x\n", gpszObject, dwErr);
            __leave;
        }

        if ( pObject->rItems[0].status )
        {
            printf("DsCrackNamesA(%s) returned object error 0x%x\n",
                   gpszObject, pObject->rItems[0].status);
            dwErr = 1;
            __leave;
        }

        // Get DN of containing domain.

        pszTmp = (CHAR *) MyAlloc( strlen(pObject->rItems[0].pDomain) + 2);
        strcpy(pszTmp, pObject->rItems[0].pDomain);
        strcat(pszTmp, "/");

        dwErr = DsCrackNamesA(  ghDS,
                                DS_NAME_NO_FLAGS,
                                DS_CANONICAL_NAME,
                                DS_FQDN_1779_NAME,
                                1,
                                &pszTmp,
                                &pDomain);

        if ( dwErr || !pDomain)
        {
            printf("DsCrackNamesA(%s) returned 0x%x\n", pszTmp, dwErr);
            __leave;
        }

        if ( pDomain->rItems[0].status )
        {
            printf("DsCrackNamesA(%s) returned object error 0x%x\n",
                   pszTmp, pDomain->rItems[0].status);
            dwErr = 1;
            __leave;
        }

        printf("Input:  %s\n", gpszObject);
        printf("Object: %s\n", pObject->rItems[0].pName);
        printf("Domain: %s\n", pObject->rItems[0].pDomain);
        printf("Domain: %s\n", pDomain->rItems[0].pName);
        printf("Server: %s\n\n", gpszServer);

        // Process everything up to the domain root.
        // Don't handle escaping or anything - just work with commas.

        cPartsObject = 1;
        cChar = strlen(pObject->rItems[0].pName);
        for ( i = 0; i < cChar; i++ )
            if ( ',' == pObject->rItems[0].pName[i] )
                cPartsObject++;

        cPartsDomain = 1;
        cChar = strlen(pDomain->rItems[0].pName);
        for ( i = 0; i < cChar; i++ )
            if ( ',' == pDomain->rItems[0].pName[i] )
                cPartsDomain++;

        cObjects = cPartsObject - cPartsDomain + 1;
        rObjects = (DumpObject *) MyAlloc( cObjects * sizeof(DumpObject));
        memset(rObjects, 0, cObjects * sizeof(DumpObject));
        rObjects[0].name = (CHAR *) MyAlloc(
                                        strlen(pObject->rItems[0].pName) + 1);
        strcpy(rObjects[0].name, pObject->rItems[0].pName);

        for ( i = 1; i < cObjects; i++ )
        {
            rObjects[i].name = (CHAR *) MyAlloc(
                                            strlen(rObjects[i-1].name) + 1);
            strcpy(rObjects[i].name, strchr(rObjects[i-1].name, ',') + 1);
        }
    }
    __finally
    {
        if ( pObject ) DsFreeNameResultA(pObject);
        if ( pDomain ) DsFreeNameResultA(pDomain);
    }

    return(dwErr);
}

//
// Parse command line arguments.
//

void GetArgs(
    int     argc,
    char    **argv
    )
{
    char *arg;

    if ( argc < 3 )
    {
        goto Usage;
    }

    gpszServer = argv[1];
    gpszObject = argv[2];

    while ( --argc > 2 )
    {
        arg = argv[argc];

        if ( !_strnicmp(arg, "-domain:", 8) )
        {
            gpszDomain = &arg[8];
        }
        else if ( !_strnicmp(arg, "-user:", 6) )
        {
            gpszUser = &arg[6];
        }
        else if ( !_strnicmp(arg, "-pwd:", 5) )
        {
            if ( 5 == strlen(arg) )
                gpszPassword = gpszNullPassword;
            else
                gpszPassword = &arg[5];
        }
        else if ( !_stricmp(arg, "-dumpSD") )
        {
            gfDumpOne = TRUE;
        }
        else if ( !_stricmp(arg, "-dumpAll") )
        {
            gfDumpAll = TRUE;
        }
        else if ( !_stricmp(arg, "-debug") )
        {
            gfVerbose = TRUE;
        }
        else
        {
            goto Usage;
        }
    }

    if (    !gpszServer
         || !gpszObject )
    {
Usage:
        printf("\nUsage: %s ServerName ObjectName [options]\n",
               argv[0]);
        printf("\t options:\n");
        printf("\t\t-dumpSD               - dumps first SD              \n");
        printf("\t\t-dumpAll              - dumps all SDs               \n");
        printf("\t\t-debug                - verbose debug output        \n");
        printf("\t\t-domain:DomainName    - for specifying credentials  \n");
        printf("\t\t-user:UserName        - for specifying credentials  \n");
        printf("\t\t-pwd:Password         - for specifying credentials  \n");
        exit(1);
    }
}

void
__cdecl
main(
    int     argc,
    char    **argv
    )
{
    ULONG                   version = 3;
    SEC_WINNT_AUTH_IDENTITY creds;
    DWORD                   dwErr;
    HANDLE                  hToken = NULL;
    TOKEN_PRIVILEGES        tp, tpPrevious;
    DWORD                   tpSize;

    __try
    {
        GetArgs(argc, argv);

        printf("\n%s\nSecurity Descriptor Check Utility - build(%d)\n\n",
               VER_PRODUCTNAME_STR,
               VER_PRODUCTBUILD);

        // Adjust privileges so we can read SACL and such.

        if ( !OpenProcessToken(GetCurrentProcess(),
                               TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
                               &hToken) )
        {
            dwErr = GetLastError();
            printf("*** Error: OpenProcessTokenError ==>0x%x - continuing\n",
                   dwErr);
            printf("           This may prevent reading of the SACL\n");
        }
        else
        {
            tp.PrivilegeCount = 1;
            tp.Privileges[0].Luid.HighPart = 0;
            tp.Privileges[0].Luid.LowPart = SE_SECURITY_PRIVILEGE;
            tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            if ( !AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tpPrevious),
                                        &tpPrevious, &tpSize) )
            {
                dwErr = GetLastError();
                printf("*** Error: AdjustTokenPrivileges ==> 0x%x - continuing\n",
                       dwErr);
                printf("           This may prevent reading of the SACL\n");
            }

            CloseHandle(hToken);
        }

    	if ( !(gldap = ldap_openA(gpszServer, LDAP_PORT)) )
        {
            printf("Failed to open connection to %s\n", gpszServer);
            __leave;
        }

        ldap_set_option(gldap, LDAP_OPT_VERSION, &version);

        memset(&creds, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));
        creds.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

        if ( gpszDomain )
        {
            creds.Domain = gpszDomain;
            creds.DomainLength = strlen(gpszDomain);
        }

        if ( gpszUser )
        {
            creds.User = gpszUser;
            creds.UserLength = strlen(gpszUser);
        }

        if ( gpszPassword )
        {
            creds.Password = gpszPassword;
            creds.PasswordLength = strlen(gpszPassword);
        }

        dwErr = ldap_bind_sA(gldap, NULL, (CHAR *) &creds, LDAP_AUTH_SSPI);

        if ( LDAP_SUCCESS != dwErr )
        {
            printf("ldap_bind_sA error 0x%x\n", dwErr);
            __leave;
        }

        dwErr = DsBindWithCredA(gpszServer, NULL, &creds, &ghDS);

        if ( dwErr )
        {
            printf("DsBindWIthCredA error 0x%x\n", dwErr);
            __leave;
        }

        // We've got all the handles we want - do the real work.

        if ( !FindObjects() )
            ProcessObjects();
    }
    __finally
    {
        CleanupGlobals();
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\schupgr\schupgr.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <sddl.h>
#include <tchar.h>
#include "permit.h"
#include "schupgr.h"
#include "dsconfig.h"
#include "locale.h"



// Internal functions

DWORD  FindLdifFiles();
DWORD  GetObjVersionFromInifile(int *Version);
PVOID  MallocExit(DWORD nBytes);


// Global for writing log file

FILE *logfp;

// Global to fill yp with ldif file prefixes (ex. d:\winnt\system32\sch)

WCHAR  LdifFilePrefix[MAX_PATH];


// Globals to store version-from and version-to for the schema
// This will be set by the main function, and used by both DN conversion
// and actual import

int VersionFrom = 0, VersionTo = 0;


//////////////////////////////////////////////////////////////////////////
//
// Routine Description:
//
//    Main routine for schema upgrade
//    Does the following in order
//        * Get the computer name
//        * ldap connect and SSPI bind to the server
//        * Get the naming contexts by doing ldap search on root DSE
//        * Get the objectVersion X on the schema container (VersionFrom)
//          (0 if none present)
//        * Get the objectVersion Y in the new schema.ini file (VersionTo)
//          (0 if none present)
//        * Gets the schema FSMO if not already there
//        * put the AD in schema-upgrade mode
//        * Calls the exe ldifde.exe to import the schema changes
//          from the ldif files schZ.ldf into the DS. The files are
//          searched for in the system directory (where winnt32 puts them)
//        * resets schema-upgrade mode in the DS
//
// Return Values:
//
//    None. Error messages are printed out to the console
//    and logged in the file schupgr.log. Process bails out on error on any
//    of the above steps (taking care of proper cleaning-up)
//
///////////////////////////////////////////////////////////////////////// 

void 
_cdecl main( )
{

    // general ldap variables (open, bind, errors)
    LDAP            *ld;   
    DWORD           LdapErr;
    SEC_WINNT_AUTH_IDENTITY Credentials;

    // for ldap searches (naming contexts, objectVersion on schema)
    LDAPMessage     *res, *e;
    WCHAR           *attrs[10];

    // for ldap mods (FSMO)
    LDAPModW         Mod;
    LDAPModW        *pMods[5];

    // Others
    WCHAR           *ServerName = NULL;
    WCHAR           *DomainDN = NULL;
    WCHAR           *ConfigDN = NULL;
    WCHAR           *SchemaDN = NULL;
    WCHAR           SystemDir[MAX_PATH];
    WCHAR           NewFile[ MAX_PATH ];
    WCHAR           LdifLogFile[MAX_PATH], LdifErrFile[MAX_PATH];
    WCHAR           TempStr[25];   // for itoa conversions
    WCHAR           RenamedFile[100];
    WCHAR           VersionStr[100], LdifLogStr[100];
    WCHAR           CommandLine[512];
    DWORD           BuffSize = MAX_COMPUTERNAME_LENGTH + 1;
    int             i, NewSchVersion = 0, StartLdifLog = 0;
    DWORD           err = 0;
    BOOL            fDomainDN, fConfigDN, fSchemaDN;
    PWCHAR          *pwTemp;

    // for running ldifde.exe
    PROCESS_INFORMATION  procInf;
    STARTUPINFOW          startInf;

    // "C", the default c-runtime locale, tends to translate extended
    // chars into 0x00; which means strings are truncated on output
    // even when printed with wprintf.
    //
    // Set the c-runtime's locale to the user's default locale to
    // alleviate the problem.
    setlocale(LC_ALL, "");
 

    // Find the log file no. X to start with for ldif.log.X
    // so that old ldif log files are not deleted 

    wcscpy(LdifLogFile,L"ldif.log.");
    _itow( StartLdifLog, VersionStr, 10 );
    wcscat(LdifLogFile,VersionStr);
    while ( (logfp = _wfopen(LdifLogFile,L"r")) != NULL) {
       StartLdifLog++;
       wcscpy(LdifLogFile,L"ldif.log.");
       _itow( StartLdifLog, LdifLogStr, 10 );
       wcscat(LdifLogFile, LdifLogStr);
    }

    // Open the schupgr log file. Erase any earlier log file

    logfp = _wfopen(L"schupgr.log", L"w");
    if (!logfp) {
      // error opening log file
      printf("Cannot open log file schupgr.log. Make sure you have permissions to create files in the current directory.\n");
      exit (1);
    }


    // get the server name
    ServerName = MallocExit(BuffSize * sizeof(WCHAR));
    while ((GetComputerNameW(ServerName, &BuffSize) == 0)
            && (ERROR_BUFFER_OVERFLOW == (err = GetLastError()))) {
        free(ServerName);
        BuffSize *= 2;
        ServerName = MallocExit(BuffSize * sizeof(WCHAR));
        err = 0;
    }

    if (err) {
         LogMessage(LOG_AND_PRT, MSG_SCHUPGR_SERVER_NAME_ERROR,
                    _itow(err, TempStr, 10), NULL);
         exit (1);
    }

    // connect through ldap

    if ( (ld = ldap_openW( ServerName, LDAP_PORT )) == NULL ) {
       LogMessage(LOG_AND_PRT, MSG_SCHUPGR_CONNECT_FAIL, ServerName, NULL);
       exit(1);
    }

    LogMessage(LOG_AND_PRT, MSG_SCHUPGR_CONNECT_SUCCEED, ServerName, NULL);

    // SSPI bind with current credentials

    memset(&Credentials, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));
    Credentials.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    LdapErr = ldap_bind_s(ld,
              NULL,  // use credentials instead
              (VOID*) &Credentials,
              LDAP_AUTH_SSPI);

    if (LdapErr != LDAP_SUCCESS) {
         LogMessage(LOG_AND_PRT, MSG_SCHUPGR_BIND_FAILED, 
                    _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
         ldap_unbind( ld );
         exit(1);
    }

    LogMessage(LOG_AND_PRT, MSG_SCHUPGR_BIND_SUCCEED, NULL, NULL);

     
    // Get the root domain DN, schema DN, and config DN

    attrs[0] = _wcsdup(L"rootDomainNamingContext");
    attrs[1] = _wcsdup(L"configurationNamingContext");
    attrs[2] = _wcsdup(L"schemaNamingContext");
    attrs[3] = NULL;
    if ( (LdapErr =ldap_search_sW( ld,
                        L"\0",
                        LDAP_SCOPE_BASE,
                        L"(objectclass=*)",
                        attrs,
                        0,
                        &res )) != LDAP_SUCCESS ) {
         LogMessage(LOG_AND_PRT, MSG_SCHUPGR_ROOT_DSE_SEARCH_FAIL,
                    _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
         ldap_unbind( ld );
         exit( 1 );
     }

    fDomainDN = FALSE;
    fConfigDN = FALSE;
    fSchemaDN = FALSE;

    for ( e = ldap_first_entry( ld, res );
          e != NULL;
          e = ldap_next_entry( ld, e ) ) {

          pwTemp = ldap_get_valuesW(ld, e, L"rootDomainNamingContext");
          if (pwTemp[0]) {
              if (DomainDN) {
                  free(DomainDN);
              }
              DomainDN = MallocExit((wcslen(pwTemp[0]) + 1) * sizeof(WCHAR));
              wcscpy(DomainDN, pwTemp[0]);
              fDomainDN = TRUE;
          }
          ldap_value_freeW(pwTemp);

          pwTemp = ldap_get_valuesW(ld, e, L"configurationNamingContext");
          if (pwTemp[0]) {
              if (ConfigDN) {
                  free(ConfigDN);
              }
              ConfigDN = MallocExit((wcslen(pwTemp[0]) + 1) * sizeof(WCHAR));
              wcscpy(ConfigDN, pwTemp[0]);
              fConfigDN = TRUE;
          }
          ldap_value_freeW(pwTemp);

          pwTemp = ldap_get_valuesW(ld, e, L"schemaNamingContext");
          if (pwTemp[0]) {
              if (SchemaDN) {
                  free(SchemaDN);
              }
              SchemaDN = MallocExit((wcslen(pwTemp[0]) + 1) * sizeof(WCHAR));
              wcscpy(SchemaDN, pwTemp[0]);
              fSchemaDN = TRUE;
          }
          ldap_value_freeW(pwTemp);
    }
    ldap_msgfree( res );
    free( attrs[0] );
    free( attrs[1] );
    free( attrs[2] );

    if ( !fDomainDN || !fConfigDN || !fSchemaDN ) {
      // One of the naming contexts were not found in the ldap read
      LogMessage(LOG_AND_PRT, MSG_SCHUPGR_MISSING_NAMING_CONTEXT, NULL, NULL);
      exit (1);
    }

    LogMessage(LOG_ONLY, MSG_SCHUPGR_NAMING_CONTEXT, DomainDN, NULL);
    LogMessage(LOG_ONLY, MSG_SCHUPGR_NAMING_CONTEXT, SchemaDN, NULL);
    LogMessage(LOG_ONLY, MSG_SCHUPGR_NAMING_CONTEXT, ConfigDN, NULL);

    // Get the schema version on the DC. if it is not found,
    // it is set to 0 (already initialized)

    attrs[0] = _wcsdup(L"objectVersion");
    attrs[1] = NULL;

    LdapErr = ldap_search_sW( ld,
                       SchemaDN,
                       LDAP_SCOPE_BASE,
                       L"(objectclass=DMD)",
                       attrs,
                       0,
                       &res );

    if ( (LdapErr != LDAP_SUCCESS) && (LdapErr != LDAP_NO_SUCH_ATTRIBUTE)) {
          LogMessage(LOG_AND_PRT, MSG_SCHUPGR_OBJ_VERSION_FAIL,
          _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
          ldap_unbind( ld );
          exit( 1 );
    }

    if (LdapErr==LDAP_NO_SUCH_ATTRIBUTE) {
       LogMessage(LOG_AND_PRT, MSG_SCHUPGR_NO_OBJ_VERSION, NULL, NULL);
    }

    // If an attribute is returned, find the value, else if no object
    // version value on schema container, we have already defaulted to 0

    if (LdapErr == LDAP_SUCCESS) {
       for ( e = ldap_first_entry( ld, res );
             e != NULL;
             e = ldap_next_entry( ld, e ) ) {

          pwTemp = ldap_get_valuesW(ld, e, L"objectVersion");
          if (pwTemp[0]) {
             VersionFrom = _wtoi( pwTemp[0]);
          }
          ldap_value_freeW(pwTemp);

       }
    }

    ldap_msgfree( res );
    free( attrs[0] );

    if (VersionFrom != 0) {
       LogMessage(LOG_AND_PRT, MSG_SCHUPGR_VERSION_FROM_INFO, 
       _itow(VersionFrom, TempStr, 10), NULL);
    }


    // find the version that they are trying to upgrade to.
    // Assumtion here is that they have ran winnt32 before this,
    // and so the schema.ini from the build they are trying to upgrade
    // to is copied in the windows directory
 
    err = GetObjVersionFromInifile(&VersionTo);
    if (err) {
       LogMessage(LOG_AND_PRT, MSG_SCHUPGR_NO_SCHEMA_VERSION,
                  _itow(err, TempStr, 10), NULL);
       ldap_unbind(ld);
       exit(1);
    }

    LogMessage(LOG_AND_PRT, MSG_SCHUPGR_VERSION_TO_INFO, 
               _itow(VersionTo, TempStr, 10), NULL);

    // If version is less than 10, and we are trying to upgrade to 10
    // or later, we cannot upgrade. Schema at version
    // 10 required a clean install
    
    if ((VersionFrom < 10) && (VersionTo >= 10)) {
       LogMessage(LOG_AND_PRT, MSG_SCHUPGR_CLEAN_INSTALL_NEEDED, NULL, NULL);
       exit(1);
    }


    // Check that all ldif files SchX.ldf (where X = VersionFrom+1 to 
    // VersionTo), exist

    // First create the prefix for all ldif files. This will be used
    // to search for the files both during DN conversion and during
    // import. so create it here. The prefix will look like
    // c:\winnt\system32\sch

    GetSystemDirectoryW(SystemDir, MAX_PATH);
    wcscat(SystemDir, L"\\");

    wcscpy(LdifFilePrefix, SystemDir);
    wcscat(LdifFilePrefix, LDIF_STRING);

    if ( err = FindLdifFiles() ) {
       // Error. Proper error message printed out by the function
       ldap_unbind( ld );
       exit (1);
    }

    // Ok, the ldif files to import from are all there  

     // Get the Schema FSMO

     pMods[0] = &Mod;
     pMods[1] = NULL;

     Mod.mod_op = LDAP_MOD_ADD;
     Mod.mod_type = _wcsdup(L"becomeSchemaMaster");
     attrs[0] = _wcsdup(L"1");
     attrs[1] = NULL;
     Mod.mod_vals.modv_strvals = attrs;

     if ( (LdapErr = ldap_modify_sW( ld, L"\0", pMods ))
                  != LDAP_SUCCESS ) {
          LogMessage(LOG_AND_PRT, MSG_SCHUPGR_FSMO_TRANSFER_ERROR,
                     _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
          ldap_unbind( ld );
          exit (1);
     }
     free(attrs[0]);
     free(pMods[0]->mod_type);

     // Check the schema version again. It is possible that the schema
     // changes were already made in the old FSMO, and the changes are
     // brought in by the FSMO transfer

     attrs[0] = _wcsdup(L"objectVersion");
     attrs[1] = NULL;

     LdapErr = ldap_search_sW( ld,
                         SchemaDN,
                         LDAP_SCOPE_BASE,
                         L"(objectclass=DMD)",
                         attrs,
                         0,
                         &res );
    if ( (LdapErr != LDAP_SUCCESS) && (LdapErr != LDAP_NO_SUCH_ATTRIBUTE)) {
           LogMessage(LOG_AND_PRT, MSG_SCHUPGR_OBJ_VERSION_RECHECK_FAIL,
                      _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
           ldap_unbind( ld );
           exit( 1 );
     }
 
     if ( LdapErr == LDAP_SUCCESS ) {
        for ( e = ldap_first_entry( ld, res );
              e != NULL;
              e = ldap_next_entry( ld, e ) ) {

            pwTemp = ldap_get_valuesW(ld, e, L"objectVersion");
            if (pwTemp[0]) {
               NewSchVersion = _wtoi( pwTemp[0]);
            }
            ldap_value_freeW(pwTemp);
        }
     }

     ldap_msgfree( res );
     free(attrs[0]);

     if (NewSchVersion == VersionTo) {
         // The schema already changed and the schema changes were
         // brought in by the FSMO transfer
          LogMessage(LOG_AND_PRT, MSG_SCHUPGR_RECHECK_OK, NULL, NULL);
          ldap_unbind(ld);
          exit (0);
      }
      else {
        if (NewSchVersion != VersionFrom) {
          // some changes were brought in, what to do? For now,
          // I will start from NewSchVersion
          // This is because the source has changes at least up to
          // NewSchVersion, and since we have done a FSMO transfer,
          // it has brought in the most uptodate schema

          VersionFrom = NewSchVersion;
        }
      }

    // Tell the AD that a schema upgrade is in progess

    pMods[0] = &Mod;
    pMods[1] = NULL;

    Mod.mod_op = LDAP_MOD_ADD;
    Mod.mod_type = _wcsdup(L"SchemaUpgradeInProgress");
    attrs[0] = _wcsdup(L"1");
    attrs[1] = NULL;
    Mod.mod_vals.modv_strvals = attrs;

    if ( (LdapErr = ldap_modify_sW( ld, L"\0", pMods ))
                 != LDAP_SUCCESS ) {
         LogMessage(LOG_AND_PRT, MSG_SCHUPGR_REQUEST_SCHEMA_UPGRADE,
                    _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
         ldap_unbind( ld );
         exit (1);
    }
    free(attrs[0]);
    free(pMods[0]->mod_type);


    // From here on, we do things in try-finally block, so that anything
    // happens we will still reset schema-upgrade mode

    __try {

       // Everything is set. Now Import

       FILE *errfp;
       
       // Create the error file name. Only way to check if
       // ldifde failed or not. ldifde creates the error file
       // in the current directory, so thats where we will look

       wcscpy(LdifErrFile,L"ldif.err");

       // Now do the imports from the ldif files

       for ( i=VersionFrom+1; i<=VersionTo; i++) {

           _itow( i, VersionStr, 10 );

           // create the file name to import
           wcscpy( NewFile, LdifFilePrefix );
           wcscat( NewFile, VersionStr );
           wcscat( NewFile, LDIF_SUFFIX);

           // Create the command line first. 
           wcscpy( CommandLine, SystemDir);
           wcscat( CommandLine, L"ldifde -i -f " );
           wcscat( CommandLine, NewFile );
           wcscat( CommandLine, L" -s ");
           wcscat( CommandLine, ServerName );
           wcscat( CommandLine, L" -c " );
           // We assume all DNs areterminated with DC=X where the root domain
           // DN need to be put in
           wcscat( CommandLine, L"DC=X " );
           wcscat( CommandLine, DomainDN );

           LogMessage(LOG_ONLY, MSG_SCHUPGR_COMMAND_LINE, CommandLine, NULL);
           memset(&startInf, 0, sizeof(startInf));
           startInf.cb = sizeof(startInf);

           // now call ldifde to actually do the import

           // Delete any earlier ldif error file
           DeleteFileW(LdifErrFile);
   
           CreateProcessW(NULL,
                         CommandLine, NULL,NULL,0,0,NULL,NULL,&startInf,&procInf);
   
           // Make the calling process wait for lidifde to finish import

           if ( WaitForSingleObject( procInf.hProcess, INFINITE )
                     == WAIT_FAILED ) {
              err = GetLastError();
              LogMessage(LOG_AND_PRT, MSG_SCHUPGR_LDIFDE_WAIT_ERROR,
                         _itow(err, TempStr, 10), NULL);
              CloseHandle(procInf.hProcess);
              CloseHandle(procInf.hThread);
              __leave;
           }
           CloseHandle(procInf.hProcess);
           CloseHandle(procInf.hThread);

           // ok, ldifde fninished. 

           // First save the log file

           wcscpy(LdifLogFile,L"ldif.log.");
           _itow( StartLdifLog, LdifLogStr, 10 );
           wcscat(LdifLogFile,LdifLogStr);
           CopyFileW(L"ldif.log",LdifLogFile, FALSE);
           StartLdifLog++;

           // Check if an error file is created.
           // Bail out in that case

           errfp = NULL;
           if ( (errfp = _wfopen(LdifErrFile,L"r")) != NULL) {
              // file opened successfully, so there is an error
              // Bail out

              fclose(errfp);
              wcscpy(RenamedFile,L"ldif.err.");
              wcscat(RenamedFile,VersionStr);
              LogMessage(LOG_AND_PRT, MSG_SCHUPGR_IMPORT_ERROR, NewFile, RenamedFile);
              CopyFileW(L"ldif.err",RenamedFile,FALSE);
              break;
           }
              
 
       } /* for */
    }
    __finally {

        // Tell the AD that a schema upgrade is no longer in progess

        pMods[0] = &Mod;
        pMods[1] = NULL;

        Mod.mod_op = LDAP_MOD_ADD;
        Mod.mod_type = _wcsdup(L"SchemaUpgradeInProgress");
        attrs[0] = _wcsdup(L"0");
        attrs[1] = NULL;
        Mod.mod_vals.modv_strvals = attrs;

        if ( (LdapErr = ldap_modify_sW( ld, L"\0", pMods ))
                     != LDAP_SUCCESS ) {
             LogMessage(LOG_AND_PRT, MSG_SCHUPGR_REQUEST_SCHEMA_UPGRADE,
                        _itow(LdapErr, TempStr, 10), LdapErrToStr(LdapErr));
             ldap_unbind( ld );
             exit (1);
        }
        free(attrs[0]);
        free(pMods[0]->mod_type);

        ldap_unbind( ld );

        free(ServerName);
        free(DomainDN);
        free(ConfigDN);
        free(SchemaDN);
    }
}

//////////////////////////////////////////////////////////////////////
//
// Routine Decsription:
//
//     Reads the objectVersion key in the SCHEMA section of the
//     schema.ini file and returns the value in *Version. If the
//     key cannot be read, 0 is returned in *Version
//     The schema.ini file is used is the one in windows directory,
//     the assumption being that winnt32 is run before this is run,
//     which would copy the schema.ini from the build we are trying
//     to upgrade to to the windows directory
//
// Arguments:
//     Version - Pointer to DWORD to return version in
// 
// Return Value:
//     0
// 
///////////////////////////////////////////////////////////////////////

DWORD GetObjVersionFromInifile(int *Version)
{
    DWORD nChars;
    char Buffer[32];
    char IniFileName[MAX_PATH] = "";
    BOOL fFound = FALSE;

    char  *SCHEMASECTION = "SCHEMA";
    char  *OBJECTVER = "objectVersion";
    char  *DEFAULT = "NOT_FOUND";


    // form the file name. It will look like c:\winnt\schema.ini
    // Windows directory is where winnt32 copies the latest schema.ini
    // to
    nChars = GetWindowsDirectoryA(IniFileName, MAX_PATH);
    if (nChars == 0 || nChars > MAX_PATH) {
        return GetLastError();
    }
    strcat(IniFileName,"\\schema.ini");

    *Version = 0;

    GetPrivateProfileStringA(
        SCHEMASECTION,
        OBJECTVER,
        DEFAULT,
        Buffer,
        sizeof(Buffer)/sizeof(char),
        IniFileName
        );

    if ( _stricmp(Buffer, DEFAULT) ) {
         // Not the default string, so got a value
         *Version = atoi(Buffer);
         fFound = TRUE;
    }

    if (fFound) {
       return 0;
    }
    else {
       // schema.ini we are looking at must have a version, since
       // we are upgrading to it. This part also catches errors like
       // the file is not there in the windows directory for some reason
       return 1;
    }
}


//////////////////////////////////////////////////////////////////////
// 
// Routine Description:
//
//     Helper file to open the correct ldif file, convert DNs in it
//     to conform to current domain, and write it out to a new file
//
// Arguments:
//
//     Version - Schema version on DC
//     pDomainDN - Pointer to Domain DN string
//     pConfigDN - Pointer to config DN string
//     pNewFile  - Pointer to space to write the new filename to
//                 (must be already allocated)
//
// Return Value:
//
//     0 on success, non-0 on error
//
//////////////////////////////////////////////////////////////////////

DWORD 
FindLdifFiles()
{
    WCHAR VersionStr[100]; // Not more than 99 digits for schema version!! 
    FILE  *fInp;
    int   i;
    WCHAR FileName[MAX_PATH];

    // Create the input ldif file name from the schema version no.
    // The file name is Sch(Version).ldf

    for ( i=VersionFrom+1; i<=VersionTo; i++ ) {
       
        wcscpy( FileName, LdifFilePrefix);

        // use version no. to find suffix
        _itow( i, VersionStr, 10 );
        wcscat( FileName, VersionStr );
        wcscat( FileName, LDIF_SUFFIX);
    
        if ( (fInp = _wfopen(FileName, L"r")) == NULL) {
           LogMessage(LOG_AND_PRT, MSG_SCHUPGR_MISSING_LDIF_FILE, FileName, NULL);
           return UPG_ERROR_CANNOT_OPEN_FILE;
        }
        fclose(fInp);
    }
    return 0;
}

PVOID
MallocExit(DWORD nBytes)
{
    PVOID  pRet;

    pRet = malloc(nBytes);
    if (!pRet) {
        LogMessage(LOG_AND_PRT, MSG_SCHUPGR_MEMORY_ERROR,
                   NULL, NULL);
        exit (1);
    }

    return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\tapicfg\ilsng.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ndnc.h

Abstract:

    This module defines the main helping functions for TAPI
    dynamic directories (aka ILSNG).

Author:

    Brett Shirley (BrettSh) 20-Feb-2000

Revision History:

    21-Jul-2000     BrettSh
        
        Moved this file and it's functionality from the ntdsutil
        directory to the new tapicfg utility.  The old source 
        location: \nt\ds\ds\src\util\ntdsutil\ilsng.h.                                    
                                    
--*/
#ifdef __cplusplus
extern "C" {
#endif

// ----------------------------------
// Common Utility Functions

ULONG
GetRootAttr(
    IN      LDAP *       hld,
    IN      WCHAR *      wszAttr,
    OUT     WCHAR **     pwszOut
    );

DWORD
GetDnFromDns(
    IN      WCHAR *       wszDns,
    OUT     WCHAR **      pwszDn
    );

DWORD
ILSNG_EnumerateSCPs(
    IN      LDAP *       hld,
    IN      WCHAR *      wszRootDn,
    IN      WCHAR *      wszExtendedFilter,
    OUT     DWORD *      pdwRet,                         // Return Value
    IN      DWORD (__stdcall * pFunc) (),  // Function
    IN OUT  PVOID        pArgs                           // Argument
    );

// ----------------------------------
// Main Worker Functions.

DWORD
InstallILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn,
    IN      BOOL          fForceDefault,
    IN      BOOL          fAllowReplicas
    );

DWORD
UninstallILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn
    );

DWORD
ListILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszDomainDn,
    IN      BOOL          fDefaultOnly
    );

DWORD
ReregisterILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn,
    IN      WCHAR *       wszDomainDn
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\tapicfg\print.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    print.c

ABSTRACT:

DETAILS:

CREATED:

    1999 May 6  JeffParh
        Lifted from netdiag\results.c.

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <assert.h>

static WCHAR s_szBuffer[4096];
static WCHAR s_szFormat[4096];
static WCHAR s_szSpaces[] = 
    L"                                                                                               ";

#ifndef DimensionOf
#define DimensionOf(x) (sizeof(x)/sizeof((x)[0]))
#endif

void PrintMessageSz(LPCWSTR pszMessage);

void
PrintMessage(
    IN  ULONG   uMessageID,
    IN  ...
    )

/*++

Routine Description:

Print a message, where a printf-style format string comes from a resource file

Arguments:

    uMessageID - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    va_list args;
    
    DWORD dwRet;

    va_start(args, uMessageID);
    
    dwRet = LoadStringW(NULL, uMessageID, s_szFormat, DimensionOf(s_szFormat));
    
    nBuf = vswprintf(s_szBuffer, s_szFormat, args);
    assert(nBuf < DimensionOf(s_szBuffer));
    
    va_end(args);
    
    PrintMessageSz(s_szBuffer);
} /* PrintMessageID */

void
PrintMessageMultiLine(
    IN  LPWSTR   pszMessage,
    IN  BOOL     bTrailingLineReturn
    )
/*++

Routine Description:

Take a multi-line buffer such as
line\nline\nline\n\0
and call PrintMessageSz on each line

Arguments:

    pszMessage - 

Return Value:

--*/

{
    LPWSTR start, end;
    WCHAR wchSave;

    start = end = pszMessage;
    while (1) {
        while ( (*end != L'\n') && (*end != L'\0') ) {
            end++;
        }

        if (*end == L'\0') {
            // Line ends prematurely, give it a nl
            if(bTrailingLineReturn){
                *end++ = L'\n';
                *end = L'\0';
            }
            PrintMessageSz(start);
            break;
        }

        // Line has newline at end
        end++;
        if (*end == L'\0') {
            // Is the last line
            PrintMessageSz(start);
            break;
        }

        // Next line follows
        // Simulate line termination temporarily
        wchSave = *end;
        *end = L'\0';
        PrintMessageSz(start);
        *end = wchSave;

        start = end;
    }
} /* PrintMessageMultiLine */

void
formatMsgHelp(
    IN  DWORD   dwWidth,
    IN  DWORD   dwMessageCode,
    IN  va_list *vaArgList
    )

/*++

Routine Description:

Print a message where the format comes from a message file. The message in the
message file does not use printf-style formatting. Use %1, %2, etc for each
argument. Use %<arg>!printf-format! for non string inserts.

Note that this routine also forces each line to be the current indention width.
Also, each line is printed at the right indentation.

Arguments:

    dwWidth - 
    dwMessageCode - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    
    // Format message will store a multi-line message in the buffer
    nBuf = FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE | dwWidth,
        0,
        dwMessageCode,
        0,
        s_szBuffer,
        DimensionOf(s_szBuffer),
        vaArgList );
    if (nBuf == 0) {
        nBuf = wsprintf( (LPTSTR) s_szBuffer, (LPCTSTR) L"Message 0x%x not found.\n",
                         dwMessageCode );
        assert(!"There is a message constant being used in the code"
               "that isn't in the message file dcdiag\\common\\msg.mc"
               "Take a stack trace and send to owner of dcdiag.");
    }
    assert(nBuf < DimensionOf(s_szBuffer));
} /* PrintMsgHelp */

void
PrintMsg(
    IN  DWORD   dwMessageCode,
    IN  ...
    )

/*++

Routine Description:

Wrapper around PrintMsgHelp with width restrictions.
This is the usual routine to use.

Arguments:

    dwMessageCode - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    DWORD width = 80; 
    va_list args;
    
    va_start(args, dwMessageCode);
    formatMsgHelp( width, dwMessageCode, &args );
    va_end(args);
    
    PrintMessageMultiLine( s_szBuffer, TRUE);

} /* PrintMsg */

void
PrintMessageSz(
    IN  LPCWSTR pszMessage
    )

/*++

Routine Description:

Print a single indented line from a buffer to the output stream

Arguments:

    pszMessage - 

Return Value:

--*/

{
    wprintf(L"%s", pszMessage);
    fflush(stdout);
} /* PrintMessageSz */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\tapicfg\print.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    print.h

Abstract:

    This module tells us about the print library from print.c

Author:

    Brett Shirley (BrettSh) 25-Jul-2000

Revision History:

--*/
#ifdef __cplusplus
extern "C" {
#endif

void     PrintMsg(DWORD dwMessageCode, ...);

#ifdef __cplusplus
}
#endif

#include "msg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\setpwd\main.c ===
/*++

Copyright (C) Microsoft Corporation, 2000.
              Microsoft Windows

Module Name:

    Main.C

Abstract:

    This file sets the Directory Service Restore Mode 
    Administrator Account Password

Author:

    08-01-00 ShaoYin

Environment:

    User Mode - Win32

Revision History:

    08-01-00 ShaoYin Created Initial File.

--*/


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//    Include header files                                              //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


#include <NTDSpch.h>
#pragma  hdrstop

#include <locale.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <ntsamp.h>
#include <lmcons.h>

#define MAX_NT_PASSWORD     PWLEN + 1

#define DLL_NAME            L"SAMLIB.DLL"
#define PROC_NAME           "SamiSetDSRMPassword"


#define CR                  0xD
#define BACKSPACE           0x8


VOID
PrintHelp()
{
    printf("Reset Directory Service Restore Mode Administrator Account Password.\n\n");
    printf("SETPWD.EXE [/s:<server>]\n");
    printf("\n");
    printf("    /s:<server> - Name of the server to use. Optional.\n");
    printf("\n");
    printf("See Microsoft Knowledge Base article Q271641 at\n");
    printf("http://support.microsoft.com for more information.\n");

    return;
}


ULONG
GetPasswordFromConsole(
    IN OUT PWCHAR Buffer, 
    IN USHORT BufferLength
    )
{
    ULONG       WinError = NO_ERROR;
    BOOL        Success;
    WCHAR       CurrentChar;
    WCHAR       *CurrentBufPtr = Buffer; 
    HANDLE      InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    DWORD       OriginalMode = 0;
    DWORD       Length = 0;
    DWORD       Read = 0;



    //
    // Always leave one WCHAR for NULL terminator
    //
    BufferLength --;  

    //
    // Change the console setting. Disable echo input
    // 
    GetConsoleMode(InputHandle, &OriginalMode);
    SetConsoleMode(InputHandle, 
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & OriginalMode);

    while (TRUE)
    {
        CurrentChar = 0;
        //
        // ReadConsole return NULL if failed
        // 
        Success = ReadConsoleW(InputHandle, 
                               &CurrentChar, 
                               1, 
                               &Read, 
                               NULL
                               );
        if (!Success)
        {
            WinError = GetLastError();
            break;
        }

        if ((CR == CurrentChar) || (1 != Read))   // end of the line 0xd
            break;

        if (BACKSPACE == CurrentChar)             // back up one or two 0x8
        {
            if (Buffer != CurrentBufPtr)
            {
                CurrentBufPtr--;
                Length--;
            }
        }
        else
        {
            if (Length == BufferLength)
            {
                printf("\nInvalid password - exceeds password length limit.\n"); 
                WinError = ERROR_PASSWORD_RESTRICTION;
                break;
            }
            *CurrentBufPtr = CurrentChar;
            CurrentBufPtr++;
            Length++;
        }
    }

    SetConsoleMode(InputHandle, OriginalMode);
    *CurrentBufPtr = L'\0';
    putchar(L'\n');


    return( WinError );
}





void
__cdecl wmain(
    int      cArgs, 
    LPWSTR * pArgs
    )
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    ULONG           WinError = NO_ERROR;
    WCHAR           Password[MAX_NT_PASSWORD];
    UNICODE_STRING  ServerName;
    UNICODE_STRING  ClearPassword;
    UNICODE_STRING  *pServerName = NULL; 


    // set locale to the default
    setlocale(LC_ALL,"");

    if (1 == cArgs)
    {
        pServerName = NULL;
    }
    else if (2 == cArgs)
    {
        //
        // get server name to use
        // 
        if ((wcslen(pArgs[1]) > 3) &&
            ((!_wcsnicmp(pArgs[1], L"-s:", 3)) || (!_wcsnicmp(pArgs[1], L"/s:", 3)))
            )
        {
            RtlInitUnicodeString(&ServerName, pArgs[1]+3);
            pServerName = &ServerName;
        }
        else
        {
            PrintHelp();
            exit( 1 );
        }
    }
    else
    {
        PrintHelp();
        exit( 1 );
    }


    printf("Please type password for DS Restore Mode Administrator Account:\n");

    //
    // get password from standard input
    // 
    memset(Password, 0, MAX_NT_PASSWORD);

    WinError = GetPasswordFromConsole(Password, 
                                      MAX_NT_PASSWORD
                                      ); 

    if (NO_ERROR == WinError)
    {
        HMODULE SamLibModule;
        FARPROC SetPasswordProc = NULL;


        RtlInitUnicodeString(&ClearPassword, Password);

        //
        // invoke SAM RPC
        // 
        SamLibModule = (HMODULE) LoadLibraryW(DLL_NAME);

        if (SamLibModule)
        {
            SetPasswordProc = GetProcAddress(SamLibModule, PROC_NAME);

            if (SetPasswordProc)
            {
                NtStatus = SetPasswordProc(pServerName,
                                           DOMAIN_USER_RID_ADMIN,
                                           &ClearPassword
                                           );

                WinError = RtlNtStatusToDosError(NtStatus);
            }
            else
            {
                WinError = GetLastError();
            }
        }
        else
        {
            WinError = GetLastError();
        }
    }


    //
    // zero out clear text password
    // 
    memset(Password, 0, MAX_NT_PASSWORD);


    if (NO_ERROR == WinError)
    {
        printf("Password has been set successfully.\n");
        exit( 0 );
    }
    else
    {
        PWCHAR      ErrorMessage = NULL;

        FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |     // find message from system resource table
                       FORMAT_MESSAGE_IGNORE_INSERTS |  // do not insert
                       FORMAT_MESSAGE_ALLOCATE_BUFFER,  // please allocate buffer for me
                       NULL,                            // source dll (NULL for system)
                       WinError,                        // message ID
                       0,                               // Language ID
                       (LPWSTR)&ErrorMessage,           // address of output
                       0,                               // maxium buffer size if not 0
                       NULL                             // can not insert message
                       );

        printf("Setting password failed.\n");
        printf("    Win32 Error Code: 0x%x\n", WinError);
        printf("    Error Message   : %ls\n", ErrorMessage);

        printf("See Microsoft Knowledge Base article Q271641 at\n");
        printf("http://support.microsoft.com for more information.\n");

        if (NULL != ErrorMessage) {
            LocalFree(ErrorMessage); 
        }

        exit( 1 );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\tapicfg\ilsng.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ilsng.c

Abstract:

    This module contains the install code for the next generation ils
    service, which is a just it's own naming context created in the
    Active Directory, along with a few special service objects.

Author:

    Brett Shirley (BrettSh)

Environment:

    User Mode.

Revision History:

    15-Mar-2000     BrettSh

        Added support for Non-Domain Naming Contexts.

    21-Jul-2000     BrettSh
        
        Moved this file and it's functionality from the ntdsutil
        directory to the new tapicfg utility.  The old source 
        location: \nt\ds\ds\src\util\ntdsutil\ilsng.c.                                    
                                                            
--*/


 
#include <NTDSpch.h>
#pragma hdrstop

#include <winldap.h>
#include <ntldap.h>
#include <assert.h>
#include <sddl.h>

#ifndef DimensionOf
#define DimensionOf(x) (sizeof(x)/sizeof((x)[0]))
#endif

// The Non-Domain Naming Context (NDNC) routines are in a different file, 
// and a whole different library, for two reasons:
// A) So this file can be ported to the Platform SDK as an example of how to 
//    implement NDNCs programmatically.
// B) So that the utility ntdsutil.exe, could make use of the same routines.
#include <ndnc.h>

#include "ilsng.h"

#include "print.h"

// --------------------------------------------------------------------------
//
// ILSNG/TAPI Directory constants.
//


// This should be probably moved to some much better header file?
#define TAPI_DIRECTORY_GUID L"a57ef962-0367-4a5d-a6a9-a48ea236ea12"

// old ACLs that allowed anonymous user's allowed to create rt-person/conf 
// objects, and anonymous users to view the SCPs.
//#define ILS_DYNAMIC_CONTAINER_SD   L"O:DAG:DAD:(A;;RPCCLC;;;WD)(A;;GA;;;DA)"
//#define TAPI_SERVICE_CONTAINER_SD  L"O:DAG:DAD:(A;;RPLCLORC;;;WD)(A;;GA;;;DA)"
//#define TAPI_SERVICE_OBJECTS_SD    L"O:DAG:DAD:(A;;RPRC;;;WD)(A;;GA;;;DA)"

// Beta 2 - We'll continue to allow anonymous read access, but disallow all
// anonymous write access.  Note the SCP SDs didn't need to change at all.
//#define ILS_DYNAMIC_CONTAINER_SD   L"O:DAG:DAD:(A;;RPCCLC;;;AU)(A;;RPLC;;;WD)(A;;GA;;;DA)"

// Beta 3 - No anonymous read or write access, must always use
// an authenticated user.
#define ILS_DYNAMIC_CONTAINER_SD   L"O:DAG:DAD:(A;;RPCCLC;;;AU)(A;;GA;;;DA)"
#define TAPI_SERVICE_CONTAINER_SD  L"O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;GA;;;DA)"
#define TAPI_SERVICE_OBJECTS_SD    L"O:DAG:DAD:(A;;RPRC;;;AU)(A;;GA;;;DA)"


#define DEFAULT_STR_SD   L"O:DAG:DAD:(A;;GA;;;AU)"

// --------------------------------------------------------------------------
//
// Helper Routines.
//

// These routines are not specific to ILSNG, TAPI Directories, they're just
// darn usefaul

DWORD
CreateOneObject(
    LDAP *           hldDC,
    WCHAR *          wszDN,
    WCHAR *          wszObjectClass,
    WCHAR *          wszStrSD,
    WCHAR **         pwszAttArr
    )
/*++

    
       
EXAMPLE: Calling CreateOneObject() w/ a correctly formated pwszAttArr.
    
    WCHAR *     pwszAttsAndVals[] = {
        // Note first string on each line is type, all other strings up to
        // the NULL are the values fro that type.
        L"ou", L"Dynamic", NULL,
        L"businessCategory", L"Widgets", L"Gizmos", L"Gadgets", NULL,
        NULL } ;
    CreateOneObject(hld, 
                    L"CN=Dynamic,DC=microsoft,DC=com",
                    L"organizationalUnit", 
                    L"O:DAG:DAD:A;;RPWPCRCCDCLCLOLORCWOWDSDDTDTSW;;;DA)(A;;RP;;;AU)
                    pwszAttsAndVals);
                           
--*/
{ 
#define   MemPanicChk(x)   if(x == NULL){ \
                               ulRet = LDAP_NO_MEMORY; \
                               __leave; \
                           }
    ULONG                  ulRet = LDAP_SUCCESS;

    LDAPModW **            paMod = NULL;
    ULONG                  iStr, iAtt, iVal;
    ULONG                  cAtt, cVal;
    // Some special stuff for the Security Descriptor (SD).
    ULONG                  iAttSD;
    LDAP_BERVAL            bervalSD = { 0, NULL };
    PSECURITY_DESCRIPTOR   pSD = NULL;
    ULONG                  cSD = 0;

    assert(hldDC);
    assert(wszDN);
    assert(wszObjectClass);

    __try{

        // First we'll do the optional attributes, because it makes the
        // indexing attributes work out much much better, in the end.
        // First lets count up the number of Attributes
        cAtt = 0;
        iAtt = 0;
        if(pwszAttArr != NULL){
            while(pwszAttArr[iAtt] != NULL){
                
                iAtt++;
                assert(pwszAttArr[iAtt]); // Need at least one value per attr.

                while(pwszAttArr[iAtt] != NULL){
                    // Run through all the attribute and all its values.
                    iAtt++;
                }

                // Finnished a single attribute, goto next attr
                iAtt++;
                cAtt++;
            }
        }


        // Allocate a LDAPMod pointer array for all the attribute elements
        // plus 3 extra, 1 for the NULL terminator, 1 for the objectClass,
        // and one more for the optional SD.
        paMod = (LDAPModW **) LocalAlloc(LMEM_FIXED, sizeof(LDAPModW *)
                                                          * (cAtt + 3));
        MemPanicChk(paMod);
        
        iStr = 0; // This is the index for pwszAttArr[].
        for(iAtt = 0; iAtt < cAtt; iAtt++, iStr++){

            assert(pwszAttArr[iAtt]);
            assert(pwszAttArr[iVal]);


            // Lets allocate a LDAPMod structure for this attribute.
            paMod[iAtt] = (LDAPModW *) LocalAlloc(LMEM_FIXED, sizeof(LDAPModW));
            MemPanicChk(paMod[iAtt]);
            

            // Lets set the LDAPMod structure and allocate a value
            // array for all the values + 1 for the NULL terminator.
            paMod[iAtt]->mod_op = LDAP_MOD_ADD;
            paMod[iAtt]->mod_type = pwszAttArr[iStr];
            // Lets count up the number of values for this one attr
            cVal = 0;
            iStr++; // We want to increment iStr to the first val.
            while(pwszAttArr[iStr + cVal] != NULL){
                cVal++;
            }
            paMod[iAtt]->mod_vals.modv_strvals = (WCHAR **) LocalAlloc(
                                LMEM_FIXED, sizeof(WCHAR *) * (cVal + 1));
            MemPanicChk(paMod[iAtt]->mod_vals.modv_strvals);
                                

            // Now fill in each of the values in the value array.
            for(iVal = 0; iVal < cVal; iVal++, iStr++){
                paMod[iAtt]->mod_vals.modv_strvals[iVal] = pwszAttArr[iStr];
            }
            // We want to NULL terminate the value array.
            paMod[iAtt]->mod_vals.modv_strvals[iVal] = NULL;
            assert(pwszAttArr[iStr] == NULL);
            
            // Last value should be NULL.
            assert(paMod[iAtt]->mod_vals.modv_strvals[cVal] == NULL);
        }

        // Now setup the default attributes, like objectClass and SD.
        // We do objectClass, because it is required, and we do the 
        // SD, b/c it's binary and so it's special.

        // Setup the object class, which is basically the type.
        paMod[iAtt] = (LDAPModW *) LocalAlloc(LMEM_FIXED, sizeof(LDAPModW));
        MemPanicChk(paMod[iAtt]);

        paMod[iAtt]->mod_op = LDAP_MOD_ADD;
        paMod[iAtt]->mod_type = L"objectClass";
        paMod[iAtt]->mod_vals.modv_strvals = (WCHAR **) LocalAlloc(
                                    LMEM_FIXED, sizeof(WCHAR *) * 2);
        MemPanicChk(paMod[iAtt]->mod_vals.modv_strvals);
        paMod[iAtt]->mod_vals.modv_strvals[0] = wszObjectClass;
        paMod[iAtt]->mod_vals.modv_strvals[1] = NULL;
        iAtt++;

        // Setup the optional security descriptor 
        if(wszStrSD != NULL){
            iAttSD = iAtt;
            if(!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                (wszStrSD) ? 
                    wszStrSD :
                    DEFAULT_STR_SD,
                SDDL_REVISION_1,
                &pSD,
                &cSD)){
                ulRet = GetLastError();  // Put this in ulRet, so programmer could g to
                // end of function and see the error code if he wanted.
                assert(!"Programmer supplied invalid SD string to CreateOneObject()\n");
                __leave;
            }
            assert(cSD != 0);

            paMod[iAtt] = (LDAPModW *) LocalAlloc(LMEM_FIXED, sizeof(LDAPModW));
            MemPanicChk(paMod[iAtt]);

            paMod[iAtt]->mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
            paMod[iAtt]->mod_type = L"nTSecurityDescriptor";
            paMod[iAtt]->mod_vals.modv_bvals = (BERVAL **) LocalAlloc(
                                        LMEM_FIXED, sizeof(LDAP_BERVAL *) * 2);
            MemPanicChk(paMod[iAtt]->mod_vals.modv_bvals);
            paMod[iAtt]->mod_vals.modv_bvals[0] = &bervalSD;
            paMod[iAtt]->mod_vals.modv_bvals[0]->bv_len = cSD;
            paMod[iAtt]->mod_vals.modv_bvals[0]->bv_val = (CHAR *) pSD;
            paMod[iAtt]->mod_vals.modv_bvals[1] = NULL;
            iAtt++;
        }
        
        // Need to NULL terminate the LDAPMod array.
        paMod[iAtt] = NULL;

        // Finally ...
        // Adding and object to the DS.
        ulRet = ldap_add_sW(hldDC,
                            wszDN,
                            paMod);

        if (LDAP_SUCCESS != ulRet) {
            // Let the error fall through.
        }
    } __finally {

        // Just checking that the BERVAL and STRVALs are at the same
        // address, lower our de-allocation depends on this assumption.
        assert(paMod[iAtt]->mod_vals.modv_strvals == paMod[iAtt]->mod_vals.modv_bvals);

        if(pSD){
            LocalFree(pSD);
        }
            
        iAtt = 0;
        if(paMod){
            while(paMod[iAtt]){
                if(paMod[iAtt]->mod_vals.modv_strvals){
                    // Note we can do this on the binary SD, because the
                    // LDAPMod structure is a union for modv_strvals and
                    // modv_bvals.
                    LocalFree(paMod[iAtt]->mod_vals.modv_strvals);
                }
                LocalFree(paMod[iAtt]);
                iAtt++;
            }
            LocalFree(paMod);
        }
    }

    return(ulRet);
}


WCHAR * 
CatAndAllocStrsW(
    WCHAR *        wszS1,
    WCHAR *        wszS2
    )
{
    WCHAR *        wszDst;

    wszDst = (WCHAR *) LocalAlloc(LMEM_FIXED, (wcslen(wszS1) + wcslen(wszS2) + 2) * sizeof(WCHAR));
    if(!wszDst){
        // No memory.
        return(NULL);
    }
    wcscpy(wszDst, wszS1);
    wcscat(wszDst, wszS2);

    return(wszDst);
}

DWORD
ReadWellKnownObject (
        LDAP  *ld,
        WCHAR *pHostObject,
        WCHAR *pWellKnownGuid,
        WCHAR **ppObjName
        )
{
    DWORD        dwErr;
    PWSTR        attrs[2];
    PLDAPMessage res, e;
    WCHAR       *pSearchBase;
    WCHAR       *pDN=NULL;
    
    // First, make the well known guid string
    pSearchBase = (WCHAR *)malloc(sizeof(WCHAR) * (11 +
                                                   wcslen(pHostObject) +
                                                   wcslen(pWellKnownGuid)));
    if(!pSearchBase) {
        return(LDAP_NO_MEMORY);
    }
    wsprintfW(pSearchBase,L"<WKGUID=%s,%s>",pWellKnownGuid,pHostObject);

    attrs[0] = L"1.1";
    attrs[1] = NULL;
    
    if ( LDAP_SUCCESS != (dwErr = ldap_search_sW(
            ld,
            pSearchBase,
            LDAP_SCOPE_BASE,
            L"(objectClass=*)",
            attrs,
            0,
            &res)) )
    {
        free(pSearchBase);
        return(dwErr);
    }
    free(pSearchBase);
    
    // OK, now, get the dsname from the return value.
    e = ldap_first_entry(ld, res);
    if(!e) {
        return(LDAP_NO_SUCH_ATTRIBUTE);
    }
    pDN = ldap_get_dnW(ld, e);
    if(!pDN) {
        return(LDAP_NO_SUCH_ATTRIBUTE);
    }

    *ppObjName = (PWCHAR)malloc(sizeof(WCHAR) *(wcslen(pDN) + 1));
    if(!*ppObjName) {
        return(LDAP_NO_MEMORY);
    }
    wcscpy(*ppObjName, pDN);
    
    ldap_memfreeW(pDN);
    ldap_msgfree(res);
    return 0;
}

ULONG
GetSystemDN(
    IN  LDAP *       hld,
    IN  WCHAR *      wszDomainDn,
    OUT WCHAR **     pwszSystemDn
    )
{
    ULONG            ulRet = LDAP_SUCCESS;
    WCHAR *          wszSystemDn = NULL;
    WCHAR *          wszRootDomainDn = NULL;

    assert(pwszPartitionsDn);                     

    *pwszSystemDn = NULL;
    
    if(wszDomainDn == NULL){
        ulRet = GetRootAttr(hld,
                            LDAP_OPATT_ROOT_DOMAIN_NAMING_CONTEXT_W,
                            &wszRootDomainDn);
        if(ulRet){
            return(ulRet);
        }
        // This is the default if no domain is supplied.
        wszDomainDn = wszRootDomainDn;
    }

    if(ReadWellKnownObject(hld,
                           wszDomainDn,
                           GUID_SYSTEMS_CONTAINER_W,
                           &wszSystemDn)){
        // Signal error.
        if(wszRootDomainDn) { LocalFree(wszRootDomainDn); }
        return(LDAP_NO_SUCH_ATTRIBUTE);
    }

    *pwszSystemDn = (WCHAR *) LocalAlloc(LMEM_FIXED, 
                                sizeof(WCHAR) * (wcslen(wszSystemDn) + 2));
    if(*pwszSystemDn == NULL){
        if(wszRootDomainDn) { LocalFree(wszRootDomainDn); }
        if(wszSystemDn) { free(wszSystemDn); }
        return(LDAP_NO_MEMORY);
    }

    wcscpy(*pwszSystemDn, wszSystemDn);
        
    if(wszRootDomainDn != NULL){ LocalFree(wszRootDomainDn); }
    if(wszSystemDn != NULL) { free(wszSystemDn); }

    return(ulRet);
}

WCHAR * 
SuperCatAndAllocStrsW(
    IN      WCHAR **        pawszStrings
    )
{
    ULONG          cStrLen = 0;
    ULONG          iStr = 0;
    WCHAR *        wszRes;

    assert(pawszStrings);
    assert(pawszStrings[0]); // Whats the point.


    // Count all the strings.
    while(pawszStrings[iStr] != NULL){
        cStrLen += wcslen(pawszStrings[iStr]);
        iStr++;
    }
    cStrLen += 1; // We want a NULL char don't we! ;)
    cStrLen *= sizeof(WCHAR); // We want it in WCHARs too.

    wszRes = (WCHAR *) LocalAlloc(LMEM_FIXED, cStrLen);
    if(!wszRes){
        return(NULL);
    }

    wcscpy(wszRes, pawszStrings[0]);

    iStr = 1;
    while(pawszStrings[iStr] != NULL){
        wcscat(wszRes, pawszStrings[iStr]);
        iStr++;
    }

    return(wszRes);
}

DWORD
GetDnFromDns(
    IN      WCHAR *       wszDns,
    OUT     WCHAR **      pwszDn
    )
{
    DWORD         dwRet = ERROR_SUCCESS;
    WCHAR *       wszFinalDns = NULL;
    DS_NAME_RESULTW *  pdsNameRes = NULL;

    assert(wszDns);
    assert(pwszDn);

    *pwszDn = NULL;

    __try{ 
        wszFinalDns = (WCHAR *) LocalAlloc(LMEM_FIXED, 
                                  (wcslen(wszDns) + 3) * sizeof(WCHAR));
        if(wszFinalDns == NULL){
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }
        wcscpy(wszFinalDns, wszDns);
        wcscat(wszFinalDns, L"/");

        // the wszILSDN parameter.  DsCrackNames to the rescue.
        dwRet = DsCrackNamesW(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY,
                              DS_CANONICAL_NAME,
                              DS_FQDN_1779_NAME, 
                              1, &wszFinalDns, &pdsNameRes);
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }
        if((pdsNameRes == NULL) ||
           (pdsNameRes->cItems < 1) ||
           (pdsNameRes->rItems == NULL)){
            dwRet = ERROR_INVALID_PARAMETER;
            __leave;
        }
        if(pdsNameRes->rItems[0].status != DS_NAME_NO_ERROR){
            dwRet = pdsNameRes->rItems[0].status;
            __leave;
        }
        if(pdsNameRes->rItems[0].pName == NULL){
            dwRet = ERROR_INVALID_PARAMETER;
            assert(!"Wait how can this happen?\n");
            __leave;
        }
        // The parameter that we want is
        //    pdsNameRes->rItems[0].pName

        *pwszDn = (WCHAR *) LocalAlloc(LMEM_FIXED, 
                             (wcslen(pdsNameRes->rItems[0].pName) + 1) * 
                             sizeof(WCHAR));
        if(*pwszDn == NULL){
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        wcscpy(*pwszDn, pdsNameRes->rItems[0].pName);

    } __finally {
        if(wszFinalDns) { LocalFree(wszFinalDns); }
        if(pdsNameRes) { DsFreeNameResultW(pdsNameRes); }
    }

    return(dwRet);
}


// --------------------------------------------------------------------------
//
// Main Helper Routines.
//

// Each of these functions, implements a major component of the ILS install
// or uninstall routines.  They are sort of helper functions, but they could 
// also be exposed as seperate functions in ntdsutil.exe if we wanted.

DWORD
ILSNG_CheckParameters(
    IN      WCHAR *        wszIlsHeadDn
    )
{
    // Then check that this parameter looks something like a DC type DN.

    if(!CheckDnsDn(wszIlsHeadDn)){
        PrintMsg(TAPICFG_BAD_DN, wszIlsHeadDn);
        return(ERROR_INVALID_PARAMETER);
    }                                   
    
    return(ERROR_SUCCESS);
}

DWORD
GetMsTapiContainerDn(
    IN      LDAP *       hld,
    IN      WCHAR *      wszDomainDn,
    IN      WCHAR **     pwszMsTapiContainerDn
    )
/*++

Routine Description:

    This gets the MS TAPI Service Connection Points (SCPs)
    container DN.

Arguments:

    hld (IN) - And LDAP binding handle.
    wszDomainDn (IN) - The domain to find the MS TAPI SCP 
        Containter in.
    pwszMsTapiContainerDn (OUT) - The result.

Return value:

    ldap error code.

--*/
{
    DWORD                dwRet;
    WCHAR *              wszSysDn = NULL;
    
    assert(pwszMsTapiContainerDn);
    
    *pwszMsTapiContainerDn = NULL;

    // ----------------------------------------
    // Get System DN.
    dwRet = GetSystemDN(hld, wszDomainDn, &wszSysDn);
    if(dwRet != ERROR_SUCCESS){
        return(dwRet);
    }

    // ----------------------------------------
    // Append the Microsoft TAPI container name.
    *pwszMsTapiContainerDn = CatAndAllocStrsW(L"CN=MicrosoftTAPI,", wszSysDn);
    if(*pwszMsTapiContainerDn == NULL){
        LocalFree(wszSysDn);
        return(LDAP_NO_MEMORY);
    }

    LocalFree(wszSysDn);
    return(LDAP_SUCCESS);
}

DWORD
FindExistingServiceObjOne(
    IN      WCHAR *        wszScpObjDn,
    IN      WCHAR *        wszTapiDirDns,
    IN      BOOL           fIsDefaultScp,
    IN      BOOL           fIsDefaultTapiDir,
    IN      PVOID          pArgs
    )
/*++

Routine Description:

    This is the helper function for ILSNG_FindExistingServiceObj(),
    this function is handed to the iterator ILSNG_EnumerateSCPs() to
    be called on to process each SCP.
              
Arguments:

    OTHER ARGS - See ILSNG_EnumerateSCPs.                                                             
    pArgs (IN) - This is the DNS name that we're looking for.

Return value:

    TRUE if a SCP matches DNS Names with the target (pArg), FALSE
    otherwise.

--*/
{
    if(wszScpObjDn == NULL){
        return(FALSE);
    }

    if(!fIsDefaultScp &&
       _wcsicmp(wszTapiDirDns, (WCHAR *) pArgs) == 0){
        return(TRUE);
    }

    return(FALSE);
}

BOOL
ILSNG_FindExistingServiceObj(
    IN      LDAP *         hldDC,
    IN      WCHAR *        wszRootDn,
    IN      WCHAR *        wszDnsName
    )
/*++

    Description:

        The goal of this function is to find any GUID Based ILSNG 
        service publication objects for an existing DNS name so we 
        don't recreate them in ILSNG_RegisterServiceObjects()
    
--*/
{

    DWORD            fRet = FALSE;
    DWORD            dwRet;
    
    // NOTE: would be more efficient to actually pass in an additional
    // filter of L"(serverDNSName=<wszDnsName>), like the
    // ILSNG_UnRegisterServiceObjects() function.  Oh well, this
    // stresses the Enumerate function in different ways, so that is
    // good.  No one will probably ever have more than a few SCPs in
    // a single domain.

    dwRet = ILSNG_EnumerateSCPs(hldDC, wszRootDn, NULL,
                                // This is the iterator function params.
                                &fRet, 
                                FindExistingServiceObjOne, 
                                (PVOID) wszDnsName);

    return(fRet);
}


DWORD
ILSNG_RegisterServiceObjects(
    IN      LDAP *         hldDC,
    IN      WCHAR *        wszILSDN,
    IN      WCHAR *        wszRegisterDomainDn,
    IN      BOOL           fForceDefault,
    IN      BOOL           fDefaultOnly
    )
{
    // Microsoft TAPI Container Obect.
    WCHAR *        wszMsTapiContainerDN = NULL;

    // Microsoft TAPI Default ILS Service object.
    WCHAR *        wszDefTapiIlsDN = NULL;
    WCHAR *        pwszDefTapiIlsAttr [] = { 
        // 1st Null is a place holder for DNS service name.
        L"serviceDNSName", NULL, NULL,
        L"serviceDNSNameType", L"SRV", NULL,
        NULL };
    WCHAR *        pwszModifyVals [2];
    LDAPModW       ModifyDefTapiIls;
    LDAPModW *     pMods[2];



    // ILS Instance Service object.
    WCHAR *        wszIlsInstanceDN = NULL;
    WCHAR *        pwszStringList[6]; // Used to constructe wszIlsInstanceDN
    WCHAR *        pwszIlsInstanceAttr [] = { 
        // 1st Null is a place holder for DNS service name.
        L"serviceDNSName", NULL, NULL, 
        L"serviceDNSNameType", L"SRV", NULL,
        L"keywords", TAPI_DIRECTORY_GUID, L"Microsoft", L"TAPI", L"ILS", NULL,
        NULL };
    
    GUID           ServiceGuid = { 0, 0, 0, 0 };
    WCHAR *        wszServiceGuid = NULL;
    DS_NAME_RESULTW *  pdsNameRes = NULL;
    DWORD          dwRet = LDAP_SUCCESS;
    WCHAR *        wszSysDN = NULL;
    
    __try {

        // Note for a couple of the ATTRs above we need the DNS name for
        // the wszILSDN parameter.  DsCrackNames to the rescue.
        dwRet = DsCrackNamesW(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY,
                              DS_FQDN_1779_NAME, DS_CANONICAL_NAME,
                              1, &wszILSDN, &pdsNameRes);
        if((dwRet != ERROR_SUCCESS) ||
           (pdsNameRes == NULL) ||
           (pdsNameRes->cItems < 1) ||
           (pdsNameRes->rItems == NULL) ||
           (pdsNameRes->rItems[0].status != DS_NAME_NO_ERROR)){
            dwRet = LDAP_NAMING_VIOLATION;
            __leave;
        }
        // The parameter that we use later in the code is
        //    pdsNameRes->rItems[0].pDomain


        // -----------------------------------------------------------------
        //
        // Create the CN=MicrosoftTAPI container
        //
        //
        
        dwRet = GetMsTapiContainerDn(hldDC, wszRegisterDomainDn, 
                                     &wszMsTapiContainerDN);
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }

        // ----------------------------------------
        // Actually create the object.
        if(dwRet = CreateOneObject(hldDC,
                                   wszMsTapiContainerDN,
                                   L"Container",
                                   TAPI_SERVICE_CONTAINER_SD,
                                   NULL)){
            if(dwRet == LDAP_ALREADY_EXISTS){
                dwRet = LDAP_SUCCESS; 
                // This is OK, continue on ...
            } else {
                // Any other error is considered fatal, so leave ...
                __leave;
            }
        }
        
        // -----------------------------------------------------------------
        //
        // Create the GUID based serviceConnectionPoint object
        //
        //
        
        // First check if one already exists.
        if(!fDefaultOnly &&
           !ILSNG_FindExistingServiceObj(hldDC,
                                         wszMsTapiContainerDN,
                                         pdsNameRes->rItems[0].pDomain)){
            // OK, so we couldn't find another service publication object
            // for this DNS name, so we'll create one.  This is the usual
            // case.  However, if someone is trying to restore the Default
            // TAPI Directory to an old DNS name this isn't the case.
        
            // Note from above ATTRs we have to fill in the serviceDNSName.
            // attributes for the pwszIlsInstanceAttr variable.
            pwszIlsInstanceAttr[1] = pdsNameRes->rItems[0].pDomain;

            // ----------------------------------------
            // Step 1: Need Guid.
            dwRet = UuidCreate(&ServiceGuid);
            if(dwRet != RPC_S_OK){
                return(dwRet);
            }

            // Step 2: Convert GUID to String.
            dwRet = UuidToStringW(&ServiceGuid, &wszServiceGuid);
            if(dwRet != RPC_S_OK){
                return(dwRet);
            }
            assert(wszServiceGuid);

            // Step 3: Put it all together.
            pwszStringList[0] = L"CN=";
            pwszStringList[1] = wszServiceGuid;
            pwszStringList[2] = L",";
            pwszStringList[3] = wszMsTapiContainerDN;
            pwszStringList[4] = NULL;
            wszIlsInstanceDN = SuperCatAndAllocStrsW(pwszStringList);
            if(wszIlsInstanceDN == NULL){
                dwRet = LDAP_NO_MEMORY;
                __leave;
            }
            RpcStringFreeW(&wszServiceGuid);
            wszServiceGuid = NULL;

            // Create the ILS Service Object.
            if(dwRet = CreateOneObject(hldDC,
                                       wszIlsInstanceDN,
                                       L"serviceConnectionPoint",
                                       TAPI_SERVICE_OBJECTS_SD,
                                       pwszIlsInstanceAttr)){
                if(dwRet != LDAP_ALREADY_EXISTS){
                    __leave;
                }
            }
        }
           
        // -----------------------------------------------------------------
        //
        // Create the CN=DefaultTAPIDirectory serviceConnectionPoint object.
        //
        //
        
        // Note from above ATTRs we have to fill in the serviceDNSName.
        // attributes for the pwszDefTAPIDirAttr variable.
        pwszDefTapiIlsAttr[1] = pdsNameRes->rItems[0].pDomain;
        
        // Create the DN for the DefaultTAPIDirectory
        wszDefTapiIlsDN = CatAndAllocStrsW(L"CN=DefaultTAPIDirectory,",
                                           wszMsTapiContainerDN);
        if(wszDefTapiIlsDN == NULL){
            return(LDAP_NO_MEMORY);
        }

        // ----------------------------------------
        // NOW Actually get around to creating the service objects
        if(dwRet = CreateOneObject(hldDC,
                                   wszDefTapiIlsDN,
                                   L"serviceConnectionPoint",
                                   TAPI_SERVICE_OBJECTS_SD,
                                   pwszDefTapiIlsAttr)){
            if(dwRet != LDAP_ALREADY_EXISTS){
                dwRet = LDAP_SUCCESS; // OH Well, continue on.
            } else {
                // OK, it already exists, so if we are supposed
                // to force the default to this NDNC, then do so.
                if(fForceDefault){
                    // Constructe Modify Args.

                    ModifyDefTapiIls.mod_op = LDAP_MOD_REPLACE;
                    ModifyDefTapiIls.mod_type = L"serviceDNSName";
                    pwszModifyVals[0] = pwszDefTapiIlsAttr[1];
                    pwszModifyVals[1] = NULL;
                    ModifyDefTapiIls.mod_vals.modv_strvals = pwszModifyVals;
                    pMods[0] = &ModifyDefTapiIls;
                    pMods[1] = NULL;
                    
                    dwRet = ldap_modify_sW(hldDC,
                                           wszDefTapiIlsDN,
                                           pMods);

                    if(dwRet != ERROR_SUCCESS){
                        // This time it is fatal.
                        __leave;
                    }
                } else {
                    dwRet = LDAP_SUCCESS; // OH Well, continue on.
                }
            }
        }

    } __finally {

        if(wszSysDN) { LocalFree(wszSysDN); }
        if(wszMsTapiContainerDN) { LocalFree(wszMsTapiContainerDN); }
        if(wszDefTapiIlsDN) { LocalFree(wszDefTapiIlsDN); }
        if(wszIlsInstanceDN) { LocalFree(wszIlsInstanceDN); }
        if(wszServiceGuid){ RpcStringFreeW(&wszServiceGuid); }
        if(pdsNameRes) { DsFreeNameResultW(pdsNameRes); }

    }

    return(dwRet);
}

DWORD
UnRegisterServiceObjectsOne(
    IN      WCHAR *        wszScpObjDn,
    IN      WCHAR *        wszTapiDirDns,
    IN      BOOL           fIsDefaultScp,
    IN      BOOL           fIsDefaultTapiDir,
    IN      PVOID          hld
    )
{
    DWORD                  dwRet;

    if(wszScpObjDn == NULL){
        return(FALSE);
    }

    dwRet = ldap_delete_sW((LDAP *) hld, wszScpObjDn);
    
    return(dwRet);
}

DWORD
ILSNG_UnRegisterServiceObjects(
    IN      LDAP *         hldDC,
    IN      WCHAR *        wszILSDN,
    IN      WCHAR *        wszRegisterDomainDn
    )
{
    DS_NAME_RESULTW *     pdsNameRes = NULL;
    DWORD                 dwRet;
    DWORD                 dwFuncErr  = LDAP_SUCCESS;
    WCHAR *               wszFilter = NULL;
    WCHAR *               wszFilterBegin = L"(serviceDNSName=";
    WCHAR *               wszFilterEnd = L")";
    WCHAR *               wszMsTapiContainerDn = NULL;

    __try {

        // Construct Root DN.
        // ----------------------------------------
        // Get the CN=MicrosoftTAPI container DN.
        
        dwRet = GetMsTapiContainerDn(hldDC, wszRegisterDomainDn, 
                                     &wszMsTapiContainerDn);
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }
        assert(wszMsTapiContainerDn);

        // Construct filter.
        // ----------------------------------------
        // Note from above ATTRs we have to fill in the serviceDNSName.
        // attributes for the pwszILSAttr and pwszDefTAPIDirAttr variables.
        // Resolve the DNS Service Name.
        dwRet = DsCrackNamesW(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY,
                              DS_FQDN_1779_NAME, DS_CANONICAL_NAME,
                              1, &wszILSDN, &pdsNameRes);
        if((dwRet != ERROR_SUCCESS) ||
           (pdsNameRes == NULL) ||
           (pdsNameRes->cItems < 1) ||
           (pdsNameRes->rItems == NULL) ||
           (pdsNameRes->rItems[0].status != DS_NAME_NO_ERROR)){
            dwRet = LDAP_NAMING_VIOLATION;
            assert(!"It's OK to assert here, because wszILSDN was gotten from cracknames in the first place!");
            __leave;
        }
        
        wszFilter = (WCHAR *) LocalAlloc(LMEM_FIXED, 
                               sizeof(WCHAR) *
                               (wcslen(pdsNameRes->rItems[0].pDomain) +
                                wcslen(wszFilterBegin) + 
                                wcslen(wszFilterEnd) + 3));
        if(!wszFilter){
            dwRet = LDAP_NO_MEMORY;
            __leave;
        }
        
        wcscpy(wszFilter, wszFilterBegin);
        wcscat(wszFilter, pdsNameRes->rItems[0].pDomain);
        wcscat(wszFilter, wszFilterEnd);

        // Iterate SCPs.
        // ----------------------------------------
        // The fucntion ILSNG_EnumerateSCPs, iterates through
        // the SCPs, calling UnRegisterServiceObjectsOne() on
        // each SCP, which then deletes the SCP.

        dwRet = ILSNG_EnumerateSCPs(hldDC, wszMsTapiContainerDn, wszFilter,
                                    // This is the iterator function params.
                                    &dwFuncErr, 
                                    UnRegisterServiceObjectsOne, 
                                    (PVOID) hldDC);

    } __finally {

        if(pdsNameRes) { DsFreeNameResultW(pdsNameRes); }
        if(wszMsTapiContainerDn) { LocalFree(wszMsTapiContainerDn); }
        if(wszFilter) { LocalFree(wszFilter); }

    }

    if(dwRet){
        return(dwRet);
    } 
    
    return(dwFuncErr);

}

DWORD
ILSNG_CreateRootTree(
    IN      LDAP *         hldDC,
    IN      WCHAR *        wszILSDN
    )
{
    DWORD          dwRet;
    WCHAR *        wszDynDN;

    // Create the dynamic ou.
    wszDynDN = CatAndAllocStrsW(L"OU=Dynamic,", wszILSDN);
    if(wszDynDN == NULL){
        return(LDAP_NO_MEMORY);
    }

    dwRet = CreateOneObject(hldDC,
                            wszDynDN,
                            L"organizationalUnit",
                            ILS_DYNAMIC_CONTAINER_SD,
                            NULL);

    LocalFree(wszDynDN);
    
    return(dwRet);
}

ULONG
GetILSNGDC(
    IN      LDAP *       hld,
    IN      WCHAR *      wszTapiDirDns,
    OUT     WCHAR **     pwszInstantiatedDc
    )
{
    ULONG                ulRet;
    WCHAR *              wszTapiDirDn = NULL;
    WCHAR *              pwszAttrFilter[2];
    LDAPMessage *        pldmResults = NULL;
    LDAPMessage *        pldmEntry = NULL;
    WCHAR **             pwszTempAttrs = NULL;
    
    assert(pwszInstantiatedDc);
    *pwszInstantiatedDc = NULL;

    // First get the DN of the TAPI Directory
    ulRet = GetDnFromDns(wszTapiDirDns, &wszTapiDirDn);
    if(ulRet){
        // Since we're returning LDAP errors, this is
        // closest to an Naming Violation.
        ulRet = LDAP_NAMING_VIOLATION;
        return(ulRet);
    }

    __try {

        // Get the masteredBy attribute of the NC head object.
        pwszAttrFilter[0] = L"masteredBy";
        pwszAttrFilter[1] = NULL;
        ulRet = ldap_search_sW(hld,
                               wszTapiDirDn,
                               LDAP_SCOPE_BASE,
                               L"(objectCategory=*)",
                               pwszAttrFilter,
                               0,
                               &pldmResults);
        if(ulRet != LDAP_SUCCESS){
            __leave;
        }

        pldmEntry = ldap_first_entry(hld, pldmResults);
        if(pldmEntry == NULL){
            ulRet = ldap_result2error(hld, pldmResults, FALSE);
            assert(ulRet);
            __leave;
        }

        pwszTempAttrs = ldap_get_valuesW(hld, pldmEntry, pwszAttrFilter[0]);
        if(pwszTempAttrs == NULL || pwszTempAttrs[0] == NULL){
            ulRet = LDAP_NO_RESULTS_RETURNED;
            __leave;
        }

        // pwszTempAttrs[0] is the ntdsa DN for the server hosting this NC.

        ulRet = GetServerDnsFromServerNtdsaDn(hld, 
                                              pwszTempAttrs[0],
                                              pwszInstantiatedDc);
        // ulRet will just get returned.
        // wszInstantiatedDc is LocalAlloc()'d if the function was successful.
    } __finally {
        if(wszTapiDirDn) { LocalFree(wszTapiDirDn); }
        if(pldmResults != NULL) { ldap_msgfree(pldmResults); }
        if(pwszTempAttrs) { ldap_value_freeW(pwszTempAttrs); }
    }

    return(ulRet);
}

DWORD
ILSNG_EnumerateSCPs(
    // This is the parameters for the function.
    IN      LDAP *       hld,
    IN      WCHAR *      wszRootDn,
    IN      WCHAR *      wszExtendedFilter,
    // These are parameters for the virtual iterator function.
    OUT     DWORD *      pdwRet,           // Return Value
    IN      DWORD (__stdcall * pFunc) (),  // Function
    IN OUT  PVOID        pArgs             // Argument
    )
/*++

Routine Description:

    This is a complicated function, but _extremely useful function, that 
    basically iterates through all the service connection points (SCPs)
    in the container wszRootDn, and calls the virtual function pFunc for
    each SCP.

Arguments:

    hld (IN) - A connected ldap handle
    wszRootDn (IN) - The base of the SCP container, containing the
        various GUID based SCPs, and the single default SCP.
    wszExtendedFilter (IN) - An extra filter, so the search for
        SCPs can be narrowed down appropriately.  This will limit
        the iteration routine to only those SCPs that also match
        this filter, and the default SCP is always called.
    pdwRet (OUT) - This is a pointer to a return value for the pFunc 
        function.  The caller must allocate this DWORD, or pass NULL.
    pFunc (IN) - This is the function to be called on each SCP.
    pArgs (IN/OUT) - This is the argument passed through this function
        to pFunc.  This can be used in any way pFunc wants to, it's
        just passed through this function with no assumptions.

Return value:

    ldap error code - Note that this is the error code for trying
    to get the SCP object, and this could be success, while the
    pdwRet is and ERROR, or vice versa.
    
Comments:    

    The arguments for this function are seperated into two sets, set one
    (the first 3 arguments) control how this routine (the iterating routine)
    behaves, what computer it searched, what container it searches, and
    what special parameters it's looking for in the SCPs to be returned
    to the SCP processing function.  The second set (the last 3 arguments)
    of arguments are related to the SCP processing function.  The fourth
    argument is a pointer to a DWORD for a return value, the fifth argument
    is the processing function itself, and the final argument is the argument
    to pass to the SCP processing function.
    
    The SCP processing function must follow this general form:
        DWORD
        pFunc(
            IN      WCHAR *        wszScpObjDn,
            IN      WCHAR *        wszTapiDirDns,
            IN      BOOL           fIsDefaultScp,
            IN      BOOL           fIsDefaultTapiDir,
            IN OUT  PVOID          pArgs
        )        
            wszScpObjDn (IN) - This is the DN of the SCP object found.
                This parameter is always filled in, except on the last
                call to pFunc this parameter is NULL, signifying the
                end of all the SCPs.
            wszTapiDirDns (IN) - This is the DNS string for the given
                SCP object.
            fIsDefaultScp (IN) - This tells you if the object returned
                is the default SCP object, there is only one of these
                and if it exists, it will be returned on the first call
                to pFunc.  Generally, this is TRUE for one call to pFunc
                for a given set of SCPs.
            fIsDefaultTapiDir (IN) - This tells you if this is a SCP
                object with the same DNS name as the DNS name for the
                default SCP object.  Generally, this will be TRUE for
                two calls to pFunc for a given set of SCPs.
            pArgs (IN/OUT) - This is the argument that pFunc can use
                however it wishes.
                
    The algorithm for pFunc being called looks like this:
        If( Default SCP exists){
            pdwRet = pFunc( x, x, TRUE, TRUE, x);
        }
        while ( pSCP = GetAnotherGUIDBasedSCP() ){
            pdwRet = pFunc( x, x, FALSE, [TRUE|FALSE], x);
        }
        pdwRet = pFunc(NULL, NULL, FALSE, FALSE, x);
    However if pFunc ever returns a non-zero result, then pFunc will
    no longer be called.
                 
--*/
{

    DWORD            dwRet;
    DWORD            dwFuncRet;
                 
    WCHAR *          wszDefTapiIlsDn = NULL;

    WCHAR *          pwszAttrFilter[] = { L"serviceDNSName", NULL };
    LDAPMessage *    pldmResults = NULL;
    LDAPMessage *    pldmEntry = NULL;
    WCHAR *          wszTempDn = NULL;
    ULONG            cwcFilter = 0; // Count in chars of filter.
    WCHAR *          wszFilter = NULL;
    WCHAR *          wszFilterBegin = 
          L"(&(objectClass=serviceConnectionPoint)(keywords=";
    WCHAR *          wszFilterEnd = L")";
    BOOL             fIsDefault = FALSE;
    WCHAR **         pwszDnsName = NULL;
    WCHAR **         pwszDefaultDnsName = NULL;
    WCHAR *          wszDefaultDnsName = NULL;
    
    __try {

        // We need this, because we could (though very very unlikely, as
        // the tools are not setup to do this, have a scenario where the
        // CN=DefaultTAPIDirectory object has the dns name, but no regular
        // service publication object exists, so we need to make sure that 
        // this object isn't the default TAPI dir object.
        wszDefTapiIlsDn = CatAndAllocStrsW(L"CN=DefaultTAPIDirectory,",
                                           wszRootDn);
        if(wszDefTapiIlsDn == NULL){
            dwRet = LDAP_NO_MEMORY;
            __leave;
        }

        // Construct filter.
        // ----------------------------------------
        // Note from above ATTRs we have to fill in the serviceDNSName.
        // attributes for the pwszILSAttr and pwszDefTAPIDirAttr variables.
        // Resolve the DNS Service Name.
        
        cwcFilter = wcslen(wszFilterBegin) + wcslen(TAPI_DIRECTORY_GUID) +
            wcslen(wszFilterEnd) + wcslen(wszFilterEnd);
        if(wszExtendedFilter){
            cwcFilter += wcslen(wszExtendedFilter);
        }
        cwcFilter++; // For NULL termination.
        wszFilter = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * cwcFilter);
        if(!wszFilter){
            dwRet = LDAP_NO_MEMORY;
            __leave;
        }
        wcscpy(wszFilter, wszFilterBegin);
        wcscat(wszFilter, TAPI_DIRECTORY_GUID);
        wcscat(wszFilter, wszFilterEnd);
        if(wszExtendedFilter){
            wcscat(wszFilter, wszExtendedFilter);
        }
        wcscat(wszFilter, wszFilterEnd);
        assert(wsclen(wszFilter) == (cwcFilter - 1));
        
        // Find the Default SCP.
        // ----------------------------------------
        // First we search for the default SCP, save the name
        // for later, and call pFunc on the first SCP.
        
        dwRet = ldap_search_sW(hld,
                               wszDefTapiIlsDn,
                               LDAP_SCOPE_BASE,
                               (wszExtendedFilter) ? 
                                      wszExtendedFilter :
                                      L"(objectCategory=*)",
                               pwszAttrFilter,
                               0,
                               &pldmResults);

        if(dwRet == LDAP_NO_SUCH_OBJECT){
            dwRet = LDAP_SUCCESS; // continue on
        } else if(dwRet) {
            __leave;
        } else {

            // This is the most common case where there is a default SCP.
            pldmEntry = ldap_first_entry(hld, pldmResults);

            if(pldmEntry == NULL){
                dwRet = LDAP_SUCCESS;
            } else {

                // This is the goods, we've got a default SCP.
                pwszDefaultDnsName = ldap_get_values(hld, pldmEntry, L"serviceDNSName");
                if(pwszDefaultDnsName != NULL && pwszDefaultDnsName[0] != NULL){
                    wszDefaultDnsName = pwszDefaultDnsName[0];

                    dwFuncRet = pFunc(wszDefTapiIlsDn,
                                      wszDefaultDnsName,
                                      TRUE,
                                      TRUE,
                                      pArgs);
                    if(pdwRet){
                        *pdwRet = dwFuncRet;
                    }
                    if(dwFuncRet){
                        // Bail out early if this is ever not 0;
                        __leave;
                    }
                }   
                if(pldmResults){
                    ldap_msgfree(pldmResults);
                    pldmResults = NULL;
                }
            }
        }


        // Find all other SCPs.
        // ----------------------------------------
        // Now we find all the other SCPs, and iterate through
        // them calling pFunc
         
        dwRet = ldap_search_sW(hld,
                               wszRootDn,
                               LDAP_SCOPE_ONELEVEL,
                               wszFilter,
                               pwszAttrFilter,
                               0,
                               &pldmResults);

        if(dwRet != LDAP_SUCCESS){
            __leave;
        }

        pldmEntry = ldap_first_entry(hld, pldmResults);
        for(pldmEntry = ldap_first_entry(hld, pldmResults);
            pldmEntry; 
            pldmEntry = ldap_next_entry(hld, pldmEntry)){
            
            // Get the DN of the TAPI Directory SCP.
            wszTempDn = ldap_get_dn(hld, pldmEntry);
            if(wszTempDn == NULL){
                continue;
            }

            pwszDnsName = ldap_get_values(hld, pldmEntry, L"serviceDNSName");
            if(pwszDnsName == NULL || pwszDnsName[0] == NULL){
                continue;
            }

            // Is if the Default TAPI Directory SCP.
            if(wszDefaultDnsName &&
               0 == _wcsicmp(wszDefaultDnsName, pwszDnsName[0])){
                fIsDefault = TRUE;
            } else {
                fIsDefault = FALSE;
            }

            // Call the virtual function passed in.
            dwFuncRet = pFunc(wszTempDn, // SCP DN
                              pwszDnsName[0],
                              FALSE,
                              fIsDefault,
                              pArgs);
            if(pdwRet){
                *pdwRet = dwFuncRet;
            }
            if(dwFuncRet){
                // Bail out early if this is ever not 0;
                __leave;
            }

            ldap_memfree(wszTempDn);
            wszTempDn = NULL;

            ldap_value_free(pwszDnsName);
            pwszDnsName = NULL;
        } // End for each Service Connection Point (SCP).
        

        // Final Call
        // ----------------------------------------
        // Do one last final call to pFunc, to let the
        // function wrap up, and reset any statics.

        dwFuncRet = pFunc(NULL, NULL, FALSE, FALSE, pArgs);
        if(pdwRet){
            *pdwRet = dwFuncRet;
        }
        if(dwFuncRet){
            __leave;
        }

    } __finally {

        if(pldmResults != NULL){ ldap_msgfree(pldmResults); }
        if(wszTempDn != NULL){ ldap_memfree(wszTempDn); }
        if(pwszDnsName != NULL) { ldap_value_free(pwszDnsName);}
        if(wszDefTapiIlsDn != NULL){ LocalFree(wszDefTapiIlsDn); }
        if(wszFilter != NULL) { LocalFree(wszFilter); }
        if(pwszDefaultDnsName != NULL) { ldap_value_free(pwszDefaultDnsName); }

    }

    return(dwRet);
}


// --------------------------------------------------------------------------
//
// Main Routines.
//
//
// These two functions are the primary ILS functions that are used by
// ntdsutil.exe.
//
    

DWORD
InstallILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn,
    IN      BOOL          fForceDefault,
    IN      BOOL          fAllowReplicas
    )
/*++

Routine Description:

    This routine is the main ILSNG/TAPI Directory installation 
    routine.  This installs the TAPI Directory (wszIlsHeadDn) on the
    machine connected to by hld.  This involveds the following steps:
    A) Create an NDNC head on the machine in hld.
    B) Create a TAPI Directory OU=Dynamic folder.
    C) Lower the replication intervals on the NDNCs.
    D) Register the Service Connection Points (SCPs)
        I) if fForceDefault, then force the default SCP to point
        to this TAPI Directory.
    E) If the TAPI Directory already exists and fAllowReplicas, then
        instead of steps A, B & C, just add ourselves to the replica
        set for the NDNC wszIlsHeadDn.

Arguments:

    hld (IN) - LDAP connection on which to create the TAPI Dir.
    wszIlsHeadDn (IN) - The DN of the TAPI Dir to be created.
    fForceDefault (IN) - Whether to force the Default SCP to
        be changed to this TAPI Dir if the Default SCP already
        exists.
    fAllowReplicas (IN) - Whether to allow replicas if the TAPI
        Dir already exists.
        
Return value:

    A Win32 error code.

--*/
{
    DWORD         dwRet = ERROR_SUCCESS;
    WCHAR *       wszSystemDN = NULL;
    WCHAR *       wszServerDn = NULL;
    VOID *        pvReferrals;
    WCHAR *       wszRegisterDomainDn = NULL;
    WCHAR *       wszDesc = NULL;

    // Validate 1st Argument - Check NCName to make sure it
    // looks like a domain name
    assert(hld);

    pvReferrals = (VOID *) FALSE; // No referrals.
    dwRet = ldap_set_option(hld, LDAP_OPT_REFERRALS, &pvReferrals);
    if(dwRet != LDAP_SUCCESS){
        PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
        return(LdapMapErrorToWin32(dwRet));
    }

    dwRet = ILSNG_CheckParameters(wszIlsHeadDn);
    if(dwRet != ERROR_SUCCESS){
        // ILSNG_CheckParameters() prints errors.
        return(dwRet);
    }

    __try{

        dwRet = GetRootAttr(hld, L"defaultNamingContext", &wszRegisterDomainDn);
        if(dwRet) {
            // This attribute is needed for proper registration of service
            // objects.
            PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
            dwRet = LdapMapErrorToWin32(dwRet);
            __leave;
        }                        
        
        dwRet = FormatMessageW((FORMAT_MESSAGE_ALLOCATE_BUFFER
                                | FORMAT_MESSAGE_FROM_HMODULE
                                | FORMAT_MESSAGE_IGNORE_INSERTS
                                | 80),
                               NULL,
                               TAPICFG_NDNC_DESC,
                               0,
                               (LPWSTR) &wszDesc,
                               sizeof(wszDesc),
                               NULL);
        if(!dwRet){
            PrintMsg(TAPICFG_GENERIC_ERROR, GetLastError());
            __leave;
        }
        assert(wszDesc);

        dwRet = CreateNDNC(hld, wszIlsHeadDn, wszDesc);

        if(dwRet == LDAP_SUCCESS){

            // Created a New NC.

            // TAPI and ILS and ILSNG imply a minimum tree, this fills
            // out that minimum tree.
            if(dwRet = ILSNG_CreateRootTree(hld, wszIlsHeadDn)){
                // dwRet is an LDAP return value.
                PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
                dwRet = LdapMapErrorToWin32(dwRet);
                __leave;
            }
            
            // We want to start following referrals now, so we goto the
            // Naming FSMO if appropriate.
            //
            pvReferrals = (VOID *) TRUE; 
            dwRet = ldap_set_option(hld, LDAP_OPT_REFERRALS, &pvReferrals);
            if(dwRet != LDAP_SUCCESS){
                return(LdapMapErrorToWin32(dwRet));
            }

            // Push down the replication intervals.
            dwRet = SetNCReplicationDelays(hld, wszIlsHeadDn, 30, 5);
            // We could check for an error if we wanted, but we're 
            // just going to go on.
            dwRet = LDAP_SUCCESS;

        } else if(dwRet == LDAP_ALREADY_EXISTS){
            
            
            if(fAllowReplicas){
                // This is if we tried to add an replica and the NC already
                // existed, so what we need to do is to see if we can add 
                // ourselves as a replica for this NC.
                dwRet = LDAP_SUCCESS;

                dwRet = GetRootAttr(hld, L"dsServiceName", &wszServerDn);
                if(dwRet){
                    PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
                    dwRet = LdapMapErrorToWin32(dwRet);
                    __leave;
                }

                // We want to start following referrals now, so we goto the
                // Naming FSMO if appropriate.
                //
                pvReferrals = (VOID *) TRUE;
                dwRet = ldap_set_option(hld, LDAP_OPT_REFERRALS, &pvReferrals);
                if(dwRet != LDAP_SUCCESS){
                    dwRet = LdapMapErrorToWin32(dwRet);
                    __leave;
                }

                // Add this DC as a replica for the NC.
                dwRet = ModifyNDNCReplicaSet(hld, wszIlsHeadDn, wszServerDn, TRUE);
                if(dwRet == LDAP_ATTRIBUTE_OR_VALUE_EXISTS ||
                   dwRet == LDAP_SUCCESS){
                    // An error of already exists or success, is the same thing to
                    // us, because if we're already a replica of this NC, then we'll
                    // go onto register service objects.

                } else {
                    PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
                    dwRet = LdapMapErrorToWin32(dwRet);
                    __leave;
                }
            }

        } else if(dwRet){
            // Unknown error, bail out.
            PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
            dwRet = LdapMapErrorToWin32(dwRet);
            __leave;
        }

        // Register the service objects.
        if(dwRet = ILSNG_RegisterServiceObjects(hld, 
                                                wszIlsHeadDn,
                                                wszRegisterDomainDn,
                                                fForceDefault,
                                                FALSE)){
            PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
            dwRet = LdapMapErrorToWin32(dwRet);
            __leave;
        }

    } __finally {

        if(wszSystemDN) { LocalFree(wszSystemDN); }
        if(wszServerDn) { LocalFree(wszServerDn); }
        if(wszDesc) { LocalFree(wszDesc); }

    }

    return(dwRet);
}
     
DWORD
UninstallILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn
    )
/*++

Routine Description:

    This routine deletes the ILSNG/TAPI Directory service installed 
    on the machine.  While this routine makes the assumption that the
    TAPI Dir is only installed on one machine, and no replicated, this
    is very likely to still succeed in the replicated case.  The steps
    in the TAPI Dir uninstall are:
    A) Delete the crossRef of the NDNC, thus deleted the whole NDNC.
    B) UnRegistering (i.e. deleting) the SCPs.

Arguments:

    hld (IN) - The directory of the machine on which the TAPI Dir was
        instantiated.
    wszIlsHeadDn - The DN of the TAPI Dir.

Return value:

    A Win32 error code.

--*/
{
    DWORD         dwRet;
    WCHAR *       wszDomainDn = NULL;
    WCHAR *       wszCrossRefDn = NULL;
    VOID *        pvReferrals;
    
    __try {
        dwRet = GetRootAttr(hld, L"defaultNamingContext", &wszDomainDn);
        if(dwRet){
            PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
            __leave;
        }
        assert(wszDomainDn);

        dwRet = GetCrossRefDNFromNCDN(hld,
                                      wszIlsHeadDn,
                                      &wszCrossRefDn);
        if(dwRet){
            PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
            __leave;
        }
        assert(wszCrossRefDn);

        pvReferrals = (VOID *) TRUE;
        dwRet = ldap_set_option(hld, LDAP_OPT_REFERRALS, &pvReferrals);
        if(dwRet != LDAP_SUCCESS){
            PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
            __leave;
        }

        dwRet = ldap_delete_sW(hld, wszCrossRefDn);
        if(dwRet){
            PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
            // NOTE: It might be a better idea to not leave, and just try
            // to clean up the service objects for this TAPI Dir.
            __leave;
        }

        dwRet = ILSNG_UnRegisterServiceObjects(hld, wszIlsHeadDn, wszDomainDn);
        if(dwRet){
            PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
            __leave;
        }

    } __finally {
        if(wszDomainDn) { LocalFree(wszDomainDn); }
        if(wszCrossRefDn) { LocalFree(wszCrossRefDn); }
    }

    return(LdapMapErrorToWin32(dwRet));
}

typedef struct _ListInArgs {
    LDAP *     hld;
    BOOL       fDefaultOnly;
} ListInArgs;

DWORD
ListILSNGOne(
    IN      WCHAR *      wszScpObjDn,
    IN      WCHAR *      wszTapiDirDns,
    IN      BOOL         fIsDefaultScp,
    IN      BOOL         fIsDefaultTapiDir,
    IN      PVOID        pArgs
    )
/*++

Routine Description:

    This routine is the partner to the ListILSNG() function, but is
    called through the ILSNG_EnumerateSCPs() function.  This routine 
    prints out some info about one SCP.

Arguments:

    wszScpObjDn (IN) - This is the DN of the SCP.
    wszTapiDirDns (IN) - This is the DNS name of the TAPI Dir for this SCP.
    fIsDefaultScp (IN) - Tells if this is the Default SCP object.
        Generally, this will be TRUE only in one call for a set of SCPs.
    fIsDefaultTapiDir - Tells if this is the default TAPI Dir.  Generally,
        this will be TRUE for two calls for a set of SCPs.
    pArgs (IN) - This is a boolean on whether to print out only the
        default TAPI Dir, or print out all of the TAPI Dirs.

Return value:

    always returns ERROR_SUCCESS.

--*/
{
    static BOOL  fFirstRun = TRUE;
    static BOOL  fPrintedDefaultScp = FALSE;
    LDAP *       hld = ((ListInArgs *) pArgs)->hld;
    BOOL         fDefaultOnly = ((ListInArgs *) pArgs)->fDefaultOnly;
    WCHAR *      wszInstantiatedDc = NULL;
    ULONG        ulRet;
    
    if(wszScpObjDn == NULL){
        fFirstRun = TRUE;
        fPrintedDefaultScp = FALSE;
        return(ERROR_SUCCESS);
    }

    assert(fIsDefaultScp && !fIsDefaultTapiDir);

    if(fFirstRun && !fIsDefaultScp){
        PrintMsg(TAPICFG_SHOW_NO_DEFAULT_SCP);
    }
    if(fIsDefaultScp){

        assert(fFirstRun);
        fPrintedDefaultScp = TRUE;
        ulRet = GetILSNGDC(hld, wszTapiDirDns, &wszInstantiatedDc);
        if(ulRet){
            PrintMsg(TAPICFG_SHOW_PRINT_DEFAULT_SCP_NO_SERVER, wszTapiDirDns);
        } else {
            PrintMsg(TAPICFG_SHOW_PRINT_DEFAULT_SCP, wszTapiDirDns,
                     wszInstantiatedDc);
            LocalFree(wszInstantiatedDc);
            wszInstantiatedDc = NULL;
        }
    }

    // On subsequent runs, we want to know we've run once.
    fFirstRun = FALSE;

    if(fDefaultOnly){
        // We've either printed out the default SCP or printed
        // that there are no default SCPs, so return.
        return(ERROR_SUCCESS);
    }

    assert(fIsDefaultTapiDir && !fPrintedDefaultScp);
    if(fIsDefaultTapiDir){
        // We don't want to print the default Tapi Dir twice
        // that'd be once for it's regular SCP and once for
        // it's default SCP.
        return(ERROR_SUCCESS);
    }

    ulRet = GetILSNGDC(hld, wszTapiDirDns, &wszInstantiatedDc);
    if(ulRet){
        PrintMsg(TAPICFG_SHOW_PRINT_SCP_NO_SERVER, wszTapiDirDns);
    } else {
        PrintMsg(TAPICFG_SHOW_PRINT_SCP, wszTapiDirDns,
                 wszInstantiatedDc);
        LocalFree(wszInstantiatedDc);
        wszInstantiatedDc = NULL;
    }

    return(ERROR_SUCCESS);
}

DWORD
ListILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszDomainDn,
    IN      BOOL          fDefaultOnly
    )
/*++

Routine Description:

    This is a function that simply prints out all the TAPI Directories,
    as identified by thier SCPs.  This uses a helper function ListILSNGOne
    to print out each SCP.

Arguments:

    hld (IN) - An LDAP binding to use.
    wszDomainDn (IN) - The Domain to enumerate the SCPs out of.
    fDefaultOnly (IN) - Whether to print out all the SCPs or just
        the default one.

Return value:

    A Win32 error code.

--*/
{
    DWORD                 dwRet = ERROR_SUCCESS;
    WCHAR *               wszMsTapiContainerDn = NULL;
    ListInArgs            Args = { hld, fDefaultOnly };

    assert(hld);

    dwRet = GetMsTapiContainerDn(hld, wszDomainDn, 
                                 &wszMsTapiContainerDn);
    if(dwRet != ERROR_SUCCESS){
        PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
        return(LdapMapErrorToWin32(dwRet));
    }

    PrintMsg(TAPICFG_SHOW_NOW_ENUMERATING);

    // Note: That this is slightly inefficient in the case where
    // fDefaultOnly = TRUE, but what this lacks in efficency it
    // more than makes up in beauty of code reuse.
    dwRet = ILSNG_EnumerateSCPs(hld, wszMsTapiContainerDn, NULL,
                                // Iterator Function Params.
                                NULL,  // Return of ListILSNGOne
                                ListILSNGOne,  // Function to Call
                                (PVOID) &Args); // Args to provide

    if(dwRet == LDAP_NO_SUCH_OBJECT){
        PrintMsg(TAPICFG_SHOW_NO_SCP);
        dwRet = LDAP_SUCCESS;
    } else if (dwRet){
        PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
    }
    LocalFree(wszMsTapiContainerDn);

    return(LdapMapErrorToWin32(dwRet));
}

DWORD
ReregisterILSNG(
    IN      LDAP *        hld,
    IN      WCHAR *       wszIlsHeadDn,
    IN      WCHAR *       wszDomainDn
    )
/*++

Routine Description:

    This routine re-registers the Default TAPI Directory SCPs to point
    to the TAPI Dir specified (wszIlsHeadDn).  This will force the 
    Default SCP to point at wszIlsHeadDn, if it doesn't already exist.

Arguments:

    hld (IN) - An LDAP binding to use.
    wszIlsHeadDn (IN) - The DN of the TAPI Dir to reregister.  This gets
        turned into a DNS name for registration purposes.
    wszDomainDn (IN) - This is the domain in which to register the Default
        SCPs.

Return value:

    ldap error code.

--*/
{
    DWORD         dwRet;

    dwRet = ILSNG_RegisterServiceObjects(hld, 
                                         wszIlsHeadDn,
                                         wszDomainDn,
                                         TRUE,
                                         TRUE);
    if(dwRet){
        PrintMsg(TAPICFG_GENERIC_LDAP_ERROR, ldap_err2string(dwRet));
    }

    return(LdapMapErrorToWin32(dwRet));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\tapicfg\main.c ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    tapicfg/main.c

ABSTRACT:

    Stand alone application for administering TAPI directories.  This
    file is primarily the parser for the command line utility, the 
    operations themselves are abstracted out into functions in ilsng.c

DETAILS:

CREATED:

    07/20/2000    Brett Shirley (brettsh)

REVISION HISTORY:


--*/

#include <NTDSpch.h>
#pragma hdrstop
     
#include <winldap.h>
#include <ilsng.h>
#include <assert.h>
#include <locale.h>

#include <ndnc.h>

#include "print.h"
          
// ---------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------

       
// ---------------------------------------------------------------------
// Forward declarations 
// ---------------------------------------------------------------------

// Command Functions          
DWORD    Help(void);
DWORD    Install(WCHAR * wszServerName, WCHAR * wszPartitionDns, BOOL fForceDefault);
DWORD    Remove(WCHAR * wszPartitionDns, WCHAR * wszServerName);
DWORD    Show(WCHAR * wszDomainDns, BOOL fDefaultOnly);
DWORD    MakeDefault(WCHAR * wszPartitionDns, WCHAR * wszDomainDns);
// Helper functions
WCHAR *  wcsistr(WCHAR * wszStr, WCHAR * wszTarget);

// ---------------------------------------------------------------------
// Main Function
// ---------------------------------------------------------------------

INT __cdecl 
wmain (
    INT                argc,
    LPWSTR *           argv,
    LPWSTR *           envp
    )
/*++

Routine Description:

    This is the main, this is where it all starts up, and is the 
    first level of the parsing that happens for the tapicfg.exe 
    utility.

Arguments:

    argc (IN) - Number of arguments in argv.
    argv (IN) - The arguments from the command line.
    envp (IN) - The environmental variables from the shell.

Return value:

    INT - 0, success, otherwise error code.  This allows the program
    to be used in scripting.

--*/
{
    ULONG              i, dwRet;
    
    // The optional command line parameters
    WCHAR *            wszPartitionDns = NULL;
    WCHAR *            wszServerName = NULL;
    WCHAR *            wszDomainDns = NULL;
    BOOL               fForceDefault = FALSE;
    BOOL               fDefaultOnly = FALSE;
    UINT               Codepage;
                       // ".", "uint in decimal", null
    char               achCodepage[12] = ".OCP";
    
    //
    // Set locale to the default
    //
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%u", Codepage);
    }
    setlocale(LC_ALL, achCodepage);

    //
    // Parse the options
    //

    if(argc < 2){
        // There is no command, lets help them out.
        PrintMsg(TAPICFG_HELP_HELP_YOURSELF);
        return(ERROR_INVALID_PARAMETER);
    }

    for(i = 2; i < (ULONG) argc; i++){

        // Determine what optional command line parameter it is.
        if(_wcsicmp(argv[i], L"/forcedefault") == 0){

            fForceDefault = TRUE;

        } else if (_wcsicmp(argv[i], L"/defaultonly") == 0) {

            fDefaultOnly = TRUE;

        } else if (wcsistr(argv[i], L"/directory:")) {

            wszPartitionDns = wcschr(argv[i], L':');
            if(wszPartitionDns == NULL ||
               wszPartitionDns[1] == L'\0'){
                wszPartitionDns = NULL;

                PrintMsg(TAPICFG_CANT_PARSE_DIRECTORY);
                PrintMsg(TAPICFG_BLANK_LINE);
                PrintMsg(TAPICFG_HELP_HELP_YOURSELF);
                return(ERROR_INVALID_PARAMETER);
            }
            wszPartitionDns++;

        } else if (wcsistr(argv[i], L"/server:")) {
            wszServerName = wcschr(argv[i], L':');
            if(wszServerName == NULL ||
               wszServerName[1] == L'\0'){
                wszServerName = NULL;

                PrintMsg(TAPICFG_CANT_PARSE_SERVER);
                PrintMsg(TAPICFG_BLANK_LINE);
                PrintMsg(TAPICFG_HELP_HELP_YOURSELF);
                return(ERROR_INVALID_PARAMETER);
            }
            wszServerName++;

        } else if (wcsistr(argv[i], L"/domain:")) {
            wszDomainDns = wcschr(argv[i], L':');
            if(wszDomainDns == NULL ||
               wszDomainDns[1] == L'\0'){
                wszDomainDns = NULL;
                
                PrintMsg(TAPICFG_CANT_PARSE_DOMAIN);
                PrintMsg(TAPICFG_BLANK_LINE);
                PrintMsg(TAPICFG_HELP_HELP_YOURSELF);
                return(ERROR_INVALID_PARAMETER);
            }
            wszDomainDns++;

        } else {

            PrintMsg(TAPICFG_CANT_PARSE_COMMAND_LINE);
            PrintMsg(TAPICFG_BLANK_LINE);
            PrintMsg(TAPICFG_HELP_HELP_YOURSELF);
            return(ERROR_INVALID_PARAMETER);

        } // End if/else kind of optional parameter.

    } // End for parse each optional parameter.

#if DBG
wprintf(L"Done with parser - %ws %ws Partition:%ws: Server:%ws: Domain:%ws:\n",
        (fForceDefault)? L"ForceDefault": L"!ForceDefault",
        (fDefaultOnly)? L"DefaultOnly": L"!DefaultOnly",
        (wszPartitionDns)? wszPartitionDns: L" ",
        (wszServerName)? wszServerName : L" ",
        (wszDomainDns)? wszDomainDns : L" ");
#endif

    //
    // Parse and call the command
    //

    assert(argv[1]);
    if (_wcsicmp(argv[1], L"install") == 0){

        dwRet = Install(wszServerName, wszPartitionDns, fForceDefault);

    } else if (_wcsicmp(argv[1], L"remove") == 0) {

        dwRet = Remove(wszPartitionDns, wszServerName);

    } else if (_wcsicmp(argv[1], L"show") == 0) {

        dwRet = Show(wszDomainDns, fDefaultOnly);

    } else if (_wcsicmp(argv[1], L"makedefault") == 0) {

        dwRet = MakeDefault(wszPartitionDns, wszDomainDns);

    } else if (_wcsicmp(argv[1], L"help") == 0 ||
               _wcsicmp(argv[1], L"?") == 0 ||
               _wcsicmp(argv[1], L"/?") == 0 ||
               _wcsicmp(argv[1], L"-?") == 0){

        dwRet = Help();

    } else {

        PrintMsg(TAPICFG_BAD_COMMAND, argv[1]);
        PrintMsg(TAPICFG_BLANK_LINE);
        PrintMsg(TAPICFG_HELP_HELP_YOURSELF);
        dwRet = ERROR_INVALID_PARAMETER;

    }

    return(dwRet);
} /* wmain  */

// ---------------------------------------------------------------------
// Other/Helper Functions
// ---------------------------------------------------------------------

WCHAR *
wcsistr(
    IN      WCHAR *            wszStr,
    IN      WCHAR *            wszTarget
    )
/*++

Routine Description:

    This is just a case insensitive version of strstr(), which searches
    wszStr for the first occurance in it's entirety of wszTarget, and
    returns a pointer to that substring.

Arguments:

    wszStr (IN) - String to search.
    wszTarget (IN) - String to search for.

Return value:

    WCHAR pointer to substring.  Returns NULL if not found.

--*/
{
    ULONG              i, j;

    for(i = 0; wszStr[i] != L'\0'; i++){
        for(j = 0; (wszTarget[j] != L'\0') && (wszStr[i+j] != L'\0'); j++){
            if(toupper(wszStr[i+j]) != toupper(wszTarget[j])){
                break;
            }
        }
        if(wszTarget[j] == L'\0'){
            return(&(wszStr[i]));
        }
    }

    return(NULL);
}

DWORD
GetCommonParams(
    OPTIONAL  IN      WCHAR *    wszTarget,
    OPTIONAL  OUT     LDAP **    phld,
    OPTIONAL  OUT     WCHAR **   pwszDefaultDomainDn,
    OPTIONAL  IN      WCHAR *    wszDnsIn,
    OPTIONAL  OUT     WCHAR **   pwszDnOut
    )
/*++

Routine Description:

    This is a hack of a routine that basically just collescs a whole 
    bunch of generic parsing routines that I needed.  This is called
    with all parameters being optional.

Arguments:

    Note: although all the arguments are optional, you may not specify
    NULL for all arguments.  You must specify one of these complete 
    sets of data (either all vars on the line or none on the line):
	phld & wszTarget
        pwszDefaultDomainDn & phld (& implicitly wszTarget)
        pwszDnOut & wszDnsIn 

    wszTarget (IN) - This is the string of the server to bind to, can
        be string of a domain, a server, or NULL (connect to local server).
    phld (OUT) - This is the handle gained from the bind to wszTarget.
    pwszDefaultDomainDn - If this is specified, then the caller, wants
        the default domain of the server bound to in phld.
    wszDnsIn (IN) - If the caller provids this, then they're looking to
        get the associated DN for this DNS name.
    pwszDnOut (OUT) - This is the DN cracked from the wszDnsIn.

Return value:

    an Win32 error code if any of the conversions failed.

--*/
{
    DWORD              dwRet = ERROR_SUCCESS;
    DWORD              dwLdapErr = LDAP_SUCCESS;
    WCHAR *            wszTemp = NULL;

    // Make sure they specified at least one out param.
    assert(phld || pwszDefaultDomainDn || pwszDnOut);
    // Give a certain output make sure they also have the associated
    // proper inputs.
    assert(phld && !pwszTarget);
    assert(pwszDefaultDomainDn && !phld);
    assert(pwszDnOut && !wszDnsIn);

   
    //
    // First NULL out all out params
    //

    if(phld){
        *phld = NULL;
    }
    if(pwszDefaultDomainDn){
        *pwszDefaultDomainDn = NULL;
    }
    if(pwszDnOut){
        *pwszDnOut = NULL;
    }
    
    //
    // One by One try to fill the out params.
    //

    __try{

        // LDAP Binding.
        //

        if(wszDnsIn &&
           (wszDnsIn[0] == L'D' || wszDnsIn[0] == L'd') &&
           (wszDnsIn[1] == L'C' || wszDnsIn[1] == L'c') && 
           wszDnsIn[2] == L'='){
           // Dns name should not start with DN, probably made mistake,
           // and specified DN instead of Dns NC name.
           PrintMsg(TAPICFG_BAD_DNS, wszDnsIn, ERROR_INVALID_PARAMETER);
        }
        if(pwszDnOut && wszDnsIn){
            dwRet = GetDnFromDns(wszDnsIn, pwszDnOut);
            if(dwRet){
                PrintMsg(TAPICFG_BAD_DNS, wszDnsIn, dwRet);
                __leave;
            }
            assert(pwszDnOut);
        }

        if(phld){
            // This will either bind to the domain, or to the local server if 
            // the parameter is NULL.  Either way, this is what we want.
            *phld = GetNdncLdapBinding(wszTarget, &dwLdapErr, FALSE, NULL);
            if (dwLdapErr) {

                wszTemp = ldap_err2string(dwLdapErr);
                dwRet = LdapMapErrorToWin32(dwLdapErr);

                if(wszTemp && wszTemp[0] != L'\0'){
                    if(wszTarget){       
                        PrintMsg(TAPICFG_LDAP_CONNECT_FAILURE, wszTarget, wszTemp);
                    } else {
                        PrintMsg(TAPICFG_LDAP_CONNECT_FAILURE_SERVERLESS, wszTemp);
                    }
                } else {
                    if(wszTarget){       
                        PrintMsg(TAPICFG_LDAP_CONNECT_FAILURE_SANS_ERR_STR, wszTarget, 
                                 dwRet, dwLdapErr);
                    } else {
                        PrintMsg(TAPICFG_LDAP_CONNECT_FAILURE_SERVERLESS_SANS_ERR_STR,
                                 dwRet, dwLdapErr);
                    }
                }
                __leave;
            }
            assert(*phld);
        }

        if(pwszDefaultDomainDn && *phld){
            dwLdapErr = GetRootAttr(*phld, L"defaultNamingContext", pwszDefaultDomainDn);
            if(dwLdapErr){
                PrintMsg(TAPICFG_LDAP_ERROR_DEF_DOM, ldap_err2string(dwLdapErr));
                dwRet = LdapMapErrorToWin32(dwLdapErr);
                __leave;
            }
            assert(*pwszDefaultDomainDn);
        }

    } __finally {
        if(dwRet){
            // There were errors clean up anything that may need to be.
            if(pwszDnOut && *pwszDnOut){ 
                LocalFree(*pwszDnOut);
                *pwszDnOut = NULL;
            }
            if(pwszDefaultDomainDn && *pwszDefaultDomainDn){ 
                LocalFree(*pwszDefaultDomainDn);
                *pwszDefaultDomainDn = NULL;
            }
            if(phld && *phld){
                ldap_unbind(*phld);
                *phld = NULL;
            }
        }
    }
        
    return(dwRet);
}


void
FreeCommonParams(
    IN      LDAP *     hld,
    IN      WCHAR *    wszIn1,
    IN      WCHAR *    wszIn2
    )
{
/*++

Routine Description:

    Associated free routine for GetCommonParams().  Pretty self explanatory.

--*/
    if(hld) { ldap_unbind(hld); }
    if(wszIn1) { LocalFree(wszIn1); }
    if(wszIn2) { LocalFree(wszIn2); }
}

// ---------------------------------------------------------------------
// Command Functions
// ---------------------------------------------------------------------

DWORD
Help(void)
/*++

Routine Description:

    This command/function simply prints out help for the tapicfg.exe

Return value:

    Win 32 error, always success though. ;)

--*/
{
    PrintMsg(TAPICFG_HELP_DESCRIPTION);
    PrintMsg(TAPICFG_BLANK_LINE);
    PrintMsg(TAPICFG_HELP_SYNTAX);
    PrintMsg(TAPICFG_BLANK_LINE);
    PrintMsg(TAPICFG_HELP_PARAMETERS_HEADER);
    PrintMsg(TAPICFG_BLANK_LINE);
    

    PrintMsg(TAPICFG_HELP_CMD_INSTALL);
    PrintMsg(TAPICFG_BLANK_LINE);
    
    PrintMsg(TAPICFG_HELP_CMD_REMOVE);
    PrintMsg(TAPICFG_BLANK_LINE);
    
    PrintMsg(TAPICFG_HELP_CMD_SHOW);
    PrintMsg(TAPICFG_BLANK_LINE);
    
    PrintMsg(TAPICFG_HELP_CMD_MAKEDEFAULT);
    PrintMsg(TAPICFG_BLANK_LINE);
    
    PrintMsg(TAPICFG_HELP_REMARKS);
    PrintMsg(TAPICFG_BLANK_LINE);

    return(ERROR_SUCCESS);
} // End PrintHelpScreen()

DWORD
Install(
    IN     WCHAR *     wszServerName,
    IN     WCHAR *     wszPartitionDns,
    IN     BOOL        fForceDefault
    )
/*++

Routine Description:

    This command/function continues parsing of the parameters so that
    InstallISLNG() can handle them well.

Arguments:

    wszServerName (IN) - Server name to install the TAPI Dir on.
    wszPartitionDns (IN) - DNS name of the TAPI Dir to install.
    fForceDefault (IN) - Whether to overwrite an existing Default SCP
        object with this TAPI Dir for the Default TAPI Dir.

Return value:

    A Win32 error.

--*/
{
    DWORD              dwRet = ERROR_SUCCESS;
    WCHAR *            wszPartitionDn = NULL;
    LDAP *             hld = NULL;

    //
    // Validate and Convert Arguments
    // 

    if(!wszPartitionDns){
        PrintMsg(TAPICFG_PARAM_ERROR_NO_PARTITION_NAME);
        return(ERROR_INVALID_PARAMETER);
    }

    dwRet = GetCommonParams(wszServerName, &hld, NULL, 
                            wszPartitionDns, &wszPartitionDn);
    if(dwRet){
        // GetCommomParams() already printed error.
        return(dwRet);
    }

    //
    // Call guts of command
    //

    dwRet = InstallILSNG(hld, wszPartitionDn, fForceDefault, FALSE);
    if(dwRet == ERROR_SUCCESS){
        PrintMsg(TAPICFG_SUCCESS);
    }

    FreeCommonParams(hld, wszPartitionDn, NULL);

    return(dwRet);
}

DWORD
Remove(
    IN      WCHAR *     wszPartitionDns,
    IN      WCHAR *     wszServerName
    )
/*++

Routine Description:

    This removes the TAPI Directory service from the machine on which
    it's installed.

Arguments:

    wszPartitionDns (IN) - The TAPI Directory to obliterate.

Return value:

    A Win32 error.

--*/
{
    DWORD       dwRet = ERROR_SUCCESS;
    LDAP *      hld = NULL;
    WCHAR *     wszPartitionDn = NULL;

    //
    // Validate and Convert Arguments
    // 

    if(!wszPartitionDns){
        PrintMsg(TAPICFG_PARAM_ERROR_NO_PARTITION_NAME);
        return(ERROR_INVALID_PARAMETER);
    }

    dwRet = GetCommonParams((wszServerName) ? wszServerName : wszPartitionDns, &hld, NULL, 
                            wszPartitionDns, &wszPartitionDn);
    if(dwRet){
        // GetCommonParams() already printed errors.
        if (wszServerName == NULL) {
            PrintMsg(TAPICFG_TRY_SERVER_OPTION, wszPartitionDns);
        }

        return(dwRet);
    }
    
    //
    // Call guts of command
    //

    assert(wszPartitionDn);

    dwRet = UninstallILSNG(hld, wszPartitionDn);
    dwRet = LdapMapErrorToWin32(dwRet);
    if(dwRet == ERROR_SUCCESS){
        PrintMsg(TAPICFG_SUCCESS);
    }

    FreeCommonParams(hld, wszPartitionDn, NULL);
    
    return(dwRet);
}

DWORD
Show(
    IN      WCHAR *      wszDomainDns,
    IN      BOOL         fDefaultOnly
    )
/*++

Routine Description:

    This routine prints out all the TAPI Directory as specified by thier
    SCPs.  This also specifies which one is the default TAPI Dir.

Arguments:

    wszDomainDns (IN) - The Domain to list the SCPs of.
    fDefaultOnly (IN) - Whether to only print the default SCP.

Return value:

    A Win32 error.
    
--*/
{
    DWORD        dwRet = ERROR_SUCCESS;
    LDAP *       hld = NULL;
    WCHAR *      wszDomainDn = NULL;
    
    //
    // Validate and Convert Arguments
    // 

    dwRet = GetCommonParams(wszDomainDns, &hld, NULL, 
                            wszDomainDns, &wszDomainDn);
    if(dwRet){
        // GetCommonParams() already printed errors.
        return(dwRet);
    }

    //
    // Call guts of command
    //

    assert(wszDomainDn);
    assert(hld);

    dwRet = ListILSNG(hld, wszDomainDn, fDefaultOnly);
    dwRet = LdapMapErrorToWin32(dwRet);
    if(dwRet == ERROR_SUCCESS){
        PrintMsg(TAPICFG_SUCCESS);
    }

    FreeCommonParams(hld, wszDomainDn, NULL);

    return(dwRet);
}

DWORD
MakeDefault(
    IN      WCHAR *       wszPartitionDns,
    IN      WCHAR *       wszDomainDns
    )
/*++

Routine Description:

    To force the Default SCP to point to the TAPI Directory specified 
    (wszPartitionDns).

Arguments:

    wszPartitionDns (IN) - The TAPI Directory name to be pointed at.
    wszDomainDns (IN) - The Domain in which to register the Default TAPI
        Directory SCP.

Return value:

    A Win32 error.                        
                      
--*/
{
    DWORD                 dwRet = ERROR_SUCCESS;
    LDAP *                hld = NULL;
    WCHAR *               wszPartitionDn = NULL;
    WCHAR *               wszDomainDn = NULL;

    //
    // Validate and Convert Arguments
    // 

    if(!wszPartitionDns){
        PrintMsg(TAPICFG_PARAM_ERROR_NO_PARTITION_NAME);
        return(ERROR_INVALID_PARAMETER);
    }

    if(wszDomainDns){
        dwRet = GetDnFromDns(wszDomainDns, &wszDomainDn);
        if(dwRet){
            PrintMsg(TAPICFG_BAD_DNS, wszDomainDns, dwRet);
            return(dwRet);
        }
        dwRet = GetCommonParams(wszDomainDns, &hld, NULL, 
                                wszPartitionDns, &wszPartitionDn);
    } else {
        dwRet = GetCommonParams(NULL, &hld, &wszDomainDn, 
                                wszPartitionDns, &wszPartitionDn);
    }

    if(dwRet){
        if(wszDomainDn) { LocalFree(wszDomainDn); }
        // GetCommonParams() already printed errors.
        return(dwRet);
    }

    //
    // Call guts of command
    //
                     
    assert(hld);
    assert(wszPartitionDn);
    assert(wszDomainDn);
    
    dwRet = ReregisterILSNG(hld, wszPartitionDn, wszDomainDn);
    dwRet = LdapMapErrorToWin32(dwRet);
    if(dwRet == ERROR_SUCCESS){
        PrintMsg(TAPICFG_SUCCESS);
    }

    FreeCommonParams(hld, wszDomainDn, wszPartitionDn);
                
    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\tlog\tlog.c ===
/*++

   Copyright (c) 1998 Microsoft Corporation. All rights reserved.

MODULE NAME:

    tlog.c

ABSTRACT:

    File logging routines. A lot of them copied unshamefully from
    netlogon.

--*/

#include <NTDSpch.h>
#include <dststlog.h>
#include "tlog.h"

BOOL fileOpened = FALSE;

BOOL
PrintLog(
    IN DWORD    Flags,
    IN LPSTR    Format,
    ...
    )
{

    va_list arglist;

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &csLogFile );

    if ( !fileOpened ) {
        fileOpened = DsOpenLogFile("ds", NULL, TRUE);
    }

    //
    // Simply change arguments to va_list form and call DsPrintRoutineV
    //

    va_start(arglist, Format);

    DsPrintRoutineV( Flags, Format, arglist );

    va_end(arglist);

    LeaveCriticalSection( &csLogFile );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\xmlschema\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\tlog\tlog.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    tlog.h

Abstract:

    Main header file for the logging routine.

--*/

#ifndef _TLOG_H_
#define _TLOG_H_

//
// from dscommon\filelog.c
//

VOID
DsPrintRoutineV(
    IN DWORD Flags,
    IN LPSTR Format,
    va_list arglist
    );

BOOL
DsOpenLogFile(
    IN PCHAR FilePrefix,
    IN PCHAR MiddleName, 
    IN BOOL fCheckDSLOGMarker
    );

VOID
DsCloseLogFile(
    VOID
    );

extern CRITICAL_SECTION csLogFile;

#endif // _TLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\tlog\main.c ===
#include <NTDSpch.h>
#include "tlog.h"

CRITICAL_SECTION csLogFile;
BOOL    fCSInit = FALSE;

BOOL 
WINAPI
DllEntry( 
   IN HINSTANCE hDll, 
   IN DWORD dwReason, 
   IN LPVOID lpvReserved 
   )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:

        if ( !InitializeCriticalSectionAndSpinCount(&csLogFile, 400) ) {
            fReturn = FALSE;
        } else {
            fCSInit = TRUE;
        }

        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH:
        DsCloseLogFile( );
        if ( fCSInit ) {
            DeleteCriticalSection(&csLogFile);
            fCSInit = FALSE;
        }
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break ;
    }

    return (fReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\xmlschema\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by XMLSchema.rc
//
#define IDS_PROJNAME                    100
#define IDR_SCHEMADOC                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\xmlschema\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( XMLSchema )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( XMLSchema ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\xmlschema\xmlschema.cpp ===
// XMLSchema.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f XMLSchemaps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "XMLSchema.h"

#include "XMLSchema_i.c"
#include "SchemaDoc.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SchemaDoc, CSchemaDoc)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_XMLSCHEMALib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\xmlschema\xmlschema_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Tue Jan 11 17:35:31 2000
 */
/* Compiler settings for D:\SRC\XMLSchema\XMLSchema.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISchemaDoc,0xB1104680,0x42A2,0x4C84,0x85,0x85,0x4B,0x2E,0x2A,0xB8,0x64,0x19);


MIDL_DEFINE_GUID(IID, LIBID_XMLSCHEMALib,0x4B990568,0x2DFE,0x4F1C,0xAF,0x61,0x4E,0xB7,0x10,0xFA,0x79,0x56);


MIDL_DEFINE_GUID(CLSID, CLSID_SchemaDoc,0x06A0D83D,0x711D,0x4114,0xB9,0x32,0xFD,0x36,0xA1,0xD7,0xF0,0x80);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Tue Jan 11 17:35:31 2000
 */
/* Compiler settings for D:\SRC\XMLSchema\XMLSchema.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISchemaDoc,0xB1104680,0x42A2,0x4C84,0x85,0x85,0x4B,0x2E,0x2A,0xB8,0x64,0x19);


MIDL_DEFINE_GUID(IID, LIBID_XMLSCHEMALib,0x4B990568,0x2DFE,0x4F1C,0xAF,0x61,0x4E,0xB7,0x10,0xFA,0x79,0x56);


MIDL_DEFINE_GUID(CLSID, CLSID_SchemaDoc,0x06A0D83D,0x711D,0x4114,0xB9,0x32,0xFD,0x36,0xA1,0xD7,0xF0,0x80);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\xmlschema\xmlschema.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Tue Jan 11 17:35:31 2000
 */
/* Compiler settings for D:\SRC\XMLSchema\XMLSchema.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __XMLSchema_h__
#define __XMLSchema_h__

/* Forward Declarations */ 

#ifndef __ISchemaDoc_FWD_DEFINED__
#define __ISchemaDoc_FWD_DEFINED__
typedef interface ISchemaDoc ISchemaDoc;
#endif 	/* __ISchemaDoc_FWD_DEFINED__ */


#ifndef __SchemaDoc_FWD_DEFINED__
#define __SchemaDoc_FWD_DEFINED__

#ifdef __cplusplus
typedef class SchemaDoc SchemaDoc;
#else
typedef struct SchemaDoc SchemaDoc;
#endif /* __cplusplus */

#endif 	/* __SchemaDoc_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ISchemaDoc_INTERFACE_DEFINED__
#define __ISchemaDoc_INTERFACE_DEFINED__

/* interface ISchemaDoc */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISchemaDoc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1104680-42A2-4C84-8585-4B2E2AB86419")
    ISchemaDoc : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateXMLDoc( 
            /* [in] */ BSTR bstrOutputFile,
            /* [in] */ BSTR bstrFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPath_and_ID( 
            /* [in] */ BSTR bstrPath,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaDocVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISchemaDoc __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISchemaDoc __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISchemaDoc __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISchemaDoc __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISchemaDoc __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISchemaDoc __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISchemaDoc __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateXMLDoc )( 
            ISchemaDoc __RPC_FAR * This,
            /* [in] */ BSTR bstrOutputFile,
            /* [in] */ BSTR bstrFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPath_and_ID )( 
            ISchemaDoc __RPC_FAR * This,
            /* [in] */ BSTR bstrPath,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrPassword);
        
        END_INTERFACE
    } ISchemaDocVtbl;

    interface ISchemaDoc
    {
        CONST_VTBL struct ISchemaDocVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaDoc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISchemaDoc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISchemaDoc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISchemaDoc_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISchemaDoc_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISchemaDoc_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISchemaDoc_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISchemaDoc_CreateXMLDoc(This,bstrOutputFile,bstrFilter)	\
    (This)->lpVtbl -> CreateXMLDoc(This,bstrOutputFile,bstrFilter)

#define ISchemaDoc_SetPath_and_ID(This,bstrPath,bstrName,bstrPassword)	\
    (This)->lpVtbl -> SetPath_and_ID(This,bstrPath,bstrName,bstrPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISchemaDoc_CreateXMLDoc_Proxy( 
    ISchemaDoc __RPC_FAR * This,
    /* [in] */ BSTR bstrOutputFile,
    /* [in] */ BSTR bstrFilter);


void __RPC_STUB ISchemaDoc_CreateXMLDoc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISchemaDoc_SetPath_and_ID_Proxy( 
    ISchemaDoc __RPC_FAR * This,
    /* [in] */ BSTR bstrPath,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword);


void __RPC_STUB ISchemaDoc_SetPath_and_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISchemaDoc_INTERFACE_DEFINED__ */



#ifndef __XMLSCHEMALib_LIBRARY_DEFINED__
#define __XMLSCHEMALib_LIBRARY_DEFINED__

/* library XMLSCHEMALib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_XMLSCHEMALib;

EXTERN_C const CLSID CLSID_SchemaDoc;

#ifdef __cplusplus

class DECLSPEC_UUID("06A0D83D-711D-4114-B932-FD36A1D7F080")
SchemaDoc;
#endif
#endif /* __XMLSCHEMALib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\xmlschema\schemadoc.cpp ===
// SchemaDoc.cpp : Implementation of CSchemaDoc
#include "stdafx.h"
#include "sddl.h"		// Security Descriptor Definition Language info
#include "XMLSchema.h"
#include "SchemaDoc.h"

/////////////////////////////////////////////////////////////////////////////
// CSchemaDoc

// Constructor/Destructor
CSchemaDoc::CSchemaDoc()
{
	HRESULT hr;
	ITypeLib   *pITypeLib;
	m_pTypeInfo = NULL;

	m_dwFlag = 0;
	m_hFile = NULL;
	m_hTempFile = NULL;

	hr = LoadRegTypeLib(LIBID_XMLSCHEMALib, 1, 0, 
                        PRIMARYLANGID(GetSystemDefaultLCID()), &pITypeLib);

	if ( SUCCEEDED(hr) )
	{
		hr   = pITypeLib->GetTypeInfoOfGuid(IID_ISchemaDoc, &m_pTypeInfo);
	}
	pITypeLib->Release();
}

CSchemaDoc::~CSchemaDoc()
{
	if ( m_pTypeInfo )
	{
		m_pTypeInfo->Release();
	}
	CloseXML();
}

/////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP CSchemaDoc::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISchemaDoc
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//////////////////////////////////////////////////// 
// Delegating IDispatch Methods to the aggregator
//////////////////////////////////////////////////////
STDMETHODIMP CSchemaDoc::GetTypeInfoCount(UINT* pctinfo)
{
   IDispatch*	pDisp;
   HRESULT		hr;

   hr = OuterQueryInterface( IID_IDispatch, (void**) &pDisp );

   if ( SUCCEEDED(hr) )
   {
	   hr = pDisp->GetTypeInfoCount( pctinfo );
	   pDisp->Release();
   }   
   return hr;
}


STDMETHODIMP CSchemaDoc::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{
   IDispatch* pDisp;
   HRESULT    hr;

   hr = OuterQueryInterface( IID_IDispatch, (void**) &pDisp );

   if ( SUCCEEDED(hr) )
   {
	   hr = pDisp->GetTypeInfo( itinfo, lcid, pptinfo );
	   pDisp->Release();
   }
   return hr;
}

STDMETHODIMP CSchemaDoc::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
									   LCID lcid, DISPID* rgdispid)
{
   IDispatch *pDisp;
   HRESULT    hr;

   hr = OuterQueryInterface( IID_IDispatch, (void**) &pDisp );

   if ( SUCCEEDED(hr) )
   {
	   hr = pDisp->GetIDsOfNames( riid, rgszNames, cNames, lcid, rgdispid);
	   pDisp->Release();
   }
   return hr;
}

STDMETHODIMP CSchemaDoc::Invoke(DISPID dispidMember, REFIID riid,
								LCID lcid, WORD wFlags, DISPPARAMS* pdispparams,
								VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
								UINT* puArgErr)
{
   IDispatch *pDisp;
   HRESULT    hr;

   hr = OuterQueryInterface( IID_IDispatch, (void**) &pDisp );

   if ( SUCCEEDED(hr) )
   {
	   hr = pDisp->Invoke( dispidMember, riid, lcid, wFlags, pdispparams, pvarResult,
		                   pexcepinfo, puArgErr);
	   pDisp->Release();
   }
   return hr;
}

///////////////////////////////////////////////////////////////////////////////
// End delegating IDispatch Methods
///////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------
// This is the entry point for this component.  It opens the output file and
// has the requested schema components stored there.
// ---------------------------------------------------------------------------
STDMETHODIMP CSchemaDoc::CreateXMLDoc(BSTR bstrOutputFile, BSTR bstrFilter)
{
	HRESULT hr = S_OK;

	hr = OpenXML(bstrOutputFile);

	if (hr == S_OK)
	{
		hr = SaveAsXMLSchema(bstrFilter);

		if (hr == S_OK)
			CopyComments();
	}
	CloseXML();
	return hr;
} // CreateXMLDoc

// ---------------------------------------------------------------------------
// This method opens the output and temp file.  The temporary file is used to
// temporarily store the comment data.
// ---------------------------------------------------------------------------
HRESULT CSchemaDoc::OpenXML(BSTR bstrFile)
{
	HRESULT hr = S_OK;

	OFSTRUCT	of;
	HANDLE		hFile;
	TCHAR		szFilename[MAX_PATH];

	of.cBytes = sizeof(of);
	sprintf(szFilename, "%S", bstrFile);
	hFile = (HANDLE)OpenFile(szFilename, &of, OF_READWRITE);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}
    else  // The file was successfully opened
    {
		m_hFile = hFile;
		GetTempFileName(".", "XML", 0, szFilename);

    	hFile = CreateFile(szFilename, GENERIC_READ | GENERIC_WRITE,
	    				   0, NULL, CREATE_ALWAYS,
                           FILE_FLAG_DELETE_ON_CLOSE, NULL);

		if (hFile == INVALID_HANDLE_VALUE)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
		else
			m_hTempFile = hFile;

		// Move to the end of the file
		SetFilePointer(m_hFile, 0, 0, FILE_END);
    }
	return hr;
} // OpenXML

HRESULT CSchemaDoc::CloseXML()
{
	if ( m_hFile )
	{
        CloseHandle(m_hFile);
		m_hFile = NULL;
	}
	if ( m_hTempFile )
	{
        CloseHandle(m_hTempFile);
		m_hTempFile = NULL;
	}
	return S_OK;
} // CloseXML

HRESULT CSchemaDoc::WriteLine(HANDLE hFile, LPCSTR pszBuff, UINT nIndent)
{
	HRESULT hr;

	hr = Write(hFile, pszBuff, nIndent);

	if (SUCCEEDED(hr))
		hr = Write(hFile, "\r\n");

	return hr;
} // WriteLine

HRESULT CSchemaDoc::Write(HANDLE hFile, LPCSTR pszBuff, UINT nIndent)
{
	HRESULT hr = S_OK;

	if (hFile != NULL ) 
	{
		BOOL	bNoFileError = TRUE;
		DWORD	dwBytesWritten;

        if (nIndent)
        {
            char szBuf[MAX_INDENT];

            if (nIndent >= MAX_INDENT)
                nIndent = MAX_INDENT -1;

            strnset(szBuf, ' ', nIndent);
            bNoFileError = WriteFile(hFile, szBuf, nIndent, &dwBytesWritten, NULL);
        }
        if (bNoFileError)
            bNoFileError = WriteFile(hFile, pszBuff, strlen(pszBuff),
									&dwBytesWritten, NULL);

        if (bNoFileError == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
	}
    else
        hr = E_INVALIDARG;

	return hr;
} // Write

// ---------------------------------------------------------------------------
// This function displays the names of classes that the specified attribute is
// is used by.
//
// INPUTS:
//   pSearch - a pointer to the IDirectorySearch interface pointer
//
// OUTPUTS: None
//
// RETURN: the HRESULT from the request.
// ---------------------------------------------------------------------------
HRESULT CSchemaDoc::DisplayContainedIns(IDirectorySearch* pSearch)
{
	ADS_SEARCH_COLUMN	col;
	HRESULT				hr;
	ADS_SEARCH_HANDLE	hSearch;
	LPWSTR				pAttr[] = { L"CN" };
	LPWSTR				pszFilter= NULL;
	char				szBuf[2000];
	WCHAR				wBuf[2000];

	swprintf(wBuf, L"(&(|(systemMustContain=%s)(MustContain=%s)(systemMayContain=%s)(MayContain=%s))(objectCategory=classSchema))",
			 m_bstrLastCN, m_bstrLastCN, m_bstrLastCN, m_bstrLastCN);
	pszFilter = wBuf;

	hr = pSearch->ExecuteSearch(pszFilter, pAttr, 1, &hSearch);

	if (SUCCEEDED(hr))
		hr = pSearch->GetFirstRow( hSearch );

	// Read the information for each returned class
	while (SUCCEEDED(hr) && hr != S_ADS_NOMORE_ROWS)
	{
		hr = pSearch->GetColumn(hSearch, L"cn", &col);

		if (SUCCEEDED(hr))  // Display the next contained in class
		{
			Write(m_hFile, "<sd:comment-containedIn>", INDENT_DSML_ATTR_ENTRY);
			sprintf(szBuf, "%.2000S", col.pADsValues->CaseIgnoreString);
			Write(m_hFile, szBuf);
			WriteLine(m_hFile, "</sd:comment-containedIn>");
		}
		hr = pSearch->GetNextRow(hSearch);
	}
	return hr;
} // DisplayContainedIns

// ---------------------------------------------------------------------------
// This function displays an attribute that was retrieved during an LDAP
// search.  It will convert the value to a displayable form based on its type.
// This function will only display single-valued attributes.
//
// INPUTS:
//   pSearch - a pointer to the IDirectorySearch interface pointer
//   pAttr   - the name of the attribute to display.
//   hSearch - a handle to the last search results.
//
// OUTPUTS: None
//
// RETURN: the HRESULT from the request.
// ---------------------------------------------------------------------------
HRESULT CSchemaDoc::DisplayXMLAttribute(IDirectorySearch* pSearch, LPWSTR pAttr,
										ADS_SEARCH_HANDLE hSearch)
{
	ADS_SEARCH_COLUMN	col;
	HRESULT				hr;
	char				szAttr[2000];


	// Write the beginning XML tag
	if (wcscmp(pAttr, L"searchFlags") == 0)
		pAttr = L"IsIndexed";

    sprintf(szAttr, "%.2000S", pAttr);
	strcat(szAttr, ">");

	Write(m_hFile, "<sd:",INDENT_DSML_ATTR_ENTRY);
	Write(m_hFile, szAttr);

	hr = pSearch->GetColumn(hSearch, pAttr, &col);

	if (SUCCEEDED(hr))
	{
		// Get the IsIndexed value from the search flags
		if (wcscmp(pAttr, L"searchFlags") == 0)
		{
			col.pADsValues->dwType = ADSTYPE_BOOLEAN;
			col.pADsValues->Integer &= 1;
		}

		CComBSTR				bstrDesc;
		DWORD					i;
		unsigned char*			puChar;
		PISECURITY_DESCRIPTOR	pSD;
		LPTSTR					pszDesc;
      	char	                szBuf[2000];

		switch(col.pADsValues->dwType)
		{
			case ADSTYPE_BOOLEAN:
				if (col.pADsValues->Boolean == TRUE)
					Write(m_hFile, "True");
				else
					Write(m_hFile, "False");
				break;

			case ADSTYPE_INTEGER:
				sprintf(szBuf, "%d", col.pADsValues->Integer);
				hr = Write(m_hFile, szBuf);
				break;

			case ADSTYPE_NT_SECURITY_DESCRIPTOR:
				pSD = (PISECURITY_DESCRIPTOR)col.pADsValues->SecurityDescriptor.lpValue;

				if (ConvertSecurityDescriptorToStringSecurityDescriptor(pSD,
						SDDL_REVISION_1, GROUP_SECURITY_INFORMATION | 
						OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION |
						SACL_SECURITY_INFORMATION, &pszDesc, NULL ))
				{
					Write(m_hFile, pszDesc);
					LocalFree(pszDesc);
				}
				else
					Write(m_hFile, "Security descriptor");
				break;

			case ADSTYPE_OCTET_STRING:
				puChar = (unsigned char*)col.pADsValues->OctetString.lpValue;

				for (i = 0; i < col.pADsValues->OctetString.dwLength; ++i)
				{
					sprintf(&szBuf[i*2], "%02X", puChar[i]);
				}
				hr = Write(m_hFile, szBuf);
				break;

			default:
                sprintf(szBuf, "%.2000S", col.pADsValues->CaseIgnoreString);

                // Update the temp file and save the value of the
				// LDAPDisplayName for later use
				if (wcscmp(pAttr, L"LDAPDisplayName") == 0)
				{
					Write(m_hTempFile, "<sd:LDAPDisplayName>",INDENT_DSML_ATTR_ENTRY);
					Write(m_hTempFile, szBuf);
					WriteLine(m_hTempFile, "</sd:LDAPDisplayName>");

					m_bstrLastCN = col.pADsValues->CaseIgnoreString;
				}
                sprintf(szBuf, "%.2000S", col.pADsValues->CaseIgnoreString);
				hr = Write(m_hFile, szBuf);
		}
		pSearch->FreeColumn(&col);
	}
	// Write the termination XML tag
	Write(m_hFile, "</sd:");
	WriteLine(m_hFile, szAttr);

	return hr;
} // DisplayXMLAttribute

// ---------------------------------------------------------------------------
// This function displays a multi-valued attribute that was retrieved during
// an LDAP search.  It is assumed that the value is a string.
//
// INPUTS:
//   pSearch - a pointer to the IDirectorySearch interface pointer
//   pAttr   - the name of the attribute to display.
//   hSearch - a handle to the last search results.
//
// OUTPUTS: None
//
// RETURN: the HRESULT from the request.
// ---------------------------------------------------------------------------
HRESULT CSchemaDoc::DisplayMultiAttribute(IDirectorySearch* pSearch, LPWSTR pAttr,
									  ADS_SEARCH_HANDLE hSearch)
{
	ADS_SEARCH_COLUMN	col;
	HRESULT				hr;
	char				szBuf[2000];

	hr = pSearch->GetColumn(hSearch, pAttr, &col);

	if (SUCCEEDED(hr))
	{
    	DWORD i;

		for( i=0; i < col.dwNumValues; i++ )
		{
			Write(m_hFile, "<sd:AttrCommonName>", INDENT_DSML_ATTR_VALUE);
			sprintf(szBuf, "%.2000S", col.pADsValues[i].CaseIgnoreString);
			Write(m_hFile, szBuf);
			WriteLine(m_hFile, "</sd:AttrCommonName>");
		}
	}
	return hr;
} // DisplayMultiAttribute

// ---------------------------------------------------------------------------
// This function is responsible for writing the class and attribute data to
// the output file.  It first displays all the class information that matches
// the filter.  Then all of the attribute information.  The filter is assumed
// to be a prefix for the class and attribute's LDAP Display Name.
//
// INPUTS:
//   szFilter - the prefix of the classes and attributes to search for.
//
// OUTPUTS: None
//
// RETURN: the HRESULT from the request.
// ---------------------------------------------------------------------------
HRESULT CSchemaDoc::SaveAsXMLSchema(LPWSTR szFilter)
{
	// Class properties
	LPWSTR pAttrs[] = { L"CN",							// 0
		                L"DefaultObjectCategory",		// 1
						L"ObjectCategory",				// 2
						L"GovernsID",					// 3
						L"SchemaIDGUID",				// 4
						L"SubClassOf",					// 5
						L"InstanceType",				// 6
						L"DefaultSecurityDescriptor",	// 7
						L"NTSecurityDescriptor",		// 8
						L"LDAPDisplayName",				// 9
						L"AuxiliaryClass",				//10
						L"PossSuperiors",				//11
						L"RDNAttID",					//12
						L"SystemMustContain",			//13
						L"MustContain",					//14
						L"SystemMayContain",			//15
						L"MayContain"					//16
	};

	// Attribute properties
	LPWSTR pAttrs1[] = {L"CN",							// 0
						L"LDAPDisplayName",				// 1
						L"AttributeID",					// 2
		                L"AttributeSyntax",				// 3
						L"OMSyntax",					// 4
						L"AttributeSecurityGUID",		// 5
						L"SchemaIDGUID",				// 6
						L"RangeLower",					// 7
						L"RangeUpper",					// 8
						L"IsSingleValued",				// 9
						L"IsEphemeral",					//10
						L"IsMemberOfPartialAttributeSet",	//11
						L"searchFlags",					//12
						L"NTSecurityDescriptor",		//13
						L"LinkID"						//14
	};

	CComBSTR					bstrFilter;
	CComBSTR					bstrPath;
	DWORD						dwNum = sizeof(pAttrs) / sizeof(LPWSTR);
	DWORD						dwPrefInfo=2;
	HRESULT						hr;
	ADS_SEARCH_HANDLE			hSearch=NULL;
	DWORD						i;
	CComPtr<IADs>				pADs = NULL;
	CComPtr<IADsObjectOptions>	pOpt = NULL;
	ADS_SEARCHPREF_INFO			prefInfo[2];
	CComPtr<IDirectorySearch>	pSearch     = NULL;
	LPWSTR						pszFilter   = NULL;
	LPWSTR						pszPassword = NULL;
	LPWSTR						pszUserName = NULL;
	CComVariant                 varServer, var;

	// Get the user Name
	if ( m_sUserName.Length() )
	{
		pszUserName = m_sUserName;
	}
	// Get Password
	if ( m_sPassword.Length() )
	{
		pszPassword = m_sPassword;
	}
	hr = ADsOpenObject(m_sDirPath, pszUserName, pszPassword, m_dwFlag,
					   IID_IADs, (void**) &pADs);

	// Get the IDirectorySearch interface pointer
	if (SUCCEEDED(hr))
		hr = ADsOpenObject(m_sDirPath, pszUserName, pszPassword, m_dwFlag, IID_IDirectorySearch,
					  (void**) &pSearch);

	if (SUCCEEDED(hr))
	{
		// Page Size
		prefInfo[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
		prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
		prefInfo[0].vValue.Integer = 100;

		// Scope - make sure a valid scope
		prefInfo[1].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
		prefInfo[1].vValue.dwType = ADSTYPE_INTEGER;
		prefInfo[1].vValue.Integer = ADS_SCOPE_ONELEVEL;
		
		hr = pSearch->SetSearchPreference( prefInfo, dwPrefInfo);
	}

	if (SUCCEEDED(hr))
	{
		// Was a filter entered?
		if ((szFilter == NULL) || (wcslen(szFilter) == 0))
		{
			pszFilter = L"(objectCategory=classSchema)";  // Use the default
		}
		else // Build the filter to search for classes
		{
			bstrFilter = L"(&(ldapDisplayName=";

			bstrFilter.Append(szFilter);
			bstrFilter.Append(L"*)(objectCategory=classSchema))");
			pszFilter = bstrFilter;
		}
	}
	//---------------------------------------------------
	// Retrieve the information for the desired classes
	//---------------------------------------------------
	if (SUCCEEDED(hr))
		hr = pSearch->ExecuteSearch(pszFilter, pAttrs, dwNum, &hSearch);

	if (SUCCEEDED(hr))
		hr = pSearch->GetFirstRow( hSearch );

	// Read the information for each returned class
	while( SUCCEEDED(hr) && hr != S_ADS_NOMORE_ROWS )
	{
		// Display the class header tag
		WriteLine(m_hFile, "<sd:Class>",INDENT_DSML_OBJECT_ENTRY);
		WriteLine(m_hTempFile, "<sd:Class>",INDENT_DSML_OBJECT_ENTRY);
		DisplayXMLAttribute(pSearch, pAttrs[0], hSearch);

  		for (i = 1; i < 13; ++i)
			DisplayXMLAttribute(pSearch, pAttrs[i], hSearch);

		// Display "Must Contain" attributes
		WriteLine(m_hFile, "<sd:MustContain>",INDENT_DSML_ATTR_ENTRY);
		DisplayMultiAttribute(pSearch, pAttrs[13], hSearch);
		DisplayMultiAttribute(pSearch, pAttrs[14], hSearch);
		WriteLine(m_hFile, "</sd:MustContain>",INDENT_DSML_ATTR_ENTRY);

		// Display "May Contain" attributes
		WriteLine(m_hFile, "<sd:MayContain>",INDENT_DSML_ATTR_ENTRY);
		DisplayMultiAttribute(pSearch, pAttrs[15], hSearch);
		DisplayMultiAttribute(pSearch, pAttrs[16], hSearch);
		WriteLine(m_hFile, "</sd:MayContain>",INDENT_DSML_ATTR_ENTRY);

		// Display the comments
		WriteLine(m_hTempFile, "<sd:comment-updatePrivelege>Fill in.</sd:comment-updatePrivelege>",
				  INDENT_DSML_ATTR_ENTRY);
		WriteLine(m_hTempFile, "<sd:comment-updateFrequency>Fill in.</sd:comment-updateFrequency>",
				  INDENT_DSML_ATTR_ENTRY);
		WriteLine(m_hTempFile, "<sd:comment-usage>Fill in.</sd:comment-usage>",
				  INDENT_DSML_ATTR_ENTRY);

		// Display the class trailer tag
		WriteLine(m_hFile, "</sd:Class>",INDENT_DSML_OBJECT_ENTRY);
		WriteLine(m_hTempFile, "</sd:Class>",INDENT_DSML_OBJECT_ENTRY);
		hr = pSearch->GetNextRow(hSearch);
	}
	if (SUCCEEDED(hr))
	{
		//---------------------------------------------------------------
		// Retrieve the information for the desired attributes
		//----------------------------------------------------------------
		dwNum = sizeof(pAttrs1) / sizeof(LPWSTR);

		bstrFilter = L"(&(ldapDisplayName=";
		bstrFilter.Append(szFilter);
		bstrFilter.Append(L"*)(!objectCategory=classSchema))");
		pszFilter = bstrFilter;

		hr = pSearch->ExecuteSearch(pszFilter, pAttrs1, dwNum, &hSearch);
	}

	if (SUCCEEDED(hr))
		hr = pSearch->GetFirstRow( hSearch );

	// Read the information for each returned class
	while( SUCCEEDED(hr) && hr != S_ADS_NOMORE_ROWS )
	{
		// Display the attribute header tag
		WriteLine(m_hFile, "<sd:Attribute>",INDENT_DSML_OBJECT_ENTRY);
		WriteLine(m_hTempFile, "<sd:Attribute>",INDENT_DSML_OBJECT_ENTRY);
		DisplayXMLAttribute(pSearch, pAttrs1[0], hSearch);
		DisplayXMLAttribute(pSearch, pAttrs1[1], hSearch);

		// Display the comments
		WriteLine(m_hTempFile, "<sd:comment-sizeInBytes>Fill in.</sd:comment-sizeInBytes>",
				  INDENT_DSML_ATTR_ENTRY);
		DisplayContainedIns(pSearch);
		WriteLine(m_hTempFile, "<sd:comment-updatePrivelege>Fill in.</sd:comment-updatePrivelege>",
				  INDENT_DSML_ATTR_ENTRY);
		WriteLine(m_hTempFile, "<sd:comment-updateFrequency>Fill in.</sd:comment-updateFrequency>",
				  INDENT_DSML_ATTR_ENTRY);
		WriteLine(m_hTempFile, "<sd:comment-usage>Fill in.</sd:comment-usage>",
				  INDENT_DSML_ATTR_ENTRY);

		for (i = 2; i < dwNum; ++i)
			DisplayXMLAttribute(pSearch, pAttrs1[i], hSearch);

		// Display the attribute trailer tag
		WriteLine(m_hFile, "</sd:Attribute>",INDENT_DSML_OBJECT_ENTRY);
		WriteLine(m_hTempFile, "</sd:Attribute>",INDENT_DSML_OBJECT_ENTRY);
		hr = pSearch->GetNextRow(hSearch);
	}
	return S_OK;
} // SaveAsDSMLSchema

// ---------------------------------------------------------------------------
// This method copies the comments for each class and 
// ---------------------------------------------------------------------------
HRESULT CSchemaDoc::CopyComments()
{
	BOOL	bNoFileError;
    HRESULT hr = S_OK;
	DWORD	dwBytesRead;
	DWORD	dwBytesWritten;
    UCHAR   uBuff[2000];

    hr = SetFilePointer(m_hTempFile, 0, 0, FILE_BEGIN);
	WriteLine(m_hFile, "<sd:Comments>",INDENT_DSML_DIR_ENTRY);

	do
    {
        bNoFileError = ReadFile(m_hTempFile, uBuff, sizeof(uBuff), &dwBytesRead, NULL);

        if (bNoFileError)
            bNoFileError = WriteFile(m_hFile,  uBuff, dwBytesRead, &dwBytesWritten, NULL);
    }
    while (bNoFileError && (dwBytesRead == sizeof(uBuff)));

	if (bNoFileError == FALSE)
		hr = HRESULT_FROM_WIN32(GetLastError());

	WriteLine(m_hFile, "</sd:Comments>",INDENT_DSML_DIR_ENTRY);
    return hr;
} // CopyComments

// ---------------------------------------------------------------------------
// This method is used to set the LDAP path, username, and password for the
// search that will be performed.
// ---------------------------------------------------------------------------
STDMETHODIMP CSchemaDoc::SetPath_and_ID(BSTR bstrPath, BSTR bstrName, BSTR bstrPassword)
{
	m_sDirPath = bstrPath;
	m_sUserName = bstrName;
	m_sPassword = bstrPassword;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\xmlschema\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1F2C8C4D_7FC6_48EB_A2B8_58F9E5019E35__INCLUDED_)
#define AFX_STDAFX_H__1F2C8C4D_7FC6_48EB_A2B8_58F9E5019E35__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "activeds.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1F2C8C4D_7FC6_48EB_A2B8_58F9E5019E35__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\xmlschema\schemadoc.h ===
// SchemaDoc.h : Declaration of the CSchemaDoc

#ifndef __SCHEMADOC_H_
#define __SCHEMADOC_H_

#include "resource.h"       // main symbols

#define INDENT_DSML_DIR_ENTRY		1
#define INDENT_DSML_OBJECT_ENTRY	2
#define INDENT_DSML_ATTR_ENTRY		3
#define INDENT_DSML_ATTR_VALUE		4
#define MAX_INDENT                  5   // This must be larger that max indent value

/////////////////////////////////////////////////////////////////////////////
// CSchemaDoc
//class ATL_NO_VTABLE CSchemaDoc : 
class  CSchemaDoc : public ISchemaDoc,
	public CComObjectRoot,
//	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSchemaDoc, &CLSID_SchemaDoc>,
	public ISupportErrorInfo,
//	public IDispatchImpl<ISchemaDoc, &IID_ISchemaDoc, &LIBID_XMLSCHEMALib>,
	public IADsExtension
{
public:
	CSchemaDoc();
	~CSchemaDoc();

DECLARE_REGISTRY_RESOURCEID(IDR_SCHEMADOC)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSchemaDoc)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISchemaDoc)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IADsExtension)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo); 
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
							 LCID lcid, DISPID* rgdispid);
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,	LCID lcid, WORD wFlags,
					  DISPPARAMS* pdispparams, VARIANT* pvarResult,
					  EXCEPINFO* pexcepinfo, UINT* puArgErr);

// IADsExtension
	STDMETHOD(Operate)(ULONG dwCode, VARIANT varData1, VARIANT varData2, VARIANT varData3)
	{
		HRESULT hr = S_OK;

		switch (dwCode) 
		{

			case ADS_EXT_INITCREDENTIALS:
				  // For debugging purpose you can prompt a dialog box
				  // MessageBox(NULL, "INITCRED", "ADsExt", MB_OK);
				  if (V_VT(&varData1) == VT_BSTR &&
					  varData1.bstrVal != NULL )
				  {					  
					   m_sUserName = V_BSTR(&varData1);
				  }
				  else
				  {
					  m_sUserName.Empty();
				  }

				  m_dwFlag = 0;

				  if ( V_VT(&varData3) == VT_I4 )
				  {
					  m_dwFlag = V_I4(&varData3);
				  }
				  break;
 
			default:
				  hr = E_FAIL;
				  break;
		}        

        return hr;
	}

	STDMETHOD(PrivateGetIDsOfNames)(REFIID riid, OLECHAR ** rgszNames, unsigned int cNames, LCID lcid, DISPID  * rgdispid)
	{
		
		if (rgdispid == NULL)
		{
			return E_POINTER;
		}
		return  DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
	}

 

	STDMETHOD(PrivateInvoke)(DISPID dispidMember, REFIID riid, LCID lcid,
							 WORD wFlags, DISPPARAMS * pdispparams,
							 VARIANT * pvarResult, EXCEPINFO * pexcepinfo,
							 UINT * puArgErr)
	{
		 return DispInvoke((ISchemaDoc*)this, m_pTypeInfo, dispidMember, wFlags, 
							pdispparams, pvarResult, pexcepinfo, puArgErr);
	}

	
// ISchemaDoc
public:
	STDMETHOD(SetPath_and_ID)(BSTR bstrPath, BSTR bstrName, BSTR bstrPassword);

	STDMETHOD(CreateXMLDoc)(BSTR bstrOutputFile, BSTR bstrFilter);

protected:
	HRESULT CloseXML();
	HRESULT CopyComments();
	HRESULT DisplayContainedIns(IDirectorySearch* pSearch);
	HRESULT DisplayMultiAttribute(IDirectorySearch* pSearch, LPWSTR pAttr,
								  ADS_SEARCH_HANDLE hSearch);
	HRESULT DisplayXMLAttribute(IDirectorySearch* pSearch, LPWSTR pAttr,
								ADS_SEARCH_HANDLE hSearch);

	HRESULT OpenXML(BSTR bstrFile);
	HRESULT SaveAsXMLSchema(LPWSTR szFilter);
	HRESULT WriteLine(HANDLE hFile, LPCSTR pszBuff, UINT nIndent=0);
	HRESULT Write(HANDLE hFile, LPCSTR pszBuff, UINT nIndent=0);

protected:
	CComBSTR	 m_bstrLastCN;
	ITypeInfo   *m_pTypeInfo;
	HANDLE		 m_hFile;
	HANDLE		 m_hTempFile;
	CComBSTR	 m_sDirPath;  // The path to the LDAP directory
	CComBSTR	 m_sPassword; // Used for binding to the LDAP directory
	CComBSTR	 m_sUserName; // Used for binding to the LDAP directory
	DWORD		 m_dwFlag;    // for re-authentication
};

#endif //__SCHEMADOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\xmlschema\xmlschema_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Tue Jan 11 17:35:31 2000
 */
/* Compiler settings for D:\SRC\XMLSchema\XMLSchema.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "XMLSchema.h"

#define TYPE_FORMAT_STRING_SIZE   37                                
#define PROC_FORMAT_STRING_SIZE   75                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ISchemaDoc, ver. 0.0,
   GUID={0xB1104680,0x42A2,0x4C84,{0x85,0x85,0x4B,0x2E,0x2A,0xB8,0x64,0x19}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISchemaDoc_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISchemaDoc_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    34
    };

static const MIDL_SERVER_INFO ISchemaDoc_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISchemaDoc_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISchemaDoc_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISchemaDoc_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(9) _ISchemaDocProxyVtbl = 
{
    &ISchemaDoc_ProxyInfo,
    &IID_ISchemaDoc,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISchemaDoc::CreateXMLDoc */ ,
    (void *)-1 /* ISchemaDoc::SetPath_and_ID */
};


static const PRPC_STUB_FUNCTION ISchemaDoc_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISchemaDocStubVtbl =
{
    &IID_ISchemaDoc,
    &ISchemaDoc_ServerInfo,
    9,
    &ISchemaDoc_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x5030118, /* MIDL Version 5.3.280 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure CreateXMLDoc */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter bstrOutputFile */

/* 16 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 18 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 20 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Parameter bstrFilter */

/* 22 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 24 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 26 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Return value */

/* 28 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 30 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 32 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetPath_and_ID */

/* 34 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 36 */	NdrFcLong( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 42 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 44 */	NdrFcShort( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0x8 ),	/* 8 */
/* 48 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter bstrPath */

/* 50 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 52 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 54 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Parameter bstrName */

/* 56 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 58 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 60 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Parameter bstrPassword */

/* 62 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 64 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 66 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Return value */

/* 68 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 70 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 72 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xc ),	/* Offset= 12 (16) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 16 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (6) */
/* 22 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 24 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 26 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x4 ),	/* 4 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _XMLSchema_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ISchemaDocProxyVtbl,
    0
};

const CInterfaceStubVtbl * _XMLSchema_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ISchemaDocStubVtbl,
    0
};

PCInterfaceName const _XMLSchema_InterfaceNamesList[] = 
{
    "ISchemaDoc",
    0
};

const IID *  _XMLSchema_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _XMLSchema_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _XMLSchema, pIID, n)

int __stdcall _XMLSchema_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_XMLSchema_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo XMLSchema_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _XMLSchema_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _XMLSchema_StubVtblList,
    (const PCInterfaceName * ) & _XMLSchema_InterfaceNamesList,
    (const IID ** ) & _XMLSchema_BaseIIDList,
    & _XMLSchema_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Tue Jan 11 17:35:31 2000
 */
/* Compiler settings for D:\SRC\XMLSchema\XMLSchema.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "XMLSchema.h"

#define TYPE_FORMAT_STRING_SIZE   39                                
#define PROC_FORMAT_STRING_SIZE   95                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ISchemaDoc, ver. 0.0,
   GUID={0xB1104680,0x42A2,0x4C84,{0x85,0x85,0x4B,0x2E,0x2A,0xB8,0x64,0x19}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISchemaDoc_ServerInfo;

#pragma code_seg(".orpc")
static const unsigned short ISchemaDoc_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    44
    };

static const MIDL_SERVER_INFO ISchemaDoc_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISchemaDoc_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ISchemaDoc_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISchemaDoc_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(9) _ISchemaDocProxyVtbl = 
{
    &ISchemaDoc_ProxyInfo,
    &IID_ISchemaDoc,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ISchemaDoc::CreateXMLDoc */ ,
    (void *)-1 /* ISchemaDoc::SetPath_and_ID */
};


static const PRPC_STUB_FUNCTION ISchemaDoc_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ISchemaDocStubVtbl =
{
    &IID_ISchemaDoc,
    &ISchemaDoc_ServerInfo,
    9,
    &ISchemaDoc_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x5030118, /* MIDL Version 5.3.280 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure CreateXMLDoc */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 16 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x2 ),	/* 2 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrOutputFile */

/* 26 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 30 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrFilter */

/* 32 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 36 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Return value */

/* 38 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 40 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 42 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetPath_and_ID */

/* 44 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 46 */	NdrFcLong( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
/* 52 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x8 ),	/* 8 */
/* 58 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 60 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
/* 64 */	NdrFcShort( 0x3 ),	/* 3 */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrPath */

/* 70 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 72 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 74 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrName */

/* 76 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 78 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 80 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter bstrPassword */

/* 82 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 84 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 86 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Return value */

/* 88 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 90 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 92 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xe ),	/* Offset= 14 (18) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 18 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 20 */	NdrFcShort( 0x8 ),	/* 8 */
/* 22 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (6) */
/* 24 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 26 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 28 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */
/* 32 */	NdrFcShort( 0x8 ),	/* 8 */
/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (2) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _XMLSchema_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ISchemaDocProxyVtbl,
    0
};

const CInterfaceStubVtbl * _XMLSchema_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ISchemaDocStubVtbl,
    0
};

PCInterfaceName const _XMLSchema_InterfaceNamesList[] = 
{
    "ISchemaDoc",
    0
};

const IID *  _XMLSchema_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _XMLSchema_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _XMLSchema, pIID, n)

int __stdcall _XMLSchema_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_XMLSchema_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo XMLSchema_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _XMLSchema_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _XMLSchema_StubVtblList,
    (const PCInterfaceName * ) & _XMLSchema_InterfaceNamesList,
    (const IID ** ) & _XMLSchema_BaseIIDList,
    & _XMLSchema_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\eximport\ifsglobals.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ifsurtl.h

Abstract:

    This module defines all EXIFS shared routines exported to user-mode.

Author:

    Ramesh Chinta      [Ramesh Chinta]      17-Jan-2000

Revision History:

--*/

#ifndef _IFSBLOBALS_H_
#define _IFSGLOBALS_H_

#ifdef  __cplusplus
extern  "C" {
#endif

#define DD_MAX_NAME 50
#define DD_MAX_PREFIX 10

class IFSURTL_EXPORT CIfsGlobals {

/*
    This class will loads different globals based on whether it is Local store
    or store to call into the right driver
*/

public:
    // members
    // device name
    CHAR m_szIFSDeviceName[DD_MAX_NAME+1];

    // device name length
    LONG m_lDeviceNameLength;

    // FS device name
    WCHAR m_wszFSDeviceName[DD_MAX_NAME +1];

    // User mode shadow dev name
    WCHAR m_wszUMShadowDevName[DD_MAX_NAME + 1];

    // Shadow mode Dev Name Len
    LONG m_lUMShadowDevNameLength;

    // User mode dev name
    WCHAR m_wszUMDevName[DD_MAX_NAME+1];

    // Public MDB share
    WCHAR m_wszPublicMDBShare[DD_MAX_NAME+1];

    // Mini Redirector Prefix
    WCHAR m_wszExifsMiniRdrPrefix[DD_MAX_PREFIX+1];
    
    // Mini Redirector Prefix
    LONG m_lExifsMiniRdrPrefixLen;

    // Mini Redirector Prefix Absolute Length
    LONG m_lExifsMiniRdrPrefixAbsLen;

    // Mini Redirector Prefix
    WCHAR m_wszExifsMiniRdrPrefixPrivate[DD_MAX_PREFIX+1];

    // UMR net root name
    WCHAR m_wszExUMRNetRootName[DD_MAX_NAME+1];   

	CHAR  m_szDrvKeyName[MAX_PATH+1];

	CHAR  m_szDrvLetterValueName[MAX_PATH+1];

	CHAR  m_szPbDeviceValueName[MAX_PATH+1];
    
    // Constructor
    CIfsGlobals(void)
    {

        // Device name
        m_szIFSDeviceName[0] = '\0';

        // device name length
        m_lDeviceNameLength = 0;

        // FS device name
        m_wszFSDeviceName[0] = L'\0';

        // User mode shadow dev name
        m_wszUMShadowDevName[0] = L'\0';

        // UM shadow DevName Length
        m_lUMShadowDevNameLength = 0;

        // User mode dev name
        m_wszUMDevName[0] = L'\0';

        // Public MDB share
        m_wszPublicMDBShare[0] = L'\0';

        // MiniRdr Pefix
        m_wszExifsMiniRdrPrefix[0] = L'\0';

        // MiniRdr Pefix
        m_wszExifsMiniRdrPrefixPrivate[0] = L'\0';

        // MiniRdr Prefix Len
        m_lExifsMiniRdrPrefixLen = 0;

        // MiniRdr Absolute Prefix Len
        m_lExifsMiniRdrPrefixAbsLen = 0;
        
        // UMR net root name
        m_wszExUMRNetRootName[0] = L'\0'; 
		
		// Driver Key name
		m_szDrvKeyName[0] = '\0';

		// Driver Value name
		m_szDrvLetterValueName[0] = '\0';

		// Driver Value Root
		m_szPbDeviceValueName[0] = '\0';

    }

    // Destructor
    ~CIfsGlobals(){};

    //methods
    // Load the right version of the globals
    void Load(void);

    // Unload the globals
    void Unload(void);

};

#ifdef  __cplusplus
}
#endif
        
#endif   // _IFSGLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\eximport\ifserr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1998  Microsoft Corp. All rights reserved.

Module Name:

    ifserr.h

Abstract:

    Constant definitions for the Exchange IFS driver error code values

Author:

    Rajeev Rajan 06-11-1998

Revision History:

Notice:

    DO NOT MODIFY; IFSERR.H IS NOT A SOURCE FILE. MAKE CHANGES TO
    IFSERR.MC INSTEAD.
    If you add an error code that will be logged in the NT event log
    make sure you include the line below at the end of the error text:
    %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.


--*/

#ifndef _IFSERR_
#define _IFSERR_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

// LanguageNames=(FrenchStandard=0x040c:msg00002)	

// Used from kernel mode. Do NOT use %1 for insertion strings since
// the I/O manager automatically inserts the driver/device name as 
// the first string.

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4
#define FACILITY_EXIFS_ERROR_CODE        0xFAD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EXSTATUS_DRIVER_LOADED
//
// MessageText:
//
//  The Exchange IFS driver loaded successfully.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define EXSTATUS_DRIVER_LOADED           ((NTSTATUS)0x6FAD2400L)

//
// MessageId: EXSTATUS_DRIVER_UNLOADED
//
// MessageText:
//
//  The Exchange IFS driver unloaded successfully.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define EXSTATUS_DRIVER_UNLOADED         ((NTSTATUS)0x6FAD2401L)

//
// MessageId: EXSTATUS_UNDERLYING_OPEN_FAILED
//
// MessageText:
//
//  Exchange IFS driver failed to open the underlying file %2. It failed with NTSTATUS %3.
//
#define EXSTATUS_UNDERLYING_OPEN_FAILED  ((NTSTATUS)0xEFAD2500L)

//
// MessageId: EXSTATUS_ROOT_NOT_INITIALIZED
//
// MessageText:
//
//  Exchange IFS driver received an I/O on an uninitialized root or failed to enter root.
//
#define EXSTATUS_ROOT_NOT_INITIALIZED    ((NTSTATUS)0xEFAD2501L)

//
// MessageId: EXSTATUS_INVALID_IO
//
// MessageText:
//
//  Exchange IFS driver received an I/O on a file that is not a data file. I/O is invalid.
//
#define EXSTATUS_INVALID_IO              ((NTSTATUS)0xEFAD2502L)

//
// MessageId: EXSTATUS_SCATTERLIST_READ_FAILED
//
// MessageText:
//
//  Exchange IFS driver failed to read scatter list data in the FCB.
//
#define EXSTATUS_SCATTERLIST_READ_FAILED ((NTSTATUS)0xEFAD2503L)

//
// MessageId: EXSTATUS_ROOT_SHARELOCK_FAILED
//
// MessageText:
//
//  Exchange IFS driver failed to get a share lock on the root.
//
#define EXSTATUS_ROOT_SHARELOCK_FAILED   ((NTSTATUS)0xEFAD2504L)

//
// MessageId: EXSTATUS_VNET_ROOT_ALREADY_EXISTS
//
// MessageText:
//
//  Exchange IFS driver failed to create a VNET_ROOT because one already exists.
//
#define EXSTATUS_VNET_ROOT_ALREADY_EXISTS ((NTSTATUS)0xEFAD2505L)

//
// MessageId: EXSTATUS_ROOTOPEN_NOT_EXCLUSIVE
//
// MessageText:
//
//  Attempt to create an Exchange IFS root without exclusive access.
//
#define EXSTATUS_ROOTOPEN_NOT_EXCLUSIVE  ((NTSTATUS)0xEFAD2506L)

//
// MessageId: EXSTATUS_READONLY_NO_SCATTERLIST
//
// MessageText:
//
//  Attempt to create a read-only Exchange IFS handle with no scatter-list.
//
#define EXSTATUS_READONLY_NO_SCATTERLIST ((NTSTATUS)0xEFAD2507L)

//
// MessageId: EXSTATUS_ROOT_ABANDONED
//
// MessageText:
//
//  Attempt to create an Exchange IFS handle in an abandoned root aka store.
//
#define EXSTATUS_ROOT_ABANDONED          ((NTSTATUS)0xEFAD2508L)

//
// MessageId: EXSTATUS_ROOT_NEEDS_SPACE
//
// MessageText:
//
//  An IFS root needs a space grant.
//
#define EXSTATUS_ROOT_NEEDS_SPACE        ((NTSTATUS)0xEFAD2509L)

//
// MessageId: EXSTATUS_TOO_MANY_SPACEREQS
//
// MessageText:
//
//  Too many SPACEREQs have been pended to an IFS root.
//
#define EXSTATUS_TOO_MANY_SPACEREQS      ((NTSTATUS)0xEFAD2510L)

//
// MessageId: EXSTATUS_NO_SUCH_FILE
//
// MessageText:
//
//  An open has been attempted on a filename that does not exist.
//
#define EXSTATUS_NO_SUCH_FILE            ((NTSTATUS)0xAFAD2511L)

//
// MessageId: EXSTATUS_RANDOM_FAILURE
//
// MessageText:
//
//  An IFS operation has been randomly failed.
//
#define EXSTATUS_RANDOM_FAILURE          ((NTSTATUS)0xEFAD2512L)

//
// MessageId: EXSTATUS_FILE_DOUBLE_COMMIT
//
// MessageText:
//
//  An attempt has been made to double-commit an IFS file.
//
#define EXSTATUS_FILE_DOUBLE_COMMIT      ((NTSTATUS)0xEFAD2513L)

//
// MessageId: EXSTATUS_INSTANCE_ID_MISMATCH
//
// MessageText:
//
//  An attempt has been made to commit an IFS file from one root into another or an attempt
//  has been made to open an IFS file in the wrong root.
//
#define EXSTATUS_INSTANCE_ID_MISMATCH    ((NTSTATUS)0xEFAD2514L)

//
// MessageId: EXSTATUS_SPACE_UNCOMMITTED
//
// MessageText:
//
//  An attempt has been made to commit an IFS file from one root into another.
//
#define EXSTATUS_SPACE_UNCOMMITTED       ((NTSTATUS)0xEFAD2515L)

//
// MessageId: EXSTATUS_INVALID_CHECKSUM
//
// MessageText:
//
//  An attempt has been made to open an IFS file with an EA that has an invalid checksum.
//
#define EXSTATUS_INVALID_CHECKSUM        ((NTSTATUS)0xEFAD2516L)

//
// MessageId: EXSTATUS_OPEN_DEADLINE_EXPIRED
//
// MessageText:
//
//  An attempt has been made to open an IFS file with an EA whose open deadline has expired.
//
#define EXSTATUS_OPEN_DEADLINE_EXPIRED   ((NTSTATUS)0xEFAD2517L)

//
// MessageId: EXSTATUS_FSRTL_MDL_READ_FAILED
//
// MessageText:
//
//  A MDL read on an IFS file failed because the underlying file failed a MDL read.
//
#define EXSTATUS_FSRTL_MDL_READ_FAILED   ((NTSTATUS)0xEFAD2518L)

//
// MessageId: EXSTATUS_FILE_ALREADY_EXISTS
//
// MessageText:
//
//  An attempt has been made to create an IFS file that already exists.
//
#define EXSTATUS_FILE_ALREADY_EXISTS     ((NTSTATUS)0xAFAD2519L)

//
// MessageId: EXSTATUS_DIRECTORY_HAS_EA
//
// MessageText:
//
//  An attempt has been made to create a directory with an EA.
//
#define EXSTATUS_DIRECTORY_HAS_EA        ((NTSTATUS)0xAFAD2520L)

//
// MessageId: EXSTATUS_STALE_HANDLE
//
// MessageText:
//
//  An I/O operation has been attempted on a stale handle. The InstanceID of the handle does
//  not match the NetRoot InstanceID.
//
#define EXSTATUS_STALE_HANDLE            ((NTSTATUS)0xEFAD2521L)

//
// MessageId: EXSTATUS_PRIVILEGED_HANDLE
//
// MessageText:
//
//  The IFS handle is privileged. The Exchange IFS driver will handle operations on a privileged handle
//  with special semantics.
//
#define EXSTATUS_PRIVILEGED_HANDLE       ((NTSTATUS)0x6FAD2522L)

#endif /* _IFSERR_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\eximport\ifsurtl.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ifsurtl.h

Abstract:

    This module defines all EXIFS shared routines exported to user-mode.

Author:

    Rajeev Rajan      [RajeevR]      2-June-1999
	Rohan  Phillips   [Rohanp]       23-June-1999 - Added provider functions

Revision History:

--*/

#ifndef _IFSURTL_H_
#define _IFSURTL_H_

#ifdef  __cplusplus
extern  "C" {
#endif

#ifdef  _IFSURTL_IMPLEMENTATION_
#ifndef IFSURTL_EXPORT
#define IFSURTL_EXPORT   __declspec( dllexport )
#endif
#else
#ifndef IFSURTL_EXPORT
#define IFSURTL_EXPORT   __declspec( dllimport )
#endif
#endif

#ifndef IFSURTL_CALLTYPE
#define IFSURTL_CALLTYPE __stdcall
#endif

///////////////////////////////////////////////////////////////////////////////
//
//  Callback for IFS functions
//
///////////////////////////////////////////////////////////////////////////////

typedef void (WINAPI *PFN_IFSCALLBACK)(PVOID);

///////////////////////////////////////////////////////////////////////////////
//
//  Following are the structures / definitions for the large buffer package
//
///////////////////////////////////////////////////////////////////////////////

#define IFS_LARGE_BUFFER_SIGNATURE              (ULONG) 'fubL'
#define IFS_CURSOR_SIGNATURE                    (ULONG) 'rsrC'

#define IFS_LARGE_BUFFER_SHARED_VIEWSIZE        (256*1024)

//
//  An IFS_LARGE_BUFFER object encapsulates a temp file containing
//  data that can be passed around and used like a buffer. Typically,
//  a producer would make one of these objects and stream in large
//  amounts of data. A consumer would read different chunks of the
//  data. The object will maintain a single mapping/view of the first
//  256K of the file. 
//
//  Consumers will need to access data using IFS_CURSORS that specify 
//  the <offset,len> pair for the span of data they are interested in. 
//  In the most common case, this should lie in the first 256K region,
//  which would yield the default view. If it is beyond this region,
//  views will be mapped/unmapped on demand.
//
typedef struct _IFS_LARGE_BUFFER {
    //
    //  Signature
    //
    ULONG   m_Signature;
    
    //
    //  Handle
    //
    HANDLE  m_FileContext1;

    //
    //  FileObject
    //
    PVOID   m_FileContext2;

    //
    //  FileMapping context for first 256K or filesize
    //    
    HANDLE  m_MappingContext;

    //
    //  Process context (optional)
    //
    PVOID   m_ProcessContext;
    
    //
    //  Memory pointer for first 256K or filesize
    //
    PBYTE   m_MemoryPtr;

    //
    //  Ref count - the lower WORD will count cursor refs
    //  the higher WORD will count object refs
    //
    ULONG   m_ReferenceCount;
    
    //
    //  Is this a reference or a live object ?
    //  If this is a reference, the fields above are NULL and
    //  the m_TempFileName should be used to make a new object !
    //
    BOOL    m_IsThisAReference;
    
    //
    //  Current ValidDataLength
    //
    LARGE_INTEGER m_ValidDataLength;
    
    //
    //  Name of temp file - we will use fixed
    //  names so we can make simplyfying assumptions
    //  about the filename len !
    //
    WCHAR    m_TempFileName    [MAX_PATH+1];
    
} IFS_LARGE_BUFFER,*PIFS_LARGE_BUFFER;

#define IsScatterListLarge( s )     FlagOn((s)->Flags, IFS_SLIST_FLAGS_LARGE_BUFFER)

#define EXIFS_EA_LEN_LARGE_SCATTER_LIST                                     \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_SCATTER_LIST) +                                \
        LongAlign(sizeof(SCATTER_LIST) + sizeof(IFS_LARGE_BUFFER) ))

#define EXIFS_EA_VALUE_LEN_LARGE_SCATTER_LIST                               \
        LongAlign(sizeof(SCATTER_LIST) + sizeof(IFS_LARGE_BUFFER) )

//
//  An IFS_CURSOR object provides a view into a large buffer.
//  Usage is as follows:
//  + Call IfsStartCursor() to init a cursor and get a pointer
//  + Use the pointer to read/write data via IfsConsumeCursor()
//  + Call IfsFinishCursor() to close the cursor
//
//  NOTE: Cursor usage will bump ref counts on the LARGE_BUFFER
//  object. If the LARGE_BUFFER object passed in is NOT live it
//  will instantiate one from the reference !
//
typedef struct _IFS_CURSOR {
    //
    //  Signature
    //
    ULONG               m_Signature;
    
    //
    //  Owning large buffer object
    //
    PIFS_LARGE_BUFFER   m_pLargeBuffer;

    //
    //  Current Offset to start of data
    //
    LARGE_INTEGER       m_Offset;

    //
    //  Current Span of data
    //
    ULONG               m_Length;

    //
    //  Append mode - if TRUE client can cursor beyond EOF
    //
    BOOL                m_AppendMode;
    
    //
    //  Is this a shared view
    //
    BOOL                m_IsViewShared;

    //
    //  Did we open the buffer
    //
    HANDLE              m_OwnBufferOpen;

    //
    //  Did we attach to the large buffer process
    //
    BOOL                m_AttachedToProcess;

    //
    //  The following fields are relevant only if the view is not shared.
    //  The first 256K view is shared via the mapping in the large buffer object.
    //  Cursors that extend beyond 256K make their own mapping - See Below.
    //

    //
    //  FileMapping context for this cursor
    //    
    HANDLE  m_MappingContext;
    
    //
    //  Memory pointer for this cursor
    //
    PBYTE   m_MemoryPtr;
    
} IFS_CURSOR,*PIFS_CURSOR;

//
//  Returns a pointer to data that can be used to
//  read/write. The pointer is valid only for the length
//  requested !
//  NOTE: If AppendMode is TRUE, cursors will be allowed
//  beyond EOF. This should be used by clients that wish
//  to append data to the large buffer.
//
PBYTE
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsGetFirstCursor(
        IN PIFS_LARGE_BUFFER pLargeBuffer,
        IN PIFS_CURSOR       pCursor,
        IN ULONG             StartOffsetHigh,
        IN ULONG             StartOffsetLow,
        IN ULONG             StartLength,
        IN BOOL              fAppendMode
        );

//
//  Consume bytes within current cursor
//  returns next pointer at which to read/write data !
//
//  NOTE: If all the data in the cursor is consumed, returns NULL
//
PBYTE
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsConsumeCursor(
        IN PIFS_CURSOR      pCursor,
        IN ULONG            Length
        );
        
//
//  Returns a pointer to data that can be used to
//  read/write. The pointer is valid only for the length
//  requested relative to the current cursor !
//
//  NOTE: This call advances the cursor in the large buffer
//
PBYTE
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsGetNextCursor(
        IN PIFS_CURSOR       pCursor,
        IN ULONG             NextLength
        );
        
//
//  Should be called for every matching GetFirstCursor() call.
//
VOID
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsFinishCursor(
        IN PIFS_CURSOR  pCursor
        );

//
//  Should be called to truncate the large buffer's valid data length
//
VOID
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsTruncateLargeBuffer(
        IN PIFS_LARGE_BUFFER pLargeBuffer,
        IN PLARGE_INTEGER    pSizeToTruncate
        );

//
//  Rules for passing around IFS_LARGE_BUFFERs:
//  1. These objects should be passed around by reference. eg passing
//     between user & kernel or between kernel and the namecache.
//  2. Use IfsCopyBufferByReference() to create a reference.
//  3. If a reference exists, there should always be a live object whose
//     lifetime encapsulates the reference. This allows the consumer of the
//     reference to make a *real* copy using the reference.
//  4. A reference can be converted into a live object. It is the responsibility
//     of the module that does this conversion to close the live object.
//  5. Example: When EA is checked in to the namecache during CLOSE,
//     it will be passed in as a reference. During checkin, the namecache should
//     call IfsOpenBufferToReference() to hold on to the buffer. Thus,
//     when the namecache blob is finalized, it needs to call IfsCloseBuffer()
//     to close the large buffer !
//
        
//
//  IN:  pLargeBuffer should be allocated by caller of the function
//  IN:  Len of the buffer required - zero if len is not known apriori
//
//  NOTE: Object needs to be closed via IfsCloseBuffer()
//
//  USAGE: Should be used when caller needs to instantiate a large buffer
//
NTSTATUS
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCreateNewBuffer( 
        IN PIFS_LARGE_BUFFER pLargeBuffer, 
        IN DWORD             dwSizeHigh,
        IN DWORD             dwSizeLow,
        IN PVOID             ProcessContext     // optional
        );

//
//  IN:  pLargeBuffer should be allocated by caller of the function
//  IN:  Len of the buffer required - zero if len is not known apriori
//
//  NOTE: Object needs to be closed via IfsCloseBuffer()
//
//  USAGE: Should be used when caller needs to instantiate a large buffer
//
NTSTATUS
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCreateNewBufferEx( 
        IN PIFS_LARGE_BUFFER pLargeBuffer, 
        IN DWORD             dwSizeHigh,
        IN DWORD             dwSizeLow,
        IN PVOID             ProcessContext,    // optional
        IN PUNICODE_STRING   FilePath           // optional
        );

//
//  IN: pSrcLargeBuffer points to a live large buffer object
//  IN OUT: pDstLargeBuffer is initialized as a reference to the Src
//
//  USAGE: Should be used to pass large buffers between user/kernel
//
VOID
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCopyBufferToReference(
        IN PIFS_LARGE_BUFFER pSrcLargeBuffer,
        IN OUT PIFS_LARGE_BUFFER pDstLargeBuffer
        );

//
//  IN: pSrcLargeBuffer points to a large buffer object (or reference)
//  IN OUT: pDstLargeBuffer will be initialized as a live object based on
//          the reference passed in
//
//  USAGE: Should be used to pass large buffers between user/kernel
//
NTSTATUS
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCopyReferenceToBuffer(
        IN PIFS_LARGE_BUFFER pSrcLargeBuffer,
        IN PVOID ProcessContext,    // optional
        IN OUT PIFS_LARGE_BUFFER pDstLargeBuffer
        );

//
//  IN:  pLargeBuffer points to a large buffer object (or reference)
//
//  NOTE: Object needs to be closed via IfsCloseBuffer()
//        OpenBuffer will always assume that the buffer len is fixed !
//
//  USAGE: Should be used when caller needs to convert a reference to a
//         live object. If the object is already live, this will bump
//         a reference on the object !
//
NTSTATUS
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsOpenBufferToReference(
        IN PIFS_LARGE_BUFFER pLargeBuffer
        );

//
//  IN:  pLargeBuffer coming in points to a live large buffer
//  OUT: pLargeBuffer going out points to a NEW live large buffer
//       The functions does a (deep) copy of the buffer data.
//
//  NOTE: Since the incoming object is live, it is closed and a
//        new object is instantiated in its place. Thus, IfsCloseBuffer()
//        needs to be called as usual on this !
//
NTSTATUS
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCopyBufferToNewBuffer(
        IN OUT PIFS_LARGE_BUFFER pLargeBuffer
        );
        
//
//  IN: Object should have been initialized by IfsCreateNewBuffer() or 
//  IfsOpenBufferToReference() or IfsCopyReferenceToBuffer()
//
VOID
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCloseBuffer(
        IN PIFS_LARGE_BUFFER pLargeBuffer
        );

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsInitializeProvider(DWORD OsType);

DWORD
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCloseProvider(void);

HANDLE
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCreateFileProv(WCHAR * FileName, DWORD DesiredAccess, DWORD ShareMode, PVOID
			  lpSecurityAttributes, DWORD CreateDisposition, DWORD FlagsAndAttributes,
			  PVOID EaBuffer, DWORD EaBufferSize);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsInitializeRoot(HANDLE hFileHandle, WCHAR * szRootName, WCHAR * SlvFileName, DWORD InstanceId, 
				  DWORD AllocationUnit, DWORD FileFlags);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsSpaceGrantRoot(HANDLE hFileHandle, WCHAR * szRootName, PSCATTER_LIST pSList, size_t cbListSize);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsSetEndOfFileRoot(HANDLE hFileHandle, WCHAR * szRootName, LONGLONG EndOfFile);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsSpaceRequestRoot(HANDLE hFileHandle, WCHAR * szRootName, PFN_IFSCALLBACK pfnIfsCallBack,
					PVOID pContext, PVOID Ov);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsQueryEaFile(HANDLE hFileHandle, WCHAR * szFileName, WCHAR * NetRootName, PVOID EaBufferIn, DWORD EaBufferInSize, 
			   PVOID EaBufferOut, DWORD EaBufferOutSize, DWORD * RequiredLength);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsSetEaFile(HANDLE hFileHandle, WCHAR * szFileName, PVOID EaBufferIn, DWORD EaBufferInSize);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsTerminateRoot(HANDLE hFileHandle, WCHAR *szRootName, ULONG Mode);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsGetOverlappedResult(HANDLE hFileHandle, PVOID Ov, DWORD * BytesReturned, BOOL Wait);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsReadFile(HANDLE hFileHandle, BYTE * InputBuffer, DWORD BytesToRead, PFN_IFSCALLBACK IfsCallBack,
			PVOID Overlapped);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsWriteFile(HANDLE hFileHandle, BYTE * InputBuffer, DWORD BytesToWrite, PFN_IFSCALLBACK IfsCallBack,
			 PVOID Overlapped);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsDeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInputBuffer, DWORD cbInBufferSize, 
				   LPVOID lpOutBuffer, DWORD cbOutBufferSize, LPDWORD lpBytesReturned, PVOID Overlapped);


BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsExpungName(HANDLE hFileHandle, WCHAR * szRootName, WCHAR * szFileName, ULONG cbPath);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsDirChangeReport(HANDLE hFileHandle, WCHAR * szRootName, ULONG ulFilterMatch,
				   ULONG ulAction, PWSTR pwszPath, ULONG cbPath);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsQueryRootStats(HANDLE hFileHandle, WCHAR * szRootName, PVOID Buffer, DWORD BuffSize);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsRegisterUmrThread(HANDLE hFileHandle, PFN_IFSCALLBACK pfnIfsCallBack);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsUmrEnableNetRoot(HANDLE hFileHandle, WCHAR * szRootName, DWORD * InstanceId);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsUmrDisableNetRoot(HANDLE hFileHandle, WCHAR * szRootName);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsStopUmrEngine(HANDLE hFileHandle, WCHAR * szRootName);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsStartUmrEngine(HANDLE hFileHandle, WCHAR * szRootName);


BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsCloseHandle(HANDLE hFileHandle);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsSetRootMap(HANDLE hFileHandle, WCHAR * szRootName, PSCATTER_LIST pSList, size_t cbListSize);

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsResetRootMap(HANDLE hFileHandle, WCHAR * szRootName);


NTSTATUS
IFSURTL_EXPORT
NTAPI
IfsNtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );



NTSTATUS
IFSURTL_EXPORT
NTAPI
IfsNtQueryEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
    );



VOID
IFSURTL_EXPORT
NTAPI
IfsRtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );



LONG
IFSURTL_EXPORT
NTAPI
IfsRtlCompareUnicodeString(
    PUNICODE_STRING String1,
    PUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );
    

BOOL
IFSURTL_EXPORT
IFSURTL_CALLTYPE
IfsFlushHandle(HANDLE hFileHandle, 
               WCHAR * szFileName, 
               WCHAR * NetRootName, 
               PVOID EaBufferIn, 
               DWORD EaBufferInSize
               );

#ifdef  __cplusplus
}
#endif
        
#endif   // _IFSURTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\eximport\exifs.h ===
/*++

Copyright (c) 1989 - 1998 Microsoft Corporation

Module Name:

    exifs.h

Abstract:

    This header exports all symbols and definitions shared between
    user-mode clients of the Exchange IFS driver and the driver itself.

Notes:

    This module has been built and tested only in UNICODE environment

Author:

    Rajeev Rajan      [RajeevR]      2-Feb-1998

Revision History:

    Mike Purtell      [MikePurt]     21-Jul-1998
	     Additions for NSM (Name Space Mapping)

	Ramesh Chinta     [Rameshc]      01-Jan-2000
	     Separate version of IFS for Local Store

--*/

#ifndef _EXIFS_H_
#define _EXIFS_H_


// These globals define LOCAL STORE version of the strings
#define LSIFS_DEVICE_NAME_A "LocalStoreIfsDevice"
// The following constant defines the length of the above name.
#define LSIFS_DEVICE_NAME_A_LENGTH (20)
// The following constant defines the path in the ob namespace
#define DD_LSIFS_FS_DEVICE_NAME_U               L"\\Device\\LocalStoreDevice"
#define DD_LSIFS_USERMODE_SHADOW_DEV_NAME_U     L"\\??\\LocalStoreIfs"
#define DD_LSIFS_USERMODE_DEV_NAME_U            L"\\\\.\\LocalStoreIfs"
#define DD_PUBLIC_MDB_SHARE_LSIFS               L"\\??\\WebStorage"



#ifdef LOCALSTORE
#define EXIFS_DEVICE_NAME_A LSIFS_DEVICE_NAME_A

// The following constant defines the length of the above name.
#define EXIFS_DEVICE_NAME_A_LENGTH LSIFS_DEVICE_NAME_A_LENGTH

// The following constant defines the path in the ob namespace
#define DD_EXIFS_FS_DEVICE_NAME_U DD_LSIFS_FS_DEVICE_NAME_U
#else  // PLATINUM
// Device name for this driver
#define EXIFS_DEVICE_NAME_A "ExchangeIfsDevice"

// The following constant defines the length of the above name.
#define EXIFS_DEVICE_NAME_A_LENGTH (18)

// The following constant defines the path in the ob namespace
#define DD_EXIFS_FS_DEVICE_NAME_U L"\\Device\\ExchangeIfsDevice"
#endif // PLATINUM

#ifndef EXIFS_DEVICE_NAME
#define EXIFS_DEVICE_NAME

//
//  The Devicename string required to access the exchange IFS device 
//  from User-Mode. Clients should use DD_EXIFS_USERMODE_DEV_NAME_U.
//
//  WARNING The next two strings must be kept in sync. Change one and you must 
//  change the other. These strings have been chosen such that they are 
//  unlikely to coincide with names of other drivers.
//
//  NOTE: These definitions MUST be synced with <ifsuser.h>
//
#ifdef LOCALSTORE
#define DD_EXIFS_USERMODE_SHADOW_DEV_NAME_U     DD_LSIFS_USERMODE_SHADOW_DEV_NAME_U
#define DD_EXIFS_USERMODE_DEV_NAME_U            DD_LSIFS_USERMODE_DEV_NAME_U
#else  // PLATINUM
#define DD_EXIFS_USERMODE_SHADOW_DEV_NAME_U     L"\\??\\ExchangeIfs"
#define DD_EXIFS_USERMODE_DEV_NAME_U            L"\\\\.\\ExchangeIfs"
#endif // PLATINUM
#define DD_EXIFS_USERMODE_WIN9X_DRIVER_NAME     "M:\EA"

//
//  Prefix needed before <store-name>\<root-name>
//
#define DD_EXIFS_MINIRDR_PREFIX                 L"\\;E:"
#define DD_EXIFS_MINIRDR_PREFIX_LEN             (sizeof(DD_EXIFS_MINIRDR_PREFIX)-2)

#define DD_EXIFS_MINIRDR_PREFIX_PRIVATE         L"\\;F:"
#define DD_EXIFS_MINIRDR_PREFIX_SPECIAL         L"\\;G:"

#endif // EXIFS_DEVICE_NAME



#define RDBSS_DRIVER_LOAD_STRING L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Rdbss"
#define STRING_MISC_POOLTAG      ('Strg')

#ifdef LOCALSTORE
#define DD_PUBLIC_MDB_SHARE             DD_PUBLIC_MDB_SHARE_LSIFS
#else  // PLATINUM
#define DD_PUBLIC_MDB_SHARE             L"\\??\\BackOfficeStorage"
#endif // PLATINUM

#define DD_MDB_SHARE_PREFIX             L"\\??\\"

#define SYSTEM_PARAMETERS L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion"

#define IFS_DEFAULT_TEMP_DIR   L"\\??\\C:\\temp\\"
#define IFS_TEMP_DIR_PREFIX    L"\\??\\"
#define IFS_TEMP_DIR_POSTFIX   L"\\"


//
// BEGIN WARNING WARNING WARNING WARNING
//  The following are from the ddk include files and cannot be changed

#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014 // from ddk\inc\ntddk.h
#define METHOD_BUFFERED 0
#define FILE_ANY_ACCESS 0

// END WARNING WARNING WARNING WARNING

#define IOCTL_EXIFS_BASE FILE_DEVICE_NETWORK_FILE_SYSTEM

//
//  This is a reserved net root name for use by the global UMR.
//
#define DD_EXUMR_NETROOT_NAME     L"\\UMR\\CONTROL"
#define DD_EXUMR_ROOT_DIR         DD_EXIFS_MINIRDR_PREFIX \
								  DD_EXUMR_NETROOT_NAME \
								  L"\\$ROOT_DIR"

#define _EXIFS_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_EXIFS_BASE, request, method, access)

//
//  Signatures of structs
//

#define SCATTER_LIST_SIGNATURE              (ULONG) 'rtcS'
#define IOCTL_INITROOT_IN_SIGNATURE         (ULONG) 'Itri'
#define IOCTL_SPACEGRANT_IN_SIGNATURE       (ULONG) 'Icps'
#define IOCTL_TERMROOT_IN_SIGNATURE         (ULONG) 'Itrt'
#define IOCTL_QUERYROOT_OUT_SIGNATURE       (ULONG) 'Otrq'
#define IOCTL_QUERYSTATS_IN_SIGNATURE       (ULONG) 'IyrQ'
#define IOCTL_QUERYSTATS_OUT_SIGNATURE      (ULONG) 'OyrQ'
#define IOCTL_SETENDOFFILE_IN_SIGNATURE     (ULONG) 'IfoE'
#define IOCTL_ENABLE_UMR_ROOT_IN_SIGNATURE  (ULONG) 'rmUE'
#define IOCTL_DIR_CHNG_REPORT_IN_SIGNATURE  (ULONG) 'CriD'
#define IOCTL_EXPUNGE_NAME_IN_SIGNATURE     (ULONG) 'ExNi'
#define IOCTL_EXPUNGE_NAME_OUT_SIGNATURE    (ULONG) 'ExNo'
#define IOCTL_EXIFS_UMRX_ENABLE_NET_ROOT_OUT_SIGNATURE  (ULONG) 'banE'

//
//  Data Str shared between user-mode clients like the exchange store
//  and Exchange IFS driver.
//

#define MAX_FRAGMENTS       (ULONG) 8

//
//  This limits the size that the scatter list portion of an EA can be.
//  896 entires will take 896*16=>14336 bytes.
//  In a 16K request buffer, this leaves about 2k for the other portion of
//    the EA of which the filename is the only other variable component.
//

#define MAX_TOTAL_SLIST_FRAGMENTS    (ULONG) 896

//
//  If MAX_CONSTANT_ALLOCATIONS have been made in a file, IFS will increase 
//  the allocation assuming that future constant requests will be made.
//
#define MAX_CONSTANT_ALLOCATIONS     (1024*4)

//
//  A SCATTER_LIST_ENTRY represents a single fragment in a scatter list.
//  All offsets are with respect to the underlying NTFS file for a given
//  root. If this file is opened with FILE_FLAG_NO_BUFFERING, the
//  following assertions must hold:
//
//  1. offsets must be integer multiples of the volume's sector size
//  2. lengths must be integer multiples of the volume's sector size
//
//  Checked builds of the driver will ASSERT if these do not hold
//
//  NOTE: Since the Offset is a multiple of the sector size which is
//  typically 512, the least significant 8 bits are unused. These bits
//  can be used for specifying flags on SLE state eg dirty/committed.
//  CAUTION: Any use of these bits should be transparent to IFS clients !
//
typedef struct _SCATTER_LIST_ENTRY_ 
{
    //
    //  64-bit offset to fragment data
    //
    LARGE_INTEGER   Offset;

    //
    //  length of fragment data
    //
    ULONG           Length;

    //
    //  reserved
    //
    ULONG           ulReserved;

} SCATTER_LIST_ENTRY, *PSCATTER_LIST_ENTRY;

//
//  Bit masks for SLE properties
//
#define RX_SLE_STATE_DIRTY      0x00000001

#define RX_SLE_STATE_MASK       0xFFFFFFFFFFFFFF00

#define RX_LONGLONG(x)          (x).QuadPart
#define RX_MASKED_LONGLONG(x)   ((x).QuadPart & RX_SLE_STATE_MASK)

//
//  SCATTER_LIST represents the scatter list. The array of fragments,          
//  sle, should in most cases be enough to describe data for a single 
//  IFS file. In extreme cases (eg very large messages), the overflow 
//  list should be used. This will ensure good page locality in the 
//  most common case, since this data is stored in the FCB extension.
//
//  If NumFragments is <= MAX_FRAGMENTS, overflow should be NULL.
//  If NumFragments is > MAX_FRAGMENTS, overflow should be non-NULL and
//  should "point" to (NumFragments - MAX_FRAGMENTS) number of
//  SCATTER_LIST_ENTRY's.
//
//  NOTE: Apps need to set OverflowOffset (relative to start
//  of struct) of the overflow fragments. The IFS uses it to point
//  to a list of overflow fragments in kernel space.
//
typedef struct _SCATTER_LIST_
{
    //
    //  signature for this struct
    //
    ULONG           Signature;

    //
    //  number of fragments in scatter list
    //
    ULONG           NumFragments;

    //
    //  TotalBytes ie. valid byte range
    //  NB: used only when scatter-list is available
    //  at create time. should *not* be used for GetFileSize()..
    //
    LARGE_INTEGER   TotalBytes;

    //
    //  array of scatter-list-entries
    //
    SCATTER_LIST_ENTRY sle[MAX_FRAGMENTS];

    //
    //  ptr to overflow list
    //

    //
    //  ptr to overflow list
    //
    union {
        struct {
            //
            //  offset to overflow frags
            //
            ULONG       OverflowOffset;

            //
            //  len of overflow data
            //
            ULONG       OverflowLen;
        };  // user-mode representation

        union {
            //
            //  list of overflow frags
            //
            LIST_ENTRY  OverflowListHead;

            //
            //  pointer to object containing overflow frags
            //
            PVOID       OverflowFragments;
        };  //  kernel-mode representation
    };

	//
	//  Flags for properties of the scatter-list
	//
	ULONG       Flags;

} SCATTER_LIST, *PSCATTER_LIST;

#define     IFS_SLIST_FLAGS_LARGE_BUFFER        0x00000001

//
//  Linked list of scatter-list entries
//
typedef struct _SCATTER_LIST_NODE {
    //
    //  Scatter-List entry
    //
    SCATTER_LIST_ENTRY      Block;

    //
    //  Doubly linked list of blocks
    //
    LIST_ENTRY              NextBlock;

} SCATTER_LIST_NODE, *PSCATTER_LIST_NODE;

#define SCATTER_LIST_CONTAINING_RECORD( x )     CONTAINING_RECORD( x, SCATTER_LIST_NODE, NextBlock )

//
//  IFS file extended attributes -
//  NtQueryEaFile() will return the extended attributes
//  for an IFS file. Currently, the following extended attributes
//  are supported (in order) - 
//
//  1. "FileName"       - WCHAR  : name of IFS file (NULL terminated)
//  2. "Commit"         - NTSTATUS: STATUS_SUCCESS if committed
//  3. "InstanceID"     - ULONG  : NET_ROOT ID for validation
//  4. "Checksum"       - ULONG  : checksum for FILE_FULL_EA_INFORMATION
//  5. "OpenDeadline"   - ULONG  : time for which ScatterList is valid
//  6. "Properties"     - ULONG  : persisted message properties
//  7. "ScatterList"    -        : scatter list for an IFS file
//
//  IFS will return values for all attributes in one call.
//  Each of the EA values will be QWORD Aligned.
//  If the Buffer supplied is not big enough, IFS will
//  return STATUS_BUFFER_OVERFLOW.
//
//  NOTE: The "Commit" EA is not actually stored. Callers of
//  NtQueryEaFile() can ask for this EA in the EaList param.
//  QUERYING FOR THIS EA IS AN IMPLICIT REQUEST TO COMMIT
//  RESERVED BYTES FOR THIS IFS HANDLE.....!
//
//  NtQueryEa() can (optionally) pass in a value for the "Properties" EA
//
//  NtCreateFile() notes:
//  This API will use all EAs except the "FileName". Semantics:
//  "Commit" - STATUS_SUCESSS => Bytes are committed, dont reuse on close.
//  "InstanceID" - used to validate handles belonging to a particular
//      instance of a root.
//  "Checksum" - validate checksum on EA list.
//  "OpenDeadline" - validate time deadline on scatter-list. If the
//      time deadline has expired, owner of root may reuse this list.
//  "Properties" - is set in the FCB extension
//  "ScatterList" - describes pages for file being created.

#define EXIFS_EA_NAME_COMMIT            "Commit"
#define EXIFS_EA_NAME_INSTANCE_ID       "InstanceID"
#define EXIFS_EA_NAME_CHECKSUM          "Checksum"
#define EXIFS_EA_NAME_OPEN_DEADLINE     "OpenDeadline"
#define EXIFS_EA_NAME_PROPERTIES        "Properties"
#define EXIFS_EA_NAME_FILENAME          "FileName"
#define EXIFS_EA_NAME_SCATTER_LIST      "ScatterList"
#define EXIFS_MAX_EAS                   7
#define EXIFS_CHECKSUM_SEED             0xFEEDFEED

#define EXIFS_INVALID_INSTANCE_ID       0xFFFFFFFF

#ifndef LongAlign
#define LongAlign(Ptr) (                \
    ((((ULONG_PTR)(Ptr)) + 3) & 0xfffffffc) \
    )
#endif

#define EXIFS_EA_LEN_COMMIT                                                 \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_COMMIT) + sizeof(ULONG))            

#define EXIFS_EA_LEN_INSTANCE_ID                                            \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_INSTANCE_ID) + sizeof(ULONG))            

#define EXIFS_EA_LEN_CHECKSUM                                               \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_CHECKSUM) + sizeof(ULONG))          

#define EXIFS_EA_LEN_OPEN_DEADLINE                                          \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_OPEN_DEADLINE) + sizeof(ULONG))     

#define EXIFS_EA_LEN_PROPERTIES                                             \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_PROPERTIES) + sizeof(ULONG))     

#define EXIFS_EA_LEN_FILENAME(len)                                          \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_FILENAME) + LongAlign(len))         

#define EXIFS_EA_LEN_SCATTER_LIST(n)                                        \
        LongAlign(FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +     \
        sizeof(EXIFS_EA_NAME_SCATTER_LIST) +                                \
        LongAlign(sizeof(SCATTER_LIST) +                                    \
        ((n)>MAX_FRAGMENTS?(n)-MAX_FRAGMENTS:0)*sizeof(SCATTER_LIST_ENTRY)))

#define EXIFS_GET_EA_LEN_COMMIT                                             \
        LongAlign(FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0] ) +      \
        sizeof(EXIFS_EA_NAME_COMMIT))            

#define EXIFS_GET_EA_LEN_INSTANCE_ID                                        \
        LongAlign(FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0] ) +      \
        sizeof(EXIFS_EA_NAME_INSTANCE_ID))            

#define EXIFS_GET_EA_LEN_PROPERTIES                                         \
        LongAlign(FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0] ) +      \
        sizeof(EXIFS_EA_NAME_PROPERTIES))            

//
//  IOCTL codes supported by Exchange IFS Device.
//

#define IOCTL_CODE_INITIALIZE_ROOT      100
#define IOCTL_CODE_SPACEGRANT_ROOT      101
#define IOCTL_CODE_SPACEREQ_ROOT        102
#define IOCTL_CODE_TERMINATE_ROOT       103
#define IOCTL_CODE_QUERYSTATS_ROOT      104
#define IOCTL_CODE_SETENDOFFILE_ROOT    105
#define IOCTL_CODE_DIR_CHNG_REPORT      106
#define IOCTL_CODE_INITDRIVE		    107
#define IOCTL_CODE_EXPUNGE_NAME         108
#define IOCTL_CODE_SETMAP_ROOT          109
#define IOCTL_CODE_RESETMAP_ROOT        110

//
//  WIN32 IOCTL codes
//
#define IOCTL_CODE_UMRX_PACKET           150
#define IOCTL_CODE_UMRX_TEARDOWN         151
#define IOCTL_CODE_UMRX_STARTUP          152
#define IOCTL_CODE_UMRX_ENABLE_NET_ROOT  153
#define IOCTL_CODE_UMRX_DISABLE_NET_ROOT 154


//suspend and resume IOCTLS
#define IOCTL_EXIFS_SETMAP_ROOT     _EXIFS_CONTROL_CODE(IOCTL_CODE_SETMAP_ROOT, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_EXIFS_RESETMAP_ROOT   _EXIFS_CONTROL_CODE(IOCTL_CODE_RESETMAP_ROOT, METHOD_NEITHER, FILE_ANY_ACCESS)

//
//  Semantics for using an IFS root:
//  1. App gets a handle (exclusive) to the root via 
//     CreateFile(\Device\ExchangeIfsDevice\{NodeName}\{RootName}).
//     This handle should be opened for overlapped I/O.
//
//  2. App calls overlapped DeviceIoControl() with INITIALIZE_ROOT IOCTL.
//
//  3. This will succeed or fail synchronously. If DeviceIoControl()
//     returns TRUE, it succeeded. If it returns FALSE, GetLastError() or
//     the NTSTATUS from NtDeviceIoControl() is the error code.
//     NOTE: If this IOCTL has NOT been made on a root successfully,
//     no I/O on this root will succeed.
//
//  3. At this point, the IFS root has no space grants.
//     It is expected that the app will make one or more SPACEGRANT_ROOT
//     IOCTLs to grant space on this root. Each of these IOCTLs will finish
//     synchronously and return semantics are similar to INITIALIZE_ROOT.
//
//  4. An app should also pend an async SPACEREQ_ROOT IOCTL. Usually, this
//     will return with ERROR_IO_PENDING. If this later completes with
//     NTSTATUS == EXSTATUS_ROOT_NEEDS_SPACE, the app should make a space
//     grant (SPACEGRANT_ROOT) and pend another SPACEREQ_ROOT. This will 
//     happen if IFS runs out of free space blocks on this root. If the IOCTL
//     completes with STATUS_SUCCESS, app should NOT pend another IOCTL.
//
//  5. App calls overlapped DeviceIoControl() with TERMINATE_ROOT IOCTL.
//     This will complete any async pended IOCTLs. After this call, the root 
//     starts shutting down. This IOCTL will complete synchronously.
//     NOTE: Once terminated, a root cannot be initialized again.
//
//  6. App closes handle to root. Note: Handle to root needs to be kept
//     open across life of root. Once the root handle is closed, the IFS
//     root has no free space. All of the free space allocated to the 
//     root before TERMINATE needs to be reclaimed by the app.
//     The app can now re-create this root starting at step1.
//
//  7. If the app with an exclusive handle to a root dies, the root will
//     be marked 'bad' and new I/Os (including IOCTLs) to this root will
//     fail. Over time, outstanding handles on this root will go away and
//     eventually the root will die. At this point, an app can re-create
//     the root starting at step 1.
//

//
//  IOCTL to initialize a net root. This results in creating an entry
//  in the RootMapTable. There is one entry in this table for every
//  secondary NTFS file managed by the IFS driver.
//  NOTE: IFS will attempt to get an exclusive handle to the underlying
//  file. This ensures that all operations on the underlying file are
//  done through IFS.
//
//  Following is the IOCTL definition and associated structs.
//
#define IOCTL_EXIFS_INITIALIZE_ROOT     _EXIFS_CONTROL_CODE(IOCTL_CODE_INITIALIZE_ROOT, METHOD_NEITHER, FILE_ANY_ACCESS)

//
//  InBuffer struct
//
typedef struct _IOCTL_INITROOT_IN
{
    //
    //  Signature for this struct
    //
    ULONG           Signature;

    //
    //  Underlying Ntfs filename for this root.
    //  Length is the size in bytes of the name.
    //  Offset should be from the start of this struct.
    //
    USHORT          NtfsFileNameLength;
    USHORT          NtfsFileNameOffset;

    //
    //  Flags to control access to Ntfs file
    //
    ULONG           NtfsFlags;

    //
    //  Allocation unit for this root. Min is 4K
    //
    ULONG           AllocationUnit;

    //
    //  root InstanceID
    //
    ULONG           InstanceID;
    
} IOCTL_INITROOT_IN, *PIOCTL_INITROOT_IN;

typedef struct _IOCTL_INITROOT_IN_EX
{
	IOCTL_INITROOT_IN InitRoot;
	WCHAR			RootName[MAX_PATH];
}IOCTL_INITROOT_IN_EX, *PIOCTL_INITROOT_IN_EX;


//
//  IOCTL to grant space to an initialized net root. 
//  Following is the IOCTL definition and associated structs.
//
#define IOCTL_EXIFS_SPACEGRANT_ROOT     _EXIFS_CONTROL_CODE(IOCTL_CODE_SPACEGRANT_ROOT, METHOD_NEITHER, FILE_ANY_ACCESS)

//
//  Free space is granted in chunks. The root owner decides
//  what the maximum chunk size is.
//
#define MAX_EXIFS_FREEBLOCK_SIZE        0x100000

//
//  Default chunk size
//
#define EXIFS_DEFAULT_CHUNK_SIZE        0x40000

//
//  MAXIMUM file size allowed by IFS
//
#define EXIFS_MAXIMUM_FILESIZE          0x7FFFFFFF

//
//  InBuffer struct
//
typedef struct _IOCTL_SPACEGRANT_IN
{
    //
    //  Signature for this struct
    //
    ULONG           Signature;

    //
    //  Scatter-list of free space - must be last
    //
    SCATTER_LIST    FreeSpaceList;


} IOCTL_SPACEGRANT_IN, *PIOCTL_SPACEGRANT_IN;

typedef struct _IOCTL_SPACEGRANT_IN_EX
{
    //
    //  Signature for this struct
    //
    ULONG           Signature;


	WCHAR			RootName[MAX_PATH];

    SCATTER_LIST    *W9xFreeSpaceList;

} IOCTL_SPACEGRANT_IN_EX, *PIOCTL_SPACEGRANT_IN_EX;

//
//  IOCTL to allow IFS to request space on an initialized net root.
//  Following is the IOCTL definition and associated structs.
//
#define IOCTL_EXIFS_SPACEREQ_ROOT     _EXIFS_CONTROL_CODE(IOCTL_CODE_SPACEREQ_ROOT, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct _IOCTL_SPACEREQ_ROOT_IN
{
	WCHAR RootName[MAX_PATH];
}IOCTL_SPACEREQ_ROOT_IN, *PIOCTL_SPACEREQ_ROOT_IN;

//
//  IOCTL to terminate a net root. This results in deleting an entry
//  in the RootMapTable. There is one entry in this table for every
//  secondary NTFS file managed by the IFS driver. Following is the IOCTL
//  definition and associated structs.
//
#define IOCTL_EXIFS_TERMINATE_ROOT      _EXIFS_CONTROL_CODE(IOCTL_CODE_TERMINATE_ROOT, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  InBuffer struct
//
typedef struct _IOCTL_TERMROOT_IN
{
    //
    //  Signature for this struct
    //
    ULONG           Signature;

    //
    //  Mode of shutdown
    //
    ULONG           Mode;

} IOCTL_TERMROOT_IN, *PIOCTL_TERMROOT_IN;

typedef struct _IOCTL_TERMROOT_IN_EX
{
	IOCTL_TERMROOT_IN	TermRoot;
	WCHAR			RootName[MAX_PATH];
} IOCTL_TERMROOT_IN_EX, *PIOCTL_TERMROOT_IN_EX;

#if 0
//
//  IOCTL to query a net root for current free space. Currently, NYI.
//  The goal for this is to allow app to retrieve fragmented free lists
//  in order to defrag.
//  Following is the IOCTL definition and associated structs.
//
#define IOCTL_EXIFS_QUERY_ROOT      _EXIFS_CONTROL_CODE(IOCTL_CODE_QUERY_ROOT, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  OutBuffer struct
//
typedef struct _IOCTL_QUERYROOT_OUT
{
    //
    //  Signature for this struct
    //
    ULONG           Signature;

    //
    //  Return code
    //
    NTSTATUS        IoctlStatus;

    //
    //  Free space list for this root
    //
    SCATTER_LIST    FreeSpaceList;

} IOCTL_QUERYROOT_OUT, *PIOCTL_QUERYROOT_OUT;
#endif

//
//  IOCTL to query stats for a net root.
//
#define IOCTL_EXIFS_QUERYSTATS_ROOT     _EXIFS_CONTROL_CODE(IOCTL_CODE_QUERYSTATS_ROOT, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_QUERYSTATS_FILENAME       L"\\$PERFMON$"

//
//  Statistics for a net root
//
typedef struct _EXIFS_NETROOT_STATS {
    //
    //  Number of Creates
    //
    ULONG           NumberOfCreates;

    //
    //  Number of Opens
    //
    ULONG           NumberOfOpens;

    //
    //  Number of Collapsed Opens
    //
    ULONG           NumberOfCollapsedOpens;

    //
    //  Number of IRP Reads
    //
    ULONG           NumberOfIrpReads;

    //
    //  Number of MDL Reads
    //
    ULONG           NumberOfMdlReads;
    
    //
    //  Number of Writes
    //
    ULONG           NumberOfWrites;

    //
    //  Number of Close
    //
    ULONG           NumberOfClose;

    //
    //  Number of FCB close
    //
    ULONG           NumberOfFCBClose;

    //
    //  Total Bytes Read
    //
    LARGE_INTEGER   TotalBytesRead;

    //
    //  Total Bytes Written
    //
    LARGE_INTEGER   TotalBytesWritten;

    //
    //  Reserved Bytes ie on primary free list
    //
    LARGE_INTEGER   ReservedBytes;
    
    //
    //  Orphaned Bytes ie on secondary free list
    //  Total Available Bytes = ReservedBytes + OrphanedBytes
    //
    LARGE_INTEGER   OrphanedBytes;

} EXIFS_NETROOT_STATS, *PEXIFS_NETROOT_STATS;

//
//  Cheap stats do not cause locks to be acquired. 
//  Other modes may need locks.
//
#define     EXIFS_QUERYSTATS_CHEAP      1
#define     EXIFS_QUERYSTATS_MEDIUM     2
#define     EXIFS_QUERYSTATS_ALL        3

//
//  InBuffer struct
//
typedef struct _IOCTL_QUERYSTATS_IN
{
    //
    //  Signature for this struct
    //
    ULONG               Signature;

    //
    //  Granularity of stats
    //
    ULONG               Granularity;

	WCHAR			RootName[MAX_PATH];

} IOCTL_QUERYSTATS_IN, *PIOCTL_QUERYSTATS_IN;

//
//  OutBuffer struct
//
typedef struct _IOCTL_QUERYSTATS_OUT
{
    //
    //  Signature for this struct
    //
    ULONG               Signature;

    //
    //  Return code
    //
    NTSTATUS            IoctlStatus;

    //
    //  Stats data
    //
    EXIFS_NETROOT_STATS RootStats;


} IOCTL_QUERYSTATS_OUT, *PIOCTL_QUERYSTATS_OUT;

//
//  IOCTL to set end of file (truncate or extend) for root underlying file.
//  It is callers responsibility to zero extended length when extending.
//
#define IOCTL_EXIFS_SETENDOFFILE_ROOT       _EXIFS_CONTROL_CODE(IOCTL_CODE_SETENDOFFILE_ROOT, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  InBuffer struct
//
typedef struct _IOCTL_SETENDOFFILE_IN
{
    //
    //  Signature for this struct
    //
    ULONG               Signature;

    //
    //  New EOF
    //
    LARGE_INTEGER       EndOfFile;

} IOCTL_SETENDOFFILE_IN, *PIOCTL_SETENDOFFILE_IN;

typedef struct _IOCTL_SETENDOFFILE_IN_EX
{

	IOCTL_SETENDOFFILE_IN	SetEndOfFile;
	WCHAR			RootName[MAX_PATH];

} IOCTL_SETENDOFFILE_IN_EX, *PIOCTL_SETENDOFFILE_IN_EX;

//
// IOCTL to send down reports about changes in directories that exifs.sys doesn't
//    know about.
//
#define IOCTL_EXIFS_DIR_CHNG_REPORT _EXIFS_CONTROL_CODE(IOCTL_CODE_DIR_CHNG_REPORT, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  InBuffer struct
//
typedef struct _IOCTL_DIR_CHNG_REPORT_IN
{
    //
    //  Signature for this struct
    //
    ULONG               Signature;

	//
	//  Action
	//
	ULONG               ulAction;

	//
	//  FilterMatch
	//
	ULONG               ulFilterMatch;
	
	//
	//  Path length (bytes)
	//
    ULONG               cbPath;

	//
	//  Path (unicode)
	//
    WCHAR               rgwchPath[1];

} IOCTL_DIR_CHNG_REPORT_IN, *PIOCTL_DIR_CHNG_REPORT_IN;

//
// IOCTL to send request to close and unlock namespace
//
#define IOCTL_EXIFS_EXPUNGE_NAME    _EXIFS_CONTROL_CODE( IOCTL_CODE_EXPUNGE_NAME, METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// InBuffer struct
//
typedef struct _IOCTL_EXPUNGE_NAME_IN
{
    //
    // Signature for this struct
    //
    ULONG       Signature;

    //
	//  Path length (bytes)
	//
    ULONG       cbPath;

	//
	//  Path (unicode)
	//
    WCHAR       rgwchPath[ 1 ];

}   IOCTL_EXPUNGE_NAME_IN, *PIOCTL_EXPUNGE_NAME_IN;

//
// OutBuffer struct
//
typedef struct _IOCTL_EXPUNGE_NAME_OUT
{
    //
    // Signature for this struct
    //
    ULONG       Signature;

    //
    // Status of operation
    //
    NTSTATUS    Status;
    
}   IOCTL_EXPUNGE_NAME_OUT, *PIOCTL_EXPUNGE_NAME_OUT;

//
//  IOCTLs for UMR piece -
//  1. UMRX_PACKET IOCTLs will be pended for WORK requests/responses. These
//     need to be pended on the Root\WIN32ROOT\$ namespace. The net root
//     needs to have been initialized already.
//
//  2. TEARDOWN IOCTL will be sent when the UMR engine on the root needs to
//     be shutdown. This should be done before the root is terminated.
//     NOTE: process shutdown is auto-detected by the UMR engine.
//
//  3. STARTUP IOCTL will allow worker threads to queue up on the UMRX's KQUEUE
//     It complements the TEARDOWN IOCTL
//
//  4. ENABLE_NET_ROOT IOCTL allows win32 usermode requests to be made from the
//     netroot that this ioctl is being done on.
//  
//  5. DISABLE_NET_ROOT IOCTL disallows win32 usermode requests to be made form the
//     newroot that this ioctl is done on.  Once the call to DeviceIoControl() returns
//     there will be no more user mode requests made on that net root.
//

#define IOCTL_EXIFS_UMRX_PACKET           _EXIFS_CONTROL_CODE(IOCTL_CODE_UMRX_PACKET, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EXIFS_UMRX_TEARDOWN         _EXIFS_CONTROL_CODE(IOCTL_CODE_UMRX_TEARDOWN, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EXIFS_UMRX_STARTUP          _EXIFS_CONTROL_CODE(IOCTL_CODE_UMRX_STARTUP, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  When enabling NetRoot's we get the current version number the netroot has squirreled away from when Jet initialized it !
//
#define IOCTL_EXIFS_UMRX_ENABLE_NET_ROOT  _EXIFS_CONTROL_CODE(IOCTL_CODE_UMRX_ENABLE_NET_ROOT, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct  _IOCTL_EXIFS_UMRX_ENABLE_NET_ROOT_OUT
{
    //
    //  Signature for this structre !
    //
    ULONG           Signature ;
    //
    //  Version of the netroot that should, be put in future open requests !
    //
    ULONG           InstanceId ;
    //
    //  Pointer to the netroot that should be put in future open responses !
    //
    ULONG           NetRootPointer ;
    //
    // Save jets allocation size
    //
    ULONG			AllocationUnit;
}   IOCTL_EXIFS_UMRX_ENABLE_NET_ROOT_OUT, *PIOCTL_EXIFS_UMRX_ENABLE_NET_ROOT_OUT ;


#define IOCTL_EXIFS_UMRX_DISABLE_NET_ROOT _EXIFS_CONTROL_CODE(IOCTL_CODE_UMRX_DISABLE_NET_ROOT, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  IMPORTANT NOTE : 
//
//  IOCTL_WIN32_FILENAME is EXACTLY 8 characters long because we will OVERWRITE 
//  it in the filenames that we put in the FCB.  We will replace the 'IN32ROOT' 
//  portion with the hexadecimal version id coming off of the netroot for the 
//  particular file.
//  Why ? Because this will cause dead FCB's to not hurt users across MDB Start/Stops
//
#define IOCTL_WIN32_FILENAME_START  L"\\W" 
#define IOCTL_WIN32_FILENAME        L"\\WIN32ROOT"
#define WIN32_PREFIX_LEN            (sizeof(IOCTL_WIN32_FILENAME)-sizeof(WCHAR))
#define WIN32_DIGIT_LEN             (sizeof(IOCTL_WIN32_FILENAME) - sizeof(IOCTL_WIN32_FILENAME_START))
#define IOCTL_WIN32_UMRX_NAME       L"\\WIN32ROOT\\$"
#define UMRX_PREFIX_LEN             (sizeof(IOCTL_WIN32_UMRX_NAME)-2)

#define IFSWIN32SIGNATURE	'WIN3'
#define IFSJETSIGNATURE		'AJET'

typedef struct _IFS_CREATE_RESPONSE_
{
	DWORD		Signature;
	NTSTATUS	Status;
	ULONG		EaLength;
	HANDLE      hResponseContext;
	PWSTR		pEaSysBuffer;
	PWSTR		Win32Name;
}IFS_CREATE_RESPONSE, *PIFS_CREATE_RESPONSE;

#define IOCTL_EXIFS_REGISTER_UMR		200

typedef struct _SETEA_INFORMATION_
{
	PVOID	EaBuffer;
	ULONG   EaLength;
	WCHAR	FcbName[MAX_PATH * sizeof(WCHAR)];
}IOCTL_SETEA_INFORMATION_IN, *PIOCTL_SETEA_INFORMATION_IN;

#define IOCTL_CODE_SET_EA			900
#define IOCTL_EXIFS_SET_EA   _EXIFS_CONTROL_CODE(IOCTL_CODE_SET_EA, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _GETEA_INFORMATION_
{
	PVOID	EaBuffer;
	ULONG   EaLength;
	WCHAR	FcbName[MAX_PATH];
}IOCTL_GETEA_INFORMATION_IN, *PIOCTL_GETEA_INFORMATION_IN;

#define IOCTL_CODE_QUERY_EA			1000
#define IOCTL_EXIFS_QUERY_EA   _EXIFS_CONTROL_CODE(IOCTL_CODE_QUERY_EA, METHOD_BUFFERED, FILE_ANY_ACCESS)


#endif // _EXIFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\export\esebcli2.h ===
/*
 *	ESEBCLI2.H
 *
 *	Microsoft Exchange
 *	Copyright (C) 1986-1996, Microsoft Corporation
 *	
 *	Contains declarations of additional definitions and interfaces
 *	for the ESE Online Backup Client APIs.
 */
#ifndef	_ESEBCLI2_
#define	_ESEBCLI2_

#include <stdio.h>
#include <time.h>

#include "esebkmsg.h" // included for the definition of errors


//	Common types
typedef	long ERR;
typedef void *HCCX;					// client context handle

#ifdef MIDL_PASS

#define RPC_STRING 		[unique, string] WCHAR *
#define RPC_SIZE(X)		[size_is(X)]

#else // ! MIDL_PASS


#include <objbase.h>
#include <initguid.h>
#include <mapiguid.h>

typedef	long HRESULT;
#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#else
typedef wchar_t WCHAR;
#endif

#define RPC_STRING WCHAR *
#define RPC_SIZE(X)		

#define IN
#define OUT

#endif // MIDL_PASS


#define	ESEBACK_API __stdcall

#ifdef	__cplusplus
extern "C" {
#endif


typedef struct _ESE_ICON_DESCRIPTION
	{
	unsigned long 										ulSize;
	RPC_SIZE(ulSize) char * 							pvData;	
	} ESE_ICON_DESCRIPTION;


#define DATABASE_MOUNTED 	0x00000010

typedef struct _DATABASE_BACKUP_INFO
	{
	RPC_STRING 											wszDatabaseDisplayName;

	unsigned long 										cwDatabaseStreams;
	RPC_SIZE(cwDatabaseStreams)  WCHAR * 				wszDatabaseStreams;
	
	GUID  												guidDatabase;
	unsigned long  										ulIconIndexDatabase;
	unsigned long 										fDatabaseFlags;
	
	} DATABASE_BACKUP_INFO;
	
typedef struct _INSTANCE_BACKUP_INFO
	{
	__int64 											hInstanceId;
	RPC_STRING							 				wszInstanceName;
	unsigned long 										ulIconIndexInstance;
	
	unsigned long 										cDatabase;
	RPC_SIZE(cDatabase) DATABASE_BACKUP_INFO * 			rgDatabase;
	
	unsigned long					 					cIconDescription;
	RPC_SIZE(cIconDescription) ESE_ICON_DESCRIPTION * 	rgIconDescription;
	
	} INSTANCE_BACKUP_INFO;
	
//
//	Type of backup passed into HrESEBackupSetup()
//

#define	BACKUP_TYPE_FULL					0x01
#define	BACKUP_TYPE_LOGS_ONLY				0x02
#define BACKUP_TYPE_FULL_WITH_ALL_LOGS		0x03
#define BACKUP_TYPE_SNAPSHOT				0x04


typedef struct _ESE_REGISTERED_INFO
	{
	RPC_STRING							 				wszDisplayName;
	RPC_STRING							 				wszEndpointAnnotation;
	unsigned long 										fFlags;
	ESE_ICON_DESCRIPTION 								iconDescription;	
	} ESE_REGISTERED_INFO;


#define ESE_REGISTER_BACKUP 			0x00000001
#define ESE_REGISTER_ONLINE_RESTORE 	0x00000002
#define ESE_REGISTER_OFFLINE_RESTORE 	0x00000004

#define ESE_REGISTER_SNAPSHOT_BACKUP 	0x00000010


HRESULT ESEBACK_API HrESEBackupRestoreGetRegistered(
	IN  WCHAR *  					wszServerName,
	IN  WCHAR *  					wszDisplayName,
	IN 	unsigned long  				fFlags,
	OUT unsigned long * 			pcRegisteredInfo,
	OUT ESE_REGISTERED_INFO ** 		paRegisteredInfo
	);
	
void ESEBACK_API ESEBackupRestoreFreeRegisteredInfo(
	IN 	unsigned long 			cRegisteredInfo,
	IN  ESE_REGISTERED_INFO * 	aRegisteredInfo);

HRESULT ESEBACK_API HrESEBackupPrepare(
	IN  WCHAR *  		wszBackupServer,
	IN  WCHAR *  		wszBackupAnnotation,
	OUT unsigned long *				pcInstanceInfo,
	OUT INSTANCE_BACKUP_INFO ** 	paInstanceInfo,
	OUT HCCX * 			phccxBackupContext
	);

HRESULT ESEBACK_API HrESEBackupSetup(
	IN  HCCX 			hccxBackupContext,
	IN  __int64 		hInstanceId,
	IN  unsigned long 	btBackupType
	);

HRESULT ESEBACK_API HrESEBackupTruncateLogs(
	IN  HCCX 			hccxBackupContext
	);
	
HRESULT ESEBACK_API HrESEBackupGetDependencyInfo(
	IN  HCCX 			hccxBackupContext,
	OUT WCHAR **		pwszInfo,
	OUT unsigned long * pcwInfo,
	OUT WCHAR **		pwszAnnotation
	);
	
HRESULT ESEBACK_API HrESEBackupOpenFile (
	IN  HCCX 			hccxBackupContext,
	IN  WCHAR *			wszFileName,
	IN  unsigned long 	cbReadHintSize,
	IN  unsigned long 	cSections,
	OUT void **			rghFile,
	OUT __int64 *		rgliSectionSize
	);

HRESULT ESEBACK_API HrESEBackupReadFile(
	IN 	HCCX 			hccxBackupContext,
	IN 	void * 			hFile,
	IN 	void * 			pvBuffer,
	IN 	unsigned long 	cbBuffer,
	OUT unsigned long *	pcbRead
	);

HRESULT ESEBACK_API HrESEBackupCloseFile(
	IN  HCCX 			hccxBackupContext,
	IN 	void * 			hFile
	);

HRESULT ESEBACK_API HrESEBackupGetLogAndPatchFiles(
	IN  HCCX 			hccxBackupContext,
	IN  WCHAR **		pwszFiles
	);

HRESULT ESEBACK_API HrESEBackupGetTruncateLogFiles(
	IN  HCCX 			hccxBackupContext,
	IN  WCHAR **		pwszFiles
	);

void ESEBACK_API ESEBackupFreeInstanceInfo(
	IN unsigned long 				cInstanceInfo,
	IN INSTANCE_BACKUP_INFO * 		aInstanceInfo
	);

void ESEBACK_API ESEBackupFree(
	IN  void *			pvBuffer
	);

#define ESE_BACKUP_INSTANCE_END_ERROR		0x00000000
#define ESE_BACKUP_INSTANCE_END_SUCCESS		0x00000001

HRESULT ESEBACK_API HrESEBackupInstanceEnd(
	IN  HCCX 			hccxBackupContext,
	IN  unsigned long 	fFlags
	);

HRESULT ESEBACK_API HrESEBackupEnd(
	IN  HCCX 			hccxBackupContext
	);
	
//	Restore client APIs

typedef enum
	{
	recoverInvalid 		= 0,
	recoverNotStarted 	= 1,
	recoverStarted 		= 2,
	recoverEnded 		= 3,
	recoverStatusMax
	}
	RECOVER_STATUS;


typedef struct _RESTORE_ENVIRONMENT
	{
	WCHAR * 		m_wszRestoreLogPath;
	
	WCHAR * 		m_wszSrcInstanceName;

	unsigned long 	m_cDatabases;
	WCHAR ** 		m_wszDatabaseDisplayName;
	GUID * 			m_rguidDatabase;

	WCHAR * 		m_wszRestoreInstanceSystemPath;	
	WCHAR * 		m_wszRestoreInstanceLogPath;	
	WCHAR * 		m_wszTargetInstanceName;	
	
	WCHAR ** 		m_wszDatabaseStreamsS;	
	WCHAR ** 		m_wszDatabaseStreamsD;	
	
	unsigned long 	m_ulGenLow;
	unsigned long 	m_ulGenHigh;
	WCHAR *	 		m_wszLogBaseName;	

	time_t 			m_timeLastRestore;

	RECOVER_STATUS 	m_statusLastRecover;
	HRESULT 		m_hrLastRecover;	
	time_t 			m_timeLastRecover;

	WCHAR * 		m_wszAnnotation;	
	
	} RESTORE_ENVIRONMENT;

HRESULT ESEBACK_API HrESERestoreLoadEnvironment(
	IN	WCHAR *				wszServerName,
	IN	WCHAR *				wszRestoreLogPath,
	OUT RESTORE_ENVIRONMENT ** 	ppRestoreEnvironment);

void ESEBACK_API ESERestoreFreeEnvironment(
	IN  RESTORE_ENVIRONMENT * 	pRestoreEnvironment);
	

HRESULT ESEBACK_API HrESERestoreOpen(
	IN  WCHAR *					wszServerName,
	IN  WCHAR *					wszServiceAnnotation,
	IN  WCHAR *		 			wszSrcInstanceName,
	IN  WCHAR * 				wszRestoreLogPath,
	OUT HCCX *					phccxRestoreContext);

HRESULT ESEBACK_API HrESERestoreReopen(
	IN  WCHAR *					wszServerName,
	IN  WCHAR *					wszServiceAnnotation,
	IN  WCHAR *		 			wszRestoreLogPath,
	OUT HCCX *					phccxRestoreContext);
	

void ESEBACK_API ESERestoreFree( IN void *pvBuffer );


#define RESTORE_CLOSE_ABORT		0x1
#define RESTORE_CLOSE_NORMAL	0x0

HRESULT ESEBACK_API HrESERestoreClose(
	IN  HCCX 					hccxRestoreContext,
	IN  unsigned long 			fRestoreAbort);

HRESULT ESEBACK_API HrESERestoreAddDatabase(
	IN  HCCX 					hccxRestoreContext,
	IN  WCHAR *					wszDatabaseDisplayName,
	IN  GUID					guidDatabase,
	IN  WCHAR *		 			wszDatabaseStreamsS,
	OUT WCHAR **	 			pwszDatabaseStreamsD);

HRESULT ESEBACK_API HrESERestoreGetEnvironment(
	IN  HCCX 					hccxRestoreContext,
	OUT RESTORE_ENVIRONMENT ** 	ppRestoreEnvironment);

HRESULT ESEBACK_API HrESERestoreSaveEnvironment(
	IN  HCCX 					hccxRestoreContext);


#define ESE_RESTORE_COMPLETE_ATTACH_DBS			0x00000001
#define ESE_RESTORE_COMPLETE_START_SERVICE		ESE_RESTORE_COMPLETE_ATTACH_DBS

#define ESE_RESTORE_COMPLETE_NOWAIT				0x00010000
#define ESE_RESTORE_KEEP_LOG_FILES				0x00020000


HRESULT ESEBACK_API HrESERestoreComplete(
	IN  HCCX 					hccxRestoreContext,
	IN  WCHAR *					wszRestoreInstanceSystemPath,	
	IN  WCHAR *					wszRestoreInstanceLogPath,	
	IN  WCHAR *					wszTargetInstanceName,	
	IN  unsigned long 			fFlags);

HRESULT ESEBACK_API HrESERestoreAddDatabaseNS(
	IN  HCCX 					hccxRestoreContext,
	IN  WCHAR *					wszDatabaseDisplayName,
	IN  GUID					guidDatabase,
	IN  WCHAR *		 			wszDatabaseStreamsS,
	IN  WCHAR *	 				wszDatabaseStreamsD);
	

HRESULT ESEBACK_API HrESERestoreOpenFile (
	IN  HCCX 			hccxRestoreContext,
	IN  WCHAR *			wszFileName,
	IN  unsigned long 	cSections,
	OUT void **			rghFile
	);

HRESULT ESEBACK_API HrESERestoreWriteFile(
	IN 	HCCX 			hccxRestoreContext,
	IN 	void * 			hFile,
	IN 	void * 			pvBuffer,
	IN 	unsigned long 	cbBuffer
	);

HRESULT ESEBACK_API HrESERestoreCloseFile(
	IN  HCCX 			hccxRestoreContext,
	IN 	void * 			hFile
	);

/* function used to find the computers to be queried for backup/restore */
/* MAD like behaviour */
#define BACKUP_NODE_TYPE_MACHINE 		0x00000001
#define BACKUP_NODE_TYPE_ANNOTATION 	0x00000010
#define BACKUP_NODE_TYPE_DISPLAY	 	0x00000100

typedef struct _BACKUP_NODE_TREE
	{
	RPC_STRING 				wszName;
	unsigned long 			fFlags;
	ESE_ICON_DESCRIPTION	iconDescription;
	
	struct _BACKUP_NODE_TREE * 	pNextNode;
	struct _BACKUP_NODE_TREE * 	pChildNode;

} BACKUP_NODE_TREE, * PBACKUP_NODE_TREE;


HRESULT ESEBACK_API HrESEBackupRestoreGetNodes(
	IN  WCHAR * 				wszComputerName,
	OUT PBACKUP_NODE_TREE * 	ppBackupNodeTree);

void ESEBACK_API ESEBackupRestoreFreeNodes(
	IN PBACKUP_NODE_TREE  	pBackupNodeTree);



// Specific errors that can be returned by callback functions

// Database to be restored is in use
#define hrFromCB_DatabaseInUse 							hrCBDatabaseInUse

// Database not found
#define hrFromCB_DatabaseNotFound 						hrCBDatabaseNotFound

// Display name for the database not found
#define hrFromCB_DatabaseDisplayNameNotFound 			hrCBDatabaseDisplayNameNotFound

// Requested path for restore log files not provided
#define hrFromCB_RestorePathNotProvided 				hrCBRestorePathNotProvided

// Instance to backup not found
#define hrFromCB_InstanceNotFound 						hrCBInstanceNotFound

// Database can not be overwritten by a restore
#define hrFromCB_DatabaseCantBeOverwritten 				hrCBDatabaseCantBeOverwritten

// snapshot API

HRESULT ESEBACK_API HrESESnapshotStart( 		
										IN  HCCX 					hccxBackupContext,
										IN  WCHAR *		 			wszDatabases,
										IN  unsigned long 			fFlags );
										

HRESULT ESEBACK_API HrESESnapshotStop(	IN  HCCX 						hccxBackupContext,
										IN  unsigned long 				fFlags );

#ifdef	__cplusplus
}
#endif

#endif	// _EDBBCLI2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\export\eseback2.h ===
/*
 *	ESEBACK2.H
 *	
 *	Contains declarations of additional definitions and interfaces
 *	for the ESE server apps.
 */
#ifndef	_ESEBACK2_
#define	_ESEBACK2_

//
//	Useful types.
//
typedef	long ERR;
typedef	long HRESULT;

#include "jet.h"
#include "esebcli2.h"

#define	ESEBACK_API __stdcall
#define	ESEBACK_CALLBACK __stdcall

#ifdef	__cplusplus
extern "C" {
#endif

#define IN
#define OUT


//  Server API for backup and restore

#ifndef ESE_REGISTER_BACKUP
#define ESE_REGISTER_BACKUP 			0x00000001
#endif

#ifndef ESE_REGISTER_ONLINE_RESTORE
#define ESE_REGISTER_ONLINE_RESTORE 	0x00000002
#endif

#ifndef ESE_REGISTER_OFFLINE_RESTORE
#define ESE_REGISTER_OFFLINE_RESTORE 	0x00000004
#endif

#ifndef ESE_REGISTER_SNAPSHOT_BACKUP
#define ESE_REGISTER_SNAPSHOT_BACKUP 	0x00000010
#endif

// this flag will determin that the HrESEGetNodes() 
// will be solved at ESEBACK2 level (return the list of Exchange
// server from DS) not at server level using callback functions
#ifndef ESE_REGISTER_EXCHANGE_SERVER
#define ESE_REGISTER_EXCHANGE_SERVER 	0x00000100
#endif



HRESULT ESEBACK_API HrESEBackupRestoreRegister(
	IN  WCHAR *  			wszDisplayName,
	IN  unsigned long		fFlags,
	IN  WCHAR *  			wszEndpointAnnotation,
	IN  WCHAR *  			wszCallbackDll);

HRESULT ESEBACK_API HrESEBackupRestoreUnregister( void );


//  Server API for restore/recover

HRESULT ESEBACK_API HrESERecoverAfterRestore ( 
	IN	WCHAR *			wszRestoreLogPath,
	IN	WCHAR *			wszCheckpointFilePath,
	IN	WCHAR *			wszLogFilePath,
	IN	WCHAR * 		wszTargetInstanceName);

HRESULT ESEBACK_API HrESERecoverAfterRestore2 ( 
		WCHAR *			wszRestoreLogPath,
		WCHAR *			wszCheckpointFilePath,
		WCHAR *			wszLogFilePath,
		WCHAR * 		wszTargetInstanceCheckpointFilePath,
		WCHAR * 		wszTargetInstanceLogPath
		);

typedef struct _ESEBACK_CONTEXT
	{
	unsigned long 		cbSize;
	WCHAR *  			wszServerName;
	void *  			pvApplicationData;
	
	} ESEBACK_CONTEXT, * PESEBACK_CONTEXT;

//	callback function definitions for backup and restore

typedef void (ESEBACK_CALLBACK *PfnESECBFree)( 
	IN  void *				pv );


typedef ERR (ESEBACK_CALLBACK *PfnErrESECBGetDatabasesInfo)(
	IN  PESEBACK_CONTEXT			pBackupContext,
	OUT unsigned long 				* pcInfo,
	OUT INSTANCE_BACKUP_INFO	   	** prgInfo,
	IN 	unsigned long	 			fReserved
	);

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBFreeDatabasesInfo)(
	IN  PESEBACK_CONTEXT			pBackupContext,
	IN	unsigned long 				cInfo,
	IN	INSTANCE_BACKUP_INFO *		rgInfo
	);


//	callback function definitions for backup

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBPrepareInstanceForBackup)( 
	IN  PESEBACK_CONTEXT	pBackupContext,
	IN  JET_INSTANCE 		ulInstanceId,
	IN  void *				pvReserved);

#define BACKUP_DONE_FLAG_ABORT		ESE_BACKUP_INSTANCE_END_ERROR
#define BACKUP_DONE_FLAG_NORMAL 	ESE_BACKUP_INSTANCE_END_SUCCESS
				
typedef ERR (ESEBACK_CALLBACK *PfnErrESECBDoneWithInstanceForBackup)(
	IN  PESEBACK_CONTEXT	pBackupContext,
	IN  JET_INSTANCE 		ulInstanceId,
	IN  unsigned long		fComplete,
	IN  void *				pvReserved );
				
typedef ERR (ESEBACK_CALLBACK *PfnErrESECBGetDependencyInfo)(
	IN  PESEBACK_CONTEXT	pBackupContext,
	IN  JET_INSTANCE 		ulInstanceId,
	OUT void **				pvInfo,
	OUT unsigned long *		pcbInfo,
	OUT WCHAR ** 			pwszAnnotations,
	IN  void *				pvReserved );




//	callback function definitions for restore

#define RESTORE_OPEN_REOPEN 	0x0001L
#define RESTORE_OPEN_GET_PATH 	0x0002L

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBRestoreOpen)(
	IN  PESEBACK_CONTEXT	pRestoreContext,
	IN  unsigned long		fFlags,
	IN  WCHAR *				wszSrcInstanceName,
	OUT WCHAR **			pwszRestorePath,
	IN  void *				pvReserved );

#define RESTORE_CLOSE_FLAG_NORMAL 						0x0001L
#define RESTORE_CLOSE_FLAG_ABORT						0x0002L
#define RESTORE_CLOSE_FLAG_RPC							0x0004L
#define RESTORE_CLOSE_FLAG_COMPLETE_CALLED 				0x0008L

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBRestoreClose)(
	IN  PESEBACK_CONTEXT	pRestoreContext,
	IN 	unsigned long		fFlags,
	IN  void *				pvReserved );

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBRestoreGetDestination)(
	IN  PESEBACK_CONTEXT	pRestoreContext,
	IN  WCHAR *				wszDatabaseDisplayName,
	IN  GUID				guidDatabase,
	IN  WCHAR *				wszDatabaseFileNameS,
	IN  WCHAR *				wszDatabaseSLVFileNameS,
	OUT WCHAR **			pwszDatabaseFileNameD,
	OUT WCHAR **			pwszDatabaseSLVFileNameD,
	IN  void *				pvReserved );

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBRestoreComplete)(
	IN  PESEBACK_CONTEXT	pRestoreContext,
	IN  WCHAR *				wszRestorePath,
	IN 	unsigned long		fFlags,
	IN  void *				pvReserved );

// calback functions for nodes tree

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBGetNodes)(
	IN  PESEBACK_CONTEXT	pContext,
	OUT PBACKUP_NODE_TREE *	ppBackupNodeTree,
	IN  void *				pvReserved );

typedef VOID (ESEBACK_CALLBACK *PfnESECBFreeNodes)(
	IN  PBACKUP_NODE_TREE 	pBackupNodeTree );

typedef ERR (ESEBACK_CALLBACK *PfnErrESECBGetIcons)(
	IN  PESEBACK_CONTEXT		pContext,
	OUT ESE_ICON_DESCRIPTION *	pDisplayIcon,
	OUT ESE_ICON_DESCRIPTION *	pAnnotationIcon,
	IN  void *				pvReserved );

#ifdef	__cplusplus
}
#endif
#endif	// _ESEBACK2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\eximport\ifsuser.h ===
/*++

Copyright (c) 1989 - 1998 Microsoft Corporation

Module Name:

    ifsuser.h

Abstract:

    Ifsuser is a static lib that wraps a bunch of user-mode code
    needed for using the IFS. It is not necessary to use the APIs
    in this lib for availing the IFS functionality. However, using
    it will isolate clients from changes to IFS headers / data str.

    Applications that do not want to use NtXXX APIs should include
    this header file.

    Applications that directly use NtXXX APIs only need <exifs.h>
    
Author:

    Rajeev Rajan      [RajeevR]      7-Apr-1998

Revision History:

--*/

#ifndef _IFSUSER_H_
#define _IFSUSER_H_

#ifdef	__cplusplus	
extern	"C"	{
#endif

#ifndef EXIFS_DEVICE_NAME
#define EXIFS_DEVICE_NAME

//////////////////////////////////////////////////////////////////////////////
//  The Devicename string required to access the exchange IFS device 
//	from User-Mode. Clients should use DD_EXIFS_USERMODE_DEV_NAME_U.
//////////////////////////////////////////////////////////////////////////////

// Local store Device names
#define DD_LSIFS_USERMODE_SHADOW_DEV_NAME_U	    L"\\??\\LocalStoreIfs"
#define DD_LSIFS_USERMODE_DEV_NAME_U            L"\\\\.\\LocalStoreIfs"

//
//  WARNING The next two strings must be kept in sync. Change one and you must 
//	change the other. These strings have been chosen such that they are 
//	unlikely to coincide with names of other drivers.
//
//   NOTE: These definitions MUST be synced with <exifs.h>
//
#define DD_EXIFS_USERMODE_SHADOW_DEV_NAME_U	    L"\\??\\ExchangeIfs"
#define DD_EXIFS_USERMODE_DEV_NAME_U			L"\\\\.\\ExchangeIfs"

//
//	Prefix needed before <store-name>\<root-name>
//
#define DD_EXIFS_MINIRDR_PREFIX			        L"\\;E:"

#endif // EXIFS_DEVICE_NAME

//
//	Bit flags for PR_DOTSTUFF_STATE
//
//      DOTSTUFF_STATE_HAS_BEEN_SCANNED - Has the content been scanned?
//      DOTSTUFF_STATE_NEEDS_STUFFING   - If it has been scanned does
//          it need to be dot stuffed?
#define DOTSTUFF_STATE_HAS_BEEN_SCANNED         0x1
#define DOTSTUFF_STATE_NEEDS_STUFFING           0x2

//////////////////////////////////////////////////////////////////////////////
//  LIST OF FUNCTIONS EXPORTED
//
//  INBOUND =>
//  ==========
//  1. IfsInitializeWrapper() :initializes a seed eg GUID for unique filenames.
//  2. IfsTerminateWrapper()  :cleanup if necessary.
// *3. IfsCreateNewFileW()    :given store prefix, return a HANDLE that can be
//                             used for storing data in that store.
//  4. IfsCacheInsertFile()   :given an EA, insert filename in FH cache.
//  4. IfsMarshallHandle()    :given an IFS handle, will return context that
//                             will aid in manifesting a new HANDLE in a 
//                             different process.
// *5. IfsUnMarshallHandle()  :given context from previous function, this will
//                             manifest a new HANDLE in current process.
//                             
//  OUTBOUND =>
//  ===========
// *1. IfsCacheCreateFile()   :given an EA, get a file handle from the FH cache.
//                             if the file handle is not in FH cache, it will be
//                             created and inserted in FH cache.
// *2. IfsCreateFile()        :given an EA, merely create a file handle -
//                             no FH cache insert/search.
// *3. IfsCreateFileRelative():given an EA, merely create a file handle -
//                             no FH cache insert/search - relative open
//
//  *NOTE: Functions with an asterisk next to them return file HANDLES.
//  It is expected that the caller will close these handles at an appropriate time !
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  INBOUND functions
//////////////////////////////////////////////////////////////////////////////

//
//  This function sets up a seed GUID to aid generation of unique names !
//

BOOL __fastcall
IfsInitializeWrapper();

//
//  This function cleans up any state setup in Init()
//

VOID __fastcall
IfsTerminateWrapper();

//
//  Create a new IFS handle given a store prefix -
//  The handle is opened for read/write. Caller should close 
//  handle after use. Closing the handle without committing the
//  bytes (via NtQueryEa) will cause the bytes to be reused by IFS.
//
//  NB: A fully qualified IFS filename is of the form:
//  "\\??\\ExchangeIfs\\;E:\\<store-name>\\<root-name>\\<filename>"
//  Typically, <store-name> is a constant for the machine, 
//             <root-name> is a function of a given MDB store and
//             <filename> is a specific message in the store
//
//  This functions expects the StorePrefix to be <store-name>\\<root-name>.
//  The function will generate a unique <filename>
//

DWORD __fastcall
IfsCreateNewFileW(
    IN      LPWSTR   StorePrefix,
    IN      DWORD    FlagsOverride,
    IN OUT  PHANDLE  phFile
    );

#ifdef _USE_FHCACHE_

//
//  Protocols should call this function to get an FIO_CONTEXT for
//  an inbound message. This replaces IfsCreateNewFileW() as the
//  preferred method of using the IFS/File Handle Cache.
//
FIO_CONTEXT*
IfsCreateInboundMessageFile(
    IN      LPWSTR  StorePrefix,
    IN      DWORD   FlagsOverride,
    IN      BOOL    fScanForDots = TRUE
);

FIO_CONTEXT*
IfsCreateInboundMessageFileEx(
    IN      LPWSTR  StorePrefix,
    IN      DWORD   FlagsOverride,
    IN      BOOL    fScanForDots = TRUE,
    IN      BOOL    fStoredWithTerminatingDot = FALSE
);

//
//  Given an FH cache FIO_CONTEXT and IFS EAs, insert file handle in
//  FH cache using filename !
//

BOOL
IfsCacheInsertFile(
    IN      FIO_CONTEXT* pContext,
    IN      PVOID        EaBuffer,
    IN      DWORD        EaLength,
    IN	    BOOL	     fKeepReference    
    );

//
//  Given an FH cache FIO_CONTEXT and IFS EAs, insert file handle in
//  FH cache using filename !
//  BINLIN - Caller of this function must ensure that EaBuffer has DotStuff state embedded!
//  This can be achieved by calling IfsMarshallStoreEA() and marshall the returned EA
//  buffer back to IIS, and use this EA buffer in IfsCacheInsertFileEx().
//

BOOL
IfsCacheInsertFileEx(
    IN      FIO_CONTEXT* pContext,
	IN		LPWSTR		 StorePrefix,
    IN      PVOID        EaBuffer,
    IN      DWORD        EaLength,
    IN	    BOOL	     fKeepReference    
    );

BOOL IfsCacheWriteFile(
    IN  PFIO_CONTEXT    pfioContext,
    IN  LPCVOID         lpBuffer,
    IN  DWORD           BytesToWrite,
    IN  FH_OVERLAPPED * lpo
    );

BOOL IfsCacheReadFile(
    IN  PFIO_CONTEXT    pfioContext,
    IN  LPCVOID         lpBuffer,
    IN  DWORD           BytesToRead,
    IN  FH_OVERLAPPED * lpo
    );   

DWORD IfsCacheGetFileSizeFromContext(
                        IN      FIO_CONTEXT*    pContext,
                        OUT     DWORD*                  pcbFileSizeHigh
                        );   

void IfsReleaseCacheContext( PFIO_CONTEXT    pContext );
    
#endif

//
//  Given an IFS handle, return context to be used by IfsUnMarshallHandle()
//  in order to manifest a handle in another process !
//  
//  fUseEA should be used to decide whether marshalling is done via EAs
//  or DuplicateHandle(). This function expects a buffer and buffer size.
//  If the function return ERROR_SUCCESS, *pcbContext == size of data
//  If the function returns ERROR_MORE_DATA, *pcbContext == size
//  expected. Caller should allocate this size and make the request again !
//

DWORD
IfsMarshallHandle(
    IN      HANDLE  hFile,              //  IFS file handle
    IN      BOOL    fUseEA,             //  If TRUE, use EA to marshall
    IN      HANDLE  hTargetProcess,     //  Handle to target process - optional
    IN OUT  PVOID   pbContext,          //  ptr to buffer for context
    IN OUT  PDWORD  pcbContext          //  IN - sizeof pbContext OUT - real size
    );

#ifdef _USE_FHCACHE_
//
//  This replaces IfsMarshallHandle() as the preferred way of marhalling
//  handles. The FIO_CONTEXT contains the IFS handle.
//
DWORD
IfsMarshallHandleEx(
    IN      FIO_CONTEXT*    pContext,   //  FH cache FIO_CONTEXT
    IN      BOOL    fUseEA,             //  If TRUE, use EA to marshall
    IN      HANDLE  hTargetProcess,     //  Handle to target process - optional
    IN OUT  PVOID   pbContext,          //  ptr to buffer for context
    IN OUT  PDWORD  pcbContext          //  IN - sizeof pbContext OUT - real size
    );
#endif

//
//  Give a context from IfsMarshallHandle(), return a handle usable in
//  current process !
//
//  Called in Store process only !
//  The HANDLE this returns will refer to an EA that has the DOT Stuff State embedded !
//

DWORD
IfsUnMarshallHandle(
    IN      LPWSTR  StorePrefix,
    IN      PVOID   pbContext,
    IN      DWORD   cbContext,
    IN OUT  PHANDLE phFile,
    OUT     PULONG  pulDotStuffState = NULL
    );
    
//////////////////////////////////////////////////////////////////////////////
//  OUTBOUND functions
//////////////////////////////////////////////////////////////////////////////

#ifdef _USE_FHCACHE_

//
//  Given an opaque EaBuffer and EaLength, return an FIO_CONTEXT from the 
//  File Handle Cache. Typically, used on outbound.
//

FIO_CONTEXT*
IfsCacheCreateFile(
    IN      LPWSTR  StorePrefix,
    IN      PVOID   EaBuffer,
    IN      DWORD   EaLength,
    IN      BOOL    fAsyncContext
    );
    
//
//  Given an opaque EaBuffer and EaLength, return an FIO_CONTEXT from the 
//  File Handle Cache. Typically, used on outbound.
//  This replaces IfsCacheCreateFile() as the preferred way to do outbound.
//  BINLIN - Caller of this function must ensure that EaBuffer has DotStuff state embedded.
//  This can be achieved by calling IfsMarshallStoreEA() and marshall the returned EA
//  buffer back to IIS, and use this EA buffer in IfsCacheInsertFileEx().
//

FIO_CONTEXT*
IfsCacheCreateFileEx(
    IN      LPWSTR  StorePrefix,
    IN      PVOID   EaBuffer,
    IN      DWORD   EaLength,
    IN      BOOL    fAsyncContext,
    IN      BOOL    fWantItStuffed
    );

#endif

//
//  Create an IFS handle given an EaBuffer and EaLength -
//  The handle is opened for read-only. EaBuffer can be freed
//  after this call. Caller should close handle after use.
//
//  NB: EaBuffer should have been obtained from a "trusted source"
//  ie. ESE or IFS.
//

DWORD
IfsCreateFileRelative(
    IN      HANDLE   hRoot,
    IN      PVOID    EaBuffer,
    IN      DWORD    EaLength,
    IN OUT  PHANDLE  phFile
    );

//
//  Create an IFS handle given an EaBuffer and EaLength -
//  The handle is opened for read-only. EaBuffer can be freed
//  after this call. Caller should close handle after use.
//
//  NB: EaBuffer should have been obtained from a "trusted source"
//  ie. ESE or IFS.
//

DWORD
IfsCreateFile(
	IN		LPWSTR	 StorePrefix,
    IN      PVOID    EaBuffer,
    IN      DWORD    EaLength,
    IN OUT  PHANDLE  phFile
    );


DWORD
IfsCreateFileEx(
	IN		LPWSTR	 StorePrefix,
	IN      PVOID    EaBuffer,
	IN      DWORD    EaLength,
	IN OUT  PHANDLE  phFile,
	IN      BOOL     fUniqueFileName,
	IN      DWORD    desiredAccess
	);

DWORD
IfsCreateFileEx2(
	IN		LPWSTR	 StorePrefix,
	IN      PVOID    EaBuffer,
	IN      DWORD    EaLength,
	IN OUT  PHANDLE  phFile,
	IN      BOOL     fUniqueFileName,
	IN      DWORD    desiredAccess,
	IN      DWORD    shareAccess,
	IN      DWORD    createDisposition  // see NT DDK
	);

#ifdef _USE_FHCACHE_
//
//  BINLIN - This function embeds the DotStuff state property into the real EA and
//  return the ptr to the new EA buffer.  Used only during outbound and before marshalling
//  EA back to IIS for TransmitFile(), normally in the Store process.
//  Here is the call sequence:
//  1) IIS request outbound message from Store
//  2) Store driver calls EcGetProp() on PR_DOTSTUFF_STATE to get DotStuff state property
//  3) Store driver calls EcGetFileHandleProp() to get real EA.
//  4) IF EA is returned, Store driver calls IfsMarshallStoreEA() and obtain a new EA buffer
//     in pbMarshallEA, and marshall that to IIS.
//  5) IF HANDLE is returned, Store driver may call IfsMarshallHandle() to obtain EA.
//     It then MUST CALL IfsMarshallStoreEA() to obtain new EA buffer pbMarshallEA.
//  In general, if EA is obtained from Store or through IfsMarshallHandle(), the returned
//  EA is not marshall-able until Store driver calls this function with DotStuff state to
//  obtain a new EA buffer.  Only marshall this new EA buffer to IIS, not the EA returned from Store!!!
//
//  General rule of marshalling EA with DotStuff state - EA buffer marshall back and forth
//  between IIS/Store always contain DotStuff state!
//  
//  NOTE:
//  1) Passing in 0 (or use default) for DotStuff state if one doesn't exist/available.
//  2) Caller must allocate memory for pbMarshallEA, and must be at least *pcbEA+sizeof(ulDotStuffState).
//  3) It's ok to pass in same buffer ptr for pbStoreEA and pbMarshallEA, as long as 2) is true.
//
DWORD
IfsMarshallStoreEA(
    IN      PVOID   pbStoreEA,          //  ptr to buffer for EA returned from Store
    IN OUT  PDWORD  pcbEA,              //  IN - sizeof pbStoreEA OUT - sizeof pbMarshallEA
    OUT     PVOID   pbMarshallEA,       //  ptr to buffer for new EA ready for marshall
    IN      ULONG   ulDotStuffState = 0 //  Dotstuff state combined into pbMarshallEA with pbStoreEA
    );
#endif

//////////////////////////////////////////////////////////////////////////////
//  UTILITY functions - not meant to be used by clients of ifsuser.lib
//////////////////////////////////////////////////////////////////////////////

//
//  Get filename from handle
//

DWORD
IfsGetFilenameFromHandle(
    IN      HANDLE  hFile,
    IN OUT  LPSTR   lpstrFilename
    );
    
//
//  Get filename from EA
//

VOID
IfsGetFilenameFromEaW(
    IN      PVOID 	EaBuffer,
    IN OUT	LPWSTR*	ppwstrFilename
    );
    
//
//  Open a file with no EA
//

DWORD
IfsOpenFileNoEa(
	IN      LPWSTR lpwstrName,
    IN  OUT PHANDLE  phFile
    );

#ifdef NT_INCLUDED
//
//  This is the function used by the I/O manager to check EA buffer
//  validity. This can be used to debug EA_LIST_INCONSISTENT errors.
//

DWORD
CheckEaBufferValidity(
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    OUT PULONG ErrorOffset
    );
#endif

#ifdef	__cplusplus	
}
#endif

#endif // _IFSUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\export\jet.h ===
#if _MSC_VER > 1000
#pragma once
#endif

#define eseVersion 0x5600
//	HISTORY:
//		0x5500	- ESE97 (Exchange 5.5)
//		0x5580	- ESENT97 (W2k)
//		0x5600	- ESENT98 (Whistler)
//		0x6000	- ESE98 (Exchange 2000)


#if !defined(_JET_INCLUDED)
#define _JET_INCLUDED

#ifdef	__cplusplus
extern "C" {
#endif

#define JET_cbPage	4096			//	UNDONE: Remove when no more components reference this.

#if defined(_M_AMD64) || defined(_M_IA64)
#include <pshpack8.h>
#else
#include <pshpack4.h>
#endif

#define JET_API     __stdcall
#define JET_NODSAPI __stdcall

#ifdef _WIN64
    typedef unsigned __int64 JET_API_PTR;
#else
    typedef unsigned long JET_API_PTR;
#endif


typedef long JET_ERR;

typedef JET_API_PTR JET_HANDLE;	/* backup file handle */
typedef JET_API_PTR JET_INSTANCE;	/* Instance Identifier */
typedef JET_API_PTR JET_SESID;  	/* Session Identifier */
typedef JET_API_PTR JET_TABLEID;	/* Table Identifier */
typedef JET_API_PTR JET_LS;		/* Local Storage */

typedef unsigned long JET_COLUMNID;	/* Column Identifier */

typedef struct tagJET_INDEXID
	{
	unsigned long	cbStruct;
	unsigned char	rgbIndexId[sizeof(JET_API_PTR)+sizeof(unsigned long)+sizeof(unsigned long)];
	} JET_INDEXID;

typedef unsigned long JET_DBID;   	/* Database Identifier */
typedef unsigned long JET_OBJTYP;	/* Object Type */
typedef unsigned long JET_COLTYP;	/* Column Type */
typedef unsigned long JET_GRBIT;  	/* Group of Bits */

typedef unsigned long JET_SNP;		/* Status Notification Process */
typedef unsigned long JET_SNT;		/* Status Notification Type */
typedef unsigned long JET_SNC;		/* Status Notification Code */
typedef double JET_DATESERIAL;		/* JET_coltypDateTime format */
typedef unsigned long JET_DLLID;      /* ID of DLL for hook functions */
typedef unsigned long JET_CBTYP;	/* Callback Types */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void *pv);

/*	required for Exchange to make RSTMAP RPC capable
/**/
#ifdef	MIDL_PASS
#define	xRPC_STRING [string]
#else
#define	xRPC_STRING
#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#else
typedef wchar_t WCHAR;
#endif
#endif

typedef struct
	{
	xRPC_STRING char		*szDatabaseName;
	xRPC_STRING char		*szNewDatabaseName;
	} JET_RSTMAP;			/* restore map */

/*	required for Exchange unicode support
/**/
#define	UNICODE_RSTMAP

typedef struct tagJET_RSTMAPW {
	xRPC_STRING WCHAR *wszDatabaseName;
	xRPC_STRING WCHAR *wszNewDatabaseName;
	} JET_RSTMAPW, *PJET_RSTMAPW;


//	For edbutil convert only.

typedef struct tagCONVERT
	{
	char					*szOldDll;
	union
		{
		unsigned long		fFlags;
		struct
			{
			unsigned long	fSchemaChangesOnly:1;
			};
		};
	} JET_CONVERT;

typedef enum
	{

	//	Database operations

	opDBUTILConsistency,
	opDBUTILDumpData,
	opDBUTILDumpMetaData,
	opDBUTILDumpPage,
	opDBUTILDumpNode,
	opDBUTILDumpSpace,
 	opDBUTILSetHeaderState,
	opDBUTILDumpHeader,
	opDBUTILDumpLogfile,
	opDBUTILDumpLogfileTrackNode,
	opDBUTILDumpCheckpoint,
	opDBUTILEDBDump,
	opDBUTILEDBRepair,
	opDBUTILMunge,
	opDBUTILEDBScrub,
	opDBUTILSLVMove,
	opDBUTILDBConvertRecords,
	opDBUTILDBDefragment,
	opDBUTILDumpExchangeSLVInfo,
	} DBUTIL_OP;

typedef enum
	{
	opEDBDumpTables,
	opEDBDumpIndexes,
	opEDBDumpColumns,
	opEDBDumpCallbacks,
	opEDBDumpPage,
	} EDBDUMP_OP;

typedef struct tagDBUTIL
	{
	unsigned long	cbStruct;

	JET_SESID	sesid;
	JET_DBID	dbid;
	JET_TABLEID	tableid;

	DBUTIL_OP	op;
	EDBDUMP_OP	edbdump;
	JET_GRBIT	grbitOptions;

	char		*szDatabase;
	char		*szSLV;
	char		*szBackup;
	char		*szTable;
	char		*szIndex;
	char		*szIntegPrefix;

	long	pgno;
	long	iline;
	
	long	lGeneration;
	long	isec;
	long	ib;

	long	cRetry;
	
	void *		pfnCallback;
	void *		pvCallback;
	
	} JET_DBUTIL;	

#define JET_bitDBUtilOptionAllNodes				0x00000001
#define JET_bitDBUtilOptionKeyStats				0x00000002
#define JET_bitDBUtilOptionPageDump				0x00000004
#define JET_bitDBUtilOptionDumpVerbose			0x10000000	// DEBUG only
#define JET_bitDBUtilOptionCheckBTree			0x20000000	// DEBUG only
#define JET_bitDBUtilOptionStats				0x00000008

#define JET_bitDBUtilOptionVerbose				0x00000010
#define JET_bitDBUtilOptionIgnoreErrors			0x00000020
#define JET_bitDBUtilOptionVerify				0x00000040
#define JET_bitDBUtilOptionReportErrors			0x00000080
#define JET_bitDBUtilOptionDontRepair			0x00000100
#define JET_bitDBUtilOptionRepairAll			0x00000200
#define JET_bitDBUtilOptionRepairIndexes		0x00000400
#define JET_bitDBUtilOptionDontBuildIndexes		0x00000800



//	Online defragmentation options
#define JET_bitDefragmentBatchStart				0x00000001
#define JET_bitDefragmentBatchStop				0x00000002
#define JET_bitDefragmentTest					0x00000004	/* run internal tests (non-RTM builds only) */
#define JET_bitDefragmentSLVBatchStart			0x00000008
#define JET_bitDefragmentSLVBatchStop			0x00000010
#define JET_bitDefragmentScrubSLV				0x00000020	/* syncronously zero free pages in the streaming file */
#define JET_bitDefragmentAvailSpaceTreesOnly	0x00000040	/* only defrag AvailExt trees */

	/* Callback-function types */

#define	JET_cbtypNull							0x00000000
#define JET_cbtypFinalize						0x00000001	/* a finalizable column has gone to zero */
#define JET_cbtypBeforeInsert					0x00000002	/* about to insert a record */
#define JET_cbtypAfterInsert					0x00000004	/* finished inserting a record */
#define JET_cbtypBeforeReplace					0x00000008	/* about to modify a record */
#define JET_cbtypAfterReplace					0x00000010	/* finished modifying a record */
#define JET_cbtypBeforeDelete					0x00000020	/* about to delete a record */
#define JET_cbtypAfterDelete					0x00000040	/* finished deleting the record */
#define JET_cbtypUserDefinedDefaultValue		0x00000080	/* calculating a user-defined default */
#define JET_cbtypOnlineDefragCompleted			0x00000100	/* a call to JetDefragment2 has completed */
#define JET_cbtypFreeCursorLS					0x00000200	/* the Local Storage associated with a cursor must be freed */
#define JET_cbtypFreeTableLS					0x00000400	/* the Local Storage associated with a table must be freed */
#define JET_cbtypDTCQueryPreparedTransaction	0x00001000	/* recovery is attempting to resolve a PreparedToCommit transaction */
#define JET_cbtypOnlineDefragProgress			0x00002000	/* online defragmentation has made progress */

	/* Callback-function prototype */

typedef JET_ERR (__stdcall *JET_CALLBACK)(
	JET_SESID 		sesid,
	JET_DBID 		dbid,
	JET_TABLEID 	tableid,
	JET_CBTYP 		cbtyp,
	void *			pvArg1,
	void *			pvArg2,
	void *			pvContext,
	JET_API_PTR		ulUnused );

	/*	Session information bits */

#define JET_bitCIMCommitted					 	0x00000001
#define JET_bitCIMDirty	 					 	0x00000002
#define JET_bitAggregateTransaction		  		0x00000008

	/* Status Notification Structures */

typedef struct				/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cunitDone;	/* Number of units of work completed */
	unsigned long	cunitTotal;	/* Total number of units of work */
	} JET_SNPROG;

typedef struct				/* Status Notification Message */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_SNC  		snc;	  	/* Status Notification Code */
	unsigned long	ul;			/* Numeric identifier */
	char	 		sz[256];  	/* Identifier */
	} JET_SNMSG;


typedef struct
	{
	unsigned long			cbStruct;
	
	unsigned long			cbFilesizeLow;			//	file's current size (low DWORD)
	unsigned long			cbFilesizeHigh;			//	file's current size (high DWORD)
	
	unsigned long			cbFreeSpaceRequiredLow;	//	estimate of free disk space required for in-place upgrade (low DWORD)
	unsigned long			cbFreeSpaceRequiredHigh;//	estimate of free disk space required for in-place upgrade (high DWORD)
	
	unsigned long			csecToUpgrade;			//	estimate of time required, in seconds, for upgrade
	
	union
		{
		unsigned long		ulFlags;
		struct
			{
			unsigned long	fUpgradable:1;
			unsigned long	fAlreadyUpgraded:1;
			};
		};
	} JET_DBINFOUPGRADE;
	

typedef struct
	{
	unsigned long		cbStruct;
	JET_OBJTYP			objtyp;
	JET_DATESERIAL		dtCreate;	//  XXX -- to be deleted
	JET_DATESERIAL		dtUpdate;	//  XXX -- to be deleted
	JET_GRBIT			grbit;
	unsigned long		flags;
	unsigned long		cRecord;
	unsigned long		cPage;
	} JET_OBJECTINFO;

	/* The following flags appear in the grbit field above */

#define JET_bitTableInfoUpdatable	0x00000001
#define JET_bitTableInfoBookmark	0x00000002
#define JET_bitTableInfoRollback	0x00000004
#define JET_bitTableSequential		0x00008000

	/* The following flags occur in the flags field above */

#define JET_bitObjectSystem			0x80000000	// Internal use only
#define JET_bitObjectTableFixedDDL	0x40000000	// Table's DDL is fixed
#define JET_bitObjectTableTemplate	0x20000000	// Table's DDL is inheritable (implies FixedDDL)
#define JET_bitObjectTableDerived	0x10000000	// Table's DDL is inherited from a template table
#define JET_bitObjectSystemDynamic	(JET_bitObjectSystem|0x08000000)	//	Internal use only (dynamic system objects)
#define JET_bitObjectTableNoFixedVarColumnsInDerivedTables	0x04000000	//	used in conjunction with JET_bitObjectTableTemplate
																		//	to disallow fixed/var columns in derived tables (so that
																		//	fixed/var columns may be added to the template in the future)


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidcontainername;
	JET_COLUMNID	columnidobjectname;
	JET_COLUMNID	columnidobjtyp;
	JET_COLUMNID	columniddtCreate;	//  XXX -- to be deleted
	JET_COLUMNID	columniddtUpdate;	//  XXX -- to be deleted
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidflags;
	JET_COLUMNID	columnidcRecord;	/* Level 2 info */
	JET_COLUMNID	columnidcPage;		/* Level 2 info */
	} JET_OBJECTLIST;

#define cObjectInfoCols 9

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidPresentationOrder;
	JET_COLUMNID	columnidcolumnname;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidcbMax;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidDefault;
	JET_COLUMNID	columnidBaseTableName;
	JET_COLUMNID	columnidBaseColumnName;
	JET_COLUMNID	columnidDefinitionName;
	} JET_COLUMNLIST;

#define cColumnInfoCols 14

typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wCollate;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT		grbit;
	} JET_COLUMNDEF;


typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wFiller;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT		grbit;
	char			szBaseTableName[256];
	char			szBaseColumnName[256];
	} JET_COLUMNBASE;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidindexname;
	JET_COLUMNID	columnidgrbitIndex;
	JET_COLUMNID	columnidcKey;
	JET_COLUMNID	columnidcEntry;
	JET_COLUMNID	columnidcPage;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidgrbitColumn;
	JET_COLUMNID	columnidcolumnname;
	JET_COLUMNID	columnidLCMapFlags;
	} JET_INDEXLIST;


#define cIndexInfoCols 15

typedef struct tag_JET_COLUMNCREATE
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char			*szColumnName;			// column name
	JET_COLTYP		coltyp;					// column type
	unsigned long	cbMax;					// the maximum length of this column (only relevant for binary and text columns)
	JET_GRBIT		grbit;					// column options
	void			*pvDefault;				// default value (NULL if none)
	unsigned long	cbDefault;				// length of default value
	unsigned long	cp;						// code page (for text columns only)
	JET_COLUMNID	columnid;				// returned column id
	JET_ERR			err;					// returned error code
	} JET_COLUMNCREATE;

//  This is the information needed to create a column with a user-defined default. It should be passed in using
//  the pvDefault and cbDefault in a JET_COLUMNCREATE structure
typedef struct tag_JET_USERDEFINEDDEFAULT
	{
	char * szCallback;
	unsigned char * pbUserData;
	unsigned long cbUserData;
	char * szDependantColumns;
	} JET_USERDEFINEDDEFAULT;

typedef struct tagJET_INDEXCREATEOLD		// [4/15/97]: to be phased out eventually (laurionb)
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char			*szIndexName;			// index name
	char			*szKey;					// index key
	unsigned long	cbKey;					// length of key
	JET_GRBIT		grbit;					// index options
	unsigned long	ulDensity;				// index density
	JET_ERR			err;					// returned error code
	} JET_INDEXCREATEOLD;


typedef struct tagJET_CONDITIONALCOLUMN
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char 			*szColumnName;			// column that we are conditionally indexed on
	JET_GRBIT		grbit;					// conditional column options
	} JET_CONDITIONALCOLUMN;

	
typedef struct tagJET_UNICODEINDEX
	{
	unsigned long	lcid;
	unsigned long	dwMapFlags;
	} JET_UNICODEINDEX;

typedef struct tagJET_INDEXCREATE
	{
	unsigned long			cbStruct;				// size of this structure (for future expansion)
	char					*szIndexName;			// index name
	char					*szKey;					// index key
	unsigned long			cbKey;					// length of key
	JET_GRBIT				grbit;					// index options
	unsigned long			ulDensity;				// index density

	union
		{
		unsigned long		lcid;					// lcid for the index (if JET_bitIndexUnicode NOT specified)
		JET_UNICODEINDEX	*pidxunicode;			// pointer to JET_UNICODEINDEX struct (if JET_bitIndexUnicode specified)
		};

	unsigned long			cbVarSegMac;			// maximum length of variable length columns in index key

	JET_CONDITIONALCOLUMN	*rgconditionalcolumn;	// pointer to conditional column structure
	unsigned long			cConditionalColumn;		// number of conditional columns
	JET_ERR					err;					// returned error code
	} JET_INDEXCREATE;


typedef struct tagJET_TABLECREATE
	{
	unsigned long		cbStruct;				// size of this structure (for future expansion)
	char				*szTableName;			// name of table to create.
	char				*szTemplateTableName;	// name of table from which to inherit base DDL
	unsigned long		ulPages;				// initial pages to allocate for table.
	unsigned long		ulDensity;				// table density.
	JET_COLUMNCREATE	*rgcolumncreate;		// array of column creation info
	unsigned long		cColumns;				// number of columns to create
	JET_INDEXCREATE		*rgindexcreate;			// array of index creation info
	unsigned long		cIndexes;				// number of indexes to create
	JET_GRBIT			grbit;
	JET_TABLEID			tableid;				// returned tableid.
	unsigned long		cCreated;				// count of objects created (columns+table+indexes).
	} JET_TABLECREATE;

typedef struct tagJET_TABLECREATE2
	{
	unsigned long		cbStruct;				// size of this structure (for future expansion)
	char				*szTableName;			// name of table to create.
	char				*szTemplateTableName;	// name of table from which to inherit base DDL
	unsigned long		ulPages;				// initial pages to allocate for table.
	unsigned long		ulDensity;				// table density.
	JET_COLUMNCREATE	*rgcolumncreate;		// array of column creation info
	unsigned long		cColumns;				// number of columns to create
	JET_INDEXCREATE		*rgindexcreate;			// array of index creation info
	unsigned long		cIndexes;				// number of indexes to create
	char				*szCallback;			// callback to use for this table
	JET_CBTYP			cbtyp;					// when the callback should be called
	JET_GRBIT			grbit;
	JET_TABLEID			tableid;				// returned tableid.
	unsigned long		cCreated;				// count of objects created (columns+table+indexes+callbacks).
	} JET_TABLECREATE2;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	JET_COLUMNID	columnidNextTagged;
	} JET_RETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	} JET_SETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	centriesLT;
	unsigned long	centriesInRange;
	unsigned long	centriesTotal;
	} JET_RECPOS;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidBookmark;
	} JET_RECORDLIST;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	JET_GRBIT		grbit;
	} JET_INDEXRANGE;

//  for database DDL conversion

typedef enum
	{
	opDDLConvNull,
	opDDLConvAddCallback,
	opDDLConvChangeColumn,
	opDDLConvAddConditionalColumnsToAllIndexes,
	opDDLConvAddColumnCallback,
	opDDLConvIncreaseMaxColumnSize,
	opDDLConvMax
	} JET_OPDDLCONV;

typedef struct tagDDLADDCALLBACK
	{
	char		*szTable;
	char		*szCallback;
	JET_CBTYP	cbtyp;
	} JET_DDLADDCALLBACK;

typedef struct tagDDLCHANGECOLUMN
	{
	char		*szTable;
	char		*szColumn;
	JET_COLTYP	coltypNew;
	JET_GRBIT	grbitNew;
	} JET_DDLCHANGECOLUMN;

typedef struct tagDDLMAXCOLUMNSIZE
	{
	char			*szTable;
	char			*szColumn;
	unsigned long	cbMax;
	} JET_DDLMAXCOLUMNSIZE;

typedef struct tagDDLADDCONDITIONALCOLUMNSTOALLINDEXES
	{
	char					* szTable;					// name of table to convert
	JET_CONDITIONALCOLUMN 	* rgconditionalcolumn;		// pointer to conditional column structure
	unsigned long			cConditionalColumn;			// number of conditional columns
	} JET_DDLADDCONDITIONALCOLUMNSTOALLINDEXES;

typedef struct tagDDLADDCOLUMCALLBACK
	{
	char			*szTable;
	char			*szColumn;
	char			*szCallback;
	void			*pvCallbackData;
	unsigned long	cbCallbackData;
	} JET_DDLADDCOLUMNCALLBACK;

//	The caller need to setup JET_OLP with a signal wait for the signal to be set.

typedef struct {
	void	*pvReserved1;		// internally use
	void	*pvReserved2;
	unsigned long cbActual;		// the actual number of bytes read through this IO
	JET_HANDLE	hSig;			// a manual reset signal to wait for the IO to complete.
	JET_ERR		err;				// Err code for this assync IO.
	} JET_OLP;
	

#include <pshpack1.h>
#define JET_MAX_COMPUTERNAME_LENGTH 15

typedef struct	{
	char		bSeconds;				//	0 - 60
	char		bMinutes;				//	0 - 60
	char		bHours;					//	0 - 24
	char		bDay;					//	1 - 31
	char		bMonth;					//	0 - 11
	char		bYear;					//	current year - 1900
	char		bFiller1;
	char		bFiller2;
	} JET_LOGTIME;

typedef struct
	{
	unsigned short	ib;				// must be the last so that lgpos can
	unsigned short	isec;			// index of disksec starting logsec
	long 			lGeneration;	// generation of logsec
	} JET_LGPOS;					// be casted to TIME.

typedef struct
	{
	unsigned long	ulRandom;			//	a random number
	JET_LOGTIME		logtimeCreate;		//	time db created, in logtime format
	char			szComputerName[ JET_MAX_COMPUTERNAME_LENGTH + 1 ];	// where db is created
	} JET_SIGNATURE;

typedef struct
	{
	JET_LGPOS		lgposMark;			//	id for this backup
	JET_LOGTIME		logtimeMark;
	unsigned long	genLow;
	unsigned long	genHigh;
	} JET_BKINFO;
	
#include <poppack.h>

typedef struct {
	unsigned long	ulVersion;		//	version of DAE the db created (see ulDAEVersion)
	unsigned long	ulUpdate;			//	used to track incremental database format updates that
										//	are backward-compatible (see ulDAEUpdate)
	JET_SIGNATURE	signDb;			//	(28 bytes) signature of the db (incl. creation time).	
	unsigned long	dbstate;		//	consistent/inconsistent state				
	
	JET_LGPOS		lgposConsistent;	//	null if in inconsistent state				
	JET_LOGTIME		logtimeConsistent;	// null if in inconsistent state				

	JET_LOGTIME		logtimeAttach;	//	Last attach time.							
	JET_LGPOS		lgposAttach;

	JET_LOGTIME		logtimeDetach;	//	Last detach time.							
 	JET_LGPOS		lgposDetach;

	JET_SIGNATURE	signLog;		//	(28 bytes) log signature for this attachments			

	JET_BKINFO		bkinfoFullPrev;	//	Last successful full backup.				

	JET_BKINFO		bkinfoIncPrev;	//	Last successful Incremental backup.			
									//	Reset when bkinfoFullPrev is set			
	JET_BKINFO		bkinfoFullCur;	//	current backup. Succeed if a				
									//	corresponding pat file generated.
	unsigned long	fShadowingDisabled;
	unsigned long	fUpgradeDb;

	//	NT version information. This is needed to decide if an index need
	//	be recreated due to sort table changes.

	unsigned long	dwMajorVersion;		/*	OS version info								*/
	unsigned long	dwMinorVersion;
	unsigned long	dwBuildNumber;
	long			lSPNumber;

	unsigned long	cbPageSize;			//	database page size (0 = 4k pages)

	} JET_DBINFOMISC;


typedef struct {

	unsigned long	cpageOwned;		//	number of owned pages in the streaming file
	unsigned long	cpageAvail;		//	number of available pages in the streaming file (subset of cpageOwned)

	} JET_STREAMINGFILESPACEINFO;



//typedef struct
//	{
//	unsigned long	cDiscont;
//	unsigned long	cUnfixedMessyPage;
//	unsigned long	centriesLT;
//	unsigned long	centriesTotal;
//	unsigned long	cpgCompactFreed;
//	} JET_OLCSTAT;

/************************************************************************/
/*************************     JET CONSTANTS	 ************************/
/************************************************************************/

#define JET_tableidNil				(~(JET_TABLEID)0)

#define	JET_sesidNil				(~(JET_SESID)0)

#define	JET_instanceNil				(~(JET_INSTANCE)0)

	/* Max size of a bookmark */

#define JET_cbBookmarkMost			256

	/* Max length of a object/column/index/property name */

#define JET_cbNameMost				64

	/* Max length of a "name.name.name..." construct */

#define JET_cbFullNameMost			255

	/* Max size of long-value (LongBinary or LongText) column chunk */

//	#define JET_cbColumnLVChunkMost		( JET_cbPage - 82 ) to the following:
//	Get cbPage from GetSystemParameter.
// 	changed JET_cbColumnLVChunkMOst reference to cbPage - JET_cbColumnLVPageOverhead

#define JET_cbColumnLVPageOverhead	82
#define JET_cbColumnLVChunkMost		( 4096 - 82 ) // This def will be removed after other components change not to use this def
#define JET_cbColumnLVChunkMost_OLD	4035

	/* Max size of long-value (LongBinary or LongText) column default value */

#define JET_cbLVDefaultValueMost	255

	/* Max size of non-long-value column data */

#define JET_cbColumnMost			255

	/* Max size of a sort/index key */

#define JET_cbKeyMost				255
#define JET_cbLimitKeyMost			256				//	maximum key size when key is formed using a Limit grbit (eg. JET_bitStrLimit)
#define JET_cbPrimaryKeyMost		255
#define JET_cbSecondaryKeyMost		255
#define JET_cbKeyMost_OLD			255

	/* Max number of components in a sort/index key */

#define JET_ccolKeyMost				12

//	maximum number of columns
#define JET_ccolMost				0x0000fee0
#define JET_ccolFixedMost			0x0000007f
#define JET_ccolVarMost				0x00000080
#define JET_ccolTaggedMost			( JET_ccolMost - 0x000000ff )

//  event logging level (only on and off for now - will add more in the future)
#define JET_EventLoggingDisable		0
#define JET_EventLoggingLevelMax	100

//	system paramters
//
//	location parameters
//
#define JET_paramSystemPath						0	//	path to check point file [".\\"]
#define JET_paramTempPath						1	//	path to the temporary database [".\\"]
#define JET_paramLogFilePath 					2	//	path to the log file directory [".\\"]
#define JET_paramBaseName						3	//	base name for all DBMS object names ["edb"]
#define JET_paramEventSource					4	//	language independent process descriptor string [""]

//	performance parameters
//
#define JET_paramMaxSessions					5	//	maximum number of sessions [16]
#define JET_paramMaxOpenTables  				6	//	maximum number of open directories [300]
													//  	need 1 for each open table index,
													//  	plus 1 for each open table with no indexes,
													//  	plus 1 for each table with long column data,
													//  	plus a few more.
													//		for 4.1, 1/3 for regular table, 2/3 for index
#define JET_paramPreferredMaxOpenTables			7	//	preferred maximum number of open directories [300]
#define JET_paramMaxCursors						8	//	maximum number of open cursors [1024]
#define JET_paramMaxVerPages					9	//	maximum version store size in 16kByte units [64]
#define JET_paramPreferredVerPages				63	//	preferred version store size in 16kByte units [64 * 0.9]
#define JET_paramGlobalMinVerPages				81	//	minimum version store size for all instances in 16kByte units [64]
#define JET_paramVersionStoreTaskQueueMax		105	//	maximum number of tasks in the task queue before start dropping the tasks [32]
#define JET_paramMaxTemporaryTables				10	//	maximum concurrent open temporary table/index creation [20]
#define JET_paramLogFileSize					11	//	log file size in kBytes [5120]
#define JET_paramLogBuffers						12	//	log buffers in 512 bytes [80]
#define JET_paramWaitLogFlush					13	//	log flush wait time in milliseconds [0] DEFUNCT
#define JET_paramLogCheckpointPeriod			14	//	checkpoint period in 512 bytes [1024] DEFUNCT
#define JET_paramLogWaitingUserMax				15	//	maximum sessions waiting log flush [3] DEFUNCT
#define JET_paramCommitDefault					16	//	default grbit for JetCommitTransaction [0]
#define JET_paramCircularLog					17	//	boolean flag for circular logging [0]
#define JET_paramDbExtensionSize				18	//	database extension size in pages [256] DEFUNCT
#define JET_paramPageTempDBMin					19  //	minimum size temporary database in pages [0] DEFUNCT
#define JET_paramPageFragment					20	//	maximum disk extent considered fragment in pages [8] DEFUNCT
#define JET_paramPageReadAheadMax				21	//	maximum read-ahead in pages [20] DEFUNCT

//  cache performance parameters
//
#define JET_paramBatchIOBufferMax				22	//	maximum batch I/O buffers in pages [64] DEFUNCT
#define JET_paramCacheSize						41	//	current cache size in pages [512]
#define JET_paramCacheSizeMin					60	//	minimum cache size in pages [64]
#define JET_paramCacheSizeMax					23	//	maximum cache size in pages [512]
#define JET_paramCheckpointDepthMax				24	//	maximum checkpoint depth in bytes [20MB]
#define JET_paramLRUKCorrInterval				25  //	time (usec) under which page accesses are correlated [128000], it was 10000
#define JET_paramLRUKHistoryMax					26  //	maximum LRUK history records [1024] (proportional to cache size max) DEFUNCT
#define JET_paramLRUKPolicy						27  //	K-ness of LRUK page eviction algorithm (1...2) [2]
#define JET_paramLRUKTimeout					28  //	time (sec) after which cached pages are always evictable [100]
#define JET_paramLRUKTrxCorrInterval			29  //	Not Used: time (usec) under which page accesses by the same transaction are correlated [5000000] DEFUNCT
#define JET_paramOutstandingIOMax				30	//	maximum outstanding I/Os [64] DEFUNCT
#define JET_paramStartFlushThreshold			31	//	evictable pages at which to start a flush [100] (proportional to CacheSizeMax)
#define JET_paramStopFlushThreshold				32	//	evictable pages at which to stop a flush [400] (proportional to CacheSizeMax)
#define JET_paramTableClassName					33  //	table stats class name (class #, string)
#define JET_paramIdleFlushTime					106 //  time interval (msec) over which all dirty pages should be written to disk after idle conditions are detected.  [0]
#define JET_paramVAReserve						109 //  amount of address space (bytes) to reserve from use by the cache [0]

//	debug only parameters
//
#define JET_paramRecovery						34	//	enable recovery [-1]
#define JET_paramOnLineCompact					35	//	enable online defrag [TRUE by default]
#define JET_paramEnableOnlineDefrag				35	//	enable online defrag [TRUE by default]
#define JET_paramAssertAction					36	//	action on assert
#define	JET_paramPrintFunction					37	//	synched print function [NULL]
#define JET_paramTransactionLevel				38	//	transaction level of session
#define JET_paramRFS2IOsPermitted				39  //	#IOs permitted to succeed [-1 = all]
#define JET_paramRFS2AllocsPermitted			40  //	#allocs permitted to success [-1 = all]
//												41	//	JET_paramCacheSize defined above
#define JET_paramCacheRequests					42  //	#cache requests (Read Only)
#define JET_paramCacheHits						43  //	#cache hits (Read Only)

//	Application specific parameter
//
#define JET_paramCheckFormatWhenOpenFail		44	//	JetInit may return JET_errDatabaseXXXformat instead of database corrupt when it is set
#define JET_paramEnableIndexChecking			45  //	Enable checking OS version for indexes (FALSE by default)
#define JET_paramEnableTempTableVersioning		46	//	Enable versioning of temp tables (TRUE by default)
#define JET_paramIgnoreLogVersion				47	//	Do not check the log version
#define JET_paramDeleteOldLogs					48	//	Delete the log files if the version is old, after deleting may make database non-recoverable
#define JET_paramEventSourceKey					49	//	Event source registration key value
#define JET_paramNoInformationEvent				50	//	Disable logging information event [ FALSE by default ]
#define JET_paramEventLoggingLevel				51	//	Set the type of information that goes to event log [ eventLoggingLevelMax by default ]
#define JET_paramDeleteOutOfRangeLogs			52	//	Delete the log files that are not matching (generation wise) during soft recovery [false]
#define JET_paramAccessDeniedRetryPeriod		53	//	Number of milliseconds to retry when about to fail with AccessDenied [10000 milliseconds]

//												60	//	JET_paramCacheSizeMin defined above
#define JET_paramLogFileFailoverPath			61	//	path to use if the log file disk should fail [none]
#define JET_paramEnableImprovedSeekShortcut		62  //	check to see if we are seeking for the record we are currently on [false]
//												63	//	JET_paramPreferredVerPages defined above
#define JET_paramDatabasePageSize				64	//	set database page size
#define JET_paramDisableCallbacks				65	//	turn off callback resolution (for defrag/repair)
#define JET_paramDisablePerfmon					107 //  disable perfmon support for this process [FALSE]
#define JET_paramAbortRetryFailCallback			108 //  I/O error callback (JET_ABORTRETRYFAILCALLBACK) [NULL]

//  Backup performance parameters
//
#define JET_paramBackupChunkSize				66  //	backup read size in pages [16]
#define JET_paramBackupOutstandingReads			67	//	backup maximum reads outstanding [8]

#define JET_paramSLVProviderEnable				68  //	Enable SLV Provider [0]
#define JET_paramLogFileCreateAsynch			69	//	prepares next log file while logging to the current one to smooth response time [true]
#define JET_paramErrorToString					70  //	turns a JET_err into a string (taken from the comment in jet.h)
#define JET_paramZeroDatabaseDuringBackup		71	//	Overwrite deleted records/LVs during backup [false]
#define JET_paramUnicodeIndexDefault			72	//	default LCMapString() lcid and flags to use for CreateIndex() and unique multi-values check
													//		(pass JET_UNICODEINDEX structure for lParam)
#define JET_paramRuntimeCallback				73	//	pointer to runtime-only callback function
#define JET_paramSLVDefragFreeThreshold	 		74	//	chunks whose free % is > this will be allocated from
#define JET_paramSLVDefragMoveThreshold			75  //	chunks whose free % is > this will be relocated
#define JET_paramEnableSortedRetrieveColumns	76	//	internally sort (in a dynamically allocated parallel array) JET_RETRIEVECOLUMN structures passed to JetRetrieveColumns()
#define JET_paramCleanupMismatchedLogFiles		77	//	instead of erroring out after a successful recovery with JET_errLogFileSizeMismatchDatabasesConsistent, ESE will silently delete the old log files and checkpoint file and continue operations
#define JET_paramRecordUpgradeDirtyLevel		78	//	how aggresively should pages with their record format converted be flushed (0-3) [1]
#define JET_paramRecoveryCurrentLogfile			79	//	which generation is currently being replayed (JetGetSystemParameter only)
#define JET_paramReplayingReplicatedLogfiles	80	//	if a logfile doesn't exist, wait for it to be created
//												81	//	JET_paramGlobalMinVerPages defined above
#define JET_paramOSSnapshotTimeout				82	//	timeout for the freeze period in msec [1000 * 20]
#define JET_paramUnicodeIndexLibrary			83	//	alternate library used for Unicode-index sorting (contains Win32 calls LCMapStringW and CompareStringW; also contains versioning API GetLCMapStringWVer)

#define JET_paramExceptionAction				98	//	what to do with exceptions generated within JET
#define JET_paramEventLogCache					99  //	number of bytes of eventlog records to cache if service is not available [0]
#define JET_paramCreatePathIfNotExist			100	//	create system/temp/log/log-failover paths if they do not exist
#define JET_paramPageHintCacheSize				101 //	maximum size of the fast page latch hint cache in bytes [256kb]
#define JET_paramOneDatabasePerSession			102	//	allow just one open user database per session [false]
#define JET_paramMaxDatabasesPerInstance		103	//	maximum number of databases per instance [6]
#define JET_paramMaxInstances					104	//	maximum number of instances per process [1 for ESENT, 16 for Exchange]
//												105	//	JET_paramVersionStoreTaskQueueMax
//												106 //	JET_paramIdleFlushTime
//												107	//	JET_paramDisablePerfmon
//												108	//	JET_paramAbortRetryFailCallback
//												109	//	JET_paramVAReserve

#define JET_paramIndexTuplesLengthMin			110	//	for tuple indexes, minimum length of a tuple [3]
#define JET_paramIndexTuplesLengthMax			111	//	for tuple indexes, maximum length of a tuple [10]
#define JET_paramIndexTuplesToIndexMax			112	//	for tuple indexes, maximum number of characters in a given string to index [32767]



//	for backward compatibility
//
#define JET_paramSysDbPath_OLD				0	/* path to the system database (defunct) ["<base name>.<base ext>"] */
#define JET_paramSystemPath_OLD				0	/* path to check point file ["."] */
#define JET_paramTempPath_OLD				1	/* path to the temporary database ["."] */
#define JET_paramMaxBuffers_OLD				8	/* maximum page cache size in pages [512] */
#define JET_paramMaxSessions_OLD			9	/* maximum number of sessions [128] */
#define JET_paramMaxOpenTables_OLD			10	/* maximum number of open tables [300] */
#define JET_paramPreferredMaxOpenTables_OLD	59	/* prefered maximum number of open tables [300] */
#define JET_paramMaxVerPages_OLD			11	/* maximum version store size in 16KB buckets [64] */
#define JET_paramMaxCursors_OLD				12	/* maximum number of open cursors [1024] */
#define JET_paramLogFilePath_OLD			13	/* path to the log file directory ["."] */
#define JET_paramMaxOpenTableIndexes_OLD 	14	/* maximum open table indexes [300] */
#define JET_paramMaxTemporaryTables_OLD		15	/* maximum concurrent JetCreateIndex [20] */
#define JET_paramLogBuffers_OLD				16	/* maximum log buffers in 512 bytes [21] */
#define JET_paramLogFileSize_OLD			17	/* maximum log file size in kBytes [5120] */
#define JET_paramBfThrshldLowPrcnt_OLD		19	/* low percentage clean buffer flush start [20] */
#define JET_paramBfThrshldHighPrcnt_OLD		20	/* high percentage clean buffer flush stop [80] */
#define JET_paramWaitLogFlush_OLD			21	/* log flush wait time in milliseconds [15] */
#define JET_paramLogCheckpointPeriod_OLD	23	/* checkpoint period in 512 bytes [1024] */
#define JET_paramLogWaitingUserMax_OLD		24	/* maximum sessions waiting log flush [3] */
#define JET_paramRecovery_OLD				30	/* Switch for log on/off */
#define JET_paramSessionInfo_OLD			33	/* per session information [0] */
#define JET_paramPageFragment_OLD			34	/* maximum disk extent considered fragment in pages [8] */
#define JET_paramMaxOpenDatabases_OLD		36	/* maximum number of open databases [100] */
#define JET_paramBufBatchIOMax_OLD			41	/* maximum batch IO in pages [64] */
#define JET_paramPageReadAheadMax_OLD		42	/* maximum read-ahead IO in pages [20] */
#define JET_paramAsynchIOMax_OLD			43	/* maximum asynchronous IO in pages [64] */
#define JET_paramEventSource_OLD			45	/* language independant process descriptor string [""] */
#define JET_paramDbExtensionSize_OLD		48	/* database extension size in pages [16] */
#define JET_paramCommitDefault_OLD			50	/* default grbit for JetCommitTransaction [0] */
#define	JET_paramBufLogGenAgeThreshold_OLD	51	/* age threshold in log files [2] */
#define	JET_paramCircularLog_OLD			52	/* boolean flag for circular logging [0] */
#define JET_paramPageTempDBMin_OLD			53  /* minimum size temporary database in pages [0] */
#define JET_paramBaseName_OLD				56  /* base name for all DBMS object names ["edb"] */
#define JET_paramBaseExtension_OLD	  		57  /* base extension for all DBMS object names ["edb"] */
#define JET_paramTableClassName_OLD			58  /* table stats class name (class #, string) */



	/* Flags for JetInit2 */

#define	JET_bitReplayReplicatedLogFiles		0x00000001
//#define JET_bitCreateSFSVolumeIfNotExist	0x00000002
// IGNORE_MISSING_ATTACH, ignoring hanging asserts for missing databases during recovery
#define JET_bitReplayIgnoreMissingDB			0x00000004 /* ignore missing databases */

	/* Flags for JetTerm2 */

#define JET_bitTermComplete				0x00000001
#define JET_bitTermAbrupt				0x00000002
#define JET_bitTermStopBackup			0x00000004

	/* Flags for JetIdle */

#define JET_bitIdleFlushBuffers			0x00000001
#define JET_bitIdleCompact				0x00000002
#define JET_bitIdleStatus				0x00000004
#define JET_bitIdleVersionStoreTest		0x00000008 /* INTERNAL USE ONLY. call version store consistency check */

	/* Flags for JetEndSession */
								   	
#define JET_bitForceSessionClosed		0x00000001

	/* Flags for JetAttach/OpenDatabase */

#define JET_bitDbReadOnly				0x00000001
#define JET_bitDbExclusive				0x00000002 /* multiple opens allowed */
#define JET_bitDbSingleExclusive		0x00000002 /* NOT CURRENTLY IMPLEMENTED - currently maps to JET_bitDbExclusive */
#define JET_bitDbDeleteCorruptIndexes	0x00000010 /* delete indexes possibly corrupted by NT version upgrade */
#define JET_bitDbRebuildCorruptIndexes	0x00000020 /* NOT CURRENTLY IMPLEMENTED - recreate indexes possibly corrupted by NT version upgrade */
#define JET_bitDbUpgrade				0x00000200 /* */

	/* Flags for JetDetachDatabase2 */

#define JET_bitForceDetach			  		0x00000001
#define JET_bitForceCloseAndDetach			(0x00000002 | JET_bitForceDetach)

	/* Flags for JetCreateDatabase */

#define JET_bitDbRecoveryOff 			0x00000008 /* disable logging/recovery for this database */
#define JET_bitDbVersioningOff			0x00000040 /* INTERNAL USE ONLY */
#define JET_bitDbShadowingOff			0x00000080 /* disable catalog shadowing */
#define JET_bitDbCreateStreamingFile	0x00000100 /* create streaming file with same name as db */
#define JET_bitDbOverwriteExisting		0x00000200 /* overwrite existing database with same name */ 

	/* Flags for JetBackup */

#define JET_bitBackupIncremental		0x00000001
#define JET_bitKeepOldLogs				0x00000002
#define JET_bitBackupAtomic				0x00000004
#define JET_bitBackupFullWithAllLogs	0x00000008
#define JET_bitBackupSnapshot			0x00000010

	/* Database types */

#define JET_dbidNil			((JET_DBID) 0xFFFFFFFF)
#define JET_dbidNoValid		((JET_DBID) 0xFFFFFFFE) /* used as a flag to indicate that there is no valid dbid */


	/* Flags for JetCreateTableColumnIndex */
#define JET_bitTableCreateFixedDDL			0x00000001	/* DDL is fixed */
#define JET_bitTableCreateTemplateTable		0x00000002	/* DDL is inheritable (implies FixedDDL) */
#define JET_bitTableCreateNoFixedVarColumnsInDerivedTables	0x00000004
														//	used in conjunction with JET_bitTableCreateTemplateTable
														//	to disallow fixed/var columns in derived tables (so that
														//	fixed/var columns may be added to the template in the future)
#define JET_bitTableCreateSystemTable		0x80000000	/*  INTERNAL USE ONLY */


	/* Flags for JetAddColumn, JetGetColumnInfo, JetOpenTempTable */

#define JET_bitColumnFixed				0x00000001
#define JET_bitColumnTagged				0x00000002
#define JET_bitColumnNotNULL			0x00000004
#define JET_bitColumnVersion			0x00000008
#define JET_bitColumnAutoincrement		0x00000010
#define JET_bitColumnUpdatable			0x00000020 /* JetGetColumnInfo only */
#define JET_bitColumnTTKey				0x00000040 /* JetOpenTempTable only */
#define JET_bitColumnTTDescending		0x00000080 /* JetOpenTempTable only */
#define JET_bitColumnMultiValued		0x00000400
#define JET_bitColumnEscrowUpdate		0x00000800 /* escrow updated */
#define JET_bitColumnUnversioned		0x00001000 /* for add column only - add column unversioned */
#define JET_bitColumnMaybeNull			0x00002000 /* for retrieve column info of outer join where no match from the inner table */
#define JET_bitColumnFinalize			0x00004000 /* this is a finalizable column */
#define JET_bitColumnUserDefinedDefault	0x00008000 /* default value from a user-provided callback */
#define JET_bitColumnRenameConvertToPrimaryIndexPlaceholder	0x00010000	//	FOR JetRenameColumn() ONLY: rename and convert to primary index placeholder (ie. no longer part of primary index ecxept as a placeholder)

//	flags for JetDeleteColumn
#define JET_bitDeleteColumnIgnoreTemplateColumns	0x00000001	//	for derived tables, don't bother looking in template columns


	/* Flags for JetSetCurrentIndex */

#define JET_bitMoveFirst				0x00000000
#define JET_bitMoveBeforeFirst 			0x00000001	// unsupported -- DO NOT USE
#define JET_bitNoMove					0x00000002

	/* Flags for JetMakeKey */

#define JET_bitNewKey					0x00000001
#define JET_bitStrLimit 				0x00000002
#define JET_bitSubStrLimit				0x00000004
#define JET_bitNormalizedKey 			0x00000008
#define JET_bitKeyDataZeroLength		0x00000010
#define JET_bitKeyOverridePrimaryIndexPlaceholder	0x00000020

#define JET_maskLimitOptions			0x00000f00
#define JET_bitFullColumnStartLimit		0x00000100
#define JET_bitFullColumnEndLimit		0x00000200
#define JET_bitPartialColumnStartLimit	0x00000400
#define JET_bitPartialColumnEndLimit	0x00000800

	/* Flags for ErrDispSetIndexRange */

#define JET_bitRangeInclusive			0x00000001
#define JET_bitRangeUpperLimit			0x00000002
#define JET_bitRangeInstantDuration		0x00000004
#define JET_bitRangeRemove				0x00000008

	/* Flags for JetGetLock */

#define JET_bitReadLock					0x00000001
#define JET_bitWriteLock				0x00000002

	/* Constants for JetMove */

#define JET_MoveFirst					(0x80000000)
#define JET_MovePrevious				(-1)
#define JET_MoveNext					(+1)
#define JET_MoveLast					(0x7fffffff)

	/* Flags for JetMove */

#define JET_bitMoveKeyNE				0x00000001

	/* Flags for JetSeek */

#define JET_bitSeekEQ					0x00000001
#define JET_bitSeekLT					0x00000002
#define JET_bitSeekLE					0x00000004
#define JET_bitSeekGE					0x00000008
#define JET_bitSeekGT		 			0x00000010
#define JET_bitSetIndexRange			0x00000020

	//	Flags for JetGotoSecondaryIndexBookmark
#define JET_bitBookmarkPermitVirtualCurrency	0x00000001	//	place cursor on relative position in index if specified bookmark no longer exists

	/* Flags for JET_CONDITIONALCOLUMN */
#define JET_bitIndexColumnMustBeNull	0x00000001
#define JET_bitIndexColumnMustBeNonNull	0x00000002

	/* Flags for JET_INDEXRANGE */
#define JET_bitRecordInIndex			0x00000001
#define JET_bitRecordNotInIndex			0x00000002

	/* Flags for JetCreateIndex */

#define JET_bitIndexUnique				0x00000001
#define JET_bitIndexPrimary				0x00000002
#define JET_bitIndexDisallowNull		0x00000004
#define JET_bitIndexIgnoreNull			0x00000008
#define JET_bitIndexClustered40			0x00000010	/*	for backward compatibility */
#define JET_bitIndexIgnoreAnyNull		0x00000020
#define JET_bitIndexIgnoreFirstNull		0x00000040
#define JET_bitIndexLazyFlush			0x00000080
#define JET_bitIndexEmpty				0x00000100	// don't attempt to build index, because all entries would evaluate to NULL (MUST also specify JET_bitIgnoreAnyNull)
#define JET_bitIndexUnversioned			0x00000200
#define JET_bitIndexSortNullsHigh		0x00000400	// NULL sorts after data for all columns in the index
#define JET_bitIndexUnicode				0x00000800	// LCID field of JET_INDEXCREATE actually points to a JET_UNICODEINDEX struct to allow user-defined LCMapString() flags
#define JET_bitIndexTuples				0x00001000	// index on substring tuples (text columns only)

// UNDONE: Remove the following:
// #define JET_bitIndexClustered			JET_bitIndexPrimary	primary index is the clustered index
// #define JET_bitIndexEmptyTable			0x40000000

	/* Flags for index key definition */

#define JET_bitKeyAscending				0x00000000
#define JET_bitKeyDescending			0x00000001

	/* Flags for JetOpenTable */

#define JET_bitTableDenyWrite		0x00000001
#define JET_bitTableDenyRead		0x00000002
#define JET_bitTableReadOnly		0x00000004
#define JET_bitTableUpdatable		0x00000008
#define JET_bitTablePermitDDL		0x00000010	/*  override table flagged as FixedDDL (must be used with DenyRead) */
#define JET_bitTableNoCache			0x00000020	/*	don't cache the pages for this table */
#define JET_bitTablePreread			0x00000040	/*	assume the table is probably not in the buffer cache */
#define JET_bitTableDelete			0x10000000	/*  INTERNAL USE ONLY */
#define JET_bitTableCreate			0x20000000	/*	INTERNAL USE ONLY */

#define JET_bitTableClassMask		0x000F0000	/*  table stats class mask  */
#define JET_bitTableClassNone		0x00000000  /*  table belongs to no stats class (default)  */
#define JET_bitTableClass1			0x00010000  /*  table belongs to stats class 1  */
#define JET_bitTableClass2			0x00020000  /*  table belongs to stats class 2  */
#define JET_bitTableClass3			0x00030000  /*  table belongs to stats class 3  */
#define JET_bitTableClass4			0x00040000  /*  table belongs to stats class 4  */
#define JET_bitTableClass5			0x00050000  /*  table belongs to stats class 5  */
#define JET_bitTableClass6			0x00060000  /*  table belongs to stats class 6  */
#define JET_bitTableClass7			0x00070000  /*  table belongs to stats class 7  */
#define JET_bitTableClass8			0x00080000  /*  table belongs to stats class 8  */
#define JET_bitTableClass9			0x00090000  /*  table belongs to stats class 9  */
#define JET_bitTableClass10			0x000A0000  /*  table belongs to stats class 10  */
#define JET_bitTableClass11			0x000B0000  /*  table belongs to stats class 11  */
#define JET_bitTableClass12			0x000C0000  /*  table belongs to stats class 12  */
#define JET_bitTableClass13			0x000D0000  /*  table belongs to stats class 13  */
#define JET_bitTableClass14			0x000E0000  /*  table belongs to stats class 14  */
#define JET_bitTableClass15			0x000F0000  /*  table belongs to stats class 15  */

#define JET_bitLSReset				0x00000001	/*	reset LS value */
#define JET_bitLSCursor				0x00000002	/*	set/retrieve LS of table cursor */
#define JET_bitLSTable				0x00000004	/*	set/retrieve LS of table */

#define JET_LSNil					(~(JET_LS)0)

	/* Flags for JetOpenTempTable and ErrIsamOpenTempTable */

#define JET_bitTTIndexed			0x00000001	/* Allow seek */
#define JET_bitTTUnique 			0x00000002	/* Remove duplicates */
#define JET_bitTTUpdatable			0x00000004	/* Allow updates */
#define JET_bitTTScrollable			0x00000008	/* Allow backwards scrolling */
#define JET_bitTTSortNullsHigh		0x00000010	/* NULL sorts after data for all columns in the index */
#define JET_bitTTForceMaterialization		0x00000020						/* Forces temp. table to be materialized into a btree (allows for duplicate detection) */
#define JET_bitTTErrorOnDuplicateInsertion	JET_bitTTForceMaterialization	/* Error always returned when duplicate is inserted (instead of dupe being silently removed) */

	/* Flags for JetSetColumn */

#define JET_bitSetAppendLV					0x00000001
#define JET_bitSetOverwriteLV				0x00000004 /* overwrite JET_coltypLong* byte range */
#define JET_bitSetSizeLV					0x00000008 /* set JET_coltypLong* size */
#define JET_bitSetZeroLength				0x00000020
#define JET_bitSetSeparateLV 				0x00000040 /* force LV separation */
#define JET_bitSetUniqueMultiValues			0x00000080 /* prevent duplicate multi-values */
#define JET_bitSetUniqueNormalizedMultiValues	0x00000100 /* prevent duplicate multi-values, normalizing all data before performing comparisons */
#define JET_bitSetRevertToDefaultValue		0x00000200 /* if setting last tagged instance to NULL, revert to default value instead if one exists */
#define JET_bitSetIntrinsicLV				0x00000400 /* store whole LV in record without bursting or return an error */

#define JET_bitSetSLVDataNotRecoverable		0x00001000 /* SLV data is not recoverable */
#define JET_bitSetSLVFromSLVInfo			0x00002000 /*  internal use only  */

	/* Flags for JetSetColumn when the SLV Provider is enabled  */

#define JET_bitSetSLVFromSLVFile			0x00004000 /* set SLV from an SLV File handle */
#define JET_bitSetSLVFromSLVEA				0x00008000 /* set SLV from an SLV EA list */

	/*	Set column parameter structure for JetSetColumns */

typedef struct {
	JET_COLUMNID			columnid;
	const void 				*pvData;
	unsigned long 			cbData;
	JET_GRBIT				grbit;
	unsigned long			ibLongValue;
	unsigned long			itagSequence;
	JET_ERR					err;
} JET_SETCOLUMN;

typedef struct {
	unsigned long	paramid;
	JET_API_PTR		lParam;
	const char		*sz;
	JET_ERR			err;
} JET_SETSYSPARAM;

	/* Options for JetPrepareUpdate */

#define JET_prepInsert						0
#define JET_prepReplace 					2
#define JET_prepCancel						3
#define JET_prepReplaceNoLock				4
#define JET_prepInsertCopy					5
#define JET_prepInsertCopyWithoutSLVColumns	6	//	same as InsertCopy, except that SLV columns are nullified instead of copied in the new record */
#define JET_prepInsertCopyDeleteOriginal	7	//	used for updating a record in the primary key; avoids the delete/insert process */
#define JET_prepReadOnlyCopy				8	//	copy record into copy buffer for read-only purposes


	/* Flags for JetEscrowUpdate */
#define JET_bitEscrowNoRollback				0x0001

	/* Flags for JetRetrieveColumn */

#define JET_bitRetrieveCopy					0x00000001
#define JET_bitRetrieveFromIndex			0x00000002
#define JET_bitRetrieveFromPrimaryBookmark	0x00000004
#define JET_bitRetrieveTag					0x00000008
#define JET_bitRetrieveNull					0x00000010	/*	for columnid 0 only */
#define JET_bitRetrieveIgnoreDefault		0x00000020	/*	for columnid 0 only */
#define JET_bitRetrieveLongId				0x00000040
#define JET_bitRetrieveLongValueRefCount	0x00000080	/*  for testing use only */
#define JET_bitRetrieveSLVAsSLVInfo			0x00000100  /*  internal use only  */

	/* Flags for JetRetrieveColumn when the SLV Provider is enabled  */

#define JET_bitRetrieveSLVAsSLVFile			0x00000200 /* retrieve SLV as an SLV File handle */
#define JET_bitRetrieveSLVAsSLVEA			0x00000400 /* retrieve SLV as an SLV EA list */

	/* Retrieve column parameter structure for JetRetrieveColumns */

typedef struct {
	JET_COLUMNID		columnid;
	void 				*pvData;
	unsigned long 		cbData;
	unsigned long 		cbActual;
	JET_GRBIT			grbit;
	unsigned long		ibLongValue;
	unsigned long		itagSequence;
	JET_COLUMNID		columnidNextTagged;
	JET_ERR				err;
} JET_RETRIEVECOLUMN;


typedef struct
	{
	JET_COLUMNID			columnid;
	unsigned short			cMultiValues;

	union
		{
		unsigned short		usFlags;
		struct
			{
			unsigned short	fLongValue:1;			//	is column LongText/Binary?
			unsigned short	fDefaultValue:1;		//	was a default value retrieved?
			unsigned short	fNullOverride:1;		//	was there an explicit null to override a default value?
			unsigned short	fDerived:1;				//	was column derived from template table?
			};
		};
	} JET_RETRIEVEMULTIVALUECOUNT;


	/* Flags for JetEnumerateColumns */

#define JET_bitEnumerateCopy				JET_bitRetrieveCopy
#define JET_bitEnumerateIgnoreDefault		JET_bitRetrieveIgnoreDefault
#define JET_bitEnumerateLocal				0x00010000
#define JET_bitEnumeratePresenceOnly		0x00020000
#define JET_bitEnumerateTaggedOnly			0x00040000
#define JET_bitEnumerateCompressOutput		0x00080000

	/* Parameter structures for JetEnumerateColumns */

typedef struct {
	JET_COLUMNID			columnid;
	unsigned long			ctagSequence;
	unsigned long*			rgtagSequence;
} JET_ENUMCOLUMNID;

typedef struct {
	unsigned long			itagSequence;
	JET_ERR					err;
	unsigned long			cbData;
	void*					pvData;
} JET_ENUMCOLUMNVALUE;

typedef struct {
	JET_COLUMNID			columnid;
	JET_ERR					err;
	union {
		struct { /* err != JET_wrnColumnSingleValue */
			unsigned long			cEnumColumnValue;
			JET_ENUMCOLUMNVALUE*	rgEnumColumnValue;
		};
		struct { /* err == JET_wrnColumnSingleValue */
			unsigned long			cbData;
			void*					pvData;
		};
	};
} JET_ENUMCOLUMN;

	/* Realloc callback for JetEnumerateColumns */

typedef void* (JET_API *JET_PFNREALLOC)( void* pvContext, void* pv, unsigned long cb );


	/* Flags for JetBeginTransaction2 */

#define JET_bitTransactionReadOnly		0x00000001	/* transaction will not modify the database */
#define JET_bitDistributedTransaction	0x00000002	/* transaction will require two-phase commit */

	/* Flags for JetCommitTransaction */

#define	JET_bitCommitLazyFlush		0x00000001	/* lazy flush log buffers. */
#define JET_bitWaitLastLevel0Commit	0x00000002	/* wait for last level 0 commit record flushed */
#define JET_bitCommitFlush_OLD		0x00000001	/* commit and flush page buffers. */
#define	JET_bitCommitLazyFlush_OLD	0x00000004	/* lazy flush log buffers. */
#define JET_bitWaitLastLevel0Commit_OLD	0x00000010	/* wait for last level 0 commit record flushed */

	/* Flags for JetRollback */

#define JET_bitRollbackAll			0x00000001

	/* Info parameter for JetGetDatabaseInfo */

#define JET_DbInfoFilename			0
#define JET_DbInfoConnect			1
#define JET_DbInfoCountry			2
#define JET_DbInfoLCID				3
#define JET_DbInfoLangid			3		// OBSOLETE: use JET_DbInfoLCID instead
#define JET_DbInfoCp				4
#define JET_DbInfoCollate			5
#define JET_DbInfoOptions			6
#define JET_DbInfoTransactions		7
#define JET_DbInfoVersion			8
#define JET_DbInfoIsam				9
#define JET_DbInfoFilesize			10
#define JET_DbInfoSpaceOwned		11
#define JET_DbInfoSpaceAvailable	12
#define JET_DbInfoUpgrade			13
#define JET_DbInfoMisc				14
#define JET_DbInfoDBInUse			15
#define JET_DbInfoHasSLVFile		16
#define JET_DbInfoPageSize			17

	/* Dbstates from JetGetDatabaseFileInfo */
	
#define JET_dbstateJustCreated		1
#define JET_dbstateDirtyShutdown	2
#define JET_dbstateInconsistent		JET_dbstateDirtyShutdown
#define JET_dbstateCleanShutdown	3
#define JET_dbstateConsistent		JET_dbstateCleanShutdown
#define JET_dbstateBeingConverted	4
#define JET_dbstateForceDetach		5

	/* Column data types */

#define JET_coltypNil				0
#define JET_coltypBit				1      /* True or False, Never NULL */
#define JET_coltypUnsignedByte		2      /* 1-byte integer, unsigned */
#define JET_coltypShort 			3      /* 2-byte integer, signed */
#define JET_coltypLong				4      /* 4-byte integer, signed */
#define JET_coltypCurrency			5      /* 8 byte integer, signed */
#define JET_coltypIEEESingle		6      /* 4-byte IEEE single precision */
#define JET_coltypIEEEDouble		7      /* 8-byte IEEE double precision */
#define JET_coltypDateTime			8      /* Integral date, fractional time */
#define JET_coltypBinary			9      /* Binary data, < 255 bytes */
#define JET_coltypText				10     /* ANSI text, case insensitive, < 255 bytes */
#define JET_coltypLongBinary		11     /* Binary data, long value */
#define JET_coltypLongText			12     /* ANSI text, long value */
#define JET_coltypSLV				13     /* SLV's */
#define JET_coltypMax				14		/* the number of column types  */
											/* used for validity tests and */
											/* array declarations.		   */

	/* Info levels for JetGetObjectInfo */

#define JET_ObjInfo					0U
#define JET_ObjInfoListNoStats		1U
#define JET_ObjInfoList 			2U
#define JET_ObjInfoSysTabCursor 	3U
#define JET_ObjInfoListACM			4U /* Blocked by JetGetObjectInfo */
#define JET_ObjInfoNoStats			5U
#define JET_ObjInfoSysTabReadOnly	6U
#define JET_ObjInfoRulesLoaded		7U
#define JET_ObjInfoMax				8U

	/* Info levels for JetGetTableInfo */

#define JET_TblInfo				0U
#define JET_TblInfoName			1U
#define JET_TblInfoDbid			2U
#define JET_TblInfoMostMany  	3U
#define JET_TblInfoRvt			4U
#define JET_TblInfoOLC			5U
#define JET_TblInfoResetOLC 	6U
#define JET_TblInfoSpaceUsage	7U
#define JET_TblInfoDumpTable	8U
#define JET_TblInfoSpaceAlloc	9U
#define JET_TblInfoSpaceOwned	10U					// OwnExt
#define JET_TblInfoSpaceAvailable		11U			// AvailExt
#define JET_TblInfoTemplateTableName	12U

	/* Info levels for JetGetIndexInfo and JetGetTableIndexInfo */

#define JET_IdxInfo					0U
#define JET_IdxInfoList 			1U
#define JET_IdxInfoSysTabCursor 	2U
#define JET_IdxInfoOLC				3U
#define JET_IdxInfoResetOLC			4U
#define JET_IdxInfoSpaceAlloc		5U
#define JET_IdxInfoLCID				6U
#define JET_IdxInfoLangid			6U		//	OBSOLETE: use JET_IdxInfoLCID instead
#define JET_IdxInfoCount			7U
#define JET_IdxInfoVarSegMac		8U
#define JET_IdxInfoIndexId			9U

	/* Info levels for JetGetColumnInfo and JetGetTableColumnInfo */

#define JET_ColInfo					0U
#define JET_ColInfoList 			1U
#define JET_ColInfoSysTabCursor 	3U
#define JET_ColInfoBase 			4U
#define JET_ColInfoListCompact 		5U
#define JET_ColInfoByColid			6U
#define JET_ColInfoListSortColumnid 7U		//	same as JET_ColInfoList except PresentationOrder is set to columnid
											//	to force sorting by columnid


	/* Engine Object Types */

#define JET_objtypNil				0
#define JET_objtypTable 			1
#define JET_objtypDb				2
#define JET_objtypContainer			3
#define JET_objtypLongRoot			9	/*  INTERNAL USE ONLY */

	/* Compact Options */

#define JET_bitCompactStats				0x00000020	/* Dump off-line compaction stats (only when progress meter also specified) */
#define JET_bitCompactRepair			0x00000040	/* Don't preread and ignore duplicate keys */
#define JET_bitCompactSLVCopy			0x00000080  /* Recreate SLV file, do not reuse the existing one */

	/* Status Notification Processes */

#define JET_snpRepair					2
#define JET_snpCompact					4
#define JET_snpRestore					8
#define JET_snpBackup					9
#define JET_snpUpgrade					10
#define JET_snpScrub					11
#define JET_snpUpgradeRecordFormat		12


	/* Status Notification Types */

#define JET_sntBegin			5	/* callback for beginning of operation */
#define JET_sntRequirements		7	/* callback for returning operation requirements */
#define JET_sntProgress 		0	/* callback for progress */
#define JET_sntComplete 		6	/* callback for completion of operation */
#define JET_sntFail				3	/* callback for failure during progress */

	/* Exception action */

#define JET_ExceptionMsgBox		0x0001		/* Display message box on exception */
#define JET_ExceptionNone		0x0002		/* Do nothing on exceptions */

	/* AssertAction */

#define JET_AssertExit			0x0000		/* Exit the application */
#define JET_AssertBreak 		0x0001		/* Break to debugger */
#define JET_AssertMsgBox		0x0002		/* Display message box */
#define JET_AssertStop			0x0004		/* Alert and stop */


	//	Online defragmentation options
#define JET_OnlineDefragDisable			0x0000		//	disable online defrag
#define JET_OnlineDefragAllOBSOLETE		0x0001		//	enable online defrag for everything (must be 1 for backward compatibility)
#define JET_OnlineDefragDatabases		0x0002		//	enable online defrag of databases
#define JET_OnlineDefragSpaceTrees		0x0004		//	enable online defrag of space trees
#define JET_OnlineDefragStreamingFiles	0x0008		//	enable online defrag of streaming files
#define JET_OnlineDefragAll				0xffff		//	enable online defrag for everything


	/* Counter flags */			// For XJET only, not for JET97

#define ctAccessPage			1
#define ctLatchConflict			2
#define ctSplitRetry			3
#define ctNeighborPageScanned	4
#define ctSplits				5

/**********************************************************************/
/***********************     ERROR CODES     **************************/
/**********************************************************************/

/* SUCCESS */

#define JET_errSuccess						 0    /* Successful Operation */

/* ERRORS */

#define JET_wrnNyi							-1    /* Function Not Yet Implemented */

/*	SYSTEM errors
/**/
#define JET_errRfsFailure			   		-100  /* Resource Failure Simulator failure */
#define JET_errRfsNotArmed					-101  /* Resource Failure Simulator not initialized */
#define JET_errFileClose					-102  /* Could not close file */
#define JET_errOutOfThreads					-103  /* Could not start thread */
#define JET_errTooManyIO		  			-105  /* System busy due to too many IOs */
#define JET_errTaskDropped					-106  /* A requested async task could not be executed */
#define JET_errInternalError				-107  /* Fatal internal error */

//	BUFFER MANAGER errors
//
#define wrnBFCacheMiss						 200  /*  ese97,esent only:  page latch caused a cache miss  */
#define errBFPageNotCached					-201  /*  page is not cached  */
#define errBFLatchConflict					-202  /*  page latch conflict  */
#define errBFPageCached						-203  /*  page is cached  */
#define wrnBFPageFlushPending				 204  /*  page is currently being written  */
#define wrnBFPageFault						 205  /*  page latch caused a page fault  */

#define errBFIPageEvicted					-250  /*  ese97,esent only:  page evicted from the cache  */
#define errBFIPageCached					-251  /*  ese97,esent only:  page already cached  */
#define errBFIOutOfOLPs						-252  /*  ese97,esent only:  out of OLPs  */
#define errBFIOutOfBatchIOBuffers			-253  /*  ese97,esent only:  out of Batch I/O Buffers  */
#define errBFINoBufferAvailable				-254  /*  no buffer available for immediate use  */
#define JET_errDatabaseBufferDependenciesCorrupted	-255	/* Buffer dependencies improperly set. Recovery failure */
#define errBFIRemainingDependencies			-256  /*  dependencies remain on this buffer  */
#define errBFIPageFlushPending				-257  /*  page is currently being written  */
#define errBFIPageNotEvicted				-258  /*  the page could not be evicted from the cache  */
#define errBFIPageFlushed					-259  /*  page write initiated  */
#define errBFIPageFaultPending				-260  /*  page is currently being read  */
#define errBFIPageNotVerified				-261  /*  page data has not been verified  */
#define errBFIDependentPurged				-262  /*  page cannot be flushed due to purged dependencies  */

//  VERSION STORE errors
//
#define wrnVERRCEMoved						275   /*  RCE was moved instead of being cleaned */

/*	DIRECTORY MANAGER errors
/**/
#define errPMOutOfPageSpace					-300  /* Out of page space */
#define errPMItagTooBig 		  			-301  /* Itag too big */					//  XXX -- to be deleted
#define errPMRecDeleted 		  			-302  /* Record deleted */					//  XXX -- to be deleted
#define errPMTagsUsedUp 		  			-303  /* Tags used up */					//  XXX -- to be deleted
#define wrnBMConflict			  			304   /* conflict in BM Clean up */
#define errDIRNoShortCircuit	  			-305  /* No Short Circuit Avail */
#define errDIRCannotSplit		  			-306  /* Cannot horizontally split FDP */
#define errDIRTop				  			-307  /* Cannot go up */
#define errDIRFDP							308	  /* On an FDP Node */
#define errDIRNotSynchronous				-309  /* May have left critical section */
#define wrnDIREmptyPage						310	  /* Moved through empty page */
#define errSPConflict						-311  /* Device extent being extended */
#define wrnNDFoundLess						312	  /* Found Less */
#define wrnNDFoundGreater					313	  /* Found Greater */
#define wrnNDNotFoundInPage					314	  /* for smart refresh */
#define errNDNotFound						-312  /* Not found */
#define errNDOutSonRange					-314  /* Son out of range */
#define errNDOutItemRange					-315  /* Item out of range */
#define errNDGreaterThanAllItems 			-316  /* Greater than all items */
#define errNDLastItemNode					-317  /* Last node of item list */
#define errNDFirstItemNode					-318  /* First node of item list */
#define wrnNDDuplicateItem					319	  /* Duplicated Item */
#define errNDNoItem							-320  /* Item not there */
#define JET_wrnRemainingVersions 			321	  /* The version store is still active */
#define JET_errPreviousVersion				-322  /* Version already existed. Recovery failure */
#define JET_errPageBoundary					-323  /* Reached Page Boundary */
#define JET_errKeyBoundary		  			-324  /* Reached Key Boundary */
#define errDIRInPageFather  				-325  /* sridFather in page to free */
#define	errBMMaxKeyInPage					-326  /* used by OLC to avoid cleanup of parent pages */
#define	JET_errBadPageLink					-327  /* Database corrupted */
#define	JET_errBadBookmark					-328  /* Bookmark has no corresponding address in database */
#define wrnBMCleanNullOp					329	  // BMClean returns this on encountering a page
												  // deleted MaxKeyInPage [but there was no conflict]
#define errBTOperNone						-330  // Split with no accompanying
												  // insert/replace
#define errSPOutOfAvailExtCacheSpace		-331  // unable to make update to AvailExt tree since
												  // in-cursor space cache is depleted
#define errSPOutOfOwnExtCacheSpace			-332  // unable to make update to OwnExt tree since
												  // in-cursor space cache is depleted
#define	wrnBTMultipageOLC					333	  // needs multipage OLC operation
#define JET_errNTSystemCallFailed 			-334  /* A call to the operating system failed */
#define wrnBTShallowTree					335   // BTree is only one or two levels deeps
#define errBTMergeNotSynchronous			-336  // Multiple threads attempting to perform merge/split on same page (likely OLD vs. RCEClean)
#define wrnSPReservedPages					337   // space manager reserved pages for future space tree splits
#define	JET_errBadParentPageLink			-338  /* Database corrupted */
#define wrnSPBuildAvailExtCache				339   // AvailExt tree is sufficiently large that it should be cached
#define JET_errSPAvailExtCacheOutOfSync		-340  // AvailExt cache doesn't match btree
#define JET_errSPAvailExtCorrupted			-341  // AvailExt space tree is corrupt
#define JET_errSPAvailExtCacheOutOfMemory	-342  // Out of memory allocating an AvailExt cache node
#define JET_errSPOwnExtCorrupted			-343  // OwnExt space tree is corrupt
#define JET_errDbTimeCorrupted				-344  // Dbtime on current page is greater than global database dbtime

/*	RECORD MANAGER errors
/**/
#define wrnFLDKeyTooBig 					400	  /* Key too big (truncated it) */
#define errFLDTooManySegments				-401  /* Too many key segments */
#define wrnFLDNullKey						402	  /* Key is entirely NULL */
#define wrnFLDOutOfKeys 					403	  /* No more keys to extract */
#define wrnFLDNullSeg						404	  /* Null segment in key */
#define wrnFLDNotPresentInIndex				405
#define JET_wrnSeparateLongValue			406	  /* Column is a separated long-value */
#define wrnRECLongField 					407	  /* Long value */
#define JET_wrnRecordFoundGreater			JET_wrnSeekNotEqual
#define JET_wrnRecordFoundLess    			JET_wrnSeekNotEqual
#define JET_errColumnIllegalNull  			JET_errNullInvalid
#define wrnFLDNullFirstSeg		   			408	  /* Null first segment in key */
#define JET_errKeyTooBig					-408  /* Key is too large */
#define wrnRECUserDefinedDefault			409   /* User-defined default value */
#define wrnRECSeparatedLV 					410	  /* LV stored in LV tree */
#define wrnRECIntrinsicLV 					411	  /* LV stored in the record */
#define wrnRECSeparatedSLV					412   /* SLV stored as a separated LV */
#define wrnRECIntrinsicSLV					413   /* SLV stored as an intrinsic LV */
#define wrnFLDIndexUpdated					414		// index update performed
#define wrnFLDOutOfTuples					415		// no more tuples for current string

/*	LOGGING/RECOVERY errors
/**/
#define JET_errInvalidLoggedOperation		-500  /* Logged operation cannot be redone */
#define JET_errLogFileCorrupt		  		-501  /* Log file is corrupt */
#define errLGNoMoreRecords					-502  /* Last log record read */
#define JET_errNoBackupDirectory 			-503  /* No backup directory given */
#define JET_errBackupDirectoryNotEmpty 		-504  /* The backup directory is not emtpy */
#define JET_errBackupInProgress 			-505  /* Backup is active already */
#define JET_errRestoreInProgress			-506  /* Restore in progress */
#define JET_errMissingPreviousLogFile		-509  /* Missing the log file for check point */
#define JET_errLogWriteFail					-510  /* Failure writing to log file */
#define JET_errLogDisabledDueToRecoveryFailure -511 /* Try to log something after recovery faild */
#define JET_errCannotLogDuringRecoveryRedo	-512	/* Try to log something during recovery redo */
#define JET_errLogGenerationMismatch		-513  /* Name of logfile does not match internal generation number */
#define JET_errBadLogVersion  	  			-514  /* Version of log file is not compatible with Jet version */
#define JET_errInvalidLogSequence  			-515  /* Timestamp in next log does not match expected */
#define JET_errLoggingDisabled 				-516  /* Log is not active */
#define JET_errLogBufferTooSmall			-517  /* Log buffer is too small for recovery */
#define errLGNotSynchronous					-518  /* retry to LGLogRec */
#define JET_errLogSequenceEnd				-519  /* Maximum log file number exceeded */
#define JET_errNoBackup						-520  /* No backup in progress */
#define	JET_errInvalidBackupSequence		-521  /* Backup call out of sequence */
#define JET_errBackupNotAllowedYet			-523  /* Cannot do backup now */
#define JET_errDeleteBackupFileFail	   		-524  /* Could not delete backup file */
#define JET_errMakeBackupDirectoryFail 		-525  /* Could not make backup temp directory */
#define JET_errInvalidBackup		 		-526  /* Cannot perform incremental backup when circular logging enabled */
#define JET_errRecoveredWithErrors			-527  /* Restored with errors */
#define JET_errMissingLogFile				-528  /* Current log file missing */
#define JET_errLogDiskFull					-529  /* Log disk full */
#define JET_errBadLogSignature				-530  /* Bad signature for a log file */
#define JET_errBadDbSignature				-531  /* Bad signature for a db file */
#define JET_errBadCheckpointSignature		-532  /* Bad signature for a checkpoint file */
#define	JET_errCheckpointCorrupt			-533  /* Checkpoint file not found or corrupt */
#define	JET_errMissingPatchPage				-534  /* Patch file page not found during recovery */
#define	JET_errBadPatchPage					-535  /* Patch file page is not valid */
#define JET_errRedoAbruptEnded				-536  /* Redo abruptly ended due to sudden failure in reading logs from log file */
#define JET_errBadSLVSignature				-537  /* Signature in SLV file does not agree with database */
#define JET_errPatchFileMissing				-538  /* Hard restore detected that patch file is missing from backup set */
#define JET_errDatabaseLogSetMismatch		-539  /* Database does not belong with the current set of log files */
#define JET_errDatabaseStreamingFileMismatch -540 /* Database and streaming file do not match each other */
#define JET_errLogFileSizeMismatch			-541  /* actual log file size does not match JET_paramLogFileSize */
#define JET_errCheckpointFileNotFound		-542  /* Could not locate checkpoint file */
#define JET_errRequiredLogFilesMissing		-543  /* The required log files for recovery is missing. */
#define JET_errSoftRecoveryOnBackupDatabase	-544  /* Soft recovery is intended on a backup database. Restore should be used instead */
#define JET_errLogFileSizeMismatchDatabasesConsistent	-545  /* databases have been recovered, but the log file size used during recovery does not match JET_paramLogFileSize */
#define JET_errLogSectorSizeMismatch		-546  /* the log file sector size does not match the current volume's sector size */
#define JET_errLogSectorSizeMismatchDatabasesConsistent	-547  /* databases have been recovered, but the log file sector size (used during recovery) does not match the current volume's sector size */
#define JET_errLogSequenceEndDatabasesConsistent -548 /* databases have been recovered, but all possible log generations in the current sequence are used; delete all log files and the checkpoint file and backup the databases before continuing */

#define JET_errStreamingDataNotLogged		-549  /* Illegal attempt to replay a streaming file operation where the data wasn't logged. Probably caused by an attempt to roll-forward with circular logging enabled */

#define JET_errDatabaseDirtyShutdown		-550  /* Database was not shutdown cleanly. Recovery must first be run to properly complete database operations for the previous shutdown. */
#define JET_errDatabaseInconsistent			JET_errDatabaseDirtyShutdown	/* OBSOLETE */
#define JET_errConsistentTimeMismatch		-551  /* Database last consistent time unmatched */
#define JET_errDatabasePatchFileMismatch	-552  /* Patch file is not generated from this backup */
#define JET_errEndingRestoreLogTooLow		-553  /* The starting log number too low for the restore */
#define JET_errStartingRestoreLogTooHigh	-554  /* The starting log number too high for the restore */
#define JET_errGivenLogFileHasBadSignature	-555  /* Restore log file has bad signature */
#define JET_errGivenLogFileIsNotContiguous	-556  /* Restore log file is not contiguous */
#define JET_errMissingRestoreLogFiles		-557  /* Some restore log files are missing */
#define JET_wrnExistingLogFileHasBadSignature	558  /* Existing log file has bad signature */
#define JET_wrnExistingLogFileIsNotContiguous	559  /* Existing log file is not contiguous */
#define JET_errMissingFullBackup			-560  /* The database miss a previous full backup befor incremental backup */
#define JET_errBadBackupDatabaseSize		-561  /* The backup database size is not in 4k */
#define JET_errDatabaseAlreadyUpgraded		-562  /* Attempted to upgrade a database that is already current */
#define JET_errDatabaseIncompleteUpgrade	-563  /* Attempted to use a database which was only partially converted to the current format -- must restore from backup */
#define JET_wrnSkipThisRecord				 564  /* INTERNAL ERROR */
#define JET_errMissingCurrentLogFiles		-565  /* Some current log files are missing for continous restore */

#define JET_errDbTimeTooOld						-566  /* dbtime on page smaller than dbtimeBefore in record */
#define JET_errDbTimeTooNew						-567  /* dbtime on page in advence of the dbtimeBefore in record */
#define wrnCleanedUpMismatchedFiles				568	  /* INTERNAL WARNING: indicates that the redo function cleaned up logs/checkpoint because of a size mismatch (see JET_paramCleanupMismatchedLogFiles) */
#define JET_errMissingFileToBackup				-569  /* Some log or patch files are missing during backup */

#define JET_errLogTornWriteDuringHardRestore	-570	/* torn-write was detected in a backup set during hard restore */
#define JET_errLogTornWriteDuringHardRecovery	-571	/* torn-write was detected during hard recovery (log was not part of a backup set) */
#define JET_errLogCorruptDuringHardRestore		-573	/* corruption was detected in a backup set during hard restore */
#define JET_errLogCorruptDuringHardRecovery	 	-574	/* corruption was detected during hard recovery (log was not part of a backup set) */

#define JET_errMustDisableLoggingForDbUpgrade	-575	/* Cannot have logging enabled while attempting to upgrade db */
#define errLGRecordDataInaccessible				-576	/* an incomplete log record was created because all the data to be logged was not accessible */

#define JET_errBadRestoreTargetInstance			-577	/* TargetInstance specified for restore is not found or log files don't match */
#define JET_wrnTargetInstanceRunning			578		/* TargetInstance specified for restore is running */

#define	JET_errDatabasesNotFromSameSnapshot		-580  /* Databases to be restored are not from the same Snapshot backup */
#define	JET_errSoftRecoveryOnSnapshot			-581  /* Soft recovery on a database from a snapshot backup set */

#define JET_wrnDatabaseRepaired					595 	/* Database corruption has been repaired */

#define JET_errUnicodeTranslationBufferTooSmall	-601	/* Unicode translation buffer too small */
#define JET_errUnicodeTranslationFail			-602	/* Unicode normalization failed */
#define JET_errUnicodeNormalizationNotSupported	-603	/* OS does not provide support for Unicode normalisation (and no normalisation callback was specified) */

#define JET_errExistingLogFileHasBadSignature	-610  /* Existing log file has bad signature */
#define JET_errExistingLogFileIsNotContiguous	-611  /* Existing log file is not contiguous */

#define JET_errLogReadVerifyFailure			-612  /* Checksum error in log file during backup */
#define JET_errSLVReadVerifyFailure			-613  /* Checksum error in SLV file during backup */

#define	errBackupAbortByCaller				-800  /* INTERNAL ERROR: Backup was aborted by client or RPC connection with client failed */
#define	JET_errBackupAbortByServer			-801  /* Backup was aborted by server by calling JetTerm with JET_bitTermStopBackup */

#define JET_errInvalidGrbit					-900  /* Invalid parameter */

#define JET_errTermInProgress		  		-1000 /* Termination in progress */
#define JET_errFeatureNotAvailable			-1001 /* API not supported */
#define JET_errInvalidName					-1002 /* Invalid name */
#define JET_errInvalidParameter 			-1003 /* Invalid API parameter */
#define JET_wrnColumnNull					 1004 /* Column is NULL-valued */
#define JET_wrnBufferTruncated				 1006 /* Buffer too small for data */
#define JET_wrnDatabaseAttached 			 1007 /* Database is already attached */
#define JET_errDatabaseFileReadOnly			-1008 /* Tried to attach a read-only database file for read/write operations */
#define JET_wrnSortOverflow					 1009 /* Sort does not fit in memory */
#define JET_errInvalidDatabaseId			-1010 /* Invalid database id */
#define JET_errOutOfMemory					-1011 /* Out of Memory */
#define JET_errOutOfDatabaseSpace 			-1012 /* Maximum database size reached */
#define JET_errOutOfCursors					-1013 /* Out of table cursors */
#define JET_errOutOfBuffers					-1014 /* Out of database page buffers */
#define JET_errTooManyIndexes				-1015 /* Too many indexes */
#define JET_errTooManyKeys					-1016 /* Too many columns in an index */
#define JET_errRecordDeleted				-1017 /* Record has been deleted */
#define JET_errReadVerifyFailure			-1018 /* Checksum error on a database page */
#define JET_errPageNotInitialized			-1019 /* Blank database page */
#define JET_errOutOfFileHandles	 			-1020 /* Out of file handles */
#define JET_errDiskIO						-1022 /* Disk IO error */
#define JET_errInvalidPath					-1023 /* Invalid file path */
#define JET_errInvalidSystemPath			-1024 /* Invalid system path */
#define JET_errInvalidLogDirectory			-1025 /* Invalid log directory */
#define JET_errRecordTooBig					-1026 /* Record larger than maximum size */
#define JET_errTooManyOpenDatabases			-1027 /* Too many open databases */
#define JET_errInvalidDatabase				-1028 /* Not a database file */
#define JET_errNotInitialized				-1029 /* Database engine not initialized */
#define JET_errAlreadyInitialized			-1030 /* Database engine already initialized */
#define JET_errInitInProgress				-1031 /* Database engine is being initialized */
#define JET_errFileAccessDenied 			-1032 /* Cannot access file, the file is locked or in use */
#define JET_errQueryNotSupported			-1034 /* Query support unavailable */				//  XXX -- to be deleted
#define JET_errSQLLinkNotSupported			-1035 /* SQL Link support unavailable */			//  XXX -- to be deleted
#define JET_errBufferTooSmall				-1038 /* Buffer is too small */
#define JET_wrnSeekNotEqual					 1039 /* Exact match not found during seek */
#define JET_errTooManyColumns				-1040 /* Too many columns defined */
#define JET_errContainerNotEmpty			-1043 /* Container is not empty */
#define JET_errInvalidFilename				-1044 /* Filename is invalid */
#define JET_errInvalidBookmark				-1045 /* Invalid bookmark */
#define JET_errColumnInUse					-1046 /* Column used in an index */
#define JET_errInvalidBufferSize			-1047 /* Data buffer doesn't match column size */
#define JET_errColumnNotUpdatable			-1048 /* Cannot set column value */
#define JET_errIndexInUse					-1051 /* Index is in use */
#define JET_errLinkNotSupported 			-1052 /* Link support unavailable */
#define JET_errNullKeyDisallowed			-1053 /* Null keys are disallowed on index */
#define JET_errNotInTransaction 			-1054 /* Operation must be within a transaction */
#define JET_wrnNoErrorInfo					1055  /* No extended error information */
#define JET_wrnNoIdleActivity		 		1058  /* No idle activity occured */
#define JET_errTooManyActiveUsers			-1059 /* Too many active database users */
#define JET_errInvalidCountry				-1061 /* Invalid or unknown country code */
#define JET_errInvalidLanguageId			-1062 /* Invalid or unknown language id */
#define JET_errInvalidCodePage				-1063 /* Invalid or unknown code page */
#define JET_errInvalidLCMapStringFlags		-1064 /* Invalid flags for LCMapString() */
#define JET_wrnNoWriteLock					1067  /* No write lock at transaction level 0 */
#define JET_wrnColumnSetNull		   		 1068 /* Column set to NULL-value */
#define JET_errVersionStoreOutOfMemory		-1069 /* Version store out of memory */
#define JET_errCurrencyStackOutOfMemory		-1070 /* UNUSED: lCSRPerfFUCB * g_lCursorsMax exceeded (XJET only) */
#define JET_errCannotIndex		 	  		-1071 /* Cannot index escrow column or SLV column */
#define JET_errRecordNotDeleted				-1072 /* Record has not been deleted */
#define JET_errTooManyMempoolEntries		-1073 /* Too many mempool entries requested */
#define JET_errOutOfObjectIDs				-1074 /* Out of btree ObjectIDs (perform offline defrag to reclaim freed/unused ObjectIds) */
#define JET_errOutOfLongValueIDs			-1075 /* Long-value ID counter has reached maximum value. (perform offline defrag to reclaim free/unused LongValueIDs) */
#define JET_errOutOfAutoincrementValues		-1076 /* Auto-increment counter has reached maximum value (offline defrag WILL NOT be able to reclaim free/unused Auto-increment values). */
#define JET_errOutOfDbtimeValues			-1077 /* Dbtime counter has reached maximum value (perform offline defrag to reclaim free/unused Dbtime values) */
#define JET_errOutOfSequentialIndexValues	-1078 /* Sequential index counter has reached maximum value (perform offline defrag to reclaim free/unused SequentialIndex values) */

#define JET_errRunningInOneInstanceMode		-1080 /* Multi-instance call with single-instance mode enabled */
#define JET_errRunningInMultiInstanceMode	-1081 /* Single-instance call with multi-instance mode enabled */
#define JET_errSystemParamsAlreadySet		-1082 /* Global system parameters have already been set */

#define JET_errSystemPathInUse				-1083 /* System path already used by another database instance */
#define JET_errLogFilePathInUse				-1084 /* Logfile path already used by another database instance */
#define JET_errTempPathInUse				-1085 /* Temp path already used by another database instance */
#define JET_errInstanceNameInUse			-1086 /* Instance Name already in use */

#define JET_errInstanceUnavailable			-1090 /* This instance cannot be used because it encountered a fatal error */
#define JET_errDatabaseUnavailable			-1091 /* This database cannot be used because it encountered a fatal error */

#define JET_errOutOfSessions  				-1101 /* Out of sessions */
#define JET_errWriteConflict				-1102 /* Write lock failed due to outstanding write lock */
#define JET_errTransTooDeep					-1103 /* Transactions nested too deeply */
#define JET_errInvalidSesid					-1104 /* Invalid session handle */
#define JET_errWriteConflictPrimaryIndex	-1105 /* Update attempted on uncommitted primary index */
#define JET_errInTransaction				-1108 /* Operation not allowed within a transaction */
#define JET_errRollbackRequired				-1109 /* Must rollback current transaction -- cannot commit or begin a new one */
#define JET_errTransReadOnly				-1110 /* Read-only transaction tried to modify the database */
#define JET_errSessionWriteConflict			-1111 /* Attempt to replace the same record by two diffrerent cursors in the same session */

#define JET_errMustCommitDistributedTransactionToLevel0			-1150 /* Attempted to PrepareToCommit a distributed transaction to non-zero level */
#define JET_errDistributedTransactionAlreadyPreparedToCommit	-1151 /* Attempted a write-operation after a distributed transaction has called PrepareToCommit */
#define JET_errNotInDistributedTransaction						-1152 /* Attempted to PrepareToCommit a non-distributed transaction */
#define JET_errDistributedTransactionNotYetPreparedToCommit		-1153 /* Attempted to commit a distributed transaction, but PrepareToCommit has not yet been called */
#define JET_errCannotNestDistributedTransactions				-1154 /* Attempted to begin a distributed transaction when not at level 0 */
#define JET_errDTCMissingCallback								-1160 /* Attempted to begin a distributed transaction but no callback for DTC coordination was specified on initialisation */
#define JET_errDTCMissingCallbackOnRecovery						-1161 /* Attempted to recover a distributed transaction but no callback for DTC coordination was specified on initialisation */
#define JET_errDTCCallbackUnexpectedError						-1162 /* Unexpected error code returned from DTC callback */
#define JET_wrnDTCCommitTransaction								1163  /* Warning code DTC callback should return if the specified transaction is to be committed */
#define JET_wrnDTCRollbackTransaction							1164  /* Warning code DTC callback should return if the specified transaction is to be rolled back */

#define JET_errDatabaseDuplicate			-1201 /* Database already exists */
#define JET_errDatabaseInUse				-1202 /* Database in use */
#define JET_errDatabaseNotFound 			-1203 /* No such database */
#define JET_errDatabaseInvalidName			-1204 /* Invalid database name */
#define JET_errDatabaseInvalidPages			-1205 /* Invalid number of pages */
#define JET_errDatabaseCorrupted			-1206 /* Non database file or corrupted db */
#define JET_errDatabaseLocked				-1207 /* Database exclusively locked */
#define	JET_errCannotDisableVersioning		-1208 /* Cannot disable versioning for this database */
#define JET_errInvalidDatabaseVersion		-1209 /* Database engine is incompatible with database */

/*	The following error code are for NT clients only. It will return such error during
 *	JetInit if JET_paramCheckFormatWhenOpenFail is set.
 */
#define JET_errDatabase200Format			-1210 /* The database is in an older (200) format */
#define JET_errDatabase400Format			-1211 /* The database is in an older (400) format */
#define JET_errDatabase500Format			-1212 /* The database is in an older (500) format */

#define JET_errPageSizeMismatch				-1213 /* The database page size does not match the engine */
#define JET_errTooManyInstances				-1214 /* Cannot start any more database instances */
#define JET_errDatabaseSharingViolation		-1215 /* A different database instance is using this database */
#define JET_errAttachedDatabaseMismatch		-1216 /* An outstanding database attachment has been detected at the start or end of recovery, but database is missing or does not match attachment info */
#define JET_errDatabaseInvalidPath			-1217 /* Specified path to database file is illegal */
#define JET_errDatabaseIdInUse				-1218 /* A database is being assigned an id already in use */
#define JET_errForceDetachNotAllowed 		-1219 /* Force Detach allowed only after normal detach errored out */
#define JET_errCatalogCorrupted				-1220 /* Corruption detected in catalog */
#define JET_errPartiallyAttachedDB			-1221 /* Database is partially attached. Cannot complete attach operation */
#define JET_errDatabaseSignInUse			-1222 /* Database with same signature in use */
#define errSkippedDbHeaderUpdate			-1223 /* some db header weren't update becase there were during detach */

#define JET_wrnTableEmpty			 		1301  /* Opened an empty table */
#define JET_errTableLocked					-1302 /* Table is exclusively locked */
#define JET_errTableDuplicate				-1303 /* Table already exists */
#define JET_errTableInUse					-1304 /* Table is in use, cannot lock */
#define JET_errObjectNotFound				-1305 /* No such table or object */
#define JET_errDensityInvalid				-1307 /* Bad file/index density */
#define JET_errTableNotEmpty				-1308 /* Table is not empty */
#define JET_errInvalidTableId				-1310 /* Invalid table id */
#define JET_errTooManyOpenTables			-1311 /* Cannot open any more tables (cleanup already attempted) */
#define JET_errIllegalOperation 			-1312 /* Oper. not supported on table */
#define JET_errObjectDuplicate				-1314 /* Table or object name in use */
#define JET_errInvalidObject				-1316 /* Object is invalid for operation */
#define JET_errCannotDeleteTempTable		-1317 /* Use CloseTable instead of DeleteTable to delete temp table */
#define JET_errCannotDeleteSystemTable		-1318 /* Illegal attempt to delete a system table */
#define JET_errCannotDeleteTemplateTable	-1319 /* Illegal attempt to delete a template table */
#define	errFCBTooManyOpen					-1320 /* Cannot open any more FCB's (cleanup not yet attempted) */
#define	errFCBAboveThreshold				-1321 /* Can only allocate FCB above preferred threshold (cleanup not yet attempted) */
#define JET_errExclusiveTableLockRequired	-1322 /* Must have exclusive lock on table. */
#define JET_errFixedDDL						-1323 /* DDL operations prohibited on this table */
#define JET_errFixedInheritedDDL			-1324 /* On a derived table, DDL operations are prohibited on inherited portion of DDL */
#define JET_errCannotNestDDL				-1325 /* Nesting of hierarchical DDL is not currently supported. */
#define JET_errDDLNotInheritable			-1326 /* Tried to inherit DDL from a table not marked as a template table. */
#define JET_wrnTableInUseBySystem			1327  /* System cleanup has a cursor open on the table */
#define JET_errInvalidSettings				-1328 /* System parameters were set improperly */
#define JET_errClientRequestToStopJetService -1329 /* Client has requested stop service */
#define JET_errCannotAddFixedVarColumnToDerivedTable	-1330	/* Template table was created with NoFixedVarColumnsInDerivedTables */
#define errFCBExists						-1331 /* Tried to create an FCB that already exists */
#define errFCBUnusable						-1332 /* Placeholder to mark an FCB that must be purged as unusable */
#define wrnCATNoMoreRecords					1333  /* Attempted to navigate past the end of the catalog */

#define JET_errIndexCantBuild				-1401 /* Index build failed */
#define JET_errIndexHasPrimary				-1402 /* Primary index already defined */
#define JET_errIndexDuplicate				-1403 /* Index is already defined */
#define JET_errIndexNotFound				-1404 /* No such index */
#define JET_errIndexMustStay				-1405 /* Cannot delete clustered index */
#define JET_errIndexInvalidDef				-1406 /* Illegal index definition */
#define JET_errInvalidCreateIndex	 		-1409 /* Invalid create index description */
#define JET_errTooManyOpenIndexes			-1410 /* Out of index description blocks */
#define JET_errMultiValuedIndexViolation	-1411 /* Non-unique inter-record index keys generated for a multivalued index */
#define JET_errIndexBuildCorrupted			-1412 /* Failed to build a secondary index that properly reflects primary index */
#define JET_errPrimaryIndexCorrupted		-1413 /* Primary index is corrupt. The database must be defragmented */
#define JET_errSecondaryIndexCorrupted		-1414 /* Secondary index is corrupt. The database must be defragmented */
#define JET_wrnCorruptIndexDeleted			1415  /* Out of date index removed */
#define JET_errInvalidIndexId				-1416 /* Illegal index id */

#define JET_errIndexTuplesSecondaryIndexOnly		-1430	//	tuple index can only be on a secondary index
#define JET_errIndexTuplesOneColumnOnly				-1431	//	tuple index may only have one column in the index
#define JET_errIndexTuplesNonUniqueOnly				-1432	//	tuple index must be a non-unique index
#define JET_errIndexTuplesTextColumnsOnly			-1433	//	tuple index must be on a text column
#define JET_errIndexTuplesVarSegMacNotAllowed		-1434	//	tuple index does not allow setting cbVarSegMac
#define JET_errIndexTuplesInvalidLimits				-1435	//	invalid min/max tuple length or max characters to index specified
#define JET_errIndexTuplesCannotRetrieveFromIndex	-1436	//	cannot call RetrieveColumn() with RetrieveFromIndex on a tuple index
#define JET_errIndexTuplesKeyTooSmall				-1437	//	specified key does not meet minimum tuple length

#define JET_errColumnLong					-1501 /* Column value is long */
#define JET_errColumnNoChunk				-1502 /* No such chunk in long value */
#define JET_errColumnDoesNotFit 			-1503 /* Field will not fit in record */
#define JET_errNullInvalid					-1504 /* Null not valid */
#define JET_errColumnIndexed				-1505 /* Column indexed, cannot delete */
#define JET_errColumnTooBig					-1506 /* Field length is greater than maximum */
#define JET_errColumnNotFound				-1507 /* No such column */
#define JET_errColumnDuplicate				-1508 /* Field is already defined */
#define JET_errMultiValuedColumnMustBeTagged -1509 /* Attempted to create a multi-valued column, but column was not Tagged */
#define JET_errColumnRedundant				-1510 /* Second autoincrement or version column */
#define JET_errInvalidColumnType			-1511 /* Invalid column data type */
#define JET_wrnColumnMaxTruncated	 		1512  /* Max length too big, truncated */
#define JET_errTaggedNotNULL				-1514 /* No non-NULL tagged columns */
#define JET_errNoCurrentIndex				-1515 /* Invalid w/o a current index */
#define JET_errKeyIsMade					-1516 /* The key is completely made */
#define JET_errBadColumnId					-1517 /* Column Id Incorrect */
#define JET_errBadItagSequence				-1518 /* Bad itagSequence for tagged column */
#define JET_errColumnInRelationship			-1519 /* Cannot delete, column participates in relationship */
#define JET_wrnCopyLongValue				1520  /* Single instance column bursted */
#define JET_errCannotBeTagged				-1521 /* AutoIncrement and Version cannot be tagged */
#define wrnLVNoLongValues					1522  /* Table does not have a long value tree */
#define JET_wrnTaggedColumnsRemaining		1523  /* RetrieveTaggedColumnList ran out of copy buffer before retrieving all tagged columns */
#define JET_errDefaultValueTooBig			-1524 /* Default value exceeds maximum size */
#define JET_errMultiValuedDuplicate			-1525 /* Duplicate detected on a unique multi-valued column */
#define JET_errLVCorrupted					-1526 /* Corruption encountered in long-value tree */
#define wrnLVNoMoreData						1527  /* Reached end of LV data */
#define JET_errMultiValuedDuplicateAfterTruncation	-1528 /* Duplicate detected on a unique multi-valued column after data was normalized, and normalizing truncated the data before comparison */
#define JET_errDerivedColumnCorruption		-1529 /* Invalid column in derived table */
#define JET_errInvalidPlaceholderColumn		-1530 /* Tried to convert column to a primary index placeholder, but column doesn't meet necessary criteria */
#define JET_wrnColumnSkipped				1531 /* Column value(s) not returned because the corresponding column id or itagSequence requested for enumeration was null */
#define JET_wrnColumnNotLocal				1532 /* Column value(s) not returned because they could not be reconstructed from the data at hand */
#define JET_wrnColumnMoreTags				1533 /* Column values exist that were not requested for enumeration */
#define JET_wrnColumnTruncated				1534 /* Column value truncated at the requested size limit during enumeration */
#define JET_wrnColumnPresent				1535 /* Column values exist but were not returned by request */
#define JET_wrnColumnSingleValue			1536 /* Column value returned in JET_COLUMNENUM as a result of JET_bitEnumerateCompressOutput */

#define JET_errRecordNotFound				-1601 /* The key was not found */
#define JET_errRecordNoCopy					-1602 /* No working buffer */
#define JET_errNoCurrentRecord				-1603 /* Currency not on a record */
#define JET_errRecordPrimaryChanged			-1604 /* Primary key may not change */
#define JET_errKeyDuplicate					-1605 /* Illegal duplicate key */
#define JET_errAlreadyPrepared				-1607 /* Attempted to update record when record update was already in progress */
#define JET_errKeyNotMade					-1608 /* No call to JetMakeKey */
#define JET_errUpdateNotPrepared			-1609 /* No call to JetPrepareUpdate */
#define JET_wrnDataHasChanged		 		1610  /* Data has changed */
#define JET_errDataHasChanged				-1611 /* Data has changed, operation aborted */
#define JET_wrnKeyChanged			 		1618  /* Moved to new key */
#define JET_errLanguageNotSupported			-1619 /* WindowsNT installation does not support language */

#define JET_errTooManySorts					-1701 /* Too many sort processes */
#define JET_errInvalidOnSort				-1702 /* Invalid operation on Sort */
#define JET_errTempFileOpenError			-1803 /* Temp file could not be opened */
#define JET_errTooManyAttachedDatabases 	-1805 /* Too many open databases */
#define JET_errDiskFull 					-1808 /* No space left on disk */
#define JET_errPermissionDenied 			-1809 /* Permission denied */
#define JET_errFileNotFound					-1811 /* File not found */
#define JET_errFileInvalidType				-1812 /* Invalid file type */
#define JET_wrnFileOpenReadOnly				1813  /* Database file is read only */
#define JET_errAfterInitialization			-1850 /* Cannot Restore after init. */
#define JET_errLogCorrupted					-1852 /* Logs could not be interpreted */
#define JET_errInvalidOperation 			-1906 /* Invalid operation */
#define JET_errAccessDenied					-1907 /* Access denied */
#define JET_wrnIdleFull						 1908 /* Idle registry full */
#define JET_errTooManySplits				-1909 /* Infinite split */
#define	JET_errSessionSharingViolation		-1910 /* Multiple threads are using the same session */
#define JET_errEntryPointNotFound			-1911 /* An entry point in a DLL we require could not be found */
#define	JET_errSessionContextAlreadySet		-1912 /* Specified session already has a session context set */
#define JET_errSessionContextNotSetByThisThread	-1913 /* Tried to reset session context, but current thread did not orignally set the session context */
#define JET_errSessionInUse					-1914 /* Tried to terminate session in use */

#define JET_errRecordFormatConversionFailed	-1915 /* Internal error during dynamic record format conversion */
#define JET_errOneDatabasePerSession		-1916 /* Just one open user database per session is allowed (JET_paramOneDatabasePerSession) */
#define JET_errRollbackError				-1917 /* error during rollback */

#define JET_wrnDefragAlreadyRunning			2000  /* Online defrag already running on specified database */
#define JET_wrnDefragNotRunning				2001  /* Online defrag not running on specified database */

#define JET_wrnCallbackNotRegistered          2100  /* Unregistered a non-existant callback function */
#define JET_errCallbackFailed				-2101 /* A callback failed */
#define JET_errCallbackNotResolved			-2102 /* A callback function could not be found */

#define wrnSLVNoStreamingData				2200  /* Database does not have a streaming file */
#define JET_errSLVSpaceCorrupted			-2201 /* Corruption encountered in space manager of streaming file */
#define JET_errSLVCorrupted					-2202 /* Corruption encountered in streaming file */
#define JET_errSLVColumnDefaultValueNotAllowed -2203 /* SLV columns cannot have a default value */
#define JET_errSLVStreamingFileMissing		-2204 /* Cannot find streaming file associated with this database */
#define JET_errSLVDatabaseMissing			-2205 /* Streaming file exists, but database to which it belongs is missing */
#define JET_errSLVStreamingFileAlreadyExists -2206 /* Tried to create a streaming file when one already exists or is already recorded in the catalog */
#define JET_errSLVInvalidPath				-2207 /* Specified path to a streaming file is invalid */
#define JET_errSLVStreamingFileNotCreated	-2208 /* Tried to perform an SLV operation but streaming file was never created */
#define JET_errSLVStreamingFileReadOnly		-2209 /* Attach a readonly streaming file for read/write operations */
#define JET_errSLVHeaderBadChecksum			-2210 /* SLV file header failed checksum verification */
#define JET_errSLVHeaderCorrupted			-2211 /* SLV file header contains invalid information */
#define wrnSLVNoFreePages					2212  /* No free pages in SLV space tree */
#define JET_errSLVPagesNotFree				-2213 /* Tried to move pages from the Free state when they were not in that state */
#define JET_errSLVPagesNotReserved			-2214 /* Tried to move pages from the Reserved state when they were not in that state */
#define JET_errSLVPagesNotCommitted			-2215 /* Tried to move pages from the Committed state when they were not in that state */
#define JET_errSLVPagesNotDeleted			-2216 /* Tried to move pages from the Deleted state when they were not in that state */
#define JET_errSLVSpaceWriteConflict		-2217 /* Unexpected conflict detected trying to write-latch SLV space pages */
#define JET_errSLVRootStillOpen				-2218 /* The database can not be created/attached because its corresponding SLV Root is still open by another process. */
#define JET_errSLVProviderNotLoaded			-2219 /* The database can not be created/attached because the SLV Provider has not been loaded. */
#define JET_errSLVEAListCorrupt				-2220 /* The specified SLV EA List is corrupted. */
#define JET_errSLVRootNotSpecified			-2221 /* The database cannot be created/attached because the SLV Root Name was omitted */
#define JET_errSLVRootPathInvalid			-2222 /* The specified SLV Root path was invalid. */
#define JET_errSLVEAListZeroAllocation		-2223 /* The specified SLV EA List has no allocated space. */
#define JET_errSLVColumnCannotDelete		-2224 /* Deletion of SLV columns is not currently supported. */
#define JET_errSLVOwnerMapAlreadyExists 	-2225 /* Tried to create a new catalog entry for SLV Ownership Map when one already exists */
#define JET_errSLVSpaceMapAlreadyExists 	-2225 /* OBSOLETE: Renamed to JET_errSLVOwnerMapCorrupted */
#define JET_errSLVOwnerMapCorrupted			-2226 /* Corruption encountered in SLV Ownership Map */
#define JET_errSLVSpaceMapCorrupted			-2226 /* OBSOLETE: Renamed to JET_errSLVOwnerMapCorrupted */
#define JET_errSLVOwnerMapPageNotFound		-2227 /* Corruption encountered in SLV Ownership Map */
#define JET_errSLVSpaceMapPageNotFound		-2227 /* OBSOLETE: Renamed to JET_errSLVOwnerMapPageNotFound */
#define wrnOLDSLVNothingToMove				2228  /* Nothing in the streaming file can be moved */
#define errOLDSLVUnableToMove				-2228 /* Unable to move a SLV File in the streaming file */
#define JET_errSLVFileStale					-2229 /* The specified SLV File handle belongs to a SLV Root that no longer exists. */
#define JET_errSLVFileInUse					-2230 /* The specified SLV File is currently in use */
#define JET_errSLVStreamingFileInUse		-2231 /* The specified streaming file is currently in use */
#define JET_errSLVFileIO					-2232 /* An I/O error occurred while accessing an SLV File (general read / write failure) */
#define JET_errSLVStreamingFileFull			-2233 /* No space left in the streaming file */
#define JET_errSLVFileInvalidPath			-2234 /* Specified path to a SLV File was invalid */
#define JET_errSLVFileAccessDenied			-2235 /* Cannot access SLV File, the SLV File is locked or is in use */
#define JET_errSLVFileNotFound				-2236 /* The specified SLV File was not found */
#define JET_errSLVFileUnknown				-2237 /* An unknown error occurred while accessing an SLV File */
#define JET_errSLVEAListTooBig				-2238 /* The specified SLV EA List could not be returned because it is too large to fit in the standard EA format.  Retrieve the SLV File as a file handle instead. */
#define JET_errSLVProviderVersionMismatch	-2239 /* The loaded SLV Provider's version does not match the database engine's version. */
#define errSLVInvalidOwnerMapChecksum		-2240 /* checksum in OwnerMap is invalid */
#define wrnSLVDatabaseHeader				2241  /* Checking the header of a streaming file */
#define errOLDSLVMoveStopped				-2242 /* OLDSLV was stopped in the middle of a move */
#define JET_errSLVBufferTooSmall			-2243 /* Buffer allocated for SLV data or meta-data was too small */

#define JET_errOSSnapshotInvalidSequence	-2401 /* OS Snapshot API used in an invalid sequence */
#define JET_errOSSnapshotTimeOut			-2402 /* OS Snapshot ended with time-out */
#define JET_errOSSnapshotNotAllowed			-2403 /* OS Snapshot not allowed (backup or recovery in progress) */

#define JET_errLSCallbackNotSpecified		-3000 /* Attempted to use Local Storage without a callback function being specified */
#define JET_errLSAlreadySet					-3001 /* Attempted to set Local Storage for an object which already had it set */
#define JET_errLSNotSet						-3002 /* Attempted to retrieve Local Storage from an object which didn't have it set */

/** FILE ERRORS
 **/
//JET_errFileAccessDenied					-1032
//JET_errFileNotFound						-1811
//JET_errInvalidFilename					-1044
 #define JET_errFileIOBeyondEOF				-4001 /* a read was issued to a location beyond EOF (writes will expand the file) */


/**********************************************************************/
/***********************     PROTOTYPES      **************************/
/**********************************************************************/

#if !defined(_JET_NOPROTOTYPES)

#ifdef __cplusplus
extern "C" {
#endif


JET_ERR JET_API JetInit( JET_INSTANCE *pinstance);
JET_ERR JET_API JetInit2( JET_INSTANCE *pinstance, JET_GRBIT grbit );
JET_ERR JET_API JetInit3(
	JET_INSTANCE *pinstance,
	JET_RSTMAP *rgstmap,
	long crstfilemap,
	JET_GRBIT grbit );

JET_ERR JET_API JetCreateInstance( JET_INSTANCE *pinstance, const char * szInstanceName );
JET_ERR JET_API JetCreateInstance2(
	JET_INSTANCE *pinstance,
	const char * szInstanceName,
	const char * szDisplayName,
	JET_GRBIT grbit );

JET_ERR JET_API JetTerm( JET_INSTANCE instance );
JET_ERR JET_API JetTerm2( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR JET_API JetStopService();
JET_ERR JET_API JetStopServiceInstance( JET_INSTANCE instance );

JET_ERR JET_API JetStopBackup();
JET_ERR JET_API JetStopBackupInstance( JET_INSTANCE instance );

JET_ERR JET_API JetSetSystemParameter(
	JET_INSTANCE	*pinstance,
	JET_SESID		sesid,
	unsigned long	paramid,
	JET_API_PTR		lParam,
	const char		*sz );

JET_ERR JET_API JetGetSystemParameter(
	JET_INSTANCE	instance,
	JET_SESID		sesid,
	unsigned long	paramid,
	JET_API_PTR		*plParam,
	char			*sz,
	unsigned long	cbMax );

JET_ERR JET_API JetEnableMultiInstance( 	JET_SETSYSPARAM *	psetsysparam,
											unsigned long 		csetsysparam,
											unsigned long *		pcsetsucceed);

JET_ERR JET_API JetResetCounter( JET_SESID sesid, long CounterType );

JET_ERR JET_API JetGetCounter( JET_SESID sesid, long CounterType, long *plValue );

JET_ERR JET_API JetBeginSession(
	JET_INSTANCE	instance,
	JET_SESID		*psesid,
	const char		*szUserName,
	const char		*szPassword );

JET_ERR JET_API JetDupSession( JET_SESID sesid, JET_SESID *psesid );

JET_ERR JET_API JetEndSession( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR JET_API JetGetVersion( JET_SESID sesid, unsigned long *pwVersion );

JET_ERR JET_API JetIdle( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR JET_API JetCreateDatabase(
	JET_SESID		sesid,
	const char		*szFilename,
	const char		*szConnect,
	JET_DBID		*pdbid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetCreateDatabase2(
	JET_SESID		sesid,
	const char		*szFilename,
	const unsigned long	cpgDatabaseSizeMax,
	JET_DBID		*pdbid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetCreateDatabaseWithStreaming(
	JET_SESID		sesid,
	const char		*szDbFileName,
	const char		*szSLVFileName,
	const char		*szSLVRootName,
	const unsigned long	cpgDatabaseSizeMax,
	JET_DBID		*pdbid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetAttachDatabase(
	JET_SESID		sesid,
	const char		*szFilename,
	JET_GRBIT		grbit );

JET_ERR JET_API JetAttachDatabase2(
	JET_SESID		sesid,
	const char		*szFilename,
	const unsigned long	cpgDatabaseSizeMax,
	JET_GRBIT		grbit );

JET_ERR JET_API JetAttachDatabaseWithStreaming(
	JET_SESID		sesid,
	const char		*szDbFileName,
	const char		*szSLVFileName,
	const char		*szSLVRootName,
	const unsigned long	cpgDatabaseSizeMax,
	JET_GRBIT		grbit );

JET_ERR JET_API JetDetachDatabase(
	JET_SESID		sesid,
	const char		*szFilename );

JET_ERR JET_API JetDetachDatabase2(
	JET_SESID		sesid,
	const char		*szFilename,
	JET_GRBIT 		grbit);

JET_ERR JET_API JetGetObjectInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_OBJTYP		objtyp,
	const char		*szContainerName,
	const char		*szObjectName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetGetTableInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetCreateTable(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	unsigned long	lPages,
	unsigned long	lDensity,
	JET_TABLEID		*ptableid );

JET_ERR JET_API JetCreateTableColumnIndex(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_TABLECREATE	*ptablecreate );

JET_ERR JET_API JetCreateTableColumnIndex2(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_TABLECREATE2	*ptablecreate );

JET_ERR JET_API JetDeleteTable(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName );

JET_ERR JET_API JetRenameTable(
	JET_SESID sesid,
	JET_DBID dbid,
	const char *szName,
	const char *szNameNew );

JET_ERR JET_API JetGetTableColumnInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetGetColumnInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	const char		*szColumnName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetAddColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName,
	const JET_COLUMNDEF	*pcolumndef,
	const void		*pvDefault,
	unsigned long	cbDefault,
	JET_COLUMNID	*pcolumnid );

JET_ERR JET_API JetDeleteColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName );
JET_ERR JET_API JetDeleteColumn2(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName,
	const JET_GRBIT	grbit );

JET_ERR JET_API JetRenameColumn(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	const char 		*szName,
	const char 		*szNameNew,
	JET_GRBIT		grbit );

JET_ERR JET_API JetSetColumnDefaultValue(
	JET_SESID			sesid,
	JET_DBID			dbid,
	const char			*szTableName,
	const char			*szColumnName,
	const void			*pvData,
	const unsigned long	cbData,
	const JET_GRBIT		grbit );

JET_ERR JET_API JetGetTableIndexInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	void			*pvResult,
	unsigned long	cbResult,
	unsigned long	InfoLevel );

JET_ERR JET_API JetGetIndexInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	const char		*szIndexName,
	void			*pvResult,
	unsigned long	cbResult,
	unsigned long	InfoLevel );

JET_ERR JET_API JetCreateIndex(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	JET_GRBIT		grbit,
	const char		*szKey,
	unsigned long	cbKey,
	unsigned long	lDensity );

JET_ERR JET_API JetCreateIndex2(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_INDEXCREATE	*pindexcreate,
	unsigned long	cIndexCreate );

JET_ERR JET_API JetDeleteIndex(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName );

JET_ERR JET_API JetBeginTransaction( JET_SESID sesid );
JET_ERR JET_API JetBeginTransaction2( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR JET_API JetPrepareToCommitTransaction(
	JET_SESID		sesid,
	const void		* pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit );
JET_ERR JET_API JetCommitTransaction( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR JET_API JetRollback( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR JET_API JetGetDatabaseInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetGetDatabaseFileInfo(
	const char		*szDatabaseName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetOpenDatabase(
	JET_SESID		sesid,
	const char		*szFilename,
	const char		*szConnect,
	JET_DBID		*pdbid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetCloseDatabase(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetOpenTable(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	const void		*pvParameters,
	unsigned long	cbParameters,
	JET_GRBIT		grbit,
	JET_TABLEID		*ptableid );

JET_ERR JET_API JetSetTableSequential(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetResetTableSequential(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_GRBIT		grbit );
	
JET_ERR JET_API JetCloseTable( JET_SESID sesid, JET_TABLEID tableid );

JET_ERR JET_API JetDelete( JET_SESID sesid, JET_TABLEID tableid );

JET_ERR JET_API JetUpdate(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvBookmark,
	unsigned long	cbBookmark,
	unsigned long	*pcbActual);

JET_ERR JET_API JetEscrowUpdate(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	void			*pv,
	unsigned long	cbMax,
	void			*pvOld,
	unsigned long	cbOldMax,
	unsigned long	*pcbOldActual,
	JET_GRBIT		grbit );

JET_ERR JET_API JetRetrieveColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	void			*pvData,
	unsigned long	cbData,
	unsigned long	*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo );

JET_ERR JET_API JetRetrieveColumns(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_RETRIEVECOLUMN	*pretrievecolumn,
	unsigned long	cretrievecolumn );

JET_ERR JET_API JetEnumerateColumns(
	JET_SESID				sesid,
	JET_TABLEID				tableid,
	unsigned long			cEnumColumnId,
	JET_ENUMCOLUMNID*		rgEnumColumnId,
	unsigned long*			pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	unsigned long			cbDataMost,
	JET_GRBIT				grbit );

JET_ERR JET_API JetRetrieveTaggedColumnList(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	unsigned long	*pcColumns,
	void			*pvData,
	unsigned long	cbData,
	JET_COLUMNID	columnidStart,
	JET_GRBIT		grbit );

JET_ERR JET_API JetSetColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	const void		*pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit,
	JET_SETINFO		*psetinfo );

JET_ERR JET_API JetSetColumns(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_SETCOLUMN	*psetcolumn,
	unsigned long	csetcolumn );

JET_ERR JET_API JetPrepareUpdate(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	unsigned long	prep );

JET_ERR JET_API JetGetRecordPosition(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_RECPOS		*precpos,
	unsigned long	cbRecpos );

JET_ERR JET_API JetGotoPosition(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_RECPOS		*precpos );

JET_ERR JET_API JetGetCursorInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR JET_API JetDupCursor(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_TABLEID		*ptableid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetGetCurrentIndex(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	char			*szIndexName,
	unsigned long	cchIndexName );

JET_ERR JET_API JetSetCurrentIndex(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName );

JET_ERR JET_API JetSetCurrentIndex2(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	JET_GRBIT		grbit );

JET_ERR JET_API JetSetCurrentIndex3(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	JET_GRBIT		grbit,
	unsigned long	itagSequence );

JET_ERR JET_API JetSetCurrentIndex4(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	JET_INDEXID		*pindexid,
	JET_GRBIT		grbit,
	unsigned long	itagSequence );

JET_ERR JET_API JetMove(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	long			cRow,
	JET_GRBIT		grbit );

JET_ERR JET_API JetGetLock(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetMakeKey(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const void		*pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit );

JET_ERR JET_API JetSeek(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_GRBIT		grbit );

JET_ERR JET_API JetGetBookmark(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void *			pvBookmark,
	unsigned long	cbMax,
	unsigned long *	pcbActual );

JET_ERR JET_API JetGetSecondaryIndexBookmark(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void *			pvSecondaryKey,
	unsigned long	cbSecondaryKeyMax,
	unsigned long *	pcbSecondaryKeyActual,
	void *			pvPrimaryBookmark,
	unsigned long	cbPrimaryBookmarkMax,
	unsigned long *	pcbPrimaryKeyActual,
	const JET_GRBIT	grbit );

JET_ERR JET_API JetCompact(
	JET_SESID		sesid,
	const char		*szDatabaseSrc,
	const char		*szDatabaseDest,
	JET_PFNSTATUS	pfnStatus,
	JET_CONVERT		*pconvert,
	JET_GRBIT		grbit );

JET_ERR JET_API JetDefragment(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	unsigned long	*pcPasses,
	unsigned long	*pcSeconds,
	JET_GRBIT		grbit );

JET_ERR JET_API JetDefragment2(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	unsigned long	*pcPasses,
	unsigned long	*pcSeconds,
	JET_CALLBACK	callback,
	JET_GRBIT		grbit );

JET_ERR JET_API JetDefragment3(
	JET_SESID		vsesid,
	const char		*szDatabaseName,
	const char		*szTableName,
	unsigned long	*pcPasses,
	unsigned long	*pcSeconds,
	JET_CALLBACK	callback,
	void			*pvContext,
	JET_GRBIT		grbit );

JET_ERR JET_API JetConvertDDL(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_OPDDLCONV	convtyp,
	void			*pvData,
	unsigned long	cbData );

JET_ERR JET_API JetUpgradeDatabase(
	JET_SESID		sesid,
	const char		*szDbFileName,
	const char		*szSLVFileName,
	const JET_GRBIT	grbit );
	
JET_ERR JET_API JetSetDatabaseSize(
	JET_SESID		sesid,
	const char		*szDatabaseName,
	unsigned long	cpg,
	unsigned long	*pcpgReal );

JET_ERR JET_API JetGrowDatabase(
	JET_SESID		sesid,
	JET_DBID		dbid,
	unsigned long	cpg,
	unsigned long	*pcpgReal );

JET_ERR JET_API JetSetSessionContext(
	JET_SESID		sesid,
	JET_API_PTR		ulContext );

JET_ERR JET_API JetResetSessionContext(
	JET_SESID		sesid );
	
JET_ERR JET_API JetDBUtilities( JET_DBUTIL *pdbutil );	

JET_ERR JET_API JetGotoBookmark(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void *			pvBookmark,
	unsigned long	cbBookmark );

JET_ERR JET_API JetGotoSecondaryIndexBookmark(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void *			pvSecondaryKey,
	unsigned long	cbSecondaryKey,
	void *			pvPrimaryBookmark,
	unsigned long	cbPrimaryBookmark,
	const JET_GRBIT	grbit );

JET_ERR JET_API JetIntersectIndexes(
	JET_SESID sesid,
	JET_INDEXRANGE * rgindexrange,
	unsigned long cindexrange,
	JET_RECORDLIST * precordlist,
	JET_GRBIT grbit );

JET_ERR JET_API JetComputeStats( JET_SESID sesid, JET_TABLEID tableid );

JET_ERR JET_API JetOpenTempTable(JET_SESID sesid,
	const JET_COLUMNDEF *prgcolumndef, unsigned long ccolumn,
	JET_GRBIT grbit, JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid);

JET_ERR JET_API JetOpenTempTable2(
	JET_SESID			sesid,
	const JET_COLUMNDEF	*prgcolumndef,
	unsigned long		ccolumn,
	unsigned long		lcid,
	JET_GRBIT			grbit,
	JET_TABLEID			*ptableid,
	JET_COLUMNID		*prgcolumnid );

JET_ERR JET_API JetOpenTempTable3(
	JET_SESID			sesid,
	const JET_COLUMNDEF	*prgcolumndef,
	unsigned long		ccolumn,
	JET_UNICODEINDEX	*pidxunicode,
	JET_GRBIT			grbit,
	JET_TABLEID			*ptableid,
	JET_COLUMNID		*prgcolumnid );

JET_ERR JET_API JetBackup( const char *szBackupPath, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus );
JET_ERR JET_API JetBackupInstance(	JET_INSTANCE 	instance,
									const char		*szBackupPath,
									JET_GRBIT		grbit,
									JET_PFNSTATUS	pfnStatus );

JET_ERR JET_API JetRestore(const char *sz, JET_PFNSTATUS pfn );
JET_ERR JET_API JetRestore2(const char *sz, const char *szDest, JET_PFNSTATUS pfn );

JET_ERR JET_API JetRestoreInstance( 	JET_INSTANCE instance,
										const char *sz,
										const char *szDest,
										JET_PFNSTATUS pfn );

JET_ERR JET_API JetSetIndexRange(JET_SESID sesid,
	JET_TABLEID tableidSrc, JET_GRBIT grbit);

JET_ERR JET_API JetIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long *pcrec, unsigned long crecMax );

JET_ERR JET_API JetRetrieveKey(JET_SESID sesid,
	JET_TABLEID tableid, void *pvData, unsigned long cbMax,
	unsigned long *pcbActual, JET_GRBIT grbit );

JET_ERR JET_API JetBeginExternalBackup( JET_GRBIT grbit );
JET_ERR JET_API JetBeginExternalBackupInstance( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR JET_API JetGetAttachInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual );
JET_ERR JET_API JetGetAttachInfoInstance(	JET_INSTANCE	instance,
											void			*pv,
											unsigned long	cbMax,
											unsigned long	*pcbActual );

JET_ERR JET_API JetOpenFile( const char *szFileName,
	JET_HANDLE	*phfFile,
	unsigned long *pulFileSizeLow,
	unsigned long *pulFileSizeHigh );

JET_ERR JET_API JetOpenFileInstance( 	JET_INSTANCE instance,
										const char *szFileName,
										JET_HANDLE	*phfFile,
										unsigned long *pulFileSizeLow,
										unsigned long *pulFileSizeHigh );
										
JET_ERR JET_API JetOpenFileSectionInstance(
										JET_INSTANCE instance,
										char *szFile,
										JET_HANDLE *phFile,
										long iSection,
										long cSections,
										unsigned long *pulSectionSizeLow,
										long *plSectionSizeHigh);

JET_ERR JET_API JetReadFile( JET_HANDLE hfFile,
	void *pv,
	unsigned long cb,
	unsigned long *pcb );
JET_ERR JET_API JetReadFileInstance(	JET_INSTANCE instance,
										JET_HANDLE hfFile,
										void *pv,
										unsigned long cb,
										unsigned long *pcb );
JET_ERR JET_API JetAsyncReadFileInstance(	JET_INSTANCE instance,
											JET_HANDLE hfFile,
											void* pv,
											unsigned long cb,
											JET_OLP *pjolp );

JET_ERR JET_API JetCheckAsyncReadFileInstance( 	JET_INSTANCE instance,
												void *pv,
												int cb,
												unsigned long pgnoFirst );

JET_ERR JET_API JetCloseFile( JET_HANDLE hfFile );
JET_ERR JET_API JetCloseFileInstance( JET_INSTANCE instance, JET_HANDLE hfFile );

JET_ERR JET_API JetGetLogInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual );
JET_ERR JET_API JetGetLogInfoInstance(	JET_INSTANCE instance,
										void *pv,
										unsigned long cbMax,
										unsigned long *pcbActual );

#define JET_BASE_NAME_LENGTH 	3
typedef struct
	{
	unsigned long 	cbSize;
	unsigned long	ulGenLow;
	unsigned long	ulGenHigh;
	char			szBaseName[ JET_BASE_NAME_LENGTH + 1 ];
	} JET_LOGINFO;
										
JET_ERR JET_API JetGetLogInfoInstance2(	JET_INSTANCE instance,
										void *pv,
										unsigned long cbMax,
										unsigned long *pcbActual,
										JET_LOGINFO * pLogInfo);

JET_ERR JET_API JetGetTruncateLogInfoInstance(	JET_INSTANCE instance,
												void *pv,
												unsigned long cbMax,
												unsigned long *pcbActual );

JET_ERR JET_API JetTruncateLog( void );
JET_ERR JET_API JetTruncateLogInstance( JET_INSTANCE instance );

JET_ERR JET_API JetEndExternalBackup( void );
JET_ERR JET_API JetEndExternalBackupInstance( JET_INSTANCE instance );

/* Flags for JetEndExternalBackupInstance2 */
#define JET_bitBackupEndNormal				0x0001
#define JET_bitBackupEndAbort				0x0002

JET_ERR JET_API JetEndExternalBackupInstance2( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR JET_API JetExternalRestore( 	char *szCheckpointFilePath,
										char *szLogPath,
										JET_RSTMAP *rgstmap,
										long crstfilemap,
										char *szBackupLogPath,
										long genLow,
										long genHigh,
										JET_PFNSTATUS pfn );

										
JET_ERR JET_API JetExternalRestore2( 	char *szCheckpointFilePath,
										char *szLogPath,
										JET_RSTMAP *rgstmap,
										long crstfilemap,
										char *szBackupLogPath,
										JET_LOGINFO * pLogInfo,
										char *szTargetInstanceName,
										char *szTargetInstanceLogPath,
										char *szTargetInstanceCheckpointPath,
										JET_PFNSTATUS pfn );
										

JET_ERR JET_API JetSnapshotStart( 		JET_INSTANCE 		instance,
										char * 				szDatabases,
										JET_GRBIT			grbit);

JET_ERR JET_API JetSnapshotStop( 		JET_INSTANCE 		instance,
										JET_GRBIT			grbit);

JET_ERR JET_API JetRegisterCallback(
	JET_SESID               sesid,
	JET_TABLEID             tableid,
	JET_CBTYP               cbtyp,
	JET_CALLBACK    		pCallback,
	void *              	pvContext,
	JET_HANDLE              *phCallbackId );
	

JET_ERR JET_API JetUnregisterCallback(
	JET_SESID               sesid,
	JET_TABLEID             tableid,
	JET_CBTYP               cbtyp,
	JET_HANDLE              hCallbackId );

typedef struct _JET_INSTANCE_INFO
	{
	JET_INSTANCE		hInstanceId;
	char * 				szInstanceName;

	JET_API_PTR	 		cDatabases;
	char ** 			szDatabaseFileName;
	char ** 			szDatabaseDisplayName;
	char ** 			szDatabaseSLVFileName;
	} JET_INSTANCE_INFO;
	
JET_ERR JET_API JetGetInstanceInfo( unsigned long *pcInstanceInfo, JET_INSTANCE_INFO ** paInstanceInfo );

	
JET_ERR JET_API JetFreeBuffer( char *pbBuf );

JET_ERR JET_API JetSetLS(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	JET_LS			ls,
	JET_GRBIT		grbit );

JET_ERR JET_API JetGetLS(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	JET_LS			*pls,
	JET_GRBIT		grbit );

typedef JET_API_PTR JET_OSSNAPID;  	/* Snapshot Session Identifier */

JET_ERR JET_API JetOSSnapshotPrepare( JET_OSSNAPID * psnapId, const JET_GRBIT grbit );
JET_ERR JET_API JetOSSnapshotFreeze( const JET_OSSNAPID snapId, unsigned long *pcInstanceInfo, JET_INSTANCE_INFO ** paInstanceInfo, const JET_GRBIT grbit );
JET_ERR JET_API JetOSSnapshotThaw( const JET_OSSNAPID snapId, const JET_GRBIT grbit );


#ifdef	__cplusplus
}
#endif

#endif	/* _JET_NOPROTOTYPES */

#include <poppack.h>

#ifdef	__cplusplus
}
#endif

#endif	/* _JET_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\export\esebkmsg.h ===
/*
 *	ESEBKMSG.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1986-1996, Microsoft Corporation
 *	
 *	Contains declarations of additional properties and interfaces
 *	offered by Microsoft Exchange Information Store
 */

#ifndef _ESEBKMSG_
#define _ESEBKMSG_

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x0
#define FACILITY_EDB                     0x800
#define FACILITY_CALLBACK                0x7FE
#define FACILITY_BACKUP                  0x7FF


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: GENERAL_CATEGORY
//
// MessageText:
//
//  General
//
#define GENERAL_CATEGORY                 0x00000001L

//
// MessageId: ESEBACK2_CAT_RECOVER_ASYNC
//
// MessageText:
//
//  Recovery
//
#define ESEBACK2_CAT_RECOVER_ASYNC       0x00000002L

//
// MessageId: ESEBACK2_CAT_BACKUP
//
// MessageText:
//
//  Backup
//
#define ESEBACK2_CAT_BACKUP              0x00000003L

//
// MessageId: ESEBACK2_CAT_RESTORE
//
// MessageText:
//
//  Restore
//
#define ESEBACK2_CAT_RESTORE             0x00000004L

//
// MessageId: ESEBACK2_CAT_CALLBACK
//
// MessageText:
//
//  Callback
//
#define ESEBACK2_CAT_CALLBACK            0x00000005L

//
// MessageId: ESEBACK2_CAT_MAX
//
// MessageText:
//
//  <EOF>
//
#define ESEBACK2_CAT_MAX                 0x00000006L

//
//	SUCCESS
//
//
// MessageId: hrNone
//
// MessageText:
//
//  The operation was successful
//
#define hrNone                           ((HRESULT)0x00000000L)

//
//	ERRORS
//
//
// MessageId: hrNyi
//
// MessageText:
//
//  The function is not yet implemented.
//
#define hrNyi                            ((HRESULT)0xC0000001L)

//
//	ERRORS FROM CALLBACK CALLS
//
//
// MessageId: hrCBDatabaseInUse
//
// MessageText:
//
//  Database is in use.
//
#define hrCBDatabaseInUse                ((HRESULT)0xC7FE1F41L)

//
// MessageId: hrCBDatabaseNotFound
//
// MessageText:
//
//  Database not found.
//
#define hrCBDatabaseNotFound             ((HRESULT)0xC7FE1F42L)

//
// MessageId: hrCBDatabaseDisplayNameNotFound
//
// MessageText:
//
//  Display Name for database not found.
//
#define hrCBDatabaseDisplayNameNotFound  ((HRESULT)0xC7FE1F43L)

//
// MessageId: hrCBRestorePathNotProvided
//
// MessageText:
//
//  Restore path not provided.
//
#define hrCBRestorePathNotProvided       ((HRESULT)0xC7FE1F44L)

//
// MessageId: hrCBInstanceNotFound
//
// MessageText:
//
//  Instance not found
//
#define hrCBInstanceNotFound             ((HRESULT)0xC7FE1F45L)

//
// MessageId: hrCBDatabaseCantBeOverwritten
//
// MessageText:
//
//  Database can not be overwritten by a restore.
//
#define hrCBDatabaseCantBeOverwritten    ((HRESULT)0xC7FE1F46L)

//
//	Backup errors
//
//
// MessageId: hrInvalidParam
//
// MessageText:
//
//  The parameter is not valid.
//
#define hrInvalidParam                   ((HRESULT)0xC7FF07D1L)

//
// MessageId: hrError
//
// MessageText:
//
//  An internal error has occurred.
//
#define hrError                          ((HRESULT)0xC7FF07D2L)

//
// MessageId: hrInvalidHandle
//
// MessageText:
//
//  The handle is not valid.
//
#define hrInvalidHandle                  ((HRESULT)0xC7FF07D3L)

//
// MessageId: hrRestoreInProgress
//
// MessageText:
//
//  The Restore process is already in progress.
//
#define hrRestoreInProgress              ((HRESULT)0xC7FF07D4L)

//
// MessageId: hrAlreadyOpen
//
// MessageText:
//
//  The file specified is already open.
//
#define hrAlreadyOpen                    ((HRESULT)0xC7FF07D5L)

//
// MessageId: hrInvalidRecips
//
// MessageText:
//
//  The recipients are invalid.
//
#define hrInvalidRecips                  ((HRESULT)0xC7FF07D6L)

//
// MessageId: hrCouldNotConnect
//
// MessageText:
//
//  Unable to perform the operation. Either you can not connect to the specified server 
//  or the service you are trying to connect to is not running.
//
#define hrCouldNotConnect                ((HRESULT)0xC7FF07D7L)

//
// MessageId: hrRestoreMapExists
//
// MessageText:
//
//  A restore map already exists for the specified component.  You can only specify
//  a restore map when performing a full restore.
//
#define hrRestoreMapExists               ((HRESULT)0xC7FF07D8L)

//
// MessageId: hrIncrementalBackupDisabled
//
// MessageText:
//
//  Another application has modified the specified Microsoft Exchange database such that any
//  subsequent backups will fail. You must perform a full backup to fix this problem.
//
#define hrIncrementalBackupDisabled      ((HRESULT)0xC7FF07D9L)

//
// MessageId: hrLogFileNotFound
//
// MessageText:
//
//  Unable to perform an incremental backup because a required Microsoft Exchange database log file could not be found.
//
#define hrLogFileNotFound                ((HRESULT)0xC7FF07DAL)

//
// MessageId: hrCircularLogging
//
// MessageText:
//
//  The Microsoft Exchange component specified is configured to use circular database logs.
//  It cannot be backed up without a full backup.
//
#define hrCircularLogging                ((HRESULT)0xC7FF07DBL)

//
// MessageId: hrNoFullRestore
//
// MessageText:
//
//  The databases have not been restored to this machine. You cannot restore an incremental backup
//  until a full backup has been restored.
//
#define hrNoFullRestore                  ((HRESULT)0xC7FF07DCL)

//
// MessageId: hrCommunicationError
//
// MessageText:
//
//  A communications error occurred while attempting to perform a local backup.
//
#define hrCommunicationError             ((HRESULT)0xC7FF07DDL)

//
// MessageId: hrFullBackupNotTaken
//
// MessageText:
//
//  You must perform a full backup before you can perform an incremental backup.
//
#define hrFullBackupNotTaken             ((HRESULT)0xC7FF07DEL)

//
// MessageId: hrSnapshotNotSupported
//
// MessageText:
//
//  Snapshot backup not supported by server.
//
#define hrSnapshotNotSupported           ((HRESULT)0xC7FF07DFL)

//
// MessageId: hrFailedToConvertWszFnameToSzFName
//
// MessageText:
//
//  Wide char name provided can't be converted to char name.
//
#define hrFailedToConvertWszFnameToSzFName ((HRESULT)0xC7FF0BB8L)

//
// MessageId: hrOpenRestoreEnvFailed
//
// MessageText:
//
//  The restore environment information isn't found.
//
#define hrOpenRestoreEnvFailed           ((HRESULT)0xC7FF0BB9L)

//
// MessageId: hrBadDatabaseName
//
// MessageText:
//
//  Database name provided is invalid.
//
#define hrBadDatabaseName                ((HRESULT)0xC7FF0BBAL)

//
// MessageId: hrBadTargetDatabaseName
//
// MessageText:
//
//  Destination database name provided is invalid.
//
#define hrBadTargetDatabaseName          ((HRESULT)0xC7FF0BBBL)

//
// MessageId: hrRestoreEnvWriteFailed
//
// MessageText:
//
//  Error writing restore environment information.
//
#define hrRestoreEnvWriteFailed          ((HRESULT)0xC7FF0BBCL)

//
// MessageId: hrBadRestoreLogFilePath
//
// MessageText:
//
//  The path provided for restore log files is invalid.
//
#define hrBadRestoreLogFilePath          ((HRESULT)0xC7FF0BBDL)

//
// MessageId: hrLoadCallbackFunctionFailed
//
// MessageText:
//
//  Error loading callback function.
//
#define hrLoadCallbackFunctionFailed     ((HRESULT)0xC7FF0BBEL)

//
// MessageId: hrLoadBackupCallbackDllFailed
//
// MessageText:
//
//  Error loading DLL for backup callbacks.
//
#define hrLoadBackupCallbackDllFailed    ((HRESULT)0xC7FF0BBFL)

//
// MessageId: hrLoadRestoreCallbackDllFailed
//
// MessageText:
//
//  Error loading DLL for restore callbacks.
//
#define hrLoadRestoreCallbackDllFailed   ((HRESULT)0xC7FF0BC0L)

//
// MessageId: hrWrnNoCallbackFunction
//
// MessageText:
//
//  Callback function not provided.
//
#define hrWrnNoCallbackFunction          ((HRESULT)0x87FF0BC1L)

//
// MessageId: hrBadFilePath
//
// MessageText:
//
//  File path provided is invalid.
//
#define hrBadFilePath                    ((HRESULT)0xC7FF0BC2L)

//
// MessageId: hrRestoreEnvCorrupted
//
// MessageText:
//
//  Restore environment information corrupted.
//
#define hrRestoreEnvCorrupted            ((HRESULT)0xC7FF0BC3L)

//
// MessageId: hrBadCSectionParameter
//
// MessageText:
//
//  Invalid parameter for number of file sections.
//
#define hrBadCSectionParameter           ((HRESULT)0xC7FF0BC4L)

//
// MessageId: hrBadFileNameToBackup
//
// MessageText:
//
//  Backup file name provided is invalid.
//
#define hrBadFileNameToBackup            ((HRESULT)0xC7FF0BC5L)

//
// MessageId: hrRestoreEnvUpdateFailed
//
// MessageText:
//
//  Error updating restore environment information.
//
#define hrRestoreEnvUpdateFailed         ((HRESULT)0x87FF0BC6L)

//
// MessageId: hrInvalidDestinationNameReturnedByServer
//
// MessageText:
//
//  Destination name returned by server is invalid.
//
#define hrInvalidDestinationNameReturnedByServer ((HRESULT)0xC7FF0BC7L)

//
// MessageId: hrLoadCallbackDllFailed
//
// MessageText:
//
//  Error loading DLL for callbacks.
//
#define hrLoadCallbackDllFailed          ((HRESULT)0xC7FF0BC8L)

//
// MessageId: hrAlreadyRegistered
//
// MessageText:
//
//  Already registered for backup and/or restore.
//
#define hrAlreadyRegistered              ((HRESULT)0xC7FF0BC9L)

//
// MessageId: hrLoadResourceFailed
//
// MessageText:
//
//  Error loading a resource.
//
#define hrLoadResourceFailed             ((HRESULT)0xC7FF0BCAL)

//
// MessageId: hrErrorNoCallbackFunction
//
// MessageText:
//
//  Callback function not provided.
//
#define hrErrorNoCallbackFunction        ((HRESULT)0xC7FF0BCBL)

//
// MessageId: hrLogBaseNameMismatch
//
// MessageText:
//
//  The log file base name does not match the one from previous logs.
//
#define hrLogBaseNameMismatch            ((HRESULT)0xC7FF0BCCL)

//
// MessageId: hrDestinationDatabaseInUse
//
// MessageText:
//
//  The database destination to restore to is in use.
//
#define hrDestinationDatabaseInUse       ((HRESULT)0xC7FF0BCDL)

//
// MessageId: hrRestoreEnvSharingViolation
//
// MessageText:
//
//  The restore environment is used by an other process.
//
#define hrRestoreEnvSharingViolation     ((HRESULT)0xC7FF0BCEL)

//
// MessageId: hrCallbackBackupInfoError
//
// MessageText:
//
//  The backup information returned by the server callback is invalid.
//
#define hrCallbackBackupInfoError        ((HRESULT)0xC7FF0BCFL)

//
// MessageId: hrInvalidCallSequence
//
// MessageText:
//
//  Functions called in an invalid sequence.
//
#define hrInvalidCallSequence            ((HRESULT)0xC7FF0FA4L)

//
// MessageId: hrRestoreAtFileLevel
//
// MessageText:
//
//  Restoring must be done by restoring the file.
//
#define hrRestoreAtFileLevel             ((HRESULT)0xC7FF0FA5L)

//
// MessageId: hrErrorFromESECall
//
// MessageText:
//
//  Error returned from an ESE function call (%d).
//
#define hrErrorFromESECall               ((HRESULT)0xC7FF1004L)

//
// MessageId: hrErrorFromCallbackCall
//
// MessageText:
//
//  Error returned from a callback function call (0x%X).
//
#define hrErrorFromCallbackCall          ((HRESULT)0xC7FF1005L)

#define	hrAlreadyListening	((HRESULT)RPC_S_ALREADY_LISTENING)
//
//	ERRORS
//
//
// SYSTEM errors
//
//
// MessageId: hrFileClose
//
// MessageText:
//
//  Unable to close the DOS file
//
#define hrFileClose                      ((HRESULT)0xC8000066L)

//
// MessageId: hrOutOfThreads
//
// MessageText:
//
//  Unable to start a thread because there are none available.
//
#define hrOutOfThreads                   ((HRESULT)0xC8000067L)

//
// MessageId: hrTooManyIO
//
// MessageText:
//
//  The system is busy because there are too many I/Os.
//
#define hrTooManyIO                      ((HRESULT)0xC8000069L)

//
//	BUFFER MANAGER errors
//
//
// MessageId: hrBFNotSynchronous
//
// MessageText:
//
//  The buffer page has been evicted.
//
#define hrBFNotSynchronous               ((HRESULT)0x880000C8L)

//
// MessageId: hrBFPageNotFound
//
// MessageText:
//
//  Unable to find the page.
//
#define hrBFPageNotFound                 ((HRESULT)0x880000C9L)

//
// MessageId: hrBFInUse
//
// MessageText:
//
//  Unable to abandon the buffer.
//
#define hrBFInUse                        ((HRESULT)0xC80000CAL)

//
//	DIRECTORY MANAGER errors
//
//
// MessageId: hrPMRecDeleted
//
// MessageText:
//
//  The record has been deleted.
//
#define hrPMRecDeleted                   ((HRESULT)0xC800012EL)

//
// MessageId: hrRemainingVersions
//
// MessageText:
//
//  There is idle work remaining.
//
#define hrRemainingVersions              ((HRESULT)0x88000141L)

//
//	RECORD MANAGER errors
//
//
// MessageId: hrFLDKeyTooBig
//
// MessageText:
//
//  The key was truncated because it is more than 255 bytes.
//
#define hrFLDKeyTooBig                   ((HRESULT)0x88000190L)

//
// MessageId: hrFLDTooManySegments
//
// MessageText:
//
//  There are too many key segments.
//
#define hrFLDTooManySegments             ((HRESULT)0xC8000191L)

//
// MessageId: hrFLDNullKey
//
// MessageText:
//
//  The key is NULL.
//
#define hrFLDNullKey                     ((HRESULT)0x88000192L)

//
//	LOGGING/RECOVERY errors
//
//
// MessageId: hrLogFileCorrupt
//
// MessageText:
//
//  The log file is damaged.
//
#define hrLogFileCorrupt                 ((HRESULT)0xC80001F5L)

//
// MessageId: hrNoBackupDirectory
//
// MessageText:
//
//  No backup directory was given.
//
#define hrNoBackupDirectory              ((HRESULT)0xC80001F7L)

//
// MessageId: hrBackupDirectoryNotEmpty
//
// MessageText:
//
//  The backup directory is not empty.
//
#define hrBackupDirectoryNotEmpty        ((HRESULT)0xC80001F8L)

//
// MessageId: hrBackupInProgress
//
// MessageText:
//
//  Backup is already active.
//
#define hrBackupInProgress               ((HRESULT)0xC80001F9L)

//
// MessageId: hrMissingPreviousLogFile
//
// MessageText:
//
//  A log file for the checkpoint is missing.
//
#define hrMissingPreviousLogFile         ((HRESULT)0xC80001FDL)

//
// MessageId: hrLogWriteFail
//
// MessageText:
//
//  Unable to write to the log file.
//
#define hrLogWriteFail                   ((HRESULT)0xC80001FEL)

//
// MessageId: hrBadLogVersion
//
// MessageText:
//
//  The version of the log file is not compatible with the version of the Microsoft Exchange Server database (EDB).
//
#define hrBadLogVersion                  ((HRESULT)0xC8000202L)

//
// MessageId: hrInvalidLogSequence
//
// MessageText:
//
//  The time stamp in the next log does not match what was expected.
//
#define hrInvalidLogSequence             ((HRESULT)0xC8000203L)

//
// MessageId: hrLoggingDisabled
//
// MessageText:
//
//  The log is not active.
//
#define hrLoggingDisabled                ((HRESULT)0xC8000204L)

//
// MessageId: hrLogBufferTooSmall
//
// MessageText:
//
//  The log buffer is too small to be recovered.
//
#define hrLogBufferTooSmall              ((HRESULT)0xC8000205L)

//
// MessageId: hrLogSequenceEnd
//
// MessageText:
//
//  The maximum number of log files has been exceeded.
//
#define hrLogSequenceEnd                 ((HRESULT)0xC8000207L)

//
// MessageId: hrNoBackup
//
// MessageText:
//
//  There is no backup in progress.
//
#define hrNoBackup                       ((HRESULT)0xC8000208L)

//
// MessageId: hrInvalidBackupSequence
//
// MessageText:
//
//  The backup call is out of sequence.
//
#define hrInvalidBackupSequence          ((HRESULT)0xC8000209L)

//
// MessageId: hrBackupNotAllowedYet
//
// MessageText:
//
//  Unable to perform a backup now.
//
#define hrBackupNotAllowedYet            ((HRESULT)0xC800020BL)

//
// MessageId: hrDeleteBackupFileFail
//
// MessageText:
//
//  Unable to delete the backup file.
//
#define hrDeleteBackupFileFail           ((HRESULT)0xC800020CL)

//
// MessageId: hrMakeBackupDirectoryFail
//
// MessageText:
//
//  Unable to make a backup temporary directory.
//
#define hrMakeBackupDirectoryFail        ((HRESULT)0xC800020DL)

//
// MessageId: hrInvalidBackup
//
// MessageText:
//
//  An incremental backup cannot be performed when circular logging is enabled.
//
#define hrInvalidBackup                  ((HRESULT)0xC800020EL)

//
// MessageId: hrRecoveredWithErrors
//
// MessageText:
//
//  Errors were encountered during the repair process.
//
#define hrRecoveredWithErrors            ((HRESULT)0xC800020FL)

//
// MessageId: hrMissingLogFile
//
// MessageText:
//
//  The current log file is missing.
//
#define hrMissingLogFile                 ((HRESULT)0xC8000210L)

//
// MessageId: hrLogDiskFull
//
// MessageText:
//
//  The log disk is full.
//
#define hrLogDiskFull                    ((HRESULT)0xC8000211L)

//
// MessageId: hrBadLogSignature
//
// MessageText:
//
//  A log file is damaged.
//
#define hrBadLogSignature                ((HRESULT)0xC8000212L)

//
// MessageId: hrBadDbSignature
//
// MessageText:
//
//  A database file is damaged.
//
#define hrBadDbSignature                 ((HRESULT)0xC8000213L)

//
// MessageId: hrBadCheckpointSignature
//
// MessageText:
//
//  A checkpoint file is damaged.
//
#define hrBadCheckpointSignature         ((HRESULT)0xC8000214L)

//
// MessageId: hrCheckpointCorrupt
//
// MessageText:
//
//  A checkpoint file either could not be found or is damaged.
//
#define hrCheckpointCorrupt              ((HRESULT)0xC8000215L)

//
// MessageId: hrDatabaseInconsistent
//
// MessageText:
//
//  The database is damaged.
//
#define hrDatabaseInconsistent           ((HRESULT)0xC8000226L)

//
// MessageId: hrConsistentTimeMismatch
//
// MessageText:
//
//  There is a mismatch in the database's last consistent time.
//
#define hrConsistentTimeMismatch         ((HRESULT)0xC8000227L)

//
// MessageId: hrPatchFileMismatch
//
// MessageText:
//
//  The patch file is not generated from this backup.
//
#define hrPatchFileMismatch              ((HRESULT)0xC8000228L)

//
// MessageId: hrRestoreLogTooLow
//
// MessageText:
//
//  The starting log number is too low for the restore.
//
#define hrRestoreLogTooLow               ((HRESULT)0xC8000229L)

//
// MessageId: hrRestoreLogTooHigh
//
// MessageText:
//
//  The starting log number is too high for the restore.
//
#define hrRestoreLogTooHigh              ((HRESULT)0xC800022AL)

//
// MessageId: hrGivenLogFileHasBadSignature
//
// MessageText:
//
//  The log file downloaded from the tape is damaged.
//
#define hrGivenLogFileHasBadSignature    ((HRESULT)0xC800022BL)

//
// MessageId: hrGivenLogFileIsNotContiguous
//
// MessageText:
//
//  Unable to find a mandatory log file after the tape was downloaded.
//
#define hrGivenLogFileIsNotContiguous    ((HRESULT)0xC800022CL)

//
// MessageId: hrMissingRestoreLogFiles
//
// MessageText:
//
//  The data is not fully restored because some log files are missing.
//
#define hrMissingRestoreLogFiles         ((HRESULT)0xC800022DL)

//
// MessageId: hrExistingLogFileHasBadSignature
//
// MessageText:
//
//  The log file in the log file path is damaged.
//
#define hrExistingLogFileHasBadSignature ((HRESULT)0x8800022EL)

//
// MessageId: hrExistingLogFileIsNotContiguous
//
// MessageText:
//
//  Unable to find a mandatory log file in the log file path.
//
#define hrExistingLogFileIsNotContiguous ((HRESULT)0x8800022FL)

//
// MessageId: hrMissingFullBackup
//
// MessageText:
//
//  The database missed a previous full backup before the incremental backup.
//
#define hrMissingFullBackup              ((HRESULT)0xC8000230L)

//
// MessageId: hrBadBackupDatabaseSize
//
// MessageText:
//
//  The backup database size must be a multiple of 4K (4096 bytes).
//
#define hrBadBackupDatabaseSize          ((HRESULT)0xC8000231L)

//
// MessageId: hrMissingBackupFiles
//
// MessageText:
//
//  Some log or patch files are missing.
//
#define hrMissingBackupFiles             ((HRESULT)0xC8000232L)

//
// MessageId: hrTermInProgress
//
// MessageText:
//
//  The database is being shut down.
//
#define hrTermInProgress                 ((HRESULT)0xC80003E8L)

//
// MessageId: hrFeatureNotAvailable
//
// MessageText:
//
//  The feature is not available.
//
#define hrFeatureNotAvailable            ((HRESULT)0xC80003E9L)

//
// MessageId: hrInvalidName
//
// MessageText:
//
//  The name is not valid.
//
#define hrInvalidName                    ((HRESULT)0xC80003EAL)

//
// MessageId: hrInvalidParameter
//
// MessageText:
//
//  The parameter is not valid.
//
#define hrInvalidParameter               ((HRESULT)0xC80003EBL)

//
// MessageId: hrColumnNull
//
// MessageText:
//
//  The value of the column is null.
//
#define hrColumnNull                     ((HRESULT)0x880003ECL)

//
// MessageId: hrBufferTruncated
//
// MessageText:
//
//  The buffer is too small for data.
//
#define hrBufferTruncated                ((HRESULT)0x880003EEL)

//
// MessageId: hrDatabaseAttached
//
// MessageText:
//
//  The database is already attached.
//
#define hrDatabaseAttached               ((HRESULT)0x880003EFL)

//
// MessageId: hrInvalidDatabaseId
//
// MessageText:
//
//  The database ID is not valid.
//
#define hrInvalidDatabaseId              ((HRESULT)0xC80003F2L)

//
// MessageId: hrOutOfMemory
//
// MessageText:
//
//  The computer is out of memory.
//
#define hrOutOfMemory                    ((HRESULT)0xC80003F3L)

//
// MessageId: hrOutOfDatabaseSpace
//
// MessageText:
//
//  The database has reached the maximum size of 16 GB.
//
#define hrOutOfDatabaseSpace             ((HRESULT)0xC80003F4L)

//
// MessageId: hrOutOfCursors
//
// MessageText:
//
//  Out of table cursors.
//
#define hrOutOfCursors                   ((HRESULT)0xC80003F5L)

//
// MessageId: hrOutOfBuffers
//
// MessageText:
//
//  Out of database page buffers.
//
#define hrOutOfBuffers                   ((HRESULT)0xC80003F6L)

//
// MessageId: hrTooManyIndexes
//
// MessageText:
//
//  There are too many indexes.
//
#define hrTooManyIndexes                 ((HRESULT)0xC80003F7L)

//
// MessageId: hrTooManyKeys
//
// MessageText:
//
//  There are too many columns in an index.
//
#define hrTooManyKeys                    ((HRESULT)0xC80003F8L)

//
// MessageId: hrRecordDeleted
//
// MessageText:
//
//  The record has been deleted.
//
#define hrRecordDeleted                  ((HRESULT)0xC80003F9L)

//
// MessageId: hrReadVerifyFailure
//
// MessageText:
//
//  A read verification error occurred.
//
#define hrReadVerifyFailure              ((HRESULT)0xC80003FAL)

//
// MessageId: hrOutOfFileHandles
//
// MessageText:
//
//  Out of file handles.
//
#define hrOutOfFileHandles               ((HRESULT)0xC80003FCL)

//
// MessageId: hrDiskIO
//
// MessageText:
//
//  A disk I/O error occurred.
//
#define hrDiskIO                         ((HRESULT)0xC80003FEL)

//
// MessageId: hrInvalidPath
//
// MessageText:
//
//  The path to the file is not valid.
//
#define hrInvalidPath                    ((HRESULT)0xC80003FFL)

//
// MessageId: hrRecordTooBig
//
// MessageText:
//
//  The record has exceeded the maximum size.
//
#define hrRecordTooBig                   ((HRESULT)0xC8000402L)

//
// MessageId: hrTooManyOpenDatabases
//
// MessageText:
//
//  There are too many open databases.
//
#define hrTooManyOpenDatabases           ((HRESULT)0xC8000403L)

//
// MessageId: hrInvalidDatabase
//
// MessageText:
//
//  The file is not a database file.
//
#define hrInvalidDatabase                ((HRESULT)0xC8000404L)

//
// MessageId: hrNotInitialized
//
// MessageText:
//
//  The database was not yet called.
//
#define hrNotInitialized                 ((HRESULT)0xC8000405L)

//
// MessageId: hrAlreadyInitialized
//
// MessageText:
//
//  The database was already called.
//
#define hrAlreadyInitialized             ((HRESULT)0xC8000406L)

//
// MessageId: hrFileAccessDenied
//
// MessageText:
//
//  Unable to access the file.
//
#define hrFileAccessDenied               ((HRESULT)0xC8000408L)

//
// MessageId: hrBufferTooSmall
//
// MessageText:
//
//  The buffer is too small.
//
#define hrBufferTooSmall                 ((HRESULT)0xC800040EL)

//
// MessageId: hrSeekNotEqual
//
// MessageText:
//
//  Either SeekLE or SeekGE did not find an exact match.
//
#define hrSeekNotEqual                   ((HRESULT)0x8800040FL)

//
// MessageId: hrTooManyColumns
//
// MessageText:
//
//  There are too many columns defined.
//
#define hrTooManyColumns                 ((HRESULT)0xC8000410L)

//
// MessageId: hrContainerNotEmpty
//
// MessageText:
//
//  The container is not empty.
//
#define hrContainerNotEmpty              ((HRESULT)0xC8000413L)

//
// MessageId: hrInvalidFilename
//
// MessageText:
//
//  The filename is not valid.
//
#define hrInvalidFilename                ((HRESULT)0xC8000414L)

//
// MessageId: hrInvalidBookmark
//
// MessageText:
//
//  The bookmark is not valid.
//
#define hrInvalidBookmark                ((HRESULT)0xC8000415L)

//
// MessageId: hrColumnInUse
//
// MessageText:
//
//  The column is used in an index.
//
#define hrColumnInUse                    ((HRESULT)0xC8000416L)

//
// MessageId: hrInvalidBufferSize
//
// MessageText:
//
//  The data buffer does not match the column size.
//
#define hrInvalidBufferSize              ((HRESULT)0xC8000417L)

//
// MessageId: hrColumnNotUpdatable
//
// MessageText:
//
//  Unable to set the column value.
//
#define hrColumnNotUpdatable             ((HRESULT)0xC8000418L)

//
// MessageId: hrIndexInUse
//
// MessageText:
//
//  The index is in use.
//
#define hrIndexInUse                     ((HRESULT)0xC800041BL)

//
// MessageId: hrNullKeyDisallowed
//
// MessageText:
//
//  Null keys are not allowed on an index.
//
#define hrNullKeyDisallowed              ((HRESULT)0xC800041DL)

//
// MessageId: hrNotInTransaction
//
// MessageText:
//
//  The operation must be within a transaction.
//
#define hrNotInTransaction               ((HRESULT)0xC800041EL)

//
// MessageId: hrNoIdleActivity
//
// MessageText:
//
//  No idle activity occured.
//
#define hrNoIdleActivity                 ((HRESULT)0x88000422L)

//
// MessageId: hrTooManyActiveUsers
//
// MessageText:
//
//  There are too many active database users.
//
#define hrTooManyActiveUsers             ((HRESULT)0xC8000423L)

//
// MessageId: hrInvalidCountry
//
// MessageText:
//
//  The country code is either not known or is not valid.
//
#define hrInvalidCountry                 ((HRESULT)0xC8000425L)

//
// MessageId: hrInvalidLanguageId
//
// MessageText:
//
//  The language ID is either not known or is not valid.
//
#define hrInvalidLanguageId              ((HRESULT)0xC8000426L)

//
// MessageId: hrInvalidCodePage
//
// MessageText:
//
//  The code page is either not known or is not valid.
//
#define hrInvalidCodePage                ((HRESULT)0xC8000427L)

//
// MessageId: hrNoWriteLock
//
// MessageText:
//
//  There is no write lock at transaction level 0.
//
#define hrNoWriteLock                    ((HRESULT)0x8800042BL)

//
// MessageId: hrColumnSetNull
//
// MessageText:
//
//  The column value is set to null.
//
#define hrColumnSetNull                  ((HRESULT)0x8800042CL)

//
// MessageId: hrVersionStoreOutOfMemory
//
// MessageText:
//
//   lMaxVerPages exceeded (XJET only)
//
#define hrVersionStoreOutOfMemory        ((HRESULT)0xC800042DL)

//
// MessageId: hrCurrencyStackOutOfMemory
//
// MessageText:
//
//  Out of cursors.
//
#define hrCurrencyStackOutOfMemory       ((HRESULT)0xC800042EL)

//
// MessageId: hrOutOfSessions
//
// MessageText:
//
//  Out of sessions.
//
#define hrOutOfSessions                  ((HRESULT)0xC800044DL)

//
// MessageId: hrWriteConflict
//
// MessageText:
//
//  The write lock failed due to an outstanding write lock.
//
#define hrWriteConflict                  ((HRESULT)0xC800044EL)

//
// MessageId: hrTransTooDeep
//
// MessageText:
//
//  The transactions are nested too deeply.
//
#define hrTransTooDeep                   ((HRESULT)0xC800044FL)

//
// MessageId: hrInvalidSesid
//
// MessageText:
//
//  The session handle is not valid.
//
#define hrInvalidSesid                   ((HRESULT)0xC8000450L)

//
// MessageId: hrSessionWriteConflict
//
// MessageText:
//
//  Another session has a private version of the page.
//
#define hrSessionWriteConflict           ((HRESULT)0xC8000453L)

//
// MessageId: hrInTransaction
//
// MessageText:
//
//  The operation is not allowed within a transaction.
//
#define hrInTransaction                  ((HRESULT)0xC8000454L)

//
// MessageId: hrDatabaseDuplicate
//
// MessageText:
//
//  The database already exists.
//
#define hrDatabaseDuplicate              ((HRESULT)0xC80004B1L)

//
// MessageId: hrDatabaseInUse
//
// MessageText:
//
//  The database is in use.
//
#define hrDatabaseInUse                  ((HRESULT)0xC80004B2L)

//
// MessageId: hrDatabaseNotFound
//
// MessageText:
//
//  The database is not mounted or does not exist.
//
#define hrDatabaseNotFound               ((HRESULT)0xC80004B3L)

//
// MessageId: hrDatabaseInvalidName
//
// MessageText:
//
//  The database name is not valid.
//
#define hrDatabaseInvalidName            ((HRESULT)0xC80004B4L)

//
// MessageId: hrDatabaseInvalidPages
//
// MessageText:
//
//  The number of pages is not valid.
//
#define hrDatabaseInvalidPages           ((HRESULT)0xC80004B5L)

//
// MessageId: hrDatabaseCorrupted
//
// MessageText:
//
//  The database file is either damaged or cannot be found.
//
#define hrDatabaseCorrupted              ((HRESULT)0xC80004B6L)

//
// MessageId: hrDatabaseLocked
//
// MessageText:
//
//  The database is locked.
//
#define hrDatabaseLocked                 ((HRESULT)0xC80004B7L)

//
// MessageId: hrTableEmpty
//
// MessageText:
//
//  An empty table was opened.
//
#define hrTableEmpty                     ((HRESULT)0x88000515L)

//
// MessageId: hrTableLocked
//
// MessageText:
//
//  The table is locked.
//
#define hrTableLocked                    ((HRESULT)0xC8000516L)

//
// MessageId: hrTableDuplicate
//
// MessageText:
//
//  The table already exists.
//
#define hrTableDuplicate                 ((HRESULT)0xC8000517L)

//
// MessageId: hrTableInUse
//
// MessageText:
//
//  Unable to lock the table because it is already in use.
//
#define hrTableInUse                     ((HRESULT)0xC8000518L)

//
// MessageId: hrObjectNotFound
//
// MessageText:
//
//  The table or object does not exist.
//
#define hrObjectNotFound                 ((HRESULT)0xC8000519L)

//
// MessageId: hrCannotRename
//
// MessageText:
//
//  Unable to rename the temporary file.
//
#define hrCannotRename                   ((HRESULT)0xC800051AL)

//
// MessageId: hrDensityInvalid
//
// MessageText:
//
//  The file/index density is not valid.
//
#define hrDensityInvalid                 ((HRESULT)0xC800051BL)

//
// MessageId: hrTableNotEmpty
//
// MessageText:
//
//  Unable to define the clustered index.
//
#define hrTableNotEmpty                  ((HRESULT)0xC800051CL)

//
// MessageId: hrInvalidTableId
//
// MessageText:
//
//  The table ID is not valid.
//
#define hrInvalidTableId                 ((HRESULT)0xC800051EL)

//
// MessageId: hrTooManyOpenTables
//
// MessageText:
//
//  Unable to open any more tables.
//
#define hrTooManyOpenTables              ((HRESULT)0xC800051FL)

//
// MessageId: hrIllegalOperation
//
// MessageText:
//
//  The operation is not supported on tables.
//
#define hrIllegalOperation               ((HRESULT)0xC8000520L)

//
// MessageId: hrObjectDuplicate
//
// MessageText:
//
//  The table or object name is already being used.
//
#define hrObjectDuplicate                ((HRESULT)0xC8000522L)

//
// MessageId: hrInvalidObject
//
// MessageText:
//
//  The object is not valid for operation.
//
#define hrInvalidObject                  ((HRESULT)0xC8000524L)

//
// MessageId: hrIndexCantBuild
//
// MessageText:
//
//  Unable to build a clustered index.
//
#define hrIndexCantBuild                 ((HRESULT)0xC8000579L)

//
// MessageId: hrIndexHasPrimary
//
// MessageText:
//
//  The primary index is already defined.
//
#define hrIndexHasPrimary                ((HRESULT)0xC800057AL)

//
// MessageId: hrIndexDuplicate
//
// MessageText:
//
//  The index is already defined.
//
#define hrIndexDuplicate                 ((HRESULT)0xC800057BL)

//
// MessageId: hrIndexNotFound
//
// MessageText:
//
//  The index does not exist.
//
#define hrIndexNotFound                  ((HRESULT)0xC800057CL)

//
// MessageId: hrIndexMustStay
//
// MessageText:
//
//  Unable to delete a clustered index.
//
#define hrIndexMustStay                  ((HRESULT)0xC800057DL)

//
// MessageId: hrIndexInvalidDef
//
// MessageText:
//
//  The index definition is illegal.
//
#define hrIndexInvalidDef                ((HRESULT)0xC800057EL)

//
// MessageId: hrIndexHasClustered
//
// MessageText:
//
//  The clustered index is already defined.
//
#define hrIndexHasClustered              ((HRESULT)0xC8000580L)

//
// MessageId: hrCreateIndexFailed
//
// MessageText:
//
//  Unable to create the index because an error occurred while creating a table.
//
#define hrCreateIndexFailed              ((HRESULT)0x88000581L)

//
// MessageId: hrTooManyOpenIndexes
//
// MessageText:
//
//  Out of index description blocks.
//
#define hrTooManyOpenIndexes             ((HRESULT)0xC8000582L)

//
// MessageId: hrColumnLong
//
// MessageText:
//
//  The column value is too long.
//
#define hrColumnLong                     ((HRESULT)0xC80005DDL)

//
// MessageId: hrColumnDoesNotFit
//
// MessageText:
//
//  The field will not fit in the record.
//
#define hrColumnDoesNotFit               ((HRESULT)0xC80005DFL)

//
// MessageId: hrNullInvalid
//
// MessageText:
//
//  The value cannot be null.
//
#define hrNullInvalid                    ((HRESULT)0xC80005E0L)

//
// MessageId: hrColumnIndexed
//
// MessageText:
//
//  Unable to delete because the column is indexed.
//
#define hrColumnIndexed                  ((HRESULT)0xC80005E1L)

//
// MessageId: hrColumnTooBig
//
// MessageText:
//
//  The length of the field exceeds the maximum length of 255 bytes.
//
#define hrColumnTooBig                   ((HRESULT)0xC80005E2L)

//
// MessageId: hrColumnNotFound
//
// MessageText:
//
//  Unable to find the column.
//
#define hrColumnNotFound                 ((HRESULT)0xC80005E3L)

//
// MessageId: hrColumnDuplicate
//
// MessageText:
//
//  The field is already defined.
//
#define hrColumnDuplicate                ((HRESULT)0xC80005E4L)

//
// MessageId: hrColumn2ndSysMaint
//
// MessageText:
//
//  Only one auto-increment or version column is allowed per table.
//
#define hrColumn2ndSysMaint              ((HRESULT)0xC80005E6L)

//
// MessageId: hrInvalidColumnType
//
// MessageText:
//
//  The column data type is not valid.
//
#define hrInvalidColumnType              ((HRESULT)0xC80005E7L)

//
// MessageId: hrColumnMaxTruncated
//
// MessageText:
//
//  The column was truncated because it exceeded the maximum length of 255 bytes.
//
#define hrColumnMaxTruncated             ((HRESULT)0x880005E8L)

//
// MessageId: hrColumnCannotIndex
//
// MessageText:
//
//  Unable to index a long value column.
//
#define hrColumnCannotIndex              ((HRESULT)0xC80005E9L)

//
// MessageId: hrTaggedNotNULL
//
// MessageText:
//
//  Tagged columns cannot be null.
//
#define hrTaggedNotNULL                  ((HRESULT)0xC80005EAL)

//
// MessageId: hrNoCurrentIndex
//
// MessageText:
//
//  The entry is not valid without a current index.
//
#define hrNoCurrentIndex                 ((HRESULT)0xC80005EBL)

//
// MessageId: hrKeyIsMade
//
// MessageText:
//
//  The key is completely made.
//
#define hrKeyIsMade                      ((HRESULT)0xC80005ECL)

//
// MessageId: hrBadColumnId
//
// MessageText:
//
//  The column ID is not correct.
//
#define hrBadColumnId                    ((HRESULT)0xC80005EDL)

//
// MessageId: hrBadItagSequence
//
// MessageText:
//
//  There is a bad instance identifier for a multivalued column.
//
#define hrBadItagSequence                ((HRESULT)0xC80005EEL)

//
// MessageId: hrCannotBeTagged
//
// MessageText:
//
//  AutoIncrement and Version cannot be multivalued.
//
#define hrCannotBeTagged                 ((HRESULT)0xC80005F1L)

//
// MessageId: hrRecordNotFound
//
// MessageText:
//
//  Unable to find the key.
//
#define hrRecordNotFound                 ((HRESULT)0xC8000641L)

//
// MessageId: hrNoCurrentRecord
//
// MessageText:
//
//  The currency is not on a record.
//
#define hrNoCurrentRecord                ((HRESULT)0xC8000643L)

//
// MessageId: hrRecordClusteredChanged
//
// MessageText:
//
//  A clustered key cannot be changed.
//
#define hrRecordClusteredChanged         ((HRESULT)0xC8000644L)

//
// MessageId: hrKeyDuplicate
//
// MessageText:
//
//  The key already exists.
//
#define hrKeyDuplicate                   ((HRESULT)0xC8000645L)

//
// MessageId: hrAlreadyPrepared
//
// MessageText:
//
//  The current entry has already been copied or cleared.
//
#define hrAlreadyPrepared                ((HRESULT)0xC8000647L)

//
// MessageId: hrKeyNotMade
//
// MessageText:
//
//  No key was made.
//
#define hrKeyNotMade                     ((HRESULT)0xC8000648L)

//
// MessageId: hrUpdateNotPrepared
//
// MessageText:
//
//  Update was not prepared.
//
#define hrUpdateNotPrepared              ((HRESULT)0xC8000649L)

//
// MessageId: hrwrnDataHasChanged
//
// MessageText:
//
//  Data has changed.
//
#define hrwrnDataHasChanged              ((HRESULT)0x8800064AL)

//
// MessageId: hrerrDataHasChanged
//
// MessageText:
//
//  The operation was abandoned because data has changed.
//
#define hrerrDataHasChanged              ((HRESULT)0xC800064BL)

//
// MessageId: hrKeyChanged
//
// MessageText:
//
//  Moved to a new key.
//
#define hrKeyChanged                     ((HRESULT)0x88000652L)

//
// MessageId: hrTooManySorts
//
// MessageText:
//
//  There are too many sort processes.
//
#define hrTooManySorts                   ((HRESULT)0xC80006A5L)

//
// MessageId: hrInvalidOnSort
//
// MessageText:
//
//  An operation that is not valid occurred in the sort.
//
#define hrInvalidOnSort                  ((HRESULT)0xC80006A6L)

//
// MessageId: hrTempFileOpenError
//
// MessageText:
//
//  Unable to open the temporary file.
//
#define hrTempFileOpenError              ((HRESULT)0xC800070BL)

//
// MessageId: hrTooManyAttachedDatabases
//
// MessageText:
//
//  There are too many databases open.
//
#define hrTooManyAttachedDatabases       ((HRESULT)0xC800070DL)

//
// MessageId: hrDiskFull
//
// MessageText:
//
//  The disk is full.
//
#define hrDiskFull                       ((HRESULT)0xC8000710L)

//
// MessageId: hrPermissionDenied
//
// MessageText:
//
//  Permission is denied.
//
#define hrPermissionDenied               ((HRESULT)0xC8000711L)

//
// MessageId: hrFileNotFound
//
// MessageText:
//
//  Unable to find the file.
//
#define hrFileNotFound                   ((HRESULT)0xC8000713L)

//
// MessageId: hrFileOpenReadOnly
//
// MessageText:
//
//  The database file is read only.
//
#define hrFileOpenReadOnly               ((HRESULT)0x88000715L)

//
// MessageId: hrAfterInitialization
//
// MessageText:
//
//  Unable to restore after initialization.
//
#define hrAfterInitialization            ((HRESULT)0xC800073AL)

//
// MessageId: hrLogCorrupted
//
// MessageText:
//
//  The database log files are damaged.
//
#define hrLogCorrupted                   ((HRESULT)0xC800073CL)

//
// MessageId: hrInvalidOperation
//
// MessageText:
//
//  The operation is not valid.
//
#define hrInvalidOperation               ((HRESULT)0xC8000772L)

//
// MessageId: hrAccessDenied
//
// MessageText:
//
//  Access is denied.
//
#define hrAccessDenied                   ((HRESULT)0xC8000773L)

//
// MessageId: hrBadRestoreTargetInstance
//
// MessageText:
//
//  Target Instance specified for restore is not found or log files don't match the backup set logs.
//
#define hrBadRestoreTargetInstance       ((HRESULT)0xC8000774L)

//
// MessageId: hrRunningInstanceIsUsingPath
//
// MessageText:
//
//  Directory contains log files that are in use by a running database. Chose a temporary location.
//
#define hrRunningInstanceIsUsingPath     ((HRESULT)0xC8000775L)

//
//	EVENTLOG
//
//
// MessageId: RESTORE_COMPLETE_START_ID
//
// MessageText:
//
//  %1 (%2) Restore started from directory %3.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define RESTORE_COMPLETE_START_ID        ((HRESULT)0xC8000385L)

//
// MessageId: RESTORE_COMPLETE_STOP_ID
//
// MessageText:
//
//  %1 (%2) Restore from directory %3 ended successfully.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define RESTORE_COMPLETE_STOP_ID         ((HRESULT)0xC8000386L)

//
// MessageId: RESTORE_COMPLETE_ERROR_ID
//
// MessageText:
//
//  %1 (%2) Restore from directory %3 ended with error (%4).
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define RESTORE_COMPLETE_ERROR_ID        ((HRESULT)0xC8000387L)

//
// MessageId: BACKUP_NOT_TRUNCATE_DB_UNMOUNTED_ID
//
// MessageText:
//
//  %1 (%2) Unable to purge transaction logs because at least one database (%3) is off-line.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define BACKUP_NOT_TRUNCATE_DB_UNMOUNTED_ID ((HRESULT)0xC80003B7L)

//
// MessageId: CALLBACK_ERROR_ID
//
// MessageText:
//
//  %1 (%2) Callback function call %3 ended with error %4 %5.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define CALLBACK_ERROR_ID                ((HRESULT)0xC8000388L)

//
// MessageId: BACKUP_RESTORE_REGISTER_ID
//
// MessageText:
//
//  %1 (%2) Server registered: %3 / %4 (callback DLL %5, flags %6).
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define BACKUP_RESTORE_REGISTER_ID       ((HRESULT)0xC8000389L)

//
// MessageId: BACKUP_RESTORE_UNREGISTER_ID
//
// MessageText:
//
//  %1 (%2) Server unregistered: %3 / %4.
//  %n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
//
#define BACKUP_RESTORE_UNREGISTER_ID     ((HRESULT)0xC800038AL)

#endif	// _ESEBKMSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\export\jetback.h ===
/*
 *	EDBBACK.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1992-1995, Microsoft Corporation
 *	
 *	Contains declarations of additional definitions and interfaces
 *	for the Exchange Online backup Server APIs.
 */

#ifndef	_MDBBACK_
#define	_MDBBACK_

//
//	Useful types.
//

typedef	LONG ERR;

//	UNDONE: HRESULT should be DWORD (unsigned)

//typedef	DWORD HRESULT;
typedef	LONG HRESULT;


#define	EDBBACK_API __stdcall

#ifdef	__cplusplus
extern "C" {
#endif

#define	BACKUP_WITH_UUID

ERR
EDBBACK_API
HrBackupRegisterW(
    UUID *puuidService,
    WCHAR * wszEndpointAnnotation
    );
ERR
EDBBACK_API
HrBackupRegisterA(
    UUID *puuidService,
    char * szEndpointAnnotation
    );

#ifdef	UNICODE
#define	HrBackupRegister HrBackupRegisterW
#else
#define	HrBackupRegister HrBackupRegisterA
#endif

ERR
EDBBACK_API
HrBackupUnregister(
    );

ERR
EDBBACK_API
ErrRestoreRegisterW(
	WCHAR * wszEndpointAnnotation,
	WCHAR * wszRestoreDll,
	char * szPerformRestore,
	char * szQueryDatabaseLocations
	);

ERR
EDBBACK_API
ErrRestoreRegisterA(
	char * szEndpointAnnotation,
	char * szRestoreDll,
	char * szPerformRestore,
	char * szQueryDatabaseLocations
	);

#ifdef	UNICODE
#define	ErrRestoreRegister ErrRestoreRegisterW
#else
#define	ErrRestoreRegister ErrRestoreRegisterA
#endif

ERR
EDBBACK_API
ErrRestoreUnregisterW(
	WCHAR * szEndpointAnnotation
	);

ERR
EDBBACK_API
ErrRestoreUnregisterA(
	char * szEndpointAnnotation
	);

#ifdef	UNICODE
#define	ErrRestoreUnregister ErrRestoreUnregisterW
#else
#define	ErrRestoreUnregister ErrRestoreUnregisterA
#endif

ERR
EDBBACK_API
ErrRecoverAfterRestoreW(
	WCHAR * szParametersRoot,
	WCHAR * wszAnnotation
	);

ERR
EDBBACK_API
ErrRecoverAfterRestoreA(
	char * szParametersRoot,
	char * szAnnotation
	);

#ifdef	UNICODE
#define	ErrRecoverAfterRestore ErrRecoverAfterRestoreW
#else
#define	ErrRecoverAfterRestore ErrRecoverAfterRestoreA
#endif



#ifdef	__cplusplus
}
#endif

#endif	// _MDBBACK_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\export\jetbcli.h ===
/*
 *	EDBBCLI.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1986-1996, Microsoft Corporation
 *	
 *	Contains declarations of additional definitions and interfaces
 *	for the Exchange Online Backup Client APIs.
 */

#ifndef	_EDBBCLI_
#define	_EDBBCLI_
#ifdef	__cplusplus
extern "C" {
#endif

#ifdef	MIDL_PASS
#define	RPC_STRING [string]
#else
#define	RPC_STRING
#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#else
typedef wchar_t WCHAR;
#endif
#endif

#define	EDBBACK_MDB_SERVER	"Exchange MDB Database"
#define	EDBBACK_DS_SERVER	"Exchange DS Database"

#define	EDBBACK_API __stdcall

//
//	Useful types.
//

//	UNDONE: HRESULT should be DWORD (unsigned)

//typedef	DWORD HRESULT;
#ifndef	MIDL_PASS
typedef	LONG HRESULT;
#endif

typedef	LONG ERR;

typedef	LONG C;
typedef TCHAR BFT;

//
//	Type of backup passed into HrBackupPrepare()
//

#define	BACKUP_TYPE_FULL			0x01
#define	BACKUP_TYPE_LOGS_ONLY		0x02

//
//	Set the current log number to this value to disable incremental or
//	differential backup.
//
#define	BACKUP_DISABLE_INCREMENTAL	0xffffffff

//
//	Backup/Restore file types
//
//
//	Please note that these file types are binary values, even though they are text (or wchar) typed.
//
//	The code in the backup API's rely on the fact that values 0-256 in 8 bit ascii map to the values 0-256 in unicode.
//

//
//	If the BFT_DIRECTORY bit is set on the backup file type, it indicates that the path specified is a directory,
//	otherwise it is a file name.
//

#define	BFT_DIRECTORY			0x80

//
//	If the BFT_DATABASE bit is set on the backup file type, it indicates that the file goes into the database directory.
//

#define BFT_DATABASE_DIRECTORY	0x40

//
//	If the BFT_LOG bit is set on the backup file type, it indicates that the file goes into the log	directory.
//

#define	BFT_LOG_DIRECTORY		0x20

//
//	Database logs.
//

#define	BFT_LOG						(BFT)(TEXT('\x01') | BFT_LOG_DIRECTORY)
#define	BFT_LOG_DIR					(BFT)(TEXT('\x02') | BFT_DIRECTORY)

//
//	Checkpoint file.
//

#define	BFT_CHECKPOINT_DIR			(BFT)(TEXT('\x03') | BFT_DIRECTORY)

//
//	Database types.
//
#define	BFT_MDB_PRIVATE_DATABASE	(BFT)(TEXT('\x05') | BFT_DATABASE_DIRECTORY)
#define	BFT_MDB_PUBLIC_DATABASE		(BFT)(TEXT('\x06') | BFT_DATABASE_DIRECTORY)
#define	BFT_DSA_DATABASE			(BFT)(TEXT('\x07') | BFT_DATABASE_DIRECTORY)

//
//	JET patch files
//
//
//	

#define	BFT_PATCH_FILE				(BFT)(TEXT('\x08') | BFT_LOG_DIRECTORY)

//
//	Catch all for unknown file types.
//

#define	BFT_UNKNOWN					(BFT)(TEXT('\x0f'))

#include <edbmsg.h>

typedef void *HBC;

typedef struct tagEDB_RSTMAPA
{
	RPC_STRING char		*szDatabaseName;
	RPC_STRING char		*szNewDatabaseName;
} EDB_RSTMAPA, *PEDB_RSTMAPA;			/* restore map */

//	required for Exchange unicode support.
//	UNDONE: NYI
#define	UNICODE_RSTMAP

typedef struct tagEDB_RSTMAPW {
	RPC_STRING WCHAR *wszDatabaseName;
	RPC_STRING WCHAR *wszNewDatabaseName;
} EDB_RSTMAPW, *PEDB_RSTMAPW;

#ifdef UNICODE
#define EDB_RSTMAP EDB_RSTMAPW
#define PEDB_RSTMAP PEDB_RSTMAPW
#else
#define EDB_RSTMAP EDB_RSTMAPA
#define PEDB_RSTMAP PEDB_RSTMAPA
#endif


ERR
EDBBACK_API
HrBackupPrepareA(
	IN char * szBackupServer,
	IN char * szBackupAnnotation,
	IN unsigned long grbit,
	IN unsigned long btBackupType,
	OUT HBC *hbcBackupContext
	);

ERR
EDBBACK_API
HrBackupPrepareW(
	IN WCHAR * wszBackupServer,
	IN WCHAR * wszBackupAnnotation,
	IN unsigned long grbit,
	IN unsigned long btBackupType,
	OUT HBC *hbcBackupContext
	);

#ifdef	UNICODE
#define	HrBackupPrepare HrBackupPrepareW
#else
#define	HrBackupPrepare HrBackupPrepareA
#endif


ERR
EDBBACK_API
HrBackupGetDatabaseNamesA(
	IN HBC pvBackupContext,
	OUT LPSTR *ppszAttachmentInformation,
	OUT LPDWORD pcbSize
	);

ERR
EDBBACK_API
HrBackupGetDatabaseNamesW(
	IN HBC pvBackupContext,
	OUT LPWSTR *ppszAttachmentInformation,
	OUT LPDWORD pcbSize
	);

#ifdef	UNICODE
#define	HrBackupGetDatabaseNames HrBackupGetDatabaseNamesW
#else
#define	HrBackupGetDatabaseNames HrBackupGetDatabaseNamesA
#endif

ERR
EDBBACK_API
HrBackupOpenFileW(
	IN HBC pvBackupContext,
	IN WCHAR * wszAttachmentName,
	IN DWORD cbReadHintSize,
	OUT LARGE_INTEGER *pliFileSize
	);

ERR
EDBBACK_API
HrBackupOpenFileA(
	IN HBC pvBackupContext,
	IN char * szAttachmentName,
	IN DWORD cbReadHintSize,
	OUT LARGE_INTEGER *pliFileSize
	);

#ifdef	UNICODE
#define	HrBackupOpenFile HrBackupOpenFileW
#else
#define HrBackupOpenFile HrBackupOpenFileA
#endif


ERR
EDBBACK_API
HrBackupRead(
	IN HBC pvBackupContext,
	IN PVOID pvBuffer,
	IN DWORD cbBuffer,
	OUT PDWORD pcbRead
	);

ERR
EDBBACK_API
HrBackupClose(
	IN HBC pvBackupContext
	);

ERR
EDBBACK_API
HrBackupGetBackupLogsA(
	IN HBC pvBackupContext,
	IN LPSTR *szBackupLogFile,
	IN PDWORD pcbSize
	);

ERR
EDBBACK_API
HrBackupGetBackupLogsW(
	IN HBC pvBackupContext,
	IN LPWSTR *szBackupLogFile,
	IN PDWORD pcbSize
	);

#ifdef	UNICODE
#define	HrBackupGetBackupLogs HrBackupGetBackupLogsW
#else
#define	HrBackupGetBackupLogs HrBackupGetBackupLogsA
#endif

ERR
EDBBACK_API
HrBackupTruncateLogs(
	IN HBC pvBackupContext
	);


ERR
EDBBACK_API
HrBackupEnd(
	IN HBC pvBackupContext
	);


VOID
EDBBACK_API
BackupFree(
	IN PVOID pvBuffer
	);


ERR
EDBBACK_API
HrRestoreGetDatabaseLocationsA(
	IN HBC hbcBackupContext,
	OUT LPSTR *ppszDatabaseLocationList,
	OUT LPDWORD pcbSize
	);

ERR
EDBBACK_API
HrRestoreGetDatabaseLocationsW(
	IN HBC pvBackupContext,
	OUT LPWSTR *ppszDatabaseLocationList,
	OUT LPDWORD pcbSize
	);

#ifdef	UNICODE
#define	HrRestoreGetDatabaseLocations HrRestoreGetDatabaseLocationsW
#else
#define	HrRestoreGetDatabaseLocations HrRestoreGetDatabaseLocationsA
#endif

ERR
EDBBACK_API
HrRestorePrepareA(
	char * szServerName,
	char * szServiceAnnotation,
	HBC *phbcBackupContext
	);

ERR
EDBBACK_API
HrRestorePrepareW(
	WCHAR * szServerName,
	WCHAR * szServiceAnnotation,
	HBC *phbcBackupContext
	);

#ifdef	UNICODE
#define	HrRestorePrepare HrRestorePrepareW
#else
#define	HrRestorePrepare HrRestorePrepareA
#endif

//
//	HrRestoreRegister will register a restore
//	operation.  It will interlock all subsequent
//	restore operations, and will prevent the restore target
//	from starting until the call to HrRestoreRegisterComplete.
//

ERR
EDBBACK_API
HrRestoreRegisterA(
	IN HBC hbcRestoreContext,
	IN char * szCheckpointFilePath,
	IN char * szLogPath,
	IN EDB_RSTMAPA rgrstmap[],
	IN C crstmap,
	IN char * szBackupLogPath,
	IN ULONG genLow,
	IN ULONG genHigh
	);

ERR
EDBBACK_API
HrRestoreRegisterW(
	IN HBC hbcRestoreContext,
	IN WCHAR * wszCheckpointFilePath,
	IN WCHAR * wszLogPath,
	IN EDB_RSTMAPW rgrstmap[],
	IN C crstmap,
	IN WCHAR * wszBackupLogPath,
	IN ULONG genLow,
	IN ULONG genHigh
	);

#ifdef	UNICODE
#define	HrRestoreRegister HrRestoreRegisterW
#else
#define	HrRestoreRegister HrRestoreRegisterA
#endif

//
//	HrRestoreRegisterComplete will complete a restore
//	operation.  It will allow further subsequent
//	restore operations, and will allow the restore target
//	to start if hrRestoreState is success.
//
//	If hrRestoreState is NOT hrNone, this will
//	prevent the restore target from restarting.
//

ERR
EDBBACK_API
HrRestoreRegisterComplete(
	HBC hbcRestoreContext,
	ERR hrRestoreState
	);

ERR
EDBBACK_API
HrRestoreEnd(
	HBC hbcRestoreContext
	);

ERR
EDBBACK_API
HrSetCurrentBackupLogW(
	WCHAR *wszServerName,
	WCHAR * wszBackupAnnotation,
	DWORD dwCurrentLog
	);

ERR
EDBBACK_API
HrSetCurrentBackupLogA(
	CHAR * szServerName,
	CHAR * szBackupAnnotation,
	DWORD dwCurrentLog
	);

#ifdef	UNICODE
#define	HrSetCurrentBackupLog HrSetCurrentBackupLogW
#else
#define	HrSetCurrentBackupLog HrSetCurrentBackupLogA
#endif

#ifdef	__cplusplus
}
#endif

#endif	// _EDBBCLI_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\dht\dht.cxx ===
#include <dht.hxx>

namespace DHT {

};  //  namespace DHT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\bf.cxx ===
#include "std.hxx"
#include "_bf.hxx"


///////////////////////////////////////////////////////////////////////////////
//
//  BF API Functions
//
///////////////////////////////////////////////////////////////////////////////

/////////////////
//  Init / Term

//  The following functions control the initialization and termination of 
//  the buffer manager.

//  Initializes the buffer manager for normal operation.  Must be called 
//  only once and BFTerm() must be called before process termination.  If an 
//  error is returned, the buffer manager is not initialized.

ERR ErrBFInit()
	{
	ERR err;

	//  validate our configuration

	CallJ( ErrBFIValidateParameters(), Validate );
		
	//  critical sections

	critBFParm.Enter();

	//  must not have been initialized

	Assert( !fBFInitialized );

	//  reset all stats

	cBFMemory					= 0;
	cBFPageFlushPending			= 0;

	//  reset all perf stats

	cBFCacheMiss				= 0;
	cBFCacheReq					= 0;
	cBFClean					= 0;
	cBFSlowLatch				= 0;
	cBFBadLatchHint				= 0;
	cBFLatchConflict			= 0;
	cBFLatchStall				= 0;

	//  init all components

	switch ( bfhash.ErrInit(	dblBFHashLoadFactor,
								dblBFHashUniformity ) )
		{
		default:
			AssertSz( fFalse, "Unexpected error initializing BF Hash Table" );
		case BFHash::errOutOfMemory:
			CallJ( ErrERRCheck( JET_errOutOfMemory ), TermLRUK );
		case BFHash::errSuccess:
			break;
		}
	switch ( bfavail.ErrInit( dblBFSpeedSizeTradeoff ) )
		{
		default:
			AssertSz( fFalse, "Unexpected error initializing BF Avail Pool" );
		case BFAvail::errOutOfMemory:
			CallJ( ErrERRCheck( JET_errOutOfMemory ), TermLRUK );
		case BFAvail::errSuccess:
			break;
		}
	switch ( bflruk.ErrInit(	BFLRUKK,
								csecBFLRUKCorrelatedTouch,
								csecBFLRUKTimeout,
								csecBFLRUKUncertainty,
								dblBFHashLoadFactor,
								dblBFHashUniformity,
								dblBFSpeedSizeTradeoff ) )
		{
		default:
			AssertSz( fFalse, "Unexpected error initializing BF LRUK Manager" );
		case BFLRUK::errOutOfMemory:
			CallJ( ErrERRCheck( JET_errOutOfMemory ), TermLRUK );
		case BFLRUK::errSuccess:
			break;
		}
	CallJ( ErrBFICacheInit(), TermLRUK );
	if ( !critpoolBFDUI.FInit( OSSyncGetProcessorCount(), rankBFDUI, szBFDUI ) )
		{
		CallJ( ErrERRCheck( JET_errOutOfMemory ), TermCache );
		}

	//  start all service threads

	CallJ( ErrBFICleanThreadInit(), TermDUI );

	//  init successful

	fBFInitialized = fTrue;
	goto Validate;

	//  term all initialized threads / components
	
TermDUI:
	critpoolBFDUI.Term();
TermCache:
	BFICacheTerm();
TermLRUK:
	bflruk.Term();
	bfavail.Term();
	bfhash.Term();
Validate:
	Assert(	err == JET_errOutOfMemory ||
			err == JET_errOutOfThreads ||
			err == JET_errSuccess );
	Assert(	( err != JET_errSuccess && !fBFInitialized ) ||
			( err == JET_errSuccess && fBFInitialized ) );

	critBFParm.Leave();
	return err;
	}

//  Terminates the buffer manager.  Must be called before process 
//  termination to avoid loss of system resources.  Cannot be called before 
//  ErrBFInit().
//  
//  NOTE:  To avoid losing changes to pages, you must call ErrBFFlush() before 
//  BFTerm()!
//
//  UNDONE:  Calling BFTerm() without calling ErrBFFlush() can cause the loss
//  of any deferred undo information attached to each buffer.  This can result
//  in recovery failure!!!  Should BFTerm() force any existing deferred undo
//  info to disk to prevent this?

void BFTerm()
	{
	//  must have been initialized
	
	Assert( fBFInitialized );
	fBFInitialized = fFalse;
	
	//  terminate all service threads
	
	BFICleanThreadTerm();

	//  critical sections

	critBFParm.Enter();

	//  terminate all components
	
	critpoolBFDUI.Term();
	BFICacheTerm();
	bflruk.Term();
	bfavail.Term();
	bfhash.Term();
	
	critBFParm.Leave();
	}


///////////////////////
//  System Parameters

//  The following functions are used to get and set the many system 
//  parameters used by the buffer manager during runtime.  Most of these 
//  parameters are used for optimizing performance.

//  Returns the minimum size of the cache in pages.

ERR ErrBFGetCacheSizeMin( ULONG_PTR* pcpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcpg == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}
		
	*pcpg = (ULONG_PTR)cbfCacheMin;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the current size of the cache in pages.

ERR ErrBFGetCacheSize( ULONG_PTR* pcpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcpg == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}
		
	*pcpg = cbfCache - cbfNewlyCommitted;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the maximum size of the cache in pages.

ERR ErrBFGetCacheSizeMax( ULONG_PTR* pcpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcpg == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}
		
	*pcpg = (ULONG_PTR)cbfCacheMax;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the maximum permitted checkpoint depth in bytes.  The buffer 
//  manager will attempt to aggressively flush any buffer that is holding 
//  the checkpoint to a depth greater than this value.

ERR ErrBFGetCheckpointDepthMax( ULONG_PTR* pcb )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcb == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}
		
	*pcb = (ULONG_PTR)cbCleanCheckpointDepthMax;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the current duration (in microseconds) of the interval over 
//  which multiple accesses of a single page will be considered correlated. 
//  A duration of zero implies that no accesses are correlated.

ERR ErrBFGetLRUKCorrInterval( ULONG_PTR* pcusec )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcusec == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}
		
	*pcusec = (ULONG_PTR)( 1000000 * csecBFLRUKCorrelatedTouch );
	critBFParm.Leave();
	return JET_errSuccess;
	}

//	Returns the current K-ness of the LRUK page replacement algorithm.

ERR ErrBFGetLRUKPolicy( ULONG_PTR* pcLRUKPolicy )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcLRUKPolicy == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}
		
	*pcLRUKPolicy = (ULONG_PTR)BFLRUKK;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the current LRUK Time-out used by the buffer manager.  The LRUK
//  Time-out is the duration (in seconds) since a multiply accessed page was
//  last accessed when that page is considered for eviction from the cache.

ERR ErrBFGetLRUKTimeout( ULONG_PTR* pcsec )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcsec == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}
		
	*pcsec = (ULONG_PTR)csecBFLRUKTimeout;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the current count of clean pages at which we will start cleaning 
//  buffers.  We will clean buffers until we reach the corresponding stop 
//  threshold.

ERR ErrBFGetStartFlushThreshold( ULONG_PTR* pcpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcpg == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}
		
	*pcpg = (ULONG_PTR)cbfCleanThresholdStart;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Returns the current count of clean pages at which we will stop cleaning 
//  buffers after beginning a flush by dropping below the corresponding start 
//  threshold.

ERR ErrBFGetStopFlushThreshold( ULONG_PTR* pcpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( pcpg == NULL )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}
		
	*pcpg = (ULONG_PTR)cbfCleanThresholdStop;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the minimum size of the cache in pages.

ERR ErrBFSetCacheSizeMin( ULONG_PTR cpg )
	{
 	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section
	
	critBFParm.Enter();

	//  validate IN args
	
	if ( cpg < 1 )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	cbfCacheMin = cpg;

	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the current (preferred) size of the cache in pages.

ERR ErrBFSetCacheSize( ULONG_PTR cpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  set the user set point

	cbfCacheSetUser = cpg;
	return JET_errSuccess;
	}

//  Sets the maximum size of the cache in pages.

ERR ErrBFSetCacheSizeMax( ULONG_PTR cpg )
	{
 	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section
	
	critBFParm.Enter();

	//  validate IN args
	
	if ( fBFInitialized )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errAlreadyInitialized );
		}

	if ( cpg < 1 )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	cbfCacheMax = cpg;

	//  normalize thresholds

	BFINormalizeThresholds();

	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the maximum permitted checkpoint depth in bytes.  The buffer 
//  manager will attempt to aggressively flush any buffer that is holding 
//  the checkpoint to a depth greater than this value.  The Maximum 
//  Checkpoint Depth can be any positive value.  This parameter can be set 
//  at any time.
//
//  NOTE:  Setting this value too low may cause excessive flushing of 
//  buffers to disk and reduced I/O performance.

ERR ErrBFSetCheckpointDepthMax( ULONG_PTR cb )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args
	
	if ( (long)cb < 0 )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}
	
	cbCleanCheckpointDepthMax = (long)cb;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the current duration (in microseconds) of the interval over which 
//  multiple accesses of a single page will be considered correlated.  A 
//  duration of zero implies that no accesses are correlated.  The 
//  Correlation Interval can be any positive duration.  This parameter can 
//  be set at any time.

ERR ErrBFSetLRUKCorrInterval( ULONG_PTR cusec )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args
	
	if ( (long)cusec < 0 )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}
	
	csecBFLRUKCorrelatedTouch = double( cusec ) / 1000000;
	critBFParm.Leave();
	return JET_errSuccess;
	}

//	Sets the current K-ness of the LRUK page replacement algorithm.

ERR ErrBFSetLRUKPolicy( ULONG_PTR cLRUKPolicy )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args

	if ( cLRUKPolicy > Kmax )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}

	BFLRUKK = int( cLRUKPolicy );
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the current LRUK Time-out used by the buffer manager.  The LRUK Time-out 
//  is the duration (in seconds) since a multiply accessed page was last accessed 
//  when that page is considered for eviction from the cache.

ERR ErrBFSetLRUKTimeout( ULONG_PTR csec )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  validate IN args
	
	if ( (long)csec <= 0 )
		{
		critBFParm.Leave();
		return ErrERRCheck( JET_errInvalidParameter );
		}
	
	csecBFLRUKTimeout = double( csec );
	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the current count of clean pages at which we will start cleaning 
//  buffers.  We will clean buffers until we reach the corresponding stop 
//  threshold.  The Start Threshold must be less than the current Stop 
//  Threshold and greater than zero.  This parameter can be set at any time.

ERR ErrBFSetStartFlushThreshold( ULONG_PTR cpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  set start threshold
	
	cbfCleanThresholdStart = (LONG_PTR)cpg;

	//  normalize thresholds

	BFINormalizeThresholds();

	critBFParm.Leave();
	return JET_errSuccess;
	}

//  Sets the current count of clean pages at which we will stop cleaning 
//  buffers after beginning a flush by dropping below the corresponding start 
//  threshold.  The Stop Threshold must be greater than the current Start 
//  Threshold.  This parameter can be set at any time.

ERR ErrBFSetStopFlushThreshold( ULONG_PTR cpg )
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  critical section

	critBFParm.Enter();

	//  set stop threshold
	
	cbfCleanThresholdStop = (LONG_PTR)cpg;

	//  normalize thresholds

	BFINormalizeThresholds();

	critBFParm.Leave();
	return JET_errSuccess;
	}
	

//////////////////
//  Page Latches

ERR ErrBFReadLatchPage( BFLatch* pbfl, IFMP ifmp, PGNO pgno, BFLatchFlags bflf )
	{
	ERR err;
	
	//  validate IN args

	Assert( FBFNotLatched( ifmp, pgno ) );

	//  Read Latch the page

	Call( ErrBFILatchPage( pbfl, ifmp, pgno, bflf, bfltShared ) );

	//  validate OUT args

	Assert( err != wrnBFPageFault || !( bflf & bflfNoUncached ) );
	Assert( err != errBFPageCached || ( bflf & bflfNoCached ) );
	Assert( err != errBFPageNotCached || ( bflf & bflfNoUncached ) );
	Assert( err != errBFLatchConflict || ( bflf & bflfNoWait ) );

HandleError:
	Assert(	(	err < JET_errSuccess &&
				FBFNotLatched( ifmp, pgno ) ) ||
			(	( err >= JET_errSuccess || ( bflf & bflfNoFail ) ) &&
				FBFReadLatched( pbfl ) &&
				PBF( pbfl->dwContext )->ifmp == ifmp &&
				PBF( pbfl->dwContext )->pgno == pgno ) );

	return err;
	}

ERR ErrBFRDWLatchPage( BFLatch* pbfl, IFMP ifmp, PGNO pgno, BFLatchFlags bflf )
	{
	ERR err;
	
	//  validate IN args

	Assert( FBFNotLatched( ifmp, pgno ) );
	Assert( !( bflf & bflfNew ) );

	//  RDW Latch the page

	Call( ErrBFILatchPage( pbfl, ifmp, pgno, bflf, bfltExclusive ) );

	//  validate OUT args

HandleError:
	Assert( err != wrnBFPageFault || !( bflf & bflfNoUncached ) );
	Assert( err != errBFPageCached || ( bflf & bflfNoCached ) );
	Assert( err != errBFPageNotCached || ( bflf & bflfNoUncached ) );
	Assert( err != errBFLatchConflict || ( bflf & bflfNoWait ) );

	Assert(	(	err < JET_errSuccess &&
				FBFNotLatched( ifmp, pgno ) ) ||
			(	( err >= JET_errSuccess || ( bflf & bflfNoFail ) ) &&
				FBFRDWLatched( pbfl ) &&
				PBF( pbfl->dwContext )->ifmp == ifmp &&
				PBF( pbfl->dwContext )->pgno == pgno ) );

	return err;
	}

ERR ErrBFWARLatchPage( BFLatch* pbfl, IFMP ifmp, PGNO pgno, BFLatchFlags bflf )
	{
	ERR err;
	
	//  validate IN args

	Assert( FBFNotLatched( ifmp, pgno ) );
	Assert( !( bflf & bflfNew ) );

	//  RDW Latch the page

	Call( ErrBFILatchPage( pbfl, ifmp, pgno, bflf, bfltExclusive ) );

	//  mark this BF as WAR Latched

	PBF( pbfl->dwContext )->fWARLatch = fTrue;

	//  return the RW Image pointer

	pbfl->pv = PBF( pbfl->dwContext )->pvRWImage;
	
	//  validate OUT args

HandleError:
	Assert( err != wrnBFPageFault || !( bflf & bflfNoUncached ) );
	Assert( err != errBFPageCached || ( bflf & bflfNoCached ) );
	Assert( err != errBFPageNotCached || ( bflf & bflfNoUncached ) );
	Assert( err != errBFLatchConflict || ( bflf & bflfNoWait ) );

	Assert(	(	err < JET_errSuccess &&
				FBFNotLatched( ifmp, pgno ) ) ||
			(	err >= JET_errSuccess &&
				FBFWARLatched( pbfl ) &&
				PBF( pbfl->dwContext )->ifmp == ifmp &&
				PBF( pbfl->dwContext )->pgno == pgno ) );

	Assert( err < JET_errSuccess || PBF( pbfl->dwContext )->err != errBFIPageNotVerified );

	return err;
	}

ERR ErrBFWriteLatchPage( BFLatch* pbfl, IFMP ifmp, PGNO pgno, BFLatchFlags bflf )
	{
	ERR err;
	
	//  validate IN args

	Assert( FBFNotLatched( ifmp, pgno ) );
	Assert( !( bflf & bflfNoFail ) );

	//  Write Latch the page

	Call( ErrBFILatchPage( pbfl, ifmp, pgno, bflf, bfltWrite ) );

	//  validate OUT args

HandleError:
	Assert( err != wrnBFPageFault || !( bflf & bflfNoUncached ) );
	Assert( err != errBFPageCached || ( bflf & bflfNoCached ) );
	Assert( err != errBFPageNotCached || ( bflf & bflfNoUncached ) );
	Assert( err != errBFLatchConflict || ( bflf & bflfNoWait ) );

	Assert(	(	err < JET_errSuccess &&
				FBFNotLatched( ifmp, pgno ) ) ||
			(	err >= JET_errSuccess &&
				FBFWriteLatched( pbfl ) &&
				PBF( pbfl->dwContext )->ifmp == ifmp &&
				PBF( pbfl->dwContext )->pgno == pgno ) );

	Assert( err < JET_errSuccess || PBF( pbfl->dwContext )->err != errBFIPageNotVerified );

	return err;
	}

ERR ErrBFUpgradeReadLatchToRDWLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFReadLatched( pbfl ) );
	
	ERR				err;
	PBF				pbf = PBF( pbfl->dwContext );
	CSXWLatch::ERR	errSXWL;

	//  try to upgrade our shared latch to the exclusive latch

	errSXWL = pbf->sxwl.ErrUpgradeSharedLatchToExclusiveLatch();

	//  there was a latch conflict

	if ( errSXWL == CSXWLatch::errLatchConflict )
		{
		//  fail with a latch conflict

		cBFLatchConflict++;
		err = ErrERRCheck( errBFLatchConflict );
		}

	//  there was no latch conflict

	else
		{
		Assert( errSXWL == CSXWLatch::errSuccess );

		//  ensure that if the page is valid it is marked as valid.  it is
		//  possible that we can't do this in the process of getting a Read
		//  Latch because we can't get the exclusive latch so we must make sure
		//  that we do it before we upgrade to a Write Latch or WAR Latch.  the
		//  reason for this is that if we modify the page while it is still
		//  marked as not validated then another thread will misinterpret the
		//  page as invalid
		//
		//  NOTE:  it should be very rare that we will actually need to perform
		//  the full validation of this page.  the reason we must do the full
		//  validation instead of just marking the page as validated is because
		//  the page may have been latched with bflfNoFail in which case we do
		//  not know for sure if it was valid in the first place

		(void)ErrBFIValidatePage( pbf, bfltExclusive );

		//  we have the RDW Latch

		err = JET_errSuccess;
		}

	//  validate OUT args

	Assert(	( err < JET_errSuccess && FBFReadLatched( pbfl ) ) ||
			( err >= JET_errSuccess && FBFRDWLatched( pbfl ) ) );

	return err;
	}
	
ERR ErrBFUpgradeReadLatchToWARLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFReadLatched( pbfl ) );
	
	ERR				err;
	PBF				pbf = PBF( pbfl->dwContext );
	CSXWLatch::ERR	errSXWL;

	//  try to upgrade our shared latch to the exclusive latch

	errSXWL = pbf->sxwl.ErrUpgradeSharedLatchToExclusiveLatch();

	//  there was a latch conflict

	if ( errSXWL == CSXWLatch::errLatchConflict )
		{
		//  fail with a latch conflict

		cBFLatchConflict++;
		err = ErrERRCheck( errBFLatchConflict );
		}

	//  there was no latch conflict

	else
		{
		Assert( errSXWL == CSXWLatch::errSuccess );

		//  ensure that if the page is valid it is marked as valid.  it is
		//  possible that we can't do this in the process of getting a Read
		//  Latch because we can't get the exclusive latch so we must make sure
		//  that we do it before we upgrade to a Write Latch or WAR Latch.  the
		//  reason for this is that if we modify the page while it is still
		//  marked as not validated then another thread will misinterpret the
		//  page as invalid
		//
		//  NOTE:  it should be very rare that we will actually need to perform
		//  the full validation of this page.  the reason we must do the full
		//  validation instead of just marking the page as validated is because
		//  the page may have been latched with bflfNoFail in which case we do
		//  not know for sure if it was valid in the first place

		(void)ErrBFIValidatePage( pbf, bfltExclusive );

		//  mark this BF as WAR Latched

		pbf->fWARLatch = fTrue;

		//  return the RW Image pointer

		pbfl->pv = pbf->pvRWImage;
		
		err = JET_errSuccess;
		}

	//  validate OUT args

	Assert(	( err < JET_errSuccess && FBFReadLatched( pbfl ) ) ||
			( err >= JET_errSuccess && FBFWARLatched( pbfl ) ) );

	Assert( err < JET_errSuccess || PBF( pbfl->dwContext )->err != errBFIPageNotVerified );

	return err;
	}

ERR ErrBFUpgradeReadLatchToWriteLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFReadLatched( pbfl ) );
	
	ERR				err;
	PBF				pbf = PBF( pbfl->dwContext );
	CSXWLatch::ERR	errSXWL;

	//  try to upgrade our shared latch to the write latch

	errSXWL = pbf->sxwl.ErrUpgradeSharedLatchToWriteLatch();

	//  there was a latch conflict

	if ( errSXWL == CSXWLatch::errLatchConflict )
		{
		//  fail with a latch conflict

		cBFLatchConflict++;
		err = ErrERRCheck( errBFLatchConflict );
		}

	//  there was no latch conflict

	else
		{
		Assert(	errSXWL == CSXWLatch::errSuccess ||
				errSXWL == CSXWLatch::errWaitForWriteLatch );

		//  wait for ownership of the write latch if required

		if ( errSXWL == CSXWLatch::errWaitForWriteLatch )
			{
			cBFLatchStall++;
			pbf->sxwl.WaitForWriteLatch();
			}

		//  ensure that if the page is valid it is marked as valid.  it is
		//  possible that we can't do this in the process of getting a Read
		//  Latch because we can't get the exclusive latch so we must make sure
		//  that we do it before we upgrade to a Write Latch or WAR Latch.  the
		//  reason for this is that if we modify the page while it is still
		//  marked as not validated then another thread will misinterpret the
		//  page as invalid
		//
		//  NOTE:  it should be very rare that we will actually need to perform
		//  the full validation of this page.  the reason we must do the full
		//  validation instead of just marking the page as validated is because
		//  the page may have been latched with bflfNoFail in which case we do
		//  not know for sure if it was valid in the first place

		(void)ErrBFIValidatePage( pbf, bfltWrite );

		//  return the RW Image pointer

		pbfl->pv = pbf->pvRWImage;
	
		err = JET_errSuccess;
		}

	//  validate OUT args

	Assert(	( err < JET_errSuccess && FBFReadLatched( pbfl ) ) ||
			( err >= JET_errSuccess && FBFWriteLatched( pbfl ) ) );

	Assert( err < JET_errSuccess || PBF( pbfl->dwContext )->err != errBFIPageNotVerified );

	return err;
	}

ERR ErrBFUpgradeRDWLatchToWARLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFRDWLatched( pbfl ) );
	
	ERR err;
	PBF pbf = PBF( pbfl->dwContext );

	//  mark this BF as WAR Latched

	pbf->fWARLatch = fTrue;

	//  return the RW Image pointer

	pbfl->pv = pbf->pvRWImage;
	
	err = JET_errSuccess;

	//  validate OUT args

	Assert(	( err < JET_errSuccess && FBFRDWLatched( pbfl ) ) ||
			( err >= JET_errSuccess && FBFWARLatched( pbfl ) ) );

	Assert( err < JET_errSuccess || PBF( pbfl->dwContext )->err != errBFIPageNotVerified );

	return err;
	}

ERR ErrBFUpgradeRDWLatchToWriteLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFRDWLatched( pbfl ) );
	
	ERR				err;
	PBF				pbf = PBF( pbfl->dwContext );
	CSXWLatch::ERR	errSXWL;

	//  upgrade our exclusive latch to the write latch

	errSXWL = pbf->sxwl.ErrUpgradeExclusiveLatchToWriteLatch();

	Assert(	errSXWL == CSXWLatch::errSuccess ||
			errSXWL == CSXWLatch::errWaitForWriteLatch );

	//  wait for ownership of the write latch if required

	if ( errSXWL == CSXWLatch::errWaitForWriteLatch )
		{
		cBFLatchStall++;
		pbf->sxwl.WaitForWriteLatch();
		}

	//  return the RW Image pointer

	pbfl->pv = pbf->pvRWImage;

	err = JET_errSuccess;

	//  validate OUT args

	Assert(	( err < JET_errSuccess && FBFRDWLatched( pbfl ) ) ||
			( err >= JET_errSuccess && FBFWriteLatched( pbfl ) ) );

	Assert( err < JET_errSuccess || PBF( pbfl->dwContext )->err != errBFIPageNotVerified );

	return err;
	}

void BFDowngradeWriteLatchToRDWLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFWriteLatched( pbfl ) );
	
	PBF pbf = PBF( pbfl->dwContext );

	//  downgrade our write latch to the exclusive latch

	pbf->sxwl.DowngradeWriteLatchToExclusiveLatch();

	//  return the RO Image pointer

	pbfl->pv = pbf->pvROImage;

	//  validate OUT args

	Assert( FBFRDWLatched( pbfl ) );
	}

void BFDowngradeWARLatchToRDWLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) );
	
	PBF pbf = PBF( pbfl->dwContext );

	//  mark this BF as not WAR Latched

	pbf->fWARLatch = fFalse;

	//  return the RO Image pointer

	pbfl->pv = pbf->pvROImage;

	//  validate OUT args

	Assert( FBFRDWLatched( pbfl ) );
	}

void BFDowngradeWriteLatchToReadLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFWriteLatched( pbfl ) );
	
	PBF pbf = PBF( pbfl->dwContext );

	//  downgrade our write latch to a shared latch

	pbf->sxwl.DowngradeWriteLatchToSharedLatch();

	//  return the RO Image pointer

	pbfl->pv = pbf->pvROImage;

	//  validate OUT args

	Assert( FBFReadLatched( pbfl ) );
	}

void BFDowngradeWARLatchToReadLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) );
	
	PBF pbf = PBF( pbfl->dwContext );

	//  mark this BF as not WAR Latched

	pbf->fWARLatch = fFalse;

	//  downgrade our exclusive latch to a shared latch

	pbf->sxwl.DowngradeExclusiveLatchToSharedLatch();

	//  return the RO Image pointer

	pbfl->pv = pbf->pvROImage;

	//  validate OUT args

	Assert( FBFReadLatched( pbfl ) );
	}

void BFDowngradeRDWLatchToReadLatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFRDWLatched( pbfl ) );
	
	PBF pbf = PBF( pbfl->dwContext );

	//  downgrade our exclusive latch to a shared latch

	pbf->sxwl.DowngradeExclusiveLatchToSharedLatch();

	//  validate OUT args

	Assert( FBFReadLatched( pbfl ) );
	}

void BFWriteUnlatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFWriteLatched( pbfl ) );

	//  if this IFMP / PGNO is clean, simply release the write latch

	const PBF			pbf		= PBF( pbfl->dwContext );

	if ( pbf->bfdf == bfdfClean )
		{
		const IFMP ifmp = pbf->ifmp;
		const PGNO pgno = pbf->pgno;

		pbf->sxwl.ReleaseWriteLatch();
		
		Assert( FBFNotLatched( ifmp, pgno ) );
		return;
		}

	//  if this IFMP / PGNO is impeding the checkpoint, mark it as filthy so that
	//  we will aggressively flush it

	FMP*	pfmp				= &rgfmp[ pbf->ifmp & ifmpMask ];
	LOG*	plog				= pfmp->Pinst()->m_plog;

	if (	CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) &&
			plog->CbOffsetLgpos(	plog->m_fRecoveringMode == fRecoveringRedo ?
										plog->m_lgposRedo :
										plog->m_lgposLogRec, pbf->lgposOldestBegin0 ) > 2 * cbCleanCheckpointDepthMax )
		{
		BFIDirtyPage( pbf, bfdfFilthy );
		}

	//  if this IFMP / PGNO is filthy, try to version it so that when we try and
	//  aggressively flush it later, it will not cause subsequent RDW/WAR/Write
	//  latches to stall on the page flush
	//
	//  NOTE:  there is no need to version the page if is already versioned

	if ( pbf->bfdf == bfdfFilthy && pbf->pbfTimeDepChainNext == pbfNil )
		{
		PBF pbfOld;
		if ( ErrBFIVersionPage( pbf, &pbfOld ) >= JET_errSuccess )
			{
			pbfOld->sxwl.ReleaseWriteLatch();
			}
		}
	
	//  release our write latch
	
	const IFMP			ifmp	= pbf->ifmp;
	const PGNO			pgno	= pbf->pgno;
	const BFDirtyFlags	bfdf	= BFDirtyFlags( pbf->bfdf );
	
	pbf->sxwl.ReleaseWriteLatch();

	//  if this IFMP / PGNO was filthy, try to flush it

	if ( bfdf == bfdfFilthy )
		{
		if ( ErrBFIFlushPage( pbf, bfdfFilthy ) == errBFIPageFlushed )
			{
			cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
			if ( ifmp & ifmpSLV )
				{
				CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
				}
			else
				{
				CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
				}
			}
		}

	//  validate OUT args

	Assert( FBFNotLatched( ifmp, pgno ) );
	}

void BFWARUnlatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) );

	//  if this IFMP / PGNO is clean, simply release the war latch

	const PBF			pbf		= PBF( pbfl->dwContext );

	if ( pbf->bfdf == bfdfClean )
		{
		const IFMP ifmp = pbf->ifmp;
		const PGNO pgno = pbf->pgno;

		pbf->fWARLatch = fFalse;
		pbf->sxwl.ReleaseExclusiveLatch();
		
		Assert( FBFNotLatched( ifmp, pgno ) );
		return;
		}

	//  if this IFMP / PGNO is impeding the checkpoint, mark it as filthy so that
	//  we will aggressively flush it

	FMP*	pfmp				= &rgfmp[ pbf->ifmp & ifmpMask ];
	LOG*	plog				= pfmp->Pinst()->m_plog;

	if (	CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) &&
			plog->CbOffsetLgpos(	plog->m_fRecoveringMode == fRecoveringRedo ?
										plog->m_lgposRedo :
										plog->m_lgposLogRec, pbf->lgposOldestBegin0 ) > 2 * cbCleanCheckpointDepthMax )
		{
		BFIDirtyPage( pbf, bfdfFilthy );
		}

	//  if this IFMP / PGNO is filthy, try to version it so that when we try and
	//  aggressively flush it later, it will not cause subsequent RDW/WAR/Write
	//  latches to stall on the page flush
	//
	//  NOTE:  there is no need to version the page if is already versioned

	if ( pbf->bfdf == bfdfFilthy && pbf->pbfTimeDepChainNext == pbfNil )
		{
		PBF pbfOld;
		if ( ErrBFIVersionPage( pbf, &pbfOld ) >= JET_errSuccess )
			{
			pbfOld->sxwl.ReleaseWriteLatch();
			}
		}
	
	//  mark this BF as not WAR Latched

	pbf->fWARLatch = fFalse;

	//  release our exclusive latch
	
	const IFMP			ifmp	= pbf->ifmp;
	const PGNO			pgno	= pbf->pgno;
	const BFDirtyFlags	bfdf	= BFDirtyFlags( pbf->bfdf );
	
	pbf->sxwl.ReleaseExclusiveLatch();

	//  if this IFMP / PGNO was filthy, try to flush it

	if ( bfdf == bfdfFilthy )
		{
		if ( ErrBFIFlushPage( pbf, bfdfFilthy ) == errBFIPageFlushed )
			{
			cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
			if ( ifmp & ifmpSLV )
				{
				CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
				}
			else
				{
				CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
				}
			}
		}

	//  validate OUT args

	Assert( FBFNotLatched( ifmp, pgno ) );
	}

void BFRDWUnlatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFRDWLatched( pbfl ) );

	//  if this IFMP / PGNO is clean, simply release the rdw latch

	const PBF			pbf		= PBF( pbfl->dwContext );

	if ( pbf->bfdf == bfdfClean )
		{
		const IFMP ifmp = pbf->ifmp;
		const PGNO pgno = pbf->pgno;

		pbf->sxwl.ReleaseExclusiveLatch();
		
		Assert( FBFNotLatched( ifmp, pgno ) );
		return;
		}

	//  if this IFMP / PGNO is impeding the checkpoint, mark it as filthy so that
	//  we will aggressively flush it

	FMP*	pfmp				= &rgfmp[ pbf->ifmp & ifmpMask ];
	LOG*	plog				= pfmp->Pinst()->m_plog;

	if (	CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) &&
			plog->CbOffsetLgpos(	plog->m_fRecoveringMode == fRecoveringRedo ?
										plog->m_lgposRedo :
										plog->m_lgposLogRec, pbf->lgposOldestBegin0 ) > 2 * cbCleanCheckpointDepthMax )
		{
		BFIDirtyPage( pbf, bfdfFilthy );
		}

	//  if this IFMP / PGNO is filthy, try to version it so that when we try and
	//  aggressively flush it later, it will not cause subsequent RDW/WAR/Write
	//  latches to stall on the page flush
	//
	//  NOTE:  there is no need to version the page if is already versioned

	if ( pbf->bfdf == bfdfFilthy && pbf->pbfTimeDepChainNext == pbfNil )
		{
		PBF pbfOld;
		if ( ErrBFIVersionPage( pbf, &pbfOld ) >= JET_errSuccess )
			{
			pbfOld->sxwl.ReleaseWriteLatch();
			}
		}
	
	//  release our exclusive latch
	
	const IFMP			ifmp	= pbf->ifmp;
	const PGNO			pgno	= pbf->pgno;
	const BFDirtyFlags	bfdf	= BFDirtyFlags( pbf->bfdf );
	
	pbf->sxwl.ReleaseExclusiveLatch();

	//  if this IFMP / PGNO was filthy, try to flush it

	if ( bfdf == bfdfFilthy )
		{
		if ( ErrBFIFlushPage( pbf, bfdfFilthy ) == errBFIPageFlushed )
			{
			cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
			if ( ifmp & ifmpSLV )
				{
				CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
				}
			else
				{
				CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
				}
			}
		}

	//  validate OUT args

	Assert( FBFNotLatched( ifmp, pgno ) );
	}

void BFReadUnlatch( BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFReadLatched( pbfl ) );

	//  if this IFMP / PGNO is not filthy, simply release the read latch

	const PBF			pbf		= PBF( pbfl->dwContext );

	if ( pbf->bfdf != bfdfFilthy )
		{
		const IFMP ifmp = pbf->ifmp;
		const PGNO pgno = pbf->pgno;

		pbf->sxwl.ReleaseSharedLatch();
	
		Assert( FBFNotLatched( ifmp, pgno ) );
		return;
		}

	//  release our shared latch
	
	const IFMP			ifmp	= pbf->ifmp;
	const PGNO			pgno	= pbf->pgno;
	
	pbf->sxwl.ReleaseSharedLatch();

	//  try to flush this filthy IFMP / PGNO

	if ( ErrBFIFlushPage( pbf, bfdfFilthy ) == errBFIPageFlushed )
		{
		cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
		if ( ifmp & ifmpSLV )
			{
			CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
			}
		else
			{
			CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
			}
		}

	//  validate OUT args

	Assert( FBFNotLatched( ifmp, pgno ) );
	}

BOOL FBFReadLatched( const BFLatch* pbfl )
	{
	return	FBFICacheValidPv( pbfl->pv ) &&
			FBFICacheValidPbf( PBF( pbfl->dwContext ) ) &&
			pbfl->pv == PBF( pbfl->dwContext )->pvROImage &&
			PBF( pbfl->dwContext )->sxwl.FOwnSharedLatch();
	}

BOOL FBFNotReadLatched( const BFLatch* pbfl )
	{
	return	!FBFICacheValidPv( pbfl->pv ) ||
			!FBFICacheValidPbf( PBF( pbfl->dwContext ) ) ||
			pbfl->pv != PBF( pbfl->dwContext )->pvROImage ||
			PBF( pbfl->dwContext )->sxwl.FNotOwnSharedLatch();
	}

BOOL FBFReadLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fReadLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is Read Latched if it is present in the hash table and
	//  the associated BF is share latched by us

	fReadLatched =	errHash == BFHash::errSuccess &&
					pgnopbf.pbf->sxwl.FOwnSharedLatch();

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fReadLatched;
	}

BOOL FBFNotReadLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fNotReadLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is not Read Latched if it is not present in the hash
	//  table or the associated BF is not share latched by us

	fNotReadLatched =	errHash == BFHash::errEntryNotFound ||
						pgnopbf.pbf->sxwl.FNotOwnSharedLatch();

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fNotReadLatched;
	}

BOOL FBFRDWLatched( const BFLatch* pbfl )
	{
	return	FBFICacheValidPv( pbfl->pv ) &&
			FBFICacheValidPbf( PBF( pbfl->dwContext ) ) &&
			pbfl->pv == PBF( pbfl->dwContext )->pvROImage &&
			!PBF( pbfl->dwContext )->fWARLatch &&
			PBF( pbfl->dwContext )->sxwl.FOwnExclusiveLatch();
	}

BOOL FBFNotRDWLatched( const BFLatch* pbfl )
	{
	return	!FBFICacheValidPv( pbfl->pv ) ||
			!FBFICacheValidPbf( PBF( pbfl->dwContext ) ) ||
			pbfl->pv != PBF( pbfl->dwContext )->pvROImage ||
			PBF( pbfl->dwContext )->fWARLatch ||
			PBF( pbfl->dwContext )->sxwl.FNotOwnExclusiveLatch();
	}

BOOL FBFRDWLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fRDWLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is RDW Latched if it is present in the hash table and
	//  the associated BF is not marked as WAR Latched and the associated BF is
	//  not exclusively latched by us

	fRDWLatched =	errHash == BFHash::errSuccess &&
					!pgnopbf.pbf->fWARLatch &&
					pgnopbf.pbf->sxwl.FOwnExclusiveLatch();

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fRDWLatched;
	}

BOOL FBFNotRDWLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fNotRDWLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is not RDW Latched if it is not present in the hash
	//  table or the associated BF is marked as WAR Latched or the associated
	//  BF is not exclusively latched by us

	fNotRDWLatched =	errHash == BFHash::errEntryNotFound ||
						pgnopbf.pbf->fWARLatch ||
						pgnopbf.pbf->sxwl.FNotOwnExclusiveLatch();

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fNotRDWLatched;
	}

BOOL FBFWARLatched( const BFLatch* pbfl )
	{
	return	FBFICacheValidPv( pbfl->pv ) &&
			FBFICacheValidPbf( PBF( pbfl->dwContext ) ) &&
			pbfl->pv == PBF( pbfl->dwContext )->pvRWImage &&
			PBF( pbfl->dwContext )->fWARLatch &&
			PBF( pbfl->dwContext )->sxwl.FOwnExclusiveLatch();
	}

BOOL FBFNotWARLatched( const BFLatch* pbfl )
	{
	return	!FBFICacheValidPv( pbfl->pv ) ||
			!FBFICacheValidPbf( PBF( pbfl->dwContext ) ) ||
			pbfl->pv != PBF( pbfl->dwContext )->pvRWImage ||
			!PBF( pbfl->dwContext )->fWARLatch ||
			PBF( pbfl->dwContext )->sxwl.FNotOwnExclusiveLatch();
	}

BOOL FBFWARLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fWARLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is WAR Latched if it is present in the hash table and
	//  the associated BF is marked as WAR Latched and the associated BF is not
	//  exclusively latched by us

	fWARLatched =	errHash == BFHash::errSuccess &&
					pgnopbf.pbf->fWARLatch &&
					pgnopbf.pbf->sxwl.FOwnExclusiveLatch();

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fWARLatched;
	}

BOOL FBFNotWARLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fNotWARLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is not WAR Latched if it is not present in the hash
	//  table or the associated BF is not marked as WAR Latched or the associated
	//  BF is not exclusively latched by us

	fNotWARLatched =	errHash == BFHash::errEntryNotFound ||
						!pgnopbf.pbf->fWARLatch ||
						pgnopbf.pbf->sxwl.FNotOwnExclusiveLatch();

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fNotWARLatched;
	}

BOOL FBFWriteLatched( const BFLatch* pbfl )
	{
	return	FBFICacheValidPv( pbfl->pv ) &&
			FBFICacheValidPbf( PBF( pbfl->dwContext ) ) &&
			pbfl->pv == PBF( pbfl->dwContext )->pvRWImage &&
			PBF( pbfl->dwContext )->sxwl.FOwnWriteLatch();
	}

BOOL FBFNotWriteLatched( const BFLatch* pbfl )
	{
	return	!FBFICacheValidPv( pbfl->pv ) ||
			!FBFICacheValidPbf( PBF( pbfl->dwContext ) ) ||
			pbfl->pv != PBF( pbfl->dwContext )->pvRWImage ||
			PBF( pbfl->dwContext )->sxwl.FNotOwnWriteLatch();
	}

BOOL FBFWriteLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fWriteLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is Write Latched if it is present in the hash table and
	//  the associated BF is write latched by us

	fWriteLatched =	errHash == BFHash::errSuccess &&
					pgnopbf.pbf->sxwl.FOwnWriteLatch();

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fWriteLatched;
	}

BOOL FBFNotWriteLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fNotWriteLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is not Write Latched if it is not present in the hash
	//  table or the associated BF is not write latched by us

	fNotWriteLatched =	errHash == BFHash::errEntryNotFound ||
						pgnopbf.pbf->sxwl.FNotOwnWriteLatch();

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fNotWriteLatched;
	}

BOOL FBFLatched( const BFLatch* pbfl )
	{
	return	FBFICacheValidPv( pbfl->pv ) &&
			FBFICacheValidPbf( PBF( pbfl->dwContext ) ) &&
			(	pbfl->pv == PBF( pbfl->dwContext )->pvRWImage ||
				pbfl->pv == PBF( pbfl->dwContext )->pvROImage ) &&
			(	PBF( pbfl->dwContext )->sxwl.FOwnSharedLatch() ||
				PBF( pbfl->dwContext )->sxwl.FOwnExclusiveLatch() ||
				PBF( pbfl->dwContext )->sxwl.FOwnWriteLatch() );
	}

BOOL FBFNotLatched( const BFLatch* pbfl )
	{
	return	!FBFICacheValidPv( pbfl->pv ) ||
			!FBFICacheValidPbf( PBF( pbfl->dwContext ) ) ||
			(	pbfl->pv != PBF( pbfl->dwContext )->pvRWImage &&
				pbfl->pv != PBF( pbfl->dwContext )->pvROImage ) ||
			(	PBF( pbfl->dwContext )->sxwl.FNotOwnSharedLatch() &&
				PBF( pbfl->dwContext )->sxwl.FNotOwnExclusiveLatch() &&
				PBF( pbfl->dwContext )->sxwl.FNotOwnWriteLatch() );
	}

BOOL FBFLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is latched if it is present in the hash table and the
	//  associated BF is latched by us

	fLatched =	errHash != BFHash::errEntryNotFound &&
					(	pgnopbf.pbf->sxwl.FOwnSharedLatch() ||
						pgnopbf.pbf->sxwl.FOwnExclusiveLatch() ||
						pgnopbf.pbf->sxwl.FOwnWriteLatch() );

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fLatched;
	}

BOOL FBFNotLatched( IFMP ifmp, PGNO pgno )
	{
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BOOL			fNotLatched;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

	//  this IFMP / PGNO is not latched if it is not present in the hash table
	//  or the associated BF is not latched by us

	fNotLatched =	errHash == BFHash::errEntryNotFound ||
					(	pgnopbf.pbf->sxwl.FNotOwnSharedLatch() &&
						pgnopbf.pbf->sxwl.FNotOwnExclusiveLatch() &&
						pgnopbf.pbf->sxwl.FNotOwnWriteLatch() );

	//  release our lock on the hash table

	bfhash.ReadUnlockKey( &lock );

	//  return the result of the test

	return fNotLatched;
	}


////////////////
//  Page State

//  These functions are used to control and query the state of a page (or 
//  pages) in the buffer cache.

//  Marks the given WAR Latched or Write Latched page as dirty.  This means
//  that the given buffer for this page contains changes that should be written
//  to disk.  The degree of dirtiness is specified by the given dirty flags.
//  A page can only be made more dirty.  Trying to make a page less dirty than
//  it currently is will have no effect.

void BFDirty( const BFLatch* pbfl, BFDirtyFlags bfdf )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) || FBFWriteLatched( pbfl ) );

	//  dirty the BF

	BFIDirtyPage( PBF( pbfl->dwContext ), bfdf );
	}

//  Returns the current dirtiness of the given latched page.

BFDirtyFlags FBFDirty( const BFLatch* pbfl )
	{
	//  validate IN args

	Assert( FBFLatched( pbfl ) );

	//  get the dirty flag for the page

	return BFDirtyFlags( PBF( pbfl->dwContext )->bfdf );
	}
	

////////////////////////
//  Logging / Recovery

//  The following functions are provided for logging / recovery support.  
//  The modify log position for each buffer is used to prevent a dirty 
//  buffer from being flushed to disk before the changes in it can be logged 
//  (under the Write Ahead Logging paradigm).  The Begin 0 log position for 
//  each buffer indicates the oldest transaction that has made a 
//  modification to that buffer.  This is used in computing the Oldest Begin 
//  0 log position, which indicates the oldest transaction that still has 
//  unsaved changes in the buffer cache.  This log position is used to 
//  compute the current checkpoint depth.

//  Returns the log position of the oldest Begin Transaction at level 0 for 
//  any session that has modified any buffer in the cache. If no buffers 
//  have been modified, then this function will return lgposMax.  This 
//  function is used to compute the current checkpoint depth.

void BFGetLgposOldestBegin0( IFMP ifmp, LGPOS* plgpos )
	{
	FMP* pfmp = &rgfmp[ ifmp & ifmpMask ];

	//  if no context is present, there must be no oldest begin 0

	pfmp->RwlBFContext().EnterAsReader();
	BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( ifmp & ifmpSLV ) );
	if ( !pbffmp )
		{
		*plgpos = lgposMax;
		pfmp->RwlBFContext().LeaveAsReader();
		return;
		}

	//  find the first entry in the oldest begin 0 index

	BFOB0::ERR		errOB0;
	BFOB0::CLock	lockOB0;

	pbffmp->bfob0.MoveBeforeFirst( &lockOB0 );
	errOB0 = pbffmp->bfob0.ErrMoveNext( &lockOB0 );

	//  we found the first entry in the index
	
	if ( errOB0 != BFOB0::errNoCurrentEntry )
		{
		//  return the lgpos of this oldest entry rounded down to the next level
		//  of uncertainty in the index
		
		PBF pbf;
		errOB0 = pbffmp->bfob0.ErrRetrieveEntry( &lockOB0, &pbf );
		Assert( errOB0 == BFOB0::errSuccess );

		plgpos->SetByIbOffset(	(	pbf->lgposOldestBegin0.IbOffset() /
									dlgposBFOB0Uncertainty.IbOffset() ) *
								dlgposBFOB0Uncertainty.IbOffset() );
		}

	//  we did not find the first entry in the index

	else
		{
		//  return lgposMax to indicate that there are no BFs with an Oldest
		//  Begin 0 dependency set

		*plgpos = lgposMax;
		}

	//  unlock the oldest begin 0 index

	pbffmp->bfob0.UnlockKeyPtr( &lockOB0 );

	//  scan the Oldest Begin 0 Overflow List and collect the Oldest Begin 0
	//  from there as well

	pbffmp->critbfob0ol.Enter();
	for ( PBF pbf = pbffmp->bfob0ol.PrevMost(); pbf != pbfNil; pbf = pbffmp->bfob0ol.Next( pbf ) )
		{
		if ( CmpLgpos( plgpos, &pbf->lgposOldestBegin0 ) > 0 )
			{
			*plgpos = pbf->lgposOldestBegin0;
			}
		}
	pbffmp->critbfob0ol.Leave();
	pfmp->RwlBFContext().LeaveAsReader();
	}

//  Sets the log position for the most recent log record to reference this 
//  buffer for a modification.  This log position determines when we can 
//  safely write a buffer to disk by allowing us to wait for the log to be 
//  flushed past this log position (under Write Ahead Logging).  This value 
//  is set to lgposMin by default.  The page must be WAR Latched or Write
//  Latched.

void BFSetLgposModify( const BFLatch* pbfl, LGPOS lgpos )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) || FBFWriteLatched( pbfl ) );

	FMP* pfmp = &rgfmp[ PBF( pbfl->dwContext )->ifmp & ifmpMask ];
	Assert(	( !pfmp->Pinst()->m_plog->m_fLogDisabled && pfmp->FLogOn() ) ||
			!CmpLgpos( &lgpos, &lgposMin ) );

	//  set the lgposModify for this BF

	BFISetLgposModify( PBF( pbfl->dwContext ), lgpos );
	}

//  Sets the log position for the last Begin Transaction at level 0 for this 
//  session that modified this buffer, if more recent than the last log 
//  position set.  This log position is used to determine the current 
//  checkpoint depth.  This value is set to lgposMax by default.  The page must
//  be WAR Latched or Write Latched.

void BFSetLgposBegin0( const BFLatch* pbfl, LGPOS lgpos )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) || FBFWriteLatched( pbfl ) );

	FMP* pfmp = &rgfmp[ PBF( pbfl->dwContext )->ifmp & ifmpMask ];
	Assert(	( !pfmp->Pinst()->m_plog->m_fLogDisabled && pfmp->FLogOn() ) ||
			!CmpLgpos( &lgpos, &lgposMax ) );

	//  set the lgposOldestBegin0 for this BF

	BFISetLgposOldestBegin0( PBF( pbfl->dwContext ), lgpos );
	}


/////////////
//  Preread

//  The following functions provide support for prereading pages from the 
//  disk before they are actually needed.  This technique can be used to 
//  minimize or eliminate buffer cache misses when Read Latching pages.

//  Prereads the given range of pages in the given database.  If cpg is greater
//  than zero, we will preread forwards from pgnoFirst to pgnoFirst + cpg - 1.
//  If cpg is less than zero, we will preread backwards from pgnoFirst to 
//  pgnoFirst + cpg + 1.  cpg can not be zero.

void BFPrereadPageRange( IFMP ifmp, PGNO pgnoFirst, CPG cpg, CPG* pcpgActual )
	{
	long cbfPreread = 0;
	
	//  calculate preread direction

	long lDir = cpg > 0 ? 1 : -1;

	//  schedule all specified pages to be preread

	for ( ULONG pgno = pgnoFirst; pgno != pgnoFirst + cpg; pgno += lDir )
		{
		const ERR err = ErrBFIPrereadPage( ifmp, pgno );

		if ( err == JET_errSuccess )
			{
			cbfPreread++;
			}
		else if ( err != errBFPageCached )
			{
			break;
			}
		}

	//  start issuing prereads

	if ( cbfPreread )
		{
		if ( ifmp & ifmpSLV )
			{
			CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
			}
		else
			{
			CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
			}
		}

	//  return the number of pages preread if requested

	if ( pcpgActual )
		{
		*pcpgActual = cpg > 0 ? pgno - pgnoFirst : pgnoFirst - pgno;
		}
	}

//  Prereads the given array of single pages in the given database.

void BFPrereadPageList( IFMP ifmp, PGNO* prgpgno, CPG* pcpgActual )
	{
	long cbfPreread = 0;
	
	//  schedule each page for preread

	for ( ULONG ipgno = 0; prgpgno[ ipgno ] != pgnoNull; ipgno++ )
		{
		const ERR err = ErrBFIPrereadPage( ifmp, prgpgno[ ipgno ] );

		if ( err == JET_errSuccess )
			{
			cbfPreread++;
			}
		else if ( err != errBFPageCached )
			{
			break;
			}
		}

	//  start issuing prereads

	if ( cbfPreread )
		{
		if ( ifmp & ifmpSLV )
			{
			CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
			}
		else
			{
			CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
			}
		}

	//  return the number of pages preread if requested

	if ( pcpgActual )
		{
		*pcpgActual = ipgno;
		}
	}
	

///////////////////////
//  Memory Allocation

//  The following routines allow the user to allocate space in the buffer 
//  cache for use as general purpose memory.  Remember that every buffer 
//  allocated from the buffer cache will reduce the buffer cache's
//  effectiveness by reducing the amount of memory it has to utilize.

//  Allocates a buffer for use as general purpose memory.  This buffer can 
//  not be stolen for use by others.  The buffer must be returned to the 
//  buffer cache when it is no longer needed via BFFree().  Note that if we 
//  cannot immediately allocate a buffer because they are all currently in 
//  use, we will wait until a buffer is free to return, possibly across an
//  I/O.

void BFAlloc( void** ppv )
	{
	//  init OUT args

	*ppv = NULL;
	
	//  try forever until we allocate a temporary buffer

	for ( BOOL fWait = fFalse; !(*ppv); fWait = fTrue )
		{
		//  we allocated a BF from the avail pool

		PBF pbf;
		if ( ErrBFIAllocPage( &pbf, fWait ) == JET_errSuccess )
			{
			//  mark this BF as in use for memory

			pbf->fMemory = fTrue;
			AtomicIncrement( (long*)&cBFMemory );

			//  give the RW Image pointer for this BF to the caller for use as memory

			*ppv = pbf->pvRWImage;
			}

		//  we didn't allocate a BF from the avail pool

		else
			{
			//  allocate a page from memory

			*ppv = PvOSMemoryPageAlloc( g_cbPage, NULL );

			if ( !(*ppv) && fWait )
				{
				UtilSleep( cmsecWaitGeneric );
				}
			}
		}
	}

//  Frees a buffer allocated with BFAlloc().

void BFFree( void* pv )
	{
	//  validate IN args

	Assert( PbfBFICachePv( pv ) != pbfNil || !( DWORD_PTR( pv ) % OSMemoryPageReserveGranularity() ) );
	Assert( PbfBFICachePv( pv ) == pbfNil || PbfBFICachePv( pv )->fMemory );

	//  retrieve the BF associated with this pointer

	const PBF pbf = PbfBFICachePv( pv );

	//  this temporary buffer is a BF

	if ( pbf != pbfNil )
		{
		//  reset this BF's memory status

		pbf->fMemory = fFalse;
		AtomicDecrement( (long*)&cBFMemory );

		//  free the BF to the avail pool

		BFIFreePage( pbf );
		}

	//  this temporary buffer is page memory

	else
		{
		//  free the page memory

		OSMemoryPageFree( pv );
		}
	}
	

//////////////////
//  Dependencies

//  Dependencies can be created between buffers to force one buffer to be 
//  flushed to disk successfully before the other.  This mechanism is an 
//  optimization to reduce logging overhead during splits and merges, which 
//  move large amounts of data between pages.  If we ensure that buffers are 
//  flushed in a particular order, there is no need to log the data that is 
//  actually moved because we can always find it somewhere (possibly in more 
//  than one place) in the database file.

//  Depends one buffer containing a RDW Latched / WAR Latched / Write Latched
//  page on another.  This forces the depended buffer to be flushed after the
//  buffer it is depended on.  The dependency must be declared before the
//  relevant modification is made.

ERR ErrBFDepend( const BFLatch* pbflFlushFirst, const BFLatch* pbflFlushSecond )
	{
	ERR	err		= JET_errSuccess;
	PBF pbf		= PBF( pbflFlushFirst->dwContext );
	PBF pbfOld	= pbfNil;
	PBF pbfD	= PBF( pbflFlushSecond->dwContext );
	PBF pbfDOld	= pbfNil;
	
	//  validate IN args

	Assert( FBFLatched( pbflFlushFirst ) && FBFNotReadLatched( pbflFlushFirst ) );
	Assert( FBFLatched( pbflFlushSecond ) && FBFNotReadLatched( pbflFlushSecond ) );

	//  no dependency is required if logging is disabled for this IFMP

	FMP* pfmp = &rgfmp[ pbf->ifmp & ifmpMask ];
	Assert( !pfmp->FLogOn() || !pfmp->Pinst()->m_plog->m_fLogDisabled );
	if ( !pfmp->FLogOn() )
		{
		return JET_errSuccess;
		}

	//  mark all BFs involved as at least bfdfDirty

	BFIDirtyPage( pbf, bfdfDirty );
	BFIDirtyPage( pbfD, bfdfDirty );

	//  setting this dependency COULD cause a cycle through space or time
	//
	//  NOTE:  it is WAY to expensive to determine this exactly, so we will
	//  guess conservatively

	if ( pbf->FDependent() || pbf->pbfTimeDepChainNext != pbfNil )
		{
		if ( pbf == pbfD )
			{
			//  Case I:  Simple Time Dependency

			//  just version this page

			Call( ErrBFIVersionPage( pbf, &pbfOld ) );
			}

		else
			{
			//  Case II:  Dependency Cycle Avoidance

			//  version both pages

			Call( ErrBFIVersionPage( pbf, &pbfOld ) );
			Call( ErrBFIVersionPage( pbfD, &pbfDOld ) );

			//  set the dependency between the new images of the pages

			critBFDepend.Enter();
			BFIDepend( pbf, pbfD );
			critBFDepend.Leave();
			}
		}

	//  setting this dependency could not possibly cause a cycle but it would
	//  cause a branch (i.e. more than one direct dependent)

	else if ( pbf->pbfDependent != pbfNil )
		{
		if ( pbf == pbfD )
			{
			//  Case III:  Simple Time Dependency

			//  just version this page

			Call( ErrBFIVersionPage( pbf, &pbfOld ) );
			}
		else
			{
			//  our dependent is already set

			if ( pbf->pbfDependent == pbfD )
				{
				//  Case IV:  Duplicate Dependency

				//  leave the existing dependency
				}

			//  our dependent is not already set

			else
				{
				//  Case V:  Dependency Branch Avoidance

				//  version both pages
				//
				//  NOTE:  we would just version the first page, but doing this in
				//  and of itself causes the potential for a cycle!  as a result, we
				//  treat branch avoidance just like cycle avoidance

				Call( ErrBFIVersionPage( pbf, &pbfOld ) );
				Call( ErrBFIVersionPage( pbfD, &pbfDOld ) );

				//  set the dependency between the new images of the pages

				critBFDepend.Enter();
				BFIDepend( pbf, pbfD );
				critBFDepend.Leave();
				}
			}
		}

	//  setting this dependency would not cause a cycle or a branch

	else
		{
		if ( pbf == pbfD )
			{
			//  Case VI:  Self Dependency

			//  there is no need to set a dependency on yourself if you have no
			//  dependents and are dependent on no one else
			}
		else
			{
			//  Case VII:  Simple Dependency

			//  determine the length of the dependency chain that would be created

			critBFDepend.Enter();
			
			long cDepChainLength = 1;
			for ( PBF pbfT = pbfD; pbfT != pbfNil ; pbfT = pbfT->pbfDependent )
				{
				cDepChainLength++;
				}

			critBFDepend.Leave();

			//  this dependency would create a dependency chain that is too long

			if ( cDepChainLength > cDepChainLengthMax )
				{
				//  version the second page so that when we set the new dependency,
				//  it will not inhibit the dependency chain starting at the second
				//  page from being flushed, breaking the chain

				Call( ErrBFIVersionPage( pbfD, &pbfDOld ) );
				}

			//  set the dependency between the two pages

			critBFDepend.Enter();
			BFIDepend( pbf, pbfD );
			critBFDepend.Leave();
			}
		}

HandleError:
	if ( pbfOld != pbfNil )
		{
		pbfOld->sxwl.ReleaseWriteLatch();
		}
	if ( pbfDOld != pbfNil )
		{
		pbfDOld->sxwl.ReleaseWriteLatch();
		}
	return err;
	}


///////////////////
//  Purge / Flush

void BFPurge( BFLatch* pbfl, BOOL fPurgeDirty )
	{
	//  validate IN args

	Assert( FBFReadLatched( pbfl ) );

	//  this BF is clean or we can purge dirty BFs and we can get the write latch

	if (	( FBFDirty( pbfl ) < bfdfDirty || fPurgeDirty ) &&
			ErrBFUpgradeReadLatchToWriteLatch( pbfl ) == JET_errSuccess )
		{
		//  just mark this BF as clean to prevent any data from being flushed.
		//  we will allow the clean thread to evict it later.  this will delay
		//  freeing the BF but will be more scalable

		BFICleanPage( PBF( pbfl->dwContext ) );

		//  release the write latch

		BFWriteUnlatch( pbfl );
		}

	//  this BF was dirty and we can't purge dirty BFs or we couldn't get the
	//  write latch

	else
		{
		//  release the read latch without purging the BF

		BFReadUnlatch( pbfl );
		}
	}

void BFPurge( IFMP ifmp, PGNO pgno, CPG cpg )
	{
	//  retry the purge until we have evicted all cached pages for this IFMP

	BOOL	fRetryPurge	= fFalse;
	PGNO	pgnoFirst	= ( pgnoNull == pgno ) ? PGNO( 1 )  : pgno;
	PGNO	pgnoLast	= ( pgnoNull == pgno ) ? PGNO( -1 ) : pgno + cpg - 1;
	do	{
		fRetryPurge	= fFalse;
			
		//  scan through all initialized BFs looking for cached pages from this
		//  IFMP

		for ( IBF ibf = 0; ibf < cbfInit; ibf++ )
			{
			PBF pbf = PbfBFICacheIbf( ibf );

			//  if this BF doesn't contain a cached page from this IFMP within
			//	the given range, skip it now

			if ( pbf->ifmp != ifmp || pbf->pgno < pgnoFirst || pbf->pgno > pgnoLast )
				{
				continue;
				}

			//  we can exclusively latch this BF

			CSXWLatch::ERR errSXWL = pbf->sxwl.ErrTryAcquireExclusiveLatch();
			
			if ( errSXWL == CSXWLatch::errSuccess )
				{
				//  this BF contains the IFMP and is within the given page range that we are purging
				
				if ( pbf->ifmp == ifmp && pbf->pgno >= pgnoFirst && pbf->pgno <= pgnoLast )
					{
					//  lock this BF in the LRUK in preparation for a possible eviction

					BFLRUK::CLock	lockLRUK;
					bflruk.LockResourceForEvict( pbf, &lockLRUK );

					//  release our exclusive latch.  we do not have to worry about
					//  the page being evicted because we have the LRUK locked

					pbf->sxwl.ReleaseExclusiveLatch();

					//  try to evict this page

					const ERR errEvict = ErrBFIEvictPage( pbf, &lockLRUK, fTrue );

					//  we failed to evict this page

					if ( errEvict < JET_errSuccess )
						{
						Assert( errEvict == errBFIPageNotEvicted ||
								errEvict == errBFLatchConflict );
						
						//  we will need to try again later to check this page

						fRetryPurge = fTrue;
						}

					//  unlock the LRUK

					bflruk.UnlockResourceForEvict( &lockLRUK );
					}

				//  this BF doesn't contain the IFMP or isn't within the given page range that we are purging afterall

				else
					{
					//  release our exclusive latch and continue our search

					pbf->sxwl.ReleaseExclusiveLatch();
					}
				}

			//  we could not exclusively latch this BF

			else
				{
				Assert( errSXWL == CSXWLatch::errLatchConflict );
				
				//  we will need to try again later to check this page

				fRetryPurge = fTrue;
				}
			}

		//  we are going to retry the purge

		if ( fRetryPurge )
			{
			//  sleep to wait for the resolution of any processes preventing us
			//  from evicting pages based on real time events
			
			UtilSleep( cmsecWaitGeneric );
			}
		}
	while ( fRetryPurge );

	//	we are purging all pages in the IFMP

	if ( pgnoNull == pgno )
		{
		//  we have an existing BF FMP Context

		FMP* pfmp = &rgfmp[ ifmp & ifmpMask ];
		pfmp->RwlBFContext().EnterAsWriter();
		BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( ifmp & ifmpSLV ) );
		if ( pbffmp )
			{
			//  test to see if the existing OB0 Index is empty

			BOOL fEmpty = fTrue;
			
			BFOB0::CLock	lockOB0;
			pbffmp->bfob0.MoveBeforeFirst( &lockOB0 );
			fEmpty = fEmpty && pbffmp->bfob0.ErrMoveNext( &lockOB0 ) == BFOB0::errNoCurrentEntry;
			pbffmp->bfob0.UnlockKeyPtr( &lockOB0 );

			pbffmp->critbfob0ol.Enter();
			fEmpty = fEmpty && pbffmp->bfob0ol.FEmpty();
			pbffmp->critbfob0ol.Leave();

			//  we should be empty

			Enforce( fEmpty );

			//  delete our context

			pbffmp->bfob0.Term();
			pbffmp->BFFMPContext::~BFFMPContext();
			OSMemoryHeapFreeAlign( pbffmp );
			pfmp->SetDwBFContext( !!( ifmp & ifmpSLV ), NULL );
			}
		pfmp->RwlBFContext().LeaveAsWriter();
		}
	}


ERR ErrBFFlush( IFMP ifmp, BOOL fFlushAll, PGNO pgno, CPG cpg )
	{
	//  retry the flush until we have flushed as much of this IFMP as possible

	ERR		err			= JET_errSuccess;
	BOOL	fRetryFlush	= fFalse;
	long	cRetryFlush	= 0;
	BOOL	fIssueIO	= fFalse;
	PGNO	pgnoFirst	= ( pgnoNull == pgno ) ? PGNO( 1 )  : pgno;
	PGNO	pgnoLast	= ( pgnoNull == pgno ) ? PGNO( -1 ) : pgno + cpg - 1;
	do	{
		fRetryFlush	= fFalse;
		fIssueIO	= fFalse;
		
		//  scan through all initialized BFs looking for cached pages from this
		//  IFMP

		for ( IBF ibf = 0; ibf < cbfInit; ibf++ )
			{
			PBF pbf = PbfBFICacheIbf( ibf );

			//  if this BF doesn't contain a cached page from this IFMP within
			//	the given range, skip it now

			if ( pbf->ifmp != ifmp || pbf->pgno < pgnoFirst || pbf->pgno > pgnoLast )
				{
				continue;
				}

			//  we have too many outstanding page flushes

			if ( cBFPageFlushPending >= cBFPageFlushPendingMax )
				{
				//  we will need to retry the flush later

				fRetryFlush = fTrue;
				cRetryFlush = 0;
				break;
				}

			//  possibly async flush this page

			const ERR errFlush = ErrBFIFlushPage( pbf );

			//  there was an error flushing this BF

			if ( errFlush < JET_errSuccess )
				{
				//  this BF still has dependencies

				if ( errFlush == errBFIRemainingDependencies )
					{
					//  we will need to retry the flush

					fRetryFlush = fTrue;
					}

				//  a BF (not necessarily this BF) is being written
				//
				//  NOTE:  this can be caused by this BF being flushed or
				//  by another BF being flushed in its behalf (say for
				//  removing a flush-order dependency)

				else if ( errFlush == errBFIPageFlushed )
					{
					cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
					
					//  we will need to retry the flush to check for
					//  completion of the write and issue the I/O

					fRetryFlush	= fTrue;
					fIssueIO	= fTrue;
					}

				//  a BF (not necessarily this BF) is still being written

				else if ( errFlush == errBFIPageFlushPending )
					{
					//  we will need to retry the flush to check for
					//  completion of the write

					fRetryFlush	= fTrue;
					}

				//  there was a latch conflict that prevented us from
				//  flushing this page

				else if ( errFlush == errBFLatchConflict )
					{
					//  we will need to try again later to check this page

					fRetryFlush = fTrue;
					}

				//  there was some other error

				else
					{
					//  save this error if we are not already failing

					err = err < JET_errSuccess ? err : errFlush;
					}
				}
			}
		
		//  we are going to retry the flush

		if ( fRetryFlush )
			{
			//  issue any remaining queued writes

			if ( fIssueIO )
				{
				if ( ifmp & ifmpSLV )
					{
					CallS( rgfmp[ ifmp & ifmpMask ].PfapiSLV()->ErrIOIssue() );
					}
				else
					{
					CallS( rgfmp[ ifmp ].Pfapi()->ErrIOIssue() );
					}
				}
			
			//  sleep to attempt to resolve outstanding writes and wait for the
			//  resolution of dependencies based on real time events

			UtilSleep( cmsecWaitGeneric );
			}
		}
	while ( fRetryFlush && ( fFlushAll || ++cRetryFlush < 2 * cDepChainLengthMax ) );

	//  we have an existing BF FMP Context

	FMP* pfmp = &rgfmp[ ifmp & ifmpMask ];
	pfmp->RwlBFContext().EnterAsWriter();
	BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( ifmp & ifmpSLV ) );
	if ( pbffmp )
		{
		//  make sure that if we are performing a full flush that there are no
		//  entries pointing to dirty buffers in the OB0 Index.  there can be
		//  entries pointing to clean buffers because of the way we maintain
		//  this index

		BFOB0::ERR		errOB0;
		BFOB0::CLock	lockOB0;

		pbffmp->bfob0.MoveBeforeFirst( &lockOB0 );
		while ( pbffmp->bfob0.ErrMoveNext( &lockOB0 ) != BFOB0::errNoCurrentEntry )
			{
			PBF pbf;
			errOB0 = pbffmp->bfob0.ErrRetrieveEntry( &lockOB0, &pbf );
			Assert( errOB0 == BFOB0::errSuccess );

			if ( pbf->pgno < pgnoFirst || pbf->pgno > pgnoLast )
				{
				continue;
				}
			Enforce( err < JET_errSuccess || pbf->bfdf == bfdfClean || !fFlushAll );
			}
		pbffmp->bfob0.UnlockKeyPtr( &lockOB0 );

		pbffmp->critbfob0ol.Enter();
		PBF pbfNext;
		for ( PBF pbf = pbffmp->bfob0ol.PrevMost(); pbf != pbfNil; pbf = pbfNext )
			{
			pbfNext = pbffmp->bfob0ol.Next( pbf );

			if ( pbf->pgno < pgnoFirst || pbf->pgno > pgnoLast )
				{
				continue;
				}
			Enforce( err < JET_errSuccess || pbf->bfdf == bfdfClean || !fFlushAll );
			}
		pbffmp->critbfob0ol.Leave();
		}
	pfmp->RwlBFContext().LeaveAsWriter();

	//  wait until we are sure that the clean thread is no longer referencing
	//  this FMP

	while ( pfmp->FBFICleanDb() || pfmp->FBFICleanSLV() )
		{
		UtilSleep( cmsecWaitGeneric );
		}

	//  return the result of the flush operation

	return err;
	}


///////////////////////////////
//  Deferred Undo Information

void BFAddUndoInfo( const BFLatch* pbfl, RCE* prce )
	{
	//  validate IN args

	Assert( FBFWARLatched( pbfl ) || FBFWriteLatched( pbfl ) );
	Assert( prce->PgnoUndoInfo() == pgnoNull );
	Assert( prce->PrceUndoInfoNext() == prceInvalid );

	//  add the undo info to the BF

	PBF pbf = PBF( pbfl->dwContext );

	ENTERCRITICALSECTION ecs( &critpoolBFDUI.Crit( pbf ) );

	BFIAddUndoInfo( pbf, prce );
	}

void BFRemoveUndoInfo( RCE* const prce, const LGPOS lgposModify )
	{
	//  validate IN args

	Assert( prce != prceNil );

	//  try forever to remove the deferred undo information in this RCE

	while ( prce->PgnoUndoInfo() != pgnoNull )
		{
		//  the IFMP / PGNO of the undo info in this RCE is in the cache
		//
		//  NOTE:  as long as we hold the read lock on this IFMP / PGNO, any
		//  BF we find cannot be evicted

		BFHash::CLock lockHash;
		bfhash.ReadLockKey( IFMPPGNO( prce->Ifmp(), prce->PgnoUndoInfo() ), &lockHash );

		PGNOPBF pgnopbf;
		if ( bfhash.ErrRetrieveEntry( &lockHash, &pgnopbf ) == BFHash::errSuccess )
			{
			//  lock the undo info chain on this BF

			CCriticalSection* const pcrit = &critpoolBFDUI.Crit( pgnopbf.pbf );
			pcrit->Enter();

			//  the IFMP / PGNO of the undo info in this RCE has undo info on
			//  this page

			if (	prce->PgnoUndoInfo() == pgnopbf.pbf->pgno &&
					prce->Ifmp() == pgnopbf.pbf->ifmp )
				{
				//  this page has no versions
				
				if ( pgnopbf.pbf->pbfTimeDepChainNext == pbfNil )
					{
#ifdef DEBUG

					//  we know that the undo info must be on this BF

					for (	RCE* prceT = pgnopbf.pbf->prceUndoInfoNext;
							prceT != prceNil && prceT != prce;
							prceT = prceT->PrceUndoInfoNext() )
						{
						}

					Assert( prceT == prce );

#endif  //  DEBUG

					//  if we are removing this undo info as a part of a lazy commit,
					//  we must depend the page on the commit record.  this is so
					//  that if we log the commit record, remove the undo info,
					//  flush the page, and then crash before flushing the commit
					//  record to the log, we will not be stranded without our undo
					//  info
					//
					//  NOTE:  this will also set the dependency for a durable
					//  commit, but it will not delay the flush of the buffer because
					//  by the time we get here, the commit record has already been
					//  flushed
					//
					//  NOTE:  the only reason it is safe to modify lgposModify
					//  without the page latch is because both lgposModify and
					//  this undo info are preventing the page from being flushed.
					//  as long as at least one keeps the BF from being flushed,
					//  we can change the other

					FMP*	pfmp	= &rgfmp[ prce->Ifmp() & ifmpMask ];
					PIB*	ppib	= prce->Pfucb()->ppib;
					
					if (	ppib->level == 1 &&
							pfmp->FLogOn() &&
							CmpLgpos( &ppib->lgposCommit0, &lgposMax ) != 0 )
						{
						Assert( !pfmp->Pinst()->m_plog->m_fLogDisabled );
						BFISetLgposModify( pgnopbf.pbf, ppib->lgposCommit0 );
						}
						
					//  remove our undo info

					BFIRemoveUndoInfo( pgnopbf.pbf, prce, lgposModify );
					
					//  unlock the undo info chain

					pcrit->Leave();
					}

				//  this page may have versions

				else
					{
					//  unlock the undo info chain

					pcrit->Leave();
					
					//  lock the dependency tree if the source page has versions
					//  so that no one can add or remove versions while we are
					//  looking for our undo info

					ENTERCRITICALSECTION ecsDepend( &critBFDepend );

					//  scan all versions of this page

					for (	PBF pbfVer = pgnopbf.pbf;
							pbfVer != pbfNil;
							pbfVer = pbfVer->pbfTimeDepChainNext )
						{
						//  lock this undo info chain

						ENTERCRITICALSECTION ecs( &critpoolBFDUI.Crit( pbfVer ) );

						//  the IFMP / PGNO of the undo info in this RCE has undo info
						//  on this page

						if (	prce->PgnoUndoInfo() == pbfVer->pgno &&
								prce->Ifmp() == pbfVer->ifmp )
							{
							//  this BF contains our undo info
							
							for (	RCE* prceT = pbfVer->prceUndoInfoNext;
									prceT != prceNil && prceT != prce;
									prceT = prceT->PrceUndoInfoNext() )
								{
								}

							if ( prceT != prceNil )
								{
								//  if we are removing this undo info as a part
								//  of a lazy commit, we must depend the page on
								//  the commit record.  this is so that if we
								//  log the commit record, remove the undo info,
								//  flush the page, and then crash before flushing
								//  the commit record to the log, we will not be
								//  stranded without our undo info
								//
								//  NOTE:  this will also set the dependency for
								//  a durable commit, but it will not delay the
								//  flush of the buffer because by the time we
								//  get here, the commit record has already been
								//  flushed
								//
								//  NOTE:  the only reason it is safe to modify
								//  lgposModify without the page latch is because
								//  both lgposModify and this undo info are
								//  preventing the page from being flushed. as
								//  long as at least one keeps the BF from being
								//  flushed, we can change the other

								FMP*	pfmp	= &rgfmp[ prce->Ifmp() & ifmpMask ];
								PIB*	ppib	= prce->Pfucb()->ppib;
								
								if (	ppib->level == 1 &&
										pfmp->FLogOn() &&
										CmpLgpos( &ppib->lgposCommit0, &lgposMax ) != 0 )
									{
									Assert( !pfmp->Pinst()->m_plog->m_fLogDisabled );
									
									BFISetLgposModify( pbfVer, ppib->lgposCommit0 );
									}
									
								//  remove our undo info

								BFIRemoveUndoInfo( pbfVer, prce, lgposModify );

								//  we're done

								break;
								}
							}

						//  this RCE doesn't have undo info on this page

						else
							{
							//  stop looking on this page
							
							break;
							}
						}
					}
				}

			//  this RCE doesn't have undo info on this page

			else
				{
				//  unlock the undo info chain

				pcrit->Leave();
				}
			}

		bfhash.ReadUnlockKey( &lockHash );
		}

	//  validate OUT args

	Assert( prce->PgnoUndoInfo() == pgnoNull );
	}

void BFMoveUndoInfo( const BFLatch* pbflSrc, const BFLatch* pbflDest, const KEY& keySep )
	{
	//  validate IN args

	Assert( FBFLatched( pbflSrc ) && FBFNotReadLatched( pbflSrc ) );
	Assert( !pbflDest || FBFWARLatched( pbflDest ) || FBFWriteLatched( pbflDest ) );

	PBF pbfSrc = PBF( pbflSrc->dwContext );
	PBF pbfDest = pbflDest ? PBF( pbflDest->dwContext ) : pbfNil;
	
	//  move all undo info of nodes whose keys are GTE the seperator key from
	//  the source page to the destination page.  if the destination page doesn't
	//  exist, throw away the undo info (i.e. move the undo info to NIL)

	//  lock the source and destination undo info chains
	
	CCriticalSection* const pcritSrc	= &critpoolBFDUI.Crit( pbfSrc );
	CCriticalSection* const pcritDest	= &critpoolBFDUI.Crit( pbfDest );

	CCriticalSection* const pcritMax	= max( pcritSrc, pcritDest );
	CCriticalSection* const pcritMin	= min( pcritSrc, pcritDest );

	ENTERCRITICALSECTION ecsMax( pcritMax );
	ENTERCRITICALSECTION ecsMin( pcritMin, pcritMin != pcritMax );

	//  scan all RCEs on this page
	
	RCE* prceNext;
	for ( RCE* prce = pbfSrc->prceUndoInfoNext; prce != prceNil; prce = prceNext )
		{
		prceNext = prce->PrceUndoInfoNext();

		//  this undo info needs to be moved

		BOOKMARK	bm;
		prce->GetBookmark( &bm );

		if ( CmpKeyWithKeyData( keySep, bm ) <= 0 )
			{
			//  remove the undo info from the source page
			//
			//  NOTE:  set the fMove flag so that the RCE's PgnoUndoInfo()
			//  is never pgnoNull during the move.  if it were to be so,
			//  someone might mistakenly think it had been removed
			//
			//  NOTE:  if there is no destination, do not set the flag
			
			BFIRemoveUndoInfo( pbfSrc, prce, lgposMin, pbfDest != pbfNil );

			//  add the undo info to the destination page, if any

			if ( pbfDest != pbfNil )
				{
				BFIAddUndoInfo( pbfDest, prce, fTrue );
				}
			}
		}
	}


///////////////////////////////////////////////////////////////////////////////
//
//  BF Internal Functions
//
///////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////
//  Buffer Manager System Parameter Critical Section

CCriticalSection critBFParm( CLockBasicInfo( CSyncBasicInfo( szBFParm ), rankBFParm, 0 ) );


//////////////////////////////
//  Buffer Manager Init flag

BOOL fBFInitialized = fFalse;


/////////////////////////////////////
//  Buffer Manager Global Constants

BOOL	fROCacheImage;
double	dblBFSpeedSizeTradeoff;
BOOL	fEnableOpportuneWrite;


//////////////////////////////////////
//  Buffer Manager Global Statistics

long cBFMemory;
long cBFPageFlushPending;


////////////////////////////////////////////////
//  Buffer Manager System Defaults Loaded flag

BOOL fBFDefaultsSet = fFalse;


//////////////////////////
//  IFMP/PGNO Hash Table

#pragma data_seg( "cacheline_aware_data" )
BFHash bfhash( rankBFHash );
#pragma data_seg()

double dblBFHashLoadFactor;
double dblBFHashUniformity;


////////////////
//  Avail Pool

#pragma bss_seg( "cacheline_aware_data" )
BFAvail bfavail;
#pragma bss_seg()


//////////
//  LRUK

#pragma data_seg( "cacheline_aware_data" )
BFLRUK bflruk( rankBFLRUK );
#pragma data_seg()

int BFLRUKK;
double csecBFLRUKCorrelatedTouch;
double csecBFLRUKTimeout;
double csecBFLRUKUncertainty;


////////////////////////////////////////////
//  Oldest Begin 0 Index and Overflow List

LGPOS dlgposBFOB0Precision;
LGPOS dlgposBFOB0Uncertainty;


///////////////////////////////
//  Deferred Undo Information

CRITPOOL< BF > critpoolBFDUI;


///////////
//  Cache

//  control

LONG_PTR		cbfCacheMin;
LONG_PTR		cbfCacheMax;
LONG_PTR		cbfCacheSet;
LONG_PTR		cbfCacheSetUser;
LONG_PTR		cbfCache;

//  stats

DWORD			cbfNewlyCommitted;
DWORD			cbfNewlyEvictedUsed;

//  data (page) storage

LONG_PTR		cpgChunk;
void**			rgpvChunkRW;
void**			rgpvChunkRO;

COSMemoryMap*	rgosmmDataChunk;


//  status (BF) storage

LONG_PTR		cbfInit;
LONG_PTR		cbfChunk;
BF**			rgpbfChunk;

COSMemoryMap*	rgosmmStatusChunk;


//  initializes the cache, or returns JET_errOutOfMemory

ERR ErrBFICacheInit()
	{
	ERR		err = JET_errSuccess;
	ULONG	ibfchunk;

	//  reset

	cbfCacheSet			= 0;
	cbfCacheSetUser		= 0;
	cbfCache			= 0;

	cbfNewlyCommitted	= 0;
	cbfNewlyEvictedUsed	= 0;

	cpgChunk			= 0;
	rgpvChunkRW			= NULL;
	rgpvChunkRO			= NULL;

	cbfInit				= 0;
	cbfChunk			= 0;
	rgpbfChunk			= NULL;

	//  determine our data allocation granularity to be a fraction of the total
	//  VA we have at our disposal

	const LONG_PTR cpgChunkMin = OSMemoryPageReserveTotal() / cCacheChunkMax / g_cbPage;
	for ( cpgChunk = 1; cpgChunk < cpgChunkMin; cpgChunk <<= 1 );

	//  allocate worst case storage for the data chunk table

	if ( !( rgpvChunkRW = new void*[ cCacheChunkMax ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	memset( rgpvChunkRW, 0, sizeof( void* ) * cCacheChunkMax );
	if ( !( rgpvChunkRO = new void*[ cCacheChunkMax ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	memset( rgpvChunkRO, 0, sizeof( void* ) * cCacheChunkMax );

	//	allocate worst case storage for the data memory map array

	if ( !( rgosmmDataChunk = new COSMemoryMap[ cCacheChunkMax ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//	init the data memory maps

	for ( ibfchunk = 0; ibfchunk < cCacheChunkMax; ibfchunk++ )
		{
		switch ( rgosmmDataChunk[ibfchunk].ErrOSMMInit() )
			{
			case COSMemoryMap::errSuccess:
				break;
			default:
				AssertSz( fFalse, "Unexpected error during BF data memory-map init" );
			case COSMemoryMap::errOutOfBackingStore:
			case COSMemoryMap::errMappingFailed:
			case COSMemoryMap::errOutOfAddressSpace:
			case COSMemoryMap::errOutOfMemory:
				Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}

	//  determine our status allocation granularity to be the same as our data
	//  allocation granularity

	cbfChunk = cpgChunk;

	//  allocate worst case storage for the status chunk table

	if ( !( rgpbfChunk = new PBF[ cCacheChunkMax ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	memset( rgpbfChunk, 0, sizeof( PBF ) * cCacheChunkMax );

	//	allocate worst case storage for the memory map array

	if ( !( rgosmmStatusChunk = new COSMemoryMap[ cCacheChunkMax ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//	init the memory maps

	for ( ibfchunk = 0; ibfchunk < cCacheChunkMax; ibfchunk++ )
		{
		switch ( rgosmmStatusChunk[ibfchunk].ErrOSMMInit() )
			{
			case COSMemoryMap::errSuccess:
				break;
			default:
				AssertSz( fFalse, "Unexpected error during BF status memory-map init" );
			case COSMemoryMap::errOutOfBackingStore:
			case COSMemoryMap::errMappingFailed:
			case COSMemoryMap::errOutOfAddressSpace:
			case COSMemoryMap::errOutOfMemory:
				Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}

	//  set the initial cache size to the minimum cache size

	Call( ErrBFICacheSetSize( cbfCacheMin ) );
	
	return JET_errSuccess;

HandleError:
	BFICacheTerm();
	return err;
	}

//  terminates the cache
	
void BFICacheTerm()
	{
	//  set the cache size to zero

	CallS( ErrBFICacheSetSize( 0 ) );

	//	free the status memory map array

	if ( rgosmmStatusChunk )
		{
		ULONG ibfchunk;
		for ( ibfchunk = 0; ibfchunk < cCacheChunkMax; ibfchunk++ )
			{
			rgosmmStatusChunk[ibfchunk].OSMMTerm();
			}
		delete [] rgosmmStatusChunk;
		rgosmmStatusChunk = NULL;
		}

	//  free our status chunk table

	if ( rgpbfChunk )
		{
		delete [] rgpbfChunk;
		rgpbfChunk = NULL;
		}

	//	free the data memory map array

	if ( rgosmmDataChunk )
		{
		ULONG ibfchunk;
		for ( ibfchunk = 0; ibfchunk < cCacheChunkMax; ibfchunk++ )
			{
			rgosmmDataChunk[ibfchunk].OSMMTerm();
			}
		delete [] rgosmmDataChunk;
		rgosmmDataChunk = NULL;
		}

	//  free our data chunk table

	if ( rgpvChunkRO )
		{
		delete [] rgpvChunkRO;
		rgpvChunkRO = NULL;
		}
	if ( rgpvChunkRW )
		{
		delete [] rgpvChunkRW;
		rgpvChunkRW = NULL;
		}
	}

//  sets the cache size

ERR ErrBFICacheSetSize( const LONG_PTR cbfCacheNew )
	{
	ERR err = JET_errSuccess;

	Assert( cbfCacheNew > 0 || !fBFInitialized );
	
	//  there are BFs to unquiesce (we are reducing cache shrink with some
	//  BFs still in the shrink state)

	if ( cbfCacheSet < cbfCache && cbfCacheNew > cbfCacheSet )
		{
		//  update the set point to reflect the unquiesced BFs

		LONG_PTR cbfCacheSetOld = cbfCacheSet;
		cbfCacheSet = min( cbfCacheNew, cbfCache );
		
		//  scan through BFs between the old set point and the new set point

		for ( IBF ibf = cbfCacheSetOld; ibf < cbfCacheSet; ibf++ )
			{
			PBF pbf = PbfBFICacheIbf( ibf );
			
			//  if this BF is quiesced, free it to the avail pool

			if ( pbf->fQuiesced )
				{
				BFIFreePage( pbf );
				}
			}
		}

	//  there are BFs to allocate (we are growing the cache)

	if ( cbfCacheNew > cbfCache )
		{
		//  the set point should be equal to the current end of cache

		Assert( cbfCacheSet == cbfCache );

		//  allocate space for the new cache set point

		Call( ErrBFICacheISetSize( cbfCacheNew ) );

		//  update the set point to reflect the allocated BFs

		cbfCacheSet = cbfCacheNew;
		}

	//  we are trying to shrink the cache

	if ( cbfCacheNew < cbfCache )
		{
		//  update the set point to quiesce and shrink the requested BFs

		cbfCacheSet = cbfCacheNew;

		//  find the first unquiesced BF closest to the end of the cache

		for ( IBF ibf = cbfCache - 1; ibf >= cbfCacheSet; ibf-- )
			{
			PBF pbf = PbfBFICacheIbf( ibf );

			if ( !pbf->fQuiesced )
				{
				break;
				}
			}

		//  if we are setting the cache size to zero then we must be terminating
		//  so we will free all BFs regardless of their quiesce state

		ibf = cbfCacheNew ? ibf : -1;

		//  free all cache beyond this BF

		CallS( ErrBFICacheISetSize( ibf + 1 ) );
		}

HandleError:
	return err;
	}

//  returns the BF associated with a page pointer

INLINE PBF PbfBFICachePv( void* const pv )
	{
	return PbfBFICacheIbf( IpgBFICachePv( pv ) );
	}

//  returns fTrue if the specified page pointer is valid

INLINE BOOL FBFICacheValidPv( void* const pv )
	{
	return IpgBFICachePv( pv ) != ipgNil;
	}

//  returns fTrue if the specified BF pointer is valid

INLINE BOOL FBFICacheValidPbf( const PBF pbf )
	{
	return IbfBFICachePbf( pbf ) != ibfNil;
	}

//  returns the PBF associated with the given IBF

INLINE PBF PbfBFICacheIbf( const IBF ibf )
	{
	return (	ibf == ibfNil ?
					pbfNil :
					rgpbfChunk[ ibf / cbfChunk ] + ibf % cbfChunk );
	}

//  returns the RW page pointer associated with the given IPG

INLINE void* PvBFICacheRWIpg( const IPG ipg )
	{
	return (	ipg == ipgNil ?
					NULL :
					(BYTE*)rgpvChunkRW[ ipg / cpgChunk ] + ( ipg % cpgChunk ) * g_cbPage );
	}

//  returns the RO page pointer associated with the given IBF

INLINE void* PvBFICacheROIpg( const IPG ipg )
	{
	return (	ipg == ipgNil ?
					NULL :
					(BYTE*)rgpvChunkRO[ ipg / cpgChunk ] + ( ipg % cpgChunk ) * g_cbPage );
	}

//  returns the IBF associated with the given PBF

IBF IbfBFICachePbf( const PBF pbf )
	{
	//  scan the PBF chunk table looking for a chunk that fits in this range

	LONG_PTR ibfChunk;
	for ( ibfChunk = 0; ibfChunk < cCacheChunkMax; ibfChunk++ )
		{
		//  our PBF is part of this chunk
		
		if (	rgpbfChunk[ ibfChunk ] &&
				rgpbfChunk[ ibfChunk ] <= pbf &&
				pbf < rgpbfChunk[ ibfChunk ] + cbfChunk  )
			{
			//  compute the IBF for this PBF

			const IBF ibf = ibfChunk * cbfChunk + pbf - rgpbfChunk[ ibfChunk ];

			Assert( PbfBFICacheIbf( ibf ) == pbf );
			return ibf;
			}
		}

	//  our PBF isn't part of any chunk so return nil
		
	return ibfNil;
	}

//  returns the IPG associated with the given page pointer

IPG IpgBFICachePv( void* const pv )
	{
	//  scan the RW page chunk table looking for a chunk that fits in this range

	LONG_PTR ipgChunk;
	for ( ipgChunk = 0; ipgChunk < cCacheChunkMax; ipgChunk++ )
		{
		//  our page pointer is part of this chunk
		
		if (	rgpvChunkRW[ ipgChunk ] &&
				rgpvChunkRW[ ipgChunk ] <= pv &&
				pv < (BYTE*)rgpvChunkRW[ ipgChunk ] + cpgChunk * g_cbPage )
			{
			//  compute the IPG for this RW page pointer

			const IPG ipg = ipgChunk * cpgChunk + ( (BYTE*)pv - (BYTE*)rgpvChunkRW[ ipgChunk ] ) / g_cbPage;

			Assert( PvBFICacheRWIpg( ipg ) == pv );
			return ipg;
			}
		}

	//  scan the RO page chunk table looking for a chunk that fits in this range

	for ( ipgChunk = 0; ipgChunk < cCacheChunkMax; ipgChunk++ )
		{
		//  our page pointer is part of this chunk
		
		if (	rgpvChunkRO[ ipgChunk ] &&
				rgpvChunkRO[ ipgChunk ] <= pv &&
				pv < (BYTE*)rgpvChunkRO[ ipgChunk ] + cpgChunk * g_cbPage )
			{
			//  compute the IPG for this RO page pointer

			const IPG ipg = ipgChunk * cpgChunk + ( (BYTE*)pv - (BYTE*)rgpvChunkRO[ ipgChunk ] ) / g_cbPage;

			Assert( PvBFICacheROIpg( ipg ) == pv );
			return ipg;
			}
		}

	//  our page pointer isn't part of any chunk so return nil
		
	return ipgNil;
	}

ERR ErrBFICacheISetDataSize( const LONG_PTR cpgCacheStart, const LONG_PTR cpgCacheNew )
	{
	ERR err = JET_errSuccess;

	//  set the current cache size as the starting cache size.  this is the
	//  effective cache size for purposes of recovering on an OOM

	LONG_PTR cpgCacheCur = cpgCacheStart;
	
	//  convert the current and new cache sizes into chunks
	//
	//  NOTE:  this function relies on the fact that if either cpgCacheStart or
	//  cpgCacheNew are 0, then ipgChunk or ipgChunkNew will become -1.  do not
	//  change their types to unsigned!!!

	const LONG_PTR ipgChunkStart	= cpgCacheStart ? ( cpgCacheStart - 1 ) / cpgChunk : -1;
	const LONG_PTR ipgChunkNew		= cpgCacheNew ? ( cpgCacheNew - 1 ) / cpgChunk : -1;
	
	//  the cache size has grown

	if ( ipgChunkNew > ipgChunkStart )
		{
		//  this is not the first allocation or an aligned allocation

		if ( cpgCacheStart % cpgChunk )
			{
			//  make sure that all the memory in the chunk at the end of the cache
			//  is committed

			const size_t ib = ( cpgCacheStart % cpgChunk ) * g_cbPage;
			const size_t cb = ( ( ipgChunkStart + 1 ) * cpgChunk - cpgCacheStart ) * g_cbPage;

			if ( !rgosmmDataChunk[ ipgChunkStart ].FOSMMCommit( ib, cb ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}
			
		//  allocate cache chunks for the new range

		for ( LONG_PTR ipgChunkAlloc = ipgChunkStart + 1; ipgChunkAlloc <= ipgChunkNew; ipgChunkAlloc++ )
			{
			void*	rgpvMap[2];
			BOOL	rgfProtect[2];

			//	prepare to make a memory mapping

			rgpvMap[ 0 ]	= NULL;
			rgpvMap[ 1 ]	= NULL;
			rgfProtect[ 0 ]	= fFalse;
			rgfProtect[ 1 ]	= fTrue;

			//	reserve the desired mapping(s)

			switch ( rgosmmDataChunk[ ipgChunkAlloc ].ErrOSMMReserve(	cpgChunk * g_cbPage, 
																		fROCacheImage ? 2 : 1, 
																		rgpvMap,
																		rgfProtect ) )
				{
				case COSMemoryMap::errSuccess:
					break;
				default:
					AssertSz( fFalse, "Unexpected error during BF memory-map reserve" );
				case COSMemoryMap::errOutOfBackingStore:
				case COSMemoryMap::errMappingFailed:
				case COSMemoryMap::errOutOfAddressSpace:
				case COSMemoryMap::errOutOfMemory:
					Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			//	record the new mappings

			rgpvChunkRW[ ipgChunkAlloc ] = rgpvMap[ 0 ];
			rgpvChunkRO[ ipgChunkAlloc ] = rgpvMap[ fROCacheImage ? 1 : 0 ];

			//  update the cache size to reflect the new cache chunk
			//
			//  NOTE:  we do this to make OOM recovery easier

			cpgCacheCur = min( cpgCacheNew, ( ipgChunkAlloc + 1 ) * cpgChunk );

			//  commit only the memory which will be in use

			const size_t ib = 0;
			const size_t cb = min( cpgChunk, cpgCacheNew - ipgChunkAlloc * cpgChunk ) * g_cbPage;

			if ( !rgosmmDataChunk[ ipgChunkAlloc ].FOSMMCommit( ib, cb ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}
		}

	//  the cache size has shrunk

	else if ( ipgChunkNew < ipgChunkStart )
		{
		//  free cache chunks for the new range

		for ( LONG_PTR ipgChunkFree = ipgChunkNew + 1; ipgChunkFree <= ipgChunkStart; ipgChunkFree++ )
			{
			rgosmmDataChunk[ ipgChunkFree ].OSMMFree( rgpvChunkRW[ ipgChunkFree ] );
			rgpvChunkRW[ ipgChunkFree ] = NULL;
			if ( fROCacheImage )
				{
				rgosmmDataChunk[ ipgChunkFree ].OSMMFree( rgpvChunkRO[ ipgChunkFree ] );
				}
			rgpvChunkRO[ ipgChunkFree ] = NULL;
			}

		//  reset cache that will not be in use, being careful of page granularity

		const LONG_PTR cpgPerPage = max( 1, OSMemoryPageCommitGranularity() / g_cbPage );
		
		LONG_PTR cpgCommit = cpgCacheNew - ipgChunkNew * cpgChunk + cpgPerPage - 1;
		cpgCommit -= cpgCommit % cpgPerPage;

		LONG_PTR cpgCommitMax = cpgChunk + cpgPerPage - 1;
		cpgCommitMax -= cpgCommitMax % cpgPerPage;

		const LONG_PTR cpgReset = cpgCommitMax - cpgCommit;
		if ( cpgReset )
			{
			OSMemoryPageReset(	(BYTE*)rgpvChunkRW[ ipgChunkNew ] + cpgCommit * g_cbPage,
								cpgReset * g_cbPage,
								fTrue );
			}
		}

	//  the cache size has stayed the same (at least chunk-wise)

	else
		{
		//  the cache size has grown but less than one chunk

		if ( cpgCacheNew > cpgCacheStart )
			{
			//  commit only the memory which will be in use

			const size_t ib = ( cpgCacheStart % cpgChunk ) * g_cbPage;
			const size_t cb = ( cpgCacheNew - cpgCacheStart ) * g_cbPage;

			if ( !rgosmmDataChunk[ cpgCacheStart / cpgChunk ].FOSMMCommit( ib, cb ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}

		//  the cache size has shrunk but less than one chunk

		else if ( cpgCacheNew < cpgCacheStart )
			{
			//  reset cache that will not be in use, being careful of page granularity

			const LONG_PTR cpgPerPage = max( 1, OSMemoryPageCommitGranularity() / g_cbPage );
			
			LONG_PTR cpgCommit = cpgCacheNew - ipgChunkNew * cpgChunk + cpgPerPage - 1;
			cpgCommit -= cpgCommit % cpgPerPage;

			LONG_PTR cpgCommitMax = cpgChunk + cpgPerPage - 1;
			cpgCommitMax -= cpgCommitMax % cpgPerPage;

			const LONG_PTR cpgReset = cpgCommitMax - cpgCommit;
			if ( cpgReset )
				{
				OSMemoryPageReset(	(BYTE*)rgpvChunkRW[ ipgChunkNew ] + cpgCommit * g_cbPage,
									cpgReset * g_cbPage,
									fTrue );
				}
			}
		}

	return JET_errSuccess;

	//  on an error, rollback all changes

HandleError:
	CallS( ErrBFICacheISetDataSize( cpgCacheCur, cpgCacheStart ) );
	return err;
	}

ERR ErrBFICacheISetStatusSize( const LONG_PTR cbfCacheStart, const LONG_PTR cbfCacheNew )
	{
	ERR err = JET_errSuccess;

	//  set the current cache size as the starting cache size.  this is the
	//  effective cache size for purposes of recovering on an OOM

	LONG_PTR cbfCacheCur = cbfCacheStart;
	
	//  convert the current and new cache sizes into chunks
	//
	//  NOTE:  this function relies on the fact that if either cbfCacheStart or
	//  cbfCacheNew are 0, then ibfChunk or ibfChunkNew will become -1.  do not
	//  change their types to unsigned!!!

	const LONG_PTR ibfChunkStart	= cbfCacheStart ? ( cbfCacheStart - 1 ) / cbfChunk : -1;
	const LONG_PTR ibfChunkNew		= cbfCacheNew ? ( cbfCacheNew - 1 ) / cbfChunk : -1;
	
	//  the cache size has grown

	if ( ibfChunkNew > ibfChunkStart )
		{
		//  this is not the first allocation or an aligned allocation

		if ( cbfCacheStart % cbfChunk )
			{
			//  make sure that all the memory in the chunk at the end of the cache
			//  is committed

			const size_t ib = ( cbfCacheStart % cbfChunk ) * sizeof( BF );
			const size_t cb = ( ( ibfChunkStart + 1 ) * cbfChunk - cbfCacheStart ) * sizeof( BF );

			if ( !rgosmmStatusChunk[ ibfChunkStart ].FOSMMCommit( ib, cb ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}
			
		//  allocate cache chunks for the new range

		for ( LONG_PTR ibfChunkAlloc = ibfChunkStart + 1; ibfChunkAlloc <= ibfChunkNew; ibfChunkAlloc++ )
			{

			//	prepare to make a memory mapping

			void*	pvMap		= NULL;
			BOOL	fProtect	= fFalse;

			//	reserve the desired mapping

			switch ( rgosmmStatusChunk[ ibfChunkAlloc ].ErrOSMMReserve(	cbfChunk * sizeof( BF ),
																		1,
																		&pvMap,
																		&fProtect ) )
				{
				case COSMemoryMap::errSuccess:
					break;
				default:
					AssertSz( fFalse, "Unexpected error during BF memory-map reserve" );
				case COSMemoryMap::errOutOfBackingStore:
				case COSMemoryMap::errMappingFailed:
				case COSMemoryMap::errOutOfAddressSpace:
				case COSMemoryMap::errOutOfMemory:
					Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			//	record the new mapping

			rgpbfChunk[ ibfChunkAlloc ] = (BF*)pvMap;
			
			//  update the cache size to reflect the new cache chunk
			//
			//  NOTE:  we do this to make OOM recovery easier

			cbfCacheCur = min( cbfCacheNew, ( ibfChunkAlloc + 1 ) * cbfChunk );

			//  commit only the memory which will be in use

			const size_t ib = 0;
			const size_t cb = min( cbfChunk, cbfCacheNew - ibfChunkAlloc * cbfChunk ) * sizeof( BF );

			if ( !rgosmmStatusChunk[ ibfChunkAlloc ].FOSMMCommit( ib, cb ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}
		}

	//  the cache size has shrunk

	else if ( ibfChunkNew < ibfChunkStart )
		{
		//  free cache chunks for the new range

		for ( LONG_PTR ibfChunkFree = ibfChunkNew + 1; ibfChunkFree <= ibfChunkStart; ibfChunkFree++ )
			{
			rgosmmStatusChunk[ ibfChunkFree ].OSMMFree( rgpbfChunk[ ibfChunkFree ] );
			rgpbfChunk[ ibfChunkFree ] = NULL;
			}

		//  reset cache that will not be in use, being careful of page granularity

		const LONG_PTR cbfPerPage = max( 1, OSMemoryPageCommitGranularity() / sizeof( BF ) );
		
		LONG_PTR cbfCommit = cbfCacheNew - ibfChunkNew * cbfChunk + cbfPerPage - 1;
		cbfCommit -= cbfCommit % cbfPerPage;

		LONG_PTR cbfCommitMax = cbfChunk + cbfPerPage - 1;
		cbfCommitMax -= cbfCommitMax % cbfPerPage;

		const LONG_PTR cbfReset = cbfCommitMax - cbfCommit;
		if ( cbfReset )
			{
			OSMemoryPageReset(	rgpbfChunk[ ibfChunkNew ] + cbfCommit,
								cbfReset * sizeof( BF ),
								fTrue );
			}
		}

	//  the cache size has stayed the same (at least chunk-wise)

	else
		{
		//  the cache size has grown but less than one chunk

		if ( cbfCacheNew > cbfCacheStart )
			{
			//  commit only the memory which will be in use

			const size_t ib = ( cbfCacheStart % cbfChunk ) * sizeof( BF );
			const size_t cb = ( cbfCacheNew - cbfCacheStart ) * sizeof( BF );

			if ( !rgosmmStatusChunk[ cbfCacheStart / cbfChunk ].FOSMMCommit( ib, cb ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}

		//  the cache size has shrunk but less than one chunk

		else if ( cbfCacheNew < cbfCacheStart )
			{
			//  reset cache that will not be in use, being careful of page granularity

			const LONG_PTR cbfPerPage = max( 1, OSMemoryPageCommitGranularity() / sizeof( BF ) );
			
			LONG_PTR cbfCommit = cbfCacheNew - ibfChunkNew * cbfChunk + cbfPerPage - 1;
			cbfCommit -= cbfCommit % cbfPerPage;

			LONG_PTR cbfCommitMax = cbfChunk + cbfPerPage - 1;
			cbfCommitMax -= cbfCommitMax % cbfPerPage;

			const LONG_PTR cbfReset = cbfCommitMax - cbfCommit;
			if ( cbfReset )
				{
				OSMemoryPageReset(	rgpbfChunk[ ibfChunkNew ] + cbfCommit,
									cbfReset * sizeof( BF ),
									fTrue );
				}
			}
		}

	return JET_errSuccess;

	//  on an error, rollback all changes

HandleError:
	CallS( ErrBFICacheISetStatusSize( cbfCacheCur, cbfCacheStart ) );
	return err;
	}

//  sets the allocated size of the cache, allocating or freeing memory as
//  necessary

ERR ErrBFICacheISetSize( const LONG_PTR cbfCacheNew )
	{
	ERR err = JET_errSuccess;

	//  save the starting cache size

	const LONG_PTR cbfCacheStart = cbfCache;
	AssertPREFIX( cbfCacheStart >= 0 );

	//  grow / shrink our data storage or rollback on OOM

	Call( ErrBFICacheISetDataSize( cbfCacheStart, cbfCacheNew ) );

	//  the cache size has grown

	if ( cbfCacheStart < cbfCacheNew )
		{
		//  grow our status storage iff we are growing past cbfInit

		if ( cbfCacheNew > cbfInit )
			{
			//  grow our status storage or rollback on OOM
			
			if ( ( err = ErrBFICacheISetStatusSize(	cbfInit, cbfCacheNew ) ) < JET_errSuccess )
				{
				CallS( ErrBFICacheISetDataSize( cbfCacheNew, cbfCacheStart ) );
				return err;
				}

			//  init all BFs in the newly allocated range

			for ( LONG_PTR ibfInit = cbfInit; ibfInit < cbfCacheNew; ibfInit++ )
				{
				PBF pbf = PbfBFICacheIbf( ibfInit );

				//  use placement new to initialize this BF

				new( pbf ) BF;

				CSXWLatch::ERR errSXWL = pbf->sxwl.ErrTryAcquireWriteLatch();
				Assert( errSXWL == CSXWLatch::errSuccess );
				pbf->sxwl.ReleaseOwnership( bfltWrite );

				//  mark this BF as initialized
			
				cbfInit = ibfInit + 1;
				}
			}

		//  initialize and free all BFs in the added range

		for ( LONG_PTR ibfInit = cbfCacheStart; ibfInit < cbfCacheNew; ibfInit++ )
			{
			PBF pbf = PbfBFICacheIbf( ibfInit );

			//  set this BF's image pointers

			pbf->pvROImage = PvBFICacheROIpg( ibfInit );
			pbf->pvRWImage = PvBFICacheRWIpg( ibfInit );

			//  update our stats

			AtomicIncrement( (long*)&cBFClean );

			pbf->fNewlyCommitted = fTrue;
			AtomicIncrement( (long*)&cbfNewlyCommitted );

			pbf->fNewlyEvicted = fFalse;

			//  free this BF to the avail pool
			
			BFIFreePage( pbf );

			//  increase the actual cache size

			cbfCache = ibfInit + 1;
			}
		}

	//  the cache size has shrunk

	else if ( cbfCacheStart > cbfCacheNew )
		{
		//  terminate all BFs in the removed range

		for ( LONG_PTR ibfTerm = cbfCacheStart - 1; ibfTerm >= cbfCacheNew; ibfTerm-- )
			{
			PBF pbf = PbfBFICacheIbf( ibfTerm );

			//  decrease the actual cache size

			cbfCache = ibfTerm;

			//  update our stats

			if ( pbf->fNewlyCommitted )
				{
				pbf->fNewlyCommitted = fFalse;
				AtomicDecrement( (long*)&cbfNewlyCommitted );
				}

			pbf->fNewlyEvicted = fFalse;

			AtomicDecrement( (long*)&cBFClean );

			//  clear this BF's image pointers

			pbf->pvROImage = NULL;
			pbf->pvRWImage = NULL;
			}

		//  shrink our status storage iff we are terminating the cache

		if ( !cbfCacheNew )
			{
			//  terminate all initialized BFs

			const LONG_PTR cbfTerm = cbfInit;
			for ( LONG_PTR ibfTerm = cbfTerm - 1; ibfTerm >= 0; ibfTerm-- )
				{
				PBF pbf = PbfBFICacheIbf( ibfTerm );

				//  mark this BF as terminated

				cbfInit = ibfTerm;

				//  explicitly destruct this BF

				if ( pbf->fQuiesced || pbf->fAvailable )
					{
					pbf->sxwl.ClaimOwnership( bfltWrite );
					pbf->sxwl.ReleaseWriteLatch();
					}

				pbf->~BF();
				}

			//  shrink our status storage
			
			CallS( ErrBFICacheISetStatusSize( cbfTerm, 0 ) );
			};
		}

	//  normalize the thresholds

	BFINormalizeThresholds();

HandleError:
	return err;
	}


///////////////////////////////////////
//  Cache Resource Allocation Manager

CCacheRAM cacheram;

inline CCacheRAM::CCacheRAM()
	{
	}

inline CCacheRAM::~CCacheRAM()
	{
	}

inline size_t CCacheRAM::TotalPhysicalMemoryPages()
	{
	return OSMemoryTotal() / OSMemoryPageCommitGranularity();
	}

inline size_t CCacheRAM::AvailablePhysicalMemoryPages()
	{
	return OSMemoryAvailable() / OSMemoryPageCommitGranularity();
	}

inline size_t CCacheRAM::PhysicalMemoryPageSize()
	{
	return OSMemoryPageCommitGranularity();
	}

inline long CCacheRAM::TotalPhysicalMemoryPageEvictions()
	{
	return OSMemoryPageEvictionCount();
	}

inline size_t CCacheRAM::TotalResources()
	{
	return cbfCache;
	}

inline size_t CCacheRAM::ResourceSize()
	{
	return g_cbPage;
	}

inline long CCacheRAM::TotalResourceEvictions()
	{
	return cbfNewlyEvictedUsed;
	}

inline void CCacheRAM::SetOptimalResourcePoolSize( size_t cResource )
	{
	//  the optimal resouce pool size will be the new cache size

	LONG_PTR cbfCacheNew = cResource;
	
	//  if the cache size is being controlled externally then override the RAM

	cbfCacheNew = cbfCacheSetUser ? cbfCacheSetUser : cbfCacheNew;

	//  limit how much cache memory we can use by the amount of virtual address
	//  space left in our process.  we do this so that we do not starve other
	//  consumers of virtual address space on machines with more physical
	//  memory than can be mapped in the current process
	//
	//  the implications of this are:
	//
	//    - other consumers of VA can push us out of memory and there is no way
	//      for us to push back because VA is not "paged" by the system
	//    - multiple DBAs that do this cannot co-exist in the same process
	//      because they will not converge or balance their memory consumption
	//
	//  NOTE:  this is only a factor on systems with limited VA

	const size_t	cbVATotal		= OSMemoryPageReserveTotal();
	const size_t	cbVAAvailMin	= size_t( cbVATotal * fracVAAvailMin );
	const size_t	cbVAAvail		= OSMemoryPageReserveAvailable();
	const size_t	cbVACache		= ( ( cbfCache + cpgChunk - 1 ) / cpgChunk ) * cpgChunk * g_cbPage;
	const size_t	cbVACacheMax	= max( cbVAAvailMin, cbVACache + cbVAAvail ) - cbVAAvailMin;
	const size_t	cbfVACacheMax	= ( cbVACacheMax / g_cbPage / cpgChunk ) * cpgChunk;

	cbfCacheNew = min( cbfCacheNew, cbfVACacheMax );
	
	//  limit the new cache size to the preferred operating range of cache sizes
	
	cbfCacheNew = max( cbfCacheNew, cbfCacheMin );
	cbfCacheNew = min( cbfCacheNew, cbfCacheMax );

	//  set new cache size
	
	const ERR err = ErrBFICacheSetSize( cbfCacheNew );
	Assert( ( cbfCacheNew > cbfCache && err == JET_errOutOfMemory ) || err == JET_errSuccess );

	//  set the page hint cache size to an appropriate size given the new
	//  cache size

	CallS( CPAGE::ErrSetPageHintCacheSize( cbfCacheNew * sizeof( DWORD_PTR ) ) );
	}


//////////////////
//  Clean Thread

THREAD				threadClean;
CAutoResetSignal	asigCleanThread( CSyncBasicInfo( _T( "asigCleanThread" ) ) );
volatile BOOL		fCleanThreadTerm;

LONG_PTR			cbfCleanThresholdStart = 0;
LONG_PTR			cbfScaledCleanThresholdStart;
LONG_PTR			cbfCleanThresholdStop = 0;
LONG_PTR			cbfScaledCleanThresholdStop;
long				cbCleanCheckpointDepthMax;

DWORD				cAvailAllocLast;
TICK				tickAvailAllocLast;

BOOL				fIdleFlushActive;
DWORD				cIdlePagesRead;
DWORD				cIdlePagesWritten;
TICK				tickIdlePeriodStart;

//  initializes the Clean Thread, or returns either JET_errOutOfMemory or
//  JET_errOutOfThreads

ERR ErrBFICleanThreadInit()
	{
	ERR		err;

	//  reset all pointers

	threadClean = NULL;

	//  reset cache stats

	cacheram.ResetStatistics();

	//  reset avail pool stats

	cAvailAllocLast			= bfavail.CRemove();
	tickAvailAllocLast		= TickOSTimeCurrent();

	//  reset idle flush stats

	fIdleFlushActive		= fFalse;
	cIdlePagesRead			= cBFPagesRead.Get( perfinstGlobal );
	cIdlePagesWritten		= (	cBFPagesWritten.Get( perfinstGlobal ) -
								cBFPagesOpportunelyWritten.Get( perfinstGlobal ) -
								cBFPagesIdlyWritten.Get( perfinstGlobal ) );
	tickIdlePeriodStart		= TickOSTimeCurrent();

	//  create Clean Thread

	fCleanThreadTerm = fFalse;
	Call( ErrUtilThreadCreate(	BFICleanThreadIProc,
								cbBFCleanStack,
								priorityNormal,
								&threadClean,
								NULL ) );

	return JET_errSuccess;

HandleError:
	BFICleanThreadTerm();
	return err;
	}

//  terminates the Clean Thread

void BFICleanThreadTerm()
	{
	//  terminate Clean Thread

	if ( threadClean != NULL )
		{
		fCleanThreadTerm = fTrue;
		asigCleanThread.Set();
		UtilThreadEnd( threadClean );
		}
	}

//  tells Clean Thread to clean some pages

INLINE void BFICleanThreadStartClean()
	{
	asigCleanThread.Set();
	}
	
//  Clean Thread

//  This thread performs the following functions:  cleaning used BFs to make BFs
//  available for allocation, flushing dirty BFs during system idle periods (to
//  minimize redo time after a crash), advancing the checkpoint, and dynamically
//  adjusting the size of the cache for optimal performance according to the run-
//  time system load (cache reorganization).

DWORD BFICleanThreadIProc( DWORD_PTR dw )
	{
	//  remember that this thread is the clean thread

	Ptls()->fCleanThread = fTrue;
	
	//  reset state

	TICK tickNextRAMSample		= TickOSTimeCurrent() + dtickRAMSamplePeriod;
	TICK tickNextClean			= TickOSTimeCurrent() + dtickCleanPeriod;
	TICK tickNextIdleFlush		= TickOSTimeCurrent() + dtickIdleFlushPeriod;
	TICK tickNextCacheReorg		= TickOSTimeCurrent() + dtickCacheReorgPeriod;
	TICK tickNextCheckpoint		= TickOSTimeCurrent() + dtickCheckpointPeriod;
	TICK tickNextChkptAdv		= TickOSTimeCurrent() + dtickChkptAdvPeriod;

	//  service loop

	while ( !fCleanThreadTerm )
		{
		//  get the current time
		
		TICK tickNow = TickOSTimeCurrent();
		
		//  compute next task to execute and sleep duration

		TICK tickNextTask = TickMin(	TickMin(	TickMin( tickNextRAMSample, tickNextIdleFlush ),
													TickMin( tickNextCacheReorg, tickNextCheckpoint ) ),
										TickMin( tickNextClean, tickNextChkptAdv ) );
		TICK tickWait = max( long( tickNextTask - tickNow ), 0 );
		Assert( tickWait <= max(	max(	max( dtickRAMSamplePeriod, dtickIdleFlushPeriod ),
											max( dtickCacheReorgPeriod, dtickCheckpointPeriod ) ),
									max( dtickCleanPeriod, dtickChkptAdvPeriod ) ) );
									
		//  wait to be killed, signaled for clean, or to timeout for other operations

		BOOL fSignal = asigCleanThread.FWait( tickWait );
	
		//  get cache RAM sample if it is time

		if ( TickCmp( TickOSTimeCurrent(), tickNextRAMSample ) >= 0 )
			{
			cacheram.UpdateStatistics();

			tickNextRAMSample = TickOSTimeCurrent() + dtickRAMSamplePeriod;
			}

		//  perform cache reorg if it is time

		if ( TickCmp( TickOSTimeCurrent(), tickNextCacheReorg ) >= 0 )
			{
			//  perform any necessary cache reorg

			BOOL fReorgDone = FBFICleanThreadIReorgCache();

			//  set next cache reorg time

			if ( fReorgDone )
				{
				tickNextCacheReorg = TickOSTimeCurrent() + dtickCacheReorgPeriod;
				}
			else
				{
				tickNextCacheReorg = TickOSTimeCurrent() + dtickRetryPeriod;
				}
			}

		//  perform checkpoint advancement if it is time

		if ( TickCmp( TickOSTimeCurrent(), tickNextChkptAdv ) >= 0 )
			{
			//  try to flush all buffers that are impeding the checkpoint

			BOOL fDone = FBFICleanThreadIAdvanceCheckpoint();

			//  set next checkpoint advancement time

			if ( fDone )
				{
				tickNextChkptAdv = TickOSTimeCurrent() + dtickChkptAdvPeriod;
				}
			else
				{
				tickNextChkptAdv = TickOSTimeCurrent() + dtickRetryPeriod;
				}
			}

		//  perform normal clean if it is time

		if ( fSignal || TickCmp( TickOSTimeCurrent(), tickNextClean ) >= 0 )
			{
			//  clean to get more avail buffers

			BOOL fDone = FBFICleanThreadIClean();

			//  set next clean time

			if ( fDone )
				{
				tickNextClean = TickOSTimeCurrent() + dtickCleanPeriod;
				}
			else
				{
				tickNextClean = TickOSTimeCurrent() + dtickRetryPeriod;
				}
			}

		//  perform idle flush if it is time

		if ( TickCmp( TickOSTimeCurrent(), tickNextIdleFlush ) >= 0 )
			{
			//  perform idle flush

			BFICleanThreadIIdleFlush();

			//  set next idle flush time

			tickNextIdleFlush = TickOSTimeCurrent() + dtickIdleFlushPeriod;
			}

		//  try to update the checkpoint if it is time

		if ( TickCmp( TickOSTimeCurrent(), tickNextCheckpoint ) >= 0 )
			{
			for ( int ipinst = 0; ipinst < ipinstMax; ipinst++ )
				{
				extern CRITPOOL< INST* > critpoolPinstAPI;
				CCriticalSection *pcritInst = &critpoolPinstAPI.Crit(&g_rgpinst[ipinst]);
				pcritInst->Enter();
				
				INST *pinst = g_rgpinst[ ipinst ];

				if ( pinstNil == pinst )
					{
					pcritInst->Leave();
					continue;
					}

				//	Use APILock to exclude the initializing and
				//	terminating an instance.
				const BOOL fAPILocked = pinst->APILock( pinst->fAPICheckpointing, fTrue );
				pcritInst->Leave();

				if ( fAPILocked )
					{
					if ( pinst->m_fJetInitialized )
						{
						(VOID) pinst->m_plog->ErrLGUpdateCheckpointFile( pinst->m_pfsapi, fFalse );
						}
					
					pinst->APIUnlock( pinst->fAPICheckpointing );
					}
				}
				
			//  set next checkpoint update time
				
			tickNextCheckpoint = TickOSTimeCurrent() + dtickCheckpointPeriod;
			}
		}

	return 0;
	}

//  cleans pages so that the Avail Pool has at least cbfScaledCleanThresholdStart
//  clean BFs, stopping when it reaches cbfScaledCleanThresholdStop BFs.  returns
//  fFalse if more cleaning is needed to reach the stop threshold

BOOL FBFICleanThreadIClean()
	{
	//  scan the LRUK looking for victims to fill the avail pool.  we will limit
	//  our search so that outstanding writes that can eventually become available
	//  buffers count as available.  at the end of the clean, we will still only
	//  consider ourselves done cleaning if the avail pool is at the requested
	//  level.  this is so we can come back later and check on the status of these
	//  flushed buffers and possibly convert them to available buffers

	FMP::BFICleanList	ilBFICleanList;
	BFLRUK::ERR			errLRUK;
	BFLRUK::CLock		lockLRUK;
	bflruk.BeginResourceScan( &lockLRUK );

	ULONG_PTR cbfFlushPending = 0;
	ULONG_PTR cbfLatched = 0;
	ULONG_PTR cbfDependent = 0;
	PBF pbf;
	while (	( errLRUK = bflruk.ErrGetNextResource( &lockLRUK, &pbf ) ) == BFLRUK::errSuccess &&
			bfavail.Cobject() + cbfFlushPending < cbfScaledCleanThresholdStop )
		{
		//  try to evict this page if it is clean or untidy

		const ERR errEvict = ErrBFIEvictPage( pbf, &lockLRUK );

		//  we failed to evict this page and we can flush more pages

		if (	errEvict < JET_errSuccess &&
				cBFPageFlushPending < cBFPageFlushPendingMax )
			{
			//  possibly async flush this page

			const ERR errFlush = ErrBFIFlushPage( pbf );

			//  count the number of latched pages we see

			if ( errEvict == errBFLatchConflict || errFlush == errBFLatchConflict )
				{
				cbfLatched++;
				}

			//  count the number of dependent pages we see

			if ( errFlush == errBFIRemainingDependencies )
				{
				cbfDependent++;
				}
				
			//  we caused a page to be flushed (not necessarily this page)

			if ( errFlush == errBFIPageFlushed )
				{
				cBFPagesOrdinarilyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
				cbfFlushPending++;

				//	prepare the IFMP to be flushed later

				BFICleanThreadIPrepareIssueIFMP( pbf->ifmp, &ilBFICleanList );
				}

			//  we see a page that is in the process of being flushed

			else if ( errFlush == errBFIPageFlushPending )
				{
				cbfFlushPending++;
				}
			}
		}

	//  end our scan of the LRUK

	bflruk.EndResourceScan( &lockLRUK );

	//  issue any remaining queued writes

	BFICleanThreadIIssue( &ilBFICleanList );

	//  get the minimum cache size to avoid an allocation deadlock

	const LONG_PTR cbfCacheDeadlock = (	cbfFlushPending +
										cbfDependent +
										cbfLatched +
										cBFMemory +
										bfavail.CWaiter() );

	//  if we are suffering from an allocation deadlock then grow the cache to
	//  avoid a hang

	if ( cbfCacheDeadlock > cbfCacheSet )
		{
		const ERR err = ErrBFICacheSetSize( cbfCacheDeadlock );
		Assert( ( cbfCacheDeadlock > cbfCache && err == JET_errOutOfMemory ) || err == JET_errSuccess );
		}

	//  keep track of ongoing buffer allocations

	if ( cAvailAllocLast != bfavail.CRemove() )
		{
		cAvailAllocLast		= bfavail.CRemove();
		tickAvailAllocLast	= TickOSTimeCurrent();
		}

	//  if there hasn't been an allocation from the avail pool for some time
	//  yet there are still threads waiting to allocate available buffers
	//  then we will conclude that the clean process has hung and is unable
	//  to produce any more available buffers.  this can happen for many
	//  reasons, including:  OOM growing the cache to avoid an allocation
	//  deadlock, exceeding the max cache size while growing the cache to avoid
	//  an allocation deadlock, and failure to flush dirty buffers due to log
	//  or database write failures

	if (	TickOSTimeCurrent() - tickAvailAllocLast > dtickCleanTimeout &&
			bfavail.CWaiter() > 0 )
		{
		//  trap here first for JET_errOutOfBuffers

		(void)ErrERRCheck( JET_errOutOfBuffers );
		
		//  reset the last allocation time to be exactly equal to the timeout
		//  to avoid nasty wrap-around issues in case we are permanently hung

		tickAvailAllocLast = TickOSTimeCurrent() - dtickCleanTimeout;

		//  release all waiters by giving them invalid BFs allocated from the
		//  stack.  ErrBFIAllocPage will detect that these BFs are invalid and
		//  translate them into an allocation failure.  this will prevent us
		//  from permanently hanging threads in ErrBFIAllocPage

		while ( bfavail.CWaiter() > 0 )
			{
			//  this is the dummy BF we will use to release the waiter.  we put
			//  it on the stack so we know that we will still get the message
			//  across even if we are under very low memory conditions, a
			//  possible scenario for a clean process hang
			
			BF bfDummy;

			//  acquire the X Latch on the BF.  the waiter will release this
			//  latch when it is done referencing the dummy BF

			CSXWLatch::ERR errSXWL = bfDummy.sxwl.ErrAcquireExclusiveLatch();
			Assert(	errSXWL == CSXWLatch::errSuccess );

			//  place the dummy BF in the queue so that it can be allocated by
			//  a thread waiting in ErrBFIAllocPage

			bfDummy.sxwl.ReleaseOwnership( bfltExclusive );
			bfavail.Insert( &bfDummy );

			//  wait for the thread to finish using the BF by waiting to acquire
			//  the X Latch again

			errSXWL = bfDummy.sxwl.ErrAcquireExclusiveLatch();
			Assert(	errSXWL == CSXWLatch::errSuccess ||
					errSXWL == CSXWLatch::errWaitForExclusiveLatch );
			if ( errSXWL == CSXWLatch::errWaitForExclusiveLatch )
				{
				bfDummy.sxwl.WaitForExclusiveLatch();
				}
			bfDummy.sxwl.ReleaseExclusiveLatch();

			//  fudge our last allocation count so that we don't trick ourselves
			//  into thinking that normal operations have resumed because someone
			//  allocated a buffer when in fact it was just us releasing threads
			//  with our dummy BF

			cAvailAllocLast++;
			}
		}
	
	//  return our status

	return bfavail.Cobject() >= cbfScaledCleanThresholdStop;
	}

//  performs idle flushing of the cache for this IFMP

void BFICleanThreadIIdleFlushForIFMP( IFMP ifmp, FMP::BFICleanList *pilBFICleanList )
	{
	FMP* pfmp = &rgfmp[ ifmp & ifmpMask ];

	//  we have a context so there may be BFs in the OB0 index

	pfmp->RwlBFContext().EnterAsReader();
	BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( ifmp & ifmpSLV ) );
	if ( pbffmp )
		{
		//  flush at least one BF from the OB0 index and overflow list

		BFOB0::ERR		errOB0;
		BFOB0::CLock	lockOB0;

		pbffmp->bfob0.MoveBeforeFirst( &lockOB0 );
		while ( pbffmp->bfob0.ErrMoveNext( &lockOB0 ) != BFOB0::errNoCurrentEntry )
			{
			PBF pbf;
			errOB0 = pbffmp->bfob0.ErrRetrieveEntry( &lockOB0, &pbf );
			Assert( errOB0 == BFOB0::errSuccess );

			LGPOS lgposOldestBegin0;
			lgposOldestBegin0.SetByIbOffset(	(	pbf->lgposOldestBegin0.IbOffset() /
													dlgposBFOB0Uncertainty.IbOffset() ) *
												dlgposBFOB0Uncertainty.IbOffset() );

			if (	pbf->bfdf == bfdfClean &&
					pbf->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
				{
				if ( pbf->bfdf == bfdfClean )
					{
					errOB0 = pbffmp->bfob0.ErrDeleteEntry( &lockOB0 );
					Assert( errOB0 == BFOB0::errSuccess );

					pbf->lgposOldestBegin0	= lgposMax;
					lgposOldestBegin0		= lgposMax;
					}
				pbf->sxwl.ReleaseExclusiveLatch();
				}
			if (	CmpLgpos( &lgposOldestBegin0, &lgposMax ) &&
					ErrBFIFlushPage( pbf ) == errBFIPageFlushed )
				{
				cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
				cBFPagesIdlyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
				
				BFICleanThreadIPrepareIssueIFMP( ifmp, pilBFICleanList );
				break;
				}
			}
		pbffmp->bfob0.UnlockKeyPtr( &lockOB0 );

		pbffmp->critbfob0ol.Enter();
		PBF pbfNext;
		for ( PBF pbf = pbffmp->bfob0ol.PrevMost(); pbf != pbfNil; pbf = pbfNext )
			{
			pbfNext = pbffmp->bfob0ol.Next( pbf );
			
			if (	pbf->bfdf == bfdfClean &&
					pbf->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
				{
				if ( pbf->bfdf == bfdfClean )
					{
					pbf->fInOB0OL = fFalse;
			
					pbffmp->bfob0ol.Remove( pbf );

					pbf->lgposOldestBegin0	= lgposMax;
					}
				pbf->sxwl.ReleaseExclusiveLatch();
				}
			if (	CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) &&
					ErrBFIFlushPage( pbf ) == errBFIPageFlushed )
				{
				cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
				cBFPagesIdlyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
				
				BFICleanThreadIPrepareIssueIFMP( ifmp, pilBFICleanList );
				break;
				}
			}
		pbffmp->critbfob0ol.Leave();
		}
	pfmp->RwlBFContext().LeaveAsReader();
	}

//  performs idle flushing of the cache.  this process performs incremental
//  writes of BFs by BFOB0 index then in-memory order.  The goal is not only to
//  minimize recovery time on a crash but also to give us a chance to write
//  changes made to cached pages that should only be written if we have
//  bandwidth to spare (untidy pages)

void BFICleanThreadIIdleFlush()
	{
	//  collect I/O statistics on the cache maneger

	const long	cPagesRead		= cBFPagesRead.Get( perfinstGlobal );
	const long	cPagesWritten	= (	cBFPagesWritten.Get( perfinstGlobal ) -
									cBFPagesOpportunelyWritten.Get( perfinstGlobal ) -
									cBFPagesIdlyWritten.Get( perfinstGlobal ) );
									
	const long	dcPagesRead		= cPagesRead - cIdlePagesRead;
	const long	dcPagesWritten	= cPagesWritten - cIdlePagesWritten;
	const long	dcPagesIO		= dcPagesRead + dcPagesWritten;

	//  some non-idle I/O occurred this period

	if ( dcPagesIO > 0 )
		{
		//  reset all I/O counters to forget that this I/O occurred

		cIdlePagesRead			= cPagesRead;
		cIdlePagesWritten		= cPagesWritten;

		//  we experienced more than a minimal amount of non-idle I/O
		
		if ( dcPagesIO > dcPagesIOIdleLimit )
			{
			//  reset our idle period to indicate that we are no longer idle
			
			tickIdlePeriodStart = TickOSTimeCurrent();
			}
		}
	
	//  we are idle if there has been minimal I/O other than idle flushes for
	//  at least a given period of time and we are allowed to do idle activity

	const BOOL fIdle = (	TickOSTimeCurrent() - tickIdlePeriodStart >= dtickIdleDetect &&
							!FUtilSystemRestrictIdleActivity() );

	//  we are not currently idle flushing

	if ( !fIdleFlushActive )
		{
		//  if we are idle and the cache is too dirty then activate the idle
		//  flush process

		if ( fIdle && cBFClean < pctIdleFlushStart * cbfCache / 100 )
			{
			fIdleFlushActive = fTrue;
			}
		}

	//  we are currently idle flushing

	else
		{
		//  if we are not idle or the cache is clean enough then deactivate the
		//  idle flush process

		if ( !fIdle || cBFClean >= pctIdleFlushStop * cbfCache / 100 )
			{
			fIdleFlushActive = fFalse;
			}
		}

	//  perform idle flush if active

	if ( fIdleFlushActive )
		{
		FMP::BFICleanList ilBFICleanList;

		//  compute the number of pages to flush this pass
		
		LONG_PTR cbfIdleFlushMin	= cbfCache * dtickIdleFlushPeriod / ctickIdleFlushTime;
		LONG_PTR cbfIdleFlushStart	= cBFPagesIdlyWritten.Get( perfinstGlobal );

		//  evenly idle flush pages from the OB0 indexes of all active databases
		//  until we have reached our limit or there are none left

		LONG_PTR cbfIdleFlushIter;
		do
			{
			cbfIdleFlushIter = cBFPagesIdlyWritten.Get( perfinstGlobal );
			
			for ( IFMP ifmp = FMP::IfmpMinInUse(); ifmp <= FMP::IfmpMacInUse(); ifmp++ )
				{
				if ( rgfmp[ ifmp ].DwBFContext( 0 ) )
					{
					BFICleanThreadIIdleFlushForIFMP( ifmp, &ilBFICleanList );
					}
				if ( rgfmp[ ifmp ].DwBFContext( 1 ) )
					{
					BFICleanThreadIIdleFlushForIFMP( ifmp | ifmpSLV, &ilBFICleanList );
					}
				}
			}
		while (	cBFPagesIdlyWritten.Get( perfinstGlobal ) - cbfIdleFlushStart < cbfIdleFlushMin &&
				cBFPagesIdlyWritten.Get( perfinstGlobal ) - cbfIdleFlushIter > 0 );

		//  use any remaining idle flush limit to circularly walk the cache and
		//  flush whatever we find

		static IBF ibfIdleScan = 0;
		
		LONG_PTR citer = 0;
		do
			{
			PBF pbf = PbfBFICacheIbf( ++ibfIdleScan % cbfInit );

			if ( ErrBFIFlushPage( pbf, bfdfUntidy ) == errBFIPageFlushed )
				{
				cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
				cBFPagesIdlyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
				
				BFICleanThreadIPrepareIssueIFMP( pbf->ifmp, &ilBFICleanList );
				}
			}
		while (	cBFPagesIdlyWritten.Get( perfinstGlobal ) - cbfIdleFlushStart < cbfIdleFlushMin &&
				++citer < cbfIdleFlushMin );

		//  issue any remaining queued writes

		BFICleanThreadIIssue( &ilBFICleanList );
		}
	}

//  performs cache reorganization requested by the user changing the cache set
//  point via ErrBFSetCacheSize(), returning fTrue if done

BOOL FBFICleanThreadIReorgCache()
	{
	//  scan through all resident BFs above the set point, trying to flush / evict
	//  pages in order to shrink the cache

	FMP::BFICleanList	ilBFICleanList;
	
	for ( IBF ibf = cbfCache - 1; ibf > cbfCacheSet - 1; ibf-- )
		{
		PBF pbf = PbfBFICacheIbf( ibf );

		//  we can exclusively latch this BF

		CSXWLatch::ERR errSXWL = pbf->sxwl.ErrTryAcquireExclusiveLatch();
		
		if ( errSXWL == CSXWLatch::errSuccess )
			{
			//  lock this BF in the LRUK in preparation for a possible eviction

			BFLRUK::CLock	lockLRUK;
			bflruk.LockResourceForEvict( pbf, &lockLRUK );

			//  release our exclusive latch.  we do not have to worry about
			//  the page being evicted because we have the LRUK locked

			pbf->sxwl.ReleaseExclusiveLatch();

			//  try to evict this page if it is clean or untidy

			const ERR errEvict = ErrBFIEvictPage( pbf, &lockLRUK );

			//  we failed to evict this page and we can flush more pages

			if (	errEvict < JET_errSuccess &&
					cBFPageFlushPending < cBFPageFlushPendingMax )
				{
				//  possibly async flush this page

				const ERR errFlush = ErrBFIFlushPage( pbf );
					
				//  we caused a page to be flushed (not necessarily this page)

				if ( errFlush == errBFIPageFlushed )
					{
					cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
					
					//	prepare the IFMP to be flushed later

					BFICleanThreadIPrepareIssueIFMP( pbf->ifmp, &ilBFICleanList );
					}
				}

			//  unlock the LRUK

			bflruk.UnlockResourceForEvict( &lockLRUK );
			}
		}

	//  purge all BFs in the avail pool that are above the set point

	BFAvail::CLock lockAvail;
	bfavail.BeginPoolScan( &lockAvail );

	PBF pbfAvail;
	while ( bfavail.ErrGetNextObject( &lockAvail, &pbfAvail ) == BFAvail::errSuccess )
		{
		//  this BF is above the set point
		
		if ( IbfBFICachePbf( pbfAvail ) >= cbfCacheSet )
			{
			//  we successfully removed this BF from the avail pool
			
			if ( bfavail.ErrRemoveCurrentObject( &lockAvail ) == BFAvail::errSuccess )
				{
				//  mark this BF as quiesced

				pbfAvail->fAvailable	= fFalse;
				pbfAvail->fQuiesced		= fTrue;
				}
			}
		}

	bfavail.EndPoolScan( &lockAvail );

	//  issue any remaining queued writes

	BFICleanThreadIIssue( &ilBFICleanList );

	//  we need to start cleaning because we ate too many avail buffers from
	//  above the set point

	if ( bfavail.Cobject() <= cbfScaledCleanThresholdStart )
		{
		//  start cleaning
		
		BFICleanThreadStartClean();
		}

	//  set the cache size to contain the highest BF we didn't quiesce

	CallS( ErrBFICacheSetSize( cbfCacheSet ) );

	//  we are done if the cache is at or below the set size

	return cbfCache <= cbfCacheSet;
	}

//  tries to flush all buffers that are impeding the checkpoint for the given IFMP

BOOL FBFICleanThreadIAdvanceCheckpointForIFMP( IFMP ifmp, FMP::BFICleanList *pilBFICleanList )
	{
	BOOL fDone = fTrue;
	
	FMP* pfmp = &rgfmp[ ifmp & ifmpMask ];

	//  if no context is present, there must be no buffers impeding the checkpoint

	pfmp->RwlBFContext().EnterAsReader();
	BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( ifmp & ifmpSLV ) );
	if ( !pbffmp )
		{
		pfmp->RwlBFContext().LeaveAsReader();
		return fDone;
		}

	//  get the most recent log record

	LOG* const	plog		= pfmp->Pinst()->m_plog;
	const LGPOS	lgposNewest	= plog->m_fRecoveringMode == fRecoveringRedo ?
								plog->m_lgposRedo :
								plog->m_lgposLogRec;

	//  flush all buffers that are impeding the checkpoint

	BFOB0::ERR		errOB0;
	BFOB0::CLock	lockOB0;

	pbffmp->bfob0.MoveBeforeFirst( &lockOB0 );
	while ( pbffmp->bfob0.ErrMoveNext( &lockOB0 ) != BFOB0::errNoCurrentEntry )
		{
		//  if we have too many oustanding page flushes then we will need to
		//  try again later

		if ( cBFPageFlushPending >= cBFPageFlushPendingMax )
			{
			break;
			}

		PBF pbf;
		errOB0 = pbffmp->bfob0.ErrRetrieveEntry( &lockOB0, &pbf );
		Assert( errOB0 == BFOB0::errSuccess );

		LGPOS lgposOldestBegin0;
		lgposOldestBegin0.SetByIbOffset(	(	pbf->lgposOldestBegin0.IbOffset() /
												dlgposBFOB0Uncertainty.IbOffset() ) *
											dlgposBFOB0Uncertainty.IbOffset() );

		if (	plog->CbOffsetLgpos( lgposNewest, lgposOldestBegin0 ) > cbCleanCheckpointDepthMax ||
				pbf->bfdf == bfdfClean )
			{
			if (	pbf->bfdf == bfdfClean &&
					pbf->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
				{
				if ( pbf->bfdf == bfdfClean )
					{
					errOB0 = pbffmp->bfob0.ErrDeleteEntry( &lockOB0 );
					Assert( errOB0 == BFOB0::errSuccess );

					pbf->lgposOldestBegin0	= lgposMax;
					lgposOldestBegin0		= lgposMax;
					}
				pbf->sxwl.ReleaseExclusiveLatch();
				}
			if ( CmpLgpos( &lgposOldestBegin0, &lgposMax ) )
				{
				switch( ErrBFIFlushPage( pbf ) )
					{
					case errBFIPageFlushed:
						cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
						BFICleanThreadIPrepareIssueIFMP( ifmp, pilBFICleanList );
					case errBFIPageFlushPending:
					case errBFIRemainingDependencies:
					case errBFLatchConflict:
						fDone = fFalse;
						break;
					default:
						break;
					}
				}
			}
		else
			{
			break;
			}
		}
	pbffmp->bfob0.UnlockKeyPtr( &lockOB0 );

	pbffmp->critbfob0ol.Enter();
	PBF pbfNext;
	for ( PBF pbf = pbffmp->bfob0ol.PrevMost(); pbf != pbfNil; pbf = pbfNext )
		{
		pbfNext = pbffmp->bfob0ol.Next( pbf );
		
		//  if we have too many oustanding page flushes then we will need to
		//  try again later

		if ( cBFPageFlushPending >= cBFPageFlushPendingMax )
			{
			break;
			}

		if (	plog->CbOffsetLgpos( lgposNewest, pbf->lgposOldestBegin0 ) > cbCleanCheckpointDepthMax ||
				pbf->bfdf == bfdfClean )
			{
			if (	pbf->bfdf == bfdfClean &&
					pbf->sxwl.ErrTryAcquireExclusiveLatch() == CSXWLatch::errSuccess )
				{
				if ( pbf->bfdf == bfdfClean )
					{
					pbf->fInOB0OL = fFalse;
			
					pbffmp->bfob0ol.Remove( pbf );

					pbf->lgposOldestBegin0	= lgposMax;
					}
				pbf->sxwl.ReleaseExclusiveLatch();
				}
			if ( CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) )
				{
				switch( ErrBFIFlushPage( pbf ) )
					{
					case errBFIPageFlushed:
						cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
						BFICleanThreadIPrepareIssueIFMP( ifmp, pilBFICleanList );
					case errBFIPageFlushPending:
					case errBFIRemainingDependencies:
					case errBFLatchConflict:
						fDone = fFalse;
						break;
					default:
						break;
					}
				}
			}
		}
	pbffmp->critbfob0ol.Leave();

	pfmp->RwlBFContext().LeaveAsReader();

	return fDone;
	}

//  tries to flush all buffers that are impeding the checkpoint

BOOL FBFICleanThreadIAdvanceCheckpoint()
	{
	FMP::BFICleanList	ilBFICleanList;
	BOOL				fDone = fTrue;
	
	//  scan all active databases
	
	for ( IFMP ifmp = FMP::IfmpMinInUse(); ifmp <= FMP::IfmpMacInUse(); ifmp++ )
		{
		//  advance the checkpoint for this IFMP
		
		if ( rgfmp[ ifmp ].DwBFContext( 0 ) )
			{
			fDone = FBFICleanThreadIAdvanceCheckpointForIFMP( ifmp, &ilBFICleanList ) && fDone;
			}
		if ( rgfmp[ ifmp ].DwBFContext( 1 ) )
			{
			fDone = FBFICleanThreadIAdvanceCheckpointForIFMP( ifmp | ifmpSLV, &ilBFICleanList ) && fDone;
			}
		}

	//  issue any remaining queued writes

	BFICleanThreadIIssue( &ilBFICleanList );

	return fDone;
	}


//	prepare to flush an IFMP by putting it into the clean thread's private flush list and 
//	marking its database or SLV file

void BFICleanThreadIPrepareIssueIFMP( IFMP ifmp, FMP::BFICleanList *pilBFICleanList )
	{
	FMP *pfmpFlush = &rgfmp[ ifmp & ifmpMask ];

	Assert( pilBFICleanList );
	if ( !pilBFICleanList->FMember( pfmpFlush ) )
		{
		pilBFICleanList->InsertAsNextMost( pfmpFlush );
		}

	if ( ifmp & ifmpSLV )
		{
		pfmpFlush->SetBFICleanSLV();
		}
	else
		{
		pfmpFlush->SetBFICleanDb();
		}
	}

//	flush the clean thread's private list of IFMPs

void BFICleanThreadIIssue( FMP::BFICleanList *pilBFICleanList )
	{
	FMP *pfmpT;

	//	flush each IFMP in the list

	Assert( pilBFICleanList );
	pfmpT = pilBFICleanList->PrevMost();
	while ( pfmpT )
		{

		//	issue I/O

		if ( pfmpT->FBFICleanDb() )
			{
			CallS( pfmpT->Pfapi()->ErrIOIssue() );
			pfmpT->ResetBFICleanDb();
			}

		if ( pfmpT->FBFICleanSLV() )
			{
			CallS( pfmpT->PfapiSLV()->ErrIOIssue() );
			pfmpT->ResetBFICleanSLV();
			}

		//	remove this FMP and move next

		FMP *pfmpNext = pilBFICleanList->Next( pfmpT );
		pilBFICleanList->Remove( pfmpT );
		pfmpT = pfmpNext;
		}
	}


//  Internal Functions

	//  System Parameters

//  validates the current configuration of all cache manager settings

ERR ErrBFIValidateParameters()
	{
	//  set defaults, if not already set

	BFISetParameterDefaults();

	//  get all the settings that we are going to be checking
	
	ULONG_PTR cbfCacheMin;
	CallS( ErrBFGetCacheSizeMin( &cbfCacheMin ) );
	ULONG_PTR cbfCacheMax;
	CallS( ErrBFGetCacheSizeMax( &cbfCacheMax ) );
	ULONG_PTR cbfCleanThresholdStart;
	CallS( ErrBFGetStartFlushThreshold( &cbfCleanThresholdStart ) );
	ULONG_PTR cbfCleanThresholdStop;
	CallS( ErrBFGetStopFlushThreshold( &cbfCleanThresholdStop ) );

	//  if any of our settings don't make sense then adjust them to be close
	//  to what was asked for but still legal

	if ( cbfCacheMin > cbfCacheMax )
		{
		cbfCacheMin = cbfCacheMax;
		CallS( ErrBFSetCacheSizeMin( cbfCacheMin ) );
		}

	if ( cbfCleanThresholdStop > cbfCacheMax )
		{
		cbfCleanThresholdStop = cbfCacheMax;
		CallS( ErrBFSetStopFlushThreshold( cbfCleanThresholdStop ) );
		}

	if ( cbfCleanThresholdStart > cbfCleanThresholdStop )
		{
		cbfCleanThresholdStart = cbfCleanThresholdStop;
		CallS( ErrBFSetStartFlushThreshold( cbfCleanThresholdStart ) );
		}

	//  if the max cache size is still set at the default max cache size then
	//  set the max cache size to allow allocating as much physical memory as
	//  we can map into our address space

	if ( cbfCacheMax == lCacheSizeDefault )
		{
		cbfCacheMax = ULONG_PTR( QWORD( min( OSMemoryPageReserveTotal(), OSMemoryTotal() ) ) / g_cbPage );
		CallS( ErrBFSetCacheSizeMax( cbfCacheMax ) );
		cbfCleanThresholdStart = ULONG_PTR( QWORD( cbfCleanThresholdStart ) * cbfCacheMax / lCacheSizeDefault );
		CallS( ErrBFSetStartFlushThreshold( cbfCleanThresholdStart ) );
		cbfCleanThresholdStop = ULONG_PTR( QWORD( cbfCleanThresholdStop ) * cbfCacheMax / lCacheSizeDefault );
		CallS( ErrBFSetStopFlushThreshold( cbfCleanThresholdStop ) );
		}

	return JET_errSuccess;
	}

//  sets all BF system parameter defaults, if not yet set

void BFISetParameterDefaults()
	{
	//  the defaults have not been set yet

	critBFParm.Enter();
	if ( !fBFDefaultsSet )
		{
		//  the defaults are now being set

		fBFDefaultsSet = fTrue;
		critBFParm.Leave();

		//  set defaults for each and every BF system parameter

		CallS( ErrBFSetCacheSizeMin( lCacheSizeMinDefault ) );
		CallS( ErrBFSetCacheSizeMax( lCacheSizeDefault ) );
		CallS( ErrBFSetCheckpointDepthMax( lCheckpointDepthMaxDefault ) );
		CallS( ErrBFSetLRUKCorrInterval( lLRUKCorrIntervalDefault ) );
		CallS( ErrBFSetLRUKPolicy( lLRUKPolicyDefault ) );
		CallS( ErrBFSetLRUKTimeout( lLRUKTimeoutDefault ) );
		CallS( ErrBFSetStopFlushThreshold( lStopFlushThresholdDefault ) );
		CallS( ErrBFSetStartFlushThreshold( lStartFlushThresholdDefault ) );

		//  CONSIDER:  expose these settings

#ifdef DEBUG
		fROCacheImage = COSMemoryMap::FCanMultiMap();
#else  //  !DEBUG
		fROCacheImage = fFalse;
#endif  //  DEBUG
		dblBFSpeedSizeTradeoff	= 0.0;
		dblBFHashLoadFactor		= 5.0;
		dblBFHashUniformity		= 1.0;
		csecBFLRUKUncertainty	= 1.0;

		dlgposBFOB0Precision.lGeneration	= 256;
		dlgposBFOB0Precision.isec			= 0;
		dlgposBFOB0Precision.ib				= 0;
		
		dlgposBFOB0Uncertainty.lGeneration	= 0;
		dlgposBFOB0Uncertainty.isec			= 128;
		dlgposBFOB0Uncertainty.ib			= 0;

		fEnableOpportuneWrite = fTrue;

		//  load configuration from the registry

		const int	cbBuf			= 256;
		_TCHAR		szBuf[ cbBuf ];
		
		if (	FOSConfigGet( _T( "Cache Manager" ), _T( "Enable RO Cache Image" ), szBuf, cbBuf ) &&
				szBuf[ 0 ] )
			{
			fROCacheImage = !!_ttol( szBuf ) && COSMemoryMap::FCanMultiMap();
			}
		
		if (	FOSConfigGet( _T( "Cache Manager" ), _T( "Enable Opportune Writes" ), szBuf, cbBuf ) &&
				szBuf[ 0 ] )
			{
			fEnableOpportuneWrite = !!_ttol( szBuf );
			}
		}
	else
		{
		critBFParm.Leave();
		}
	}

//  normalizes the flush thresholds after a parameter that could affect them changes

INLINE void BFINormalizeThresholds()
	{
	//  scale flush thresholds to cache size

	cbfScaledCleanThresholdStart = LONG_PTR( QWORD( cbfCleanThresholdStart ) * cbfCache / cbfCacheMax );
	cbfScaledCleanThresholdStop = LONG_PTR( QWORD( cbfCleanThresholdStop ) * cbfCache / cbfCacheMax );
	if ( cbfScaledCleanThresholdStart == cbfScaledCleanThresholdStop )
		{
		cbfScaledCleanThresholdStop += cbfCache / 100;
		}

	if ( cbfScaledCleanThresholdStop == cbfCacheMax )
		{
		cbfScaledCleanThresholdStop = cbfCacheMax - 1;
		}
	if ( cbfScaledCleanThresholdStop - cbfScaledCleanThresholdStart < 1 )
		{
		cbfScaledCleanThresholdStop = min( cbfCacheMax - 1, cbfScaledCleanThresholdStop + 1 );
		}
	if ( cbfScaledCleanThresholdStop - cbfScaledCleanThresholdStart < 1 )
		{
		cbfScaledCleanThresholdStart = max( 1, cbfScaledCleanThresholdStart - 1 );
		}
	}

	//  Page Manipulation

ERR ErrBFIAllocPage( PBF* const ppbf, const BOOL fWait )
	{
	ERR err = JET_errSuccess;

	//  try to allocate an available BF, waiting forever if we are not just
	//  allocating only if available

	BFAvail::ERR errAvail;
	errAvail = bfavail.ErrRemove( ppbf, fWait );
	if ( errAvail == BFAvail::errOutOfObjects )
		{
		Call( ErrERRCheck( errBFINoBufferAvailable ) );
		}
	Assert( errAvail == BFAvail::errSuccess );

	//  we need to start cleaning

	if ( bfavail.Cobject() <= cbfScaledCleanThresholdStart )
		{
		//  start cleaning
		
		BFICleanThreadStartClean();
		}

	//  the BF we got from the pool is not a valid BF

	if ( !FBFICacheValidPbf( *ppbf ) )
		{
		//  the clean thread gave us a dummy BF to unblock us because it could
		//  not produce any more clean buffers.  as a result, we will fail this
		//  allocation with a fatal resource error after acknowledging that we
		//  have received that signal by releasing the X Latch on the dummy BF

		(*ppbf)->sxwl.ClaimOwnership( bfltExclusive );
		(*ppbf)->sxwl.ReleaseExclusiveLatch();

		if ( fWait )
			{
			Call( ErrERRCheck( JET_errOutOfBuffers ) );
			}
		else
			{
			Call( ErrERRCheck( errBFINoBufferAvailable ) );
			}
		}

	//  update DBA statistics

	(*ppbf)->fAvailable = fFalse;

	if ( (*ppbf)->fNewlyCommitted )
		{
		(*ppbf)->fNewlyCommitted = fFalse;
		AtomicDecrement( (long*)&cbfNewlyCommitted );
		}

	if ( (*ppbf)->fNewlyEvicted )
		{
		(*ppbf)->fNewlyEvicted = fFalse;
		cbfNewlyEvictedUsed++;
		}

	return JET_errSuccess;

HandleError:
	*ppbf = pbfNil;
	return err;
	}

void BFIFreePage( PBF pbf )
	{
	//  officially remove this IFMP / PGNO from this BF

	pbf->ifmp = ~( IFMP( 0 ) );
	pbf->pgno = pgnoNull;

	//  mark this BF as available

	pbf->fQuiesced	= fFalse;
	pbf->fAvailable	= fTrue;

	//  free the available BF

	bfavail.Insert( pbf );
	}

ERR ErrBFICachePage(	PBF* const	ppbf,
						const IFMP	ifmp,
						const PGNO	pgno,
						const BOOL	fUseHistory,
						const BOOL	fWait )
	{
	ERR				err;
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	BFLRUK::ERR		errLRUK;
	
	//  allocate our BF FMP context, if not allocated

	FMP* pfmp = &rgfmp[ ifmp & ifmpMask ];
	if ( !pfmp->DwBFContext( !!( ifmp & ifmpSLV ) ) )
		{
		pfmp->RwlBFContext().EnterAsWriter();
		if ( !pfmp->DwBFContext( !!( ifmp & ifmpSLV ) ) )
			{
			BYTE* rgbBFFMPContext = (BYTE*)PvOSMemoryHeapAllocAlign( sizeof( BFFMPContext ), cbCacheLine );
			if ( !rgbBFFMPContext )
				{
				pfmp->RwlBFContext().LeaveAsWriter();
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			BFFMPContext* pbffmp = new( rgbBFFMPContext ) BFFMPContext();

			BFOB0::ERR errOB0 = pbffmp->bfob0.ErrInit(	dlgposBFOB0Precision.IbOffset(),
														dlgposBFOB0Uncertainty.IbOffset(),
														dblBFSpeedSizeTradeoff );
			if ( errOB0 != BFOB0::errSuccess )
				{
				Assert( errOB0 == BFOB0::errOutOfMemory );

				pbffmp->BFFMPContext::~BFFMPContext();
				OSMemoryHeapFreeAlign( pbffmp );
				
				pfmp->RwlBFContext().LeaveAsWriter();
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			
			pfmp->SetDwBFContext( !!( ifmp & ifmpSLV ), DWORD_PTR( pbffmp ) );
			}
		pfmp->RwlBFContext().LeaveAsWriter();
		}
	
	//  allocate a new BF to contain this IFMP / PGNO, waiting forever if
	//  necessary and requested

	Call( ErrBFIAllocPage( &pgnopbf.pbf, fWait ) );

	//  set this BF to contain this IFMP / PGNO

	pgnopbf.pbf->ifmp = ifmp;
	pgnopbf.pbf->pgno = pgno;

	pgnopbf.pgno = pgno;

	//  insert this IFMP / PGNO in the LRUK

	errLRUK = bflruk.ErrCacheResource( IFMPPGNO( ifmp, pgno ), pgnopbf.pbf, fUseHistory );

	//  we failed to insert this IFMP / PGNO in the LRUK
	
	if ( errLRUK != BFLRUK::errSuccess )
		{
		Assert( errLRUK == BFLRUK::errOutOfMemory );

		//  release our allocated BF

		BFIFreePage( pgnopbf.pbf );

		//  bail with out of memory

		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  insert this IFMP / PGNO in the hash table

	bfhash.WriteLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrInsertEntry( &lock, pgnopbf );
	bfhash.WriteUnlockKey( &lock );

	//  the insert succeeded

	if ( errHash == BFHash::errSuccess )
		{
		//  mark this BF as the current version of this IFMP / PGNO

		pgnopbf.pbf->fCurrentVersion = fTrue;
		
		//  return success

		*ppbf = pgnopbf.pbf;
		return JET_errSuccess;
		}

	//  the insert failed

	else
		{
		//  release our allocated BF
		//
		//  HACK:  if we can't evict the resource, wait until we can.  no one
		//  else will be able to evict it because we have the write latch so we
		//  can't get stuck here forever.  besides, this case is extremely rare

 		while ( bflruk.ErrEvictResource( IFMPPGNO( pgnopbf.pbf->ifmp, pgnopbf.pbf->pgno ), pgnopbf.pbf, fFalse ) != BFLRUK::errSuccess )
 			{
 			UtilSleep( cmsecWaitGeneric );
 			}

		BFIFreePage( pgnopbf.pbf );
		
		//  the insert failed because the IFMP / PGNO is already cached

		if ( errHash == BFHash::errKeyDuplicate )
			{
			//  fail with page already cached

			Call( ErrERRCheck( errBFPageCached ) );
			}

		//  the insert failed because we are out of memory

		else
			{
			Assert( errHash == BFHash::errOutOfMemory );

			//  fail with out of memory

			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}

HandleError:
	*ppbf = pbfNil;
	return err;
	}
	
ERR ErrBFIVersionPage( PBF pbf, PBF* ppbfOld )
	{
	ERR			err		= JET_errSuccess;
	BFLRUK::ERR	errLRUK;
	
	//  allocate a new BF to contain the OLD version of the given BF

	Call( ErrBFIAllocPage( ppbfOld ) );

	//  set this BF to contain this IFMP / PGNO

	(*ppbfOld)->ifmp = pbf->ifmp;
	(*ppbfOld)->pgno = pbf->pgno;

	//  insert this IFMP / PGNO in the LRUK.  do not use history so that the
	//  old BF will be evicted ASAP

	errLRUK = bflruk.ErrCacheResource( IFMPPGNO( pbf->ifmp, pbf->pgno ), *ppbfOld, fFalse );

	//  we failed to insert this IFMP / PGNO in the LRUK
	
	if ( errLRUK != BFLRUK::errSuccess )
		{
		Assert( errLRUK == BFLRUK::errOutOfMemory );

		//  release our allocated BF

		BFIFreePage( *ppbfOld );

		//  bail with out of memory

		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	(*ppbfOld)->sxwl.ClaimOwnership( bfltWrite );

	//  save the current BF image

	UtilMemCpy( (*ppbfOld)->pvRWImage, pbf->pvROImage, g_cbPage );

	//  copy the error state

	(*ppbfOld)->err = pbf->err;

	//  mark both BFs as dirty.  if the given BF is filthy, move the filthy state
	//  to the old BF

	BFIDirtyPage( pbf, bfdfDirty );
	BFIDirtyPage( *ppbfOld, BFDirtyFlags( pbf->bfdf ) );
	pbf->bfdf = bfdfDirty;

	//  move the lgpos information to the old BF because it is tied with the
	//  flush of the relevant data

	BFISetLgposOldestBegin0( *ppbfOld, pbf->lgposOldestBegin0 );
	BFIResetLgposOldestBegin0( pbf );

	BFISetLgposModify( *ppbfOld, pbf->lgposModify );
	BFIResetLgposModify( pbf );

	//  move the dependency tree from the given BF to the old BF, fixing up the
	//  dependency tree as necessary

	critBFDepend.Enter();

	Assert( FBFIAssertValidDependencyTree( pbf ) );
	Assert( FBFIAssertValidDependencyTree( *ppbfOld ) );
	
	(*ppbfOld)->pbfDependent		= pbf->pbfDependent;
	(*ppbfOld)->pbfDepChainHeadPrev	= pbf->pbfDepChainHeadPrev;
	(*ppbfOld)->pbfDepChainHeadNext	= pbf->pbfDepChainHeadNext;
	
	if ( pbf->FDependent() )
		{
		PBF pbfPrevMost = pbf;
		while ( pbfPrevMost->FDependent() )
			{
			pbfPrevMost = pbfPrevMost->pbfDepChainHeadNext;
			Assert( pbfPrevMost != pbfNil );
			}
		PBF pbfNextMost = pbf;
		while ( pbfNextMost->FDependent() )
			{
			pbfNextMost = pbfNextMost->pbfDepChainHeadPrev;
			Assert( pbfNextMost != pbfNil );
			}
		PBF pbfDepChainHead = pbfNil;
		do
			{
			pbfDepChainHead = pbfDepChainHead == pbfNil ? pbfPrevMost : pbfDepChainHead->pbfDepChainHeadNext;
			PBF pbfCurr = pbfDepChainHead;
			while ( pbfCurr != *ppbfOld && pbfCurr->pbfDependent != pbf )
				{
				pbfCurr = pbfCurr->pbfDependent;
				}
			if ( pbfCurr != *ppbfOld )
				{
				pbfCurr->pbfDependent = *ppbfOld;
				}
			}
		while ( pbfDepChainHead != pbfNextMost );
		}
	else
		{
		if ( pbf->pbfDepChainHeadPrev == pbf )
			{
			Assert( pbf->pbfDepChainHeadNext == pbf );
			(*ppbfOld)->pbfDepChainHeadPrev = *ppbfOld;
			(*ppbfOld)->pbfDepChainHeadNext = *ppbfOld;
			}
		else
			{
			Assert( pbf->pbfDepChainHeadNext != pbf );
			PBF pbfNext = pbf->pbfDepChainHeadNext;
			PBF pbfPrev = pbf->pbfDepChainHeadPrev;
			Assert( pbfNext->pbfDepChainHeadPrev == pbf );
			Assert( pbfPrev->pbfDepChainHeadNext == pbf );
			pbfNext->pbfDepChainHeadPrev = *ppbfOld;
			pbfPrev->pbfDepChainHeadNext = *ppbfOld;
			}
		}
	if ( pbf->pbfDependent != pbfNil )
		{
		PBF pbfD = pbf->pbfDependent;
		if ( pbfD->pbfDepChainHeadPrev == pbf )
			{
			pbfD->pbfDepChainHeadPrev = *ppbfOld;
			}
		if ( pbfD->pbfDepChainHeadNext == pbf )
			{
			pbfD->pbfDepChainHeadNext = *ppbfOld;
			}
		}

	pbf->pbfDependent			= pbfNil;
	pbf->pbfDepChainHeadPrev	= pbf;
	pbf->pbfDepChainHeadNext	= pbf;
		
	Assert( FBFIAssertValidDependencyTree( pbf ) );
	Assert( FBFIAssertValidDependencyTree( *ppbfOld ) );

	//  add ourself as a time dependency to the given BF

	(*ppbfOld)->pbfTimeDepChainNext	= pbf->pbfTimeDepChainNext;
	(*ppbfOld)->pbfTimeDepChainPrev	= pbf;
	pbf->pbfTimeDepChainNext		= *ppbfOld;
	if ( (*ppbfOld)->pbfTimeDepChainNext != pbfNil )
		{
		(*ppbfOld)->pbfTimeDepChainNext->pbfTimeDepChainPrev = *ppbfOld;
		}

	(*ppbfOld)->fOlderVersion = fTrue;

	critBFDepend.Leave();

	//  move our undo info to the old BF because its removal is tied with the
	//  flush of the relevant data
	//
	//  NOTE:  this must be done after linking in the versioned page so that it
	//  is always possible to reach an RCE containing undo info from the hash
	//  table

	if ( pbf->prceUndoInfoNext != prceNil )
		{
		CCriticalSection* const pcrit		= &critpoolBFDUI.Crit( pbf );
		CCriticalSection* const pcritOld	= &critpoolBFDUI.Crit( *ppbfOld );

		CCriticalSection* const pcritMax	= max( pcrit, pcritOld );
		CCriticalSection* const pcritMin	= min( pcrit, pcritOld );

		ENTERCRITICALSECTION ecsMax( pcritMax );
		ENTERCRITICALSECTION ecsMin( pcritMin, pcritMin != pcritMax );

		(*ppbfOld)->prceUndoInfoNext	= pbf->prceUndoInfoNext;
		pbf->prceUndoInfoNext			= prceNil;
		}

	//  keep versioned page stats

	cBFPagesVersioned.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
	AtomicIncrement( (long*)&cBFVersioned );

	//  update our page write stats
	//
	//  NOTE:  page versioning is a "virtual" flush

	if ( !pbf->fFlushed )
		{
		pbf->fFlushed = fTrue;
		}

	return JET_errSuccess;

HandleError:
	*ppbfOld = pbfNil;
	return err;
	}

ERR ErrBFIPrereadPage( IFMP ifmp, PGNO pgno )
	{
	ERR				err		= errBFPageCached;
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;

	//  look up this IFMP / PGNO in the hash table

	bfhash.ReadLockKey( IFMPPGNO( ifmp, pgno ), &lock );
	errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );
	bfhash.ReadUnlockKey( &lock );

	//  the IFMP / PGNO was not present in the hash table

	if ( errHash != BFHash::errSuccess )
		{
		//  try to add this page to the cache

		PBF pbf;
		err = ErrBFICachePage( &pbf, ifmp, pgno, fTrue, fFalse );

		//  the page was added to the cache

		if ( err == JET_errSuccess )
			{
			//  schedule the read of the page image from disk.  further preread
			//  manipulation of the BF will be done in BFIAsyncReadComplete()

			BFIAsyncRead( pbf );

			cBFUncachedPagesPreread.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
			}
		}

	cBFPagesPreread.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
	return err;
	}

INLINE ERR ErrBFIValidatePage( const PBF pbf, const BFLatchType bflt )
	{
	//  we should only see bfltShared, bfltExclusive, and bfltWrite

	Assert( bflt == bfltShared || bflt == bfltExclusive || bflt == bfltWrite );

	//  if this page is not in an error state then return its current error code

	ERR errBF;
	if ( ( errBF = pbf->err ) >= JET_errSuccess )
		{
		return errBF;
		}

	//  perform slow validation on this page

	return ErrBFIValidatePageSlowly( pbf, bflt );
	}

INLINE BOOL FBFIDatabasePage( const PBF pbf )
	{
	//	determines if the page contains
	//	unstructured data

	//	UNDONE: only sort pages actually need to be
	//	excluded, but we currently can't differentiate
	//	between sort pages and temp. table pages, so
	//	we need to exclude the temp. database
	//	altogether

	return ( !( pbf->ifmp & ifmpSLV )
			&& dbidTemp != rgfmp[ pbf->ifmp ].Dbid() );
	}

ERR ErrBFIValidatePageSlowly( PBF pbf, const BFLatchType bflt )
	{
	ERR err;

	//  if this page has already been verified then get the result from the page

	ERR errBF;
	if ( ( errBF = pbf->err ) != errBFIPageNotVerified )
		{
		err = (	pbf->bfdf == bfdfClean || errBF >= JET_errSuccess ?
					errBF :
					JET_errSuccess );
		}
	
	//  we already have or can upgrade to the exclusive latch
	
	else if (	bflt != bfltShared ||
				pbf->sxwl.ErrUpgradeSharedLatchToExclusiveLatch() == CSXWLatch::errSuccess )
		{
		//  if the page has still not been verified then verify the page and
		//  save the result

		if ( pbf->err == errBFIPageNotVerified )
			{
			//  perform page verification
			
			ERR errT = ErrBFIVerifyPage( pbf );
			pbf->err = SHORT( errT );
			Assert( pbf->err == errT );

			//  if there was no error while verifying the page and we can rule
			//  out the existence of any active versions by its dbtime then go
			//  ahead and reset all versioned state on the page
			//
			//	must exclude pages with unstructured data
			//
			//  NOTE:  these updates are being done as if under a WAR Latch

			if ( errT >= JET_errSuccess
				&& FBFIDatabasePage( pbf ) )
				{
				CPAGE	cpage;
				cpage.LoadPage( pbf->pvRWImage );

				if ( cpage.Dbtime() < rgfmp[ pbf->ifmp ].DbtimeOldestGuaranteed() )
					{
					NDResetVersionInfo( &cpage );
					}

				cpage.UnloadPage();
				}

			//  if there was an error while verifying the page and we are not
			//  in repair and we are not in the redo phase of recovery then log
			//  the error

			if (	errT < JET_errSuccess &&
					!fGlobalRepair &&
					(	PinstFromIfmp( pbf->ifmp & ifmpMask )->m_plog->m_fLogDisabled ||
						PinstFromIfmp( pbf->ifmp & ifmpMask )->m_plog->m_fRecoveringMode != fRecoveringRedo ) )
				{
				IFileAPI*		pfapi		= (	( pbf->ifmp & ifmpSLV ) ?
													rgfmp[ pbf->ifmp & ifmpMask ].PfapiSLV() :
													rgfmp[ pbf->ifmp ].Pfapi() );
				const _TCHAR*	rgpsz[ 6 ];
				DWORD			irgpsz		= 0;
				_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
				_TCHAR			szOffset[ 64 ];
				_TCHAR			szLength[ 64 ];
				_TCHAR			szError[ 64 ];

				CallS( pfapi->ErrPath( szAbsPath ) );
				_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), OffsetOfPgno( pbf->pgno ), OffsetOfPgno( pbf->pgno ) );
				_stprintf( szLength, _T( "%u (0x%08x)" ), g_cbPage, g_cbPage );
				_stprintf( szError, _T( "%i (0x%08x)" ), errT, errT );
		
				rgpsz[ irgpsz++ ]	= szAbsPath;
				rgpsz[ irgpsz++ ]	= szOffset;
				rgpsz[ irgpsz++ ]	= szLength;
				rgpsz[ irgpsz++ ]	= szError;

				if ( errT == JET_errReadVerifyFailure )
					{
					CPAGE cpage;
					cpage.LoadPage( pbf->pvROImage );

					const ULONG	ulChecksumExpected	= *( (LittleEndian<DWORD>*) ( pbf->pvROImage ) );
					const ULONG	ulChecksumActual	= UlUtilChecksum( (const BYTE*) pbf->pvROImage, g_cbPage );
					const PGNO	pgnoExpected		= pbf->pgno;
					const PGNO	pgnoActual			= cpage.Pgno();

					cpage.UnloadPage();
					
					if ( ulChecksumExpected != ulChecksumActual )
						{
						_TCHAR	szChecksumExpected[ 64 ];
						_TCHAR	szChecksumActual[ 64 ];

						_stprintf( szChecksumExpected, _T( "%u (0x%08x)" ), ulChecksumExpected, ulChecksumExpected );
						_stprintf( szChecksumActual, _T( "%u (0x%08x)" ), ulChecksumActual, ulChecksumActual );
				
						rgpsz[ irgpsz++ ]	= szChecksumExpected;
						rgpsz[ irgpsz++ ]	= szChecksumActual;

						UtilReportEvent(	eventError,
											BUFFER_MANAGER_CATEGORY,
											DATABASE_PAGE_CHECKSUM_MISMATCH_ID,
											irgpsz,
											rgpsz );
						}
					else if ( pgnoExpected != pgnoActual )
						{
						_TCHAR	szPgnoExpected[ 64 ];
						_TCHAR	szPgnoActual[ 64 ];

						_stprintf( szPgnoExpected, _T( "%u (0x%08x)" ), pgnoExpected, pgnoExpected );
						_stprintf( szPgnoActual, _T( "%u (0x%08x)" ), pgnoActual, pgnoActual );
				
						rgpsz[ irgpsz++ ]	= szPgnoExpected;
						rgpsz[ irgpsz++ ]	= szPgnoActual;

						UtilReportEvent(	eventError,
											BUFFER_MANAGER_CATEGORY,
											DATABASE_PAGE_NUMBER_MISMATCH_ID,
											irgpsz,
											rgpsz );
						}
					}
				else if ( errT == JET_errPageNotInitialized )
					{
					UtilReportEvent(	eventError,
										BUFFER_MANAGER_CATEGORY,
										DATABASE_PAGE_DATA_MISSING_ID,
										irgpsz,
										rgpsz );
					}
				}
			}

		//  get the error for this page
		
		err = (	pbf->bfdf == bfdfClean || pbf->err >= JET_errSuccess ?
					pbf->err :
					JET_errSuccess );

		//  release the exclusive latch if acquired

		if ( bflt == bfltShared )
			{
			pbf->sxwl.DowngradeExclusiveLatchToSharedLatch();
			}
		}

	//  we do not have exclusive access to the page
	
	else
		{
		//  verify the page without saving the results.  we do this so that
		//  we can validate the page without blocking if someone else is
		//  currently verifying the page
		
		err = ErrBFIVerifyPage( pbf );

		//  if there is an error in the page then check the status of the page
		//  again.  there are two possibilities:  the page is really bad or the
		//  page was modified by someone with a WAR Latch
		//
		//  if the page is really bad then it will either be flagged as not
		//  verified or it will be clean and flagged with the verification
		//  error.  if it is still not verified then we should use our own
		//  result.  if it has been verified then we will use the actual result
		//
		//  if the page was modified by someone with a WAR Latch then we know
		//  that it was verified at one time so we should just go ahead and
		//  use the result of that validation
		
		if ( err < JET_errSuccess )
			{
			ERR errBF;
			if ( ( errBF = pbf->err ) != errBFIPageNotVerified )
				{
				err = (	pbf->bfdf == bfdfClean || errBF >= JET_errSuccess ?
							errBF :
							JET_errSuccess );
				}
			}
		}

	//  return the result

	return err;
	}

ERR ErrBFIVerifyPage( PBF pbf )
	{
	//  the page contains unstructured data

	if ( !FBFIDatabasePage( pbf ) )
		{
		//  the page is verified
		
		return JET_errSuccess;
		}

	//  compute this page's checksum and pgno

	CPAGE cpage;
	cpage.LoadPage( pbf->pvROImage );

	const ULONG	ulChecksumExpected	= *( (LittleEndian<DWORD>*) ( pbf->pvROImage ) );
	const ULONG	ulChecksumActual	= UlUtilChecksum( (const BYTE*) pbf->pvROImage, g_cbPage );
	const PGNO	pgnoExpected		= pbf->pgno;
	const PGNO	pgnoActual			= cpage.Pgno();

	cpage.UnloadPage();

	//  the pgno of the page is pgnoNull

	if ( pgnoActual == pgnoNull )
		{
		//  the page is uninitialized

		return ErrERRCheck( JET_errPageNotInitialized );
		}

	//  the checksum matches and the pgno matches

	if ( ulChecksumActual == ulChecksumExpected && pgnoActual == pgnoExpected )
		{
		//  the page is verified

		return JET_errSuccess;
		}

	//  the checksum doesn't match

	else
		{
		//  the page has a verification failure

		return ErrERRCheck( JET_errReadVerifyFailure );
		}
	}

INLINE ERR ErrBFILatchPage(	BFLatch* const		pbfl,
							const IFMP			ifmp,
							const PGNO			pgno,
							const BFLatchFlags	bflf,
							const BFLatchType	bflt )
	{
	//  we should only see bfltShared, bfltExclusive, and bfltWrite

	Assert( bflt == bfltShared || bflt == bfltExclusive || bflt == bfltWrite );
	
	//  we should never see bflfNoFail with bflfNew

	Assert( !( bflf & bflfNoFail ) || !( bflf & bflfNew ) );
	
	//  we should never see bflfNew without bfltExclusive or bfltWrite

	Assert( !( bflf & bflfNew ) || bflt == bfltExclusive || bflt == bfltWrite );

	//  the latch flag criteria are met for a possible fast latch using a user
	//  provided hint

	const BFLatchFlags bflfMask		= BFLatchFlags(	bflfNoCached |
													bflfNew |
													bflfHint );
	const BFLatchFlags bflfPattern	= BFLatchFlags( bflfHint );

	if ( ( bflf & bflfMask ) == bflfPattern )
		{
		return ErrBFILatchPageTryHint( pbfl, ifmp, pgno, bflf, bflt );
		}

	//  latch the page slowly

	else
		{
		return ErrBFILatchPageNoHint( pbfl, ifmp, pgno, bflf, bflt );
		}
	}

ERR ErrBFILatchPageTryHint(	BFLatch* const		pbfl,
							const IFMP			ifmp,
							const PGNO			pgno,
							const BFLatchFlags	bflf,
							const BFLatchType	bflt )
	{
	//  fetch the PBF from the BFLatch.  we assume that this PBF was valid
	//  at one time

	const PBF pbfHint = PBF( pbfl->dwContext );
	Assert( FBFICacheValidPbf( pbfHint ) );

	//  try to latch the page as if bflfNoWait were specified.  we must do
	//  this to be compatible with the locking scheme in ErrBFIEvictPage()
	//
	//  NOTE:  we must disable ownership tracking here because we may
	//  accidentally try to latch a page we already have latched causing
	//  an assert.  the assert would be invalid because we will later
	//  find out that we shouldn't have the latch anyway and release it

	CSXWLatch::ERR errSXWL;

	CLockDeadlockDetectionInfo::DisableOwnershipTracking();
	switch ( bflt )
		{
		case bfltShared:
			errSXWL = pbfHint->sxwl.ErrTryAcquireSharedLatch();
			break;
			
		case bfltExclusive:
			errSXWL = pbfHint->sxwl.ErrTryAcquireExclusiveLatch();
			break;
			
		case bfltWrite:
			errSXWL = pbfHint->sxwl.ErrTryAcquireWriteLatch();
			break;
		}
	CLockDeadlockDetectionInfo::EnableOwnershipTracking();

	//  we successfully latched this BF

	if ( errSXWL == CSXWLatch::errSuccess )
		{
		//  this BF contains the current version of this IFMP / PGNO and it
		//  is not in an error state

		ERR errBF;
		if (	pbfHint->ifmp == ifmp &&
				pbfHint->pgno == pgno &&
				pbfHint->fCurrentVersion &&
				( errBF = pbfHint->err ) >= JET_errSuccess )
			{
			//  transfer ownership of the latch to the current context.  we
			//  must do this to properly set up deadlock detection for this
			//  latch

			pbfHint->sxwl.ClaimOwnership( bflt );

			//  touch this page if requested

			if ( !( bflf & bflfNoTouch ) )
				{
				bflruk.TouchResource( pbfHint );
				}

			//  return the page

			cBFCacheReq++;

			pbfl->pv = bflt == bfltWrite ? pbfHint->pvRWImage : pbfHint->pvROImage;
			Assert( pbfl->dwContext == DWORD_PTR( pbfHint ) );

			return errBF;
			}

		//  release our latch and fall through to the slow latch path
		
		CLockDeadlockDetectionInfo::DisableOwnershipTracking();
		switch ( bflt )
			{
			case bfltShared:
				pbfHint->sxwl.ReleaseSharedLatch();
				break;
				
			case bfltExclusive:
				pbfHint->sxwl.ReleaseExclusiveLatch();
				break;
				
			case bfltWrite:
				pbfHint->sxwl.ReleaseWriteLatch();
				break;
			}
		CLockDeadlockDetectionInfo::EnableOwnershipTracking();
		}

	//  latch the page slowly

	return ErrBFILatchPageNoHint( pbfl, ifmp, pgno, bflf, bflt );
	}

ERR ErrBFILatchPageNoHint(	BFLatch* const		pbfl,
							const IFMP			ifmp,
							const PGNO			pgno,
							const BFLatchFlags	bflf,
							const BFLatchType	bflt )
	{
	ERR				err			= JET_errSuccess;
	BFLatchFlags	bflfT		= bflf;
	BOOL			fCacheMiss	= fFalse;
	IFMPPGNO		ifmppgno	= IFMPPGNO( ifmp, pgno );
	PGNOPBF			pgnopbf;
	BFHash::ERR		errHash;
	BFHash::CLock	lock;
	CSXWLatch::ERR	errSXWL;

	//  try forever until we read latch the page or fail with an error

	forever
		{
		//  look up this IFMP / PGNO in the hash table

		bfhash.ReadLockKey( ifmppgno, &lock );
		errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );

		//  we found the IFMP / PGNO and we are latching uncached pages or the
		//  found BF is not currently undergoing I/O

		if (	errHash == BFHash::errSuccess &&
				( !( bflfT & bflfNoUncached ) || pgnopbf.pbf->err != errBFIPageFaultPending ) )
			{
			//  if we are not latching cached pages, bail

			if ( bflfT & bflfNoCached )
				{
				bfhash.ReadUnlockKey( &lock );
				return ErrERRCheck( errBFPageCached );
				}

			//  this is a cache miss if the found BF is currently undergoing I/O

			fCacheMiss = fCacheMiss || pgnopbf.pbf->err == errBFIPageFaultPending;
			
			//  latch the page

			switch ( bflt )
				{
				case bfltShared:
					if ( bflfT & bflfNoWait )
						{
						errSXWL = pgnopbf.pbf->sxwl.ErrTryAcquireSharedLatch();
						}
					else
						{
						errSXWL = pgnopbf.pbf->sxwl.ErrAcquireSharedLatch();
						}
					break;
					
				case bfltExclusive:
					if ( bflfT & bflfNoWait )
						{
						errSXWL = pgnopbf.pbf->sxwl.ErrTryAcquireExclusiveLatch();
						}
					else
						{
						errSXWL = pgnopbf.pbf->sxwl.ErrAcquireExclusiveLatch();
						}
					break;
					
				case bfltWrite:
					if ( bflfT & bflfNoWait )
						{
						errSXWL = pgnopbf.pbf->sxwl.ErrTryAcquireWriteLatch();
						}
					else
						{
						errSXWL = pgnopbf.pbf->sxwl.ErrAcquireExclusiveLatch();
						}
					break;
					
				}

			//  release our lock on the hash table

			bfhash.ReadUnlockKey( &lock );

			//  if this was a latch conflict, bail

			if ( errSXWL == CSXWLatch::errLatchConflict )
				{
				cBFLatchConflict++;
				return ErrERRCheck( errBFLatchConflict );
				}

			//  wait for ownership of the latch if required

			else if ( errSXWL == CSXWLatch::errWaitForSharedLatch )
				{
				cBFLatchStall++;
				pgnopbf.pbf->sxwl.WaitForSharedLatch();
				}

			else if ( errSXWL == CSXWLatch::errWaitForExclusiveLatch )
				{
				cBFLatchStall++;
				pgnopbf.pbf->sxwl.WaitForExclusiveLatch();
				}

			if (	bflt == bfltWrite &&
					!( bflfT & bflfNoWait ) &&
					pgnopbf.pbf->sxwl.ErrUpgradeExclusiveLatchToWriteLatch() == CSXWLatch::errWaitForWriteLatch )
				{
				cBFLatchStall++;
				pgnopbf.pbf->sxwl.WaitForWriteLatch();
				}

			//  we are latching a new page

			if ( bflfT & bflfNew )
				{
				//  clear the error state of this BF

				pgnopbf.pbf->err = JET_errSuccess;

				//  the page is valid

				err = JET_errSuccess;
				}

			//  we are not latching a new page

			else
				{
				//  if this page was preread and we are touching it for the first
				//  time after the preread, do not touch it again even if asked

				if ( pgnopbf.pbf->err == errBFIPageNotVerified )
					{
					bflfT = BFLatchFlags( bflfT | bflfNoTouch );
					}
				
				//  validate the page

				err = ErrBFIValidatePage( pgnopbf.pbf, bflt );

				//  the page is in an error state and we should fail on an error

				if ( err < JET_errSuccess && !( bflfT & bflfNoFail ) )
					{
					//  release our latch and return the error

					switch ( bflt )
						{
						case bfltShared:
							pgnopbf.pbf->sxwl.ReleaseSharedLatch();
							break;

						case bfltExclusive:
							pgnopbf.pbf->sxwl.ReleaseExclusiveLatch();
							break;

						case bfltWrite:
							pgnopbf.pbf->sxwl.ReleaseWriteLatch();
							break;
						}

					return err;
					}
				}

			//  the user requested that we touch this page

			if ( !( bflfT & bflfNoTouch ) )
				{
				//  touch the page
				
				bflruk.TouchResource( pgnopbf.pbf );
				}

			//  return the page

			break;
			}

		//  we did not find the IFMP / PGNO or we are not latching uncached pages
		//  and the found BF is currently undergoing I/O

		else
			{
			//  release our lock on the hash table

			bfhash.ReadUnlockKey( &lock );

			//  if we are not latching uncached pages, bail

			if ( bflfT & bflfNoUncached )
				{
				return ErrERRCheck( errBFPageNotCached );
				}

			//  this is now officially a cache miss

			fCacheMiss = fTrue;

			//  try to add this page to the cache

			err = ErrBFICachePage( &pgnopbf.pbf, ifmp, pgno, !( bflfT & bflfNew ) );

			//  the page was added to the cache

			if ( err == JET_errSuccess )
				{
				//  transfer ownership of the latch to the current context.  we
				//  must do this to properly set up deadlock detection for this
				//  latch

				pgnopbf.pbf->sxwl.ClaimOwnership( bfltWrite );
				
				//  we are not latching a new page

				if ( !( bflfT & bflfNew ) )
					{
					//  read the page image from disk

					BFISyncRead( pgnopbf.pbf );

					//  validate the page

					err = ErrBFIValidatePage( pgnopbf.pbf, bfltWrite );
					
					//  the page is in an error state and we should fail on an error

					if ( err < JET_errSuccess && !( bflfT & bflfNoFail ) )
						{
						//  release our latch and return the error

						pgnopbf.pbf->sxwl.ReleaseWriteLatch();
						return err;
						}
					}

				//  downgrade our write latch to the requested latch

				switch ( bflt )
					{
					case bfltShared:
						pgnopbf.pbf->sxwl.DowngradeWriteLatchToSharedLatch();
						break;

					case bfltExclusive:
						pgnopbf.pbf->sxwl.DowngradeWriteLatchToExclusiveLatch();
						break;

					case bfltWrite:
						break;
					}

				//  return the page

				break;
				}

			//  the page was already in the cache

			else if ( err == errBFPageCached )
				{
				//  try to latch the page again

				continue;
				}

			//  the page could not be added to the cache

			else
				{
				Assert(	err == JET_errOutOfMemory ||
						err == JET_errOutOfBuffers );

				//  fail with out of memory

				return err;
				}
			}
		}

	//  return the page

	if ( fCacheMiss )
		{
		cBFCacheMiss++;
		}
	cBFSlowLatch++;
	if ( bflf & bflfHint )
		{
		cBFBadLatchHint++;
		}
	cBFCacheReq++;

	pbfl->pv		= (	bflt == bfltWrite ?
							pgnopbf.pbf->pvRWImage :
							pgnopbf.pbf->pvROImage );
	pbfl->dwContext	= DWORD_PTR( pgnopbf.pbf );

	return	(	err != JET_errSuccess ?
					err :
					(	fCacheMiss ?
							ErrERRCheck( wrnBFPageFault ) :
							JET_errSuccess ) );
	}


#ifdef ELIMINATE_PAGE_PATCHING

INLINE BOOL FBFIPatchWouldBeRequired( PBF pbf )
	{
	FMP * const		pfmp			= rgfmp + pbf->ifmp;
	BOOL			fPatchRequired	= fFalse;

	//	"Patching" is required during backup only under very
	//	specific circumstances:
	//		1)	This page is the "flush first" page of a
	//			dependency.
	//		2)	This page has either already been copied to the
	//			backup set or will not be copied to the backup
	//			set (because it's beyond the pre-established
	//			backup end-point.
	//		3)	At least one of the "flush second" pages of the
	//			existing dependencies on this page has not yet
	//			been copied to the backup set, but will.
	//	In all other circumstances, patching is not required
	//	because we can reconstruct the "flush second" page
	//	from either the log files in the backup set or from
	//	the "flush first" page in the backup set.


	Assert( pfmp->CritLatch().FOwner() );
	Assert( pfmp->PgnoMost() > 0 );

	if ( !FBFIPageWillBeCopiedToBackup( pfmp, pbf->pgno ) )
		{
		critBFDepend.Enter();
		for ( PBF pbfDependentT = pbf->pbfDependent;
			NULL != pbfDependentT;
			pbfDependentT = pbfDependentT->pbfDependent )
			{
			if ( FBFIPageWillBeCopiedToBackup( pfmp, pbfDependentT->pgno ) )
				{
				fPatchRequired = fTrue;
				break;
				}
			}
		critBFDepend.Leave();
		}

	return fPatchRequired;
	}

#endif	//	ELIMINATE_PAGE_PATCHING


ERR ErrBFIPrepareFlushPage( PBF pbf, const BOOL fRemoveDependencies )
	{
	ERR err = JET_errSuccess;

	//  check the error state of this BF.  if the BF is already in an error
	//  state, fail immediately
	//
	//  NOTE:  this check makes I/O errors "permanent" such that if we ever fail
	//  when trying to flush a BF then we will never try again.  we may want to
	//  change this behavior in the future.  if so then we need to remove this
	//  check and make sure that anyone who removes this error code has the W
	//  Latch to avoid interactions with ErrBFIValidatePage

	Call( pbf->err );

	//  if this BF had a flush order dependency on another BF and that BF was
	//  purged then it is unflushable

	if ( pbf->fDependentPurged )
		{
		Call( ErrERRCheck( errBFIDependentPurged ) );
		}

	//  remove all flush order dependencies from this BF

	while ( pbf->pbfTimeDepChainNext != pbfNil || pbf->FDependent() )
		{
		//  find a leaf of our branch in the dependency tree

		critBFDepend.Enter();

		PBF pbfT = pbf;
		while ( pbfT->pbfTimeDepChainNext != pbfNil || pbfT->FDependent() )
			{
			while ( pbfT->pbfTimeDepChainNext != pbfNil )
				{
				pbfT = pbfT->pbfTimeDepChainNext;
				Assert( pbfT->ifmp == pbf->ifmp );	//	no cross-database dependencies allowed
				}

			while ( pbfT->FDependent() )
				{
				pbfT = pbfT->pbfDepChainHeadNext;
				Assert( pbfT->ifmp == pbf->ifmp );	//	no cross-database dependencies allowed
				}
			}
		
		critBFDepend.Leave();

		//  possibly async flush this BF
		//
		//  NOTE:  it is possible that someone else already flushed this
		//  page.  this is because the BF will be in the dependency tree
		//  until after the write completes.  if this happens, we will
		//  get JET_errSuccess and retry the entire operation
		//
		//  NOTE:  this call will result in at least one level of recursion.
		//  usually, we will only recurse once because we are trying to flush
		//  dependency chain heads.  it is possible that another thread could
		//  write latch the page, add a dependency, and release the write
		//  latch between the time we leave the critical section protecting
		//  the dependency tree and try to get the exclusive latch on the
		//  page.  this would cause us to recurse another level.  because we
		//  can recurse far faster than any other thread should be able to
		//  do the above, the probability of deep recursion should be remote.
		//  if we do happen to catch someone doing this, we will stop
		//  recursing with errBFLatchConflict because we will not be able
		//  to exclusively latch the page to flush it
		//
		//  NOTE:  we must disable ownership tracking because it is possible
		//  that we will try to latch a page that we already have latched
		//  while trying to flush the dependency chain.  yes, this is tragic.
		//  the only reason it works is because we try-acquire the exclusive
		//  latch instead of acquiring it and this will work even if we
		//  already have the shared latch

		if (	!fRemoveDependencies &&
				( pbf->pgno != pbfT->pgno || pbf->ifmp != pbfT->ifmp ) )
			{
			Call( ErrERRCheck( errBFIRemainingDependencies ) );
			}

		CLockDeadlockDetectionInfo::DisableOwnershipTracking();
		err = ErrBFIFlushPage( pbfT, bfdfDirty, !fRemoveDependencies );
		CLockDeadlockDetectionInfo::EnableOwnershipTracking();
		Call( err );
		}

	//  log and remove all undo info from the BF

	if ( pbf->prceUndoInfoNext != prceNil )
		{
		if ( !fRemoveDependencies )
			{
			Call( ErrERRCheck( errBFIRemainingDependencies ) );
			}
		
		ENTERCRITICALSECTION ecs( &critpoolBFDUI.Crit( pbf ) );
		
		while ( pbf->prceUndoInfoNext != prceNil )
			{
			//  try to log the current undo info, but do not wait if the log buffer
			//  is full

			LGPOS lgpos;
			err = ErrLGUndoInfoWithoutRetry( pbf->prceUndoInfoNext, &lgpos );

			//  we succeeded logging the undo info

			if ( err >= JET_errSuccess )
				{
				//  remove this undo info from the BF

				BFIRemoveUndoInfo( pbf, pbf->prceUndoInfoNext, lgpos );
				}

			//  we failed logging the undo info
			
			else
				{
				//  we failed because the log is down

				if (	err == JET_errLogWriteFail ||
						err == JET_errLogDisabledDueToRecoveryFailure )
					{
					//  fail with this error

					Call( err );
					}

				//  we failed because we cannot log undo info during redo

				else if ( err == JET_errCannotLogDuringRecoveryRedo )
					{
					//  we must wait for this dependency to be removed via
					//  BFRemoveUndoInfo()
					//
					//  NOTE:  act as if this was a latch conflict so that the
					//  allocation quota system views it as an external buffer
					//  allocation (which it is...  sort of)

					Call( ErrERRCheck( errBFLatchConflict ) );
					}

				//  we failed because the log buffers are full

				else
					{
					Assert( err == errLGNotSynchronous );

					//  flush the log

					PinstFromIfmp( pbf->ifmp & ifmpMask )->m_plog->LGSignalFlush();

					//  we must wait to remove this dependency

					Call( ErrERRCheck( errBFIRemainingDependencies ) );
					}
				}
			}
		}

	//  this BF is depended on the log

	LOG*	plog;
	int		icmp;
	plog	= PinstFromIfmp( pbf->ifmp & ifmpMask )->m_plog;
	plog->m_critLGBuf.Enter();
	icmp	= CmpLgpos( &pbf->lgposModify, &plog->m_lgposToFlush );
	plog->m_critLGBuf.Leave();

	if (	!plog->m_fLogDisabled &&
			plog->m_fRecoveringMode != fRecoveringRedo &&
			icmp >= 0 )
		{
		if ( !fRemoveDependencies )
			{
			Call( ErrERRCheck( errBFIRemainingDependencies ) );
			}
		
		//  the log is down

		if ( plog->m_fLGNoMoreLogWrite )
			{
			//  fail with this error

			Call( ErrERRCheck( JET_errLogWriteFail ) );
			}

		//  the log is up

		else
			{
			//  flush the log

			plog->LGSignalFlush();

			//  we must wait to remove this dependency

			Call( ErrERRCheck( errBFIRemainingDependencies ) );
			}
		}

	//  check the range lock (backup dependency)

	if ( !( pbf->ifmp & ifmpSLV ) )
		{
		//  get the active range lock

		FMP* const	pfmp		= &rgfmp[ pbf->ifmp ];
		const int	irangelock	= pfmp->EnterRangeLock();
		BOOL		fFlushable	= !pfmp->FRangeLocked( irangelock, pbf->pgno );

#ifdef ELIMINATE_PAGE_PATCHING
		//  this page is not range locked, check if dependencies during
		//	backup preclude flushing

		if ( fFlushable && 0 != pfmp->PgnoMost() )	//	non-zero pgnoMost implies backup in progress
			{
			pfmp->CritLatch().Enter();
			fFlushable	= ( 0 == pfmp->PgnoMost()	//	double-check pgnoMost now that we're in critLatch
							|| !FBFIPatchWouldBeRequired( pbf ) );
			pfmp->CritLatch().Leave();
			}
#endif

		//	this page is not range-locked, and there are no dependencies
		//	that would preclude flushing it during backup

		if ( fFlushable )
			{
			//  leave our reference on this range lock until this BF has
			//  been flushed or we decide to not flush this BF

			pbf->irangelock = BYTE( irangelock );
			Assert( pbf->irangelock == irangelock );
			}
		else
			{
			//  release our reference on this range lock

			pfmp->LeaveRangeLock( irangelock );

			//  there is a dependency on this BF that we must wait to remove

			Call( ErrERRCheck( errBFIRemainingDependencies ) );
			}
		}

HandleError:

	//  we cannot remove all dependencies on this BF due to a fatal error

	if (	err < JET_errSuccess &&
			err != errBFIRemainingDependencies &&
			err != errBFIPageFlushed &&
			err != errBFIPageFlushPending &&
			err != errBFLatchConflict )
		{
		//  set this BF to the appropriate error state
		
		pbf->err = SHORT( err );
		Assert( pbf->err == err );
		}

	//  return the result of the remove dependencies operation

	return err;
	}

ERR ErrBFIFlushPage( PBF pbf, const BFDirtyFlags bfdfFlushMin, const BOOL fOpportune )
	{
	ERR err = JET_errSuccess;

	//  we can exclusively latch this BF

	CSXWLatch::ERR errSXWL = pbf->sxwl.ErrTryAcquireExclusiveLatch();

	if ( errSXWL == CSXWLatch::errSuccess )
		{
		//  this BF is too clean to flush

		if ( pbf->bfdf < max( bfdfFlushMin, bfdfUntidy ) )
			{
			//  release our latch and leave

			pbf->sxwl.ReleaseExclusiveLatch();
			}

		//  this BF is dirty enough to flush

		else
			{
			//  try to remove all dependencies on this BF.  if there is an
			//  issue, release our latch and fail with the error

			if ( ( err = ErrBFIPrepareFlushPage( pbf, !fOpportune ) ) < JET_errSuccess )
				{
				pbf->sxwl.ReleaseExclusiveLatch();
				Call( err );
				}

			//  schedule this page for async write

			const IFMP	ifmp	= pbf->ifmp;
			const PGNO	pgno	= pbf->pgno;

			pbf->sxwl.ReleaseOwnership( bfltExclusive );
			BFIAsyncWrite( pbf );

			//  perform opportunistic flush of eligible neighboring pages
			//
			//  NOTE:  we must disable ownership tracking because it is possible
			//  that we will try to latch a page that we already have latched
			//  while trying to flush an eligible neighboring page.  *sigh!*
			//  the only reason it works is because we try-acquire the exclusive
			//  latch instead of acquiring it and this will work even if we
			//  already have the shared latch

			BOOL			fDidOpp;
			PGNO			pgnoOpp;
			PGNOPBF			pgnopbf;
			BFHash::ERR		errHash;
			BFHash::CLock	lock;

			fDidOpp = !fOpportune && fEnableOpportuneWrite;
			for ( pgnoOpp = pgno + 1; fDidOpp; pgnoOpp++ )
				{
				bfhash.ReadLockKey( IFMPPGNO( ifmp, pgnoOpp ), &lock );
				errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );
				bfhash.ReadUnlockKey( &lock );

				CLockDeadlockDetectionInfo::DisableOwnershipTracking();
				fDidOpp = (	errHash == BFHash::errSuccess &&
							FBFIOpportuneWrite( pgnopbf.pbf ) &&
							cBFPageFlushPending < cBFPageFlushPendingMax &&
							ErrBFIFlushPage( pgnopbf.pbf, bfdfUntidy, fTrue ) == errBFIPageFlushed );
				CLockDeadlockDetectionInfo::EnableOwnershipTracking();

				if ( fDidOpp )
					{
					cBFPagesOpportunelyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
					}
				}

			fDidOpp = !fOpportune && fEnableOpportuneWrite;
			for ( pgnoOpp = pgno - 1; fDidOpp; pgnoOpp-- )
				{
				bfhash.ReadLockKey( IFMPPGNO( ifmp, pgnoOpp ), &lock );
				errHash = bfhash.ErrRetrieveEntry( &lock, &pgnopbf );
				bfhash.ReadUnlockKey( &lock );

				CLockDeadlockDetectionInfo::DisableOwnershipTracking();
				fDidOpp = (	errHash == BFHash::errSuccess &&
							FBFIOpportuneWrite( pgnopbf.pbf ) &&
							cBFPageFlushPending < cBFPageFlushPendingMax &&
							ErrBFIFlushPage( pgnopbf.pbf, bfdfUntidy, fTrue ) == errBFIPageFlushed );
				CLockDeadlockDetectionInfo::EnableOwnershipTracking();

				if ( fDidOpp )
					{
					cBFPagesOpportunelyWritten.Inc( PinstFromIfmp( ifmp & ifmpMask ) );
					}
				}

			//  return an error indicating that the page was flushed

			Call( ErrERRCheck( errBFIPageFlushed ) );
			}
		}

	//  we can not exclusively latch this BF

	else
		{
		//  the page is currently being flushed

		if ( pbf->err == wrnBFPageFlushPending )
			{
			//  return flush in progress

			Call( ErrERRCheck( errBFIPageFlushPending ) );
			}

		//  the page is not currently being flushed

		else
			{
			//  return latch confict because we could not flush the page

			Call( ErrERRCheck( errBFLatchConflict ) );
			}
		}

HandleError:
	return err;
	}

ERR ErrBFIEvictPage( PBF pbf, BFLRUK::CLock* plockLRUK, BOOL fEvictDirty )
	{
	ERR err = JET_errSuccess;

	//  write lock this IFMP / PGNO in the hash table to prevent new
	//  latch attempts on this BF

	BFHash::CLock	lockHash;
	bfhash.WriteLockKey( IFMPPGNO( pbf->ifmp, pbf->pgno ), &lockHash );

	//  no one currently owns or is waiting to own the latch on this BF
	//  (we tell this by trying to acquire the Write Latch)

	CSXWLatch::ERR errSXWL = pbf->sxwl.ErrTryAcquireWriteLatch();

	if ( errSXWL == CSXWLatch::errSuccess )
		{
		//  this BF is clean / untidy or we are allowed to evict dirty BFs

		if ( pbf->bfdf < bfdfDirty || fEvictDirty )
			{
			//  we currently have this BF locked in the LRUK

			PBF pbfLocked;
			if ( bflruk.ErrGetCurrentResource( plockLRUK, &pbfLocked ) == BFLRUK::errSuccess )
				{
				//  determine if we will save the history for this BF.  we only
				//  want to save history for the current version of a page that
				//  was actually touched (i.e. validated) and is not being
				//  purged (inferred via fEvictDirty)

				const BOOL fSaveHistory =	!fEvictDirty &&
											pbf->fCurrentVersion &&
											pbf->err != errBFIPageNotVerified;
				
				//  remove this BF from the IFMP / PGNO hash table if it is the
				//  current version of the page

				if ( pbf->fCurrentVersion )
					{
					pbf->fCurrentVersion = fFalse;
					
					BFHash::ERR errHash = bfhash.ErrDeleteEntry( &lockHash );
					Assert( errHash == BFHash::errSuccess );
					}
				
				//  release our write lock on this IFMP / PGNO

				bfhash.WriteUnlockKey( &lockHash );

				//  remove this BF from the LRUK

				BFLRUK::ERR errLRUK = bflruk.ErrEvictCurrentResource( plockLRUK, IFMPPGNO( pbf->ifmp, pbf->pgno ), fSaveHistory );
				Assert( errLRUK == BFLRUK::errSuccess );

				//  force this BF to be clean, purging any dependencies

				BFICleanPage( pbf );

				//  make sure our lgposOldestBegin0 is reset

				BFIResetLgposOldestBegin0( pbf );

				//  update DBA statistics
				
				pbf->fNewlyEvicted = fTrue;
				
				//  free this BF to the avail pool

				pbf->sxwl.ReleaseOwnership( bfltWrite );
				BFIFreePage( pbf );
				}

			//  we currently do not have this BF locked in the LRUK

			else
				{
				//  release our write lock on this IFMP / PGNO

				bfhash.WriteUnlockKey( &lockHash );

				//  release our write latch on this BF

				pbf->sxwl.ReleaseWriteLatch();

				//  we can not evict this page

				Call( ErrERRCheck( errBFIPageNotEvicted ) );
				}
			}

		//  this BF is dirty / filthy and we are not allowed to evict dirty BFs

		else
			{
			//  release our write lock on this IFMP / PGNO

			bfhash.WriteUnlockKey( &lockHash );

			//  release our write latch on this BF

			pbf->sxwl.ReleaseWriteLatch();

			//  we can not evict this page

			Call( ErrERRCheck( errBFIPageNotEvicted ) );
			}
		}

	//  someone owns or is waiting to own a latch on this BF

	else
		{
		//  release our write lock on this IFMP / PGNO

		bfhash.WriteUnlockKey( &lockHash );

		//  we can not evict this page because of a latch conflict

		Call( ErrERRCheck( errBFLatchConflict ) );
		}

HandleError:
	return err;
	}

void BFIDirtyPage( PBF pbf, BFDirtyFlags bfdf )
	{
	//  the BF is clean

	if ( pbf->bfdf == bfdfClean )
		{
		//  reset the BF's lgposOldestBegin0

		BFIResetLgposOldestBegin0( pbf );

		//  reset the error state of the BF
		//
		//  NOTE:  this is to handle the case where we want to modify a page
		//  that was latched with bflfNoFail.  we want a chance to write our
		//  changes to the page

		pbf->err = JET_errSuccess;
		}
	
	//  make this BF dirtier
	
	if ( pbf->bfdf < bfdfDirty && bfdf >= bfdfDirty )
		{
		AtomicDecrement( (long*)&cBFClean );
		}
	
	pbf->bfdf = BYTE( max( pbf->bfdf, bfdf ) );
	Assert( pbf->bfdf == max( pbf->bfdf, bfdf ) );
	}

void BFICleanPage( PBF pbf )
	{
	//  remove every BF above us and ourself from the dependency tree, both in
	//  time and space (time dependencies and flush order dependencies)
	//
	//  NOTE:  we should not be dependent on anyone else if we were flushed.
	//  the generality of this code is aimed at handling the purging of BFs
	//  that are in an error state before crashing the system and forcing a
	//  recovery due to an I/O error on the database or log files

	if (	pbf->bfdf >= bfdfDirty &&
			(	pbf->FDependent() ||
				pbf->pbfDependent != pbfNil ||
				pbf->pbfTimeDepChainPrev != pbfNil ||
				pbf->pbfTimeDepChainNext != pbfNil ||
				pbf->fDependentPurged ) )
		{
		critBFDepend.Enter();

		while (	pbf->FDependent() ||
				pbf->pbfDependent != pbfNil ||
				pbf->pbfTimeDepChainPrev != pbfNil ||
				pbf->pbfTimeDepChainNext != pbfNil )
			{
			//  find a leaf of our branch in the dependency tree

			PBF pbfT = pbf;
			while ( pbfT->pbfTimeDepChainNext != pbfNil || pbfT->FDependent() )
				{
				while ( pbfT->pbfTimeDepChainNext != pbfNil )
					{
					pbfT = pbfT->pbfTimeDepChainNext;
					Assert( pbfT->ifmp == pbf->ifmp );	//	no cross-database dependencies allowed
					}

				while ( pbfT->FDependent() )
					{
					pbfT = pbfT->pbfDepChainHeadNext;
					Assert( pbfT->ifmp == pbf->ifmp );	//	no cross-database dependencies allowed
					}
				}

			//  if this BF is part of the dependency tree, remove it

			if ( pbfT->pbfDependent != pbfNil )
				{
				pbfT->pbfDependent->fDependentPurged = pbf->err != wrnBFPageFlushPending;
				BFIUndepend( pbfT, pbfT->pbfDependent );
				}

			//  if this BF is part of a time dependency list, remove it

			if ( pbfT->pbfTimeDepChainPrev != pbfNil )
				{
				pbfT->pbfTimeDepChainPrev->fDependentPurged		= pbf->err != wrnBFPageFlushPending;
				pbfT->pbfTimeDepChainPrev->pbfTimeDepChainNext	= pbfNil;
				pbfT->pbfTimeDepChainPrev						= pbfNil;
				}
			}

		if ( pbf->fOlderVersion )
			{
			pbf->fOlderVersion = fFalse;
			AtomicDecrement( (long*)&cBFVersioned );
			}
		pbf->fDependentPurged = fFalse;

		critBFDepend.Leave();
		}

	//  remove all undo info

	if ( pbf->prceUndoInfoNext != prceNil )
		{
		ENTERCRITICALSECTION ecs( &critpoolBFDUI.Crit( pbf ) );

		while ( pbf->prceUndoInfoNext != prceNil )
			{
			BFIRemoveUndoInfo( pbf, pbf->prceUndoInfoNext );
			}
		}

	//  reset our lgposModify

	BFIResetLgposModify( pbf );

	//  reset our I/O error status

	if ( pbf->err == errBFIPageNotVerified )
		{
		cBFPagesPrereadUntouched.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
		}

	pbf->err = JET_errSuccess;

	//  update our page write stats

	if ( pbf->fFlushed )
		{
		pbf->fFlushed = fFalse;
		}

	//  make this BF clean (do this after removing ourself from the dependency
	//  tree to avoid asserting)

	if ( pbf->bfdf >= bfdfDirty )
		{
		AtomicIncrement( (long*)&cBFClean );
		}
	pbf->bfdf = bfdfClean;
	}

	//  I/O

//  this function performs a Sync Read into the specified Write Latched BF

void BFISyncRead( PBF pbf )
	{
	//  prepare sync read

	BFISyncReadPrepare( pbf );

	//  issue sync read

	IFileAPI *const pfapi		=	( pbf->ifmp & ifmpSLV ) ?
										rgfmp[pbf->ifmp & ifmpMask].PfapiSLV() :
										rgfmp[pbf->ifmp].Pfapi();
	const QWORD		ibOffset	=	OffsetOfPgno( pbf->pgno );
	const DWORD		cbData		=	g_cbPage;
	BYTE* const		pbData		=	(BYTE*)pbf->pvRWImage;
	
	ERR err = pfapi->ErrIORead( ibOffset, cbData, pbData );

	//  complete sync read

	BFISyncReadComplete( err, pfapi, ibOffset, cbData, pbData, pbf );
	}

void BFISyncReadPrepare( PBF pbf )
	{
	//  declare I/O pending

	ERR errT = ErrERRCheck( errBFIPageFaultPending );
	pbf->err = SHORT( errT );
	Assert( pbf->err == errT );
	}

void BFISyncReadComplete(	const ERR 			err,
							IFileAPI* const		pfapi,
							const QWORD 		ibOffset,
							const DWORD 		cbData,
							const BYTE* const	pbData,
							const PBF 			pbf )
	{
	//  read was successful

	if ( err >= 0 )
		{
		//  declare I/O successful but page unverified

		ERR errT = ErrERRCheck( errBFIPageNotVerified );
		pbf->err = SHORT( errT );
		Assert( pbf->err == errT );
		}

	//  read was not successful

	else
		{
		//  declare the appropriate I/O error

		pbf->err = SHORT( err );
		Assert( pbf->err == err );
		}

	cBFPagesRead.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
	}

//  this function performs a Async Read into the specified Write Latched BF

void BFIAsyncRead( PBF pbf )
	{
	//  prepare async read

	BFIAsyncReadPrepare( pbf );

	//  issue async read

	IFileAPI * const pfapi = (	pbf->ifmp & ifmpSLV ) ?
									rgfmp[pbf->ifmp & ifmpMask].PfapiSLV() :
									rgfmp[pbf->ifmp].Pfapi();
								
	ERR err = pfapi->ErrIORead(	OffsetOfPgno( pbf->pgno ),
								g_cbPage,
								(BYTE*)pbf->pvRWImage,
								IFileAPI::PfnIOComplete( BFIAsyncReadComplete ),
								DWORD_PTR( pbf ) );
	}

void BFIAsyncReadPrepare( PBF pbf )
	{
	//  declare I/O pending

	ERR errT = ErrERRCheck( errBFIPageFaultPending );
	pbf->err = SHORT( errT );
	Assert( pbf->err == errT );
	}

void BFIAsyncReadComplete(	const ERR			err,
							IFileAPI* const		pfapi,
							const QWORD			ibOffset,
							const DWORD			cbData,
							const BYTE* const	pbData,
							const PBF			pbf )
	{
	//  read was successful

	if ( err >= 0 )
		{
		//  declare I/O successful but page unverified

		ERR errT = ErrERRCheck( errBFIPageNotVerified );
		pbf->err = SHORT( errT );
		Assert( pbf->err == errT );
		}

	//  read was not successful

	else
		{
		//  declare the appropriate I/O error

		pbf->err = SHORT( err );
		Assert( pbf->err == err );
		}

	cBFPagesRead.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
	
	//  release our Write Latch on this BF

	pbf->sxwl.ClaimOwnership( bfltWrite );
	pbf->sxwl.ReleaseWriteLatch();
	}

//  this function prepares and schedules a BF for Async Write

void BFIAsyncWrite( PBF pbf )
	{
	//  prepare async write

	BFIAsyncWritePrepare( pbf );

	//  issue async write

	IFileAPI * const pfapi = (	pbf->ifmp & ifmpSLV ) ?
									rgfmp[pbf->ifmp & ifmpMask].PfapiSLV() :
									rgfmp[pbf->ifmp].Pfapi();

	ERR err = pfapi->ErrIOWrite(	OffsetOfPgno( pbf->pgno ),
									g_cbPage,
									(BYTE*)pbf->pvROImage,
									IFileAPI::PfnIOComplete( BFIAsyncWriteComplete ),
									DWORD_PTR( pbf ) );
	}

void BFIAsyncWritePrepare( PBF pbf )
	{
	//  declare I/O pending

	ERR errT = ErrERRCheck( wrnBFPageFlushPending );
	pbf->err = SHORT( errT );
	Assert( pbf->err == errT );

	AtomicIncrement( (long*)&cBFPageFlushPending );

	//  the page does not contain unstructured data

	if ( FBFIDatabasePage( pbf ) )
		{
		//  compute and update page checksum

		*( (LittleEndian<DWORD>*) ( pbf->pvRWImage ) ) = UlUtilChecksum( (const BYTE*) pbf->pvRWImage, g_cbPage );
		}

	//  HACK:  set the flush flag here so that we close a race condition
	//  between flush and the clean thread

	if ( Ptls()->fCleanThread )
		{
		if ( pbf->ifmp & ifmpSLV )
			{
			rgfmp[pbf->ifmp & ifmpMask].SetBFICleanSLV();
			}
		else
			{
			rgfmp[pbf->ifmp].SetBFICleanDb();
			}
		}
	}

void BFIAsyncWriteComplete(	const ERR			err,
							IFileAPI* const		pfapi,
							const QWORD			ibOffset,
							const DWORD			cbData,
							const BYTE* const	pbData,
							const PBF			pbf )
	{
	//  write was successful

	if ( err >= 0 )
		{
		FMP *		pfmp	= rgfmp + ( pbf->ifmp & ifmpMask );

#ifdef ELIMINATE_PAGE_PATCHING
		const BOOL	fPatch	= fFalse;
#else		
		BOOL		fPatch	= ( pfapi == pfmp->Pfapi() );

		//  we need to re-issue this write to the patch file

		if ( fPatch )
			{
			pfmp->CritLatch().Enter();
			if ( FBFIPatch( pfmp, pbf ) )
				{
				Assert( !( pbf->ifmp & ifmpSLV ) );
				
				//  get next available offset in patch file
				
				QWORD ibOffset = OffsetOfPgno( pfmp->CpagePatch() + 1 );
				
				//  update patch file size and write count

				pfmp->IncCpagePatch( cbData / g_cbPage );
				pfmp->IncCPatchIO();
				pfmp->CritLatch().Leave();

				//  re-issue write to the patch file

				const ERR	errT	= pfmp->PfapiPatch()->ErrIOWrite(
																ibOffset,
																cbData,
																pbData,
																IFileAPI::PfnIOComplete( BFIAsyncWriteCompletePatch ),
																DWORD_PTR( pbf ) );

				CallS( pfmp->PfapiPatch()->ErrIOIssue() );
				}
			else
				{
				pfmp->CritLatch().Leave();
				fPatch = fFalse;
				}
			}

#endif	//	ELIMINATE_PAGE_PATCHING

		//  we do not need to re-issue this write to the patch file

		if ( !fPatch )
			{
			//  release our reference count on the range lock now that our write
			//  has completed

			if ( !( pbf->ifmp & ifmpSLV ) )
				{
				rgfmp[ pbf->ifmp ].LeaveRangeLock( pbf->irangelock );
				}

			//  reset BF to "cleaned" status

			const BOOL	fFlushed		= pbf->fFlushed;
			const BOOL	fOlderVersion	= pbf->fOlderVersion;

			BFICleanPage( pbf );

			//  update our page write stats

			if ( fFlushed )
				{
				cBFPagesRepeatedlyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
				}
			pbf->fFlushed = fTrue;
			if ( fOlderVersion )
				{
				cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
				}

			cBFPagesWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
			AtomicDecrement( (long*)&cBFPageFlushPending );

			//  release our exclusive latch on this BF

			pbf->sxwl.ClaimOwnership( bfltExclusive );
			pbf->sxwl.ReleaseExclusiveLatch();
			}
		}

	//  write was not successful

	else
		{
		//  release our reference count on the range lock now that our write
		//  has completed

		if ( !( pbf->ifmp & ifmpSLV ) )
			{
			rgfmp[ pbf->ifmp ].LeaveRangeLock( pbf->irangelock );
			}

		//  declare the appropriate I/O error

		pbf->err = SHORT( err );
		Assert( pbf->err == err );

		//  update our page write stats

		if ( pbf->fFlushed )
			{
			cBFPagesRepeatedlyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
			}
		else
			{
			pbf->fFlushed = fTrue;
			}
		if ( pbf->fOlderVersion )
			{
			cBFPagesAnomalouslyWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
			}

		cBFPagesWritten.Inc( PinstFromIfmp( pbf->ifmp & ifmpMask ) );
		AtomicDecrement( (long*)&cBFPageFlushPending );

		//  release our exclusive latch on this BF

		pbf->sxwl.ClaimOwnership( bfltExclusive );
		pbf->sxwl.ReleaseExclusiveLatch();
		}
	}

#ifdef ELIMINATE_PAGE_PATCHING
#else
void BFIAsyncWriteCompletePatch(	const ERR			err,
									IFileAPI* const		pfapi,
									const QWORD			ibOffset,
									const DWORD			cbData,
									const BYTE* const	pbData,
									const PBF			pbf )
	{
	Assert( !( pbf->ifmp & ifmpSLV ) );
			
	FMP* pfmp = rgfmp + pbf->ifmp;

	//  update patch file write count and error
	
	pfmp->CritLatch().Enter();
	pfmp->DecCPatchIO();
	if ( pfmp->ErrPatch() >= JET_errSuccess )
		{
		pfmp->SetErrPatch( err );
		}
	pfmp->CritLatch().Leave();

	//  complete the original write again.  we will not need to patch this page,
	//  so we will take the non-patch case this time

	BFIAsyncWriteComplete( err, pfapi, ibOffset, cbData, pbData, pbf );
	}
#endif	//	ELIMINATE_PAGE_PATCHING

//  returns fTrue if this BF is a good candidate for being opportunely written

INLINE BOOL FBFIOpportuneWrite( PBF pbf )
	{
	//  if this page has older versions then we should try and write it

	if ( pbf->pbfTimeDepChainNext != pbfNil )
		{
		return fTrue;
		}

	//  if this page is not a hot page then we should try and write it

	if ( !bflruk.FHotResource( pbf ) )
		{
		return fTrue;
		}

	//  if this page is impeding the checkpoint and it is not being modified
	//  too frequently then we should try and write it

	LOG* const	plog		= PinstFromIfmp( pbf->ifmp & ifmpMask )->m_plog;
	const LGPOS	lgposNewest	= (	plog->m_fRecoveringMode == fRecoveringRedo ?
									plog->m_lgposRedo :
									plog->m_lgposLogRec );

	if (	CmpLgpos( &pbf->lgposModify, &lgposMin ) &&
			CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) &&
			(	__int64( plog->CbOffsetLgpos( lgposNewest, pbf->lgposModify ) ) >
				__int64(	cbCleanCheckpointDepthMax -
							plog->CbOffsetLgpos( lgposNewest, pbf->lgposOldestBegin0 ) ) ) )
		{
		return fTrue;
		}

	//  otherwise, we should not try and write it

	return fFalse;
	}


	//  Patch File

#ifdef ELIMINATE_PAGE_PATCHING
#else
//  returns TRUE if the BF should be appended to the patch file.
//	*** NOTE *** The general rule to determine if a page should be
//	patched is as follows: "If the source page still needs to be
//	copied to the backup, but the destination page doesn't, then
//	the destination page must be patched".
INLINE BOOL FBFIPatch( FMP * pfmp, PBF pbf )
	{
	//  critical section

	Assert( pfmp->CritLatch().FOwner() );

	//	if page written successfully and one of the following two cases
	//
	//	case 1: new page in split is a reuse of old page. contents of
	//	        old page will be moved to new page, but new page is copied
	//			already, so we have to recopy the new page with new data
	//			again.
	//	1) this page must be written before another page, and
	//	2) backup in progress, and
	//	3) page number is less than last copied page number,
	//	then write page to patch file.
	//
	//	case 2: similar to above, but new page is greater than the database
	//	        that will be copied. So the new page will not be able to be
	//			copied. We need to patch it.
	//
	//	Note that if all dependent pages were also before copy
	//	page then write to patch file would not be necessary.

	//  backup is going on and there is no error

	BOOL	fPatch	= ( NULL != pfmp->PfapiPatch()
						&& pfmp->ErrPatch() >= JET_errSuccess
						&& !FBFIPageWillBeCopiedToBackup( pfmp, pbf->pgno ) );

	//	no need to check PgnoMost() because:
	//		- we are in pfmp->CritLatch(), so this value is guaranteed not to change
	//		- the FBFIPageWillBeCopiedToBackup() check on the old page will fail if
	//		  PgnoMost() is 0, meaning the new page will not get patched
	//	fPatch = fPatch && pfmp->PgnoMost() > 0;

	//	if the old page doesn't have to be copied, then this page doesn't
	//	have to be patched:
	//		case 1:	old page already copied, meaning it was flushed, but
	//				it has a dependency on this page, so this page must
	//				have been flushed as well
	//		case 2: old page is beyond end of db to be copied, so must
	//				have all the correct log records to replay all
	//				the operations
	//	if the old page has to be copied, then this page has to be patched
	//	if one of the following is true:
	//		case 1: new page number is less than the page number being copied
	//				while old page is not copied yet. If we flush new page,
	//				and later old page is flushed and copied, then the old
	//				contents of old page is on new page and not copied. So we
	//				have to patch the new page for backup.
	//		case 2:	new page is beyond the last page that will be copied and old
	//				page is not copied yet. If we flush the new page, old page, and
	//				copied the old page, then we lost the old contents of old page.
	//				patch the new page for backup.

	if ( fPatch )
		{
		fPatch = fFalse;

		//	check if any of its old page (depend list) will be copied for backup.

		critBFDepend.Enter();
		for ( PBF pbfDependentT = pbf->pbfDependent;
			NULL != pbfDependentT;
			pbfDependentT = pbfDependentT->pbfDependent )
			{
			//	check if old page wil be copied to backup
			if ( FBFIPageWillBeCopiedToBackup( pfmp, pbfDependentT->pgno ) )
				{
				fPatch = fTrue;
				break;
				}

			}
		critBFDepend.Leave();
		}

	return fPatch;
	}

#endif	//	ELIMINATE_PAGE_PATCHING


	//  Dependencies

//  critical section protecting all dependency trees

CCriticalSection	critBFDepend( CLockBasicInfo( CSyncBasicInfo( szBFDepend ), rankBFDepend, 0 ) );

//  makes pbfD dependent on pbf.  pbf must not have a dependent

void BFIDepend( PBF pbf, PBF pbfD )
	{
	//  critical section

	Assert( critBFDepend.FOwner() );
	
	//  validate IN args
	
	Assert( pbf != pbfNil );
	Assert( pbfD != pbfNil );
	Assert( FBFIAssertValidDependencyTree( pbf ) );
	Assert( FBFIAssertValidDependencyTree( pbfD ) );
	Assert( pbf->pbfDependent == pbfNil );
		
	//  update dependency chain head index

	//  cases 1 & 2:  pbfD is at the head of a dependency chain

	if ( !pbfD->FDependent() )
		{
		//  case 2:  pbfD is at the head of a dependency chain and one of many in
		//           the dependency chain head list

		if ( pbfD->pbfDepChainHeadNext != pbfD )
			{
			Assert( pbfD->pbfDepChainHeadPrev != pbfD );
			
			//  get prev / next BFs from pbfD
			
			PBF pbfDPrev = pbfD->pbfDepChainHeadPrev;
			PBF pbfDNext = pbfD->pbfDepChainHeadNext;

			//  get prev-most / next-most BFs from pbf

			PBF pbfPrevMost = pbf;
			while ( pbfPrevMost->FDependent() )
				{
				pbfPrevMost = pbfPrevMost->pbfDepChainHeadNext;
				Assert( pbfPrevMost != pbfNil );
				}
			PBF pbfNextMost = pbfPrevMost->pbfDepChainHeadPrev;

			//  fixup dependency chain head list

			pbfDPrev->pbfDepChainHeadNext = pbfPrevMost;
			pbfDNext->pbfDepChainHeadPrev = pbfNextMost;
			pbfPrevMost->pbfDepChainHeadPrev = pbfDPrev;
			pbfNextMost->pbfDepChainHeadNext = pbfDNext;
			}
			
		//  set both dependency chain pointers on pbfD to point to pbf

		pbfD->pbfDepChainHeadPrev = pbf;
		pbfD->pbfDepChainHeadNext = pbf;
		}

	// case 3:  pbfD is not at the head of a dependency chain

	else
		{
		//  get next-most / next-most-next BFs from pbfD

		PBF pbfDNextMost = pbfD;
		while ( pbfDNextMost->FDependent() )
			{
			pbfDNextMost = pbfDNextMost->pbfDepChainHeadPrev;
			Assert( pbfDNextMost != pbfNil );
			}
		PBF pbfDNextMostNext = pbfDNextMost->pbfDepChainHeadNext;

		//  get prev-most / next-most BFs from pbf

		PBF pbfPrevMost = pbf;
		while ( pbfPrevMost->FDependent() )
			{
			pbfPrevMost = pbfPrevMost->pbfDepChainHeadNext;
			Assert( pbfPrevMost != pbfNil );
			}
		PBF pbfNextMost = pbfPrevMost->pbfDepChainHeadPrev;

		//  fixup dependency chain head list

		pbfDNextMost->pbfDepChainHeadNext = pbfPrevMost;
		pbfDNextMostNext->pbfDepChainHeadPrev = pbfNextMost;
		pbfPrevMost->pbfDepChainHeadPrev = pbfDNextMost;
		pbfNextMost->pbfDepChainHeadNext = pbfDNextMostNext;
		
		//  set prev dependency chain pointer on pbfD to point to pbf

		pbfD->pbfDepChainHeadPrev = pbf;
		}

	//  set the dependence

	pbf->pbfDependent = pbfD;

	//  validate OUT args

	Assert( FBFIAssertValidDependencyTree( pbf ) );
	Assert( FBFIAssertValidDependencyTree( pbfD ) );
	}


//  removes pbfD as a dependent on pbf.  pbf must not be dependent on other BFs

void BFIUndepend( PBF pbf, PBF pbfD )
	{
	//  critical section

	Assert( critBFDepend.FOwner() );
	
	//  validate IN args
	
	Assert( pbf != pbfNil );
	Assert( pbfD != pbfNil );
	Assert( FBFIAssertValidDependencyTree( pbf ) );
	Assert( FBFIAssertValidDependencyTree( pbfD ) );
	Assert( !pbf->FDependent() );

	//  case 1 & 2:  pbfD is only dependent on pbf

	if ( pbfD->pbfDepChainHeadNext == pbf && pbfD->pbfDepChainHeadPrev == pbf )
		{
		//  case 1:  pbf is the only member of the dependency chain head list

		if ( pbf->pbfDepChainHeadNext == pbf )
			{
			Assert( pbf->pbfDepChainHeadPrev == pbf );

			//  reset pbfD dependency chain head list pointers

			pbfD->pbfDepChainHeadPrev = pbfD;
			pbfD->pbfDepChainHeadNext = pbfD;
			}

		//  case 2:  pbf is not the only member of the dependency chain head list

		else
			{
			Assert( pbf->pbfDepChainHeadPrev != pbf );

			//  get prev / next BFs from pbf

			PBF pbfPrev = pbf->pbfDepChainHeadPrev;
			PBF pbfNext = pbf->pbfDepChainHeadNext;

			//  fixup dependency chain head list

			pbfNext->pbfDepChainHeadPrev = pbfD;
			pbfPrev->pbfDepChainHeadNext = pbfD;
			pbfD->pbfDepChainHeadPrev = pbfPrev;
			pbfD->pbfDepChainHeadNext = pbfNext;

			//  reset pbf dependency chain head list pointers

			pbf->pbfDepChainHeadPrev = pbf;
			pbf->pbfDepChainHeadNext = pbf;
			}
		}

	//  case 3, 4, & 5:  pbfD is not only dependent on pbf

	else
		{
		//  get prev / next BFs from pbf

		PBF pbfPrev = pbf->pbfDepChainHeadPrev;
		PBF pbfNext = pbf->pbfDepChainHeadNext;

		//  case 3:  pbfD dependency chain head list next pointer points to pbf

		if ( pbfD->pbfDepChainHeadNext == pbf )
			{
			//  fixup pbfD dependency chain head list next pointer

			PBF pbfT = pbfNext;
			while ( pbfT->pbfDependent != pbfD )
				{
				pbfT = pbfT->pbfDependent;
				}
			pbfD->pbfDepChainHeadNext = pbfT;
			}

		//  case 5:  pbfD dependency chain head list prev pointers points to pbf

		else if ( pbfD->pbfDepChainHeadPrev == pbf )
			{
			//  fixup pbfD dependency chain head list next pointer

			PBF pbfT = pbfPrev;
			while ( pbfT->pbfDependent != pbfD )
				{
				pbfT = pbfT->pbfDependent;
				}
			pbfD->pbfDepChainHeadPrev = pbfT;
			}

		//  fixup dependency chain head list

		pbfPrev->pbfDepChainHeadNext = pbfNext;
		pbfNext->pbfDepChainHeadPrev = pbfPrev;

		//  reset pbf dependency chain head list pointers

		pbf->pbfDepChainHeadPrev = pbf;
		pbf->pbfDepChainHeadNext = pbf;
		}

	//  reset dependency

	pbf->pbfDependent = pbfNil;

	//  validate OUT args

	Assert( FBFIAssertValidDependencyTree( pbf ) );
	Assert( FBFIAssertValidDependencyTree( pbfD ) );
	}


#ifdef DEBUG

//  set this variable to assert when a dependency tree is found to be
//  invalid (stops only once per call to FBFIAssertValidDependencyTree())

BOOL fStopWhenInvalid = fTrue;

//  asserts the first time fValid is fFalse

//  NOTE:  call this everytime fValid is modified by something other than the
//         retval of FBFIAssertValidDependencyTreeAux() (the redundant case)

BOOL fStopWhenInvalidArmed = fFalse;
void BFIAssertStopWhenInvalid( BOOL fValid )
	{
	if ( !fValid && fStopWhenInvalidArmed )
		{
		fStopWhenInvalidArmed = fFalse;
		AssertSz( fFalse, "Invalid dependency tree encountered" );
		}
	}

//  returns fTrue if the given BF is a member of a valid dependency tree

BOOL FBFIAssertValidDependencyTree( PBF pbf )
	{
	BOOL fValid = fTrue;
	
	//  critical section

	Assert( critBFDepend.FOwner() );

#ifdef DEBUG_DEPENDENCIES

	//  reset stop-when-invalid logic

	fStopWhenInvalidArmed = fStopWhenInvalid;
	
	//  move to the root of the dependency tree of which this BF is a member

	PBF pbfRoot = pbf;
	long cLoop = 0;
	while ( pbfRoot->pbfDependent != pbfNil )
		{
		pbfRoot = pbfRoot->pbfDependent;
		BFIAssertStopWhenInvalid
			(
			fValid = fValid && ++cLoop < cbfCache
			);
		}

	//  recursively validate the entire tree

	fValid = fValid && FBFIAssertValidDependencyTreeAux( pbfRoot, pbfRoot );

#endif  //  DEBUG_DEPENDENCIES

	return fValid;
	}


//  returns fTrue if the dependency tree rooted at the given BF is valid

BOOL FBFIAssertValidDependencyTreeAux( PBF pbf, PBF pbfRoot )
	{
	BOOL fValid = fTrue;

	//  we had better never see the same IFMP / PGNO twice

	BFIAssertStopWhenInvalid
		(
		fValid = fValid && ( pbf == pbfRoot || !( pbf->pgno == pbfRoot->pgno && pbf->ifmp == pbfRoot->ifmp ) )
		);

	//  validate pointers

	BFIAssertStopWhenInvalid
		(
		fValid = fValid && ( pbf->pbfDependent == pbfNil || FBFICacheValidPbf( pbf->pbfDependent ) )
		);
	BFIAssertStopWhenInvalid
		(
		fValid = fValid && FBFICacheValidPbf( pbf->pbfDepChainHeadNext )
		);
	BFIAssertStopWhenInvalid
		(
		fValid = fValid && FBFICacheValidPbf( pbf->pbfDepChainHeadPrev )
		);

	//  normalize pointers

	PBF pbfDep = pbf->pbfDependent;
	PBF pbfNext = pbf->pbfDepChainHeadNext;
	PBF pbfPrev = pbf->pbfDepChainHeadPrev;

	//  if we have a dependent or are dependent on others, we must be dirty

	BFIAssertStopWhenInvalid
		(
		fValid = fValid && ( ( pbfDep == pbfNil && !pbf->FDependent() ) || pbf->bfdf >= bfdfDirty )
		);

	//  if we have a dependent, it must be dirty

	BFIAssertStopWhenInvalid
		(
		fValid = fValid && ( pbfDep == pbfNil || pbfDep->bfdf >= bfdfDirty )
		);

	//  we are dependent on others

	if ( pbf->FDependent() )
		{
		//  our next / prev pointers must not point at us

		BFIAssertStopWhenInvalid
			(
			fValid = fValid && pbfNext != pbf
			);
		BFIAssertStopWhenInvalid
			(
			fValid = fValid && pbfPrev != pbf
			);

		//  our next / prev pointers must point at a node that we are
		//  immediately dependent on

		BFIAssertStopWhenInvalid
			(
			fValid = fValid && pbfNext->pbfDependent == pbf
			);
		BFIAssertStopWhenInvalid
			(
			fValid = fValid && pbfPrev->pbfDependent == pbf
			);

		//  both our next / prev pointers are dependent on no-one

		if ( !pbfNext->FDependent() && !pbfPrev->FDependent() )
			{
			//  ensure that we are (eventually) dependent on all the nodes in
			//  the dependency chain head list between our next / prev pointers

			PBF pbfHead = pbfNext;
			long cLoop = 0;
			while ( pbfHead != pbfPrev )
				{
				PBF pbfCurr = pbfHead;
				long cLoop2 = 0;
				while (	pbfCurr->pbfDependent != pbfNil &&
						pbfCurr->pbfDependent != pbf )
					{
					pbfCurr = pbfCurr->pbfDependent;
					BFIAssertStopWhenInvalid
						(
						fValid = fValid && ++cLoop2 < cbfCache
						);
					}
				BFIAssertStopWhenInvalid
					(
					fValid = fValid && pbfCurr->pbfDependent == pbf
					);
				pbfHead = pbfHead->pbfDepChainHeadNext;
				BFIAssertStopWhenInvalid
					(
					fValid = fValid && ++cLoop < cbfCache
					);
				}
			}

		//  our tree is valid only if the trees based at our next / prev
		//  pointers are valid

		fValid = fValid && FBFIAssertValidDependencyTreeAux( pbfNext, pbfRoot );
		fValid = fValid && FBFIAssertValidDependencyTreeAux( pbfPrev, pbfRoot );
		}

	//  we are not dependent on others

	else
		{
		//  either our next / prev pointers must both point at us or neither
		//  must point at us

		BFIAssertStopWhenInvalid
			(
			fValid = fValid && (	( pbfNext == pbf && pbfPrev == pbf ) ||
									( pbfNext != pbf && pbfPrev != pbf ) )
			);

		//  get the root of our next neighbor's dependency tree

		PBF pbfNextRoot = pbfNext;
		long cLoop = 0;
		while ( pbfNextRoot->pbfDependent != pbfNil )
			{
			pbfNextRoot = pbfNextRoot->pbfDependent;
			BFIAssertStopWhenInvalid
				(
				fValid = fValid && ++cLoop < cbfCache
				);
			}

		//  get the root of our prev neighbor's dependency tree

		PBF pbfPrevRoot = pbfNext;
		cLoop = 0;
		while ( pbfPrevRoot->pbfDependent != pbfNil )
			{
			pbfPrevRoot = pbfPrevRoot->pbfDependent;
			BFIAssertStopWhenInvalid
				(
				fValid = fValid && ++cLoop < cbfCache
				);
			}

		//  the root of the dependency tree in which our next / prev neighbors'
		//  reside must be the same as the root or our dependency tree

		BFIAssertStopWhenInvalid
			(
			fValid = fValid && pbfNextRoot == pbfRoot
			);
		BFIAssertStopWhenInvalid
			(
			fValid = fValid && pbfPrevRoot == pbfRoot
			);
		}

	return fValid;
	}

#endif  //  DEBUG

void BFISetLgposOldestBegin0( PBF pbf, LGPOS lgpos )
	{
	//  all pages with an OB0 must be dirty.  this is because we don't want untidy
	//  pages to stick around and hold up the checkpoint as we normally don't want
	//  to flush them

	BFIDirtyPage( pbf, bfdfDirty );
	
	//  save the current lgposOldestBegin0 for this BF

	LGPOS lgposOldestBegin0 = pbf->lgposOldestBegin0;

	//  if the specified lgposBegin0 is earlier than the current lgposOldestBegin0
	//  then reset the BF's lgposOldestBegin0

	if ( CmpLgpos( &lgposOldestBegin0, &lgpos ) > 0 )
		{
		BFIResetLgposOldestBegin0( pbf );
		}
	
	//  the new lgposOldestBegin0 is earlier than the current lgposOldestBegin0

	if ( CmpLgpos( &lgposOldestBegin0, &lgpos ) > 0 )
		{
		FMP* pfmp = &rgfmp[ pbf->ifmp & ifmpMask ];
		pfmp->RwlBFContext().EnterAsReader();
		
		BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( pbf->ifmp & ifmpSLV ) );
		Assert( pbffmp );

		//  set the new lgposOldestBegin0
		
		pbf->lgposOldestBegin0 = lgpos;

		//  try to insert ourself into the OB0 index

		BFOB0::CLock lock;
		pbffmp->bfob0.LockKeyPtr( lgpos.IbOffset(), pbf, &lock );
		
		BFOB0::ERR errOB0 = pbffmp->bfob0.ErrInsertEntry( &lock, pbf );

		pbffmp->bfob0.UnlockKeyPtr( &lock );

		//  we failed to insert ourelf into the OB0 index

		if ( errOB0 != BFOB0::errSuccess )
			{
			Assert(	errOB0 == BFOB0::errOutOfMemory ||
					errOB0 == BFOB0::errKeyRangeExceeded );

			//  insert ourself into the OB0 index overflow list.  this always
			//  succeeds but isn't good because it is unordered

			pbf->fInOB0OL = fTrue;

			pbffmp->critbfob0ol.Enter();
			pbffmp->bfob0ol.InsertAsNextMost( pbf );
			pbffmp->critbfob0ol.Leave();
			}

		pfmp->RwlBFContext().LeaveAsReader();
		}
	}

void BFIResetLgposOldestBegin0( PBF pbf )
	{
	//  delete ourself from the Oldest Begin 0 index or the overflow list

	if ( CmpLgpos( &pbf->lgposOldestBegin0, &lgposMax ) )
		{
		FMP* pfmp = &rgfmp[ pbf->ifmp & ifmpMask ];
		pfmp->RwlBFContext().EnterAsReader();
		
		BFFMPContext* pbffmp = (BFFMPContext*)pfmp->DwBFContext( !!( pbf->ifmp & ifmpSLV ) );
		Assert( pbffmp );

		if ( pbf->fInOB0OL )
			{
			pbf->fInOB0OL = fFalse;
			
			pbffmp->critbfob0ol.Enter();
			pbffmp->bfob0ol.Remove( pbf );
			pbffmp->critbfob0ol.Leave();
			}
		else
			{
			BFOB0::CLock lock;
			pbffmp->bfob0.LockKeyPtr( pbf->lgposOldestBegin0.IbOffset(), pbf, &lock );
			
			BFOB0::ERR errOB0 = pbffmp->bfob0.ErrDeleteEntry( &lock );
			Assert( errOB0 == BFOB0::errSuccess );

			pbffmp->bfob0.UnlockKeyPtr( &lock );
			}

		pfmp->RwlBFContext().LeaveAsReader();

		pbf->lgposOldestBegin0 = lgposMax;
		}
	}

void BFISetLgposModify( PBF pbf, LGPOS lgpos )
	{
	//  the new lgposModify is later than the current lgposModify

	if ( CmpLgpos( &pbf->lgposModify, &lgpos ) < 0 )
		{
		//  set the new lgposModify

		pbf->lgposModify = lgpos;
		}
	}

void BFIResetLgposModify( PBF pbf )
	{
	pbf->lgposModify = lgposMin;
	}

void BFIAddUndoInfo( PBF pbf, RCE* prce, BOOL fMove )
	{
	//  add this RCE to the RCE chain off of the BF

	prce->AddUndoInfo( pbf->pgno, pbf->prceUndoInfoNext, fMove );

	//  put this RCE at the head of the list
	
	pbf->prceUndoInfoNext = prce;
	}

void BFIRemoveUndoInfo( PBF pbf, RCE* prce, LGPOS lgposModify, BOOL fMove )
	{
	//  depend this BF on the specified lgposModify

	BFISetLgposModify( pbf, lgposModify );
	
	//  if this RCE is at the head of the list, fix up the next pointer in the BF

	if ( pbf->prceUndoInfoNext == prce )
		{
		pbf->prceUndoInfoNext = prce->PrceUndoInfoNext();
		}

	//  remove the RCE from the RCE chain off of the BF

	prce->RemoveUndoInfo( fMove );
	}


//  Performance Monitoring Support

long cBFCacheMiss;

long LBFCacheHitsCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFCacheReq - cBFCacheMiss;
		}
		
	return 0;
	}

long cBFCacheReq;

long LBFCacheReqsCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFCacheReq ? cBFCacheReq : 1;
		}
		
	return 0;
	}

long cBFClean;

long LBFCleanBuffersCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFClean;
		}
		
	return 0;
	}

PERFInstanceGlobal<> cBFPagesRead;
long LBFPagesReadCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesRead.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceGlobal<> cBFPagesWritten;
long LBFPagesWrittenCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesWritten.PassTo( iInstance, pvBuf );
	return 0;
	}

long LBFPagesTransferredCEFLPv( long iInstance, void* pvBuf )
	{
	if ( NULL != pvBuf )
		{
		*( (LONG *) pvBuf ) = cBFPagesRead.Get( iInstance ) + cBFPagesWritten.Get( iInstance );
		}
	return 0;
	}

long LBFLatchCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFCacheReq;
		}
		
	return 0;
	}

long cBFSlowLatch;

long LBFFastLatchCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFCacheReq - cBFSlowLatch;
		}
		
	return 0;
	}

long cBFBadLatchHint;

long LBFBadLatchHintCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFBadLatchHint;
		}
		
	return 0;
	}

long cBFLatchConflict;

long LBFLatchConflictCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFLatchConflict;
		}
		
	return 0;
	}

long cBFLatchStall;

long LBFLatchStallCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFLatchStall;
		}
		
	return 0;
	}

long LBFAvailBuffersCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bfavail.Cobject() : 0;
		
	return 0;
	}

long LBFCacheFaultCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bfavail.CRemove() : 0;
		
	return 0;
	}

long LBFCacheEvictCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = cbfNewlyEvictedUsed;
		
	return 0;
	}

long LBFAvailStallsCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bfavail.CRemoveWait() : 0;
		
	return 0;
	}

long LBFTotalBuffersCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = (unsigned long)( fBFInitialized ? cbfCache : 1 );
		
	return 0;
	}

long LBFCacheSizeCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		*( (unsigned __int64*) pvBuf ) = ( cbfCache - cbfNewlyCommitted ) * g_cbPage;
		
	return 0;
	}

long LBFStartFlushThresholdCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = (unsigned long)cbfScaledCleanThresholdStart;
		}
		
	return 0;
	}

long LBFStopFlushThresholdCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = (unsigned long)cbfScaledCleanThresholdStop;
		}
		
	return 0;
	}

PERFInstanceG<> cBFPagesPreread;
long LBFPagesPrereadCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesPreread.PassTo( iInstance, pvBuf );
	return 0;
	}


PERFInstanceG<> cBFUncachedPagesPreread;
long LBFCachedPagesPrereadCEFLPv( long iInstance, void* pvBuf )
	{
	if ( NULL != pvBuf )
		{
		*( (LONG *) pvBuf ) = cBFPagesPreread.Get( iInstance ) - cBFUncachedPagesPreread.Get( iInstance );
		}
	return 0;
	}


PERFInstanceG<> cBFPagesPrereadUntouched;
long LBFPagesPrereadUntouchedCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesPrereadUntouched.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceGlobal<> cBFPagesVersioned;

long LBFPagesVersionedCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesVersioned.PassTo( iInstance, pvBuf );
	return 0;
	}

long cBFVersioned;

long LBFVersionedCEFLPv( long iInstance, void* pvBuf )
	{
	Unused( iInstance );
	
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cBFVersioned;
		}
		
	return 0;
	}

PERFInstanceGlobal<> cBFPagesOrdinarilyWritten;

long LBFPagesOrdinarilyWrittenCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesOrdinarilyWritten.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceGlobal<> cBFPagesAnomalouslyWritten;

long LBFPagesAnomalouslyWrittenCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesAnomalouslyWritten.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceGlobal<> cBFPagesOpportunelyWritten;

long LBFPagesOpportunelyWrittenCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesOpportunelyWritten.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceGlobal<> cBFPagesRepeatedlyWritten;

long LBFPagesRepeatedlyWrittenCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesRepeatedlyWritten.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceGlobal<> cBFPagesIdlyWritten;

long LBFPagesIdlyWrittenCEFLPv( long iInstance, void* pvBuf )
	{
	cBFPagesIdlyWritten.PassTo( iInstance, pvBuf );
	return 0;
	}

long LBFPageHistoryCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bflruk.CHistoryRecord() : 0;
		
	return 0;
	}

long LBFPageHistoryHitsCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bflruk.CHistoryHit() : 0;
		
	return 0;
	}

long LBFPageHistoryReqsCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bflruk.CHistoryRequest() : 1;
		
	return 0;
	}

long LBFPageScannedOutOfOrderCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bflruk.CResourceScannedOutOfOrder() : 0;
		
	return 0;
	}

long LBFPageScannedCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = fBFInitialized ? bflruk.CResourceScanned() : 1;
		
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\cat.cxx ===
#include "std.hxx"
#include "_cat.cxx"

const OBJID	objidFDPMSO						= 2;
const OBJID objidFDPMSOShadow				= 3;

const ULONG	cbCATNormalizedObjid			= 5;	//	header byte + 4-byte objid

#pragma data_seg( "cacheline_aware_data" )
CATHash g_cathash( rankCATHash );
#pragma data_seg()


//	
//	initialization for the CATALOG layer
//	

ERR ErrCATInit()
	{
	ERR err = JET_errSuccess;

	//	initialize the catalog hash-table
	//		load factor		5.0
	//		uniformity		1.0
	
	CATHash::ERR errCATHash = g_cathash.ErrInit( 5.0, 1.0 );
	Assert( errCATHash == CATHash::errSuccess || CATHash::errOutOfMemory );
	if ( errCATHash == CATHash::errOutOfMemory )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	return JET_errSuccess;

HandleError:

	//	term the catalog hash-table 
	
	g_cathash.Term();

	return err;
	}


//	
//	termination of the CATALOG layer
//

void CATTerm()
	{
#ifdef DEBUG

	//	catalog hash should be empty

	CATHashAssertClean();

#endif	//	DEBUG

	//	term the catalog hash-table

	g_cathash.Term();
	}


//	lookup an entry in the catalog hash-table
// 	if lookup succeeds, returns FCB from entryCATHash

BOOL FCATHashILookup(
	IFMP			ifmp,
	CHAR* const 	szTableName,
	PGNO* const		ppgnoTableFDP,
	OBJID* const	pobjidTable )
	{
	Assert( NULL != ppgnoTableFDP );
	Assert( NULL != pobjidTable );

	//	attempt to short-circuit the catalog seek by 
	//	looking for it in the global ifmp/table-name
	//	hash table first
	
	CATHashKey		keyCATHash( ifmp, szTableName );
	CATHashEntry	entryCATHash;
	CATHash::CLock	lockCATHash;

	//	lock the key
	g_cathash.ReadLockKey( keyCATHash, &lockCATHash );

	//	see if we the entry exists
	const CATHash::ERR	errCATHash	= g_cathash.ErrRetrieveEntry( &lockCATHash, &entryCATHash );
	const BOOL			fFound		= ( CATHash::errSuccess == errCATHash );
	if ( fFound )
		{
		Assert( pfcbNil != entryCATHash.m_pfcb );
		*ppgnoTableFDP = entryCATHash.m_pfcb->PgnoFDP();
		*pobjidTable = entryCATHash.m_pfcb->ObjidFDP();
		}	
	else
		{
		Assert( CATHash::errEntryNotFound == errCATHash );
		}
	
	//	unlock the key
	g_cathash.ReadUnlockKey( &lockCATHash );

	return fFound;
	}
	

//	try to insert an entry into the catalog hash-table
//	ignore the result -- at best, we will get it in there or it will already be there
//						 at worst, we will get out-of-memory and the user will just have
//							 to incur the penalty for seeking every time

VOID CATHashIInsert( FCB *pfcb, CHAR *const szTable )
	{

	//	try to add the new pgnoFDP / objidFDP to the 
	//	catalog hash-table; if we fail, it means that
	//	someone else was racing with us to insert
	//	the entry and won (assert that the entry matches)

	CATHashKey		keyCATHash( pfcb->Ifmp(), szTable );
	CATHashEntry	entryCATHash( pfcb );
	CATHash::CLock	lockCATHash;
	BOOL			fProceedWithInsert = fTrue;
	BOOL			fInitialized;

	Assert( pfcb != NULL );
	// we never put temp tables in catalog hash
	Assert( pfcb->FTypeTable() );

	fInitialized = pfcb->FInitialized();

	//	lock the key

	g_cathash.WriteLockKey( keyCATHash, &lockCATHash );

	//	insert the entry

	if ( fInitialized )
		{
		entryCATHash.m_pfcb->EnterDML();
		fProceedWithInsert = !entryCATHash.m_pfcb->FDeletePending();
		}

	if ( fProceedWithInsert )
		{
		const CATHash::ERR errCATHash = g_cathash.ErrInsertEntry( &lockCATHash, entryCATHash );

//#ifdef DEBUG
#if 0	//	UNDONE: need to handle EnterDML problems
		if ( errCATHash == CATHash::errKeyDuplicate )
			{

			//	the entry was already there

			//	verify that it matches the data we just got

			CATHash::ERR errCATHashT = g_cathash.ErrRetrieveEntry( &lockCATHash, &entryCATHash );
			Assert( errCATHashT == CATHash::errSuccess );

	//	entryCATHash.m_pfcb->EnterDML();
			Assert( entryCATHash.m_uiHashIfmpName == UiHashIfmpName( entryCATHash.m_pfcb->Ifmp(), entryCATHash.m_pfcb->Ptdb()->SzTableName() ) );
			Assert( UtilCmpName( entryCATHash.m_pfcb->Ptdb()->SzTableName(), keyCATHash.m_pszName ) == 0 );
	//	entryCATHash.m_pfcb->LeaveDML();
			Assert( entryCATHash.m_pfcb == pfcb );
			Assert( entryCATHash.m_pgnoFDPDBG == pfcb->PgnoFDP() );
			Assert( entryCATHash.m_objidFDPDBG == pfcb->ObjidFDP() );
			}
		else 
			{
			Assert( errCATHash == CATHash::errSuccess );
			}
#endif
		}
		
	if ( fInitialized )
		entryCATHash.m_pfcb->LeaveDML();

	//	unlock the key

	g_cathash.WriteUnlockKey( &lockCATHash );
	}



//	delete an entry from the catalog hash-table
//	ignore the results -- at best, we will delete it
//						  at worst, it will already be gone

VOID CATHashIDelete( FCB *pfcb, CHAR *const szTable )
	{

	//	try to add the new pgnoFDP / objidFDP to the 
	//	catalog hash-table; if we fail, it means that
	//	someone else was racing with us to insert
	//	the entry and won (assert that the entry matches)

	CATHashKey		keyCATHash( pfcb->Ifmp(), szTable );
	CATHash::CLock	lockCATHash;

	//	lock the key

	g_cathash.WriteLockKey( keyCATHash, &lockCATHash );

	//	delete the entry (ignore the result)

	(VOID)g_cathash.ErrDeleteEntry( &lockCATHash );

	//	unlock the key

	g_cathash.WriteUnlockKey( &lockCATHash );
	}


#ifdef DEBUG

//	make sure all entries in the catalog hash pertaining to the given IFMP are gone

VOID CATHashAssertCleanIfmp( IFMP ifmp )
	{
	CATHash::CLock	lockCATHash;
	CATHash::ERR	errCATHash;
	CATHashEntry	entryCATHash;

	//	start a scan

	g_cathash.BeginHashScan( &lockCATHash );

	while ( ( errCATHash = g_cathash.ErrMoveNext( &lockCATHash ) ) != CATHash::errNoCurrentEntry )
		{

		//	fetch the current entry

		errCATHash = g_cathash.ErrRetrieveEntry( &lockCATHash, &entryCATHash );
		Assert( errCATHash == CATHash::errSuccess );

		//	ifmp should not match

		Assert( pfcbNil != entryCATHash.m_pfcb );
		Assert( entryCATHash.m_pfcb->Ifmp() != ifmp );
		}

	//	complete the scan

	g_cathash.EndHashScan( &lockCATHash );
	}


//	make sure all entries in the catalog hash are gone

VOID CATHashAssertClean()
	{
	CATHash::CLock	lockCATHash;
	CATHash::ERR	errCATHash;
	CATHashEntry	entryCATHash;

	//	start a scan

	g_cathash.BeginHashScan( &lockCATHash );
	errCATHash = g_cathash.ErrMoveNext( &lockCATHash );
	AssertSz( errCATHash == CATHash::errNoCurrentEntry, "Catalog hash-table was not empty during shutdown!" );
	while ( errCATHash != CATHash::errNoCurrentEntry )
		{

		//	fetch the current entry

		errCATHash = g_cathash.ErrRetrieveEntry( &lockCATHash, &entryCATHash );
		Assert( errCATHash == CATHash::errSuccess );

		//	move to the next entry

		errCATHash = g_cathash.ErrMoveNext( &lockCATHash );
		}

	//	complete the scan

	g_cathash.EndHashScan( &lockCATHash );
	}

#endif	//	DEBUG
	

/*=================================================================
ErrCATCreate

Description:

	Called from ErrIsamCreateDatabase; creates all system tables

Parameters:

	PIB		*ppib		; PIB of user
	IFMP	ifmp		; ifmp of database that needs tables

Return Value:

	whatever error it encounters along the way

=================================================================*/

INLINE ERR ErrCATICreateCatalogIndexes(
	PIB			*ppib,
	const IFMP	ifmp,
	OBJID		*pobjidNameIndex,
	OBJID		*pobjidRootObjectsIndex )
	{
	ERR			err;
	FUCB		*pfucbTableExtent;
	PGNO		pgnoIndexFDP;
	FCB 		*pfcb = pfcbNil;

	//	don't maintain secondary indexes on the shadow catalog.

	// Open cursor for space navigation
	CallR( ErrDIROpen( ppib, pgnoFDPMSO, ifmp, &pfucbTableExtent ) );

	pfcb = pfucbTableExtent->u.pfcb;

	Assert( pfucbTableExtent != pfucbNil );
	Assert( !FFUCBVersioned( pfucbTableExtent ) );	// Verify won't be deferred closed.
	Assert( pfcb != pfcbNil );
	Assert( !pfcb->FInitialized() );
	Assert( pfcb->Pidb() == pidbNil );

	//	complete the initialization of the FCB

	pfcb->Lock();
	pfcb->CreateComplete();
	pfcb->Unlock();
	
	Call( ErrDIRCreateDirectory(
				pfucbTableExtent,
				(CPG)0,
				&pgnoIndexFDP,
				pobjidNameIndex,
				CPAGE::fPageIndex,
				fSPMultipleExtent|fSPUnversionedExtent ) );
	Assert( pgnoIndexFDP == pgnoFDPMSO_NameIndex );

	Call( ErrDIRCreateDirectory(
				pfucbTableExtent,
				(CPG)0,
				&pgnoIndexFDP,
				pobjidRootObjectsIndex,
				CPAGE::fPageIndex,
				fSPMultipleExtent|fSPUnversionedExtent ) );
	Assert( pgnoIndexFDP == pgnoFDPMSO_RootObjectIndex );
		
HandleError:
	Assert( pfcb->FInitialized() );
	Assert( pfcb->WRefCount() == 1 );

	//	force the FCB to be uninitialized so it will be purged by DIRClose

	pfcb->Lock();
	pfcb->CreateComplete( errFCBUnusable );
	pfcb->Unlock();
	
	//	verify that this FUCB won't be defer-closed

	Assert( !FFUCBVersioned( pfucbTableExtent ) );

	//	close the FUCB
	
	DIRClose( pfucbTableExtent );
	
	return err;
	}


// Returns the FID of a column in a catalog table.
INLINE FID ColumnidCATColumn( const CHAR *szColumnName )
	{
	COLUMNID	columnid	= 0;
	UINT		i;

	for ( i = 0; i < cColumnsMSO; i++ )
		{
		if ( 0 == UtilCmpName( rgcdescMSO[i].szColName, szColumnName ) )
			{
			Assert( !FCOLUMNIDTemplateColumn( rgcdescMSO[i].columnid ) );
			columnid = rgcdescMSO[i].columnid;
			break;
			}
		}

	Assert( i < cColumnsMSO );
	Assert( columnid > 0 );
	
	return FID( columnid );
	}


//  ================================================================
ERR ErrCATIRetrieveTaggedColumn(
	FUCB				* const pfucb,
	const FID			fid,
	const ULONG 		itagSequence,
	const DATA&			dataRec,
	BYTE				* const pbRet,
	const ULONG			cbRetMax,
	ULONG				* const pcbRetActual )
//  ================================================================
//
//  Retrieve a tagged column, possibly going to the LV tree
//  Takes a latched page and leaves the page latched. Because the
//  page is unlatched and relatched any pointers held into the page
//  may be invalidated
//
//-
	{
	ERR err;

	Assert( FTaggedFid( fid ) );
	Assert( 1 == itagSequence );
	Assert( Pcsr( pfucb )->FLatched() );

	DATA dataRetrieved;
	Call( ErrRECIRetrieveTaggedColumn(
				pfucb->u.pfcb,
				ColumnidOfFid( fid, fFalse ),
				itagSequence,
				dataRec,
				&dataRetrieved ) );
	Assert( Pcsr( pfucb )->FLatched() );
	Assert( wrnRECUserDefinedDefault != err );
	Assert( wrnRECSeparatedSLV != err );
	Assert( wrnRECIntrinsicSLV != err );

	Assert( wrnRECLongField != err );
	if ( wrnRECSeparatedLV == err )
		{
		Assert( sizeof(LID) == dataRetrieved.Cb() );
		
		Call( ErrRECIRetrieveSeparatedLongValue(
					pfucb,
					dataRetrieved,
					fTrue,
					0,
					pbRet,
					cbRetMax,
					pcbRetActual,
					NO_GRBIT ) );
		Assert( JET_wrnColumnNull != err );

		//	must re-latch record
		Assert( !Pcsr( pfucb )->FLatched() );
		const ERR errT = ErrDIRGet( pfucb );
		err = ( errT < 0 ) ? errT : err;
		}
	else if( wrnRECIntrinsicLV == err ) 
		{
		*pcbRetActual = dataRetrieved.Cb();
		UtilMemCpy( pbRet, dataRetrieved.Pv(), min( cbRetMax, dataRetrieved.Cb() ) );
		err = ( cbRetMax >= dataRetrieved.Cb() ) ? JET_errSuccess : ErrERRCheck( JET_wrnBufferTruncated );
		}
	else
		{
		Assert( JET_wrnColumnNull == err );
		*pcbRetActual = 0;
		}

HandleError:
	Assert( err < 0 || Pcsr( pfucb )->FLatched() );

	return err;
	}


/*	Catalog-retrieval routines for system tables.
/*
/*	This code was lifted from the key parsing code in ErrIsamCreateIndex(), with
/*	optimisations for assumptions made for key strings of system table indexes.
/**/
LOCAL BYTE CfieldCATKeyString( CHAR *szKey, IDXSEG* rgidxseg )
	{
	CHAR	*pch;
	ULONG	cfield = 0;

	for ( pch = szKey; *pch != '\0'; pch += strlen( pch ) + 1 )
		{
		/*	Assume the first character of each component is a '+' (this is
		/*	specific to system table index keys).  In general, this may also
		/*	be a '-' or nothing at all (in which case '+' is assumed), but we
		/*	don't use descending indexes for system tables and we'll assume we
		/*	know enough to put '+' characters in our key string.
		/**/
		Assert( *pch == '+' );
		pch++;

		rgidxseg[cfield].ResetFlags();
		rgidxseg[cfield].SetFid( FidOfColumnid( ColumnidCATColumn( pch ) ) );
		Assert( !rgidxseg[cfield].FTemplateColumn() );
		Assert( !rgidxseg[cfield].FDescending() );
		Assert( !rgidxseg[cfield].FMustBeNull() );
		cfield++;
		}


	// Verify the key-field array will fit in the IDB.
	Assert( cfield > 0 );
	Assert( cfield <= cIDBIdxSegMax );

	return (BYTE)cfield;
	}

ERR ErrCATPopulateCatalog(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
	const PGNO	pgnoFDP,
	const OBJID	objidTable,
	const CHAR	*szTableName,
	const CPG	cpgInitial,
	const BOOL  fExpectKeyDuplicateErrors )
	{
	ERR			err;
	UINT		i;
	FIELD		field;

	field.ibRecordOffset	= ibRECStartFixedColumns;	// record offset will be calculated at catalog open time
	field.cp				= usEnglishCodePage;

	//	must insert MSysObjects record to prevent clients from
	//	creating a table named "MSysObjects".
	err = ErrCATAddTable(
				ppib,
				pfucbCatalog,
				pgnoFDP,
				objidTable,
				szTableName,
				NULL,
				cpgInitial,
				ulFILEDefaultDensity,
				JET_bitObjectSystem|JET_bitObjectTableFixedDDL );
	if( JET_errTableDuplicate == err && fExpectKeyDuplicateErrors )
		{
		err = JET_errSuccess;
		}
	Call( err );

	for ( i = 0; i < cColumnsMSO; i++ )
		{
		field.coltyp	= FIELD_COLTYP( rgcdescMSO[i].coltyp );
		field.cbMaxLen 	= UlCATColumnSize( field.coltyp, 0, NULL );

		//	only supported flag for system table columns is JET_bitColumnNotNULL
		field.ffield	= 0;
		Assert( 0 == rgcdescMSO[i].grbit
				|| JET_bitColumnNotNULL == rgcdescMSO[i].grbit
				|| JET_bitColumnTagged == rgcdescMSO[i].grbit );
		if ( JET_bitColumnNotNULL == rgcdescMSO[i].grbit )
			FIELDSetNotNull( field.ffield );
		
		Assert( ibRECStartFixedColumns == field.ibRecordOffset );	//	offset will be fixed up at catalog open time
		Assert( usEnglishCodePage == field.cp );
		
		err = ErrCATAddTableColumn(
				ppib,
				pfucbCatalog,
				objidTable,
				rgcdescMSO[i].szColName,
				rgcdescMSO[i].columnid,
				&field,
				NULL,
				0,
				NULL,
				NULL,
				0 );
		if( JET_errColumnDuplicate == err && fExpectKeyDuplicateErrors )
			{
			err = JET_errSuccess;
			}
		Call( err );
		}

HandleError:
	return err;
	}


//  ================================================================
ERR ErrCATUpdate( PIB * const ppib, const IFMP ifmp )
//  ================================================================
//
//  Adds new catalog records to an old format catalog. We may have
//  crashed before updating the version during a previous upgrade
//  so be prepared for the records to already exist
//
//-
	{
	ERR		err;
	FUCB	* pfucb	= pfucbNil;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	
	Call( ErrFILEOpenTable(
			ppib,
			ifmp,
			&pfucb, 
			szMSO,
			JET_bitTableDenyRead ) );

	Call( ErrCATPopulateCatalog(
			ppib,
			pfucb,
			pgnoFDPMSO,
			objidFDPMSO,
			szMSO,
			cpgMSOInitial,
			fTrue ) );
	Call( ErrCATPopulateCatalog(
			ppib,
			pfucb,
			pgnoFDPMSOShadow,
			objidFDPMSOShadow,
			szMSOShadow,
			cpgMSOShadowInitial,
			fTrue ) );
	
HandleError:
	if( pfucbNil != pfucb )
		{
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}
	err = ErrDIRCommitTransaction( ppib, NO_GRBIT );
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


ERR ErrREPAIRCATCreate( 
	PIB *ppib, 
	const IFMP ifmp,
	const OBJID	objidNameIndex,
	const OBJID	objidRootObjectsIndex, 
	const BOOL	fInRepair )
	{
	ERR		err;
	FUCB	*pfucb				= pfucbNil;
	
	IDB		idb;
	
	//	open table in exclusive mode, for output parameter
	//
	CallR( ErrFILEOpenTable(
			ppib,
			ifmp,
			&pfucb, 
			szMSO,
			JET_bitTableDenyRead ) );
	Assert( pfucbNil != pfucb );

	Call( ErrCATPopulateCatalog(
				ppib,
				pfucb,
				pgnoFDPMSO,
				objidFDPMSO,
				szMSO,
				cpgMSOInitial,
				fInRepair ) ); //fFalse by default (non-repair situation)
	
	Call( ErrCATPopulateCatalog(
				ppib,
				pfucb,
				pgnoFDPMSOShadow,
				objidFDPMSOShadow,
				szMSOShadow,
				cpgMSOShadowInitial,
				fInRepair ) ); //fFalse by default (non-repair situation)

	idb.SetLcid( lcidDefault );
	idb.SetDwLCMapFlags( dwLCMapFlagsDefault );
	idb.SetCidxsegConditional( 0 );		//  UNDONE: catalog indexes cannot be conditional
	
	idb.SetCidxseg( CfieldCATKeyString( rgidescMSO[0].szIdxKeys, idb.rgidxseg ) );
	idb.SetFlagsFromGrbit( rgidescMSO[0].grbit );
	idb.SetCbVarSegMac( JET_cbPrimaryKeyMost );
	
	err = ErrCATAddTableIndex(
					ppib,
					pfucb,
					objidFDPMSO,
					szMSOIdIndex,
					pgnoFDPMSO,
					objidFDPMSO,
					&idb,
					idb.rgidxseg,
					idb.rgidxsegConditional,
					ulFILEDefaultDensity );
	if( fInRepair && JET_errIndexDuplicate == err )
		{
		err = JET_errSuccess;
		}
	else
		{
		Call( err );
		}
	
	err = ErrCATAddTableIndex(
					ppib,
					pfucb,
					objidFDPMSOShadow,
					szMSOIdIndex,
					pgnoFDPMSOShadow,
					objidFDPMSOShadow,
					&idb,
					idb.rgidxseg,
					idb.rgidxsegConditional,
					ulFILEDefaultDensity );
	if( fInRepair && JET_errIndexDuplicate == err )
		{
		err = JET_errSuccess;
		}
	else
		{
		Call( err );
		}

	idb.SetCbVarSegMac( JET_cbSecondaryKeyMost );

	idb.SetCidxseg( CfieldCATKeyString( rgidescMSO[1].szIdxKeys, idb.rgidxseg ) );
	idb.SetFlagsFromGrbit( rgidescMSO[1].grbit );
	err = ErrCATAddTableIndex(
					ppib,
					pfucb,
					objidFDPMSO,
					szMSONameIndex,
					pgnoFDPMSO_NameIndex,
					objidNameIndex,
					&idb,
					idb.rgidxseg,
					idb.rgidxsegConditional,
					ulFILEDefaultDensity );
	if( fInRepair && JET_errIndexDuplicate == err )
		{
		err = JET_errSuccess;
		}
	else
		{
		Call( err );
		}
		
	idb.SetCidxseg( CfieldCATKeyString( rgidescMSO[2].szIdxKeys, idb.rgidxseg ) );
	idb.SetFlagsFromGrbit( rgidescMSO[2].grbit );
	err = ErrCATAddTableIndex(
					ppib,
					pfucb,
					objidFDPMSO,
					szMSORootObjectsIndex,
					pgnoFDPMSO_RootObjectIndex,
					objidRootObjectsIndex,
					&idb,
					idb.rgidxseg,
					idb.rgidxsegConditional,
					ulFILEDefaultDensity );
	if( fInRepair && JET_errIndexDuplicate == err )
		{
		err = JET_errSuccess;
		}
	else
		{
		Call( err );
		}
		
	Assert( pfucb->u.pfcb->FInitialized() );
	Assert( pfucb->u.pfcb->FTypeTable() );
	Assert( pfucb->u.pfcb->FPrimaryIndex() );

	err = JET_errSuccess;

HandleError:
	if ( pfucbNil != pfucb )
		{
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}
		
	return err;
	}


ERR ErrCATCreate( PIB *ppib, const IFMP ifmp )
	{
	ERR		err;
	FUCB	*pfucb				= pfucbNil;
	PGNO	pgnoFDP;
	PGNO	pgnoFDPShadow;
	OBJID	objidFDP;
	OBJID	objidFDPShadow;
	OBJID	objidNameIndex;
	OBJID	objidRootObjectsIndex;
	
	FMP::AssertVALIDIFMP( ifmp );
	Assert( dbidTemp != rgfmp[ifmp].Dbid() );

	//	no transaction/versioning needed because if this fails,
	//	the entire createdb will fail
	Assert( 0 == ppib->level );
	Assert( rgfmp[ifmp].FCreatingDB() );

	CheckPIB( ppib );
	CheckDBID( ppib, ifmp );

	//	allocate cursor
	//
	CallR( ErrDIROpen( ppib, pgnoSystemRoot, ifmp, &pfucb ) );
	Assert( pfucbNil != pfucb );
	Assert( cpgMSOInitial > cpgTableMin );
	Call( ErrDIRCreateDirectory(
				pfucb,
				cpgMSOInitial,
				&pgnoFDP,
				&objidFDP,
				CPAGE::fPagePrimary,
				fSPMultipleExtent|fSPUnversionedExtent ) );
	Call( ErrDIRCreateDirectory(
				pfucb,
				cpgMSOShadowInitial,
				&pgnoFDPShadow,
				&objidFDPShadow,
				CPAGE::fPagePrimary,
				fSPMultipleExtent|fSPUnversionedExtent ) );
	DIRClose( pfucb );
	pfucb = pfucbNil;

	Assert( FCATSystemTable( pgnoFDP ) );
	Assert( PgnoCATTableFDP( szMSO ) == pgnoFDP );
	Assert( pgnoFDPMSO == pgnoFDP );
	Assert( objidFDPMSO == objidFDP );
	
	Assert( FCATSystemTable( pgnoFDPShadow ) );
	Assert( PgnoCATTableFDP( szMSOShadow ) == pgnoFDPShadow );
	Assert( pgnoFDPMSOShadow == pgnoFDPShadow );
	Assert( objidFDPMSOShadow == objidFDPShadow );

	CallR( ErrCATICreateCatalogIndexes( ppib, ifmp, &objidNameIndex, &objidRootObjectsIndex ) );

	Call( ErrREPAIRCATCreate( ppib, ifmp, objidNameIndex, objidRootObjectsIndex, fFalse ) );

	err = JET_errSuccess;

HandleError:
	if ( pfucbNil != pfucb )
		{
		DIRClose( pfucb );
		}

	return err;
	}


/*=================================================================
ErrCATInsert

Description:

	Inserts a record into a system table when new tables, indexes, 
	or columns are added to the database.

Parameters:

	PIB		*ppib;
	IFMP   	ifmp;
	INT		itable;
	DATA   	rgdata[];

Return Value:

	whatever error it encounters along the way

=================================================================*/

INLINE ERR ErrCATIInsert(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
	DATA		rgdata[],
	const UINT	iHighestFixedToSet )
	{
	ERR			err;
	TDB			* const ptdbCatalog		= pfucbCatalog->u.pfcb->Ptdb();

	CallR( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepInsert ) );

	//	set highest fixed column first, to eliminate calls to memmove()
	Assert( iHighestFixedToSet > 0 );
	Assert( iHighestFixedToSet < cColumnsMSO );
	Assert( FCOLUMNIDFixed( rgcdescMSO[iHighestFixedToSet].columnid ) );
	Assert( rgdata[iHighestFixedToSet].Cb() > 0 );
	CallS( ErrRECISetFixedColumn(
				pfucbCatalog,
				ptdbCatalog,
				rgcdescMSO[iHighestFixedToSet].columnid,
				rgdata+iHighestFixedToSet ) );

	for ( UINT i = 0; i < cColumnsMSO; i++ )
		{
		if ( rgdata[i].Cb() != 0 )
			{
			Assert( rgdata[i].Cb() > 0 );

			if ( FCOLUMNIDFixed( rgcdescMSO[i].columnid ) )
				{
				Assert( i <= iHighestFixedToSet );
				if ( iHighestFixedToSet != i )
					{
					CallS( ErrRECISetFixedColumn(
								pfucbCatalog,
								ptdbCatalog,
								rgcdescMSO[i].columnid,
								rgdata+i ) );
					}
				}
			else if( FCOLUMNIDVar( rgcdescMSO[i].columnid ) )
				{
				Assert( i != iHighestFixedToSet );
				CallS( ErrRECISetVarColumn(
							pfucbCatalog,
							ptdbCatalog,
							rgcdescMSO[i].columnid,
							rgdata+i ) );
				}
			else
				{
				Assert( FCOLUMNIDTagged( rgcdescMSO[i].columnid ) );
				Assert( i != iHighestFixedToSet );
				//  currently all tagged fields must be Long-Values
				//  call ErrRECISetTaggedColumn if the column isn't
				Assert( rgcdescMSO[i].coltyp == JET_coltypLongText
						|| rgcdescMSO[i].coltyp == JET_coltypLongBinary );
				CallS( ErrRECSetLongField( 
							pfucbCatalog,
							rgcdescMSO[i].columnid,
							0,
							rgdata+i ) );
				}
			}
		}

	/*	insert record into system table
	/**/
	err = ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT );
	if( err < 0 )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepCancel ) );
		}
	return err;
	}

LOCAL ERR ErrCATInsert(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
	DATA		rgdata[],
	const UINT	iHighestFixedToSet )
	{
	ERR			err;

	//	ensure we're in a transaction, so that on failure, updates to both
	//	catalog and its shadow are rolled back
	Assert( ppib->level > 0
		|| rgfmp[pfucbCatalog->ifmp].FCreatingDB() );
	
	CallR( ErrCATIInsert( ppib, pfucbCatalog, rgdata, iHighestFixedToSet ) );

	if ( !rgfmp[pfucbCatalog->u.pfcb->Ifmp()].FShadowingOff() )
		{
		FUCB	*pfucbShadow;
		CallR( ErrCATOpen( ppib, pfucbCatalog->u.pfcb->Ifmp(), &pfucbShadow, fTrue ) );
		Assert( pfucbNil != pfucbShadow );
	
		err = ErrCATIInsert( ppib, pfucbShadow, rgdata, iHighestFixedToSet );

		CallS( ErrCATClose( ppib, pfucbShadow ) );
		}

	return err;
	}


ERR ErrCATAddTable(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const PGNO		pgnoTableFDP,
	const OBJID		objidTable,
	const CHAR		*szTableName,
	const CHAR		*szTemplateTableName,
	const ULONG		ulPages,
	const ULONG		ulDensity,
	const ULONG		ulFlags )
	{
	DATA			rgdata[idataMSOMax];
	const SYSOBJ	sysobj				= sysobjTable;
	const BYTE		bTrue				= 0xff;

	Assert( objidTable > objidSystemRoot );
	
	//	must zero out to ensure unused fields are ignored
	memset( rgdata, 0, sizeof(rgdata) );
	
	rgdata[iMSO_ObjidTable].SetPv( 		(BYTE *)&objidTable );
	rgdata[iMSO_ObjidTable].SetCb(		sizeof(objidTable) );

	rgdata[iMSO_Type].SetPv(			(BYTE *)&sysobj );
	rgdata[iMSO_Type].SetCb(			sizeof(sysobj) );

	rgdata[iMSO_Id].SetPv(				(BYTE *)&objidTable );
	rgdata[iMSO_Id].SetCb(				sizeof(objidTable) );
	
	rgdata[iMSO_Name].SetPv(			(BYTE *)szTableName );
	rgdata[iMSO_Name].SetCb(			strlen(szTableName) );

	rgdata[iMSO_PgnoFDP].SetPv(			(BYTE *)&pgnoTableFDP );
	rgdata[iMSO_PgnoFDP].SetCb(			sizeof(pgnoTableFDP) );

	rgdata[iMSO_SpaceUsage].SetPv(		(BYTE *)&ulDensity );
	rgdata[iMSO_SpaceUsage].SetCb(		sizeof(ulDensity) );

	rgdata[iMSO_Flags].SetPv(			(BYTE *)&ulFlags );
	rgdata[iMSO_Flags].SetCb(			sizeof(ulFlags) );

	rgdata[iMSO_Pages].SetPv(			(BYTE *)&ulPages );
	rgdata[iMSO_Pages].SetCb(			sizeof(ulPages) );
	Assert( 0 == rgdata[iMSO_Stats].Cb() );
	
	rgdata[iMSO_RootFlag].SetPv(		(BYTE *)&bTrue );
	rgdata[iMSO_RootFlag].SetCb(		sizeof(bTrue) );

	if ( NULL != szTemplateTableName )
		{
		rgdata[iMSO_TemplateTable].SetPv( (BYTE *)szTemplateTableName );
		rgdata[iMSO_TemplateTable].SetCb( strlen(szTemplateTableName) );
		}
	else
		{
		Assert( 0 == rgdata[iMSO_TemplateTable].Cb() );
		}

	ERR	err = ErrCATInsert( ppib, pfucbCatalog, rgdata, iMSO_RootFlag );
	if ( JET_errKeyDuplicate == err )
		{
		if ( 0 == strcmp( szTableName, "MSysDefrag1" ) )
			{
			FireWall();
			}
		err = ErrERRCheck( JET_errTableDuplicate );
		}
	
	return err;
	}


ERR ErrCATAddTableColumn(
	PIB					*ppib,
	FUCB				*pfucbCatalog,
	const OBJID			objidTable,
	const CHAR			*szColumnName,
	COLUMNID			columnid,
	const FIELD			*pfield,
	const VOID			*pvDefault,
	const ULONG			cbDefault,
	const CHAR			* const szCallback,
	const VOID			* const pvUserData,
	const ULONG			cbUserData )
	{
	DATA				rgdata[idataMSOMax];
	UINT				iHighestFixedToSet;
	const SYSOBJ		sysobj				= sysobjColumn;
	const JET_COLTYP	coltyp				= pfield->coltyp;
	const ULONG			ulCodePage			= pfield->cp;

	//	filter out flags that shouldn't be persisted
	Assert( !FFIELDDeleted( pfield->ffield ) );
	const ULONG			ulFlags				= ( pfield->ffield & ffieldPersistedMask );

	Assert( objidTable > objidSystemRoot );

	
	//	must zero out to ensure unused fields are ignored
	memset( rgdata, 0, sizeof(rgdata) );

	rgdata[iMSO_ObjidTable].SetPv(		(BYTE *)&objidTable );
	rgdata[iMSO_ObjidTable].SetCb(		sizeof(objidTable) );

	rgdata[iMSO_Type].SetPv(			(BYTE *)&sysobj );
	rgdata[iMSO_Type].SetCb(			sizeof(sysobj) );

	Assert( FCOLUMNIDValid( columnid ) );
	Assert( !FCOLUMNIDTemplateColumn( columnid )
		|| FFIELDTemplateColumnESE98( pfield->ffield ) );
	COLUMNIDResetFTemplateColumn( columnid );
	rgdata[iMSO_Id].SetPv(				(BYTE *)&columnid );
	rgdata[iMSO_Id].SetCb(				sizeof(columnid) );

	rgdata[iMSO_Name].SetPv(			(BYTE *)szColumnName );
	rgdata[iMSO_Name].SetCb(			strlen(szColumnName) );

	rgdata[iMSO_Coltyp].SetPv(			(BYTE *)&coltyp );
	rgdata[iMSO_Coltyp].SetCb(			sizeof(coltyp) );

	rgdata[iMSO_SpaceUsage].SetPv(		(BYTE *)&pfield->cbMaxLen );
	rgdata[iMSO_SpaceUsage].SetCb(		sizeof(pfield->cbMaxLen) );

	rgdata[iMSO_Flags].SetPv(			(BYTE *)&ulFlags );
	rgdata[iMSO_Flags].SetCb(			sizeof(ulFlags) );

	rgdata[iMSO_Localization].SetPv(	(BYTE *)&ulCodePage );
	rgdata[iMSO_Localization].SetCb(	sizeof(ulCodePage) );
	
	rgdata[iMSO_Callback].SetPv(		(BYTE*)szCallback );
	rgdata[iMSO_Callback].SetCb(		( szCallback ? strlen(szCallback) : 0 ) );
	
	rgdata[iMSO_DefaultValue].SetPv(	(BYTE *)pvDefault );
	rgdata[iMSO_DefaultValue].SetCb(	cbDefault );
	
	rgdata[iMSO_CallbackData].SetPv(	(BYTE*)pvUserData );
	rgdata[iMSO_CallbackData].SetCb(	cbUserData );

	if ( FCOLUMNIDFixed( columnid ) )
		{
		Assert( pfield->ibRecordOffset >= ibRECStartFixedColumns );
		rgdata[iMSO_RecordOffset].SetPv( (BYTE *)&pfield->ibRecordOffset );
		rgdata[iMSO_RecordOffset].SetCb( sizeof(pfield->ibRecordOffset) );
		iHighestFixedToSet = iMSO_RecordOffset;
		}
	else
		{
		// Don't need to persist record offsets for var/tagged columns.
		Assert( FCOLUMNIDVar( columnid ) || FCOLUMNIDTagged( columnid ) );
		Assert( 0 == rgdata[iMSO_RecordOffset].Cb() );
		iHighestFixedToSet = iMSO_Localization;
		}
		
	ERR	err = ErrCATInsert( ppib, pfucbCatalog, rgdata, iHighestFixedToSet );
	if ( JET_errKeyDuplicate == err )
		err = ErrERRCheck( JET_errColumnDuplicate );

	return err;
	}


ERR ErrCATAddTableIndex(
	PIB					*ppib,
	FUCB				*pfucbCatalog,
	const OBJID			objidTable,
	const CHAR			*szIndexName,
	const PGNO			pgnoIndexFDP,
	const OBJID			objidIndex,
	const IDB			*pidb,
	const IDXSEG* const	rgidxseg,
	const IDXSEG* const	rgidxsegConditional,
	const ULONG			ulDensity )
	{
	DATA				rgdata[idataMSOMax];
	LE_IDXFLAG			le_idxflag;
	const SYSOBJ		sysobj				= sysobjIndex;

	Assert( objidTable > objidSystemRoot );
	Assert( objidIndex > objidSystemRoot );
	
	//	objids are monotonically increasing, so an index should
	//	always have higher objid than its table
	Assert( ( pidb->FPrimary() && objidIndex == objidTable )
		|| ( !pidb->FPrimary() && objidIndex > objidTable ) );
	
	
	//	must zero out to ensure unused fields are ignored
	memset( rgdata, 0, sizeof(rgdata) );

	rgdata[iMSO_ObjidTable].SetPv(		(BYTE *)&objidTable );
	rgdata[iMSO_ObjidTable].SetCb(		sizeof(objidTable) );

	rgdata[iMSO_Type].SetPv(			(BYTE *)&sysobj );
	rgdata[iMSO_Type].SetCb(			sizeof(sysobj) );

	rgdata[iMSO_Id].SetPv(				(BYTE *)&objidIndex );
	rgdata[iMSO_Id].SetCb(				sizeof(objidIndex) );

	rgdata[iMSO_Name].SetPv(			(BYTE *)szIndexName );
	rgdata[iMSO_Name].SetCb(			strlen(szIndexName) );

	rgdata[iMSO_PgnoFDP].SetPv(			(BYTE *)&pgnoIndexFDP );
	rgdata[iMSO_PgnoFDP].SetCb(			sizeof(pgnoIndexFDP) );

	rgdata[iMSO_SpaceUsage].SetPv(		(BYTE *)&ulDensity );
	rgdata[iMSO_SpaceUsage].SetCb(		sizeof(ulDensity) );

	le_idxflag.fidb = pidb->FPersistedFlags();
	le_idxflag.fIDXFlags = fIDXExtendedColumns;
	
	//	Hack on this field: SetColumn() will convert the fixed
	//	columns. So convert it here so that later it can be
	//	converted back to current value.
	LONG		l			= *(LONG *)&le_idxflag;
	l = ReverseBytesOnBE( l );

	rgdata[iMSO_Flags].SetPv(			(BYTE *)&l );
	rgdata[iMSO_Flags].SetCb(			sizeof(l) );

	LCID		lcid		= pidb->Lcid();
	rgdata[iMSO_Localization].SetPv(	(BYTE *)&lcid );
	rgdata[iMSO_Localization].SetCb(	sizeof(lcid) );

	DWORD		dwMapFlags	= pidb->DwLCMapFlags();
	rgdata[iMSO_LCMapFlags].SetPv(		(BYTE *)&dwMapFlags );
	rgdata[iMSO_LCMapFlags].SetCb(		sizeof(dwMapFlags) );

	BYTE		*pbidxseg;
	LE_IDXSEG	le_rgidxseg[ JET_ccolKeyMost ];
	LE_IDXSEG	le_rgidxsegConditional[ JET_ccolKeyMost ];
	
	if ( FHostIsLittleEndian() )
		{
		pbidxseg = (BYTE *)rgidxseg;

#ifdef DEBUG
		for ( UINT iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
			{
			Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );
			}
#endif			
		}
	else
		{
		for ( UINT iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
			{
			Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );

			//	Endian conversion
			le_rgidxseg[ iidxseg ] = rgidxseg[iidxseg];
			}

		pbidxseg = (BYTE *)le_rgidxseg;
		}

	rgdata[iMSO_KeyFldIDs].SetPv( pbidxseg );
	rgdata[iMSO_KeyFldIDs].SetCb( pidb->Cidxseg() * sizeof(IDXSEG) );

	if ( FHostIsLittleEndian() )
		{
		pbidxseg = (BYTE *)rgidxsegConditional;

#ifdef DEBUG
		for ( UINT iidxseg = 0; iidxseg < pidb->CidxsegConditional(); iidxseg++ )
			{
			//	verify no longer persisting old format
			Assert( FCOLUMNIDValid( rgidxsegConditional[iidxseg].Columnid() ) );
			}
#endif			
		}
	else
		{
		for ( UINT iidxseg = 0; iidxseg < pidb->CidxsegConditional(); iidxseg++ )
			{
			Assert( FCOLUMNIDValid( rgidxsegConditional[iidxseg].Columnid() ) );

			//	Endian conversion
			le_rgidxsegConditional[ iidxseg ] = rgidxsegConditional[iidxseg];
			}
		pbidxseg = (BYTE *)le_rgidxsegConditional;
		}

	rgdata[iMSO_ConditionalColumns].SetPv( 	pbidxseg );
	rgdata[iMSO_ConditionalColumns].SetCb( 	pidb->CidxsegConditional() * sizeof(IDXSEG) );

	UnalignedLittleEndian<USHORT>	le_cbVarSegMac = pidb->CbVarSegMac();
	if ( pidb->CbVarSegMac() < KEY::CbKeyMost( pidb->FPrimary() ) )
		{
		rgdata[iMSO_VarSegMac].SetPv( (BYTE *)&le_cbVarSegMac );
		rgdata[iMSO_VarSegMac].SetCb( sizeof(le_cbVarSegMac) );
		}
	else
		{
		Assert( KEY::CbKeyMost( pidb->FPrimary() == pidb->CbVarSegMac() ) );
		Assert( 0 == rgdata[iMSO_VarSegMac].Cb() );
		}

	LE_TUPLELIMITS	le_tuplelimits;
	if ( pidb->FTuples() )
		{
		le_tuplelimits.le_chLengthMin = pidb->ChTuplesLengthMin();
		le_tuplelimits.le_chLengthMax = pidb->ChTuplesLengthMax();
		le_tuplelimits.le_chToIndexMax = pidb->ChTuplesToIndexMax();

		rgdata[iMSO_TupleLimits].SetPv( (BYTE *)&le_tuplelimits );
		rgdata[iMSO_TupleLimits].SetCb( sizeof(le_tuplelimits) );
		}
	else
		{
		Assert( 0 == rgdata[iMSO_TupleLimits].Cb() );
		}


	ERR	err = ErrCATInsert( ppib, pfucbCatalog, rgdata, iMSO_LCMapFlags );
	if ( JET_errKeyDuplicate == err )
		err = ErrERRCheck( JET_errIndexDuplicate );

	return err;
	}


ERR ErrCATAddTableLV(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	const PGNO		pgnoLVFDP,
	const OBJID		objidLV )
	{
	DATA			rgdata[idataMSOMax];
	const SYSOBJ	sysobj				= sysobjLongValue;
	const ULONG		ulPages				= cpgLVTree;
	const ULONG		ulDensity			= ulFILEDensityMost;
	const ULONG		ulFlagsNil			= 0;

	//	objids are monotonically increasing, so LV should
	//	always have higher objid than its table
	Assert( objidLV > objidTable );
	
	//	must zero out to ensure unused fields are ignored
	memset( rgdata, 0, sizeof(rgdata) );

	rgdata[iMSO_ObjidTable].SetPv(		(BYTE *)&objidTable );
	rgdata[iMSO_ObjidTable].SetCb(		sizeof(objidTable) );

	rgdata[iMSO_Type].SetPv(			(BYTE *)&sysobj );
	rgdata[iMSO_Type].SetCb(			sizeof(sysobj) );

	rgdata[iMSO_Id].SetPv(				(BYTE *)&objidLV );
	rgdata[iMSO_Id].SetCb(				sizeof(objidLV) );

	rgdata[iMSO_Name].SetPv(			(BYTE *)szLVRoot );
	rgdata[iMSO_Name].SetCb(			cbLVRoot );