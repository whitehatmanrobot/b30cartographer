*>* GetClientList() { return _pdaClients; }
    void AddClientToOEMRow(LPCWSTR pszName, CLIENTINFO* pci);
    HRESULT AddKeepUnchanged(CLIENTINFO* pciKeepUnchanged);
    void SetNotEmpty() { _bEmpty = false; }

    // to be used by SetFilterCB
    bool IsEmpty() { return _bEmpty; }

    // to be used by ClientBlock::TransferFromClientPicker
    CLIENTINFO* GetSelectedClient();

    // to be used by ARPFrame when metrics change
    void CalculateWidth();

private:
    static void CALLBACK s_DelayShowCombo(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
    void _DelayShowCombo();
    void _CancelDelayShowCombo();
    bool _NeedsCombo() { return GetClientList()->GetSize() > 1; }
    void _SyncUIActive();
    void _SetStaticText(LPCWSTR pszText);
    void _CheckBlockOK(bool bSelected);

private:
    int                       _iSel;
    CLIENTFILTER              _cf;
    bool                      _bFilledCombo;
    bool                      _bEmpty;
    bool                      _bUIActive;
    bool                      _bBlockedOK;      // did I block the OK button?
    HWND                      _hwndHost;
    DynamicArray<CLIENTINFO*>*_pdaClients;
    Element*                  _peStatic;
    Combobox*                 _peCombo;
    ClientBlock*              _pcb;             // associated client block
public:                                         // manipulated from ClientBlock
    Element*                  _peShowHide;
};

class ClientBlock : public Element
{
    typedef Element super;         // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Property definitions
    static PropertyInfo* ClientTypeProp;
    static PropertyInfo* WindowsClientProp;
    static PropertyInfo* OtherMSClientsProp;
    static PropertyInfo* KeepTextProp;
    static PropertyInfo* KeepMSTextProp;
    static PropertyInfo* PickTextProp;

    // Quick property accessors
    const LPWSTR GetClientTypeString(Value** ppv) DUIQuickGetterInd(GetString(), ClientType, Specified)
    HRESULT SetClientTypeString(LPCWSTR v) DUIQuickSetter(CreateString(v), ClientType)
    const LPWSTR GetWindowsClientString(Value** ppv) DUIQuickGetterInd(GetString(), WindowsClient, Specified)
    HRESULT SetWindowsClientString(LPCWSTR v) DUIQuickSetter(CreateString(v), WindowsClient)
    const LPWSTR GetOtherMSClientsString(Value** ppv) DUIQuickGetterInd(GetString(), OtherMSClients, Specified)
    HRESULT SetOtherMSClientsString(LPCWSTR v) DUIQuickSetter(CreateString(v), OtherMSClients)
    const LPWSTR GetKeepTextString(Value** ppv) DUIQuickGetterInd(GetString(), KeepText, Specified)
    HRESULT SetKeepTextString(LPCWSTR v) DUIQuickSetter(CreateString(v), KeepText)
    const LPWSTR GetKeepMSTextString(Value** ppv) DUIQuickGetterInd(GetString(), KeepMSText, Specified)
    HRESULT SetKeepMSTextString(LPCWSTR v) DUIQuickSetter(CreateString(v), KeepMSText)
    const LPWSTR GetPickTextString(Value** ppv) DUIQuickGetterInd(GetString(), PickText, Specified)
    HRESULT SetPickTextString(LPCWSTR v) DUIQuickSetter(CreateString(v), PickText)

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    // overrides
    HRESULT Initialize();
    ~ClientBlock();

    // post-parse initialization
    HRESULT ParseCompleted(ARPFrame* paf);
    HRESULT AddStaticClientInfoToTop(PropertyInfo* ppi);
    HRESULT InitializeClientPicker(ClientPicker* pcp);
    HRESULT TransferFromClientPicker(ClientPicker* pcp);

    // doing actual work
    HRESULT Apply(ARPFrame* paf);

private:
    void _EnableShowCheckbox(Element* peRadio, bool fEnable);

    enum CBTIER {           // clients fall into one of these three tiers
        CBT_NONMS,          // third-party client
        CBT_MS,             // Microsoft client but not Windows default
        CBT_WINDOWSDEFAULT, // Windows default client
    };
    inline bool IsThirdPartyClient(CBTIER cbt) { return cbt == CBT_NONMS; }
    inline bool IsMicrosoftClient(CBTIER cbt) { return cbt >= CBT_MS; }
    inline bool IsWindowsDefaultClient(CBTIER cbt) { return cbt == CBT_WINDOWSDEFAULT; }

    CBTIER _GetClientTier(LPCTSTR pszClient);
    TRIBIT _GetFilterShowAdd(CLIENTINFO* pci, ClientPicker* pcp, bool* pbAdd);

    HKEY _OpenClientKey(HKEY hkRoot = HKEY_LOCAL_MACHINE, DWORD dwAccess = KEY_READ);
    bool _GetDefaultClient(HKEY hkClient, HKEY hkRoot, LPTSTR pszBuf, LONG cchBuf);
    bool _IsCurrentClientNonWindowsMS();
    void _RemoveEmptyOEMRow(Element* peShowHide, LPCWSTR pszName);

private:
    DynamicArray<CLIENTINFO*>*  _pdaClients;
    StringList                  _slOtherMSClients;
    Selector*                   _peSel;
};

class Expandable : public Element
{
    typedef Element super;         // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Everything inherits from Element; we just have a new property

    // Property definitions
    static PropertyInfo* ExpandedProp;

    // Quick property accessors
    bool GetExpanded()          DUIQuickGetter(bool, GetBool(), Expanded, Specified)
    HRESULT SetExpanded(bool v) DUIQuickSetter(CreateBool(v), Expanded)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
};

class Expando : public Expandable
{
    typedef Expandable super;       // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Event types
    static UID Click; // no parameters

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    HRESULT Initialize();
    Clipper* GetClipper();

private:
    void FireClickEvent();

private:
    bool        _fExpanding;
};


class Clipper: public Expandable
{
    typedef Expandable super;       // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Self-layout methods
    void _SelfLayoutDoLayout(int dWidth, int dHeight);
    SIZE _SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    HRESULT Initialize();

private:
};

class AutoButton : public Button
{
    typedef Button super;           // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    // misc public stuff
    void SyncDefAction();

private:
};

class GradientLine : public Element
{
    typedef Element super;         // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Everything inherits from Element
    // We use the foreground as the center color
    // and the background as the edge color

    // Rendering callbacks
    void Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

private:
    COLORREF GetColorProperty(PropertyInfo* ppi);
};

class BigElement : public Element
{
    typedef Element super;         // name for our superclass
public:
    static HRESULT Create(OUT Element** ppElement);

    // Everything inherits from Element; we just have a new property

    // Property definitions
    static PropertyInfo* StringResIDProp;

    // Quick property accessors
    int GetStringResID()            DUIQuickGetter(int, GetInt(), StringResID, Specified)
    HRESULT SetStringResID(int ids) DUIQuickSetter(CreateInt(ids), StringResID)

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
};

class ARPParser : public Parser
{
public:
    static HRESULT Create(ARPFrame* paf, UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);
    HRESULT Initialize(ARPFrame* paf, UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB);

    virtual Value* GetSheet(LPCWSTR pszResID);

private:
    ARPFrame* _paf;
    HANDLE    _arH[2];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\awthunk.c ===
#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM


//============================================================================
// This file contains a bunch of Unicode/Ansi thunks to handle calling
// some internal functions that on Windows 95 the strings are Ansi,
// whereas the string on NT are unicode
//============================================================================

#define PFN_FIRSTTIME   ((void *)-1)

// First undefine everything that we are intercepting as to not forward back to us...
#undef SHGetSpecialFolderPath



// Explicit prototype because only the A/W prototypes exist in the headers
STDAPI_(BOOL) SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR lpszPath, int nFolder, BOOL fCreate);

typedef BOOL (WINAPI * PFNGETSPECIALFOLDERPATH)(HWND hwndOwner, LPTSTR pwszPath, int nFolder, BOOL fCreate); 

BOOL _AorW_SHGetSpecialFolderPath(HWND hwndOwner, /*OUT*/ LPTSTR pszPath, int nFolder, BOOL fCreate)
{
    // The classic shell exported a non-decorated SHGetSpecialFolderPath
    // that took TCHAR parameters.  The IE4 shell exported additional
    // decorated versions.  Try to use the explicit decorated versions if
    // we can.
    
    static PFNGETSPECIALFOLDERPATH s_pfn = PFN_FIRSTTIME;

    *pszPath = 0;
    
    if (PFN_FIRSTTIME == s_pfn)
    {
        HINSTANCE hinst = LoadLibraryA("SHELL32.DLL");
        if (hinst)
        {
#ifdef UNICODE 
            s_pfn = (PFNGETSPECIALFOLDERPATH)GetProcAddress(hinst, "SHGetSpecialFolderPathW");
#else
            s_pfn = (PFNGETSPECIALFOLDERPATH)GetProcAddress(hinst, "SHGetSpecialFolderPathA");
#endif
        }
        else
            s_pfn = NULL;
    }

    if (s_pfn)
    {
        return s_pfn(hwndOwner, pszPath, nFolder, fCreate);
    }
    else
    {
        return SHGetSpecialFolderPath(hwndOwner, pszPath, nFolder, fCreate);
    }
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\cctl.cpp ===
//  CCtl.CPP
//
//      Implementation of the control
//
//  Created 17-Apr-98 [JonT]

#include "priv.h"
#include "resource.h"
#include "cctl.h"
#include "util.h"
#include "dump.h"       // for Dbg_* functions


//--------------------------------------------------------------------
//
//
//  CARPCtl class
//
//
//--------------------------------------------------------------------


// ARPCtlEnumCB
//      Callback for EnumAppItems that adds the appdata item to
//      the array.

void CALLBACK ARPCtlEnumCB(CAppData * pcad, LPARAM lParam)
{
    ((CARPCtl *)lParam)->EnumCallback(pcad);
}


//--------------------------------------------------------------------
// Methods


// CARPCtl::EnumCallback
//      EnumAppItems callback for the ARPCtl.

void CARPCtl::EnumCallback(CAppData * pcad)
{
    switch (_dwEnum)
    {
    case ENUM_INSTALLED:
    case ENUM_PUBLISHED:    
    case ENUM_OCSETUP:    
        if (S_OK == _pmtxarray->AddItem(pcad, NULL))
        {
            _dwcItems++;
            TraceMsg(TF_CTL, "ARP: Added item \"%s\" to list", pcad->GetData()->pszDisplayName);

            // Fire the event saying the new row is ready.
            // Note that this has to be AFTER we increment so that
            // the ItemCount property will be correct at this point.
            Fire_OnRowReady(_dwcItems - 1);
        }
        break;

    case ENUM_CATEGORIES:
        if (S_OK == _pmtxarray->AddItem(pcad, NULL))
        {
            _dwcItems++;
            TraceMsg(TF_CTL, "ARP: Added item \"%s\" to list", pcad->GetCategory());

            // Fire the event saying the new row is ready.
            // Note that this has to be AFTER we increment so that
            // the ItemCount property will be correct at this point.
            Fire_OnRowReady(_dwcItems - 1);
        }
        break;
    }
}


//  CARPCtl::InitData
//      Script tells the control to get data from the app management object
//      and which order to sort in.
//
//      bstrEnum can be:
//          "installed" - enumerate currently installed apps.
//          ""          - ditto.
//          "published" - enumerate published apps.
//          "categories" - enumerate published categories.

STDMETHODIMP
CARPCtl::InitData(
    BSTR bstrEnum,
    DWORD dwSortOrder
    )
{
    HRESULT hres = S_FALSE;

    // Determine what we're enumerating
    _dwEnum = ENUM_INSTALLED;               // default value
    if (0 == lstrcmpiW(bstrEnum, L"published"))
        _dwEnum = ENUM_PUBLISHED;
    else if (0 == lstrcmpiW(bstrEnum, L"categories"))
        _dwEnum = ENUM_CATEGORIES;
    else if (0 == lstrcmpiW(bstrEnum, L"ocsetup"))
        _dwEnum = ENUM_OCSETUP;

        
    // Load the app manager if we haven't already
    if (_pam == NULL)
    {
        if (FAILED(CoCreateInstance(CLSID_ShellAppManager, NULL,
            CLSCTX_INPROC, IID_IShellAppManager, (void**)&_pam)))
        {
            TraceMsg(TF_ERROR, "Couldn't instantiate ShellAppManager object");
            return S_FALSE;
        }
    }

    // Make sure the worker thread isn't already running. Stop it if it is.
    _workerthread.Kill();

    // If we already have a list, nuke it
    _FreeAppData();

    // Now create the new list
    _pmtxarray = new CMtxArray2(_dwEnum);
    if (_pmtxarray)
    {
        // Start enumerating items
        hres = EnumAppItems(_dwEnum, _pam, ARPCtlEnumCB, (LPARAM)this);

        // Did the enumeration succeed?
        if (SUCCEEDED(hres))
        {
            // Yes; tell the script we're done getting the synchronous data
            
            // This call is synchronous and does not return until the script 
            // is finished responding.  This seems like a bug in Trident.
            Fire_OnSyncDataReady();

            // We only get slow info for the installed apps
            if (ENUM_INSTALLED == _dwEnum)
            {
                // Create and kick off the worker thread
                hres = _workerthread.Initialize(SAFECAST(this, IWorkerEvent *), _pmtxarray);
            }
        }
    }

    // Can't return failure to script
    if (FAILED(hres))
        hres = S_FALSE;
        
    return hres;
}


//  CARPCtl::MoveFirst
//      Script tells control to move to the first item in the list.
//      Returns false if there are no items.

STDMETHODIMP
CARPCtl::MoveFirst(
    BOOL* pbool
    )
{
    // Set our current index to the start
    _dwCurrentIndex = 0;

    // Return TRUE iff we are pointing to a valid item
    *pbool = _dwCurrentIndex >= _dwcItems ? FALSE : TRUE;

    return S_OK;
}


//  CARPCtl::MoveNext
//      Script tells control to move to the next item in the curren tlist.
//      Returns false if off the end of the list.

STDMETHODIMP
CARPCtl::MoveNext(
    BOOL* pbool
    )
{
    _dwCurrentIndex++;

    // Return TRUE iff we are pointing to a valid item
    *pbool = _dwCurrentIndex >= _dwcItems ? FALSE : TRUE;

    return S_OK;
}


//  CARPCtl::MoveTo
//      Tells the control to move to a specific item

STDMETHODIMP
CARPCtl::MoveTo(
    DWORD dwRecNum,
    BOOL* pbool
    )
{
    // If they want to go past the end, fail it and don't move the pointer
    if (dwRecNum >= _dwcItems)
    {
        *pbool = FALSE;
        return S_OK;
    }

    // Update the pointer and return success
    _dwCurrentIndex = dwRecNum;
    *pbool = TRUE;
    return S_OK;
}


//  CARPCtl::Exec
//      Tells the control to exec a command.  The command may act
//      upon the current record.

STDMETHODIMP
CARPCtl::Exec(
    BSTR bstrCmd
    )
{
    TraceMsg(TF_CTL, "(Ctl) Command (%ls) called", bstrCmd);

#ifdef NOTYET    
    // security check must pass before we could exec anything. 
    if (!_fSecure)
    {
        TraceMsg(TF_CTL, "(Ctl) Security blocked Exec call");
        return S_FALSE;        // scripting methods cannot return failure
    }
#endif    
    
    const static struct {
        LPCWSTR pszCmd;
        APPCMD  appcmd;
    } s_rgCmds[] = {
        { L"install",           APPCMD_INSTALL },
        { L"uninstall",         APPCMD_UNINSTALL },
        { L"modify",            APPCMD_MODIFY },
        { L"upgrade",           APPCMD_UPGRADE },
        { L"repair",            APPCMD_REPAIR },
        { L"generic install",   APPCMD_GENERICINSTALL },
        { L"ntoptions",         APPCMD_NTOPTIONS },
        { L"winupdate",         APPCMD_WINUPDATE },
    };

    int i;
    APPCMD appcmd = APPCMD_UNKNOWN;

    for (i = 0; i < ARRAYSIZE(s_rgCmds); i++)
    {
        if (0 == StrCmpIW(bstrCmd, s_rgCmds[i].pszCmd))
        {
            appcmd = s_rgCmds[i].appcmd;
            break;
        }
    }

    switch (appcmd)
    {
        case APPCMD_INSTALL:
        case APPCMD_UNINSTALL:
        case APPCMD_MODIFY:
        case APPCMD_UPGRADE:
        case APPCMD_REPAIR:
            {
                CAppData * pappdata = _GetAppData(_dwCurrentIndex);
                if (pappdata)
                    pappdata->DoCommand(appcmd);
            }
            break;

        case APPCMD_GENERICINSTALL:
            InstallAppFromFloppyOrCDROM(NULL);
            break;

        case APPCMD_NTOPTIONS:
            // command to invoke and OCMgr
            // "sysocmgr /x /i:%systemroot%\system32\sysoc.inf"
            TCHAR szInf[MAX_PATH];
            if (GetSystemDirectory(szInf, ARRAYSIZE(szInf)) && PathCombine(szInf, szInf, TEXT("sysoc.inf")))
            {
                TCHAR szParam[MAX_PATH];
                wsprintf(szParam, TEXT("/x /i:%s"), szInf);
                ShellExecute(NULL, NULL, TEXT("sysocmgr"), szParam, NULL, SW_SHOWDEFAULT);
            }
            break;

        case APPCMD_WINUPDATE:
            break;

        case APPCMD_UNKNOWN:
            TraceMsg(TF_ERROR, "(Ctl) Received invalid appcmd %ls", bstrCmd);
            break;
    }
        
    return S_OK;
}


//  IWorkerEvent::FireOnDataReady
//      Called by worker thread when some data is ready.

STDMETHODIMP 
CARPCtl::FireOnDataReady(
    LONG iRow
    )
{
    Fire_OnAsyncDataReady(iRow);
    return S_OK;
}


//  IWorkerEvent::FireOnFinished
//      Called by worker thread when it is complete.

STDMETHODIMP 
CARPCtl::FireOnFinished(void)
{
    return S_OK;
}





//--------------------------------------------------------------------
//  Properties

// SIMPLE_PROPERTY_GET
//
//  Defines a simple property get method so that we don't type the same
//  code over and over. It only works for strings copied from the APPINFODATA
//  structure.
//
//  This keeps the code cleaned up. but doesn't help
//  with the code bloat, so a better approach would be great.

#define SIMPLE_PROPERTY_GET(PropName)                                       \
STDMETHODIMP                                                                \
CARPCtl::get_##PropName##(BSTR* pbstr)                                      \
{                                                                           \
    USES_CONVERSION;                                                        \
                                                                            \
    if (_dwCurrentIndex >= _dwcItems)                                       \
        return E_FAIL;                                                      \
                                                                            \
    CAppData * pappdata = _GetAppData(_dwCurrentIndex);                     \
    if (pappdata)                                                           \
    {                                                                       \
        APPINFODATA * paidata = pappdata->GetData();                        \
                                                                            \
        ASSERT(NULL == paidata->psz##PropName || IS_VALID_STRING_PTRW(paidata->psz##PropName, -1)); \
                                                                            \
        *pbstr = W2BSTR(paidata->psz##PropName);                            \
    }                                                                       \
    else                                                                    \
        *pbstr = NULL;                                                      \
                                                                            \
    return S_OK;                                                            \
}

// TODO: Since this is big code bloat, make sure we really need all these...

SIMPLE_PROPERTY_GET(Version)
SIMPLE_PROPERTY_GET(Publisher)
SIMPLE_PROPERTY_GET(ProductID)
SIMPLE_PROPERTY_GET(RegisteredOwner)
SIMPLE_PROPERTY_GET(Language)
SIMPLE_PROPERTY_GET(SupportUrl)
SIMPLE_PROPERTY_GET(SupportTelephone)
SIMPLE_PROPERTY_GET(HelpLink)
SIMPLE_PROPERTY_GET(InstallLocation)
SIMPLE_PROPERTY_GET(InstallSource)
SIMPLE_PROPERTY_GET(InstallDate)
SIMPLE_PROPERTY_GET(RequiredByPolicy)
SIMPLE_PROPERTY_GET(Contact)

// DisplayName
//      The display name of the item.

STDMETHODIMP
CARPCtl::get_DisplayName(BSTR* pbstr)
{
    USES_CONVERSION;
    CAppData * pappdata;

    if (_dwCurrentIndex >= _dwcItems)
        return E_FAIL;

    pappdata = _GetAppData(_dwCurrentIndex);
    if (pappdata)
    {
        if (ENUM_CATEGORIES == _dwEnum)
        {
            *pbstr = W2BSTR(pappdata->GetCategory());
        }
        else
        {
            *pbstr = W2BSTR(pappdata->GetData()->pszDisplayName);
        }
    }
    else
        *pbstr = NULL;
    
    return S_OK;
}

//  Size
//      The calculated size of the application. Returns "Unknown" if not available

STDMETHODIMP
CARPCtl::get_Size(BSTR* pbstr)
{
    USES_CONVERSION;
    TCHAR szSize[256];
    ULONG ulSize = 0;
    LPTSTR WINAPI ShortSizeFormat(DWORD dw, LPTSTR szBuf);
    CAppData * pappdata;

    if (_dwCurrentIndex >= _dwcItems)
        return E_FAIL;

    // Get the size and truncate to a ULONG. If the app is bigger than 4G,
    // well, too bad.
    pappdata = _GetAppData(_dwCurrentIndex);
    if (pappdata)
        ulSize = (ULONG)pappdata->GetSlowData()->ullSize;

    // If the size is zero, return unknown, otherwise,
    // Use the shell32 function to make a nicely formatted size string
    if (ulSize == 0)
        LoadString(g_hinst, IDS_UNKNOWN, szSize, ARRAYSIZE(szSize));
    else
        ShortSizeFormat(ulSize, szSize);

    // Return as a BSTR
    *pbstr = W2BSTR(szSize);
    return S_OK;
}


//  TimesUsed
//      Returns the number of times used for this item

STDMETHODIMP
CARPCtl::get_TimesUsed(BSTR* pbstr)
{
    USES_CONVERSION;
    int ncUsed = 0;
    WCHAR szUsed[256];
    CAppData * pappdata;

    if (_dwCurrentIndex >= _dwcItems)
        return E_FAIL;

    pappdata = _GetAppData(_dwCurrentIndex);
    if (pappdata)
        ncUsed = pappdata->GetSlowData()->iTimesUsed;

    // Convert to a BSTR
    wsprintf(szUsed, TEXT("%d"), ncUsed);
    *pbstr = W2BSTR(szUsed);
    return S_OK;
}


//  LastUsed
//      Returns last date the app was used

STDMETHODIMP
CARPCtl::get_LastUsed(BSTR* pbstr)
{
    USES_CONVERSION;
    FILETIME ft = {0};
    WCHAR szDate[256];
    CAppData * pappdata;

    if (_dwCurrentIndex >= _dwcItems)
        return E_FAIL;

    pappdata = _GetAppData(_dwCurrentIndex);
    if (pappdata)
        ft = pappdata->GetSlowData()->ftLastUsed;

    // Convert to a BSTR
    FileTimeToDateTimeString(&ft, szDate, SIZECHARS(szDate));
    *pbstr = W2BSTR(szDate);
    return S_OK;
}


//  Capability
//      Flags that indicate the possible actions that can
//      be performed on the item.  See APPACTION_* flags.

STDMETHODIMP
CARPCtl::get_Capability(long * pVal)
{
    CAppData * pappdata;
    
    if (_dwCurrentIndex >= _dwcItems)
        return E_FAIL;

    pappdata = _GetAppData(_dwCurrentIndex);
    if (pappdata)
        *pVal = pappdata->GetCapability();
    else
        *pVal = 0;

    return S_OK;
}




//  ItemCount
//      Number of items in current list

STDMETHODIMP
CARPCtl::get_ItemCount(long * pVal)
{
    *pVal = _dwcItems;

    return S_OK;
}


//--------------------------------------------------------------------
// Object lifetime stuff

//  CARPCtl constructor

CARPCtl::CARPCtl()
{
    ASSERT(NULL == _pmtxarray);
    ASSERT(NULL == _pam);
}

// CARPCtl destructor

CARPCtl::~CARPCtl()
{
    // Kill the worker thread if it's still around
    _workerthread.Kill();

    // Free our contained object
    ATOMICRELEASE(_pam);

    // Clean up the application list
    _FreeAppData();
}


//--------------------------------------------------------------------
// Private methods


//  CARPCtl::_GetAppData
//      Returns the appdata of the current record, or NULL if there
//      is no such record.

CAppData *
CARPCtl::_GetAppData(DWORD iItem)
{
    CAppData * pappdata = NULL;

    if (_pmtxarray && iItem < _dwcItems)
        pappdata = _pmtxarray->GetAppData(iItem);
        
    return pappdata;
}


//  CARPCtl::_FreeAppData
//      Frees all memory associated with the application

void
CARPCtl::_FreeAppData()
{
    if (_pmtxarray)
    {
        delete _pmtxarray;
        _pmtxarray = NULL;
    }
    _dwcItems = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\arp.cpp ===
// ARP.cpp : Add Remove Programs
//
#include "priv.h"
#define GADGET_ENABLE_TRANSITIONS

// Related services
#include <duser.h>
#include <directui.h>
#include "stdafx.h"
#include "appwizid.h"
#include "resource.h"

#include <winable.h>            // BlockInput
#include <process.h>            // Multi-threaded routines
#include "setupenum.h"
#include <tsappcmp.h>           // for TermsrvAppInstallMod
#include <comctrlp.h>           // for DPA stuff
#include "util.h"
#include <xpsp1res.h>
#include <shstyle.h>

using namespace DirectUI;

UsingDUIClass(Element);
UsingDUIClass(Button);
UsingDUIClass(RepeatButton);    // used by ScrollBar
UsingDUIClass(Thumb);           // used by ScrollBar
UsingDUIClass(ScrollBar);       // used by ScrollViewer
UsingDUIClass(Selector);
UsingDUIClass(HWNDElement);
UsingDUIClass(ScrollViewer);
UsingDUIClass(Combobox);

#include "shappmgrp.h"

#include "arp.h"

#define HRCHK(r)  if (FAILED(r)) goto Cleanup;

// Primary thread run flag
bool g_fRun = true;

// Appliction shutting down after run flag goes false
bool g_fAppShuttingDown = false;

// Service Pack resource DLL
HINSTANCE g_hinstSP1;

void CALLBACK ARPParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine);

inline void StrFree(LPWSTR psz)
{
    CoTaskMemFree(psz); // CoTaskMemFree handles NULL parameter
}

// Need this weirdo helper function to avoid compiler complaining that
// "bool is smaller than LPARAM, you're truncating!"  Do this only if
// you know that the LPARAM came from a bool originally.

bool UNCASTLPARAMTOBOOL(LPARAM lParam)
{
    return (bool&)lParam;
}

extern "C" void inline SetElementAccessability(Element* pe, bool bAccessible, int iRole, LPCWSTR pszAccName);

//  Client names are compared in English to avoid weirdness
//  with collation rules of certain languages.
inline bool AreEnglishStringsEqual(LPCTSTR psz1, LPCTSTR psz2)
{
    return CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, psz1, -1, psz2, -1) == CSTR_EQUAL;
}

//
//  Set the default action based on a resource ID in oleacc.
//

HRESULT SetDefAction(Element* pe, UINT oleacc)
{
    WCHAR szBuf[80];
    if (!GetRoleTextW(oleacc, szBuf, DUIARRAYSIZE(szBuf)))
    {
        szBuf[0] = TEXT('\0');
    }
    return pe->SetAccDefAction(szBuf);
}

////////////////////////////////////////////////////////
//  Tree traversal upwards
//

Element* _FindAncestorElement(Element* pe, IClassInfo* Class)
{
    while (pe && !pe->GetClassInfo()->IsSubclassOf(Class))
    {
        pe = pe->GetParent();
    }
    return pe;
}

template<class T>
T* FindAncestorElement(Element *pe)
{
    return (T*)_FindAncestorElement(pe, T::Class);
}

////////////////////////////////////////////////////////
//  Tree traversal downwards
//

typedef HRESULT (CALLBACK *_TRAVERSETREECB)(Element*, LPARAM);

//
//  _TraverseTree is the worker function for TraverseTree<T>.

HRESULT _TraverseTree(Element* pe, IClassInfo* Class, _TRAVERSETREECB lpfnCB, LPARAM lParam)
{
    HRESULT hr = S_OK;
    Value* pv;

    if (pe->GetClassInfo()->IsSubclassOf(Class)) {
        hr = lpfnCB(pe, lParam);
    }

    if (SUCCEEDED(hr))
    {
        ElementList* peList = pe->GetChildren(&pv);

        if (peList)
        {
            Element* peChild;
            for (UINT i = 0; SUCCEEDED(hr) && i < peList->GetSize(); i++)
            {
                peChild = peList->GetItem(i);
                hr = _TraverseTree(peChild, Class, lpfnCB, lParam);
            }

            pv->Release();
        }
    }

    return hr;
}


//  TraverseTree<T> walks the tree starting at pe and calls the callback
//  for each element of type T.  T is inferred from the callback function,
//  but for readability, it is suggested that you state it explicitly.
//
//  Callback should return S_OK to continue enumeration or a COM error
//  to stop enumeration, in which case the COM error code is returned as
//  the return value from TraverseTree.
//

template <class T>
HRESULT TraverseTree(Element* pe,
                     HRESULT (CALLBACK *lpfnCB)(T*, LPARAM), LPARAM lParam = 0)
{
    return _TraverseTree(pe, T::Class, (_TRAVERSETREECB)lpfnCB, lParam);
}

////////////////////////////////////////////////////////
//
//  When chunks of the tree go UI-inactive, you must manually
//  enable and disable accessibility on them.


HRESULT DisableElementAccessibilityCB(Element* pe, LPARAM)
{
    pe->SetAccessible(false);
    return S_OK;
}

HRESULT CheckAndEnableElementAccessibilityCB(Element* pe, LPARAM)
{
    if ( 0 != pe->GetAccRole())
    {
        pe->SetAccessible(true);
    }
    return S_OK;
}

void DisableElementTreeAccessibility(Element* pe)
{
    TraverseTree(pe, DisableElementAccessibilityCB);
}

void EnableElementTreeAccessibility(Element* pe)
{
    TraverseTree(pe, CheckAndEnableElementAccessibilityCB);
}

HRESULT DisableElementShortcutCB(Element* pe, LPARAM)
{
    pe->SetShortcut(0);
    return S_OK;
}

// When a tree is hidden or removed from layout permanently (due to
// restriction), we also have to remove all keyboard shortcuts so the
// user doesn't have a backdoor.
//
void DisableElementTreeShortcut(Element* pe)
{
    pe->SetVisible(false);
    TraverseTree(pe, DisableElementShortcutCB);
}

////////////////////////////////////////////////////////
//
// Locates resources in g_hinstSP1
//
////////////////////////////////////////////////////////

HRESULT FindSPResource(UINT id, LPCSTR* ppszData, int* pcb)
{
    HRESULT hr = E_FAIL;

    HRSRC hrsrc = FindResource(g_hinstSP1, MAKEINTRESOURCE(id), RT_RCDATA);
    if (hrsrc)
    {
        *ppszData = (LPCSTR)LoadResource(g_hinstSP1, hrsrc);
        if (*ppszData)
        {
            *pcb = SizeofResource(g_hinstSP1, hrsrc);
            hr = S_OK;
        }
    }
    return hr;
}

////////////////////////////////////////////////////////
// ARPFrame class
////////////////////////////////////////////////////////

// ARPFrame IDs (for identifying targets of events)
ATOM ARPFrame::_idChange = 0;
ATOM ARPFrame::_idAddNew = 0;
ATOM ARPFrame::_idAddRmWin = 0;
ATOM ARPFrame::_idClose = 0;
ATOM ARPFrame::_idAddFromDisk = 0;
ATOM ARPFrame::_idAddFromMsft = 0;
ATOM ARPFrame::_idComponents = 0;
ATOM ARPFrame::_idSortCombo = 0;
ATOM ARPFrame::_idCategoryCombo = 0;
ATOM ARPFrame::_idAddFromCDPane = 0;
ATOM ARPFrame::_idAddFromMSPane = 0;
ATOM ARPFrame::_idAddFromNetworkPane = 0;
ATOM ARPFrame::_idAddWinComponent = 0;
ATOM ARPFrame::_idPickApps = 0;
ATOM ARPFrame::_idOptionList = 0;

HANDLE ARPFrame::htPopulateInstalledItemList = NULL;
HANDLE ARPFrame::htPopulateAndRenderOCSetupItemList = NULL;    
HANDLE ARPFrame::htPopulateAndRenderPublishedItemList = NULL;

ARPFrame::~ARPFrame()
{
    UINT i;

    if (_psacl)
    {
        for (i = 0; i < _psacl->cCategories; i++)
        {
           if (_psacl->pCategory[i].pszCategory)
           {
               StrFree(_psacl->pCategory[i].pszCategory);
           }
        }
        delete _psacl;
    }

    if (_pParserStyle)
        _pParserStyle->Destroy();
    
    // Close theme handles (if applicable)
    for (i = FIRSTHTHEME; i <= LASTHTHEME; i++)
    {
        if (_arH[i])
            CloseThemeData(_arH[i]);
    }

    if (_arH[SHELLSTYLEHINSTANCE])
    {
        FreeLibrary((HMODULE)_arH[SHELLSTYLEHINSTANCE]);
    }

    EndProgressDialog();
}

HRESULT ARPFrame::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT ARPFrame::Create(NativeHWNDHost* pnhh, bool fDblBuffer, OUT Element** ppElement)
{
    *ppElement = NULL;

    ARPFrame* paf = HNewAndZero<ARPFrame>();
    if (!paf)
        return E_OUTOFMEMORY;

    HRESULT hr = paf->Initialize(pnhh, fDblBuffer);
    if (FAILED(hr))
    {
        paf->Destroy();
        return hr;
    }

    *ppElement = paf;

    return S_OK;
}

HRESULT ARPFrame::Initialize(NativeHWNDHost* pnhh, bool fDblBuffer)
{
    // Initialize
    _pnhh = pnhh;
    _bDoubleBuffer = fDblBuffer;
    _pParserStyle = NULL;
    ZeroMemory(_arH, sizeof(_arH));
    _fThemedStyle = FALSE;
    _pParserStyle = NULL;
    _hdsaInstalledItems = NULL;
    _hdsaPublishedItems = NULL;
    _bAnimationEnabled = true;

    if (IsOS(OS_TERMINALSERVER))
    {
        _bTerminalServer = true;
    }
    else
    {
        _bTerminalServer = false;
    }

    // Do base class initialization
    HRESULT hr = HWNDElement::Initialize(pnhh->GetHWND(), fDblBuffer, 0);
    if (FAILED(hr))
        return hr;

    CurrentSortType = SORT_NAME;

    hr = CreateStyleParser(&_pParserStyle);

    if (FAILED(hr) || !_pParserStyle || _pParserStyle->WasParseError())
        return hr;

    ManageAnimations();

    return S_OK;
}

HRESULT ARPFrame::CreateStyleParser(Parser** ppParser)
{
    HRESULT hr;

    // We always need these two
    _arH[THISDLLHINSTANCE] = g_hinst; // Default HINSTANCE
    _arH[XPSP1HINSTANCE] = g_hinstSP1; // Alternate HINSTANCE

    // And this one
    if (_arH[SHELLSTYLEHINSTANCE])
    {
        FreeLibrary((HMODULE)_arH[SHELLSTYLEHINSTANCE]);
    }
    _arH[SHELLSTYLEHINSTANCE] = SHGetShellStyleHInstance();

    UINT uidRes;

    // Store style and theme information
    // We cannot trust IsAppThemed() or IsThemeActive() because WindowBlinds
    // patches them to return hard-coded TRUE.  If we trusted it, then
    // we would think that we're using a theme-enabled shellstyle.dll and
    // fail when we try to load resources out of it.  Instead, sniff
    // the DLL to see if it has a control panel watermark bitmap.

    if (FindResource((HMODULE)_arH[SHELLSTYLEHINSTANCE],
                     MAKEINTRESOURCE(IDB_CPANEL_WATERMARK), RT_BITMAP))
    {
        _fThemedStyle = TRUE;
        // Populate handle list for theme style parsing
        _arH[BUTTONHTHEME] = OpenThemeData(GetHWND(), L"Button");
        _arH[SCROLLBARHTHEME] = OpenThemeData(GetHWND(), L"Scrollbar");
        _arH[TOOLBARHTHEME] = OpenThemeData(GetHWND(), L"Toolbar");
        uidRes = IDR_APPWIZ_ARPSTYLETHEME;
    }
    else
    {
        _fThemedStyle = FALSE;
        uidRes = IDR_APPWIZ_ARPSTYLESTD;
    }

    LPCSTR pszData;
    int cbData;

    hr = FindSPResource(uidRes, &pszData, &cbData);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = Parser::Create(pszData, cbData, _arH, ARPParseError, ppParser);
    return hr;
}

extern "C" DWORD _cdecl ARPIsRestricted(LPCWSTR pszPolicy);
extern "C" bool _cdecl ARPIsOnDomain();

//  Handy helper functions.

// Finds a descendent and asserts if not found.

Element* FindDescendentByName(Element* peRoot, LPCWSTR pszName)
{
    Element* pe = peRoot->FindDescendent(StrToID(pszName));
    DUIAssertNoMsg(pe);
    return pe;
}

// Finds a descendent but doesn't complain if not found.

Element* MaybeFindDescendentByName(Element* peRoot, LPCWSTR pszName)
{
    Element* pe = peRoot->FindDescendent(StrToID(pszName));
    return pe;
}

HRESULT _SendParseCompleted(ClientBlock* pcb, LPARAM lParam)
{
    return pcb->ParseCompleted((ARPFrame*)lParam);
}

// Initialize IDs and hold parser, called after contents are filled
bool ARPFrame::Setup(Parser* pParser, int uiStartPane)
{
    WCHAR szTemp[1024];

    _pParser = pParser;
    if (uiStartPane >= 0 && uiStartPane <= 3)
    {
        _uiStartPane = uiStartPane;
    }

    //
    //  DUI's parser doesn't support handlemap()s in rcchar so we have
    //  to do it manually.
    //
    LoadString(g_hinstSP1, IDS_APPWIZ_SHORTCUTPICKAPPS, szTemp, DUIARRAYSIZE(szTemp));
    FindDescendentByName(this, L"pickappsshortcut")->SetShortcut(szTemp[0]);

    // Initialize ID cache
    _idChange = StrToID(L"change");
    _idAddNew = StrToID(L"addnew");
    _idAddRmWin = StrToID(L"addrmwin");
    _idClose = StrToID(L"close");
    _idAddFromDisk = StrToID(L"addfromdisk");
    _idAddFromMsft = StrToID(L"addfrommsft");
    _idComponents = StrToID(L"components");
    _idSortCombo = StrToID(L"sortcombo");
    _idCategoryCombo = StrToID(L"categorycombo");
    _idAddFromCDPane = StrToID(L"addfromCDPane");
    _idAddFromMSPane = StrToID(L"addfromMSpane");
    _idAddFromNetworkPane = StrToID(L"addfromNetworkpane");    
    _idAddWinComponent = StrToID(L"addwincomponent");
    _idPickApps = StrToID(L"pickapps");
    _idOptionList = StrToID(L"optionlist");

    // Find children
    _peOptionList             = (ARPSelector*)   FindDescendentByName(this, L"optionlist");
    _peInstalledItemList      = (Selector*)      FindDescendentByName(this, L"installeditemlist");
    _pePublishedItemList      = (Selector*)      FindDescendentByName(this, L"publisheditemlist");
    _peOCSetupItemList        = (Selector*)      FindDescendentByName(this, L"ocsetupitemlist");
    _peSortCombo              = (Combobox*)      FindDescendentByName(this, L"sortcombo");
    _pePublishedCategory      = (Combobox*)      FindDescendentByName(this, L"categorycombo");
    _pePublishedCategoryLabel = (Element*)       FindDescendentByName(this, L"categorylabel");
    _peClientTypeList         = (ARPSelector*)   FindDescendentByName(this, L"clienttypelist");
    _peOEMClients             = (Expando*)       FindDescendentByName(_peClientTypeList, L"oemclients");
    _peMSClients              = (Expando*)       FindDescendentByName(_peClientTypeList, L"msclients");
    _peNonMSClients           = (Expando*)       FindDescendentByName(_peClientTypeList, L"nonmsclients");
    _peCustomClients          = (Expando*)       FindDescendentByName(_peClientTypeList, L"customclients");
    _peOK                     =                  FindDescendentByName(this, L"ok");
    _peCancel                 =                  FindDescendentByName(this, L"cancel");
    _peCurrentItemList = NULL;

    _peChangePane   = FindDescendentByName(this, L"changepane");
    _peAddNewPane   = FindDescendentByName(this, L"addnewpane");
    _peAddRmWinPane = FindDescendentByName(this, L"addrmwinpane");
    _pePickAppPane  = FindDescendentByName(this, L"pickapppane");

    if (NULL != _peSortCombo)
    {
        LoadStringW(_pParser->GetHInstance(), IDS_APPNAME, szTemp, DUIARRAYSIZE(szTemp));     
        _peSortCombo->AddString(szTemp);
        LoadStringW(_pParser->GetHInstance(), IDS_SIZE, szTemp, DUIARRAYSIZE(szTemp));
        _peSortCombo->AddString(szTemp);
        LoadStringW(_pParser->GetHInstance(), IDS_FREQUENCY, szTemp, DUIARRAYSIZE(szTemp));
        _peSortCombo->AddString(szTemp);
        LoadStringW(_pParser->GetHInstance(), IDS_DATELASTUSED, szTemp, DUIARRAYSIZE(szTemp));    
        _peSortCombo->AddString(szTemp);
        _peSortCombo->SetSelection(0);
    }

    _bInDomain = ARPIsOnDomain();

    _bOCSetupNeeded = !!COCSetupEnum::s_OCSetupNeeded();

    // Apply polices as needed
    ApplyPolices();

    if(!_bOCSetupNeeded)
    {
        Element* pe = FindDescendentByName(this, L"addrmwinoc");
        DUIAssertNoMsg(pe);
        pe->SetLayoutPos(LP_None);
    }
    // Set initial selection of option list
    Element* peSel;
    switch(_uiStartPane)
    {
    case 3:
        peSel = FindDescendent(_idPickApps);
        break;

    case 2:
        peSel = FindDescendent(_idAddRmWin);        
        break;
    case 1:
        peSel = FindDescendent(_idAddNew);
        break;
    case 0:
    default:
        peSel = FindDescendent(_idChange);
        break;
    }

    // Set initial selection of style list
    DUIAssertNoMsg(peSel);
    _peOptionList->SetSelection(peSel);

    // initialize focus-following floater window
    peLastFocused = NULL;
    Element::Create(0, &peFloater);
    peFloater->SetLayoutPos(LP_Absolute);
    Add(peFloater);
    peFloater->SetBackgroundColor(ARGB(64, 255, 255, 0));

    ///////////////////////////////////////////////////////////////
    // Initialize the Pick Apps pane

    // Tell the clientblock elements that it's safe to initialize now
    if (FAILED(TraverseTree<ClientBlock>(this, _SendParseCompleted, (LPARAM)this)))
    {
        return false;
    }

    // Fill the client type lists
    InitClientCombos(_peOEMClients,    CLIENTFILTER_OEM);
    InitClientCombos(_peMSClients,     CLIENTFILTER_MS);
    InitClientCombos(_peNonMSClients,  CLIENTFILTER_NONMS);

    _peClientTypeList->SetSelection(_peCustomClients);
    _peCustomClients->SetExpanded(false);

    return true;
}

struct SETFILTERINFO {
    CLIENTFILTER   _cf;
    BOOL           _fHasApp;
    ARPFrame*      _paf;
};

HRESULT SetFilterCB(ClientPicker *pe, LPARAM lParam)
{
    SETFILTERINFO* pfi = (SETFILTERINFO*)lParam;
    HRESULT hr = pe->SetFilter(pfi->_cf, pfi->_paf);
    if (SUCCEEDED(hr) && !pe->IsEmpty())
    {
        pfi->_fHasApp = TRUE;
    }
    return hr;
}

HRESULT ARPFrame::InitClientCombos(Expando* pexParent, CLIENTFILTER cf)
{
    HRESULT hr;
    Element* pe;
    hr = _pParser->CreateElement(L"clientcategoryblock", NULL, &pe);
    if (SUCCEEDED(hr))
    {
        //
        // The client combos appear as the last element in the
        // clipped block.  The clipped block is the first (only)
        // child of the clipper.
        //
        GetNthChild(pexParent->GetClipper(), 0)->Add(pe);

        SETFILTERINFO sfi = { cf, FALSE, this };
        hr = TraverseTree<ClientPicker>(pe, SetFilterCB, (LPARAM)&sfi);
        if (sfi._cf == CLIENTFILTER_OEM && !sfi._fHasApp)
        {
            pexParent->SetLayoutPos(LP_None);
        }
    }
    pexParent->SetExpanded(false);

    return hr;
}

//
//  ARPFrame::FindClientBlock locates a ClientBlock by client type.
//
struct FINDCLIENTBLOCKINFO {
    LPCWSTR         _pwszType;
    ClientBlock*    _pcb;
};

HRESULT FindClientBlockCB(ClientBlock* pcb, LPARAM lParam)
{
    FINDCLIENTBLOCKINFO* pfcbi = (FINDCLIENTBLOCKINFO*)lParam;
    Value* pv;
    LPWSTR pwszType = pcb->GetClientTypeString(&pv);

    // Use LOCALE_INVARIANT so we aren't bitten by locales that do not
    // collate the same way as English.

    if (pwszType &&
        AreEnglishStringsEqual(pwszType, pfcbi->_pwszType))
    {
        pfcbi->_pcb = pcb;      // found it!
    }
    pv->Release();

    return S_OK;
}


ClientBlock* ARPFrame::FindClientBlock(LPCWSTR pwszType)
{
    FINDCLIENTBLOCKINFO fcbi = { pwszType, NULL };
    TraverseTree<ClientBlock>(this, FindClientBlockCB, (LPARAM)&fcbi);
    return fcbi._pcb;
}

/*
 *  You must be a member of the Administrators group in order to
 *  configure programs.  Being Power User isn't good enough because
 *  Power Users can't write to %ALLUSERSPROFILE%.
 */
BOOL CanConfigurePrograms()
{
    return IsUserAnAdmin();
}

HINSTANCE LoadLibraryFromSystem32Directory(LPCTSTR pszDll)
{
    TCHAR szDll[MAX_PATH];
    if (GetSystemDirectory(szDll, ARRAYSIZE(szDll)) && PathAppend(szDll, pszDll))
    {
        return LoadLibraryEx(szDll, NULL, LOAD_LIBRARY_AS_DATAFILE);
    }
    return NULL;
}

void ARPFrame::ApplyPolices()
{
   Element* pe;

   if (ARPIsRestricted(L"NoSupportInfo"))
   {
       _bSupportInfoRestricted = true;
   }


   if (ARPIsRestricted(L"ShowPostSetup"))
   {
       _bOCSetupNeeded = true;
   }
   else if (ARPIsRestricted(L"NoServices"))
   {
       _bOCSetupNeeded = false;
   }
   
   pe = FindDescendent(_idChange);
   DUIAssertNoMsg(pe);
   if (ARPIsRestricted(L"NoRemovePage"))
   {
       pe->SetLayoutPos(LP_None);
       if (0 == _uiStartPane)
        {
           _uiStartPane++;
        }
    }
   pe = FindDescendent(_idAddNew);
   DUIAssertNoMsg(pe);
   if (ARPIsRestricted(L"NoAddPage"))
   {
       pe->SetLayoutPos(LP_None);
       if (1 == _uiStartPane)
        {
           _uiStartPane++;
        }
   }
   else
   {
       if (ARPIsRestricted(L"NoAddFromCDorFloppy"))
       {
           pe = FindDescendent(_idAddFromCDPane);
           DUIAssertNoMsg(pe);
           pe->SetVisible(false);
           DisableElementTreeShortcut(pe);
       }
       if (ARPIsRestricted(L"NoAddFromInternet"))
       {
           pe = FindDescendent(_idAddFromMSPane);
           DUIAssertNoMsg(pe);
           pe->SetVisible(false);           
           DisableElementTreeShortcut(pe);
       }
       if (!_bInDomain || ARPIsRestricted(L"NoAddFromNetwork"))
       {
           pe = FindDescendent(_idAddFromNetworkPane);
           DUIAssertNoMsg(pe);
           pe->SetVisible(false);           
           DisableElementTreeShortcut(pe);
       }
   }
   pe = FindDescendent(_idAddRmWin);
   DUIAssertNoMsg(pe);

   // Note that in real ARP, we will never end up here with all thre panes disabled since we check for that before doing anything elese.
   if (ARPIsRestricted(L"NoWindowsSetupPage"))
   {
       pe->SetLayoutPos(LP_None);
       DisableElementTreeShortcut(pe);
       if (2 == _uiStartPane)
        {
           _uiStartPane++;
        }
   }

  pe = FindDescendent(_idAddWinComponent);
  DUIAssertNoMsg(pe);
  if (ARPIsRestricted(L"NoComponents"))
  {
      pe->SetVisible(false);
      DisableElementTreeShortcut(pe);
  }

   // Remove the "pick apps" page entirely if we are on Server or embedded
   // ("Choose Programs" is a workstation-only feature)
   // or it is restricted
   // (
   pe = FindDescendent(_idPickApps);
   DUIAssertNoMsg(pe);
   if (IsOS(OS_ANYSERVER) ||
       IsOS(OS_EMBEDDED) ||
       ARPIsRestricted(L"NoChooseProgramsPage"))
   {
       pe->SetLayoutPos(LP_None);
       DisableElementTreeShortcut(pe);
       if (3 == _uiStartPane)
        {
           _uiStartPane++;
        }
    }
    else
    {
       // Last-minute change:  Swap in a new image
       // DUI doesn't support content=rcicon so we have to set it manually
       HINSTANCE hinstMorIcons = LoadLibraryFromSystem32Directory(TEXT("moricons.dll"));
       if (hinstMorIcons)
       {
            HICON hico = (HICON)LoadImage(hinstMorIcons, MAKEINTRESOURCE(114), IMAGE_ICON,
                                   32, 32, 0);
            if (hico)
            {
                Value *pv = Value::CreateGraphic(hico);
                if (pv)
                {
                    GetNthChild(pe, 0)->SetValue(ContentProp, PI_Local, pv);
                    pv->Release();
                }
            }
            FreeLibrary(hinstMorIcons);
       }

       // Neuter the "pick apps" page if the user can't configure apps
       if (!CanConfigurePrograms()) {
            pe = FindDescendentByName(_pePickAppPane, L"pickappadmin");
            pe->SetVisible(false);
            DisableElementTreeShortcut(pe);
            pe = FindDescendentByName(_pePickAppPane, L"pickappnonadmin");
            pe->SetVisible(true);
       }
    }

}

bool ARPFrame::IsChangeRestricted()
{
   return ARPIsRestricted(L"NoRemovePage")? true : false;
}

void ARPFrame::RunOCManager()
{
    // Invoke Add/Remove Windows components
    // Command to invoke and OCMgr: "sysocmgr /y /i:%systemroot%\system32\sysoc.inf"
    WCHAR szInf[MAX_PATH];
    if (GetSystemDirectoryW(szInf, MAX_PATH) && PathCombineW(szInf, szInf, L"sysoc.inf"))
    {
        WCHAR szParam[MAX_PATH];
        wnsprintf(szParam, ARRAYSIZE(szParam), L"/y /i:%s", szInf);
        ShellExecuteW(NULL, NULL, L"sysocmgr", szParam, NULL, SW_SHOWDEFAULT);
    }
}

DWORD WINAPI PopulateInstalledItemList(void* paf);

void ARPFrame::UpdateInstalledItems()
{
    if (!IsChangeRestricted())
    {
        _peInstalledItemList->RemoveAll();
        _bInstalledListFilled = false;

        // Start second thread for item population
        //_beginthread(PopulateInstalledItemList, 0, (void*)this);
        if (!htPopulateInstalledItemList && g_fRun)
            htPopulateInstalledItemList = CreateThread(NULL, 0, PopulateInstalledItemList, (void*)this, 0, NULL);
    }
}

////////////////////////////////////////////////////////
// Generic eventing

// Helper
inline void _SetElementSheet(Element* peTarget, ATOM atomID, Value* pvSheet, bool bSheetRelease = true)
{
    if (pvSheet)
    {
        Element* pe = peTarget->FindDescendent(atomID);
        DUIAssertNoMsg(pe);
        pe->SetValue(Element::SheetProp, PI_Local, pvSheet);
        if (bSheetRelease)
            pvSheet->Release();
    }
} 

BOOL IsValidFileTime(FILETIME ft)
{
    return ft.dwHighDateTime || ft.dwLowDateTime;
}

BOOL IsValidSize(ULONGLONG ull)
{
    return ull != (ULONGLONG)-1;
}

BOOL IsValidFrequency(int iTimesUsed)
{
    return iTimesUsed >= 0;
}

void CALLBACK
_UnblockInputCallback(HWND /*hwnd*/, UINT /*uMsg*/, UINT_PTR idEvent, DWORD /*dwTime*/)
{
    BlockInput(FALSE);
    KillTimer(NULL, idEvent);
}

void _BlockDoubleClickInput(void)
{
    if (SetTimer(NULL, 0, GetDoubleClickTime(), _UnblockInputCallback))
    {
        BlockInput(TRUE);
    }
}


//#ifdef NEVER
//
// NTRAID#NTBUG9-314154-2001/3/12-brianau   Handle Refresh
//
//    Need to finish this for Whistler.
//

DWORD WINAPI PopulateAndRenderPublishedItemList(void* paf);
DWORD WINAPI PopulateAndRenderOCSetupItemList(void* paf);
void EnablePane(Element* pePane, bool fEnable);

void ARPFrame::OnInput(InputEvent *pEvent)
{
    if (GMF_BUBBLED == pEvent->nStage)
    {
        if (GINPUT_KEYBOARD == pEvent->nCode)
        {
            KeyboardEvent *pke = (KeyboardEvent *)pEvent;
            if (VK_F5 == pke->ch)
            {
                if (_peCurrentItemList)
                {
                    if (_peCurrentItemList == _peInstalledItemList)
                    {
                        UpdateInstalledItems();
                    }
                    else if (_peCurrentItemList == _pePublishedItemList)
                    {
                        RePopulatePublishedItemList();
                    }
                    else if (_peCurrentItemList == _peOCSetupItemList)
                    {
                        RePopulateOCSetupItemList();
                    }
                }
            }
        }
    }
    HWNDElement::OnInput(pEvent);
}
//#endif

HRESULT SetVisibleClientCB(ClientPicker *pe, LPARAM lParam)
{
    pe->SetVisible(UNCASTLPARAMTOBOOL(lParam));
    return TRUE;
}

//
//  This hides the controls that belong to the old pane and shows the
//  controls that belong to the new pane.
//
void ARPFrame::ChangePane(Element *pePane)
{
    bool fEnable;

    // Show/hide elements that belong to _peChangePane...
    fEnable = pePane == _peChangePane;
    // TODO: Zero size ancestors need to cause adaptors (HWNDHosts) to hide
    _peSortCombo->SetVisible(fEnable);
    EnablePane(_peChangePane, fEnable);

    // Show/hide elements that belong to _peAddNewPane
    fEnable = pePane == _peAddNewPane;
    _pePublishedCategory->SetVisible(fEnable);
    _pePublishedCategoryLabel->SetVisible(fEnable);
    EnablePane(_peAddNewPane, fEnable);

    // Show/hide elements that belong to _peAddRmWinPane
    fEnable = pePane == _peAddRmWinPane;
    EnablePane(_peAddRmWinPane, fEnable);

    // Show/hide elements that belong to _pePickAppPane
    fEnable = pePane == _pePickAppPane;
    TraverseTree<ClientPicker>(_pePickAppPane, SetVisibleClientCB, fEnable);

    EnablePane(_pePickAppPane, fEnable);
}

//  If we can't put focus on the list, it will go to the fallback location
void ARPFrame::PutFocusOnList(Selector* peList)
{
    Element* pe;
    if (pe = peList->GetSelection())
    {
       pe->SetKeyFocus();
    }
    else
    {
        pe = FallbackFocus();

        if (pe)
        {
            pe->SetKeyFocus();
        }
    }
}

void ARPFrame::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            ButtonClickEvent* pbce = (ButtonClickEvent*)pEvent;

            if (pbce->peTarget->GetID() == _idClose ||
                pbce->peTarget == _peOK)
            {
                // Close button
                if (OnClose())
                {
                    _pnhh->DestroyWindow();
                }
                pEvent->fHandled = true;
                return;
            }
            else if (pbce->peTarget == _peCancel)
            {
                // Do not call OnClose; nothing will be applied
                _pnhh->DestroyWindow();
                pEvent->fHandled = true;
                return;
            }
            else if (pbce->peTarget->GetID() == _idAddFromDisk)
            {
                // Add from disk button
                HRESULT hr;
                IShellAppManager* pisam = NULL;
                hr = CoCreateInstance(__uuidof(ShellAppManager), NULL, CLSCTX_INPROC_SERVER, __uuidof(IShellAppManager), (void**)&pisam);
                if (SUCCEEDED(hr))
                {
                    pisam->InstallFromFloppyOrCDROM(GetHWND());
                }
                if (pisam)
                {
                    pisam->Release();
                }    
                pEvent->fHandled = true;
                return;
            }
            else if (pbce->peTarget->GetID() == _idAddFromMsft)
            {
                // Windows update button
                ShellExecuteW(NULL, NULL, L"wupdmgr.exe", NULL, NULL, SW_SHOWDEFAULT);
                pEvent->fHandled = true;
                return;
            }
            else if (pbce->peTarget->GetID() == _idComponents)
            {
                RunOCManager();
            }
            else if (pbce->peTarget->GetID() == ARPItem::_idSize ||
                     pbce->peTarget->GetID() == ARPItem::_idFreq ||
                     pbce->peTarget->GetID() == ARPItem::_idSupInfo)
            {
                // Help requests
                ARPHelp* peHelp;
                NativeHWNDHost* pnhh = NULL;
                Element* pe = NULL;
                WCHAR szTitle[1024];
                if (pbce->peTarget->GetID() == ARPItem::_idSize)
                {
                    LoadStringW(_pParser->GetHInstance(), IDS_SIZETITLE, szTitle, DUIARRAYSIZE(szTitle));
                    if (SUCCEEDED(NativeHWNDHost::Create(szTitle, GetHWND(), NULL, CW_USEDEFAULT, CW_USEDEFAULT, 200, 200, 0, WS_POPUPWINDOW | WS_OVERLAPPED | WS_DLGFRAME, NHHO_NoSendQuitMessage | NHHO_HostControlsSize | NHHO_ScreenCenter, &pnhh)))
                    {
                        ARPHelp::Create(pnhh, this, _bDoubleBuffer, (Element**)&peHelp);
                        _pParser->CreateElement(L"sizehelp", peHelp, &pe);
                    }
                    else
                    {
                        DUITrace(">> Failed to create NativeHWNDHost for size info window.\n");
                    }
                }    
                else if (pbce->peTarget->GetID() == ARPItem::_idFreq)
                {
                    LoadStringW(_pParser->GetHInstance(), IDS_FREQUENCYTITLE, szTitle, DUIARRAYSIZE(szTitle));
                    if (SUCCEEDED(NativeHWNDHost::Create(szTitle, GetHWND(), NULL, CW_USEDEFAULT, CW_USEDEFAULT, 200, 200, 0, WS_POPUPWINDOW | WS_OVERLAPPED | WS_DLGFRAME, NHHO_NoSendQuitMessage | NHHO_HostControlsSize | NHHO_ScreenCenter, &pnhh)))
                    {
                        ARPHelp::Create(pnhh, this, _bDoubleBuffer, (Element**)&peHelp);
                        _pParser->CreateElement(L"freqhelp", peHelp, &pe);
                    }
                    else
                    {
                        DUITrace(">> Failed to create NativeHWNDHost for frequency info window.\n");
                    }
                }    
                else
                {
                    // Support information, add additional fields
                    LoadStringW(_pParser->GetHInstance(), IDS_SUPPORTTITLE, szTitle, DUIARRAYSIZE(szTitle));
                    if (SUCCEEDED(NativeHWNDHost::Create(szTitle, GetHWND(), NULL, CW_USEDEFAULT, CW_USEDEFAULT, 200, 200, 0, WS_POPUPWINDOW | WS_OVERLAPPED | WS_DLGFRAME, NHHO_NoSendQuitMessage | NHHO_HostControlsSize | NHHO_ScreenCenter, &pnhh)))
                    {
                        ARPHelp::Create(pnhh, this, _bDoubleBuffer, (Element**)&peHelp);
                        _pParser->CreateElement(L"suphelp", peHelp, &pe);

                        // Get application info
                        APPINFODATA aid = {0};

                        // Query
                        aid.cbSize = sizeof(APPINFODATA);
                        aid.dwMask = AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | 
                                     AIM_REGISTEREDOWNER | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | 
                                     AIM_SUPPORTTELEPHONE | AIM_HELPLINK | AIM_INSTALLLOCATION | AIM_INSTALLDATE |
                                     AIM_COMMENTS | AIM_IMAGE | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;

                        // There must be a selection
                        ARPItem* peSel = (ARPItem*)_peInstalledItemList->GetSelection();

                        peSel->_piia->GetAppInfo(&aid);
                        ((ARPHelp*)peHelp)->_piia = peSel->_piia;                    
                        PrepareSupportInfo(peHelp, &aid);

                        // Clean up
                        ClearAppInfoData(&aid);
                    }
                    else
                    {
                        DUITrace(">> Failed to create NativeHWNDHost for support info window.\n");
                    }
                }
                
                if (pe && pnhh) // Fill contents using substitution
                {
                     // Set visible and host
                     _pah = peHelp;
                     _bInModalMode = true;                     
                     EnableWindow(GetHWND(), FALSE);                     
                     pnhh->Host(peHelp);
                     peHelp->SetVisible(true);                     
                     peHelp->SetDefaultFocus();

                   // Do initial show
                   pnhh->ShowWindow();
                }


                pEvent->fHandled = true;
                return;
            }
        }
        else if (pEvent->uidType == Selector::SelectionChange)
        {
            SelectionChangeEvent* sce = (SelectionChangeEvent*)pEvent;

            //
            // NTRAID#NTBUG9-294015-2001/02/08-jeffreys
            //
            // If the user double-clicks, weird things can happen.
            //
            //
            // NTRAID#NTBUG9-313888-2001/2/14-brianau
            // 
            // This fix for 294015 caused more strange things to happen.  The most notable
            // is that sometimes you click a button and it remains depressed
            // but nothing happens.  Disabling this call to block double
            // click input fixes this problem.  We need to devise a better way
            // of handling double-click input in DUI.
            //
//            _BlockDoubleClickInput();

            if (sce->peTarget == _peOptionList)
            {
                // ARP options
                StartDefer();

                Element* peAddContentHeader = FindDescendentByName(this, L"addcontentheader");

                ASSERT(peAddContentHeader != NULL);

                if (sce->peNew->GetID() == _idChange)
                {
                    if (!_bInstalledListFilled)
                    {
                        UpdateInstalledItems();
                    }

                    ChangePane(_peChangePane);

                    _peCurrentItemList = _peInstalledItemList;
                    _peInstalledItemList->SetContentString(L"");
                    PutFocusOnList(_peInstalledItemList);
                }
                else if (sce->peNew->GetID() == _idAddNew)
                {
                    if (!_bPublishedListFilled)
                    {
                        WCHAR szTemp[1024];
                        LoadStringW(_pParser->GetHInstance(), IDS_WAITFEEDBACK, szTemp, DUIARRAYSIZE(szTemp));
                        _pePublishedItemList->SetContentString(szTemp);
                        SetElementAccessability(_pePublishedItemList, true, ROLE_SYSTEM_STATICTEXT, szTemp);
                        RePopulatePublishedItemList();
                    }

                    ChangePane(_peAddNewPane);

                    if (_bTerminalServer)
                    {
                        // No applications are available to install
                        // from the network in terminal server mode
                        // so there is no point choosing a category
                        _pePublishedCategory->SetVisible(false);
                        _pePublishedCategoryLabel->SetVisible(false);
                    }

                    _peCurrentItemList = _pePublishedItemList;

                    PutFocusOnList(_pePublishedItemList);
                }
                else if (sce->peNew->GetID() == _idAddRmWin)
                {
                    ChangePane(_peAddRmWinPane);

                    _peCurrentItemList = _peOCSetupItemList;

                    if (!_bOCSetupNeeded)
                    {
                        RunOCManager();
                        if (sce->peOld) {
                            _peOptionList->SetSelection(sce->peOld);
                        }
                    }
                    else 
                    {
                        if (!_bOCSetupListFilled)
                        {
                            //_beginthread(PopulateAndRenderOCSetupItemList, 0, (void*)this);
                            if (!htPopulateAndRenderOCSetupItemList && g_fRun)
                                htPopulateAndRenderOCSetupItemList = CreateThread(NULL, 0, PopulateAndRenderOCSetupItemList, (void*)this, 0, NULL);        

                            _bOCSetupListFilled = true;
                        }

                        PutFocusOnList(_peOCSetupItemList);
                    }
                }
                else if (sce->peNew->GetID() == _idPickApps)
                {
                    ChangePane(_pePickAppPane);
                    _peCurrentItemList = _peClientTypeList;
                    PutFocusOnList(_peClientTypeList);
                }

                EndDefer();

            }
            else if (sce->peTarget == _peInstalledItemList)
            {
                if (sce->peOld)
                {
                   sce->peOld->FindDescendent(ARPItem::_idRow[0])->SetEnabled(false);
                }
                if (sce->peNew)
                {
                   sce->peNew->FindDescendent(ARPItem::_idRow[0])->RemoveLocalValue(EnabledProp);
                }
            }

            pEvent->fHandled = true;
            return;
        }
        else if (pEvent->uidType == Combobox::SelectionChange)
        {
            SelectionIndexChangeEvent* psice = (SelectionIndexChangeEvent*)pEvent;
            if (psice->peTarget->GetID() == _idSortCombo)
            {
                SortList(psice->iNew, psice->iOld);
            }
            else if (psice->peTarget->GetID() == _idCategoryCombo)
            {
                _curCategory = psice->iNew;
                if (_bPublishedComboFilled)
                {
                    if (_bPublishedListFilled)
                    {
                        RePopulatePublishedItemList();
                    }
                }    
            }
        }
    }
    
    HWNDElement::OnEvent(pEvent);
}

void ARPFrame::OnKeyFocusMoved(Element* peFrom, Element* peTo)
{
    if(peTo && IsDescendent(peTo))
    {
        peLastFocused = peTo;
    }
    Element::OnKeyFocusMoved(peFrom, peTo);

/*  uncomment when JStall's message fixing is done
    if (peTo != peLastFocused)
    {
        // transition focus-following floater element from old to new

        if (!peTo)
            peFloater->SetVisible(false);
        else
        {
            Value* pvSize;
            const SIZE* psize = peTo->GetExtent(&pvSize);
            peFloater->SetWidth(psize->cx);
            peFloater->SetHeight(psize->cy);
            pvSize->Release();

            POINT pt = { 0, 0 };
            MapElementPoint(peTo, &pt, &pt);
            peFloater->SetX(pt.x);
            peFloater->SetY(pt.y);

            if (!peLastFocused)
                peFloater->SetVisible(true);
        }

        peLastFocused = peTo;
    }
*/
}

void ARPFrame::OnPublishedListComplete()
{
    Invoke(ARP_PUBLISHEDLISTCOMPLETE, NULL);
}

void ARPFrame::RePopulatePublishedItemList()
{
    //_beginthread(::PopulateAndRenderPublishedItemList, 0, (void*)this);
    if (!htPopulateAndRenderPublishedItemList && g_fRun)
    {
        // Disable the category combo until we are done populating the list
        _pePublishedCategory->SetEnabled(false);

        _bPublishedListFilled = false;
        _pePublishedItemList->DestroyAll();

        htPopulateAndRenderPublishedItemList = CreateThread(NULL, 0, PopulateAndRenderPublishedItemList, (void*)this, 0, NULL);        
    }
}

void ARPFrame::RePopulateOCSetupItemList()
{
    if (!htPopulateAndRenderOCSetupItemList && g_fRun)
    {
        _peOCSetupItemList->DestroyAll();
        _bOCSetupListFilled = false;

        htPopulateAndRenderOCSetupItemList = CreateThread(NULL, 0, PopulateAndRenderOCSetupItemList, (void*)this, 0, NULL);

        _bOCSetupListFilled = true;
    }
}

bool ARPFrame::CanSetFocus()
{
    if (_bInModalMode)
    {
        HWND hWnd = _pah->GetHost()->GetHWND();
        FLASHWINFO fwi = {
        sizeof(FLASHWINFO),               // cbSize
            hWnd,   // hwnd
            FLASHW_CAPTION,               // flags
            5,                            // uCount
            75                            // dwTimeout
            };
        FlashWindowEx(&fwi);
        SetFocus(hWnd);
        return false;
    }
    return true;
}

HRESULT TransferToCustomCB(ClientPicker *pe, LPARAM)
{
    return pe->TransferToCustom();
}

HRESULT ApplyClientBlockCB(ClientBlock* pcb, LPARAM lParam)
{
    return pcb->Apply((ARPFrame*)lParam);
}

bool ARPFrame::OnClose()
{
    if (_peClientTypeList)
    {
        Element *peSelected = _peClientTypeList->GetSelection();
        if (peSelected)
        {
            // Get all the client pickers in the user's selection
            // to transfer their settings to the Custom pane.
            // (This is a NOP if the current selection is itself the custom pane.)
            TraverseTree<ClientPicker>(peSelected, TransferToCustomCB);

            InitProgressDialog();

            // To get the progress bar right, we apply in two passes.
            // The first pass is "fake mode" where all we do is count up
            // how much work we are going to do.
            SetProgressFakeMode(true);
            TraverseTree<ClientBlock>(this, ApplyClientBlockCB, (LPARAM)this);

            // Okay now we know what the progress bar limit should be.
            _dwProgressTotal = _dwProgressSoFar;
            _dwProgressSoFar = 0;

            // The second pass is "real mode" where we do the actualy work.
            SetProgressFakeMode(false);
            TraverseTree<ClientBlock>(this, ApplyClientBlockCB, (LPARAM)this);


            EndProgressDialog();
        }
    }
    return true;
}

void ARPFrame::InitProgressDialog()
{
    TCHAR szBuf[MAX_PATH];

    EndProgressDialog();

    _dwProgressTotal = _dwProgressSoFar = 0;

    if (SUCCEEDED(CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IProgressDialog, &_ppd))))
    {
        _ppd->SetAnimation(GetModuleHandle(TEXT("SHELL32")), 165);
        LoadString(g_hinstSP1, IDS_APPWIZ_APPLYINGCLIENT, szBuf, SIZECHARS(szBuf));
        _ppd->SetTitle(szBuf);
        _ppd->StartProgressDialog(GetHostWindow(), NULL, PROGDLG_MODAL | PROGDLG_NOTIME | PROGDLG_NOMINIMIZE, NULL);
    }
}

void ARPFrame::SetProgressDialogText(UINT ids, LPCTSTR pszName)
{
    TCHAR szBuf[MAX_PATH];
    TCHAR szFormat[MAX_PATH];

    if (_ppd)
    {
        LoadString(g_hinstSP1, ids, szFormat, SIZECHARS(szFormat));
        wnsprintf(szBuf, SIZECHARS(szBuf), szFormat, pszName);
        _ppd->SetLine(1, szBuf, FALSE, NULL);
        _ppd->SetProgress(_dwProgressSoFar, _dwProgressTotal);
    }
}

void ARPFrame::EndProgressDialog()
{
    if (_ppd)
    {
        _ppd->StopProgressDialog();
        _ppd->Release();
        _ppd = NULL;
    }
}


HRESULT ARPFrame::LaunchClientCommandAndWait(UINT ids, LPCTSTR pszName, LPTSTR pszCommand)
{
    HRESULT hr = S_OK;

    if (!_bFakeProgress)
    {
        if (_ppd && _ppd->HasUserCancelled())
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        else
        {
            SetProgressDialogText(ids, pszName);

            PROCESS_INFORMATION pi;
            STARTUPINFO si = { 0 };
            si.cb = sizeof(si);
            si.dwFlags = STARTF_USESHOWWINDOW;
            si.wShowWindow = SW_SHOWNORMAL;
            if (CreateProcess(NULL, pszCommand, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
            {
                while (SHWaitForSendMessageThread(pi.hProcess, 1000) == WAIT_TIMEOUT)
                {
                    if (_ppd && _ppd->HasUserCancelled())
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                        break;
                    }
                }
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }
        }
    }
    _dwProgressSoFar++;

    return hr;
}

////////////////////////////////////////////////////////
// Caller thread-safe APIs (do any additional work on callers thread and then marshal)

// Sets the range for the total number of installed items
void ARPFrame::SetInstalledItemCount(UINT cItems)
{
    Invoke(ARP_SETINSTALLEDITEMCOUNT, (void*)(UINT_PTR)cItems);
}
   
void  ARPFrame::DecrementInstalledItemCount()
{
    Invoke(ARP_DECREMENTINSTALLEDITEMCOUNT, NULL);
}

// Sets the range for the total number of installed items
void ARPFrame::SetPublishedItemCount(UINT cItems)
{
    Invoke(ARP_SETPUBLISHEDITEMCOUNT, (void*)(UINT_PTR)cItems);
}
   
void  ARPFrame::DecrementPublishedItemCount()
{
    Invoke(ARP_DECREMENTPUBLISHEDITEMCOUNT, NULL);
}

// Inserts in items, sorted into the ARP list
void ARPFrame::InsertInstalledItem(IInstalledApp* piia)
{
    if (piia == NULL)
    {
        Invoke(ARP_DONEINSERTINSTALLEDITEM, NULL);
    }
    else
    {
        // Setup marshalled call, do as much work as possible on caller thread
        InsertItemData iid;

        APPINFODATA aid = {0};
        SLOWAPPINFO sai = {0};

        // Query only for display name and support URL
        aid.cbSize = sizeof(APPINFODATA);
        aid.dwMask =  AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | 
                      AIM_REGISTEREDOWNER | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | 
                      AIM_SUPPORTTELEPHONE | AIM_HELPLINK | AIM_INSTALLLOCATION | AIM_INSTALLDATE |
                      AIM_COMMENTS | AIM_IMAGE | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;

        piia->GetAppInfo(&aid);
        if(FAILED(piia->GetCachedSlowAppInfo(&sai)))
        {
            piia->GetSlowAppInfo(&sai);
        }

        // Set data
        iid.piia = piia;

        if (aid.pszDisplayName && aid.pszDisplayName[0])
        {
            // Title
            CopyMemory(iid.pszTitle, aid.pszDisplayName, min(sizeof(iid.pszTitle), (wcslen(aid.pszDisplayName) + 1) * sizeof(WCHAR)));

            // Image
            if (aid.pszImage && aid.pszImage[0])
            {
                iid.iIconIndex = PathParseIconLocationW(aid.pszImage);
                CopyMemory(iid.pszImage, aid.pszImage, min(sizeof(iid.pszImage), (wcslen(aid.pszImage) + 1) * sizeof(WCHAR)));    
            }
            else if (sai.pszImage && sai.pszImage[0])
            {
                iid.iIconIndex = PathParseIconLocationW(sai.pszImage);
                CopyMemory(iid.pszImage, sai.pszImage, min(sizeof(iid.pszImage), (wcslen(sai.pszImage) + 1) * sizeof(WCHAR)));
            }
            else
            {
                *iid.pszImage = NULL;
            }

            // Size, Frequency, and Last Used On
            iid.ullSize = sai.ullSize;
            iid.iTimesUsed = sai.iTimesUsed;
            iid.ftLastUsed = sai.ftLastUsed;

            // Possible actions (change, remove, etc.)
            piia->GetPossibleActions(&iid.dwActions);

            // Flag if support information is available
            iid.bSupportInfo = ShowSupportInfo(&aid);

            Invoke(ARP_INSERTINSTALLEDITEM, &iid);
        }
        else
        // Adjust Status bar size.
        {
            DecrementInstalledItemCount();
        }

        // Free query memory
        ClearAppInfoData(&aid);
    }
}

void ARPFrame::InsertPublishedItem(IPublishedApp* pipa, bool bDuplicateName)
{
    PUBAPPINFO* ppai;
    APPINFODATA aid = {0};
    InsertItemData iid= {0};
   
    ppai = new PUBAPPINFO;
    if (ppai == NULL)
    {
        return;
    }
    ppai->cbSize = sizeof(PUBAPPINFO);
    ppai->dwMask = PAI_SOURCE | PAI_ASSIGNEDTIME | PAI_PUBLISHEDTIME | PAI_EXPIRETIME | PAI_SCHEDULEDTIME;

    aid.cbSize = sizeof(APPINFODATA);
    aid.dwMask =  AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | 
                  AIM_REGISTEREDOWNER | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | 
                  AIM_SUPPORTTELEPHONE | AIM_HELPLINK | AIM_INSTALLLOCATION | AIM_INSTALLDATE |
                  AIM_COMMENTS | AIM_IMAGE | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;

    pipa->GetAppInfo(&aid);
    pipa->GetPublishedAppInfo(ppai);
    
    // Title
    if (bDuplicateName)
    {
        //
        // Duplicate entries have their publisher name appended 
        // to the application name so that they can be differentiated
        // from one another in the UI.
        //
        wnsprintf(iid.pszTitle, 
                  ARRAYSIZE(iid.pszTitle), 
                  L"%ls: %ls", 
                  aid.pszDisplayName, 
                  ppai->pszSource);                    
    }
    else
    {
        //
        // iid.pszTitle, despite the name is a character buffer, not a pointer.
        //
        lstrcpyn(iid.pszTitle, aid.pszDisplayName, ARRAYSIZE(iid.pszTitle));
    }

    iid.pipa = pipa;
    iid.ppai = ppai;

    Invoke(ARP_INSERTPUBLISHEDITEM, &iid);

    // Free query memory
    ClearAppInfoData(&aid);
}

void ARPFrame::InsertOCSetupItem(COCSetupApp* pocsa)
{
    APPINFODATA aid = {0};
    InsertItemData iid= {0};

    aid.cbSize = sizeof(APPINFODATA);
    aid.dwMask =  AIM_DISPLAYNAME;
    pocsa->GetAppInfo(&aid);

    iid.pocsa = pocsa;
    // Title
    CopyMemory(iid.pszTitle, aid.pszDisplayName, min(sizeof(iid.pszTitle), (wcslen(aid.pszDisplayName) + 1) * sizeof(WCHAR)));

    Invoke(ARP_INSERTOCSETUPITEM, &iid);

     // Free query memory
    ClearAppInfoData(&aid);
}
void ARPFrame::FeedbackEmptyPublishedList()
{
    Invoke(ARP_SETPUBLISHEDFEEDBACKEMPTY, 0);
}

void ARPFrame::DirtyInstalledListFlag()
{
    _bInstalledListFilled=false;

    // Refresh if we are on the published list
    if (_peCurrentItemList == _peInstalledItemList)
    {
        UpdateInstalledItems();
    }
}

void ARPFrame::DirtyPublishedListFlag()
{
    _bPublishedListFilled=false;

    // Refresh if we are on the published list
    if (_peCurrentItemList == _pePublishedItemList)
    {
        RePopulatePublishedItemList();
    }
}

void  ARPFrame::PopulateCategoryCombobox()
{
    Invoke(ARP_POPULATECATEGORYCOMBO, NULL);
}

LPCWSTR ARPFrame::GetCurrentPublishedCategory()
{
    int iCurrentCategory = _curCategory;
    if (iCurrentCategory == 0 || iCurrentCategory == CB_ERR || _psacl == NULL)
    {
        return NULL;
    }
    return _psacl->pCategory[iCurrentCategory - 1].pszCategory;
}

inline bool ARPFrame::ShowSupportInfo(APPINFODATA *paid)
{
   if (_bSupportInfoRestricted)
   {
       return false;
   }
   if (paid->pszVersion && paid->pszVersion ||
      paid->pszPublisher && paid->pszPublisher ||
      paid->pszProductID && paid->pszProductID ||
      paid->pszRegisteredOwner && paid->pszRegisteredOwner ||
      paid->pszRegisteredCompany && paid->pszRegisteredCompany ||
      paid->pszSupportUrl && paid->pszSupportUrl ||
      paid->pszHelpLink && paid->pszHelpLink ||
      paid->pszContact && paid->pszContact ||
      paid->pszReadmeUrl && paid->pszReadmeUrl ||
      paid->pszComments && paid->pszComments)
   {
       return TRUE;
   }
   return FALSE;
}

void ARPFrame::PrepareSupportInfo(Element* peHelp, APPINFODATA *paid)
{
    DWORD dwAction = 0;
    Element* pe;
    pe = FindDescendentByName(peHelp, L"title");
    pe->SetContentString(paid->pszDisplayName);
    SetElementAccessability(pe, true, ROLE_SYSTEM_STATICTEXT, paid->pszDisplayName);
    
    pe = FindDescendentByName(peHelp, L"prodname");
    pe->SetContentString(paid->pszDisplayName); 
    SetElementAccessability(pe, true, ROLE_SYSTEM_STATICTEXT, paid->pszDisplayName);

    ARPSupportItem* pasi;
    pasi = (ARPSupportItem*) FindDescendentByName(peHelp, L"publisher");
    pasi->SetAccValue(paid->pszPublisher);
    pasi->SetURL(paid->pszSupportUrl);

    FindDescendentByName(peHelp, L"version")->SetAccValue(paid->pszVersion);

    FindDescendentByName(peHelp, L"contact")->SetAccValue(paid->pszContact);

    pasi = (ARPSupportItem*) FindDescendentByName(peHelp, L"support");
    pasi->SetAccValue(paid->pszHelpLink);
    pasi->SetURL(paid->pszHelpLink);
    
    pasi = (ARPSupportItem*) FindDescendentByName(peHelp, L"readme");
    pasi->SetAccValue(paid->pszReadmeUrl);
    pasi->SetURL(paid->pszReadmeUrl);

    pasi = (ARPSupportItem*) FindDescendentByName(peHelp, L"update");
    pasi->SetAccValue(paid->pszUpdateInfoUrl);
    pasi->SetURL(paid->pszUpdateInfoUrl);

    FindDescendentByName(peHelp, L"productID")->SetAccValue(paid->pszProductID);

    FindDescendentByName(peHelp, L"regCompany")->SetAccValue(paid->pszRegisteredCompany);

    FindDescendentByName(peHelp, L"regOwner")->SetAccValue(paid->pszRegisteredOwner);

    FindDescendentByName(peHelp, L"comments")->SetAccValue(paid->pszComments);

    ((ARPHelp*)peHelp)->_piia->GetPossibleActions(&dwAction);
    if (!(dwAction & APPACTION_REPAIR))
        FindDescendentByName(peHelp, L"repairblock")->SetLayoutPos(LP_None);
}

extern "C" int __cdecl CompareElementDataName(const void* pA, const void* pB);
extern "C" int __cdecl CompareElementDataSize(const void* pA, const void* pB);
extern "C" int __cdecl CompareElementDataFreq(const void* pA, const void* pB);
extern "C" int __cdecl CompareElementDataLast(const void* pA, const void* pB);

CompareCallback ARPFrame::GetCompareFunction()
{
    switch(CurrentSortType)
    {
        case SORT_SIZE:      return CompareElementDataSize;
        case SORT_TIMESUSED: return CompareElementDataFreq;
        case SORT_LASTUSED:  return CompareElementDataLast;
        default:             return CompareElementDataName;
    }
}

void ARPFrame::SortList(int iNew, int iOld)
{
    if ((iNew >= 0) && (iNew != CurrentSortType))
    {
        CurrentSortType = (SortType) iNew;

        StartDefer();

        if (((iNew != SORT_NAME) || (iOld != SORT_SIZE)) &&
            ((iNew != SORT_SIZE) || (iOld != SORT_NAME)))
        {
            Value* pvChildren;
            ElementList* pel = _peInstalledItemList->GetChildren(&pvChildren);
            if (NULL == pel)
            {
                EndDefer();
                return;
            }

            for (UINT i = 0; i < pel->GetSize(); i++)
                ((ARPItem*) pel->GetItem(i))->SortBy(iNew, iOld);

            pvChildren->Release();
        }

        _peInstalledItemList->SortChildren(GetCompareFunction());

        if (!_peInstalledItemList->GetSelection())
        {
            Value* pv;
            ElementList* peList = _peInstalledItemList->GetChildren(&pv);
            if (NULL == peList)
            {
                EndDefer();
                return;
            }

            _peInstalledItemList->SetSelection(peList->GetItem(0));
            pv->Release();
        }

        EndDefer();
    }
}

void ARPFrame::SelectInstalledApp(IInstalledApp* piia)
{
    Value* pv;
    ElementList* peList = _peInstalledItemList->GetChildren(&pv);

    for (UINT i = 0; i < peList->GetSize(); i++)
    {
        ARPItem* pai = (ARPItem*) peList->GetItem(i);
        if (pai->_piia == piia)
        {
            pai->SetKeyFocus();
            break;
        }
    }
    pv->Release();
}

// Selects an app adjacent in the list to piia if possible, or to the fallback otherwise.
// First preference is for the app immediately following piia, if available.
void ARPFrame::SelectClosestApp(IInstalledApp* piia)
{
    Value* pv;
    ElementList* peList = _peInstalledItemList->GetChildren(&pv);

    for (UINT i = 0; i < peList->GetSize(); i++)
    {
        ARPItem* pai = (ARPItem*) peList->GetItem(i);
        if (pai->_piia == piia)
        {
            Element* peFocus = FallbackFocus();

            // If there is an app after piia, select it.
            if ((i + 1) < peList->GetSize())
            {
                peFocus = (Element*) peList->GetItem(i + 1);
            }
            // else if there is an app before piia, select it
            else if (i != 0)
            {
                peFocus = (Element*) peList->GetItem(i - 1);
            }

            peFocus->SetKeyFocus();
            break;
        }
    }
    pv->Release();
}

////////////////////////////////////////////////////////
// Callee thread-safe invoke (override)
void ARPFrame::OnInvoke(UINT nType, void* pData)
{
    // We are shutting down, ignore any requests from other threads
    if (!g_fRun)
        return;

    // Initialize ID cache if first pass
    if (!ARPItem::_idTitle)
    {
        ARPItem::_idTitle = StrToID(L"title");
        ARPItem::_idIcon = StrToID(L"icon");
        ARPItem::_idSize = StrToID(L"size");
        ARPItem::_idFreq = StrToID(L"freq");
        ARPItem::_idLastUsed = StrToID(L"lastused");
        ARPItem::_idInstalled = StrToID(L"installed");
        ARPItem::_idExInfo = StrToID(L"exinfo");
        ARPItem::_idSupInfo = StrToID(L"supinfo");
        ARPItem::_idItemAction = StrToID(L"itemaction");
        ARPItem::_idRow[0] = StrToID(L"row1");
        ARPItem::_idRow[1] = StrToID(L"row2");
        ARPItem::_idRow[2] = StrToID(L"row3");
    }

    switch (nType)
    {
    case ARP_SETINSTALLEDITEMCOUNT:
        // pData is item count
        _cMaxInstalledItems = (int)(INT_PTR)pData;
        break;

    case ARP_DECREMENTINSTALLEDITEMCOUNT:
        _cMaxInstalledItems--;
        break;

    case ARP_SETPUBLISHEDITEMCOUNT:
        // pData is item count
        _cMaxPublishedItems = (int)(INT_PTR)pData;
        break;

    case ARP_DECREMENTPUBLISHEDITEMCOUNT:
        _cMaxPublishedItems--;
        break;

    case ARP_SETPUBLISHEDFEEDBACKEMPTY:
        {
        WCHAR szTemp[1024];

        if (_bTerminalServer)
        {
            // We are running terminal server
            // This means no applications are displayed by design (not because there aren't any available)

            LoadStringW(_pParser->GetHInstance(), IDS_TERMSERVFEEDBACK, szTemp, DUIARRAYSIZE(szTemp));
        }
        else
        {
            LoadStringW(_pParser->GetHInstance(), IDS_EMPTYFEEDBACK, szTemp, DUIARRAYSIZE(szTemp));
        }

        _pePublishedItemList->SetContentString(szTemp);
        SetElementAccessability(_pePublishedItemList, true, ROLE_SYSTEM_STATICTEXT, szTemp);
        }
        break;
    case ARP_INSERTINSTALLEDITEM:
        {
        WCHAR szTemp[1024] = {0};
        
        // pData is InsertItemData struct
        InsertItemData* piid = (InsertItemData*)pData;

        StartDefer();
        
        // Create ARP item
        DUIAssertNoMsg(_pParser);

        ARPItem* peItem;
        Element* pe;

        if (_hdsaInstalledItems == NULL)
        {
            LoadStringW(_pParser->GetHInstance(), IDS_PLEASEWAIT, szTemp, DUIARRAYSIZE(szTemp));      
            _hdsaInstalledItems = DSA_Create(sizeof(ARPItem*), _cMaxInstalledItems);
            _peInstalledItemList->SetContentString(szTemp);
        }

        _pParser->CreateElement(L"installeditem", NULL, (Element**)&peItem);
        peItem->_paf = this;
        
        // Add appropriate change, remove buttons
        Element* peAction = NULL;
        if (!(piid->dwActions & APPACTION_MODIFYREMOVE))
        {
            // It isn't marked with modify/remove (the default)
            // Somebody gave us some special instructions from the registry
            if (!(piid->dwActions & APPACTION_UNINSTALL))
            {
                // NoRemove is set to 1
                if (piid->dwActions & APPACTION_MODIFY)
                {
                    // NoModify is not set so we can show the change button
                    _pParser->CreateElement(L"installeditemchangeonlyaction", NULL, &peAction);
                    if (!ARPItem::_idChg)
                    {
                        ARPItem::_idChg = StrToID(L"chg");
                    }
                    LoadStringW(_pParser->GetHInstance(), IDS_HELPCHANGE, szTemp, DUIARRAYSIZE(szTemp));
                }
            }
            else if (!(piid->dwActions & APPACTION_MODIFY))
            {
                // NoModify is set to 1
                // The only way we get here is if NoRemove is not set
                // so we don't have to check it again
                _pParser->CreateElement(L"installeditemremoveonlyaction", NULL, &peAction);
                if (!ARPItem::_idRm)
                {
                    ARPItem::_idRm = StrToID(L"rm");
                }
                LoadStringW(_pParser->GetHInstance(), IDS_HELPREMOVE, szTemp, DUIARRAYSIZE(szTemp));
            }
            else
            {
                // Just display both Change and Remove buttons
                _pParser->CreateElement(L"installeditemdoubleaction", NULL, &peAction);
                if (!ARPItem::_idChg)
                {
                    ARPItem::_idChg = StrToID(L"chg");
                    ARPItem::_idRm = StrToID(L"rm");
                }
                LoadStringW(_pParser->GetHInstance(), IDS_HELPCHANGEORREMOVE, szTemp, DUIARRAYSIZE(szTemp));
            }
        }
        else
        {
            // Display the default "Change/Remove" button
            _pParser->CreateElement(L"installeditemsingleaction", NULL, &peAction);
            if (!ARPItem::_idChgRm)
                ARPItem::_idChgRm = StrToID(L"chgrm");
            LoadStringW(_pParser->GetHInstance(), IDS_HELPCHANGEREMOVE, szTemp, DUIARRAYSIZE(szTemp));                
        }

        // Common steps for all cases above
        if (peAction)
        {
            // If peAction is not set, we are not displaying any buttons...
            pe = FindDescendentByName(peItem, L"instruct");
            pe->SetContentString(szTemp);
            SetElementAccessability(pe, true, ROLE_SYSTEM_STATICTEXT, szTemp);
            peItem->FindDescendent(ARPItem::_idItemAction)->Add(peAction);
        }

        // Support information
        if (!piid->bSupportInfo)
            peItem->FindDescendent(ARPItem::_idSupInfo)->SetLayoutPos(LP_None);

        // Set fields

        // Installed app interface pointer
        peItem->_piia = piid->piia;
        peItem->_piia->AddRef();

        // should just be call into the peItem: peItem->SetTimesUsed(piid->iTimesUsed); etc.
        peItem->_iTimesUsed = piid->iTimesUsed;
        peItem->_ftLastUsed = piid->ftLastUsed;
        peItem->_ullSize    = piid->ullSize;

        // Title
        Element* peField = peItem->FindDescendent(ARPItem::_idTitle);
        DUIAssertNoMsg(peField);
        peField->SetContentString(piid->pszTitle);
        SetElementAccessability(peField, true, ROLE_SYSTEM_STATICTEXT, piid->pszTitle);
        SetElementAccessability(peItem, true, ROLE_SYSTEM_LISTITEM, piid->pszTitle);

        // Icon
        if (piid->pszImage)
        {
            HICON hIcon;
            ExtractIconExW(piid->pszImage, piid->iIconIndex, NULL, &hIcon, 1);
            if (hIcon)
            {
                peField = peItem->FindDescendent(ARPItem::_idIcon);
                DUIAssertNoMsg(peField);
                Value* pvIcon = Value::CreateGraphic(hIcon);
                if (NULL != pvIcon)
                {
                    peField->SetValue(Element::ContentProp, PI_Local, pvIcon);  // Element takes ownership (will destroy)
                    pvIcon->Release();
                }
            }    
        }
        *szTemp = NULL;
        // Size
        peField = peItem->FindDescendent(ARPItem::_idSize);
        DUIAssertNoMsg(peField);
        if (IsValidSize(piid->ullSize))
        {
            WCHAR szMBLabel[5] = L"MB";
            WCHAR szSize[15] = {0};
            double fSize = (double)(__int64)piid->ullSize;

            fSize /= 1048576.;  // 1MB
            LoadStringW(_pParser->GetHInstance(), IDS_SIZEUNIT, szMBLabel, DUIARRAYSIZE(szMBLabel));

            if (fSize > 100.)
            {
                swprintf(szTemp, L"%d", (__int64)fSize);  // Clip
            }    
            else
            {
                swprintf(szTemp, L"%.2f", fSize);
            }    

            // Format the number for the current user's locale
            if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, NULL, szSize, DUIARRAYSIZE(szSize)) == 0)
            {
                lstrcpyn(szSize, szTemp, DUIARRAYSIZE(szSize));
            }

            if (lstrcat(szSize, szMBLabel))
            {
                peField->SetContentString(szSize);
                SetElementAccessability(peField, true, ROLE_SYSTEM_STATICTEXT, szTemp);
            }
        }
        else
        {
            peField->SetVisible(false);
            FindDescendentByName(peItem, L"sizelabel")->SetVisible(false);
        }

        // Frequency
        peField = peItem->FindDescendent(ARPItem::_idFreq);
        DUIAssertNoMsg(peField);
        if (IsValidFrequency(piid->iTimesUsed))
        {
            if (piid->iTimesUsed <= 2)
                LoadStringW(_pParser->GetHInstance(), IDS_USEDREARELY, szTemp, DUIARRAYSIZE(szTemp));
            else if (piid->iTimesUsed <= 10)
                LoadStringW(_pParser->GetHInstance(), IDS_USEDOCCASIONALLY, szTemp, DUIARRAYSIZE(szTemp));
            else
                LoadStringW(_pParser->GetHInstance(), IDS_USEDFREQUENTLY, szTemp, DUIARRAYSIZE(szTemp));

            peField->SetContentString(szTemp);
            SetElementAccessability(peField, true, ROLE_SYSTEM_STATICTEXT, szTemp);
        }
        else
        {
            peField->SetVisible(false);
            FindDescendentByName(peItem, L"freqlabel")->SetVisible(false);
        }

        // Last used on
        peField = peItem->FindDescendent(ARPItem::_idLastUsed);
        DUIAssertNoMsg(peField);
        if (IsValidFileTime(piid->ftLastUsed))
        {
            LPWSTR szDate;
            SYSTEMTIME stLastUsed;
            DWORD dwDateSize = 0;
            BOOL bFailed=FALSE;

            // Get the date it was last used on
            FileTimeToSystemTime(&piid->ftLastUsed, &stLastUsed);

            dwDateSize = GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stLastUsed, NULL, NULL, dwDateSize);
            if (dwDateSize)
            {
                szDate = new WCHAR[dwDateSize];

                if (szDate)
                {
                    dwDateSize = GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &stLastUsed, NULL, szDate, dwDateSize);
                    if (dwDateSize)
                    {
                        peField->SetContentString(szDate);
                        SetElementAccessability(peField, true, ROLE_SYSTEM_STATICTEXT, szDate);
                    }
                    else
                    {
                        bFailed=TRUE;
                    }

                    delete [] szDate;
                }
                else
                {
                    bFailed=TRUE;
                }
            }
            else
            {
                bFailed=TRUE;
            }
            
            if (bFailed)
            {
                peField->SetVisible(false);
                FindDescendentByName(peItem, L"lastlabel")->SetVisible(false);
            }
        }
        else
        {
            peField->SetVisible(false);
            FindDescendentByName(peItem, L"lastlabel")->SetVisible(false);
        }

        // Insert item into DSA
        int cNum = DSA_InsertItem(_hdsaInstalledItems, INT_MAX, &peItem);

        // Insert failed
        if (cNum < 0)
        {
            _cMaxInstalledItems--;

            // We're out of items to insert so remove the wait string
            if (!_cMaxInstalledItems)
            {
                _peInstalledItemList->SetContentString(L"");
            }
        }

        EndDefer();
        }
        break;

    case ARP_DONEINSERTINSTALLEDITEM:
        {
            DUITrace(">> ARP_DONEINSERTINSTALLEDITEM STARTED.\n");

            StartDefer();

            if (_hdsaInstalledItems != NULL)
            {
                int iMax = DSA_GetItemCount(_hdsaInstalledItems);

                // Just to be safe so if all items get removed we won't be
                // stuck with the please wait string.
                _peInstalledItemList->SetContentString(L"");
                
                for (int i=0; i < iMax; i++)
                {
                    ARPItem* aItem;
                    if (DSA_GetItem(_hdsaInstalledItems, i, &aItem))
                    {
                        _peInstalledItemList->Add(aItem, GetCompareFunction());
                    }
                }
                DSA_Destroy(_hdsaInstalledItems);
                _hdsaInstalledItems = NULL;

                // Set focus to first item
                // once list is populated, move focus to list
                GetNthChild(_peInstalledItemList, 0)->SetKeyFocus();

                _bInstalledListFilled = true;
            }

            EndDefer();

            DUITrace(">> ARP_DONEINSERTINSTALLEDITEM DONE.\n");
        }
        break;
    
    case ARP_INSERTPUBLISHEDITEM:
        {
        WCHAR szTemp[MAX_PATH] = {0};
        InsertItemData* piid = (InsertItemData*)pData;

        StartDefer();

        // Need a DSA so we can add them all to the list at one time to avoid
        // having lots of redrawing of the layout.  This method is much much faster.
        if (_hdsaPublishedItems == NULL)
        {
            LoadStringW(_pParser->GetHInstance(), IDS_PLEASEWAIT, szTemp, DUIARRAYSIZE(szTemp));      
            _hdsaPublishedItems = DSA_Create(sizeof(ARPItem*), _cMaxPublishedItems);
            _pePublishedItemList->SetContentString(szTemp);
        }

        // Create ARP item
        DUIAssertNoMsg(_pParser);
        ARPItem* peItem;
        Element* pe;
        _pParser->CreateElement(L"publisheditem", NULL, (Element**)&peItem);
        peItem->_paf = this;

        // Add appropriate change, remove buttons
        Element* peAction = NULL;
        _pParser->CreateElement(L"publisheditemsingleaction", NULL, &peAction);
        if (!ARPItem::_idAdd)
            ARPItem::_idAdd = StrToID(L"add");
        peItem->FindDescendent(ARPItem::_idItemAction)->Add(peAction);

        if (S_OK == piid->pipa->IsInstalled())
        {
            peItem->ShowInstalledString(TRUE);
        }
        
        // Published app interface pointer
        peItem->_pipa = piid->pipa;
        peItem->_pipa->AddRef();        
        peItem->_ppai = piid->ppai;


        // Title
        Element* peField = peItem->FindDescendent(ARPItem::_idTitle);
        DUIAssertNoMsg(peField);
        peField->SetContentString(piid->pszTitle);
        SetElementAccessability(peField, true, ROLE_SYSTEM_STATICTEXT, piid->pszTitle);
        SetElementAccessability(peItem, true, ROLE_SYSTEM_LISTITEM, piid->pszTitle);

        // Icon
        if (piid->pszImage)
        {
            HICON hIcon;
            ExtractIconExW(piid->pszImage, NULL, NULL, &hIcon, 1);
            if (hIcon)
            {
                peField = peItem->FindDescendent(ARPItem::_idIcon);
                DUIAssertNoMsg(peField);
                Value* pvIcon = Value::CreateGraphic(hIcon);
                peField->SetValue(Element::ContentProp, PI_Local, pvIcon);  // Element takes ownership (will destroy)
                pvIcon->Release();
            }    
        }

        // Insert into DSA, alphabetically
        if (_hdsaPublishedItems != NULL)
        {
            int iInsert;
            int cNum = DSA_GetItemCount(_hdsaPublishedItems);

            // Search for place to insert
            for (iInsert = 0; iInsert < cNum; iInsert++)
            {
                ARPItem* fItem;

                if (DSA_GetItem(_hdsaPublishedItems, iInsert, &fItem))
                {
                    Value* pvTitle;

                    pe = fItem->FindDescendent(ARPItem::_idTitle);
                    DUIAssertNoMsg(pe);
                
                    if (wcscmp(pe->GetContentString(&pvTitle), piid->pszTitle) > 0)
                    {
                        pvTitle->Release();
                        break;
                    }

                    pvTitle->Release();
                }
            }

            // Insert item into DSA
            if (DSA_InsertItem(_hdsaPublishedItems, iInsert, &peItem) < 0)
            {
                // Failed to insert the item
                // Bring the total down by 1
                _cMaxPublishedItems--;
            }
        }

        // We only want to start actually adding the items to the list
        // when we reach our last item.  If we insert each item into the list
        // as we process these messages, it can take upwards of 4 minutes to populate
        // if there are a lot of items.
        if (_hdsaPublishedItems != NULL &&
            DSA_GetItemCount(_hdsaPublishedItems) == _cMaxPublishedItems)
        {
            for (int i=0; i < _cMaxPublishedItems; i++)
            {
                ARPItem* aItem;
                if (DSA_GetItem(_hdsaPublishedItems, i, &aItem))
                {
                    _pePublishedItemList->Insert(aItem, i);
                }
            }
            DSA_Destroy(_hdsaPublishedItems);
            _hdsaPublishedItems = NULL;
        
            _pePublishedItemList->SetSelection(GetNthChild(_pePublishedItemList, 0));
        }
           
        EndDefer();
    }
        break;
    case ARP_INSERTOCSETUPITEM:
    {
        WCHAR szTemp[MAX_PATH] = {0};
        InsertItemData* piid = (InsertItemData*)pData;

        StartDefer();

        // Create ARP item
        DUIAssertNoMsg(_pParser);
        ARPItem* peItem;
        if (SUCCEEDED(_pParser->CreateElement(L"ocsetupitem", NULL, (Element**)&peItem)))
        {
            peItem->_paf = this;

            if (!ARPItem::_idConfigure)
                ARPItem::_idConfigure = StrToID(L"configure");

            // Add appropriate change, remove buttons
            Element* peAction = NULL;
            if (SUCCEEDED(_pParser->CreateElement(L"ocsetupitemsingleaction", NULL, &peAction)))
            {
                Element *peItemAction = peItem->FindDescendent(ARPItem::_idItemAction);
                if (NULL != peItemAction && SUCCEEDED(peItemAction->Add(peAction)))
                {
                    peAction = NULL; // Action successfully added.
                    
                    // OCSetup pointer
                    peItem->_pocsa = piid->pocsa;

                    // Title
                    Element* peField = peItem->FindDescendent(ARPItem::_idTitle);
                    DUIAssertNoMsg(peField);
                    peField->SetContentString(piid->pszTitle);
                    SetElementAccessability(peField, true, ROLE_SYSTEM_STATICTEXT, piid->pszTitle);
                    SetElementAccessability(peItem, true, ROLE_SYSTEM_LISTITEM, piid->pszTitle);

                    // Insert into list, alphabetically
                    Value* pvElList;
                    ElementList* peElList = _peOCSetupItemList->GetChildren(&pvElList);

                    Value* pvTitle;
                    Element* pe;
                    UINT iInsert = 0;

                    if (peElList)
                    {
                        for (; iInsert < peElList->GetSize(); iInsert++)
                        {
                            pe = peElList->GetItem(iInsert)->FindDescendent(ARPItem::_idTitle);
                            DUIAssertNoMsg(pe);

                            if (wcscmp(pe->GetContentString(&pvTitle), piid->pszTitle) > 0)
                            {
                                pvTitle->Release();
                                break;
                            }

                            pvTitle->Release();
                        }
                    }
                    
                    pvElList->Release();

                    // Insert item into list
                    if (FAILED(_peOCSetupItemList->Insert(peItem, iInsert)))
                    {
                        //
                        // Failed to insert item into list.  Need to delete
                        // the OCSetupApp object.
                        //
                        delete peItem->_pocsa;
                        peItem->_pocsa = NULL;
                    }
                    else
                    {
                        peItem = NULL;  // Successfully added to list.
                        _peOCSetupItemList->SetSelection(GetNthChild(_peOCSetupItemList, 0));
                    }
                }
                if (NULL != peAction)
                {
                    peAction->Destroy();
                    peAction = NULL;
                }
            }
            if (NULL != peItem)
            {
                peItem->Destroy();
                peItem = NULL;
            }
        }
       
        EndDefer();

    }
        break;
    case ARP_POPULATECATEGORYCOMBO:
    {
    UINT i;
    WCHAR szTemp[1024];
    UINT iSelection = 0; // Default to "All Categories"

    SHELLAPPCATEGORY *psac = _psacl->pCategory;
    LoadStringW(_pParser->GetHInstance(), IDS_ALLCATEGORIES, szTemp, DUIARRAYSIZE(szTemp));
    _pePublishedCategory->AddString(szTemp);

    szTemp[0] = 0;
    ARPGetPolicyString(L"DefaultCategory", szTemp, ARRAYSIZE(szTemp));
    
    StartDefer();
    for (i = 0; i < _psacl->cCategories; i++, psac++)
    {
        if (psac->pszCategory)
        {
            _pePublishedCategory->AddString(psac->pszCategory);
            if (0 == lstrcmpi(psac->pszCategory, szTemp))
            {
                //
                // Policy says default to this category.
                // i + 1 is required since element 0 is "All Categories"
                // and is ALWAYS present at element 0.
                //
                iSelection = i + 1;
            }
        }
    }
    _pePublishedCategory->SetSelection(iSelection);

    EndDefer();
    }
        break;
    case ARP_PUBLISHEDLISTCOMPLETE:
    {
        _pePublishedCategory->SetEnabled(true);
        break;
    }    
    }
}

void ARPFrame::ManageAnimations()
{
    BOOL fAnimate = TRUE;
    SystemParametersInfo(SPI_GETMENUANIMATION, 0, &fAnimate, 0);
    if (fAnimate)
    {
        if (!IsFrameAnimationEnabled())
        {
            _bAnimationEnabled = true;
            EnableAnimations();
        }
    }
    else
    {
        if (IsFrameAnimationEnabled())
        {
            _bAnimationEnabled = false;
            DisableAnimations();
        }
    }

    DUIAssertNoMsg((fAnimate != FALSE) == IsFrameAnimationEnabled());
}

HRESULT CalculateWidthCB(ClientPicker* pcp, LPARAM)
{
    pcp->CalculateWidth();
    return S_OK;
}

LRESULT ARPFrame::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_THEMECHANGED:
    case WM_SETTINGCHANGE:
        {
            LockWindowUpdate(_pnhh->GetHWND());
        
            Parser* pOldStyle = _pParserStyle;
            Parser* pNewStyle = NULL;

            if (!pOldStyle)
                break;

            // System parameter changing, reload style sheets so to sync
            // up with changes
            if (_fThemedStyle)
            {
                for (int i = FIRSTHTHEME; i <= LASTHTHEME; i++)
                {
                    if (_arH[i])
                    {
                        CloseThemeData(_arH[i]);
                        _arH[i] = NULL;
                    }
                }
            }

            CreateStyleParser(&pNewStyle);

            // Replace all style sheets
            if (pNewStyle)
            {
                Parser::ReplaceSheets(this, pOldStyle, pNewStyle);
            }

            // New style parser
            _pParserStyle = pNewStyle;

            // Destroy old
            pOldStyle->Destroy();

            // Animation setting may have changed
            ManageAnimations();

            TraverseTree<ClientPicker>(this, CalculateWidthCB);

            LockWindowUpdate(NULL);
        }
        break;
    }

    return HWNDElement::WndProc(hWnd, uMsg, wParam, lParam);
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* ARPFrame::Class = NULL;
HRESULT ARPFrame::Register()
{
    return ClassInfo<ARPFrame,HWNDElement>::Register(L"ARPFrame", NULL, 0);
}

////////////////////////////////////////////////////////
// ARPItem class
////////////////////////////////////////////////////////


// ARP item IDs
ATOM ARPItem::_idTitle = 0;
ATOM ARPItem::_idIcon = 0;
ATOM ARPItem::_idSize = 0;
ATOM ARPItem::_idFreq = 0;
ATOM ARPItem::_idLastUsed = 0;
ATOM ARPItem::_idExInfo = 0;
ATOM ARPItem::_idInstalled = 0;
ATOM ARPItem::_idChgRm = 0;
ATOM ARPItem::_idChg = 0;
ATOM ARPItem::_idRm = 0;
ATOM ARPItem::_idAdd = 0;
ATOM ARPItem::_idConfigure = 0;
ATOM ARPItem::_idSupInfo = 0;
ATOM ARPItem::_idItemAction = 0;
ATOM ARPItem::_idRow[3] = { 0, 0, 0 };


////////////////////////////////////////////////////////
// ARPItem

HRESULT ARPItem::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ARPItem* pai = HNew<ARPItem>();
    if (!pai)
        return E_OUTOFMEMORY;

    HRESULT hr = pai->Initialize();
    if (FAILED(hr))
    {
        pai->Destroy();
        return hr;
    }

    *ppElement = pai;

    return S_OK;
}

HRESULT ARPItem::Initialize()
{
    _piia = NULL; // Init before base in event of failure (invokes desstructor)
    _pipa = NULL; // Init before base in event of failure (invokes desstructor)


    // Do base class initialization
    HRESULT hr = Button::Initialize(AE_MouseAndKeyboard);
    if (FAILED(hr))
        return hr;

    return S_OK;
}


ARPItem::~ARPItem()
{
    if (_piia)
        _piia->Release();

    if (_pipa)
        _pipa->Release();

    if (_pocsa)
        delete _pocsa;

    if (_ppai)
    {
        ClearPubAppInfo(_ppai);
        delete _ppai;
    }
}

void ARPItem::ShowInstalledString(BOOL bInstalled)
{
    WCHAR szTemp[MAX_PATH] = L"";
    Element* pe = FindDescendent(ARPItem::_idInstalled);

    if (pe != NULL)
    {
        if (bInstalled)
        {
            LoadStringW(g_hinst, IDS_INSTALLED, szTemp, DUIARRAYSIZE(szTemp));
        }

        pe->SetContentString(szTemp);
        SetElementAccessability(pe, true, ROLE_SYSTEM_STATICTEXT, szTemp);         
    }
}

extern HWND _CreateTransparentStubWindow(HWND hwndParent);

////////////////////////////////////////////////////////
// Generic eventing

void ARPItem::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->uidType == Element::KeyboardNavigate)
    {
        KeyboardNavigateEvent* pkne = (KeyboardNavigateEvent*)pEvent;
        if (pkne->iNavDir & NAV_LOGICAL)
        {
            if (pEvent->nStage == GMF_DIRECT)
            {
            }
        }
        else
        {
            if (pEvent->nStage == GMF_ROUTED)
            {
                pEvent->fHandled = true;

                KeyboardNavigateEvent kne;
                kne.uidType = Element::KeyboardNavigate;
                kne.peTarget = this;
                kne.iNavDir = pkne->iNavDir;

                FireEvent(&kne);  // Will route and bubble
            }
            return;
        }
    }

    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            ButtonClickEvent* pbce = (ButtonClickEvent*)pEvent;
            ATOM id = pbce->peTarget->GetID();
            if (id == _idChgRm || id == _idRm || id == _idChg || id == _idAdd || id == _idConfigure)
            {
                HWND hwndStub = NULL;
                HWND hwndHost = NULL;
                DUIAssertNoMsg(_paf);
                
                if (_paf)
                {
                    hwndHost = _paf->GetHostWindow();
                }    
                if (hwndHost)
                {
                    hwndStub = _CreateTransparentStubWindow(hwndHost);
                    EnableWindow(hwndHost, FALSE);
                    SetActiveWindow(hwndStub);                    
                }

                if (id == _idAdd)
                {
                    
                    HRESULT hres = S_OK;
                    // Does the app have an expired publishing time?
                    if (_ppai->dwMask & PAI_EXPIRETIME)
                    {
                        // Yes, it does. Let's compare the expired time with our current time
                        SYSTEMTIME stCur = {0};
                        GetLocalTime(&stCur);

                        // Is "now" later than the expired time?
                        if (CompareSystemTime(&stCur, &_ppai->stExpire) > 0)
                        {
                            // Yes, warn the user and return failure
                            ShellMessageBox(g_hinst, hwndHost, MAKEINTRESOURCE(IDS_EXPIRED),
                                            MAKEINTRESOURCE(IDS_ARPTITLE), MB_OK | MB_ICONEXCLAMATION);
                            hres = E_FAIL;
                        }    
                    }
                    // if hres is not set by the above code, preceed with installation
                    if (hres == S_OK)
                    {
                        HCURSOR hcur = ::SetCursor(LoadCursor(NULL, IDC_WAIT));
                        // On NT,  let Terminal Services know that we are about to install an application.
                        // NOTE: This function should be called no matter the Terminal Services
                        // is running or not.
                        BOOL bPrevMode = TermsrvAppInstallMode();
                        SetTermsrvAppInstallMode(TRUE);
                        if (SUCCEEDED(_pipa->Install(NULL)))
                        {
                            // Show this item as installed
                            ShowInstalledString(TRUE);

                            // update installed items list
                            _paf->DirtyInstalledListFlag();
                        }
                        SetTermsrvAppInstallMode(bPrevMode);
                        ::SetCursor(hcur);
                    }                        
                }
                else
                {
                    HRESULT hr = E_FAIL;

                    if ((id == _idChgRm) || (id == _idRm))
                        hr = _piia->Uninstall(hwndHost);

                    else if (id == _idChg)
                        hr = _piia->Modify(hwndHost);

                    if (SUCCEEDED(hr))
                    {
                        if (S_FALSE == _piia->IsInstalled())
                        {
                            _paf->DirtyPublishedListFlag();
                        }
                    }
                }
                if (id == _idConfigure)
                {
                    _pocsa->Run();
                    _paf->RePopulateOCSetupItemList();
                }
                
                if (hwndHost)
                {
                    if (!_piia)
                    {
                        EnableWindow(hwndHost, TRUE);
                        SetForegroundWindow(hwndHost);
                    }

                    if (hwndStub)
                    {
                        DestroyWindow(hwndStub);
                    }    

                    EnableWindow(hwndHost, TRUE);
                }

                if (_piia)
                {
                    if (S_OK == _piia->IsInstalled())
                    {
                        SetKeyFocus();
                    }
                    else
                    {
                        // remove from installed items list
                        _paf->SelectClosestApp(_piia);
                        Destroy();
                    }
                }

                pEvent->fHandled = true;
                return;
            }
        }
    }

    Button::OnEvent(pEvent);
}

////////////////////////////////////////////////////////
// System events

void ARPItem::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(Selected))
    {
        // Display of extended information
        Element* peExInfo = FindDescendent(_idExInfo);
        DUIAssertNoMsg(peExInfo);

        peExInfo->SetLayoutPos(pvNew->GetBool() ? BLP_Top : LP_None);

        // Do default processing in this case
    }

    Button::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

void GetOrder(int iSortBy, int* iOrder)
{
    switch (iSortBy)
    {
        case SORT_NAME:
        case SORT_SIZE:      iOrder[0] = 0; iOrder[1] = 1; iOrder[2] = 2; break;
        case SORT_TIMESUSED: iOrder[0] = 1; iOrder[1] = 0; iOrder[2] = 2; break;
        case SORT_LASTUSED:  iOrder[0] = 2; iOrder[1] = 0; iOrder[2] = 1; break;
    }
}

void ARPItem::SortBy(int iNew, int iOld)
{
    Element* pe[3][2];     // size, timesused, lastused
    int iOrderOld[3];      // size, timesused, lastused
    int iOrderNew[3];      // size, timesused, lastused

    GetOrder(iOld, iOrderOld);
    GetOrder(iNew, iOrderNew);

    //
    // First get all the DUI elements to be sorted.  If we
    // can't get all of them, this sort fails.
    //
    bool bAllFound = true;
    int i;
    Element* peRow[3];     // row1, row2, row3
    for (i = 0; i < ARRAYSIZE(peRow); i++)
    {
        if (iOrderOld[i] != iOrderNew[i])
        {
            peRow[i] = FindDescendent(ARPItem::_idRow[i]);
            if (NULL == peRow[i])
            {
                bAllFound = false;
            }
        }
    }

    if (bAllFound)
    {
        for (i = 0; i < ARRAYSIZE(iOrderOld); i++) // loop through rows
        {
            int row = iOrderOld[i];
            if (row == iOrderNew[i])
                iOrderNew[i] = -1;
            else
            {
                DUIAssertNoMsg(NULL != peRow[i]);
                                
                Value* pvChildren;
                ElementList* pel;

                pel = peRow[i]->GetChildren(&pvChildren);
                pe[row][0] = pel->GetItem(0);
                pe[row][1] = pel->GetItem(1);
                pvChildren->Release();
            }
        }

        for (i = 0; i < 3; i++)
        {
            int row = iOrderNew[i];
            if (row != -1) // meaning that this row doesn't change
                peRow[i]->Add(pe[row], 2);
        }
    }
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* ARPItem::Class = NULL;
HRESULT ARPItem::Register()
{
    return ClassInfo<ARPItem,Button>::Register(L"ARPItem", NULL, 0);
}

////////////////////////////////////////////////////////
// ARPHelp
////////////////////////////////////////////////////////

HRESULT ARPHelp::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT ARPHelp::Create(NativeHWNDHost* pnhh, ARPFrame* paf, bool bDblBuffer, OUT Element** ppElement)
{

    *ppElement = NULL;

    ARPHelp* pah = HNew<ARPHelp>();
    if (!pah)
        return E_OUTOFMEMORY;

    HRESULT hr = pah->Initialize(pnhh, paf, bDblBuffer);
    if (FAILED(hr))
    {
        pah->Destroy();
        return hr;
    }

    *ppElement = pah;

    return S_OK;
}

HRESULT ARPHelp::Initialize(NativeHWNDHost* pnhh, ARPFrame* paf, bool bDblBuffer)
{
    // Do base class initialization
    HRESULT hr = HWNDElement::Initialize(pnhh->GetHWND(), bDblBuffer, 0);
    if (FAILED(hr))
        return hr;

    // Initialize
    // SetActive(AE_MouseAndKeyboard);
    _pnhh = pnhh;
    _paf = paf;

    return S_OK;
}
void ARPHelp::SetDefaultFocus()
{
    Element* pe = FindDescendentByName(this, L"close");
    if (pe)
    {
        pe->SetKeyFocus();
    }
}

////////////////////////////////////////////////////////
// Generic eventing

void ARPHelp::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            ATOM id = pEvent->peTarget->GetID();
            if (id == StrToID(L"repair")) 
                _piia->Repair(NULL);
            if (pEvent->peTarget->GetID() == StrToID(L"close")) 
            {
                _pnhh->DestroyWindow();
            }
            pEvent->fHandled = true;
            return;
        }
    }

    HWNDElement::OnEvent(pEvent);
}

void ARPHelp::OnDestroy()
{
    HWNDElement::OnDestroy();
    if (_paf)
    {
        _paf->SetModalMode(false);
    }

}

ARPHelp::~ARPHelp()
{
    if (_paf)
    {
        EnableWindow(_paf->GetHWND(), TRUE);
        SetFocus(_paf->GetHWND());
        _paf->RestoreKeyFocus();        
    }
    if (_pnhh)
    {
        _pnhh->Destroy();
    }
}
////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* ARPHelp::Class = NULL;
HRESULT ARPHelp::Register()
{
    return ClassInfo<ARPHelp,HWNDElement>::Register(L"ARPHelp", NULL, 0);
}

////////////////////////////////////////////////////////
// ARPSupportItem
////////////////////////////////////////////////////////

HRESULT ARPSupportItem::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ARPSupportItem* pasi = HNew<ARPSupportItem>();
    if (!pasi)
        return E_OUTOFMEMORY;

    HRESULT hr = pasi->Initialize();
    if (FAILED(hr))
    {
        pasi->Destroy();
        return hr;
    }

    *ppElement = pasi;

    return S_OK;
}

Value* _pvRowLayout = NULL;

HRESULT ARPSupportItem::Initialize()
{
    // Do base class initialization
    HRESULT hr = Element::Initialize(0);
    if (FAILED(hr))
        return hr;

    // Initialize
    bool fCreateLayout = !_pvRowLayout;

    if (fCreateLayout)
    {
        int ari[3] = { -1, 0, 3 };
        hr = RowLayout::Create(3, ari, &_pvRowLayout);
        if (FAILED(hr))
            return hr;
    }

    Element* peName;
    hr = Element::Create(AE_Inactive, &peName);
    if (FAILED(hr))
        return hr;

    Button* peValue;
    hr = Button::Create((Element**) &peValue);
    if (FAILED(hr))
    {
        peName->Destroy();
        return hr;
    }

    peValue->SetEnabled(false);

    Add(peName);
    Add(peValue);

    SetValue(LayoutProp, PI_Local, _pvRowLayout);
    SetLayoutPos(LP_None);

    if (fCreateLayout)
    {
        // todo:  need to track in propertychanged to know when it reaches null, which is
        // when we need to set it to NULL
    }

    return S_OK;
}

////////////////////////////////////////////////////////
// System events

#define ASI_Name  0
#define ASI_Value 1

Element* GetNthChild(Element *peRoot, UINT index)
{
    Value* pvChildren;
    ElementList* pel = peRoot->GetChildren(&pvChildren);
    Element* pe = NULL;
    if (pel && (pel->GetSize() > index))
        pe = pel->GetItem(index);
    pvChildren->Release();
    return pe;
}

Element* ARPSupportItem::GetChild(UINT index)
{
    return GetNthChild(this, index);
}


void ARPSupportItem::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    int index = -1;
    if (IsProp(AccName))
        index = ASI_Name;
    else if (IsProp(AccValue))
        index = ASI_Value;
    else if (IsProp(URL))
    {
        Element* pe = GetChild(ASI_Value);
        if (pe)
        {
            if (pvNew && pvNew->GetString() && *(pvNew->GetString()))
                pe->RemoveLocalValue(EnabledProp);
            else
                pe->SetEnabled(false);
        }
    }

    if (index != -1)
    {
        Element* pe = GetChild(index);
        if (index == ASI_Value)
        {
            // WARNING -- this code assumes you will not put a layoutpos on this element
            // as this code toggles between LP_None and unset, ignoring any previous setting
            // to the property -- verify this with Mark -- could be that this is local
            // and the markup is specified?  then there wouldn't be a problem
            if (pvNew && pvNew->GetString() && *(pvNew->GetString()))
                RemoveLocalValue(LayoutPosProp);
            else
                SetLayoutPos(LP_None);
        }
        if (pe)
        pe->SetValue(ContentProp, PI_Local, pvNew);

    }

    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

////////////////////////////////////////////////////////
// Generic eventing

void ARPSupportItem::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->uidType == Button::Click)
        {
            Value* pvURL;
            LPCWSTR lpszURL = GetURL(&pvURL);
            if (*lpszURL)
                ShellExecuteW(NULL, NULL, lpszURL, NULL, NULL, SW_SHOWDEFAULT);
            pvURL->Release();

            pEvent->fHandled = true;
            return;
        }
    }

    Element::OnEvent(pEvent);
}

// URL property
static int vvURL[] = { DUIV_STRING, -1 }; StaticValuePtr(svDefaultURL, DUIV_STRING, (void*)L"");
static PropertyInfo impURLProp = { L"URL", PF_Normal|PF_Cascade, 0, vvURL, NULL, (Value*)&svDefaultURL };
PropertyInfo* ARPSupportItem::URLProp = &impURLProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                ARPSupportItem::URLProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* ARPSupportItem::Class = NULL;
HRESULT ARPSupportItem::Register()
{
    return ClassInfo<ARPSupportItem,Element>::Register(L"ARPSupportItem", _aPI, DUIARRAYSIZE(_aPI));
}

////////////////////////////////////////////////////////
//
//  ARPSelector
//
//  A Selector whose children are all buttons.  If the user clicks
//  any of the buttons, that button automatically becomes the new
//  selection.

// Define class info with type and base type, set static class pointer
HRESULT ARPSelector::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ARPSelector* ps = HNew<ARPSelector>();
    if (!ps)
        return E_OUTOFMEMORY;

    HRESULT hr = ps->Initialize();
    if (FAILED(hr))
    {
        ps->Destroy();
        return hr;
    }

    *ppElement = ps;

    return S_OK;
}

////////////////////////////////////////////////////////
// Generic eventing

HRESULT CALLBACK CollapseExpandosExceptCB(Expando* pex, LPARAM lParam)
{
    if (pex != (Expando*)lParam)
    {
        pex->SetExpanded(false);
    }
    return S_OK;
}

void CALLBACK s_Repaint(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    KillTimer(hwnd, idEvent);
    ARPSelector* self = (ARPSelector*)idEvent;
    Element* pe;
    if (SUCCEEDED(Element::Create(0, &pe)))
    {
        pe->SetLayoutPos(BLP_Client);
        if (SUCCEEDED(self->Add(pe)))
        {
            self->Remove(pe);
        }
        pe->Destroy();
    }
}

void ARPSelector::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        // Selection occurs only for Button::Click or Expando::Click events
        if (pEvent->uidType == Button::Click ||
            pEvent->uidType == Expando::Click)
        {
            pEvent->fHandled = true;
            SetSelection(pEvent->peTarget);

            // If it was a Click from an Expando, then unexpand all the
            // other Expandos and expand this expando
            if (pEvent->uidType == Expando::Click)
            {
                TraverseTree<Expando>(this, CollapseExpandosExceptCB, (LPARAM)pEvent->peTarget);
                Expando* pex = (Expando*)pEvent->peTarget;
                pex->SetExpanded(true);

                // Hack for DUI painting weirdness
                // After the animation is over, repaint ourselves
                // to get rid of the detritus.
                ARPFrame* paf = FindAncestorElement<ARPFrame>(this);
                if (paf->GetHostWindow())
                {
                    SetTimer(paf->GetHostWindow(),
                             (UINT_PTR)this,
                             paf->GetAnimationTime(), s_Repaint);
                }

            }
            return;
        }
    }
    Selector::OnEvent(pEvent);
}

// If we are not the option list, bypass Selector::GetAdjacent because
// Selector navigates from the selected element but we want to navigate
// from the focus element because the focus element has interesting
// subelements...

Element *ARPSelector::GetAdjacent(Element *peFrom, int iNavDir, NavReference const *pnr, bool bKeyable)
{
    if (GetID() == ARPFrame::_idOptionList)
    {
        // Let the option list navigate normally
        return Selector::GetAdjacent(peFrom, iNavDir, pnr, bKeyable);
    }
    else
    {
        // All other selectors navigate from selection
        return Element::GetAdjacent(peFrom, iNavDir, pnr, bKeyable);
    }
}

IClassInfo* ARPSelector::Class = NULL;
HRESULT ARPSelector::Register()
{
    return ClassInfo<ARPSelector,Selector>::Register(L"ARPSelector", NULL, 0);
}

////////////////////////////////////////////////////////
//
//  CLIENTINFO
//
//  Tracks information about a specific client.
//

bool CLIENTINFO::GetInstallFile(HKEY hkInfo, LPCTSTR pszValue, LPTSTR pszBuf, UINT cchBuf, bool fFile)
{
    DWORD dwType;
    DWORD cb = cchBuf * sizeof(TCHAR);
    if (SHQueryValueEx(hkInfo, pszValue, NULL, &dwType, pszBuf, &cb) != ERROR_SUCCESS ||
        dwType != REG_SZ)
    {
        // If a file, then failure is okay (it means nothing to verify)
        return fFile;
    }

    TCHAR szBuf[MAX_PATH];

    lstrcpyn(szBuf, pszBuf, DUIARRAYSIZE(szBuf));

    if (!fFile)
    {
        // Now validate that the program exists
        PathRemoveArgs(szBuf);
        PathUnquoteSpaces(szBuf);
    }

    // Must be fully-qualified
    if (PathIsRelative(szBuf))
    {
        return false;
    }

    // File must exist, but don't hit the network to validate it
    if (!PathIsNetworkPath(szBuf) &&
        !PathFileExists(szBuf))
    {
        return false;
    }

    return true;
}

bool CLIENTINFO::GetInstallCommand(HKEY hkInfo, LPCTSTR pszValue, LPTSTR pszBuf, UINT cchBuf)
{
    return GetInstallFile(hkInfo, pszValue, pszBuf, cchBuf, FALSE);
}


LONG RegQueryDWORD(HKEY hk, LPCTSTR pszValue, DWORD* pdwOut)
{
    DWORD dwType;
    DWORD cb = sizeof(*pdwOut);
    LONG lRc = RegQueryValueEx(hk, pszValue, NULL, &dwType, (LPBYTE)pdwOut, &cb);
    if (lRc == ERROR_SUCCESS && dwType != REG_DWORD)
    {
        lRc = ERROR_INVALID_DATA;
    }
    return lRc;
}

//
//  hkInfo = NULL means that pzsKey is actually the friendlyname for
//  "keep this item"
//
bool CLIENTINFO::Initialize(HKEY hkApp, HKEY hkInfo, LPCWSTR pszKey)
{
    LPCWSTR pszName;
    WCHAR szBuf[MAX_PATH];

    DUIAssertNoMsg(_tOEMShown == TRIBIT_UNDEFINED);

    if (hkInfo)
    {
        _pszKey = StrDupW(pszKey);
        if (!_pszKey) return false;

        // Program must have properly registered IconsVisible status

        DWORD dwValue;
        if (RegQueryDWORD(hkInfo, TEXT("IconsVisible"), &dwValue) != ERROR_SUCCESS)
        {
            return false;
        }

        // If there is a VerifyFile, the file must exist
        if (!GetInstallFile(hkInfo, TEXT("VerifyFile"), szBuf, DUIARRAYSIZE(szBuf), TRUE))
        {
            return false;
        }

        _bShown = BOOLIFY(dwValue);

        // Program must have properly registered Reinstall, HideIcons and ShowIcons commands

        if (!GetInstallCommand(hkInfo, TEXT("ReinstallCommand"), szBuf, DUIARRAYSIZE(szBuf)) ||
            !GetInstallCommand(hkInfo, TEXT("HideIconsCommand"), szBuf, DUIARRAYSIZE(szBuf)) ||
            !GetInstallCommand(hkInfo, TEXT("ShowIconsCommand"), szBuf, DUIARRAYSIZE(szBuf)))
        {
            return false;
        }

        // Get the OEM's desired hide/show setting for this app, if any
        if (RegQueryDWORD(hkInfo, TEXT("OEMShowIcons"), &dwValue) == ERROR_SUCCESS)
        {
            _tOEMShown = dwValue ? TRIBIT_TRUE : TRIBIT_FALSE;
        }

        // See if this is the OEM's default client
        if (RegQueryDWORD(hkInfo, TEXT("OEMDefault"), &dwValue) == ERROR_SUCCESS &&
            dwValue != 0)
        {
            _bOEMDefault = BOOLIFY(dwValue);
        }

        SHLoadLegacyRegUIStringW(hkApp, NULL, szBuf, ARRAYSIZE(szBuf));
        if (!szBuf[0]) return false;
        pszName = szBuf;
    }
    else
    {
        pszName = pszKey;
    }

    _pszName = StrDupW(pszName);
    if (!_pszName) return false;

    return true;
}

CLIENTINFO* CLIENTINFO::Create(HKEY hkApp, HKEY hkInfo, LPCWSTR pszKey)
{
    CLIENTINFO* pci = HNewAndZero<CLIENTINFO>();
    if (pci)
    {
        if (!pci->Initialize(hkApp, hkInfo, pszKey))
        {
            pci->Delete();
            pci = NULL;
        }
    }
    return pci;
}

CLIENTINFO::~CLIENTINFO()
{
    LocalFree(_pszKey);
    LocalFree(_pszName);
    if (_pvMSName)
    {
        _pvMSName->Release();
    }
}

int CLIENTINFO::QSortCMP(const void* p1, const void* p2)
{
    CLIENTINFO* pci1 = *(CLIENTINFO**)p1;
    CLIENTINFO* pci2 = *(CLIENTINFO**)p2;
    return lstrcmpi(pci1->_pszName, pci2->_pszName);
}

////////////////////////////////////////////////////////
//
//  StringList
//
//  A list of strings.  The buffer for all the strings is allocated
//  in _pszBuf; the DynamicArray contains pointers into that buffer.
//

void StringList::Reset()
{
    if (_pdaStrings)
    {
        _pdaStrings->Destroy();
        _pdaStrings = NULL;
    }
    LocalFree(_pszBuf);
    _pszBuf = NULL;
}

//  pszInit is a semicolon-separated list

HRESULT StringList::SetStringList(LPCTSTR pszInit)
{
    HRESULT hr;
    Reset();
    if (!pszInit)
    {
        hr = S_OK;              // empty list
    }
    else if (SUCCEEDED(hr = DynamicArray<LPTSTR>::Create(0, false, &_pdaStrings)))
    {
        _pszBuf = StrDup(pszInit);
        if (_pszBuf)
        {
            LPTSTR psz = _pszBuf;

            hr = S_OK;
            while (SUCCEEDED(hr) && psz && *psz)
            {
                LPTSTR pszT = StrChr(psz, L';');
                if (pszT)
                {
                    *pszT++ = L'\0';
                }
                hr = _pdaStrings->Add(psz);
                psz = pszT;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

bool StringList::IsStringInList(LPCTSTR pszFind)
{
    if (_pdaStrings)
    {
        for (UINT i = 0; i < _pdaStrings->GetSize(); i++)
        {
            if (AreEnglishStringsEqual(_pdaStrings->GetItem(i), pszFind))
            {
                return true;
            }
        }
    }
    return false;
}

////////////////////////////////////////////////////////
//
//  ClientPicker
//
//  An element which manages a list of registered clients.
//
//  If there is only one item in the list, then the element is static.
//  Otherwise, the element hosts a combo box.
//
//  The clienttype attribute is the name of the registry key under Clients.
//

HRESULT ClientPicker::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ClientPicker* pcc = HNewAndZero<ClientPicker>();
    if (!pcc)
        return E_OUTOFMEMORY;

    HRESULT hr = pcc->Initialize();
    if (FAILED(hr))
    {
        pcc->Destroy();
        return hr;
    }

    *ppElement = pcc;

    return S_OK;
};

HRESULT ClientPicker::Initialize()
{
    HRESULT hr;

    // Initialize base
    hr = super::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize members
    hr = DynamicArray<CLIENTINFO*>::Create(0, false, &_pdaClients);
    if (FAILED(hr))
        return hr;

    hr = Element::Create(0, &_peStatic);
    if (FAILED(hr))
        return hr;

    if (FAILED(hr = _peStatic->SetClass(L"clientstatic")) ||
        FAILED(hr = Add(_peStatic)))
    {
        _peStatic->Destroy();
        return hr;
    }
    _peStatic->SetAccessible(true);
    _peStatic->SetAccRole(ROLE_SYSTEM_STATICTEXT);

    hr = Combobox::Create((Element**)&_peCombo);
    if (FAILED(hr))
        return hr;

    if (FAILED(hr = Add(_peCombo)) ||
        FAILED(hr = _peCombo->SetVisible(false)))
    {
        _peCombo->Destroy();
        return hr;
    }

    // JeffBog says I should mess with the width here
    SetWidth(10);

    return S_OK;
}

ClientPicker::~ClientPicker()
{
    _CancelDelayShowCombo();
    if (_pdaClients)
    {
        _pdaClients->Destroy();
    }
}

void ClientPicker::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{

    super::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    // Since UIActive = Selected && ParentEnabled, we need to call
    // _SyncUIActive if either property changes.

    if (IsProp(Selected))
    {
        // Change in selection may require us to block or unblock the OK button.
        _CheckBlockOK(pvNew->GetBool());

        _SyncUIActive();
    }
    else if (IsProp(ParentExpanded))
    {
        _SyncUIActive();
    }
}

//  To keep accessibility happy, we reflect content in the AccName.

void _SetStaticTextAndAccName(Element* pe, Value* pv)
{
    pe->SetValue(Element::ContentProp, PI_Local, pv);
    pe->SetValue(Element::AccNameProp, PI_Local, pv);
}

void _SetStaticTextAndAccName(Element* pe, LPCWSTR pszText)
{
    Value* pv = Value::CreateString(pszText);
    _SetStaticTextAndAccName(pe, pv);
    pv->Release();
}

//
//  When UI Active, show the combo box.
//  When not UI Active, hide our combo box so animation doesn't tube it.
//
void ClientPicker::_SyncUIActive()
{
    ARPFrame* paf = FindAncestorElement<ARPFrame>(this);
    bool bUIActive = GetSelected() && GetParentExpanded();

    if (_bUIActive != bUIActive)
    {
        _bUIActive = bUIActive;
        if (_bUIActive)
        {
            // Normally we would just _peCombo->SetVisible(_NeedsCombo())
            // and go home. Unfortunately, DirectUI gets confused if a
            // combo box moves around, so we have to change the visibility
            // after the world has gone quiet

            _hwndHost = paf->GetHostWindow();
            if (_hwndHost)
            {
                SetTimer(_hwndHost,
                         (UINT_PTR)this,
                         paf->GetAnimationTime(), s_DelayShowCombo);
            }
        }
        else
        {
            // Inactive - copy current combo selection to static
            // and hide the combo
            UINT iSel = _peCombo->GetSelection();
            if (iSel < GetClientList()->GetSize())
            {
                _SetStaticTextAndAccName(_peStatic, GetClientList()->GetItem(iSel)->GetFilteredName(GetFilter()));
            }
            _peCombo->SetVisible(false);
            _peStatic->SetVisible(true);
            _CancelDelayShowCombo();
        }
    }
}

void ClientPicker::_DelayShowCombo()
{
    // Tell DirectUI to let the combo participate in layout again
    bool bNeedsCombo = _NeedsCombo();
    _peCombo->SetVisible(bNeedsCombo);
    _peStatic->SetVisible(!bNeedsCombo);

    // Force a relayout by shrinking the combo box a teensy bit, then
    // returning it to normal size. This cannot be done inside a
    // Defer because that ends up optimizing out the relayout.

    _peCombo->SetWidth(_peCombo->GetWidth()-1);
    _peCombo->RemoveLocalValue(WidthProp);

    if (!_bFilledCombo)
    {
        _bFilledCombo = true;

        SendMessage(_peCombo->GetHWND(), CB_RESETCONTENT, 0, 0);
        for (UINT i = 0; i < GetClientList()->GetSize(); i++)
        {
            _peCombo->AddString(GetClientList()->GetItem(i)->GetFilteredName(GetFilter()));
        }
        _peCombo->SetSelection(0);
    }
}

// If the user picked "Choose from list" and we are selected,
// then block OK since the user actually needs to choose something.

void ClientPicker::_CheckBlockOK(bool bSelected)
{
    ARPFrame* paf = FindAncestorElement<ARPFrame>(this);
    CLIENTINFO* pci = GetSelectedClient();
    if (pci)
    {
        if (bSelected && pci->IsPickFromList())
        {
            if (!_bBlockedOK)
            {
                _bBlockedOK = true;
                paf->BlockOKButton();
            }
        }
        else
        {
            if (_bBlockedOK)
            {
                _bBlockedOK = false;
                paf->UnblockOKButton();
            }
        }
    }
}

void ClientPicker::s_DelayShowCombo(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    KillTimer(hwnd, idEvent);
    ClientPicker* self = (ClientPicker*)idEvent;
    self->_DelayShowCombo();
}

void ClientPicker::_CancelDelayShowCombo()
{
    if (_hwndHost)
    {
        KillTimer(_hwndHost, (UINT_PTR)this);
        _hwndHost = NULL;
    }
}

void ClientPicker::OnEvent(Event* pEvent)
{
    // Handle only bubbled generic events
    if (pEvent->nStage == GMF_BUBBLED)
    {
        // If the selection changed, then see if it's a change
        // that should block the OK button.
        if (pEvent->uidType == Combobox::SelectionChange)
        {
            _CheckBlockOK(GetSelected());
        }
    }

    super::OnEvent(pEvent);
}

//
//  CLIENTFILTER_OEM - add one if marked OEM, else "Keep unchanged"
//  CLIENTFILTER_MS  - add any that are marked MS, else "Keep unchanged"
//  CLIENTFILTER_NONMS - add any that are not marked MS, else "Keep unchanged"
//                       furthermore, if more than one non-MS, then
//                       add and select "Choose from list"
//
//  On success, returns the number of items added
//  (not counting "Keep unchanged" / "Choose from list")
//
HRESULT ClientPicker::SetFilter(CLIENTFILTER cf, ARPFrame* paf)
{
    HRESULT hr = E_FAIL;

    DUIAssert(_cf == 0, "SetFilter called more than once");
    _cf = cf;
    _bEmpty = true;
    _bFilledCombo = false;

    Value* pv;
    LPWSTR pszType = GetClientTypeString(&pv);
    if (pszType)
    {
        _pcb = paf->FindClientBlock(pszType);
        if (_pcb)
        {
            hr = _pcb->InitializeClientPicker(this);
        }
    }
    pv->Release();

    // The static element gets the first item in the list
    if (SUCCEEDED(hr) && GetClientList()->GetSize())
    {
        _SetStaticTextAndAccName(_peStatic, GetClientList()->GetItem(0)->_pszName);
    }

    if (SUCCEEDED(hr))
    {
        CalculateWidth();
        _SyncUIActive();
    }

    return hr;
}

//  Set our width to the width of the longest string in our combo box.
//  Combo boxes don't do this themselves, so they need our help.  We have
//  to set the width on ourselves and not on the combobox because
//  RowLayout will change the width of the combobox and HWNDHost will
//  treat the HWND width as authoritative, overwriting the combobox width
//  we had set.

void ClientPicker::CalculateWidth()
{
    HWND hwndCombo = _peCombo->GetHWND();
    HDC hdc = GetDC(hwndCombo);
    if (hdc)
    {
        HFONT hfPrev = SelectFont(hdc, GetWindowFont(hwndCombo));
        int cxMax = 0;
        SIZE siz;
        for (UINT i = 0; i < GetClientList()->GetSize(); i++)
        {
            LPCTSTR pszName = GetClientList()->GetItem(i)->GetFilteredName(GetFilter());
            if (GetTextExtentPoint(hdc, pszName, lstrlen(pszName), &siz) &&
                cxMax < siz.cx)
            {
                cxMax = siz.cx;
            }
        }
        SelectFont(hdc, hfPrev);
        ReleaseDC(hwndCombo, hdc);

        //  Add in the borders that USER adds to the combo box.
        //  Unfortunately, we get called when the combo box has been
        //  squished to zero width, so GetComboBoxInfo is of no use.
        //  We have to replicate the computations.
        //
        //  The client space is arranged horizontally like so:
        //
        //   SM_CXFIXEDFRAME
        //   v            v
        //  | |  edit    | | |
        //                  ^
        //       SM_CXVSCROLL

        RECT rc = { 0, 0, cxMax, 0 };
        rc.right += 2 * GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXVSCROLL);
        rc.right += GetSystemMetrics(SM_CXEDGE);    // extra edge for Hebrew/Arabic
        AdjustWindowRect(&rc, GetWindowStyle(hwndCombo), FALSE);
        SetWidth(rc.right - rc.left);
    }
}


HRESULT ClientPicker::TransferToCustom()
{
    HRESULT hr = E_FAIL;

    if (_pcb)
    {
        hr = _pcb->TransferFromClientPicker(this);
    }

    return hr;
}

CLIENTINFO* ClientPicker::GetSelectedClient()
{
    if (_peCombo)
    {
        UINT iSel = _peCombo->GetSelection();
        if (iSel < GetClientList()->GetSize())
        {
            return GetClientList()->GetItem(iSel);
        }
    }

    return NULL;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// ClientType property
static int vvCCClientType[] = { DUIV_STRING, -1 };
static PropertyInfo impCCClientTypeProp = { L"ClientType", PF_Normal, 0, vvCCClientType, NULL, Value::pvStringNull };
PropertyInfo* ClientPicker::ClientTypeProp = &impCCClientTypeProp;

// ParentExpanded property
static int vvParentExpanded[] = { DUIV_BOOL, -1 };
static PropertyInfo impParentExpandedProp = { L"parentexpanded", PF_Normal, 0, vvParentExpanded, NULL, Value::pvBoolFalse };
PropertyInfo* ClientPicker::ParentExpandedProp = &impParentExpandedProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
PropertyInfo* _aClientPickerPI[] = {
    ClientPicker::ClientTypeProp,
    ClientPicker::ParentExpandedProp,
};

// Define class info with type and base type, set static class pointer

IClassInfo* ClientPicker::Class = NULL;
HRESULT ClientPicker::Register()
{
    return ClassInfo<ClientPicker,super>::Register(L"clientpicker", _aClientPickerPI, DUIARRAYSIZE(_aClientPickerPI));
}

////////////////////////////////////////////////////////
// ARP Parser

HRESULT ARPParser::Create(ARPFrame* paf, UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser)
{
    *ppParser = NULL;

    ARPParser* ap = HNew<ARPParser>();
    if (!ap)
        return E_OUTOFMEMORY;
    
    HRESULT hr = ap->Initialize(paf, uRCID, hInst, pfnErrorCB);
    if (FAILED(hr))
    {
        ap->Destroy();
        return hr;
    }

    *ppParser = ap;

    return S_OK;
}

HRESULT ARPParser::Initialize(ARPFrame* paf, UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB)
{
    _paf = paf;
    _arH[0] = hInst;
    _arH[1] = g_hinstSP1;

    LPCSTR pszData;
    int cbData;

    HRESULT hr = FindSPResource(uRCID, &pszData, &cbData);
    if (FAILED(hr))
    {
        return hr;
    }

    return Parser::Initialize(pszData, cbData, _arH, pfnErrorCB);
}

Value* ARPParser::GetSheet(LPCWSTR pszResID)
{
    // All style sheet mappings go through here. Redirect sheet queries to appropriate
    // style sheets (i.e. themed or standard look). _pParserStyle points to the
    // appropriate stylesheet-only Parser instance
    return _paf->GetStyleParser()->GetSheet(pszResID);
}

////////////////////////////////////////////////////////
//
//  AutoButton
//
//  A button that does a bunch of stuff that USER does automagically,
//  if it were a regular button control.
//
//  -   Automatically updates its own accessibility state and action
//  -   If a checkbox, autotoggles on click

HRESULT AutoButton::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    AutoButton* pb = HNew<AutoButton>();
    if (!pb)
        return E_OUTOFMEMORY;

    HRESULT hr = pb->Initialize(AE_MouseAndKeyboard);
    if (FAILED(hr))
    {
        pb->Destroy();
        return hr;
    }

    *ppElement = pb;

    return S_OK;
}

void AutoButton::OnEvent(Event* pev)
{
    // Checkboxes auto-toggle on click

    if (pev->nStage == GMF_DIRECT &&
        pev->uidType == Button::Click &&
        GetAccRole() == ROLE_SYSTEM_CHECKBUTTON)
    {
        pev->fHandled = true;

        // Toggle the selected state
        SetSelected(!GetSelected());
    }

    super::OnEvent(pev);
}

//
//  Reflect the selected state to accessibility.
//
void AutoButton::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    super::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    if (IsProp(Selected))
    {
        int state = GetAccState();
        if (GetAccRole() == ROLE_SYSTEM_OUTLINEBUTTON)
        {
            // Outline buttons expose Selection as expanded/collapsed
            state &= ~(STATE_SYSTEM_EXPANDED | STATE_SYSTEM_COLLAPSED);
            if (pvNew->GetBool())
            {
                state |= STATE_SYSTEM_EXPANDED;
            }
            else
            {
                state |= STATE_SYSTEM_COLLAPSED;
            }
        }
        else
        {
            // Radio buttons and checkboxes expose Selection as checked/unchecked
            if (pvNew->GetBool())
            {
                state |= STATE_SYSTEM_CHECKED;
            }
            else
            {
                state &= ~STATE_SYSTEM_CHECKED;
            }
        }
        SetAccState(state);

        SyncDefAction();
    }
    else if (IsProp(AccRole))
    {
        SyncDefAction();
    }
}

//
//  Role strings from oleacc.  They are biased by 1100 since that is
//  where roles begin.
//
#define OLEACCROLE_EXPAND       (305-1100)
#define OLEACCROLE_COLLAPSE     (306-1100)
#define OLEACCROLE_CHECK        (309-1100)
#define OLEACCROLE_UNCHECK      (310-1100)

// Default action is "Check" if a radio button or an unchecked
// checkbox.  Default action is "Uncheck" if an unchecked checkbox.

void AutoButton::SyncDefAction()
{
    UINT idsAction;
    switch (GetAccRole())
    {
    // Checkbuttons will check or uncheck depending on state
    case ROLE_SYSTEM_CHECKBUTTON:
        idsAction = (GetAccState() & STATE_SYSTEM_CHECKED) ?
                            OLEACCROLE_UNCHECK :
                            OLEACCROLE_CHECK;
        break;

    // Radiobutton always checks.
    case ROLE_SYSTEM_RADIOBUTTON:
        idsAction = OLEACCROLE_CHECK;
        break;

    // Expando button expands or collapses.
    case ROLE_SYSTEM_OUTLINEBUTTON:
        idsAction = (GetAccState() & STATE_SYSTEM_EXPANDED) ?
                            OLEACCROLE_COLLAPSE :
                            OLEACCROLE_EXPAND;
        break;

    default:
        DUIAssert(0, "Unknown AccRole");
        return;

    }

    SetDefAction(this, idsAction);
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer

IClassInfo* AutoButton::Class = NULL;
HRESULT AutoButton::Register()
{
    return ClassInfo<AutoButton,super>::Register(L"AutoButton", NULL, 0);
}

////////////////////////////////////////////////////////
// ClientBlock class
//
//  Manages a block of elements which expose all the clients registered
//  to a particular client category.

HRESULT ClientBlock::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    ClientBlock* pcb = HNewAndZero<ClientBlock>();
    if (!pcb)
        return E_OUTOFMEMORY;

    HRESULT hr = pcb->Initialize();
    if (FAILED(hr))
    {
        pcb->Destroy();
        return hr;
    }

    *ppElement = pcb;

    return S_OK;
}

HRESULT ClientBlock::Initialize()
{
    HRESULT hr;

    // Initialize base
    hr = super::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize members
    hr = DynamicArray<CLIENTINFO*>::Create(0, false, &_pdaClients);
    if (FAILED(hr))
        return hr;

    return S_OK;
}

ClientBlock::~ClientBlock()
{
    if (_pdaClients)
    {
        for (UINT i = 0; i < _pdaClients->GetSize(); i++)
        {
            _pdaClients->GetItem(i)->Delete();
        }
        _pdaClients->Destroy();
    }
}

//
//  If the user clicks a new default application, force it to be checked
//  and disable it so it cannot be unchecked.  Also re-enable the old one.
//
void ClientBlock::OnEvent(Event* pev)
{
    if (pev->nStage == GMF_BUBBLED &&
        pev->uidType == Selector::SelectionChange)
    {
        SelectionChangeEvent* sce = (SelectionChangeEvent*)pev;

        // Re-enable the previous guy, if any
        _EnableShowCheckbox(sce->peOld, true);

        // Disable the new guy, if any
        _EnableShowCheckbox(sce->peNew, false);
    }

    super::OnEvent(pev);
}

void ClientBlock::_EnableShowCheckbox(Element* peRadio, bool fEnable)
{
    if (peRadio)
    {
        Element* peRow = peRadio->GetParent();
        if (peRow)
        {
            Element* peShow = MaybeFindDescendentByName(peRow, L"show");
            if (peShow)
            {
                peShow->SetEnabled(fEnable);
                peShow->SetSelected(true); // force checked

                // HACKHACK - DUI doesn't realize that the checkbox needs
                // to be repainted so I have to kick it.
                InvalidateGadget(peShow->GetDisplayNode());
            }
        }
    }
}

//
//  ClientBlock initialization / apply methods...
//

HKEY ClientBlock::_OpenClientKey(HKEY hkRoot, DWORD dwAccess)
{
    HKEY hkClient = NULL;

    Value *pv;
    LPCWSTR pszClient = GetClientTypeString(&pv);
    if (pszClient)
    {
        WCHAR szBuf[MAX_PATH];
        wnsprintfW(szBuf, ARRAYSIZE(szBuf), TEXT("Software\\Clients\\%s"),
                   pszClient);
        RegOpenKeyExW(hkRoot, szBuf, 0, dwAccess, &hkClient);
        pv->Release();
    }
    return hkClient;
}

bool ClientBlock::_GetDefaultClient(HKEY hkClient, HKEY hkRoot, LPTSTR pszBuf, LONG cchBuf)
{
    bool bResult = false;
    HKEY hk = _OpenClientKey(hkRoot);
    if (hk)
    {
        DWORD cbSize = cchBuf * sizeof(*pszBuf);
        DWORD dwType;
        // Client must be defined, be of type REG_SZ, be non-NULL, and have
        // a corresponding entry in HKLM\Software\Clients.  RegQueryValue
        // is a handy abbreviatio for RegQueryKeyExists.
        LONG l;
        if (SHGetValue(hk, NULL, NULL, &dwType, pszBuf, &cbSize) == ERROR_SUCCESS &&
            dwType == REG_SZ && pszBuf[0] &&
            RegQueryValue(hkClient, pszBuf, NULL, &l) == ERROR_SUCCESS)
        {
            bResult = true;
        }
        RegCloseKey(hk);
    }
    return bResult;
}

//  Determines whether the current client is a Microsoft client different
//  from the Windows default client.  Usually, this is when the current
//  client is Outlook but the Windows default client is Outlook Express.

bool ClientBlock::_IsCurrentClientNonWindowsMS()
{
    bool bResult = false;

    HKEY hkClient = _OpenClientKey();
    if (hkClient)
    {
        TCHAR szClient[MAX_PATH];
        if (_GetDefaultClient(hkClient, HKEY_CURRENT_USER, szClient, ARRAYSIZE(szClient)) ||
            _GetDefaultClient(hkClient, HKEY_LOCAL_MACHINE, szClient, ARRAYSIZE(szClient)))
        {
            // Is it a Microsoft client that isn't the Windows default?
            if (_GetClientTier(szClient) == CBT_MS)
            {
                bResult = true;
            }
        }
        RegCloseKey(hkClient);
    }
    return bResult;
}

//
//  Called after the entire tree has been parsed and hosted.
//  (Sort of like readystatecomplete.)
//
HRESULT ClientBlock::ParseCompleted(ARPFrame *paf)
{
    HRESULT hr = S_OK;

    Value* pv;
    hr = _slOtherMSClients.SetStringList(GetOtherMSClientsString(&pv));
    pv->Release();

    if (SUCCEEDED(hr))
    {
        hr = paf->CreateElement(L"clientblockselector", NULL, (Element**)&_peSel);
        if (SUCCEEDED(hr))
        {
            hr = Add(_peSel);
            if (SUCCEEDED(hr))
            {
                // Failure to open the client key is not fatal; it just means that
                // there are vacuously no clients.

                HKEY hkClient = _OpenClientKey();
                if (hkClient)
                {
                    //  Enumerate each app under the client key and look for those which
                    //  have a "InstallInfo" subkey.
                    TCHAR szKey[MAX_PATH];
                    for (DWORD dwIndex = 0;
                         SUCCEEDED(hr) &&
                         RegEnumKey(hkClient, dwIndex, szKey, ARRAYSIZE(szKey)) == ERROR_SUCCESS;
                         dwIndex++)
                    {
                        HKEY hkApp;
                        if (RegOpenKeyEx(hkClient, szKey, 0, KEY_READ, &hkApp) == ERROR_SUCCESS)
                        {
                            HKEY hkInfo;
                            if (RegOpenKeyEx(hkApp, TEXT("InstallInfo"), 0, KEY_READ, &hkInfo) == ERROR_SUCCESS)
                            {
                                // Woo-hoo, this client provided install info
                                // Let's see if it's complete.
                                CLIENTINFO* pci = CLIENTINFO::Create(hkApp, hkInfo, szKey);
                                if (pci)
                                {
                                    if (SUCCEEDED(hr = _pdaClients->Add(pci)))
                                    {
                                        // success
                                    }
                                    else
                                    {
                                        pci->Delete();
                                    }
                                }

                                RegCloseKey(hkInfo);
                            }
                            RegCloseKey(hkApp);
                        }
                    }

                    RegCloseKey(hkClient);

                    //
                    //  Sort the clients alphabetically to look nice.
                    //  (Otherwise they show up alphabetical by registry key name,
                    //  which is not very useful to an end-user.)
                    //
                    _pdaClients->Sort(CLIENTINFO::QSortCMP);

                }

                //
                //  Insert "Keep unchanged" and "Pick from list".
                //  Do this after sorting because we want those two
                //  to be at the top.  Since we are adding to the top,
                //  we add them in the reverse order so
                //  "Keep unchanged" = 1, "Pick from list" = 0.
                hr = AddStaticClientInfoToTop(KeepTextProp);
                if (SUCCEEDED(hr))
                {
                    hr = AddStaticClientInfoToTop(PickTextProp);
                }

                //  Now create one row for each client we found
                //  Start at i=1 to skip over "Pick from list"
                for (UINT i = 1; SUCCEEDED(hr) && i < _pdaClients->GetSize(); i++)
                {
                    CLIENTINFO* pci = _pdaClients->GetItem(i);
                    Element* pe;
                    hr = paf->CreateElement(L"clientitem", NULL, &pe);
                    if (SUCCEEDED(hr))
                    {
                        hr = _peSel->Add(pe);
                        if (SUCCEEDED(hr))
                        {
                            pci->_pe = pe;

                            // Set friendly name
                            pci->SetFriendlyName(pci->_pszName);

                            if (pci->IsSentinel())
                            {
                                // "Keep Unchanged" loses the checkboxes and defaults selected
                                // Merely hide the checkboxes instead of destroying them;
                                // this keeps RowLayout happy.
                                FindDescendentByName(pe, L"show")->SetVisible(false);
                                _peSel->SetSelection(pe);
                            }
                            else
                            {
                                // Others initialize the checkbox and default unselected
                                pci->SetShowCheckbox(pci->_bShown);
                            }

                        }
                        else // _peSel->Add(pe) failed
                        {
                            pe->Destroy();
                        }
                    }
                }
            }
            else // Add(_peSel) failed
            {
                _peSel->Destroy();
                _peSel = NULL;
            }

        }
    }

    return hr;
}

HRESULT ClientBlock::AddStaticClientInfoToTop(PropertyInfo* ppi)
{
    HRESULT hr;
    Value* pv;
    pv = GetValue(ppi, PI_Specified);
    CLIENTINFO* pci = CLIENTINFO::Create(NULL, NULL, pv->GetString());
    pv->Release();

    if (pci)
    {
        if (SUCCEEDED(hr = _pdaClients->Insert(0, pci)))
        {
            // maybe this block has a custom replacement text for the
            // Microsoft section if the current app is a Microsoft app.
            GetKeepMSTextString(&pci->_pvMSName);
        }
        else
        {
            pci->Delete();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

ClientBlock::CBTIER ClientBlock::_GetClientTier(LPCTSTR pszClient)
{
    Value* pv;
    LPWSTR pwsz;

    // Highest tier is "Windows default client"

    pwsz = GetWindowsClientString(&pv);
    bool bRet = pwsz && AreEnglishStringsEqual(pwsz, pszClient);
    pv->Release();

    if (bRet)
    {
        return CBT_WINDOWSDEFAULT;
    }

    // next best is "Microsoft client"
    if (_slOtherMSClients.IsStringInList(pszClient))
    {
        return CBT_MS;
    }

    // otherwise, it's a thirdparty app
    return CBT_NONMS;
}

//
//  Based on the filter, determine whether the specified item should
//  be shown, hidden, or left alone (returned as a TRIBIT), and optionally
//  determine whether the item should be added to the client picker.
//
TRIBIT ClientBlock::_GetFilterShowAdd(CLIENTINFO* pci, ClientPicker* pcp, bool* pbAdd)
{
    bool bAdd = false;
    TRIBIT tShow = TRIBIT_UNDEFINED;

    CBTIER cbt = _GetClientTier(pci->_pszKey);

    switch (pcp->GetFilter())
    {
    case CLIENTFILTER_OEM:
        //
        // Add the one that is marked "OEM Default".
        // (Caller will catch the "more than one" scenario.)
        // Set show/hide state according to OEM preference.
        //
        bAdd = pci->_bOEMDefault;
        if (bAdd) {
            tShow = TRIBIT_TRUE;
        } else {
            tShow = pci->_tOEMShown;
        }
        break;

    case CLIENTFILTER_MS:
        //
        //  Add the Windows preferred client.
        //  Show all applications except for "keep unchanged" (which
        //  isn't really an application anyway).
        //
        bAdd = IsWindowsDefaultClient(cbt);
        tShow = TRIBIT_TRUE;
        break;

    case CLIENTFILTER_NONMS:
        //
        //  Hide all Microsoft clients.
        //  Add all thirdparty clients and show them.
        //
        if (IsMicrosoftClient(cbt))
        {
            bAdd = false;
            tShow = TRIBIT_FALSE;
        }
        else
        {
            bAdd = true;
            tShow = TRIBIT_TRUE;
        }
        break;

    default:
        DUIAssert(0, "Invalid client filter category");
        break;
    }

    if (pbAdd)
    {
        *pbAdd = bAdd;
    }

    if (pci->IsSentinel())
    {
        tShow = TRIBIT_UNDEFINED;
    }

    return tShow;
}

//
//  On success, returns the number of items added
//  (not counting "Keep unchanged")
//

HRESULT ClientBlock::InitializeClientPicker(ClientPicker* pcp)
{
    HRESULT hr = S_OK;

    ARPFrame* paf = FindAncestorElement<ARPFrame>(this);

    // Walk our children looking for ones that match the filter.
    HKEY hkClient = _OpenClientKey();
    if (hkClient)
    {
        if (SUCCEEDED(paf->CreateElement(L"oemclientshowhide", NULL, &pcp->_peShowHide)))
        {
            // Insert the template after our parent
            Element* peParent = pcp->GetParent();
            peParent->GetParent()->Insert(pcp->_peShowHide, peParent->GetIndex() + 1);
        }

        // Note!  Start loop with 2 because we don't care about
        // "Pick from list" or "Keep Unchanged" yet
        DUIAssert(_pdaClients->GetItem(0)->IsPickFromList(), "GetItem(0) must be 'Pick from list'");
        DUIAssert(_pdaClients->GetItem(1)->IsKeepUnchanged(), "GetItem(1) must be 'Keep unchanged'");
        for (UINT i = 2; SUCCEEDED(hr) && i < _pdaClients->GetSize(); i++)
        {
            CLIENTINFO* pci = _pdaClients->GetItem(i);
            bool bAdd;
            TRIBIT tShow = _GetFilterShowAdd(pci, pcp, &bAdd);

            if (pcp->_peShowHide)
            {
                switch (tShow)
                {
                case TRIBIT_TRUE:
                    pcp->AddClientToOEMRow(L"show", pci);
                    pcp->SetNotEmpty();
                    break;

                case TRIBIT_FALSE:
                    pcp->AddClientToOEMRow(L"hide", pci);
                    pcp->SetNotEmpty();
                    break;
                }
            }

            if (bAdd)
            {
                hr = pcp->GetClientList()->Add(pci);
                pcp->SetNotEmpty();
            }

        }

        RegCloseKey(hkClient);
    }

    if (SUCCEEDED(hr))
    {
        // Now some wacko cleanup rules.

        switch (pcp->GetFilter())
        {
        case CLIENTFILTER_OEM:
            // There can be only one OEM default item.
            // If there's more than one (OEM or app trying to cheat),
            // then throw them all away.
            if (pcp->GetClientList()->GetSize() != 1)
            {
                pcp->GetClientList()->Reset(); // throw away everything
            }
            break;

        case CLIENTFILTER_MS:
            // If the current client is not the default client but
            // does belong to Microsoft, then add "Keep unchanged"
            // and select it.  What's more, save the current string
            // to be used if the user picks the Windows client,
            // then append the Windows app to the "Also Show" string
            // and save that too.
            if (_IsCurrentClientNonWindowsMS())
            {
                hr = pcp->AddKeepUnchanged(_pdaClients->GetItem(1));
            }
            break;

        case CLIENTFILTER_NONMS:
            // If there is more than one available, then insert
            // "Pick an app"
            if (pcp->GetClientList()->GetSize() > 1)
            {
                hr = pcp->GetClientList()->Insert(0, _pdaClients->GetItem(0)); // insert "pick an app"
            }
            break;
        }

        // If there are no items, then add "Keep unchanged"
        if (pcp->GetClientList()->GetSize() == 0)
        {
            hr = pcp->GetClientList()->Add(_pdaClients->GetItem(1)); // add "keep unchanged"
        }
    }

    if (pcp->_peShowHide)
    {
        _RemoveEmptyOEMRow(pcp->_peShowHide, L"show");
        _RemoveEmptyOEMRow(pcp->_peShowHide, L"hide");
    }

    return hr;
}

HRESULT ClientPicker::AddKeepUnchanged(CLIENTINFO* pciKeepUnchanged)
{
    HRESULT hr = GetClientList()->Insert(0, pciKeepUnchanged); // insert "keep unchanged"
    return hr;
}

void ClientPicker::AddClientToOEMRow(LPCWSTR pszName, CLIENTINFO* pci)
{
    Element* peRow = FindDescendentByName(_peShowHide, pszName);
    Element* peList = FindDescendentByName(peRow, L"list");
    Value* pv;

    LPCWSTR pszContent = peList->GetContentString(&pv);
    if (!pszContent)
    {
        _SetStaticTextAndAccName(peList, pci->_pszName);
    }
    else
    {
        TCHAR szFormat[20];
        LPCWSTR rgpszInsert[2] = { pszContent, pci->_pszName };
        LoadString(g_hinstSP1, IDS_APPWIZ_ADDITIONALCLIENTFORMAT, szFormat, SIZECHARS(szFormat));
        LPWSTR pszFormatted;

        if (FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           szFormat, 0, 0, (LPWSTR)&pszFormatted, 0, (va_list*)rgpszInsert))
        {
            _SetStaticTextAndAccName(peList, pszFormatted);
            LocalFree(pszFormatted);
        }
    }
    pv->Release();
}

void ClientBlock::_RemoveEmptyOEMRow(Element* peShowHide, LPCWSTR pszName)
{
    Element* peRow = FindDescendentByName(peShowHide, pszName);
    Element* peList = FindDescendentByName(peRow, L"list");
    Value* pv;

    LPCWSTR pszContent = peList->GetContentString(&pv);
    if (!pszContent || !pszContent[0])
    {
        peRow->Destroy();
    }
    pv->Release();
}

// Take the setting from the ClientPicker and copy it to the Custom item
// This is done in preparation for Apply()ing the custom item to make the
// changes stick.
HRESULT ClientBlock::TransferFromClientPicker(ClientPicker* pcp)
{
    HRESULT hr = S_OK;
    CLIENTINFO* pciSel = pcp->GetSelectedClient();

    for (UINT i = 0; SUCCEEDED(hr) && i < _pdaClients->GetSize(); i++)
    {
        CLIENTINFO* pci = _pdaClients->GetItem(i);

        // If this is the one the guy selected, then select it here too
        if (pci == pciSel && _peSel)
        {
            if (pci->IsPickFromList())
            {
                // "Pick from list" -> "Keep unchanged"
                _peSel->SetSelection(_pdaClients->GetItem(1)->GetSetDefault());
            }
            else
            {
                _peSel->SetSelection(pci->GetSetDefault());
            }
        }

        // Transfer the hide/show setting into the element
        TRIBIT tShow = _GetFilterShowAdd(pci, pcp, NULL);

        if (tShow != TRIBIT_UNDEFINED)
        {
            pci->SetShowCheckbox(tShow == TRIBIT_TRUE);
        }
    }
    return hr;
}

//
//  Okay, here it is, the whole reason we're here.  Apply the user's
//  choices.
//
HRESULT ClientBlock::Apply(ARPFrame* paf)
{
    HRESULT hr = S_OK;
    HKEY hkClient = _OpenClientKey(HKEY_LOCAL_MACHINE, KEY_READ | KEY_WRITE);
    if (hkClient)
    {
        // Note!  Start loop with 2 because we don't care about applying "Keep Unchanged"
        // or "Pick an app"
        DUIAssert(_pdaClients->GetItem(0)->IsPickFromList(), "GetItem(0) must be 'Pick from list'");
        DUIAssert(_pdaClients->GetItem(1)->IsKeepUnchanged(), "GetItem(1) must be 'Keep unchanged'");
        for (UINT i = 2; SUCCEEDED(hr) && i < _pdaClients->GetSize(); i++)
        {
            CLIENTINFO* pci = _pdaClients->GetItem(i);

            TCHAR szBuf[MAX_PATH];
            wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s\\InstallInfo"), pci->_pszKey);
            HKEY hkInfo;
            if (RegOpenKeyEx(hkClient, szBuf, 0, KEY_READ, &hkInfo) == ERROR_SUCCESS)
            {
                // Always do hide/show first.  That way, an application being
                // asked to set itself as the default always does so while its
                // icons are shown.

                bool bShow = pci->IsShowChecked();
                if (bShow != pci->_bShown)
                {
                    if (pci->GetInstallCommand(hkInfo, bShow ? TEXT("ShowIconsCommand") : TEXT("HideIconsCommand"),
                                               szBuf, DUIARRAYSIZE(szBuf)))
                    {
                        hr = paf->LaunchClientCommandAndWait(bShow ? IDS_APPWIZ_SHOWINGICONS : IDS_APPWIZ_HIDINGICONS, pci->_pszName, szBuf);
                    }
                }

                if (pci->GetSetDefault()->GetSelected())
                {
                    if (pci->GetInstallCommand(hkInfo, TEXT("ReinstallCommand"),
                                               szBuf, DUIARRAYSIZE(szBuf)))
                    {
                        FILETIME ft;
                        GetSystemTimeAsFileTime(&ft);
                        SHSetValue(hkClient, NULL, TEXT("LastUserInitiatedDefaultChange"),
                                   REG_BINARY, &ft, sizeof(ft));
                        hr = paf->LaunchClientCommandAndWait(IDS_APPWIZ_SETTINGDEFAULT, pci->_pszName, szBuf);
                    }
                }

                RegCloseKey(hkInfo);
            }
        }
        RegCloseKey(hkClient);
    }
    return hr;
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// ClientType property
static int vvClientType[] = { DUIV_STRING, -1 };
static PropertyInfo impClientTypeProp = { L"ClientType", PF_Normal, 0, vvClientType, NULL, Value::pvStringNull };
PropertyInfo* ClientBlock::ClientTypeProp = &impClientTypeProp;

// WindowsClient property
static int vvWindowsClient[] = { DUIV_STRING, -1 };
static PropertyInfo impWindowsClientProp = { L"WindowsClient", PF_Normal, 0, vvWindowsClient, NULL, Value::pvStringNull };
PropertyInfo* ClientBlock::WindowsClientProp = &impWindowsClientProp;

// OtherMSClients property
static int vvOtherMSClients[] = { DUIV_STRING, -1 };
static PropertyInfo impOtherMSClientsProp = { L"OtherMSClients", PF_Normal, 0, vvOtherMSClients, NULL, Value::pvStringNull };
PropertyInfo* ClientBlock::OtherMSClientsProp = &impOtherMSClientsProp;

// KeepText property
static int vvKeepText[] = { DUIV_STRING, -1 };
static PropertyInfo impKeepTextProp = { L"KeepText", PF_Normal, 0, vvKeepText, NULL, Value::pvStringNull };
PropertyInfo* ClientBlock::KeepTextProp = &impKeepTextProp;

// KeepMSText property
static int vvKeepMSText[] = { DUIV_STRING, -1 };
static PropertyInfo impKeepMSTextProp = { L"KeepMSText", PF_Normal, 0, vvKeepMSText, NULL, Value::pvStringNull };
PropertyInfo* ClientBlock::KeepMSTextProp = &impKeepMSTextProp;

// PickText property
static int vvPickText[] = { DUIV_STRING, -1 };
static PropertyInfo impPickTextProp = { L"PickText", PF_Normal, 0, vvPickText, NULL, Value::pvStringNull };
PropertyInfo* ClientBlock::PickTextProp = &impPickTextProp;

// Class properties
PropertyInfo* _aClientBlockPI[] = {
    ClientBlock::ClientTypeProp,
    ClientBlock::WindowsClientProp,
    ClientBlock::OtherMSClientsProp,
    ClientBlock::KeepTextProp,
    ClientBlock::KeepMSTextProp,
    ClientBlock::PickTextProp,
};

// Define class info with type and base type, set static class pointer
IClassInfo* ClientBlock::Class = NULL;
HRESULT ClientBlock::Register()
{
    return ClassInfo<ClientBlock,super>::Register(L"clientblock", _aClientBlockPI, DUIARRAYSIZE(_aClientBlockPI));
}


////////////////////////////////////////////////////////
// Expandable class
//
//  Base class for Expando and Clipper.  It is just an element
//  with an "expanded" property.  This property inherits from parent
//  to child.  This is used so Clipper can inherit (and therefore
//  react to) the expanded state of its parent Expando.
//

HRESULT Expandable::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Expandable* pe = HNew<Expandable>();
    if (!pe)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pe->Initialize(0);
    if (FAILED(hr))
    {
        pe->Destroy();
        return hr;
    }

    *ppElement = pe;

    return S_OK;
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { DUIV_INT, -1 }; StaticValue(svDefault!!!, DUIV_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

// Expanded property
static int vvExpanded[] = { DUIV_BOOL, -1 };
static PropertyInfo impExpandedProp = { L"Expanded", PF_Normal|PF_Inherit, 0, vvExpanded, NULL, Value::pvBoolTrue };
PropertyInfo* Expandable::ExpandedProp = &impExpandedProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
PropertyInfo* _aExpandablePI[] = { Expandable::ExpandedProp };

// Define class info with type and base type, set static class pointer
IClassInfo* Expandable::Class = NULL;
HRESULT Expandable::Register()
{
    return ClassInfo<Expandable,super>::Register(L"Expandable", _aExpandablePI, DUIARRAYSIZE(_aExpandablePI));
}

////////////////////////////////////////////////////////
// Expando class
//
//  An Expando element works in conjunction with a Clipper element
//  to provide expand/collapse functionality.
//
//  The Expando element manages the expanded/contracted state.
//  The Expando element has two child elements:
//
//      The first element is a button (the "header").
//      The second element is a Clipper.
//
//  The Clipper vanishes when contracted and is shown when expanded.
//  The header is always shown.
//
//  One of the elements in the header must be a button of type "arrow".
//  Clicking this button causes the Expando to expand/collapse.
//
//  A click on any other element causes an Expando::Click event
//  to fire (to be caught by an ancestor element.)
//
//  The "selected" property on the "arrow" tracks the "expanded"
//  property on the Expando.
//

DefineClassUniqueID(Expando, Click)

HRESULT Expando::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Expando* pex = HNewAndZero<Expando>();
    if (!pex)
        return E_OUTOFMEMORY;

    HRESULT hr = pex->Initialize();
    if (FAILED(hr))
    {
        pex->Destroy();
        return hr;
    }

    *ppElement = pex;

    return S_OK;
}

HRESULT Expando::Initialize()
{
    HRESULT hr;

    // Initialize base
    hr = super::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize
    _fExpanding = false;

    return S_OK;
}

Clipper* Expando::GetClipper()
{
    Element* pe = GetNthChild(this, 1);
    DUIAssertNoMsg(pe->GetClassInfo()->IsSubclassOf(Clipper::Class));
    return (Clipper*)pe;
}

//
//  Do this so ARPSelector will select us and deselect our siblings
//
void Expando::FireClickEvent()
{
    Event e;
    e.uidType = Expando::Click;
    FireEvent(&e);      // Will route and bubble
}

void Expando::OnEvent(Event* pev)
{
    if (pev->nStage == GMF_BUBBLED)
    {
        if (pev->uidType == Button::Click)
        {
            pev->fHandled = true;

            // Clicking the arrow toggles the expanded state
            if (pev->peTarget->GetID() == StrToID(L"arrow"))
            {
                SetExpanded(!GetExpanded());
            }
            else
            {
                // Clicking anything else activates our section
                FireClickEvent();
            }
        }
    }

    Element::OnEvent(pev);
}

////////////////////////////////////////////////////////
// System events

HRESULT _SetParentExpandedProp(ClientPicker* pcp, LPARAM lParam)
{
    Value* pv = (Value*)lParam;
    pcp->SetValue(ClientPicker::ParentExpandedProp, PI_Local, pv);
    return S_OK;
}

void Expando::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Do default processing
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    if (IsProp(Selected))
    {
        // BUGBUG something goes here?
    }
    else if (IsProp(Expanded))
    {
        // Update height of clipper based on expanded state
        Element* pe = GetClipper();
        if (pe)
        {
            // The following will cause a relayout, mark object so that
            // when the expando's Extent changes, it'll go through
            // with the EnsureVisible. Otherwise, it's being resized
            // as a result of something else. In which case, do nothing.
            _fExpanding = true;

            // To achieve "pulldown" animation, we use a clipper control that will
            // size it's child based on it's unconstrained desired size in its Y direction.
            // We also push the Expanded property into all child ClientPicker
            // elements as the Selected property so they can turn static when
            // collapsed.
            if (pvNew->GetBool())
            {
                pe->RemoveLocalValue(HeightProp);
            }
            else
            {
                pe->SetHeight(0);
            }
            TraverseTree<ClientPicker>(pe, _SetParentExpandedProp, (LPARAM)pvNew);
        }
        // child Clipper object inherits the Expanded state

        // Push the Expanded state as the arrow's Selected state
        FindDescendentByName(this, L"arrow")->SetValue(SelectedProp, PI_Local, pvNew);

    }
    else if (IsProp(Extent))
    {
        if (_fExpanding && GetExpanded())
        {
            _fExpanding = false;

            // On extent, we want to ensure that not just the client area but
            // also the bottom margin of the expando is visible.  Why?  Simply
            // because it looks better to scroll the expando plus its margin
            // into view versus just the expando.
            //
            Value* pvSize;
            Value* pvMargin;
            const SIZE* psize = GetExtent(&pvSize);
            const RECT* prect = GetMargin(&pvMargin);
            EnsureVisible(0, 0, psize->cx, psize->cy + prect->bottom);
            pvSize->Release();
            pvMargin->Release();
        }
    }
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* Expando::Class = NULL;
HRESULT Expando::Register()
{
    return ClassInfo<Expando,super>::Register(L"Expando", NULL, 0);
}

////////////////////////////////////////////////////////
//
//  Clipper class
//
//  Used to do the smooth hide/show animation.
//
//  The Clipper element animates away its one child, typically
//  an <element> with layout and inner child elements.
//

HRESULT Clipper::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Clipper* pc = HNewAndZero<Clipper>();
    if (!pc)
        return E_OUTOFMEMORY;

    HRESULT hr = pc->Initialize();
    if (FAILED(hr))
    {
        pc->Destroy();
        return hr;
    }

    *ppElement = pc;

    return S_OK;
}

HRESULT Clipper::Initialize()
{
    // Initialize base
    HRESULT hr = super::Initialize(EC_SelfLayout); // Normal display node creation, self layout
    if (FAILED(hr))
        return hr;

    // Children can exist outside of Element bounds
    SetGadgetStyle(GetDisplayNode(), GS_CLIPINSIDE, GS_CLIPINSIDE);

    return S_OK;
}

////////////////////////////////////////////////////////
// Self-layout methods

SIZE Clipper::_SelfLayoutUpdateDesiredSize(int cxConstraint, int cyConstraint, Surface* psrf)
{
    UNREFERENCED_PARAMETER(cyConstraint);

    SIZE size = { 0, 0 };

    // Desired size of this is based solely on it's first child.
    // Width is child's width, height is unconstrained height of child.
    Element* pec = GetNthChild(this, 0);
    if (pec)
    {
        size = pec->_UpdateDesiredSize(cxConstraint, INT_MAX, psrf);

        if (size.cx > cxConstraint)
            size.cx = cxConstraint;
        if (size.cy > cyConstraint)
            size.cy = cyConstraint;
    }

    return size;
}

void Clipper::_SelfLayoutDoLayout(int cx, int cy)
{

    // Layout first child giving it's desired height and aligning
    // it with the clipper's bottom edge
    Element* pec = GetNthChild(this, 0);
    if (pec)
    {
        const SIZE* pds = pec->GetDesiredSize();

        pec->_UpdateLayoutPosition(0, cy - pds->cy);
        pec->_UpdateLayoutSize(cx, pds->cy);
    }
}

////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* Clipper::Class = NULL;
HRESULT Clipper::Register()
{
    return ClassInfo<Clipper,super>::Register(L"Clipper", NULL, 0);
}

////////////////////////////////////////////////////////
// GradientLine class
//
//  This is necessary for two reasons.
//
//  1.  gradient(...) doesn't support FILLTYPE_TriHGradient.
//      The code to implement tri-gradients exists only in
//      the GdiPlus version.  We can fake it by putting two
//      FILLTYPE_HGradient elements next to each other, except
//      for the second problem...
//  2.  gradient(...) doesn't support system colors like "buttonface".
//

HRESULT GradientLine::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    GradientLine* pe = HNew<GradientLine>();
    if (!pe)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pe->Initialize(0);
    if (FAILED(hr))
    {
        pe->Destroy();
        return hr;
    }

    *ppElement = pe;

    return S_OK;
}

COLORREF GradientLine::GetColorProperty(PropertyInfo* ppi)
{
    // on failure, use transparent color (i.e., nothing happens)
    COLORREF cr = ARGB(0xFF, 0, 0, 0);

    Value* pv = GetValue(ppi, PI_Specified);
    switch (pv->GetType())
    {
    case DUIV_INT:
        cr = ColorFromEnumI(pv->GetInt());
        break;

    case DUIV_FILL:
        {
            const Fill* pf = pv->GetFill();
            if (pf->dType == FILLTYPE_Solid)
            {
                cr = pf->ref.cr;
            }
            else
            {
                DUIAssert(0, "GradientLine supports only solid colors");
            }
        }
        break;

    default:
        DUIAssert(0, "GradientLine supports only solid colors");
    }
    pv->Release();

    return cr;
}

void GradientLine::Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent)
{
    // Paint default except content
    RECT rcContent;
    Element::Paint(hDC, prcBounds, prcInvalid, prcSkipBorder, &rcContent);

    // Render gradient content if requested
    if (!prcSkipContent)
    {
        //
        //  Vertices are as indicated.  The two rectangles are (0-1) and (1-2).
        //
        //  0(bgcolor)                         2(bgcolor)
        //  +-----------------+----------------+
        //  |                                  |
        //  |                                  |
        //  |                                  |
        //  +-----------------+----------------+
        //                    1(fgcolor)

        TRIVERTEX rgvert[3];
        GRADIENT_RECT rggr[2];
        COLORREF cr;

        cr = GetColorProperty(BackgroundProp);
        rgvert[0].x     = rcContent.left;
        rgvert[0].y     = rcContent.top;
        rgvert[0].Red   = GetRValue(cr) << 8;
        rgvert[0].Green = GetGValue(cr) << 8;
        rgvert[0].Blue  = GetBValue(cr) << 8;
        rgvert[0].Alpha = GetAValue(cr) << 8;

        rgvert[2] = rgvert[0];
        rgvert[2].x     = rcContent.right;

        cr = GetColorProperty(ForegroundProp);
        rgvert[1].x     = (rcContent.left + rcContent.right) / 2;
        rgvert[1].y     = rcContent.bottom;
        rgvert[1].Red   = GetRValue(cr) << 8;
        rgvert[1].Green = GetGValue(cr) << 8;
        rgvert[1].Blue  = GetBValue(cr) << 8;
        rgvert[1].Alpha = GetAValue(cr) << 8;

        rggr[0].UpperLeft = 0;
        rggr[0].LowerRight = 1;
        rggr[1].UpperLeft = 1;
        rggr[1].LowerRight = 2;
        GradientFill(hDC, rgvert, DUIARRAYSIZE(rgvert), rggr, DUIARRAYSIZE(rggr), GRADIENT_FILL_RECT_H);
    }
    else
    {
        *prcSkipContent = rcContent;
    }
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* GradientLine::Class = NULL;
HRESULT GradientLine::Register()
{
    return ClassInfo<GradientLine,super>::Register(L"GradientLine", NULL, 0);
}


////////////////////////////////////////////////////////
// BigElement class
//
//  This is necessary because the DUI parser limits rcstr() to 256
//  characters and we have strings that are dangerously close to that
//  limit.  (So localization will likely push them over the limit.)
//

HRESULT BigElement::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    BigElement* pe = HNew<BigElement>();
    if (!pe)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pe->Initialize(0);
    if (FAILED(hr))
    {
        pe->Destroy();
        return hr;
    }

    *ppElement = pe;

    return S_OK;
}

void BigElement::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Do default processing
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    if (IsProp(StringResID))
    {
        UINT uID = pvNew->GetInt();
        HRSRC hrsrc = FindResource(g_hinstSP1, (LPTSTR)(LONG_PTR)(1 + uID / 16), RT_STRING);
        if (hrsrc)
        {
            PWCHAR pwch = (PWCHAR)LoadResource(g_hinstSP1, hrsrc);
            if (pwch)
            {
                // Now skip over strings until we hit the one we want.
                for (uID %= 16; uID; uID--)
                {
                    pwch += *pwch + 1;
                }

                // Found it -- load the entire string and set it
                LPWSTR pszString = new WCHAR[*pwch + 1];
                if (pszString)
                {
                    memcpy(pszString, pwch+1, *pwch * sizeof(WCHAR));
                    pszString[*pwch] = L'\0';
                    SetContentString(pszString);
                    SetAccName(pszString);
                    delete[] pszString;
                }
            }
        }
    }
}


////////////////////////////////////////////////////////
// Property definitions

// StringResID property
static int vvStringResID[] = { DUIV_INT, -1 };
static PropertyInfo impStringResIDProp = { L"StringResID", PF_Normal, 0, vvStringResID, NULL, Value::pvIntZero };
PropertyInfo* BigElement::StringResIDProp = &impStringResIDProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
PropertyInfo* _aBigElementPI[] = { BigElement::StringResIDProp };

// Define class info with type and base type, set static class pointer
IClassInfo* BigElement::Class = NULL;
HRESULT BigElement::Register()
{
    return ClassInfo<BigElement,super>::Register(L"BigElement", _aBigElementPI, DUIARRAYSIZE(_aBigElementPI));
}


////////////////////////////////////////////////////////
// ARP Parser callback

void CALLBACK ARPParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR buf[201];

    if (dLine != -1)
        wnsprintf(buf, ARRAYSIZE(buf), L"%s '%s' at line %d", pszError, pszToken, dLine);
    else
        wnsprintf(buf, ARRAYSIZE(buf), L"%s '%s'", pszError, pszToken);

    MessageBoxW(NULL, buf, L"Parser Message", MB_OK);
}

void inline SetElementAccessability(Element* pe, bool bAccessible, int iRole, LPCWSTR pszAccName)
{
    if (pe) 
    {
        pe->SetAccessible(bAccessible);
        pe->SetAccRole(iRole);
        pe->SetAccName(pszAccName);
    }
}

void EnablePane(Element* pePane, bool fEnable)
{
    if (fEnable)
    {
        pePane->SetLayoutPos(BLP_Client);
        EnableElementTreeAccessibility(pePane);
    }
    else
    {
        pePane->SetLayoutPos(LP_None);
        DisableElementTreeAccessibility(pePane);
    }
}

void BestFitOnDesktop(RECT* r)
{
    ASSERT(r != NULL);
    
    RECT wr; // Rect to hold size of work area
    
    if (SystemParametersInfo(SPI_GETWORKAREA, 0, &wr, 0)) 
    {
        if ((wr.right-wr.left) < ARP_DEFAULT_WIDTH) 
        {
            // Default width is too large, use the entire width of the desktop area
            r->left = wr.left;
            r->right = wr.right - wr.left;
        }
        else 
        {
            // Center on screen using default width
            r->left = wr.left + (((wr.right-wr.left) - ARP_DEFAULT_WIDTH) / 2);
            r->right = ARP_DEFAULT_WIDTH;
        }

        if ((wr.bottom-wr.top) < ARP_DEFAULT_HEIGHT)
        {
            // Default height is too large, use the entire height of the desktop area
            r->top = wr.top;
            r->bottom = wr.bottom - wr.top;
        }
        else
        {
            // Center on screen using default height
            r->top = wr.top + (((wr.bottom-wr.top) - ARP_DEFAULT_HEIGHT) / 2); 
            r->bottom = ARP_DEFAULT_HEIGHT;
        }
    }
    else
    {
        // Don't know why the function would fail, but if it does just use the default size
        // and position
        SetRect(r, 
                ARP_DEFAULT_POS_X,
                ARP_DEFAULT_POS_Y,
                ARP_DEFAULT_WIDTH,
                ARP_DEFAULT_HEIGHT);
    }
}

////////////////////////////////////////////////////////
// ARP entry point

DWORD WINAPI PopulateInstalledItemList(void* paf);

STDAPI ARP(HWND hWnd, int nPage)
{
    HRESULT hr;
    Parser* pParser = NULL;
    NativeHWNDHost* pnhh = NULL;
    ARPFrame* paf = NULL;
    Element* pe = NULL;
    RECT rect;
    
    WCHAR szTemp[1024];

    g_hinstSP1 = LoadLibraryFromSystem32Directory(TEXT("XPSP1RES.DLL"));

    if (!g_hinstSP1)
    {
        goto Failure;
    }

    // DirectUI init process
    hr = InitProcess();
    if (FAILED(hr))
        goto Failure;

    // Register classes
    hr = ARPFrame::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ARPItem::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ARPHelp::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ARPSupportItem::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ARPSelector::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ClientPicker::Register();
    if (FAILED(hr))
        goto Failure;

    hr = AutoButton::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ClientBlock::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Expandable::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Expando::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Clipper::Register();
    if (FAILED(hr))
        goto Failure;

    hr = GradientLine::Register();
    if (FAILED(hr))
        goto Failure;

    hr = BigElement::Register();
    if (FAILED(hr))
        goto Failure;

    // DirectUI init thread
    hr = InitThread();
    if (FAILED(hr))
        goto Failure;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
        goto Failure;

    Element::StartDefer();

    // Create host
    LoadStringW(g_hinst, IDS_ARPTITLE, szTemp, DUIARRAYSIZE(szTemp));

    BestFitOnDesktop(&rect);
    hr = NativeHWNDHost::Create(szTemp, hWnd, LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_CPLICON)), rect.left, rect.top, rect.right, rect.bottom, WS_EX_APPWINDOW, WS_OVERLAPPEDWINDOW, 0, &pnhh);
    if (FAILED(hr))
        goto Failure;   

    hr = ARPFrame::Create(pnhh, true, (Element**)&paf);
    if (FAILED(hr))
        goto Failure;

    // Load resources
    ARPParser::Create(paf, IDR_APPWIZ_ARP, g_hinst, ARPParseError, &pParser);

    if (!pParser || pParser->WasParseError())
        goto Failure;

    pParser->CreateElement(L"main", paf, &pe);
    if (pe && // Fill contents using substitution
        paf->Setup(pParser, nPage)) // Set ARPFrame state (incluing ID initialization)
    {
        // Set visible and host
        paf->SetVisible(true);
        pnhh->Host(paf);

        Element::EndDefer();

        // Do initial show
        pnhh->ShowWindow();
        Element* peClose = ((ARPFrame*)pe)->FallbackFocus();
        if (peClose)
        {
            peClose->SetKeyFocus();
        }

        if (!paf->IsChangeRestricted())
        {
            paf->UpdateInstalledItems();
        }

        // Pump messages
        MSG msg;
        bool fDispatch = true;
        while (GetMessageW(&msg, 0, 0, 0) != 0)
        {
            // Check for destruction of top-level window (always async)
            if (msg.hwnd == pnhh->GetHWND() && msg.message == NHHM_ASYNCDESTROY)
            {
                // Async destroy requested, clean up secondary threads

                // Signal that secondary threads should complete as soon as possible
                // Any requests from secondary threads will be ignored
                // No more secondary threads will be allowed to start
                g_fRun = false;

                // Hide window, some threads may need more time to exit normally
                pnhh->HideWindow();

                // Don't dispatch this one
                if (!g_fAppShuttingDown)
                    fDispatch = false;
            }

            // Check for pending threads
            if (!g_fRun)
            {
                if (!ARPFrame::htPopulateInstalledItemList && 
                    !ARPFrame::htPopulateAndRenderOCSetupItemList &&
                    !ARPFrame::htPopulateAndRenderPublishedItemList)
                {
                    if (!g_fAppShuttingDown)
                    {
                        // Done, reissue async destroy
                        DUITrace(">> App shutting down, async destroying main window\n");
                        g_fAppShuttingDown = true;
                        pnhh->DestroyWindow();
                    }
                }
            }
        
            if (fDispatch)
            {
                TranslateMessage(&msg);
                DispatchMessageW(&msg);
            }
            else
                fDispatch = true;
        }

        // paf will be deleted by native HWND host when destroyed
    }
    else
        Element::EndDefer();

Failure:

    if (pnhh)
    {
        if (pnhh->GetHWND())
        {
            // In the error case we didn't destroy the window cleanly, so
            // we need to do it viciously.  Cannot use pnhh->DestroyWindow()
            // because that defers the destroy but we need it to happen now.
            DestroyWindow(pnhh->GetHWND());
        }
        pnhh->Destroy();
    }
    if (pParser)
        pParser->Destroy();

    CoUninitialize();
    UnInitThread();
    UnInitProcess();

    return 0;
}

DWORD _cdecl ARPIsRestricted(LPCWSTR pszPolicy)
{
    return SHGetRestriction(NULL, L"Uninstall", pszPolicy);
}

bool _cdecl ARPIsOnDomain()
{
    // NOTE: assume it's on the domain 
    bool bRet = true;
    LPWSTR pszDomain;
    NETSETUP_JOIN_STATUS nsjs;
    
    if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &nsjs))
    {
        if (nsjs != NetSetupDomainName)
            bRet = FALSE;
        NetApiBufferFree(pszDomain);
    }
    return bRet;
}

////////////////////////////////////////////////////////
// Async ARP item population thread

////////////////////////////////////////////////////////
// Query system and enumerate installed apps

HRESULT BuildPublishedAppArray(IEnumPublishedApps *penum, HDSA *phdsaPubApps);
HRESULT InstallPublishedAppArray(ARPFrame *paf, HDSA hdsaPubApps, UINT *piCount);
HRESULT InsertPubAppInPubAppArray(HDSA hdsa, IPublishedApp *ppa);
HRESULT GetPubAppName(IPublishedApp *ppa, LPWSTR *ppszName);
int CALLBACK DestroyPublishedAppArrayEntry(void *p, void *pData);

DWORD WINAPI PopulateAndRenderPublishedItemList(void* paf)
{
    DUITrace(">> Thread 'htPopulateAndRenderPublishedItemList' STARTED.\n");

    HRESULT hr;
    UINT iCount = 0;
    IShellAppManager* pisam = NULL;
    IEnumPublishedApps* piepa = NULL;
    IPublishedApp* pipa = NULL;
    HDCONTEXT hctx = NULL;

    // Initialize
    HRESULT hrOle = CoInitialize(NULL);

    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize       = sizeof(ig);
    ig.nThreadMode  = IGTM_MULTIPLE;
    ig.nMsgMode     = IGMM_ADVANCED;
    ig.hctxShare    = NULL;
    hctx = InitGadgets(&ig);
    if (hctx == NULL) {
        goto Cleanup;
    }

    // Create shell manager
    hr = CoCreateInstance(__uuidof(ShellAppManager), NULL, CLSCTX_INPROC_SERVER, __uuidof(IShellAppManager), (void**)&pisam);
    HRCHK(hr);

    if (!((ARPFrame*)paf)->GetPublishedComboFilled())
    {
        // Get the list of categories
        SHELLAPPCATEGORYLIST* psacl = ((ARPFrame*)paf)->GetShellAppCategoryList();
        if (psacl == NULL)
        {
            psacl = new SHELLAPPCATEGORYLIST; 
        }
        if (psacl == NULL)
        {
            goto Cleanup;
        }
        else
        {
            ((ARPFrame*)paf)->SetShellAppCategoryList(psacl);
        }
        hr = pisam->GetPublishedAppCategories(psacl);
        ((ARPFrame*)paf)->PopulateCategoryCombobox();
        ((ARPFrame*)paf)->SetPublishedComboFilled(true);
    }

    hr = pisam->EnumPublishedApps(((ARPFrame*)paf)->GetCurrentPublishedCategory(), &piepa);
    HRCHK(hr);

    HDSA hdsaPubApps = NULL;
    hr = BuildPublishedAppArray(piepa, &hdsaPubApps);
    HRCHK(hr);
    
    hr = InstallPublishedAppArray((ARPFrame *)paf, hdsaPubApps, &iCount);
    HRCHK(hr);

    if (iCount == 0)
    {
        ((ARPFrame*)paf)->FeedbackEmptyPublishedList();
    }

Cleanup:

    if (NULL != hdsaPubApps)
    {
        DSA_DestroyCallback(hdsaPubApps, DestroyPublishedAppArrayEntry, NULL);
        hdsaPubApps = NULL;
    }

    if (paf)
    {
        ((ARPFrame*)paf)->OnPublishedListComplete();
        ((ARPFrame*)paf)->SetPublishedListFilled(true);
    }

    if (pisam)
        pisam->Release();
    if (piepa)
        piepa->Release();

    if (hctx)
        DeleteHandle(hctx);

    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }

    // Thread is done
    ARPFrame::htPopulateAndRenderPublishedItemList = NULL;

    // Information primary thread that this worker is complete
    PostMessage(((ARPFrame*)paf)->GetHWND(), WM_ARPWORKERCOMPLETE, 0, 0);

    DUITrace(">> Thread 'htPopulateAndRenderPublishedItemList' DONE.\n");

    return 0;
}


// ----------------------------------------------------------------------------
// Handling published apps with duplicate names
// ----------------------------------------------------------------------------
//
// Entry in dynamic array of published app items.
// Entries with duplicate application names must be identifed
// in the UI by appending the applicable publishing source name
// to the display name of the application.  In order to do this,
// we need to assemble all of the published entries in a sorted
// array then mark as such those that have duplicate names.
// When the array items are added to the ARP frame, the items
// marked 'duplicate' have their publisher's name appended to
// their application name.
//
struct PubItemListEntry
{
    IPublishedApp *ppa;  // The published app object.
    bool bDuplicateName; // Does it have a duplicate name?
};


//
// Build the dynamic array of app/duplicate information.
// One entry for each published app.  If this function succeeds,
// the caller is responsible for destroying the returnd DSA.
//
HRESULT
BuildPublishedAppArray(
    IEnumPublishedApps *penum,
    HDSA *phdsaPubApps
    )
{
    ASSERT(NULL != penum);
    ASSERT(NULL != phdsaPubApps);
    ASSERT(!IsBadWritePtr(phdsaPubApps, sizeof(*phdsaPubApps)));
    
    HRESULT hr = S_OK;
    //
    // Create a large DSA so that we minimize resizing.
    //
    HDSA hdsa = DSA_Create(sizeof(PubItemListEntry), 512);
    if (NULL != hdsa)
    {
        IPublishedApp *ppa;
        while(g_fRun)
        {
            hr = THR(penum->Next(&ppa));
            if (S_OK == hr)
            {
                //
                // Ignore any errors related to a specific published app.
                //
                THR(InsertPubAppInPubAppArray(hdsa, ppa));
                ppa->Release();
            }
            else
            {
                break;
            }
        }
        if (FAILED(hr))
        {
            DSA_DestroyCallback(hdsa, DestroyPublishedAppArrayEntry, NULL);
            hdsa = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    ASSERT(FAILED(hr) || NULL != hdsa);
    *phdsaPubApps = hdsa;
    return THR(hr);
}


//
// Retrieve the application name string for a given published app.
// If this function succeeds, the caller is responsible for freeing
// the name string by using SHFree.
//
HRESULT
GetPubAppName(
    IPublishedApp *ppa,
    LPWSTR *ppszName
    )
{
    ASSERT(NULL != ppa);
    ASSERT(NULL != ppszName);
    ASSERT(!IsBadWritePtr(ppszName, sizeof(*ppszName)));
    
    APPINFODATA aid;
    aid.cbSize = sizeof(aid);
    aid.dwMask = AIM_DISPLAYNAME;

    *ppszName = NULL;

    HRESULT hr = THR(ppa->GetAppInfo(&aid));
    if (SUCCEEDED(hr))
    {
        if (AIM_DISPLAYNAME & aid.dwMask)
        {
            *ppszName = aid.pszDisplayName;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return THR(hr);
}
    
    
//
// Insert a published app into the published app array.
// Upon return, the dynamic array is sorted by published app name 
// and all duplicate entries are marked with their bDuplicateName
// member set to 'true'.
//
HRESULT
InsertPubAppInPubAppArray(
    HDSA hdsa,
    IPublishedApp *ppa
    )
{
    ASSERT(NULL != hdsa);
    ASSERT(NULL != ppa);

    LPWSTR pszAppName;
    HRESULT hr = THR(GetPubAppName(ppa, &pszAppName));
    if (SUCCEEDED(hr))
    {
        //
        // Create the new entry.  We'll addref the COM pointer
        // only after the item is successfully inserted into the array.
        //
        PubItemListEntry entryNew = { ppa, false };
        //
        // Find the insertion point so that the array is 
        // sorted by app name.
        //
        const int cEntries = DSA_GetItemCount(hdsa);
        int iInsertHere = 0; // Insertion point.
        PubItemListEntry *pEntry = NULL;

        for (iInsertHere = 0; iInsertHere < cEntries; iInsertHere++)
        {
            pEntry = (PubItemListEntry *)DSA_GetItemPtr(hdsa, iInsertHere);
            TBOOL(NULL != pEntry);
            if (NULL != pEntry)
            {
                LPWSTR psz;
                hr = THR(GetPubAppName(pEntry->ppa, &psz));
                if (SUCCEEDED(hr))
                {
                    int iCompare = lstrcmpi(psz, pszAppName);
                    SHFree(psz);
                    psz = NULL;
                    
                    if (0 <= iCompare)
                    {
                        //
                        // This is the insertion point.
                        //
                        if (0 == iCompare)
                        {
                            //
                            // This entry has the same name.
                            //
                            entryNew.bDuplicateName = true;
                            pEntry->bDuplicateName  = true;
                        }
                        break;
                    }
                }
            }
        }
        //
        // Now mark all other duplicates.  Note that if the entry
        // currently at the insertion point is a duplicate of the
        // entry we're inserting, we've already marked it as a duplicate
        // above.  Therefore, we can start with the next entry.
        //
        for (int i = iInsertHere + 1; i < cEntries; i++)
        {
            pEntry = (PubItemListEntry *)DSA_GetItemPtr(hdsa, i);
            TBOOL(NULL != pEntry);
            if (NULL != pEntry)
            {
                LPWSTR psz;
                hr = THR(GetPubAppName(pEntry->ppa, &psz));
                if (SUCCEEDED(hr))
                {
                    int iCompare = lstrcmpi(psz, pszAppName);
                    SHFree(psz);
                    psz = NULL;
                    //
                    // Assert that the array is sorted alphabetically.
                    //
                    ASSERT(0 <= iCompare);
                    if (0 == iCompare)
                    {
                        //
                        // Yep, another duplicate.
                        //
                        pEntry->bDuplicateName = true;
                    }
                    else
                    {
                        break; // No need to look further.
                    }
                }
            }
        }

        //
        // Insert the new item.
        //
        if (-1 != DSA_InsertItem(hdsa, iInsertHere, &entryNew))
        {
            entryNew.ppa->AddRef();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        SHFree(pszAppName);
    }
    return THR(hr);
}
                
    
//
// Given a DSA of application/duplicate-flag pairs, install
// the items in the ARP frame.
//
HRESULT
InstallPublishedAppArray(
    ARPFrame *paf,
    HDSA hdsaPubApps, 
    UINT *piCount     // optional.  Can be NULL.
    )
{
    ASSERT(NULL != paf);
    ASSERT(NULL != hdsaPubApps);
    ASSERT(NULL == piCount || !IsBadWritePtr(piCount, sizeof(*piCount)));
    
    int cEntries = DSA_GetItemCount(hdsaPubApps);
    paf->SetPublishedItemCount(cEntries);

    UINT iCount = 0;
    for (int i = 0; i < cEntries && g_fRun; i++)
    {
        PubItemListEntry *pEntry = (PubItemListEntry *)DSA_GetItemPtr(hdsaPubApps, i);
        TBOOL(NULL != pEntry);
        if (NULL != pEntry)
        {
            //
            // Unfortunately, InsertPublishedItem() doesn't return a value.
            //
            paf->InsertPublishedItem(pEntry->ppa, pEntry->bDuplicateName);
            iCount++;
        }
    }

    if (NULL != piCount)
    {
        *piCount = iCount;
    }
    return S_OK;
}

//
// Callback for destroying the DSA of application/duplicate-flag pairs.
// Need to release the IPublishedApp ptr for each entry.
//
int CALLBACK
DestroyPublishedAppArrayEntry(
    void *p, 
    void *pData
    )
{
    PubItemListEntry *pEntry = (PubItemListEntry *)p;
    ASSERT(NULL != pEntry && NULL != pEntry->ppa);
    ATOMICRELEASE(pEntry->ppa);
    return 1;
}



DWORD WINAPI PopulateAndRenderOCSetupItemList(void* paf)
{
    DUITrace(">> Thread 'htPopulateAndRenderOCSetupItemList' STARTED.\n");

    HDCONTEXT hctx = NULL;

    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize       = sizeof(ig);
    ig.nThreadMode  = IGTM_MULTIPLE;
    ig.nMsgMode     = IGMM_ADVANCED;
    ig.hctxShare    = NULL;
    
    hctx = InitGadgets(&ig);
    if (hctx == NULL) {
        goto Cleanup;
    }

   // Create an object that enums the OCSetup items
    COCSetupEnum * pocse = new COCSetupEnum;
    if (pocse)
    {
        if (pocse->EnumOCSetupItems())
        {
            COCSetupApp* pocsa;

            while (g_fRun && pocse->Next(&pocsa))
            {
                APPINFODATA ai = {0};
                ai.cbSize = sizeof(ai);
                ai.dwMask = AIM_DISPLAYNAME;

                if ( pocsa->GetAppInfo(&ai) && (lstrlen(ai.pszDisplayName) > 0) )
                {
                    //
                    // InsertOCSetupItem doesn't return a status value
                    // so we have no way of knowing if the item was
                    // added to ARP or not.  So... we have no way of knowing
                    // if we should delete it to prevent a leak.
                    // I've added code to ARPFrame::OnInvoke to delete
                    // the pocsa object if it cannot be added to ARP.
                    // [brianau - 2/27/01]
                    //
                    // Insert item
                    ((ARPFrame*)paf)->InsertOCSetupItem(pocsa);
                }
                else
                {
                    delete pocsa;
                    pocsa = NULL;
                }
            }
        }
        delete pocse;
        pocse = NULL;
    }

Cleanup:

    if (hctx)
        DeleteHandle(hctx);

    // Thread is done
    ARPFrame::htPopulateAndRenderOCSetupItemList = NULL;

    // Information primary thread that this worker is complete
    PostMessage(((ARPFrame*)paf)->GetHWND(), WM_ARPWORKERCOMPLETE, 0, 0);

    DUITrace(">> Thread 'htPopulateAndRenderOCSetupItemList' DONE.\n");

    return 0;
}

DWORD WINAPI PopulateInstalledItemList(void* paf)
{
    DUITrace(">> Thread 'htPopulateInstalledItemList' STARTED.\n");

    HRESULT hr;
    IShellAppManager* pisam = NULL;
    IEnumInstalledApps* pieia = NULL;
    IInstalledApp* piia = NULL;
    DWORD dwAppCount = 0;
    APPINFODATA aid = {0};
    HDCONTEXT hctx = NULL;

    // Initialize
    CoInitialize(NULL);

    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize       = sizeof(ig);
    ig.nThreadMode  = IGTM_MULTIPLE;
    ig.nMsgMode     = IGMM_ADVANCED;
    ig.hctxShare    = NULL;
    hctx = InitGadgets(&ig);
    if (hctx == NULL) {
        goto Cleanup;
    }

    aid.cbSize = sizeof(APPINFODATA);
    aid.dwMask =  AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | 
                  AIM_REGISTEREDOWNER | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | 
                  AIM_SUPPORTTELEPHONE | AIM_HELPLINK | AIM_INSTALLLOCATION | AIM_INSTALLDATE |
                  AIM_COMMENTS | AIM_IMAGE | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;

    // Create shell manager
    hr = CoCreateInstance(__uuidof(ShellAppManager), NULL, CLSCTX_INPROC_SERVER, __uuidof(IShellAppManager), (void**)&pisam);
    HRCHK(hr);

    hr = pisam->EnumInstalledApps(&pieia);
    HRCHK(hr);

    // Count installed apps, IShellAppManager::GetNumberofInstalledApps() not impl
    while (g_fRun)
    {
        hr = pieia->Next(&piia);
        if (hr == S_FALSE)  // Done with enumeration
            break;

        dwAppCount++;
    }

    // IEnumInstalledApps::Reset() doesn't work
    pieia->Release();
    pieia = NULL;
    hr = pisam->EnumInstalledApps(&pieia);
    HRCHK(hr);

    // Set app count in frame
    ((ARPFrame*)paf)->SetInstalledItemCount(dwAppCount);

    // Enumerate apps
    while (g_fRun)
    {
        hr = pieia->Next(&piia);
        if (hr == S_FALSE)  // Done with enumeration
            break;

        // Insert item
        if (piia != NULL)
        {
            ((ARPFrame*)paf)->InsertInstalledItem(piia);
        }
    }

    // Passing NULL to InsertInstalledItem signals ARP that it is finished
    // inserting items and should now display the list.
    if (dwAppCount > 0)
    {
        ((ARPFrame*)paf)->InsertInstalledItem(NULL);
    }

Cleanup:

    if (pisam)
        pisam->Release();
    if (pieia)
        pieia->Release();

    if (hctx)
        DeleteHandle(hctx);

    CoUninitialize();

    if (g_fRun)
        ((ARPFrame*)paf)->FlushWorkingSet();

    // Thread is done
    ARPFrame::htPopulateInstalledItemList = NULL;

    // Information primary thread that this worker is complete
    PostMessage(((ARPFrame*)paf)->GetHWND(), WM_ARPWORKERCOMPLETE, 0, 0);

    DUITrace(">> Thread 'htPopulateInstalledItemList' DONE.\n");

    return 0;
}

// Sorting
int __cdecl CompareElementDataName(const void* pA, const void* pB)
{
    Value* pvName1   = NULL;
    Value* pvName2   = NULL;
    LPCWSTR pszName1 = NULL;
    LPCWSTR pszName2 = NULL;
    Element *pe;
    if (NULL != pA)
    {
        pe = (*(ARPItem**)pA)->FindDescendent(ARPItem::_idTitle);
        if (NULL != pe)
        {
            pszName1 = pe->GetContentString(&pvName1);
        }
    }
    if (NULL != pB)
    {
        pe = (*(ARPItem**)pB)->FindDescendent(ARPItem::_idTitle);
        if (NULL != pe)
        {
            pszName2 = pe->GetContentString(&pvName2);
        }
    }

    static const int rgResults[2][2] = {
                            /*  pszName2 == NULL,    pszName2 != NULL  */
     /* pszName1 == NULL */  {        0,                      1   },
     /* pszName1 != NULL */  {       -1,                      2   }
        };

    int iResult = rgResults[int(NULL != pszName1)][int(NULL != pszName2)];
    if (2 == iResult)
    {
        iResult = StrCmpW(pszName1, pszName2);
    }
    
    if (NULL != pvName1)
    {
        pvName1->Release();
    }
    if (NULL != pvName2)
    {
       pvName2->Release();
    }
    return iResult;
}

int __cdecl CompareElementDataSize(const void* pA, const void* pB)
{
    ULONGLONG ull1 = (*(ARPItem**)pA)->_ullSize;
    ULONGLONG ull2 = (*(ARPItem**)pB)->_ullSize;
    if (!IsValidSize(ull1))
        ull1 = 0;
    if (!IsValidSize(ull2))
        ull2 = 0;

    // Big apps come before smaller apps
    if (ull1 > ull2)
        return -1;
    else if (ull1 < ull2)
        return 1;

    return   CompareElementDataName(pA, pB);
}

int __cdecl CompareElementDataFreq(const void* pA, const void* pB)
{
    // Rarely used apps come before frequently used apps.  Blank
    // (unknown) apps go last.  Unknown apps are -1, so those sort
    // to the bottom if we simply compare unsigned values.
    UINT u1 = (UINT)(*(ARPItem**)pA)->_iTimesUsed;
    UINT u2 = (UINT)(*(ARPItem**)pB)->_iTimesUsed;

   if (u1 < u2)
       return -1;
   else if (u1 > u2)
       return 1;
   return   CompareElementDataName(pA, pB);

}

int __cdecl CompareElementDataLast(const void* pA, const void* pB)
{
   FILETIME ft1 = (*(ARPItem**)pA)->_ftLastUsed;
   FILETIME ft2 = (*(ARPItem**)pB)->_ftLastUsed;

   BOOL bTime1 = IsValidFileTime(ft1);
   BOOL bTime2 = IsValidFileTime(ft2);

   if (!bTime1 || !bTime2)
   {
       if (bTime1)
           return -1;
       if (bTime2)
           return 1;
       // else they're both not set -- use name
   }
   else
   {
       LONG diff = CompareFileTime(&ft1, &ft2);
       if (diff)
           return diff;
   }

   return   CompareElementDataName(pA, pB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\browse.c ===
//
//  Browse.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 5/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"
#include "util.h"
#ifdef WINNT
#include <uastrfnc.h>
#endif

#ifdef WINNT
#ifndef DOWNLEVEL_PLATFORM
#include <tsappcmp.h>       // for TermsrvAppInstallMode
#endif // DOWNLEVEL_PLATFORM
#endif // WINNT

// Copied from shelldll\ole2dup.h
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

//
//  Initialize the browse property sheet.  Limit the size of the edit control.
//

void BrowseInitPropSheet(HWND hDlg, LPARAM lParam)
{
    LPWIZDATA lpwd = InitWizSheet(hDlg, lParam, 0);

    Edit_LimitText(GetDlgItem(hDlg, IDC_COMMAND), ARRAYSIZE(lpwd->szExeName)-1);

#ifndef DOWNLEVEL_PLATFORM
    if (FAILED(SHAutoComplete(GetDlgItem(hDlg, IDC_COMMAND), 0)))
    {
        TraceMsg(TF_WARNING, "%s", "WARNING: Create Shortcut wizard won't AutoComplete because: 1) bad registry, 2) bad OleInit, or 3) Out of memory.");
    }
#endif //DOWNLEVEL_PLATFORM
}

//
//  Sets the appropriate wizard buttons.  If there's any text in the
//  edit control then Next is enabled.  Otherwise, Next and Back are both
//  grey.
//
void SetBrowseButtons(LPWIZDATA lpwd)
{
    BOOL fIsText = GetWindowTextLength(GetDlgItem(lpwd->hwnd, IDC_COMMAND)) > 0;
    BOOL fIsSetup = (lpwd->dwFlags & WDFLAG_SETUPWIZ);
    int iBtns = fIsSetup ? PSWIZB_BACK : 0;

    if (fIsSetup)
    {
#ifndef DOWNLEVEL_PLATFORM
#ifdef WINNT       
        // Are we running Terminal Service? Is this user an Admin?
        if (IsTerminalServicesRunning() && IsUserAnAdmin())
        {
            lpwd->bTermSrvAndAdmin = TRUE;
            iBtns |= fIsText ? PSWIZB_NEXT : PSWIZB_DISABLEDFINISH;
        }
        else
#endif // WINNT
#endif // DOWNLEVEL_PLATFORM
            iBtns |= fIsText ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH;
    }
    else
    {
        if (fIsText)
        {
            iBtns |= PSWIZB_NEXT;
        }
    }
    PropSheet_SetWizButtons(GetParent(lpwd->hwnd), iBtns);
}


//
//  NOTES: 1) This function assumes that lpwd->hwnd has already been set to
//           the dialogs hwnd.  2) This function is called from NextPushed
//           if the application specified can not be found.
//
//  BrowseSetActive enables the next button and sets the focus to the edit
//  control by posting a POKEFOCUS message.
//

void BrowseSetActive(LPWIZDATA lpwd)
{
    //
    // NOTE: We re-use the szProgDesc string since it will always be reset
    //       when this page is activated.  Use it to construct a command line.
    //

    #define   szCmdLine lpwd->szProgDesc

    lstrcpy(szCmdLine, lpwd->szExeName);

    PathQuoteSpaces(szCmdLine);

    if (lpwd->szParams[0] != 0)
    {
        lstrcat(szCmdLine, TEXT(" "));
        lstrcat(szCmdLine, lpwd->szParams);
    }

    Edit_SetText(GetDlgItem(lpwd->hwnd, IDC_COMMAND), szCmdLine);

    if (lpwd->dwFlags & WDFLAG_SETUPWIZ)
    {
        int   iHaveHeader = IsTerminalServicesRunning() ? IDS_TSHAVESETUPPRG : IDS_HAVESETUPPRG;
        int   iHeader = szCmdLine[0] != 0 ? iHaveHeader : IDS_NOSETUPPRG;
        TCHAR szInstruct[MAX_PATH];

        LoadString(g_hinst, iHeader, szInstruct, ARRAYSIZE(szInstruct));

        Static_SetText(GetDlgItem(lpwd->hwnd, IDC_SETUPMSG), szInstruct);
    }

    SetBrowseButtons(lpwd);

    PostMessage(lpwd->hwnd, WMPRIV_POKEFOCUS, 0, 0);

    szCmdLine[0] = 0;            // Reset progdesc to empty string
    #undef szCmdLine
}


//
//  Returns TRUE if able to get properties for szExeName from PifMgr.  The
//  program properties will be read into lpwd->PropPrg.
//

BOOL ReadPifProps(LPWIZDATA lpwd)
{
    HANDLE hPifProp;
    LPTSTR lpszName = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;

    hPifProp = PifMgr_OpenProperties(lpszName, NULL, 0, OPENPROPS_INHIBITPIF);
    if (!hPifProp)
    {
        TraceMsg(TF_ERROR, "%s", "Unable to open properties for DOS exe.");
    }

    if (hPifProp == 0)
        return(FALSE);

    PifMgr_GetProperties(hPifProp, (LPSTR)GROUP_PRG, &(lpwd->PropPrg),
                         sizeof(lpwd->PropPrg), GETPROPS_NONE);

    PifMgr_CloseProperties(hPifProp, CLOSEPROPS_DISCARD);

    return(TRUE);
}


//
//  Returns TRUE if lpwd->szExeName points to a valid exe type.  It also sets
//  the appropriate flags, such as APPKNOWN and DOSAPP in the wizdata structure
//  if the exe is valid.
//

void DetermineExeType(LPWIZDATA lpwd)
{

    DWORD   dwExeType;
    LPTSTR  lpszName = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;

    lpwd->dwFlags &= ~(WDFLAG_APPKNOWN | WDFLAG_DOSAPP | WDFLAG_SINGLEAPP);

    dwExeType = (DWORD)SHGetFileInfo(lpszName, 0, NULL, 0, SHGFI_EXETYPE);

    if (LOWORD(dwExeType) != ('M' | ('Z' << 8)))
    {
        lpwd->dwFlags |= WDFLAG_APPKNOWN;

        if (lstrcmpi(PathFindExtension(lpszName), c_szPIF) == 0)
        {
            lpwd->dwFlags |= WDFLAG_DOSAPP;
        }
    }
    else
    {
        lpwd->dwFlags |= WDFLAG_DOSAPP;

        if (ReadPifProps(lpwd))
        {
            if ((lpwd->PropPrg.flPrgInit & PRGINIT_INFSETTINGS) ||
                ((lpwd->PropPrg.flPrgInit &
                     (PRGINIT_NOPIF | PRGINIT_DEFAULTPIF)) == 0))
            {
                lpwd->dwFlags |= WDFLAG_APPKNOWN;

                if (lpwd->PropPrg.flPrgInit & PRGINIT_REALMODE)
                {
                    lpwd->dwFlags |= WDFLAG_SINGLEAPP;
                }
            }
        }
    }
}


//
//  Removes the filename extension (if any) from the string.
//

void StripExt(LPTSTR lpsz)
{
    if(lpsz)
    {
        LPTSTR pExt = PathFindExtension(lpsz);

        if (*pExt)
            *pExt = 0;    // null out the "."
    }
}



//
//  Sets the working directory as appropriate for the file type.
//

void FindWorkingDir(LPWIZDATA lpwd)
{
    LPTSTR lpszName = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;
#ifdef WINNT
    TCHAR szWindir[ MAX_PATH ];
    DWORD dwLen;
#endif

    if (PathIsUNC(lpszName) || PathIsDirectory(lpszName))
    {
        lpwd->szWorkingDir[0] = 0;
    }
    else
    {
        lstrcpy(lpwd->szWorkingDir, lpszName);
        PathRemoveFileSpec(lpwd->szWorkingDir);
    }

#ifdef WINNT
    //
    // Okay, at this point we should have the absolute path for the
    // working directory of the link.  On NT, if the working dir happens to be for
    // something in the %Windir% directory (or a subdir of %windir%),
    // then store the path as %windir%\blah\blah\blah instead of as an
    // absolute path.  This will help with interoperability of shortcuts
    // across different machines, etc.  But only do this for shortcuts that
    // are already marked as having expandable env strings...
    //

    if (lpwd->dwFlags & WDFLAG_EXPSZ)
    {
        dwLen = ExpandEnvironmentStrings( TEXT("%windir%"),
                                          szWindir,
                                          ARRAYSIZE(szWindir)
                                         );
        if (dwLen &&
            dwLen < ARRAYSIZE(szWindir) &&
            lstrlen(szWindir) <= lstrlen(lpwd->szWorkingDir)
           )
        {
            //
            // we use dwLen-1 because dwLen includes the '\0' character
            //
            if (CompareString( LOCALE_SYSTEM_DEFAULT,
                               NORM_IGNORECASE,
                               szWindir, dwLen-1 ,
                               lpwd->szWorkingDir, dwLen-1
                              ) == 2)
            {
                TCHAR szWorkingDir[ MAX_PATH ];
                //
                // We should substitute the env variable for the
                // actual string here...
                //
                ualstrcpy( szWorkingDir, lpwd->szWorkingDir );
                ualstrcpy( lpwd->szWorkingDir, TEXT("%windir%") );

                // 8 == lstrlen("%windir%")
                ualstrcpy( lpwd->szWorkingDir + 12, szWorkingDir+dwLen-1 );

            }
        }
    }
#endif // winnt
}


#ifndef NO_NEW_SHORTCUT_HOOK

//
// Returns:
//    Hook result or error.
//
// S_OK:
//    *pnshhk is the INewShortcutHook of the object to use to save the new Shortcut.
//    szProgDesc[] and szExt[] are filled in.
//    szExeName[] may be translated.
// otherwise:
//    *pnshhk is NULL.
//    szProgDesc[] and szExt[] are empty strings.
//

HRESULT QueryNewLinkHandler(LPWIZDATA lpwd, LPCLSID pclsidHook)
{
   HRESULT   hr;
   IUnknown *punk;
   LPTSTR lpszName = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;

   lpwd->pnshhk = NULL;
#ifdef UNICODE
   lpwd->pnshhkA = NULL;
#endif

   *(lpwd->szProgDesc) = TEXT('\0');
   *(lpwd->szExt) = TEXT('\0');

   hr = CoCreateInstance(pclsidHook, NULL, CLSCTX_INPROC_SERVER, &IID_IUnknown, &punk);

   if (hr == S_OK)
   {
      INewShortcutHook *pnshhk;

      hr = punk->lpVtbl->QueryInterface(punk, &IID_INewShortcutHook, &pnshhk);

      if (hr == S_OK)
      {
         hr = pnshhk->lpVtbl->SetReferent(pnshhk, lpszName, lpwd->hwnd);

         if (hr == S_OK)
         {
            hr = pnshhk->lpVtbl->SetFolder(pnshhk, lpwd->lpszFolder);

            if (hr == S_OK)
            {
               hr = pnshhk->lpVtbl->GetName(pnshhk, lpwd->szProgDesc,
                                            ARRAYSIZE(lpwd->szProgDesc));

               if (hr == S_OK)
               {
                  hr = pnshhk->lpVtbl->GetExtension(pnshhk, lpwd->szExt,
                                                    ARRAYSIZE(lpwd->szExt));

                  if (hr == S_OK)
                     hr = pnshhk->lpVtbl->GetReferent(pnshhk, lpszName,
                                                      ARRAYSIZE(lpwd->szExeName));
               }
            }
         }

         if (hr == S_OK)
            lpwd->pnshhk = pnshhk;
         else
            pnshhk->lpVtbl->Release(pnshhk);
      }
#ifdef UNICODE
      else
      {
          INewShortcutHookA *pnshhkA;
          hr = punk->lpVtbl->QueryInterface(punk, &IID_INewShortcutHookA, &pnshhkA);

          if (hr == S_OK)
          {
             UINT   cFolderA = WideCharToMultiByte(CP_ACP,0,lpwd->lpszFolder,-1,NULL,0,0,0)+1;
             LPSTR  lpszFolderA = (LPSTR)LocalAlloc(LPTR,cFolderA*SIZEOF(CHAR));

             if (NULL == lpszFolderA)
             {
                 hr = E_OUTOFMEMORY;
             }
             else
             {
                 CHAR   szNameA[MAX_PATH];
                 CHAR   szProgDescA[MAX_PATH];
                 CHAR   szExtA[MAX_PATH];

                 WideCharToMultiByte(CP_ACP, 0,
                                     lpszName, -1,
                                     szNameA, ARRAYSIZE(szNameA),
                                     0, 0);

                 WideCharToMultiByte(CP_ACP, 0,
                                     lpwd->lpszFolder, -1,
                                     lpszFolderA, cFolderA,
                                     0, 0);

                 hr = pnshhkA->lpVtbl->SetReferent(pnshhkA, szNameA, lpwd->hwnd);

                 if (hr == S_OK)
                 {
                    hr = pnshhkA->lpVtbl->SetFolder(pnshhkA, lpszFolderA);

                    if (hr == S_OK)
                    {
                       hr = pnshhkA->lpVtbl->GetName(pnshhkA, szProgDescA,
                                                    ARRAYSIZE(szProgDescA));

                       if (hr == S_OK)
                       {
                          MultiByteToWideChar(CP_ACP, 0,
                                              szProgDescA, -1,
                                              lpwd->szProgDesc, ARRAYSIZE(lpwd->szProgDesc));

                          hr = pnshhkA->lpVtbl->GetExtension(pnshhkA, szExtA,
                                                            ARRAYSIZE(szExtA));

                          if (hr == S_OK)
                          {
                             MultiByteToWideChar(CP_ACP, 0,
                                                 szExtA, -1,
                                                 lpwd->szExt, ARRAYSIZE(lpwd->szExt));

                             hr = pnshhkA->lpVtbl->GetReferent(pnshhkA, szNameA,
                                                              ARRAYSIZE(szNameA));

                             MultiByteToWideChar(CP_ACP, 0,
                                                 szExtA, -1,
                                                 lpszName, ARRAYSIZE(lpwd->szExeName));
                          }
                       }
                    }
                 }

                 if (hr == S_OK)
                    lpwd->pnshhkA = pnshhkA;
                 else
                    pnshhkA->lpVtbl->Release(pnshhkA);

                 LocalFree(lpszFolderA);
             }
          }
      }
#endif
      punk->lpVtbl->Release(punk);
   }

   return(hr);
}


const TCHAR c_szNewLinkHandlers[] = REGSTR_PATH_EXPLORER TEXT("\\NewShortcutHandlers");


//
// Sets lpwd->pnshhk to NULL for CLSID_ShellLink (default) or to the
// INewShortcutHook of the object to be used.
//
// If lpwd->pnshhk is returned non-NULL, szProgDesc[] and szExt[] are also
// filled in.
//

void DetermineLinkHandler(LPWIZDATA lpwd)
{
   HKEY hkeyHooks;

   // Lose any previously saved external new Shortcut handler.

   if (lpwd->pnshhk)
   {
      lpwd->pnshhk->lpVtbl->Release(lpwd->pnshhk);
      lpwd->pnshhk = NULL;
   }
#ifdef UNICODE
   if (lpwd->pnshhkA)
   {
      lpwd->pnshhkA->lpVtbl->Release(lpwd->pnshhkA);
      lpwd->pnshhkA = NULL;
   }
#endif

   //
   // Enumerate the list of new link handlers.  Each new link handler is
   // registered as a GUID value under c_szNewLinkHandlers.
   //

   if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szNewLinkHandlers, &hkeyHooks)
       == ERROR_SUCCESS)
   {
      DWORD dwiValue;
      TCHAR szCLSID[GUIDSTR_MAX];
      DWORD dwcbCLSIDLen;

      //
      // Invoke each hook.  A hook returns S_FALSE if it does not wish to
      // handle the new link.  Stop if a hook returns S_OK.
      //

      for (dwcbCLSIDLen = ARRAYSIZE(szCLSID), dwiValue = 0;
           RegEnumValue(hkeyHooks, dwiValue, szCLSID, &dwcbCLSIDLen, NULL,
                        NULL, NULL, NULL) == ERROR_SUCCESS;
           dwcbCLSIDLen = ARRAYSIZE(szCLSID), dwiValue++)
      {
         CLSID clsidHook;

         if (SHCLSIDFromString(szCLSID, &clsidHook) == S_OK &&
             QueryNewLinkHandler(lpwd, &clsidHook) == S_OK)
            break;
      }

      RegCloseKey(hkeyHooks);
   }

   return;
}

#endif


//
//  Returns TRUE if it's OK to go to the next wizard dialog.
//

BOOL NextPushed(LPWIZDATA lpwd)
{
    GetDlgItemText(lpwd->hwnd, IDC_COMMAND, lpwd->szExeName, ARRAYSIZE(lpwd->szExeName));

    // Is the string a path with spaces, without arguments, but isn't correctly
    // quoted?  NT #d: >C:\Program Files\Windows NT\dialer.exe< is treated like
    // "C:\Program" with "Files\Windows NT\dialer.exe" as args.
    if (PathFileExists(lpwd->szExeName))
    {
        // Yes, so let's quote it so we don't treat the stuff after
        // the space like args.
        PathQuoteSpaces(lpwd->szExeName);
    }
    
    PathRemoveBlanks(lpwd->szExeName);

    if (lpwd->szExeName[0] != 0)
    {
        BOOL    bUNC;
        LPTSTR  lpszTarget = NULL;
        HCURSOR hcurOld  = SetCursor(LoadCursor(NULL, IDC_WAIT));
        LPTSTR  lpszArgs = PathGetArgs(lpwd->szExeName);

        lstrcpy(lpwd->szParams, lpszArgs);

        if (*lpszArgs)
        {
            *(lpszArgs - 1) = 0;   // clobber the ' ' in the exe name field
        }

        ExpandEnvironmentStrings( lpwd->szExeName,
                                  lpwd->szExpExeName,
                                  ARRAYSIZE(lpwd->szExpExeName)
                                 );
        lpwd->szExpExeName[ MAX_PATH-1 ] = TEXT('\0');
        if (lstrcmp(lpwd->szExeName, lpwd->szExpExeName))
            lpwd->dwFlags |= WDFLAG_EXPSZ;


        lpszTarget = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;


        PathUnquoteSpaces(lpszTarget);
        if (lpwd->dwFlags & WDFLAG_EXPSZ)
            PathUnquoteSpaces(lpwd->szExeName);

        lpwd->dwFlags &= ~WDFLAG_COPYLINK;

#ifndef NO_NEW_SHORTCUT_HOOK

        //
        // Figure out who wants to handle this string as a link referent.
        //

        DetermineLinkHandler(lpwd);

        if (lpwd->pnshhk)
        {
            //
            // We are using an external link handler.  Skip file system
            // validation.
            //

            lpwd->dwFlags |= WDFLAG_APPKNOWN;
            SetCursor(hcurOld);
            return(TRUE);
        }
#ifdef UNICODE
        if (lpwd->pnshhkA)
        {
            //
            // We are using an external link handler.  Skip file system
            // validation.
            //

            lpwd->dwFlags |= WDFLAG_APPKNOWN;
            SetCursor(hcurOld);
            return(TRUE);
        }
#endif

#endif

        bUNC = PathIsUNC(lpszTarget);

        if (bUNC && !SHValidateUNC(lpwd->hwnd, lpszTarget, FALSE))
            goto Done;

        //
        //  If the user tries to make a link to A:\ and there's no disk
        //  in the drive, PathResolve would fail.  So, for drive roots, we
        //  don't try to resolve it.
        //

        if ((PathIsRoot(lpszTarget) && !bUNC &&
             DriveType(DRIVEID(lpszTarget))) ||
             PathResolve(lpszTarget, NULL,
                         PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS))
        {
            //
            // If we found a PIF file then we'll try to convert it to the
            // name of the file it points to.
            //

            if (lstrcmpi(PathFindExtension(lpszTarget), c_szPIF) == 0)
            {
                if (!ReadPifProps(lpwd))
                {
                    goto Done;
                }

#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0, lpwd->PropPrg.achCmdLine, -1,
                                    lpszTarget, ARRAYSIZE(lpwd->szExeName));
#else
                lstrcpy(lpszTarget, lpwd->PropPrg.achCmdLine);
#endif // UNICODE

                PathRemoveArgs(lpszTarget);

                if (!PathResolve(lpszTarget, NULL,
                                 PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS))
                {
                    goto Done;
                }
            }

#ifdef WINNT
            //
            // Okay, at this point we should have the absolute path for the
            // target of the link.  On NT, if the target happens to be for
            // something in the %Windir% directory (or a subdir of %Windir%),
            // AND the user didn't type in an expandable path already, then
            // store the path as %windir%\blah\blah\blah instead of as an
            // absolute path.  This will help with interoperability of shortcuts
            // across different machines, etc.
            //

            if (!(lpwd->dwFlags & WDFLAG_EXPSZ))
            {
                TCHAR szWindir[ MAX_PATH ];
                DWORD dwLen;

                //
                // What did the user type in?
                //
                GetDlgItemText(lpwd->hwnd, IDC_COMMAND, szWindir, ARRAYSIZE(szWindir));
                if (ualstrcmpi(szWindir, lpwd->szExeName)==0)
                {
                    //
                    // If we didn't change it, it means the user typed in an
                    // exact path.  In that case, don't try to map anyting.
                    //
                    goto LinkToALinkCase;
                }
                dwLen = ExpandEnvironmentStrings( TEXT("%windir%"),
                                                  szWindir,
                                                  ARRAYSIZE(szWindir)
                                                 );
                if (dwLen &&
                    dwLen < ARRAYSIZE(szWindir) &&
                    lstrlen(szWindir) <= lstrlen(lpszTarget)
                   )
                {
                    //
                    // we use dwLen-1 because dwLen includes the '\0' character
                    //
                    if (CompareString( LOCALE_SYSTEM_DEFAULT,
                                       NORM_IGNORECASE,
                                       szWindir, dwLen-1 ,
                                       lpszTarget, dwLen-1
                                      ) == 2)
                    {
                        //
                        // We should substitute the env variable for the
                        // actual string here...
                        //
                        lstrcpy( lpwd->szExpExeName, lpwd->szExeName );
                        lstrcpy( lpwd->szExeName, TEXT("%windir%") );

                        // 8 == lstrlen("%windir%")
                        ualstrcpy( lpwd->szExeName + 8, lpwd->szExpExeName+dwLen-1 );
                        lpwd->dwFlags |= WDFLAG_EXPSZ;
                        lpszTarget = lpwd->szExpExeName;

                    }
                }
            }
#endif // winnt

#ifdef WINNT
            //
            // Okay, at this point we should have the absolute path for the
            // target of the link.  On NT, if the target happens to be for
            // something in the %Windir% directory (or a subdir of %Windir%),
            // AND the user didn't type in an expandable path already, then
            // store the path as %windir%\blah\blah\blah instead of as an
            // absolute path.  This will help with interoperability of shortcuts
            // across different machines, etc.
            //

            if (!(lpwd->dwFlags & WDFLAG_EXPSZ))
            {
                TCHAR szWindir[ MAX_PATH ];
                DWORD dwLen;

                //
                // What did the user type in?
                //
                GetDlgItemText(lpwd->hwnd, IDC_COMMAND, szWindir, ARRAYSIZE(szWindir));
                if (ualstrcmpi(szWindir, lpwd->szExeName)==0)
                {
                    //
                    // If we didn't change it, it means the user typed in an
                    // exact path.  In that case, don't try to map anyting.
                    //
                    goto LinkToALinkCase;
                }
                dwLen = ExpandEnvironmentStrings( TEXT("%windir%"),
                                                  szWindir,
                                                  ARRAYSIZE(szWindir)
                                                 );
                if (dwLen &&
                    dwLen < ARRAYSIZE(szWindir) &&
                    lstrlen(szWindir) <= lstrlen(lpszTarget)
                   )
                {
                    //
                    // we use dwLen-1 because dwLen includes the '\0' character
                    //
                    if (CompareString( LOCALE_SYSTEM_DEFAULT,
                                       NORM_IGNORECASE,
                                       szWindir, dwLen-1 ,
                                       lpszTarget, dwLen-1
                                      ) == 2)
                    {
                        //
                        // We should substitute the env variable for the
                        // actual string here...
                        //
                        lstrcpy( lpwd->szExpExeName, lpwd->szExeName );
                        lstrcpy( lpwd->szExeName, TEXT("%windir%") );

                        // 8 == lstrlen("%windir%")
                        ualstrcpy( lpwd->szExeName + 8, lpwd->szExpExeName+dwLen-1 );
                        lpwd->dwFlags |= WDFLAG_EXPSZ;
                        lpszTarget = lpwd->szExpExeName;

                    }
                }
            }
LinkToALinkCase:

#endif // winnt

            //
            //  Really, really obscure case. The user creates "New Shortcut" and
            //  tries to point it to itself. Don't allow it.  We'd be confused
            //  later. Since it's so obscure, just give a generic error about
            //  "Can't find this file"
            //

            if (!(lpwd->lpszOriginalName &&
                  lstrcmpi(lpwd->lpszOriginalName, lpszTarget) == 0))
            {
                DetermineExeType(lpwd);
                FindWorkingDir(lpwd);

                lpwd->szProgDesc[0] = 0;  // Reset description
                                          // EVEN IF WE DON'T RECREATE IT HERE!

                if (lpwd->lpszFolder && lpwd->lpszFolder[0] != 0 &&
                    !DetermineDefaultTitle(lpwd))
                {
                    goto Done;
                }

                if (lpwd->dwFlags & WDFLAG_EXPSZ)
                {
                    LPTSTR lpszExt = PathFindExtension( lpwd->szExeName );

                    if (!(*lpszExt))
                    {
                        // do simple check to make sure there was a file name
                        // at the end of the original entry.  we assume that
                        // if we got this far, lpszExt points to the end of
                        // the string pointed to by lpwd->szExeName, and that
                        // lpwd->szExeName has at least one character in it.
                        if (lpwd->szExeName &&
                            (*lpwd->szExeName) &&
                            (*(lpszExt-1)!=TEXT('%'))
                            )
                        {
                            lstrcpy( lpszExt, PathFindExtension( lpszTarget ) );
                        }
                    }
                }

                SetCursor(hcurOld);
                return(TRUE);
            }

        }
Done:

        SetCursor(hcurOld);
        ShellMessageBox(g_hinst, lpwd->hwnd, MAKEINTRESOURCE(IDS_BADPATHMSG), 0, MB_OK | MB_ICONEXCLAMATION, lpwd->szExeName);
    }

    BrowseSetActive(lpwd);
    return(FALSE);
}


//
//  Returns TRUE if it's OK to run the setup program.
//

BOOL SetupCleanupExePath(LPWIZDATA lpwd)
{
    BOOL fValidPrg = FALSE;

    GetDlgItemText(lpwd->hwnd, IDC_COMMAND, lpwd->szExeName, ARRAYSIZE(lpwd->szExeName));

    // Is the string a path with spaces, without arguments, but isn't correctly
    // quoted?  NT #d: >C:\Program Files\Windows NT\dialer.exe< is treated like
    // "C:\Program" with "Files\Windows NT\dialer.exe" as args.
    if (PathFileExists(lpwd->szExeName))
    {
        // Yes, so let's quote it so we don't treat the stuff after
        // the space like args.
        PathQuoteSpaces(lpwd->szExeName);
    }

    PathRemoveBlanks(lpwd->szExeName);

    if (lpwd->szExeName[0] != 0)
    {
        LPTSTR lpszTarget = NULL;
        LPTSTR lpszArgs = NULL;
        HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));


        ExpandEnvironmentStrings( lpwd->szExeName,
                                  lpwd->szExpExeName,
                                  ARRAYSIZE(lpwd->szExpExeName)
                                 );
        if (lstrcmp(lpwd->szExeName, lpwd->szExpExeName))
            lpwd->dwFlags |= WDFLAG_EXPSZ;

        lpszTarget = (lpwd->dwFlags & WDFLAG_EXPSZ) ? lpwd->szExpExeName : lpwd->szExeName;

        lpszArgs = PathGetArgs(lpszTarget);
        lstrcpy(lpwd->szParams, lpszArgs);
        if (*lpszArgs)
        {
            *(lpszArgs - 1) = 0;   // clobber the ' ' in the exe name field
        }
   
        PathUnquoteSpaces(lpszTarget);
        if (lpwd->dwFlags & WDFLAG_EXPSZ)
            PathUnquoteSpaces(lpwd->szExeName);

        if (PathResolve(lpszTarget, NULL,
                        PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS))
        {
            LPTSTR lpszExt = PathFindExtension( lpszTarget );
            fValidPrg = TRUE;
            FindWorkingDir(lpwd);
            if (lpwd->dwFlags & WDFLAG_EXPSZ)
            {
                if (!(*lpszExt))
                {
                    lstrcpy( lpszExt, PathFindExtension( lpszTarget ) );
                }
            }
            
            if ((*lpszExt) && lpwd->bTermSrvAndAdmin && (!lstrcmpi(lpszExt, TEXT(".msi"))))
                lstrcat(lpwd->szParams, TEXT(" ALLUSERS=1"));

            PathQuoteSpaces( lpszTarget );
        }
        SetCursor(hcurOld);
    }


    if (!fValidPrg)
    {
        ShellMessageBox(g_hinst, lpwd->hwnd, MAKEINTRESOURCE(IDS_BADPATHMSG), 0, MB_OK | MB_ICONEXCLAMATION, lpwd->szExeName);
        BrowseSetActive(lpwd);
    }
    return(fValidPrg);
}


BOOL DetermineDefaultTitle(LPWIZDATA lpwd)
{
    TCHAR   szFullName[MAX_PATH];
    BOOL    fCopy;
    LPTSTR  lpszName;

    lpwd->dwFlags &= ~WDFLAG_COPYLINK;

    if (lpwd->dwFlags & WDFLAG_EXPSZ)
        lpszName = lpwd->szExpExeName;
    else
        lpszName = lpwd->szExeName;

    if (!SHGetNewLinkInfo(lpszName, lpwd->lpszFolder, szFullName,
                     &fCopy, 0))
    {
        //
        // failure...
        //

        return(FALSE);
    }

    lpszName = PathFindFileName(szFullName);

    StripExt(lpszName);

    lstrcpyn(lpwd->szProgDesc, lpszName, ARRAYSIZE(lpwd->szProgDesc));

    //
    // We will never copy PIF files since they often do not contain
    // the appropriate current directory.  This is becuase they are
    // automatically created when you run a DOS application from the
    // shell.
    //

    if ((lpwd->dwFlags & WDFLAG_DOSAPP) == 0)
    {
        if (fCopy)
        {
            lpwd->dwFlags |= WDFLAG_COPYLINK;
        }
#ifndef NO_NEW_SHORTCUT_HOOK
        lstrcpy(lpwd->szExt, c_szLNK);
    }
    else
    {
        lstrcpy(lpwd->szExt, c_szPIF);
#endif
    }

    return(TRUE);
}

//
// paranoia: evaluate each time in case it is installed after ARP was first open, but
//           before it is closed and re-opened
//
BOOL MSI_IsMSIAvailable()
{
    BOOL bAvailable = FALSE;

    HINSTANCE hinst = LoadLibraryA("MSI.DLL");
    
    if (hinst)
    {
        bAvailable = TRUE;

        FreeLibrary(hinst);
    }

    return bAvailable;
}

//
//  Call the common dialog code for File Open
//
BOOL BrowseForExe(HWND hwnd, LPTSTR pszName, DWORD cchName, LPCTSTR pszInitDir)
{
    TCHAR szExt[80];
    TCHAR szFilter[200];
    TCHAR szTitle[80];
    TCHAR szBootDir[64];

    //
    // Must pass the buffer size to GetBootDir because that is what
    // the RegQueryValueEx function expects - not count of chars.
    //

    if (!pszInitDir)
    {
        GetBootDir(szBootDir, ARRAYSIZE(szBootDir));
    }
    else
    {
        // we want to pass in an initial directory since GetFileNameFromBrowse
        // try to determine an initial directory by doing a PathRemoveFileSpec
        // on pszName.  If pszName is already a directory then the last directory
        // is removed (even though it's not a file).  E.g.: "c:\winnt" -> "c:\"
        lstrcpyn(szBootDir, pszInitDir, ARRAYSIZE(szBootDir));
    }

    if (MSI_IsMSIAvailable())
        LoadAndStrip(IDS_BROWSEFILTERMSI, szFilter, ARRAYSIZE(szFilter));
    else
        LoadAndStrip(IDS_BROWSEFILTER, szFilter, ARRAYSIZE(szFilter));

    LoadString(g_hinst, IDS_BROWSEEXT,    szExt,    ARRAYSIZE(szExt));
    LoadString(g_hinst, IDS_BROWSETITLE,  szTitle,  ARRAYSIZE(szTitle));

    // we need to set pszName to NULL or else GetFileNameFromBrowse will use it
    // to find the initial directory even though we explicitly pass in an initial
    // dir.
    *pszName = 0;

    return(GetFileNameFromBrowse(hwnd, pszName, cchName,
                                 szBootDir, szExt, szFilter, szTitle));
}

//
//  Use the common open dialog to browse for program. Used by SetupBrowseDlgProc
//

void BrowsePushed(LPWIZDATA lpwd)
{
    LPTSTR lpszName;
    DWORD cchName = 0;

    GetDlgItemText(lpwd->hwnd, IDC_COMMAND, lpwd->szExeName, ARRAYSIZE(lpwd->szExeName));
    ExpandEnvironmentStrings( lpwd->szExeName, lpwd->szExpExeName, ARRAYSIZE(lpwd->szExpExeName) );
    if (lstrcmp(lpwd->szExeName, lpwd->szExpExeName))
        lpwd->dwFlags |= WDFLAG_EXPSZ;

    if (lpwd->dwFlags & WDFLAG_EXPSZ)
    {
        lpszName = lpwd->szExpExeName;
        cchName = ARRAYSIZE(lpwd->szExpExeName);
    }
    else
    {
        lpszName = lpwd->szExeName;
        cchName = ARRAYSIZE(lpwd->szExeName);
    }

    if (BrowseForExe(lpwd->hwnd, lpszName, cchName, lpszName))
    {
        lpwd->szParams[0] = 0;
        BrowseSetActive(lpwd);
    }
}


int CALLBACK BrowseCallbackProc(
    HWND hwnd, 
    UINT uMsg, 
    LPARAM lParam, 
    LPARAM lpData
    )
{
    LPITEMIDLIST pidlNavigate;

    switch (uMsg)
    {
    case BFFM_INITIALIZED:
        // Check if we should navigate to a folder on initialize
        pidlNavigate = (LPITEMIDLIST) lpData;
        if (pidlNavigate != NULL)
        {
            // Yes! We have a folder to navigate to; send the message
            SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM) FALSE, (LPARAM) pidlNavigate);
        }
        break;

    case BFFM_SELCHANGED:
        // Check if we should enable/disable the Ok button
        pidlNavigate = (LPITEMIDLIST)lParam;
        if (pidlNavigate != NULL)
        {
            DWORD dwFlags = SFGAO_FILESYSTEM;
            WCHAR szName[MAX_PATH] = L"";
            
            if (SUCCEEDED(SHGetNameAndFlags(pidlNavigate, SHGDN_NORMAL, szName, ARRAYSIZE(szName), &dwFlags)))
            {
                if ((dwFlags & SFGAO_FILESYSTEM) != 0 ||
                    !lstrncmp(szName, L"\\\\", 2))
                {
                    // Path is either a valid local path
                    // or a valid network path, enable the ok button
                    SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM)0, (LPARAM)1);
                }
                else
                {
                    // Path does not exist, disable the ok button
                    // This could be My Computer or an empty floppy drive etc...
                    SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM)0, (LPARAM)0);
                }
            }
        }
    }
     
    return 0;
}

// This implementation of 'Browse' uses SHBrowseForFolder to find a file or folder
// for the shortcut wizard - used by BrowseDlgProc
void BrowseForFileOrFolder(LPWIZDATA lpwd)
{
    TCHAR szBrowseTitle[256];
    TCHAR szName[MAX_PATH];
    BROWSEINFO bi = {0};
    LPITEMIDLIST pidlSelected;
    LPITEMIDLIST pidlStartBrowse;
    IShellFolder* pdesktop;

    // Try to start the browse at a location indicated by the typed-in command line,
    // if possible
    GetDlgItemText(lpwd->hwnd, IDC_COMMAND, lpwd->szExeName, ARRAYSIZE(lpwd->szExeName));

    // ..Get the desktop folder
    if (SUCCEEDED(SHGetDesktopFolder(&pdesktop)))
    {
        // ..Now try to parse the path the user entered into a pidl to start at
        ULONG chEaten;

#ifdef UNICODE
        if (FAILED(pdesktop->lpVtbl->ParseDisplayName(pdesktop, lpwd->hwnd, NULL,
            lpwd->szExeName, &chEaten, &pidlStartBrowse, NULL)))
#else
        WCHAR szTmp[MAX_PATH];
        
        SHAnsiToUnicode(lpwd->szExeName, szTmp, MAX_PATH);

        if (FAILED(pdesktop->lpVtbl->ParseDisplayName(pdesktop, lpwd->hwnd, NULL,
            szTmp, &chEaten, &pidlStartBrowse, NULL)))        
#endif
        {
            // The path the user entered didn't make any sense
            // pidlStartBrowse should already be NULL, but we want to make sure
            pidlStartBrowse = NULL;
        }

        // Now we can continue and display the browse window

        // Load the title string for the browse window
        LoadString(g_hinst, IDS_FILEFOLDERBROWSE_TITLE, szBrowseTitle, ARRAYSIZE(szBrowseTitle));

        // Note that bi = {0} for all other members except:
        bi.hwndOwner = lpwd->hwnd;
        bi.pszDisplayName = szName;
        bi.lpszTitle = szBrowseTitle;
        bi.ulFlags = BIF_BROWSEINCLUDEFILES | BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;

        // Ensure the pidl we want to start at is passed to the callback function
        bi.lpfn = BrowseCallbackProc;
        bi.lParam = (LPARAM) pidlStartBrowse;

        pidlSelected = SHBrowseForFolder(&bi);

        if (pidlSelected != NULL)
        {
            STRRET strret;
            if (SUCCEEDED(pdesktop->lpVtbl->GetDisplayNameOf(pdesktop, pidlSelected, SHGDN_NORMAL | SHGDN_FORPARSING, &strret)))
            {
                StrRetToBuf(&strret, pidlSelected, lpwd->szExeName, ARRAYSIZE(lpwd->szExeName));

                // Assume no parameters for this new file
                lpwd->szParams[0] = 0;
                
                // Populate the text box with the new file, etc.
                BrowseSetActive(lpwd);
            }
            // Free the pidl
            ILFree(pidlSelected);
        }

        if (pidlStartBrowse != NULL)
        {
            ILFree(pidlStartBrowse);
        }
            
        pdesktop->lpVtbl->Release(pdesktop);
    }
    else
    {
        // This really shouldn't happen; SHGetDesktopdesktop failed; out of memory?
    }
}

//
//  Main dialog procedure for first page of shortcut wizard.
//

//
//  Note that there are now two BrowseDlgProcs, the one below and
//  'SetupBrowseDlgProc'. This is because BrowseDlgProc now uses
//  a different method for implementing the 'Browse' button and I
//  wanted to do this without affecting the Setup Wizard which will
//  now use SetupBrowseDlgProc. - dsheldon 6/16/98
//

BOOL_PTR CALLBACK BrowseDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm = NULL;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = NULL;

    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            if(lpnm)
            {
                switch(lpnm->code)
                {
                   case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            lpwd->hwnd = hDlg;
                            if (lpwd->dwFlags & WDFLAG_NOBROWSEPAGE)
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                            else
                            {
                                BrowseSetActive(lpwd);
                            }
                        }
                        break;

                   case PSN_WIZNEXT:
                        if(lpwd)
                        {
                            if (!NextPushed(lpwd) ||
                                ((lpwd->dwFlags & WDFLAG_SETUPWIZ) && !SetupCleanupExePath(lpwd)))
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                        }
                        break;

                   case PSN_WIZFINISH:
                        if(lpwd)
                        {
                            BOOL ForceWx86;

#ifdef WX86
                            ForceWx86 = bWx86Enabled && bForceX86Env;
#else
                            ForceWx86 = FALSE;
#endif

                            if (!SetupCleanupExePath(lpwd) ||
                                !ExecSetupProg(lpwd, ForceWx86, TRUE))
                            {
                                BrowseSetActive(lpwd);
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                        }
                        break;

                   case PSN_RESET:
                        if(lpwd)
                        {
                            CleanUpWizData(lpwd);
                        }
                        break;

                   default:
                      return FALSE;
                }
            }
            break;

        case WM_INITDIALOG:
            BrowseInitPropSheet(hDlg, lParam);
            break;

        case WMPRIV_POKEFOCUS:
            {
            HWND hCmd = GetDlgItem(hDlg, IDC_COMMAND);

            SetFocus(hCmd);

            Edit_SetSel(hCmd, 0, -1);

            break;
            }

        case WM_DESTROY:
        case WM_HELP:
        case WM_CONTEXTMENU:
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDHELP:
                    break;

                case IDC_COMMAND:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case EN_CHANGE:
                            if(lpwd)
                            {
                                SetBrowseButtons(lpwd);
                            }
                            break;
                    }
                    break;

                case IDC_BROWSE:
                    if(lpwd)
                    {
                        BrowseForFileOrFolder(lpwd);
                    }
                    break;

            } // end of switch on WM_COMMAND
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;
}  // BrowseDlgProc


BOOL_PTR CALLBACK SetupBrowseDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm = NULL;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = NULL;

    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            if(lpnm)
            {
                switch(lpnm->code)
                {
                   BOOL bForceWx86;
                   case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            lpwd->hwnd = hDlg;
                            if (lpwd->dwFlags & WDFLAG_NOBROWSEPAGE)
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                            else
                            {
                                BrowseSetActive(lpwd);
                            }
                        }
                        break;

                   case PSN_WIZNEXT:
                        if(lpwd)
                        {
                            // Remember the previous "InstallMode"
                            lpwd->bPrevMode = TermsrvAppInstallMode();

                            // Set the "InstallMode"
                            SetTermsrvAppInstallMode(TRUE);

#ifdef WX86
                            bForceWx86 = bWx86Enabled && bForceX86Env;
#else
                            bForceWx86 = FALSE;
#endif
                            if (!NextPushed(lpwd) || !SetupCleanupExePath(lpwd) ||
                                  !ExecSetupProg(lpwd, bForceWx86, FALSE))
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                        }
                        break;

                   case PSN_WIZFINISH:
                       if(lpwd)
                       {
#ifdef WX86
                           bForceWx86 = bWx86Enabled && bForceX86Env;
#else
                           bForceWx86 = FALSE;
#endif

                           if (!SetupCleanupExePath(lpwd) ||
                               !ExecSetupProg(lpwd, bForceWx86, TRUE))
                           {
                               BrowseSetActive(lpwd);
                               SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                           }
                       }
                       break;

                   case PSN_RESET:
                       if(lpwd)
                       {
                           CleanUpWizData(lpwd);
                       }
                       break;

                   default:
                      return FALSE;
                }
            }
            break;

        case WM_INITDIALOG:
            BrowseInitPropSheet(hDlg, lParam);
            break;

        case WMPRIV_POKEFOCUS:
            {
            HWND hCmd = GetDlgItem(hDlg, IDC_COMMAND);

            SetFocus(hCmd);

            Edit_SetSel(hCmd, 0, -1);

            break;
            }

        case WM_DESTROY:
        case WM_HELP:
        case WM_CONTEXTMENU:
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDHELP:
                        break;

                case IDC_COMMAND:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case EN_CHANGE:
                            if(lpwd)
                            {
                                SetBrowseButtons(lpwd);
                            }
                            break;
                    }
                    break;

                case IDC_BROWSE:
                    if(lpwd)
                    {
                        BrowsePushed(lpwd);
                    }
                    break;

            } // end of switch on WM_COMMAND
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;
}  // SetupBrowseDlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\cctl.h ===
// CCtl.h : Declaration of the CARPCtl

#ifndef __CARPCTL_H_
#define __CARPCTL_H_

#include "events.h"
#include "util.h"
#include "mtxarray.h"       // for CAppData
#include "worker.h"         // for IWorkerEvent

// CARPCtl

class ATL_NO_VTABLE CARPCtl : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CARPCtl, &CLSID_CARPCtl>,
    public IObjectWithSiteImpl<CARPCtl>,
    public IConnectionPointContainerImpl<CARPCtl>,
    public IObjectSafetyImpl<CARPCtl>,
    public IDispatchImpl<IARPCtl, &IID_IARPCtl, &LIBID_ARPCTLLib>,
    public CProxy_ARPCtlEvents<CARPCtl>,
    public IProvideClassInfo2Impl<&CLSID_CARPCtl, &DIID__ARPCtlEvents, &LIBID_ARPCTLLib>,
    public IWorkerEvent
{
private:
    DWORD   _dwCurrentIndex;
    DWORD   _dwcItems;
    DWORD   _dwEnum;            // One of ENUM_*

    IShellAppManager* _pam;
    CMtxArray2 * _pmtxarray;

    CWorkerThread _workerthread;
    
    BITBOOL _fSecure: 1;

    void    _FreeAppData();
    CAppData * _GetAppData(DWORD iItem);

public:
    CARPCtl();
    ~CARPCtl();
    
    void EnumCallback(CAppData * pcad);

DECLARE_REGISTRY_RESOURCEID(IDR_CARPCTL)
DECLARE_NOT_AGGREGATABLE(CARPCtl)

BEGIN_COM_MAP(CARPCtl)
    COM_INTERFACE_ENTRY(IARPCtl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CARPCtl)
    CONNECTION_POINT_ENTRY(DIID__ARPCtlEvents)
END_CONNECTION_POINT_MAP()


// IARPCtl
public:
    // *** IWorkerEvent methods ***
    STDMETHOD(FireOnDataReady)  (LONG iRow);
    STDMETHOD(FireOnFinished)   (void);

    STDMETHOD(get_ItemCount)(/*[out, retval]*/ long *pVal);
    STDMETHOD(InitData)(BSTR bstrEnum, DWORD dwSortOrder);
    STDMETHOD(MoveNext)(BOOL* pbool);
    STDMETHOD(MoveFirst)(BOOL* pbool);
    STDMETHOD(MoveTo)(DWORD dwRecNum, BOOL* pbool);
    STDMETHOD(Exec)(BSTR bstrExec);
    STDMETHOD(get_DisplayName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Version)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Publisher)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ProductID)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RegisteredOwner)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Language)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SupportUrl)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SupportTelephone)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_HelpLink)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_InstallLocation)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_InstallSource)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_InstallDate)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RequiredByPolicy)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Contact)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Size)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_TimesUsed)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_LastUsed)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Capability)(/*[out, retval]*/ long *pVal);
};


#endif //__CARPCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\chgusr.c ===
//
//  Chgusr.C
//
//  Copyright (C) Citrix, 1996 All Rights Reserved.
//
//  History:
//  scottn 11/19/96 - First pass
//
//  scottn 12/5/96  - Add storage of chgusr option into registry.
//
//  scottn 12/13/96 - Create the UNINSTALL key if necessary (upon
//			first install of an uninstallable)
//
//  scottn 12/17/96 - Remove cwait (hangs on 16-bit installs).  Now
//			just exec and go to next page.  Add Finish page
//			which will turn option back and end tracking thread.
//
#include "priv.h"
#ifndef DOWNLEVEL_PLATFORM
#ifdef WINNT
#include "appwiz.h"
#include "regstr.h"
#include <uastrfnc.h>
#include <stdio.h>
#include <process.h>
#include <tsappcmp.h>       // for TermsrvAppInstallMode
#include "scripts.h"

static LPVOID g_pAppScripts = NULL;

//
//  Initialize the chgusr property sheet.  Check the "install" radio control.
//

void ChgusrFinishInitPropSheet(HWND hDlg, LPARAM lParam)
{
    LPWIZDATA lpwd = InitWizSheet(hDlg, lParam, 0);
}

void ChgusrFinishPrevInitPropSheet(HWND hDlg, LPARAM lParam)
{
    LPWIZDATA lpwd = InitWizSheet(hDlg, lParam, 0);
}

//
//  Sets the appropriate wizard buttons.
//
void SetChgusrFinishButtons(LPWIZDATA lpwd)
{
    // no BACK button so that they don't relaunch the app and
    // start a new thread, etc.

    int iBtns = PSWIZB_FINISH | PSWIZB_BACK;

    PropSheet_SetWizButtons(GetParent(lpwd->hwnd), iBtns);
}

void SetChgusrFinishPrevButtons(LPWIZDATA lpwd)
{
    // no BACK button so that they don't relaunch the app and
    // start a new thread, etc.

    int iBtns = PSWIZB_NEXT;

    PropSheet_SetWizButtons(GetParent(lpwd->hwnd), iBtns);
}

//
//  NOTES: 1) This function assumes that lpwd->hwnd has already been set to
//           the dialogs hwnd.
//

void ChgusrFinishSetActive(LPWIZDATA lpwd)
{
    if (lpwd->dwFlags & WDFLAG_SETUPWIZ)
    {
        TCHAR szInstruct[MAX_PATH];

        LoadString(g_hinst, IDS_CHGUSRFINISH, szInstruct, ARRAYSIZE(szInstruct));

        Static_SetText(GetDlgItem(lpwd->hwnd, IDC_SETUPMSG), szInstruct);
    }

    SetChgusrFinishButtons(lpwd);

    PostMessage(lpwd->hwnd, WMPRIV_POKEFOCUS, 0, 0);
}

void ChgusrFinishPrevSetActive(LPWIZDATA lpwd)
{
    g_pAppScripts = ScriptManagerInitScripts();

    if (lpwd->dwFlags & WDFLAG_SETUPWIZ)
    {
        TCHAR szInstruct[MAX_PATH];

        LoadString(g_hinst, IDS_CHGUSRFINISH_PREV, szInstruct, ARRAYSIZE(szInstruct));

        Static_SetText(GetDlgItem(lpwd->hwnd, IDC_SETUPMSG), szInstruct);
    }

    SetChgusrFinishPrevButtons(lpwd);

    PostMessage(lpwd->hwnd, WMPRIV_POKEFOCUS, 0, 0);
}

//
//  Main dialog procedure for fourth page of setup wizard.
//
BOOL_PTR CALLBACK ChgusrFinishPrevDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = NULL;

    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_SETACTIVE:
                    if (lpwd)
                    {
                        lpwd->hwnd = hDlg;
                        ChgusrFinishPrevSetActive(lpwd);
                    }
                    break;

                case PSN_WIZNEXT:
                    break;

                case PSN_RESET:
                    if (lpwd)
                    {
                        SetTermsrvAppInstallMode(lpwd->bPrevMode);
                        CleanUpWizData(lpwd);
                    }
                    if(g_pAppScripts)
                    {
                        ScriptManagerRunScripts(&g_pAppScripts);
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_INITDIALOG:
            ChgusrFinishPrevInitPropSheet(hDlg, lParam);
            break;

        case WMPRIV_POKEFOCUS:
        {
            break;
        }

        case WM_ENDSESSION:
            KdPrint(("ChgusrFinishPrevDlgProc - WM_ENDSESSION message received!\n"));
            if(g_pAppScripts)
            {
                ScriptManagerRunScripts(&g_pAppScripts);
            }
            return FALSE;

        case WM_DESTROY:
        case WM_HELP:
        case WM_CONTEXTMENU:
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDHELP:
                    break;

                case IDC_COMMAND:
                    break;

            } // end of switch on WM_COMMAND
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;
}  // ChgusrFinishDlgProc

//
//  Main dialog procedure for last page of setup wizard.
//
BOOL_PTR CALLBACK ChgusrFinishDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = NULL;

    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_SETACTIVE:
                    if (lpwd)
                    {
                        lpwd->hwnd = hDlg;
                        ChgusrFinishSetActive(lpwd);
                    }
                    break;

                case PSN_WIZFINISH:
                case PSN_RESET:
                    if (lpwd)
                    {
                        SetTermsrvAppInstallMode(lpwd->bPrevMode);

                        if (lpnm->code == PSN_RESET)
                            CleanUpWizData(lpwd);
                    }
                    if(g_pAppScripts)
                    {
                        ScriptManagerRunScripts(&g_pAppScripts);
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_INITDIALOG:
            ChgusrFinishInitPropSheet(hDlg, lParam);
            break;

        case WMPRIV_POKEFOCUS:
        {
            break;
        }


        case WM_ENDSESSION:
            KdPrint(("ChgusrFinishDlgProc - WM_ENDSESSION message received!\n"));
            if(g_pAppScripts)
            {
                ScriptManagerRunScripts(&g_pAppScripts);
            }
            return FALSE;

        case WM_DESTROY:
        case WM_HELP:
        case WM_CONTEXTMENU:
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDHELP:
                    break;

                case IDC_COMMAND:
                    break;

            } // end of switch on WM_COMMAND
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;
}  // ChgusrFinishDlgProc


#endif // WINNT
#endif // DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\darenum.h ===
#ifndef __DARENUM_H_
#define __DARENUM_H_


class CDarwinEnumPublishedApps : public IEnumPublishedApps
{
public:

    CDarwinEnumPublishedApps(GUID * pAppCategoryId);
    ~CDarwinEnumPublishedApps();
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IEnumPublishedApps
    STDMETHODIMP Next(IPublishedApp ** ppia);
    STDMETHODIMP Reset(void);
    //STDMETHODIMP SetCategory(GUID * pAppCategoryId);

protected:

    UINT    _cRef;
    GUID    _CategoryGUID;
    BOOL    _bGuidUsed;
    DWORD   _dwNumApps;
    DWORD   _dwIndex;
    PMANAGEDAPPLICATION _prgApps;
};

#endif //__DARENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\darpub.h ===
#ifndef __APPPUB_H_
#define __APPPUB_H_

/////////////////////////////////////////////////////////////////////////////
// CDarwinAppPublisher
class CDarwinAppPublisher : public IAppPublisher
{
public:
    CDarwinAppPublisher();
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAppPublisher
    STDMETHODIMP GetNumberOfCategories(DWORD * pdwCat);
    STDMETHODIMP GetCategories(APPCATEGORYINFOLIST * pAppCategoryList);
    STDMETHODIMP GetNumberOfApps(DWORD * pdwApps);
    STDMETHODIMP EnumApps(GUID * pAppCategoryId, IEnumPublishedApps ** ppepa);

protected:

    virtual ~CDarwinAppPublisher();

    UINT _cRef;
};

#endif //__APPPUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\darapp.h ===
#ifndef __DARAPP_H_
#define __DARAPP_H_


/////////////////////////////////////////////////////////////////////////////
// CDarwinPublishedApp
class CDarwinPublishedApp : public IPublishedApp
{
public:
    // Constructor for Darwin Apps
    CDarwinPublishedApp(MANAGEDAPPLICATION * ppdi);
    ~CDarwinPublishedApp();

    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellApp
    STDMETHODIMP GetAppInfo(PAPPINFODATA pai);
    STDMETHODIMP GetPossibleActions(DWORD * pdwActions);
    STDMETHODIMP GetSlowAppInfo(PSLOWAPPINFO psai);
    STDMETHODIMP GetCachedSlowAppInfo(PSLOWAPPINFO psai);
    STDMETHODIMP IsInstalled(void);
    
    // *** IPublishedApp
    STDMETHODIMP Install(LPSYSTEMTIME pftInstall);
    STDMETHODIMP GetPublishedAppInfo(PPUBAPPINFO ppai);
    STDMETHODIMP Unschedule(void);
    
protected:

    LONG _cRef;
    DWORD _dwAction;

    // Specific info on this Darwin App
    MANAGEDAPPLICATION _ma;
};

#endif //__DARAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\confopt.c ===
//
//  ConfOpt.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 5/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"

#define MAX_CFG_FILE_SIZE   20000
#define MAX_DESC_SIZE         100

//
//  Return codes for OptSelected
//
#define OPTSEL_YES      0
#define OPTSEL_NO       1
#define OPTSEL_NOTSUPP  2

//
//  Define checkbox states for listview
//
#define LVIS_GCNOCHECK      0x1000
#define LVIS_GCCHECK        0x2000

//
//  Character definitions
//
#define CR                13
#define LF                10


TCHAR const c_szCRLF[]            = {CR, LF, 0};
TCHAR const c_szRegValAutoexec[]  = REGSTR_VAL_AUTOEXEC;
TCHAR const c_szRegValConfigSys[] = REGSTR_VAL_CONFIGSYS;
TCHAR const c_szRegDosOptFlags[]  = REGSTR_VAL_DOSOPTFLAGS;
TCHAR const c_szRegStandardOpt[]  = REGSTR_VAL_STDDOSOPTION;
TCHAR const c_szRegDosOptTip[]    = REGSTR_VAL_DOSOPTTIP;
TCHAR const c_szRegDosOptsPath[]  = REGSTR_PATH_MSDOSOPTS;
TCHAR const c_szRegGlobalFlags[]  = REGSTR_VAL_DOSOPTGLOBALFLAGS;
TCHAR const c_szRegShutdownKey[]  = REGSTR_PATH_SHUTDOWN;
TCHAR const c_szForceRebootVal[]  = REGSTR_VAL_FORCEREBOOT;



BOOL MustRebootSystem(void)
{
    HKEY hk;
    BOOL bMustReboot = FALSE;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szRegShutdownKey, &hk) == ERROR_SUCCESS)
    {
        bMustReboot = (RegQueryValueEx(hk, c_szForceRebootVal, NULL,
                                       NULL, NULL, NULL) == ERROR_SUCCESS);
        RegCloseKey(hk);
    }
    return(bMustReboot);
}


DWORD GetMSDOSOptGlobalFlags(LPWIZDATA lpwd)
{
    if ((lpwd->dwFlags & WDFLAG_READOPTFLAGS) == 0)
    {
        HKEY hk;

        lpwd->dwFlags |= WDFLAG_READOPTFLAGS;

        if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szRegDosOptsPath, &hk)
               == ERROR_SUCCESS)
        {
            UINT cb = sizeof(lpwd->dwDosOptGlobalFlags);

            if (RegQueryValueEx(hk, c_szRegGlobalFlags, NULL, NULL,
                                (LPVOID)(&(lpwd->dwDosOptGlobalFlags)), &cb)
                                != ERROR_SUCCESS)
            {
                lpwd->dwDosOptGlobalFlags = 0;
            }
            RegCloseKey(hk);
        }

        if (MustRebootSystem())
        {
            lpwd->dwDosOptGlobalFlags |= DOSOPTGF_DEFCLEAN;
        }
    }
    return(lpwd->dwDosOptGlobalFlags);
}


//
//  Structure used to store text for Autoexec.Bat and Config.Sys
//

typedef struct _TEXTDATA {
    UINT    cb;
    LPTSTR  lpszData;
} TEXTDATA, FAR * LPTEXTDATA;


//
//  Gets a single value from the specified option index.  If no data is
//  found for the specified value name then a 0 DWORD is stored.
//

void GetOptVal(LPWIZDATA lpwd, int i, LPCTSTR lpszValName, LPVOID lpData, UINT cb)
{
    if (RegQueryValueEx(lpwd->DosOpt[i].hk, lpszValName, NULL, NULL, lpData, &cb) != ERROR_SUCCESS)
    {
        *(LPDWORD)lpData = (DWORD)0;
    }
}


BOOL FindDriver(int idFiles, int idLoadHigh, HKEY hk, LPCTSTR lpszRegVal,
                LPCTSTR FAR dirs[])
{
    TCHAR  szFiles[MAX_PATH];
    LPTSTR lpszCur, lpszFileName;
    TCHAR  szCommand[MAX_PATH+20];

    LoadAndStrip(idFiles, szFiles, ARRAYSIZE(szFiles));
    LoadString(g_hinst, idLoadHigh, szCommand, ARRAYSIZE(szCommand));

    lpszFileName = &szCommand[lstrlen(szCommand)];
    lpszCur = szFiles;

    while (*lpszCur)
    {
        lstrcpy(lpszFileName, lpszCur);
        if (PathResolve(lpszFileName, dirs, PRF_VERIFYEXISTS))
        {
            PathGetShortPath(lpszFileName);

            RegSetValueEx(hk, lpszRegVal, 0, REG_SZ, (LPBYTE) szCommand,
                            (lstrlen(szCommand)+1)*sizeof(TCHAR));

            return(TRUE);
        }
        lpszCur = SkipStr(lpszCur);
    }
    return(FALSE);
}


BOOL SetUpMouse(LPWIZDATA lpwd, int i)
{
    #define MOpt lpwd->DosOpt[i]
    TCHAR  szMouseEnv[64];
    TCHAR  szMouseDir[64];
    LPCTSTR FAR dirs[] = {szMouseDir, NULL};
    BOOL fRetVal;

    if (!LoadString(g_hinst, IDS_MOUSEENV, szMouseEnv, ARRAYSIZE(szMouseEnv)))
    {
        fRetVal = FALSE;
    }
    else
    {
        lstrcpy(szMouseDir, szMouseEnv);

        DoEnvironmentSubst(szMouseDir, ARRAYSIZE(szMouseDir));

        if (lstrcmp(szMouseDir, szMouseEnv) == 0)
        {
            dirs[0] = NULL;
        }

        if (FindDriver(IDS_MOUSETSRS, IDS_LOADHIGH,MOpt.hk, c_szRegValAutoexec,  dirs) ||
            FindDriver(IDS_MOUSEDRVS, IDS_DEVHIGH, MOpt.hk, c_szRegValConfigSys, dirs))
        {
            MOpt.dwFlags |= DOSOPTF_SUPPORTED;
            TraceMsg(TF_ERROR, "%s", "Found real mode mouse driver");
        }

        MOpt.dwFlags &= ~DOSOPTF_NEEDSETUP;
        RegSetValueEx(MOpt.hk, c_szRegDosOptFlags, 0, REG_DWORD,
                      (LPBYTE)&(MOpt.dwFlags), sizeof(MOpt.dwFlags));
        fRetVal = TRUE;
    }

    return fRetVal;
    #undef MOpt
}


//
//  The option is not configured.  Here's where to add code to set up any
//  standard option.  Currently, we only set up the mouse.
//

BOOL SetupOption(LPWIZDATA lpwd, int i)
{
    BOOL fRetVal;
    
    if (RMOPT_MOUSE == lpwd->DosOpt[i].dwStdOpt)
    {
        TraceMsg(TF_ERROR, "%s", "About to search for real mode mouse driver");
        fRetVal = SetUpMouse(lpwd, i);
    }
    else
    {
        fRetVal = TRUE;
    }

    return fRetVal;
}


//
//  Closes all open hkeys and frees the memory.  NOTE:        This function can
//  be called any time, even if ReadRegInfo has not been called previously.
//

void FreeRegInfo(LPWIZDATA lpwd)
{
    int i;

    if (!lpwd->DosOpt)
    {
        return;
    }

    for (i = 0; i < lpwd->NumOpts; i++)
    {
        RegCloseKey(lpwd->DosOpt[i].hk);
    }

    LocalFree(lpwd->DosOpt);
    lpwd->DosOpt = NULL;
    lpwd->NumOpts = 0;
}


//
//  Initializes the option table in the wizard data header.
//

BOOL ReadRegInfo(LPWIZDATA lpwd)
{
    HKEY    hk;
    BOOL    bSuccess = FALSE;
    int     i;

    if (lpwd->DosOpt)
    {
        return(TRUE);
    }

    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szRegDosOptsPath, &hk) !=
            ERROR_SUCCESS)
    {
        goto Exit;
    }

    if (RegQueryInfoKey(hk, NULL, NULL, NULL, &(lpwd->NumOpts),
                        NULL, NULL, NULL, NULL, NULL, NULL, NULL) !=
            ERROR_SUCCESS)
    {
        goto ExitCloseKey;
    }

    lpwd->DosOpt = LocalAlloc(LPTR, lpwd->NumOpts * sizeof(DOSOPT));

    if (!lpwd->DosOpt)
    {
        goto ExitCloseKey;
    }

    for (i = 0; i < lpwd->NumOpts; i++)
    {
        UINT   cb;
        TCHAR  szOptKey[80];        
        HKEY   hkOpt;
        UINT   uOrder = 0;
        int    InsPos;

        cb = ARRAYSIZE(szOptKey);

        if ((RegEnumKeyEx(hk, i, szOptKey, &cb, NULL, NULL, NULL, NULL) != ERROR_SUCCESS) ||
            (RegOpenKey(hk, szOptKey, &hkOpt) != ERROR_SUCCESS))
        {
            lpwd->NumOpts = i - 1;
            FreeRegInfo(lpwd);        // This frees the DosOpt memory
            goto ExitCloseKey;
        }

        cb = sizeof(uOrder);

        RegQueryValueEx(hkOpt, REGSTR_VAL_OPTORDER, NULL, NULL, (LPVOID)&uOrder, &cb);

        for (InsPos = i;
             (InsPos > 0) && (lpwd->DosOpt[InsPos-1].uOrder > uOrder);
             InsPos--);

        if (InsPos < i)
        {
            MoveMemory(&(lpwd->DosOpt[InsPos+1]), &(lpwd->DosOpt[InsPos]),
                       (i - InsPos) * sizeof(DOSOPT));
        }

        lpwd->DosOpt[InsPos].hk = hkOpt;
        lpwd->DosOpt[InsPos].uOrder = uOrder;

        GetOptVal(lpwd, InsPos, c_szRegDosOptFlags, &(lpwd->DosOpt[InsPos].dwFlags), sizeof(DWORD));
        GetOptVal(lpwd, InsPos, c_szRegStandardOpt, &(lpwd->DosOpt[InsPos].dwStdOpt), sizeof(DWORD));

        if (lpwd->DosOpt[InsPos].dwFlags & DOSOPTF_NEEDSETUP)
        {
            if (!SetupOption(lpwd, InsPos))
            {
                goto ExitCloseKey;
            }
        }
    }
    bSuccess = TRUE;

ExitCloseKey:
    RegCloseKey(hk);
Exit:
    return(bSuccess);
}


//
//  Inserts a single column into the specified ListView.
//

void InitSingleColListView(HWND hLV)
{
    LV_COLUMN col = {LVCF_FMT | LVCF_WIDTH, LVCFMT_LEFT};
    RECT    rc;

    GetClientRect(hLV, &rc);

    col.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL)
            - GetSystemMetrics(SM_CXSMICON)
            - 2 * GetSystemMetrics(SM_CXEDGE);

    ListView_InsertColumn(hLV, 0, &col);
}


//
//  Initializes the listview with all available options
//

void ConfOptInit(HWND hDlg, LPPROPSHEETPAGE lpp)
{
    HIMAGELIST himlState;
    HWND hwndOptions = GetDlgItem(hDlg, IDC_OPTIONLIST);
    LPWIZDATA lpwd = InitWizSheet(hDlg, (LPARAM)lpp, 0);

    InitSingleColListView(hwndOptions);

    //
    // Lets load our bitmap as an imagelist
    //

    himlState = ImageList_LoadImage(g_hinst, MAKEINTRESOURCE(IDB_CHECKSTATES), 0, 2,
            CLR_NONE, IMAGE_BITMAP, LR_LOADTRANSPARENT);

    ListView_SetImageList(hwndOptions, himlState, LVSIL_STATE);

    //
    //        Find all options for MS-DOS configs and set their approropriate state
    //        information
    //

    if (ReadRegInfo(lpwd))
    {
        int i;

        for (i = 0; i < lpwd->NumOpts; i++)
        {
            DWORD dwFlags = lpwd->DosOpt[i].dwFlags;

            if ((dwFlags & DOSOPTF_SUPPORTED) &&
                ((dwFlags & DOSOPTF_ALWAYSUSE) == 0) &&
                ((dwFlags & DOSOPTF_USESPMODE) == 0 ||
                 (lpwd->dwFlags & WDFLAG_REALMODEONLY) == 0) &&
                (lpwd->DosOpt[i].uOrder > 0))
            {
                TCHAR   szDesc[MAX_DESC_SIZE];
                LV_ITEM lvi;

                GetOptVal(lpwd, i, NULL, szDesc, sizeof(szDesc));

                lvi.mask     = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
                lvi.iItem    = 0x7FFF;
                lvi.iSubItem = 0;

                //
                ///// REARCHITECT If program properties contains real mode flags, use them for defaults!
                //

                lvi.state      = (dwFlags & DOSOPTF_DEFAULT) ? LVIS_GCCHECK : LVIS_GCNOCHECK;
                lvi.stateMask  = LVIS_ALL;
                lvi.pszText    = szDesc;
                lvi.lParam     = (LPARAM)i;
                lvi.cchTextMax = 0;

                ListView_InsertItem(hwndOptions, &lvi);
            }
        }
    }
}


//
//  Toggles the state of the specified item in the list view.
//

void ToggleState(HWND hwndLV, int i)
{
    UINT    state = ListView_GetItemState(hwndLV, i, LVIS_STATEIMAGEMASK);

    state = (state == LVIS_GCNOCHECK) ? LVIS_GCCHECK : LVIS_GCNOCHECK;

    ListView_SetItemState(hwndLV, i, state, LVIS_STATEIMAGEMASK);
}


//
//  Returns the path to the boot directory.  If we can't find it in the
//  registry then this function returns the default (drive that windows
//  directory is on)
//

void GetBootDir(LPTSTR lpszBootDir, int cchBootDir)
{
    HKEY    hkSetup;

    *lpszBootDir = 0;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP REGSTR_KEY_SETUP,
                   &hkSetup) == ERROR_SUCCESS)
    {
        UINT cb = cchBootDir * SIZEOF(TCHAR);

        RegQueryValueEx(hkSetup, REGSTR_VAL_BOOTDIR, NULL,
                        NULL, (LPBYTE) lpszBootDir, &cb);
        RegCloseKey(hkSetup);
    }

    if (*lpszBootDir == 0)
    {
        if (0 != GetWindowsDirectory(lpszBootDir, cchBootDir)
             && lpszBootDir[0] != TEXT('\0')
             && lpszBootDir[1] == TEXT(':')
             && lpszBootDir[2] == TEXT('\\'))
        {
            lpszBootDir[3] = TEXT('\0');
        }
        else
        {
            LoadString(g_hinst, IDS_DEFBOOTDIR, lpszBootDir, cchBootDir);
        }
    }
}


//
//  Process the clicks on the listview.  do a hittest to see where the user
//  clicked.  If on one of the state bitmaps, toggle it.
//

void ConfOptClick(HWND hDlg, LPNMHDR pnmhdr)
{
    //
    // The user clicked on one the listview see where...
    //

    DWORD dwpos;
    LV_HITTESTINFO lvhti;

    dwpos = GetMessagePos();
    lvhti.pt.x = GET_X_LPARAM(dwpos);
    lvhti.pt.y = GET_Y_LPARAM(dwpos);

    MapWindowPoints(HWND_DESKTOP, pnmhdr->hwndFrom, &lvhti.pt, 1);

    ListView_HitTest(pnmhdr->hwndFrom, &lvhti);

    if (lvhti.flags & LVHT_ONITEMSTATEICON)
    {
        ToggleState(pnmhdr->hwndFrom, lvhti.iItem);
    }
}


//
//  When the user hits the space bar, toggle the state of the selected item.
//
BOOL ConfOptKeyDown(HWND hDlg, LV_KEYDOWN *plvkd)
{
    int iCursor;

    if (plvkd->wVKey == VK_SPACE && !(GetAsyncKeyState(VK_MENU) < 0))
    {
        //
        // Lets toggle the cursored item.
        //

        iCursor = ListView_GetNextItem(plvkd->hdr.hwndFrom, -1, LVNI_FOCUSED);

        if (iCursor != -1)
        {
            ToggleState(plvkd->hdr.hwndFrom, iCursor);
        }
        return TRUE;
    }
    return FALSE;
}


//
//  Item selection changed.  Update tip.
//

void ItemChanged(LPWIZDATA lpwd, LPNM_LISTVIEW lpnmlv)
{
    LV_ITEM lvi;
    TCHAR   szTip[200]; ///???

    if ((lpnmlv->uNewState & LVIS_FOCUSED) &&
        (!(lpnmlv->uOldState & LVIS_FOCUSED)))
    {
        lvi.iItem = lpnmlv->iItem;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM;

        ListView_GetItem(lpnmlv->hdr.hwndFrom, &lvi);

        GetOptVal(lpwd, (int)lvi.lParam, c_szRegDosOptTip, szTip, sizeof(szTip));

        Static_SetText(GetDlgItem(lpwd->hwnd, IDC_OPTIONTIP), szTip);
    }
}


void _inline NoSupportMsg(LPWIZDATA lpwd, int iOpt)
{
    LPTSTR lpszDesc = (LPTSTR)LocalAlloc(LMEM_FIXED, MAX_DESC_SIZE*sizeof(TCHAR));

    if (lpszDesc)
    {
        LPTSTR lpszMsg = (LPTSTR)LocalAlloc(LMEM_FIXED, 512*sizeof(TCHAR)); // Max 2 resource size

        if (lpszMsg)
        {
            GetOptVal(lpwd, iOpt, NULL, lpszDesc, MAX_DESC_SIZE*sizeof(TCHAR));
            LoadString(g_hinst, IDS_NOSUPPORT1, lpszMsg, 512);
            LoadString(g_hinst, IDS_NOSUPPORT2, lpszMsg+lstrlen(lpszMsg), 256);
            ShellMessageBox(g_hinst, lpwd->hwnd,
                            lpszMsg, 0,
                            MB_OK | MB_ICONEXCLAMATION,
                            lpszDesc);
            LocalFree(lpszMsg);
        }
        LocalFree(lpszDesc);
    }
}


//
//  Returns OPTSEL_YES if the option indicated by i is selected in the list
//  box, or, if hwndLV is NULL then OPTSEL_YES if option should be added,
//  OPTSEL_NO if should not be added, and OPTSEL_NOTSUPP if the option is
//  required but can't be added.
//

int OptSelected(LPWIZDATA lpwd, int i, HWND hwndLV)
{
    BOOL bSelected = FALSE;

    if (lpwd->DosOpt[i].dwFlags & DOSOPTF_ALWAYSUSE)
    {
        bSelected = TRUE;
    }
    else
    {
        if (hwndLV)
        {
            LV_ITEM lvi;
            int     NumItems = ListView_GetItemCount(hwndLV);

            for (lvi.iItem = 0; lvi.iItem < NumItems; lvi.iItem++)
            {
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM | LVIF_STATE;
                lvi.stateMask = LVIS_STATEIMAGEMASK;
                ListView_GetItem(hwndLV, &lvi);
                if ((int)lvi.lParam == i)
                {
                    bSelected = ((lvi.state & LVIS_STATEIMAGEMASK) == LVIS_GCCHECK);
                }
            }
        }
        else
        {
            BOOL bSupported = lpwd->DosOpt[i].dwFlags & DOSOPTF_SUPPORTED;

            if (lpwd->PropPrg.dwRealModeFlags & lpwd->DosOpt[i].dwStdOpt)
            {
                bSelected = TRUE;

                if (!bSupported)
                {
                    NoSupportMsg(lpwd, i);
                    return(OPTSEL_NOTSUPP);
                }
            }
            else
            {
                if (bSupported)
                {
                    bSelected = (lpwd->PropPrg.dwRealModeFlags & (lpwd->DosOpt[i].dwStdOpt >> 16));
                }
            }
        }
    }

    if (bSelected)
    {
        return(OPTSEL_YES);
    }
    else
    {
        return(OPTSEL_NO);
    }
}


void AppendStr(LPTEXTDATA lpTD, LPTSTR lpStr)
{
    int cb = lstrlen(lpStr)*sizeof(TCHAR);

    if ((lpTD->cb + cb + 2) <= MAX_CFG_FILE_SIZE*sizeof(TCHAR))
    {
        memcpy(lpTD->lpszData+lpTD->cb, lpStr, cb);
        lpTD->cb += cb;
    }
}


//
//  Appends the string+cr/lf to the TextData structure.
//

void AppendLine(LPTEXTDATA lpTD, LPTSTR lpStr)
{
    AppendStr(lpTD, lpStr);
    AppendStr(lpTD, (LPTSTR)c_szCRLF);
}


//
//  Returns NULL if none of the strings in szKeys matches the first entry
//  in the specified string.
//

LPTSTR MatchesKey(LPTSTR lpszStr, LPTSTR lpszKeys)
{
    UINT    cch = lstrlen(lpszStr);
    TCHAR   szUpLine[20];
    LPTSTR  lpszCurKey;

    if (cch >= ARRAYSIZE(szUpLine))
    {
        cch = ARRAYSIZE(szUpLine)-1;
    }

    memcpy(szUpLine, lpszStr, cch*sizeof(TCHAR));

    szUpLine[cch] = 0;

    CharUpper(szUpLine);

    for (lpszCurKey = lpszKeys; *lpszCurKey; lpszCurKey = SkipStr(lpszCurKey))
    {
        UINT cchKey = lstrlen(lpszCurKey);

        if ((cchKey < cch) &&
            ((szUpLine[cchKey] == TEXT(' ')) || (szUpLine[cchKey] == TEXT('='))) &&
            (memcmp(lpszCurKey, szUpLine, cchKey*sizeof(TCHAR)) == 0))
        {
            return(lpszCurKey);
        }
    }
    return(NULL);
}


//
//  Copy the current environment into Autoexec.Bat
//

void CopyEnvironment(LPTEXTDATA lpAE)
{
    TCHAR   szKeys[MAX_PATH];         // SIZE?
    TCHAR   szSetCmd[20];
    LPTSTR  lpszCur = (LPTSTR)GetEnvironmentStrings();

    LoadString(g_hinst, IDS_SETCMD, szSetCmd, ARRAYSIZE(szSetCmd));
    LoadAndStrip(IDS_NOCOPYENV, szKeys, ARRAYSIZE(szKeys));

    while (*lpszCur)
    {
        if (!MatchesKey(lpszCur, szKeys))
        {
            AppendStr(lpAE, szSetCmd);
            AppendLine(lpAE, lpszCur);
        }

        lpszCur = SkipStr(lpszCur);
    }
}


//
//  Add keyboard type option for JKEYB.SYS
//

void SetJkeybOpt(LPTSTR lpszStr)
{
    UINT    cb, cbKey;
    TCHAR   szUpLine[64];
    TCHAR   lpszKey[] = TEXT("JKEYB.SYS");
    TCHAR   *lpszOpts[] = {TEXT(" /101"), TEXT(" /AX"), TEXT(" /106"), TEXT(" /J31DT"), TEXT(" /J31NB"), TEXT(" /J31LT")};
    int     KeybOpt;
    int     i;

    ASSERT(lpszStr);

    cb = lstrlen(lpszStr);
    cbKey = lstrlen(lpszKey);

    if (cb >= ARRAYSIZE(szUpLine))
    {
        cb = ARRAYSIZE(szUpLine)-1;
    }

    memcpy(szUpLine, lpszStr, cb*sizeof(TCHAR));

    szUpLine[cb] = 0;

//    AnsiUpper(szUpLine);
    CharUpper(szUpLine);

    for (i = 0; cbKey <= cb; i++, cb--)
    {
        if (memcmp(lpszKey, &szUpLine[i], cbKey*sizeof(TCHAR)) == 0)
        {

//            if (GetKeyboardType(0) == 7){
//                switch(GetKeyboardType(1)) {

            if (GetPrivateProfileInt(TEXT("keyboard"), TEXT("type"), 0, TEXT("SYSTEM.INI")) == 7)
            {
                switch(GetPrivateProfileInt(TEXT("keyboard"), TEXT("subtype"), 0, TEXT("SYSTEM.INI")))
                {
                    case 0:
                        KeybOpt = 0;
                        break;
                    case 1:
                        KeybOpt = 1;
                        break;
                    case 2:
                    case 3:
                    case 4:
                        KeybOpt = 2;
                        break;
                    case 13:
                        KeybOpt = 3;
                        break;
                    case 14:
                        KeybOpt = 4;
                        break;
                    case 15:
                        KeybOpt = 5;
                        break;
                    default:
                        KeybOpt = 0;
                        break;
                }
            }
            else
                KeybOpt = 0;

            lstrcat(lpszStr, lpszOpts[KeybOpt]);
            break;
        }
    }
}


//
//  Adds an option line from the specified value name to the TEXTDATA structure
//

BOOL AddOption(HKEY hk, LPCTSTR lpszValName, LPTEXTDATA lpTD,
               LPTSTR lpszHighCmds, LPTSTR lpszLowCmd, BOOL bCanLoadHigh)
{
    TCHAR  szOptData[256];
    UINT   cb = sizeof(szOptData);
    DWORD  dwType;
    LCID   lcid = GetThreadLocale();

    if (RegQueryValueEx(hk, lpszValName, NULL,
            &dwType, (LPBYTE) szOptData, &cb) == ERROR_SUCCESS)
    {
        LPTSTR  lpszAddData = szOptData;

        DoEnvironmentSubst(szOptData, ARRAYSIZE(szOptData));

        //
        //  Now remove LH or LoadHigh or DeviceHigh and replace with the
        //  appropriate string if EMM386 has not loaded yet.
        //

        if (!bCanLoadHigh)
        {
            LPTSTR lpszMatch = MatchesKey(szOptData, lpszHighCmds);

            if (lpszMatch)
            {
                int cbHigh = lstrlen(lpszMatch);
                if (lpszLowCmd)
                {
                    int cbLow = lstrlen(lpszLowCmd);

                    lpszAddData += cbHigh - cbLow;

                    memcpy(lpszAddData, lpszLowCmd, cbLow*sizeof(TCHAR));

                }
                else
                {
                    lpszAddData += cbHigh + 1;
                }
            }
        }

        if (PRIMARYLANGID(LANGIDFROMLCID(lcid))==LANG_JAPANESE)
        {
            SetJkeybOpt(lpszAddData);
        }
        AppendLine(lpTD, lpszAddData);

        return(TRUE);
    }
    return(FALSE);
}


//
//  Sets the appropriate configuration options in the PIF proprties
//  If fForceCleanCfg is TRUE then a clean configuration is created.  Otherwise
//  the autoexec and config fields are nuked to force the app to use the current
//  configuration.
//

PIFWIZERR SetConfOptions(LPWIZDATA lpwd, HWND hwndOptions, BOOL fForceCleanCfg)
{
    TEXTDATA  AE;
    TEXTDATA  CS;
    int       i;
    PIFWIZERR err = PIFWIZERR_SUCCESS;
    TCHAR     szCSHighCmds[100];
    TCHAR     szCSLowCmd[20];
    TCHAR     szAEHighCmds[100];
    BOOL      bCanLoadHigh = FALSE;

    //
    // Make sure the real mode flag is set in the program properties.
    //

    PifMgr_GetProperties(lpwd->hProps, (LPSTR)GROUP_PRG, &(lpwd->PropPrg),
                         sizeof(lpwd->PropPrg), GETPROPS_NONE);

    lpwd->PropPrg.flPrgInit |= PRGINIT_REALMODE;

    PifMgr_SetProperties(lpwd->hProps, (LPSTR)GROUP_PRG, &(lpwd->PropPrg),
                         sizeof(lpwd->PropPrg), SETPROPS_NONE);

    if (!fForceCleanCfg)
    {
        TCHAR NullStr = 0;

        PifMgr_SetProperties(lpwd->hProps, AUTOEXECHDRSIG40, &NullStr, 0, SETPROPS_NONE);
        PifMgr_SetProperties(lpwd->hProps, CONFIGHDRSIG40,   &NullStr, 0, SETPROPS_NONE);
        return(err);
    }

    //
    // Load strings used to force drivers to load low if no EMM386.
    //

    LoadString(g_hinst, IDS_CSLOWSTR, szCSLowCmd, ARRAYSIZE(szCSLowCmd));
    LoadAndStrip(IDS_CSHIGHSTRS, szCSHighCmds, ARRAYSIZE(szCSHighCmds));
    LoadAndStrip(IDS_AEHIGHSTRS, szAEHighCmds, ARRAYSIZE(szAEHighCmds));

    //
    // Allocate memory for autoexec/config.sys buffers.
    //

    AE.lpszData = (LPTSTR)LocalAlloc(LPTR, MAX_CFG_FILE_SIZE*sizeof(TCHAR));

    if (AE.lpszData == NULL)
    {
        return(PIFWIZERR_OUTOFMEM);
    }

    CS.lpszData = (LPTSTR)LocalAlloc(LPTR, MAX_CFG_FILE_SIZE*sizeof(TCHAR));

    if (CS.lpszData == NULL)
    {
        LocalFree(AE.lpszData);
        return(PIFWIZERR_OUTOFMEM);
    }

    AE.cb = CS.cb = 0;

    //
    // Copy the appropriate goop out of config.sys and autoexec.bat
    //

    CopyEnvironment(&AE);

    for (i = 0; i < lpwd->NumOpts; i++)
    {
        int OptSel = OptSelected(lpwd, i, hwndOptions);

        if (OptSel == OPTSEL_YES)
        {
            bCanLoadHigh |= (lpwd->DosOpt[i].dwFlags & DOSOPTF_PROVIDESUMB);

            AddOption(lpwd->DosOpt[i].hk, c_szRegValAutoexec,  &AE,
                      szAEHighCmds, NULL, bCanLoadHigh);

            AddOption(lpwd->DosOpt[i].hk, c_szRegValConfigSys, &CS,
                      szCSHighCmds, szCSLowCmd, bCanLoadHigh);

            //
            // DOSOPTF_MULTIPLE will load multiple configuration from
            // Config.Sys1 - Config.Sys9 and Autoexec.Bat1 - Autoexec.Bat9
            //

            if (lpwd->DosOpt[i].dwFlags & DOSOPTF_MULTIPLE)
            {
                BOOL  ret;
                TCHAR multicount[2];
                TCHAR multiAutoexec[64];
                TCHAR multiConfig[64];

                lstrcpy(multicount,TEXT("1"));

                while (1)
                {
                    lstrcpy(multiAutoexec, c_szRegValAutoexec);
                    lstrcat(multiAutoexec, multicount);
                    lstrcpy(multiConfig, c_szRegValConfigSys);
                    lstrcat(multiConfig, multicount);

                    ret = AddOption(lpwd->DosOpt[i].hk, multiAutoexec,  &AE,
                                     szAEHighCmds, NULL, bCanLoadHigh);

                    ret |= AddOption(lpwd->DosOpt[i].hk, multiConfig, &CS,
                                     szCSHighCmds, szCSLowCmd, bCanLoadHigh);

                    if (!ret)
                        break;

                    multicount[0] += 1;

                    if (multicount[0] > TEXT('9'))
                        break;
                }
            }
        }
        else
        {
            if (OptSel == OPTSEL_NOTSUPP)
            {
                err = PIFWIZERR_UNSUPPORTEDOPT;
            }
        }
    }

    //
    //  Set the properties in the PIF file
    //

    PifMgr_SetProperties(lpwd->hProps, AUTOEXECHDRSIG40, AE.lpszData, AE.cb, SETPROPS_NONE);
    PifMgr_SetProperties(lpwd->hProps, CONFIGHDRSIG40, CS.lpszData, CS.cb, SETPROPS_NONE);

    //
    //  Clean up allocated memory
    //

    LocalFree(AE.lpszData);
    LocalFree(CS.lpszData);

    return(err);
}


//
//  The user hit the finish button.  Set the proper configuration.
//

PIFWIZERR ConfigRealModeOptions(LPWIZDATA lpwd, HWND hwndOptList,
                                UINT uAction)
{
    PIFWIZERR err = PIFWIZERR_GENERALFAILURE;
    BOOL      fCleanCfg;

    switch(uAction)
    {
        case CRMOACTION_DEFAULT:
            fCleanCfg = GetMSDOSOptGlobalFlags(lpwd) & DOSOPTGF_DEFCLEAN;
            break;

        case CRMOACTION_CLEAN:
            fCleanCfg = TRUE;
            break;

        case CRMOACTION_CURRENT:
            fCleanCfg = FALSE;
            break;
    }

    //
    // OK to call twice -- Returns true
    //

    if (ReadRegInfo(lpwd))
    {
        if (lpwd->hProps == 0)
        {
            if (CreateLink(lpwd))
            {
                TCHAR szLinkName[MAX_PATH];

                GetLinkName(szLinkName, lpwd);

                lpwd->hProps = PifMgr_OpenProperties(szLinkName, NULL, 0, OPENPROPS_NONE);

                if (lpwd->hProps)
                {
                    err = SetConfOptions(lpwd, hwndOptList, fCleanCfg);

                    PifMgr_CloseProperties(lpwd->hProps, CLOSEPROPS_NONE);

                    lpwd->hProps = 0;
                }
            }
        }
        else
        {
            err = SetConfOptions(lpwd, hwndOptList, fCleanCfg);
        }

        FreeRegInfo(lpwd);
    }
    return(err);
}


BOOL_PTR CALLBACK ConfigOptionsDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    LPNMHDR lpnm = NULL;
    LPPROPSHEETPAGE lpp = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = lpp ? (LPWIZDATA)lpp->lParam : NULL;

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (LPNMHDR)lParam;

            if(lpnm)
            {
                switch(lpnm->code)
                {
                    case LVN_ITEMCHANGED:
                        if(lpwd)
                        {
                            ItemChanged(lpwd, (LPNM_LISTVIEW)lParam);
                        }
                        break;

                    case NM_CLICK:
                    case NM_DBLCLK:
                        ConfOptClick(hDlg, lpnm);
                        break;

                    case LVN_KEYDOWN:
                        SetDlgMsgResult(hDlg, WM_NOTIFY,
                                        ConfOptKeyDown(hDlg, (LV_KEYDOWN *)lParam));
                        break;


                    case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            lpwd->hwnd = hDlg;

                            if (lpwd->dwFlags & WDFLAG_PIFPROP)
                            {
                                TCHAR szOK[20];

                                LoadString(g_hinst, IDS_OK, szOK, ARRAYSIZE(szOK));
                                PropSheet_SetFinishText(GetParent(hDlg), szOK);
                            }
                            else
                            {
                                PropSheet_SetWizButtons(GetParent(hDlg),
                                                         PSWIZB_FINISH | PSWIZB_BACK);
                            }
                        }
                        break;

                    case PSN_WIZFINISH:
                        if(lpwd)
                        {
                            ConfigRealModeOptions(lpwd, GetDlgItem(hDlg, IDC_OPTIONLIST),
                                                  CRMOACTION_CLEAN);
                        }
                        break;

                    case PSN_RESET:
                        if(lpwd)
                        {
                            CleanUpWizData(lpwd);
                        }
                        break;

                    default:
                        return FALSE;
                }
            }
            break;


        case WM_INITDIALOG:
            ConfOptInit(hDlg, (LPPROPSHEETPAGE)lParam);
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////

void WhichConfInit(HWND hDlg, LPPROPSHEETPAGE lpp)
{
    LPWIZDATA lpwd = InitWizSheet(hDlg, (LPARAM)lpp, 0);

    CheckRadioButton(hDlg, IDB_CURCFG, IDB_CLEANCFG,
                     GetMSDOSOptGlobalFlags(lpwd) & DOSOPTGF_DEFCLEAN ?
                     IDB_CLEANCFG : IDB_CURCFG);
}


void SetChoiceWizBtns(LPWIZDATA lpwd)
{
    PropSheet_SetWizButtons(GetParent(lpwd->hwnd),
                            IsDlgButtonChecked(lpwd->hwnd, IDB_CLEANCFG) ?
                            PSWIZB_NEXT | PSWIZB_BACK :
                            PSWIZB_FINISH | PSWIZB_BACK);
}


BOOL_PTR CALLBACK PickConfigDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    LPNMHDR lpnm = NULL;
    LPPROPSHEETPAGE lpp = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = lpp ? (LPWIZDATA)lpp->lParam : NULL;

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (LPNMHDR)lParam;

            if(lpnm)
            {
                switch(lpnm->code)
                {
                    case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            lpwd->hwnd = hDlg;
                            if (MustRebootSystem())
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                            else
                            {
                                SetChoiceWizBtns(lpwd);
                            }
                        }
                        break;

                    case PSN_WIZFINISH:
                        if(lpwd)
                        {
                            ConfigRealModeOptions(lpwd, GetDlgItem(hDlg, IDC_OPTIONLIST),
                                                  CRMOACTION_CURRENT);
                        }
                        break;

                    case PSN_RESET:
                        if(lpwd)
                        {
                            CleanUpWizData(lpwd);
                        }
                        break;

                    default:
                        return FALSE;
                }
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDB_CURCFG:
                case IDB_CLEANCFG:
                    if(lpwd)
                    {
                        SetChoiceWizBtns(lpwd);
                    }
            }
            break;

        case WM_INITDIALOG:
            WhichConfInit(hDlg, (LPPROPSHEETPAGE)lParam);
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\darapp.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: instapp.cpp
//
// Installed applications 
//
// History:
//         1-18-97  by dli
//------------------------------------------------------------------------
#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include "darapp.h"
#include "util.h"   
#include "appwizid.h"

// constructor
CDarwinPublishedApp::CDarwinPublishedApp(MANAGEDAPPLICATION * pma) : _cRef(1)
{
    DllAddRef();

    TraceAddRef(CDarwinPublishedApp, _cRef);
    
    hmemcpy(&_ma, pma, SIZEOF(_ma));
    _dwAction  |= APPACTION_INSTALL;
}


// destructor
CDarwinPublishedApp::~CDarwinPublishedApp()
{
    ClearManagedApplication(&_ma);
    DllRelease();
}



// IShellApps::GetAppInfo
STDMETHODIMP CDarwinPublishedApp::GetAppInfo(PAPPINFODATA pai)
{
    if (pai->cbSize != SIZEOF(APPINFODATA))
        return E_FAIL;

    DWORD dwInfoFlags = pai->dwMask;
    pai->dwMask = 0;
    
    if (dwInfoFlags & AIM_DISPLAYNAME)
    {
        if (SUCCEEDED(SHStrDupW(_ma.pszPackageName, &pai->pszDisplayName)))
            pai->dwMask |= AIM_DISPLAYNAME;
    }

    if ((dwInfoFlags & AIM_PUBLISHER) && _ma.pszPublisher && _ma.pszPublisher[0])
    {
        if (SUCCEEDED(SHStrDupW(_ma.pszPublisher, &pai->pszPublisher)))
            pai->dwMask |= AIM_PUBLISHER;
    }

    if ((dwInfoFlags & AIM_SUPPORTURL) && _ma.pszSupportUrl && _ma.pszSupportUrl[0])
    {
        if (SUCCEEDED(SHStrDupW(_ma.pszSupportUrl, &pai->pszSupportUrl)))
            pai->dwMask |= AIM_SUPPORTURL;
    }

    if ((dwInfoFlags & AIM_VERSION) && (_ma.dwVersionHi != 0))
    {
        pai->pszVersion = (LPWSTR)SHAlloc(SIZEOF(WCHAR) * MAX_PATH);
        wsprintf(pai->pszVersion, L"%d.%d.%d.%d", HIWORD(_ma.dwVersionHi), LOWORD(_ma.dwVersionHi), HIWORD(_ma.dwVersionLo), LOWORD(_ma.dwVersionLo));
        pai->dwMask |= AIM_VERSION;
    }

    
    // REARCHITECT: get more info for Darwin apps
    // original comment: don't know how to retrieve other infomation, need to talk to the Darwin guys about it
    TraceMsg(TF_GENERAL, "(DarPubApp) GetAppInfo with %x but got %x", dwInfoFlags, pai->dwMask);
    
    return S_OK;
}

// IShellApps::GetPossibleActions
STDMETHODIMP CDarwinPublishedApp::GetPossibleActions(DWORD * pdwActions)
{
    ASSERT(pdwActions);
    *pdwActions = _dwAction;
    return S_OK;
}
        
// IShellApps::GetSlowAppInfo
STDMETHODIMP CDarwinPublishedApp::GetSlowAppInfo(PSLOWAPPINFO psai)
{
    return E_NOTIMPL;
}

// IShellApps::GetSlowAppInfo
STDMETHODIMP CDarwinPublishedApp::GetCachedSlowAppInfo(PSLOWAPPINFO psai)
{
    return E_NOTIMPL;
}

// IShellApps::IsInstalled
STDMETHODIMP CDarwinPublishedApp::IsInstalled()
{
    return _ma.bInstalled ? S_OK : S_FALSE;
}

// IPublishedApps::Install
STDMETHODIMP CDarwinPublishedApp::Install(LPSYSTEMTIME pftInstall)
{
    INSTALLDATA id;
    id.Type = APPNAME;
    id.Spec.AppName.Name = _ma.pszPackageName;
    id.Spec.AppName.GPOId = _ma.GpoId;
    LONG lRet = InstallApplication(&id);

    HRESULT hres = HRESULT_FROM_WIN32(lRet);
    // Tell the users what is wrong with this install. 
    if (FAILED(hres))
        _ARPErrorMessageBox(lRet);
    else
        _ma.bInstalled = TRUE;
    
    return hres;
}

// IPublishedApps::GetPublishedTime
STDMETHODIMP CDarwinPublishedApp::GetPublishedAppInfo(PPUBAPPINFO ppai)
{
    if (ppai->cbSize != SIZEOF(PUBAPPINFO))
        return E_FAIL;

    DWORD dwInfoFlags = ppai->dwMask;
    ppai->dwMask = 0;
    
    if ((dwInfoFlags & PAI_SOURCE) && _ma.pszPolicyName && _ma.pszPolicyName[0])
    {
        if (SUCCEEDED(SHStrDupW(_ma.pszPolicyName, &ppai->pszSource)))
            ppai->dwMask |= PAI_SOURCE;
    }
    return S_OK;
}

// IPublishedApps::GetAssignedTime
STDMETHODIMP CDarwinPublishedApp::Unschedule(void)
{
    return E_NOTIMPL;
}

// IPublishedApp::QueryInterface
HRESULT CDarwinPublishedApp::QueryInterface(REFIID riid, LPVOID * ppvOut)
{ 
    static const QITAB qit[] = {
        QITABENT(CDarwinPublishedApp, IPublishedApp),                  // IID_IPublishedApp
        QITABENTMULTI(CDarwinPublishedApp, IShellApp, IPublishedApp),  // IID_IShellApp
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IPublishedApp::AddRef
ULONG CDarwinPublishedApp::AddRef()
{
    InterlockedIncrement(&_cRef);
    TraceAddRef(CDarwinPublishedApp, _cRef);
    return _cRef;
}

// IPublishedApp::Release
ULONG CDarwinPublishedApp::Release()
{
    InterlockedDecrement(&_cRef);
    TraceRelease(CDarwinPublishedApp, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\darenum.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: darenum.cpp
//
// The current order of enumeration is Legacy --> Darwin --> SMS
//
// History:
//         2-03-97  by dli
//------------------------------------------------------------------------
#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include "darenum.h"
#include "darapp.h"
#include "util.h"

CDarwinEnumPublishedApps::CDarwinEnumPublishedApps(GUID * pAppCategoryId) : _cRef(1)
{
    ASSERT(_bGuidUsed == FALSE);

    // Do we have a Catogory GUID?
    if (pAppCategoryId)
    {
        // Yes
        _CategoryGUID = *pAppCategoryId;
        _bGuidUsed = TRUE;
    }

    GetManagedApplications(_bGuidUsed ? &_CategoryGUID : NULL, _bGuidUsed ? MANAGED_APPS_FROMCATEGORY : MANAGED_APPS_USERAPPLICATIONS,
                           MANAGED_APPS_INFOLEVEL_DEFAULT, &_dwNumApps, &_prgApps);
}

CDarwinEnumPublishedApps::~CDarwinEnumPublishedApps() 
{
    if (_prgApps && (_dwNumApps > 0))
    {
        LocalFree(_prgApps);
    }
}

// IEnumPublishedApps::QueryInterface
HRESULT CDarwinEnumPublishedApps::QueryInterface(REFIID riid, LPVOID * ppvOut)
{ 
    static const QITAB qit[] = {
        QITABENT(CDarwinEnumPublishedApps, IEnumPublishedApps),                  // IID_IEnumPublishedApps
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IEnumPublishedApps::AddRef
ULONG CDarwinEnumPublishedApps::AddRef()
{
    _cRef++;
    TraceMsg(TF_OBJLIFE, "CDarwinEnumPublishedApps()::AddRef called, new _cRef=%lX", _cRef);
    return _cRef;
}

// IEnumPublishedApps::Release
ULONG CDarwinEnumPublishedApps::Release()
{
    _cRef--;
    TraceMsg(TF_OBJLIFE, "CDarwinEnumPublishedApps()::Release called, new _cRef=%lX", _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


// IEnumPublishedApps::Next
// PERF: we should do some optimization instead of enumerating these apps
// one by one.
// S_FALSE means end of enumeration
HRESULT CDarwinEnumPublishedApps::Next(IPublishedApp ** ppia)
{
    HRESULT hres = S_FALSE;
    *ppia = NULL;
    if (_prgApps && (_dwNumApps > 0) && (_dwIndex < _dwNumApps))
    {
        BOOL bContinue = FALSE;
        do {
            PMANAGEDAPPLICATION pma = &_prgApps[_dwIndex];

            // NOTE: no Hydra machines (_bTSSession == TRUE) we filter out all the
            // Darwin apps. 
            if (pma->pszPackageName && pma->pszPackageName[0])
            {
                CDarwinPublishedApp *pdpa = new CDarwinPublishedApp(pma);
                if (pdpa)
                {
                    *ppia = SAFECAST(pdpa, IPublishedApp *);
                    hres = S_OK;
                }
                else
                    hres = E_OUTOFMEMORY;
                bContinue = FALSE;
            }   
            else
            {
                ClearManagedApplication(pma);
                bContinue = TRUE;
            }
            
            _dwIndex++;
        } while (bContinue && (_dwIndex < _dwNumApps));
    }
    
    return hres;
}


// IEnumPublishedApps::Reset
HRESULT CDarwinEnumPublishedApps::Reset(void)
{
    if (_prgApps && (_dwNumApps > 0))
    {
        LocalFree(_prgApps);
    }

    GetManagedApplications(_bGuidUsed ? &_CategoryGUID : NULL, MANAGED_APPS_USERAPPLICATIONS,
                           _bGuidUsed ? MANAGED_APPS_FROMCATEGORY : MANAGED_APPS_INFOLEVEL_DEFAULT, &_dwNumApps, &_prgApps);

    _dwIndex = 0;
    return S_OK;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\darpub.cpp ===
#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include "darpub.h"
#include "darenum.h"
#include "sccls.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// CDarwinAppPublisher
// Very thin layer around the darwin CoGet* API's


// constructor
CDarwinAppPublisher::CDarwinAppPublisher() : _cRef(1)
{
    DllAddRef();

    TraceAddRef(CDarwinAppPub, _cRef);
}


// destructor
CDarwinAppPublisher::~CDarwinAppPublisher()
{
    DllRelease();
}


// IAppPublisher::QueryInterface
HRESULT CDarwinAppPublisher::QueryInterface(REFIID riid, LPVOID * ppvOut)
{ 
     static const QITAB qit[] = {
        QITABENT(CDarwinAppPublisher, IAppPublisher),                  // IID_IAppPublisher
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IAppPublisher::AddRef
ULONG CDarwinAppPublisher::AddRef()
{
    _cRef++;
    TraceAddRef(CDarwinAppPub, _cRef);
    return _cRef;
}

// IAppPublisher::Release
ULONG CDarwinAppPublisher::Release()
{
    _cRef--;
    TraceRelease(CDarwinAppPub, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

// IAppPublisher::GetNumberOfCategories
STDMETHODIMP CDarwinAppPublisher::GetNumberOfCategories(DWORD * pdwCat)
{
    return E_NOTIMPL;
}

// IAppPublisher::GetCategories
STDMETHODIMP CDarwinAppPublisher::GetCategories(APPCATEGORYINFOLIST * pAppCategoryList)
{
    HRESULT hres = E_FAIL;
    DWORD   dwStatus;
    RIP(pAppCategoryList);

    ZeroMemory(pAppCategoryList, SIZEOF(APPCATEGORYINFOLIST));
    APPCATEGORYINFOLIST acil = {0};
    dwStatus = GetManagedApplicationCategories(0, &acil);
    
    hres = HRESULT_FROM_WIN32( dwStatus );

    if (SUCCEEDED(hres) && (acil.cCategory > 0))
    {
        hres = _DuplicateCategoryList(&acil, pAppCategoryList);
        ReleaseAppCategoryInfoList(&acil);
    }
    
    return hres;
}

// IAppPublisher::GetNumberOfApps
STDMETHODIMP CDarwinAppPublisher::GetNumberOfApps(DWORD * pdwApps)
{
    return E_NOTIMPL;
}

// IAppPublisher::EnumApps
STDMETHODIMP CDarwinAppPublisher::EnumApps(GUID * pAppCategoryId, IEnumPublishedApps ** ppepa)
{
    HRESULT hres = E_FAIL;
    CDarwinEnumPublishedApps * pdepa = new CDarwinEnumPublishedApps(pAppCategoryId);
    if (pdepa)
    {
        *ppepa = SAFECAST(pdepa, IEnumPublishedApps *);
        hres = S_OK;
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
    
}

/*----------------------------------------------------------
Purpose: Create-instance function for class factory

*/
STDAPI CDarwinAppPublisher_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres = E_OUTOFMEMORY;
    CDarwinAppPublisher* pObj = new CDarwinAppPublisher();
    if (pObj)
    {
        *ppunk = SAFECAST(pObj, IAppPublisher *);
        hres = S_OK;
    }

    return hres;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\datasrc.cpp ===
//+-----------------------------------------------------------------------
//
//  Add/Remove Programs Data Source Object
//
//------------------------------------------------------------------------


#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include "datasrc.h"
#include "dump.h"
#include "util.h"

//---------------------------------------------------------------------------
//   
//---------------------------------------------------------------------------


// constructor
CDataSrc::CDataSrc()
{
    TraceMsg(TF_OBJLIFE, "(Mtx) creating");
    TraceAddRef(CDataSrc, _cRef);
    
    ASSERT(NULL == _parpevt);
    ASSERT(NULL == _pmtxarray);
    ASSERT(NULL == _psam);
    ASSERT(FALSE == _fAppsEnumed);
    ASSERT(FALSE == _fInEnumOp);
    
    _loadstate = LS_NOTSTARTED;
}


// destructor
CDataSrc::~CDataSrc()
{
    TraceMsg(TF_OBJLIFE, "(Mtx) destroying");

    ATOMICRELEASE(_pmtxarray);
    ATOMICRELEASE(_parpevt);
    ATOMICRELEASE(_psam);
}


/*--------------------------------------------------------------------
Purpose: IUnknown::QueryInterface
*/
STDMETHODIMP CDataSrc::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDataSrc, IARPSimpleProvider),
        QITABENT(CDataSrc, OLEDBSimpleProvider),
        QITABENT(CDataSrc, ISequentialStream),
        QITABENT(CDataSrc, IWorkerEvent),
        { 0 },
    };

    HRESULT hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);
    if (FAILED(hres))
        hres = CWorkerThread::QueryInterface(riid, ppvObj);

    return hres;
}


/*--------------------------------------------------------------------
Purpose: IARPWorker::KillWT
         Kills the worker thread that enumerates apps
*/
STDMETHODIMP CDataSrc::KillWT()
{
    // Primary thread wants to kill us, this means we are about to be released
    // also kill the mtxarray thread here, because that kill has to be on the main thread, too.
    // And we can't depend on CDataSrc descrutor to do it (because that final release could be called on the
    // back groud thread) 
    _KillMtxWorkerThread();

    return CWorkerThread::KillWT();
}

/*-------------------------------------------------------------------------
Purpose: IWorkerEvent::FireOnDataReady

         Called by worker thread when some data is ready.
*/
STDMETHODIMP 
CDataSrc::FireOnDataReady(
    DBROWCOUNT iRow
    )
{
    // OSP listener expects row to be 1-based
    _parpevt->RowChanged(iRow + 1);
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IWorkerEvent::FireOnFinished

         Called by worker thread when it is complete.
*/
STDMETHODIMP 
CDataSrc::FireOnFinished(void)
{
    _loadstate = LS_DONE;
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IWorkerEvent::FireOnDatasetChanged

         Called by worker thread when it is complete.
*/
STDMETHODIMP 
CDataSrc::FireOnDatasetChanged(void)
{
    if (_parpevt)
        _parpevt->DataSetChanged();
    return S_OK;
}

//  CDataSrc::_CalcRows
//      Calculate the number of rows in the OSP

DBROWCOUNT CDataSrc::_CalcRows(void)
{
    DBROWCOUNT lRet = 0;
    
    if (_pmtxarray)
        _pmtxarray->GetItemCount(&lRet);
        
    return lRet;    
}


//  CDataSrc::_CalcCols
//      Calculate the number of columns in the OSP

DB_LORDINAL CDataSrc::_CalcCols(void)
{
    DB_LORDINAL lRet = 0;
    
    if (_pmtxarray)
        _pmtxarray->GetFieldCount(&lRet);
        
    return lRet;
}


inline BOOL CDataSrc::_IsValidDataRow(DBROWCOUNT iRow)
{
    // Rows are 1-based.  The 0th row refers to label information.
    // -1 means wildcard.

    // The 0th row is NOT a valid data row.
    return (iRow > 0 && iRow <= _cRows);
}


inline BOOL CDataSrc::_IsValidRow(DBROWCOUNT iRow)
{
    // Rows are 1-based.  The 0th row refers to label information.
    // -1 means wildcard.
    return (iRow >= 0 && iRow <= _cRows);
}


inline BOOL CDataSrc::_IsValidCol(DB_LORDINAL iCol)
{
    // Columns are 1-based.  The 0th column refers to header information.
    // -1 means wildcard.
    return (iCol >= 1 && iCol <= _cCols);
}


inline BOOL CDataSrc::_IsValidCell(DBROWCOUNT iRow, DB_LORDINAL iCol)
{
    return _IsValidRow(iRow) && _IsValidCol(iCol);
}


/*-------------------------------------------------------------------------
Purpose: Returns the appdata object of the given row (1-based).  Returns
         NULL if there is none.
*/
IAppData * CDataSrc::_GetAppData(DBROWCOUNT iRow)
{
    IAppData * pappdata = NULL;

    if (_pmtxarray)
    {
        ASSERT(0 < iRow && iRow <= _cRows);
        _pmtxarray->GetAppData(iRow-1, &pappdata);
    }
    
    return pappdata;
}


// Structure used to transfer matrix object thru ISequentialStream()

typedef struct tagARPDSODATA
{
    LOAD_STATE  loadstate;
    DB_LORDINAL cCols;         // count of columns
    DBROWCOUNT  cRows;         // count of rows
    DWORD       dwEnum;        // items to enumerate (ENUM_*)
    IMtxArray * pmtxarray;     // data is stored here
    BSTR        bstrSort;      // sort string
} ARPDSODATA;




/*-------------------------------------------------------------------------
Purpose: ISequentialStream::Read

         Return the matrix object of this datasource object.
         IARPSimpleProvider::TransferData uses this method.
*/
STDMETHODIMP CDataSrc::Read(void * pvData, ULONG cbData, ULONG * pcbRead)
{
    HRESULT hres = E_INVALIDARG;
    
    ASSERT(IS_VALID_WRITE_BUFFER(pvData, BYTE, cbData));
    ASSERT(NULL == pcbRead || IS_VALID_WRITE_PTR(pcbRead, ULONG));
    
    if (pvData)
    {
        ARPDSODATA * pdsodata = (ARPDSODATA *)pvData;

        if (pcbRead)
            *pcbRead = 0;

        if (sizeof(*pdsodata) <= cbData)
        {
            pdsodata->loadstate = _loadstate;
            pdsodata->cCols = _cCols;
            pdsodata->cRows = _cRows;
            pdsodata->dwEnum = _dwEnum;

            pdsodata->pmtxarray = _pmtxarray;
            if (_pmtxarray)
                _pmtxarray->AddRef();
            
            pdsodata->bstrSort = _cbstrSort.Copy();

            if (pcbRead)
                *pcbRead = sizeof(*pdsodata);
        }
        hres = S_OK;
    }
    
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: ISequentialStream::Write

         Set the matrix object of this datasource object.
         IARPSimpleProvider::TransferData uses this method.
*/
STDMETHODIMP CDataSrc::Write(void const * pvData, ULONG cbData, ULONG * pcbWritten)
{
    HRESULT hres = E_INVALIDARG;
    
    ASSERT(IS_VALID_READ_BUFFER(pvData, BYTE, cbData));
    ASSERT(NULL == pcbWritten || IS_VALID_WRITE_PTR(pcbWritten, ULONG));
    
    if (pvData)
    {
        ARPDSODATA * pdsodata = (ARPDSODATA *)pvData;

        if (pcbWritten)
            *pcbWritten = 0;

        if (sizeof(*pdsodata) <= cbData)
        {
            _loadstate = pdsodata->loadstate;
            _cCols = pdsodata->cCols;
            _cRows = pdsodata->cRows;
            _dwEnum = pdsodata->dwEnum;

            // We won't addref this, since the supplier should have done that.
            _pmtxarray = pdsodata->pmtxarray;

            _cbstrSort.Empty();
            _cbstrSort.Attach(pdsodata->bstrSort);

            if (pcbWritten)
                *pcbWritten = sizeof(*pdsodata);
        }
        hres = S_OK;
    }
    
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: IARPSimpleProvider::Initialize

         Must be called before enumerating items.
         
*/
STDMETHODIMP CDataSrc::Initialize(IShellAppManager * psam, IARPEvent * parpevt, DWORD dwEnum)
{
    ASSERT(psam);
    ASSERT(IS_VALID_CODE_PTR(parpevt, CEventBroker));

    ATOMICRELEASE(_psam);
    ATOMICRELEASE(_parpevt);

    _psam = psam;
    _psam->AddRef();
    
    _parpevt = parpevt;
    _parpevt->AddRef();

    _dwEnum = dwEnum;
    
    return S_OK;
}


HRESULT CDataSrc::_EnumAppItems(DWORD dwEnum, LPCWSTR pszCategory)
{
    HRESULT hres = E_INVALIDARG;
    IInstalledApp* pAppIns;
    CAppData* pcad;

    ASSERT(NULL == pszCategory || IS_VALID_STRING_PTRW(pszCategory, -1));
    
    switch (dwEnum)
    {
    case ENUM_INSTALLED:
        IEnumInstalledApps* pEnumIns;

        // Now that we have the object, start enumerating the items
        hres = THR(_psam->EnumInstalledApps(&pEnumIns));
        if (SUCCEEDED(hres))
        {
            // Loop through all the apps on the machine, building our table
            while (S_OK == pEnumIns->Next(&pAppIns))
            {
                // If we've been asked to bail, do so
                if (IsKilled())
                {
                    pAppIns->Release();
                    break;
                }
                
                APPINFODATA ai = {0};
                
                // Get the 'fast' app info from the app manager object
                ai.cbSize = sizeof(ai);
                ai.dwMask = AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | AIM_REGISTEREDOWNER
                               | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | AIM_SUPPORTTELEPHONE | AIM_HELPLINK
                               | AIM_INSTALLLOCATION | AIM_INSTALLDATE | AIM_COMMENTS | AIM_IMAGE
                               | AIM_READMEURL | AIM_CONTACT | AIM_UPDATEINFOURL;
                if (SUCCEEDED(pAppIns->GetAppInfo(&ai)) &&
                    lstrlen(ai.pszDisplayName) > 0)
                {
                    SLOWAPPINFO sai = {0};
                    pAppIns->GetCachedSlowAppInfo(&sai);
                    
                    // Now save all this information away
                    pcad = new CAppData(pAppIns, &ai, &sai);
                    if (pcad)
                    {
                        _pmtxarray->AddItem(pcad, NULL);
                        pcad->Release();
                    }
                    else
                    {
                        // Something failed
                        pAppIns->Release();
                        ClearAppInfoData(&ai);
                    }
                }
                // NOTE: we do NOT release the pointer (pAppIns) here,
                // its lifetime is passed to the CAppData object
            }
            pEnumIns->Release();
            hres = S_OK;
        }
        break;

    case ENUM_PUBLISHED:
        IEnumPublishedApps * pepa;      // Salt 'n...

        // Convert an empty string to a null string if we need to
        if (pszCategory && 0 == *pszCategory)
            pszCategory = NULL;
            
        // Enumerate published apps
        hres = THR(_psam->EnumPublishedApps(pszCategory, &pepa));
        if (SUCCEEDED(hres))
        {
            IPublishedApp * ppa;

            while (S_OK == pepa->Next(&ppa))
            {
                // If we've been asked to bail, do so
                if (IsKilled())
                {
                    ppa->Release();
                    break;
                }
                
                APPINFODATA ai = {0};
                
                // Get the 'fast' app info from the app manager object
                ai.cbSize = sizeof(ai);
                ai.dwMask = AIM_DISPLAYNAME | AIM_VERSION | AIM_PUBLISHER | AIM_PRODUCTID | AIM_REGISTEREDOWNER
                               | AIM_REGISTEREDCOMPANY | AIM_SUPPORTURL | AIM_SUPPORTTELEPHONE | AIM_HELPLINK
                               | AIM_INSTALLLOCATION | AIM_INSTALLDATE | AIM_COMMENTS | AIM_IMAGE;
                if (SUCCEEDED(ppa->GetAppInfo(&ai)) &&
                    lstrlen(ai.pszDisplayName) > 0)
                {
                    PUBAPPINFO pai = {0};
                    pai.cbSize = sizeof(pai);
                    pai.dwMask = PAI_SOURCE | PAI_ASSIGNEDTIME | PAI_PUBLISHEDTIME | PAI_EXPIRETIME | PAI_SCHEDULEDTIME;
                    ppa->GetPublishedAppInfo(&pai);
                    
                    // Now save all this information away
                    pcad = new CAppData(ppa, &ai, &pai);
                    if (pcad)
                    {
                        _pmtxarray->AddItem(pcad, NULL);
                        pcad->Release();
                    }
                    else
                    {
                        // Something failed
                        ppa->Release();
                        ClearAppInfoData(&ai);
                        ClearPubAppInfo(&pai);
                    }
                }
                // NOTE: we do NOT release the pointer (ppa) here,
                // its lifetime is passed to the CAppData object
            }
            pepa->Release();
            hres = S_OK;
        } 
        
        break;

    case ENUM_OCSETUP:
        // Create an object that enums the OCSetup items
        COCSetupEnum * pocse;
        
        pocse = new COCSetupEnum;
        if ( pocse && pocse->EnumOCSetupItems() )
        {
            COCSetupApp * pocsa;

            while ( pocse->Next(&pocsa) )
            {
                // If we've been asked to bail, do so
                if (IsKilled())
                {
                    delete pocsa;
                    break;
                }
            
                // REVIEW: Is it worth it to use an APPINFODATA structure?  COcSetupApp
                // doesn't need this structure but I think it buys us sorting once inside
                // the CAppData array as well as a free implementation of the get_DisplayName
                // property which can be accessed via script.  The data sorting might be
                // important but it might also be worth it to special case that ability.
                APPINFODATA ai = {0};
                ai.cbSize = sizeof(ai);
                ai.dwMask = AIM_DISPLAYNAME;

                if ( pocsa->GetAppInfo(&ai) && (lstrlen(ai.pszDisplayName) > 0) )
                {
                    // Now save all this information away
                    pcad = new CAppData(pocsa, &ai);
                    if (pcad)
                    {
                        _pmtxarray->AddItem(pcad, NULL);
                        pcad->Release();
                    }
                    else
                    {
                        // Something failed
                        delete pocsa;
                        ClearAppInfoData(&ai);
                    }
                }
                // NOTE: we do NOT release the pointer (pocsa) here,
                // its lifetime is passed to the CAppData object
            }
        }
        hres = S_OK;
        break;

    case ENUM_CATEGORIES:
        SHELLAPPCATEGORYLIST sacl = {0};

        // Get the list of categories
        hres = _psam->GetPublishedAppCategories(&sacl);
        if (SUCCEEDED(hres))
        {
            SHELLAPPCATEGORY * psac = sacl.pCategory;

            // If we've been asked to bail, do so
            if (IsKilled())
            {
                ReleaseShellCategory(psac);
                break;
            }
            
            UINT i;

            for (i = 0; i < sacl.cCategories; i++, psac++)
            {
                // Now save all this information away
                pcad = new CAppData(psac);
                if (pcad)
                {
                    _pmtxarray->AddItem(pcad, NULL);
                    pcad->Release();
                }
                else
                {
                    // Something failed
                    ReleaseShellCategory(psac);
                }
            }

            // NOTE: we do NOT release the pointer (sacl) here,
            // its lifetime is passed to the CAppData object
        }
        break;
    }

    return hres;
}
    

/*-------------------------------------------------------------------------
Purpose: CDataSrc::_ThreadStartProc()
         The thread proc for the background thread that enumerates applications
*/
DWORD CDataSrc::_ThreadStartProc()
{
    TraceMsg(TF_TASKS, "[%x] Starting enumerator thread", _dwThreadId);

    // Enumerate the applications, this function does the real work
    _EnumAppItems(_dwEnum, _cbstrCategory);

    // Claim to the world that we are done
    _fAppsEnumed = TRUE;
    _fInEnumOp = FALSE;

    // Tell Trident that dataset has changed
    PostWorkerMessage(WORKERWIN_FIRE_DATASETCHANGED, 0, 0);

    // Call our base class and do clean up. 
    return CWorkerThread::_ThreadStartProc();
}


/*-------------------------------------------------------------------------
Purpose: IARPSimpleProvider::Recalculate

         Recalculate the number of rows and columns and apply the sorting criteria
         for installed apps, load it's slowappinfo. 
*/
STDMETHODIMP CDataSrc::Recalculate(void)
{
    HRESULT hres = E_PENDING;
    
    if (_fAppsEnumed)
    {
        // Calculate the columns used and cache that away.
        _cCols = _CalcCols();
        _cRows = _CalcRows();
        
        // Presort the items according to the existing sort criteria
        _ApplySortCriteria(FALSE);
        
        if (0 < _cRows)
            _parpevt->RowsAvailable(0, _cRows);
        _parpevt->LoadCompleted();

        // We only get slow info for the installed apps
        if (ENUM_INSTALLED == _dwEnum)
        {
            _loadstate = LS_LOADING_SLOWINFO;

            // Create and kick off the worker thread
            IWorkerEvent * pwrkevt;
            IARPWorker * pmtxworker;

            QueryInterface(IID_IWorkerEvent, (LPVOID *)&pwrkevt);
            ASSERT(pwrkevt);        // this should never fail

            hres = _pmtxarray->QueryInterface(IID_IARPWorker, (LPVOID *)&pmtxworker);
            if (SUCCEEDED(hres))
            {
                // Tell the worker thread to notify us
                pmtxworker->SetListenerWT(pwrkevt);
                hres = pmtxworker->StartWT(THREAD_PRIORITY_BELOW_NORMAL);

                pmtxworker->Release();
            }
            pwrkevt->Release();
        }
        else
            _loadstate = LS_DONE;

        hres = S_OK;
    }
    else
    {
        //
        // ISSUE-2000/09/01-BrianAu  Watch this message.
        // This used to be an assert.  Based on comments from the Trident devs
        // and from what I can glean from this code, the assert is unnecessary.
        // When the enumeration is complete we fire a 'dataMemberChanged' event which
        // results in Recalculate being called again.  Since the _fAppsEnumed
        // flag is set only after enumeration is complete, any prior calls to 
        // this function are harmless.  
        //
        TraceMsg(TF_ALWAYS, "This function should only be called when app enumeration is done");
    }
    
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: IARPSimpleProvider::EnumerateItemsAsync

         Enumerate the app items asynchronously.  This  call returns
         when all the items have been enumerated.  The caller should call
         Initialize first.
*/
STDMETHODIMP CDataSrc::EnumerateItemsAsync(void)
{
    HRESULT hres = S_OK;

    ASSERT(_parpevt);      // Caller should have called Initialize() first
    ASSERT(_psam);

    if (!_fInEnumOp)
    {
        _fInEnumOp = TRUE;
        // Make sure the slow info worker thread isn't already running. Stop it if it is.
        _KillMtxWorkerThread();

        // If we already have a list, nuke it
        ATOMICRELEASE(_pmtxarray);

        hres = THR(CMtxArray_CreateInstance(IID_IMtxArray, (LPVOID *)&_pmtxarray));
        if (SUCCEEDED(hres))
        {
            _pmtxarray->Initialize(_dwEnum);

            // Start enumerating items
            SetListenerWT(this);

            // Can't AddRef and worker thread
            hres = THR(StartWT(THREAD_PRIORITY_NORMAL));
        }
        else
            // Let people try again. 
            _fInEnumOp = FALSE;
    }
    else
    {
        // This function should only be called before any enumeration started
        ASSERTMSG(FALSE, "This function should only be called before any enumeration started");
        hres = E_PENDING;
    }
    
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: Sorts the data
*/
HRESULT CDataSrc::_ApplySortCriteria(BOOL bFireDataSetChanged)
{
    HRESULT hres = E_FAIL;

    if (_pmtxarray)
    {
        _pmtxarray->SetSortCriteria(_cbstrSort);
        
        hres = _pmtxarray->SortItems();
        if (SUCCEEDED(hres))
        {
            // Mark the duplicated name entries for published apps
            if ((ENUM_PUBLISHED == _dwEnum) && !StrCmpW(_cbstrSort, L"displayname"))
                _pmtxarray->MarkDupEntries();
        	
            // Tell the databinding agent that our dataset changed
            if (bFireDataSetChanged)
                _parpevt->DataSetChanged();
        }
    }

    return hres;
}


/*-------------------------------------------------------------------------
Purpose: IARPSimpleProvider::SetSortCriteria
         Set the sort criterion for the datasource.

         Returns S_OK if the sort criteria is different, S_FALSE if it is
         no different.

         bstrSortExpr       Name of column to sort by ("" = no sorting)
         
*/
STDMETHODIMP CDataSrc::SetSortCriteria(BSTR bstrSortExpr) 
{
    HRESULT hres = S_FALSE;

    // Is this a new sort criteria?
    if (NULL == (LPWSTR)_cbstrSort || 0 != StrCmpIW(bstrSortExpr, _cbstrSort))
    {
        // Yes
        _cbstrSort = bstrSortExpr;
        hres = S_OK;
        _fSortDirty = TRUE;
    }

    return hres;
}


/*-------------------------------------------------------------------------
Purpose: IARPSimpleProvider::SetFilter
         Set the filter criterion for the datasource.  Right now this only
         works for published apps, via a category.

         Returns S_OK if the filter criteria is different, S_FALSE if it is
         no different.

         bstrSortExpr       Name of column to sort by ("" = no sorting)
         
*/
STDMETHODIMP CDataSrc::SetFilter(BSTR bstrFilter) 
{
    HRESULT hres = S_FALSE;

    // Is this a new filter criteria?
    if (NULL == (LPWSTR)_cbstrCategory || 0 != StrCmpIW(bstrFilter, _cbstrCategory))
    {
        // Yes
        _cbstrCategory = bstrFilter;
        hres = S_OK;
    }

    return hres;
}


/*-------------------------------------------------------------------------
Purpose: IARPSimpleProvider::Sort

         Initiates a sort operation if any of the changes invalidates the 
         existing criteria.
*/
STDMETHODIMP CDataSrc::Sort(void) 
{
    HRESULT hres = S_OK;

    if (_fSortDirty)
    {
        // Is the datasource started?
        if (LS_NOTSTARTED != _loadstate)
        {
            // Yes; we can apply the sort now
            hres = _ApplySortCriteria(TRUE);
            if (SUCCEEDED(hres))
                _fSortDirty = FALSE;
        }
    }

    return hres;
}


/*-------------------------------------------------------------------------
Purpose: IARPSimpleProvider::TransferData

         Transfer the contents of given datasource object to this datasource.  
         This is useful for operations that change the dataset in-place, 
         like sorting.
*/
STDMETHODIMP CDataSrc::TransferData(IARPSimpleProvider * parposp)
{
    HRESULT hres;
    ISequentialStream * pstream;
    
    ASSERT(parposp);

    hres = parposp->QueryInterface(IID_ISequentialStream, (LPVOID *)&pstream);
    if (SUCCEEDED(hres))
    {
        IARPWorker * pmtxworker;
        ARPDSODATA dsodata;
        ULONG cb;

        // Transfer the state and data from that datasource to this
        // datasource.
        pstream->Read(&dsodata, sizeof(dsodata), &cb);
        Write(&dsodata, cb, NULL);

        if (_pmtxarray)
        {
            hres = _pmtxarray->QueryInterface(IID_IARPWorker, (LPVOID *)&pmtxworker);
            if (SUCCEEDED(hres))
            {
                // Tell the worker thread that this is the new datasource 
                // object to receive events
                IWorkerEvent * pwrkevt;
                
                QueryInterface(IID_IWorkerEvent, (LPVOID *)&pwrkevt);
                ASSERT(pwrkevt);        // this should never fail
                
                pmtxworker->SetListenerWT(pwrkevt);
                pmtxworker->Release();

                pwrkevt->Release();
            }

            _fAppsEnumed = TRUE;
        }        
        pstream->Release();
    }
    
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: IARPSimpleProvider::DoCommand

         Commit a specific action on the record.  Unlike standard
         ADO commands that affect a recordset, these commands
         are intended to be specific to managing the apps themselves
         (like installing or uninstalling).

         NOTE: this method is called indirectly via script.
*/
STDMETHODIMP CDataSrc::DoCommand(HWND hwndParent, APPCMD appcmd, DBROWCOUNT iRow)
{
    HRESULT hres = S_OK;
    
    IAppData * pappdata = _GetAppData(iRow);
    if (pappdata)
    {
        if (_IsValidDataRow(iRow))
        {
            hres = pappdata->DoCommand(hwndParent, appcmd);

            // Was the app succesfully uninstalled/changed/whatever?
            if (S_OK == hres)
            {
                // Yes
                DBROWCOUNT lDeleted;
                
                switch (appcmd)
                {
                case APPCMD_UNINSTALL:
                    // Fire the event to the databinding agent
                    deleteRows(iRow, 1, &lDeleted); 
                    break;

                case APPCMD_UPGRADE:
                case APPCMD_REPAIR:
                case APPCMD_MODIFY:
                case APPCMD_INSTALL:
                    // Fire the event
                    _parpevt->RowChanged(iRow);
                    break;
                }
            }
        }
        pappdata->Release();
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::getRowCount

         Return the number of rows in the table.
*/
STDMETHODIMP CDataSrc::getRowCount(DBROWCOUNT *pcRows)
{
    ASSERT(IS_VALID_WRITE_PTR(pcRows, DBROWCOUNT));

    *pcRows = _cRows;
        
    TraceMsg(TF_DSO, "(Mtx) getRowCount returning %d", _cRows);
    
    return S_OK;
}


/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::getColumnCount

         Return the number of columns in the table.
*/
STDMETHODIMP CDataSrc::getColumnCount(DB_LORDINAL *pcCols)
{
    ASSERT(IS_VALID_WRITE_PTR(pcCols, DB_LORDINAL));

    *pcCols = _cCols;

    TraceMsg(TF_DSO, "(Mtx) getColumnCount returning %d", _cCols);

    return S_OK;
}


/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::getRWStatus

         Gets the read/write status of a cell, row, column or the 
         entire array.  

         This implementation cannot set the read/write status on any
         cell, so all data cells are presumed to have the default
         access and all column heading cells are presumed to be 
         read-only.  Therefore, we don't keep track of this info
         in the individual cells.

         E_INVALIDARG - returned if indices are out of bounds
*/
STDMETHODIMP CDataSrc::getRWStatus(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPRW *prwStatus)
{
    HRESULT hres = E_INVALIDARG;

    if ((_IsValidRow(iRow) || -1 == iRow) && 
        (_IsValidCol(iCol) || -1 == iCol))
    {
        if (iRow == -1)
        {
            *prwStatus = OSPRW_MIXED;
        }
        else if (iRow == 0)
            *prwStatus = OSPRW_READONLY;
        else
            *prwStatus = OSPRW_DEFAULT;
        hres = S_OK;
    }

    if (FAILED(hres))
        TraceMsg(TF_WARNING, "(Mtx) getRWStatus(%d, %d) failed %s", iRow, iCol, Dbg_GetHRESULT(hres));
    else        
        TraceMsg(TF_DSO, "(Mtx) getRWStatus(%d, %d) returning %s", iRow, iCol, Dbg_GetOSPRW(*prwStatus));
    
    return hres;
}


/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::getVariant

         Retrieves a variant value for a cell.
*/
STDMETHODIMP CDataSrc::getVariant(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT format, VARIANT * pvar)
{
    HRESULT hres  = E_INVALIDARG;

    TraceMsg(TF_DSO, "(Mtx) getVariant(%d, %d)", iRow, iCol);
    
    ASSERT(IS_VALID_WRITE_PTR(pvar, VARIANT));
    
    if (_IsValidCell(iRow, iCol))
    {
        VARIANT var;

        // Massage col to be 0-based
        iCol--;
        
        // Are they asking for the field name?
        if (0 == iRow)
        {
            // Yes; get the field name
            if (_pmtxarray)
                hres = _pmtxarray->GetFieldName(iCol, &var);
            else
                hres = E_FAIL;
        }
        else
        {
            // No; get the field value
            IAppData * pappdata = _GetAppData(iRow);
            if (pappdata)
            {
                hres = pappdata->GetVariant(iCol, &var);
                pappdata->Release();
            }
            else
                hres = E_FAIL;
        }
            
        if (SUCCEEDED(hres))
        {
            if (OSPFORMAT_RAW == format)
            {
                // Copy the raw variant value
                *pvar = var;
            }
            else if (OSPFORMAT_FORMATTED == format || OSPFORMAT_HTML == format)
            {
                // Consumer wants it in text format
                if (VT_BSTR == var.vt || VT_EMPTY == var.vt)
                {
                    // Already done
                    *pvar = var;
                }
                else if (VT_UI4 == var.vt)
                {
                    // Coerce
                    VarBstrFromUI4( var.lVal, 0, 0, &(pvar->bstrVal));
                    if (pvar->bstrVal != NULL)
                    {
                        pvar->vt = VT_BSTR;
                    }
                    else
                        hres = E_OUTOFMEMORY;
                }
                else
                    hres = E_NOTIMPL;
            }
            else
                hres = E_INVALIDARG;

            if (FAILED(hres))
            {
                VariantClear(&var);
                pvar->vt = VT_BSTR;
                pvar->bstrVal = SysAllocString(L"#Error");
            }
        }
    }

    if (FAILED(hres))
        TraceMsg(TF_WARNING, "(Mtx) getVariant failed %s", Dbg_GetHRESULT(hres));
    
    return hres;
}



/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::setVariant

         Set a cell's variant value from a given variant.  The given variant
         type is coerced into the columns underlying type.
*/
STDMETHODIMP CDataSrc::setVariant(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT format, VARIANT var)
{
    HRESULT hres = E_INVALIDARG;

    TraceMsg(TF_DSO, "(Mtx) setVariant(%d, %d)", iRow, iCol);

#ifdef NYI
    if (_IsValidCol(iCol))
    {
        // Massage col to be 0-based
        iCol--;
        
        // Is the data agent trying to change an existing cell?
        if (_IsValidDataRow(iRow))
        {
            // Yes
            IAppData * pappdata = _GetAppData(iRow);
            if (pappdata)
            {
                hres = pappdata->SetVariant(iCol, &var);
                pappdata->Release();
            }
            else
                hres = E_FAIL;
        }
        else
        {
            // No; it wants to add a new row
        }
    }
#else
    hres = E_NOTIMPL;
#endif

    if (FAILED(hres))
        TraceMsg(TF_WARNING, "(Mtx) setVariant failed %s", Dbg_GetHRESULT(hres));
    
    return hres;
}


/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::getLocale

         Returns to the consumer the locale of the data we
         are providing.  App management data is in the locale
         of the system, so return an empty bstr.
         
*/
STDMETHODIMP CDataSrc::getLocale(BSTR *pbstrLocale)
{
    TraceMsg(TF_DSO, "(Mtx) getLocale");
    
    *pbstrLocale = SysAllocString(L"");
    return *pbstrLocale ? S_OK : E_OUTOFMEMORY;
}


/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::deleteRows

         Used to delete rows from the array.  Bounds are checked
         to make sure that the rows can all be deleted.  Label
         rows cannot be deleted.

         E_INVALIDARG - returned if any rows to be deleted are 
                        out of bounds
*/
STDMETHODIMP CDataSrc::deleteRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted)
{
    HRESULT hres = E_INVALIDARG;

    TraceMsg(TF_DSO, "(Mtx) deleteRows(%d, %d)", iRow, cRows);
    
    *pcRowsDeleted = 0;

    if (_IsValidDataRow(iRow) && cRows >= 0 &&
        _IsValidDataRow(iRow + cRows - 1))
    {
        _parpevt->AboutToDeleteRows(iRow, cRows);

        *pcRowsDeleted = cRows;
        if (cRows > 0)
        {
            //  Delete the rows from the array
            
            _pmtxarray->DeleteItems(iRow - 1, cRows);
            _cRows = _CalcRows();

            //  Notify the event-handler of the deletion
            _parpevt->DeletedRows(iRow, cRows);
        }
        hres = S_OK;
    }

    if (FAILED(hres))
        TraceMsg(TF_WARNING, "(Mtx) deleteRows failed %s", Dbg_GetHRESULT(hres));
    
    return hres;
}


//+-----------------------------------------------------------------------
//
//  Member:    InsertRows()
//
//  Synopsis:  Allows for the insertion of new rows.  This can either be
//             used to insert new rows between existing rows, or to
//             append new rows to the end of the table.  Thus, to
//             insert new rows at the end of the table, a user would
//             specify the initial row as 1 greater than the current
//             row dimension.
//             Note that iRow is checked to ensure that it is within the
//             proper bounds (1..<current # of rows>+1).
//             User cannot delete column heading row.
//
//  Arguments: iRow            rows will be inserted *before* row 'iRow'
//             cRows           how many rows to insert
//             pcRowsInserted  actual number of rows inserted (OUT)
//
//  Returns:   S_OK upon success, i.e. all rows could be inserted.
//             E_INVALIDARG if row is out of allowed bounds.
//             It is possible that fewer than the requested rows were
//             inserted.  In this case, E_OUTOFMEMORY would be returned,
//             and the actual number of rows inserted would be set.
//
//------------------------------------------------------------------------

/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::insertRows

*/
STDMETHODIMP CDataSrc::insertRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted)
{
    HRESULT hres  = E_NOTIMPL;

    TraceMsg(TF_DSO, "(Mtx) insertRows(%d, %d)", iRow, cRows);
    
    if (FAILED(hres))
        TraceMsg(TF_WARNING, "(Mtx) insertRows failed %s", Dbg_GetHRESULT(hres));
    
    return hres;
}


//+-----------------------------------------------------------------------
//
//  Member:    Find()
//
//  Synopsis:  Searches for a row matching the specified criteria
//
//  Arguments: iRowStart       The starting row for the search
//             iCol            The column being tested
//             vTest           The value against which cells in the
//                               test column are tested
//             findFlags       Flags indicating whether to search up/down
//                               and whether comparisons are case sensitive.
//             compType        The comparison operator for matching (find a
//                             cell =, >=, <=, >, <, <> the test value)
//             piRowFound      The row with a matching cell [OUT]
//
//  Returns:   S_OK upon success, i.e. a row was found (piRowFound set).
//             E_FAIL upon failure, i.e. a row was not found.
//             E_INVALIDARG if starting row 'iRowStart' or test column 'iCol'
//               are out of bounds.
//             DISP_E_TYPEMISMATCH if the test value's type does not match
//               the test column's type.
//
//------------------------------------------------------------------------

/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::find

*/
STDMETHODIMP CDataSrc::find(DBROWCOUNT iRowStart, DB_LORDINAL iCol, VARIANT vTest,
        OSPFIND findFlags, OSPCOMP compType, DBROWCOUNT *piRowFound)
{
    HRESULT hres  = E_NOTIMPL;

    TraceMsg(TF_DSO, "(Mtx) find(%d, %d)", iRowStart, iCol);
    
    if (FAILED(hres))
        TraceMsg(TF_WARNING, "(Mtx) find failed %s", Dbg_GetHRESULT(hres));
    
    return hres;
}


/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::addOLEDBSimpleProviderListener

         Sets or clears a reference to the OSP listener.
*/
STDMETHODIMP CDataSrc::addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospl)
{
    HRESULT hres;

    TraceMsg(TF_DSO, "(Mtx) addOLEDBSimpleProviderListener  <%s>", Dbg_GetLS(_loadstate));
    
    if (_parpevt == NULL)
        hres = E_FAIL;
    else
    {
        _parpevt->SetOSPListener(pospl);
        
        // If the event sink has been added, and we're already loaded,
        // then fire transferComplete, because we probably couldn't before.
        if (LS_NOTSTARTED < _loadstate)
            _parpevt->LoadCompleted();

        hres = S_OK;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::removeOLEDBSimpleProviderListener

*/
STDMETHODIMP CDataSrc::removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener * pospl)
{
    if (_parpevt && S_OK == _parpevt->IsOSPListener(pospl))
    {
        TraceMsg(TF_DSO, "(Mtx) removeOLEDBSimpleProviderListener");
        
        _parpevt->SetOSPListener(NULL);
    }
    return S_OK;
}


/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::getEstimatedRows

         Returns an estimated number of rows in the matrix.
         Return -1 if unknown.
*/
STDMETHODIMP CDataSrc::getEstimatedRows(DBROWCOUNT *pcRows)
{
    if (LS_NOTSTARTED == _loadstate)
        *pcRows = -1;
    else
        *pcRows = _cRows;

    TraceMsg(TF_DSO, "(Mtx) getEstimatedRows returning %d  <%s>", *pcRows, Dbg_GetLS(_loadstate));
    
    return S_OK;
}


/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::isAsync

*/
STDMETHODIMP CDataSrc::isAsync(BOOL *pbAsync)
{
    // This OSP always behaves as if it is async.  Specifically, we always fire
    // TransferComplete, even if we have to buffer the notification until our
    // addOLEDBSimplerProviderListener is actually called.
    *pbAsync = TRUE;
    return S_OK;
}


/*----------------------------------------------------------
Purpose: OLEDBSimpleProvider::stopTransfer

         The data download has been cancelled.
*/
STDMETHODIMP CDataSrc::stopTransfer()
{
    TraceMsg(TF_DSO, "(Mtx) stopTransfer  <%s>", Dbg_GetLS(_loadstate));
    
    //  Force the load state into UNINITIALISED or LOADED ...
    //
    switch (_loadstate)
    {
    case LS_NOTSTARTED:
    case LS_DONE:
        // No need to do anything, because we either haven't started
        // or are already finished.
        break;

    case LS_LOADING_SLOWINFO:
        // Stop the worker thread.
        _KillMtxWorkerThread();

        // Say we're done
        _loadstate = LS_DONE;
        
        TraceMsg(TF_DSO, "(Mtx) Setting state to <%s>", Dbg_GetLS(_loadstate));
        
        // Fire an abort event
        _parpevt->LoadAborted();
        break;
    }

    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: Helper method to kill the worker thread
*/
HRESULT CDataSrc::_KillMtxWorkerThread(void)
{
    HRESULT hres = S_OK;

    if (_pmtxarray)
    {
        IARPWorker * pmtxworker;
        
        hres = _pmtxarray->QueryInterface(IID_IARPWorker, (LPVOID *)&pmtxworker);
        if (SUCCEEDED(hres))
        {
            hres = pmtxworker->KillWT();
            pmtxworker->Release();
        }
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Create-instance function for CDataSrc

*/
HRESULT CDataSrc_CreateInstance(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = E_OUTOFMEMORY;

    *ppvObj = NULL;
    
    CDataSrc * pObj = new CDataSrc();
    if (pObj)
    {
        hres = pObj->QueryInterface(riid, ppvObj);
        pObj->Release();
    }

    return hres;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\datasrc.h ===
//+-----------------------------------------------------------------------
//
//  Add/Remove Programs Data Source Object
//
//------------------------------------------------------------------------

#ifndef _DATASRC_H_
#define _DATASRC_H_

#include <simpdata.h>       // for OLEDBSimpleProvider
#include "mtxarray.h"       // for CMtxArray
#include "worker.h"
#include "iface.h"          // for IARPSimpleProvider


// The load state progression can be as follows:
//
//  LS_NOTSTARTED  -->  LS_LOADING_SLOWINFO -->  LS_DONE
//
// or
//
//  LS_NOTSTARTED  -->  LS_DONE
//  
enum LOAD_STATE
{
    LS_NOTSTARTED,                  // OSP is not initialized
    LS_LOADING_SLOWINFO,            // loading slow info (worker thread)
    LS_DONE,                        // completely finished
};


// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM
//------------------------------------------------------------------------
//
//  CDataSrc (ARP Data Source Object)
//
//  This is the OSP (OLEDB Simple Provider).  It organizes
//  the data in matrix form and disseminates the data to the data
//  consumer via the OLEDBSimpleProvider interface.
//
//------------------------------------------------------------------------

class CDataSrc : public CWorkerThread,
                public OLEDBSimpleProvider,
                public IWorkerEvent,
                public IARPSimpleProvider,
                public ISequentialStream
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef   (void) {return CWorkerThread::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release  (void) {return CWorkerThread::Release();};
    virtual STDMETHODIMP QueryInterface   (REFIID riid, LPVOID * ppvObj);

    // *** ISequentialStream ***
    STDMETHOD(Read)             (void * pvData, ULONG cbData, ULONG * pcbRead);
    STDMETHOD(Write)            (void const * pvData, ULONG cbData, ULONG * pcbWritten);
    
    // *** OLEDBSimpleProvider ***
    STDMETHOD(getRowCount)      (DBROWCOUNT *pcRows);
    STDMETHOD(getColumnCount)   (DB_LORDINAL *pcCols);
    STDMETHOD(getRWStatus)      (DBROWCOUNT iRow, DB_LORDINAL iCol, OSPRW *prwStatus);
    STDMETHOD(getVariant)       (DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT format, VARIANT *pVar);
    STDMETHOD(setVariant)       (DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT format, VARIANT Var);
    STDMETHOD(getLocale)        (BSTR *pbstrLocale);
    STDMETHOD(deleteRows)       (DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted);
    STDMETHOD(insertRows)       (DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted);
    STDMETHOD(find)             (DBROWCOUNT iRowStart, DB_LORDINAL iCol, VARIANT val,
                                 OSPFIND findFlags, OSPCOMP compType, DBROWCOUNT *piRowFound);
    STDMETHOD(addOLEDBSimpleProviderListener)(OLEDBSimpleProviderListener *pospIListener);
    STDMETHOD(removeOLEDBSimpleProviderListener)(OLEDBSimpleProviderListener *pospIListener);
    STDMETHOD(getEstimatedRows) (DBROWCOUNT *pcRows);
    STDMETHOD(isAsync)          (BOOL *pbAsync);
    STDMETHOD(stopTransfer)     (void);

    // *** IWorkerEvent methods ***
    STDMETHOD(FireOnDataReady)  (DBROWCOUNT iRow);
    STDMETHOD(FireOnFinished)   (void);
    STDMETHOD(FireOnDatasetChanged)   (void);
    
    // *** IARPSimpleProvider methods ***
    STDMETHOD(Initialize)       (IShellAppManager * psam, IARPEvent *, DWORD dwEnum);
    STDMETHOD(EnumerateItemsAsync)   (void);
    STDMETHOD(Recalculate)      (void);
    STDMETHOD(SetSortCriteria)  (BSTR bstrSortExpr);
    STDMETHOD(SetFilter)        (BSTR bstrFilter);
    STDMETHOD(Sort)             (void);
    STDMETHOD(DoCommand)        (HWND hwndParent, APPCMD appcmd, DBROWCOUNT iRow);
    STDMETHOD(TransferData)     (IARPSimpleProvider * parposp);
    CDataSrc();

    // *** IARPWorker *** (overide)
    STDMETHOD(KillWT)           (void);
    
private:

    virtual ~CDataSrc();

    inline BOOL _IsValidDataRow(DBROWCOUNT iRow);
    inline BOOL _IsValidRow(DBROWCOUNT iRow);
    inline BOOL _IsValidCol(DB_LORDINAL iCol);
    inline BOOL _IsValidCell(DBROWCOUNT iRow, DB_LORDINAL iCol);

    DBROWCOUNT _CalcRows(void);
    DB_LORDINAL _CalcCols(void);
    HRESULT _ApplySortCriteria(BOOL bFireDataSetChanged);
    IAppData * _GetAppData(DBROWCOUNT iRow);

    // NOTE: this is not used to kill the apps enumeration thread!!
    // kills only the thread that get slow appinfo. 
    HRESULT _KillMtxWorkerThread(void);
    HRESULT _EnumAppItems(DWORD dwEnum, LPCWSTR pszCategory);
    DWORD   _ThreadStartProc();
            
    ULONG        _cRef;          // interface reference count
    LOAD_STATE  _loadstate;
    DB_LORDINAL _cCols;         // count of columns
    DBROWCOUNT  _cRows;         // count of rows

    DWORD       _dwEnum;        // items to enumerate (ENUM_*)
    BITBOOL     _fSortDirty: 1; // TRUE: the sort criteria is dirty
    BITBOOL     _fFilterDirty: 1; // TRUE: the sort criteria is dirty
    BITBOOL     _fAppsEnumed : 1; // TRUE if we have already finished enumerating apps
    BITBOOL     _fInEnumOp : 1;   // TRUE if we are in a enumeraion opertion
    IShellAppManager * _psam;
    IARPEvent * _parpevt;
    IMtxArray * _pmtxarray;     // data is stored here
    CComBSTR    _cbstrSort;     // sort string.  contains name of column to sort.
    CComBSTR    _cbstrCategory; // category.  used only for published apps.
};


HRESULT CDataSrc_CreateInstance(REFIID riid, LPVOID * ppvObj);

#endif //DOWNLEVEL_PLATFORM

#endif // _DATASRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\dump.c ===
#include "priv.h"
#include "shdguid.h"
#include "shguidp.h"

// REARCHITECT (scotth): someday convert dump.c to dump.cpp

#include "..\..\inc\dump.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__3964D99C_AC96_11D1_9851_00C04FD91972__INCLUDED_)
#define AFX_DLLDATAX_H__3964D99C_AC96_11D1_9851_00C04FD91972__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__3964D99C_AC96_11D1_9851_00C04FD91972__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400 //for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "shappmgrp_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\debug.cpp ===
#include "priv.h"

// These have to come before dump.h otherwise dump.h won't declare
// some of the prototypes.  Failure to do this will cause the compiler
// to decorate some of these functions with C++ mangling.

#include "datasrc.h"        // for LOAD_STATE
#include "simpdata.h"       // for OSPRW


#include "dump.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "appwiz.ini"
#define SZ_DEBUGSECTION     "appwiz"
#define SZ_MODULE           "APPWIZ"
#define DECLARE_DEBUG
#include <debug.h>


#ifdef DEBUG

LPCTSTR Dbg_GetReadyState(LONG state)
{
    LPCTSTR pcsz = TEXT("<Unknown READYSTATE>");
    
    switch (state)
    {
    STRING_CASE(READYSTATE_UNINITIALIZED);
    STRING_CASE(READYSTATE_LOADING);
    STRING_CASE(READYSTATE_LOADED);
    STRING_CASE(READYSTATE_INTERACTIVE);
    STRING_CASE(READYSTATE_COMPLETE);
    }

    ASSERT(pcsz);

    return pcsz;
}


// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM
LPCTSTR Dbg_GetGuid(REFGUID rguid, LPTSTR pszBuf, int cch)
{
    SHStringFromGUID(rguid, pszBuf, cch);
    return pszBuf;
}
#endif //DOWNLEVEL_PLATFORM

LPCTSTR Dbg_GetBool(BOOL bVal)
{
    return bVal ? TEXT("TRUE") : TEXT("FALSE");
}


LPCTSTR Dbg_GetOSPRW(OSPRW state)
{
    LPCTSTR pcsz = TEXT("<Unknown OSPRW>");
    
    switch (state)
    {
    STRING_CASE(OSPRW_MIXED);
    STRING_CASE(OSPRW_READONLY);
    STRING_CASE(OSPRW_READWRITE);
    }

    ASSERT(pcsz);

    return pcsz;
}


LPCTSTR Dbg_GetLS(LOAD_STATE state)
{
    LPCTSTR pcsz = TEXT("<Unknown LOAD_STATE>");
    
    switch (state)
    {
    STRING_CASE(LS_NOTSTARTED);
    STRING_CASE(LS_LOADING_SLOWINFO);
    STRING_CASE(LS_DONE);
    }

    ASSERT(pcsz);

    return pcsz;
}


LPCTSTR Dbg_GetAppCmd(APPCMD appcmd)
{
    LPCTSTR pcsz = TEXT("<Unknown APPCMD>");
    
    switch (appcmd)
    {
    STRING_CASE(APPCMD_UNKNOWN);
    STRING_CASE(APPCMD_INSTALL);
    STRING_CASE(APPCMD_UNINSTALL);
    STRING_CASE(APPCMD_REPAIR);
    STRING_CASE(APPCMD_UPGRADE);
    STRING_CASE(APPCMD_MODIFY);
    STRING_CASE(APPCMD_GENERICINSTALL);
    }

    ASSERT(pcsz);

    return pcsz;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\dlinst.h ===
//
// Downlevel (NT4, win9X) Install/Unistall page
//

STDAPI DL_FillAppListBox(HWND hwndListBox, DWORD* pdwApps);
STDAPI_(BOOL) DL_ConfigureButtonsAndStatic(HWND hwndPage, HWND hwndListBox, int iSel);
STDAPI_(BOOL) DL_InvokeAction(int iButtonID, HWND hwndPage, HWND hwndListBox, int iSel);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\dlinst.cpp ===
//
// Downlevel (NT4, win9X) Install/Unistall page
//

#include "priv.h"
#include "appwizid.h"
#include "dlinst.h"
#include "sccls.h"

//
// DonwLevelManager: Ugly singleton class
//
// Mainly there to keep state info and for its destructor
//

class CDLManager* g_pDLManager = NULL;

class CDLManager
{
public:
    // Rely on the fact that shell "new" zero out memory
    CDLManager() : _hrInit(E_FAIL)
    {
        _hrInit = CoInitialize(0);
        _szStatic[0] = 0;
        _szStatic2[0] = 0;
        _uiStatic = 0;
    }
    ~CDLManager()
    {
        if (_peia)
            _peia->Release();

        if (SUCCEEDED(_hrInit))
            CoUninitialize();
    }
public:
    void InitButtonsHandle(HWND hwndPage)
    {
        // No check for success: check before using

        if (!_hwndModifyUninstall)
        {
            _hwndModifyUninstall = GetDlgItem(hwndPage, IDC_MODIFYUNINSTALL);
            _rghwndButtons[IDC_MODIFY-IDC_BASEBUTTONS]    = GetDlgItem(hwndPage, IDC_MODIFY);
            _rghwndButtons[IDC_REPAIR-IDC_BASEBUTTONS]    = GetDlgItem(hwndPage, IDC_REPAIR);
            _rghwndButtons[IDC_UNINSTALL-IDC_BASEBUTTONS] = GetDlgItem(hwndPage, IDC_UNINSTALL);
        }
    }
    void SetVisibleButtons(BOOL bShow3Buttons)
    {
        // bShow3Buttons == TRUE will show the three buttons

        if (_hwndModifyUninstall)
            ShowWindow(_hwndModifyUninstall, bShow3Buttons?SW_HIDE:SW_SHOW);

        for (int i=0;i<3;++i)
        {
            if (_rghwndButtons[i])
                ShowWindow(_rghwndButtons[i], bShow3Buttons?SW_SHOW:SW_HIDE);
        }
    }
public:
    IEnumInstalledApps* _peia;

    HWND _hwndModifyUninstall;
    HWND _rghwndButtons[3];

    HRESULT _hrInit;

    TCHAR _szStatic[250];
    TCHAR _szStatic2[50];

    UINT _uiStatic;
};

//
// pcApps has to be already initialized, we only increment it
//
STDAPI DL_FillAppListBox(HWND hwndListBox, DWORD* pdwApps)
{
    ASSERT(IsWindow(hwndListBox));

    static CDLManager DLManager;

    g_pDLManager = &DLManager;

    ASSERT(g_pDLManager);

    HRESULT hres = E_FAIL;

    IShellAppManager * pam;

    if (SUCCEEDED(g_pDLManager->_hrInit))
    {
        hres = CoCreateInstance(CLSID_ShellAppManager, NULL, CLSCTX_INPROC_SERVER,
            IID_IShellAppManager, (LPVOID *)&pam);

        if (SUCCEEDED(hres))
        {
            // Initialize InstalledApp Enum if required

            if (!g_pDLManager->_peia)
                hres = pam->EnumInstalledApps(&g_pDLManager->_peia);

            if (SUCCEEDED(hres))
            {
                IInstalledApp* pia;

                while ((hres = g_pDLManager->_peia->Next(&pia)) == S_OK)
                {
                    APPINFODATA ais = {0};
                    ais.cbSize = sizeof(ais);
                    ais.dwMask = AIM_DISPLAYNAME;

                    pia->GetAppInfo(&ais);
            
                    if (ais.dwMask & AIM_DISPLAYNAME)
                    {
                        int iIndex = LB_ERR;
#ifdef UNICODE
                        iIndex = ListBox_AddString(hwndListBox, ais.pszDisplayName);
#else
                        PCHAR pszTmp = NULL;

                        // Get the size

                        int cbSize = WideCharToMultiByte(CP_ACP, 0, ais.pszDisplayName, -1, pszTmp, 0,
                            NULL, NULL);

                        if (cbSize)
                        {
                            pszTmp = (LPTSTR)LocalAlloc(LPTR, cbSize);

                            if (pszTmp)
                            {
                                cbSize = WideCharToMultiByte(CP_ACP, 0, ais.pszDisplayName, -1, pszTmp, cbSize,
                                    NULL, NULL);

                                if (cbSize)
                                    iIndex = ListBox_AddString(hwndListBox, pszTmp);

                                LocalFree(pszTmp);
                            }
                        }
#endif

                        // Did the operation succeed?
                        if (LB_ERR != iIndex)
                        {
                            // Is memory OK?
                            if (LB_ERRSPACE != iIndex)
                            {
                                // Yes
                                ListBox_SetItemData(hwndListBox, iIndex, pia);

                                ++(*pdwApps);
                            }
                            else
                            {
                                // No, better get out
                                pia->Release();
                                break;                         
                            }
                        }
                    }
                    else
                        pia->Release();

                }
            }
            pam->Release();
        }
    }

    return hres;
}

STDAPI_(BOOL) DL_ConfigureButtonsAndStatic(HWND hwndPage, HWND hwndListBox, int iSel)
{
    ASSERT(IsWindow(hwndPage));
    ASSERT(IsWindow(hwndListBox));
    ASSERT(0 <= iSel);

    UINT uiStatic = IDS_UNINSTINSTR_LEGACY;

    BOOL fret = FALSE;

    if (LB_ERR != iSel)
    {
        LRESULT lres = ListBox_GetItemData(hwndListBox, iSel);

        if (LB_ERR != lres)
        {
            fret = TRUE;

            IInstalledApp* pia = (IInstalledApp*)lres;

            DWORD dwActions = 0;

            pia->GetPossibleActions(&dwActions);

            dwActions &= (APPACTION_MODIFY|APPACTION_REPAIR|APPACTION_UNINSTALL|APPACTION_MODIFYREMOVE);

            g_pDLManager->InitButtonsHandle(hwndPage);

            if (dwActions & APPACTION_MODIFYREMOVE)
            {
                // Manage to show the right buttons

                g_pDLManager->SetVisibleButtons(FALSE);

                EnableWindow(g_pDLManager->_hwndModifyUninstall, TRUE);
            }
            else
            {
                if (dwActions & (APPACTION_MODIFY|APPACTION_REPAIR|APPACTION_UNINSTALL))
                {
                    // Manage to show the right buttons

                    g_pDLManager->SetVisibleButtons(TRUE);

                    // Enable the applicable buttons

                    EnableWindow(g_pDLManager->_rghwndButtons[IDC_MODIFY-IDC_BASEBUTTONS],
                        (dwActions&APPACTION_MODIFY)?TRUE:FALSE);

                    EnableWindow(g_pDLManager->_rghwndButtons[IDC_REPAIR-IDC_BASEBUTTONS],
                        (dwActions&APPACTION_REPAIR)?TRUE:FALSE);

                    EnableWindow(g_pDLManager->_rghwndButtons[IDC_UNINSTALL-IDC_BASEBUTTONS],
                        (dwActions&APPACTION_UNINSTALL)?TRUE:FALSE);

                    uiStatic = IDS_UNINSTINSTR_NEW;
                }
                else
                {
                    // Manage to show the right buttons

                    g_pDLManager->SetVisibleButtons(FALSE);

                    EnableWindow(g_pDLManager->_hwndModifyUninstall, FALSE);
                }
            }
        }
    }

    if (!(*g_pDLManager->_szStatic))
    {
        if(!LoadString(g_hinst, IDS_UNINSTINSTR, g_pDLManager->_szStatic, ARRAYSIZE(g_pDLManager->_szStatic)))
            *(g_pDLManager->_szStatic) = 0;
    }   
    
    if (*g_pDLManager->_szStatic && (g_pDLManager->_uiStatic != uiStatic))
    {
        TCHAR szMergedStatic[250];

        LoadString(g_hinst, uiStatic, g_pDLManager->_szStatic2, ARRAYSIZE(g_pDLManager->_szStatic2));

        wsprintf(szMergedStatic, g_pDLManager->_szStatic, g_pDLManager->_szStatic2);

        SetDlgItemText(hwndPage, IDC_UNINSTINSTR, szMergedStatic);

        g_pDLManager->_uiStatic = uiStatic;
    }

    return fret;
}

STDAPI_(BOOL) DL_InvokeAction(int iButtonID, HWND hwndPage, HWND hwndListBox, int iSel)
{
    BOOL fret = FALSE;

    // Get app from listbox selection

    LRESULT lres = ListBox_GetItemData(hwndListBox, iSel);
    
    if (LB_ERR != lres)
    {
        fret = TRUE;

        IInstalledApp* pia = (IInstalledApp*)lres;

        // Invoke action from button ID

        if (pia)
        {

            HWND hwndPropSheet = GetParent(hwndPage);

            ::EnableWindow(hwndPropSheet, FALSE);

            switch(iButtonID)
            {
                case IDC_MODIFY:
                    pia->Modify(hwndPropSheet);
                    break;
                case IDC_REPAIR:
                    // Pass FALSe, we don't want to reinstall, only repair
                    pia->Repair(FALSE);
                    break;
                case IDC_MODIFYUNINSTALL:
                case IDC_UNINSTALL:
                    pia->Uninstall(hwndPropSheet);
                    break;
                default:
                    //???
                    break;
            }

            ::EnableWindow(hwndPropSheet , TRUE);
        }
    }

    return fret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\dll.cpp ===
/***************************************************************************
 *  dll.c
 *
 *  Standard DLL entry-point functions 
 *
 ***************************************************************************/

// Note: Proxy/Stub Information from ATL
//
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for shappmgr.idl by adding the following 
//      files to the Outputs.
//          shappmgr_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f shappmgrps.mk in the project directory.


#include "priv.h"
#include "sccls.h"

#ifndef DOWNLEVEL
#include "adcctl.h"
#endif //DOWNLEVEL

#include <ntverp.h>
#include <advpub.h>         // For REGINSTALL

// Define GUIDs


extern "C" 
{
HINSTANCE g_hinst = NULL;

int g_cxIcon;
int g_cyIcon;
BOOL g_bMirroredOS;
LONG    g_cRefThisDll = 0;      // per-instance

#ifdef WX86
//
// from uninstal.c
//
extern BOOL bWx86Enabled;
BOOL IsWx86Enabled(VOID);
#endif

};

#ifndef DOWNLEVEL
CComModule _Module;         // ATL module object

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_ADCCtl, CADCCtl)
END_OBJECT_MAP()
#endif //DOWNLEVEL

/*----------------------------------------------------------
Purpose: DllEntryPoint

*/
BOOL 
APIENTRY 
DllMain(
    IN HINSTANCE hinst, 
    IN DWORD dwReason, 
    IN LPVOID lpReserved)
{
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif

    switch(dwReason) 
    {
    case DLL_PROCESS_ATTACH:
#ifndef DOWNLEVEL
        _Module.Init(ObjectMap, hinst);
#endif //DOWNLEVEL
        DisableThreadLibraryCalls(hinst);
        SHFusionInitializeFromModule(hinst);
     
#ifdef DEBUG
        CcshellGetDebugFlags();
        
        if (g_dwBreakFlags & BF_ONDLLLOAD)
            DebugBreak();
#endif

        g_hinst = hinst;

        g_cxIcon = GetSystemMetrics(SM_CXICON);
        g_cyIcon = GetSystemMetrics(SM_CYICON);
        g_bMirroredOS = IS_MIRRORING_ENABLED();
#ifdef WX86
        bWx86Enabled = IsWx86Enabled();
#endif
        break;
        

    case DLL_PROCESS_DETACH:
#ifndef DOWNLEVEL
        _Module.Term();
#endif //DOWNLEVEL
        SHFusionUninitialize();
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        // We shouldn't get these because we called 
        // DisableThreadLibraryCalls(). 
        ASSERT_MSG(0, "DllMain received DLL_THREAD_ATTACH/DETACH!  We're not expecting this.");
        break;

    default:
        break;
    } 

    return TRUE;
} 


/*----------------------------------------------------------
Purpose: This function provides the DLL version info.  This 
         allows the caller to distinguish running NT SUR vs.
         Win95 shell vs. Nashville, etc.

         The caller must GetProcAddress this function.  

Returns: NO_ERROR
         ERROR_INVALID_PARAMETER if pinfo is invalid

*/

// All we have to do is declare this puppy and CCDllGetVersion does the rest
DLLVER_DUALBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);

/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.
*/
HRESULT _CallRegInstall(LPCSTR szSection, BOOL bUninstall)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
#ifdef WINNT                
            STRENTRY seReg[] = {
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            hr = pfnri(g_hinst, szSection, &stReg);
#else
            hr = pfnri(g_hinst, szSection, NULL);
#endif                
            if (bUninstall)
            {
                // ADVPACK will return E_UNEXPECTED if you try to uninstall 
                // (which does a registry restore) on an INF section that was 
                // never installed.  We uninstall sections that may never have
                // been installed, so ignore this error
                hr = ((E_UNEXPECTED == hr) ? S_OK : hr);
            }
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}


/*----------------------------------------------------------
Purpose: Install/uninstall user settings

*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;
    HRESULT hrExternal = S_OK;

#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllInstall");
        DEBUG_BREAK;
    }
#endif

    if (bInstall)
    {
        // Delete any old registration entries, then add the new ones.
        // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
        // (The inf engine doesn't guarantee DelReg/AddReg order, that's
        // why we explicitly unreg and reg here.)
        //
        hr = THR(_CallRegInstall("RegDll", FALSE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;
    }
    else
    {
        hr = THR(_CallRegInstall("UnregDll", TRUE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;
    }

    return hrExternal;
}


/*----------------------------------------------------------
Purpose: Returns a class factory to create an object of
         the requested type.

*/
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    TraceMsg(TF_OBJLIFE, "DllGetClassObject called with riid=%x (%x)", riid, &riid);

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif

    if (riid == IID_IClassFactory || riid == IID_IUnknown)
    {
        // Try our native class factory
        HRESULT hres = GetClassObject(rclsid, riid, ppv);

#ifndef DOWNLEVEL
        if (FAILED(hres))
        {
            // Try the ATL class factory
            hres = _Module.GetClassObject(rclsid, riid, ppv);
        }
#endif //DOWNLEVEL

        return hres;
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}


STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif

#ifndef DOWNLEVEL
    // This component uses ATL and natively-implemented COM objects
    if (0 != g_cRefThisDll || 0 != _Module.GetLockCount())
        return S_FALSE;
#endif //DOWNLEVEL

    TraceMsg(DM_TRACE, "DllCanUnloadNow returning S_OK (bye, bye...)");
    return S_OK;
}


STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
    ASSERT(g_cRefThisDll < 1000);   // reasonable upper limit
}


STDAPI_(void) DllRelease(void)
{
    InterlockedDecrement(&g_cRefThisDll);
    ASSERT(g_cRefThisDll >= 0);      // don't underflow
}


STDAPI DllRegisterServer(void)
{
    HRESULT hres = S_OK;
    
#ifdef _MERGE_PROXYSTUB
    hres = THR(PrxDllRegisterServer());
    if (FAILED(hres))
        return hres;
#endif

#ifndef DOWNLEVEL
    // registers object, typelib and all interfaces in typelib
    hres = THR(_Module.RegisterServer(TRUE));
#endif //DOWNLEVEL

    return hres;
}


STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

#ifndef DOWNLEVEL
    _Module.UnregisterServer();
#endif //DOWNLEVEL
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\event.h ===
#ifndef _EVENT_H_
#define _EVENT_H_

#include "iface.h"          // for IARPEvent


//------------------------------------------------------------------------
//
//  CEventBroker
//
//  This class brokers events sent from the OSP to the OSP listener
//  or the data source listener.
// 
//------------------------------------------------------------------------

class CEventBroker : public IARPEvent
{
public:
    // *** IUnknown ***
    STDMETHOD_(ULONG, AddRef)   (void);
    STDMETHOD_(ULONG, Release)  (void);
    STDMETHOD(QueryInterface)   (REFIID riid, LPVOID * ppvObj);

    // *** IARPEvent ***
    STDMETHOD(SetDataSourceListener)(DataSourceListener *);
    STDMETHOD(IsOSPListener)        (OLEDBSimpleProviderListener * posp);
    STDMETHOD(SetOSPListener)       (OLEDBSimpleProviderListener * posp);
    STDMETHOD(AboutToDeleteRows)    (DBROWCOUNT iRowStart, DBROWCOUNT cRows);
    STDMETHOD(DeletedRows)          (DBROWCOUNT iRowStart, DBROWCOUNT cRows);
    STDMETHOD(RowsAvailable)        (DBROWCOUNT iRowStart, DBROWCOUNT cRows);
    STDMETHOD(RowChanged)           (DBROWCOUNT iRow);
    STDMETHOD(LoadCompleted)        (void);
    STDMETHOD(LoadAborted)          (void);
    STDMETHOD(DataSetChanged)       (void);
    
    CEventBroker(LPWSTR pszQualifier);
    ~CEventBroker();

private:
    
    ULONG _cRef;         
    
    DataSourceListener * _pdsl;
    OLEDBSimpleProviderListener *_pospl;

    BSTR _cbstrQualifier;
};

HRESULT CARPEvent_CreateInstance(REFIID riid, LPVOID * ppvObj, LPWSTR pszQualifier);


#endif // _EVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\events.h ===
//////////////////////////////////////////////////////////////////////////////
// CProxy_ARPCtlEvents
template <class T>
class CProxy_ARPCtlEvents : public IConnectionPointImpl<T, &DIID__ARPCtlEvents, CComDynamicUnkArray>
{
public:
//methods:
//_ARPCtlEvents : IDispatch
public:
	void Fire_OnSyncDataReady()
	{
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
	}
	void Fire_OnAsyncDataReady(
		long row)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= row;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_OnRowReady(
		long row)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= row;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\dump.h ===
//
// Prototypes for debug dump functions
//

#ifndef _DUMP_H_
#define _DUMP_H_

#ifdef DEBUG

EXTERN_C LPCTSTR Dbg_GetReadyState(LONG state);

#ifndef DOWNLEVEL_PLATFORM
EXTERN_C LPCTSTR Dbg_GetGuid(REFGUID rguid, LPTSTR pszBuf, int cch);
#endif //DOWNLEVEL_PLATFORM

EXTERN_C LPCTSTR Dbg_GetBool(BOOL bVal);

#ifdef _DATASRC_H_
EXTERN_C LPCTSTR Dbg_GetLS(LOAD_STATE state);
#endif

#ifdef _MTXARRAY_H_
EXTERN_C LPCTSTR Dbg_GetAppCmd(APPCMD appcmd);
#endif

#ifdef __simpdata_h__
EXTERN_C LPCTSTR Dbg_GetOSPRW(OSPRW state);
#endif

#else

#define Dbg_GetReadyState(state)            TEXT("")

#ifndef DOWNLEVEL_PLATFORM
#define Dbg_GetGuid(rguid, pszBuf, cch)     TEXT("")
#endif //DOWNLEVEL_PLATFORM

#define Dbg_GetBool(bVal)                   TEXT("")
#define Dbg_GetOSPRW(status)                TEXT("")
#define Dbg_GetLS(status)                   TEXT("")
#define Dbg_GetAppCmd(appcmd)               TEXT("")

#endif // DEBUG


#endif // _DUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\findapp.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: findapp.cpp
//
// Implements hueristics to find the folder of an application 
//            
// History:
//         2-17-98  by dli implemented FindAppFolder
//         5-01-98  added lots of little functioins 
//------------------------------------------------------------------------
#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include "appwiz.h"
#include "appsize.h"
#include "findapp.h"
#include "util.h"


// Things to do:
// 1. Move special strings into the RC file


/*-------------------------------------------------------------------------
Purpose: This function searches and returns the sub word (if one is found).
         pszStr is the big string, pszSrch is the candidate substring used
         in the search.

         Returns NULL if no subword is found.
*/
LPCTSTR FindSubWord(LPCTSTR pszStr, LPCTSTR pszSrch)
{
    LPCTSTR pszRet = NULL;

    LPCTSTR pszBegin = pszStr;
    // Search for the sub string from the beginning
    LPCTSTR pszSub;
    while (NULL != (pszSub = StrStrI(pszBegin, pszSrch)))
    {
        LPCTSTR pszPrev;
        LPCTSTR pszEnd = pszSub + lstrlen(pszSrch);
        
        // Is the previous character alphanumeric?
        if (pszSub != pszBegin)
        {
            ASSERT(pszSub > pszBegin);
            pszPrev = CharPrev(pszBegin, pszSub);
            ASSERT(pszPrev >= pszBegin);
            if (IsCharAlphaNumeric(*pszPrev))
            {
                // yes, go on searching
                pszBegin = pszEnd;
                continue;
            }
        }

        // Is the character after the sub string we found
        // alpha numeric? 
        if (IsCharAlphaNumeric(*pszEnd))
        {
            // yes, go on searching
            pszBegin = pszEnd;
            continue;
        }

        // No to both questions above, it is a sub word!!
        pszRet = pszSub;
        break;
    }

    return pszRet;
}

int MatchMultipleSubWords(LPCTSTR pszStr, LPCTSTR pszSubWords)
{
    if (!StrChrI(pszSubWords, TEXT(' ')))
        return 0;

    TCHAR szSubWords[MAX_PATH];
    lstrcpy(szSubWords, pszSubWords);
    LPTSTR pszStart = szSubWords;

    LPTSTR pszSpace;
    int iNumMatches = 0;
    while (pszSpace = StrChrI(pszStart, TEXT(' ')))
    {
        *pszSpace = 0;
        if (FindSubWord(pszStr, pszStart))
            iNumMatches++;
        pszStart = ++pszSpace;
    }

    if (FindSubWord(pszStr, pszStart))
        iNumMatches++;
    
    return iNumMatches;
}




/*-------------------------------------------------------------------------
Purpose: Removes the spaces from pszPath, including spaces in the middle
         of the folder or filespec.  The resulting string is placed in
         pszBuf.

         Example:
         
         (before)
         "C:\Program Files\Microsoft Office\Word.exe"
         (after)
         "C:\ProgramFiles\MicrosoftOffice\Word.exe"
         
*/
void PathRemoveSpaces(LPCTSTR pszPath, LPTSTR pszBuf, int cchBuf)
{
    ASSERT(IS_VALID_STRING_PTR(pszPath, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pszBuf, TCHAR, cchBuf));

    --cchBuf; // Leave room for terminating NUL.

    while(0 < cchBuf && TEXT('\0') != *pszPath)
    {
        //
        // Skip beyond spaces.
        //
        while(TEXT(' ') == *pszPath)
            ++pszPath;

        if (TEXT('\0') != *pszPath)
        {
            //
            // Copy to output.
            //
            *pszBuf++ = *pszPath++;
            --cchBuf;
        }
    }
    *pszBuf = TEXT('\0');
}


// Returns TRUE if all chars in pszCharGroup is in pszString
BOOL AllCharsInString(LPCTSTR pszString, LPCTSTR pszCharGroup)
{
    if (!pszCharGroup || !pszCharGroup[0])
        return FALSE;

    LPCTSTR pszT = pszCharGroup;
    while (*pszT && StrChrI(pszString, *pszT))
        pszT++;

    return (*pszT == 0) ? TRUE : FALSE;
}



/*-------------------------------------------------------------------------
Purpose: Given the full name (and sometimes the short name) of the app,
         this function determines whether the given pszName is a match.
         If bStrict is TRUE, the heuristic skips the slinky checks.

         Returns a ranking of the accuracy of the match:
            MATCH_LEVEL_NOMATCH - pszName does not match whatsoever
            MATCH_LEVEL_LOW     - pszName somewhat matches
            MATCH_LEVEL_NORMAL  - pszName matches pretty good
            MATCH_LEVEL_HIGH    - pszName definitely matches
*/
int MatchAppNameExact(
    LPCTSTR pszName, 
    LPCTSTR pszAppFullName, 
    LPCTSTR pszAppShortName, 
    BOOL bStrict)
{
    TraceMsg(TF_FINDAPP, "MatchAppName ---- %s | %s | %s ", pszName, pszAppShortName, pszAppFullName);

    ASSERT(IS_VALID_STRING_PTR(pszName, -1));

    // In the heuristic below, we never degrade from a better match
    // to a lower match.
    int iMatch = MATCH_LEVEL_NOMATCH;

    // Since the long fullname has the most accuracy, check that first.
    if (pszAppFullName && *pszAppFullName)
    {
        // Is pszName equivalent to the full name of the app?
        if (!lstrcmpi(pszAppFullName, pszName))
            iMatch = MATCH_LEVEL_HIGH;        // Yes, definitely a high match
        else
        {
            // No, okay let's see if there are multiple (> 1) number of sub 
            // words from pszName that match the subwords in the app's full name 
            int iSubMatches = MatchMultipleSubWords(pszAppFullName, pszName);

            // More than three matches, definitely high match
            // NOTE: there could be a risk here, but I have not found a 
            // counter example yet. 
            if (iSubMatches > 3)
                iMatch = MATCH_LEVEL_HIGH;

            // NOTE: there is a risk here. For example: 
            //
            // Microsoft Internet Explorer Setup Files vs. 
            // Microsoft Internet Explorer ... 
            
            else if ((iSubMatches > 1) && (!bStrict || (iSubMatches > 2)))
                iMatch = MATCH_LEVEL_NORMAL;

            // All these are turned off if we have a strict matching
            else if (!bStrict)
            {
                // If the potential folder name is a subset of the full name or 
                // if all of the characters of the potential folder name can 
                // be found in the full name, we have a low match 
                // (Counter Ex: Microsoft vs. Microsoft Office)

                // NOTE: The reason for AllCharsInString is to detect case like 
                // Ex: "PM65 vs. Adobe Page Maker 6.5"
                // There might be a risk in this, but I have not found a counter 
                // example, yet.
                if (StrStrI(pszAppFullName, pszName) || AllCharsInString(pszAppFullName, pszName))
                    iMatch = MATCH_LEVEL_LOW;
            }
        }
    }

    // Association between folder name and the reg key name(short name)
    // This is given second priority because the reg key name is unreliable (could be an ID)
    if (MATCH_LEVEL_HIGH > iMatch && pszAppShortName && *pszAppShortName)
    {
        // Does the string exactly match the app's shortname?
        if (!lstrcmpi(pszAppShortName, pszName))
            iMatch = MATCH_LEVEL_HIGH;      // yes

        // All these are turned off if we have strict matching
        else if (!bStrict)
        {
            // Does the string contain the app's shortname?
            if (iMatch < MATCH_LEVEL_NORMAL && StrStrI(pszName, pszAppShortName))
                iMatch = MATCH_LEVEL_NORMAL;        // yes

            // Or does the app's shortname contain the string?
            else if (iMatch < MATCH_LEVEL_LOW && StrStrI(pszAppShortName, pszName))
                iMatch = MATCH_LEVEL_LOW;           // yes
        }
    }
    
    return iMatch;
}


/*-------------------------------------------------------------------------
Purpose: This function tries some different heuristics to see how well
         pszCandidate matches the given variations of the app name
         (short and long names).

         If bStrict is TRUE, the heuristic skips the slinky checks.

         Returns a ranking of the accuracy of the match:
            MATCH_LEVEL_NOMATCH - pszName does not match whatsoever
            MATCH_LEVEL_LOW     - pszName somewhat matches
            MATCH_LEVEL_NORMAL  - pszName matches pretty good
            MATCH_LEVEL_HIGH    - pszName definitely matches
*/
int MatchAppName(
    LPCTSTR pszCandidate, 
    LPCTSTR pszAppFullName, 
    LPCTSTR pszAppShortName,    OPTIONAL
    BOOL bStrict)
{
    int iMatch = MATCH_LEVEL_NOMATCH;
    if (pszCandidate && *pszCandidate)
    {
        // Clean up all the strings MAX_PATH+1, in this case, we only stick a
        // ' ' on 
        TCHAR szCleanFolderName[MAX_PATH+1];
        InsertSpaceBeforeVersion(pszCandidate, szCleanFolderName);
        
        // Now match the exact name
        iMatch = MatchAppNameExact(szCleanFolderName, pszAppFullName, pszAppShortName, bStrict);

        // Is there still no match, and do we have some flexibility to fudge?
        if (!bStrict)
        {
            int iNewMatch = MATCH_LEVEL_NOMATCH;
            // Yes; try finding it without the spaces in the filename and paths
            TCHAR szCandidate[MAX_PATH];
            TCHAR szFullName[MAX_PATH];
            TCHAR szShortName[MAX_PATH];
            
            PathRemoveSpaces(pszCandidate, szCandidate, ARRAYSIZE(szCandidate));
            PathRemoveSpaces(pszAppFullName, szFullName, ARRAYSIZE(szFullName));

            if (pszAppShortName && pszAppShortName[0])
            {
                PathRemoveSpaces(pszAppShortName, szShortName, ARRAYSIZE(szShortName));
                pszAppShortName = szShortName;
            }
            
            iNewMatch = MatchAppNameExact(szCandidate, szFullName, pszAppShortName, bStrict);

            if (iNewMatch > iMatch)
                iMatch = iNewMatch;
        }
    }

    return iMatch;
}


// This function returns a pointer to the beginning of the right most string 
// which looks like folder path.  This only looks for paths with fixed drive
// letters.
//
// NOTES: 
//  1. This funcion damages pszString 
//  2. We are really cracking the string, what happens
//     in localized versions? Are these going to be international char strings?
//
// Returns NULL if it could not find a legit-looking path.

LPTSTR GetRightMostFolderPathInString(LPTSTR pszString)
{
    // Reverse find the ':' in the path
    LPTSTR pszRoot = StrRChr(pszString, NULL, TEXT(':'));

    // Make sure what we found is not at the beginning of the whole 
    // string or the last character of the string
    if (pszRoot && (pszRoot > pszString) && (*CharNext(pszRoot) == TEXT('\\')))
    {
        // Okay, now move back one, we should be pointing to the drive letter
        pszRoot--;          // Don't have to use CharPrev since we're on a ':'
        
        TCHAR szDrive[2];
        szDrive[0] = *pszRoot;
        szDrive[1] = 0;
        CharUpper(szDrive);
        if ((szDrive[0] >= TEXT('C')) && (szDrive[0] <= TEXT('Z')))
        {
            // Yes, it is a real drive letter
            TCHAR atch[4];
            wsprintf(atch, TEXT("%c:\\"), *pszRoot);

            // We are only interested in fixed drives and let's check the path
            if (GetDriveType(atch) == DRIVE_FIXED)
            {
                PathRemoveFileSpec(pszRoot);
                return pszRoot;
            }
        }
    }

    return NULL;
}


// Given a full path, an app name, an app short name, finds the best match in this path
// EX: App Name: Microsoft Office  Short Name: Office
// C:\Microsoft Office\Office --> C:\Microsoft Office

int FindBestMatch(
    LPCTSTR pszFolder, 
    LPCTSTR pszAppFullName, 
    LPCTSTR pszAppShortName, 
    BOOL bStrict, 
    LPTSTR pszResult)
{
    // This can't be a root directory 
    ASSERT(!PathIsRoot(pszFolder));

    int iBest = MATCH_LEVEL_NOMATCH;
    int iPre  = MATCH_LEVEL_NOMATCH;
    int iThis  = MATCH_LEVEL_NOMATCH;
    
    TCHAR szPrefix[MAX_PATH];
    lstrcpy(szPrefix, pszFolder);

    if (PathRemoveFileSpec(szPrefix) && !PathIsRoot(szPrefix))
        iPre = FindBestMatch(szPrefix, pszAppFullName, pszAppShortName, bStrict, pszResult);
    
    LPTSTR pszName = PathFindFileName(pszFolder);
    if (pszName)
        iThis = MatchAppName(pszName, pszAppFullName, pszAppShortName, bStrict);

    iBest = (iPre > iThis) ? iPre : iThis;
    
    // In case there is both match in the current folder and the previous folder
    // take this current one because:
    // 1. This folder is closer to the "Uninstall" or "Modify" string
    // 2. It costs less to walk this folder;
    if ((iThis > MATCH_LEVEL_NOMATCH) && (iThis >= iPre))
        lstrcpy(pszResult, pszFolder);
    
    return iBest;
}


/*--------------------------------------------------------------------------
Purpose: Given a file name or a folder name, compare it with our list of setup
app names.

NOTE: the comparason are done as the following: We compare the name with the first portion
and the last portion of our setup name EX:
name --> myuninst.exe or uninstall.exe
Setup Name --> uninst

should bother return TRUE 
*/
BOOL IsFileOrFolderSetup(LPTSTR pszName, LPCTSTR pszDoubleString)
{       
    ASSERT(pszName);
    ASSERT(pszDoubleString);

    BOOL bRet = FALSE;

    // Neither pszName of pszDoubleString should be NULL
    if (pszName && pszDoubleString)
    {
        PathRemoveExtension(pszName);
        int cchName = lstrlen(pszName);
        LPCTSTR pszT = pszDoubleString;
        while (*pszT)
        {
            int cch = lstrlen(pszT);
            // NOTE: we compare from the beginning and from the end
            if (!StrCmpNI(pszName, pszT, cch) ||
                ((cchName > cch) && !StrCmpNI(pszName + cchName - cch, pszT, cch)))
            {
                bRet = TRUE;
                break;
            }
            
            pszT += lstrlen(pszT) + 1;
        }
    }

    return bRet;
}
/*-------------------------------------------------------------------------
Purpose: Sniffs the pszFolder for any signs that the path refers to a setup
         program.  Paths that have foldernames or filespecs with the word
         "setup" or "install" are suspect.  Returns TRUE if it looks like
         it might be a setup app or folder.

         An example is "c:\program files\microsoft office\office\setup\outlook\olmaint.exe".
         This function will return TRUE because "setup" is one of the parent
         folder names.

         cStripLevel means how many levels we will go up the directory ladder
*/
BOOL PathIsSetup(LPCTSTR pszFolder, int cStripLevel)
{
    ASSERT(IS_VALID_STRING_PTR(pszFolder, -1));
    ASSERT(cStripLevel > 0);
            
    BOOL bRet = FALSE;
    TCHAR szPath[MAX_PATH];
    TCHAR szName[MAX_PATH];
    lstrcpy(szPath, pszFolder);

    static TCHAR s_szNames[MAX_PATH];
    static BOOL s_bNamesLoaded = FALSE;

    if (!s_bNamesLoaded)
    {
        LoadAndStrip(IDS_SETUPAPPNAMES, s_szNames, ARRAYSIZE(s_szNames));
        s_bNamesLoaded = TRUE;
    }
    
    LPTSTR pszName;
    int iStripLevel = cStripLevel;
    while ((iStripLevel-- > 0) && (NULL != (pszName = PathFindFileName(szPath))))
    {
        lstrcpy(szName, pszName);
        if (IsFileOrFolderSetup(szName, s_szNames))
        {
            bRet = TRUE;
            break;
        }
        else if (!PathRemoveFileSpec(szPath) || PathIsRoot(szPath))
            break;
    }

    return bRet;
}

BOOL PathIsCommonFiles(LPCTSTR pszPath)
{
    TCHAR szCommonFiles[MAX_PATH];
    TCHAR szShortCommonFiles[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTR(pszPath, -1));
    
    // This definitely need to be put in the RC file
    wsprintf(szCommonFiles, TEXT("%c:\\Program Files\\Common Files"), pszPath[0]);

    BOOL bShort = GetShortPathName(szCommonFiles, szShortCommonFiles, ARRAYSIZE(szShortCommonFiles));
    if (bShort)
    {
        ASSERT(szShortCommonFiles[0] == szCommonFiles[0]);
    }
    
    return PathIsPrefix(szCommonFiles, pszPath) || (bShort && PathIsPrefix(szShortCommonFiles, pszPath));
}


// returns TRUE if windows directory is the prefix of pszPath
BOOL PathIsUnderWindows(LPCTSTR pszPath)
{
    TCHAR szWindows[MAX_PATH];

    if (GetWindowsDirectory(szWindows, ARRAYSIZE(szWindows)))
    {
        // Is this path somewhere below the windows directory?
        return PathIsPrefix(szWindows, pszPath);
    }
    return FALSE;
}

/*-------------------------------------------------------------------------
Purpose: This function looks for a valid-looking path in the given pszInfo
         string that may indicate where the app is installed.  This attempts
         to weed out suspect paths like references to setup programs in 
         other folders.

         Returns TRUE if a useful path was found.  pszOut will contain the
         path.
*/
BOOL ParseInfoString(LPCTSTR pszInfo, LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszOut)
{
    ASSERT(IS_VALID_STRING_PTR(pszInfo, -1));
    ASSERT(IS_VALID_STRING_PTR(pszFullName, -1));
    ASSERT(pszOut);

    *pszOut = 0;
    
    // if it starts with rundll, forget it!
    if (!StrCmpNI(pszInfo, TEXT("rundll"), SIZECHARS(TEXT("rundll"))))
        return FALSE;

    // more strings we bail on ...
    
    TCHAR szInfoT[MAX_INFO_STRING];
    lstrcpyn(szInfoT, pszInfo, SIZECHARS(szInfoT));

    // The algorithm: we crack the string, and go from the right most path inside the string
    // to the left most one by one and guess which one is a more reasonable
    LPTSTR pszFolder;
    while (NULL != (pszFolder = GetRightMostFolderPathInString(szInfoT)))
    {
        TCHAR szFullPath[MAX_PATH];
        // GetLongPathName does not work on Win 95
        if (StrChrI(pszFolder, TEXT('\\')) && GetLongPathName(pszFolder, szFullPath, ARRAYSIZE(szFullPath)))
        {
            // Make sure this actually is a path and not a root drive
            if (PathIsDirectory(szFullPath) && !PathIsRoot(szFullPath) && !PathIsUnderWindows(szFullPath))
            {
                // No; then we'll consider it

                LPTSTR pszFolderName;
                BOOL bStop = FALSE;
                // Find out the last folder name
                // If it is "setup" or "install", move up until it's not or we can't move up any more
                while(NULL != (pszFolderName = PathFindFileName(szFullPath)) &&
                      PathIsSetup(pszFolderName, 1))
                {
                    // Have we reached the root of the path?
                    if (!PathRemoveFileSpec(szFullPath) || PathIsRoot(szFullPath))
                    {
                        // Yes; don't go any further
                        bStop = TRUE;
                        break;
                    }
                }

                // We still reject those strings with "setup" or "install" in the middle,
                // or those under the program files common files
                if (!bStop && !PathIsRoot(szFullPath) && 
                    !PathIsSetup(szFullPath, 3) && !PathIsCommonFiles(szFullPath))
                {
                    if (MATCH_LEVEL_NOMATCH < FindBestMatch(szFullPath, pszFullName, pszShortName, FALSE, pszOut))
                        return TRUE;
                }
            }
        }
        
        *pszFolder = 0;
        continue;
    }

    return FALSE;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\event.cpp ===
//+-----------------------------------------------------------------------
//
//  event.cpp:  Implementation of the CEventBroker class.
//              This class translates internal ADC/OSP events into
//              appropriate notifications for the external world.
//
//------------------------------------------------------------------------

#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include "event.h"
//#include "dump.h"


// constructor
CEventBroker::CEventBroker(LPWSTR pszQualifier) : _cRef(1)
{
    ASSERT(NULL == _pospl);
    ASSERT(NULL == _pdsl);

    TraceAddRef(CEventBroker, _cRef);
    _cbstrQualifier = SysAllocString(pszQualifier);
}


// destructor
CEventBroker::~CEventBroker()
{
    TraceMsg(TF_OBJLIFE, "(EventBroker) destroying");
    
    SetDataSourceListener(NULL);
    SetOSPListener(NULL);
    if (_cbstrQualifier)
        SysFreeString(_cbstrQualifier);
}



/*--------------------------------------------------------------------
Purpose: IUnknown::QueryInterface
*/
STDMETHODIMP CEventBroker::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CEventBroker, IARPEvent),
        { 0 },
    };

    return QISearch(this, (LPCQITAB)qit, riid, ppvObj);
}


STDMETHODIMP_(ULONG) CEventBroker::AddRef()
{
    ++_cRef;
    TraceAddRef(CEventBroker, _cRef);
    return _cRef;
}


STDMETHODIMP_(ULONG) CEventBroker::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    TraceRelease(CEventBroker, _cRef);
    
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


/*-------------------------------------------------------------------------
Purpose: IARPEvent::SetDataSourceListener

         Sets the Data Source listener.

         If pdsl is NULL, no notifcations are sent.
*/
STDMETHODIMP CEventBroker::SetDataSourceListener(DataSourceListener * pdsl)
{
    // If we've changed/reset the data source listener, make sure we don't
    // think we've fired dataMemberChanged on it yet.
    ATOMICRELEASE(_pdsl);

    _pdsl = pdsl;
    if (_pdsl)
        _pdsl->AddRef();

    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IARPEvent::SetOSPListener

         Sets the OSP listener.

         If pospl is NULL, no notifications are sent.
*/
STDMETHODIMP CEventBroker::SetOSPListener(OLEDBSimpleProviderListener *pospl)
{
    ATOMICRELEASE(_pospl);

    _pospl = pospl;
    if (_pospl)
        _pospl->AddRef();
        
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IARPEvent::IsOSPListener

         Returns S_OK if the given listener is the current OSP listener.
*/
STDMETHODIMP CEventBroker::IsOSPListener(OLEDBSimpleProviderListener *pospl)
{
    return (pospl == _pospl) ? S_OK : S_FALSE;
}


/*-------------------------------------------------------------------------
Purpose: IARPEvent::RowChanged

         Fired when the OSP updated some fields in a row.
*/
STDMETHODIMP CEventBroker::RowChanged(DBROWCOUNT iRow)
{
    ASSERT(iRow >= 0);
    
    if (_pospl)
    {
        TraceMsg(TF_DSO, "(CEventBroker) rowChanged %d", iRow);
    
        _pospl->cellChanged(iRow, -1);
    }
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IARPEvent::AboutToDeleteRows

         Fired when the OSP is going to delete some rows.
*/
STDMETHODIMP CEventBroker::AboutToDeleteRows(DBROWCOUNT iRowStart, DBROWCOUNT cRows)
{
    ASSERT(iRowStart >= 0);
    ASSERT(cRows > 0);
    
    if (_pospl)
    {
        TraceMsg(TF_DSO, "(CEventBroker) AboutToDeleteRows(%d, %d)", iRowStart, cRows);
    
        _pospl->aboutToDeleteRows(iRowStart, cRows);
    }
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IARPEvent::DeletedRows

         Fired when the OSP has deleted some rows.
*/
STDMETHODIMP CEventBroker::DeletedRows(DBROWCOUNT iRowStart, DBROWCOUNT cRows)
{
    ASSERT(iRowStart >= 0);
    ASSERT(cRows > 0);
    
    if (_pospl)
    {
        TraceMsg(TF_DSO, "(CEventBroker) DeletedRows(%d, %d)", iRowStart, cRows);
    
        _pospl->deletedRows(iRowStart, cRows);
    }
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IARPEvent::RowsAvailable

         Fired when the OSP has enumerated some rows.
*/
STDMETHODIMP CEventBroker::RowsAvailable(DBROWCOUNT iRowStart, DBROWCOUNT cRows)
{
    ASSERT(iRowStart >= 0);
    ASSERT(cRows > 0);
    
    if (_pospl)
    {
        TraceMsg(TF_DSO, "(CEventBroker) RowsAvailable(%d, %d)", iRowStart, cRows);
        
        _pospl->rowsAvailable(iRowStart, cRows);
    }
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IARPEvent::LoadCompleted

         Fired when the OSP has finished enumerating its data.
*/
STDMETHODIMP CEventBroker::LoadCompleted(void)
{
    if (_pospl)
    {
        TraceMsg(TF_DSO, "(CEventBroker) LoadCompleted");

        _pospl->transferComplete(OSPXFER_COMPLETE);
    }
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IARPEvent::LoadAborted

         Fired when the OSP has aborted its enumeration.
*/
STDMETHODIMP CEventBroker::LoadAborted(void)
{
    // Right now, any error results in not returning an SP object,
    // therefore we should not fire transfer complete.
    if (_pospl)
    {
        TraceMsg(TF_DSO, "(CEventBroker) LoadAborted");
    
        _pospl->transferComplete(OSPXFER_ABORT);
    }
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IARPEvent::DataSetChanged

         Fired when the OSP's data set has changed (resorted, refiltered, etc.)
*/
STDMETHODIMP CEventBroker::DataSetChanged(void)
{
    if (_pdsl)
    {
        TraceMsg(TF_DSO, "(CEventBroker) DataSetChanged");
        
        _pdsl->dataMemberChanged(_cbstrQualifier);
    }
    return S_OK;
}


/*----------------------------------------------------------
Purpose: Create-instance function for CARPEvent

*/
HRESULT CARPEvent_CreateInstance(REFIID riid, LPVOID * ppvObj, LPWSTR pszQualifier)
{
    HRESULT hres = E_OUTOFMEMORY;

    *ppvObj = NULL;
    
    CEventBroker * pObj = new CEventBroker(pszQualifier);
    if (pObj)
    {
        hres = pObj->QueryInterface(riid, ppvObj);
        pObj->Release();
    }

    return hres;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\findapp.h ===
#ifndef __FINDAPP_H_
#define __FINDAPP_H_

// Match Levels
#define MATCH_LEVEL_NOMATCH 0
#define MATCH_LEVEL_LOW     1
#define MATCH_LEVEL_NORMAL  2
#define MATCH_LEVEL_HIGH    3

// Parse a string to find the possible path in it
BOOL ParseInfoString(LPCTSTR pszInfo, LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszOut);

// Match the app folder or exe name
int MatchAppName(LPCTSTR pszName, LPCTSTR pszAppFullName, LPCTSTR pszAppShortName, BOOL bStrict);

// Find the best match for an app folder give a path name
int FindBestMatch(LPCTSTR pszFolder, LPCTSTR pszAppFullName, LPCTSTR pszAppShortName, BOOL bStrict, LPTSTR pszResult);

// Find a sub word
LPCTSTR FindSubWord(LPCTSTR pszStr, LPCTSTR pszSrch);

// is the path a setup path, cStripLevel is the maximum level we go up in the
// directory chain
BOOL PathIsSetup(LPCTSTR pszFolder, int cStripLevel);

BOOL PathIsCommonFiles(LPCTSTR pszPath);

BOOL PathIsUnderWindows(LPCTSTR pszPath);
#endif // _FINDAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\gettitle.c ===
//
//  GetTitle.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 5/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"


//
//  Enables the appropriate buttons depending upon the state of the
//  description edit control and what type of shortcut we're trying to
//  make.
//

void EnableNextFinish(LPWIZDATA lpwd)
{
    DWORD dwEnable = PSWIZB_BACK;
    if (GetWindowTextLength(GetDlgItem(lpwd->hwnd, IDC_TITLE)) > 0)
    {
        //
        //  If this is a "known" application then enalble finish, else next.
        //

        dwEnable |= (lpwd->dwFlags & (WDFLAG_APPKNOWN | WDFLAG_COPYLINK)) ?
                                           PSWIZB_FINISH : PSWIZB_NEXT;
    }
    PropSheet_SetWizButtons(GetParent(lpwd->hwnd), dwEnable);
}


//
//  Called from PSN_SETACTIVE.        Assumes lpwd->hwnd already initialized.
//

void GetTitleSetActive(LPWIZDATA lpwd)
{
    //
    // Most of the code to process this was moved into the Next button
    // processing of the previous page as there were some failure cases
    // that we could not get a title that we should detect before we
    // allow the user to change to this page...  HOWEVER, there are some
    // cases where we can't determine the name until we get to this page.
    // If we don't have a name for the sortcut, try to figure one out here.
    //

    if (lpwd->szProgDesc[0] == 0)
    {
        DetermineDefaultTitle(lpwd);
    }

    SetDlgItemText(lpwd->hwnd, IDC_TITLE, lpwd->szProgDesc);
    EnableNextFinish(lpwd);
    PostMessage(lpwd->hwnd, WMPRIV_POKEFOCUS, 0, 0);
}


//
//  Check to see if link name is a duplicate.  If it is then ask the user
//  if they want to replace the old link.  If they say "no" then this function
//  returns FALSE.
//

BOOL GetTitleNextPushed(LPWIZDATA lpwd)
{
    TCHAR szLinkName[MAX_PATH];

    GetDlgItemText(lpwd->hwnd, IDC_TITLE, lpwd->szProgDesc, ARRAYSIZE(lpwd->szProgDesc));
    if (lpwd->szProgDesc[0] == 0)
    {
        return(FALSE);
    }

    if( ( PathCleanupSpec( lpwd->lpszFolder, lpwd->szProgDesc ) != 0 ) ||
        !GetLinkName( szLinkName, lpwd ) )
    {
        ShellMessageBox(g_hinst, lpwd->hwnd, MAKEINTRESOURCE(IDS_MODNAME),
                        0, MB_OK | MB_ICONEXCLAMATION);
        return(FALSE);
    }

    if (PathFileExists(szLinkName))
    {
        //
        //  Obscure boundary case.  If we're creating a new link and the user
        //  happens to want to name it exactly it's current name then we'll let
        //  them do it without a warning.
        //

        if (lpwd->lpszOriginalName && lstrcmpi(lpwd->lpszOriginalName, szLinkName) == 0)
        {
            TraceMsg(TF_ERROR, "%s", "Unbelieveable!  User selected exactly the same name");
            return(TRUE);
        }
        return(IDYES == ShellMessageBox(g_hinst, lpwd->hwnd,
                                    MAKEINTRESOURCE(IDS_DUPLINK), 0,
                                    MB_YESNO | MB_DEFBUTTON1 | MB_ICONHAND,
                                    lpwd->szProgDesc));
    }
    return(TRUE);
}


//
//  Dialog procedure for title dialog
//
BOOL_PTR CALLBACK GetTitleDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm = NULL;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = NULL;

    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            if(lpnm)
            {
                switch(lpnm->code)
                {
                    case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            lpwd->hwnd = hDlg;
                            GetTitleSetActive(lpwd);
                        }
                        break;

                    case PSN_WIZNEXT:
                        if(lpwd)
                        {
                            if (!GetTitleNextPushed(lpwd))
                            {
                                GetTitleSetActive(lpwd);
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                        }
                        break;

                    case PSN_WIZFINISH:
                        if(lpwd)
                        {
                            int        iResult = -1;

                            if (GetTitleNextPushed(lpwd))
                            {
                                if (lpwd->dwFlags & WDFLAG_SINGLEAPP)
                                {
                                    PIFWIZERR err = ConfigRealModeOptions(lpwd, NULL,
                                                        CRMOACTION_DEFAULT);

                                    if (err == PIFWIZERR_SUCCESS ||
                                        err == PIFWIZERR_UNSUPPORTEDOPT)
                                    {
                                        iResult = 0;
                                    }
                                }
                                else
                                {
                                    if (CreateLink(lpwd))
                                    {
                                        iResult = 0;
                                    }
                                }
                            }
                            if (iResult != 0)
                            {
                                GetTitleSetActive(lpwd);
                            }
                            SetDlgMsgResult(hDlg, WM_NOTIFY, iResult);
                        }
                        break;

                    case PSN_RESET:
                        if(lpwd)
                        {
                            CleanUpWizData(lpwd);
                        }
                        break;

                    default:
                        return FALSE;
                }
            }
            break;

        case WM_INITDIALOG:
            lpwd = InitWizSheet(hDlg, lParam, 0);
            if(lpwd)
            {
                Edit_LimitText(GetDlgItem(hDlg, IDC_TITLE), ARRAYSIZE(lpwd->szProgDesc)-1);
            }
            break;

        case WMPRIV_POKEFOCUS:
            {
            HWND hTitle = GetDlgItem(hDlg, IDC_TITLE);
            SetFocus(hTitle);
            Edit_SetSel(hTitle, 0, -1);
            break;
            }

        case WM_DESTROY:
        case WM_HELP:
        case WM_CONTEXTMENU:
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDHELP:
                        break;

                case IDC_TITLE:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case EN_CHANGE:
                            if(lpwd)
                            {
                                EnableNextFinish(lpwd);
                            }
                            break;
                    }
                    break;

            } // end of switch on WM_COMMAND
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;

}  // GetTitleDlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\folder.c ===
//
//  Folder.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 6/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//

#include "priv.h"
#include "appwiz.h"
#include "help.h"        // Help context IDs

typedef struct _FILEITEMDATA {
    DWORD   dwFlags;
    TCHAR   szPath[1];
} FILEITEMDATA, * LPFILEITEMDATA;

#define FIDFLAG_CANADDNEW      0x00000001
#define FIDFLAG_CANDEL         0x00000002
#define FIDFLAG_ISFOLDER       0x00000004
#define FIDFLAG_ISPROGS        0x00000008


//
//
//

int CALLBACK CompareFolderCB(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    #define lpfid1  ((LPFILEITEMDATA)lParam1)
    #define lpfid2  ((LPFILEITEMDATA)lParam2)
    #define b1IsDir (lpfid1->dwFlags & FIDFLAG_ISFOLDER)
    #define b2IsDir (lpfid2->dwFlags & FIDFLAG_ISFOLDER)

    //
    // Programs folder always goes to top
    //

    if (lpfid1->dwFlags & FIDFLAG_ISPROGS)
    {
        return(-1);
    }

    if (lpfid2->dwFlags & FIDFLAG_ISPROGS)
    {
        return(1);
    }

    if (b1IsDir == b2IsDir)
    {
        return(lstrcmpi(lpfid1->szPath, lpfid2->szPath));
    }
    else
    {
        if (b1IsDir)
        {
            return(-1);
        }
        else
        {
            return(1);
        }
    }

    #undef  b1IsDir
    #undef  b2IsDir
    #undef  lpfid1
    #undef  lpfid2
}


//
//  Sorts the specified folder so that folders appear at the top and all
//  files appear in alphabetical order below.
//

void SortFolder(HWND hwndTree, HTREEITEM hParent)
{
    TV_SORTCB sSortCB;

    sSortCB.hParent = hParent;
    sSortCB.lpfnCompare = CompareFolderCB;
    sSortCB.lParam = 0;

    TreeView_SortChildrenCB(hwndTree, &sSortCB, FALSE);
}



//
//  Adds a new folder for the specifed path and returns its HTREEITEM.        If
//  it is unable to add the item then NULL is returned.
//  NOTE:  If dwFileAttributes == AI_NOATTRIB (-1) then no attributes specified.
//           If pidl is NULL then no pidl specified.
//

HTREEITEM AddItem(HWND hwndTree, LPCTSTR pszPath,
                    HTREEITEM hParent, LPITEMIDLIST pidl,
                    DWORD dwFlags)
{
    HTREEITEM       newhti = NULL;
    LPFILEITEMDATA  lpfid = (LPFILEITEMDATA)LocalAlloc(LMEM_FIXED,
                             sizeof(FILEITEMDATA) + (lstrlen(pszPath) + 1)*sizeof(TCHAR));
    if (lpfid)
    {
        TV_INSERTSTRUCT tvis;
        lpfid->dwFlags = dwFlags;
        lstrcpy(lpfid->szPath, pszPath);

        tvis.item.pszText = LPSTR_TEXTCALLBACK;
        tvis.item.iImage = tvis.item.iSelectedImage = I_IMAGECALLBACK;
        tvis.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvis.item.lParam = (LPARAM)lpfid;

        tvis.hParent = hParent;
        tvis.hInsertAfter = TVI_LAST;

        newhti = TreeView_InsertItem(hwndTree, &tvis);
        if (!newhti)
            LocalFree((LPVOID)lpfid);
    }
    return newhti;
}

//
//  Flags for FillFolder
//

#define FFF_AddFiles                1
#define FFF_AddDirs                2

//
//  Recursively add all folders below CurDir to the tree below hParent
//

BOOL IsFolderShortcut(LPCTSTR pszName)
{
    SHFOLDERCUSTOMSETTINGS fcs = {0};
    CLSID clsid = {0};
    fcs.dwSize = sizeof(fcs);
    fcs.dwMask = FCSM_CLSID;
    fcs.pclsid = &clsid;

    if (SUCCEEDED(SHGetSetFolderCustomSettings(&fcs, pszName, FCS_READ)))
    {
        return IsEqualGUID(&clsid, &CLSID_FolderShortcut);
    }
    return FALSE;
}

void FillFolder(HWND hwndTree, LPTSTR lpszCurDir, LPTSTR lpszExclude,
                    HTREEITEM hParent, DWORD dwFlags)
{
    int     iStrTerm = lstrlen(lpszCurDir);
    WIN32_FIND_DATA fd;
    HANDLE  hfind;
    HTREEITEM hNewItem = NULL;
    #define bAddFiles (dwFlags & FFF_AddFiles)
    #define bAddDirs  (dwFlags & FFF_AddDirs)

    lstrcat(lpszCurDir, TEXT("\\*.*"));

    hfind = FindFirstFile(lpszCurDir, &fd);

    if (hfind != INVALID_HANDLE_VALUE)
    {
        do
        {
            BOOL bIsDir = (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);

            if (((bAddFiles && !bIsDir) ||
                // skip "." and ".." and hidden files
                (bAddDirs && bIsDir && (fd.cFileName[0] != TEXT('.')))) &&
                !(fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
            {
                lpszCurDir[iStrTerm] = TEXT('\\');
                lstrcpy(lpszCurDir + iStrTerm + 1, fd.cFileName);

                // let's fudge it -- if it's a folder shortcut, don't treat it
                // like a real folder, since we can't navigate into it anyway
                // and it's not worth the trouble to try.
                if (bIsDir && IsFolderShortcut(lpszCurDir))
                {
                    bIsDir = FALSE;
                }

                //
                // Don't add this if it's supposed to be excluded
                //

                if (!lpszExclude || !bIsDir ||
                    lstrcmpi(lpszExclude, lpszCurDir) != 0)
                {
                    hNewItem = AddItem(hwndTree, lpszCurDir, hParent, NULL,
                                        FIDFLAG_CANADDNEW | FIDFLAG_CANDEL |
                                        (bIsDir ? FIDFLAG_ISFOLDER : 0));
                    if (bIsDir)
                    {
                        FillFolder(hwndTree, lpszCurDir, NULL,
                                   hNewItem, dwFlags);
                    }
                }
            }
        } while (FindNextFile(hfind, &fd));

        FindClose(hfind);
    }

    lpszCurDir[iStrTerm] = 0;

    //
    //  Non-null if any items added to folder.
    //

    if (hNewItem)
    {
        SortFolder(hwndTree, hParent);
        if (!bAddFiles)
        {
            TreeView_Expand(hwndTree, hParent, TVE_EXPAND);
        }
    }
    #undef  bAddFiles
    #undef  bRecurse
}


//
//  Returns a pointer to the directory string for the currently selected
//  item.
//

LPFILEITEMDATA GetCurSel(HWND hwndTree, HTREEITEM * lphtiSel)
{
    TV_ITEM  tvi;

    tvi.hItem = TreeView_GetSelection(hwndTree);

    if (lphtiSel)
    {
        *lphtiSel = tvi.hItem;
    }

    if (tvi.hItem == NULL)
    {
        return(NULL);
    }

    tvi.mask = TVIF_PARAM;
    TreeView_GetItem(hwndTree, &tvi);

    return((LPFILEITEMDATA)tvi.lParam);
}


//
//  Add the specified special folder..
//

HTREEITEM AddSpecialFolder(HWND hwndTree, HTREEITEM htiParent, int nFolder,
                           LPTSTR pszPath, DWORD dwFlags)
{
    LPITEMIDLIST pidl = NULL;
    HTREEITEM    hti = NULL;

    if (SUCCEEDED(SHGetSpecialFolderLocation(hwndTree, nFolder, &pidl)))
    {
        if (SHGetPathFromIDList(pidl, pszPath))
        {
            //
            //  For the desktop, we want the desktop directory, but the icon
            //  for the magic desktop PIDL.
            //
            if (nFolder == CSIDL_DESKTOPDIRECTORY)
            {
                SHFree(pidl);
                if (FAILED(SHGetSpecialFolderLocation(hwndTree, CSIDL_DESKTOP, &pidl)))
                {
                    pidl = NULL;
                }
            }

            if (NULL != pidl)
            {
                hti = AddItem(hwndTree, pszPath, htiParent, pidl,
                              FIDFLAG_ISFOLDER | dwFlags);
            }
        }
    }
    if (NULL != pidl)
    {
        SHFree(pidl);
    }
    return(hti);
}


BOOL _inline MakePrgIcon0Index(HWND hwndTree, HIMAGELIST himl)
{
    LPITEMIDLIST pidl;

    if (SUCCEEDED(SHGetSpecialFolderLocation(hwndTree, CSIDL_PROGRAMS, &pidl)))
    {
        SHFILEINFO   fi;
        BOOL_PTR fOk = SHGetFileInfo( (LPTSTR) pidl, 0, &fi, sizeof( fi ),
                                      SHGFI_ICON | SHGFI_SMALLICON | SHGFI_PIDL );

        SHFree( pidl );
        
        if (fOk)
        {
            ImageList_AddIcon(himl, fi.hIcon);
            DestroyIcon(fi.hIcon);
            return(TRUE);
        }
    }
    return FALSE;
}


//
//  Initialize the tree
//

void InitFolderTree( HWND hwndTree, BOOL bAddFiles, HIMAGELIST *phiml )
{
    HCURSOR    hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    HTREEITEM  htiStart = NULL;
    HTREEITEM  htiPrgs = NULL;
    TCHAR      szPathStart[MAX_PATH];
    TCHAR      szPathPrgs[MAX_PATH];
    UINT       flags = ILC_MASK | ILC_COLOR32;
    HIMAGELIST himl;
    
    if(IS_WINDOW_RTL_MIRRORED(hwndTree))
    {
        flags |= ILC_MIRROR;
    }
    himl = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                       GetSystemMetrics(SM_CYSMICON),
                                       flags, 10, 1);

    if (phiml)
        *phiml = himl;

    if (!himl)
    {
        return;
    }

    TreeView_SetImageList(hwndTree, himl, TVSIL_NORMAL);

    //
    // Add the programs folder as index 0.  All sub-folders of programs
    // will also have the same icon.  This saves both memory and time.
    //

    if (!MakePrgIcon0Index(hwndTree, himl))
    {
        return;
    }

    if (!bAddFiles)
    {
        AddSpecialFolder(hwndTree, TVI_ROOT, CSIDL_DESKTOPDIRECTORY, szPathStart, 0);
    }

    htiStart = AddSpecialFolder(hwndTree, TVI_ROOT, CSIDL_STARTMENU, szPathStart, FIDFLAG_CANADDNEW);

    if (htiStart)
    {
        htiPrgs = AddSpecialFolder(hwndTree, htiStart, CSIDL_PROGRAMS, szPathPrgs, FIDFLAG_CANADDNEW | FIDFLAG_ISPROGS);
        if (htiPrgs)
        {
            FillFolder(hwndTree, szPathPrgs, NULL, htiPrgs,
                       FFF_AddDirs | (bAddFiles ? FFF_AddFiles : 0));
            //
            // Now fill in the rest of the start menu, excluding programs
            //

            FillFolder(hwndTree, szPathStart, szPathPrgs, htiStart,
                       FFF_AddDirs | (bAddFiles ? FFF_AddFiles : 0));
        }
    }

    //
    // Now select and expand the programs folder.
    //

    if (htiPrgs)
    {
        TreeView_SelectItem(hwndTree, htiPrgs);
        if (bAddFiles)
        {
            TreeView_Expand(hwndTree, htiPrgs, TVE_EXPAND);
        }
    }
    SetCursor(hcurOld);
}


//
//  Delete Selected Item
//

VOID RemoveSelItem(HWND hDlg, HWND hwndTree)
{
    HTREEITEM hCur;
    LPFILEITEMDATA lpfid = GetCurSel(hwndTree, &hCur);

    if (!lpfid)
    {
        ShellMessageBox(g_hinst, hDlg, MAKEINTRESOURCE(IDS_NONESEL),
                        0, MB_OK | MB_ICONEXCLAMATION);
    }
    else
    {
        if (lpfid->dwFlags & FIDFLAG_CANDEL)
        {
            TCHAR szFileDblNull[MAX_PATH+1];

            SHFILEOPSTRUCT sFileOp =
            {
                hDlg,
                FO_DELETE,
                szFileDblNull,
                NULL,
                (lpfid->dwFlags & FIDFLAG_ISFOLDER) ?
                FOF_ALLOWUNDO :
                FOF_SILENT | FOF_ALLOWUNDO,
            };

            lstrcpy(szFileDblNull, lpfid->szPath);

            szFileDblNull[lstrlen(szFileDblNull)+1] = 0;

            if (!SHFileOperation(&sFileOp))
            {
                if (!(sFileOp.fAnyOperationsAborted))
                {
                    TreeView_DeleteItem(hwndTree, hCur);
                }
            }

        }
        else
        {
            ShellMessageBox(g_hinst, hDlg, MAKEINTRESOURCE(IDS_CANTDELETE),
                            0, MB_OK | MB_ICONEXCLAMATION, PathFindFileName(lpfid->szPath));
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
//  END SHARED CODE.  BEGIN WIZARD SPECIFIC CODE.
/////////////////////////////////////////////////////////////////////////////


//
//  Returns -1 if no item is selected, otherwise, sets lpwd->lpszFolder
//  to point to the appropriate string, and returns 0.
//

LPARAM PickFolderNextHit(LPWIZDATA lpwd)
{
    LPFILEITEMDATA lpfid = GetCurSel(GetDlgItem(lpwd->hwnd, IDC_FOLDERTREE), NULL);

    if (lpfid)
    {
        lpwd->lpszFolder = (LPTSTR)&(lpfid->szPath);
        lpwd->szProgDesc[0] = 0;
        return(0);
    }
    else
    {
        return(-1);
    }
}


//
//  Creates a new, empty folder.
//

VOID CreateNewFolder(LPWIZDATA lpwd)
{
    TCHAR          szNewName[MAX_PATH];
    HTREEITEM      hParent;
    LPFILEITEMDATA lpfidParent = GetCurSel(GetDlgItem(lpwd->hwnd, IDC_FOLDERTREE), &hParent);

    if (lpfidParent && (lpfidParent->dwFlags & FIDFLAG_CANADDNEW))
    {
        int   iDirLen = lstrlen(lpfidParent->szPath);
        TCHAR szNewShort[10];
        TCHAR szNewLong[80];

        LoadString(g_hinst, IDS_NEWFOLDERSHORT, szNewShort, ARRAYSIZE(szNewShort));
        LoadString(g_hinst, IDS_NEWFOLDERLONG, szNewLong, ARRAYSIZE(szNewLong));

        PathMakeUniqueName(szNewName, ARRAYSIZE(szNewName),
                           szNewShort, szNewLong, lpfidParent->szPath);
        if (CreateDirectory(szNewName, NULL))
        {
            HWND    hwndTree = GetDlgItem(lpwd->hwnd, IDC_FOLDERTREE);
            HTREEITEM hNewDude = AddItem(hwndTree, szNewName, hParent, NULL,
                              FIDFLAG_ISFOLDER | FIDFLAG_CANADDNEW | FIDFLAG_CANDEL);

            if (hNewDude == NULL)
            {
                TraceMsg(TF_ERROR, "%s", "Unable to add new folder to tree.");
            }

            if (hNewDude)
            {
                SortFolder(hwndTree, hParent);
                TreeView_SelectItem(hwndTree, hNewDude);
                TreeView_EditLabel(hwndTree, hNewDude);
            }
        }
        else
        {
            TraceMsg(TF_ERROR, "%s", "Unable to create new directory");
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "%s", "No group selected.  Can't create directory.");
    }
}


//
//  Begin editing a tree label.  This function returns FALSE for success, and
//  TRUE for failure.
//

BOOL BeginEdit(LPWIZDATA lpwd, TV_DISPINFO * lptvdi)
{
    if (TreeView_GetParent(lptvdi->hdr.hwndFrom, lptvdi->item.hItem))
    {
        lpwd->dwFlags |= WDFLAG_INEDITMODE;
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


//
//  Return FALSE if rename can't happen.  True if it worked.
//

BOOL EndEdit(LPWIZDATA lpwd, TV_DISPINFO * lptvdi)
{
    BOOL bWorked = FALSE;
    #define lpszNewName (LPTSTR)lptvdi->item.pszText
    #define lpfidOld ((LPFILEITEMDATA)(lptvdi->item.lParam))
    #define hCurItem lptvdi->item.hItem;

    lpwd->dwFlags &= ~WDFLAG_INEDITMODE;

    if (lpszNewName)
    {
        LPFILEITEMDATA lpfidNew = (LPFILEITEMDATA)LocalAlloc(LMEM_FIXED,
                                   sizeof(LPFILEITEMDATA)+MAX_PATH*sizeof(TCHAR));

        if (lpfidNew)
        {
            lpfidNew->dwFlags = lpfidOld->dwFlags;

            lstrcpy(lpfidNew->szPath, lpfidOld->szPath);

            PathRemoveFileSpec(lpfidNew->szPath);

            PathCleanupSpec(lpfidNew->szPath, lpszNewName);

            PathCombine(lpfidNew->szPath, lpfidNew->szPath, lpszNewName);

            if (MoveFile(lpfidOld->szPath, lpfidNew->szPath))
            {
                TV_ITEM tvi;
                tvi.hItem = hCurItem;
                tvi.mask = TVIF_PARAM;
                tvi.lParam = (LPARAM)lpfidNew;
                TreeView_SetItem(lptvdi->hdr.hwndFrom, &tvi);
                bWorked = TRUE;
            }
            else
            {
                TraceMsg(TF_ERROR, "%s", "Unable to rename directory");
            }
            LocalFree(bWorked ? lpfidOld : lpfidNew);
        }
    }

    return(bWorked);

    #undef lpszNewName
    #undef lpfidOld
    #undef hCurItem
}


//
//  Called when Next or Back is hit to force the end of label editing.
//

void ForceEndEdit(LPWIZDATA lpwd)
{
    if (lpwd->dwFlags & WDFLAG_INEDITMODE)
    {
        TreeView_EndEditLabelNow(GetDlgItem(lpwd->hwnd, IDC_FOLDERTREE), FALSE);
    }
}


void FillInItem(TV_DISPINFO * ptvdi)
{
    SHFILEINFO fi;

    #define lpfid ((LPFILEITEMDATA)(ptvdi->item.lParam))
    if (SHGetFileInfo(lpfid->szPath, 0, &fi, sizeof(fi),
                      SHGFI_ICON | SHGFI_DISPLAYNAME | SHGFI_SMALLICON))
    {
        if (ptvdi->item.mask & TVIF_IMAGE)
        {
            ptvdi->item.iImage = ptvdi->item.iSelectedImage =
                  ImageList_AddIcon(TreeView_GetImageList(ptvdi->hdr.hwndFrom, TVSIL_NORMAL),
                                    fi.hIcon);
            ptvdi->item.mask |= TVIF_SELECTEDIMAGE;
        }

        if (ptvdi->item.mask & TVIF_TEXT)
        {
            StrCpyN(ptvdi->item.pszText, fi.szDisplayName, ptvdi->item.cchTextMax);
        }

        DestroyIcon(fi.hIcon);

        ptvdi->item.mask |= TVIF_DI_SETITEM;
    }
}



//
//  Main dialog procedure for tree of folders
//

BOOL_PTR CALLBACK PickFolderDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnm = NULL;
    LPPROPSHEETPAGE lpp = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = lpp ? (LPWIZDATA)lpp->lParam : NULL;

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR *)lParam;
            if(lpnm)
            {
                switch(lpnm->code)
                {
                    case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            if (lpwd->dwFlags & WDFLAG_LINKHEREWIZ)
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                            else
                            {
                                lpwd->hwnd = hDlg;
                                PropSheet_SetWizButtons(GetParent(hDlg),
                                                        (lpwd->dwFlags & WDFLAG_NOBROWSEPAGE) ?
                                                          PSWIZB_NEXT : PSWIZB_BACK | PSWIZB_NEXT);

                                PostMessage(hDlg, WMPRIV_POKEFOCUS, 0, 0);
                            }
                        }
                        break;

                    case PSN_WIZBACK:
                        if(lpwd)
                        {
                            ForceEndEdit(lpwd);
                            SetDlgMsgResult(hDlg, WM_NOTIFY, 0);
                        }
                        break;

                    case PSN_WIZNEXT:
                        if(lpwd)
                        {
                            ForceEndEdit(lpwd);
                            SetDlgMsgResult(hDlg, WM_NOTIFY, PickFolderNextHit(lpwd));
                        }
                        break;

                    case PSN_RESET:
                        if(lpwd)
                        {
                            CleanUpWizData(lpwd);
                        }
                        break;

                    case NM_DBLCLK:
                        PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                        break;

                    #define lpfidNew ((LPFILEITEMDATA)(((LPNM_TREEVIEW)lParam)->itemNew.lParam))

                    case TVN_SELCHANGED:
                        Button_Enable(GetDlgItem(hDlg, IDC_NEWFOLDER),
                                      (lpfidNew->dwFlags & FIDFLAG_CANADDNEW));
                        break;
                    #undef lpfidNew

                    #define lptvdi ((TV_DISPINFO *)lParam)

                    case TVN_BEGINLABELEDIT:
                        if(lpwd)
                        {
                            SetDlgMsgResult(hDlg, WM_NOTIFY, BeginEdit(lpwd, lptvdi));
                        }
                        break;

                    case TVN_ENDLABELEDIT:
                        if(lpwd)
                        {
                            SetDlgMsgResult(hDlg, WM_NOTIFY, EndEdit(lpwd, lptvdi));
                        }
                        break;
                    #undef lptvdi

                    #define lptvn ((LPNM_TREEVIEW)lParam)

                    case TVN_ITEMEXPANDING:
                        if (lptvn->action != TVE_EXPAND)
                        {
                            SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                        }
                        break;

                    case TVN_DELETEITEM:
                        if (lptvn->itemOld.lParam)
                        {
                            LocalFree((LPVOID)lptvn->itemOld.lParam);
                        }
                        break;
                    #undef lptvn

                    case TVN_GETDISPINFO:
                        FillInItem(((TV_DISPINFO *)lParam));
                        break;

                    default:
                        return FALSE;
                }
            }
            break;

        case WM_INITDIALOG:
            lpwd = InitWizSheet(hDlg, lParam, 0);
            if(lpwd)
            {
                lpwd->himl = NULL;

                if( !( lpwd->dwFlags & WDFLAG_LINKHEREWIZ ) )
                {
                    InitFolderTree( GetDlgItem( hDlg, IDC_FOLDERTREE ),
                                    FALSE, &lpwd->himl );
                }
            }
            break;


        case WM_NCDESTROY:
            //
            //  See if we should destroy the himl...
            //

            if(lpwd)
            {
                if (lpwd->himl)
                {
                    ImageList_Destroy(lpwd->himl);
                    lpwd->himl = NULL;  // make sure not twice
                }
            }
            return FALSE;


        case WMPRIV_POKEFOCUS:
            SetFocus(GetDlgItem(hDlg, IDC_FOLDERTREE));
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_NEWFOLDER:
                    if(lpwd)
                    {
                        CreateNewFolder(lpwd);
                    }
                    break;

             ///   case IDC_DELFOLDER:
             ///   {
             ///       HWND    hTree = GetDlgItem(hDlg, IDC_FOLDERTREE);
             ///       RemoveSelItem(hDlg, hTree);
             ///       SetFocus(hTree);
             ///       break;
             ///   }
            }

        default:
            return FALSE;

    }
    return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
//  END WIZARD SPECIFIC CODE.  BEGIN DELETE ITEM DIALOG CODE.
/////////////////////////////////////////////////////////////////////////////

typedef struct _FOLDERTHREADINFO {
    HANDLE     hThread;
    HWND       hwndTree;
    HIMAGELIST himl;
} FOLDERTHREADINFO, * PFOLDERTHREADINFO;


void CALLBACK FolderEnumItems(PFOLDERTHREADINFO pfti, HTREEITEM hParent)
{
    HTREEITEM hitem;

    hitem = hParent;
    while (hitem && pfti->hThread)
    {
        TV_ITEM tvi;
        tvi.mask  = TVIF_IMAGE;
        tvi.hItem = hitem;
        TreeView_GetItem(pfti->hwndTree, &tvi);
        hitem = TreeView_GetNextSibling(pfti->hwndTree, hitem);
    }

    hitem = TreeView_GetChild(pfti->hwndTree, hParent);

    while (hitem && pfti->hThread)
    {
        FolderEnumItems(pfti, hitem);
        hitem = TreeView_GetNextSibling(pfti->hwndTree, hitem);
    }
}


DWORD CALLBACK FolderThread(PFOLDERTHREADINFO pfti)
{
    HANDLE hThread = pfti->hThread;

    FolderEnumItems(pfti, TreeView_GetRoot(pfti->hwndTree));

    CloseHandle(hThread);

    pfti->hThread = 0;

    return 0;
}


VOID CreateFolderThread(PFOLDERTHREADINFO pfti)
{
    //
    // Create background thread to force list view to draw items
    //

    DWORD idThread;

    if (pfti->hThread)
    {
        return;
    }

    pfti->hThread = CreateThread(NULL, 0, FolderThread, pfti, 0, &idThread);

    if(pfti->hThread)
    {
        SetThreadPriority(pfti->hThread, THREAD_PRIORITY_BELOW_NORMAL);
    }
}


//
//  Main dialog procedure for delete items dialog.
//

const static DWORD aDelItemHelpIDs[] = {  // Context Help IDs
    IDC_TEXT,         NO_HELP,
    IDC_FOLDERTREE,   IDH_TRAY_REMOVEDLG_LIST,
    IDC_DELETEITEM,   IDH_TRAY_REMOVEDLG_DEL,

    0, 0
};

void WaitForThreadToFinish(HWND hDlg, FOLDERTHREADINFO *pfti)
{
    if (pfti->hThread)
    {
        SHProcessSentMessagesUntilEvent(hDlg, pfti->hThread, 10000);
        CloseHandle(pfti->hThread);
        pfti->hThread = NULL;
    }
}

BOOL_PTR CALLBACK DelItemDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    PFOLDERTHREADINFO pfti = (PFOLDERTHREADINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
        case WM_NOTIFY:
            #define lpnm ((NMHDR *)lParam)

            switch(lpnm->code)
            {
                #define lpfidNew ((LPFILEITEMDATA)(((LPNM_TREEVIEW)lParam)->itemNew.lParam))

                case TVN_SELCHANGED:
                {
                    BOOL fCanDel = (lpfidNew->dwFlags & FIDFLAG_CANDEL);
                    HWND hwndDelItem = GetDlgItem(hDlg, IDC_DELETEITEM);

                    if ((!fCanDel) && (GetFocus() == hwndDelItem))
                    {
                        SetFocus(GetDlgItem(hDlg, IDOK));
                        SendMessage(hDlg, DM_SETDEFID, IDOK, 0);
                    }
                    Button_Enable(hwndDelItem, fCanDel);
                    break;
                }

                #undef lpfidNew

                #define lptvn ((LPNM_TREEVIEW)lParam)

                case TVN_DELETEITEM:
                    if (lptvn->itemOld.lParam)
                    {
                        LocalFree((LPVOID)lptvn->itemOld.lParam);
                    }
                    break;

                #undef lptvn

                #define lptkd ((TV_KEYDOWN *)lParam)

                case TVN_KEYDOWN:
                    if (lptkd->wVKey == VK_DELETE)
                    {
                        WaitForThreadToFinish(hDlg, pfti);
                        RemoveSelItem(hDlg, GetDlgItem(hDlg, IDC_FOLDERTREE));
                        CreateFolderThread(pfti);
                        return TRUE;
                    }
                    break;

                #undef lptkd

                case TVN_GETDISPINFO:
                    FillInItem(((TV_DISPINFO *)lParam));
                    break;

                default:
                    return FALSE;

            #undef lpnm
            }
            break;

        case WM_INITDIALOG:

            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            pfti = (PFOLDERTHREADINFO)lParam;

            InitFolderTree(GetDlgItem(hDlg, IDC_FOLDERTREE), TRUE, &pfti->himl);

            pfti->hwndTree = GetDlgItem(hDlg, IDC_FOLDERTREE);
            pfti->hThread = 0;

            CreateFolderThread(pfti);
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aDelItemHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) aDelItemHelpIDs);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    WaitForThreadToFinish(hDlg, pfti);                    
                    EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

                case IDC_DELETEITEM:
                    WaitForThreadToFinish(hDlg, pfti);                    
                    
                    RemoveSelItem(hDlg, GetDlgItem(hDlg, IDC_FOLDERTREE));
                    CreateFolderThread(pfti);
                    break;
            }

        default:
            return FALSE;

    }
    return TRUE;
}


BOOL RemoveItemsDialog( HWND hParent )
{
    BOOL fReturn;

    FOLDERTHREADINFO fti;

    fti.himl = NULL;    // incase we can not create the window

    fReturn = (int)DialogBoxParam( g_hinst, MAKEINTRESOURCE( DLG_DELITEM ),
                                   hParent, DelItemDlgProc, (LPARAM) &fti );

    if( fti.himl )
        ImageList_Destroy( fti.himl );

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\instenum.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: instenum.cpp
//
// The current order of enumeration is Legacy --> Darwin --> SMS
//
// History:
//         1-18-97  by dli
//------------------------------------------------------------------------
#include "priv.h"
#include "instenum.h"
#include "instapp.h"
#include "sccls.h"



// constructor
CEnumInstalledApps::CEnumInstalledApps(void) : _cRef(1), _bEnumLegacy(TRUE), _dwCIA(-1) //_bEnumDarwin(FALSE)
{
    DllAddRef();

    TraceAddRef(CEnumInstalledApps, _cRef);
    
    // Start off enumerating legacy apps, then switch to
    // enumerating darwin apps.
    ASSERT(_hkeyUninstall == NULL);

}


// destructor
CEnumInstalledApps::~CEnumInstalledApps()
{
    if (_hkeyUninstall)
    {
        RegCloseKey(_hkeyUninstall);
        _hkeyUninstall = NULL;
    }

    DllRelease();
}


// IEnumInstalledApps::QueryInterface
HRESULT CEnumInstalledApps::QueryInterface(REFIID riid, LPVOID * ppvOut)
{
    static const QITAB qit[] = {
        QITABENT(CEnumInstalledApps, IEnumInstalledApps),                  // IID_IEnumInstalledApps
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IUnknown::AddRef
ULONG CEnumInstalledApps::AddRef()
{
    _cRef++;
    TraceAddRef(CEnumInstalledApps, _cRef);
    return _cRef;
}

// IUnknown::Release
ULONG CEnumInstalledApps::Release()
{
    _cRef--;
    TraceRelease(CEnumInstalledApps, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

#define REGSTR_VAL_UNINSTALLER_WINDOWSINSTALLER TEXT("WindowsInstaller")
#define REGSTR_VAL_UNINSTALLER_SYSTEMCOMPONENT TEXT("SystemComponent")


HRESULT CEnumInstalledApps::_GetNextLegacyAppFromRegistry(IInstalledApp ** ppia)
{
    HRESULT hres = S_FALSE;
    LONG lRet;
    HKEY hkeySub = NULL;
    TCHAR szKeyName[MAX_PATH];
    DWORD dwType;
    BOOL bTryAgain;

    do
    {
        ULONG cchKeyName = ARRAYSIZE(szKeyName);
        FILETIME ftLast;

        bTryAgain = FALSE;
        
        // Start enumerationg subkeys under _hkeyUninstall
        if (RegEnumKeyEx(_hkeyUninstall, _iIndexEach, szKeyName, &cchKeyName, NULL,
                         NULL, NULL, &ftLast) == ERROR_SUCCESS)
        {
            _iIndexEach++;

            // Open the key and get the subkey name
            lRet = RegOpenKeyEx(_hkeyUninstall, szKeyName, 0, KEY_READ, &hkeySub);
            if (lRet == ERROR_SUCCESS)
            {
                TCHAR szProduct[MAX_PATH];

                // Don't enumerate system components 
                DWORD dwSysComponent = 0;
                DWORD cbSysComponent = SIZEOF(dwSysComponent);
                lRet = SHQueryValueEx(hkeySub, REGSTR_VAL_UNINSTALLER_SYSTEMCOMPONENT, 0, &dwType,
                                       (PBYTE)&dwSysComponent, &cbSysComponent); 
                if ((lRet != ERROR_SUCCESS) || (dwSysComponent != 1))
                {
                    // Don't enumerate Darwin apps, who has WindowsInstaller set to 1
                    ULONG uDarwin;
                    ULONG cbDarwin = SIZEOF(uDarwin);
                    lRet = SHQueryValueEx(hkeySub, REGSTR_VAL_UNINSTALLER_WINDOWSINSTALLER, 0, &dwType,
                                          (PBYTE)&uDarwin, &cbDarwin); 
                    if ((lRet != ERROR_SUCCESS) || (uDarwin != 1))
                    {

                        // Get the DisplayName value
                        ULONG cbProductName = SIZEOF(szProduct);
                        lRet = SHQueryValueEx(hkeySub, REGSTR_VAL_UNINSTALLER_DISPLAYNAME, 0, &dwType,
                                              (PBYTE)szProduct, &cbProductName); 
                        if (lRet == ERROR_SUCCESS)
                        {
                            TCHAR szUninstall[MAX_INFO_STRING];

                            // we proceed even if the below SHQueryValueEx fails, so we need
                            // to zero initialize
                            szUninstall[0] = 0;

                            // Get the uninstaller string
                            ULONG cbUninstall = SIZEOF(szUninstall);
                            lRet = SHQueryValueEx(hkeySub, REGSTR_VAL_UNINSTALLER_COMMANDLINE, 0, &dwType, (PBYTE)szUninstall, &cbUninstall);

                            // NOTE: We don't create CInstalledApp Object if there is no "Uninstall" key 
                            // should we just delete this from registry?
                            if (lRet == ERROR_SUCCESS)
                            {
                                // Create new CInstalledApp Object 
                                CInstalledApp * pia = new CInstalledApp(hkeySub, szKeyName, szProduct, szUninstall, _dwCIA);
                                if (pia)
                                {
                                    *ppia = SAFECAST(pia, IInstalledApp *);
                                    hres = S_OK;
                                }
                                else
                                    hres = E_OUTOFMEMORY;
                                break;  // We found an app, return
                            }
                        }
                    }
                }
                
                // In failure cases, go to the next one and try again
                RegCloseKey(hkeySub);
                bTryAgain = TRUE;
                continue;
                
                // (hkeySub is owned and closed by the CInstalledApp object)
            }
        }
        else
        {
            RegCloseKey(_hkeyUninstall);
            _hkeyUninstall = NULL;
        }
    } while (bTryAgain);

    return hres;
}

typedef struct LEGACYAPPREGKEY {
    HKEY hkRoot;
    LPCTSTR pszSubkey;
} LEGACYAPPREGKEY;

const LEGACYAPPREGKEY c_rgLegacy[] = {
    {   HKEY_LOCAL_MACHINE, REGSTR_PATH_UNINSTALL }, // CIA_LM_NATIVE
    {   HKEY_CURRENT_USER,  REGSTR_PATH_UNINSTALL }, // CIA_CU_NATIVE
#ifdef _WIN64
    {   HKEY_LOCAL_MACHINE, REGSTR_PATH_ALTUNINSTALL }, // CIA_LM_ALT
    {   HKEY_CURRENT_USER,  REGSTR_PATH_ALTUNINSTALL }, // CIA_CU_ALT
#endif
};

// Gets the next legacy app from the registry "uninstall" key

HRESULT CEnumInstalledApps::_GetNextLegacyApp(IInstalledApp ** ppia)
{
    HRESULT hres = S_FALSE;

restart:
    // If we don't have an active enumeration key, then try to make a new one
    while (_hkeyUninstall == NULL && ++_dwCIA < ARRAYSIZE(c_rgLegacy))
    {
        _iIndexEach = 0; // restart the RegEnumKey
        RegOpenKeyEx(c_rgLegacy[_dwCIA].hkRoot,
                     c_rgLegacy[_dwCIA].pszSubkey,
                     0, KEY_READ, &_hkeyUninstall);
    }

    if (_hkeyUninstall)
    {
        // Enumerate the next one
        hres = _GetNextLegacyAppFromRegistry(ppia);

        if (hres == S_FALSE)
        {
            // No more from that key, try another one
            // (_GetNextLegacyAppFromRegistry sets _hkeyUninstall = NULL when it returns S_FALSE)
            goto restart;
        }
    }

    return hres;
}


HRESULT CEnumInstalledApps::_GetNextDarwinApp(IInstalledApp ** ppia)
{
    HRESULT hres = S_FALSE;
    TCHAR szProductID[GUIDSTR_MAX];

    BOOL bContinue;
    do
    {
        bContinue = FALSE;
        
        UINT uRet = TW32(MsiEnumProducts(_iIndexEach, szProductID));
        if (uRet == ERROR_SUCCESS)
        {
            BOOL bTake = TRUE; // Do we want to show this app, default to yes. 
            _iIndexEach++; // increment the counter
            
            HKEY hkeySub = NULL;
            DWORD dwType;
            TCHAR szRegKey[MAX_PATH];
            wnsprintf(szRegKey, ARRAYSIZE(szRegKey), TEXT("%s\\%s"), REGSTR_PATH_UNINSTALL, szProductID);

            // Open this key in the registry
            uRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegKey, 0, KEY_READ, &hkeySub);
            if (uRet == ERROR_SUCCESS)
            {
                // Don't enumerate system components 
                DWORD dwSysComponent = 0;
                DWORD cbSysComponent = SIZEOF(dwSysComponent);
                uRet = SHQueryValueEx(hkeySub, REGSTR_VAL_UNINSTALLER_SYSTEMCOMPONENT, 0, &dwType,
                                      (PBYTE)&dwSysComponent, &cbSysComponent);
                if ((uRet == ERROR_SUCCESS) && (dwType == REG_DWORD) && (dwSysComponent == 1))
                    bTake = FALSE;

                RegCloseKey(hkeySub);
            }

            if (bTake)
            {
                INSTALLSTATE is = MsiQueryProductState(szProductID);

                if ((is != INSTALLSTATE_DEFAULT) && (is != INSTALLSTATE_ADVERTISED))
                    bTake = FALSE;

                // NOTE: INSTALLSTATE_ADVERTISED means assigned apps
                if (bTake)
                {
                    CInstalledApp * pia = new CInstalledApp(szProductID);
                    if (pia)
                    {
                        *ppia = SAFECAST(pia, IInstalledApp *);
                        hres = S_OK;
                    }
                    else
                        hres = E_OUTOFMEMORY;
                    break;
                }
            } 
            bContinue = TRUE;
        }
        else
        {
            switch(uRet)
            {
                case ERROR_NO_MORE_ITEMS:
                    //
                    // Enumeration is complete.
                    //
                    break;

                case ERROR_ACCESS_DENIED:
                    hres = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
                    break;
                    
                default:
                    //
                    // Some error other than "access denied" occured.
                    // Continue enumerating products.
                    //
                    _iIndexEach++;
                    bContinue = TRUE;
                    break;
            }
        }
    } while (bContinue);
    
    return hres;
}


// IEnumInstalledApps::Next
// We allow only one app at a time. 
STDMETHODIMP CEnumInstalledApps::Next(IInstalledApp ** ppia)
{
    HRESULT hres = S_FALSE;
    if (_bEnumLegacy)
    {
        hres = _GetNextLegacyApp(ppia);
        if (hres == S_FALSE)
        {
            // End of the enumeration for legacy apps
            _bEnumLegacy = FALSE;
            _iIndexEach = 0;
            goto EnumDarwinNow;
        }
    }
    else
    {    
EnumDarwinNow:
        hres = _GetNextDarwinApp(ppia);
    }
    
    return hres;
}

// IEnumInstalledApps::Reset
STDMETHODIMP CEnumInstalledApps::Reset(void)
{
    // Start off enumerating legacy apps, then switch to
    // enumerating darwin apps.
    _bEnumLegacy = TRUE;
    _dwCIA = -1;
    _iIndexEach = 0;

    return S_OK;
}


/*----------------------------------------------------------
Purpose: Create-instance function for class factory

*/
STDAPI CEnumInstalledApps_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres = E_OUTOFMEMORY;
    CEnumInstalledApps * pObj = new CEnumInstalledApps();
    if (pObj)
    {
        *ppunk = SAFECAST(pObj, IEnumInstalledApps *);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\iface.h ===
// iface.h : Definition of private interfaces


// {139D4EBC-DF7D-11d1-8661-00C04FD91972}
DEFINE_GUID(IID_IWorkerEvent, 0x139d4ebc, 0xdf7d, 0x11d1, 0x86, 0x61, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {EF4F9629-FC00-11d1-8677-00C04FD91972}
DEFINE_GUID(IID_IARPEvent, 0xef4f9629, 0xfc00, 0x11d1, 0x86, 0x77, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {C3E05A89-FBDB-11d1-8677-00C04FD91972}
DEFINE_GUID(IID_IARPSimpleProvider, 0xc3e05a89, 0xfbdb, 0x11d1, 0x86, 0x77, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {DB89BD6D-FCCD-11d1-8677-00C04FD91972}
DEFINE_GUID(IID_IAppData, 0xdb89bd6d, 0xfccd, 0x11d1, 0x86, 0x77, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {C2D3A971-FC11-11d1-8677-00C04FD91972}
DEFINE_GUID(IID_IMtxArray, 0xc2d3a971, 0xfc11, 0x11d1, 0x86, 0x77, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {AAEC4A45-FCCD-11d1-8677-00C04FD91972}
DEFINE_GUID(IID_IARPWorker, 0xaaec4a45, 0xfccd, 0x11d1, 0x86, 0x77, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);


#ifndef __IFACE_H_
#define __IFACE_H_

#include "simpdata.h"       // for OLEDBSimpleProviderListener and DBROWCOUNT et al

// IWorkerEvent
//      This interface is used by CWorkerThread. /CWorkerThread calls 
//      IWorkerEvent methods to fire events.

#undef  INTERFACE
#define INTERFACE   IWorkerEvent

DECLARE_INTERFACE_(IWorkerEvent, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // *** IWorkerEvent methods ***
    STDMETHOD(FireOnDataReady)      (THIS_ DBROWCOUNT iRow) PURE;
    STDMETHOD(FireOnFinished)       (THIS) PURE;
    STDMETHOD(FireOnDatasetChanged) (THIS) PURE;
};


// IARPEvent
//      This interface is implemented by CEventBroker, and called
//      by anyone who wants to fire events to the databinding listeners.

#include "msdatsrc.h"

#undef  INTERFACE
#define INTERFACE   IARPEvent

DECLARE_INTERFACE_(IARPEvent, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // *** IARPEvent methods ***
    STDMETHOD(SetDataSourceListener)(THIS_ DataSourceListener *) PURE;
    STDMETHOD(IsOSPListener)        (THIS_ OLEDBSimpleProviderListener * posp) PURE;
    STDMETHOD(SetOSPListener)       (THIS_ OLEDBSimpleProviderListener * posp) PURE;
    STDMETHOD(AboutToDeleteRows)    (THIS_ DBROWCOUNT iRowStart, DBROWCOUNT cRows) PURE;
    STDMETHOD(DeletedRows)          (THIS_ DBROWCOUNT iRowStart, DBROWCOUNT cRows) PURE;
    STDMETHOD(RowsAvailable)        (THIS_ DBROWCOUNT iRowStart, DBROWCOUNT cRows) PURE;
    STDMETHOD(RowChanged)           (THIS_ DBROWCOUNT iRow) PURE;
    STDMETHOD(LoadCompleted)        (THIS) PURE;
    STDMETHOD(LoadAborted)          (THIS) PURE;
    STDMETHOD(DataSetChanged)       (THIS) PURE;
};


interface IMtxArray;        // forward reference


// IAppData
//      This provides an interface to an appdata object.

// commands for DoCommand()
typedef enum tagAPPCMD 
{
    APPCMD_UNKNOWN          = 0,
    APPCMD_INSTALL          = 1,        // "install"
    APPCMD_UNINSTALL        = 2,        // "uninstall"
    APPCMD_MODIFY           = 3,        // "modify"
    APPCMD_REPAIR           = 4,        // "repair"
    APPCMD_UPGRADE          = 5,        // "upgrade"
    APPCMD_GENERICINSTALL   = 6,        // "generic install" (install from floppy or CD)
    APPCMD_NTOPTIONS        = 7,        // "nt options"
    APPCMD_WINUPDATE        = 8,        // "update windows"
    APPCMD_ADDLATER         = 9,        // "add later"
} APPCMD;


#undef  INTERFACE
#define INTERFACE   IAppData

DECLARE_INTERFACE_(IAppData, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IAppData ***
    STDMETHOD(DoCommand)        (THIS_ HWND hwndParent, APPCMD appcmd) PURE;
    STDMETHOD(ReadSlowData)     (THIS) PURE;
    STDMETHOD(GetVariant)       (THIS_ DB_LORDINAL iField, VARIANT * pvar) PURE;
    STDMETHOD(SetMtxParent)     (THIS_ IMtxArray * pmtxParent) PURE;
    STDMETHOD_(APPINFODATA *, GetDataPtr)(THIS) PURE;
    STDMETHOD_(SLOWAPPINFO *, GetSlowDataPtr)(THIS) PURE;
    STDMETHOD(GetFrequencyOfUse)(THIS_ LPWSTR pszBuf, int cchBuf) PURE;
    STDMETHOD(SetNameDupe)      (THIS_ BOOL bDupe) PURE;
};


// IMtxArray
//      This provides an interface to the matrix array, which the
//      handles the data for the data source object.

#undef  INTERFACE
#define INTERFACE   IMtxArray

DECLARE_INTERFACE_(IMtxArray, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IMtxArray methods ***
    STDMETHOD(Initialize)       (THIS_ DWORD dwEnum) PURE;
    STDMETHOD(AddItem)          (THIS_ IAppData * pappdata, DBROWCOUNT * piRow) PURE;
    STDMETHOD(DeleteItems)      (THIS_ DBROWCOUNT iRow, DBROWCOUNT cRows) PURE;
    STDMETHOD(GetAppData)       (THIS_ DBROWCOUNT iRow, IAppData ** ppappdata) PURE;
    STDMETHOD(GetItemCount)     (THIS_ DBROWCOUNT * pcItems) PURE;
    STDMETHOD(GetFieldCount)    (THIS_ DB_LORDINAL * pcFields) PURE;
    STDMETHOD(GetFieldName)     (THIS_ DB_LORDINAL iField, VARIANT * pvar) PURE;
    STDMETHOD(GetSortIndex)     (THIS_ DWORD * pdwSort) PURE;
    STDMETHOD(SetSortCriteria)  (THIS_ LPCWSTR pszSortField) PURE;
    STDMETHOD(SortItems)        (THIS) PURE;
    STDMETHOD_(int,CompareItems)(THIS_ IAppData * pappdata1, IAppData * pappdata2) PURE;
    STDMETHOD(MarkDupEntries)   (void) PURE;    
};


// IARPWorker
//      This provides an interface to the matrix array's worker thread.

#undef  INTERFACE
#define INTERFACE   IARPWorker

DECLARE_INTERFACE_(IARPWorker, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IARPWorker methods ***
    STDMETHOD(KillWT)           (THIS) PURE;
    STDMETHOD(StartWT)          (THIS_ int iPriority) PURE;
    STDMETHOD(SetListenerWT)    (THIS_ IWorkerEvent * pwe) PURE;
};


// IARPSimpleProvider
//      This provides an interface between ARP's OSP object and its
//      main control.

#undef  INTERFACE
#define INTERFACE   IARPSimpleProvider

DECLARE_INTERFACE_(IARPSimpleProvider, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IARPSimpleProvider methods ***
    STDMETHOD(Initialize)       (THIS_ IShellAppManager * psam, IARPEvent * parpevt, DWORD dwEnum) PURE;
    STDMETHOD(EnumerateItemsAsync)   (THIS) PURE;
    STDMETHOD(Recalculate)      (THIS) PURE;
    STDMETHOD(SetSortCriteria)  (THIS_ BSTR bstrSortExpr) PURE;
    STDMETHOD(SetFilter)        (THIS_ BSTR bstrFilter) PURE;
    STDMETHOD(Sort)             (THIS) PURE;
    STDMETHOD(DoCommand)        (THIS_ HWND hwndParent, APPCMD appcmd, DBROWCOUNT iRow) PURE;
    STDMETHOD(TransferData)     (THIS_ IARPSimpleProvider * parposp) PURE;
};


#endif //__IFACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\instenum.h ===
#ifndef __INSTENUM_H_
#define __INSTENUM_H_

/////////////////////////////////////////////////////////////////////////////
// CEnumInstalledApps
class CEnumInstalledApps : public IEnumInstalledApps
{
public:

    CEnumInstalledApps(void);
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IEnumInstalledApps
    STDMETHODIMP Next(IInstalledApp ** ppia);
    STDMETHODIMP Reset(void);

protected:

    virtual ~CEnumInstalledApps(void);

    HRESULT _GetNextLegacyAppFromRegistry(IInstalledApp ** ppia);
    HRESULT _GetNextLegacyApp(IInstalledApp ** ppia);
    HRESULT _GetNextDarwinApp(IInstalledApp ** ppia);
    
    UINT _cRef;
    
    DWORD    _iEnumIndex;     // Total Application Enumeration index.
    DWORD    _iIndexEach;     // Shared index by Legacy or Darwin or SMS 
    BOOL     _bEnumLegacy;
    DWORD    _dwCIA;          // What kind of legacy enumeration are we doing?
    HKEY     _hkeyUninstall;
};

#endif //__INSTENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\link.c ===
//
//  Link.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 6/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"

const static TCHAR szExplorer[] = TEXT("Explorer");
const static TCHAR szExpSelParams[] = TEXT("/Select,");

//
//  Returns the fully-qualified path name of the link.
//
BOOL GetLinkName(LPTSTR lpszLinkName, LPWIZDATA lpwd)
{
    if( PathCombine(lpszLinkName, lpwd->lpszFolder, lpwd->szProgDesc) == NULL )
        return( FALSE );

#ifdef NO_NEW_SHORTCUT_HOOK
    lstrcat(lpszLinkName, (lpwd->dwFlags & WDFLAG_DOSAPP) ? c_szPIF : c_szLNK);
#else
    if ((lstrlen(lpszLinkName) + lstrlen(lpwd->szExt)) >= MAX_PATH)
        return FALSE;

    lstrcat(lpszLinkName, lpwd->szExt);
#endif

    return( TRUE );
}


//
//  Opens the folder of the newly created link.
//

BOOL OpenLinkFolder(LPWIZDATA lpwd, LPTSTR lpszLinkName)
{
    SHELLEXECUTEINFO ei;

    TCHAR szParams[MAX_PATH];

    lstrcpy(szParams, szExpSelParams);
    lstrcat(szParams, lpszLinkName);

    ei.cbSize = sizeof(ei);
    ei.hwnd = lpwd->hwnd;
    ei.fMask = 0;
    ei.lpVerb = NULL;
    ei.lpFile = szExplorer;
    ei.lpParameters = szParams;
    ei.lpDirectory = NULL;
    ei.lpClass = NULL;
    ei.nShow = SW_SHOWDEFAULT;
    ei.hInstApp = g_hinst;

    return(ShellExecuteEx(&ei));
}


//
//  Cretates a link.
//

BOOL CreateLink(LPWIZDATA lpwd)
{
    BOOL          bWorked = FALSE;
    IShellLink   *psl;
    HCURSOR       hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    IPersistFile *ppf;
    TCHAR         szLinkName[MAX_PATH];
    WCHAR         wszPath[MAX_PATH];

    szLinkName[0] = TEXT('\0');
    GetLinkName(szLinkName, lpwd);

    if (lpwd->lpszOriginalName)
    {
        if (PathFileExists(szLinkName))
        {
            DeleteFile(lpwd->lpszOriginalName);
            SHChangeNotify(SHCNE_DELETE, SHCNF_FLUSH | SHCNF_PATH,
                        lpwd->lpszOriginalName, NULL);
        }
        else
        {
            // we use full pidls here since simple net pidls fail to compare to full net pidls,
            // and thus the changenotify will never make it to the client and it will not update.
            LPITEMIDLIST pidlOriginal = ILCreateFromPath(lpwd->lpszOriginalName);   // need to do this before the move!
            LPITEMIDLIST pidlLink = NULL;

            if (MoveFile(lpwd->lpszOriginalName, szLinkName))
            {
                pidlLink = ILCreateFromPath(szLinkName);    // need to do this after the move (or it won't exist)!

                if (pidlOriginal && pidlLink)
                {
                    SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_FLUSH | SHCNF_IDLIST, pidlOriginal, pidlLink);
                }
                else
                {
                    TraceMsg(TF_ERROR, "%s", "Unable to generate pidls for rename notify");
                    SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_FLUSH | SHCNF_PATH, lpwd->lpszOriginalName, szLinkName);
                }
            }
            else
            {
                TraceMsg(TF_ERROR, "%s", "Unable to rename link -- Will end up with two");
                TraceMsg(TF_ERROR, "%s", szLinkName);
            }
            
            if (pidlOriginal)
                ILFree(pidlOriginal);

            if (pidlLink)
                ILFree(pidlLink);
        }

        //
        // Now get rid of this in case we fail later and then re-enter
        // this routine later.
        //

        lpwd->lpszOriginalName = NULL;
    }

    //
    //    If we're just supposed to copy it, it's simple!
    //

    if (lpwd->dwFlags & WDFLAG_COPYLINK)
    {
        bWorked = CopyFile(lpwd->szExeName, szLinkName, FALSE);
        goto ExitNoFree;
    }

#ifndef NO_NEW_SHORTCUT_HOOK
    if (lpwd->pnshhk)
    {
        //
        // The object is ready to be saved to a file.
        //

        if (FAILED(lpwd->pnshhk->lpVtbl->QueryInterface(lpwd->pnshhk, &IID_IPersistFile, &ppf)))
            goto ExitFreePSL;
    }
    else
#ifdef UNICODE
        if (lpwd->pnshhkA)
        {
            //
            // The object is ready to be saved to a file.
            //

            if (FAILED(lpwd->pnshhkA->lpVtbl->QueryInterface(lpwd->pnshhkA, &IID_IPersistFile, &ppf)))
                goto ExitFreePSL;
        }
        else
#endif
    {
#endif
        //
        //    We didn't do a simple copy.  Now do the full-blown create.
        //
        if (FAILED(CoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLink, (void **)&psl)))
        {
            TraceMsg(TF_ERROR, "%s", "Could not create instance of IShellLink");
            goto ExitNoFree;
        }

        if (FAILED(psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf)))
        {
            goto ExitFreePSL;
        }

        psl->lpVtbl->SetPath(psl, lpwd->szExeName);

        psl->lpVtbl->SetArguments(psl, lpwd->szParams);

        psl->lpVtbl->SetWorkingDirectory(psl, lpwd->szWorkingDir);

        if (lpwd->dwFlags & WDFLAG_DOSAPP)
        {
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0, lpwd->PropPrg.achIconFile, -1, wszPath, ARRAYSIZE(wszPath));

            psl->lpVtbl->SetIconLocation(psl, wszPath, (int)(lpwd->PropPrg.wIconIndex));
#else
            psl->lpVtbl->SetIconLocation(psl, lpwd->PropPrg.achIconFile, (int)(lpwd->PropPrg.wIconIndex));
#endif  //  UNICODE

        }
#ifndef NO_NEW_SHORTCUT_HOOK
    }
#endif

#ifdef UNICODE
    bWorked = SUCCEEDED(ppf->lpVtbl->Save(ppf, szLinkName, TRUE));
#else
    if (MultiByteToWideChar(CP_ACP, 0, szLinkName, -1, wszPath, ARRAYSIZE(wszPath)))
    {
        bWorked = SUCCEEDED(ppf->lpVtbl->Save(ppf, wszPath, TRUE));
    }
#endif  //  UNICODE

    ppf->lpVtbl->Release(ppf);

ExitFreePSL:

#ifndef NO_NEW_SHORTCUT_HOOK
    if (lpwd->pnshhk)
    {
        lpwd->pnshhk->lpVtbl->Release(lpwd->pnshhk);
        lpwd->pnshhk = NULL;
    }
    else
#ifdef UNICODE
          if (lpwd->pnshhkA)
          {
              lpwd->pnshhkA->lpVtbl->Release(lpwd->pnshhkA);
              lpwd->pnshhkA = NULL;
          }
          else
#endif
#endif
        psl->lpVtbl->Release(psl);

ExitNoFree:

    if (bWorked)
    {
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_FLUSH | SHCNF_PATH,
                       szLinkName, NULL);
    }
    SetCursor(hcurOld);

    if (bWorked)
    {
        if (!(lpwd->dwFlags & WDFLAG_DONTOPENFLDR))
        {
            OpenLinkFolder(lpwd, szLinkName);
        }
    }
    else
    {
        ShellMessageBox(g_hinst, lpwd->hwnd, MAKEINTRESOURCE(IDS_NOSHORTCUT),
                        0, MB_OK | MB_ICONEXCLAMATION);
    }

    return(bWorked);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\instapp.h ===
#ifndef __INSTAPP_H_
#define __INSTAPP_H_

/////////////////////////////////////////////////////////////////////////////
// CInstalledApp

//
//  There are four classes of legacy applications...
//
//  Uninstall keys can go into either HKLM or HKCU, on either the native
//  platform or the alternate platform.
//
//  For Win64, the alternate platform is Win32.
//  For Win32, there is no alternate platform.
//
#define CIA_LM              0x0000
#define CIA_CU              0x0001
#define CIA_NATIVE          0x0000
#define CIA_ALT             0x0002

#define CIA_LM_NATIVE       (CIA_LM | CIA_NATIVE)
#define CIA_CU_NATIVE       (CIA_CU | CIA_NATIVE)
#define CIA_LM_ALT          (CIA_LM | CIA_ALT)
#define CIA_CU_ALT          (CIA_CU | CIA_ALT)

#define REGSTR_PATH_ALTUNINSTALL TEXT("Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall")

STDAPI_(void) WOW64Uninstall_RunDLLW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow);

class CInstalledApp : public IInstalledApp
{
public:
    // Constructor for Legacy Apps
    CInstalledApp(HKEY hkeySub, LPCTSTR pszKeyName, LPCTSTR pszProducts, LPCTSTR pszUninstall, DWORD dwCIA);

    // Constructor for Darwin Apps
    CInstalledApp(LPTSTR pszProductID);

    ~CInstalledApp(void);

    // Helper function for SysWOW64 execution
    friend void WOW64Uninstall_RunDLLW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow);

    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellApp
    STDMETHODIMP GetAppInfo(PAPPINFODATA pai);
    STDMETHODIMP GetPossibleActions(DWORD * pdwActions);
    STDMETHODIMP GetSlowAppInfo(PSLOWAPPINFO psai);
    STDMETHODIMP GetCachedSlowAppInfo(PSLOWAPPINFO psai);
    STDMETHODIMP IsInstalled(void);
    
    // *** IInstalledApp
    STDMETHODIMP Uninstall(HWND hwndParent);
    STDMETHODIMP Modify(HWND hwndParent);
    STDMETHODIMP Repair(BOOL bReinstall);
    STDMETHODIMP Upgrade(void);
    
protected:

    LONG _cRef;
#define IA_LEGACY     1
#define IA_DARWIN     2
#define IA_SMS        4

    DWORD _dwSource;            // App install source (IA_*)  
    DWORD _dwAction;            // APPACTION_*
    DWORD _dwCIA;               // CIA_*

    // products name
    TCHAR _szProduct[MAX_PATH];

    // action strings 
    TCHAR _szModifyPath[MAX_INFO_STRING];
    TCHAR _szUninstall[MAX_INFO_STRING];

    // info strings
    TCHAR _szInstallLocation[MAX_PATH];

    // for Darwin apps only
    TCHAR _szProductID[GUIDSTR_MAX];
    LPTSTR _pszUpdateUrl;
    
    // for Legacy apps only 
    TCHAR _szKeyName[MAX_PATH];
    TCHAR _szCleanedKeyName[MAX_PATH];
    
    // app size
    BOOL _bTriedToFindFolder;        // TRUE: we have attempted to find the 
                                     //   install folder already

    // GUID identifying this InstalledApp
    GUID _guid;

#define PERSISTSLOWINFO_IMAGE 0x00000001
    // Structure used to persist SLOWAPPINFO
    typedef struct _PersistSlowInfo
    {
        DWORD dwSize;
        DWORD dwMasks;
        ULONGLONG ullSize;
        FILETIME  ftLastUsed;
        int       iTimesUsed;
        WCHAR     szImage[MAX_PATH];
    } PERSISTSLOWINFO;

    HKEY _MyHkeyRoot() { return (_dwCIA & CIA_CU) ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE; };
    BOOL _LegacyUninstall(HWND hwndParent);
    BOOL _LegacyModify(HWND hwndParent);
    LONG _DarRepair(BOOL bReinstall);

    HKEY    _OpenRelatedRegKey(HKEY hkey, LPCTSTR pszRegLoc, REGSAM samDesired, BOOL bCreate);
    HKEY    _OpenUninstallRegKey(REGSAM samDesired);
    void    _GetUpdateUrl();
    void    _GetInstallLocationFromRegistry(HKEY hkeySub);
    LPWSTR  _GetLegacyInfoString(HKEY hkeySub, LPTSTR pszInfoName);
    BOOL    _GetDarwinAppSize(ULONGLONG * pullTotal);
    BOOL    _IsAppFastUserSwitchingCompliant(void);
    
    DWORD   _QueryActionBlockInfo(HKEY hkey);
    DWORD   _QueryBlockedActions(HKEY hkey);
            
#ifndef DOWNLEVEL_PLATFORM
    BOOL    _FindAppFolderFromStrings();
#endif //DOWNLEVEL_PLATFORM
    HRESULT _DarwinGetAppInfo(DWORD dwInfoFlags, PAPPINFODATA pai);
    HRESULT _LegacyGetAppInfo(DWORD dwInfoFlags, PAPPINFODATA pai);
    HRESULT _PersistSlowAppInfo(PSLOWAPPINFO psai);

#define CAMP_UNINSTALL  0
#define CAMP_MODIFY     1

    BOOL    _CreateAppModifyProcess(HWND hwndParent, DWORD dwCAMP);
    BOOL    _CreateAppModifyProcessWow64(HWND hwndParent, DWORD dwCAMP);
    BOOL    _CreateAppModifyProcessNative(HWND hwndParent, LPTSTR pszExePath);

    HRESULT _SetSlowAppInfoChanged(HKEY hkeyCache, DWORD dwValue);
    HRESULT _IsSlowAppInfoChanged();
};

#endif //__INSTAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\instapp.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: instapp.cpp
//
// Installed applications 
//
// History:
//         1-18-97  by dli
//------------------------------------------------------------------------
#include "priv.h"
#include "instapp.h"
#include "sccls.h"
#include "util.h"
#ifndef DOWNLEVEL_PLATFORM
#include "findapp.h"
#endif //DOWNLEVEL_PLATFORM
#include "tasks.h"
#include "slowfind.h"
#include "appsize.h"
#include "appwizid.h"
#include "resource.h"
#include "uemapp.h"

const TCHAR c_szInstall[]  = TEXT("Software\\Installer\\Products\\%s");
const TCHAR c_szTSInstallMode[]  = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Change User Option");
const TCHAR c_szUpdateInfo[] = TEXT("URLUpdateInfo");
const TCHAR c_szSlowInfoCache[] = TEXT("SlowInfoCache");
const TCHAR c_szRegstrARPCache[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Management\\ARPCache");


#ifdef WX86
EXTERN_C BOOL bWx86Enabled;
EXTERN_C BOOL bForceX86Env;
#endif

#ifdef WINNT
#ifndef DOWNLEVEL_PLATFORM
#include <tsappcmp.h>       // for TermsrvAppInstallMode
#include "scripts.h"
#endif // DOWNLEVEL_PLATFORM
#endif // WINNT

#include <winsta.h>         // WinStation* APIs
#include <allproc.h>        // TS_COUNTER
#include <msginaexports.h>  // ShellIsMultipleUsersEnabled, ShellSwitchUser


#define APPACTION_STANDARD  (APPACTION_UNINSTALL | APPACTION_MODIFY | APPACTION_REPAIR)
// overloaded constructor (for legacy apps)
CInstalledApp::CInstalledApp(HKEY hkeySub, LPCTSTR pszKeyName, LPCTSTR pszProduct, LPCTSTR pszUninstall, DWORD dwCIA) : _cRef(1), _dwSource(IA_LEGACY), _dwCIA(dwCIA), _guid(GUID_NULL)
{
    DWORD dwType;
    ULONG cbModify;
    LONG lRet;
        
    ASSERT(IS_VALID_HANDLE(hkeySub, KEY));
    ASSERT(_bTriedToFindFolder == FALSE);

    TraceAddRef(CInstalledApp, _cRef);

    DllAddRef();
    
    TraceMsg(TF_INSTAPP, "(CInstalledApp) Legacy App Created key name = %s, product name = %s, uninstall string = %s",
             pszKeyName, pszProduct, pszUninstall);
    lstrcpy(_szKeyName, pszKeyName);
    InsertSpaceBeforeVersion(_szKeyName, _szCleanedKeyName);
    
    lstrcpy(_szProduct, pszProduct);
#ifdef FULL_DEBUG
    if (_dwCIA & CIA_ALT)
    {
        StrCatBuff(_szProduct, TEXT(" (32-bit)"), ARRAYSIZE(_szProduct));
    }
#endif
    lstrcpy(_szUninstall, pszUninstall);

    DWORD dwActionBlocked = _QueryBlockedActions(hkeySub);
    if (dwActionBlocked != 0)
    {
        // NoRemove, NoModify, or NoRepair has been specified 
        _dwAction |= APPACTION_STANDARD & (~dwActionBlocked);
    }
    else
    {
        // Start with the basics.  For legacy apps, we assume they don't distinguish between
        // modify and remove functions.
        _dwAction |= APPACTION_MODIFYREMOVE;
    }
    
    // If there is no "uninstall" key, we could try to find other hints as where
    // this app lives, if we could find that hint, as the uninstall process, we could
    // just delete that directory and the registry entry.

    // What if we find no hints at all? Should we just delete this thing from the
    // registry?
    if (!(dwActionBlocked & APPACTION_UNINSTALL) && _szUninstall[0])
        _dwAction |= APPACTION_UNINSTALL;

    // Does this app have an explicit modify path?
    cbModify = SIZEOF(_szModifyPath);
    lRet = SHQueryValueEx(hkeySub, TEXT("ModifyPath"), 0, &dwType, (PBYTE)_szModifyPath, &cbModify);
    if ((ERROR_SUCCESS == lRet) && (TEXT('\0') != _szModifyPath[0]))
    {
        // Yes; remove the legacy modify/remove combination.
        _dwAction &= ~APPACTION_MODIFYREMOVE;

        // Does policy prevent this?
        if (!(dwActionBlocked & APPACTION_MODIFY))
            _dwAction |= APPACTION_MODIFY;          // No
    }
    
    _GetInstallLocationFromRegistry(hkeySub);
    _GetUpdateUrl();
    RegCloseKey(hkeySub);
}


// overloaded constructor (for darwin apps)
CInstalledApp::CInstalledApp(LPTSTR pszProductID) : _cRef(1), _dwSource(IA_DARWIN), _guid(GUID_NULL)
{
    ASSERT(_bTriedToFindFolder == FALSE);

    TraceAddRef(CInstalledApp, _cRef);

    DllAddRef();
    
    TraceMsg(TF_INSTAPP, "(CInstalledApp) Darwin app created product name = %s", pszProductID);
    lstrcpy(_szProductID, pszProductID);

    // Get the information from the ProductId
    ULONG cchProduct = ARRAYSIZE(_szProduct);
    MsiGetProductInfo(pszProductID, INSTALLPROPERTY_PRODUCTNAME, _szProduct, &cchProduct);

    BOOL bMachineAssigned = FALSE;
    
    // For Machine Assigned Darwin Apps, only admins should be allowed
    // to modify the app
    if (!IsUserAnAdmin())
    {
        TCHAR szAT[5];
        DWORD cchAT = ARRAYSIZE(szAT);

        // NOTE: according to chetanp, the first character of szAT should be "0" or "1"
        // '0' means it's user assigned, '1' means it's machine assigned
        if ((ERROR_SUCCESS == MsiGetProductInfo(pszProductID, INSTALLPROPERTY_ASSIGNMENTTYPE,
                                               szAT, &cchAT))
            && (szAT[0] == TEXT('1')))
            bMachineAssigned = TRUE;
    }    

    // Query the install state and separate the cases where this app is
    // installed on the machine or assigned...
    // In the assigned case we allow only Uninstall operation. 
    if (INSTALLSTATE_ADVERTISED == MsiQueryProductState(pszProductID))
    {   
        _dwAction |= APPACTION_UNINSTALL;
    }
    else
    {
        DWORD dwActionBlocked = 0;
        HKEY hkeySub = _OpenUninstallRegKey(KEY_READ);
        if (hkeySub)
        {
            dwActionBlocked = _QueryBlockedActions(hkeySub);
            _GetInstallLocationFromRegistry(hkeySub);
            RegCloseKey(hkeySub);
            if (bMachineAssigned)
                _dwAction |= APPACTION_REPAIR & (~dwActionBlocked);
            else
            {
                _dwAction |= APPACTION_STANDARD & (~dwActionBlocked);
                _GetUpdateUrl();
            }
        }
    }
}


// destructor
CInstalledApp::~CInstalledApp()
{
    if (_pszUpdateUrl)
    {
        ASSERT(_dwSource & IA_DARWIN);
        LocalFree(_pszUpdateUrl);
    }

    DllRelease();
}



// The UpdateUrl info is optional for both Darwin and Legacy apps. 
void CInstalledApp::_GetUpdateUrl()
{
    TCHAR szInstall[MAX_PATH];
    HKEY hkeyInstall;
    wnsprintf(szInstall, ARRAYSIZE(szInstall), c_szInstall, _szProductID);
    if (RegOpenKeyEx(_MyHkeyRoot(), szInstall, 0, KEY_READ, &hkeyInstall) == ERROR_SUCCESS)
    {
        ULONG cbUrl;
        if (SHQueryValueEx(hkeyInstall, c_szUpdateInfo, NULL, NULL, NULL, &cbUrl) == ERROR_SUCCESS)
        {
            _pszUpdateUrl = (LPTSTR) LocalAlloc(LPTR, cbUrl);
            if (ERROR_SUCCESS != SHQueryValueEx(hkeyInstall, TEXT(""), NULL, NULL, (PBYTE)_pszUpdateUrl, &cbUrl))
            {
                LocalFree(_pszUpdateUrl);
                _pszUpdateUrl = NULL;
            }
            else
                _dwAction |= APPACTION_UPGRADE;
        }
        RegCloseKey(hkeyInstall);
    }
}

// Queries policy restrictions on the action info
DWORD CInstalledApp::_QueryActionBlockInfo(HKEY hkey)
{
    DWORD dwRet = 0;
    DWORD dwType = 0;
    DWORD dwData = 0;
    ULONG cbData = SIZEOF(dwData);
    if ((ERROR_SUCCESS == SHQueryValueEx(hkey, TEXT("NoRemove"), 0, &dwType, (PBYTE)&dwData, &cbData))
        && (dwType == REG_DWORD) && (dwData == 1))
        dwRet |= APPACTION_UNINSTALL;

    if ((ERROR_SUCCESS == SHQueryValueEx(hkey, TEXT("NoModify"), 0, &dwType, (PBYTE)&dwData, &cbData))
        && (dwType == REG_DWORD) && (dwData == 1))
        dwRet |= APPACTION_MODIFY;

    if ((ERROR_SUCCESS == SHQueryValueEx(hkey, TEXT("NoRepair"), 0, &dwType, (PBYTE)&dwData, &cbData))
        && (dwType == REG_DWORD) && (dwData == 1))
        dwRet |= APPACTION_REPAIR;

    return dwRet;
}

DWORD CInstalledApp::_QueryBlockedActions(HKEY hkey)
{
    DWORD dwRet = _QueryActionBlockInfo(hkey);
    
    if (dwRet != APPACTION_STANDARD)
    {
        HKEY hkeyPolicy = _OpenRelatedRegKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"), KEY_READ, FALSE);
        if (hkeyPolicy)
        {
            dwRet |= _QueryActionBlockInfo(hkeyPolicy);
            RegCloseKey(hkeyPolicy);
        }
    }

    return dwRet;
}

void CInstalledApp::_GetInstallLocationFromRegistry(HKEY hkeySub)
{
    DWORD dwType;
    ULONG cbInstallLocation = SIZEOF(_szInstallLocation);
    LONG lRet = SHQueryValueEx(hkeySub, TEXT("InstallLocation"), 0, &dwType, (PBYTE)_szInstallLocation, &cbInstallLocation);
    PathUnquoteSpaces(_szInstallLocation);
    
    if (lRet == ERROR_SUCCESS)
    {
        ASSERT(IS_VALID_STRING_PTR(_szInstallLocation, -1));
        _dwAction |= APPACTION_CANGETSIZE;
    }
}


HKEY CInstalledApp::_OpenRelatedRegKey(HKEY hkey, LPCTSTR pszRegLoc, REGSAM samDesired, BOOL bCreate)
{
    HKEY hkeySub = NULL;
    LONG lRet;
    
    TCHAR szRegKey[MAX_PATH];

    RIP (pszRegLoc);
    
    // For Darwin apps, use the ProductID as the key name
    LPTSTR pszKeyName = (_dwSource & IA_DARWIN) ? _szProductID : _szKeyName;
    wnsprintf(szRegKey, ARRAYSIZE(szRegKey), TEXT("%s\\%s"), pszRegLoc, pszKeyName, ARRAYSIZE(szRegKey));
    
    // Open this key in the registry
    lRet = RegOpenKeyEx(hkey, szRegKey, 0, samDesired, &hkeySub);
    if (bCreate && (lRet == ERROR_FILE_NOT_FOUND))
    {
        lRet = RegCreateKeyEx(hkey, szRegKey, 0, NULL, REG_OPTION_NON_VOLATILE, samDesired,
                              NULL, &hkeySub, NULL);
    }

    if (lRet != ERROR_SUCCESS)
        hkeySub = NULL;

    return hkeySub;
}


HKEY CInstalledApp::_OpenUninstallRegKey(REGSAM samDesired)
{
    LPCTSTR pszSubkey = (_dwCIA & CIA_ALT) ? REGSTR_PATH_ALTUNINSTALL : REGSTR_PATH_UNINSTALL;
    return _OpenRelatedRegKey(_MyHkeyRoot(), pszSubkey, samDesired, FALSE);
}

// Helper function to query the registry for legacy app info strings
LPWSTR CInstalledApp::_GetLegacyInfoString(HKEY hkeySub, LPTSTR pszInfoName)
{
    DWORD cbSize;
    DWORD dwType;
    LPWSTR pwszInfo = NULL;
    if (SHQueryValueEx(hkeySub, pszInfoName, 0, &dwType, NULL, &cbSize) == ERROR_SUCCESS)
    {
        LPTSTR pszInfoT = (LPTSTR)LocalAlloc(LPTR, cbSize);
        if (pszInfoT && (SHQueryValueEx(hkeySub, pszInfoName, 0, &dwType, (PBYTE)pszInfoT, &cbSize) == ERROR_SUCCESS))
        {
            if ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ))
            {
                if (FAILED(SHStrDup(pszInfoT, &pwszInfo)))
                {
                    ASSERT(pwszInfo == NULL);
                }

                // For the "DisplayIcon" case, we need to make sure the path of
                // the icon actually exists.
                if (pwszInfo && !lstrcmp(pszInfoName, TEXT("DisplayIcon")))
                {
                    PathParseIconLocation(pszInfoT);
                    if (!PathFileExists(pszInfoT))
                    {
                        SHFree(pwszInfo);
                        pwszInfo = NULL;
                    }
                }
                    
            }
            LocalFree(pszInfoT);
        }
    }

    return pwszInfo;
}

// IShellApps::GetAppInfo
STDMETHODIMP CInstalledApp::GetAppInfo(PAPPINFODATA pai)
{
    ASSERT(pai);
    if (pai->cbSize != SIZEOF(APPINFODATA))
        return E_FAIL;
    
    DWORD dwInfoFlags = pai->dwMask;
    pai->dwMask = 0;
    // We cache the product name in all cases(Legacy, Darwin, SMS). 
    if (dwInfoFlags & AIM_DISPLAYNAME)
    {
        if (SUCCEEDED(SHStrDup(_szProduct, &pai->pszDisplayName)))
            pai->dwMask |= AIM_DISPLAYNAME;
    }

    if (dwInfoFlags & ~AIM_DISPLAYNAME)
    {
        HKEY hkeySub = _OpenUninstallRegKey(KEY_READ);
        if (hkeySub != NULL)
        {
            const static struct {
                DWORD dwBit;
                LPTSTR szRegText;
                DWORD ibOffset;
            } s_rgInitAppInfo[] = {
                //
                // WARNING: If you add a new field that is not an LPWSTR type,
                // revisit the loop below.  It only knows about LPWSTR.
                //
                {AIM_VERSION,         TEXT("DisplayVersion"),   FIELD_OFFSET(APPINFODATA, pszVersion)   },
                {AIM_PUBLISHER,       TEXT("Publisher"),        FIELD_OFFSET(APPINFODATA, pszPublisher) },
                {AIM_PRODUCTID,       TEXT("ProductID"),        FIELD_OFFSET(APPINFODATA, pszProductID) },
                {AIM_REGISTEREDOWNER,  TEXT("RegOwner"),        FIELD_OFFSET(APPINFODATA, pszRegisteredOwner) },
                {AIM_REGISTEREDCOMPANY, TEXT("RegCompany"),     FIELD_OFFSET(APPINFODATA, pszRegisteredCompany) },
                {AIM_SUPPORTURL,      TEXT("UrlInfoAbout"),     FIELD_OFFSET(APPINFODATA, pszSupportUrl) },
                {AIM_SUPPORTTELEPHONE,TEXT("HelpTelephone"),    FIELD_OFFSET(APPINFODATA, pszSupportTelephone) },
                {AIM_HELPLINK,        TEXT("HelpLink"),         FIELD_OFFSET(APPINFODATA, pszHelpLink) },
                {AIM_INSTALLLOCATION, TEXT("InstallLocation"),  FIELD_OFFSET(APPINFODATA, pszInstallLocation) },
                {AIM_INSTALLSOURCE,   TEXT("InstallSource"),    FIELD_OFFSET(APPINFODATA, pszInstallSource) },
                {AIM_INSTALLDATE,     TEXT("InstallDate"),      FIELD_OFFSET(APPINFODATA, pszInstallDate) },
                {AIM_CONTACT,         TEXT("Contact"),          FIELD_OFFSET(APPINFODATA, pszContact) },
                {AIM_COMMENTS,        TEXT("Comments"),         FIELD_OFFSET(APPINFODATA, pszComments) },
                {AIM_IMAGE,           TEXT("DisplayIcon"),      FIELD_OFFSET(APPINFODATA, pszImage) },
                {AIM_READMEURL,       TEXT("Readme"),           FIELD_OFFSET(APPINFODATA, pszReadmeUrl) },
                {AIM_UPDATEINFOURL,   TEXT("UrlUpdateInfo"),    FIELD_OFFSET(APPINFODATA, pszUpdateInfoUrl) },
                };

            ASSERT(IS_VALID_HANDLE(hkeySub, KEY));

            int i;
            for (i = 0; i < ARRAYSIZE(s_rgInitAppInfo); i++)
            {
                if (dwInfoFlags & s_rgInitAppInfo[i].dwBit)
                {
                    LPWSTR pszInfo = _GetLegacyInfoString(hkeySub, s_rgInitAppInfo[i].szRegText);
                    if (pszInfo)
                    {
                        // We are assuming each field is a LPWSTR.
                        LPBYTE pbField = (LPBYTE)pai + s_rgInitAppInfo[i].ibOffset;
                        
                        pai->dwMask |= s_rgInitAppInfo[i].dwBit;
                        *(LPWSTR *)pbField = pszInfo;
                    }
                }
            }    

            // If we want a image path but did not get it, and we are a darwin app
            if ((dwInfoFlags & AIM_IMAGE) && !(pai->dwMask & AIM_IMAGE) && (_dwSource & IA_DARWIN))
            {
                TCHAR szProductIcon[MAX_PATH*2];
                DWORD cchProductIcon = ARRAYSIZE(szProductIcon);
                // Okay, call Darwin to get the image
                if ((ERROR_SUCCESS == MsiGetProductInfo(_szProductID, INSTALLPROPERTY_PRODUCTICON, szProductIcon, &cchProductIcon))
                    && szProductIcon[0])
                {
                    // Expand any embedded environment strings while copying
                    // to return buffer.
                    TCHAR szTemp[1];
                    int cchExp = ExpandEnvironmentStrings(szProductIcon, szTemp, ARRAYSIZE(szTemp));
                    pai->pszImage = (TCHAR *)CoTaskMemAlloc(cchExp * sizeof(TCHAR));
                    if (NULL != pai->pszImage)
                    {
                        ExpandEnvironmentStrings(szProductIcon, pai->pszImage, cchExp);
                        pai->dwMask |= AIM_IMAGE;
                    }
                }
            }

            RegCloseKey(hkeySub);
        }
    }

#ifndef DOWNLEVEL_PLATFORM
    // Software installation policy settings can override the default display name
    // and help link url which are authored into a windows installer package.
    if ( (_dwSource & IA_DARWIN) && (dwInfoFlags & (AIM_DISPLAYNAME | AIM_HELPLINK)) )
    {
        LPWSTR  pwszDisplayName = 0;
        LPWSTR  pwszSupportUrl = 0;

        GetLocalManagedApplicationData( _szProductID, &pwszDisplayName, &pwszSupportUrl ); 
        
        if ( pwszDisplayName && (dwInfoFlags & AIM_DISPLAYNAME) )
        {
            LPWSTR  pwszNewDisplayName;

            if ( SUCCEEDED(SHStrDup(pwszDisplayName, &pwszNewDisplayName)) )
            {
                if ( pai->dwMask & AIM_DISPLAYNAME )
                    SHFree( pai->pszDisplayName );

                pai->pszDisplayName = pwszNewDisplayName;
                pai->dwMask |= AIM_DISPLAYNAME;
            }
        }

        if ( pwszSupportUrl && (dwInfoFlags & AIM_HELPLINK) )
        {
            LPWSTR  pwszNewHelpLink;

            if ( SUCCEEDED(SHStrDup(pwszSupportUrl, &pwszNewHelpLink)) )
            {
                if ( pai->dwMask & AIM_HELPLINK )
                    SHFree( pai->pszHelpLink );

                pai->pszHelpLink = pwszNewHelpLink;
                pai->dwMask |= AIM_HELPLINK;
            }
        }

        LocalFree( pwszDisplayName );
        LocalFree( pwszSupportUrl );
    }
#endif // DOWNLEVEL_PLATFORM

    TraceMsg(TF_INSTAPP, "(CInstalledApp) GetAppInfo with %x but got %x", dwInfoFlags, pai->dwMask);
    
    return S_OK;
}


// IShellApps::GetPossibleActions
STDMETHODIMP CInstalledApp::GetPossibleActions(DWORD * pdwActions)
{
    ASSERT(IS_VALID_WRITE_PTR(pdwActions, DWORD));
    *pdwActions = _dwAction;
    return S_OK;
}

#ifndef DOWNLEVEL_PLATFORM
/*-------------------------------------------------------------------------
Purpose: This method finds the application folder for this app.  If a
         possible folder is found, it is stored in the _szInstallLocation
         member variable.

         Returns TRUE if a possible path is found.
*/
BOOL CInstalledApp::_FindAppFolderFromStrings()
{
    TraceMsg(TF_INSTAPP, "(CInstalledApp) FindAppFolderFromStrings ---- %s  %s  %s  %s",
            _szProduct, _szCleanedKeyName, _szUninstall, _szModifyPath);

    // Try to determine from the "installlocation", "uninstall", or "modify"
    // regvalues.
    
    // Say we have tried
    _bTriedToFindFolder = TRUE;

    // First try out the location string, this is most likely to give us some thing
    // and probably is the correct location for logo 5 apps. 
    if (_dwAction & APPACTION_CANGETSIZE)
    {
        if (!IsValidAppFolderLocation(_szInstallLocation))
        {
            // We got bad location string from the registry, set it to empty string
            _dwAction &= ~APPACTION_CANGETSIZE;
            _szInstallLocation[0] = 0;
        }
        else
            // The string from the registry is fine
            return TRUE;
    }
    
    // We didn't have a location string or failed to get anything from it.
    // logo 3 apps are typically this case...
    LPTSTR pszShortName  = (_dwSource & IA_LEGACY) ? _szCleanedKeyName : NULL;
    TCHAR  szFolder[MAX_PATH];
    
    // Let's take a look at the uninstall string, 2nd most likely to give hints
    if ((_dwAction & APPACTION_UNINSTALL) &&
        (ParseInfoString(_szUninstall, _szProduct, pszShortName, szFolder)))
    {
        // remember this string and set the Action bit to get size
        lstrcpy(_szInstallLocation, szFolder);
        _dwAction |= APPACTION_CANGETSIZE;
        return TRUE;
    }

    // Now try the modify string
    if ((_dwAction & APPACTION_MODIFY) &&
        (ParseInfoString(_szModifyPath, _szProduct, pszShortName, szFolder)))
    {
        // remember this string and set the Action bit to get size
        lstrcpy(_szInstallLocation, szFolder);
        _dwAction |= APPACTION_CANGETSIZE;
        return TRUE;
    }

    return FALSE;
}

/*-------------------------------------------------------------------------
Purpose: Persists the slow app info under the "uninstall" key in the registry
         EX: HKLM\\...\\Uninstall\\Word\\ARPCache 
         Returns S_OK if successfully saved it to the registry
         E_FAIL if failed. 
*/
HRESULT CInstalledApp::_PersistSlowAppInfo(PSLOWAPPINFO psai)
{
    HRESULT hres = E_FAIL;
    ASSERT(psai);
    HKEY hkeyARPCache = _OpenRelatedRegKey(_MyHkeyRoot(), c_szRegstrARPCache, KEY_SET_VALUE, TRUE);
    if (hkeyARPCache)
    {
        PERSISTSLOWINFO psi = {0};
        DWORD dwType = 0;
        DWORD cbSize = SIZEOF(psi);
        // Read in the old cached info, and try to preserve the DisplayIcon path
        // Note if the PERSISTSLOWINFO structure is not what we are looking for, we
        // ignore the old icon path. 
        if ((ERROR_SUCCESS != RegQueryValueEx(hkeyARPCache, c_szSlowInfoCache, 0, &dwType, (LPBYTE)&psi, &cbSize))
            || (psi.dwSize != SIZEOF(psi)))
            ZeroMemory(&psi, SIZEOF(psi));
        
        psi.dwSize = SIZEOF(psi);
        psi.ullSize = psai->ullSize;
        psi.ftLastUsed = psai->ftLastUsed;
        psi.iTimesUsed = psai->iTimesUsed;
        
        if (!(psi.dwMasks & PERSISTSLOWINFO_IMAGE) && psai->pszImage && psai->pszImage[0])
        {
            psi.dwMasks |= PERSISTSLOWINFO_IMAGE;
            StrCpy(psi.szImage, psai->pszImage);
        }

        if (RegSetValueEx(hkeyARPCache, c_szSlowInfoCache, 0, REG_BINARY, (LPBYTE)&psi, sizeof(psi)) == ERROR_SUCCESS)
            hres = S_OK;

        _SetSlowAppInfoChanged(hkeyARPCache, 0);
        RegCloseKey(hkeyARPCache);
    }    
    return hres;
}

#endif //DOWNLEVEL_PLATFORM


/*-------------------------------------------------------------------------
Purpose: _SetSlowAppInfoChanged

         Set in the registry that this app has been changed. 
*/
HRESULT CInstalledApp::_SetSlowAppInfoChanged(HKEY hkeyARPCache, DWORD dwValue)
{
    HRESULT hres = E_FAIL;
    BOOL bNewKey = FALSE;
    if (!hkeyARPCache)
    {
        hkeyARPCache = _OpenRelatedRegKey(_MyHkeyRoot(), c_szRegstrARPCache, KEY_READ, FALSE);
        if (hkeyARPCache)
            bNewKey = TRUE;
    }
    
    if (hkeyARPCache)
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkeyARPCache, TEXT("Changed"), 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue)))
            hres = S_OK;

        if (bNewKey)
            RegCloseKey(hkeyARPCache);
    }

    return hres;
}

// IShellApps::GetSlowAppInfo
/*-------------------------------------------------------------------------
Purpose: IShellApps::_IsSlowAppInfoChanged

         Retrieve whether the slow app info has been changed from the registry
*/
HRESULT CInstalledApp::_IsSlowAppInfoChanged()
{
    HRESULT hres = S_FALSE;
    HKEY hkeyARPCache = _OpenRelatedRegKey(_MyHkeyRoot(), c_szRegstrARPCache, KEY_READ, FALSE);
    if (hkeyARPCache)
    {
        DWORD dwValue;
        DWORD dwType;
        DWORD cbSize = SIZEOF(dwValue);
        if (ERROR_SUCCESS == SHQueryValueEx(hkeyARPCache, TEXT("Changed"), 0, &dwType, &dwValue, &cbSize)
            && (dwType == REG_DWORD) && (dwValue == 1))
            hres = S_OK;

        RegCloseKey(hkeyARPCache);
    }
    else
        hres = S_OK;
    return hres;
}

BOOL CInstalledApp::_GetDarwinAppSize(ULONGLONG * pullTotal)
{
    BOOL bRet = FALSE;
    HKEY hkeySub = _OpenUninstallRegKey(KEY_READ);

    RIP(pullTotal);
    *pullTotal = 0;
    if (hkeySub)
    {
        DWORD dwSize = 0;
        DWORD dwType = 0;
        DWORD cbSize = SIZEOF(dwSize);

        if (ERROR_SUCCESS == SHQueryValueEx(hkeySub, TEXT("EstimatedSize"), 0, &dwType, &dwSize, &cbSize)
            && (dwType == REG_DWORD))
        {
            // NOTE: EstimatedSize is in "kb"
            *pullTotal = dwSize * 1024;
            bRet = TRUE;
        }

        RegCloseKey(hkeySub);
    }
    
    return bRet;
}

// IShellApps::GetSlowAppInfo
/*-------------------------------------------------------------------------
Purpose: IShellApps::GetSlowAppInfo

         Gets the appinfo that may take awhile.  This includes the amount
         of diskspace that the app might take up, etc.

         Returns S_OK if some valid info was obtained.  S_FALSE is returned
         if nothing useful was found.  Errors may be returned as well.
*/
STDMETHODIMP CInstalledApp::GetSlowAppInfo(PSLOWAPPINFO psai)
{
#ifndef DOWNLEVEL_PLATFORM
    HRESULT hres = E_INVALIDARG;
    if (psai)
    {
        // Is this an app that we know we can't get info for?
        // In this case this is a darwin app that has not changed
        BOOL bFoundFolder = FALSE;
        LPCTSTR pszShortName = NULL;
        BOOL bSlowAppInfoChanged = (S_OK == _IsSlowAppInfoChanged());

        // Nothing should have changed except for the usage info, so get the cached one first
        if (FAILED(GetCachedSlowAppInfo(psai)))
        {
            ZeroMemory(psai, sizeof(*psai));
            psai->iTimesUsed = -1;
            psai->ullSize = (ULONGLONG) -1;
        }

        // No; have we tried to determine this app's installation location?    
        switch (_dwSource) {
            case IA_LEGACY:
            {
                if (!_bTriedToFindFolder)
                {
                    // No; try to find out now
                    BOOL bRet = _FindAppFolderFromStrings();
                    if (bRet)
                        TraceMsg(TF_ALWAYS, "(CInstalledApp) App Folder Found %s --- %s", _szProduct, _szInstallLocation);
                    else
                    {
                        ASSERT(!(_dwAction & APPACTION_CANGETSIZE));
                        ASSERT(_szInstallLocation[0] == 0);
                    }
                }

                pszShortName = _szCleanedKeyName;

                bFoundFolder = _dwAction & APPACTION_CANGETSIZE;
                if (!bFoundFolder) 
                    bFoundFolder = SlowFindAppFolder(_szProduct, pszShortName, _szInstallLocation);
            }
            break;

            case IA_DARWIN:
            {                    
                if (bSlowAppInfoChanged)
                {
                    // Can we get the Darwin app size?
                    if (!_GetDarwinAppSize(&psai->ullSize))
                        // No, let's set it back to the default value
                        psai->ullSize = (ULONGLONG) -1;
                }

                // Get the "times used" info from UEM
                UEMINFO uei = {0};
                uei.cbSize = SIZEOF(uei);
                uei.dwMask = UEIM_HIT | UEIM_FILETIME;
                if(SUCCEEDED(UEMQueryEvent(&UEMIID_SHELL, UEME_RUNPATH, (WPARAM)-1, (LPARAM)_szProductID, &uei)))
                {
                    // Is there a change to the times used?
                    if (uei.cHit > psai->iTimesUsed)
                    {
                        // Yes, then overwrite the times used field 
                        psai->iTimesUsed = uei.cHit;
                    }

                    if (CompareFileTime(&(uei.ftExecute), &psai->ftLastUsed) > 0)
                        psai->ftLastUsed = uei.ftExecute;
                }
            }   
            break;

            default:
                break;
        }

        LPCTSTR pszInstallLocation = bFoundFolder ? _szInstallLocation : NULL; 
        hres = FindAppInfo(pszInstallLocation, _szProduct, pszShortName, psai, bSlowAppInfoChanged);
        _PersistSlowAppInfo(psai);
    }
#else
    HRESULT hres = E_NOTIMPL;
#endif //DOWNLEVEL_PLATFORM
    return hres;
}

// IShellApps::GetCachedSlowAppInfo
/*-------------------------------------------------------------------------
Purpose: IShellApps::GetCachedSlowAppInfo

         Gets the cached appinfo, to get the real info might take a while

         Returns S_OK if some valid info was obtained.
         Returns E_FAIL if can't find the cached info. 
*/
STDMETHODIMP CInstalledApp::GetCachedSlowAppInfo(PSLOWAPPINFO psai)
{
#ifndef DOWNLEVEL_PLATFORM
    HRESULT hres = E_FAIL;
    if (psai)
    {
        ZeroMemory(psai, sizeof(*psai));
        HKEY hkeyARPCache = _OpenRelatedRegKey(_MyHkeyRoot(), c_szRegstrARPCache, KEY_READ, FALSE);
        if (hkeyARPCache)
        {
            PERSISTSLOWINFO psi = {0};
            DWORD dwType;
            DWORD cbSize = SIZEOF(psi);
            if ((RegQueryValueEx(hkeyARPCache, c_szSlowInfoCache, 0, &dwType, (LPBYTE)&psi, &cbSize) == ERROR_SUCCESS)
                && (psi.dwSize == SIZEOF(psi)))
            {
                psai->ullSize = psi.ullSize;
                psai->ftLastUsed = psi.ftLastUsed;
                psai->iTimesUsed = psi.iTimesUsed;
                if (psi.dwMasks & PERSISTSLOWINFO_IMAGE)
                    SHStrDupW(psi.szImage, &psai->pszImage);
                hres = S_OK;
            } 
            RegCloseKey(hkeyARPCache);
        }
    }
#else
        HRESULT hres = E_NOTIMPL;
#endif //DOWNLEVEL_PLATFORM
        return hres;
}


// IShellApp::IsInstalled
STDMETHODIMP CInstalledApp::IsInstalled()
{
    HRESULT hres = S_FALSE;

    switch (_dwSource)
    {
        case IA_LEGACY:
        {
            // First Let's see if the reg key is still there
            HKEY hkey = _OpenUninstallRegKey(KEY_READ);
            if (hkey)
            {
                // Second we check the "DisplayName" and the "UninstallString"
                LPWSTR pszName = _GetLegacyInfoString(hkey, REGSTR_VAL_UNINSTALLER_DISPLAYNAME);
                if (pszName)
                {
                    if (pszName[0])
                    {
                        LPWSTR pszUninstall = _GetLegacyInfoString(hkey, REGSTR_VAL_UNINSTALLER_COMMANDLINE);
                        if (pszUninstall)
                        {
                            if (pszUninstall[0])
                                hres = S_OK;

                            SHFree(pszUninstall);
                        }
                    }

                    SHFree(pszName);
                }
                RegCloseKey(hkey);
            }
        }
        break;

        case IA_DARWIN:
            if (MsiQueryProductState(_szProductID) == INSTALLSTATE_DEFAULT)
                hres = S_OK;
            break;

        case IA_SMS:
            break;

        default:
            break;
    }

    return hres;

}


#ifdef DOWNLEVEL_PLATFORM

STDAPI_(BOOL) Old_CreateAndWaitForProcess(LPTSTR pszExeName)
{
    PROCESS_INFORMATION pi = {0};
    STARTUPINFO si = {0};
    BOOL fWorked = FALSE;
#ifdef WX86
    DWORD  cchArch;
    WCHAR  szArchValue[32];
#endif    

    DWORD dwCreationFlags = 0;
    // Create the install process
    si.cb = sizeof(si);

#ifdef WX86
    if (bWx86Enabled && bForceX86Env) {
        cchArch = GetEnvironmentVariableW(ProcArchName,
            szArchValue,
            sizeof(szArchValue)
            );

        if (!cchArch || cchArch >= sizeof(szArchValue)) {
            szArchValue[0]=L'\0';
        }

        SetEnvironmentVariableW(ProcArchName, L"x86");
    }
#endif

    // Create the process
    fWorked = CreateProcess(NULL, pszExeName, NULL, NULL, FALSE, dwCreationFlags, NULL, NULL,
                            &si, &pi);
    if (fWorked)
    {
        //
        // Wait for the install to finish.
        //
        HANDLE rghWait[1];
        rghWait[0] = pi.hProcess;
        DWORD dwWaitRet;
#ifdef WX86
        if (ForceWx86) {
            SetEnvironmentVariableW(ProcArchName, ProcArchValue);
        }
#endif
            
        do {
            dwWaitRet = MsgWaitForMultipleObjects(1, rghWait, FALSE, INFINITE, QS_ALLINPUT);

            if (dwWaitRet == WAIT_OBJECT_0 + 1) {
                // block-local variable
                MSG msg ;

                // read all of the messages in this next loop
                // removing each message as we read it
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);

                } // end of PeekMessage while loop
            }
        } while ((dwWaitRet != WAIT_OBJECT_0) && (dwWaitRet != WAIT_ABANDONED_0));

        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);            
    }
    return fWorked;
}

#endif  // DOWNLEVEL_PLATFORM


/*-------------------------------------------------------------------------
Purpose: Creates a process and waits for it to finish
*/
STDAPI_(BOOL) CreateAndWaitForProcess(LPTSTR pszExeName)
{
#if defined(WINNT) && !defined(DOWNLEVEL_PLATFORM)
    return NT5_CreateAndWaitForProcess(pszExeName);
#else
    return Old_CreateAndWaitForProcess(pszExeName);
#endif
}


// Returns FALSE if "pszPath" contains a network app that can not be accessed
// TRUE for all other pathes
BOOL PathIsNetAndCreatable(LPCTSTR pszPath, LPTSTR pszErrExe, UINT cchErrExe)
{
    ASSERT(IS_VALID_STRING_PTR(pszPath, -1));
    BOOL bRet = TRUE;
    TCHAR szExe[MAX_PATH];
    lstrcpyn(szExe, pszPath, ARRAYSIZE(szExe));
    LPTSTR pSpace = PathGetArgs(szExe);
    if (pSpace)
        *pSpace = 0;
    
    if (!PathIsLocalAndFixed(szExe))
        bRet = PathFileExists(szExe);

    if (!bRet)
        lstrcpyn(pszErrExe, szExe, cchErrExe);
    
    return bRet;
}

EXTERN_C BOOL BrowseForExe(HWND hwnd, LPTSTR pszName, DWORD cchName,
                                   LPCTSTR pszInitDir);
/*--------------------------------------------------------------------------*
 *--------------------------------------------------------------------------*/
BOOL_PTR CALLBACK NewUninstallProc(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    LPTSTR pszExe = (LPTSTR) GetWindowLongPtr(hDlg, DWLP_USER);
    switch (msg)
    {
    case WM_INITDIALOG:
        RIP (lp);
        if (lp != NULL)
        {
            pszExe = (LPTSTR)lp;
            SetWindowText(GetDlgItem(hDlg, IDC_TEXT), pszExe);
            pszExe[0] = 0;
            SetWindowLongPtr(hDlg, DWLP_USER, lp);
        }
        else
            EndDialog(hDlg, -1);
        break;

    case WM_COMMAND:
        ASSERT(pszExe);
        RIP (lp);
        switch (GET_WM_COMMAND_ID(wp, lp))
        {
        case IDC_BROWSE:
            if (BrowseForExe(hDlg, pszExe, MAX_PATH, NULL))
                Edit_SetText(GetDlgItem(hDlg, IDC_COMMAND), pszExe);
            break;
            
        case IDOK:
            // NOTE: we are assuming the size of the buffer is at least MAX_PATH
            GetDlgItemText(hDlg, IDC_COMMAND, pszExe, MAX_PATH);

        case IDCANCEL:
            EndDialog(hDlg, (GET_WM_COMMAND_ID(wp, lp) == IDOK));
            break;


        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// Assumes pszExePath is of size MAX_PATH
int GetNewUninstallProgram(HWND hwndParent, LPTSTR pszExePath, DWORD cchExePath)
{
    int iRet = 0;
    RIP(pszExePath);
    if (cchExePath >= MAX_PATH)
    {
        iRet = (int)DialogBoxParam(g_hinst, MAKEINTRESOURCE(DLG_UNCUNINSTALLBROWSE),
                              hwndParent, NewUninstallProc, (LPARAM)(int *)pszExePath);
    }

    return iRet;
}

// CreateProcess the app modification of uninstall process
BOOL CInstalledApp::_CreateAppModifyProcessNative(HWND hwndParent, LPTSTR pszExePath)
{
    BOOL bRet = FALSE;
    TCHAR szModifiedExePath[MAX_PATH + MAX_INFO_STRING];

#ifndef DOWNLEVEL_PLATFORM
    // PPCF_LONGESTPOSSIBLE does not exist on down level platforms
    if (0 >= PathProcessCommand(pszExePath, szModifiedExePath,
                                 ARRAYSIZE(szModifiedExePath), PPCF_ADDQUOTES | PPCF_NODIRECTORIES | PPCF_LONGESTPOSSIBLE))
#endif
        lstrcpy(szModifiedExePath,pszExePath);

    TCHAR szErrExe[MAX_PATH];
    if (!PathIsNetAndCreatable(szModifiedExePath, szErrExe, ARRAYSIZE(szErrExe)))
    {
        TCHAR szExplain[MAX_PATH];
        LoadString(g_hinst, IDS_UNINSTALL_UNCUNACCESSIBLE, szExplain, ARRAYSIZE(szExplain));

        wnsprintf(szModifiedExePath, ARRAYSIZE(szModifiedExePath), szExplain, _szProduct, szErrExe, ARRAYSIZE(szModifiedExePath));
        if (!GetNewUninstallProgram(hwndParent, szModifiedExePath, ARRAYSIZE(szModifiedExePath))) 
            return FALSE;
    }
    
    bRet = CreateAndWaitForProcess(szModifiedExePath);
    if (!bRet)
    {
        if (ShellMessageBox( HINST_THISDLL, hwndParent, MAKEINTRESOURCE( IDS_UNINSTALL_FAILED ),
                             MAKEINTRESOURCE( IDS_UNINSTALL_ERROR ),
                             MB_YESNO | MB_ICONEXCLAMATION, _szProduct, _szProduct) == IDYES)
        {
            // If we are unable to uninstall the app, give the user the option of removing
            // it from the Add/Remove programs list.  Note that we only know an uninstall
            // has failed if we are unable to execute its command line in the registry.  This
            // won't cover all possible failed uninstalls.  InstallShield, for instance, passes
            // an uninstall path to a generic C:\WINDOWS\UNINST.EXE application.  If an
            // InstallShield app has been blown away, UNINST will still launch sucessfully, but
            // will bomb out when it can't find the path, and we have no way of knowing it failed
            // because it always returns an exit code of zero.
            // A future work item (which I doubt will ever be done) would be to investigate
            // various installer apps and see if any of them do return error codes that we could
            // use to be better at detecting failure cases.
            HKEY hkUninstall;
            if (RegOpenKey(_MyHkeyRoot(), REGSTR_PATH_UNINSTALL, &hkUninstall) == ERROR_SUCCESS)
            {
                if (ERROR_SUCCESS == SHDeleteKey(hkUninstall, _szKeyName))
                    bRet = TRUE;
                else
                {
                    ShellMessageBox( HINST_THISDLL, hwndParent, MAKEINTRESOURCE( IDS_CANT_REMOVE_FROM_REGISTRY ),
                                     MAKEINTRESOURCE( IDS_UNINSTALL_ERROR ),
                                     MB_OK | MB_ICONEXCLAMATION, _szProduct);
                }
                RegCloseKey(hkUninstall);
            }
        }
    }
    return bRet;
}

// CreateProcess the app modification of uninstall process
BOOL CInstalledApp::_CreateAppModifyProcess(HWND hwndParent, DWORD dwCAMP)
{
    if (_dwCIA & CIA_ALT)
    {
        return _CreateAppModifyProcessWow64(hwndParent, dwCAMP);
    }
    else
    {
        switch (dwCAMP)
        {
        case CAMP_UNINSTALL:
            return _CreateAppModifyProcessNative(hwndParent, _szUninstall);
        case CAMP_MODIFY:
            return _CreateAppModifyProcessNative(hwndParent, _szModifyPath);
        }
        return FALSE;
    }
}

//
//  Command line to the rundll32 is
//
//  %SystemRoot%\SysWOW64\rundll32.exe %SystemRoot%\SysWOW64\appwiz.cpl,
//      WOW64Uninstall_RunDLL,<hwnd>,<CIA>,<CAMP>,<KeyName>
//
//  The KeyName must come last because it might contain a comma.
//
//
BOOL CInstalledApp::_CreateAppModifyProcessWow64(HWND hwndParent, DWORD dwCAMP)
{
    TCHAR szSysWow64[MAX_PATH];
    TCHAR szRundll32[MAX_PATH];
    TCHAR szCmdLine[MAX_PATH * 2];
    BOOL fSuccess = FALSE;

    if (GetWindowsDirectory(szSysWow64, ARRAYSIZE(szSysWow64)) &&
        PathAppend(szSysWow64, TEXT("SysWOW64")))
    {
        wnsprintf(szRundll32, ARRAYSIZE(szRundll32), TEXT("%s\\rundll32.exe"), szSysWow64);
        wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine),
                  TEXT("\"%s\" \"%s\\appwiz.cpl\",WOW64Uninstall_RunDLL %d,%d,%d,%s"),
                  szRundll32, szSysWow64, hwndParent, _dwCIA, dwCAMP, _szKeyName);
        STARTUPINFO si = { 0 };
        si.cb = sizeof(si);
        PROCESS_INFORMATION pi;
        if (CreateProcess(szRundll32, szCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
        {
            SHProcessMessagesUntilEvent(NULL, pi.hProcess, INFINITE);
            DWORD dwExitCode;
            if (GetExitCodeProcess(pi.hProcess, &dwExitCode) && dwExitCode == 0)
            {
                fSuccess = TRUE;
            }
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }

    return fSuccess;
}

//  Helper function for command line parsing...

int _ParseCmdLineIntegerAndComma(LPWSTR *ppwsz)
{
    LPWSTR psz = *ppwsz;
    if (!psz)
    {
        return -1;
    }

    int i = StrToInt(psz);
    psz = StrChr(psz, TEXT(','));
    if (!psz)
    {
        *ppwsz = NULL;
        return -1;
    }
    *ppwsz = psz + 1;
    return i;
}

//
//  Special export that the 64-bit version of appwiz uses to force an app
//  uninstaller to run in 32-bit mode.
//
//  Command line arguments are as described above.

STDAPI_(void) WOW64Uninstall_RunDLLW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow)
{
    BOOL fSuccess = FALSE;
    HWND hwndParent = (HWND)IntToPtr(_ParseCmdLineIntegerAndComma(&lpszCmdLine));
    int dwCIA = _ParseCmdLineIntegerAndComma(&lpszCmdLine);
    int dwCAMP = _ParseCmdLineIntegerAndComma(&lpszCmdLine);

    if (lpszCmdLine && *lpszCmdLine)
    {
        dwCIA &= ~CIA_ALT; // We *are* the alternate platform

        HKEY hkRoot = (dwCIA & CIA_CU) ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;
        HKEY hkSub;
        TCHAR szBuf[MAX_PATH];
        TCHAR szName[MAX_PATH];
        // Note: This is running on the 32-bit side so we don't use ALT
        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s\\%s"), REGSTR_PATH_UNINSTALL, lpszCmdLine);
        if (ERROR_SUCCESS == RegOpenKeyEx(hkRoot, szBuf, 0, KEY_READ, &hkSub))
        {
            DWORD cb;
            szBuf[0] = 0;
            cb = SIZEOF(szBuf);
            SHQueryValueEx(hkSub, REGSTR_VAL_UNINSTALLER_COMMANDLINE, 0, NULL, (PBYTE)szBuf, &cb);

            szName[0] = 0;
            cb = SIZEOF(szName);
            SHQueryValueEx(hkSub, REGSTR_VAL_UNINSTALLER_DISPLAYNAME, 0, NULL, (PBYTE)szName, &cb);

            CInstalledApp * pia = new CInstalledApp(hkSub, lpszCmdLine, szName, szBuf, dwCIA);
            if (pia)
            {
                fSuccess = pia->_CreateAppModifyProcess(hwndParent, dwCAMP);
                pia->Release();
            }

            RegCloseKey(hkSub);
        }
    }

    // Let my parent regain foreground activation now that I'm finished
    DWORD dwPid;
    if (GetWindowThreadProcessId(hwndParent, &dwPid))
    {
        AllowSetForegroundWindow(dwPid);
    }

    // Return 0 on success, 1 on failure (exit codes are like that)
    ExitProcess(!fSuccess);
}

// Uinstalls legacy apps
BOOL CInstalledApp::_LegacyUninstall(HWND hwndParent)
{
    LPVOID pAppScripts = ScriptManagerInitScripts();

    BOOL bRet = FALSE;
    if (_dwAction & APPACTION_UNINSTALL)
        bRet = _CreateAppModifyProcess(hwndParent, CAMP_UNINSTALL);

    if(pAppScripts)
    {
        ScriptManagerRunScripts(&pAppScripts);
    }

    return bRet;
}

#ifdef WINNT
#ifndef DOWNLEVEL_PLATFORM
DWORD _QueryTSInstallMode(LPTSTR pszKeyName)
{
    // NOTE: Terminal Server guys confirmed this, when this value is 0, it means
    // we were installed in install mode. 1 means not installed in "Install Mode"

    // Set default to "install mode"
    DWORD dwVal = 0;
    DWORD dwValSize = SIZEOF(dwVal);
    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, c_szTSInstallMode, pszKeyName,
                                   NULL, &dwVal, &dwValSize))
    {
        dwVal = 0;
    }
    
    return dwVal;
}
#endif // DOWNLEVEL_PLATFORM
#endif // WINNT


BOOL_PTR CALLBACK _MultiUserWarningProc(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg)
    {
    case WM_INITDIALOG:
        SendDlgItemMessage(hDlg, IDC_ICON_WARNING, STM_SETICON, (WPARAM)LoadIcon(NULL, IDI_WARNING), 0);
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wp, lp))
        {
        case IDC_SWITCHUSER:
            ShellSwitchUser(FALSE);
            EndDialog(hDlg, IDCANCEL);
            break;

        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, GET_WM_COMMAND_ID(wp, lp));
            break;
        }
        break;
    }

    return FALSE;
}

int _GetLoggedOnUserCount(void)
{
    int iCount = 0;
    HANDLE hServer;

    //  Open a connection to terminal services and get the number of sessions.

    hServer = WinStationOpenServerW(reinterpret_cast<WCHAR*>(SERVERNAME_CURRENT));
    if (hServer != NULL)
    {
        TS_COUNTER tsCounters[2] = {0};

        tsCounters[0].counterHead.dwCounterID = TERMSRV_CURRENT_DISC_SESSIONS;
        tsCounters[1].counterHead.dwCounterID = TERMSRV_CURRENT_ACTIVE_SESSIONS;

        if (WinStationGetTermSrvCountersValue(hServer, ARRAYSIZE(tsCounters), tsCounters))
        {
            int i;

            for (i = 0; i < ARRAYSIZE(tsCounters); i++)
            {
                if (tsCounters[i].counterHead.bResult)
                {
                    iCount += tsCounters[i].dwValue;
                }
            }
        }

        WinStationCloseServer(hServer);
    }

    return iCount;
}

int _ShowMultiUserWarning(HWND hwndParent)
{
    int iRet = IDOK;

    if (ShellIsMultipleUsersEnabled() && _GetLoggedOnUserCount() > 1)
    {
        iRet = (int)DialogBoxParam(g_hinst, MAKEINTRESOURCE(DLG_MULTIUSERWARNING),
                              hwndParent, _MultiUserWarningProc, 0);
    }

    return iRet;
}


// IInstalledApps::Uninstall
STDMETHODIMP CInstalledApp::Uninstall(HWND hwndParent)
{
    HRESULT hres = E_FAIL;

    if (!_IsAppFastUserSwitchingCompliant() && (IDOK != _ShowMultiUserWarning(hwndParent)))
        return hres;

#ifdef WINNT
#ifndef DOWNLEVEL_PLATFORM

    // Default to turn install mode off (1 is off)
    DWORD dwTSInstallMode = 1;
    BOOL bPrevMode = FALSE;
    
    if (IsTerminalServicesRunning())
    {
        // On NT,  let Terminal Services know that we are about to uninstall an application.
        dwTSInstallMode = _QueryTSInstallMode((_dwSource & IA_DARWIN) ? _szProductID : _szKeyName);
        if (dwTSInstallMode == 0)
        {
            bPrevMode = TermsrvAppInstallMode();
            SetTermsrvAppInstallMode(TRUE);
        }
    }
#endif // DOWNLEVEL_PLATFORM
#endif // WINNT
    
    switch (_dwSource)
    {
        case IA_LEGACY:
            if (_LegacyUninstall(hwndParent))
                hres = S_OK;
            break;

        case IA_DARWIN:
        {
            TCHAR   szFinal[512], szPrompt[256];

            LoadString(g_hinst, IDS_CONFIRM_REMOVE, szPrompt, ARRAYSIZE(szPrompt));
            wnsprintf(szFinal, ARRAYSIZE(szFinal), szPrompt, _szProduct);
            if (ShellMessageBox(g_hinst, hwndParent, szFinal, MAKEINTRESOURCE(IDS_NAME),
                                MB_YESNO | MB_ICONQUESTION, _szProduct, _szProduct) == IDYES)
            {
                LONG lRet;
                INSTALLUILEVEL OldUI = MsiSetInternalUI(INSTALLUILEVEL_BASIC, NULL);
                lRet = MsiConfigureProduct(_szProductID, INSTALLLEVEL_DEFAULT, INSTALLSTATE_ABSENT);
                MsiSetInternalUI(OldUI, NULL);
                hres = HRESULT_FROM_WIN32(lRet);


                // Is this an ophaned assigned app? If so, say we succeeded and call
                // Class Store to remove it. 
                // REARCHITECT: This is too Class Store specific, what if the app is from
                // SMS? 
                if ((lRet == ERROR_INSTALL_SOURCE_ABSENT) &&
                    (INSTALLSTATE_ADVERTISED == MsiQueryProductState(_szProductID)))
                {
                    hres = S_OK;
                    lRet = ERROR_SUCCESS;
                }
                
                // Tell the software installation service  we are uninstalling a Darwin app
                // NOTE: We call this function for every Darwin app, which is not right because
                // some darwin apps could be from a different source, such as SMS, we need a better
                // way to do this. 

                // We call this regardless of failure or success -- this is needed so that
                // RSoP can record both success and failure status for this uninstall
                WCHAR wszProductID[GUIDSTR_MAX];
#ifdef UNICODE
                StrCpy(wszProductID, _szProductID);
#else
                SHTCharToUnicode(_szProductID, wszProductID, ARRAYSIZE(wszProductID));
#endif
                UninstallApplication(
                    wszProductID,
                    lRet);
  
                if (FAILED(hres))
                {
                    _ARPErrorMessageBox(lRet);
                }

            }
            else
            {
                hres = E_ABORT;      // works for user cancelled
            }
            break;
        }
        
        case IA_SMS:
            break;

        default:
            break;
    }

    // Get rid of the ARP Cache for this app. 
    if (SUCCEEDED(hres))
    {
        HKEY hkeyARPCache;
        if (ERROR_SUCCESS == RegOpenKey(_MyHkeyRoot(), c_szRegstrARPCache, &hkeyARPCache))
        {
            LPTSTR pszKeyName = (_dwSource & IA_DARWIN) ? _szProductID : _szKeyName;
            SHDeleteKey(hkeyARPCache, pszKeyName);
            RegCloseKey(hkeyARPCache);
        }
    }
    
#ifdef WINNT
#ifndef DOWNLEVEL_PLATFORM
    if (dwTSInstallMode == 0)
        SetTermsrvAppInstallMode(bPrevMode);
#endif // DOWNLEVEL_PLATFORM
#endif // WINNT
    return hres;
}

BOOL CInstalledApp::_LegacyModify(HWND hwndParent)
{
    ASSERT(_dwAction & APPACTION_MODIFY);
    ASSERT(_dwSource & (IA_LEGACY | IA_DARWIN));
//    ASSERT(IS_VALID_STRING_PTR(_szProductID, 39));

    return _CreateAppModifyProcess(hwndParent, CAMP_MODIFY);
}

// IInstalledApps::Modify
STDMETHODIMP CInstalledApp::Modify(HWND hwndParent)
{
    HRESULT hres = E_FAIL;

    if (!_IsAppFastUserSwitchingCompliant() && (IDOK != _ShowMultiUserWarning(hwndParent)))
        return hres;

#ifdef WINNT
#ifndef DOWNLEVEL_PLATFORM
    // On NT,  let Terminal Services know that we are about to modify an application.
    DWORD dwTSInstallMode = _QueryTSInstallMode((_dwSource & IA_DARWIN) ? _szProductID : _szKeyName);
    BOOL bPrevMode = FALSE;
    if (dwTSInstallMode == 0)
    {
        bPrevMode = TermsrvAppInstallMode();
        SetTermsrvAppInstallMode(TRUE);
    }
#endif // DOWNLEVEL_PLATFORM
#endif // WINNT

    if (_dwAction & APPACTION_MODIFY)
    {
        if ((_dwSource & IA_LEGACY) && _LegacyModify(hwndParent))
            hres = S_OK;
        else if (_dwSource & IA_DARWIN)
        {
            // For modify operations we need to use the FULL UI level to give user
            // more choices
            // NOTE: we are currently not setting this back to the original after the
            // modify operation. This seems to be okay with the Darwin guys
            INSTALLUILEVEL OldUI = MsiSetInternalUI(INSTALLUILEVEL_FULL, NULL);
            LONG lRet = MsiConfigureProduct(_szProductID, INSTALLLEVEL_DEFAULT,
                                            INSTALLSTATE_DEFAULT);
            MsiSetInternalUI(OldUI, NULL);
            hres = HRESULT_FROM_WIN32(lRet);
            if (FAILED(hres))
                _ARPErrorMessageBox(lRet);
            else
                _SetSlowAppInfoChanged(NULL, 1);
        }
    }

#ifdef WINNT
#ifndef DOWNLEVEL_PLATFORM
    if (dwTSInstallMode == 0)
        SetTermsrvAppInstallMode(bPrevMode);
#endif // DOWNLEVEL_PLATFORM
#endif // WINNT
    return hres;
}

// Repair Darwin apps. 
LONG CInstalledApp::_DarRepair(BOOL bReinstall)
{
    DWORD dwReinstall;

    dwReinstall = REINSTALLMODE_USERDATA | REINSTALLMODE_MACHINEDATA |
                  REINSTALLMODE_SHORTCUT | REINSTALLMODE_FILEOLDERVERSION |
                  REINSTALLMODE_FILEVERIFY | REINSTALLMODE_PACKAGE;
    
    return MsiReinstallProduct(_szProductID, dwReinstall);
}

// IInstalledApps::Repair 
STDMETHODIMP CInstalledApp::Repair(BOOL bReinstall)
{
    HRESULT hres = E_FAIL;
    if (_dwSource & IA_DARWIN)
    {
        LONG lRet = _DarRepair(bReinstall);
        hres = HRESULT_FROM_WIN32(lRet);
        if (FAILED(hres))
            _ARPErrorMessageBox(lRet);
        else
            _SetSlowAppInfoChanged(NULL, 1);
    }
    
    // don't know how to do SMS stuff

    return hres;
}

// IInstalledApp::Upgrade
STDMETHODIMP CInstalledApp::Upgrade()
{
    HRESULT hres = E_FAIL;
    if ((_dwAction & APPACTION_UPGRADE) && (_dwSource & IA_DARWIN))
    {
        ShellExecute(NULL, NULL, _pszUpdateUrl, NULL, NULL, SW_SHOWDEFAULT);
        hres = S_OK;
        _SetSlowAppInfoChanged(NULL, 1);
    }


    return hres;
}

// IInstalledApp::QueryInterface
HRESULT CInstalledApp::QueryInterface(REFIID riid, LPVOID * ppvOut)
{ 
    static const QITAB qit[] = {
        QITABENT(CInstalledApp, IInstalledApp),                  // IID_IInstalledApp
        QITABENTMULTI(CInstalledApp, IShellApp, IInstalledApp),  // IID_IShellApp
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IInstalledApp::AddRef
ULONG CInstalledApp::AddRef()
{
    InterlockedIncrement(&_cRef);
    TraceAddRef(CInstalledApp, _cRef);
    return _cRef;
}

// IInstalledApp::Release
ULONG CInstalledApp::Release()
{
    InterlockedDecrement(&_cRef);
    TraceRelease(CInstalledApp, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

//
// As of this first release of Windows XP, most applications are 
// not going to be aware of Fast User Switching in the sense that if
// User 'A' is running the application and User 'B' tries to 
// uninstall that application, the application may be damaged.
// To protect against this, we display a warning message informing
// the user of this potential problem.  See function _ShowMultiUserWarning().
// If an application is aware of Fast User Switching, they make that
// indication by setting a registry value in their "Uninstall" key.
// This function queries for that value and returns TRUE/FALSE to indicate
// it's presence.  So that we err on the conservative side, any
// failure to read this value is equivalent to it's absence.
//
BOOL 
CInstalledApp::_IsAppFastUserSwitchingCompliant(
    void
    )
{
    BOOL bCompliant = FALSE;
    HKEY hkey = _OpenUninstallRegKey(KEY_QUERY_VALUE);
    if (NULL != hkey)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD cbData = sizeof(dwValue);
        DWORD dwResult = RegQueryValueEx(hkey, 
                                         TEXT("FastUserSwitchingCompliant"),
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&dwValue,
                                         &cbData);
        if (ERROR_SUCCESS == dwResult)
        {
            if (REG_DWORD == dwType)
            {
                if (1 == dwValue)
                {
                    bCompliant = TRUE;
                }
            }
            else
            {
                TraceMsg(TF_ERROR, "FastUserSwitchingCompliant reg value is invalid type (%d).  Expected REG_DWORD.", dwType);
            }
        }
        else if (ERROR_FILE_NOT_FOUND != dwResult)
        {
            TraceMsg(TF_ERROR, "Error %d reading FastUserSwitchingCompliant reg value.", dwResult);
        }
        RegCloseKey(hkey);
    }
    else
    {
        TraceMsg(TF_ERROR, "Error opening application Uninstall reg key");
    }
    return bCompliant;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc

# This is the list of html and related files packaged in the resource
HTM_FILES = \
            $(O)\arp.css         \
            $(O)\default.hta     \
            $(O)\accel.htc       \
            $(O)\listbox.htc     \
            $(O)\places.htc      \
            $(O)\def_freq.htm    \
            $(O)\def_size.htm    \
            $(O)\support.htm     \
            $(O)\add.js          \
            $(O)\bplate.js       \
            $(O)\config.js       \
            $(O)\dlg.js          \
            $(O)\preload.js      \
            $(O)\remove.js       \
            $(O)\util.js
UI_FILES = \
             $(O)\arp.uipp            \
             $(O)\arpstylestd.uipp    \
             $(O)\arpstyletheme.uipp

OTHER_FILES = \
            ..\adcctl.rgs           \
            ..\carpctl.rgs

..\appwiz.rc : $(OTHER_FILES) $(HTM_FILES) $(UI_FILES) $(SELFREGNAME)

UIPPGEN_FLAGS=/nologo /EP /I$(WINDOWS_INC_PATH)\DUser /DLEGACY_UIPP

$(O)\arp.uipp: ..\arp.ui
    cl $(UIPPGEN_FLAGS) ..\arp.ui > $(O)\arp.uipp

$(O)\arpstylestd.uipp: ..\arpstylestd.ui
    cl $(UIPPGEN_FLAGS) ..\arpstylestd.ui > $(O)\arpstylestd.uipp

$(O)\arpstyletheme.uipp: ..\arpstyletheme.ui
    cl $(UIPPGEN_FLAGS) ..\arpstyletheme.ui > $(O)\arpstyletheme.uipp

#
# Inference rules
#

.SUFFIXES:.js .htc .htm .hta .css .ui

{..\html}.hta{$(O)}.hta:
    cleaninf -w $** $@

{..\html}.htm{$(O)}.htm:
    cleaninf -w $** $@

{..\html}.htc{$(O)}.htc:
    cleaninf -w $** $@

{..\html}.css{$(O)}.css:
    cleaninf -w -htc $** $@

{..\html}.js{$(O)}.js:
    cleaninf -w $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\mtxarray.cpp ===
//+-----------------------------------------------------------------------
//
//  Matrix Array
//
//------------------------------------------------------------------------


#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include <shstr.h>
#include "mtxarray.h"
#include "adcctl.h"         // for EnumArea string constants
#include "util.h"           // for ReleaseShellCategory
#include "dump.h"
#include "appwizid.h"

#ifdef WINNT
#include <tsappcmp.h>       // for TermsrvAppInstallMode
#endif

//--------------------------------------------------------------------
//
//
//  CAppData class
//
//
//--------------------------------------------------------------------

#define MAX_DATE_SIZE   50

#define IFS_APPINFODATA      1
#define IFS_SHELLCAT         2
#define IFS_CAPABILITY       3
#define IFS_SUPPORTINFO      4
#define IFS_INDEXLABEL       5
#define IFS_INDEXVALUE       6
#define IFS_PROPERTIES       7
#define IFS_SIZE             8
#define IFS_TIMESUSED        9
#define IFS_LASTUSED         10
#define IFS_OCSETUP          11
#define IFS_SCHEDULE         12
#define IFS_ICON             13
#define IFS_ISINSTALLED      14


const APPFIELDS g_rginstfields[] = {
    { /* 0 */ L"displayname",       SORT_NAME,      IFS_APPINFODATA, VT_BSTR, FIELD_OFFSET(APPINFODATA, pszDisplayName) },
    { /* 1 */ L"size",              SORT_SIZE,      IFS_SIZE,        VT_BSTR, 0 },
    { /* 2 */ L"timesused",         SORT_TIMESUSED, IFS_TIMESUSED,   VT_BSTR, 0 },
    { /* 3 */ L"lastused",          SORT_LASTUSED,  IFS_LASTUSED,    VT_BSTR, 0 },
    { /* 4 */ L"capability",        SORT_NA,        IFS_CAPABILITY , VT_UI4, 0 },
    { /* 5 */ L"supportinfo",       SORT_NA,        IFS_SUPPORTINFO, VT_BSTR, 0 },
    { /* 6 */ L"indexlabel",        SORT_NA,        IFS_INDEXLABEL,  VT_BSTR, 0 },
    { /* 7 */ L"indexvalue",        SORT_NA,        IFS_INDEXVALUE,  VT_BSTR, 0 },
    { /* 8 */ L"htmlproperties",    SORT_NA,        IFS_PROPERTIES,  VT_BSTR, 0 },  
    { /* 9 */ L"icon",              SORT_NA,        IFS_ICON,        VT_BSTR, 0 },    
};

const APPFIELDS g_rgpubfields[] = {
    { /* 0 */ L"displayname",       SORT_NAME,  IFS_APPINFODATA, VT_BSTR, FIELD_OFFSET(APPINFODATA, pszDisplayName) },
    { /* 1 */ L"capability",        SORT_NA,    IFS_CAPABILITY , VT_UI4, 0 },
    { /* 2 */ L"supporturl",        SORT_NA,    IFS_APPINFODATA, VT_BSTR, FIELD_OFFSET(APPINFODATA, pszSupportUrl) },
    { /* 3 */ L"htmlproperties",    SORT_NA,    IFS_PROPERTIES,  VT_BSTR, 0 },
    { /* 4 */ L"addlaterschedule",  SORT_NA,    IFS_SCHEDULE,    VT_BSTR, 0 },
    { /* 5 */ L"isinstalled",       SORT_NA,    IFS_ISINSTALLED, VT_BSTR, 0 },
};

const APPFIELDS g_rgsetupfields[] = {
    { /* 0 */ L"displayname",       SORT_NAME,  IFS_OCSETUP, VT_BSTR, FIELD_OFFSET(COCSetupApp, _szDisplayName) },
};

const APPFIELDS g_rgcatfields[] = {
    { /* 0 */ L"DisplayName",       SORT_NAME,  IFS_SHELLCAT, VT_BSTR, FIELD_OFFSET(SHELLAPPCATEGORY, pszCategory) },
    { /* 1 */ L"ID",                SORT_NA,    IFS_SHELLCAT, VT_UI4, FIELD_OFFSET(SHELLAPPCATEGORY, idCategory) },
};





// Overloaded constructor
CAppData::CAppData(IInstalledApp* pia, APPINFODATA* paid, PSLOWAPPINFO psai) : _cRef(1)
{
    _pia = pia;
    CopyMemory(&_ai, paid, sizeof(_ai));
    //NOTE: psai can be NULL
    if (psai)
    {
        CopyMemory(&_aiSlow, psai, sizeof(_aiSlow)); 
        
        // Let's massage some values.  
        _MassageSlowAppInfo();
    }
    _dwEnum = ENUM_INSTALLED;
    InitializeCriticalSection(&_cs);
    _fCsInitialized = TRUE;
}

// Overloaded constructor
CAppData::CAppData(IPublishedApp* ppa, APPINFODATA* paid, PUBAPPINFO * ppai) : _cRef(1)
{
    _ppa = ppa;
    CopyMemory(&_ai, paid, sizeof(_ai));
    CopyMemory(&_pai, ppai, sizeof(_pai));
    _dwEnum = ENUM_PUBLISHED;
}

// Overloaded constructor
CAppData::CAppData(COCSetupApp * pocsa, APPINFODATA* paid) : _cRef(1)
{
    _pocsa = pocsa;
    CopyMemory(&_ai, paid, sizeof(_ai));
    _dwEnum = ENUM_OCSETUP;
}

// Overloaded constructor
CAppData::CAppData(SHELLAPPCATEGORY * psac) : _cRef(1)
{
    _psac = psac;
    _dwEnum = ENUM_CATEGORIES;
}

// destructor
CAppData::~CAppData()
{
    if (ENUM_CATEGORIES == _dwEnum)
        ReleaseShellCategory(_psac);
    else if (ENUM_OCSETUP == _dwEnum)
    {
        delete _pocsa;
        ClearAppInfoData(&_ai);
    }
    else
    {
        // Release _pia or _ppa.  Take your pick.  Either way releases
        // the object because both inherit from IUnknown.
        _pia->Release();
        
        ClearAppInfoData(&_ai);
        ClearSlowAppInfo(&_aiSlow);
        ClearPubAppInfo(&_pai);
    }

    if (_fCsInitialized)
        DeleteCriticalSection(&_cs);
}


/*--------------------------------------------------------------------
Purpose: IUnknown::QueryInterface
*/
STDMETHODIMP CAppData::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAppData, IAppData),
        { 0 },
    };

    return QISearch(this, (LPCQITAB)qit, riid, ppvObj);
}


STDMETHODIMP_(ULONG) CAppData::AddRef()
{
    InterlockedIncrement(&_cRef);
    TraceAddRef(CAppData, _cRef);
    return _cRef;
}


STDMETHODIMP_(ULONG) CAppData::Release()
{
    ASSERT(_cRef > 0);
    InterlockedDecrement(&_cRef);

    TraceRelease(CAppData, _cRef);
    
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


/*-------------------------------------------------------------------------
Purpose: Massage some values so they are sorted correctly
*/
void CAppData::_MassageSlowAppInfo(void)
{
    // We don't tell the difference b/t unknown app sizes and zero 
    // app sizes, so to make sorting easier, change the unknown app 
    // size to zero.
    if (-1 == (__int64)_aiSlow.ullSize)
        _aiSlow.ullSize = 0;

    // Unmarked last-used fields will get marked as 'not used', so
    // they are sorted correctly.
    if (0 == _aiSlow.ftLastUsed.dwHighDateTime && 
        0 == _aiSlow.ftLastUsed.dwLowDateTime)
    {
        _aiSlow.ftLastUsed.dwHighDateTime = NOTUSED_HIGHDATETIME;
        _aiSlow.ftLastUsed.dwLowDateTime = NOTUSED_LOWDATETIME;
    }
}


/*-------------------------------------------------------------------------
Purpose: IAppData::ReadSlowData

         Read the slow app data.  Call GetSlowDataPtr() to get it.
*/
STDMETHODIMP CAppData::ReadSlowData(void)
{
    HRESULT hres = E_FAIL;
    
    if (ENUM_INSTALLED == _dwEnum && _pia)
    {
        SLOWAPPINFO sai = {0};
        hres = _pia->GetSlowAppInfo(&sai);
      
        if (S_OK == hres)
        {
            // Switch our current SLOWAPPINFO with the new one
            // This is necessary because our current one is from the GetCachedSlowAppInfo
            // It may not have the most up-to-date info.
            if (IsSlowAppInfoChanged(&_aiSlow, &sai))
            {
                EnterCriticalSection(&_cs);
                {
                    ClearSlowAppInfo(&_aiSlow);
                    _aiSlow = sai;
                    hres = S_OK;
                }
                LeaveCriticalSection(&_cs);

                // Let's massage some values.  
                _MassageSlowAppInfo();
            }
            else
                hres = S_FALSE;
        }        
    }

    return hres;
}


/*-------------------------------------------------------------------------
Purpose: IAppData::GetDataPtr

         Returns the pointer to the internal data structure.  The
         caller must hold the appdata object to guarantee the pointer
         remains valid.
*/
STDMETHODIMP_(APPINFODATA *) CAppData::GetDataPtr(void)
{
    return &_ai;
}


/*-------------------------------------------------------------------------
Purpose: IAppData::GetSlowDataPtr

         Returns the pointer to the internal data structure for slow
         data.  The caller must hold the appdata object to guarantee the 
         pointer remains valid.
*/
STDMETHODIMP_(SLOWAPPINFO *) CAppData::GetSlowDataPtr(void)
{
    return &_aiSlow;
}


/*-------------------------------------------------------------------------
Purpose: Return the capability flags
*/
DWORD CAppData::_GetCapability(void)
{
    DWORD dwCapability = 0;
    
    if (ENUM_INSTALLED == _dwEnum || ENUM_PUBLISHED == _dwEnum)
    {
        // We can use _pia or _ppa for this method because both
        // inherit from IShellApp.
        _pia->GetPossibleActions(&dwCapability);
    }
    
    return dwCapability;
}


/*-------------------------------------------------------------------------
Purpose: Returns the current sort index
*/
DWORD CAppData::_GetSortIndex(void)
{
    DWORD dwRet = SORT_NAME;        // default
    
    if (_pmtxParent)
        _pmtxParent->GetSortIndex(&dwRet);

    return dwRet;
}


/*-------------------------------------------------------------------------
Purpose: Return the amount of disk space the app occupies.  

         Returns S_OK if the field is valid.
*/
HRESULT CAppData::_GetDiskSize(LPTSTR pszBuf, int cchBuf)
{
    HRESULT hres = S_FALSE;
    ULONGLONG ullSize = GetSlowDataPtr()->ullSize;

    if (pszBuf && 0 < cchBuf)
        *pszBuf = 0;

    // Is this size printable?
    if (-1 != (__int64)ullSize && 0 != (__int64)ullSize)
    {
        // Yes
        if (pszBuf)
            ShortSizeFormat64(ullSize, pszBuf);
        hres = S_OK;
    }

    return hres;
}


#define FREQDECAY_OFTEN     10


/*-------------------------------------------------------------------------
Purpose: IAppData::GetFrequencyOfUse

         Return friendly names that map from the frequency-of-use
         metric from the UEM.  Returns S_OK if the field is valid.
*/
STDMETHODIMP CAppData::GetFrequencyOfUse(LPTSTR pszBuf, int cchBuf)
{
    HRESULT hres;
    int iTemp = GetSlowDataPtr()->iTimesUsed;
    
    if (0 > iTemp)
    {
        if (pszBuf && 0 < cchBuf)
            *pszBuf = 0;
        hres = S_FALSE;
    }    
    else
    {
        UINT ids = IDS_OFTEN;
        
        if (2 >= iTemp)
            ids = IDS_RARELY;
        else if (FREQDECAY_OFTEN >= iTemp)
            ids = IDS_SOMETIMES;

        if (pszBuf)
            LoadString(g_hinst, ids, pszBuf, cchBuf);
            
        hres = S_OK;
    }        
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: Return the friendly date when the app was last used.

         Returns S_OK if the field is valid.
*/
HRESULT CAppData::_GetLastUsed(LPTSTR pszBuf, int cchBuf)
{
    HRESULT hres;
    FILETIME ft = GetSlowDataPtr()->ftLastUsed;
    
    if (NOTUSED_HIGHDATETIME == ft.dwHighDateTime && 
        NOTUSED_LOWDATETIME == ft.dwLowDateTime)
    {
        if (pszBuf && 0 < cchBuf)
            *pszBuf = 0;
        hres = S_FALSE;
    }
    else
    {
        DWORD dwFlags = FDTF_SHORTDATE;
        
        ASSERT(0 != ft.dwHighDateTime || 0 != ft.dwLowDateTime);
        
        if (pszBuf)
            SHFormatDateTime(&ft, &dwFlags, pszBuf, cchBuf);
        hres = S_OK;
    }
    
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: Build up a structured string that the html script can read and
         parse.  The Boilerplate JavaScript class assumes the fields
         follow this format:

         <fieldname1 "value1"><fieldname2 value2>...

         It can accept quoted or non-quoted values.  If the value has a '>' in
         it, then it should be quoted, otherwise the Boilerplate code will 
         get confused.

         The order of the fieldnames is not important, and some or all may
         be missing.
*/
LPTSTR CAppData::_BuildSupportInfo(void)
{
    const static struct 
    {
        LPWSTR pszFieldname;
        DWORD ibOffset;        // offset into structure designated by dwStruct
    } s_rgsupfld[] = {
        { L"comments",      FIELD_OFFSET(APPINFODATA, pszComments) }, 
        { L"contact",       FIELD_OFFSET(APPINFODATA, pszContact) },
        { L"displayname",   FIELD_OFFSET(APPINFODATA, pszDisplayName) },
        { L"helpurl",       FIELD_OFFSET(APPINFODATA, pszHelpLink) },
        { L"helpphone",     FIELD_OFFSET(APPINFODATA, pszSupportTelephone) },
        { L"productID",     FIELD_OFFSET(APPINFODATA, pszProductID) },
        { L"publisher",     FIELD_OFFSET(APPINFODATA, pszPublisher) },
        { L"readmeUrl",     FIELD_OFFSET(APPINFODATA, pszReadmeUrl) },
        { L"regcompany",    FIELD_OFFSET(APPINFODATA, pszRegisteredCompany) },
        { L"regowner",      FIELD_OFFSET(APPINFODATA, pszRegisteredOwner) },
        { L"supporturl",    FIELD_OFFSET(APPINFODATA, pszSupportUrl) },
        { L"updateinfoUrl", FIELD_OFFSET(APPINFODATA, pszUpdateInfoUrl) },
        { L"version",       FIELD_OFFSET(APPINFODATA, pszVersion) },
    };

    ShStr shstr;
    int i;

    // Now populate the structured string
    for (i = 0; i < ARRAYSIZE(s_rgsupfld); i++)
    {
        LPWSTR pszT = *(LPWSTR *)((LPBYTE)&_ai + s_rgsupfld[i].ibOffset);
        if (pszT && *pszT)
        {
            TCHAR sz[64];

            wsprintf(sz, TEXT("<%s \""), s_rgsupfld[i].pszFieldname);
            shstr.Append(sz);
            shstr.Append(pszT);
            shstr.Append(TEXT("\">"));
        }
    }

    return shstr.CloneStr();
}


#define c_szPropRowBegin    TEXT("<TR><TD class=PropLabel>")
#define c_szPropRowMid      TEXT("</TD><TD class=PropValue>")
#define c_szPropRowEnd      TEXT("</TD></TR>")

// CAppData::_BuildPropertiesHTML
//      Build up a string of HTML that represents the list of useful 
//      properties for this app.  We skip any blank fields.  

LPTSTR CAppData::_BuildPropertiesHTML(void)
{
    LPTSTR pszRet = NULL;
    DWORD dwSort = _GetSortIndex();

    // The HTML consists of a table, each row is a property label and value.
    // Since the 'indexlabel' and 'indexvalue' properties vary depending
    // on the sort criteria, we exclude them to avoid duplication.  For 
    // example, if the user is sorting by size, we don't show the size
    // in the properties HTML because the size is being shown via the
    // 'indexvalue' property.

    // Let's first make a pass of the eligible properties to see which
    // ones to include.

    #define PM_SIZE         0x0001
    #define PM_TIMESUSED    0x0002
    #define PM_LASTUSED     0x0004
    #define PM_INSTALLEDON  0x0008

    TCHAR szSize[64];
    TCHAR szFreq[64];
    TCHAR szLastUsed[64];
    DWORD dwPropMask = 0;       // Can be combination of PM_*
    
    dwPropMask |= (S_OK == _GetDiskSize(szSize, SIZECHARS(szSize))) ? PM_SIZE : 0;
    dwPropMask |= (S_OK == GetFrequencyOfUse(szFreq, SIZECHARS(szFreq))) ? PM_TIMESUSED : 0;
    dwPropMask |= (S_OK == _GetLastUsed(szLastUsed, SIZECHARS(szLastUsed))) ? PM_LASTUSED : 0;

    // The sorting criteria should be removed
    if (SORT_NAME == dwSort || SORT_SIZE == dwSort)
        dwPropMask &= ~PM_SIZE;
    else if (SORT_TIMESUSED == dwSort)
        dwPropMask &= ~PM_TIMESUSED;
    else if (SORT_LASTUSED == dwSort)
        dwPropMask &= ~PM_LASTUSED;

    // Are there any properties to show at all?
    if (dwPropMask)
    {
        // Yes; build the html for the table.
        ShStr shstr;
        TCHAR szLabel[64];

        shstr = TEXT("<TABLE id=idTblExtendedProps class=Focus>");

        struct {
            DWORD dwMask;
            UINT  ids;
            LPTSTR psz;
        } s_rgProp[] = {
            { PM_SIZE, IDS_LABEL_SIZE, szSize },
            { PM_TIMESUSED, IDS_LABEL_TIMESUSED, szFreq },
            { PM_LASTUSED, IDS_LABEL_LASTUSED, szLastUsed },
        };

        int i;

        for (i = 0; i < ARRAYSIZE(s_rgProp); i++)
        {
            if (dwPropMask & s_rgProp[i].dwMask)
            {
                LoadString(g_hinst, s_rgProp[i].ids, szLabel, SIZECHARS(szLabel));
                
                shstr.Append(c_szPropRowBegin);
                shstr.Append(szLabel);
                shstr.Append(c_szPropRowMid);

                // Size and frequency-of-use get anchor elements around them...
                if (s_rgProp[i].dwMask & PM_TIMESUSED)
                    shstr.Append(TEXT("<SPAN id=idAFrequency class='FakeAnchor' tabIndex=0 onKeyDown='_OnKeyDownFakeAnchor()' onClick='_OpenDefinition();'>&nbsp;<U>"));
                else if (s_rgProp[i].dwMask & PM_SIZE)
                    shstr.Append(TEXT("<SPAN id=idASize class='FakeAnchor' tabIndex=0 onKeyDown='_OnKeyDownFakeAnchor()' onClick='_OpenDefinition();'>&nbsp;<U>"));
                
                shstr.Append(s_rgProp[i].psz);

                if (s_rgProp[i].dwMask & PM_TIMESUSED)
                    shstr.Append(TEXT("</U></SPAN>"));
                else if (s_rgProp[i].dwMask & PM_SIZE)
                    shstr.Append(TEXT("</U></SPAN>"));
                    
                shstr.Append(c_szPropRowEnd);
            }
        }

        shstr.Append(TEXT("</TABLE>"));

        pszRet = shstr.CloneStr();  // clone for the caller
    }

    return pszRet;
}

#define c_szIconHTMLFormat TEXT("sysimage://%s/small")

/*-------------------------------------------------------------------------
Purpose: Return the HTML that points to the icon of this application 
         use instshld.ico as a default
*/
void CAppData::_GetIconHTML(LPTSTR pszIconHTML, UINT cch)
{
    if (cch > (MAX_PATH + ARRAYSIZE(c_szIconHTMLFormat)))
    {
        TCHAR szImage[MAX_PATH+10];

        if (_ai.pszImage && _ai.pszImage[0])
        {
            StrCpyN(szImage, _ai.pszImage, ARRAYSIZE(szImage));
            //PathParseIconLocation(szImage);
        }
        else
        {
            BOOL bUseDefault = FALSE;
            EnterCriticalSection(&_cs);        
            if (_aiSlow.pszImage && _aiSlow.pszImage[0])
                lstrcpy(szImage, _aiSlow.pszImage);
            else
                bUseDefault = TRUE;
            LeaveCriticalSection(&_cs);

            if (bUseDefault)
                goto DEFAULT;
        }

        wnsprintf(pszIconHTML, cch, c_szIconHTMLFormat, szImage);
    }
    else
DEFAULT:
        // In the default case, return instshld.ico
        lstrcpy(pszIconHTML, TEXT("res://appwiz.cpl/instshld.ico"));
}

/*-------------------------------------------------------------------------
Purpose: Sets the variant with the correct data given the field
*/
HRESULT CAppData::_VariantFromData(const APPFIELDS * pfield, LPVOID pvData, VARIANT * pvar)
{
    HRESULT hres = S_OK;

    VariantInit(pvar);
    
    if (pvData)
    {
        if (VT_BSTR == pfield->vt)
        {
            LPWSTR psz = *(LPWSTR*)pvData;
            if (NULL == psz)
                psz = L"";

            ASSERT(IS_VALID_STRING_PTR(psz, -1));

            pvar->bstrVal = SysAllocString(psz);
            if (pvar->bstrVal)
                pvar->vt = VT_BSTR;
            else
                hres = E_OUTOFMEMORY;
        }
        else if (VT_UI4 == pfield->vt)
        {
            pvar->lVal = *(LONG*)pvData;
            pvar->vt = pfield->vt;
        }
    }
    
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: Get the value of the installed-app field.
*/
HRESULT CAppData::_GetInstField(DB_LORDINAL iField, VARIANT * pvar)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_WRITE_PTR(pvar, VARIANT));
    ASSERT(ENUM_INSTALLED == _dwEnum);
    
    // Columns map to different fields.

    if (IsInRange(iField, 0, ARRAYSIZE(g_rginstfields)))
    {
        const APPFIELDS * pfield = &g_rginstfields[iField];
        LPVOID pvData = NULL;       // assume no value
        TCHAR szTemp[MAX_PATH*2];
        LPCTSTR pszTmp;
        DWORD dwTemp;

        // Map the field ordinal to the actual value in the appropriate structure
        switch (pfield->dwStruct)
        {
        case IFS_APPINFODATA:
            pvData = (LPVOID)((LPBYTE)&_ai + pfield->ibOffset);
            break;

        case IFS_CAPABILITY:
            dwTemp = _GetCapability();
            pvData = (LPVOID) &dwTemp;
            break;

        case IFS_SUPPORTINFO:
            pszTmp = CAppData::_BuildSupportInfo();
            if (pszTmp)
            {
                TraceMsg(TF_VERBOSEDSO, "HTML (supportinfo): \"%s\"", pszTmp);
                pvData = (LPVOID) &pszTmp;
            }
            break;

        case IFS_SIZE:
            _GetDiskSize(szTemp, SIZECHARS(szTemp));
            pszTmp = szTemp;
            pvData = (LPVOID) &pszTmp;
            break;

        case IFS_TIMESUSED:
            GetFrequencyOfUse(szTemp, SIZECHARS(szTemp));
            pszTmp = szTemp;
            pvData = (LPVOID) &pszTmp;
            break;

        case IFS_LASTUSED:
            _GetLastUsed(szTemp, SIZECHARS(szTemp));
            pszTmp = szTemp;
            pvData = (LPVOID) &pszTmp;
            break;
            
        case IFS_INDEXLABEL:
            // Unknown values shouldn't show the labels, so assume the
            // value will be unknown
            dwTemp = 0;
            
            // The index label is according to the current sort criteria
            switch (_GetSortIndex())
            {
            case SORT_NAME:     // when sorting by name, we show the size
            case SORT_SIZE:
                if (S_OK == _GetDiskSize(NULL, 0))
                    dwTemp = IDS_LABEL_SIZE;
                break;

            case SORT_TIMESUSED:
                if (S_OK == GetFrequencyOfUse(NULL, 0))
                    dwTemp = IDS_LABEL_TIMESUSED;
                break;

            case SORT_LASTUSED:
                if (S_OK == _GetLastUsed(NULL, 0))
                    dwTemp = IDS_LABEL_LASTUSED;
                break;
            }

            if (0 != dwTemp)
            {
                LoadString(g_hinst, dwTemp, szTemp, SIZECHARS(szTemp));
                pszTmp = szTemp;
                pvData = (LPVOID) &pszTmp;

                TraceMsg(TF_VERBOSEDSO, "HTML (indexlabel): \"%s\"", pszTmp);
            }
            break;

        case IFS_INDEXVALUE:
            // The index value is according to the current sort criteria
            switch (_GetSortIndex())
            {
            case SORT_NAME:     // when sorting by name, we show the size
            case SORT_SIZE:
                _GetDiskSize(szTemp, SIZECHARS(szTemp));
                break;

            case SORT_TIMESUSED:
                GetFrequencyOfUse(szTemp, SIZECHARS(szTemp));
                break;

            case SORT_LASTUSED:
                _GetLastUsed(szTemp, SIZECHARS(szTemp));
                break;
            }
            
            pszTmp = szTemp;
            pvData = (LPVOID) &pszTmp;

            TraceMsg(TF_VERBOSEDSO, "HTML (indexvalue) for %s: \"%s\"", GetDataPtr()->pszDisplayName, pszTmp);
            break;

        case IFS_PROPERTIES:
            pszTmp = _BuildPropertiesHTML();
            if (pszTmp)
            {
                pvData = (LPVOID) &pszTmp;
                TraceMsg(TF_VERBOSEDSO, "HTML (properties) for %s: \"%s\"", GetDataPtr()->pszDisplayName, pszTmp);
            }
            break;

        case IFS_ICON:
            _GetIconHTML(szTemp, ARRAYSIZE(szTemp));
            pszTmp = szTemp;
            pvData = (LPVOID) &pszTmp;
            TraceMsg(TF_VERBOSEDSO, "Icon HTML for %s: \"%s\"", GetDataPtr()->pszDisplayName, pszTmp);
            break;
            
        default:
            ASSERTMSG(0, "invalid field type");
            break;
        }

        hres = _VariantFromData(pfield, pvData, pvar);

        // Clean up
        switch (pfield->dwStruct)
        {
        case IFS_SUPPORTINFO:
        case IFS_PROPERTIES:
            if (pvData)
            {
                pszTmp = *(LPWSTR*)pvData;
                LocalFree((HLOCAL)pszTmp);
            }
            break;
        }
    }
    return hres;
}


#define c_szAddLaterHTML TEXT("<TABLE id=idTblExtendedProps class=Focus><TR><TD class=AddPropLabel>%s</TD><TD class=AddPropValue><A id=idASchedule class=Focus href=''>%s</A></TD></TR></TABLE>")


/*-------------------------------------------------------------------------
Purpose: Get the value of the published app field.
*/
HRESULT CAppData::_GetPubField(DB_LORDINAL iField, VARIANT * pvar)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_WRITE_PTR(pvar, VARIANT));
    ASSERT(ENUM_PUBLISHED == _dwEnum);
    
    // Columns map to different fields.

    if (IsInRange(iField, 0, ARRAYSIZE(g_rgpubfields)))
    {
        DWORD dwTemp = 0;
        const APPFIELDS * pfield = &g_rgpubfields[iField];
        LPVOID pvData = NULL;
        WCHAR szTemp[MAX_PATH*2];
        LPWSTR pszTmp = NULL;        
        // Map the field ordinal to the actual value in the appropriate structure
        switch (pfield->dwStruct)
        {
            case IFS_APPINFODATA:
                // For the display name, we want to display it in the following format if there are 
                // duplicate entries: Ex "Word : Policy1" and "Word : Policy2"
                if ((iField == 0) && _bNameDupe && (_pai.dwMask & PAI_SOURCE) && _pai.pszSource && _pai.pszSource[0])
                {
                    wnsprintf(szTemp, ARRAYSIZE(szTemp), L"%ls: %ls", _ai.pszDisplayName, _pai.pszSource);
                    pszTmp = szTemp;
                    pvData = (LPVOID) &pszTmp;
                }
                else
                    pvData = (LPVOID)((LPBYTE)&_ai + pfield->ibOffset);
                break;

        case IFS_CAPABILITY:
            dwTemp = _GetCapability();
            pvData = (LPVOID) &dwTemp;
            break;

        case IFS_SCHEDULE:
            if ((_GetCapability() & APPACTION_ADDLATER) && (_pai.dwMask & PAI_SCHEDULEDTIME))
            {
                TCHAR szTime[MAX_PATH];
                if (FormatSystemTimeString(&_pai.stScheduled, szTime, ARRAYSIZE(szTime)))
                {
                    TCHAR szAddLater[100];
                    LoadString(g_hinst, IDS_ADDLATER, szAddLater, ARRAYSIZE(szAddLater));           

                    wsprintf(szTemp, c_szAddLaterHTML, szAddLater, szTime);
                    pszTmp = szTemp;
                    pvData = (LPVOID) &pszTmp;
                }
            }
            break;

        case IFS_ISINSTALLED:
            if (S_OK == _ppa->IsInstalled())
            {
                LoadString(g_hinst, IDS_INSTALLED, szTemp, SIZECHARS(szTemp));
                pszTmp = szTemp;
                pvData = (LPVOID) &pszTmp;
            }
            break;
                
        default:
            ASSERTMSG(0, "invalid field type");
            hres = E_FAIL;
            break;
        }

        hres = _VariantFromData(pfield, pvData, pvar);
    }
    return hres;
}

/*-------------------------------------------------------------------------
Purpose: Get the value of the ocsetup app field.
*/
HRESULT CAppData::_GetSetupField(DB_LORDINAL iField, VARIANT * pvar)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_WRITE_PTR(pvar, VARIANT));
    ASSERT(ENUM_OCSETUP == _dwEnum);
    
    // Columns map to different fields.

    if (IsInRange(iField, 0, ARRAYSIZE(g_rgsetupfields)))
    {
        const APPFIELDS * pfield = &g_rgsetupfields[iField];
        LPVOID pvData = NULL;

        ASSERT(IFS_OCSETUP == pfield->dwStruct);

        pvData = (LPVOID)((LPBYTE)&_pocsa + pfield->ibOffset);

        hres = _VariantFromData(pfield, pvData, pvar);
    }
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: Get the value of the category field.
*/
HRESULT CAppData::_GetCatField(DB_LORDINAL iField, VARIANT * pvar)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_WRITE_PTR(pvar, VARIANT));
    ASSERT(ENUM_CATEGORIES == _dwEnum);
    
    // Columns map to different fields.

    if (IsInRange(iField, 0, ARRAYSIZE(g_rgcatfields)))
    {
        const APPFIELDS * pfield = &g_rgcatfields[iField];
        LPVOID pvData = NULL;

        ASSERT(IFS_SHELLCAT == pfield->dwStruct);

        pvData = (LPVOID)((LPBYTE)_psac + pfield->ibOffset);

        hres = _VariantFromData(pfield, pvData, pvar);
    }
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: IAppData::GetVariant

         Return the particular field as a variant.  The caller is responsible
         for clearing/freeing the variant.  The iField is assumed to be
         0-based.  
*/
STDMETHODIMP CAppData::GetVariant(DB_LORDINAL iField, VARIANT * pvar)
{
    HRESULT hres;

    switch (_dwEnum)
    {
    case ENUM_INSTALLED:
        hres = _GetInstField(iField, pvar);
        break;

    case ENUM_PUBLISHED:
        hres = _GetPubField(iField, pvar);
        break;

    case ENUM_OCSETUP:
        hres = _GetSetupField(iField, pvar);
        break;

    case ENUM_CATEGORIES:
        hres = _GetCatField(iField, pvar);
        break;
    }
    
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: IAppData::SetMtxParent
*/
STDMETHODIMP CAppData::SetMtxParent(IMtxArray * pmtxParent)
{
    // We don't AddRef because this appdata object lives within the
    // lifetime of the matrix object.
    
    _pmtxParent = pmtxParent;
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IAppData::DoCommand

         Executes the given command depending on the capabilities
         of the item.
*/
STDMETHODIMP CAppData::DoCommand(HWND hwndParent, APPCMD appcmd)
{
    HRESULT hres = S_FALSE;
    DWORD dwActions = 0;

    switch (_dwEnum)
    {
    case ENUM_INSTALLED:
       
        // Find out of the requested command is allowed
        // FEATURE (scotth): need to add policies check here
        _pia->GetPossibleActions(&dwActions);

        switch (appcmd)
        {
        case APPCMD_UNINSTALL:
            if (g_dwPrototype & PF_FAKEUNINSTALL)
            {
                // Say the app was deleted (this is optimized out in retail)
                hres = S_OK;
            }
            else
            {
                if (dwActions & APPACTION_UNINSTALL)
                {
                    hres = _pia->Uninstall(hwndParent);
                    if (SUCCEEDED(hres))
                    {
                        // Return S_FALSE if the app is still installed (the user
                        // might have cancelled the uninstall)
                        hres = (S_OK == _pia->IsInstalled()) ? S_FALSE : S_OK;
                    }
                }
            }
            break;

        case APPCMD_MODIFY:
            if (dwActions & APPACTION_MODIFY)
                hres = _pia->Modify(hwndParent);
            break;

        case APPCMD_REPAIR:
            if (dwActions & APPACTION_REPAIR)
                hres = _pia->Repair(TRUE);       
            break;

        case APPCMD_UPGRADE:
            if (dwActions & APPACTION_UPGRADE)
                hres = _pia->Upgrade();
            break;

        default:
            TraceMsg(TF_ERROR, "(Ctl) invalid appcmd %s", Dbg_GetAppCmd(appcmd)); 
            break;
        }
        break;

    case ENUM_PUBLISHED:
        // Find out of the requested command is allowed
        // FEATURE (scotth): need to add policies check here
        _ppa->GetPossibleActions(&dwActions);

        switch (appcmd)
        {
        case APPCMD_INSTALL:
            if (dwActions & APPACTION_INSTALL)
            {
                hres = S_OK;
                // Does the app have an expired publishing time?
                if (_pai.dwMask & PAI_EXPIRETIME)
                {
                    // Yes, it does. Let's compare the expired time with our current time
                    SYSTEMTIME stCur = {0};
                    GetLocalTime(&stCur);

                    // Is "now" later than the expired time?
                    if (CompareSystemTime(&stCur, &_pai.stExpire) > 0)
                    {
                        // Yes, warn the user and return failure
                        ShellMessageBox(g_hinst, hwndParent, MAKEINTRESOURCE(IDS_EXPIRED),
                                        MAKEINTRESOURCE(IDS_NAME), MB_OK | MB_ICONEXCLAMATION);
                        hres = E_FAIL;
                    }
                }

                // if hres is not set by the above code, preceed with installation
                if (hres == S_OK)
                {
                    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
#ifdef WINNT
                    // On NT,  let Terminal Services know that we are about to install an application.
                    // NOTE: This function should be called no matter the Terminal Services
                    // is running or not.
                    BOOL bPrevMode = TermsrvAppInstallMode();
                    SetTermsrvAppInstallMode(TRUE);
#endif
                    hres = _ppa->Install(NULL);
#ifdef WINNT
                    SetTermsrvAppInstallMode(bPrevMode);
#endif
                    SetCursor(hcur);
                }
            }
            break;

        case APPCMD_ADDLATER:
            if (dwActions & APPACTION_ADDLATER)
            {
                ADDLATERDATA ald = {0};
                        
                if (_pai.dwMask & PAI_SCHEDULEDTIME)
                {
                    ald.stSchedule = _pai.stScheduled;
                    ald.dwMasks |= ALD_SCHEDULE;
                }

                if (_pai.dwMask & PAI_ASSIGNEDTIME)
                {
                    ald.stAssigned = _pai.stAssigned;
                    ald.dwMasks |= ALD_ASSIGNED;
                }
                
                if (_pai.dwMask & PAI_EXPIRETIME)
                {
                    ald.stExpire = _pai.stExpire;
                    ald.dwMasks |= ALD_EXPIRE;
                }
                
                if (GetNewInstallTime(hwndParent, &ald))
                {
                    if (ald.dwMasks & ALD_SCHEDULE)
                        hres = _ppa->Install(&ald.stSchedule);
                    else
                        hres = _ppa->Unschedule();
                }
            }
        default:
            TraceMsg(TF_ERROR, "(Ctl) invalid appcmd %s", Dbg_GetAppCmd(appcmd)); 
            break;
        }
        break;

    case ENUM_OCSETUP:
        switch (appcmd)
        {
        case APPCMD_INSTALL:
            // call some command that "installs" the selected item.
            _pocsa->Run();
            hres = S_OK;
            break;

        default:
            TraceMsg(TF_ERROR, "(Ctl) invalid appcmd %s", Dbg_GetAppCmd(appcmd)); 
            break;
        }
        break;

    case ENUM_CATEGORIES:
        TraceMsg(TF_WARNING, "(Ctl) tried to exec appcmd %s on a category.  Not supported.", Dbg_GetAppCmd(appcmd));
        break;
    }

    return hres;
}



//---------------------------------------------------------------------------
//   Matrix Array class
//---------------------------------------------------------------------------


// constructor
CMtxArray2::CMtxArray2()
{
    ASSERT(NULL == _hdpa);
    ASSERT(0 == _cRefLock);

    TraceMsg(TF_OBJLIFE, "(MtxArray) creating");
    
    InitializeCriticalSection(&_cs);
}


// destructor
CMtxArray2::~CMtxArray2()
{
    DBROWCOUNT cItems;
    
    ASSERT(0 == _cRefLock);

    TraceMsg(TF_OBJLIFE, "(MtxArray) destroying");

    GetItemCount(&cItems);
    DeleteItems(0, cItems);
    if (_hdpa)
        DPA_Destroy(_hdpa);
    
    DeleteCriticalSection(&_cs);
}


/*--------------------------------------------------------------------
Purpose: IUnknown::QueryInterface
*/
STDMETHODIMP CMtxArray2::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMtxArray2, IMtxArray),
        { 0 },
    };

    HRESULT hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);
    if (FAILED(hres))
        hres = CWorkerThread::QueryInterface(riid, ppvObj);

    return hres;
}


void CMtxArray2::_Lock(void)
{
    EnterCriticalSection(&_cs);
    DEBUG_CODE( _cRefLock++; )
}

void CMtxArray2::_Unlock(void)
{
    DEBUG_CODE( _cRefLock--; )
    LeaveCriticalSection(&_cs);
}


/*-------------------------------------------------------------------------
Purpose: Create array 
*/
HRESULT CMtxArray2::_CreateArray(void)
{
    _Lock();
    if (NULL == _hdpa)
        _hdpa = DPA_Create(8);
    _Unlock();
    
    return _hdpa ? S_OK : E_OUTOFMEMORY;
}


HRESULT CMtxArray2::_DeleteItem(DBROWCOUNT idpa)
{
    // The caller must enter the lock first
    ASSERT(0 < _cRefLock);
    ASSERT(_hdpa);

    IAppData * pappdata = (IAppData *)DPA_GetPtr(_hdpa, (LONG)idpa);
    if (pappdata)
        pappdata->Release();
        
    DPA_DeletePtr(_hdpa, (LONG)idpa);
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IMtxArray::Initialize
*/
STDMETHODIMP CMtxArray2::Initialize(DWORD dwEnum)
{
    _dwEnum = dwEnum;
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IMtxArray::AddItem

         Add an item to the array

         Returns the row in which the record was added (0-based).
*/
STDMETHODIMP CMtxArray2::AddItem(IAppData * pappdata, DBROWCOUNT * piRow)
{
    HRESULT hres = E_FAIL;

    ASSERT(pappdata);
    ASSERT(NULL == piRow || IS_VALID_WRITE_PTR(piRow, DBROWCOUNT));
    
    hres = _CreateArray();
    if (SUCCEEDED(hres))
    {
        _Lock();
        {
            pappdata->AddRef();     // AddRef since we're storing it away
            
            LONG iRow = DPA_AppendPtr(_hdpa, pappdata);
            if (DPA_ERR != iRow)
            {
                DEBUG_CODE( TraceMsg(TF_DSO, "(CMtxArray) added record %d", iRow); )
                pappdata->SetMtxParent(SAFECAST(this, IMtxArray *));
                hres = S_OK;
            }
            else
            {
                pappdata->Release();
                hres = E_OUTOFMEMORY;
                iRow = -1;
            }

            if (piRow)
                *piRow = iRow;
        }
        _Unlock();
    }    
    return hres;
}

/*-------------------------------------------------------------------------
Purpose: IMtxArray::DeleteItems

         Delete a group of records (count of cRows) starting at iRow.

         Assumes iRow is 0-based.
*/
STDMETHODIMP CMtxArray2::DeleteItems(DBROWCOUNT idpa, DBROWCOUNT cdpa)
{
    DBROWCOUNT i;

    if (_hdpa)
    {
        _Lock();
        {
            ASSERT(IS_VALID_HANDLE(_hdpa, DPA));
            ASSERT(IsInRange(idpa, 0, DPA_GetPtrCount(_hdpa)));

            for (i = idpa + cdpa - 1; i >= idpa; i--)
            {
                _DeleteItem(i);
            }
        }
        _Unlock();
    }

    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IMtxArray::GetAppData

         Return a pointer to the appdata element of the given row.  The
         caller must Release the returned appdata.
*/
STDMETHODIMP CMtxArray2::GetAppData(DBROWCOUNT iRow, IAppData ** ppappdata)
{
    HRESULT hres = E_FAIL;
    IAppData * pappdata = NULL;
    
    if (_hdpa)
    {
        _Lock();
        pappdata = (IAppData *)DPA_GetPtr(_hdpa, iRow);
        if (pappdata)
        {
            pappdata->AddRef(); 
            hres = S_OK;
        }
        _Unlock();
    }

    *ppappdata = pappdata;

    return hres;
}

/*-------------------------------------------------------------------------
Purpose: IMtxArray::GetItemCount

         Return the count of items in the array.
*/
STDMETHODIMP CMtxArray2::GetItemCount(DBROWCOUNT * pcItems)
{
    if (_hdpa)
        *pcItems = DPA_GetPtrCount(_hdpa);
    else
        *pcItems = 0;

    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IMtxArray::GetFieldCount

         Return the count of fields based upon what we are enumerating.
*/
STDMETHODIMP CMtxArray2::GetFieldCount(DB_LORDINAL * pcFields)
{
    DB_LORDINAL lRet = 0;

    switch (_dwEnum)
    {
    case ENUM_INSTALLED:
        lRet = ARRAYSIZE(g_rginstfields);
        break;

    case ENUM_PUBLISHED:
        lRet = ARRAYSIZE(g_rgpubfields);
        break;

    case ENUM_OCSETUP:
        lRet = ARRAYSIZE(g_rgsetupfields);
        break;

    case ENUM_CATEGORIES:
        lRet = ARRAYSIZE(g_rgcatfields);
        break;
    }

    *pcFields = lRet;
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IMtxArray::GetFieldName

         Return the field name.
*/
STDMETHODIMP CMtxArray2::GetFieldName(DB_LORDINAL iField, VARIANT * pvar)
{
    HRESULT hres = E_INVALIDARG;
    DB_LORDINAL cfields = 0;
    const APPFIELDS *rgfield;
    
    VariantInit(pvar);

    switch (_dwEnum)
    {
    case ENUM_INSTALLED:
        cfields = ARRAYSIZE(g_rginstfields);
        rgfield = g_rginstfields;
        break;

    case ENUM_PUBLISHED:
        cfields = ARRAYSIZE(g_rgpubfields);
        rgfield = g_rgpubfields;
        break;

    case ENUM_OCSETUP:
        cfields = ARRAYSIZE(g_rgsetupfields);
        rgfield = g_rgsetupfields;
        break;

    case ENUM_CATEGORIES:
        cfields = ARRAYSIZE(g_rgcatfields);
        rgfield = g_rgcatfields;
        break;
    }

    if (IsInRange(iField, 0, cfields))
    {
        pvar->bstrVal = SysAllocString(rgfield[iField].pszLabel);
        if (pvar->bstrVal)
        {
            pvar->vt = VT_BSTR;
            hres = S_OK;
        }
        else
            hres = E_OUTOFMEMORY;
    }

    return hres;
}


/*-------------------------------------------------------------------------
Purpose: IMtxArray:GetSortIndex
*/
STDMETHODIMP CMtxArray2::GetSortIndex(DWORD * pdwSort)
{
    ASSERT(pdwSort);

    *pdwSort = _dwSort;
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: IMtxArray::SetSortCriteria

         Determines which field to sort by depending on the given criteria.
*/
STDMETHODIMP CMtxArray2::SetSortCriteria(LPCWSTR pszSortField)
{
    int i;
    int cfields;
    const APPFIELDS * pfield;
    
    ASSERT(IS_VALID_STRING_PTRW(pszSortField, -1));

    switch (_dwEnum)
    {
    case ENUM_INSTALLED:
        cfields = ARRAYSIZE(g_rginstfields);
        pfield = g_rginstfields;
        break;

    case ENUM_PUBLISHED:
        cfields = ARRAYSIZE(g_rgpubfields);
        pfield = g_rgpubfields;
        break;

    case ENUM_OCSETUP:
        cfields = ARRAYSIZE(g_rgsetupfields);
        pfield = g_rgsetupfields;
        break;

    case ENUM_CATEGORIES:
        cfields = ARRAYSIZE(g_rgcatfields);
        pfield = g_rgcatfields;
        break;
    }

    // Find the given field's sort index
    for (i = 0; i < cfields; i++, pfield++)
    {
        if (0 == StrCmpW(pszSortField, pfield->pszLabel))
        {
            // Can this field be sorted?
            if (SORT_NA != pfield->dwSort)
            {
                // Yes
                _dwSort = pfield->dwSort;
            }
            break;
        }
    }

    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: Static callback function to handle sorting.  lParam is the
         pointer to the IMtxArray.
*/
int CMtxArray2::s_SortItemsCallbackWrapper(LPVOID pv1, LPVOID pv2, LPARAM lParam)
{
    IMtxArray * pmtxarray = (IMtxArray *)lParam;
    ASSERT(pmtxarray);
    
    return pmtxarray->CompareItems((IAppData *)pv1, (IAppData *)pv2);
}


/*-------------------------------------------------------------------------
Purpose: IMtxArray::CompareItems

         Compares two appdata objects according to the current sort index.
*/
STDMETHODIMP_(int) CMtxArray2::CompareItems(IAppData * pappdata1, IAppData * pappdata2)
{
    
    switch (_dwSort)
    {

    case SORT_SIZE:
        {
            ULONGLONG ull1 = pappdata1->GetSlowDataPtr()->ullSize;
            ULONGLONG ull2 = pappdata2->GetSlowDataPtr()->ullSize;

            // Big apps come before smaller apps
            if (ull1 > ull2)
                return -1;
            else if (ull1 < ull2)
                return 1;

            goto sort_by_name;
        }
        break;

    case SORT_TIMESUSED:
        {
            // Rarely used apps come before frequently used apps.  Blank
            // (unknown) apps go last.  Unknown apps are -1, so those sort
            // to the bottom if we simply compare unsigned values.
            UINT u1 = (UINT)pappdata1->GetSlowDataPtr()->iTimesUsed;
            UINT u2 = (UINT)pappdata2->GetSlowDataPtr()->iTimesUsed;

            if (u1 < u2)
                return -1;
            else if (u1 > u2)
                return 1;

            goto sort_by_name;
        }
        break;

    case SORT_LASTUSED:
        {
            FILETIME ft1 = pappdata1->GetSlowDataPtr()->ftLastUsed;
            FILETIME ft2 = pappdata2->GetSlowDataPtr()->ftLastUsed;

            LONG diff = CompareFileTime(&ft1, &ft2);
            if (0 != diff)
                return diff;

            goto sort_by_name;
        }
        break;
    
sort_by_name:
    case SORT_NAME:
        {
            LPWSTR pszName1 = pappdata1->GetDataPtr()->pszDisplayName;
            LPWSTR pszName2 = pappdata2->GetDataPtr()->pszDisplayName;

            if (pszName1 && pszName2)
                return StrCmpW(pszName1, pszName2);
            else if (pszName1)
                return 1;
            else if (pszName2)
                return -1;
        }
        break;
    }

    return 0;
}


/*-------------------------------------------------------------------------
Purpose: IMtxArray::SortItems

         Sorts the array according to the current sort index.
*/
STDMETHODIMP CMtxArray2::SortItems(void)
{
    if (_hdpa)
    {
        _Lock();
        {
            ASSERT(IS_VALID_HANDLE(_hdpa, DPA));

            DPA_Sort(_hdpa, s_SortItemsCallbackWrapper, (LPARAM)this);
        }
        _Unlock();
    }
    return S_OK;
}

/*-------------------------------------------------------------------------
Purpose: IMtxArray::MarkDupEntries

         Mark the (name) duplicate entries in the DPA array of app data
*/
STDMETHODIMP CMtxArray2::MarkDupEntries(void)
{
    if (_hdpa)
    {
        _Lock();
        {
            int idpa;
            for (idpa = 0; idpa < DPA_GetPtrCount(_hdpa) - 1; idpa++) 
            {
                IAppData * pad = (IAppData *)DPA_GetPtr(_hdpa, idpa);
                IAppData * padNext = (IAppData *)DPA_GetPtr(_hdpa, idpa+1);
                LPWSTR pszName = pad->GetDataPtr()->pszDisplayName;
                LPWSTR pszNameNext = padNext->GetDataPtr()->pszDisplayName;
                if (pszName && pszNameNext && !StrCmpW(pszName, pszNameNext))
                {
                    pad->SetNameDupe(TRUE);
                    padNext->SetNameDupe(TRUE);
                }
            }
        }
        _Unlock();
    }
    return S_OK;
}

/*-------------------------------------------------------------------------
Purpose: IMtxArray::KillWT

         Kills the worker thread. 
*/

STDMETHODIMP CMtxArray2::KillWT()
{
    return CWorkerThread::KillWT();
}

/*----------------------------------------------------------
Purpose: Create-instance function for CMtxArray

*/
HRESULT CMtxArray_CreateInstance(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = E_OUTOFMEMORY;

    *ppvObj = NULL;
    
    CMtxArray2 * pObj = new CMtxArray2();
    if (pObj)
    {
        hres = pObj->QueryInterface(riid, ppvObj);
        pObj->Release();
    }

    return hres;
}

/*-------------------------------------------------------------------------
Purpose: IMtxArray::_ThreadStartProc()

*/
DWORD CMtxArray2::_ThreadStartProc()
{
    DBROWCOUNT i;

    TraceMsg(TF_TASKS, "[%x] Starting slow app info thread", _dwThreadId);

    DBROWCOUNT cItems = 0;
    GetItemCount(&cItems);
    
    // Loop through all enumerated items, getting the 'slow' information
    for (i = 0 ; i < cItems ; i++)
    {
        IAppData * pappdata;
        
        // If we've been asked to bail, do so
        if (IsKilled())
            break;

        GetAppData(i, &pappdata);
        if (pappdata)
        {
            HRESULT hres = pappdata->ReadSlowData(); 
            // Call to get the slow info for the item. Fire an event on success
            if (hres == S_OK)
            {
                PostWorkerMessage(WORKERWIN_FIRE_ROW_READY, i, 0);

                TraceMsg(TF_TASKS, "[%x] Slow info for %d (%ls): hit", _dwThreadId, i, 
                        pappdata->GetDataPtr()->pszDisplayName);
            }
            else
            {
                TraceMsg(TF_TASKS, "[%x] Slow info for %d (%ls): miss", _dwThreadId, i, 
                         pappdata->GetDataPtr()->pszDisplayName);
            }
            pappdata->Release();
        }
    }

    PostWorkerMessage(WORKERWIN_FIRE_FINISHED, 0, 0);
    return  CWorkerThread::_ThreadStartProc();
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\pubenum.h ===
#ifndef __PUBENUM_H_
#define __PUBENUM_H_


class CShellEnumPublishedApps : public IEnumPublishedApps
{
public:

    CShellEnumPublishedApps(HDPA hdpaEnum);
    ~CShellEnumPublishedApps();
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IEnumPublishedApps
    STDMETHODIMP Next(IPublishedApp ** ppia);
    STDMETHODIMP Reset(void);
    //STDMETHODIMP SetCategory(GUID * pAppCategoryId);

protected:

    UINT _cRef;

    // Internal list of all IEnumPublishedApps * 
    HDPA _hdpaEnum;
    int  _iEnum;  
};

#endif //__PUBENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\pubenum.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: pubenum.cpp
//
// The current order of enumeration is Legacy --> Darwin --> SMS
//
// History:
//         1-18-97  by dli
//------------------------------------------------------------------------
#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include "pubenum.h"


void _DestroyHdpaEnum(HDPA hdpaEnum)
{
    ASSERT(IsValidHDPA(hdpaEnum));
    IEnumPublishedApps * pepa;
    int idpa;
    for (idpa = 0; idpa < DPA_GetPtrCount(hdpaEnum); idpa++)
    {
        pepa = (IEnumPublishedApps *)DPA_GetPtr(hdpaEnum, idpa);
        if (EVAL(pepa))
            pepa->Release();
    }

    DPA_Destroy(hdpaEnum);
}

CShellEnumPublishedApps::CShellEnumPublishedApps(HDPA hdpaEnum) : _cRef(1), _hdpaEnum(hdpaEnum)
{
}

CShellEnumPublishedApps::~CShellEnumPublishedApps()
{
    if (_hdpaEnum)
        _DestroyHdpaEnum(_hdpaEnum);
}

// IEnumPublishedApps::QueryInterface
HRESULT CShellEnumPublishedApps::QueryInterface(REFIID riid, LPVOID * ppvOut)
{ 
    static const QITAB qit[] = {
        QITABENT(CShellEnumPublishedApps, IEnumPublishedApps),                  // IID_IEnumPublishedApps
        { 0 },
    };

    return QISearch(this, qit, riid, ppvOut);
}

// IEnumPublishedApps::AddRef
ULONG CShellEnumPublishedApps::AddRef()
{
    _cRef++;
    TraceMsg(TF_OBJLIFE, "CShellEnumPublishedApps()::AddRef called, new _cRef=%lX", _cRef);
    return _cRef;
}

// IEnumPublishedApps::Release
ULONG CShellEnumPublishedApps::Release()
{
    _cRef--;
    TraceMsg(TF_OBJLIFE, "CShellEnumPublishedApps()::Release called, new _cRef=%lX", _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


// IEnumPublishedApps::Next
HRESULT CShellEnumPublishedApps::Next(IPublishedApp ** ppia)
{
    HRESULT hres = E_FAIL;
    if (_hdpaEnum)
    {
        IEnumPublishedApps * pepa = (IEnumPublishedApps *)DPA_GetPtr(_hdpaEnum, _iEnum);

        //
        // If pepa is not valid or pepa->Next failed, or at the end of the current enumerator, 
        // we skip this Enumerator, and go on to the next one until we hit the limit
        
        while ((!pepa || S_OK != (hres = pepa->Next(ppia))) && (_iEnum < DPA_GetPtrCount(_hdpaEnum)))
        {
            _iEnum++;
            pepa = (IEnumPublishedApps *)DPA_GetPtr(_hdpaEnum, _iEnum);
        }
    }    
    return hres;
}


// IEnumPublishedApps::Reset
HRESULT CShellEnumPublishedApps::Reset(void)
{
    // Call reset on everyone in the list and set our index iEnum to 0;
    if (_hdpaEnum)
    {
        IEnumPublishedApps * pepa;
        int idpa;
        for (idpa = 0; idpa < DPA_GetPtrCount(_hdpaEnum); idpa++)
        {
            pepa = (IEnumPublishedApps *)DPA_GetPtr(_hdpaEnum, idpa);
            if (pepa)
                pepa->Reset();
        }

        _iEnum = 0;

        return S_OK;
    }
    
    return E_FAIL;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\msdos.c ===
//
//  MSDOS.C     Wizard started by SHELL.VxD
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"
#include <wshioctl.h>


//
//  This exported entry point is called by RUNDLL32 when a VxD calls the
//  Shell_SuggestSingleMSDOSMode service.
//

void WINAPI SingleMSDOSWizard(HWND hwnd, HINSTANCE hAppInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
    WIZDATA wd;

    memset(&wd, 0, sizeof(wd));

    wd.hwnd = hwnd;

    if (GetSingleAppInfo(&wd))
    {
        if (wd.hProps != 0)
        {
            MSDOSPropOnlyWizard(&wd);
        }
        else
        {
            wd.dwFlags |= WDFLAG_SINGLEAPP;
            LinkWizard(&wd);
        }
    }

    //
    //    Note, we close properties here in case GetSingleAppInfo returned false,
    //    but still had opened the hProps.
    //

    if (wd.hProps != 0)
    {
        PifMgr_CloseProperties(wd.hProps, CLOSEPROPS_NONE);
    }
}


//
//  Inline helper function.  If the name ends with the extension .EXE, .BAT,
//  or .COM then we'll accept it.  Otherwise, try to take the given name and
//  convert it to a program name we can execute.  This fixes the case where
//  Flight Simulator's setup program runs FS5.OVL.  The user should really
//  run FS5.BAT.
//

HRESULT _inline CleanUpName(LPWIZDATA lpwd)
{
    LPCTSTR PathDirs[2];
    LPTSTR  pszExt;
    LPTSTR  pszCurExt;
    TCHAR   szValidExt[100];

    ASSERT(lpwd);
    pszExt = PathFindExtension(lpwd->szExeName);
    if (!pszExt)
    {
        return E_FAIL;
    }
    PathDirs[0] = lpwd->szWorkingDir;
    PathDirs[1] = NULL;

    if (*pszExt)
        pszExt++;    // NSL: *pszExt == '.' so this should be fine

    //
    //    Make sure that the extension is a real progarm extension (not .OVL
    //    for example.  If it is, search for the matching name.
    //
    szValidExt[0] = TEXT('\0');
    if (!LoadAndStrip(IDS_EXTENSIONS, szValidExt, ARRAYSIZE(szValidExt)))
    {
        return E_FAIL;
    }

    pszCurExt = szValidExt;

    while (*pszCurExt)
    {
        if (lstrcmpi(pszExt, pszCurExt) == 0)
        {
            if (PathResolve(lpwd->szExeName, PathDirs, PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS))
            {
                return S_OK;
            }
            else
            {
                return S_FALSE;
            }
        }

        pszCurExt = SkipStr(pszCurExt);
    }

    pszCurExt = szValidExt;

    while (*pszCurExt)
    {
        lstrcpy(pszExt, pszCurExt);

        if (PathResolve(lpwd->szExeName, PathDirs, PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS))
        {
            return S_OK;
        }

        pszCurExt = SkipStr(pszCurExt);
    }
    return S_FALSE;
}


BOOL GetSingleAppInfo(LPWIZDATA lpwd)
{
    HANDLE  hDevice;
    BOOL    bMakeLink = FALSE;
    SINGLEAPPSTRUC SAS;
    DWORD   dwRetSize;
    LPDWORD lpResult;
    HRESULT hr;

    hDevice = CreateFile(SHELLFILENAME, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,
                         OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

    if (hDevice == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    if (DeviceIoControl(hDevice, WSHIOCTL_GET1APPINFO, NULL, 0,
                        &SAS, sizeof(SAS), &dwRetSize, NULL))
    {

        #define fVMDead ((BOOL)(SAS.SSA_dwFlags & SSAMFLAG_KILLVM))

        int idString = fVMDead ? IDS_VMCLOSED : IDS_VMSTILLALIVE;

        TraceMsg(TF_ERROR, "%s", "Got info on a single MS-DOS mode app.  Now will show Exe, Command line params, directory, and PIF.");
        TraceMsg(TF_ERROR, "%s", SAS.SSA_ProgName);
        TraceMsg(TF_ERROR, "%s", SAS.SSA_CommandLine);
        TraceMsg(TF_ERROR, "%s", SAS.SSA_CurDir);
        TraceMsg(TF_ERROR, "%s", SAS.SSA_PIFPath);
    
        if (SAS.SSA_dwFlags & SSAMFLAG_FROMREGLIST)
        {
            SHELLEXECUTEINFO ei;

            lpResult = (LPVOID)SAS.SSA_ResultPtr;
            *lpResult = SSR_KILLAPP;

            DeviceIoControl(hDevice, WSHIOCTL_SIGNALSEM, &SAS, sizeof(SAS),
                            NULL, 0, NULL, NULL);
    
            ei.cbSize = sizeof(ei);
            ei.hwnd = lpwd->hwnd;
            ei.lpVerb = NULL;
            ei.fMask = 0;
            ei.lpFile = SAS.SSA_ProgName;

            if (SAS.SSA_CommandLine[0] == 0)
            {
                ei.lpParameters = NULL;
            }
            else
            {
                ei.lpParameters = SAS.SSA_CommandLine;
            }

            if (SAS.SSA_CurDir == TEXT('\0'))
            {
                ei.lpDirectory = NULL;
            }
            else
            {
                ei.lpDirectory = SAS.SSA_CurDir;
            }

            ei.lpClass = NULL;
            ei.nShow = SW_SHOWDEFAULT;
            ei.hInstApp = g_hinst;
    
            ShellExecuteEx(&ei);
            goto CloseHandleExit;
        }
    
    
        if (SAS.SSA_dwFlags & SSAMFLAG_REQREALMODE)
        {
            lpwd->dwFlags |= WDFLAG_REALMODEONLY;
        }
    
        lstrcpyn(lpwd->szExeName, SAS.SSA_ProgName,    ARRAYSIZE(lpwd->szExeName));
        lstrcpyn(lpwd->szParams,  SAS.SSA_CommandLine, ARRAYSIZE(lpwd->szParams));
        lstrcpyn(lpwd->szWorkingDir, SAS.SSA_CurDir,   ARRAYSIZE(lpwd->szWorkingDir));
    
    
        hr = CleanUpName(lpwd);
        if (FAILED(hr))
        {
            bMakeLink = FALSE;
            goto CloseHandleExit;
        }
        else if (hr == S_OK)
        {
            DetermineExeType(lpwd);
            lpwd->dwFlags |= WDFLAG_NOBROWSEPAGE;

            //
            // There are three different possibilities with SSA_PIFPath:
            //        Empty string indicates program run from command line.
            //        " " indicates exe run from shell, but no PIF exists
            //        Name of PIF that was run.
            // If the program was run from command.com then we will force
            // the user to create a shortcut.  If not started from a specific
            // PIF then we'll set the default properties for the program.  If
            // started from a specific PIF then we'll set the properties for
            // that PIF.
            //

            if (SAS.SSA_PIFPath[0] != 0)
            {
                lpwd->hProps = PifMgr_OpenProperties((SAS.SSA_PIFPath[0] == TEXT(' ')) ?
                                    lpwd->szExeName : SAS.SSA_PIFPath,
                                    NULL, 0, OPENPROPS_NONE);

                if (lpwd->hProps != 0)
                {
                    idString = fVMDead ? IDS_CHGPROPCLOSED
                                       : IDS_CHGPROPSTILLALIVE;
                }
            }
        }
        else
        {
            LPTSTR pszStartName = PathFindFileName(lpwd->szExeName);

            *pszStartName = 0;

            LoadStringA(g_hinst, IDS_GENERICNAME,
                       lpwd->PropPrg.achTitle, ARRAYSIZE(lpwd->PropPrg.achTitle));
        }
    
        bMakeLink = (IDYES == ShellMessageBox(g_hinst,
                                    lpwd->hwnd,
                                    MAKEINTRESOURCE(idString),
                                    MAKEINTRESOURCE(IDS_1APPWARNTITLE),
                                    MB_YESNO | MB_DEFBUTTON1 | MB_ICONEXCLAMATION,
                                    lpwd->PropPrg.achTitle));
    
        lpResult = (LPVOID)SAS.SSA_ResultPtr;

        if (!fVMDead && lpResult != NULL)
        {
            if (bMakeLink)
            {
                *lpResult = (SAS.SSA_dwFlags & SSAMFLAG_FROMREGLIST) ?
                                SSR_KILLAPP : SSR_CLOSEVM;
            }
            else
            {
                *lpResult = SSR_CONTINUE;
            }
    
            DeviceIoControl(hDevice, WSHIOCTL_SIGNALSEM, &SAS, sizeof(SAS),
                            NULL, 0, NULL, NULL);
        }
    }

CloseHandleExit:

    CloseHandle(hDevice);

    return(bMakeLink);

    #undef fVMDead
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\resource.h ===
#ifndef _IDS_H_ // DANGER! DANGER! ANY CHANGE TO THIS FILE CAN POTENTIALLY CHANGE
#define _IDS_H_ // THE *.uipp FILES AND WILL BREAK MUI!  PROCEED WITH CAUTION!
#define IDS_FONTFACE0                        1
#define IDS_FONTFACE1                        2
#define IDS_FONTFACE2                        3
#define IDS_CLOSE                            4
#define IDS_CHANGEORREMOVEP                  5
#define IDS_ADDPROGRAMS                      6
#define IDS_ADDREMOVEWINDOWS                 7
#define IDS_CURRENTINSTALLED                 8 
#define IDS_ADDFROMCD                        9
#define IDS_CDHELP                          10
#define IDS_CDORFLOPPY                      11 
#define IDS_ADDFROMMS                       12
#define IDS_ADDWUPDATEHELP                  13
#define IDS_WINDOWSUPDATE                   14
#define IDS_LOADING                         15
#define IDS_SUPPORT                         16
#define IDS_CHANGE                          17
#define IDS_REMOVE                          18
#define IDS_CHANGEORREMOVE                  19
#define IDS_ADD                             20
#define IDS_SIZE                            21
#define IDS_SIZEHELP                        22
#define IDS_FREQUENCY                       23
#define IDS_FREQUENCYHELP                   24
#define IDS_FREQUENCYHELP1                  25
#define IDS_FREQUENCYHELP2                  26
#define IDS_TECHSUPPORT                     27
#define IDS_PUBLISHER                       28
#define IDS_VERSION                         29
#define IDS_CONTACT                         30
#define IDS_SUPPORTINFO                     31
#define IDS_README                          32
#define IDS_UPDATE                          33
#define IDS_PRODUCTID                       34
#define IDS_REGCOMPANY                      35
#define IDS_REGOWNER                        36
#define IDS_COMMENTS                        37
#define IDS_REPAIRDESC                      38
#define IDS_REPAIR                          39
#define IDS_SORTBY                          40
#define IDS_GATEGORY                        41 
#define IDS_ADDFROMNETWORK                  42
#define IDS_APPNAME                         43
#define IDS_DATELASTUSED                    44
#define IDS_ALLCATEGORIES                   45
#define IDS_HELPCHANGEORREMOVE              46
#define IDS_HELPCHANGEREMOVE                47
#define IDS_SIZEUNIT                        48
#define IDS_TERMSERVFEEDBACK                49
#define IDS_USEDREARELY                     50
#define IDS_USEDOCCASIONALLY                51
#define IDS_USEDFREQUENTLY                  52
#define IDS_ADDHELP                         54          
#define IDS_APPINSTALLED                    55
#define IDS_ARPTITLE                        56
#define IDS_WAITFEEDBACK                    57
#define IDS_EMPTYFEEDBACK                   58
#define IDS_DEFINITION                      59
#define IDS_SIZELABEL                       60
#define IDS_FREQUENCYLABEL                  61
#define IDS_LASTUSEDLABEL                   62
#define IDS_SIZETITLE                       63
#define IDS_FREQUENCYTITLE                  64
#define IDS_SUPPORTTITLE                    65
#define IDS_CONFIGURE                       66
#define IDS_OCSETUPHELP                     67
#define IDS_OCSETUPWARNING                  68
#define IDS_ADDREMOVEWIN                    69
#define IDS_WINHELP                         70
#define IDS_COMPONENTS                      71
#define IDS_SERVICELABEL                    72
#define IDS_FONTSIZEFRAME                   73
#define IDS_FONTSIZEHELP                    74
#define IDS_FONTSIZEHELPTITLE               75
#define IDS_SHORTCUTCLOSE                   76
#define IDS_SHORTCUTSORT                    77
#define IDS_SHORTCUTCDORFLOPPY              78
#define IDS_SHORTCUTWINUPDATE               79
#define IDS_SHORTCUTCATEGORY                80
#define IDS_FONTWEIGHTSEL                   82
#define IDS_FONTWEIGHTHELPTITLE             83
#define IDS_SHORTCUTCHANE                   84
#define IDS_SHORTCUTADD                     85
#define IDS_SHORTCUTWINDOWS                 86
#define IDS_HELPCHANGE                      87
#define IDS_HELPREMOVE                      88
#define IDS_PLEASEWAIT                      89
#define IDS_SORTBY_WIDTH                    90

#define IDB_PROGRESS                       100
#define IDB_ARP0                           101
#define IDB_ARP1                           102
#define IDB_ARP2                           103
#define IDB_ARP3                           104
#define IDB_ARP4                           105
#define IDB_ARPX                           106
#define IDB_ARPX1                          107

#define IDR_ARP                            300
#define IDR_ARPSTYLESTD                    301
#define IDR_ARPSTYLETHEME                  302

#if defined(LEGACY_UIPP) // !!! Cannot change the *.uipp file or you break MUI!
// hTheme identification from within the resource
#define BUTTONHTHEME                       1
#define SCROLLBARHTHEME                    2
#define TOOLBARHTHEME                      3
#else
#define THISDLLHINSTANCE                   0
#define XPSP1HINSTANCE                     1
#define SHELLSTYLEHINSTANCE                2
#define FIRSTHTHEME                        3
#define BUTTONHTHEME                       3
#define SCROLLBARHTHEME                    4
#define TOOLBARHTHEME                      5
#define LASTHTHEME                         5
#endif

#define IDR_ADCCTL          0x2000
#define IDR_CARPCTL         0x2001

#define IDS_BYTES           0x3000
#define IDS_ORDERKB         0x3001
#define IDS_ORDERMB         0x3002
#define IDS_ORDERGB         0x3003
#define IDS_ORDERTB         0x3004
#define IDS_ORDERPB         0x3005
#define IDS_ORDEREB         0x3006

#define IDS_UNKNOWN         0x3010
#define IDS_NOTUSED         0x3011
#define IDS_LABEL_SIZE      0x3012
#define IDS_LABEL_INSTALLEDON 0x3013
#define IDS_LABEL_TIMESUSED 0x3014
#define IDS_LABEL_LASTUSED  0x3015
#define IDS_RARELY          0x3016
#define IDS_SOMETIMES       0x3017
#define IDS_OFTEN           0x3018
#define IDS_RESTRICTION     0x3019
#define IDS_EXPIRED         0x3020
#define IDS_PASSASSIGNED    0x3021
#define IDS_PASSEXPIRED     0x3022
#define IDS_ADDLATER        0x3023
#define IDS_INSTALLED       0x3024
#define IDS_CONFIRM_REMOVE  0x3025
#define IDS_WINUPD_URL      0x3026

#define IDC_PICKER          0x3050
#define IDC_ADDLATER        0x3051
#define IDC_UNSCHEDULE      0x3052
#define DLG_ADDLATER        0x3100
#endif // _IDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\pickicon.c ===
//
//  PickIcon.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 6/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//

#include "priv.h"
#include "appwiz.h"


//
//  Size?
//
#define MAX_ICONS   75


//
//  Adds icons to the list box.
//

void PutIconsInList(HWND hLB, LPWIZDATA lpwd)
{
    HICON   rgIcons[MAX_ICONS];
    int     iTempIcon;
    int     cIcons;
    HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    RECT    rc;
    int     cy;

    ListBox_SetColumnWidth(hLB, g_cxIcon+12);

    //
    // compute the height of the listbox based on icon dimensions
    //

    GetWindowRect(hLB, &rc);

    cy = g_cyIcon + GetSystemMetrics(SM_CYHSCROLL) + GetSystemMetrics(SM_CYEDGE) * 3;

    SetWindowPos(hLB, NULL, 0, 0, rc.right-rc.left, rc.bottom-rc.top,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    ListBox_ResetContent(hLB);

    SendMessage(hLB, WM_SETREDRAW, FALSE, 0L);

#ifdef DEBUG
    {
    //
    //  This is necessary for Unicode (i.e. NT) builds because the shell32
    //  library does not support ShellMessageBoxA and W versions.
    //
#ifdef UNICODE
    TCHAR szTemp[MAX_PATH];

    MultiByteToWideChar(CP_ACP, 0, lpwd->PropPrg.achIconFile, -1, szTemp, ARRAYSIZE(szTemp));

    TraceMsg(TF_ERROR, "%s", szTemp);
#else
    TraceMsg(TF_ERROR, "%s", lpwd->PropPrg.achIconFile);
#endif

    }
#endif  //  DEBUG

    cIcons = (int)ExtractIconExA(lpwd->PropPrg.achIconFile, 0, rgIcons, NULL, MAX_ICONS);

    for (iTempIcon = 0; iTempIcon < cIcons; iTempIcon++)
    {
        ListBox_AddString(hLB, rgIcons[iTempIcon]);
    }

    ListBox_SetCurSel(hLB, 0);

    SendMessage(hLB, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(hLB, NULL, TRUE);

    SetCursor(hcurOld);
}


//
//
//

void PickIconInitDlg(HWND hDlg, LPARAM lParam)
{
    LPPROPSHEETPAGE lpp = (LPPROPSHEETPAGE)lParam;
    LPWIZDATA lpwd = InitWizSheet(hDlg, lParam, 0);

    PutIconsInList(GetDlgItem(hDlg, IDC_ICONLIST), lpwd);
}


//
//  Returns TRUE if a vaild icon is selected.
//

BOOL PickIconNextPressed(LPWIZDATA lpwd)
{
    int iIconIndex = ListBox_GetCurSel(GetDlgItem(lpwd->hwnd, IDC_ICONLIST));

    lpwd->PropPrg.wIconIndex = (WORD)iIconIndex;

    return(iIconIndex != LB_ERR);
}


//
//
//

BOOL_PTR CALLBACK PickIconDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm = NULL;
    LPPROPSHEETPAGE lpp = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = lpp ? (LPWIZDATA)lpp->lParam : NULL;

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            if(lpnm)
            {
                switch(lpnm->code)
                {
                    case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            //
                            // If PIFMGR has assigned an icon for this app then
                            // we'll skip it.  This condition only happens when
                            // creating a shortcut to a single MS-DOS session.
                            //

                            if (lpwd->dwFlags & WDFLAG_APPKNOWN)
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                            else
                            {
                                lpwd->hwnd = hDlg;
                                PropSheet_SetWizButtons(GetParent(hDlg),
                                                       (lpwd->dwFlags & WDFLAG_SINGLEAPP) ?
                                                        PSWIZB_BACK | PSWIZB_NEXT :
                                                        PSWIZB_BACK | PSWIZB_FINISH);
                            }
                        }
                        break;

                    case PSN_WIZNEXT:
                        if(lpwd)
                        {
                            if (!PickIconNextPressed(lpwd))
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                        }
                        break;

                    case PSN_WIZFINISH:
                        if(lpwd)
                        {
                            if (!(PickIconNextPressed(lpwd) && CreateLink(lpwd)))
                            {
                                SetDlgMsgResult(hDlg, WM_NOTIFY, -1);
                            }
                        }
                        break;

                    case PSN_RESET:
                        if(lpwd)
                        {
                            CleanUpWizData(lpwd);
                        }
                        break;

                    default:
                        return FALSE;
                }
            }
            break;

        case WM_INITDIALOG:
            PickIconInitDlg(hDlg, lParam);
            break;

        case WM_COMMAND:
            if(lpwd)
            {
                if ((GET_WM_COMMAND_ID(wParam, lParam) == IDC_ICONLIST) &&
                    ((GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)))
                {
                    PropSheet_PressButton(GetParent(hDlg),
                                          (lpwd->dwFlags & WDFLAG_SINGLEAPP) ?
                                                     PSBTN_NEXT : PSBTN_FINISH);
                }
            }
            break;

        //
        // owner draw messages for icon listbox
        //

        case WM_DRAWITEM:
            #define lpdi ((DRAWITEMSTRUCT FAR *)lParam)

            if (lpdi->itemState & ODS_SELECTED)
                SetBkColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
            else
                SetBkColor(lpdi->hDC, GetSysColor(COLOR_WINDOW));

            //
            // repaint the selection state
            //

            ExtTextOut(lpdi->hDC, 0, 0, ETO_OPAQUE, &lpdi->rcItem, NULL, 0, NULL);

            //
            // draw the icon
            //

            if ((int)lpdi->itemID >= 0)
              DrawIcon(lpdi->hDC, (lpdi->rcItem.left + lpdi->rcItem.right - g_cxIcon) / 2,
                                  (lpdi->rcItem.bottom + lpdi->rcItem.top - g_cyIcon) / 2, (HICON)lpdi->itemData);

            // InflateRect(&lpdi->rcItem, -1, -1);

            //
            // if it has the focus, draw the focus
            //

            if (lpdi->itemState & ODS_FOCUS)
                DrawFocusRect(lpdi->hDC, &lpdi->rcItem);

            #undef lpdi
            break;

        case WM_MEASUREITEM:
            #define lpmi ((MEASUREITEMSTRUCT FAR *)lParam)

            lpmi->itemWidth = g_cxIcon + 12;
            lpmi->itemHeight = g_cyIcon + 4;

            #undef lpmi
            break;

        case WM_DELETEITEM:
            #define lpdi ((DELETEITEMSTRUCT FAR *)lParam)

            DestroyIcon((HICON)lpdi->itemData);

            #undef lpdi
            break;

        default:
            return FALSE;

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\mtxarray.h ===
//+-----------------------------------------------------------------------
//
//  Matrix Array
//
//------------------------------------------------------------------------


#ifndef _MTXARRAY_H_
#define _MTXARRAY_H_

#include "iface.h"          // for APPCMD_*
#include "worker.h"
#include "setupenum.h"      // for COCSetup* classes
#include "simpdata.h"       // for OLEDB

// Areas that this control can enumerate
// Warning: Please do not change these numbers, they are also used
// as array indexes. 
#define ENUM_INSTALLED  0       // installed apps
#define ENUM_PUBLISHED  1       // published apps
#define ENUM_CATEGORIES 2       // published categories
#define ENUM_OCSETUP    3       // Optional components selected during setup
#define ENUM_UNKNOWN    0xffffffff

// Sort indexes
#define SORT_NA         (-1)    // n/a
#define SORT_NAME       0       // sort by name
#define SORT_SIZE       1       // sort by size
#define SORT_TIMESUSED  2       // sort by frequency of use
#define SORT_LASTUSED   3       // sort by last used date


typedef struct tagAPPFIELDS
{
    LPWSTR pszLabel;
    DWORD  dwSort;          // can be SORT_*
    DWORD  dwStruct;        // IFS_*
    VARTYPE vt;             // field type
    DWORD  ibOffset;        // offset into structure designated by dwStruct
} APPFIELDS;


// REARCHITECT: (dli) We should have just one base CAppData class and installed, published,
// categories and OCSetup should derives from it. 
// CAppData

class CAppData : public IAppData
{
public:
    // *** IUnknown ***
    STDMETHOD_(ULONG, AddRef)   (void);
    STDMETHOD_(ULONG, Release)  (void);
    STDMETHOD(QueryInterface)   (REFIID riid, LPVOID * ppvObj);

    // *** IAppData ***
    STDMETHOD(DoCommand)        (HWND hwndParent, APPCMD appcmd);
    STDMETHOD(ReadSlowData)     (void);
    STDMETHOD(GetVariant)       (DB_LORDINAL iField, VARIANT * pvar);
    STDMETHOD(SetMtxParent)     (IMtxArray * pmtxParent);
    STDMETHOD_(APPINFODATA *, GetDataPtr)(void);
    STDMETHOD_(SLOWAPPINFO *, GetSlowDataPtr)(void);
    STDMETHOD(GetFrequencyOfUse)(LPWSTR pszBuf, int cchBuf);
    STDMETHOD(SetNameDupe)      (BOOL bDupe) {_bNameDupe = bDupe; return S_OK;};
            
    // Overloaded constructors
    CAppData(IInstalledApp* pia, APPINFODATA* paid, PSLOWAPPINFO psai);
    CAppData(IPublishedApp* ppa, APPINFODATA* paid, PUBAPPINFO * ppai);
    CAppData(SHELLAPPCATEGORY * psac);
    CAppData(COCSetupApp * pocsa, APPINFODATA* paid);

    ~CAppData();

    
private:
    HRESULT _GetInstField(DB_LORDINAL iField, VARIANT * pvar);
    HRESULT _GetPubField(DB_LORDINAL iField, VARIANT * pvar);
    HRESULT _GetSetupField(DB_LORDINAL iField, VARIANT * pvar);
    HRESULT _GetCatField(DB_LORDINAL iField, VARIANT * pvar);

    LPTSTR _BuildSupportInfo(void);
    LPTSTR _BuildPropertiesHTML(void);
    void   _GetIconHTML(LPTSTR pszIconHTML, UINT cch);
                        
    HRESULT _VariantFromData(const APPFIELDS * pfield, LPVOID pvData, VARIANT * pvar);
    DWORD   _GetCapability();
    HRESULT _GetDiskSize(LPTSTR pszBuf, int cchBuf);
    HRESULT _GetLastUsed(LPTSTR pszBuf, int cchBuf);
    DWORD   _GetSortIndex(void);

    void    _MassageSlowAppInfo(void);
    
    LONG _cRef;
    union
    {
        IInstalledApp* _pia;
        IPublishedApp* _ppa;
        SHELLAPPCATEGORY * _psac;
        COCSetupApp * _pocsa;
    };
    APPINFODATA _ai;
    PUBAPPINFO _pai;        // Published app specific info
    SLOWAPPINFO _aiSlow;
    IMtxArray * _pmtxParent;
    DWORD _dwEnum;          // Can be ENUM_*
    BOOL  _bNameDupe;       // Has a duplicate name with other apps
    CRITICAL_SECTION _cs;   // NOTE: only used for Installed Apps. 
    BOOL  _fCsInitialized;  // Was the critical section initialized 
};


// EnumAppItems callback
typedef void (CALLBACK *ENUMAPPITEMSCB)(IAppData * pappdata, LPARAM lParam);

HRESULT EnumAppItems(DWORD dwEnum, LPCWSTR pszCategory, IShellAppManager * pam, ENUMAPPITEMSCB pfnCallback, LPARAM lpContext);



//------------------------------------------------------------------------
//
//  Matrix Array
//
//  This object maintains the array of data.  It knows how to map
//  ordinal row/column references to the actual records and fields
//  kept in the array.  The base class supplies all the necessary
//  methods as virtuals, and derived classes allow for arrays of:
//
//   - installed apps
//   - published apps
//   - publishing categories
//
//------------------------------------------------------------------------

class CMtxArray2 : public IMtxArray,
                   public CWorkerThread
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef   (void) {return CWorkerThread::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release  (void) {return CWorkerThread::Release();};
    virtual STDMETHODIMP QueryInterface   (REFIID riid, LPVOID * ppvObj);
    
    // *** IMtxArray ***
    STDMETHOD(Initialize)       (DWORD dwEnum);
    STDMETHOD(AddItem)          (IAppData * pappdata, DBROWCOUNT * piRow);
    STDMETHOD(DeleteItems)      (DBROWCOUNT iRow, DBROWCOUNT cRows);
    STDMETHOD(GetAppData)       (DBROWCOUNT iRow, IAppData ** ppappdata);
    STDMETHOD(GetItemCount)     (DBROWCOUNT * pcItems);
    STDMETHOD(GetFieldCount)    (DB_LORDINAL * pcFields);
    STDMETHOD(GetFieldName)     (DB_LORDINAL iField, VARIANT * pvar);
    STDMETHOD(GetSortIndex)     (DWORD * pdwSort);
    STDMETHOD(SortItems)        (void);
    STDMETHOD(SetSortCriteria)  (LPCWSTR pszSortField);
    STDMETHOD_(int,CompareItems)(IAppData * pappdata1, IAppData * pappdata2);
    STDMETHOD(MarkDupEntries)   (void);
    
    // *** IARPWorker methods *** (override)
    STDMETHOD(KillWT)           (void);

    CMtxArray2();
    ~CMtxArray2();

    static int s_SortItemsCallbackWrapper(LPVOID pv1, LPVOID pv2, LPARAM lParam);
    
protected:
    HRESULT _DeleteItem(DBROWCOUNT idpa);
    HRESULT _CreateArray(void);
    DWORD   _ThreadStartProc();

    void    _Lock(void);
    void    _Unlock(void);

    CRITICAL_SECTION _cs;
    DEBUG_CODE( LONG _cRefLock; )

            

    HDPA        _hdpa;          // the data is here
    DWORD       _dwEnum;
    DWORD       _dwSort;        // can be SORT_*
};


HRESULT CMtxArray_CreateInstance(REFIID riid, LPVOID * ppvObj);


#endif // _MTXARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

#define STRICT

/* disable "non-standard extension" warnings in our code
 */
#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif

// Define these before including dldecl.h
#define DL_OLEAUT32
#define DL_OLE32

#include "dldecl.h"             // dldecl.h needs to go before everything else

#define CC_INTERNAL             // This is for some internal prshtp.h stuff


#ifndef WINNT
#undef ShellMessageBoxA
#define ShellMessageBoxA ShellMessageBox

#undef SHGetNewLinkInfo
#define SHGetNewLinkInfoA SHGetNewLinkInfo
#endif


// copied from old 
#ifdef WINNT
//
// need Wx86 definitions from ntpsapi.h
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#endif

#include <windows.h>

// VariantInit is a trivial function -- avoid using OleAut32, use intrinsic
// version of memset for a good size win
// (it's here so that atl (in stdafx.h) gets it too)
#define VariantInit(p) memset(p, 0, sizeof(*(p)))

#ifdef __cplusplus
// (stdafx.h must come before windowsx.h)
#include "stdafx.h"             // ATL header file for this component
#endif

#include <windowsx.h>
#include <ole2.h>               // to get IStream for image.c
#include "..\inc\port32.h"
#include <winerror.h>
#include <winnlsp.h>
#include <docobj.h>
#include <lm.h>
#include <shlobj.h>

#define _SHLWAPI_
#include <shlwapi.h>

#include <ccstock.h>
#include <crtfree.h>
#define DISALLOW_Assert
#include <debug.h>
#include <regstr.h>
#define _WIN32_MSI 110
#include <msi.h>                // Darwin APIs
#include <msiquery.h>           // Darwin Datebase Query APIs
#include <wininet.h>            // For INTERNET_MAX_URL_LENGTH

#include "shappmgrp.h"
#include "shellp.h"

#include <appmgmt.h>
#include "apithk.h"
#include "awthunk.h"

#include <uxtheme.h>


#include <shfusion.h>

//
// Local includes
//

//
// Wrappers so our Unicode calls work on Win95
//

#ifdef WINNT

#define StrCmpIW            lstrcmpiW

#else

#define lstrcmpW            StrCmpW
#define lstrcmpiW           StrCmpIW
#define lstrcatW            StrCatW
#define lstrcpyW            StrCpyW
#define lstrcpynW           StrCpyNW

#endif

// This DLL needs to run correctly on Win95.  CharNextW is only stubbed
// on Win95, so we need to do this...
#define CharNextW(x)        ((x) + 1)
#define CharPrevW(y, x)     ((x) - 1)

// This is a TCHAR export on win9x and NT4, and since we need to link to
// the old shell32.nt4/shell32.w95 we #undef it here
#undef ILCreateFromPath
STDAPI_(LPITEMIDLIST) ILCreateFromPath(LPCTSTR pszPath);


//
// Trace/dump/break flags specific to shell32.
//   (Standard flags defined in debug.h)
//

// Trace flags
#define TF_OBJLIFE          0x00000010      // Object lifetime
#define TF_DSO              0x00000020      // Data source object
#define TF_FINDAPP          0x00000040      // Find app heuristic stuff
#define TF_INSTAPP          0x00000080      
#define TF_SLOWFIND         0x00000100
#define TF_TASKS            0x00000200
#define TF_CTL              0x00000400
#define TF_VERBOSEDSO       0x00000800      // squirts html and stuff

// Break flags
#define BF_ONDLLLOAD        0x00000010


// Prototype flags
#define PF_NEWADDREMOVE     0x00000001
#define PF_NOSECURITYCHECK  0x00000002
#define PF_FAKEUNINSTALL    0x00000004

// Debug functions
#ifdef DEBUG
#define TraceAddRef(classname, cref)    TraceMsg(TF_OBJLIFE, #classname "(%#08lx) %d>", (DWORD_PTR)this, cref)
#define TraceRelease(classname, cref)   TraceMsg(TF_OBJLIFE, #classname "(%#08lx) %d<", (DWORD_PTR)this, cref)
#else
#define TraceAddRef(classname, cref)    
#define TraceRelease(classname, cref)   
#endif

#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


//
// Info string MAX length
//
#define MAX_INFO_STRING MAX_PATH * 3

//
// Global variables
//
EXTERN_C HINSTANCE g_hinst;

#define HINST_THISDLL   g_hinst

#ifdef WINNT
#define g_bRunOnNT  TRUE
#ifdef DOWNLEVEL
#define g_bRunOnNT5 FALSE
#else
#define g_bRunOnNT5 TRUE
#endif
#else
#define g_bRunOnNT  FALSE
#define g_bRunOnNT5 FALSE
#endif

EXTERN_C BOOL g_bRunOnIE4Shell;

#ifdef DOWNLEVEL

#pragma message("DOWNLEVEL is defined")

#undef PathBuildRoot
#undef PathCombine
#undef PathFileExists
#undef PathIsDirectory
#undef PathIsUNC
#undef PathRemoveArgs

#undef PathFindExtension
STDAPI_(LPTSTR) PathFindExtension(LPCTSTR pszPath);

#undef PathFindFileName
STDAPI_(LPTSTR) PathFindFileName(LPCTSTR pPath);

#undef PathIsRoot
STDAPI_(BOOL) PathIsRoot(LPCTSTR pPath);

#undef PathQuoteSpaces
STDAPI_(void) PathQuoteSpaces(LPTSTR lpsz);

#undef PathRemoveBlanks
STDAPI_(void) PathRemoveBlanks(LPTSTR lpszString);

#undef PathRemoveFileSpec
STDAPI_(BOOL) PathRemoveFileSpec(LPTSTR pFile);

#undef PathGetArgs
STDAPI_(LPTSTR) PathGetArgs(LPCTSTR pszPath);

#undef PathStripToRoot
STDAPI_(BOOL) PathStripToRoot(LPTSTR szRoot);

#undef PathUnquoteSpaces
STDAPI_(void) PathUnquoteSpaces(LPTSTR lpsz);

#undef SHAnsiToUnicode
STDAPI_(int)
SHAnsiToUnicode(LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf);

#undef SHDeleteKey

#ifdef UNICODE
STDAPI_(DWORD)
SHDeleteKeyW(
    IN HKEY    hkey, 
    IN LPCWSTR pwszSubKey);
#define SHDeleteKey SHDeleteKeyW
#else
STDAPI_(DWORD)
SHDeleteKeyA(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey);
#define SHDeleteKey SHDeleteKeyA
#endif

#undef SHQueryValueEx
#undef SHQueryValueExA
#undef SHQueryValueExW

STDAPI_(DWORD)
SHQueryValueExW(
    IN     HKEY    hkey,
    IN     LPCWSTR pwszValue,
    IN     LPDWORD lpReserved,
    OUT    LPDWORD pdwType,
    OUT    LPVOID  pvData,
    IN OUT LPDWORD pcbData);

STDAPI_(DWORD)
SHQueryValueExA(
    IN     HKEY    hkey,
    IN     LPCSTR  pszValue,
    IN     LPDWORD lpReserved,
    OUT    LPDWORD pdwType,
    OUT    LPVOID  pvData,
    IN OUT LPDWORD pcbData);

#ifdef UNICODE
#define SHQueryValueEx SHQueryValueExW
#else
#define SHQueryValueEx SHQueryValueExA
#endif

#undef SHStrDup

#ifdef UNICODE
STDAPI SHStrDupW(LPCWSTR psz, WCHAR **ppwsz);
#define SHStrDup SHStrDupW
#else
STDAPI SHStrDupA(LPCSTR psz, WCHAR **ppwsz);
#define SHStrDup SHStrDupA
#endif

#define OVERRIDE_SHLWAPI_PATH_FUNCTIONS

#include "shsemip.h"

#endif //DOWNLEVEL

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\scripts.h ===
EXTERN_C LPVOID ScriptManagerInitScripts();
EXTERN_C void ScriptManagerRunScripts(LPVOID *ppScriptManager);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\sccls.c ===
#include "priv.h"
#include "sccls.h"

extern const IClassFactoryVtbl c_CFVtbl;        // forward

//
// This array holds information needed for ClassFactory.
//
// PERF: this table should be ordered in most-to-least used order
//
const OBJECTINFO g_ObjectInfo[] =
{
    
    &c_CFVtbl, &CLSID_ShellAppManager,         CShellAppManager_CreateInstance,
        COCREATEONLY,

#ifndef DOWNLEVEL_PLATFORM
    &c_CFVtbl, &CLSID_DarwinAppPublisher,      CDarwinAppPublisher_CreateInstance,
        COCREATEONLY,
#endif //DOWNLEVEL_PLATFORM

    &c_CFVtbl, &CLSID_EnumInstalledApps,       CEnumInstalledApps_CreateInstance,
        COCREATEONLY, 

    NULL, NULL, NULL, NULL, NULL, 0, 0,0,
} ;


// static class factory (no allocs!)

STDMETHODIMP CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = (void *)pcf;
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory_AddRef(IClassFactory *pcf)
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory_Release(IClassFactory *pcf)
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, &IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        OBJECTINFO *this = IToClass(OBJECTINFO, cf, pcf);
        IUnknown *punk;
        HRESULT hres;
        
        if (punkOuter) {

            if (!(this->dwClassFactFlags & OIF_ALLOWAGGREGATION))
                return CLASS_E_NOAGGREGATION;
        }

        // if we're aggregated, then we know we're looking for an
        // IUnknown so we should return punk directly. otherwise
        // we need to QI.
        //
        hres = this->pfnCreateInstance(punkOuter, &punk, this);
        if (SUCCEEDED(hres))
        {
            if (punkOuter)
            {
                *ppv = (LPVOID)punk;
            }
            else
            {
                hres = punk->lpVtbl->QueryInterface(punk, riid, ppv);
                punk->lpVtbl->Release(punk);
            }
        }
    
        ASSERT(FAILED(hres) ? *ppv == NULL : TRUE);
        return hres;
    }
}

STDMETHODIMP CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{
    extern LONG g_cRefThisDll;

    if (fLock)
        DllAddRef();
    else
        DllRelease();
    TraceMsg(DM_TRACE, "sccls: LockServer(%s) to %d", fLock ? TEXT("LOCK") : TEXT("UNLOCK"), g_cRefThisDll);
    return S_OK;
}

const IClassFactoryVtbl c_CFVtbl = {
    CClassFactory_QueryInterface, CClassFactory_AddRef, CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer
};


STDAPI GetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hres = CLASS_E_CLASSNOTAVAILABLE;
    
    extern IClassFactory *CInstClassFactory_Create(const CLSID *pInstID);

    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        const OBJECTINFO *pcls;
        for (pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, pcls->pclsid))
            {
                *ppv = (void *)&(pcls->cf);
                DllAddRef();        // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\scripts.cpp ===
//+-------------------------------------------------------------------------
//
//  AppWiz.cpl - "Add or Remove Programs" CPL.
//  Copyright (C) Microsoft
//
//  File:       Scripts.CPP 
//              authomates running of TS application compatibility scripts
//
//  History:    Nov-14-2000   skuzin  Created
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <regapi.h>
#include <tsappcmp.h>
#include "Scripts.h"

#include <list>
using namespace std;
  
//
//Struct to establish correspondence between app. name (key name)
//and install and uninstall script names
//
class CAppScript
{
private:
    LPWSTR m_szKeyName; //key name that represents installed application
    LPWSTR m_szInstallScript; //install script name
    LPWSTR m_szUninstallScript; //uninstall script name
    DWORD m_bNeedReboot; //If set - then scripts must be run after reboot.
    BOOL m_bAlreadyInstalled; // 
public:
    //
    CAppScript() : 
        m_szKeyName(NULL), m_szInstallScript(NULL), m_szUninstallScript(NULL),
        m_bNeedReboot(FALSE), m_bAlreadyInstalled(FALSE)
    {
    }
    ~CAppScript()
    {
        if(m_szKeyName)
        {
            LocalFree(m_szKeyName);
        }

        if(m_szInstallScript)
        {
            LocalFree(m_szInstallScript);
        }

        if(m_szUninstallScript)
        {
            LocalFree(m_szUninstallScript);
        }
    }

    BOOL Load(HKEY hKeyParent,LPCWSTR szKeyName);
    BOOL RunScriptIfApplicable();

private:
    BOOL RunScript(LPCWSTR szDir, LPCWSTR szScript);
    BOOL PrepareScriptForReboot(LPCWSTR szInstallDir, LPCWSTR szScript);
    //BUGBUG this function is public for test only
};

//This class describes a list of pointers 
//to objects of class CAppScript
class CAppScriptList : public list<CAppScript*>
{
public:
    //Deletes all CAppScript objects 
    //before destroing the list itself.
    ~CAppScriptList()
    {
        CAppScriptList::iterator it;
            
        for(it=begin();it!=end(); it++)
        {
            delete (*it);
        }
    }
};

class CAppScriptManager
{
private:
    CAppScriptList m_AppScriptList;
public:
    CAppScriptManager(){};
    ~CAppScriptManager(){};

    BOOL Init();
    BOOL RunScripts();
private:
    BOOL LoadSupportedAppList();
    BOOL IsAppCompatOn();
};


//Functions - helpers.
DWORD RegLoadString(HKEY hKey, LPCWSTR szValueName, LPWSTR *pszValue);
DWORD RegLoadDWORD(HKEY hKey, LPCWSTR szValueName, DWORD *pdwValue);
BOOL  RegIsKeyExist(HKEY hKeyParent, LPCWSTR szKeyName);
DWORD RegGetKeyInfo(HKEY hKey, LPDWORD pcSubKeys, LPDWORD pcMaxNameLen);
DWORD RegKeyEnum(HKEY hKey, DWORD dwIndex, LPWSTR szSubKeyName, DWORD cSubKeyName);

///////////////////////////////////////////////////////////////////////////////
//Exports
///////////////////////////////////////////////////////////////////////////////
extern "C"
LPVOID 
ScriptManagerInitScripts()
{
    CAppScriptManager *pScriptManager = new CAppScriptManager();
    if(pScriptManager)
    {
        if(!pScriptManager->Init())
        {
            delete pScriptManager;
            pScriptManager = NULL;
        }
    }

    return pScriptManager; 
}

extern "C"
void 
ScriptManagerRunScripts(
        LPVOID *ppScriptManager)
{
    if(*ppScriptManager)
    {
        CAppScriptManager *pScriptManager = reinterpret_cast<CAppScriptManager *>(*ppScriptManager);
        pScriptManager->RunScripts();
        delete pScriptManager;
        *ppScriptManager = NULL;
    }
}

///////////////////////////////////////////////////////////////////////////////
//class CAppScript
///////////////////////////////////////////////////////////////////////////////

/******************************************************************************
CAppScript::Load()
Purpose:
Loads script information from the registry
Sets m_bIsInitiallyInstalled to TRUE if app already installed
******************************************************************************/
BOOL 
CAppScript::Load(
        HKEY hKeyParent,
        LPCWSTR szKeyName)
{
    DWORD err;
    HKEY hKey;

    err = RegOpenKeyExW(hKeyParent, szKeyName, 0, KEY_QUERY_VALUE, &hKey );

    if(err == ERROR_SUCCESS)
    {
        RegLoadString(hKey, L"KeyName", &m_szKeyName);
        RegLoadString(hKey, L"InstallScript", &m_szInstallScript);
        RegLoadString(hKey, L"UninstallScript", &m_szUninstallScript);
        RegLoadDWORD(hKey, L"NeedReboot", &m_bNeedReboot);

        RegCloseKey(hKey);

        if(m_szKeyName)
        {
            m_bAlreadyInstalled = RegIsKeyExist(HKEY_LOCAL_MACHINE, m_szKeyName);
            return TRUE;
        }
    }
    
    return FALSE;
}

/******************************************************************************
CAppScript::RunScriptIfApplicable()
Purpose:
Checks if the application was installed or uninstalled and runs the script.
If m_bNeedReboot flag is set - schedules the script to run after reboot.
******************************************************************************/
BOOL 
CAppScript::RunScriptIfApplicable()
{
    KdPrint(("CAppScript::RunScriptIfApplicable() - ENTER\n"));

    const WCHAR szInstallSubDir[] = L"\\Application Compatibility Scripts\\Install";
    const WCHAR szUninstallSubDir[] = L"\\Application Compatibility Scripts\\Uninstall";
    static WCHAR szInstallDir[MAX_PATH+sizeof(szInstallSubDir)/sizeof(WCHAR)+1] = L"";
    static WCHAR szUninstallDir[MAX_PATH+sizeof(szUninstallSubDir)/sizeof(WCHAR)+1] = L"";
    
    if(!szInstallDir[0])
    {
        //Get the scripts location
        //We need to do it only once
        
        //get Windows directory name
        if(!GetSystemWindowsDirectoryW(szInstallDir,MAX_PATH))
        {
            KdPrint(("CAppScript::RunScriptIfApplicable() - GetWindowsDirectoryW() FAILED\n"));
            return FALSE;
        }
        
        wcscpy(szUninstallDir,szInstallDir);
        wcscat(szInstallDir,szInstallSubDir);
        wcscat(szUninstallDir,szUninstallSubDir);
    }

    if(!m_bAlreadyInstalled && RegIsKeyExist(HKEY_LOCAL_MACHINE, m_szKeyName) && m_szInstallScript)
    {
        //Application was installed
        if(m_bNeedReboot)
        {
            //Setup will continue after reboot
            //Create RunOnce entry to run script after system is rebooted
            KdPrint(("CAppScript::RunScriptIfApplicable() - PrepareScriptForReboot %ws\n",m_szInstallScript));
            if(!PrepareScriptForReboot(szInstallDir, m_szInstallScript))
            {
                KdPrint(("CAppScript::PrepareScriptForReboot() - FAILED\n",m_szInstallScript));
                return FALSE;
            }

        }
        else
        {
            KdPrint(("CAppScript::RunScriptIfApplicable() - executing script %ws\n",m_szInstallScript));
            if(!RunScript(szInstallDir,m_szInstallScript))
            {
                KdPrint(("CAppScript::RunScriptIfApplicable() - executing script FAILED\n",m_szInstallScript));
                return FALSE;
            }
        }

        m_bAlreadyInstalled = TRUE;
    }
    else
    {
        if(m_bAlreadyInstalled && !RegIsKeyExist(HKEY_LOCAL_MACHINE, m_szKeyName) && m_szUninstallScript)
        {
            //Application was uninstalled
            
            KdPrint(("CAppScript::RunScriptIfApplicable() - executing script %ws\n",m_szUninstallScript));
            if(!RunScript(szUninstallDir,m_szUninstallScript))
            {
                KdPrint(("CAppScript::RunScriptIfApplicable() - executing script FAILED\n",m_szUninstallScript));
                return FALSE;
            }

            m_bAlreadyInstalled = FALSE;
        }
    }

    return TRUE;
}

/******************************************************************************
CAppScript::RunScript()
Purpose:
Runs script
Waits untill script finishes
******************************************************************************/
BOOL 
CAppScript::RunScript(
        LPCWSTR szDir, 
        LPCWSTR szScript)
{
    WCHAR szCmdLineTemplate[] = L"cmd.exe /C %s";
    DWORD dwSize = wcslen(szScript)*sizeof(WCHAR)+sizeof(szCmdLineTemplate);
    LPWSTR szCmdLine = (LPWSTR)LocalAlloc(LPTR,dwSize);

    if(!szCmdLine)
    {
        return FALSE;
    }

    swprintf(szCmdLine,szCmdLineTemplate,szScript);    
    
    STARTUPINFO si;               // startup information
    PROCESS_INFORMATION pi; // process information
    
    //Prepare startup info
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);

    BOOL bResult = CreateProcessW(
                  NULL,                 // name of executable module
                  szCmdLine,                      // command line string
                  NULL, // SD
                  NULL,  // SD
                  FALSE,                      // handle inheritance option
                  CREATE_NEW_CONSOLE,                     // creation flags
                  NULL,                      // new environment block
                  szDir,                // current directory name
                  &si,               // startup information
                  &pi // process information
                );

    LocalFree(szCmdLine);

    if(bResult)
    {
        WaitForSingleObject(pi.hProcess, INFINITE);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
 
    return bResult;
}

/******************************************************************************
CAppScript::PrepareScriptForReboot()
Purpose:
Creates CMD file that will change current directory to 
...\Application Compatibility Scripts\Install 
and then run the script.
Schedules this CMD file to be run after reboot by creating an entry uder 
"HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce" key.
******************************************************************************/
BOOL 
CAppScript::PrepareScriptForReboot(
        LPCWSTR szInstallDir, 
        LPCWSTR szScript)
{
    WCHAR szFileNameTemplate[] = L"%s\\RunOnce.cmd";

    LPWSTR szFullFileName = (LPWSTR)LocalAlloc(LPTR,
        wcslen(szInstallDir)*sizeof(WCHAR)+sizeof(szFileNameTemplate));

    if(!szFullFileName)
    {
        return FALSE;
    }
    
    //Assemble full file name
    swprintf(szFullFileName,szFileNameTemplate,szInstallDir);    

    HANDLE hFile = CreateFile(
                    szFullFileName,                         // file name
                    GENERIC_WRITE,                      // access mode
                    0,                          // share mode
                    NULL, // SD
                    CREATE_NEW,                // how to create
                    FILE_ATTRIBUTE_NORMAL,                 // file attributes
                    NULL                        // handle to template file
                    );
    
    LocalFree(szFullFileName);
    
    //File did not exist
    if(hFile != INVALID_HANDLE_VALUE)
    {
        //File did not exist before
        //create code and write it into the file.
        //need code in ANSI
        char szCodeTemplate[] = "cd %S\r\n%%1\r\n";
        DWORD nNumberOfBytesToWrite = wcslen(szInstallDir)+sizeof(szCodeTemplate);
        DWORD nNumberOfBytesWritten = 0;

        LPSTR szFileCode = (LPSTR)LocalAlloc(LPTR, nNumberOfBytesToWrite);

        if(!szFileCode)
        {
            CloseHandle(hFile);
            return FALSE;
        }
        
        sprintf(szFileCode, szCodeTemplate,szInstallDir);
        nNumberOfBytesToWrite = strlen(szFileCode);

        BOOL bResult = WriteFile(
                        hFile,                    // handle to file
                        (LPCVOID)szFileCode,                // data buffer
                        nNumberOfBytesToWrite,     // number of bytes to write
                        &nNumberOfBytesWritten,  // number of bytes written
                        NULL        // overlapped buffer
                        );

        CloseHandle(hFile);
        LocalFree(szFileCode);

        if(!bResult || nNumberOfBytesToWrite != nNumberOfBytesWritten )
        {
            return FALSE;
        }
    }
    else
    {
        if(GetLastError()!=ERROR_FILE_EXISTS)
        {
            return FALSE;
        }
        //If file already exists - do only registry changes.
    }

    //Registry changes:
    WCHAR szCommandTemplate[] = L"\"%s\\RunOnce.cmd\" %s";
    DWORD cbCommandLen = (wcslen(szInstallDir)+wcslen(szScript))*sizeof(WCHAR)+sizeof(szCommandTemplate);
    LPWSTR szCommand = (LPWSTR)LocalAlloc(LPTR,cbCommandLen);

    if(!szCommand)
    {
        return FALSE;
    }
    
    swprintf(szCommand,szCommandTemplate,szInstallDir,szScript); 
    cbCommandLen = (wcslen(szCommand)+1)*sizeof(WCHAR);

    HKEY hKey;
    LONG err;
    err = RegCreateKeyExW(HKEY_CURRENT_USER,
                    L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
                    0,
                    NULL,
                    0,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    NULL);
    if(err == ERROR_SUCCESS)
    {
        err = RegSetValueExW(hKey,
                    L"ZZZAppCompatScript",
                    0,
                    REG_SZ,
                    (CONST BYTE *)szCommand,
                    cbCommandLen);
        RegCloseKey(hKey);
    }

    LocalFree(szCommand);

    if(err == ERROR_SUCCESS)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

///////////////////////////////////////////////////////////////////////////////
//class CAppScriptManager
///////////////////////////////////////////////////////////////////////////////

/******************************************************************************
CAppScriptManager::Init()
Purpose:
Initialization. 
Returns FALSE if TS Application Compatibility if OFF or list of supported
applications was not found in the registry.
******************************************************************************/
BOOL 
CAppScriptManager::Init()
{
    //DebugBreak();
    KdPrint(("CAppScriptManager::Init() - ENTER\n"));

    if(!IsAppCompatOn())
    {
        KdPrint(("CAppScriptManager::Init() - TS App Compat is off!\n"));
        return FALSE;
    }

    if(!LoadSupportedAppList())
    {
        KdPrint(("CAppScriptManager::Init() - LoadSupportedAppList() FAILED\n"));
        return FALSE;
    }
    
    KdPrint(("CAppScriptManager::Init() - OK\n"));
    return TRUE;
}

/******************************************************************************
CAppScriptManager::LoadSupportedAppList()
Purpose:
Loads from the registry the list of applications we care about
along with their script names. Save this information in array of 
APP_SCRIPT structures.
******************************************************************************/
BOOL 
CAppScriptManager::LoadSupportedAppList()
{
    HKEY hKey;
    LONG err;
    DWORD cSubKeys;
    DWORD cMaxSubKeyLen;

    KdPrint(("CAppScriptManager::LoadSupportedAppList() - ENTER\n"));
    
    err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Compatibility\\Scripts",
        0, KEY_READ, &hKey );
    
    if(err == ERROR_SUCCESS)
    {

        err = RegGetKeyInfo(hKey, &cSubKeys, &cMaxSubKeyLen);

        if(err == ERROR_SUCCESS)
        {
            cMaxSubKeyLen+=1; //to include terminating NULL character
            KdPrint(("CAppScriptManager::LoadSupportedAppList() - %d apps supported\n",cSubKeys));
            //Allocate buffer for subkey names
            LPWSTR szKeyName = (LPWSTR)LocalAlloc(LPTR,cMaxSubKeyLen*sizeof(WCHAR));
        
            if(!szKeyName)
            {
                RegCloseKey(hKey);
                return FALSE;
            }
            
            

            CAppScript *pAppScript = NULL;

            for(DWORD i=0;i<cSubKeys;i++)
            {
                //Get the key name
                err = RegKeyEnum(hKey, i, szKeyName, cMaxSubKeyLen );
                
                if(err != ERROR_SUCCESS)
                {
                    break;
                }

                KdPrint(("CAppScriptManager::LoadSupportedAppList() - loading %ws\n",szKeyName));

                pAppScript = new CAppScript();
                if(!pAppScript)
                {
                    break;
                }
                
                if(pAppScript->Load(hKey, szKeyName))
                {
                    m_AppScriptList.push_back(pAppScript);
                }
                else
                {
                    KdPrint(("CAppScriptManager::LoadSupportedAppList() - FAILED to load\n"));
                    delete pAppScript;
                }
                
            }

            LocalFree(szKeyName);
        }
        
        RegCloseKey(hKey);
    }
    
    if(err != ERROR_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

/******************************************************************************
CAppScriptManager::RunScripts()
Purpose:
Runs scripts for all installed or uninstalled applications.
******************************************************************************/
BOOL 
CAppScriptManager::RunScripts()
{

    BOOL bInstallMode = FALSE;
    KdPrint(("CAppScriptManager::RunScripts() - ENTER\n"));
    //system must be now in INSTALL mode, set EXECUTE mode
    if(TermsrvAppInstallMode())
    {
        bInstallMode = TRUE;
        KdPrint(("CAppScriptManager::RunScripts() - set EXECUTE mode\n"));
        if(!SetTermsrvAppInstallMode(FALSE))
        {
            KdPrint(("CAppScriptManager::RunScripts() - SetTermsrvAppInstallMode() FAILED\n"));
            return FALSE;
        }
    }
    
    CAppScriptList::iterator it;
            
    for(it=m_AppScriptList.begin();it!=m_AppScriptList.end(); it++)
    {
        (*it)->RunScriptIfApplicable();
    }

    if(bInstallMode)
    {
        //Restore INSTALL mode
        KdPrint(("CAppScriptManager::RunScripts() - return to INSTALL mode\n"));
        if(!SetTermsrvAppInstallMode(TRUE))
        {
            KdPrint(("CAppScriptManager::RunScripts() - SetTermsrvAppInstallMode() FAILED\n"));
            return FALSE;
        }
    }

    KdPrint(("CAppScriptManager::RunScripts() - FINISH\n"));
    return TRUE;
}

/******************************************************************************
CAppScriptManager::IsAppCompatOn()
Purpose:
Checks if TS Application Compatibility mode is enabled.
Returns TRUE if enabled, 
otherwise, as well as in case of any error, returns FALSE.
******************************************************************************/
BOOL 
CAppScriptManager::IsAppCompatOn()
{
    HKEY hKey;
    DWORD dwData;
    BOOL fResult = FALSE;
    
    KdPrint(("CAppScriptManager::IsAppCompatOn() - ENTER\n"));

    if( RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                  REG_CONTROL_TSERVER,
                  0,
                  KEY_QUERY_VALUE,
                  &hKey) == ERROR_SUCCESS )
    {
	
        if(RegLoadDWORD(hKey, L"TSAppCompat", &dwData) == ERROR_SUCCESS )
        {
            KdPrint(("CAppScriptManager::IsAppCompatOn() - OK; Result=%d\n",dwData));
            fResult = dwData;
        }
    
        RegCloseKey(hKey);
    }

    return fResult;
}

///////////////////////////////////////////////////////////////////////////////
//Functions - helpers.
///////////////////////////////////////////////////////////////////////////////
/******************************************************************************
RegLoadString()
Purpose:
Loads a REG_SZ value from the registry
Allocates buffer.
Buffer then need to be freed using LocalFree function.
******************************************************************************/
DWORD
RegLoadString(
        HKEY hKey, 
        LPCWSTR szValueName, 
        LPWSTR *pszValue)
{
    
    DWORD cbData = 0;
    
    *pszValue = NULL;

    DWORD err = RegQueryValueExW(
                    hKey,            // handle to key
                    szValueName,  // value name
                    NULL,   // reserved
                    NULL,       // type buffer
                    NULL,        // data buffer
                    &cbData      // size of data buffer
                    );
    if(err == ERROR_SUCCESS)
    {
        *pszValue = (LPWSTR)LocalAlloc(LPTR,cbData);
        if(!*pszValue)
        {
            return GetLastError();
        }

        err = RegQueryValueExW(
                    hKey,            // handle to key
                    szValueName,  // value name
                    NULL,   // reserved
                    NULL,       // type buffer
                    (LPBYTE)*pszValue,        // data buffer
                    &cbData      // size of data buffer
                    );
        if(err !=ERROR_SUCCESS)
        {
            LocalFree(*pszValue);
            *pszValue = NULL;
        }

    }

    return err;
}

/******************************************************************************
RegLoadDWORD()
Purpose:
Loads a REG_DWORD value from the registry
******************************************************************************/
DWORD 
RegLoadDWORD(
        HKEY hKey, 
        LPCWSTR szValueName, 
        DWORD *pdwValue)
{
    DWORD cbData = sizeof(DWORD);

    return RegQueryValueExW(
              hKey,            // handle to key
              szValueName,  // value name
              NULL,   // reserved
              NULL,       // type buffer
              (LPBYTE)pdwValue,        // data buffer
              &cbData      // size of data buffer
            );
}

/******************************************************************************
RegIsKeyExist()
Purpose:
Checks if key exists
******************************************************************************/
BOOL 
RegIsKeyExist(
        HKEY hKeyParent, 
        LPCWSTR szKeyName)
{
    LONG    err;
    HKEY    hKey;
    
    KdPrint(("RegIsKeyExist() - Opening key: hKeyParent=%d Key: %ws\n",hKeyParent,szKeyName));
    
    err = RegOpenKeyExW(hKeyParent, szKeyName, 0, MAXIMUM_ALLOWED, &hKey );

    if(err == ERROR_SUCCESS)
    {
        KdPrint(("RegIsKeyExist() - Key Exists!\n",err));
        RegCloseKey(hKey);
        return TRUE;
    }
    else
    {
        KdPrint(("RegIsKeyExist() - err=%d\n",err));
        return FALSE;
    }
}

/******************************************************************************
RegGetKeyInfo()
Purpose:
Gets key's number of sub keys and max sub key name length
******************************************************************************/
DWORD
RegGetKeyInfo(
        HKEY hKey,
        LPDWORD pcSubKeys,
        LPDWORD pcMaxNameLen)
{
    return RegQueryInfoKey(
              hKey,                      // handle to key
              NULL,                 // class buffer
              NULL,               // size of class buffer
              NULL,             // reserved
              pcSubKeys,             // number of subkeys
              pcMaxNameLen,        // longest subkey name (in TCHARs)
              NULL,         // longest class string
              NULL,              // number of value entries
              NULL,     // longest value name
              NULL,         // longest value data
              NULL, // descriptor length
              NULL     // last write time
            );
    
}

/******************************************************************************
RegKeyEnum()
Purpose:
Enumerates sub keys of the registry key
******************************************************************************/
DWORD
RegKeyEnum(
        HKEY hKey,                  // handle to key to enumerate
        DWORD dwIndex,              // subkey index
        LPWSTR szSubKeyName,              // subkey name
        DWORD cSubKeyName)
{
    FILETIME ftLastWriteTime;

    return RegEnumKeyExW(
              hKey,                  // handle to key to enumerate
              dwIndex,              // subkey index
              szSubKeyName,              // subkey name
              &cSubKeyName,            // size of subkey buffer
              NULL,         // reserved
              NULL,             // class string buffer
              NULL,           // size of class string buffer
              &ftLastWriteTime // last write time
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\setupenum.h ===
#ifndef __SETUPENUM_H_
#define __SETUPENUM_H_

class COCSetupApp
{
public:

    COCSetupApp();
    ~COCSetupApp();
    
    BOOL GetAppInfo(APPINFODATA *pai);
    BOOL ReadFromKey(HKEY hkey);
    BOOL Run();

    TCHAR _szDisplayName[MAX_PATH];

protected:
    TCHAR _szApp[MAX_PATH];
    TCHAR _szArgs[MAX_PATH];
};

class COCSetupEnum
{
public:
    COCSetupEnum();
    ~COCSetupEnum();

    BOOL EnumOCSetupItems();
    BOOL Next(COCSetupApp **);

    static BOOL s_OCSetupNeeded();

protected:
    HKEY _hkeyRoot;
    int _iRegEnumIndex;     // used to walk through the items
};

#endif //__SETUPENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\sccls.h ===
// Create Instance functions

#ifndef _SCCLS_H_
#define _SCCLS_H_

//
// global object array - used for class factory, auto registration, type libraries, oc information
//
typedef struct tagOBJECTINFO
{
#ifdef __cplusplus
    void *cf;
#else
    const IClassFactoryVtbl *cf;
#endif
    CLSID const* pclsid;
    HRESULT (*pfnCreateInstance)(IUnknown* pUnkOuter, IUnknown** ppunk, const struct tagOBJECTINFO *);

    // for OCs and automation objects:
    IID const* piid;
    IID const* piidEvents;
    long lVersion;
    DWORD dwOleMiscFlags;
    DWORD dwClassFactFlags;
} OBJECTINFO;

typedef OBJECTINFO const * LPCOBJECTINFO;

#define OIF_ALLOWAGGREGATION  0x0001



#define VERSION_2 2 // so we don't get confused by too many integers
#define VERSION_1 1
#define VERSION_0 0
#define COCREATEONLY NULL,NULL,VERSION_0,0,0 // piid,piidEvents,lVersion,dwOleMiscFlags,dwClassFactFlags
#define COCREATEONLY_NOFLAGS NULL,NULL,VERSION_0,0 // piid,piidEvents,lVersion,dwOleMiscFlags



STDAPI  CShellAppManager_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CEnumInstalledApps_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
#ifndef DOWNLEVEL_PLATFORM
STDAPI  CDarwinAppPublisher_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
#endif //DOWNLEVEL_PLATFORM

// to save some typing:
#define CLSIDOFOBJECT(p)          (*((p)->_pObjectInfo->pclsid))
#define VERSIONOFOBJECT(p)          ((p)->_pObjectInfo->lVersion)
#define EVENTIIDOFCONTROL(p)      (*((p)->_pObjectInfo->piidEvents))
#define OLEMISCFLAGSOFCONTROL(p)    ((p)->_pObjectInfo->dwOleMiscFlags)

extern const OBJECTINFO g_ObjectInfo[]; // sccls.c

STDAPI GetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);

#endif // _SCCLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\setup.c ===
//
//  Setup.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  ral 5/23/94 - First pass
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"



void _inline InitSetupWiz(HWND hDlg, LPARAM lParam)
{
    InitWizSheet(hDlg, lParam, 0);
}


//
//  Loads the specified resource ID string and replaces all ';' characters
//  with NULL.        The end of the string will be doubly null-teminated.
//

BOOL LoadAndStrip(int id, LPTSTR lpsz, int cbstr)
{
    ASSERT(lpsz);
    ASSERT(cbstr != 0);

    if (!LoadString(g_hinst, id, lpsz, cbstr-1))
    {
        return FALSE;
    }
    else
    {
        while (*lpsz)
        {
            if (*lpsz == TEXT('@'))
            {
                *lpsz = 0;
                lpsz++;
            }
            else
            {
                lpsz = CharNext(lpsz);
            }
        }
        *(lpsz+1) = 0;
        return TRUE;
    }
}


//
//  Skips to the first charcter of the next string in a list of null-terminated
//  strings.  The caller should check to see if the pointer returned points to
//  a null.  If so, the end of the table has been reached.
//

LPTSTR SkipStr(LPTSTR lpsz)
{
    while (*lpsz)
    {
        lpsz = CharNext(lpsz);
    }
    lpsz++;

    return(lpsz);
}


void SetStaticStr(HWND hCtl, int id)
{
    TCHAR szText[MAX_PATH];

    LoadString(g_hinst, id, szText, ARRAYSIZE(szText));

    Static_SetText(hCtl, szText);
}


void FreeIcon(HWND hDlg)
{
    HICON hicon = Static_SetIcon(GetDlgItem(hDlg, IDC_SEARCHICON), NULL);

    if (hicon)
    {
        DestroyIcon(hicon);
    }
}


//
//  ProgramExists returns TRUE if the specified file exists.  This function
//  accepts wildcards, and if a file matches the specified name then
//  the file name buffer will be updated to the actual name of the first
//  matching file.  This allows FindBestSetupPrg to pass in *setup to find
//  programs such as WPSETUP.EXE.
//
//  This function assumes that szFindName is of size MAX_PATH.
//

BOOL ProgramExists(LPTSTR lpszFindName)
{
    HANDLE hfind;
    WIN32_FIND_DATA fd;

    hfind = FindFirstFile(lpszFindName, &fd);

    if (hfind == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    FindClose(hfind);

    lstrcpy(lpszFindName+3, fd.cFileName);

    return(TRUE);
}


//
//  This function searches for the "best" setup program.  Once a windows app
//  with the appropriate name is found it stops.  If it finds a install/setup
//  program that is a DOS program, it remembers the first one, but continues
//  searching for a Windows setup program.
//  Games like Math Rabbit have a DOS Install.Exe and a Windows Setup.Exe.
//

BOOL FindBestSetupPrg(LPTSTR lpszExeName, LPTSTR lpszDriveRoot, LPTSTR lpszSpecialCase,
                      LPTSTR lpszAppNames, LPTSTR lpszExtensions)
{
    LPTSTR  lpszCurApp, lpszCurExt;
    TCHAR   szThisOne[MAX_PATH];

    *lpszExeName = 0;

    //
    //        Look for special-case programs first
    //

    lpszCurApp = lpszSpecialCase;

    while(*lpszCurApp)
    {
        lstrcpy(szThisOne, lpszDriveRoot);
        lstrcat(szThisOne, lpszCurApp);

        if (ProgramExists(szThisOne))
        {
            lstrcpy(lpszExeName, szThisOne);
            return(TRUE);
        }

        lpszCurApp = SkipStr(lpszCurApp);
    }

    //
    //        Now look for generic setup program names
    //

    lpszCurApp = lpszAppNames;

    while (*lpszCurApp)
    {
        lpszCurExt = lpszExtensions;

        while (*lpszCurExt)
        {
            lstrcpy(szThisOne, lpszDriveRoot);
            lstrcat(szThisOne, lpszCurApp);
            lstrcat(szThisOne, TEXT("."));
            lstrcat(szThisOne, lpszCurExt);

            if (ProgramExists(szThisOne))
            {
                BOOL fIsWinApp = HIWORD(SHGetFileInfo(szThisOne, 0, NULL,
                                                      0, SHGFI_EXETYPE)) > 0;

                if (*lpszExeName == 0 || fIsWinApp)
                {
                    lstrcpy(lpszExeName, szThisOne);
                }

                if (fIsWinApp)
                {
                    return(TRUE);
                }
            }

            lpszCurExt = SkipStr(lpszCurExt);
        }

        lpszCurApp = SkipStr(lpszCurApp);
    }

    return(*lpszExeName != 0);
}


//
//  Gets information about the specified file/drive root and sets the
//  icon and description fields in the dialog.
//

void _inline UpdateFileInfo(LPWIZDATA lpwd, LPTSTR lpszFileName)
{
    HWND        hKiddie;
    HICON       hOldIcon;
    SHFILEINFO  fi;
    DWORD_PTR   pdwRes;

    pdwRes = SHGetFileInfo(lpszFileName, 0, &fi, sizeof(fi),
                           SHGFI_ICON | SHGFI_DISPLAYNAME | SHGFI_LARGEICON);
    
    if (pdwRes)
    {
        hKiddie = GetDlgItem(lpwd->hwnd, IDC_SEARCHICON);

        hOldIcon = Static_SetIcon(hKiddie, fi.hIcon);

        if (hOldIcon)
        {
            DestroyIcon(hOldIcon);
        }

        UpdateWindow(hKiddie);

        hKiddie = GetDlgItem(lpwd->hwnd, IDC_SEARCHNAME);

        Static_SetText(hKiddie, fi.szDisplayName);

        UpdateWindow(hKiddie);
    }
}


//
//  Search for the setup program
//

BOOL SetupNextPressed(LPWIZDATA lpwd)
{
    int   iDrive, iDrvType;
    BOOL  fFoundExe = FALSE;
    HWND  hMainMsg = GetDlgItem(lpwd->hwnd, IDC_SETUPMSG);
    HWND  hSetupName = GetDlgItem(lpwd->hwnd, IDC_SEARCHNAME);
    TCHAR szAppNames[MAX_PATH];
    TCHAR szExtensions[100];
    TCHAR szSpecialCase[MAX_PATH];
    TCHAR szDriveRoot[4];

    HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //BOOL fFoundDisk = FALSE;

    lpwd->szExeName[0] = 0;        // Reset any existing name

    SetStaticStr(hMainMsg, IDS_SEARCHING);

    LoadAndStrip(IDS_SETUPPRGNAMES, szAppNames,    ARRAYSIZE(szAppNames));
    LoadAndStrip(IDS_EXTENSIONS,    szExtensions,  ARRAYSIZE(szExtensions));
    LoadAndStrip(IDS_SPECIALCASE,   szSpecialCase, ARRAYSIZE(szSpecialCase));

    for (iDrive = 0; (!fFoundExe) && (iDrive < 26); iDrive++)
    {
        iDrvType = DriveType(iDrive);

        if ((iDrvType == DRIVE_REMOVABLE) || (iDrvType == DRIVE_CDROM))
        {

            PathBuildRoot(szDriveRoot, iDrive);
            UpdateFileInfo(lpwd, szDriveRoot);
            if (PathFileExists(szDriveRoot))
            {
                //fFoundDisk = TRUE;

                fFoundExe = FindBestSetupPrg(lpwd->szExeName, szDriveRoot,
                                             szSpecialCase,
                                             szAppNames, szExtensions);
            }
        }
    }

    FreeIcon(lpwd->hwnd);
    SetCursor(hcurOld);

    return(fFoundExe);
}


void SetupSetToDefault(LPWIZDATA lpwd)
{
    SetStaticStr(GetDlgItem(lpwd->hwnd, IDC_SETUPMSG), IDS_INSERTDISK);

    Static_SetText(GetDlgItem(lpwd->hwnd, IDC_SEARCHNAME), NULL);

    FreeIcon(lpwd->hwnd);

    PropSheet_SetWizButtons(GetParent(lpwd->hwnd), PSWIZB_NEXT);

    //
    // To make sure that the next button always has the focus, we post
    // this message that sets the wiz buttons AFTER we're active.  We have
    // to do the one above to make sure that Back is disabled to avoid any
    // random window where the back button could be hit.
    //

    PostMessage(lpwd->hwnd, WMPRIV_POKEFOCUS, 0, 0);
}



BOOL_PTR CALLBACK SetupDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm = NULL;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPWIZDATA lpwd = NULL;

    if (lpPropSheet)
    {
        lpwd = (LPWIZDATA)lpPropSheet->lParam;
    }

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            if(lpnm)
            {
                switch(lpnm->code)
                {
                    case PSN_SETACTIVE:
                        if(lpwd)
                        {
                            lpwd->hwnd = hDlg;
                            SetupSetToDefault(lpwd);
                        }
                        break;

                    case PSN_WIZNEXT:
                        if(lpwd)
                        {
                            SetupNextPressed(lpwd);
                            SetDlgMsgResult(hDlg, WM_NOTIFY, 0);
                        }
                        break;

                    case PSN_RESET:
                        if(lpwd)
                        {
                            CleanUpWizData(lpwd);
                        }
                        break;

                    default:
                        return FALSE;
                }
            }
            break;

        case WMPRIV_POKEFOCUS:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
            break;

        case WM_INITDIALOG:
            InitSetupWiz(hDlg, lParam);
            break;

        case WM_DESTROY:
            FreeIcon(hDlg);
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;

}  // SetupdlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\shlwapi.c ===
#include "priv.h"

// Build this file only on Win9X or NT4
#ifdef DOWNLEVEL_PLATFORM

__inline LPWSTR StrCpyNXW(LPWSTR psz1, LPCWSTR psz2, int cchMax)
{
    ASSERT(psz1);
    ASSERT(psz2);

    if (0 < cchMax)
    {
        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            if ( !(*psz1++ = *psz2++) ) {
                --psz1;
                break;
            }
        }

        if (0 == cchMax)
            *psz1 = L'\0';

        ASSERT(*psz1 == 0);
    }

    return psz1;
}

LPWSTR StrCpyNW(LPWSTR psz1, LPCWSTR psz2, int cchMax)
{
    StrCpyNXW(psz1, psz2, cchMax);
    return psz1;
}

LPWSTR StrCpyW(LPWSTR psz1, LPCWSTR psz2)
{
    LPWSTR psz = psz1;

    ASSERT(psz1);
    ASSERT(psz2);

    while (*psz1++ = *psz2++)
        ;

    return psz;
}

STDAPI_(DWORD)
RegData_AtoW(
    IN    LPCVOID pvData,
    IN    DWORD   dwSize,
    IN    DWORD   dwType,
    /*INOUT*/ LPDWORD pcbData
)
{
    DWORD dwRet = NO_ERROR;

    if (REG_SZ == dwType || REG_EXPAND_SZ == dwType || REG_MULTI_SZ == dwType)
    {
        DWORD cbData = pcbData ? *pcbData : -1;
        if (pvData)
        {
            // Allocate a temporary buffer to work with
            int cch = MultiByteToWideChar(CP_ACP, 0, (LPSTR)pvData, cbData, NULL, 0);
            LPWSTR pwszT = (LPWSTR)LocalAlloc(LPTR, CbFromCchW(cch));

            if (!pwszT)
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
            else
            {
                if (CbFromCchW(cch) > dwSize)
                    dwRet = ERROR_MORE_DATA;
                else
                {
                    // Convert it to the temporary buffer
                    MultiByteToWideChar(CP_ACP, 0, (LPSTR)pvData, cbData, pwszT, cch);

                    // Copy it back to the output buffer
                    StrCpyW((LPWSTR)pvData, pwszT);
                }
                LocalFree(pwszT);
            }

            // If string data, make room for unicode 
            if (pcbData)
            {
                (*pcbData) = cch * sizeof(WCHAR);
            }
        }
        else if (pcbData)
        {
            // We don't have the data so guess (actual value may be less)
            // PERF: Does this need to be exact?  For now this seem sufficient. (Stevepro)
            (*pcbData) *= sizeof(WCHAR);
        }
    }
    return dwRet;
}


/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.  Mimics what RegDeleteKey does in Win95.

Returns: 
Cond:    --
*/
DWORD
DeleteKeyRecursively(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, MAXIMUM_ALLOWED, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
        CHAR    szClass[MAX_PATH];
        DWORD   cbClass = ARRAYSIZE(szClass);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKeyA(hkSubKey,
                                 szClass,
                                 &cbClass,
                                 NULL,
                                 &dwIndex, // The # of subkeys -- all we need
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKeyA(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursively(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKeyA(hkey, pszSubKey);
    }

    return dwRet;
}

/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
SHDeleteKeyA(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey)
{
    DWORD dwRet;

    if (g_bRunOnNT)
    {
        dwRet = DeleteKeyRecursively(hkey, pszSubKey);
    }
    else
    {
        // On Win95, RegDeleteKey does what we want
        dwRet = RegDeleteKeyA(hkey, pszSubKey);
    }

    return dwRet;
}


/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
SHDeleteKeyW(
    IN HKEY    hkey, 
    IN LPCWSTR pwszSubKey)
{
    DWORD dwRet;
    CHAR sz[MAX_PATH];

    WideCharToMultiByte(CP_ACP, 0, pwszSubKey, -1, sz, SIZECHARS(sz), NULL, NULL);

    if (g_bRunOnNT)
    {
        dwRet = DeleteKeyRecursively(hkey, sz);
    }
    else
    {
        // On Win95, RegDeleteKey does what we want
        dwRet = RegDeleteKeyA(hkey, sz);
    }

    return dwRet;
}


/*----------------------------------------------------------
Purpose: Behaves just like RegQueryValueEx, except if the
         data type is REG_EXPAND_SZ, then this goes ahead
         and expands out the string.  *pdwType will always
         be massaged to REG_SZ if this happens.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
SHQueryValueExA(
    IN     HKEY    hkey,
    IN     LPCSTR  pszValue,
    IN     LPDWORD lpReserved,
    OUT    LPDWORD pdwType,
    OUT    LPVOID  pvData,
    IN OUT LPDWORD pcbData)
{
    DWORD dwRet;
    DWORD cbSize;
    DWORD dwType;
    LPSTR lpsz;

    // Trying to get back data

    if (pcbData)
        cbSize = *pcbData;     // Size of output buffer
        
    dwRet = RegQueryValueExA(hkey, pszValue, lpReserved, &dwType,
                             pvData, &cbSize);

    // Normally, we'd be done with this.  But do some extra work
    // if this is an expandable string (something that has system
    // variables in it), or if we need to pad the buffer.

    if (NO_ERROR == dwRet)
    {
        // Note: on Win95, RegSetValueEx will always write the 
        // full string out, including the null terminator.  On NT,
        // it won't unless the write length was specified.  
        // Hence, we have the following check.

        // Pad the buffer, in case the string didn't have a null
        // terminator when it was stored?
        if (REG_SZ == dwType)
        {
            // Yes
            if (pvData && cbSize < *pcbData) 
            {
                LPSTR lpszData = pvData;
                lpszData[cbSize] = '\0';
            }
        }
        // Expand the string?
        else if (REG_EXPAND_SZ == dwType)
        {
            // Yes

            // Use a temporary buffer to expand
            if (pvData)
            {
                lpsz = (LPSTR)LocalAlloc(LPTR, *pcbData);    
                if ( !lpsz )
                    return ERROR_OUTOFMEMORY;

                cbSize = ExpandEnvironmentStringsA(pvData, lpsz, *pcbData);

                // NT screws up the cbSize returned...
                if (cbSize > 0)
                    cbSize = lstrlenA(lpsz) + 1;
                if (cbSize > 0 && cbSize <= *pcbData) 
                    lstrcpynA(pvData, lpsz, *pcbData);
                else
                    dwRet = GetLastError();
            }
            else
            {
                //
                // Find out the length of the expanded string
                // we have to call in and actually get the data to do this
                //
                CHAR szBuff[1];

                lpsz = (LPSTR)LocalAlloc(LPTR, cbSize);
                if (!lpsz)
                    return ERROR_OUTOFMEMORY;

                dwRet = RegQueryValueExA(hkey, pszValue, lpReserved, NULL,
                                         (LPBYTE)lpsz, &cbSize);

                if (NO_ERROR == dwRet)
                {
                    //  dummy buffer required...
                    DWORD cbExpand = ExpandEnvironmentStringsA(lpsz, szBuff, ARRAYSIZE(szBuff));
                    cbSize = max(cbExpand, cbSize);


                }

            }

            LocalFree(lpsz);

            // Massage dwType so that callers always see REG_SZ
            dwType = REG_SZ;
        }
    }

    if (pdwType)
        *pdwType = dwType;

    if (pcbData)
        *pcbData = cbSize;

    return dwRet;
}

#ifdef UNICODE
/*----------------------------------------------------------
Purpose: Behaves just like RegQueryValueEx, except if the
         data type is REG_EXPAND_SZ, then this goes ahead
         and expands out the string.  *pdwType will always
         be massaged to REG_SZ if this happens.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
SHQueryValueExW(
    IN     HKEY    hkey,
    IN     LPCWSTR pwszValue,
    IN     LPDWORD lpReserved,
    OUT    LPDWORD pdwType,
    OUT    LPVOID  pvData,
    IN OUT LPDWORD pcbData)
{
    DWORD dwRet;
    DWORD cbSize;
    DWORD dwType;
    LPWSTR lpsz;

    if ( !g_bRunOnNT )
    {
        CHAR szValue[MAX_PATH];
        LPSTR pszValue = NULL;
        DWORD dwOriginalSize = 0;

        if (pcbData)
            dwOriginalSize = *pcbData;

        if (pwszValue)
        {
            WideCharToMultiByte(CP_ACP, 0, pwszValue, -1, szValue, SIZECHARS(szValue), NULL, NULL);
            pszValue = szValue;
        }

        if (!pdwType)
            pdwType = &dwType;

        dwRet = SHQueryValueExA(hkey, pszValue, lpReserved, pdwType, pvData, pcbData);

        if (NO_ERROR == dwRet)
            dwRet = RegData_AtoW(pvData, dwOriginalSize, *pdwType, pcbData);   // Thunk data from ANSI->UNICODE if needed.
    }
    else
    {
        // Running on NT
        // Trying to get back data

        if (pcbData)
            cbSize = *pcbData;     // Size of output buffer
            
        dwRet = RegQueryValueExW(hkey, pwszValue, lpReserved, &dwType,
                                 pvData, &cbSize);

        // Normally, we'd be done with this.  But do some extra work
        // if this is an expandable string (something that has system
        // variables in it), or if we need to pad the buffer.

        if (NO_ERROR == dwRet)
        {
            // Note: on Win95, RegSetValueEx will always write the 
            // full string out, including the null terminator.  On NT,
            // it won't unless the write length was specified.  
            // Hence, we have the following check.

            // Pad the buffer, in case the string didn't have a null
            // terminator when it was stored?
            if (REG_SZ == dwType)
            {
                // Yes
                if (pvData && cbSize + sizeof(WCHAR) <= *pcbData) 
                {
                    LPWSTR lpszData = pvData;
                    lpszData[cbSize / sizeof(WCHAR)] = '\0';
                }
            }
            // Expand the string?
            else if (REG_EXPAND_SZ == dwType)
            {
                if (pvData)
                {
                    // Yes

                    // Use a temporary buffer to expand
                    lpsz = (LPWSTR)LocalAlloc(LPTR, *pcbData);    
                    if (!lpsz)
                        return ERROR_OUTOFMEMORY;

                    cbSize = CbFromCchW(ExpandEnvironmentStringsW(pvData, lpsz, *pcbData / sizeof(WCHAR)));
                    if (cbSize > 0 && cbSize <= *pcbData) 
                        StrCpyNW(pvData, lpsz, *pcbData / sizeof(WCHAR));
                    else
                        dwRet = GetLastError();
                }
                else
                {
                    //
                    // Find out the length of the expanded string
                    // we have to call in and actually get the data to do this
                    //
                    WCHAR szBuff[1];

                    // Find out the length of the expanded string
                    //
                    lpsz = (LPWSTR)LocalAlloc(LPTR, cbSize);
                    if (!lpsz)
                        return ERROR_OUTOFMEMORY;

                    dwRet = RegQueryValueExW(hkey, pwszValue, lpReserved, NULL,
                                             (LPBYTE)lpsz, &cbSize);

                    if (NO_ERROR == dwRet)
                    {
                        DWORD cbExpand = CbFromCchW(ExpandEnvironmentStringsW(lpsz, szBuff, 
                                                                      ARRAYSIZE(szBuff)));
                        cbSize = max(cbExpand, cbSize);
                    }
                }

                LocalFree(lpsz);

                // Massage dwType so that callers always see REG_SZ
                dwType = REG_SZ;
            }
        }

        if (pdwType)
            *pdwType = dwType;

        if (pcbData)
            *pcbData = cbSize;
    }

    return dwRet;
}
#endif //UNICODE

/*
 *  @doc    INTERNAL
 *
 *  @func   int | SHAnsiToUnicodeNativeCP |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          specified Windows code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   UINT | uiCP |
 *
 *          The code page in which to perform the conversion.
 *          This must be a Windows code page.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   int | cchSrc |
 *
 *          Source buffer length, including terminating null.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 */

int
SHAnsiToUnicodeNativeCP(UINT uiCP,
                        LPCSTR pszSrc, int cchSrc,
                        LPWSTR pwszDst, int cwchBuf)
{
    int cwchRc = 0;             /* Assume failure */

    /*
     *  Checks the caller should've made.
     */
    ASSERT(IS_VALID_STRING_PTRA(pszSrc, -1));
    ASSERT(cchSrc == lstrlenA(pszSrc) + 1);
    ASSERT(IS_VALID_WRITE_BUFFER(pwszDst, WCHAR, cwchBuf));
    ASSERT(pszSrc != NULL);
    ASSERT(uiCP != 1200 && uiCP != 65000 && uiCP != 50000 && uiCP != 65001);
    ASSERT(pwszDst);
    ASSERT(cwchBuf);

    cwchRc = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc, pwszDst, cwchBuf);
    if (cwchRc) {
        /*
         *  The output buffer was big enough; no double-buffering
         *  needed.
         */
    } else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        /*
         *  The output buffer wasn't big enough.  Need to double-buffer.
         */

        int cwchNeeded = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc,
                                             NULL, 0);

        ASSERT(cwchRc == 0);        /* In case we fail later */
        if (cwchNeeded) {
            LPWSTR pwsz = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                             cwchNeeded * SIZEOF(WCHAR));
            if (pwsz) {
                cwchRc = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc,
                                             pwsz, cwchNeeded);
                if (cwchRc) {
                    StrCpyNW(pwszDst, pwsz, cwchBuf);
                    cwchRc = cwchBuf;
                }
                LocalFree(pwsz);
            }
        }
    } else {
        /* Possibly unsupported code page */
        ASSERT(!"Unexpected error in MultiByteToWideChar");
    }

    return cwchRc;
}

int
SHAnsiToUnicodeCP_ACP(LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf)
{
    int cwchRc = 0;             /* Assume failure */

    ASSERT(IS_VALID_STRING_PTRA(pszSrc, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pwszDst, WCHAR, cwchBuf));

    /*
     *  Sanity check - NULL source string is treated as a null string.
     */
    if (pszSrc == NULL) {
        pszSrc = "";
    }

    /*
     *  Sanity check - Output buffer must be non-NULL and must be of
     *  nonzero size.
     */
    if (pwszDst && cwchBuf) {

        int cchSrc;

        pwszDst[0] = 0;         /* In case of error */

        cchSrc = lstrlenA(pszSrc) + 1;

        cwchRc = SHAnsiToUnicodeNativeCP(CP_ACP, pszSrc, cchSrc, pwszDst, cwchBuf);
    }

    return cwchRc;
}

/*
 *  @doc    EXTERNAL
 *
 *  @func   int | SHAnsiToUnicode |
 *
 *          Convert an ANSI string to a UNICODE string via the
 *          <c CP_ACP> code page.  If the source string is too large
 *          for the destination buffer, then as many characters as
 *          possible are copied.
 *
 *          The resulting output string is always null-terminated.
 *
 *  @parm   LPCSTR | pszSrc |
 *
 *          Source buffer containing ANSI string to be converted.
 *
 *  @parm   LPWSTR | pwszDst |
 *
 *          Destination buffer to receive converted UNICODE string.
 *
 *  @parm   int | cwchBuf |
 *
 *          Size of the destination buffer in <t WCHAR>s.
 *
 *  @returns
 *
 *          On success, the number of characters copied to the output
 *          buffer is returned, including the terminating null.
 *
 */

int
SHAnsiToUnicode(LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf)
{
    return SHAnsiToUnicodeCP_ACP(pszSrc, pwszDst, cwchBuf);
}

// dupe a string using the task allocator for returing from a COM interface
// These functions use SHAlloc, so they cannot go into shlwapi.

STDAPI SHStrDupA(LPCSTR psz, WCHAR **ppwsz)
{
    DWORD cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    *ppwsz = (WCHAR *)CoTaskMemAlloc((cch + 1) * SIZEOF(WCHAR));
    if (*ppwsz)
    {
        MultiByteToWideChar(CP_ACP, 0, psz, -1, *ppwsz, cch);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

// dupe a string using the task allocator for returing from a COM interface

STDAPI SHStrDupW(LPCWSTR psz, WCHAR **ppwsz)
{
    *ppwsz = (WCHAR *)CoTaskMemAlloc((lstrlenW(psz) + 1) * SIZEOF(WCHAR));
    if (*ppwsz)
    {
        StrCpyW(*ppwsz, psz);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

// Modifies:
//      szRoot
//
// Returns:
//      TRUE if a drive root was found
//      FALSE otherwise
//
STDAPI_(BOOL)
PathStripToRoot(
    LPTSTR szRoot)
{
    while(!PathIsRoot(szRoot))
    {
        if (!PathRemoveFileSpec(szRoot))
        {
            // If we didn't strip anything off,
            // must be current drive
            return(FALSE);
        }
    }

    return(TRUE);
}

//
// SHStringFromGUIDA
//
// converts GUID into (...) form without leading identifier; returns
// amount of data copied to lpsz if successful; 0 if buffer too small.
//

// An endian-dependant map of what bytes go where in the GUID
// text representation.
//
// Do NOT use the TEXT() macro in GuidMap... they're intended to be bytes
//

static const BYTE c_rgbGuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                     8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const CHAR c_szDigitsA[] = "0123456789ABCDEF";
static const WCHAR c_szDigitsW[] = TEXTW("0123456789ABCDEF");

STDAPI_(int) 
SHStringFromGUIDA(
    UNALIGNED REFGUID rguid, 
    LPSTR   psz, 
    int     cchMax)
{
    int i;
    const BYTE * pBytes = (const BYTE *) rguid;

    if (cchMax < GUIDSTR_MAX)
        return 0;

#ifdef BIG_ENDIAN
    // This is the slow, but portable version
    wnsprintf(psz, cchMax,"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            rguid->Data1, rguid->Data2, rguid->Data3,
            rguid->Data4[0], rguid->Data4[1],
            rguid->Data4[2], rguid->Data4[3],
            rguid->Data4[4], rguid->Data4[5],
            rguid->Data4[6], rguid->Data4[7]);
#else
    // The following algorithm is faster than the wsprintf.
    *psz++ = '{';

    for (i = 0; i < SIZEOF(c_rgbGuidMap); i++)
    {
        if (c_rgbGuidMap[i] == '-')      // don't TEXT() this line
        {
            *psz++ = '-';
        }
        else
        {
            // Convert a byte-value into a character representation
            *psz++ = c_szDigitsA[ (pBytes[c_rgbGuidMap[i]] & 0xF0) >> 4 ];
            *psz++ = c_szDigitsA[ (pBytes[c_rgbGuidMap[i]] & 0x0F) ];
        }
    }
    *psz++ = '}';
    *psz   = '\0';
#endif /* !BIG_ENDIAN */

    return GUIDSTR_MAX;
}

STDAPI_(int) 
SHStringFromGUIDW(
    UNALIGNED REFGUID rguid, 
    LPWSTR  psz, 
    int     cchMax)
{
    int i;
    const BYTE * pBytes = (const BYTE *) rguid;

    if (cchMax < GUIDSTR_MAX)
        return 0;

#ifdef BIG_ENDIAN
    // This is the slow, but portable version
    wnsprintfW(psz, cchMax, L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            rguid->Data1, rguid->Data2, rguid->Data3,
            rguid->Data4[0], rguid->Data4[1],
            rguid->Data4[2], rguid->Data4[3],
            rguid->Data4[4], rguid->Data4[5],
            rguid->Data4[6], rguid->Data4[7]);
#else
    // The following algorithm is faster than the wsprintf.
    *psz++ = TEXTW('{');

    for (i = 0; i < SIZEOF(c_rgbGuidMap); i++)
    {
        if (c_rgbGuidMap[i] == '-')      // don't TEXT() this line
        {
            *psz++ = TEXTW('-');
        }
        else
        {
            // Convert a byte-value into a character representation
            *psz++ = c_szDigitsW[ (pBytes[c_rgbGuidMap[i]] & 0xF0) >> 4 ];
            *psz++ = c_szDigitsW[ (pBytes[c_rgbGuidMap[i]] & 0x0F) ];
        }
    }
    *psz++ = TEXTW('}');
    *psz   = TEXTW('\0');
#endif /* !BIG_ENDIAN */

    return GUIDSTR_MAX;
}

//
//  Why do we use the unsafe version?
//
//  -   Unsafe is much faster.
//
//  -   The safe version isn't safe after all and serves only to mask
//      existing bugs.  The situation the safe version "saves" is if
//      two threads both try to atomicrelease the same object.  This
//      means that at the same moment, both threads think the object
//      is alive.  Change the timing slightly, and now one thread
//      atomicreleases the object before the other one, so the other
//      thread is now using an object after the first thread already
//      atomicreleased it.  Bug.
//
STDAPI_(void) IUnknown_AtomicRelease(void **ppunk)
{
#if 1 // Unsafe
    if (ppunk && *ppunk) {
        IUnknown* punk = *(IUnknown**)ppunk;
        *ppunk = NULL;
        punk->lpVtbl->Release(punk);
    }
#else // Safe
    if (ppunk) {
        IUnknown* punk = (IUnknown *)InterlockedExchangePointer(ppunk, NULL);
        if (punk) {
            punk->Release();
        }
    }
#endif
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\slowfind.h ===
#ifndef __SLOWFIND_H_
#define __SLOWFIND_H_

#include "appsize.h"

#define MAX_PROGFILES_SEARCH_DEPTH 1
#define MAX_STARTMENU_SEARCH_DEPTH 2

HRESULT GetShortcutTarget(LPCWSTR pszPath, LPTSTR pszTarget, UINT cch);
BOOL SlowFindAppFolder(LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszFolder);

class CStartMenuAppFinder : public CAppFolderSize
{
    friend BOOL SlowFindAppFolder(LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszFolder);
public:
    CStartMenuAppFinder(LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszFolder);

    // *** IShellTreeWalkerCallBack methods ***
    STDMETHODIMP FoundFile(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    
    HRESULT SearchInFolder(LPCTSTR pszStart);

protected:
    BOOL _MatchSMLinkWithApp(LPCTSTR pszLnkFile);

    LPCTSTR _pszFullName;
    LPCTSTR _pszShortName;

    // The Result
    LPTSTR  _pszFolder;

    // Best match found
    int _iBest;
}; 


#endif // _SLOWFIND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\slowfind.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: slowfind.cpp
//
// Implements CProgFilesAppFinder
//            CStartMenuAppFinder
// History:
//         3-01-98  by dli implemented CProgFilesAppFinder
//         4-15-98  by dli implemented CStartMenuAppFinder
//------------------------------------------------------------------------
#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include "appsize.h"
#include "findapp.h"
#include "slowfind.h"


// Todo: Remember the find result somewhere in the registry or cache it in code
// so that we don't waste time repeatedly computing it. 

//
//  App Folder Finder tree walker callback class
//
class CProgFilesAppFinder : public CAppFolderSize
{
    friend BOOL SlowFindAppFolder(LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszFolder);
public:
    CProgFilesAppFinder(LPCTSTR pszFullName, LPCTSTR pszShortName, BOOL * pfFound, LPTSTR pszFolder);

    // *** IShellTreeWalkerCallBack methods ***
    virtual STDMETHODIMP EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);

    HRESULT SearchInFolder(LPCTSTR pszStart);
    void    SetRootSearch(BOOL bRootSearch);
protected:

    LPCTSTR _pszFullName;
    LPCTSTR _pszShortName;

    // The Result
    LPTSTR  _pszFolder;

    // Best match found
    int _iBest;
    int _iCurDepth;

    // found it or not?
    BOOL * _pfFound;

    // are we searching from root dirs like c:?
    BOOL _fRootSearch;

    // system directory used by the root search
    TCHAR _szSystemDir[MAX_PATH];
}; 

CProgFilesAppFinder::CProgFilesAppFinder(LPCTSTR pszFullName, LPCTSTR pszShortName, BOOL * pfFound, LPTSTR pszFolder) :
   CAppFolderSize(NULL), _pszFullName(pszFullName), _pszShortName(pszShortName), _pfFound(pfFound), _pszFolder(pszFolder)
{
    ASSERT(IS_VALID_STRING_PTR(pszFullName, -1) || IS_VALID_STRING_PTR(pszShortName, -1));
    ASSERT(IS_VALID_STRING_PTR(pszFolder, -1));
    
    ASSERT(pfFound);
    ASSERT(*pfFound == FALSE);
    ASSERT(_fRootSearch == FALSE);
}


void CProgFilesAppFinder::SetRootSearch(BOOL bRootSearch)
{
    _fRootSearch = bRootSearch;
    GetSystemDirectory(_szSystemDir, ARRAYSIZE(_szSystemDir));
}

//
// IShellTreeWalkerCallBack::EnterFolder
//
HRESULT CProgFilesAppFinder::EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    HRESULT hres = S_OK;
    TCHAR szFolder[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pwszFolder, -1));

#ifdef UNICODE  
    lstrcpy(szFolder, pwszFolder);
#else
    WideCharToMultiByte(CP_ACP, 0,
                        pwszFolder, -1,
                        szFolder, ARRAYSIZE(szFolder), NULL, NULL);
#endif

    TraceMsg(TF_SLOWFIND, "Enter Folder: %s -- %s  Depth %d", _pszFullName, szFolder, ptws->nDepth);

    LPTSTR pszName = PathFindFileName(szFolder);

    // Don't go into common files or where we already have seen
    // FEATURE: These should be in the registry.
    if (_fRootSearch)
    {
        if (!lstrcmpi(pszName, TEXT("Program Files")) || !lstrcmpi(pszName, TEXT("Windows")) ||
            !lstrcmpi(pszName, TEXT("Temp")) || !lstrcmpi(pszName, TEXT("Users")) || StrStrI(pszName, TEXT("WINNT")) ||
            !lstrcmpi(_szSystemDir, szFolder))
            return S_FALSE;
    }
    else if (!lstrcmpi(pszName, TEXT("Common Files")) || !lstrcmpi(pszName, TEXT("Windows NT"))
             || !lstrcmpi(pszName, TEXT("Plus!")) || !lstrcmpi(pszName, TEXT("Uninstall Information")))
        return S_FALSE;

    if (pszName)
    {
        int iMatch = MatchAppName(pszName, _pszFullName, _pszShortName, TRUE);

        // The deeper the match folder is down the tree, the better a match
        // it is.
        if ((iMatch > _iBest) || ((iMatch > 0) && (ptws->nDepth > _iCurDepth)))
        {
            _iBest = iMatch;
            _iCurDepth = ptws->nDepth;
            
            TraceMsg(TF_SLOWFIND, "Slow Match Found: %s -- %s Depth %d", _pszFullName, szFolder, _iCurDepth); 
            ASSERT(IS_VALID_STRING_PTR(_pszFolder, -1));
            lstrcpy(_pszFolder, szFolder);

            if (iMatch == MATCH_LEVEL_HIGH)
            {
                *_pfFound = TRUE;
                hres = E_FAIL;
            }
        }
    }

    if (SUCCEEDED(hres))
        hres = CAppFolderSize::EnterFolder(pwszFolder, ptws, pwfd);

    return hres;
}

//
// Wrapper around WalkTree
//
HRESULT CProgFilesAppFinder::SearchInFolder(LPCTSTR pszStart)
{
    HRESULT hres = E_FAIL;
    WCHAR wszDir[MAX_PATH];
    DWORD dwSearchFlags = WT_MAXDEPTH | WT_NOTIFYFOLDERENTER | WT_FOLDERONLY;

    SHTCharToUnicode(pszStart, wszDir, SIZECHARS(wszDir));

    if (_pstw)
        hres = _pstw->WalkTree(dwSearchFlags, wszDir, NULL, MAX_PROGFILES_SEARCH_DEPTH, SAFECAST(this, IShellTreeWalkerCallBack *));

    return hres;
}

CStartMenuAppFinder::CStartMenuAppFinder(LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszFolder) :
   CAppFolderSize(NULL), _pszFullName(pszFullName), _pszShortName(pszShortName), _pszFolder(pszFolder)
{
    ASSERT(IS_VALID_STRING_PTR(pszFullName, -1) || IS_VALID_STRING_PTR(pszShortName, -1));
    ASSERT(IS_VALID_STRING_PTR(pszFolder, -1));
    
}

//
// get the target of a shortcut. 
//
// NOTE: pszPath is WCHAR string
//
HRESULT GetShortcutTarget(LPCWSTR pszLinkPath, LPTSTR pszTargetPath, UINT cchTargetPath)
{
    IShellLink* psl;
    HRESULT hres = E_FAIL;
    HRESULT hresT = LoadFromFile(CLSID_ShellLink, pszLinkPath, IID_PPV_ARG(IShellLink, &psl));
    if (SUCCEEDED(hresT)) 
    { 
        IShellLinkDataList* psldl;
        hresT = psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &psldl));
        if (SUCCEEDED(hresT)) 
        {
            EXP_DARWIN_LINK* pexpDarwin;
            BOOL bDarwin = FALSE;
            hresT = psldl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);
            if (SUCCEEDED(hresT))
            {
                // This is a darwin link, so we return S_FALSE here. 
                LocalFree(pexpDarwin);
                bDarwin = TRUE;
            }
            
            hresT = psl->GetPath(pszTargetPath, cchTargetPath, NULL, NULL);
            if (hresT == S_OK)
            {
                // Return S_FALSE for the darwin apps. 
                hres = bDarwin ? S_FALSE : hresT;
            }
            
            psldl->Release();
        }
        psl->Release();
    }

    return hres;
}

//
// IShellTreeWalkerCallBack::EnterFolder
//
HRESULT CStartMenuAppFinder::EnterFolder(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    TCHAR szFolder[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pwszFolder, -1));

    SHUnicodeToTChar(pwszFolder, szFolder, SIZECHARS(szFolder));

    LPTSTR pszName = PathFindFileName(szFolder);

    // Skip menus like the "Administrative Tools" and the "Accessories"
    // FEATURE (scotth): these strings should be resourced-based
    if (FindSubWord(pszName, TEXT("Administrative")) || 
        FindSubWord(pszName, TEXT("Accessories")))
    {
        return  S_FALSE;
    }
    return CAppFolderSize::EnterFolder(pwszFolder, ptws, pwfd);
}


/*-------------------------------------------------------------------------
Purpose: Checks if the given shortcut filename closely matches this
         app's fullname or shortname.  Returns TRUE if it does.
*/
BOOL CStartMenuAppFinder::_MatchSMLinkWithApp(LPCTSTR pszLnkFile)
{
    TCHAR szLnkFile[MAX_PATH];
    
    ASSERT(IS_VALID_STRING_PTR(pszLnkFile, -1));
    
    lstrcpyn(szLnkFile, pszLnkFile, SIZECHARS(szLnkFile));
    LPTSTR pszFileName = PathFindFileName(szLnkFile);
    PathRemoveExtension(pszFileName);
    
    if (MATCH_LEVEL_NORMAL <= MatchAppName(pszFileName, _pszFullName, _pszShortName, FALSE))
        return TRUE;
    
    PathRemoveFileSpec(szLnkFile);
    LPTSTR pszDirName = PathFindFileName(szLnkFile);
    if (MatchAppName(pszFileName, _pszFullName, _pszShortName, FALSE) >= MATCH_LEVEL_NORMAL)
        return TRUE;
    
    return FALSE;
}

//
// IShellTreeWalkerCallBack::FoundFile
//
HRESULT CStartMenuAppFinder::FoundFile(LPCWSTR pwszFile, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    HRESULT hres = S_OK;
    TCHAR szLnkFile[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pwszFile, -1));

    SHUnicodeToTChar(pwszFile, szLnkFile, ARRAYSIZE(szLnkFile));
    TraceMsg(TF_SLOWFIND, "CSMAF:Lnk %s -- %s %s", _pszFullName, szLnkFile);

    if (!_MatchSMLinkWithApp(szLnkFile))
        return S_FALSE;

    
    TCHAR szTargetFile[MAX_PATH];
    HRESULT hresT = GetShortcutTarget(pwszFile, szTargetFile, ARRAYSIZE(szTargetFile));
    if (hresT == S_OK) 
    {
        if(!PathIsRoot(szTargetFile) && !PathIsUnderWindows(szTargetFile) && !PathIsSetup(szTargetFile, 3)
           && !PathIsCommonFiles(szTargetFile))
        {
            TraceMsg(TF_SLOWFIND, "CSMAF:Target %s -- %s %s", _pszFullName, szTargetFile);
            PathRemoveFileSpec(szTargetFile);
            if (!PathIsRoot(szTargetFile))
            {
                int iMatch = FindBestMatch(szTargetFile, _pszFullName, _pszShortName, FALSE, _pszFolder);
                // The deeper the match folder is down the tree, the better a match
                // it is.
                if (iMatch > _iBest)
                {
                    _iBest = iMatch;

                    ASSERT(IS_VALID_STRING_PTR(_pszFolder, -1));
                    ASSERT(PathIsPrefix(_pszFolder, szTargetFile));
                    TraceMsg(TF_SLOWFIND, "CSMAF: Slow Match Found: %s -- %s", _pszFullName, szLnkFile); 

                    if (iMatch == MATCH_LEVEL_HIGH)
                        hres = E_FAIL;
                }
            }
        }
    }
    
    if (SUCCEEDED(hres))
        hres = CAppFolderSize::FoundFile(pwszFile, ptws, pwfd);

    return hres;
}

//
// Wrapper around WalkTree
//
HRESULT CStartMenuAppFinder::SearchInFolder(LPCTSTR pszStart)
{
    HRESULT hres = E_FAIL;
    DWORD dwSearchFlags = WT_MAXDEPTH | WT_NOTIFYFOLDERENTER | WT_FOLDERFIRST;

    if (_pstw)
        hres = _pstw->WalkTree(dwSearchFlags, pszStart, L"*.lnk", MAX_STARTMENU_SEARCH_DEPTH, SAFECAST(this, IShellTreeWalkerCallBack *));

    return hres;
}

//
// NOTE: assuming pszFolder was allocated MAX_PATH long
// pszFolder will contain the result as return
// 
BOOL SlowFindAppFolder(LPCTSTR pszFullName, LPCTSTR pszShortName, LPTSTR pszFolder)
{
    ASSERT(IS_VALID_STRING_PTR(pszFolder, -1));
    ASSERT(IS_VALID_STRING_PTR(pszFullName, -1) || IS_VALID_STRING_PTR(pszShortName, -1));

    int iMatch = MATCH_LEVEL_NOMATCH;
    
    // Search from the start menu
    CStartMenuAppFinder * psmaf = new CStartMenuAppFinder(pszFullName, pszShortName, pszFolder);
    if (psmaf)
    {
        if (SUCCEEDED(psmaf->Initialize()))
        {
            TCHAR szStartMenu[MAX_PATH];
            if (SHGetSpecialFolderPath(NULL, szStartMenu, CSIDL_COMMON_STARTMENU, FALSE))
                psmaf->SearchInFolder(szStartMenu);

            if ((psmaf->_iBest == MATCH_LEVEL_NOMATCH) && (SHGetSpecialFolderPath(NULL, szStartMenu, CSIDL_STARTMENU, FALSE)))
                psmaf->SearchInFolder(szStartMenu);

            iMatch = psmaf->_iBest;
        }
        psmaf->Release();
    }

    if (iMatch == MATCH_LEVEL_NOMATCH)
    {
        BOOL fFound = FALSE;

        // Start searching from stratch, no hints on where to start what so ever
        CProgFilesAppFinder * psaff = new CProgFilesAppFinder(pszFullName, pszShortName, &fFound, pszFolder);
        if (psaff)
        {
            if (SUCCEEDED(psaff->Initialize()))
            {
                // search down from "Program Files" directory under root of all fixed drives
                TCHAR szDrive[4];
                TCHAR szProgFiles[30];
                lstrcpy(szDrive, TEXT("A:\\"));
                lstrcpy(szProgFiles, TEXT("A:\\Program Files"));
                for (; !fFound && szDrive[0] <= TEXT('Z'); szProgFiles[0]++, szDrive[0]++)
                {
                    ASSERT(szDrive[0] == szProgFiles[0]);
                    if (GetDriveType(szDrive) == DRIVE_FIXED)
                        psaff->SearchInFolder(szProgFiles);
                }

            }

            if (!fFound)
            {
                psaff->SetRootSearch(TRUE);
                
                TCHAR szDrive[4];
                lstrcpy(szDrive, TEXT("A:\\"));
                for (; !fFound && szDrive[0] <= TEXT('Z'); szDrive[0]++)
                {
                    if (GetDriveType(szDrive) == DRIVE_FIXED)
                        psaff->SearchInFolder(szDrive);
                }
            }

            iMatch = psaff->_iBest;
            psaff->Release();
        }
        
        if (iMatch > MATCH_LEVEL_NOMATCH)
            TraceMsg(TF_ALWAYS, "CPFAF: Found %s at %s", pszFullName, pszFolder);
    }
    else
        TraceMsg(TF_ALWAYS, "CSMAF: Found %s at %s", pszFullName, pszFolder);

    return iMatch;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\setupenum.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: setupenum.cpp
//
// The current order of enumeration is whatever order we read from the registry
//
// History:
//         6-11-98  by toddb
//------------------------------------------------------------------------
#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include <shellp.h>     // for IsUserAnAdmin
#include "setupenum.h"
#include "appwizid.h"

#define c_szOCSetupKey  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\OCManager\\ToDoList")

//-----------------------------------------------------------------------
// OCSetupApp
//-----------------------------------------------------------------------

COCSetupApp::COCSetupApp()
{
    // This must be heap alloced so everything should be zero'ed out.
    // Make sure this wasn't stack alloced using these asserts:
    ASSERT(0 == _szDisplayName[0]);
    ASSERT(0 == _szApp[0]);
    ASSERT(0 == _szArgs[0]);
}

COCSetupApp::~COCSetupApp()
{
}

//-----------------------------------------------------------------------
// GetAppInfo
//
// Fills in the only valid field in our psuedo APPINFODATA structure.

BOOL COCSetupApp::GetAppInfo(PAPPINFODATA pai)
{
    if (pai->cbSize != SIZEOF(APPINFODATA))
        return FALSE;

    DWORD dwInfoFlags = pai->dwMask;
    pai->dwMask = 0;
    
    if (dwInfoFlags & AIM_DISPLAYNAME)
    {
        if (SUCCEEDED(SHStrDup(_szDisplayName, &pai->pszDisplayName)))
            pai->dwMask |= AIM_DISPLAYNAME;
    }
    return TRUE;
}

//-----------------------------------------------------------------------
// ReadFromKey
//
// This function reads the actual data from the given reg key.  It returns
// TRUE if all required fields contained string data.

BOOL COCSetupApp::ReadFromKey( HKEY hkey )
{
    DWORD dwType;
    DWORD dwSize;

    dwSize = sizeof(_szDisplayName);
    if ( ERROR_SUCCESS != RegQueryValueEx( hkey, TEXT("Title"), 0, &dwType, (LPBYTE)_szDisplayName, &dwSize ) ||
         dwType != REG_SZ )
    {
        // DisplayName is required
        return FALSE;
    }

    dwSize = sizeof(_szApp);
    if ( ERROR_SUCCESS == RegQueryValueEx( hkey, TEXT("ConfigCommand"), 0, &dwType, (LPBYTE)_szApp, &dwSize ) &&
         (dwType == REG_SZ || dwType == REG_EXPAND_SZ) )
    {
        if ( dwType == REG_EXPAND_SZ )
        {
            TCHAR szBuf[MAX_PATH];
            ExpandEnvironmentStrings(_szApp, szBuf, ARRAYSIZE(szBuf));
            lstrcpyn(_szApp, szBuf, ARRAYSIZE(_szApp));
        }
    }
    else
    {
        // ConfigCommand is required
        return FALSE;
    }

    dwSize = sizeof(_szArgs);
    if ( ERROR_SUCCESS == RegQueryValueEx( hkey, TEXT("ConfigArgs"), 0, &dwType, (LPBYTE)_szArgs, &dwSize ) &&
         (dwType == REG_SZ || dwType == REG_EXPAND_SZ) )
    {
        if ( dwType == REG_EXPAND_SZ )
        {
            TCHAR szBuf[MAX_PATH];
            ExpandEnvironmentStrings(_szArgs, szBuf, ARRAYSIZE(szBuf));
            lstrcpyn(_szArgs, szBuf, ARRAYSIZE(_szArgs));
        }
    }
    else
    {
        // This is optional so we don't fail.  Instead simply insure that _szArgs is an empty string.
        _szArgs[0] = 0;
    }

    return TRUE;
}

BOOL COCSetupApp::Run()
{
    // REARCHITECT: (stephstm, 03/17/99) we should probably wait on a job object in case
    // the spawned process spawns some other process(es) and then exits before them.

    BOOL fRet = FALSE;
    SHELLEXECUTEINFO sei = {0};

    sei.cbSize = sizeof(SHELLEXECUTEINFO);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = GetDesktopWindow();
    sei.lpFile = _szApp;
    sei.lpParameters = _szArgs[0] ? _szArgs : NULL;
    sei.nShow = SW_SHOWDEFAULT; 

    fRet = ShellExecuteEx(&sei);

    if (fRet)
    {
        DWORD dwRet;

        do
        {
            MSG msg;

            // Get and process the messages!
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            // MsgWaitForMultipleObjects can fail with -1 being returned!
            dwRet = MsgWaitForMultipleObjects(1, &sei.hProcess, FALSE, INFINITE, QS_ALLINPUT);
        }
        while ((WAIT_OBJECT_0 != dwRet) && (-1 != dwRet));

        // Did MsgWait... failed?
        if (-1 == dwRet)
        {
            // Yes, kill the process
            TerminateProcess(sei.hProcess, 0);

            fRet = FALSE;
        }

        CloseHandle(sei.hProcess);
    }
    else
    {
        ShellMessageBox(HINST_THISDLL, sei.hwnd,  MAKEINTRESOURCE( IDS_CONFIGURE_FAILED ),
                             MAKEINTRESOURCE( IDS_NAME ),
                             MB_OK | MB_ICONEXCLAMATION);
    }

    return fRet;
}


//-----------------------------------------------------------------------
// OCSetupEnum
//-----------------------------------------------------------------------

COCSetupEnum::COCSetupEnum()
{
    _hkeyRoot = 0;
    _iRegEnumIndex = -1;
}

COCSetupEnum::~COCSetupEnum()
{
    if ( _hkeyRoot )
    {
        RegCloseKey( _hkeyRoot );
    }
}

//-----------------------------------------------------------------------
// s_OCSetupNeeded
//
// This checks for the neccessaary conditions to display the OC Setup portion of the ARP.
// This section is only shown if the current user is a member of the administrators group
// AND there are any items listed in the registry that need to be displayed.

BOOL COCSetupEnum::s_OCSetupNeeded()
{
    BOOL fResult = FALSE;
    HKEY hkey;
    // Temporarily open the reg key to see if it exists and has any sub keys
    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szOCSetupKey, 0, KEY_READ, &hkey ) )
    {
        TCHAR szBuf[MAX_PATH];
        if ( ERROR_SUCCESS == RegEnumKey( hkey, 0, szBuf, ARRAYSIZE(szBuf) ) )
        {
            // Yes, there are OCSetup items, but is the current user an administrator?
            if ( IsUserAnAdmin() )
            {
                fResult = TRUE;
            }
        }
        RegCloseKey( hkey );
    }
    return fResult;
}

//-----------------------------------------------------------------------
// EnumOCSetupItems
//
// This begins the enumeration by opening the required registry key.  This does
// not attempt to read any of the sub items so there is no garentee that the
// first call to Next() will succeed.

BOOL COCSetupEnum::EnumOCSetupItems()
{
    ASSERT( NULL == _hkeyRoot );
    // Open the reg key, return true if it's open.  We leave the key open until
    // our destructor is called since we need this key to do the enumeration.
    if ( ERROR_SUCCESS == RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            c_szOCSetupKey,
            0,
            KEY_READ,
            &_hkeyRoot ) )
    {
        return TRUE;
    }
    return FALSE;
}

//-----------------------------------------------------------------------
// Next
//
// Reads the data from the next sub key of _hkeyRoot and returns the data in the
// out pointer.  Returns TRUE if the out pointer is a valid COCSetupApp object.

BOOL COCSetupEnum::Next(COCSetupApp **ppocsa)
{
    HKEY hkeySub;
    TCHAR szSubKeyName[MAX_PATH];

    // We open each subkey of the root key and attempt to read an OCSetup item from the subkey.
    if ( ERROR_SUCCESS == RegEnumKey( _hkeyRoot, ++_iRegEnumIndex, szSubKeyName, ARRAYSIZE(szSubKeyName) ) )
    {
        if ( ERROR_SUCCESS == RegOpenKeyEx( _hkeyRoot, szSubKeyName, 0, KEY_READ, &hkeySub ) )
        {
            *ppocsa = new COCSetupApp();
            if ( *ppocsa )
            {
                if ( (*ppocsa)->ReadFromKey( hkeySub ) )
                {
                    RegCloseKey( hkeySub );
                    return TRUE;
                }

                delete *ppocsa;
            }
            RegCloseKey( hkeySub );
        }
        // fall through
    }

    *ppocsa = NULL;
    return FALSE;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\cpls\appwzdui\appwiz.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\cpls\appwzdui\appwiz.inc

SELFREGNAME     = $(O)\selfreg_appwiz.inf
MISCFILES       = $(MISCFILES) $(SELFREGNAME)

# Don't include core Windows resource header
C_DEFINES       = $(C_DEFINES) -DNOWINRES

LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

TARGETNAME    = appwiz
TARGETPATH    = obj
TARGETTYPE    = DYNLINK
TARGETEXT     = cpl

# Note:  Do >not< link to ntdll.  Win95 has an extremely minimal
#        implementation of ntdll.
TARGETLIBS      = \
                  $(WINDOWS_LIB_PATH)\obj\duser.lib          \
!if $(FREEBUILD)
                  $(WINDOWS_LIB_PATH)\directui.lib                   \
!else
                  $(WINDOWS_LIB_PATH)\directuid.lib                  \
!endif
                  $(SDK_LIB_PATH)\GdiPlus.lib                        \
                  $(SDK_LIB_PATH)\msimg32.lib                        \
                  $(SDK_LIB_PATH)\oleacc.lib                         \
                  $(SDK_LIB_PATH)\gdi32.lib         \
                  $(SDK_LIB_PATH)\user32.lib        \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(SDK_LIB_PATH)\uuid.lib          \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\oleaut32.lib      \
                  $(SDK_LIB_PATH)\winsta.lib        \
                  $(SDK_LIB_PATH)\uxtheme.lib       \
                  $(DS_LIB_PATH)\msgina.lib         \
!ifndef DOWNLEVEL_PLATFORM
                  $(SHELL_LIB_PATH)\shlwapip.lib    \
!endif
                  $(CCSHELL_DIR)\lib\$O\shguidp.lib \
                  $(CCSHELL_DIR)\lib\$O\shguid.lib  \
                  $(CCSHELL_DIR)\lib\$O\ieguidp.lib  \
                  $(SHELL_LIB_PATH)\shfusion.lib     \
!ifdef TARGET_WIN95
                  $(SDK_LIB_DEST)\chicago\i386\kernel32.lib      \
                  $(CCSHELL_DIR)\lib\i386\shell32.w95
!else
                  $(SDK_LIB_PATH)\kernl32p.lib     \
                  $(SHELL_LIB_PATH)\shell32p.lib
!endif

DELAYLOAD = OLE32.DLL;OLEAUT32.DLL;WINSTA.DLL;MSGINA.DLL

# nt5api must be finished before this one
SYNCHRONIZE_DRAIN=1

!ifdef DOWNLEVEL_PLATFORM
LINKLIBS        = $(CCSHELL_DIR)\lib\$O\stock4.lib

!ifdef TARGET_WIN95
LINKLIBS        = $(LINKLIBS)               \
                  ..\w5api\$O\apithk.lib    \
                  ..\w95c\$O\srcc.lib
!else #TARGET_WIN95
LINKLIBS        = $(LINKLIBS)               \
                  ..\nt5api\$O\apithk.lib   \
                  ..\nt4c\$O\srcc.lib
!endif #TARGET_WIN95

!else #DOWNLEVEL_PLATFORM

LINKLIBS        = $(CCSHELL_DIR)\lib\$O\stock.lib \
                  ..\nt5api\$O\apithk.lib   \
                  ..\ntc\$O\srcc.lib

!endif #DOWNLEVEL_PLATFORM

USE_MSVCRT      = 1

DLLENTRY        = _DllMainCRTStartup

USE_STATIC_ATL  = 1

DLLDEF          = $(O)\appwiz.def
DLLBASE         = 0x71900000

# For RC to find shappmgr.TLB and HTML files, $(O) must come first
INCLUDES        = $(O);$(PROJECT_ROOT)\lib\$(O);..\html;$(WINDOWS_INC_PATH)\DUser;$(INCLUDES);$(DS_INC_PATH);$(SDK_INC_PATH);$(QFE_INC_PATH)

# Pass zero stuff
NTTARGETFILE0   = $(SELFREGNAME)

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\priv.h

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_TLBDIR=$(O)


# Maintain the sources list in the alphabetical order
SOURCES         = \
                  ..\arp.cpp       \
                  ..\adcctl.cpp    \
                  ..\appmgr.cpp    \
                  ..\appsize.cpp   \
                  ..\appwiz.rc     \
                  ..\awthunk.c     \
                  ..\datasrc.cpp   \
                  ..\darpub.cpp    \
                  ..\darenum.cpp   \
                  ..\darapp.cpp    \
                  ..\debug.cpp     \
                  ..\dlinst.cpp    \
                  ..\dll.cpp       \
                  ..\dlldatax.c    \
                  ..\event.cpp     \
                  ..\findapp.cpp   \
                  ..\instapp.cpp   \
                  ..\instenum.cpp  \
                  ..\mtxarray.cpp  \
                  ..\pubenum.cpp   \
                  ..\sccls.c       \
                  ..\setupenum.cpp \
                  ..\shappmgrp.idl \
                  ..\shappmgrp_i.c \
                  ..\shlwapi.c     \
                  ..\slowfind.cpp  \
                  ..\stdafx.cpp    \
                  ..\tasks.cpp     \
                  ..\util.cpp      \
                  ..\worker.cpp

# 
# Fusionized
# 
SXS_MANIFEST_RESOURCE_ID=123 
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\srcc.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\cpls\appwzdui\appwiz.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\cpls\appwzdui\appwiz.inc

INCLUDES        = $(INCLUDES);..\winnt\$(O)


NO_BROWSER_FILE = 1
USE_NATIVE_EH=1

TARGETNAME      = srcc
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

PRECOMPILED_INCLUDE = ..\priv.h

SOURCES         = \
                  ..\applist.c  \
                  ..\appwiz.c   \
                  ..\browse.c   \
                  ..\confopt.c  \
                  ..\dump.c     \
                  ..\folder.c   \
                  ..\gettitle.c \
                  ..\link.c     \
                  ..\msdos.c    \
                  ..\pickicon.c \
                  ..\setup.c    \
                  ..\uninstal.c \
                  ..\scripts.cpp \
                  ..\chgusr.c




 
 
# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.ControlPanel.ApplicationWizard
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM
#include "stdafx.h"


// HACKHACK (scotth): windowsx.h #define SubclassWindow.  ATL 2.1 headers
//  (namely atlwin.h and atlwin.cpp) have a member function with the
//  same name.
#ifdef SubclassWindow
#undef SubclassWindow
#endif


#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#if !defined(AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED_)
#define AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT



//#define _WIN32_WINNT 0x0400       // (scotth): Use what is defined in priv.h
#define _ATL_APARTMENT_THREADED

#define _ATL_NO_DEBUG_CRT           // use the shell debug facilities
#include <debug.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED)

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\tasks.h ===
#ifndef __TASKS_H_
#define __TASKS_H_

#include <runtask.h>

// Search Depth
#define MAX_EXE_SEARCH_DEPTH 2
HRESULT FindAppInfo(LPCTSTR pszFolder, LPCTSTR pszFullName, LPCTSTR pszShortName, PSLOWAPPINFO psai, BOOL bDarwin);

#endif // _TASKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\tasks.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: tasks.cpp
// App Management tasks running on the secondary thread
// 
// History:
//         2-26-98  by dli implemented CAppUemInfoTask
//------------------------------------------------------------------------
#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include "shguidp.h"
#include "uemapp.h"
#include "appsize.h"
#include "findapp.h"
#include "tasks.h"
#include "slowfind.h"
#include "dump.h"
#include "util.h"


// Utility function to get times used or last used time for "exe" files
void ExtractExeInfo(LPCTSTR pszExe, PSLOWAPPINFO psai, BOOL bNoImageChange)
{
    ASSERT(IS_VALID_STRING_PTR(pszExe, -1));
    
    // Got to have a legal psai
    ASSERT(psai);

    // Get the "times used" info
    UEMINFO uei = {0};
    uei.cbSize = SIZEOF(uei);
    uei.dwMask = UEIM_HIT;
    if (SUCCEEDED(UEMQueryEvent(&UEMIID_SHELL, UEME_RUNPATH, (WPARAM)-1, (LPARAM)pszExe, &uei)))
    {
        if (uei.cHit > psai->iTimesUsed)
            psai->iTimesUsed = uei.cHit;
    }

    // Get the most recent access time
    HANDLE hFile = CreateFile(pszExe, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                               NULL, OPEN_EXISTING, 0, NULL ); 
    if( INVALID_HANDLE_VALUE != hFile )
    {
        FILETIME ftCreate, ftAccessed, ftWrite;
        if (GetFileTime(hFile, &ftCreate, &ftAccessed, &ftWrite))
        {
            // Is the creation and accessed dates identical, and is the
            // UEM's statistic useless?
            if (0 == CompareFileTime(&ftAccessed, &ftCreate) && 
                0 == psai->ftLastUsed.dwHighDateTime)
            {
                // Yes; then it doesn't look like anyone has used it
                psai->ftLastUsed.dwHighDateTime = NOTUSED_HIGHDATETIME;
                psai->ftLastUsed.dwLowDateTime = NOTUSED_LOWDATETIME;
                if (!bNoImageChange && (psai->pszImage == NULL))
                    SHStrDup(pszExe, &psai->pszImage);
            }
            else if (CompareFileTime(&ftAccessed, &psai->ftLastUsed) > 0)
            {
                // No; someone must have used this program
                psai->ftLastUsed = ftAccessed;

                if (!bNoImageChange)
                {
                    // If there was an exe file for the icon, release that
                    if (psai->pszImage)
                        SHFree(psai->pszImage);

                    // Set the icon image of this app to this exe's icon
                    // because this exe is the most recently used one.

                    SHStrDup(pszExe, &psai->pszImage);
                }
            }
        }

        CloseHandle(hFile);
    }
}

const static struct {
    LPTSTR szAppName;
    LPTSTR szExeName;
} s_rgAppHacks[] = {
    { TEXT("Microsoft Office"), TEXT("msoffice.exe")},
};

//--------------------------------------------------------------------------------
//  CAppInfoFinder class
//--------------------------------------------------------------------------------

static const WCHAR sc_wszStarDotExe[] = L"*.exe";

// Use the TreeWalker to find the application "exe" file
class CAppInfoFinder : public CAppFolderSize
{
public:
    CAppInfoFinder(PSLOWAPPINFO psai, BOOL fSize, LPCTSTR pszHintExe, BOOL fNoImageChange);
    
    // *** IShellTreeWalkerCallBack methods (override) ***
    STDMETHOD(FoundFile)    (LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);

    HRESULT SearchInFolder(LPCTSTR pszFolder);

protected:
    PSLOWAPPINFO _psai;
    BOOL _fComputeSize;         // Compute size or not
    BOOL _fNoImageChange;       // Do not change image from now on.
    TCHAR _szHintExe[MAX_PATH];
}; 


// constructor
CAppInfoFinder::CAppInfoFinder(PSLOWAPPINFO psai, BOOL fSize, LPCTSTR pszHintExe, BOOL fNoImageChange) :
   _fComputeSize(fSize), _fNoImageChange(fNoImageChange), _psai(psai), CAppFolderSize(&psai->ullSize)
{
    if (pszHintExe)
        lstrcpyn(_szHintExe, pszHintExe, ARRAYSIZE(_szHintExe));
}


/*-------------------------------------------------------------------------
Purpose: IShellTreeWalkerCallBack::FoundFile

         Extracts the exe info that we want if the given file matches
         an exe spec.  The info is stored in the _psai member variable.
*/
HRESULT CAppInfoFinder::FoundFile(LPCWSTR pwszFile, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfdw)
{
    HRESULT hres = S_OK;

    ASSERT(IS_VALID_STRING_PTRW(pwszFile, -1));

    if (PathMatchSpecW(pwfdw->cFileName, sc_wszStarDotExe))
    {
        TCHAR szPath[MAX_PATH];
        TraceMsg(TF_SLOWFIND, "Found Exe File: %s", pwszFile);
        
        SHUnicodeToTChar(pwszFile, szPath, ARRAYSIZE(szPath));

        if (!PathIsSetup(szPath, 2))
        {
            ExtractExeInfo(szPath, _psai, _fNoImageChange);

            if (_szHintExe[0] != TEXT('\0'))
            {
                // Does this exe match our app's Hint icon exe?
                if (!lstrcmpi(_szHintExe, PathFindFileName(szPath)))
                {
                    // Yes, Bingo!! Use this icon. 

                    // If there was an exe file for the icon, release that
                    if (_psai->pszImage)
                        SHFree(_psai->pszImage);

                    // Set the icon image of this app to this exe's icon
                    SHStrDup(szPath, &_psai->pszImage);

                    _fNoImageChange = TRUE;
                }
            }
        }
    }

    if (_fComputeSize)
        hres = CAppFolderSize::FoundFile(pwszFile, ptws, pwfdw);
        
    return hres;
}


/*-------------------------------------------------------------------------
Purpose: Method to kick off the tree walk, starting at pszFolder.
*/
HRESULT CAppInfoFinder::SearchInFolder(LPCTSTR pszFolder)
{
    HRESULT hres = E_FAIL;
    WCHAR wszDir[MAX_PATH];

    SHTCharToUnicode(pszFolder, wszDir, SIZECHARS(wszDir));

    if (_pstw)
        hres = _pstw->WalkTree(0, wszDir, NULL, 0, SAFECAST(this, IShellTreeWalkerCallBack *));

    return hres;
}


//--------------------------------------------------------------------------------
//  CAppInfoFinderSM class
//--------------------------------------------------------------------------------


// Use the TreeWalker to find the application "exe" file
class CAppInfoFinderSM : public CStartMenuAppFinder
{
public:
    CAppInfoFinderSM(LPCTSTR pszFullName, LPCTSTR pszShortName, PSLOWAPPINFO psai);
    
    // *** IShellTreeWalkerCallBack methods ***
    virtual STDMETHODIMP FoundFile(LPCWSTR pwszFolder, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);

protected:
    PSLOWAPPINFO _psai;
    TCHAR _szFakeFolder[MAX_PATH];
}; 


// constructor
CAppInfoFinderSM::CAppInfoFinderSM(LPCTSTR pszFullName, LPCTSTR pszShortName, PSLOWAPPINFO psai) : 
    _psai(psai),CStartMenuAppFinder(pszFullName, pszShortName, _szFakeFolder)
{
}


/*-------------------------------------------------------------------------
Purpose: IShellTreeWalkerCallBack::FoundFile

         Extracts the exe info that we want if the given file matches
         an exe spec.  The info is stored in the _psai member variable.
*/
HRESULT CAppInfoFinderSM::FoundFile(LPCWSTR pwszFile, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    TCHAR szLnkFile[MAX_PATH];

    ASSERT(IS_VALID_STRING_PTRW(pwszFile, -1));

    SHUnicodeToTChar(pwszFile, szLnkFile, ARRAYSIZE(szLnkFile));
    TraceMsg(TF_SLOWFIND, "CSMAF:Lnk %s -- %s %s", _pszFullName, szLnkFile);

    if (!_MatchSMLinkWithApp(szLnkFile))
        return S_OK;

    TCHAR szTargetFile[MAX_PATH];
    HRESULT hresT = GetShortcutTarget(szLnkFile, szTargetFile, ARRAYSIZE(szTargetFile));
    if ((S_FALSE == hresT) || ((S_OK == hresT) && !PathIsRoot(szTargetFile) && !PathIsUnderWindows(szTargetFile) && !PathIsSetup(szTargetFile, 1)))
    {
        LPCTSTR pszName = PathFindFileName(szTargetFile);
        
        if (PathMatchSpec(pszName, sc_wszStarDotExe))
            ExtractExeInfo(szTargetFile, _psai, FALSE);
    }

    return S_OK;
}


LPTSTR LookUpHintExes(LPCTSTR pszAppName, LPTSTR pszHintExe, DWORD cbHintExe)
{
    // Open the reg key
    HKEY hkeyIconHints = NULL;
    LPTSTR pszRet = NULL;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Management\\Icon Hints")
                                      , 0, KEY_READ, &hkeyIconHints))
    {
        DWORD dwType;
        // Look up in the registry for this cpl name
        if ((ERROR_SUCCESS == SHQueryValueEx(hkeyIconHints, pszAppName, NULL, &dwType, pszHintExe, &cbHintExe))
            && (dwType == REG_SZ))
        {
            pszRet = pszHintExe;
        }

        RegCloseKey(hkeyIconHints);
    }

    return pszRet;
}

// use the tree walker to find the "exe" file for the application
HRESULT FindAppInfo(LPCTSTR pszFolder, LPCTSTR pszFullName, LPCTSTR pszShortName, PSLOWAPPINFO psai, BOOL bChanged)
{
    // If there is no output string, a folder and a name, we can't do anything
    ASSERT(IS_VALID_WRITE_PTR(psai, SLOWAPPINFO));
    if (pszFolder)
    {
        // We only compute sizes for locally installed apps and apps installed
        // on fixed drives. Ex: On board or external hard drives.
        // We purposely not compute size for network apps, apps on the CD ROMs and so on

        BOOL bGetSize = bChanged && PathIsLocalAndFixed(pszFolder);
        
        TCHAR szHintExe[MAX_PATH];
        LPTSTR pszHintExe = LookUpHintExes(pszFullName, szHintExe, SIZEOF(szHintExe));
        CAppInfoFinder * paef = new CAppInfoFinder(psai, bGetSize, pszHintExe, !bChanged);
        if (paef)
        {
            if (SUCCEEDED(paef->Initialize()))
                paef->SearchInFolder(pszFolder);
            
            paef->Release();
        }
    }

    if (bChanged)
    {
        CAppInfoFinderSM * paifsm = new CAppInfoFinderSM(pszFullName, pszShortName, psai);
        if (paifsm)
        {
            if (SUCCEEDED(paifsm->Initialize()))
            {
                TCHAR szStartMenu[MAX_PATH];
                if (SHGetSpecialFolderPath(NULL, szStartMenu, CSIDL_COMMON_PROGRAMS, FALSE))
                    paifsm->SearchInFolder(szStartMenu);

                if (SHGetSpecialFolderPath(NULL, szStartMenu, CSIDL_PROGRAMS, FALSE))
                    paifsm->SearchInFolder(szStartMenu);
            }            
            paifsm->Release();
        }
    }
    
    return S_OK;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\uninstal.c ===
//
//  Uninstal.C
//
//  Copyright (C) Microsoft, 1994,1995 All Rights Reserved.
//
//  History:
//  3/20/95  [stevecat] - NT port & real clean up, unicode, etc.
//
//
#include "priv.h"
#include "appwiz.h"
#include "regstr.h"
#include "dlinst.h"

#ifdef WX86
BOOL bWx86Enabled=FALSE;
BOOL bForceX86Env=FALSE;
const WCHAR ProcArchName[]=L"PROCESSOR_ARCHITECTURE";
#endif

#ifdef DOWNLEVEL

//////////////////////////////////////////////////////////////////////////////
//
// Unistall Page - the basic idea:
//
//  this page has a simple listbox displaying removable software components
//  the user can select one and hit the "remove" button
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
// defines
//
//////////////////////////////////////////////////////////////////////////////

#define UNM_WAKEUP     ( WM_APP + 1 )   // from terminated worker thread


//////////////////////////////////////////////////////////////////////////////
//
// constant strings
//
//////////////////////////////////////////////////////////////////////////////

static const TCHAR *c_UninstallKey = REGSTR_PATH_UNINSTALL;
static const TCHAR *c_UninstallItemName = REGSTR_VAL_UNINSTALLER_DISPLAYNAME;
static const TCHAR *c_UninstallItemCommand = REGSTR_VAL_UNINSTALLER_COMMANDLINE;

const static DWORD aUninstallHelpIDs[] = {  // Context Help IDs
                IDC_BUTTONSETUP,     IDH_APPWIZ_DISKINTALLL_BUTTON,
                IDC_MODIFYUNINSTALL, IDH_APPWIZ_UNINSTALL_BUTTON,
                IDC_REGISTERED_APPS, IDH_APPWIZ_UNINSTALL_LIST,
                0, 0
                };

#define DISPLAYNAME_SIZE 64




//////////////////////////////////////////////////////////////////////////////
//
// Uninstall_FreeList -- empties list of removable applications
//
//  NOTE: the third parameter is the listbox to empty, which may be NULL
//
//////////////////////////////////////////////////////////////////////////////

void Uninstall_FreeList( HWND dlg, LPWIZDATA lpwd, HWND listbox )
{
    if( listbox )
        ListBox_ResetContent( listbox );

    if( lpwd->lpUItem )
    {
        LocalFree( (HANDLE)lpwd->lpUItem );
        lpwd->lpUItem = 0;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Uninstall_RefreshList -- fills/refills the list of removable applications
//
//////////////////////////////////////////////////////////////////////////////

void Uninstall_RefreshList( HWND dlg, LPWIZDATA lpwd )
{
    DWORD   dwTotal;

    //
    // we wouldn't have gotten here if dlgmgr failed to create the listbox
    //

    HWND listbox = GetDlgItem( dlg, IDC_REGISTERED_APPS );

    //
    // avoid flicker when visible
    //

    SetWindowRedraw( listbox, FALSE );

    //
    // clean out any residual junk
    //

    Uninstall_FreeList( dlg, lpwd, listbox );

    //
    // Maximum size of lists of removable apps
    //

    dwTotal = 0;

    DL_FillAppListBox(listbox, &dwTotal);

    DL_ConfigureButtonsAndStatic(dlg, listbox, LB_ERR);
    //
    // redraw now that we've filled it
    //

    SetWindowRedraw( listbox, TRUE );

}


//////////////////////////////////////////////////////////////////////////////
//
// UNINSTALL_THREAD_INFO
//
//////////////////////////////////////////////////////////////////////////////

typedef struct
{
    PROCESS_INFORMATION uninstaller;
    HWND dlg;

} UNINSTALL_THREAD_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// Uninstall_TrackingThread
//
//    -- waits for an uninstall command  to complete and refreshes the dialog
//
//////////////////////////////////////////////////////////////////////////////

DWORD Uninstall_TrackingThread( UNINSTALL_THREAD_INFO *info )
{
    ResumeThread( info->uninstaller.hThread );
    CloseHandle( info->uninstaller.hThread );

    WaitForSingleObject( info->uninstaller.hProcess, INFINITE );
    CloseHandle( info->uninstaller.hProcess );

    PostMessage( info->dlg, UNM_WAKEUP, 0, 0 );
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//
// InstallUninstallDlgProc -- dlgproc for the install/uninstall page (surprise)
//
//////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK
InstallUninstallDlgProc( HWND dlg, UINT message, WPARAM wparam, LPARAM lparam )
{
    LPPROPSHEETPAGE page = (LPPROPSHEETPAGE)GetWindowLongPtr( dlg, DWLP_USER );
    LPWIZDATA lpwd = page ? (LPWIZDATA)page->lParam : NULL;

    switch( message )
    {
        case WM_INITDIALOG:
            SetWindowLongPtr( dlg, DWLP_USER, lparam );
            page = (LPPROPSHEETPAGE)lparam;
            lpwd = (LPWIZDATA)page->lParam;
            lpwd->hwnd = dlg;
            Uninstall_RefreshList( dlg, lpwd );

#ifdef WX86
            //
            // Set initial state of ForceX86Env to FALSE (unchecked)
            //
            bForceX86Env = FALSE;

            if (bWx86Enabled) {
                SendDlgItemMessage(dlg,
                                   IDC_FORCEX86ENV,
                                   BM_SETSTATE,
                                   BST_UNCHECKED,
                                   0
                                   );
           } else {
                ShowWindow(GetDlgItem(dlg,IDC_FORCEX86ENV), SW_HIDE);
           }
#endif

            break;
        case WM_DESTROY:
            Uninstall_FreeList( dlg, lpwd, NULL );
            break;

        case UNM_WAKEUP:
            //
            // an uninstall in another thread just finished
            //

            EnableWindow( GetParent( dlg ), TRUE );
            SetForegroundWindow( GetParent( dlg ) );
            Uninstall_RefreshList( dlg, lpwd );
            break;

        case WM_NOTIFY:
        {
            NMHDR *nmhdr = (NMHDR *)lparam;

            switch( nmhdr->code )
            {
                case PSN_SETACTIVE:
                    lpwd->hwnd = dlg;
                    break;

                case PSN_KILLACTIVE:
                case PSN_HASHELP:
                case PSN_HELP:
                    break;

                default:
                    return FALSE;
            }
            break;
        }

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lparam)->hItemHandle, NULL,
                    HELP_WM_HELP, (DWORD_PTR)aUninstallHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wparam, NULL, HELP_CONTEXTMENU,
                    (DWORD_PTR)aUninstallHelpIDs);
            break;

        case WM_COMMAND:
            switch( GET_WM_COMMAND_ID( wparam, lparam ) )
            {
                case IDC_BUTTONSETUP:
                    if( GET_WM_COMMAND_CMD( wparam, lparam ) == BN_CLICKED ) {
                        if (SetupWizard(lpwd)) {
                            DismissCPL(lpwd);
                        }
                    }
                    break;

                case IDC_MODIFY:
                case IDC_REPAIR:
                case IDC_UNINSTALL:
                case IDC_MODIFYUNINSTALL:
                    if( GET_WM_COMMAND_CMD( wparam, lparam ) == BN_CLICKED )
                    {
                        HWND hwndListBox = GetDlgItem(dlg, IDC_REGISTERED_APPS);
                        
                        if (hwndListBox)
                        {
                            int iSel = ListBox_GetCurSel(hwndListBox);
                    
                            if (LB_ERR != iSel)
                                DL_InvokeAction(GET_WM_COMMAND_ID( wparam, lparam ), dlg, hwndListBox, iSel);
                        }
                    }
                    break;

                case IDC_REGISTERED_APPS:
                    switch( GET_WM_COMMAND_CMD( wparam, lparam ) )
                    {
                        case LBN_SELCHANGE:
                            {
                                HWND hwndListBox = GetDlgItem(dlg, IDC_REGISTERED_APPS);
                            
                                if (hwndListBox)
                                {
                                    int iSel = ListBox_GetCurSel(hwndListBox);
                        
                                    if (LB_ERR != iSel)
                                        DL_ConfigureButtonsAndStatic(dlg, hwndListBox, iSel);
                                }
                                break;
                            }

                        case LBN_DBLCLK:
                            {
                                int iButtonID = 0;
                                HWND hwndListBox = GetDlgItem(dlg, IDC_REGISTERED_APPS);
                                
                                if (hwndListBox)
                                {
                                    int iSel = ListBox_GetCurSel(hwndListBox);
                        
                                    if (LB_ERR != iSel)
                                    {
                                        // Go through all the buttons in order of less damaging to more
                                        //   damaging and invoke the first visible+enable one

                                        HWND hwndTmp = GetDlgItem(dlg, IDC_MODIFYUNINSTALL);

                                        if (IsWindowVisible(hwndTmp) && IsWindowEnabled(hwndTmp))
                                            iButtonID = IDC_MODIFYUNINSTALL;
                                        else
                                        {
                                            hwndTmp = GetDlgItem(dlg, IDC_MODIFY);
                                            if (IsWindowVisible(hwndTmp) && IsWindowEnabled(hwndTmp))
                                                iButtonID = IDC_MODIFY;
                                            else
                                            {
                                                hwndTmp = GetDlgItem(dlg, IDC_REPAIR);
                                                if (IsWindowVisible(hwndTmp) && IsWindowEnabled(hwndTmp))
                                                    iButtonID = IDC_REPAIR;
                                                else
                                                {
                                                    hwndTmp = GetDlgItem(dlg, IDC_UNINSTALL);
                                                    if (IsWindowVisible(hwndTmp) && IsWindowEnabled(hwndTmp))
                                                        iButtonID = IDC_UNINSTALL;
                                                }
                                            }
                                        }
                                        if (iButtonID)
                                            DL_InvokeAction(iButtonID, dlg, hwndListBox, iSel);
                                    }
                                }
                                break;
                            }
                    }
                    break;

#ifdef WX86
                case IDC_FORCEX86ENV:
                    if (bWx86Enabled &&
                        GET_WM_COMMAND_CMD( wparam, lparam ) == BN_CLICKED )
                      {
                       bForceX86Env = !bForceX86Env;
                    }
                    break;
#endif

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

#endif // DOWNLEVEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\util.cpp ===
// 
// Random stuff
//
//


#include "priv.h"
#include "exdisp.h"
#include "mshtml.h"
#include "htiframe.h"
#include "util.h"
#include "resource.h"
#include "appwizid.h"

#ifdef DOWNLEVEL_PLATFORM

#define DF_DEBUGQI 0
#define TF_QISTUB 0

#ifdef DEBUG
#define DEBUG_WAS_DEFINED
#undef DEBUG
#endif

#include "dbutil.h"
#include "..\inc\dbutil.cpp"
#include "..\inc\qistub.cpp"

#ifdef DEBUG_WAS_DEFINED
#define DEBUG
#undef DEBUG_WAS_DEFINED
#endif

#endif

#define CPP_FUNCTIONS
#include <crtfree.h>        // declare new, delete, etc.

#define DATEFORMAT_MAX 40

#ifndef DOWNLEVEL_PLATFORM

#include <shguidp.h>
#include <ieguidp.h>

// is this okay to do?
#ifdef ENTERCRITICAL
#undef ENTERCRITICAL
#endif
#ifdef LEAVECRITICAL
#undef LEAVECRITICAL
#endif

#define ENTERCRITICAL
#define LEAVECRITICAL

#include "..\inc\uassist.cpp"
#endif //DOWNLEVEL_PLATFORM

// Prototype
BOOL _IsARPAllowed(void);

const VARIANT c_vaEmpty = {0};
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)
STDAPI OpenAppMgr(HWND hwnd, int nPage)
{
    HRESULT hres = E_FAIL;

    // Make sure we aren't restricted
    if (!_IsARPAllowed())
    {
        ShellMessageBox(g_hinst, hwnd, MAKEINTRESOURCE(IDS_RESTRICTION),
            MAKEINTRESOURCE(IDS_NAME), MB_OK | MB_ICONEXCLAMATION);
    }
    else if ((nPage >= 0) && (nPage < NUMSTARTPAGES))
    {
        ARP(hwnd, nPage);        
        hres = S_OK;
    }
    return hres;
}


inline void StrFree(LPWSTR psz)
{
    if (psz)
        SHFree(psz);
}


/*-------------------------------------------------------------------------
Purpose: Clear the given app data structure.  Frees any allocated fields.
*/
void ClearAppInfoData(APPINFODATA * pdata)
{
    if (pdata)
    {
        if (pdata->dwMask & AIM_DISPLAYNAME)
            StrFree(pdata->pszDisplayName);
            
        if (pdata->dwMask & AIM_VERSION)
            StrFree(pdata->pszVersion);

        if (pdata->dwMask & AIM_PUBLISHER)
            StrFree(pdata->pszPublisher);
            
        if (pdata->dwMask & AIM_PRODUCTID)
            StrFree(pdata->pszProductID);
            
        if (pdata->dwMask & AIM_REGISTEREDOWNER)
            StrFree(pdata->pszRegisteredOwner);
            
        if (pdata->dwMask & AIM_REGISTEREDCOMPANY)
            StrFree(pdata->pszRegisteredCompany);
            
        if (pdata->dwMask & AIM_LANGUAGE)
            StrFree(pdata->pszLanguage);
            
        if (pdata->dwMask & AIM_SUPPORTURL)
            StrFree(pdata->pszSupportUrl);
            
        if (pdata->dwMask & AIM_SUPPORTTELEPHONE)
            StrFree(pdata->pszSupportTelephone);
            
        if (pdata->dwMask & AIM_HELPLINK)
            StrFree(pdata->pszHelpLink);
            
        if (pdata->dwMask & AIM_INSTALLLOCATION)
            StrFree(pdata->pszInstallLocation);
            
        if (pdata->dwMask & AIM_INSTALLSOURCE)
            StrFree(pdata->pszInstallSource);
            
        if (pdata->dwMask & AIM_INSTALLDATE)
            StrFree(pdata->pszInstallDate);
            
        if (pdata->dwMask & AIM_CONTACT)
            StrFree(pdata->pszContact);

        if (pdata->dwMask & AIM_COMMENTS)
            StrFree(pdata->pszComments);

        if (pdata->dwMask & AIM_IMAGE)
            StrFree(pdata->pszImage);
    }
}


void ClearSlowAppInfo(SLOWAPPINFO * pdata)
{
    if (pdata)
    {
        StrFree(pdata->pszImage);
        pdata->pszImage = NULL;
    }
}


// NOTE: Returns TRUE only if psaiNew has valid info and different from psaiOrig
BOOL IsSlowAppInfoChanged(PSLOWAPPINFO psaiOrig, PSLOWAPPINFO psaiNew)
{
    BOOL bRet = FALSE;

    ASSERT(psaiOrig && psaiNew);

    if (psaiNew)
    {    
        // Compare size first
        if (psaiOrig == NULL)
        {
            bRet = TRUE;
        }
        else if (((__int64)psaiNew->ullSize > 0) && (psaiNew->ullSize != psaiOrig->ullSize))
        {
            bRet = TRUE;
        }
        // Now compare the file time
        else if (((0 != psaiNew->ftLastUsed.dwHighDateTime) &&
                  (psaiOrig->ftLastUsed.dwHighDateTime != psaiNew->ftLastUsed.dwHighDateTime))
                 || ((0 != psaiNew->ftLastUsed.dwLowDateTime) &&
                     (psaiOrig->ftLastUsed.dwLowDateTime != psaiNew->ftLastUsed.dwLowDateTime)))
        {
            bRet = TRUE;
        }
        // Compare times used
        else if (psaiOrig->iTimesUsed != psaiNew->iTimesUsed)
        {
            bRet = TRUE;
        }
        // Compare the icon image
        else if ((psaiNew->pszImage != NULL) && (psaiOrig->pszImage != NULL) && lstrcmpi(psaiNew->pszImage, psaiOrig->pszImage))
            bRet = TRUE;

    }
    return bRet;
}

void ClearManagedApplication(MANAGEDAPPLICATION * pma)
{
    if (pma)
    {
        if (pma->pszPackageName)
            LocalFree(pma->pszPackageName);

        if (pma->pszPublisher)
            LocalFree(pma->pszPublisher);

        if (pma->pszPolicyName)
            LocalFree(pma->pszPolicyName);

        if (pma->pszOwner)
            LocalFree(pma->pszOwner);

        if (pma->pszCompany)
            LocalFree(pma->pszCompany);

        if (pma->pszComments)
            LocalFree(pma->pszComments);

        if (pma->pszContact)
            LocalFree(pma->pszContact);
    }
}

/*-------------------------------------------------------------------------
Purpose: Clear the given PUBAPPINFO data structure.  Frees any allocated fields.
*/
void ClearPubAppInfo(PUBAPPINFO * pdata)
{
    if (pdata)
    {
        if ((pdata->dwMask & PAI_SOURCE) && pdata->pszSource)
            StrFree(pdata->pszSource);
    }
}

/*-------------------------------------------------------------------------
Purpose: Frees a specific category structure
*/
HRESULT ReleaseShellCategory(SHELLAPPCATEGORY * psac)
{
    ASSERT(psac);

    if (psac->pszCategory)
    {
        SHFree(psac->pszCategory);
        psac->pszCategory = NULL;
    }
    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: Frees the list of categories
*/
HRESULT ReleaseShellCategoryList(SHELLAPPCATEGORYLIST * psacl)
{
    UINT i;
    SHELLAPPCATEGORY * psac;

    ASSERT(psacl);

    psac = psacl->pCategory;
    
    for (i = 0; i < psacl->cCategories; i++, psac++)
    {
        ReleaseShellCategory(psac);
    }
    return S_OK;
}


#define MAX_INT64_SIZE  30              // 2^64 is less than 30 chars long
#define MAX_COMMA_NUMBER_SIZE   (MAX_INT64_SIZE + 10)
#define MAX_COMMA_AS_K_SIZE     (MAX_COMMA_NUMBER_SIZE + 10)
#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)


void Int64ToStr( _int64 n, LPTSTR lpBuffer)
{
    TCHAR   szTemp[MAX_INT64_SIZE];
    _int64  iChr;

    iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(n % 10);
        n = n / 10;
    } while (n != 0);

    do {
        iChr--;
        *lpBuffer++ = szTemp[iChr];
    } while (iChr != 0);

    *lpBuffer++ = '\0';
}

// takes a DWORD add commas etc to it and puts the result in the buffer
LPTSTR WINAPI AddCommas64(_int64 n, LPTSTR pszResult)
{
    // FEATURE: We should pass in the lenght on pszResult buffer, we assume 40 will be enough
    TCHAR  szTemp[MAX_COMMA_NUMBER_SIZE];
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = StrToInt(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    Int64ToStr(n, szTemp);

    // Should have passed in size
    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, MAX_COMMA_NUMBER_SIZE) == 0)
        lstrcpy(pszResult, szTemp);

    return pszResult;
}

//
// Add Peta 10^15 and Exa 10^18 to support 64-bit integers.
//
const short pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB,
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

/* converts numbers into sort formats
 *      532     -> 523 bytes
 *      1340    -> 1.3KB
 *      23506   -> 23.5KB
 *              -> 2.4MB
 *              -> 5.2GB
 */
LPTSTR WINAPI ShortSizeFormat64(__int64 dw64, LPTSTR szBuf)
{
    int i;
    _int64 wInt;
    UINT wLen, wDec;
    TCHAR szTemp[MAX_COMMA_NUMBER_SIZE], szOrder[20], szFormat[5];

    if (dw64 < 1000) {
        wsprintf(szTemp, TEXT("%d"), LODWORD(dw64));
        i = 0;
        goto AddOrder;
    }

    for (i = 1; i<ARRAYSIZE(pwOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = dw64 >> 10;
    AddCommas64(wInt, szTemp);
    wLen = lstrlen(szTemp);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpy(szFormat, TEXT("%02d"));

        szFormat[2] = TEXT('0') + 3 - wLen;
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, ARRAYSIZE(szTemp)-wLen);
        wLen = lstrlen(szTemp);
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
    }

AddOrder:
    LoadString(HINST_THISDLL, pwOrders[i], szOrder, ARRAYSIZE(szOrder));
    wsprintf(szBuf, szOrder, (LPTSTR)szTemp);

    return szBuf;
}


#define c_szUninstallPolicy     L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Uninstall"


/*-------------------------------------------------------------------------
Purpose: Helper function for ARP's policy check
*/
DWORD ARPGetRestricted(LPCWSTR pszPolicy)
{
    return SHGetRestriction(NULL, TEXT("Uninstall"), pszPolicy);
}


/*-------------------------------------------------------------------------
Purpose: Return a policy string value
*/
void ARPGetPolicyString(LPCWSTR pszPolicy, LPWSTR pszBuf, int cch)
{
    DWORD dwSize, dwType;

    *pszBuf = 0;
    
    // Check local machine first and let it override what the
    // HKCU policy has done.
    dwSize = cch * sizeof(WCHAR);
    if (ERROR_SUCCESS != SHGetValueW(HKEY_LOCAL_MACHINE,
                                     c_szUninstallPolicy, pszPolicy,
                                     &dwType, pszBuf, &dwSize))
    {
        // Check current user if we didn't find anything for the local machine.
        dwSize = cch * sizeof(WCHAR);
        SHGetValueW(HKEY_CURRENT_USER,
                    c_szUninstallPolicy, pszPolicy,
                    &dwType, pszBuf, &dwSize);
    }
}


/*-------------------------------------------------------------------------
Purpose: Returns TRUE if it's okay to start ARP.

*/
BOOL _IsARPAllowed(void)
{
    // ARP is forbidden if the entire CPL is disabled
    if (ARPGetRestricted(L"NoAddRemovePrograms"))
    {
        return FALSE;
    }

    // ARP is permitted if there exists a non-restricted page.

    BOOL fAnyPages = !ARPGetRestricted(L"NoRemovePage") ||
                     !ARPGetRestricted(L"NoAddPage") ||
                     !ARPGetRestricted(L"NoWindowsSetupPage");

    // If we are not a server SKU, then also check the new page.
    if (!fAnyPages && !IsOS(OS_ANYSERVER))
    {
        fAnyPages = !ARPGetRestricted(L"NoChooseProgramsPage");
    }

    return fAnyPages;
}


#ifndef DOWNLEVEL_PLATFORM

/*-------------------------------------------------------------------------
Purpose: Take the error message and give user feedback through messagebox
*/
void _ARPErrorMessageBox(DWORD dwError)
{
    TCHAR szErrorMsg[MAX_PATH];
    szErrorMsg[0] = 0;

    LPTSTR pszMsg = NULL;
    switch (dwError) {
        // The following error code cases are ignored.     
        case ERROR_INSTALL_USEREXIT:
        case ERROR_SUCCESS_REBOOT_REQUIRED:
        case ERROR_SUCCESS_REBOOT_INITIATED:            
            ASSERT(pszMsg == NULL);
            break;

        default:
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0L, szErrorMsg,
                          ARRAYSIZE(szErrorMsg), NULL);
            pszMsg = szErrorMsg;
            break;
    }

    if (pszMsg)
    {
        ShellMessageBox( g_hinst, NULL, pszMsg,
                         MAKEINTRESOURCE( IDS_NAME ),
                         MB_OK | MB_ICONEXCLAMATION);
    }
}

/*-------------------------------------------------------------------------
Purpose: Format the SYSTEMTIME into the following format: "mm/dd/yy h:mm"
*/
BOOL FormatSystemTimeString(LPSYSTEMTIME pst, LPTSTR pszStr, UINT cchStr)
{
    BOOL bRet = FALSE;
    FILETIME ft = {0};

    if (SystemTimeToFileTime(pst, &ft))
    {
        DWORD dwFlags = FDTF_SHORTTIME | FDTF_SHORTDATE;
        bRet = SHFormatDateTime(&ft, &dwFlags, pszStr, cchStr);
    }
    return bRet;
}
#endif //DOWNLEVEL_PLATFORM

/*-------------------------------------------------------------------------
Purpose: Get the correct Date time format for specific locale
*/
BOOL _GetLocaleDateTimeFormat(LPTSTR pszFormat, UINT cchFormat)
{
    TCHAR szTime[DATEFORMAT_MAX];
    TCHAR szDate[DATEFORMAT_MAX];
    if (cchFormat >= (ARRAYSIZE(szTime) + ARRAYSIZE(szDate) + 2))
    {
        LCID lcid = LOCALE_USER_DEFAULT;
        if (GetLocaleInfo(lcid, LOCALE_STIMEFORMAT, szTime, ARRAYSIZE(szTime)) && 
            GetLocaleInfo(lcid, LOCALE_SSHORTDATE, szDate, ARRAYSIZE(szDate)))
        {
            wsprintf(pszFormat, TEXT("%s  %s"), szDate, szTime);
            return TRUE;
        }
    }

    return FALSE;
}

/*-------------------------------------------------------------------------
Purpose: Compare two SYSTEMTIME data

Returnes : 1 : st1 > st2
           0 : st1 == st2
          -1: st1 < st2

NOTE:  We do not compare seconds since ARP does not need that much precision. 
*/
int CompareSystemTime(SYSTEMTIME *pst1, SYSTEMTIME *pst2)
{
    int iRet;

    if (pst1->wYear < pst2->wYear)
        iRet = -1;
    else if (pst1->wYear > pst2->wYear)
        iRet = 1;
    else if (pst1->wMonth < pst2->wMonth)
        iRet = -1;
    else if (pst1->wMonth > pst2->wMonth)
        iRet = 1;
    else if (pst1->wDay < pst2->wDay)
        iRet = -1;
    else if (pst1->wDay > pst2->wDay)
        iRet = 1;
    else if (pst1->wHour < pst2->wHour)
        iRet = -1;
    else if (pst1->wHour > pst2->wHour)
        iRet = 1;
    else if (pst1->wMinute < pst2->wMinute)
        iRet = -1;
    else if (pst1->wMinute > pst2->wMinute)
        iRet = 1;
//    else if (pst1->wSecond < pst2->wSecond)
//        iRet = -1;
//    else if (pst1->wSecond > pst2->wSecond)
//        iRet = 1;
    else
        iRet = 0;

    return(iRet);
}

#ifndef DOWNLEVEL_PLATFORM
/*--------------------------------------------------------------------------
Purpose: Window proc for the add later dialog box
*/
BOOL_PTR CALLBACK AddLaterDlgProc(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            PADDLATERDATA pald = (PADDLATERDATA)lp;

            // We should definitely have this (dli)
            ASSERT(pald);

            SYSTEMTIME stInit = {0};
            // Get the current local time
            GetLocalTime(&stInit);

            // Has this app already expired?
            if ((pald->dwMasks & ALD_EXPIRE) &&
                (CompareSystemTime(&pald->stExpire, &stInit) > 0))
            {
                // NO,
                
                // Assigned time does not make sense if the assigned time has already
                // passed
                if ((pald->dwMasks & ALD_ASSIGNED) &&
                    (CompareSystemTime(&pald->stAssigned, &stInit) <= 0))
                    pald->dwMasks &= ~ALD_ASSIGNED;

                // find the date/time picker window
                HWND hwndPicker = GetDlgItem(hDlg, IDC_PICKER);

                // always check "add later" radio button initially
                CheckDlgButton(hDlg, IDC_ADDLATER, BST_CHECKED);

                TCHAR szFormat[MAX_PATH];
                if (_GetLocaleDateTimeFormat(szFormat, ARRAYSIZE(szFormat)))
                {
                    // set the locale date time format
                    DateTime_SetFormat(hwndPicker, szFormat);

                    // The new time can only be in the future, so set the current time
                    // as the lower limit
                    DateTime_SetRange(hwndPicker, GDTR_MIN, &stInit);

                    // Do we have a schedule (in the future) already?
                    // Schedule in the past means nothing
                    if ((pald->dwMasks & ALD_SCHEDULE) &&
                        (CompareSystemTime(&pald->stSchedule, &stInit) >= 0))
                    {
                        // Set our initial value to this schedule
                        stInit = pald->stSchedule;
                    }

                    // Set the initial value in date/time picker
                    DateTime_SetSystemtime(hwndPicker, GDT_VALID, &stInit);

                    // Uncheck the SCHEDULE flag so that we know we don't have a new
                    // schedule, yet
                    pald->dwMasks &= ~ALD_SCHEDULE;

                    SetWindowLongPtr(hDlg, DWLP_USER, lp);

                    return TRUE;
                }
            }
            else
            {
                // Yes, it's expired, warn the user
                ShellMessageBox(g_hinst, hDlg, MAKEINTRESOURCE(IDS_EXPIRED),
                                MAKEINTRESOURCE(IDS_NAME), MB_OK | MB_ICONEXCLAMATION);

                // Then end the dialog. 
                EndDialog(hDlg, 0);
            }
            return FALSE;
        }
        break;
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wp, lp))
            {
                case IDC_ADDLATER:
                case IDC_UNSCHEDULE:
                {
                    HWND hwndPicker = GetDlgItem(hDlg, IDC_PICKER);
                    EnableWindow(hwndPicker, IsDlgButtonChecked(hDlg, IDC_ADDLATER));
                }
                break;
                
                case IDOK:
                {
                    PADDLATERDATA pald = (PADDLATERDATA)GetWindowLongPtr(hDlg, DWLP_USER);

                    // we did set window long ptr this should be there. 
                    ASSERT(pald);

                    // did the user choose to add later?
                    if (IsDlgButtonChecked(hDlg, IDC_ADDLATER))
                    {
                        // Yes
                        // Let's find out if the time user has chosen is valid
                        
#define LATER_THAN_ASSIGNED_TIME 1
#define LATER_THAN_EXPIRED_TIME 2
                        int iStatus = 0;
                        HWND hwndPicker = GetDlgItem(hDlg, IDC_PICKER);
                        DateTime_GetSystemtime(hwndPicker, &pald->stSchedule);

                        // Is this time later than the assigned time?
                        if ((pald->dwMasks & ALD_ASSIGNED) &&
                            (CompareSystemTime(&pald->stSchedule, &pald->stAssigned) > 0))
                            iStatus = LATER_THAN_ASSIGNED_TIME;

                        // Is this time later than the expired time?
                        if ((pald->dwMasks & ALD_EXPIRE) &&
                            (CompareSystemTime(&pald->stSchedule, &pald->stExpire) >= 0))
                            iStatus = LATER_THAN_EXPIRED_TIME;

                        // Is either of the above two cases TRUE?
                        if (iStatus > 0)
                        {
                            TCHAR szDateTime[MAX_PATH];
                            
                            // Is the time user chose passed expired time or assigned?
                            BOOL bExpired = (iStatus == LATER_THAN_EXPIRED_TIME);
                            
                            // Get the time string
                            if (FormatSystemTimeString(bExpired ? &pald->stExpire : &pald->stAssigned,
                                szDateTime, ARRAYSIZE(szDateTime)))
                            {
                                TCHAR szFinal[MAX_PATH * 2];
                                TCHAR szWarn[MAX_PATH];
                                LoadString(g_hinst,  bExpired ? IDS_PASSEXPIRED : IDS_PASSASSIGNED,
                                           szWarn, ARRAYSIZE(szWarn));
                                
                                wsprintf(szFinal, szWarn, szDateTime, szDateTime);
                                ShellMessageBox(g_hinst, hDlg, szFinal, 
                                                MAKEINTRESOURCE(IDS_NAME), MB_OK | MB_ICONEXCLAMATION);
                            }
                        }
                        else
                            // No, we are okay to go
                            pald->dwMasks |= ALD_SCHEDULE;
                    }
                }

                //
                // fall through
                //
                case IDCANCEL:
                    EndDialog(hDlg, (GET_WM_COMMAND_ID(wp, lp) == IDOK));
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

/*-------------------------------------------------------------------------
Purpose: GetNewInstallTime

         Start up the Add Later dialog box to get the new install schedule
         (represented by a SYSTEMTIME data struct) 
*/
BOOL GetNewInstallTime(HWND hwndParent, PADDLATERDATA pal)
{
    return (DialogBoxParam(g_hinst, MAKEINTRESOURCE(DLG_ADDLATER),
                           hwndParent, AddLaterDlgProc, (LPARAM)pal) == IDOK);
}
#endif //DOWNLEVEL_PLATFORM

// Take the name of the potential app folder and see if it ends with numbers or dots
// if it does, let's separate the numbers and see if there is a match.
// It's inspired by cases like Office8.0 or MSVC50 or Bookshelf98
// NOTE: we can't use the key words without the numbers, it might lead to mistake
// in case the user has two versions of the same software on one machine. (there might
// be something we can do though, I am too tired to think about this now)
void InsertSpaceBeforeVersion(LPCTSTR pszIn, LPTSTR pszOut)
{
    ASSERT(IS_VALID_STRING_PTR(pszIn, -1));
    ASSERT(IS_VALID_STRING_PTR(pszOut, -1));

    // Copy the old string into the buffer
    lstrcpy(pszOut, pszIn);

    // Find the end of the string
    LPTSTR pszEnd = pszOut + lstrlen(pszOut);
    ASSERT(pszEnd > pszOut);

    // Go back until we can't see numbers or '.'
    LPTSTR pszLastChar = CharPrev(pszOut, pszEnd);
    LPTSTR pszPrev = pszLastChar;
    while ((pszPrev > pszOut) && (((*pszPrev <= TEXT('9')) && (*pszPrev >= TEXT('0'))) || (*pszPrev == TEXT('.'))))
        pszPrev = CharPrev(pszOut, pszPrev);

    // Did we find any numbers at the end?
    if ((pszPrev < pszLastChar) && IsCharAlphaNumeric(*pszPrev))
    {
        // Yes, let's stick a ' ' in between
        TCHAR szNumbers[MAX_PATH];
        lstrcpy(szNumbers, ++pszPrev);
        *(pszPrev++) = TEXT(' ');
        lstrcpy(pszPrev, szNumbers);
    }
}

#ifndef DOWNLEVEL_PLATFORM
// 
// Basic sanity check on whether the app folder location is valid. 
// Return Value:
// TRUE does not mean it is valid.
// FALSE means it definitely is not valid.
//
BOOL IsValidAppFolderLocation(LPCTSTR pszFolder)
{
    ASSERT(IS_VALID_STRING_PTR(pszFolder, -1));
    BOOL bRet = FALSE;
    if (!PathIsRoot(pszFolder) && PathFileExists(pszFolder) && PathIsDirectory(pszFolder))
    {
        TCHAR szPath[MAX_PATH];
        if (lstrcpy(szPath, pszFolder) && PathStripToRoot(szPath))
            bRet = (GetDriveType(szPath) == DRIVE_FIXED);
    }

    return bRet;
}

#ifdef WINNT
EXTERN_C BOOL IsTerminalServicesRunning(void)
{
    static int s_fIsTerminalServer = -1;

    if (s_fIsTerminalServer == -1)
    {
        BOOL TSAppServer;
        BOOL TSRemoteAdmin;
    
        OSVERSIONINFOEX osVersionInfo;
        DWORDLONG dwlConditionMask = 0;
    
        ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
        osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;
    
        VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
    
        TSAppServer = (int)VerifyVersionInfo(&osVersionInfo, VER_SUITENAME, dwlConditionMask);
    
    
        ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
        osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;
    
        VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
    
        TSRemoteAdmin = (int)VerifyVersionInfo(&osVersionInfo, VER_SUITENAME, dwlConditionMask);
    
        if ( !TSRemoteAdmin & TSAppServer )
        {
            s_fIsTerminalServer = TRUE;
        }
        else
        {
            // do not treat tsremoteadmin as TS machine from the application compatability point of view.
            s_fIsTerminalServer = FALSE;
        }
    }

    return s_fIsTerminalServer ? TRUE : FALSE;
}

#endif //WINNT
#endif //DOWNLEVEL_PLATFORM

// returns TRUE if pszFile is a local file and on a fixed drive
BOOL PathIsLocalAndFixed(LPCTSTR pszFile)
{
    if (!pszFile || !pszFile[0])
        return FALSE;

    if (PathIsUNC(pszFile))
        return FALSE;
    
    TCHAR szDrive[MAX_PATH];
    lstrcpy(szDrive, pszFile); 
    if (PathStripToRoot(szDrive) && GetDriveType(szDrive) != DRIVE_FIXED)
        return FALSE;

    return TRUE;
}


// This function will duplicate an APPCATEGORYINFOLIST and allocate the new copy
// using COM memory allocation functions
STDAPI  _DuplicateCategoryList(APPCATEGORYINFOLIST * pacl, APPCATEGORYINFOLIST * paclNew)
{
    HRESULT hres = E_FAIL;
    ASSERT(pacl && paclNew);
    ZeroMemory(paclNew, SIZEOF(APPCATEGORYINFOLIST));

    if (pacl && (pacl->cCategory > 0) && pacl->pCategoryInfo)
    {
        DWORD dwDesiredSize = pacl->cCategory * SIZEOF(APPCATEGORYINFO);
        APPCATEGORYINFO * paci = pacl->pCategoryInfo;
        paclNew->pCategoryInfo = (APPCATEGORYINFO *)SHAlloc(dwDesiredSize);
        if (paclNew->pCategoryInfo)
        {
            UINT iCategory = 0;
            paclNew->cCategory = 0;
            APPCATEGORYINFO * paciNew = paclNew->pCategoryInfo;
            while (paci && (iCategory < pacl->cCategory))
            {
                if (paci->pszDescription)
                {
                    hmemcpy(paciNew, paci, SIZEOF(APPCATEGORYINFO));
                    if (FAILED(SHStrDup(paci->pszDescription, &(paciNew->pszDescription))))
                    {
                        // We may be out of memory, stop here. 
                        ZeroMemory(paciNew, SIZEOF(APPCATEGORYINFO));
                        break;
                    }
                    
                    paciNew++;
                    paclNew->cCategory++;
                }
                
                iCategory++;
                paci++;
            }

            hres = S_OK;
        }
        else
            hres = E_OUTOFMEMORY;
    }
    return hres;
}

STDAPI _DestroyCategoryList(APPCATEGORYINFOLIST * pacl)
{
    if (pacl && pacl->pCategoryInfo)
    {
        UINT iCategory = 0;
        APPCATEGORYINFO * paci = pacl->pCategoryInfo;
        while (paci && (iCategory < pacl->cCategory))
        {
            if (paci->pszDescription)
            {
                SHFree(paci->pszDescription);
            }
            iCategory++;
            paci++;
        }
        SHFree(pacl->pCategoryInfo);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\worker.cpp ===
//  worker.cpp
//
//      Implementation of the worker thread object
//

#include "priv.h"

// Do not build this file if on Win9X or NT4
#ifndef DOWNLEVEL_PLATFORM

#include "resource.h"
#include "worker.h"


//--------------------------------------------------------------------
//
//
//  CWorkerThread class
//
//
//--------------------------------------------------------------------


//  CWorkerThread constructor

CWorkerThread::CWorkerThread() : _cRef(1)
{
    ASSERT(NULL == _hthreadWorker);
    ASSERT(NULL == _hwndWorker);
    ASSERT(FALSE == _fKillWorker);
    ASSERT(NULL == _pwe);
    ASSERT(0 == _cRefLockWorker);

    InitializeCriticalSection(&_csWorker);
    DllAddRef();
}


//  CWorkerThread destructor

CWorkerThread::~CWorkerThread()
{
    ASSERT(0 == _cRefLockWorker);

    if (IsWindow(_hwndWorker))
    {
        DestroyWindow(_hwndWorker);
    }

    SetListenerWT(NULL);
    DeleteCriticalSection(&_csWorker);

    DllRelease();
}


BOOL CWorkerThread::PostWorkerMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bRet = FALSE;

    _LockWorker();
    // Only if we are not being killed, and the worker window is valid we
    // post the message, we don't want to post to NULL window (desktop)
    if (!_fKillWorker && _hwndWorker)
        bRet = PostMessage(_hwndWorker, uMsg, wParam, lParam);
    _UnlockWorker();
    return bRet;
}

/*--------------------------------------------------------------------
Purpose: IUnknown::QueryInterface
*/
STDMETHODIMP CWorkerThread::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CWorkerThread, IARPWorker),
        { 0 },
    };

    return QISearch(this, (LPCQITAB)qit, riid, ppvObj);
}


STDMETHODIMP_(ULONG) CWorkerThread::AddRef()
{
    LONG cRef = InterlockedIncrement(&_cRef);
    TraceAddRef(CWorkerThread, cRef);
    return cRef;
}


STDMETHODIMP_(ULONG) CWorkerThread::Release()
{
    LONG cRef = InterlockedDecrement(&_cRef);
    TraceRelease(CWorkerThread, cRef);
    if (cRef)
        return cRef;

    delete this;
    return 0;
}

/*-------------------------------------------------------------------------
Purpose: Sets the event listener so the worker thread can fire
         events incrementally.
*/
HRESULT CWorkerThread::SetListenerWT(IWorkerEvent * pwe)
{
    _LockWorker();
    {
        // We have to protect _pwe because it can be accessed by this
        // thread and the main thread.

        // Don't AddRef the event listener or we'll have a circular
        // reference.
        _pwe = pwe;
    }
    _UnlockWorker();

    return S_OK;
}


/*-------------------------------------------------------------------------
Purpose: Start the thread
*/
HRESULT CWorkerThread::StartWT(int iPriority)
{
    DWORD thid;     // Not used but we have to pass something in

    // Create a hidden top-level window to post messages to from the
    // worker thread
    _hwndWorker = SHCreateWorkerWindow(_WorkerWndProcWrapper, NULL, 0, 0, NULL, this);

    if (_hwndWorker)
    {
        AddRef(); // AddRef myself, the background thread is responsible of releasing
        // this ref count

        // Kick off the worker thread to do the slow enumeration.
        _hthreadWorker = CreateThread(NULL, 0,
                                      (LPTHREAD_START_ROUTINE)_ThreadStartProcWrapper,
                                      (LPVOID)this, CREATE_SUSPENDED, &thid);

        if (_hthreadWorker)
        {
            // Demote the priority so it doesn't interfere with the
            // initial HTML databinding.
            SetThreadPriority(_hthreadWorker, iPriority);
            ResumeThread(_hthreadWorker);
        }
        else
        {
            // Release my refcount in case of failure
            Release();

            // If we can't create the background thread, don't bother with the window
            DestroyWindow(_hwndWorker);
            _hwndWorker = NULL;
        }
    }
    return (_hthreadWorker != NULL) ? S_OK : E_FAIL;
}


/*-------------------------------------------------------------------------
Purpose: Kills the worker thread if one is around
*/

HRESULT CWorkerThread::KillWT(void)
{
    MSG msg;

    // I should never call KillWT to kill myself
    ASSERT(_hthreadWorker != GetCurrentThread());

    TraceMsg(TF_TASKS, "[%x] Killing worker thread...", _dwThreadId);

    // Tell the worker thread to stop when it can
    // Do this inside the critical section because we don't want random messages
    // get posted to the worker window after this.
    _LockWorker();
    _fKillWorker = TRUE;
    _UnlockWorker();

    // If we have no worker thread, nothing to do
    if (_hthreadWorker)
    {
        // Now wait for the worker to stop
        if (WaitForSingleObject(_hthreadWorker, 10000) == WAIT_TIMEOUT)
            TraceMsg(TF_ERROR, "[%x] Worker thread termination wait timed out!", _dwThreadId);
        else
            TraceMsg(TF_TASKS, "[%x] Worker thread wait exited cleanly", _dwThreadId);

        // Now that the thread is stopped, release our hold so all its memory can go away
        CloseHandle(_hthreadWorker);
        _hthreadWorker = NULL;
    }

    // Make sure that all messages to our worker HWND get processed
    if (_hwndWorker)
    {
        while (PeekMessage(&msg, _hwndWorker, 0, 0, PM_REMOVE))
            DispatchMessage(&msg);

        DestroyWindow(_hwndWorker);
        _hwndWorker = NULL;
    }
    SetListenerWT(NULL);

    return S_OK;
}



//--------------------------------------------------------------------
// Private methods



void CWorkerThread::_LockWorker(void)
{
    EnterCriticalSection(&_csWorker);
    DEBUG_CODE( _cRefLockWorker++; )
}

void CWorkerThread::_UnlockWorker(void)
{
    DEBUG_CODE( _cRefLockWorker--; )
    LeaveCriticalSection(&_csWorker);
}


/*-------------------------------------------------------------------------
Purpose: Static wndproc wrapper. Calls the real non-static WndProc.
*/
LRESULT
CALLBACK
CWorkerThread::_WorkerWndProcWrapper(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (uMsg == WM_DESTROY)
        SetWindowLongPtr(hwnd, 0, 0);
    else
    {
        CWorkerThread * pWorker = (CWorkerThread*)GetWindowLongPtr(hwnd, 0);
        if (pWorker)
            return pWorker->_WorkerWndProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


/*-------------------------------------------------------------------------
Purpose: Used to fire events back to Trident since they can't be fired from
         the worker thread.
*/
LRESULT
CWorkerThread::_WorkerWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WORKERWIN_FIRE_ROW_READY:
        // Posted by worker thread when async data is ready
        _LockWorker();
        {
            if (_pwe)
            {
                TraceMsg(TF_TASKS, "[%x] Firing event for row #%d", _dwThreadId, wParam);
                _pwe->FireOnDataReady((LONG)wParam);
            }
        }
        _UnlockWorker();
        return 0;

    case WORKERWIN_FIRE_FINISHED:
        // Posted by worker thread when thread is finished enumerating
        // async data.
        _LockWorker();
        {
            if (_pwe)
            {
                TraceMsg(TF_TASKS, "[%x] Firing finished", _dwThreadId);
                _pwe->FireOnFinished();
            }
        }
        _UnlockWorker();
        return 0;

    case WORKERWIN_FIRE_DATASETCHANGED:
        // Posted by worker thread when matrix array finished enumerating
        _LockWorker();
        {
            if (_pwe)
            {
                TraceMsg(TF_TASKS, "[%x] Firing DatasetChanged", _dwThreadId);
                _pwe->FireOnDatasetChanged();
            }
        }
        _UnlockWorker();
        return 0;

    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


/*-------------------------------------------------------------------------
Purpose: Start and exit of worker thread to do slow app information
*/
DWORD
CALLBACK
CWorkerThread::_ThreadStartProcWrapper(
    LPVOID lpParam          // this pointer of object since wrapper is static
    )
{
    CWorkerThread * pwt = (CWorkerThread *)lpParam;

    pwt->_dwThreadId = GetCurrentThreadId();

    return pwt->_ThreadStartProc();
}


/*-------------------------------------------------------------------------
Purpose: Contains the code run on the worker thread where we get the slow
         information about applications
*/
DWORD
CWorkerThread::_ThreadStartProc()
{
    // Don't bother killing the worker window here, let the main thread take care
    // of the life time of the worker window.

    // Signal that we don't have a worker thread anymore. Prevents race
    // conditions.
    _fKillWorker = FALSE;

    TraceMsg(TF_TASKS, "[%x] Exiting worker thread", _dwThreadId);

    // Release the ref count to "this" object at end of thread, be it CMtxArray or CDataSrc  because we
    // AddRef()ed before this thread started.
    Release();
    return 0;
}

#endif //DOWNLEVEL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\worker.h ===
// worker.h : Declaration of the CWorkerThread

#ifndef __WORKER_H_
#define __WORKER_H_

#include "iface.h"          // for IWorkerEvent


// CWorkerThread

class CWorkerThread : public IARPWorker
{
public:
    CWorkerThread();
    virtual ~CWorkerThread();
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef   (void);
    virtual STDMETHODIMP_(ULONG) Release  (void);
    virtual STDMETHODIMP QueryInterface   (REFIID riid, LPVOID * ppvObj);

    // *** IARPWorker ***
    virtual STDMETHODIMP KillWT (void);
    STDMETHOD(StartWT)          (int iPriority);
    STDMETHOD(SetListenerWT)    (IWorkerEvent * pwe);

    
    BOOL    IsKilled() { return _fKillWorker; };
    BOOL    PostWorkerMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    virtual DWORD   _ThreadStartProc();

protected:
    DWORD   _dwThreadId;

private:
    void    _LockWorker(void);
    void    _UnlockWorker(void);

    LONG    _cRef;
    
    CRITICAL_SECTION _csWorker;
    DEBUG_CODE( LONG _cRefLockWorker; )
    
    LONG    _cItems;
    IWorkerEvent * _pwe;
    
    BITBOOL _fKillWorker: 1;
    HANDLE  _hthreadWorker;
    HWND    _hwndWorker;

    LRESULT _WorkerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    static DWORD CALLBACK _ThreadStartProcWrapper(LPVOID lpParam);
    static LRESULT CALLBACK _WorkerWndProcWrapper(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

};

// Window messages from worker thread that cause actions on the main thread
#define WORKERWIN_FIRE_ROW_READY          (WM_USER + 0x0101)  // wParam is row #
#define WORKERWIN_FIRE_FINISHED           (WM_USER + 0X0102)
#define WORKERWIN_FIRE_DATASETCHANGED     (WM_USER + 0X0103)
#endif //__WORKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_

#include <appmgmt.h>

STDAPI InstallAppFromFloppyOrCDROM(HWND hwnd);

DWORD ARPGetRestricted(LPCWSTR pszPolicy);
void ARPGetPolicyString(LPCWSTR pszPolicy, LPWSTR pszBuf, int cch);

STDAPI ARP(HWND hWnd, int nPage);
STDAPI OpenAppMgr(HWND hwnd, int nPage);

void ClearAppInfoData(APPINFODATA * pdata);
void ClearSlowAppInfo(SLOWAPPINFO * pdata);
void ClearPubAppInfo(PUBAPPINFO * pdata);
void ClearManagedApplication(MANAGEDAPPLICATION * pma);

HRESULT ReleaseShellCategoryList(SHELLAPPCATEGORYLIST * psacl);
HRESULT ReleaseShellCategory(SHELLAPPCATEGORY * psac);

// These values can be set in the FILETIME structure to indicate the
// app has never been used.
#define NOTUSED_HIGHDATETIME    0xFFFFFFFF
#define NOTUSED_LOWDATETIME     0xFFFFFFFF

LPTSTR WINAPI ShortSizeFormat64(__int64 dw64, LPTSTR szBuf);

#define ALD_ASSIGNED    0x00000001
#define ALD_EXPIRE      0x00000002
#define ALD_SCHEDULE    0x00000004

#ifndef DOWNLEVEL_PLATFORM
typedef struct tagAddLaterData
{
    DWORD dwMasks;
    SYSTEMTIME stAssigned;         // (in) assigned time 
    SYSTEMTIME stExpire;           // (in) expired time
    SYSTEMTIME stSchedule;         // (in/out) scheduled time 
} ADDLATERDATA, *PADDLATERDATA;

BOOL GetNewInstallTime(HWND hwndParent, PADDLATERDATA pal);
BOOL FormatSystemTimeString(LPSYSTEMTIME pst, LPTSTR pszStr, UINT cchStr);

#ifdef WINNT
EXTERN_C BOOL IsTerminalServicesRunning(void);
#endif // WINNT
#endif // DOWNLEVEL_PLATFORM

#define NUMSTARTPAGES 4

// Take an app key name or folder name and separate the number(version) from the name
void InsertSpaceBeforeVersion(LPCTSTR pszIn, LPTSTR pszOut);

// Is this path a valid folder location?
BOOL IsValidAppFolderLocation(LPCTSTR pszFolder);

BOOL PathIsLocalAndFixed(LPCTSTR pszFile);

BOOL IsSlowAppInfoChanged(PSLOWAPPINFO psaiOrig, PSLOWAPPINFO psaiNew);

// Comparison function for systemtimes
int CompareSystemTime(SYSTEMTIME *pst1, SYSTEMTIME *pst2);

void _ARPErrorMessageBox(DWORD dwError);

STDAPI _DuplicateCategoryList(APPCATEGORYINFOLIST * pacl, APPCATEGORYINFOLIST * paclNew);
STDAPI _DestroyCategoryList(APPCATEGORYINFOLIST * pacl);

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\nt4c\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\w95c\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\wnt4\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\winnt\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\win95\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\ntc\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\wshioctl.h ===
/*****************************************************************************
 *
 *  (C) Copyright MICROSOFT Corp., 1994, 1995
 *
 *  Title:      WSHOICTL.H - IOCTL interface for Wshell
 *
 *  Version:    4.00
 *
 *  Date:       30-Nov-1988
 *
 *  Author:     RAL
 *
 *----------------------------------------------------------------------------
 *
 *  Change log:
 *
 *     DATE     REV                 DESCRIPTION
 *  ----------- --- ----------------------------------------------------------
 *  01-Aug-1994 RAL Original
 *  05-Apr-1995 [stevecat] NT and Unicode port
 *
 *****************************************************************************/

#ifndef _WSHIOCTL_H
#define _WSHIOCTL_H


#define SHELLFILENAME TEXT("\\\\.\\SHELL")

//
// Flags for _SHELL_SuggestSingleMSDOSMode
//
// SSAMFLAG_KILLVM
//        A fatal application error has occurred.  Display a warning box
//        unconditionally.  Regardless of the answer, terminate the VM.
//        If this bit is set, the call does not return.
//
//  SSAMFLAG_TIMER
//        Not used.  Sorry.
//
//  SSAM_REQREALMODE
//        App requires *real* mode, not V86 mode, not EMM stuff, not
//        QEMM.  Just pure unadulterated real mode.  Also known as
//        SSAM_COMANCHE, because Comanche does an "lgdt" to enter
//        protected mode without checking if it is safe to do so.
//        This flag is inspected by AppWiz to decide how to set up
//        the config.sys and autoexec.bat.
//
//  SSAM_KILLUNLESSTOLD
//        Suggest Single MS-DOS mode (unless suppressed via PIF), and
//        if the answer is "Okay", then kill the VM.  If the user
//        says, "Keep running", then let it stay.
//
//  SSAM_FROMREGLIST
//        This app was run from a command prompt, triggered by registry
//        settings.  Just re-execute it in its own VM so that APPS.INF
//        settings will take effect.
//
//  SSAM_FAILEDAPI
//        This app just made an API call that was unsuccessful or
//        unsupported.  If the app terminates within 0.1 second,
//        then suggest single-app mode.  If the app continues
//        execution, then don't suggest.
//

#define SSAMFLAG_KILLVM         0x0000001
#define SSAMFLAG_TIMER          0x0000002
#define SSAMFLAG_REQREALMODE    0x0000004
#define SSAMFLAG_KILLUNLESSTOLD 0x0000008
#define SSAMFLAG_FROMREGLIST    0x0000010
#define SSAMFLAG_FAILEDAPI      0x0000020

//
//  IOCTL codes
//
#define WSHIOCTL_GETVERSION       0
#define WSHIOCTL_BLUESCREEN       1
#define WSHIOCTL_GET1APPINFO      2
#define WSHIOCTL_SIGNALSEM        3
#define WSHIOCTL_MAX              4        /* Remember, _MAX = _LIMIT + 1 */

//
//  Result codes
//
#define SSR_CONTINUE       0
#define SSR_CLOSEVM        1
#define SSR_KILLAPP        2

//
//  Sizes for strings
//
#define MAXVMTITLESIZE      32
#define MAXVMPROGSIZE       64
#define MAXVMCMDSIZE        64
#define MAXVMDIRSIZE        64
#define MAXPIFPATHSIZE      260

typedef struct _SINGLEAPPSTRUC {    /* shex */

        DWORD        SSA_dwFlags;
        DWORD        SSA_VMHandle;
        DWORD_PTR    SSA_ResultPtr;
        DWORD        SSA_Semaphore;
        TCHAR        SSA_PIFPath[MAXPIFPATHSIZE];
        TCHAR        SSA_VMTitle[MAXVMTITLESIZE];
        TCHAR        SSA_ProgName[MAXVMPROGSIZE];
        TCHAR        SSA_CommandLine[MAXVMCMDSIZE];
        TCHAR        SSA_CurDir[MAXVMCMDSIZE];

} SINGLEAPPSTRUC;

//
// Structures for WSHIOCTL_BLUESCREEN.
//
// lpvInBuffer must point to a BLUESCREENINFO structure.
// lpvOutBuffer must point to a DWORD which receives the message box result.
// The message box result is an IDXX value, as defined in windows.h.
//

/* H2INCSWITCHES -t */
typedef struct _BLUESCREENINFO {    /* bsi */

    TCHAR *pszText;         /* Message text (OEM character set) */
    TCHAR *pszTitle;        /* Message title (OEM character set) */
                            /* NULL means "Windows" */
    DWORD  flStyle;         /* Message box flags (see windows.h) */
                            /* Add'l flags defined in ddk\inc\shell.h */

} BLUESCREENINFO;
/* H2INCSWITCHES -t- */



#endif // _WSHIOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\appwzdui\winnt4\makefile.inc ===
!include $(CCSHELL_DIR)\cpls\appwzdui\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\common\deskcmmn.h ===
#ifndef _DESKCMMN_H
#define _DESKCMMN_H


//==========================================================================
//                              Guids
//==========================================================================

DEFINE_GUID(GUID_DISPLAY_ADAPTER_INTERFACE, 
            0x5b45201d, 
            0xf2f2, 0x4f3b, 
            0x85, 0xbb, 0x30, 0xff, 0x1f, 0x95, 0x35, 0x99);

#define SZ_DISPLAY_ADAPTER_INTERFACE_NAME TEXT("{5b45201d-f2f2-4f3b-85bb-30ff1f953599}")

//==========================================================================
//                              Macros
//==========================================================================

#define SZ_REGISTRYMACHINE  TEXT("\\REGISTRY\\MACHINE\\")
#define SZ_PRUNNING_MODE    TEXT("PruningMode")

#define SZ_GUID                TEXT("VideoID")
#define SZ_VIDEO_DEVICES       TEXT("System\\CurrentControlSet\\Control\\Video\\")
#define SZ_COMMON_SUBKEY       TEXT("\\Video")
#define SZ_SERVICES_PATH       TEXT("System\\CurrentControlSet\\Services\\")
#define SZ_SERVICE             TEXT("Service")

#define DCDSF_DYNA (0x0001)
#define DCDSF_ASK  (0x0002)

#define DCDSF_PROBABLY      (DCDSF_ASK  | DCDSF_DYNA)
#define DCDSF_PROBABLY_NOT  (DCDSF_ASK  |          0)
#define DCDSF_YES           (0          | DCDSF_DYNA)
#define DCDSF_NO            (0          |          0)


#define REGSTR_VAL_DYNASETTINGSCHANGE    TEXT("DynaSettingsChange")
#define SZ_UPGRADE_FROM_PLATFORM         TEXT("PlatformId")
#define SZ_UPGRADE_FROM_MAJOR_VERSION    TEXT("MajorVersion")
#define SZ_UPGRADE_FROM_MINOR_VERSION    TEXT("MinorVersion")
#define SZ_UPGRADE_FROM_BUILD_NUMBER     TEXT("BuildNumber")
#define SZ_UPGRADE_FROM_VERSION_DESC     TEXT("CSDVersion")
#define SZ_UPGRADE_FROM_PELS_WIDTH       TEXT("PelsWidth")
#define SZ_UPGRADE_FROM_PELS_HEIGHT      TEXT("PelsHeight")
#define SZ_UPGRADE_FROM_BITS_PER_PEL     TEXT("BPP")
#define SZ_UPGRADE_FROM_PLANES           TEXT("Planes")
#define SZ_UPGRADE_FROM_DISPLAY_FREQ     TEXT("VRefresh")
#define SZ_UPGRADE_FAILED_ALLOW_INSTALL  TEXT("FailedAllowInstall")
#define SZ_VIDEOMAP                      TEXT("HARDWARE\\DEVICEMAP\\VIDEO")
#define SZ_DEVICE                        TEXT("\\Device")
#define SZ_ENUM                          TEXT("Enum")

#define SZ_UPDATE_SETTINGS               TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\VideoUpgradeDisplaySettings")
#define SZ_UPDATE_SETTINGS_PATH          TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define SZ_UPDATE_SETTINGS_KEY           TEXT("VideoUpgradeDisplaySettings")

#define SZ_VU_COUNT                      TEXT("Count")
#define SZ_VU_PHYSICAL                   TEXT("Physical")
#define SZ_VU_LOGICAL                    TEXT("Logical")
#define SZ_VU_BUS_NUMBER                 TEXT("BusNumber")
#define SZ_VU_ADDRESS                    TEXT("Address")
#define SZ_VU_PREFERRED_MODE             TEXT("UsePreferredMode")
#define SZ_VU_ATTACHED_TO_DESKTOP        TEXT("Attach.ToDesktop")
#define SZ_VU_RELATIVE_X                 TEXT("Attach.RelativeX")
#define SZ_VU_RELATIVE_Y                 TEXT("Attach.RelativeY")
#define SZ_VU_BITS_PER_PEL               TEXT("DefaultSettings.BitsPerPel")
#define SZ_VU_X_RESOLUTION               TEXT("DefaultSettings.XResolution")
#define SZ_VU_Y_RESOLUTION               TEXT("DefaultSettings.YResolution")
#define SZ_VU_VREFRESH                   TEXT("DefaultSettings.VRefresh")
#define SZ_VU_FLAGS                      TEXT("DefaultSettings.Flags")

#define SZ_HW_ACCELERATION               TEXT("Acceleration.Level")


#define SZ_VOLATILE_SETTINGS             TEXT("VolatileSettings")

#define SZ_DETECT_DISPLAY                TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\DetectDisplay")
#define SZ_NEW_DISPLAY                   TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers\\NewDisplay")

#define SZ_SERVICES_TO_DISABLE           TEXT("ServicesToDisable")
#define SZ_APPEXT_TO_DELETE              TEXT("AppletExtensionsToDelete")

#define SZ_SHELLEX                       TEXT("shellex")

#define REGSTR_PATH_CONTROLSFOLDER_DISPLAY REGSTR_PATH_CONTROLSFOLDER TEXT("\\Display")
#define REGSTR_PATH_CONTROLSFOLDER_DISPLAY_SHEX_PROPSHEET REGSTR_PATH_CONTROLSFOLDER_DISPLAY TEXT("\\shellex\\PropertySheetHandlers")

#define REGSTR_PATH_CONTROLSFOLDER_DEVICE REGSTR_PATH_CONTROLSFOLDER TEXT("\\Device")
#define REGSTR_PATH_CONTROLSFOLDER_DEVICE_SHEX_PROPSHEET REGSTR_PATH_CONTROLSFOLDER_DEVICE TEXT("\\shellex\\PropertySheetHandlers")

//==========================================================================
//                              Functions
//==========================================================================

// LPTSTR SubStrEnd(LPTSTR pszTarget, LPTSTR pszScan )
//
// If pszScan starts with pszTarget, then the function returns the first
// char of pszScan that follows the pszTarget; other wise it returns pszScan.
//
// eg: SubStrEnd("abc", "abcdefg" ) ==> "defg"
//     SubStrEnd("abc", "abZQRT" ) ==> "abZQRT"
LPTSTR SubStrEnd(LPTSTR pszTarget, LPTSTR pszScan);


BOOL GetDeviceRegKey(LPCTSTR pstrDeviceKey, HKEY* phKey, BOOL* pbReadOnly);


int GetDisplayCPLPreference(LPCTSTR szRegVal);


int GetDynaCDSPreference();


void SetDisplayCPLPreference(LPCTSTR szRegVal, int val);


LONG WINAPI MyStrToLong(LPCTSTR sz);

BOOL 
AllocAndReadInterfaceName(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInterfaceName
    );

BOOL 
AllocAndReadInstanceID(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInstanceID
    );

BOOL 
AllocAndReadValue(
    IN  HKEY hkKey,
    IN  LPTSTR pValueName,
    OUT LPWSTR* ppwValueData
    );

typedef struct _APPEXT {
    TCHAR szKeyName[MAX_PATH];
    TCHAR szDefaultValue[MAX_PATH];
    struct _APPEXT* pNext;
} APPEXT, *PAPPEXT;

VOID
DeskAESnapshot(
    HKEY hkExtensions,
    PAPPEXT* ppAppExtList
    );

VOID
DeskAECleanup(
    PAPPEXT pAppExtList
    );


#endif // _DESKCMMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\common\deskcplext.h ===
#define DESKCPLEXT_DISPLAY_DEVICE       TEXT("Display Device")  // "\DisplayX"
#define DESKCPLEXT_DISPLAY_NAME         TEXT("Display Name")    // " ATI Mach64 Turbo 3 "
#define DESKCPLEXT_MONITOR_DEVICE       TEXT("Monitor Device")  // " \DisplayX\MonitorX "
#define DESKCPLEXT_MONITOR_NAME         TEXT("Monitor Name")    // " NEC Multi-sync II "
#define DESKCPLEXT_PRUNING_MODE         TEXT("Pruning Mode")    // 1 = on (default value), 0 = off

#define DESKCPLEXT_DISPLAY_DEVICE_KEY   TEXT("Display Key")     // "\REGISTRY\MACHINE\SYSTEM\ControlSet00X\Services\<driver>\DeviceY"
#define DESKCPLEXT_DISPLAY_ID           TEXT("Display ID")      // "ROOT\*PNP0F03\1-0-21-0-31-0"
#define DESKCPLEXT_DISPLAY_STATE_FLAGS  TEXT("Display State Flags")
#define DESKCPLEXT_MONITOR_ID           TEXT("Monitor ID")      // "ROOT\*PNP0F04\1-0-21-0-31-0"
#define DESKCPLEXT_INTERFACE            TEXT("Desk.cpl extension interface")

typedef
LPDEVMODEW
(*LPDESKCPLEXT_ENUM_ALL_MODES) (
    LPVOID pContext,
    DWORD iMode
    );

typedef
LPDEVMODEW
(*LPDESKCPLEXT_GET_SELECTED_MODE) (
    LPVOID pContext
    );

typedef
BOOL
(*LPDESKCPLEXT_SET_SELECTED_MODE) (
    LPVOID pContext,
    LPDEVMODEW lpdm
    );

typedef
VOID 
(*LPDESKCPLEXT_GET_PRUNING_MODE) (
    LPVOID pContext,
    BOOL*  pbCanBePruned,
    BOOL*  pbIsReadOnly,
    BOOL*  pbIsPruningOn
    );
    
typedef
VOID 
(*LPDESKCPLEXT_SET_PRUNING_MODE) (
    LPVOID pContext,
    BOOL   bIsPruningOn
    );


typedef struct _DISPLAY_REGISTRY_HARDWARE_INFO {

    WCHAR MemSize[128];
    WCHAR ChipType[128];
    WCHAR DACType[128];
    WCHAR AdapString[128];
    WCHAR BiosString[128];

} DISPLAY_REGISTRY_HARDWARE_INFO, *PDISPLAY_REGISTRY_HARDWARE_INFO;




typedef struct _DESK_EXTENSION_INTERFACE {

    DWORD   cbSize;
    LPVOID  pContext;

    LPDESKCPLEXT_ENUM_ALL_MODES    lpfnEnumAllModes;
    LPDESKCPLEXT_SET_SELECTED_MODE lpfnSetSelectedMode;
    LPDESKCPLEXT_GET_SELECTED_MODE lpfnGetSelectedMode;
    LPDESKCPLEXT_SET_PRUNING_MODE  lpfnSetPruningMode;
    LPDESKCPLEXT_GET_PRUNING_MODE  lpfnGetPruningMode;
    
    DISPLAY_REGISTRY_HARDWARE_INFO Info;

} DESK_EXTENSION_INTERFACE, *PDESK_EXTENSION_INTERFACE;

#define NORMAL_TIMEOUT  7000
#define SLOW_TIMEOUT   12000

typedef
int
(*LPDISPLAY_SAVE_SETTINGS)   (
    LPVOID pContext,
    HWND   hwnd
    );

typedef
DWORD
(*LPDISPLAY_TEST_SETTINGS) (
    LPDEVMODEW lpDevMode,
    LPWSTR     pwszDevice,
    DWORD      dwTimeout
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\common\deskcmmn.cpp ===
#include "deskcmmn.h"
#include <regstr.h>
#include <ccstock.h>


LPTSTR SubStrEnd(LPTSTR pszTarget, LPTSTR pszScan)
    {
    int i;
    for (i = 0; pszScan[i] != TEXT('\0') && pszTarget[i] != TEXT('\0') &&
            CharUpperChar(pszScan[i]) == CharUpperChar(pszTarget[i]); i++);

    if (pszTarget[i] == TEXT('\0'))
        {
        // we found the substring
        return pszScan + i;
        }

    return pszScan;
    }


BOOL GetDeviceRegKey(LPCTSTR pstrDeviceKey, HKEY* phKey, BOOL* pbReadOnly)
    {
    //ASSERT(lstrlen(pstrDeviceKey) < MAX_PATH);

    if(lstrlen(pstrDeviceKey) >= MAX_PATH)
        return FALSE;

    BOOL bRet = FALSE;

    // copy to local string
    TCHAR szBuffer[MAX_PATH];
    lstrcpy(szBuffer, pstrDeviceKey);

    //
    // At this point, szBuffer has something like:
    //  \REGISTRY\Machine\System\ControlSet001\Services\Jazzg300\Device0
    //
    // To use the Win32 registry calls, we have to strip off the \REGISTRY
    // and convert \Machine to HKEY_LOCAL_MACHINE
    //

    LPTSTR pszRegistryPath = SubStrEnd(SZ_REGISTRYMACHINE, szBuffer);

    if(pszRegistryPath)
        {
        // Open the registry key
        bRet = (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             pszRegistryPath,
                             0,
                             KEY_ALL_ACCESS,
                             phKey) == ERROR_SUCCESS);
        if(bRet)
            {
            *pbReadOnly = FALSE;
            }
        else
            {
            bRet = (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 pszRegistryPath,
                                 0,
                                 KEY_READ,
                                 phKey) == ERROR_SUCCESS);
            if (bRet)
                {
                *pbReadOnly = TRUE;
                }
            }
        }

    return bRet;
    }


int GetDisplayCPLPreference(LPCTSTR szRegVal)
{
    int val = -1;
    HKEY hk;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                     REGSTR_PATH_CONTROLSFOLDER_DISPLAY, 
                     0, 
                     KEY_READ, 
                     &hk) == ERROR_SUCCESS)
    {
        TCHAR sz[64];
        DWORD cb = sizeof(sz);

        *sz = 0;
        if ((RegQueryValueEx(hk, szRegVal, NULL, NULL,
            (LPBYTE)sz, &cb) == ERROR_SUCCESS) && *sz)
        {
            val = (int)MyStrToLong(sz);
        }

        RegCloseKey(hk);
    }

    if (val == -1 && RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                  REGSTR_PATH_CONTROLSFOLDER_DISPLAY, 
                                  0, 
                                  KEY_READ, 
                                  &hk) == ERROR_SUCCESS)
    {
        TCHAR sz[64];
        DWORD cb = sizeof(sz);

        *sz = 0;
        if ((RegQueryValueEx(hk, szRegVal, NULL, NULL,
            (LPBYTE)sz, &cb) == ERROR_SUCCESS) && *sz)
        {
            val = (int)MyStrToLong(sz);
        }

        RegCloseKey(hk);
    }

    return val;
}


int GetDynaCDSPreference()
{
//DLI: until we figure out if this command line stuff is still needed.
//    if (g_fCommandLineModeSet)
//        return DCDSF_YES;

    int iRegVal = GetDisplayCPLPreference(REGSTR_VAL_DYNASETTINGSCHANGE);
    if (iRegVal == -1)
        iRegVal = DCDSF_DYNA; // Apply dynamically
    return iRegVal;
}


void SetDisplayCPLPreference(LPCTSTR szRegVal, int val)
{
    HKEY hk;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, 
                       REGSTR_PATH_CONTROLSFOLDER_DISPLAY, 
                       0, 
                       TEXT(""), 
                       0, 
                       KEY_WRITE, 
                       NULL, 
                       &hk, 
                       NULL) == ERROR_SUCCESS)
    {
        TCHAR sz[64];

        wsprintf(sz, TEXT("%d"), val);
        RegSetValueEx(hk, szRegVal, NULL, REG_SZ,
            (LPBYTE)sz, lstrlen(sz) + 1);

        RegCloseKey(hk);
    }
}


LONG WINAPI MyStrToLong(LPCTSTR sz)
{
    long l=0;

    while (*sz >= TEXT('0') && *sz <= TEXT('9'))
        l = l*10 + (*sz++ - TEXT('0'));

    return l;
}


BOOL
AllocAndReadInterfaceName(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInterfaceName
    )

/*

    Note: If this function retuns success, the caller is responsible
          to free the memory pointed by *ppInterfaceName

*/

{
    BOOL bSuccess = FALSE;
    LPTSTR pszPath = NULL;
    HKEY hkDevice = 0;
    HKEY hkVolatileSettings = 0;

    //ASSERT (pDeviceKey != NULL);

    pszPath = SubStrEnd(SZ_REGISTRYMACHINE, pDeviceKey);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pszPath,
                     0,
                     KEY_READ,
                     &hkDevice) != ERROR_SUCCESS) {

        hkDevice = 0;
        goto Cleanup;
    }

    if (RegOpenKeyEx(hkDevice,
                     SZ_VOLATILE_SETTINGS,
                     0,
                     KEY_READ,
                     &hkVolatileSettings) != ERROR_SUCCESS) {

        hkVolatileSettings = 0;
        goto Cleanup;
    }

    bSuccess = AllocAndReadValue(hkVolatileSettings,
                                 SZ_DISPLAY_ADAPTER_INTERFACE_NAME,
                                 ppInterfaceName);

Cleanup:

    if (hkVolatileSettings) {
        RegCloseKey(hkVolatileSettings);
    }

    if (hkDevice) {
        RegCloseKey(hkDevice);
    }

    return bSuccess;
}


BOOL
AllocAndReadInstanceID(
    IN  LPTSTR pDeviceKey,
    OUT LPWSTR* ppInstanceID
    )

/*

    Note: If this function retuns success, the caller is responsible
          to free the memory pointed by *ppInstanceID

*/

{
    LPTSTR pDeviceKeyCopy = NULL, pDeviceKeyCopy2 = NULL;
    LPTSTR pTemp = NULL, pX = NULL;
    BOOL bSuccess = FALSE;
    HKEY hkEnum = 0;
    HKEY hkService = 0;
    HKEY hkCommon = 0;
    DWORD Count = 0;
    DWORD cb = 0, len = 0;

    //ASSERT (pDeviceKey != NULL);

    //
    // Make a copy of pDeviceKey
    //

    len = max (256, (lstrlen(pDeviceKey) + 6) * sizeof(TCHAR));
    pDeviceKeyCopy2 = pDeviceKeyCopy = (LPTSTR)LocalAlloc(LPTR, len);

    if (pDeviceKeyCopy == NULL) {
        goto Cleanup;
    }

    lstrcpy(pDeviceKeyCopy, pDeviceKey);
    pTemp = SubStrEnd(SZ_REGISTRYMACHINE, pDeviceKeyCopy);
    pDeviceKeyCopy = pTemp;

    //
    // Open the service key
    //

    pTemp = pDeviceKeyCopy + lstrlen(pDeviceKeyCopy);

    while ((pTemp != pDeviceKeyCopy) && (*pTemp != TEXT('\\'))) {
        pTemp--;
    }

    if (pTemp == pDeviceKeyCopy) {
        goto Cleanup;
    }

    pX = SubStrEnd(SZ_DEVICE, pTemp);

    if (pX == pTemp) {

        //
        // The new key is used: CCS\Control\Video\[GUID]\000X
        //

        *pTemp = UNICODE_NULL;

        lstrcat(pDeviceKeyCopy, SZ_COMMON_SUBKEY);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         pDeviceKeyCopy,
                         0,
                         KEY_READ,
                         &hkCommon) != ERROR_SUCCESS) {
            
            hkCommon = 0;
            goto Cleanup;
        }
    
        pDeviceKeyCopy = pDeviceKeyCopy2;

        ZeroMemory(pDeviceKeyCopy, len);
        
        lstrcpy(pDeviceKeyCopy, SZ_SERVICES_PATH);

        cb = len - (lstrlen(pDeviceKeyCopy) + 1) * sizeof(TCHAR);

        if (RegQueryValueEx(hkCommon,
                            SZ_SERVICE,
                            NULL,
                            NULL,
                            (LPBYTE)(pDeviceKeyCopy + lstrlen(pDeviceKeyCopy)),
                            &cb) != ERROR_SUCCESS) {
            
            goto Cleanup;
        }

    } else {

        //
        // The old key is used: CCS\Services\[SrvName]\DeviceX
        //

        *pTemp = UNICODE_NULL;
    }

    //
    // Open the ServiceName key
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pDeviceKeyCopy,
                     0,
                     KEY_READ,
                     &hkService) != ERROR_SUCCESS) {

        hkService = 0;
        goto Cleanup;
    }
    
    //
    // Open the "Enum" key under the devicename
    //

    if (RegOpenKeyEx(hkService,
                     SZ_ENUM,
                     0,
                     KEY_READ,
                     &hkEnum) != ERROR_SUCCESS) {
        hkEnum = 0;
        goto Cleanup;
    }

    cb = sizeof(Count);
    if ((RegQueryValueEx(hkEnum,
                         SZ_VU_COUNT,
                         NULL,
                         NULL,
                         (LPBYTE)&Count,
                         &cb) != ERROR_SUCCESS) ||
        (Count != 1)) {

        //
        // Igonore the case when there are at least 2 devices.
        //

        goto Cleanup;
    }

    bSuccess = AllocAndReadValue(hkEnum, TEXT("0"), ppInstanceID);

Cleanup:

    if (hkEnum != 0) {
        RegCloseKey(hkEnum);
    }

    if (hkService != 0) {
        RegCloseKey(hkService);
    }

    if (hkCommon != 0) {
        RegCloseKey(hkCommon);
    }
    
    if (pDeviceKeyCopy2 != NULL) {
        LocalFree(pDeviceKeyCopy2);
    }

    return bSuccess;
}


BOOL
AllocAndReadValue(
    IN  HKEY hkKey,
    IN  LPTSTR pValueName,
    OUT LPWSTR* ppwValueData
    )

/*

    Note: If this function retuns success, the caller is responsible
          to free the memory pointed by *ppwValueData

*/

{
    LPWSTR pwValueData = NULL;
    DWORD AllocUnit = 64;
    DWORD cBytes = 0;
    BOOL bSuccess = FALSE;
    LONG Error = ERROR_SUCCESS;

    while (!bSuccess) {

        AllocUnit *= 2;
        cBytes = AllocUnit * sizeof(WCHAR);

        pwValueData = (LPWSTR)(LocalAlloc(LPTR, cBytes));
        if (pwValueData == NULL)
            break;

        Error = RegQueryValueEx(hkKey,
                                pValueName,
                                NULL,
                                NULL,
                                (LPBYTE)pwValueData,
                                &cBytes);

        bSuccess = (Error == ERROR_SUCCESS);

        if (!bSuccess) {

            LocalFree(pwValueData);
            pwValueData = NULL;

            if (Error != ERROR_MORE_DATA)
                break;
        }
    }

    if (bSuccess) {
        *ppwValueData = pwValueData;
    }

    return bSuccess;
}


VOID
DeskAESnapshot(
    HKEY hkExtensions,
    PAPPEXT* ppAppExtList
    )
{
    HKEY hkSubkey = 0;
    DWORD index = 0;
    DWORD ulSize = MAX_PATH;
    APPEXT AppExtTemp;
    PAPPEXT pAppExtBefore = NULL;
    PAPPEXT pAppExtTemp = NULL;

    ulSize = sizeof(AppExtTemp.szKeyName) / sizeof(TCHAR);
    while (RegEnumKeyEx(hkExtensions, 
                        index, 
                        AppExtTemp.szKeyName, 
                        &ulSize, 
                        NULL, 
                        NULL, 
                        NULL, 
                        NULL) == ERROR_SUCCESS) {

            if (RegOpenKeyEx(hkExtensions,
                             AppExtTemp.szKeyName,
                             0,
                             KEY_READ,
                             &hkSubkey) == ERROR_SUCCESS) {

                ulSize = sizeof(AppExtTemp.szDefaultValue);
                if ((RegQueryValueEx(hkSubkey,
                                     NULL,
                                     0,
                                     NULL,
                                     (PBYTE)AppExtTemp.szDefaultValue,
                                     &ulSize) == ERROR_SUCCESS) && 
                    (AppExtTemp.szDefaultValue[0] != TEXT('\0'))) {

                    PAPPEXT pAppExt = (PAPPEXT)LocalAlloc(LPTR, sizeof(APPEXT));
                    
                    if (pAppExt != NULL) {

                        *pAppExt = AppExtTemp;

                        pAppExtBefore = pAppExtTemp = *ppAppExtList;
                        
                        while((pAppExtTemp != NULL) &&
                              (lstrcmpi(pAppExtTemp->szDefaultValue,
                                        pAppExt->szDefaultValue) < 0)) {

                            pAppExtBefore = pAppExtTemp;
                            pAppExtTemp = pAppExtTemp->pNext;
                        }

                        if (pAppExtBefore != pAppExtTemp) {
                        
                            pAppExt->pNext = pAppExtBefore->pNext;
                            pAppExtBefore->pNext = pAppExt;

                        } else {

                            pAppExt->pNext = *ppAppExtList;
                            *ppAppExtList = pAppExt;
                        }
                    }
                }

                RegCloseKey(hkSubkey);
            }

        ulSize = sizeof(AppExtTemp.szKeyName) / sizeof(TCHAR);
        index++;
    }
}


VOID
DeskAECleanup(
    PAPPEXT pAppExt
    )
{
    PAPPEXT pAppExtTemp;

    while (pAppExt) {
        pAppExtTemp = pAppExt->pNext;
        LocalFree(pAppExt);
        pAppExt = pAppExtTemp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskadp\deskadp.h ===
/******************************************************************************

  Source File:  deskadp.h

  General include file

  Copyright (c) 1997-1998 by Microsoft Corporation

  Change History:

  12-01-97 AndreVa - Created It

******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shsemip.h>
#include <stdlib.h>
#include <shlobjp.h>
#include <shellp.h>
//#include <commctrl.h>
#include <string.h>

#include <initguid.h>
#include <help.h>
#include "..\..\common\deskcplext.h"
#include "..\..\common\propsext.h"
#include "resource.h"

typedef struct _NEW_DESKTOP_PARAM {
    LPDEVMODEW lpdevmode;
    LPWSTR pwszDevice;
} NEW_DESKTOP_PARAM, *PNEW_DESKTOP_PARAM;




VOID DrawBmp(HDC hDC);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\common\propsext.h ===
//---------------------------------------------------------------------------
//
//  File: propsext.h
//
//  General definition of OLE Entry points, CClassFactory and CPropSheetExt
//
//  Common Code for all display property sheet extension
//
//  Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
//
//---------------------------------------------------------------------------

#ifndef _COMMONPROPEXT_H
#define _COMMONPROPEXT_H


extern BOOL         g_RunningOnNT;
extern HINSTANCE    g_hInst;
extern LPDATAOBJECT g_lpdoTarget;

// OLE-Registry magic number
extern GUID         g_CLSID_CplExt;

// Someone made a spelling mistake
#define PropertySheeDlgProc         PropertySheetDlgProc

INT_PTR CALLBACK PropertySheetDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
UINT CALLBACK PropertySheetCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

  
//Type for an object-destroyed callback
typedef void (FAR PASCAL *LPFNDESTROYED)(void);


class CClassFactory : public IClassFactory
{
protected:
        ULONG m_cRef;

public:
        CClassFactory();
        ~CClassFactory();

        //IUnknown members
        STDMETHODIMP         QueryInterface( REFIID, LPVOID* );
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        //IClassFactory members
        STDMETHODIMP         CreateInstance( LPUNKNOWN, REFIID, LPVOID* );
        STDMETHODIMP         LockServer( BOOL );
};


class CPropSheetExt : public IShellPropSheetExt, IShellExtInit
{
private:
        ULONG         m_cRef;
        LPUNKNOWN     m_pUnkOuter;    //Controlling unknown
        LPFNDESTROYED m_pfnDestroy;   //Function closure call

public:
        CPropSheetExt( LPUNKNOWN pUnkOuter, LPFNDESTROYED pfnDestroy );
        ~CPropSheetExt(void);

        // IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //  IShellExtInit methods
        STDMETHODIMP         Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj,
                                        HKEY hKeyID);

        //IShellPropSheetExt methods ***
        STDMETHODIMP         AddPages( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
        STDMETHODIMP         ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                         LPARAM lParam);
};



#endif // _COMMONPROPEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\common\propsext.cpp ===
//--------------------------------------------------------------------------------
//
//  File:   propsext.cpp
//
//  General handling of OLE Entry points, CClassFactory and CPropSheetExt
//
//  Common Code for all display property sheet extension
//
//  Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
//
//--------------------------------------------------------------------------------

#include "shfusion.h"

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//
// Count number of objects and number of locks.
//
HINSTANCE    g_hInst = NULL;
BOOL         g_RunningOnNT = FALSE;
LPDATAOBJECT g_lpdoTarget = NULL;

ULONG        g_cObj = 0;
ULONG        g_cLock = 0;



//---------------------------------------------------------------------------
// DllMain()
//---------------------------------------------------------------------------
int APIENTRY DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID )
{
    if (dwReason == DLL_PROCESS_ATTACH)        // Initializing
    {
        if ((int)GetVersion() >= 0)
        {
            g_RunningOnNT = TRUE;
        }

        g_hInst = hInstance;

        DisableThreadLibraryCalls(hInstance);
        SHFusionInitializeFromModuleID(hInstance, 124);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        SHFusionUninitialize();
    }

    return 1;
}
//---------------------------------------------------------------------------
//      DllGetClassObject()
//
//      If someone calls with our CLSID, create an IClassFactory and pass it to
//      them, so they can create and use one of our CPropSheetExt objects.
//
//---------------------------------------------------------------------------
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID* ppvOut )
{
    *ppvOut = NULL; // Assume Failure
    if( IsEqualCLSID( rclsid, g_CLSID_CplExt ) )
    {
        //
        //Check that we can provide the interface
        //
        if( IsEqualIID( riid, IID_IUnknown) ||
            IsEqualIID( riid, IID_IClassFactory )
           )
        {
            //Return our IClassFactory for CPropSheetExt objects
            *ppvOut = (LPVOID* )new CClassFactory();
            if( NULL != *ppvOut )
            {
                //AddRef the object through any interface we return
                ((CClassFactory*)*ppvOut)->AddRef();
                return NOERROR;
            }
            return E_OUTOFMEMORY;
        }
        return E_NOINTERFACE;
    }
    else
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }
}

//---------------------------------------------------------------------------
//      DllCanUnloadNow()
//
//      If we are not locked, and no objects are active, then we can exit.
//
//---------------------------------------------------------------------------
STDAPI DllCanUnloadNow()
{
    SCODE   sc;

    //
    //Our answer is whether there are any object or locks
    //
    sc = (0L == g_cObj && 0 == g_cLock) ? S_OK : S_FALSE;

    return ResultFromScode(sc);
}

//---------------------------------------------------------------------------
//      ObjectDestroyed()
//
//      Function for the CPropSheetExt object to call when it is destroyed.
//      Because we're in a DLL, we only track the number of objects here,
//      letting DllCanUnloadNow take care of the rest.
//---------------------------------------------------------------------------
void FAR PASCAL ObjectDestroyed( void )
{
    g_cObj--;
    return;
}

UINT CALLBACK PropertySheetCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    switch (uMsg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        if (g_lpdoTarget) {
            g_lpdoTarget->Release();
            g_lpdoTarget = NULL;
        }
        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}



//***************************************************************************
//
//  CClassFactory Class
//
//***************************************************************************



//---------------------------------------------------------------------------
//      Constructor
//---------------------------------------------------------------------------
CClassFactory::CClassFactory()
{
    m_cRef = 0L;
    return;
}

//---------------------------------------------------------------------------
//      Destructor
//---------------------------------------------------------------------------
CClassFactory::~CClassFactory( void )
{
    return;
}

//---------------------------------------------------------------------------
//      QueryInterface()
//---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface( REFIID riid, LPVOID* ppv )
{
    *ppv = NULL;

    //Any interface on this object is the object pointer.
    if( IsEqualIID( riid, IID_IUnknown ) ||
        IsEqualIID( riid, IID_IClassFactory )
       )
    {
        *ppv = (LPVOID)this;
        ++m_cRef;
        return NOERROR;
    }

    return E_NOINTERFACE;
}

//---------------------------------------------------------------------------
//      AddRef()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return ++m_cRef;
}

//---------------------------------------------------------------------------
//      Release()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    ULONG cRefT;

    cRefT = --m_cRef;

    if( 0L == m_cRef ) 
        delete this;

    return cRefT;
}


// Allow the caller to specify another class to use.  The only requirement
// is that there be a contructore with (punk, void FAR PASCAL pfnObjDes(void) )
#ifndef PROPSHEET_CLASS
#define PROPSHEET_CLASS             CPropSheetExt
#endif // PROPSHEET_CLASS

//---------------------------------------------------------------------------
//      CreateInstance()
//---------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::CreateInstance( LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR *ppvObj
                              )
{
    CPropSheetExt*  pObj;
    HRESULT         hr = E_OUTOFMEMORY;

    *ppvObj = NULL;

    // We don't support aggregation at all.
    if( pUnkOuter )
    {
        return CLASS_E_NOAGGREGATION;
    }

    //Verify that a controlling unknown asks for IShellPropSheetExt
    if( IsEqualIID( riid, IID_IShellPropSheetExt ) )
    {
        //Create the object, passing function to notify on destruction
        pObj = new PROPSHEET_CLASS(pUnkOuter, ObjectDestroyed);

        if( NULL == pObj )
        {
            return hr;
        }

        hr = pObj->QueryInterface( riid, ppvObj );

        //Kill the object if initial creation or FInit failed.
        if( FAILED(hr) )
        {
            delete pObj;
        }
        else
        {
            g_cObj++;
        }
        return hr;
    }

    return E_NOINTERFACE;
}

//---------------------------------------------------------------------------
//      LockServer()
//---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer( BOOL fLock )
{
    if( fLock )
    {
        g_cLock++;
    }
    else
    {
        g_cLock--;
    }
    return NOERROR;
}



//***************************************************************************
//
//  CPropSheetExt Class
//
//***************************************************************************



//---------------------------------------------------------------------------
//  Constructor
//---------------------------------------------------------------------------
CPropSheetExt::CPropSheetExt( LPUNKNOWN pUnkOuter, LPFNDESTROYED pfnDestroy )
{
    m_cRef = 0;
    m_pUnkOuter = pUnkOuter;
    m_pfnDestroy = pfnDestroy;
    return;
}

//---------------------------------------------------------------------------
//  Destructor
//---------------------------------------------------------------------------
CPropSheetExt::~CPropSheetExt( void )
{
    return;
}

//---------------------------------------------------------------------------
//  QueryInterface()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::QueryInterface( REFIID riid, LPVOID* ppv )
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellExtInit))
    {
        *ppv = (IShellExtInit *) this;
    }

    if (IsEqualIID(riid, IID_IShellPropSheetExt))
    {
        *ppv = (LPVOID)this;
    }

    if (*ppv)
    {
        ++m_cRef;
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

//---------------------------------------------------------------------------
//  AddRef()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropSheetExt::AddRef( void )
{
    return ++m_cRef;
}

//---------------------------------------------------------------------------
//  Release()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropSheetExt::Release( void )
{
ULONG cRefT;

    cRefT = --m_cRef;

    if( m_cRef == 0 )
    {
        // Tell the housing that an object is going away so that it
        // can shut down if appropriate.
        if( NULL != m_pfnDestroy )
        {
            (*m_pfnDestroy)();
        }
        delete this;
    }
    return cRefT;
}

//---------------------------------------------------------------------------
//  AddPages()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam )
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;
    TCHAR szTitle[ 30 ];

    LoadString( g_hInst, IDS_PAGE_TITLE, szTitle, ARRAYSIZE(szTitle) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE | PSP_USECALLBACK;
    psp.hIcon = NULL;
    psp.hInstance = g_hInst;
    psp.pszTemplate =MAKEINTRESOURCE( PROP_SHEET_DLG );
    psp.pfnDlgProc = PropertySheetDlgProc;
    psp.pfnCallback = PropertySheetCallback;
    psp.pszTitle = szTitle;
    psp.lParam = 0;

#ifdef USESLINKCONTROL
    LinkWindow_RegisterClass();
#endif
    
    if( ( hpage = CreatePropertySheetPage( &psp ) ) == NULL )
    {
        return ( E_OUTOFMEMORY );
    }

    if( !lpfnAddPage(hpage, lParam ) )
    {
        DestroyPropertySheetPage(hpage );
        return ( E_FAIL );
    }
    return NOERROR;
}

//---------------------------------------------------------------------------
//  ReplacePage()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam )
{
    return NOERROR;
}


//---------------------------------------------------------------------------
//  IShellExtInit member function- this interface needs only one
//---------------------------------------------------------------------------

STDMETHODIMP CPropSheetExt::Initialize(LPCITEMIDLIST pcidlFolder,
                                       LPDATAOBJECT pdoTarget,
                                       HKEY hKeyID)
{
    //  The target data object is an HDROP, or list of files from the shell.
    if (g_lpdoTarget)
    {
        g_lpdoTarget->Release();
        g_lpdoTarget = NULL;
    }

    if (pdoTarget)
    {
        g_lpdoTarget = pdoTarget;
        g_lpdoTarget->AddRef();
    }

    return  NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskadp\propsext.cpp ===
#include "deskadp.h"

#include "..\..\common\propsext.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskadp\resource.h ===
/******************************************************************************

  Source File:  Resource.H

  Resource Identifier Definitions for deskctop adapter information

  Copyright (c) 1998 by Microsoft Corporation


******************************************************************************/

// Icon

#define IDI_ADAPTER           100

// Property sheet

#define PROP_SHEET_DLG        200
#define ID_ADP_ADPGRP         201
#define ID_ADP_ADAPTOR        202
#define ID_ADP_ADPINFGRP      203
#define ID_ADP_CHIP           204
#define ID_ADP_DAC            205
#define ID_ADP_MEM            206
#define ID_ADP_ADP_STRING     207
#define ID_ADP_BIOS_INFO      208
#define ID_ADP_AI1            209
#define ID_ADP_AI2            210
#define ID_ADP_AI3            211
#define ID_ADP_AI4            212
#define ID_ADP_AI5            213
#define IDC_TEST_MODE         214
#define IDC_LIST_ALL          215
#define IDC_PROPERTIES        216

#define DLG_SET_MODE_LIST     800
#define ID_MODE_LISTGRP       801
#define ID_MODE_LIST          802

// test bitmap

#define IDS_PAGE_TITLE         1
#define IDS_TEST_BITMAP        10
#define IDS_COLOR_RED          11
#define IDS_COLOR_GREEN        12
#define IDS_COLOR_BLUE         13
#define IDS_COLOR_YELLOW       14
#define IDS_COLOR_MAGENTA      15
#define IDS_COLOR_CYAN         16
#define IDS_COLOR_WHITE        17
#define IDS_PATTERN_VERT       18
#define IDS_PATTERN_HORZ       19
#define IDS_RED_SHADES         20
#define IDS_GREEN_SHADES       21
#define IDS_BLUE_SHADES        22
#define IDS_RESOLUTION_FMT     23
#define IDS_UNAVAILABLE        24
#define IDS_GRAY_SHADES        25

#define IDS_TEST_WARNING       30
#define IDS_TEST_MODE          31
#define IDS_TEST_RESULT        32
#define IDS_TEST_FAILED        33

#define IDS_MODE_4BIT_COLOR    40
#define IDS_MODE_8BIT_COLOR    41
#define IDS_MODE_15BIT_COLOR   42
#define IDS_MODE_16BIT_COLOR   43
#define IDS_MODE_TRUECOLOR24   44
#define IDS_MODE_TRUECOLOR32   45
#define IDS_MODE_REFRESH_DEF   46
#define IDS_MODE_REFRESH_INT   47
#define IDS_MODE_REFRESH_HZ    48
#define IDS_BAD_COLOR          49
#define IDS_BAD_REFRESH        50
#define IDS_MODE_UNSETTABLE    51

// help ids
#define IDH_NOHELP                                          ((DWORD)-1)
#define IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_TYPE  4160
#define IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO  4161
#define IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_LIST_MODES    4162    
#define IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_PROPERTIES    4164

#define IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_LISTMODE_DIALOGBOX  4163
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskadp\deskadp.cpp ===
/******************************************************************************

  Source File:  deskadp.cpp

  Main code for the advanced desktop adapter page

  Copyright (c) 1997-1998 by Microsoft Corporation

  Change History:

  12-16-97 AndreVa - Created It

******************************************************************************/


#include    "deskadp.h"
#define DECL_CRTFREE
#include <crtfree.h>
#include "shfusion.h"

DWORD ApplyNowThd(LPVOID lpThreadParameter);

//
// The function DevicePropertiesW() is implemented in DevMgr.dll; Since we don't have a devmgr.h, we
// explicitly declare it here.
//
typedef int (WINAPI  *DEVPROPERTIESW)(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceID,
    BOOL ShowDeviceTree
    );

// OLE-Registry magic number
// 42071712-76d4-11d1-8b24-00a0c9068ff3
//
GUID g_CLSID_CplExt = { 0x42071712, 0x76d4, 0x11d1,
                        { 0x8b, 0x24, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3}
                      };

DESK_EXTENSION_INTERFACE DeskInterface;

static const DWORD sc_AdapterHelpIds[] =
{
    ID_ADP_ADPINFGRP,  IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_AI1,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_AI2,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_AI3,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_AI4,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_AI5,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_CHIP,       IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_DAC,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_MEM,        IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_ADP_STRING, IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,
    ID_ADP_BIOS_INFO,  IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_INFO,

    ID_ADP_ADPGRP,     IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_TYPE,
    IDI_ADAPTER,       IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_TYPE,
    ID_ADP_ADAPTOR,    IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_ADAPTER_TYPE,

    IDC_LIST_ALL,      IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_LIST_MODES,
    IDC_PROPERTIES,    IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_PROPERTIES,

    0, 0
};

static const DWORD sc_ListAllHelpIds[] = 
{
    ID_MODE_LIST,    IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_LISTMODE_DIALOGBOX,
    ID_MODE_LISTGRP, IDH_DISPLAY_SETTINGS_ADVANCED_ADAPTER_LISTMODE_DIALOGBOX,

    0, 0
};


///////////////////////////////////////////////////////////////////////////////
//
// Messagebox wrapper
//
///////////////////////////////////////////////////////////////////////////////


int
FmtMessageBox(
    HWND hwnd,
    UINT fuStyle,
    DWORD dwTitleID,
    DWORD dwTextID)
{
    TCHAR Title[256];
    TCHAR Text[1500];

    LoadString(g_hInst, dwTextID, Text, ARRAYSIZE(Text));
    LoadString(g_hInst, dwTitleID, Title, ARRAYSIZE(Title));

    return (MessageBox(hwnd, Text, Title, fuStyle));
}



///////////////////////////////////////////////////////////////////////////////
//
// Main dialog box Windows Proc
//
///////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
ListAllModesProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPDEVMODEW lpdm, lpdmCur; 
    HWND hList;
    DWORD i;
    LRESULT item;

    switch (uMessage)
    {
    case WM_INITDIALOG:

        //
        // Save the lParam - we will store the new mode here
        //
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        lpdmCur = *((LPDEVMODEW *)lParam);
        Assert (lpdmCur != NULL);

        //
        // Build the list of modes to display
        //
        i = 0;
        hList = GetDlgItem(hDlg, ID_MODE_LIST); 
        while (lpdm = DeskInterface.lpfnEnumAllModes(DeskInterface.pContext, i))
        {
            TCHAR  achFreData[50];
            TCHAR  achFre[50];
            TCHAR  achStr[80];
            TCHAR  achText[120];
            DWORD  idColor;
            DWORD  idFreq;

            //
            // convert bit count to number of colors and make it a string
            //

            switch (lpdm->dmBitsPerPel)
            {
            case 32: idColor = IDS_MODE_TRUECOLOR32; break;
            case 24: idColor = IDS_MODE_TRUECOLOR24; break;
            case 16: idColor = IDS_MODE_16BIT_COLOR; break;
            case 15: idColor = IDS_MODE_15BIT_COLOR; break;
            case  8: idColor = IDS_MODE_8BIT_COLOR; break;
            case  4: idColor = IDS_MODE_4BIT_COLOR; break;
            default:
                FmtMessageBox(hDlg,
                              MB_OK | MB_ICONINFORMATION,
                              IDS_BAD_COLOR,
                              IDS_BAD_COLOR);

                EndDialog(hDlg, -1);
                break;
            }

            if (lpdm->dmDisplayFrequency == 0)
            {
                FmtMessageBox(hDlg,
                              MB_OK | MB_ICONINFORMATION,
                              IDS_BAD_REFRESH,
                              IDS_BAD_REFRESH);

                EndDialog(hDlg, -1);
                break;
            }
            else if (lpdm->dmDisplayFrequency == 1)
            {
                LoadString(g_hInst, IDS_MODE_REFRESH_DEF, achFre, ARRAYSIZE(achFre));
            }
            else
            {
                if (lpdm->dmDisplayFrequency <= 50)
                    idFreq = IDS_MODE_REFRESH_INT;
                else
                    idFreq = IDS_MODE_REFRESH_HZ;

                LoadString(g_hInst, idFreq, achFreData, ARRAYSIZE(achFreData));
                wsprintf(achFre, achFreData, lpdm->dmDisplayFrequency);
            }

            LoadString(g_hInst, idColor, achStr, ARRAYSIZE(achStr));
            wsprintf(achText, achStr, lpdm->dmPelsWidth, lpdm->dmPelsHeight, achFre);

            item = ListBox_AddString(hList, achText);
            if (lpdm == lpdmCur) 
                ListBox_SetCurSel(hList, item);
            ListBox_SetItemData(hList, item, lpdm);

            i++;
        }

        //
        // If no modes are available, put up a popup and exit.
        //

        if (i == 0)
        {
            EndDialog(hDlg, -1);
        }


        break;

    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case ID_MODE_LIST:

            if (HIWORD(wParam) != LBN_DBLCLK)
            {
                return FALSE;
            }

            //
            // fall through, as DBLCLK means select.
            //

        case IDOK:

            //
            // Save the mode back
            //

            item = SendDlgItemMessage(hDlg, ID_MODE_LIST, LB_GETCURSEL, 0, 0);

            if ((item != LB_ERR) &&
                (lpdm = (LPDEVMODEW) SendDlgItemMessage(hDlg, ID_MODE_LIST, LB_GETITEMDATA, item, 0)))
            {
                *((LPDEVMODEW *)GetWindowLongPtr(hDlg, DWLP_USER)) = lpdm;
                EndDialog(hDlg, TRUE);
                break;
            }

            //
            // fall through
            //

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        default:

            return FALSE;
        }

        break;

    case WM_HELP:

        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                TEXT("display.hlp"),
                HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)sc_ListAllHelpIds);

        break;

    case WM_CONTEXTMENU:

        WinHelp((HWND)wParam,
                TEXT("display.hlp"),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR)sc_ListAllHelpIds);

        break;

    default:

        return FALSE;
    }

    return TRUE;

}

void Adaptor_OnApply(HWND hDlg)
{
    HINSTANCE               hInst;
    LPDISPLAY_SAVE_SETTINGS lpfnDisplaySaveSettings = NULL;
    long                    lRet = PSNRET_INVALID_NOCHANGEPAGE;

    hInst = LoadLibrary(TEXT("desk.cpl"));
    if (hInst)
    {
        lpfnDisplaySaveSettings = (LPDISPLAY_SAVE_SETTINGS)
                                  GetProcAddress(hInst, "DisplaySaveSettings");
        if (lpfnDisplaySaveSettings)
        {
            LONG lSave = lpfnDisplaySaveSettings(DeskInterface.pContext, hDlg);
            if (lSave == DISP_CHANGE_SUCCESSFUL)
            {
                //
                // Save the current mode - to restore it in case the user cancels the p. sheet
                //
                LPDEVMODEW lpdmOnCancel = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
                SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lpdmOnCancel);
                lRet = PSNRET_NOERROR;
            }
            else if (lSave == DISP_CHANGE_RESTART)
            {
                //
                // User wants to reboot system.
                //
                PropSheet_RestartWindows(GetParent(hDlg));
                lRet = PSNRET_NOERROR;
            }
        }

        FreeLibrary(hInst);
    }

    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lRet);
}

void Adaptor_OnInitDialog(HWND hDlg)
{
    Assert (DeskInterface.cbSize == 0);

    //
    // Get the CPL extension interfaces from IDataObject.
    //
    FORMATETC fmte = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_INTERFACE),
                      (DVTARGETDEVICE FAR *) NULL,
                      DVASPECT_CONTENT,
                      -1,
                      TYMED_HGLOBAL};

    STGMEDIUM stgm;

    HRESULT hres = g_lpdoTarget->GetData(&fmte, &stgm);

    if (SUCCEEDED(hres) && stgm.hGlobal)
    {
        //
        // The storage now contains Display device path (\\.\DisplayX) in UNICODE.
        //

        PDESK_EXTENSION_INTERFACE pInterface =
            (PDESK_EXTENSION_INTERFACE) GlobalLock(stgm.hGlobal);

        if (pInterface != NULL)
        {
            RtlCopyMemory(&DeskInterface,
                          pInterface,
                          min(pInterface->cbSize,
                              sizeof(DESK_EXTENSION_INTERFACE)));
    
            GlobalUnlock(stgm.hGlobal);
            
            SendDlgItemMessageW(hDlg, ID_ADP_CHIP,       WM_SETTEXT, 0, (LPARAM)&(DeskInterface.Info.ChipType[0]));
            SendDlgItemMessageW(hDlg, ID_ADP_DAC,        WM_SETTEXT, 0, (LPARAM)&(DeskInterface.Info.DACType[0]));
            SendDlgItemMessageW(hDlg, ID_ADP_MEM,        WM_SETTEXT, 0, (LPARAM)&(DeskInterface.Info.MemSize[0]));
            SendDlgItemMessageW(hDlg, ID_ADP_ADP_STRING, WM_SETTEXT, 0, (LPARAM)&(DeskInterface.Info.AdapString[0]));
            SendDlgItemMessageW(hDlg, ID_ADP_BIOS_INFO,  WM_SETTEXT, 0, (LPARAM)&(DeskInterface.Info.BiosString[0]));
        
            //
            // Save the initial selected mode - to restore it in case the user cancels the p. sheet
            //

            LPDEVMODEW lpdmOnCancel = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lpdmOnCancel);
        }
        
        ReleaseStgMedium(&stgm);
    }

    //
    // Get device description from IDataObject.
    //

    LPWSTR pDeviceDescription;

    FORMATETC fmte2 = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_NAME),
                       (DVTARGETDEVICE FAR *) NULL,
                       DVASPECT_CONTENT,
                       -1,
                       TYMED_HGLOBAL};

    hres = g_lpdoTarget->GetData(&fmte2, &stgm);

    if (SUCCEEDED(hres) && stgm.hGlobal)
    {
        pDeviceDescription = (LPWSTR) GlobalLock(stgm.hGlobal);

        SendDlgItemMessageW(hDlg, ID_ADP_ADAPTOR, WM_SETTEXT, 0, (LPARAM)pDeviceDescription);

        GlobalUnlock(stgm.hGlobal);
        
        ReleaseStgMedium(&stgm);
    }

    //
    // Enable/disable the properties button
    //

    BOOL bEnable = FALSE;
    LPWSTR pwDeviceID = NULL;

    FORMATETC fmte3 = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_ID),
                       (DVTARGETDEVICE FAR *)NULL,
                       DVASPECT_CONTENT,
                       -1,
                       TYMED_HGLOBAL};

    hres = g_lpdoTarget->GetData(&fmte3, &stgm);

    if (SUCCEEDED(hres) && stgm.hGlobal)
    {
        pwDeviceID = (LPWSTR)GlobalLock(stgm.hGlobal);
        bEnable = ((pwDeviceID != NULL) && (*pwDeviceID != L'\0'));
        GlobalUnlock(stgm.hGlobal);
        ReleaseStgMedium(&stgm);
    }

    HWND hPropButton = GetDlgItem(hDlg, IDC_PROPERTIES);
    if (hPropButton != NULL)
        EnableWindow(hPropButton, bEnable);
}

void Adaptor_OnCancel(HWND hDlg)
{
    //
    // Restore initial mode
    //
    LPDEVMODEW lpdmOnCancel = (LPDEVMODEW) GetWindowLongPtr(hDlg, DWLP_USER);
    DeskInterface.lpfnSetSelectedMode(DeskInterface.pContext, lpdmOnCancel);
}

void Adaptor_OnListAllModes(HWND hDlg)
{
    LPDEVMODEW lpdmBefore, lpdmAfter;

    lpdmAfter = lpdmBefore = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
    if (DialogBoxParam(g_hInst,
                       MAKEINTRESOURCE(DLG_SET_MODE_LIST),
                       hDlg,
                       ListAllModesProc,
                       (LPARAM) &lpdmAfter) == 1 &&
        lpdmAfter && (lpdmAfter != lpdmBefore)) 
    {

        //
        // If the user selected a new setting, tell the property sheet
        // we have outstanding changes. This will enable the Apply button.
        //
        PropSheet_Changed(GetParent(hDlg), hDlg);
        DeskInterface.lpfnSetSelectedMode(DeskInterface.pContext, lpdmAfter);
    }
}

void Adaptor_OnProperties(HWND hDlg)
{
    // Invoke the device manager property sheets to show the properties of the
    // given hardware.

    LPWSTR pwDeviceID;
    HRESULT hres;
    STGMEDIUM stgm;

    FORMATETC fmte2 = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_ID),
                   (DVTARGETDEVICE FAR *) NULL,
                   DVASPECT_CONTENT,
                   -1,
                   TYMED_HGLOBAL};

    hres = g_lpdoTarget->GetData(&fmte2, &stgm);

    if (SUCCEEDED(hres) && stgm.hGlobal)
    {
        pwDeviceID = (LPWSTR) GlobalLock(stgm.hGlobal);

        HINSTANCE hinstDevMgr = LoadLibrary(TEXT("DEVMGR.DLL"));
        if (hinstDevMgr)
        {
            DEVPROPERTIESW pfnDevPropW =
               (DEVPROPERTIESW)GetProcAddress(hinstDevMgr, "DevicePropertiesW");
            if (pfnDevPropW)
            {
                //Display the property sheets for this device.
                (*pfnDevPropW)(hDlg, NULL, pwDeviceID, FALSE);
            }

            FreeLibrary(hinstDevMgr);
        }

        GlobalUnlock(stgm.hGlobal);
        ReleaseStgMedium(&stgm);
    }
}

#if TEST_MODE
void Adaptor_OnTestMode(HWND hDlg)
{
    //
    // Warn the user
    //
    if (FmtMessageBox(hDlg,
                      MB_OKCANCEL | MB_ICONINFORMATION,
                      IDS_TEST_MODE,
                      IDS_TEST_WARNING) == IDCANCEL) {
        return;
    }

    //
    // The user wants to test his new selection.  We need to
    // create a new desktop with the selected resolution, switch
    // to it, and put up a dialog box so he can see if it works with
    // his hardware.
    //
    // All this needs to be done in a separate thread since you can't
    // switch a thread with open windows to a new desktop.
    //

    //
    // Create the test thread.  It will do the work of creating the desktop
    //

    //
    // Get device name from IDataObject.
    //
    LPWSTR pDeviceName = NULL;

    FORMATETC fmte = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_DEVICE),
                      (DVTARGETDEVICE FAR *) NULL,
                      DVASPECT_CONTENT,
                      -1,
                      TYMED_HGLOBAL};

    STGMEDIUM stgm;

    HRESULT hres = g_lpdoTarget->GetData(&fmte, &stgm);

    if (SUCCEEDED(hres) && stgm.hGlobal) {
        //
        // The storage now contains Display device path (\\.\DisplayX) in UNICODE.
        //

        pDeviceName = (LPWSTR) GlobalLock(stgm.hGlobal);
    }

    desktopParam.lpdevmode = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
    desktopParam.pwszDevice = pDeviceName;

    hThread = CreateThread(NULL,
                           4096,
                           ApplyNowThd,
                           (LPVOID) (&desktopParam),
                           SYNCHRONIZE | THREAD_QUERY_INFORMATION,
                           &idThread);

    WaitForSingleObject(hThread, INFINITE);

    GetExitCodeThread(hThread, &bTest);

    //
    // clean up memory
    //
    if (pDeviceName)
    {
        GlobalUnlock(stgm.hGlobal);
        ReleaseStgMedium(&stgm);
    }

    CloseHandle(hThread);

    if (!bTest)
    {
        FmtMessageBox(hDlg,
                      MB_ICONEXCLAMATION | MB_OK,
                      IDS_TEST_MODE,
                      IDS_TEST_FAILED);

    }

    SetForegroundWindow(hDlg);
}
#endif


//---------------------------------------------------------------------------
//
// PropertySheeDlgProc()
//
//  The dialog procedure for the "Adapter" property sheet page.
//
//---------------------------------------------------------------------------
INT_PTR
CALLBACK
PropertySheeDlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMessage)
    {
    case WM_INITDIALOG:

        RtlZeroMemory(&DeskInterface, sizeof(DESK_EXTENSION_INTERFACE));

        if (!g_lpdoTarget)
        {
            return FALSE;
        }
        else
        {
            Adaptor_OnInitDialog(hDlg);
        }

        break;

    case WM_COMMAND:

        if (DeskInterface.cbSize > 0) 
        {
            switch( LOWORD(wParam) )
            {
    #if TEST_MODE
            case IDC_TEST_MODE:
                Adaptor_OnTestMode(hDlg);
                break;
    #endif
    
            case IDC_LIST_ALL:
                Adaptor_OnListAllModes(hDlg);
                break;
    
            case IDC_PROPERTIES:
                Adaptor_OnProperties(hDlg);
                break;
    
            default:
                return FALSE;
            }
        }

        break;

    case WM_NOTIFY:

        if (DeskInterface.cbSize > 0) 
        {
            switch (((NMHDR FAR *)lParam)->code)
            {
            case PSN_APPLY: 
                Adaptor_OnApply(hDlg);
                break;
    
            case PSN_RESET:
                Adaptor_OnCancel(hDlg);
                break;
                
            default:
                return FALSE;
            }
        }

        break;

    case WM_HELP:

        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                TEXT("display.hlp"),
                HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)sc_AdapterHelpIds);

        break;

    case WM_CONTEXTMENU:

        WinHelp((HWND)wParam,
                TEXT("display.hlp"),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR)sc_AdapterHelpIds);

        break;

    default:

        return FALSE;
    }

    return TRUE;
}


//
// This functionality has been deprectaed by the new style of testing a video 
// settings (apply the changes, bring up a countdown dialog to confirm).  If
// need to dipslay a bmp still exists, import TestDisplaySettings from desk.cpl
// via LoadLibrary and GetProcAddress...
//
#if TEST_MODE

/****************************************************************************\
*
* DWORD WINAPI ApplyNowThd(LPVOID lpThreadParameter)
*
* Thread that gets started when the use hits the Apply Now button.
* This thread creates a new desktop with the new video mode, switches to it
* and then displays a dialog box asking if the display looks OK.  If the
* user does not respond within the time limit, then 'NO' is assumed to be
* the answer.
*
\****************************************************************************/
DWORD ApplyNowThd(LPVOID lpThreadParameter)
{

    PNEW_DESKTOP_PARAM lpDesktopParam = (PNEW_DESKTOP_PARAM) lpThreadParameter;
    HDESK hdsk = NULL;
    HDESK hdskDefault = NULL;
    BOOL bTest = FALSE;
    HDC hdc;

    //
    // HACK:
    // We need to make a USER call before calling the desktop stuff so we can
    // sure our threads internal data structure are associated with the default
    // desktop.
    // Otherwise USER has problems closing the desktop with our thread on it.
    //

    GetSystemMetrics(SM_CXSCREEN);

    //
    // Create the desktop
    //

    hdskDefault = GetThreadDesktop(GetCurrentThreadId());

    if (hdskDefault != NULL) {

        hdsk = CreateDesktopW(L"Display.Cpl Desktop",
                              lpDesktopParam->pwszDevice,
                              lpDesktopParam->lpdevmode,
                              0,
                              MAXIMUM_ALLOWED,
                              NULL);

        if (hdsk != NULL) {

            //
            // use the desktop for this thread
            //

            if (SetThreadDesktop(hdsk)) {

                hdc = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);

                if (hdc) {

                    DrawBmp(hdc);

                    DeleteDC(hdc);

                    bTest = TRUE;
                }

                //
                // Sleep for some seconds so you have time to look at the screen.
                //

                Sleep(7000);

            }
        }


        //
        // Reset the thread to the right desktop
        //

        SetThreadDesktop(hdskDefault);

        SwitchDesktop(hdskDefault);

        //
        // Can only close the desktop after we have switched to the new one.
        //

        if (hdsk != NULL)
            CloseDesktop(hdsk);

    }

    ExitThread((DWORD) bTest);

    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskmon\deskcmmn.cpp ===
#include "deskmon.h"

#include "..\..\common\deskcmmn.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskmon\deskmon.h ===
/******************************************************************************

  Source File:  deskmon.h

  General include file

  Copyright (c) 1997-1998 by Microsoft Corporation

  Change History:

  12-01-97 AndreVa - Created It

******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shsemip.h>
#include <stdlib.h>
#include <shlobjp.h>
#include <shellp.h>
#include <string.h>
#include <tchar.h>
#include <winuserp.h>
#include <cfgmgr32.h>

#include <initguid.h>
#include <help.h>
#include "..\..\common\deskcplext.h"
#include "..\..\common\propsext.h"
#include "..\..\common\deskcmmn.h"
#include "resource.h"


class CMonitorPage
{
public:
    // Constructors / destructor
    CMonitorPage(HWND hDlg);
    ~CMonitorPage();

    // Message handlers
    void OnInitDialog();
    void OnDestroy();
    void OnApply();
    void OnCancel();
    void OnProperties();
    BOOL OnSetActive();
    void OnSelMonitorChanged();
    void OnFrequencyChanged();
    void OnPruningModeChanged();

#ifdef DBG
    void AssertValid() const;
#endif

private:
    // Helpers
    void InitPruningMode();
    void SaveMonitorInstancePath(DEVINST devInstAdapter, LPCTSTR pMonitorID, int nNewItem);
    void RefreshFrequenciesList();

    // Data members
    HWND       m_hDlg;
    LPDEVMODEW m_lpdmPrevious;
    BOOL       m_bCanBePruned;          // true if the raw modes list != pruned modes list
    BOOL       m_bIsPruningReadOnly;    // false if can be pruned and we can write the pruning mode
    BOOL       m_bIsPruningOn;          // non null if pruning mode is on
    int        m_cMonitors;
    HWND       m_hMonitorsList;
    LPDEVMODEW m_lpdmOnCancel;          // device mode to be restored on cancel
    BOOL       m_bOnCancelIsPruningOn;  // pruning mode to be restored on cancel
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskadp\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

TARGETNAME = deskadp
TARGETPATH = obj
TARGETTYPE = DYNLINK
TARGETEXT  = dll

COFFBASE   = desk

DLLDEF=$(O)\deskadp.def

INCLUDES=$(INCLUDES);..;$(SDK_LIB_PATH);$(PROJECT_ROOT)\lib\$(O);$(PROJECT_ROOT)\inc\$(O);

SOURCES = ..\deskadp.rc   \
          ..\deskadp.cpp  \
          ..\propsext.cpp \
          ..\setdrw.cpp


# Dynamically loading comctl32 through shfusion.  Need to ignore "locally defined symbol imported" error. (LAmadio)
LINKER_FLAGS    = $(LINKER_FLAGS) -ignore:4049 -ignore:4217

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib         \
           $(SDK_LIB_PATH)\uuid.lib             \
           $(SDK_LIB_PATH)\gdi32.lib            \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\ole32.lib            \
           $(SDK_LIB_PATH)\shlwapi.lib          \
           $(SHELL_LIB_PATH)\shfusion.lib

UMTYPE     = windows

USE_MSVCRT = 1

DLLENTRY   = DllMain

 
 
# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=WindowsShell 
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE=0000 
SXS_MANIFEST=WindowsShell.Manifest 
SXS_MANIFEST_IN_RESOURCES= 
SXS_MANIFEST_RESOURCE_ID=124 
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskadp\setdrw.cpp ===
/******************************************************************************

  Source File:  setdrw.c

  This file contains the code to draw the test bitmap

  Copyright (c) 1997-1998 by Microsoft Corporation

  Change History:

  Original version - ChrisW
  12-01-97 AndreVa - Created It

******************************************************************************/


#include    "deskadp.h"



/****************************************************************************

    FUNCTION: MakeRect 

    PURPOSE:  Fill in RECT structure given contents. 

****************************************************************************/
VOID MakeRect( PRECT pRect, INT xmin, INT ymin, INT xmax, INT ymax )
{
    pRect->left= xmin;
    pRect->right= xmax;
    pRect->bottom= ymin;
    pRect->top= ymax;
}

// type constants for DrawArrow

#define AW_TOP      1   // top
#define AW_BOTTOM   2   // bottom
#define AW_LEFT     3   // left
#define AW_RIGHT    4   // right

/****************************************************************************

    FUNCTION: DrawArrow 

    PURPOSE:  Draw one arrow in a given color. 

****************************************************************************/
static
VOID DrawArrow( HDC hDC, INT type, INT xPos, INT yPos, COLORREF crPenColor )
{
    INT shaftlen=30;         // length of arrow shaft
    INT headlen=15;          // height or width of arrow head (not length)
    HGDIOBJ hPen, hPrevPen = NULL;   // pens
    INT x,y;
    INT xdir, ydir;          // directions of x and y (1,-1)

    hPen= CreatePen( PS_SOLID, 1, crPenColor );
    if( hPen )
        hPrevPen= SelectObject( hDC, hPen );

    MoveToEx( hDC, xPos, yPos, NULL );

    xdir= ydir= 1;   // defaults
    switch( type )
    {
        case AW_BOTTOM:
            ydir= -1;
        case AW_TOP:
            LineTo(hDC, xPos, yPos+ydir*shaftlen);

            for( x=0; x<3; x++ )
            {
                MoveToEx( hDC, xPos,             yPos+ydir*x, NULL );
                LineTo(   hDC, xPos-(headlen-x), yPos+ydir*headlen );
                MoveToEx( hDC, xPos,             yPos+ydir*x, NULL );
                LineTo(   hDC, xPos+(headlen-x), yPos+ydir*headlen );
            }
            break;

        case AW_RIGHT:
            xdir= -1;
        case AW_LEFT:
            LineTo( hDC, xPos + xdir*shaftlen, yPos );

            for( y=0; y<3; y++ )
            {
                MoveToEx( hDC, xPos + xdir*y, yPos, NULL );
                LineTo(   hDC, xPos + xdir*headlen, yPos+(headlen-y));
                MoveToEx( hDC, xPos + xdir*y, yPos, NULL );
                LineTo(   hDC, xPos + xdir*headlen, yPos-(headlen-y));
            }
            break;
    }

    if( hPrevPen )
        SelectObject( hDC, hPrevPen );

    if (hPen)
        DeleteObject(hPen);

}
/****************************************************************************

    FUNCTION: LabelRect 

    PURPOSE:  Label a rectangle with centered text given resource ID.

****************************************************************************/

static
VOID LabelRect(HDC hDC, PRECT pRect, UINT idString )
{
    UINT iStatus;
    INT xStart, yStart;
    SIZE Size;              // for size of string
    TCHAR szMsg[256];

    if( idString == 0 )     // make it easy to ignore call
        return;

    SetBkMode( hDC, OPAQUE );
    SetBkColor( hDC, RGB(0,0,0) );
    SetTextColor( hDC, RGB(255,255,255) );

    // center
    xStart= (pRect->left+pRect->right) /2;
    yStart= (pRect->top+pRect->bottom) /2;

    iStatus= LoadString( g_hInst, idString, szMsg, ARRAYSIZE(szMsg) );
    if( !iStatus )
    {
        return;      // can't find string - print nothing
    }

    GetTextExtentPoint32( hDC, szMsg, lstrlen(szMsg), &Size );
    TextOut( hDC, xStart-Size.cx/2, yStart-Size.cy/2, szMsg, lstrlen(szMsg) );
}

/****************************************************************************

    FUNCTION: PaintRect 

    PURPOSE:  Color in a rectangle and label it. 

****************************************************************************/
static
VOID PaintRect(
HDC hDC,         // DC to paint 
INT lowx,        // coordinates describing rectangle to fill 
INT lowy,        //  
INT highx,       // 
INT highy,       // 
COLORREF rgb,    // color to fill in rectangle with 
UINT idString )  // resource ID to use to label or 0 is none
{
    RECT rct;
    HBRUSH hBrush;

    MakeRect( &rct, lowx, lowy, highx, highy );

    hBrush = CreateSolidBrush( rgb );
    if (hBrush)
    {
        FillRect( hDC, &rct, hBrush );
        DeleteObject( hBrush );
    }

    LabelRect( hDC, &rct, idString ); 

}

/****************************************************************************

    FUNCTION: DrawArrows 

    PURPOSE:  Draw all the arrows showing edges of resolution.

****************************************************************************/
VOID DrawArrows( HDC hDC, INT xRes, INT yRes )
{
    INT dx,dy;
    INT x,y;
    COLORREF color= RGB(0,0,0);    // color of arrow

    dx= xRes/8;
    dy= yRes/8;

    for( x=0; x<xRes; x += dx )
    {
        DrawArrow( hDC, AW_TOP,    dx/2+x,   0,      color ); 
        DrawArrow( hDC, AW_BOTTOM, dx/2+x,   yRes-1, color );
    }
    for( y=0; y<yRes; y += dy )
    {
        DrawArrow( hDC, AW_LEFT,       0, dy/2+y,   color  ); 
        DrawArrow( hDC, AW_RIGHT, xRes-1, dy/2+y,   color );
    }
}
/****************************************************************************

    FUNCTION: LabelResolution 

    PURPOSE:  Labels the resolution in a form a user may understand.
              FEATURE: We could label vertically too. 

****************************************************************************/

VOID LabelResolution( HDC hDC, INT xmin, INT ymin, INT xmax, INT ymax )
{
   TCHAR szRes[120];    // text for resolution
   TCHAR szFmt[256];    // format string
   SIZE  Size;
   INT iStatus;

   iStatus= LoadString( g_hInst, IDS_RESOLUTION_FMT, szFmt, ARRAYSIZE(szFmt) );
   if( !iStatus || iStatus==ARRAYSIZE(szFmt) )
   { 
       lstrcpy(szFmt,TEXT("%d x %d"));   // make sure we get something
   }
   wsprintf( szRes, szFmt, xmax, ymax );

   SetBkMode( hDC, TRANSPARENT );
   SetTextColor( hDC, RGB(0,0,0) );

   GetTextExtentPoint32( hDC, szRes, lstrlen(szRes), &Size );

   // Text near bottom of screen ~10 pixels from bottom
   TextOut( hDC, xmax/2 - Size.cx/2, ymax - 10-Size.cy, szRes, lstrlen(szRes) );
} 


// table of resolutions that we show off.
// if the resolution is larger, then we show that one too.

typedef struct tagRESTAB {
    INT xRes;
    INT yRes;
    COLORREF crColor;           // color to paint this resolution
} RESTAB;

RESTAB ResTab[] ={
   { 1600, 1200, RGB(255,0,0)},
   { 1280, 1024, RGB(0,255,0)},
   { 1152,  900, RGB(0,0,255)},
   { 1024,  768, RGB(255,0,0)},
   {  800,  600, RGB(0,255,0)},
   // 640x480 or 640x400 handled specially
   { 0, 0, 0}         // end of table
   };

/****************************************************************************

    FUNCTION: Set1152Mode

    PURPOSE:  Set the height of the 1152 mode since it varies from card to
              card.

****************************************************************************/
VOID Set1152Mode(int height)
{
    ResTab[2].yRes = height;
}

/****************************************************************************

    FUNCTION: DrawBmp

    PURPOSE:  Show off a fancy screen so the user has some idea
              of what will be seen given this resolution, colour
              depth and vertical refresh rate.  Note that we do not
              try to simulate the font sizes.  

****************************************************************************/
VOID DrawBmp(HDC hDC)
{
    INT    nBpp;          // bits per pixel
    INT    nWidth;        // width of screen in pixels
    INT    nHeight;       // height of screen in pixels
    INT    xUsed,yUsed;   // amount of x and y to use for dense bitmap
    INT    dx,dy;         // delta x and y for color bars
    RECT   rct;           // rectangle for passing bounds
//    HFONT  hFont;         // stock font for logfont
//    LOGFONT lf;           // for creating new font
    HGDIOBJ hPrevFont=0;   // previous font in DC
    HGDIOBJ hNewFont;      // new font if possible
    HGDIOBJ hPrevPen;      // previous pen handle
    INT    x,y,i;
    INT    off;           // offset in dx units

    // try to use bigger better looking font

    //hFont= GetStockObject( DEVICE_DEFAULT_FONT );
    //GetObject( hFont, sizeof(LOGFONT), &lf );
    //lf.lfHeight= 30;
    //hNewFont= CreateFontIndirect( &lf );
    hNewFont = (HFONT)NULL;

    if( hNewFont )                              // if no font, use old
        hPrevFont= SelectObject( hDC, hNewFont );

    // get surface information
    nBpp= GetDeviceCaps( hDC, BITSPIXEL ) * GetDeviceCaps( hDC, PLANES );
    nWidth= GetDeviceCaps( hDC, HORZRES );
    nHeight= GetDeviceCaps( hDC, VERTRES );

    // background for everything is yellow.
    PaintRect( hDC, 0,0,nWidth, nHeight, RGB(255,255,0),0 );
    LabelResolution( hDC, 0,0,nWidth, nHeight );

    // Background for various resolutions
    // biggest ones first

    for( i=0; ResTab[i].xRes !=0; i++ )
    {
        // Only draw if it will show
        if( ( nWidth>=ResTab[i].xRes ) | ( nHeight>=ResTab[i].yRes ) )
        {
           PaintRect(hDC,0,0,ResTab[i].xRes,ResTab[i].yRes,ResTab[i].crColor,0);
           LabelResolution( hDC, 0, 0, ResTab[i].xRes, ResTab[i].yRes);
        }
    }

    // color bars - only in standard vga area 

    xUsed= min( nWidth, 640 );    // only use vga width
    yUsed= min( nHeight, 480 );   // could be 400 on some boards
    dx= xUsed/2;
    dy= yUsed/6;

    PaintRect( hDC, 0,   0, dx, dy*1,  RGB(255,0,0),   IDS_COLOR_RED );
    PaintRect( hDC, 0,dy*1, dx, dy*2,  RGB(0,255,0),   IDS_COLOR_GREEN );
    PaintRect( hDC, 0,dy*2, dx, dy*3,  RGB(0,0,255),   IDS_COLOR_BLUE );
    PaintRect( hDC, 0,dy*3, dx, dy*4,  RGB(255,255,0 ),IDS_COLOR_YELLOW );
    PaintRect( hDC, 0,dy*4, dx, dy*5,  RGB(255,0,255), IDS_COLOR_MAGENTA  );
    PaintRect( hDC, 0,dy*5, dx, yUsed, RGB(0,255,255), IDS_COLOR_CYAN  );

    // gradations of colors for true color detection
    for( x=dx; x<xUsed; x++ )
    {
        INT level;
        level= 255- ( 256*(x-dx) ) / dx;
        PaintRect( hDC, x, dy*0, x+1,  dy*1, RGB( level,0,0 ),0 );
        PaintRect( hDC, x, dy*1, x+1,  dy*2, RGB( 0,level,0 ),0 );
        PaintRect( hDC, x, dy*2, x+1,  dy*3, RGB( 0,0,level ),0 );
        PaintRect( hDC, x, dy*5, x+1,  dy*6, RGB( level,level,level), 0 );
    }
    MakeRect( &rct, dx,0,dx*2,dy*1 );
    LabelRect( hDC, &rct, IDS_RED_SHADES );
    MakeRect( &rct, dx,dy,dx*2,dy*2);
    LabelRect( hDC, &rct, IDS_GREEN_SHADES );
    MakeRect( &rct, dx,2*dy,dx*2,dy*3);
    LabelRect( hDC, &rct, IDS_BLUE_SHADES );
    MakeRect( &rct, dx,5*dy,dx*2,dy*6);
    LabelRect( hDC, &rct, IDS_GRAY_SHADES );

    // horizontal lines for interlace detection
    off= 3;
    PaintRect(hDC, dx,dy*off, xUsed, dy*(off+1),RGB(255,255,255),0 );// white
    hPrevPen= SelectObject( hDC, GetStockObject(BLACK_PEN) );
    for( y=dy*off; y<dy*(off+1); y= y+2 )
    {
        MoveToEx( hDC, dx,   y, NULL );
        LineTo(   hDC, dx*2, y );
    }
    SelectObject( hDC, hPrevPen );
    MakeRect( &rct, dx, dy*off, dx*2, dy*(off+1) );
    LabelRect( hDC, &rct, IDS_PATTERN_HORZ );

    // vertical lines for bad dac detection
    off= 4;
    PaintRect(hDC, dx,dy*off, xUsed,dy*(off+1), RGB(255,255,255),0 );  // white
    hPrevPen= SelectObject( hDC, GetStockObject(BLACK_PEN) );
    for( x=dx; x<xUsed; x= x+2 )
    {
        MoveToEx( hDC, x, dy*off, NULL );
        LineTo(   hDC, x, dy*(off+1) );
    }
    SelectObject( hDC, hPrevPen );
    MakeRect( &rct, dx, dy*off, dx*2, dy*(off+1) );
    LabelRect( hDC, &rct, IDS_PATTERN_VERT );

    DrawArrows( hDC, nWidth, nHeight ); 

    LabelResolution(hDC, 0,0, xUsed, yUsed );

    // delete created font if one was created
    if( hPrevFont )
    {
        hPrevFont= SelectObject( hDC, hPrevFont );
        DeleteObject( hPrevFont );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskmon\propsext.cpp ===
#include "deskmon.h"

#include "..\..\common\propsext.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskmon\deskmon.cpp ===
/******************************************************************************

  Source File:  deskmon.cpp

  Main code for the advanced desktop Monitor page

  Copyright (c) 1997-1998 by Microsoft Corporation

  Change History:

  12-16-97 AndreVa - Created It

******************************************************************************/


#include    "deskmon.h"
#define DECL_CRTFREE
#include <crtfree.h>


//
// The function DeviceProperties() is implemented in DevMgr.dll; Since we don't have a devmgr.h, we
// explicitly declare it here.
// 
typedef int (WINAPI  *DEVPROPERTIES)(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceID,
    BOOL ShowDeviceTree
    );


// OLE-Registry magic number
// 42071713-76d4-11d1-8b24-00a0c9068ff3
//
GUID g_CLSID_CplExt = { 0x42071713, 0x76d4, 0x11d1,
                        { 0x8b, 0x24, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3}
                      };


DESK_EXTENSION_INTERFACE DeskInterface;

static const DWORD sc_MonitorHelpIds[] =
{
    IDC_MONITOR_GRP,    IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_TYPE, 
    IDI_MONITOR,        IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_TYPE, 
    IDC_MONITORDESC,    IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_TYPE, 
    IDC_MONITORS_LIST,  IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_MONITORTYPE_LISTBOX,
    IDC_PROPERTIES,     IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_PROPERTIES,

    IDC_MONSET_GRP,     IDH_NOHELP, 
    IDC_MONSET_FREQSTR, IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_REFRESH, 
    IDC_MONSET_FREQ,    IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_REFRESH, 
    IDC_MONSET_PRUNNING_MODE,       IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_HIDEMODE_CHECKBOX, 
    IDC_MONSET_PRUNNING_MODE_DESC,  IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_HIDEMODE_CHECKBOX, 

    0, 0
};

///////////////////////////////////////////////////////////////////////////////
//
// Messagebox wrapper
//
///////////////////////////////////////////////////////////////////////////////


int
FmtMessageBox(
    HWND hwnd,
    UINT fuStyle,
    DWORD dwTitleID,
    DWORD dwTextID)
{
    TCHAR Title[256];
    TCHAR Text[1700];

    LoadString(g_hInst, dwTextID, Text, ARRAYSIZE(Text));
    LoadString(g_hInst, dwTitleID, Title, ARRAYSIZE(Title));

    return (MessageBox(hwnd, Text, Title, fuStyle));
}


// Constructors / destructor
CMonitorPage::CMonitorPage(HWND hDlg)
    : m_hDlg(hDlg)
    , m_lpdmPrevious(NULL)
    , m_bCanBePruned(FALSE)
    , m_bIsPruningReadOnly(TRUE)
    , m_bIsPruningOn(FALSE)
    , m_cMonitors(0)
    , m_hMonitorsList(NULL)
    , m_lpdmOnCancel(NULL)
    , m_bOnCancelIsPruningOn(FALSE)
{
    // preconditions
    //ASSERT(NULL != hDlg);
}


CMonitorPage::~CMonitorPage()
{
}


void CMonitorPage::OnApply()
{
    long lRet = PSNRET_INVALID_NOCHANGEPAGE;
    HINSTANCE hInst;
    LPDISPLAY_SAVE_SETTINGS lpfnDisplaySaveSettings = NULL;

    hInst = LoadLibrary(TEXT("desk.cpl"));
    if (hInst)
    {
        lpfnDisplaySaveSettings = (LPDISPLAY_SAVE_SETTINGS)
                                  GetProcAddress(hInst, "DisplaySaveSettings");
        if (lpfnDisplaySaveSettings)
        {
            long lSave = lpfnDisplaySaveSettings(DeskInterface.pContext, m_hDlg);
            LPDEVMODEW lpdmCurrent = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);

            if (lSave == DISP_CHANGE_SUCCESSFUL)
            {
                //
                // Save the current mode - to restore it in case the user cancels the p. sheet
                //
                m_lpdmOnCancel = m_lpdmPrevious = lpdmCurrent;
                m_bOnCancelIsPruningOn = m_bIsPruningOn;
                lRet = PSNRET_NOERROR;
            }
            else if (lSave == DISP_CHANGE_RESTART)
            {
                //
                // User wants to reboot system.
                //
                PropSheet_RestartWindows(GetParent(m_hDlg));
                lRet = PSNRET_NOERROR;
            }
            else
            {
                //
                // Keep the apply button active
                //
                lRet = PSNRET_INVALID_NOCHANGEPAGE;
                
                RefreshFrequenciesList();
                
                BOOL bCanBePruned, bIsPruningReadOnly, bIsPruningOn;
                DeskInterface.lpfnGetPruningMode(DeskInterface.pContext, 
                                                 &bCanBePruned, 
                                                 &bIsPruningReadOnly,
                                                 &bIsPruningOn);
                if(m_bIsPruningOn != bIsPruningOn)
                    InitPruningMode();
            }
        }

        FreeLibrary(hInst);
    }

    SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, lRet);
}

    
void CMonitorPage::OnCancel()
{
    if (m_bCanBePruned && !m_bIsPruningReadOnly && 
        ((m_bOnCancelIsPruningOn != 0) != (m_bIsPruningOn != 0)))
        DeskInterface.lpfnSetPruningMode(DeskInterface.pContext, m_bOnCancelIsPruningOn);

    DeskInterface.lpfnSetSelectedMode(DeskInterface.pContext, m_lpdmOnCancel);
};


void CMonitorPage::OnInitDialog()
{
    m_hMonitorsList = GetDlgItem(m_hDlg, IDC_MONITORS_LIST); 
    HWND hSingleMonitor = GetDlgItem(m_hDlg, IDC_MONITORDESC); 
    //ASSERT((NULL != m_hMonitorsList) && (NULL != hSingleMonitor));
    ListBox_ResetContent(m_hMonitorsList);

    //
    // Get the CPL extension interfaces from IDataObject.
    //
    STGMEDIUM stgmExt;
    FORMATETC fmteExt = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_INTERFACE),
                         (DVTARGETDEVICE FAR *) NULL,
                         DVASPECT_CONTENT,
                         -1,
                         TYMED_HGLOBAL};

    HRESULT hres = g_lpdoTarget->GetData(&fmteExt, &stgmExt);

    if (SUCCEEDED(hres) && stgmExt.hGlobal)
    {
        //
        // The storage now contains Display device path (\\.\DisplayX) in UNICODE.
        //
        PDESK_EXTENSION_INTERFACE pInterface =
            (PDESK_EXTENSION_INTERFACE) GlobalLock(stgmExt.hGlobal);

        RtlCopyMemory(&DeskInterface,
                      pInterface,
                      min(pInterface->cbSize,
                      sizeof(DESK_EXTENSION_INTERFACE)));

        GlobalUnlock(stgmExt.hGlobal);
        ReleaseStgMedium(&stgmExt);
    }

    //
    // Get the adapter devnode.
    // The adapter is the parent of all monitors in the device tree.
    //
    DEVINST devInstAdapter;
    BOOL bDevInstAdapter = FALSE;

    STGMEDIUM stgmAdpId;
    FORMATETC fmteAdpId = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_ID),
                           (DVTARGETDEVICE FAR *) NULL,
                           DVASPECT_CONTENT,
                           -1,
                           TYMED_HGLOBAL};

    hres = g_lpdoTarget->GetData(&fmteAdpId, &stgmAdpId);

    if(SUCCEEDED(hres) && stgmAdpId.hGlobal)
    {
        LPWSTR pwDeviceID = (LPWSTR) GlobalLock(stgmAdpId.hGlobal);

        #ifdef UNICODE
            bDevInstAdapter = (CM_Locate_DevNodeW(&devInstAdapter, pwDeviceID, 0) == CR_SUCCESS);
        #else // UNICODE
    	    CHAR szBuffer[MAX_PATH];
            bDevInstAdapter = (BOOL)WideCharToMultiByte(CP_ACP, 0, pwDeviceID, lstrlenW(pwDeviceID) + 1,
                                                        szBuffer, MAX_PATH, NULL, NULL);
            if(bDevInstAdapter)
            {
                bDevInstAdapter = (CM_Locate_DevNodeA(&devInstAdapter, szBuffer, 0) == CR_SUCCESS);
            }
        #endif // UNICODE

        GlobalUnlock(stgmAdpId.hGlobal);
        ReleaseStgMedium(&stgmAdpId);
    }

    //
    // Get the adapter device and enum all monitors
    //
    STGMEDIUM stgmAdpDev;
    FORMATETC fmteAdpDev = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_DEVICE),
                           (DVTARGETDEVICE FAR *) NULL,
                           DVASPECT_CONTENT,
                           -1,
                           TYMED_HGLOBAL};
    hres = g_lpdoTarget->GetData(&fmteAdpDev, &stgmAdpDev);

    if (SUCCEEDED(hres) && stgmAdpDev.hGlobal)
    {
        LPWSTR pwDisplayDevice = (LPWSTR)GlobalLock(stgmAdpDev.hGlobal);
        LPTSTR pBuffer = NULL;

        #ifdef UNICODE
            pBuffer = pwDisplayDevice;
        #else // UNICODE
    	    CHAR szBuffer[MAX_PATH];
            if(WideCharToMultiByte(CP_ACP, 0, pwDisplayDevice, lstrlenW(pwDisplayDevice) + 1,
                                   szBuffer, MAX_PATH, NULL, NULL))
                pBuffer = szBuffer;
        #endif // UNICODE

        if(NULL != pBuffer)
        {
            DISPLAY_DEVICE ddMon;
            BOOL bSuccess = FALSE;
            int cMonitors = 0;

            do 
            {
                ZeroMemory(&ddMon, sizeof(ddMon));
                ddMon.cb = sizeof(DISPLAY_DEVICE);

                bSuccess = EnumDisplayDevices(pBuffer, cMonitors, &ddMon, 0);
                if (bSuccess) 
                {
                    ++cMonitors;

                    if (ddMon.StateFlags & DISPLAY_DEVICE_ATTACHED)
                    {
                        if(0 == m_cMonitors)
                            SendDlgItemMessage(m_hDlg, IDC_MONITORDESC, WM_SETTEXT, 0, (LPARAM)ddMon.DeviceString);
    
                        int nNewItem = ListBox_AddString(m_hMonitorsList, (LPTSTR)ddMon.DeviceString);
                        if(nNewItem >= 0)
                        {
                            ++m_cMonitors;
    
                            ListBox_SetItemData(m_hMonitorsList, nNewItem, NULL);
                            if(bDevInstAdapter)
                                SaveMonitorInstancePath(devInstAdapter, ddMon.DeviceID, nNewItem);
                        }
                    }
                }
            }
            while (bSuccess);
        }
        
        GlobalUnlock(stgmAdpDev.hGlobal);
        ReleaseStgMedium(&stgmAdpDev);
    }

    if(m_cMonitors <= 0)
    {
        TCHAR szDefaultMonitor[MAX_PATH];
        LoadString(g_hInst, IDS_DEFAULT_MONITOR, szDefaultMonitor, ARRAYSIZE(szDefaultMonitor));
        SendDlgItemMessage(m_hDlg, IDC_MONITORDESC, WM_SETTEXT, 0, (LPARAM)szDefaultMonitor);
        EnableWindow(GetDlgItem(m_hDlg, IDC_PROPERTIES), FALSE);
    }
    else if(m_cMonitors == 1)
    {
        BOOL bEnable = ((ListBox_GetCount(m_hMonitorsList) >= 1) &&
                        (NULL != (LPTSTR)ListBox_GetItemData(m_hMonitorsList, 0)));
        EnableWindow(GetDlgItem(m_hDlg, IDC_PROPERTIES), bEnable);
    }
    else
    {
        ListBox_SetCurSel(m_hMonitorsList, 0);
        OnSelMonitorChanged();
    }

    ShowWindow(((m_cMonitors <= 1) ? m_hMonitorsList : hSingleMonitor), SW_HIDE);

    //
    // Init the pruning mode check box
    //
    InitPruningMode();
    m_bOnCancelIsPruningOn = m_bIsPruningOn;

    //
    // Save the current mode - in case the user cancels the p. sheet    
    //
    m_lpdmOnCancel = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
}


void CMonitorPage::OnDestroy()
{
    //ASSERT(NULL != m_hMonitorsList);
    int cMonitors = ListBox_GetCount(m_hMonitorsList);
    for(int nMonitor = 0; nMonitor < cMonitors; ++nMonitor)
    {
        LPTSTR pMonitorInstancePath = (LPTSTR)ListBox_GetItemData(m_hMonitorsList, nMonitor);
        if(NULL != pMonitorInstancePath)
            LocalFree(pMonitorInstancePath);
    }
}


void CMonitorPage::SaveMonitorInstancePath(DEVINST devInstAdapter, LPCTSTR pMonitorID, int nNewItem)
{
    //ASSERT(NULL != m_hMonitorsList);

    DEVINST devInstChild, devInstPrevChild;
    TCHAR szBuff[256]; // buffer used to concatenate: HARDWAREID, "\" and DRIVER
                       // this is what EnumDisplayDevice returns in DeviceID in case of a monitor
    ULONG lenBuff; // size of the buffer, in bytes

    if (CM_Get_Child(&devInstChild, devInstAdapter, 0) != CR_SUCCESS) 
        return;

    do 
    {
        devInstPrevChild = devInstChild;

        //CM_DRP_HARDWAREID
        lenBuff = ARRAYSIZE(szBuff) - 2 ; // make sure we have place to append "\"
        if (CM_Get_DevNode_Registry_Property(devInstChild,
                                             CM_DRP_HARDWAREID,
                                             NULL,
                                             szBuff,
                                             &lenBuff,
                                             0) != CR_SUCCESS)
            continue;

        // "\"
        lstrcat(szBuff, TEXT("\\"));

        //CM_DRP_DRIVER
        lenBuff = sizeof(szBuff) - lstrlen(szBuff) * sizeof(TCHAR);
        if (CM_Get_DevNode_Registry_Property(devInstChild,
                                             CM_DRP_DRIVER,
                                             NULL,
                                             szBuff + lstrlen(szBuff),
                                             &lenBuff,
                                             0) != CR_SUCCESS)
            continue;

        if (lstrcmpi(szBuff, pMonitorID) == 0) 
        {
            LPTSTR pMonitorInstancePath = (LPTSTR)LocalAlloc(LPTR, MAX_PATH * sizeof(TCHAR));
            if((NULL != pMonitorInstancePath) &&
               (CM_Get_Device_ID(devInstChild, pMonitorInstancePath, MAX_PATH, 0) == CR_SUCCESS))
                ListBox_SetItemData(m_hMonitorsList, nNewItem, (LPARAM)pMonitorInstancePath);
            break;
        }

    } 
    while(CM_Get_Sibling(&devInstChild, devInstPrevChild, 0) == CR_SUCCESS);
}


void CMonitorPage::OnSelMonitorChanged()
{
    //ASSERT(NULL != m_hMonitorsList);
    //ASSERT(NULL != m_hDlg);
   
    //
    // Enable / Disable the Properties button
    //
    BOOL bEnable = FALSE;
    if(ListBox_GetCount(m_hMonitorsList) >= 1)
    {
        int nCurSel = ListBox_GetCurSel(m_hMonitorsList);
        if(nCurSel >= 0)
            bEnable = (NULL != (LPTSTR)ListBox_GetItemData(m_hMonitorsList, nCurSel));
    }
    EnableWindow(GetDlgItem(m_hDlg, IDC_PROPERTIES), bEnable);
}


void CMonitorPage::OnProperties()
{
    int nSelMonitor;

    if(m_cMonitors <= 0)
        nSelMonitor = -1;
    else if(m_cMonitors == 1)
        nSelMonitor = ((ListBox_GetCount(m_hMonitorsList) >= 1) ? 0 : -1);
    else
        nSelMonitor = ListBox_GetCurSel(m_hMonitorsList);

    if(nSelMonitor < 0)
        return;

    //ASSERT(nSelMonitor < ListBox_GetCount(m_hMonitorsList));

    LPTSTR pMonitorInstancePath = (LPTSTR)ListBox_GetItemData(m_hMonitorsList, nSelMonitor);
    if(NULL != pMonitorInstancePath)
    {
        HINSTANCE hinstDevMgr = LoadLibrary(TEXT("DEVMGR.DLL"));

        if (hinstDevMgr)
        {
            DEVPROPERTIES pfnDevProp = NULL;
            #ifdef UNICODE
                pfnDevProp = (DEVPROPERTIES)GetProcAddress(hinstDevMgr, "DevicePropertiesW");
            #else // UNICODE
                pfnDevProp = (DEVPROPERTIES)GetProcAddress(hinstDevMgr, "DevicePropertiesA");
            #endif // UNICODE

            if (pfnDevProp)
            {
                //Display the property sheets for this device.
                (*pfnDevProp)(m_hDlg, NULL, pMonitorInstancePath, FALSE);
            }

            FreeLibrary(hinstDevMgr);
        }
    }
}


BOOL CMonitorPage::OnSetActive()
{
    LPDEVMODEW lpdm;
    DWORD      item;
    LPDEVMODEW lpdmCurrent, lpdmPrevious;
    LPDEVMODEW lpdmTmp;
    DWORD      i = 0;
    TCHAR      achFre[50];
    TCHAR      achText[80];
    DWORD      pos;
    HWND       hFreq;
    
    InitPruningMode();
    
    //
    // Build the list of refresh rates for the currently selected mode.
    //
    lpdmCurrent = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
    hFreq = GetDlgItem(m_hDlg, IDC_MONSET_FREQ);
    
    if (lpdmCurrent == NULL)
        return -1;

    if (m_lpdmPrevious) 
    {
        if (lpdmCurrent->dmBitsPerPel != m_lpdmPrevious->dmBitsPerPel ||
            lpdmCurrent->dmPelsWidth  != m_lpdmPrevious->dmPelsWidth  ||
            lpdmCurrent->dmPelsHeight != m_lpdmPrevious->dmPelsHeight) 
        {
            ComboBox_ResetContent(hFreq);
        }
    }
    m_lpdmPrevious = lpdmCurrent;
    
    while (lpdm = DeskInterface.lpfnEnumAllModes(DeskInterface.pContext, i++)) {
    
        //
        // Only show refresh frequencies for current modes.
        //
        if ((lpdmCurrent->dmBitsPerPel != lpdm->dmBitsPerPel)  ||
            (lpdmCurrent->dmPelsWidth  != lpdm->dmPelsWidth)   ||
            (lpdmCurrent->dmPelsHeight != lpdm->dmPelsHeight))
            continue;
    
        //
        // convert bit count to number of colors and make it a string
        //
        // WARNING should this be 0 ?
        if (lpdm->dmDisplayFrequency == 1) {
            LoadString(g_hInst, IDS_DEFFREQ, achText, ARRAYSIZE(achText));
        }
        else {
            DWORD  idFreq = IDS_FREQ;
    
            if (lpdm->dmDisplayFrequency < 50)
            {
                idFreq = IDS_INTERLACED;
            }
    
            LoadString(g_hInst, idFreq, achFre, ARRAYSIZE(achFre));
            wsprintf(achText, TEXT("%d %s"), lpdm->dmDisplayFrequency, achFre);
        }
    
        //
        // Insert the string in the right place
        //
        pos = 0;
    
        while (lpdmTmp = (LPDEVMODEW) ComboBox_GetItemData(hFreq, pos))  {
            if ((ULONG_PTR)lpdmTmp != CB_ERR) {
                if (lpdmTmp->dmDisplayFrequency == lpdm->dmDisplayFrequency) {
                    break;
                }
    
                if (lpdmTmp->dmDisplayFrequency < lpdm->dmDisplayFrequency) {
                    pos++;
                    continue;
                }
            }
    
            //
            // Insert it here
            //
            item = ComboBox_InsertString(hFreq, pos, achText);
            ComboBox_SetItemData(hFreq, item, lpdm); 
            break;
        }
    }
    
    //
    // Finally, set the right selection
    //
    pos = 0;
    while (lpdmTmp = (LPDEVMODEW) ComboBox_GetItemData(hFreq, pos)) {
    
        if ((ULONG_PTR)lpdmTmp == CB_ERR) {
            FmtMessageBox(m_hDlg,
                          MB_OK | MB_ICONINFORMATION,
                          IDS_BAD_REFRESH,
                          IDS_BAD_REFRESH);
            return -1;
        }
    
        if (lpdmTmp->dmDisplayFrequency == lpdmCurrent->dmDisplayFrequency) {
            ComboBox_SetCurSel(hFreq, pos);
            break;
        }
    
        pos++;
    }
    
    return 0;
}


void CMonitorPage::OnFrequencyChanged()
{
    DWORD       item;
    HWND        hFreq;
    LPDEVMODEW  lpdmSelected = NULL, lpdmCurrent = NULL;

    //
    // Save the mode back
    //
    hFreq = GetDlgItem(m_hDlg, IDC_MONSET_FREQ);
    item = ComboBox_GetCurSel(hFreq);
    if (item == LB_ERR) 
        return;

    lpdmCurrent = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
    lpdmSelected = (LPDEVMODEW) ComboBox_GetItemData(hFreq, item);

    if (lpdmSelected && (lpdmSelected != lpdmCurrent))
        DeskInterface.lpfnSetSelectedMode(DeskInterface.pContext, lpdmSelected);
}


void CMonitorPage::OnPruningModeChanged()
{
    if (m_bCanBePruned && !m_bIsPruningReadOnly)
    {
        BOOL bNewIsPruningOn = (BST_UNCHECKED != IsDlgButtonChecked(m_hDlg, IDC_MONSET_PRUNNING_MODE));
        if((m_bIsPruningOn != 0) != bNewIsPruningOn)
        {
            m_bIsPruningOn = bNewIsPruningOn;
            DeskInterface.lpfnSetPruningMode(DeskInterface.pContext, m_bIsPruningOn);
            RefreshFrequenciesList();
        }
    }
}


void CMonitorPage::InitPruningMode()
    {
    m_bCanBePruned = FALSE;
    m_bIsPruningReadOnly = TRUE;
    m_bIsPruningOn = FALSE;
    
    DeskInterface.lpfnGetPruningMode(DeskInterface.pContext, 
                                     &m_bCanBePruned, 
                                     &m_bIsPruningReadOnly,
                                     &m_bIsPruningOn);
    
    BOOL bEnable = (m_bCanBePruned && !m_bIsPruningReadOnly);
    EnableWindow(GetDlgItem(m_hDlg, IDC_MONSET_PRUNNING_MODE), bEnable);
    EnableWindow(GetDlgItem(m_hDlg, IDC_MONSET_PRUNNING_MODE_DESC), bEnable);

    BOOL bChecked = (m_bCanBePruned && m_bIsPruningOn);
    CheckDlgButton(m_hDlg, IDC_MONSET_PRUNNING_MODE, bChecked);
    }


void CMonitorPage::RefreshFrequenciesList()
{
    LPDEVMODEW lpdm;
    DWORD      item;
    LPDEVMODEW lpdmCurrent, lpdmPrevious;
    LPDEVMODEW lpdmTmp;
    DWORD      i = 0;
    TCHAR      achFre[50];
    TCHAR      achText[80];
    DWORD      pos;
    HWND       hFreq;

    HWND hwndCurr = GetFocus();
    
    //
    // Build the list of refresh rates for the currently selected mode.
    //
    
    lpdmCurrent = DeskInterface.lpfnGetSelectedMode(DeskInterface.pContext);
    if (lpdmCurrent == NULL)
        return;

    hFreq = GetDlgItem(m_hDlg, IDC_MONSET_FREQ);
    ComboBox_ResetContent(hFreq);
    
    while (lpdm = DeskInterface.lpfnEnumAllModes(DeskInterface.pContext, i++))
    {

        //
        // Only show refresh frequencies for current modes.
        //
        if ((lpdmCurrent->dmBitsPerPel != lpdm->dmBitsPerPel)  ||
            (lpdmCurrent->dmPelsWidth  != lpdm->dmPelsWidth)   ||
            (lpdmCurrent->dmPelsHeight != lpdm->dmPelsHeight))
            continue;

        //
        // convert bit count to number of colors and make it a string
        //
        // WARNING should this be 0 ?
        if (lpdm->dmDisplayFrequency == 1)
        {
            LoadString(g_hInst, IDS_DEFFREQ, achText, ARRAYSIZE(achText));
        }
        else
        {
            DWORD  idFreq = IDS_FREQ;

            if (lpdm->dmDisplayFrequency < 50)
            {
                idFreq = IDS_INTERLACED;
            }

            LoadString(g_hInst, idFreq, achFre, ARRAYSIZE(achFre));
            wsprintf(achText, TEXT("%d %s"), lpdm->dmDisplayFrequency, achFre);
        }

        //
        // Insert the string in the right place
        //
        pos = 0;

        while (lpdmTmp = (LPDEVMODEW) ComboBox_GetItemData(hFreq, pos))
        {
            if ((ULONG_PTR)lpdmTmp != CB_ERR)
            {
                if (lpdmTmp->dmDisplayFrequency == lpdm->dmDisplayFrequency)
                {
                    break;
                }

                if (lpdmTmp->dmDisplayFrequency < lpdm->dmDisplayFrequency)
                {
                    pos++;
                    continue;
                }
            }

            //
            // Insert it here
            //
            item = ComboBox_InsertString(hFreq, pos, achText);
            ComboBox_SetItemData(hFreq, item, lpdm); 
            break;
        }
    }

    //
    // Finally, set the right selection
    //
    pos = 0;
    while (lpdmTmp = (LPDEVMODEW) ComboBox_GetItemData(hFreq, pos))
    {

        if ((ULONG_PTR)lpdmTmp == CB_ERR)
        {
            FmtMessageBox(m_hDlg,
                          MB_OK | MB_ICONINFORMATION,
                          IDS_BAD_REFRESH,
                          IDS_BAD_REFRESH);
            break;
        }

        if (lpdmTmp->dmDisplayFrequency == lpdmCurrent->dmDisplayFrequency)
        {
            ComboBox_SetCurSel(hFreq, pos);
            break;
        }

        pos++;
    }

    if (hwndCurr)
        SetFocus(hwndCurr);

    return;
}


#ifdef DBG

void CMonitorPage::AssertValid() const
{
    //ASSERT(m_hDlg != NULL);
    //ASSERT(!m_bIsPruningOn || m_bCanBePruned);
}

#endif


//---------------------------------------------------------------------------
//
// PropertySheeDlgProc()
//
//  The dialog procedure for the "Monitor" property sheet page.
//
//---------------------------------------------------------------------------
INT_PTR
CALLBACK
PropertySheeDlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    NMHDR FAR *lpnm;
    CMonitorPage * pMonitorPage = (CMonitorPage*)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage)
    {
    case WM_INITDIALOG:

        if (!g_lpdoTarget)
        {
            return FALSE;
        }
        else
        {
            //ASSERT(!pMonitorPage);
            pMonitorPage = new CMonitorPage(hDlg);
            if(!pMonitorPage)
                return FALSE;
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pMonitorPage);
            pMonitorPage->OnInitDialog();
        }

        break;

    case WM_DESTROY:

        if (pMonitorPage)
        {
            pMonitorPage->OnDestroy();
            SetWindowLongPtr(hDlg, DWLP_USER, NULL);
            delete pMonitorPage;
        }

        break;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_MONSET_FREQ:

            switch(GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case CBN_SELCHANGE:
                PropSheet_Changed(GetParent(hDlg), hDlg);
                if(pMonitorPage)
                   pMonitorPage->OnFrequencyChanged();
                break;

            default:
                break;
            }
            break;
            
        case IDC_PROPERTIES:
            if(pMonitorPage)
                pMonitorPage->OnProperties();
            break;

        case IDC_MONSET_PRUNNING_MODE:
            PropSheet_Changed(GetParent(hDlg), hDlg);
            if(pMonitorPage)
                pMonitorPage->OnPruningModeChanged();
            break;

        case IDC_MONITORS_LIST:

            switch(GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case LBN_SELCHANGE:
                if(pMonitorPage)
                    pMonitorPage->OnSelMonitorChanged();
                break;

            default:
                return FALSE;
            }
            break;

        default:
            return FALSE;
        }

        break;

    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            return (pMonitorPage && pMonitorPage->OnSetActive());

        case PSN_APPLY: 
            if(pMonitorPage)
                pMonitorPage->OnApply();
            break;

        case PSN_RESET: 
            if(pMonitorPage)
                pMonitorPage->OnCancel();
            break;
        
        default:
            return FALSE;
        }

        break;


    case WM_HELP:

        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                TEXT("display.hlp"),
                HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)sc_MonitorHelpIds);

        break;


    case WM_CONTEXTMENU:

        WinHelp((HWND)wParam,
                TEXT("display.hlp"),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR)sc_MonitorHelpIds);

        break;


    default:

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\backdlg.cpp ===
/*  BACKDLG.C
**
**  Copyright (C) Microsoft, 1993, All Rights Reserved.
**
**
**  History:
**
*/

#include "precomp.h"
#include "shlwapi.h"

#define MAX_RHS    256

TCHAR g_szPattern[] = TEXT("pattern");
TCHAR szDesktop[] = TEXT("desktop");
TCHAR szWallpaper[] = TEXT("wallpaper");
TCHAR szTileWall[] = TEXT("TileWallpaper");
TCHAR szDotBMP[] = TEXT(".bmp");
TCHAR szBMP[] = TEXT("\\*.bmp");
TCHAR szDefExt[] = TEXT("bmp");
BOOL g_bValidBitmap = FALSE;    // the currently selected wallpaper is valid

TCHAR g_szCurPattern[MAX_PATH];
TCHAR g_szCurWallpaper[MAX_PATH];
TCHAR g_szTempItem[MAX_PATH];      // which is more of a waste, stack or data?

BOOL g_Back_bInit = TRUE;       // assume we are in initialization process
BOOL g_Back_bChanged = FALSE;   // changes have been made

static void NukeExt(LPTSTR sz);
static void AddExt(LPTSTR sz, LPTSTR x);
static LPTSTR NEAR PASCAL NiceName(LPTSTR sz);

INT_PTR CALLBACK PatternDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

#include "help.h"

const static DWORD FAR aBckgrndHelpIds[] = {
        IDC_NO_HELP_1,   IDH_COMM_GROUPBOX,
        IDC_NO_HELP_2,   IDH_COMM_GROUPBOX,
        IDC_PATLIST,     IDH_DSKTPBACKGROUND_PATTLIST,
        IDC_EDITPAT,     IDH_DSKTPBACKGROUND_EDITPAT,
        IDC_WALLLIST,    IDH_DSKTPBACKGROUND_WALLLIST,
        IDC_BROWSEWALL,  IDH_DSKTPBACKGROUND_BROWSE,
        IDC_TXT_DISPLAY, IDH_DSKTPBACKGROUND_DISPLAY,
        IDC_TILE,        IDH_DSKTPBACKGROUND_TILE,
        IDC_CENTER,      IDH_DSKTPBACKGROUND_CENTER,
        IDC_BACKPREV,    IDH_DSKTPBACKGROUND_MONITOR,

        0, 0
};

static const TCHAR szRegStr_Desktop[] = REGSTR_PATH_DESKTOP;
static const TCHAR szRegStr_Setup[] = REGSTR_PATH_SETUP TEXT("\\Setup");
static const TCHAR szSharedDir[] = TEXT("SharedDir");

// we're mainly trying to filter multilingual upgrade cases
// where the text for "(None)" is unpredictable
//
BOOL NEAR PASCAL IsProbablyAValidPattern( LPCTSTR pat )
{
    BOOL sawanumber = FALSE;

    while( *pat )
    {
        if( ( *pat < TEXT('0') ) || ( *pat > TEXT('9') ) )
        {
            // it's not a number, it better be a space
            if( *pat != TEXT(' ') )
                return FALSE;
        }
        else
            sawanumber = TRUE;

        // NOTE: we avoid the need for AnsiNext by only advancing on US TCHARs
        pat++;
    }

    // TRUE if we saw at least one digit and there were only digits and spaces
    return sawanumber;
}


#ifdef DEBUG

#define REG_INTEGER  1000
int  fTraceRegAccess = 0;

void NEAR PASCAL  RegDetails(int iWrite, HKEY hk, LPCTSTR lpszSubKey,
    LPCTSTR lpszValueName, DWORD dwType, LPTSTR  lpszString, int iValue)
{
  TCHAR Buff[256];
  TCHAR far *lpszReadWrite[] = { TEXT("DESK.CPL:Read"), TEXT("DESK.CPL:Write") };

  if(!fTraceRegAccess)
     return;

  switch(dwType)
    {
      case REG_SZ:
          wsprintf(Buff, TEXT("%s String:hk=%#08lx, %s:%s=%s\n\r"), lpszReadWrite[iWrite],
                           hk, lpszSubKey, lpszValueName, lpszString);
          break;

      case REG_INTEGER:
          wsprintf(Buff, TEXT("%s int:hk=%#08lx, %s:%s=%d\n\r"), lpszReadWrite[iWrite],
                           hk, lpszSubKey, lpszValueName, iValue);
          break;

      case REG_BINARY:
          wsprintf(Buff, TEXT("%s Binary:hk=%#08lx, %s:%s=%#0lx;DataSize:%d\r\n"), lpszReadWrite[iWrite],
                           hk, lpszSubKey, lpszValueName, lpszString, iValue);
          break;
    }
  OutputDebugString(Buff);
}

#endif  // DEBUG


//---------------------------------------------------------------------------
//  GetIntFromSubKey
//      hKey is the handle to the subkey
//      (already pointing to the proper location).
//---------------------------------------------------------------------------

int NEAR PASCAL GetIntFromSubkey(HKEY hKey, LPCTSTR lpszValueName, int iDefault)
{
  TCHAR  szValue[20];
  DWORD dwSizeofValueBuff = sizeof(szValue);
  DWORD dwType;
  int   iRetValue = iDefault;

  if((RegQueryValueEx(hKey, lpszValueName, NULL, &dwType,
                        (LPBYTE)szValue,
                &dwSizeofValueBuff) == ERROR_SUCCESS) && dwSizeofValueBuff)
  {
    // BOGUS: This handles only the string type entries now!
    if(dwType == REG_SZ)
        iRetValue = (int)StrToInt(szValue);
#ifdef DEBUG
    else
        OutputDebugString(TEXT("String type expected from Registry\n\r"));
#endif
  }
#ifdef DEBUG
  RegDetails(0, hKey, TEXT(""), lpszValueName, REG_INTEGER, NULL, iRetValue);
#endif
  return(iRetValue);
}

//---------------------------------------------------------------------------
//  GetIntFromReg()
//       Opens the given subkey and gets the int value.
//---------------------------------------------------------------------------

int NEAR PASCAL GetIntFromReg(HKEY   hKey,
                                        LPCTSTR lpszSubkey,
                                        LPCTSTR lpszNameValue, int iDefault)
{
  HKEY hk;
  int   iRetValue = iDefault;

  // See if the key is present.
  if(RegOpenKey(hKey, lpszSubkey, &hk) == ERROR_SUCCESS)
    {
      iRetValue = GetIntFromSubkey(hk, lpszNameValue, iDefault);
      RegCloseKey(hk);
    }
  return(iRetValue);
}

BOOL NEAR PASCAL GetStringFromReg(HKEY   hKey,
                                        LPCTSTR lpszSubkey,
                                        LPCTSTR lpszValueName,
                                        LPCTSTR lpszDefault,
                                        LPTSTR lpszValue,
                                        DWORD cchSizeofValueBuff)
{
  HKEY hk;
  DWORD dwType;
  BOOL  fSuccess = FALSE;

  cchSizeofValueBuff *= sizeof(TCHAR);

  // See if the key is present.
  if(RegOpenKey(hKey, lpszSubkey, &hk) == ERROR_SUCCESS)
    {
      if((RegQueryValueEx(hk, lpszValueName, NULL, &dwType,
                        (LPBYTE)lpszValue,
                &cchSizeofValueBuff) == ERROR_SUCCESS) && cchSizeofValueBuff)
        {
          // BOGUS: This handles only the string type entries now!
#ifdef DEBUG
          if(dwType != REG_SZ)
            {
              OutputDebugString(TEXT("String type expected from Registry\n\r"));
            }
          else
#endif
            fSuccess = TRUE;
        }
      RegCloseKey(hk);
    }

  // If failure, use the default string.
  if(!fSuccess && lpszDefault)
      lstrcpy(lpszValue, lpszDefault);

#ifdef DEBUG
  RegDetails(0, hKey, lpszSubkey, lpszValueName, REG_SZ, lpszValue, 0);
#endif
  return(fSuccess);
}

//---------------------------------------------------------------------------
//
//  UpdateRegistry:
//      This updates a given value of any data type at a given
//      location in the registry.
//
//  The value name is passed in as an Id to a string in USER's String table.
//
//---------------------------------------------------------------------------

BOOL FAR PASCAL UpdateRegistry(HKEY     hKey,
                                LPCTSTR   lpszSubkey,
                                LPCTSTR   lpszValueName,
                                DWORD   dwDataType,
                                LPVOID  lpvData,
                                DWORD   dwDataSize)
{
  HKEY  hk;

  if(RegCreateKey(hKey, lpszSubkey, &hk) == ERROR_SUCCESS)
    {
      RegSetValueEx(hk, lpszValueName,
                        0L, dwDataType,
                        (const UCHAR *) lpvData,
                        dwDataSize);
#ifdef DEBUG
      RegDetails(1, hKey, lpszSubkey, lpszValueName, dwDataType, (LPTSTR)lpvData, (int)dwDataSize);
#endif
      RegCloseKey(hk);
      return(TRUE);
    }
  return(FALSE);
}

/*-------------------------------------------------------------
** force the update of the preview.
**-------------------------------------------------------------*/
void NEAR PASCAL UpdatePreview(HWND hDlg, WORD flags)
{
    if (IsDlgButtonChecked(hDlg, IDC_TILE))
        flags |= BP_TILE;

    SendDlgItemMessage(hDlg, IDC_BACKPREV, WM_SETBACKINFO, flags, 0L);

    if (!g_Back_bInit && !g_Back_bChanged)
    {
        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);

        g_Back_bChanged = TRUE;
    }
}

/*------------------------------------------------------------------
** read in all of the entries (LHS only) in a section.
**
** return: handle to local (fixed) memory containing names
**------------------------------------------------------------------*/
HANDLE PASCAL GetSection(LPTSTR lpIniFile, LPTSTR lpSection)
{
    int nCount;
    int cchSize = 4096;
    int cbSize = (cchSize * sizeof(TCHAR));
    HANDLE hLocal, hTemp;

    if (!(hLocal = LocalAlloc(LPTR, cbSize)))
        return(NULL);

    while (1)
    {
        nCount = GetPrivateProfileString(lpSection, NULL, g_szNULL, (LPTSTR)hLocal, cchSize, lpIniFile);

        if (nCount <= (cchSize-1))
            break;

        // need to grow the buffer
        cchSize += 2048;
        cbSize = (cchSize * sizeof(TCHAR));
        hTemp = hLocal;
        if (!(hLocal = LocalReAlloc(hTemp, cbSize, LMEM_MOVEABLE)))
        {
            LocalFree(hTemp);
            return(NULL);
        }
    }

    return(hLocal);
}

static void NukeExt(LPTSTR sz)
{
    int len;

    len = lstrlen(sz);

    if (len > 4 && sz[len-4] == TEXT('.'))
        sz[len-4] = 0;
}

static void AddExt(LPTSTR sz, LPTSTR x)
{
    int len;

    len = lstrlen(sz);

    if (len <= 4 || sz[len-4] != TEXT('.'))
    {
        lstrcat(sz, TEXT("."));
        lstrcat(sz, x);
    }
}

static void NameOnly(LPTSTR sz)
{
    LPTSTR p = sz;
    LPTSTR s = NULL;

    while( *p )
    {
        if( ( *p == TEXT('\\') ) || ( *p == TEXT(':') ) )
            s = p;
#if defined(DBCS) || (defined(FE_SB) && !defined(UNICODE))
        p = AnsiNext(p);
#else
        p++;
#endif
    }

    if( s )
    {
        p = sz;

        while( *s++ )
        {
            *p++ = *s;
        }
    }
}

static BOOL PathOnly(LPTSTR sz)
{
    LPTSTR p = sz;
    LPTSTR s = NULL;

    while( *p )
    {
        if( *p == TEXT('\\') )
        {
            s = p;
        }
        else if( *p == TEXT(':') )
        {
            s = p + 1;
        }
#if defined(DBCS) || (defined(FE_SB) && !defined(UNICODE))
        p = AnsiNext(p);
#else
        p++;
#endif
    }

    if( s )
    {
        if( s == sz )
            s++;

        *s = TEXT('\0');
        return TRUE;
    }

    return FALSE;
}

static LPTSTR NEAR PASCAL NiceName(LPTSTR sz)
{
    NukeExt(sz);

    if (IsCharUpper(sz[0]) && IsCharUpper(sz[1]))
    {
        CharLower(sz);
        CharUpperBuff(sz, 1);
    }

    return sz;
}

int NEAR PASCAL AddAFileToLB( HWND hwndList, LPCTSTR szDir, LPTSTR szFile )
{
    int index = LB_ERR;

    LPTSTR szPath = (LPTSTR)LocalAlloc( LPTR,
        (( szDir? lstrlen( szDir ) : 0 ) + lstrlen( szFile ) + 2) * sizeof(TCHAR) );

    if( szPath )
    {
        if( szDir )
        {
            lstrcpy( (LPTSTR)szPath, (LPTSTR)szDir );
            lstrcat( (LPTSTR)szPath, TEXT("\\") );
        }
        else
            *szPath = TEXT('\0');

        lstrcat( (LPTSTR)szPath, szFile );
        NameOnly( szFile );
        NiceName( szFile );

        index = (int)SendMessage( hwndList, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szFile );

        if( index >= 0 )
        {
            SendMessage( hwndList, LB_SETITEMDATA, (WPARAM)index,
                (LPARAM)(LPTSTR)szPath );
        }
        else
            LocalFree( (HANDLE)szPath );
    }

    return index;
}

void NEAR PASCAL AddFilesToLB(HWND hwndList, LPTSTR pszDir, LPTSTR szSpec)
{
    WIN32_FIND_DATA fd;
    HANDLE h;
    TCHAR szBuf[MAX_PATH];

    lstrcpy(szBuf, pszDir);
    lstrcat(szBuf, szSpec);

    h = FindFirstFile(szBuf, &fd);

    if (h != INVALID_HANDLE_VALUE)
    {
        do
        {
            AddAFileToLB(hwndList, pszDir, fd.cFileName);
        }
        while (FindNextFile(h, &fd));

        FindClose(h);
    }
}

/*-------------------------------------------------------------
** set a new wallpaper and notify the right places.
**
** the new name is in g_szCurWallpaper
**-------------------------------------------------------------*/
void NEAR PASCAL SetNewWallpaper(HWND hDlg, LPTSTR szFile, BOOL bCanAdd)
{
    HWND hwndList = GetDlgItem(hDlg, IDC_WALLLIST);

    if(!szFile || !lstrcmpi(szFile, g_szNone))
        szFile = TEXT("");

    if(
#if defined(DBCS) || (defined(FE_SB) && !defined(UNICODE))
        !IsDBCSLeadByte(szFile[0]) &&
#endif
        (szFile[1] == TEXT(':')) )
    {
        TCHAR szDrive[3];
        TCHAR szNet[MAX_PATH];
        ULONG lenNet = ARRAYSIZE(szNet);

        lstrcpyn(szDrive, szFile, ARRAYSIZE(szDrive));
        if ((NO_ERROR == WNetGetConnection(szDrive, szNet, &lenNet)) &&
            (szNet[0] == TEXT('\\')) && (szNet[1] == TEXT('\\')))
        {
            lstrcat(szNet, szFile+2);
            lstrcpy(szFile, szNet);
        }
    }

    lstrcpy(g_szCurWallpaper, szFile);
    UpdatePreview(hDlg, BP_NEWWALL);

    if(bCanAdd && *szFile && g_bValidBitmap)
    {
        TCHAR szName[MAX_PATH];
        int sel;

        lstrcpy(szName, szFile);
        NameOnly(szName);
        NiceName(szName);

        if ((sel = (int)SendMessage(hwndList, LB_FINDSTRINGEXACT, (WPARAM)-1,
            (LPARAM)(LPTSTR)szName)) == LB_ERR)
        {
            sel = AddAFileToLB(hwndList, NULL, szFile);
        }

        SendMessage(hwndList, LB_SETCURSEL, (WPARAM)sel, 0L);
    }

    {
        BOOL bEnable = (*szFile) ? TRUE : FALSE;

        EnableWindow( GetDlgItem(hDlg, IDC_TXT_DISPLAY), bEnable );
        EnableWindow( GetDlgItem(hDlg, IDC_TILE), bEnable );
        EnableWindow( GetDlgItem(hDlg, IDC_CENTER), bEnable );
    }
}

void NEAR PASCAL InitBackgroundDialog(HWND hDlg)
{
    HANDLE hSection;
    HWND hwndList;
    LPTSTR pszBuffer;
    TCHAR szBuf[MAX_PATH];
    TCHAR szCurPatBits[MAX_PATH];

    g_szCurPattern[0] = 0;
    g_szCurWallpaper[0] = 0;
    g_Back_bChanged = FALSE;

    /*
    ** initialize the pattern list
    */
    // get the current pattern.
    // GetProfileString(szDesktop, g_szPattern, g_szNULL, szCurPatBits, ARRAYSIZE(szCurPatBits));
    szCurPatBits[0] = 0; //Initialize
    GetStringFromReg(HKEY_CURRENT_USER, szRegStr_Desktop,
                                        g_szPattern, g_szNULL, szCurPatBits,
                                        ARRAYSIZE(szCurPatBits));
    if (!(*szCurPatBits))
        lstrcpy(g_szCurPattern, g_szNone);
    else
        *g_szCurPattern = 0;

    hwndList = GetDlgItem(hDlg, IDC_PATLIST);
    if (hSection = GetSection(g_szControlIni, g_szPatterns))
    {
        BOOL bAddedNone = FALSE;
        /* Put the patterns into the combo box. */
        for (pszBuffer = (LPTSTR) LocalLock(hSection); *pszBuffer; pszBuffer += (lstrlen(pszBuffer)+1))
        {
            if (GetPrivateProfileString(g_szPatterns, pszBuffer, g_szNULL, szBuf, ARRAYSIZE(szBuf), g_szControlIni))
            {
                BOOL bIsNone = !bAddedNone && !lstrcmpi( g_szNone, szBuf );

                /* if there's a right-hand side, add it to the list box */
                if( bIsNone || IsProbablyAValidPattern( szBuf ) )
                {
                    if( bIsNone )
                        bAddedNone = TRUE;

                    SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)pszBuffer);

                    // if haven't found current pattern name, maybe this is it.
                    if (!(*g_szCurPattern) && (!lstrcmpi(szBuf, szCurPatBits)))
                    {
                        // same pattern bits.  we have a name
                        lstrcpy(g_szCurPattern, pszBuffer);
                    }
                }
            }
        }
        LocalUnlock(hSection);
        LocalFree(hSection);
    }

    // if our patternTEXT('s bits weren')t in the list, use a fake name
    if (!(*g_szCurPattern))
        LoadString(hInstance, IDS_UNLISTEDPAT, g_szCurPattern, ARRAYSIZE(g_szCurPattern));

    SendMessage(hwndList, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)(LPTSTR)g_szCurPattern);
    UpdatePreview(hDlg, BP_NEWPAT);

    // exclude TEXT("none") pattern
    if( (int)SendDlgItemMessage(hDlg,IDC_PATLIST,LB_GETCURSEL,0,0l) <= 0 )
    {
        HWND epat = GetDlgItem( hDlg, IDC_EDITPAT );

        if( GetFocus() == epat )
        {
            SendMessage( hDlg, WM_NEXTDLGCTL,
                (WPARAM)GetDlgItem( hDlg, IDC_PATLIST ), (LPARAM)TRUE );
        }

        EnableWindow( epat, FALSE );
    }

    /*
    ** initialize the tile/center buttons
    */
    if(GetIntFromReg(HKEY_CURRENT_USER, szRegStr_Desktop, szTileWall, 1))
        CheckRadioButton(hDlg, IDC_CENTER, IDC_TILE, IDC_TILE);
    else
        CheckRadioButton(hDlg, IDC_CENTER, IDC_TILE, IDC_CENTER);

    /*
    ** initialize the wallpaper list
    */
    hwndList = GetDlgItem(hDlg, IDC_WALLLIST);

    if (!GetWindowsDirectory(szBuf, ARRAYSIZE(szBuf)))
    {
        szBuf[0] = 0;
    }

    // override with net home dir on shared copies of windows
    GetStringFromReg(HKEY_LOCAL_MACHINE, szRegStr_Setup, szSharedDir, (LPTSTR)NULL, szBuf, ARRAYSIZE(szBuf));
    AddFilesToLB(hwndList, szBuf, szBMP);

    //GetProfileString(szDesktop, szWallpaper, g_szNone, szBuf, sizeof(szBuf));
    GetStringFromReg(HKEY_CURRENT_USER, szRegStr_Desktop, szWallpaper, g_szNone, szBuf, ARRAYSIZE(szBuf));

    SetNewWallpaper(hDlg, szBuf, TRUE); // will add and select if not in list

    // and don't forget the 'none' option
    if (SendMessage(hwndList, LB_INSERTSTRING, 0, (LPARAM)(LPTSTR)g_szNone) !=
        LB_ERR)
    {
        int sel = (int)SendMessage(hwndList, LB_GETCURSEL, 0, 0L);

        if (sel == -1)
            sel = 0;

        SendMessage(hwndList, LB_SETCURSEL, (WPARAM)sel, 0L);
        if (!sel) {
            EnableWindow( GetDlgItem(hDlg, IDC_TILE), FALSE );
            EnableWindow( GetDlgItem(hDlg, IDC_CENTER), FALSE );
            EnableWindow( GetDlgItem(hDlg, IDC_TXT_DISPLAY), FALSE );
        }
    }

    // allow people to drag wallpapers to this page
    DragAcceptFiles(hDlg, TRUE);
}

//the intl tools cannot handle embedded nulls in strings
//hack: use the vertical bar and convert
void NEAR PASCAL
ConvertPipesToNull(LPTSTR szFilter)
{
#if defined(DBCS) || (defined(FE_SB) && !defined(UNICODE))
    if (IsDBCSLeadByte('|'))
        return;
#endif

    while (*szFilter)
    {
        LPTSTR p = CharNext(szFilter);

        if (*szFilter == TEXT('|'))
            *szFilter = TEXT('\0');

        szFilter = p;
    }
}

void NEAR PASCAL BrowseForWallpaper(HWND hDlg)
{
    TCHAR szPath[MAX_PATH];
    static TCHAR szWorkDir[MAX_PATH] = TEXT("");
    OPENFILENAME ofn;

    TCHAR szTitle[CCH_MAX_STRING];
    TCHAR szFilter[CCH_MAX_STRING];

    LoadString(hInstance, IDS_BROWSETITLE, szTitle, ARRAYSIZE(szTitle));
    if (LoadString(hInstance, IDS_BROWSEFILTER, szFilter, ARRAYSIZE(szFilter)))
        ConvertPipesToNull(szFilter);


    if (!PathOnly(szWorkDir))
    {
        if (!GetWindowsDirectory(szWorkDir, ARRAYSIZE(szWorkDir)))
        {
            szWorkDir[0] = 0;
        }
    }

    szPath[0] = TEXT('\0');

    ofn.lStructSize       = sizeof(ofn);
    ofn.hwndOwner         = hDlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex      = 1;
    ofn.nMaxCustFilter    = 0;
    ofn.lpstrFile         = szPath;
    ofn.nMaxFile          = ARRAYSIZE(szPath);
    ofn.lpstrInitialDir   = (szWorkDir[0] ? szWorkDir : NULL);
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
    ofn.lpfnHook          = NULL;
    ofn.lpstrDefExt       = szDefExt;
    ofn.lpstrFileTitle    = NULL;

    if (GetOpenFileName(&ofn) && (lstrcmpi(g_szCurWallpaper, szPath) != 0))
    {
        CharUpper(szPath); // will be nicenamed (best we can do...)
        SetNewWallpaper(hDlg, szPath, TRUE);
    }

    if (!GetCurrentDirectory(ARRAYSIZE(szWorkDir), szWorkDir))
    {
        szWorkDir[0] = 0;
    }
}

void NEAR PASCAL HandleWallpaperDrop(HWND hDlg, HDROP hDrop)
{
    TCHAR szPath[MAX_PATH];

    if (DragQueryFile(hDrop, 1, szPath, ARRAYSIZE(szPath)) &&
        (lstrcmpi(g_szCurWallpaper, szPath) != 0))
    {
        int len = lstrlen(szPath);

        if (len > 4 && !lstrcmpi(szPath+len-4, szDotBMP))
            SetNewWallpaper(hDlg, szPath, TRUE);
    }

    DragFinish(hDrop);
}


INT_PTR APIENTRY  BackgroundDlgProc(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;
    TCHAR szTiled[] = TEXT("0");
    TCHAR szBuf[MAX_PATH];
    TCHAR szBuf2[50];
    int  iTemp;

    switch(message)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_APPLY: {
                    DWORD dwRet = PSNRET_NOERROR;
                    if (g_Back_bChanged)
                    {
                        HCURSOR old = SetCursor( LoadCursor( NULL, IDC_WAIT ) );
                        HWND cover;

                        if (!g_bValidBitmap)
                        {
                            LoadString(hInstance, IDS_BADWALLPAPER, szBuf, ARRAYSIZE(szBuf));
                            GetWindowText(GetParent(hDlg), szBuf2, ARRAYSIZE(szBuf2));
                            MessageBox(hDlg, szBuf, szBuf2, MB_OK | MB_ICONEXCLAMATION);
                            dwRet = PSNRET_INVALID_NOCHANGEPAGE;
                        }

                        // do this after whimpering
                        cover = CreateCoverWindow( COVER_NOPAINT );

                        // need to write out tile first
                        szTiled[0] += (TCHAR)IsDlgButtonChecked(hDlg, IDC_TILE);
                        UpdateRegistry(HKEY_CURRENT_USER, szRegStr_Desktop,
                            szTileWall, REG_SZ, szTiled, SIZEOF(TCHAR)*(lstrlen(szTiled)+1));

                        if (g_bValidBitmap)
                        {
                            SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, g_szCurWallpaper,
                                SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
                        }

                        if (GetPrivateProfileString(g_szPatterns, g_szCurPattern, g_szNULL, szBuf, ARRAYSIZE(szBuf), g_szControlIni))
                        {
                            SystemParametersInfo(SPI_SETDESKPATTERN, 0, szBuf,
                                        SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
                        }

                        // we're back to no changes
                        g_Back_bChanged = FALSE;

                        if( cover )
                            PostMessage( cover, WM_CLOSE, 0, 0L );

                        SetCursor( old );
                    }
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, dwRet );
                    return TRUE;
                }

                case PSN_RESET:
                    break;
            }
            break;

        case WM_INITDIALOG:
            g_Back_bInit = TRUE;
            InitBackgroundDialog(hDlg);
            g_Back_bInit = FALSE;               // no longer initializing
            break;

        case WM_SYSCOLORCHANGE:
        case WM_DISPLAYCHANGE:
            g_Back_bInit = TRUE;    // fake init so we don't do PSM_CHANGED
            UpdatePreview(hDlg, BP_REINIT | BP_NEWPAT );
            g_Back_bInit = FALSE;
            break;

        case WM_DESTROY:
        {
            int count = (int)SendDlgItemMessage(hDlg, IDC_WALLLIST,
                LB_GETCOUNT, 0, 0L);

            while (count--)
            {
                LPTSTR sz = (LPTSTR)SendDlgItemMessage(hDlg, IDC_WALLLIST,
                    LB_GETITEMDATA, count, 0L);

                if (sz)
                    LocalFree ((HANDLE)sz);
            }
            break;
        }


        case WM_HELP:
            WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, TEXT("display.hlp"),
                HELP_WM_HELP, (DWORD_PTR) (LPTSTR) aBckgrndHelpIds);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, TEXT("display.hlp"), HELP_CONTEXTMENU,
                (DWORD_PTR) (LPTSTR) aBckgrndHelpIds);
            return TRUE;

        case WM_DROPFILES:
            HandleWallpaperDrop(hDlg, (HDROP)wParam);
            return TRUE;

        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            SendDlgItemMessage(hDlg, IDC_BACKPREV, message, wParam, lParam);
            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_PATLIST:
                    if(HIWORD(wParam) == LBN_SELCHANGE)
                    {
                        iTemp = (int)SendDlgItemMessage(hDlg,IDC_PATLIST,
                            LB_GETCURSEL,0,0l);
                        if(iTemp >= 0)
                        {
                            SendDlgItemMessage(hDlg, IDC_PATLIST, LB_GETTEXT,
                                iTemp, (LPARAM)(LPTSTR)szBuf);

                            if (lstrcmpi(szBuf, g_szCurPattern) == 0)
                                break;

                            lstrcpy(g_szCurPattern, szBuf);
                            UpdatePreview(hDlg, BP_NEWPAT);
                        }

                        EnableWindow( GetDlgItem( hDlg, IDC_EDITPAT ),
                            ( iTemp > 0 ) );  // exclude "none" pattern
                    }
                    break;

                case IDC_WALLLIST:
                    if(HIWORD(wParam) == LBN_SELCHANGE)
                    {
                        LPTSTR pBuf = NULL;

                        iTemp = (int)SendDlgItemMessage(hDlg,IDC_WALLLIST,
                            LB_GETCURSEL,0,0l);

                        if(iTemp >= 0)
                        {
                            pBuf = (LPTSTR)SendDlgItemMessage(hDlg,
                                IDC_WALLLIST, LB_GETITEMDATA, iTemp, 0L);
                        }

                        SetNewWallpaper(hDlg, pBuf, FALSE);
                    }
                    break;

                case IDC_CENTER:
                case IDC_TILE:
                    if ((HIWORD(wParam) == BN_CLICKED) &&
                                (!IsDlgButtonChecked(hDlg, LOWORD(wParam))))
                    {
                        CheckRadioButton(hDlg, IDC_CENTER, IDC_TILE, LOWORD(wParam));
                        UpdatePreview(hDlg, 0);
                    }
                    break;

                case IDC_BROWSEWALL:
                    BrowseForWallpaper(hDlg);
                    break;
            }
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskmon\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc

TARGETNAME = deskmon
TARGETPATH = obj
TARGETTYPE = DYNLINK
TARGETEXT  = dll


COFFBASE   = desk

DLLDEF=$(O)\deskmon.def


NO_BROWSER_FILE = 1

SOURCES_USED=..\sources.inc $(CCSHELL_DIR)\common.inc $(SOURCES_USED)

INCLUDES=$(INCLUDES);..;$(SDK_LIB_PATH);$(PROJECT_ROOT)\lib\$(O);$(PROJECT_ROOT)\inc\$(O);

SOURCES = ..\deskmon.rc   \
          ..\deskmon.cpp  \
          ..\propsext.cpp \
          ..\deskcmmn.cpp


# Dynamically loading comctl32 through shfusion.  Need to ignore "locally defined symbol imported" error. (LAmadio)
LINKER_FLAGS    = $(LINKER_FLAGS) -ignore:4049 -ignore:4217

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib         \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\gdi32.lib            \
           $(SDK_LIB_PATH)\ole32.lib            \
           $(SDK_LIB_PATH)\setupapi.lib         \
           $(SDK_LIB_PATH)\shlwapi.lib          \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\uuid.lib             \
           $(WINDOWS_LIB_PATH)\user32p.lib      \
           $(SHELL_LIB_PATH)\shfusion.lib



UMTYPE     = windows

USE_MSVCRT = 1

DLLENTRY   = DllMain

 
 
# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=WindowsShell 
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE=0000 
SXS_MANIFEST=WindowsShell.Manifest 
SXS_MANIFEST_IN_RESOURCES= 
SXS_MANIFEST_RESOURCE_ID=124 
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\debug.cpp ===
//
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "precomp.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "deskcpl"
#define SZ_MODULE           "DESKCPL"
#define DECLARE_DEBUG
#include "debug.h"


// Include the standard helper functions to dump common ADTs
//#include "..\lib\dump.c"


#ifdef DEBUG

//
// Typedefs
//
typedef struct _ALLOCHEADER {
    LIST_ENTRY  ListEntry;
    PTCHAR      File;
    ULONG       Line;
    LONG        AllocNumber;
    ULONG       Size;
} ALLOCHEADER, *PALLOCHEADER;


//
// Globals
//
LIST_ENTRY AllocListHead =
{
    &AllocListHead,
    &AllocListHead
};

#undef LocalAlloc
#undef LocalReAlloc
#undef LocalFree

INT g_BreakAtAlloc = -1;
INT g_BreakAtFree = -1;
ULONG g_AllocNumber = 0;

#define TRAP() DbgBreakPoint()

//*****************************************************************************
//
// MyAlloc()
//
//*****************************************************************************

HLOCAL
DeskAllocPrivate (
    const TCHAR *File,
    ULONG       Line,
    ULONG       Flags,
    DWORD       dwBytes
)
{
    static ULONG allocNumber = 0;
    DWORD bytes;
    PALLOCHEADER header;

    if (dwBytes) {
        bytes = dwBytes + sizeof(ALLOCHEADER);

        header = (PALLOCHEADER)LocalAlloc(Flags, bytes);

        if (header != NULL) {
            InsertTailList(&AllocListHead, &header->ListEntry);

            header->File = (TCHAR*) File;
            header->Line = Line;
            header->AllocNumber = ++allocNumber;
            header->Size = dwBytes;

            if (header->AllocNumber == g_BreakAtAlloc) {
                // user set assert
                TRAP();
            }

            return (HLOCAL)(header + 1);
        }
    }

    return NULL;
}

//*****************************************************************************
//
// MyReAlloc()
//
//*****************************************************************************

HLOCAL
DeskReAllocPrivate (
    const TCHAR *File,
    ULONG       Line,
    HLOCAL      hMem,
    DWORD       dwBytes,
    ULONG       Flags
    )
{
    PALLOCHEADER header;
    PALLOCHEADER headerNew;

    if (hMem)
    {
        header = (PALLOCHEADER)hMem;

        header--;

        // Remove the old address from the allocation list
        //
        RemoveEntryList(&header->ListEntry);

        headerNew = (PALLOCHEADER) LocalReAlloc((HLOCAL)header, dwBytes, Flags);

        if (headerNew != NULL)
        {
            // Add the new address to the allocation list
            //
            headerNew->File = (TCHAR*) File;
            headerNew->Line = Line;
            headerNew->AllocNumber = ++g_AllocNumber;
            headerNew->Size = dwBytes;

            if (headerNew->AllocNumber == g_BreakAtAlloc) {
                // user set assert
                TRAP();
            }

            InsertTailList(&AllocListHead, &headerNew->ListEntry);

            return (HLOCAL)(headerNew + 1);
        }
        else
        {
            // If GlobalReAlloc fails, the original memory is not freed,
            // and the original handle and pointer are still valid.
            // Add the old address back to the allocation list.
            //
            InsertTailList(&AllocListHead, &header->ListEntry);
        }

    }

    return NULL;
}


//*****************************************************************************
//
// MyFree()
//
//*****************************************************************************

HLOCAL
DeskFreePrivate (
    HLOCAL hMem
)
{
    PALLOCHEADER header;
    TCHAR buf[128];

    if (hMem)
    {
        header = (PALLOCHEADER)hMem;
        header--;

        if (header->AllocNumber == g_BreakAtFree) {
            TRAP();
        }

        wsprintf(buf, TEXT("free alloc number %d, size %d\r\n"), 
                 header->AllocNumber, header->Size);

        RemoveEntryList(&header->ListEntry);

        return LocalFree((HLOCAL)header);
    }
 
    return LocalFree(hMem);
}

HLOCAL  DeskFreeDirect (HLOCAL hMem)

{
    return(LocalFree(hMem));
}

//*****************************************************************************
//
// MyCheckForLeaks()
//
//*****************************************************************************

VOID
DeskCheckForLeaksPrivate (
    VOID
)
{
    PALLOCHEADER  header;
    TCHAR         buf[1024+40], tmpBuf[512];
    unsigned int  i, size, size2, ic;
    DWORD         *pdw;
    char          *pch, *pch2;
    LPVOID        mem;

#if UNICODE 
    #define DeskIsPrintable iswprint
#else
    #define DeskIsPrintable isprint
#endif

    while (!IsListEmpty(&AllocListHead))
    {
        header = (PALLOCHEADER)RemoveHeadList(&AllocListHead);
        mem = header + 1;
            
        wsprintf(buf, TEXT("Desk.cpl mem leak in File:  %s\r\n Line: %d Size:  %d  Allocation:  %d Buffer:  0x%x\r\n"),
                 header->File, header->Line, header->Size, header->AllocNumber, mem);
        OutputDebugString(buf);

        //
        // easy stuff, print out all the 4 DWORDS we can 
        //
        pdw = (DWORD *) mem;
        pch = (char *) mem;
        *buf = TEXT('\0');
        for (i = 0; i < header->Size/16; i++, pdw += 4) {
            wsprintf(tmpBuf, TEXT(" %08x %08x %08x %08x   "),
                     pdw[0], pdw[1], pdw[2], pdw[3]);
            lstrcat(buf, tmpBuf);

            for (ic = 0; ic < 16; ic++, pch++) {
                tmpBuf[ic] = DeskIsPrintable(*pch) ? *pch : TEXT('.');
            }
            tmpBuf[ic] =  TEXT('\0');
            lstrcat(buf, tmpBuf);
            OutputDebugString(buf);
            OutputDebugString(TEXT("\n"));

            *buf = TEXT('\0');
        }

        //
        // Is there less than a 16 byte chunk left?
        //
        size = header->Size % 16;
        if (size) {
            //
            // Print all the DWORDs we can
            //
            for (i = 0; i < size / 4; i++, pdw++) {
                wsprintf(tmpBuf, TEXT(" %08x"), *pdw);
                lstrcat(buf, tmpBuf);
            }

            if (size % 4) {
                // 
                // Print the remaining bytes
                // 
                lstrcat(buf, TEXT(" "));

                pch2 = (char*) pdw;
                for (i = 0; i < size % 4; i++, pch2++) {
                    wsprintf(tmpBuf, TEXT("%02x"), (DWORD) *pch2);
                    lstrcat(buf, tmpBuf);
                }

                //
                // Align with 4 bytes
                //
                for ( ; i < 4; i++) {
                    lstrcat(buf, TEXT("  "));
                }
            }

            //
            // Print blanks for any remaining DWORDs (ie to match the 4 above)
            //
            size2 = (16 - (header->Size % 16)) / 4;
            for (i = 0; i < size2; i++) {
                lstrcat(buf, TEXT("         "));
            }

            lstrcat(buf, TEXT("   "));
            
            //
            // Print the actual remain bytes as chars
            //
            for (i = 0; i < size; i++, pch++) {
                tmpBuf[i] = DeskIsPrintable(*pch) ? *pch : TEXT('.');
            }
            tmpBuf[i] = TEXT('\0');
            lstrcat(buf, tmpBuf);

            OutputDebugString(buf);
            OutputDebugString(TEXT("\n"));
        }

        OutputDebugString(TEXT("\n"));
        ASSERT(0);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskmon\resource.h ===
/******************************************************************************

  Source File:  Resource.H

  Resource Identifier Definitions for desktop monitor information

  Copyright (c) 1998 by Microsoft Corporation


******************************************************************************/

// Icon 
#define IDI_MONITOR           100


// Property sheet
#define PROP_SHEET_DLG                200
#define IDC_MONITOR_GRP               201
#define IDC_MONITORDESC               202
#define IDC_MONSET_GRP                203
#define IDC_MONSET_FREQSTR            204
#define IDC_MONSET_FREQ               205
#define IDC_PANEL_GRP                 206
#define IDC_PROPERTIES	              207
#define IDC_MONSET_PRUNNING_MODE      208
#define IDC_MONSET_PRUNNING_MODE_DESC 209
#define IDC_MONITORS_LIST             210

// Strings
#define IDS_PAGE_TITLE          1
#define IDS_INTERLACED        301
#define IDS_FREQ              302
#define IDS_DEFFREQ           303
#define IDS_BAD_REFRESH       304
#define IDS_MODE_UNSETTABLE   305
#define IDS_DEFAULT_MONITOR   306

// help
#define IDH_NOHELP                                                  ((DWORD)-1)
#define IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_TYPE                  4165
#define IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_REFRESH               4166
#define IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_PROPERTIES            4168
#define IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_HIDEMODE_CHECKBOX     4169
#define IDH_DISPLAY_SETTINGS_ADVANCED_MONITOR_MONITORTYPE_LISTBOX   4171
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\deskcmmn.cpp ===
#include "precomp.h"

#include "..\..\common\deskcmmn.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\deskdbg.h ===
#ifdef __cplusplus
extern "C" {
#endif

#if DEBUG

#define LocalAlloc(flags, dwBytes)   DeskAllocPrivate(TEXT(__FILE__), __LINE__, flags, (dwBytes))
#define LocalReAlloc(hMem, dwBytes, flags)  DeskReAllocPrivate(TEXT(__FILE__), __LINE__, (hMem), (dwBytes), flags)
#define LocalFree(hMem)              DeskFreePrivate((hMem))
#define DeskCheckForLeaks()         DeskCheckForLeaksPrivate()
#define DirectLocalFree(hMem)       DeskFreeDirect((hMem))

#define ODS(sz) (OutputDebugStringA(sz), OutputDebugStringA("\r\n"))

#else

#define DirectLocalFree(hMem)       LocalFree((hMem))

#define ODS(sz)

#endif

HLOCAL
DeskAllocPrivate(const TCHAR *File, ULONG Line, ULONG Flags, DWORD dwBytes);

HLOCAL
DeskReAllocPrivate(const TCHAR *File, ULONG Line, HLOCAL hMem, DWORD dwBytes, ULONG Flags);

HLOCAL
DeskFreePrivate(HLOCAL hMem);

HLOCAL
DeskFreeDirect(HLOCAL hMem);

VOID
DeskCheckForLeaksPrivate(VOID);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\desk.cpp ===
#include "precomp.h"
#include "winuser.h"
#include <shdguid.h>            // For CLSID_CDeskHtmlProp
#include <shlwapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapip.h>
#include <regapi.h>
#include <ctxdef.h> // hydra stuff
#include <cowsite.h>
#include <theme.h>

#include "cplext.h"
#include "cplp.h"


HWND g_hDlg = NULL;


///////////////////////////////////////////////////////////////////////////////
// Array defining each page in the sheet
///////////////////////////////////////////////////////////////////////////////

typedef struct {
    int id;
    DLGPROC pfnDlgProc;
    RESTRICTIONS dwPolicy1;
    RESTRICTIONS dwPolicy2;
    long nExtensionID;          // The page
} PAGEINFO;

PAGEINFO aPageInfo[] = {
    { 0,                NULL,               REST_NODISPLAYAPPEARANCEPAGE, REST_NOTHEMESTAB, PAGE_DISPLAY_THEMES},       // Theme page
    { DLG_BACKGROUND,   BackgroundDlgProc,  REST_NODISPBACKGROUND, (RESTRICTIONS)0, 0},                                               // Background page
    { DLG_SCREENSAVER,  NULL,               REST_NODISPSCREENSAVEPG, (RESTRICTIONS)0, 0},                                             // Screen Saver page
    { 0,                NULL,               REST_NODISPLAYAPPEARANCEPAGE, (RESTRICTIONS)0, PAGE_DISPLAY_APPEARANCE},                  // Appearance page
    { 0,                NULL,               REST_NODISPSETTINGSPG, (RESTRICTIONS)0, PAGE_DISPLAY_SETTINGS},                           // Settings page
};

#define C_PAGES_DESK    ARRAYSIZE(aPageInfo)
#define IPI_SETTINGS    (C_PAGES_DESK-1)        // Index to "Settings" page
#define WALLPAPER     L"Wallpaper"

#define EnableApplyButton(hdlg) PropSheet_Changed(GetParent(hdlg), hdlg)


IThemeUIPages * g_pThemeUI = NULL;

// Local Constant Declarations
static const TCHAR sc_szCoverClass[] = TEXT("DeskSaysNoPeekingItsASurprise");
LRESULT CALLBACK CoverWindowProc( HWND, UINT, WPARAM, LPARAM );

// These are actions that can be passed in the cmdline.
// FORMAT: "/Action:<ActionType>" 
#define DESKACTION_NONE             0x00000000
#define DESKACTION_OPENTHEME        0x00000001
#define DESKACTION_OPENMSTHEM       0x00000002

///////////////////////////////////////////////////////////////////////////////
// Globals
///////////////////////////////////////////////////////////////////////////////

TCHAR gszDeskCaption[CCH_MAX_STRING];

TCHAR g_szNULL[] = TEXT("");
TCHAR g_szControlIni[] = TEXT("control.ini");
TCHAR g_szPatterns[] = TEXT("patterns") ;
TCHAR g_szNone[CCH_NONE];                      // this is the '(None)' string
TCHAR g_szSystemIni[] = TEXT("system.ini");
TCHAR g_szWindows[] = TEXT("Windows");

TCHAR szRegStr_Colors[] = REGSTR_PATH_COLORS;

HDC g_hdcMem = NULL;
HBITMAP g_hbmDefault = NULL;
BOOL g_bMirroredOS = FALSE;

///////////////////////////////////////////////////////////////////////////////
// Externs
///////////////////////////////////////////////////////////////////////////////
extern BOOL NEAR PASCAL GetStringFromReg(HKEY   hKey,
                                        LPCTSTR lpszSubkey,
                                        LPCTSTR lpszValueName,
                                        LPCTSTR lpszDefault,
                                        LPTSTR lpszValue,
                                        DWORD cchSizeofValueBuff);



//============================================================================================================
// Class
//============================================================================================================
class CDisplayControlPanel      : public CObjectWithSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);


    void DisplayDialog(HINSTANCE hInst, HWND hwndParent, LPCTSTR pszCmdline);

    CDisplayControlPanel(void);
    virtual ~CDisplayControlPanel(void);

private:
    // Private Member Variables
    long                    m_cRef;
    HANDLE                  m_hBackgroundThreads;

    void _ShowDialog(HINSTANCE hInst, HWND hwndParent, LPCTSTR pszCmdline);
};



/*---------------------------------------------------------
**
**---------------------------------------------------------*/
BOOL NEAR PASCAL CreateGlobals()
{
    WNDCLASS wc;
    HBITMAP hbm;
    HDC hdc;

    //
    // Check if the mirroring APIs exist on the current
    // platform.
    //
    g_bMirroredOS = IS_MIRRORING_ENABLED();

    if( !GetClassInfo( hInstance, sc_szCoverClass, &wc ) )
    {
        // if two pages put one up, share one dc
        wc.style = CS_CLASSDC;
        wc.lpfnWndProc = CoverWindowProc;
        wc.cbClsExtra = wc.cbWndExtra = 0;
        wc.hInstance = hInstance;
        wc.hIcon = (HICON)( wc.hCursor = NULL );
        // use a real brush since user will try to paint us when we're "hung"
        wc.hbrBackground = (HBRUSH) GetStockObject( NULL_BRUSH );
        wc.lpszMenuName = NULL;
        wc.lpszClassName = sc_szCoverClass;

        if( !RegisterClass( &wc ) )
            return FALSE;
    }

    hdc = GetDC(NULL);
    g_hdcMem = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);

    if (!g_hdcMem)
        return FALSE;

    hbm = CreateBitmap(1, 1, 1, 1, NULL);
    if (hbm)
    {
        g_hbmDefault = (HBITMAP) SelectObject(g_hdcMem, hbm);
        SelectObject(g_hdcMem, g_hbmDefault);
        DeleteObject(hbm);
    }

    LoadString(hInstance, IDS_NONE, g_szNone, ARRAYSIZE(g_szNone));

    return TRUE;
}


BOOL AreExtraMonitorsDisabledOnPersonal(void)
{
    BOOL fIsDisabled = IsOS(OS_PERSONAL);

    if (fIsDisabled)
    {
        // TODO: Insert call to SystemParametersInfo() to see if there are video cards that we had to disable.
        fIsDisabled = FALSE;
    }

    return fIsDisabled;
}


/*---------------------------------------------------------
**
**---------------------------------------------------------*/

HBITMAP FAR LoadMonitorBitmap( BOOL bFillDesktop )
{
    HBITMAP hbm = NULL;

    if (g_pThemeUI)
    {
        g_pThemeUI->LoadMonitorBitmap(bFillDesktop, &hbm);
    }
    
    return hbm;
}

int DisplaySaveSettings(PVOID pContext, HWND hwnd)
{
    int iRet = 0;

    if (g_pThemeUI)
    {
        g_pThemeUI->DisplaySaveSettings(pContext, hwnd, &iRet);
    }
    
    return iRet;
}

///////////////////////////////////////////////////////////////////////////////
//
// Messagebox wrapper
//
//
///////////////////////////////////////////////////////////////////////////////


int
FmtMessageBox(
    HWND hwnd,
    UINT fuStyle,
    DWORD dwTitleID,
    DWORD dwTextID)
{
    TCHAR Title[256];
    TCHAR Text[2000];

    LoadString(hInstance, dwTextID, Text, ARRAYSIZE(Text));
    LoadString(hInstance, dwTitleID, Title, ARRAYSIZE(Title));

    return (ShellMessageBox(hInstance, hwnd, Text, Title, fuStyle));
}

///////////////////////////////////////////////////////////////////////////////
//
// InstallScreenSaver
//
// Provides a RUNDLL32-callable routine to install a screen saver
//
///////////////////////////////////////////////////////////////////////////////


#ifdef UNICODE
//
// Windows NT:
//
// Thunk ANSI version to the Unicode function
//
void WINAPI InstallScreenSaverW( HWND wnd, HINSTANCE inst, LPWSTR cmd, int shw );

void WINAPI InstallScreenSaverA( HWND wnd, HINSTANCE inst, LPSTR cmd, int shw )
{
    LPWSTR  pwszCmd;
    int     cch;

    cch = MultiByteToWideChar( CP_ACP, 0, cmd, -1, NULL, 0);
    if (cch == 0)
        return;

    pwszCmd = (LPWSTR) LocalAlloc( LMEM_FIXED, cch * SIZEOF(TCHAR) );
    if (pwszCmd == NULL)
        return;

    if (0 != MultiByteToWideChar( CP_ACP, 0, cmd, -1, pwszCmd, cch))
    {
        InstallScreenSaverW(wnd, inst, pwszCmd, shw);
    }

    LocalFree(pwszCmd);
}

#   define REAL_INSTALL_SCREEN_SAVER   InstallScreenSaverW

#else

//
// Windows 95:
//
// Stub out Unicode version
//
void WINAPI InstallScreenSaverW( HWND wnd, HINSTANCE inst, LPWSTR cmd, int shw )
{
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return;
}

#   define REAL_INSTALL_SCREEN_SAVER   InstallScreenSaverA

#endif


void WINAPI REAL_INSTALL_SCREEN_SAVER( HWND wnd, HINSTANCE inst, LPTSTR cmd, int shw )
{
    TCHAR buf[ MAX_PATH ];
    int timeout;

    lstrcpy( buf, cmd );
    PathGetShortPath( buf ); // so msscenes doesn't die
    WritePrivateProfileString( TEXT("boot"), TEXT("SCRNSAVE.EXE"), buf, TEXT("system.ini") );

    SystemParametersInfo( SPI_SETSCREENSAVEACTIVE, TRUE, NULL,
        SPIF_UPDATEINIFILE );

    // make sure the user has a reasonable timeout set
    SystemParametersInfo( SPI_GETSCREENSAVETIMEOUT, 0, &timeout, 0 );
    if( timeout <= 0 )
    {
        // 15 minutes seems like a nice default
        SystemParametersInfo( SPI_SETSCREENSAVETIMEOUT, 900, NULL,
            SPIF_UPDATEINIFILE );
    }

    // bring up the screen saver page on our rundll
#ifdef UNICODE
    Control_RunDLLW( wnd, inst, TEXT("DESK.CPL,,1"), shw );
#else
    Control_RunDLL( wnd, inst, TEXT("DESK.CPL,,1"), shw );
#endif
}

/*****************************************************************************\
*
* DeskInitCpl( void )
*
\*****************************************************************************/

BOOL DeskInitCpl(void) {

    //
    // Private Debug stuff
    //
#if ANDREVA_DBG
    g_dwTraceFlags = 0xFFFFFFFF;
#endif


    InitCommonControls();

    CreateGlobals();

    return TRUE;
}


HRESULT OpenAdvancedDialog(HWND hDlg, const CLSID * pClsid)
{
    HRESULT hr = E_FAIL;
    IEnumUnknown * pEnumUnknown;

    hr = g_pThemeUI->GetBasePagesEnum(&pEnumUnknown);
    if (SUCCEEDED(hr))
    {
        IUnknown * punk;

        hr = IEnumUnknown_FindCLSID(pEnumUnknown, *pClsid, &punk);
        if (SUCCEEDED(hr))
        {
            IBasePropPage * pBasePage;

            hr = punk->QueryInterface(IID_PPV_ARG(IBasePropPage, &pBasePage));
            if (SUCCEEDED(hr))
            {
                IPropertyBag * pPropertyBag;

                hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
                if (SUCCEEDED(hr))
                {
                    if (IsEqualCLSID(PPID_Background, *pClsid))
                    {
                        // We are going to treat the Background tab differently.  We tell it to open
                        // the advanced dialog.  We do this so it can close the dialog if the user
                        // clicks to open the Gallery and we need the CPL to close.
                        hr = SHPropertyBag_WriteBOOL(pPropertyBag, SZ_PBPROP_OPENADVANCEDDLG, TRUE);
                    }
                    else
                    {
                        IAdvancedDialog * pAdvAppearDialog;

                        hr = pBasePage->GetAdvancedDialog(&pAdvAppearDialog);
                        if (SUCCEEDED(hr))
                        {
                            BOOL fEnableApply = FALSE;

                            hr = pAdvAppearDialog->DisplayAdvancedDialog(hDlg, pPropertyBag, &fEnableApply);
                            if (SUCCEEDED(hr) && fEnableApply)
                            {
                                EnableApplyButton(hDlg);
                                g_pThemeUI->UpdatePreview(0);   // The Preview settings may have changed.
                            }

                            pAdvAppearDialog->Release();
                        }
                    }

                    pPropertyBag->Release();
                }

                pBasePage->Release();
            }

            punk->Release();
        }

        pEnumUnknown->Release();
    }

    return hr;
}


HRESULT SetAdvStartPage(LPTSTR pszStartPage, DWORD cchSize)
{
    HRESULT hr = S_OK;

    // Does the caller want us to open the advanced dialog to a certain tab?
    if (g_pThemeUI)
    {
        // Yes, so open the dialog.
        if (!StrCmpI(pszStartPage, TEXT("Theme Settings")))
        {
            OpenAdvancedDialog(g_hDlg, &PPID_Theme);
        }
        else if (!StrCmpI(pszStartPage, TEXT("Appearance")))
        {
            OpenAdvancedDialog(g_hDlg, &PPID_BaseAppearance);
        }
        else if (!StrCmpI(pszStartPage, TEXT("Web")))
        {
            OpenAdvancedDialog(g_hDlg, &PPID_Background);
            StrCpyNW(pszStartPage, L"Desktop", cchSize);
        }
    }

    return hr;
}


typedef struct
{
    LPCTSTR pszCanonical;
    UINT nResourceID;
} CANONICAL_TO_LOCALIZE_TABMAPPING;

CANONICAL_TO_LOCALIZE_TABMAPPING s_TabMapping[] =
{
    {SZ_DISPLAYCPL_OPENTO_THEMES, IDS_TAB_THEMES},
    {SZ_DISPLAYCPL_OPENTO_DESKTOP, IDS_TAB_DESKTOP},
    {TEXT("Background"), IDS_TAB_DESKTOP},                          // These are other names people may use
    {TEXT("Screen Saver"), IDS_TAB_SCREENSAVER},                    // These are other names people may use
    {SZ_DISPLAYCPL_OPENTO_SCREENSAVER, IDS_TAB_SCREENSAVER},
    {SZ_DISPLAYCPL_OPENTO_APPEARANCE, IDS_TAB_APPEARANCE},
    {SZ_DISPLAYCPL_OPENTO_SETTINGS, IDS_TAB_SETTINGS},
};

HRESULT _TabCanonicalToLocalized(IN OUT LPTSTR pszStartPage, DWORD cchSize)
{
    HRESULT hr = S_OK;

    // pszStartPage is an in AND out param
    for (int nIndex = 0; nIndex < ARRAYSIZE(s_TabMapping); nIndex++)
    {
        if (!StrCmpI(s_TabMapping[nIndex].pszCanonical, pszStartPage))
        {
            if (0 == s_TabMapping[nIndex].nResourceID)
            {
                hr = E_FAIL;
            }
            else
            {
                LoadString(hInstance, s_TabMapping[nIndex].nResourceID, pszStartPage, cchSize);
            }
            break;
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// SetStartPage checks the command line for start page by name.
///////////////////////////////////////////////////////////////////////////////
#define SZ_ACTIONFLAG_THEME     TEXT("/Action:OpenTheme")
#define SZ_ACTIONFLAG_MSTHEME   TEXT("/Action:OpenMSTheme")

#define SZ_FILEFLAG           TEXT("/File:\"")

void SetStartPage(PROPSHEETHEADER *ppsh, LPCTSTR pszCmdLine, DWORD * pdwAction, LPTSTR pszPath, DWORD cchPathSize, LPTSTR pszStartPage, DWORD cchSize)
{
    StrCpyNW(pszPath, L"", cchPathSize);
    StrCpyNW(pszStartPage, L"", cchSize);
    if (pszCmdLine)
    {
        // Strip spaces
        while (*pszCmdLine == TEXT(' '))
        {
            pszCmdLine++;
        }

        // Check for @ sign.
        if (*pszCmdLine == TEXT('@'))
        {
            LPCTSTR pszBegin;
            BOOL fInQuote = FALSE;
            int cchLen;

            pszCmdLine++;

            // Skip past a quote
            if (*pszCmdLine == TEXT('"'))
            {
                pszCmdLine++;
                fInQuote = TRUE;
            }

            // Save the beginning of the name.
            pszBegin = pszCmdLine;

            // Find the end of the name.
            while (pszCmdLine[0] &&
                   (fInQuote || (pszCmdLine[0] != TEXT(' '))) &&
                   (!fInQuote || (pszCmdLine[0] != TEXT('"'))))
            {
                pszCmdLine++;
            }
            cchLen = (int)(pszCmdLine - pszBegin);

            TCHAR szStartPage[MAX_PATH];

            StrCpyN(szStartPage, pszBegin, cchLen+1);
            SetAdvStartPage(szStartPage, ARRAYSIZE(szStartPage));

            // Store the name in the pStartPage field.
            StrCpyN(pszStartPage, szStartPage, cchSize);

            if (StrStrIW(pszCmdLine, SZ_ACTIONFLAG_THEME) || StrStrW(pszCmdLine, SZ_ACTIONFLAG_MSTHEME))
            {
                *pdwAction = (StrStrW(pszCmdLine, SZ_ACTIONFLAG_THEME) ? DESKACTION_OPENTHEME : DESKACTION_OPENMSTHEM);

                pszCmdLine = StrStrIW(pszCmdLine, SZ_FILEFLAG);
                if (pszCmdLine)
                {
                    pszCmdLine += (ARRAYSIZE(SZ_FILEFLAG) - 1);   // Skip past flag

                    LPCWSTR pszEnd = StrStrIW(pszCmdLine, L"\"");
                    if (pszEnd)
                    {
                        DWORD cchSize = (DWORD)((pszEnd - pszCmdLine) + 1);
                        StrCpyNW(pszPath, pszCmdLine, min(cchPathSize, cchSize));
                    }
                }
            }

            if (SUCCEEDED(_TabCanonicalToLocalized(pszStartPage, cchSize)))        // The caller passes a canonical name but the propsheet wants to localized name
            {
                ppsh->dwFlags |= PSH_USEPSTARTPAGE;
                ppsh->pStartPage = pszStartPage;
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// _AddDisplayPropSheetPage  adds pages for outside callers...
///////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK _AddDisplayPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER FAR * ppsh = (PROPSHEETHEADER FAR *) lParam;

    if (ppsh)
    {
        if (hpage && (ppsh->nPages < MAX_PAGES))
        {
            ppsh->phpage[ppsh->nPages++] = hpage;
            return TRUE;
        }
    }

    return FALSE;
}



static int
GetClInt( const TCHAR *p )
{
    BOOL neg = FALSE;
    int v = 0;

    while( *p == TEXT(' ') )
        p++;                        // skip spaces

    if( *p == TEXT('-') )                 // is it negative?
    {
        neg = TRUE;                     // yes, remember that
        p++;                            // skip '-' char
    }

    // parse the absolute portion
    while( ( *p >= TEXT('0') ) && ( *p <= TEXT('9') ) )     // digits only
        v = v * 10 + *p++ - TEXT('0');    // accumulate the value

    return ( neg? -v : v );         // return the result
}



BOOL CheckRestrictionPage(const PAGEINFO * pPageInfo)
{
    BOOL fRestricted = SHRestricted(pPageInfo->dwPolicy1);

    if (!fRestricted && pPageInfo->dwPolicy2)
    {
        fRestricted = SHRestricted(pPageInfo->dwPolicy2);
    }

    return fRestricted;
}


///////////////////////////////////////////////////////////////////////////////
// CreateReplaceableHPSXA creates a new hpsxa that contains only the
// interfaces with valid ReplacePage methods.
// APPCOMPAT - EzDesk only implemented AddPages.  ReplacePage is NULL for them.
///////////////////////////////////////////////////////////////////////////////

typedef struct {
    UINT count, alloc;
    IShellPropSheetExt *interfaces[0];
} PSXA;

HPSXA
CreateReplaceableHPSXA(HPSXA hpsxa)
{
    PSXA *psxa = (PSXA *)hpsxa;
    DWORD cb = SIZEOF(PSXA) + SIZEOF(IShellPropSheetExt *) * psxa->alloc;
    PSXA *psxaRet = (PSXA *)LocalAlloc(LPTR, cb);

    if (psxaRet)
    {
        UINT i;

        psxaRet->count = 0;
        psxaRet->alloc = psxa->alloc;

        for (i=0; i<psxa->count; i++)
        {
            if (psxa->interfaces[i])
            {
                psxaRet->interfaces[psxaRet->count++] = psxa->interfaces[i];
            }
        }
    }

    return (HPSXA)psxaRet;
}


BOOL HideBackgroundTabOnTermServices(void)
{
    BOOL fHideThisPage = FALSE;
    TCHAR   szSessionName[WINSTATIONNAME_LENGTH * 2];
    TCHAR   szWallPaper[MAX_PATH*2];
    TCHAR   szBuf[MAX_PATH*2];
    TCHAR   szActualValue[MAX_PATH*2];
    DWORD   dwLen;
    DWORD   i;

    ZeroMemory((PVOID)szSessionName,sizeof(szSessionName));
    dwLen = GetEnvironmentVariable(TEXT("SESSIONNAME"), szSessionName, ARRAYSIZE(szSessionName));
    if (dwLen != 0)
    {
        // Now that we have the session name, search for the # character.
        for(i = 0; i < dwLen; i++)
        {
            if (szSessionName[i] == TEXT('#'))
            {
                szSessionName[i] = TEXT('\0');
                break;
            }
        }

        // Here is what we are looking for in NT5:
        //  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\
        //      WinStations\RDP-Tcp\UserOverride\Control Panel\Desktop
        //
        // The value is:
        //      Wallpaper
        //
        lstrcpy(szWallPaper,WALLPAPER);
        lstrcpy(szBuf, WINSTATION_REG_NAME );  
        lstrcat(szBuf, L"\\" );
        lstrcat(szBuf, szSessionName );
        lstrcat(szBuf, L"\\" );
        lstrcat(szBuf, WIN_USEROVERRIDE );
        lstrcat(szBuf, L"\\" );
        lstrcat(szBuf, REGSTR_PATH_DESKTOP );   // Control Panel\\Desktop

        // See if we can get the wallpaper string.  This will fail if the key
        // doesn't exist.  This means the policy isn't set.
        //
        //                                 hKey, lpszSubkey, lpszValueName, lpszDefault, 
        if (GetStringFromReg(HKEY_LOCAL_MACHINE, szBuf,      szWallPaper,   TEXT(""),    
                                // lpszValue,     cchSizeofValueBuff)
                                   szActualValue, ARRAYSIZE(szActualValue)))
        {
            fHideThisPage = TRUE;
        }
    }

    return fHideThisPage;
}


HRESULT AddPropSheetExtArrayToThemePageUI(IThemeUIPages * pThemeUI, HPSXA hpsxa)
{
    HRESULT hr = E_INVALIDARG;

    if (pThemeUI && hpsxa)
    {
        PSXA *psxa = (PSXA *)hpsxa;
        IShellPropSheetExt **spsx = psxa->interfaces;
        UINT nIndex;

        for (nIndex = 0; nIndex < psxa->count; nIndex++)
        {
            if (psxa->interfaces[nIndex])
            {
                IBasePropPage * pBasePropPage;

                if (SUCCEEDED(psxa->interfaces[nIndex]->QueryInterface(IID_PPV_ARG(IBasePropPage, &pBasePropPage))))
                {
                    pThemeUI->AddBasePage(pBasePropPage);
                    pBasePropPage->Release();
                }
            }
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        If the caller gave the page index, we need to open to that page.  The
    order of the pages has changed from Win2k to Whistler, so map the indexes.

    Win2K:
    Index 0: Background
    Index 1: Screen Saver
    Index 2: Appearance
       None: Web
       None: Effects
    Index 3: Settings (Index 3)

    Whistler: (Base Dlg)
       None: Themes
    Index 0: Background
    Index 1: Screen Saver
    Index 2: Appearance
    Index 3: Settings

    Whistler: (Adv Dlg)
       None: Themes Settings
       None: Adv Appearance
       None: Web
       None: Effects
\*****************************************************************************/
int UpgradeStartPageMappping(LPTSTR pszCmdLine, DWORD cchSize)
{
    int nNewStartPage = GetClInt(pszCmdLine);

    if (pszCmdLine)
    {
        switch (nNewStartPage)
        {
        case 0:         // Background
            StrCpyN(pszCmdLine, TEXT("@Desktop"), cchSize);
            break;
        case 1:         // Screen Saver
            StrCpyN(pszCmdLine, TEXT("@ScreenSaver"), cchSize);
            break;
        case 2:         // Screen Saver
            StrCpyN(pszCmdLine, TEXT("@ScreenSaver"), cchSize);
            break;
        case 3:         // Settings
            StrCpyN(pszCmdLine, TEXT("@Settings"), cchSize);
            break;
        default:
            return nNewStartPage;
            break;
        }
    }
    else
    {
        return nNewStartPage;
    }

    return 0;
}


#define DestroyReplaceableHPSXA(hpsxa) LocalFree((HLOCAL)hpsxa)

/*****************************************************************************\
*
* DeskShowPropSheet( HWND hwndParent )
*
\*****************************************************************************/
typedef HRESULT (*LPFNCOINIT)(LPVOID);
typedef HRESULT (*LPFNCOUNINIT)(void);

int ComputeNumberOfDisplayDevices();


void DeskShowPropSheet(HINSTANCE hInst, HWND hwndParent, LPCTSTR pszCmdline)
{
    CDisplayControlPanel displayCPL;

    displayCPL.DisplayDialog(hInst, hwndParent, pszCmdline);
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CDisplayControlPanel::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CDisplayControlPanel::Release()
{
    if (InterlockedDecrement(&m_cRef))
    {
        if ((1 == m_cRef) && m_hBackgroundThreads)
        {
            SetEvent(m_hBackgroundThreads);
        }

        return m_cRef;
    }

    delete this;
    return 0;
}


HRESULT CDisplayControlPanel::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] = {
        QITABENT(CDisplayControlPanel, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}



CDisplayControlPanel::CDisplayControlPanel(void) : m_cRef(1)
{
    m_hBackgroundThreads = NULL;
}


CDisplayControlPanel::~CDisplayControlPanel(void)
{
    if (m_hBackgroundThreads)
    {
        CloseHandle(m_hBackgroundThreads);
        m_hBackgroundThreads = NULL;
    }
}


// Wait 30 seconds for hung apps to process our message before we give up.
// It would be nice to wait longer, but if the user tries to launch the Display
// Control Panel again, it will not launch because we are still running.  The only
// thing that we will give up on doing after 30 seconds it notifying apps.  In the worse
// case the user will need to log-off and back in to get apps to refresh.
#define MAX_WAITFORHUNGAPPS         (30)

void CDisplayControlPanel::DisplayDialog(HINSTANCE hInst, HWND hwndParent, LPCTSTR pszCmdline)
{
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        SHSetInstanceExplorer(SAFECAST(this, IUnknown *));
        _ShowDialog(hInst, hwndParent, pszCmdline);

        // Wait until the background threads finish.
        if (m_cRef > 1)
        {
            m_hBackgroundThreads = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (m_hBackgroundThreads && (m_cRef > 1))
            {
                DWORD dwResult = SHProcessMessagesUntilEvent(NULL, m_hBackgroundThreads, (MAX_WAITFORHUNGAPPS * 1000));

                if (WAIT_TIMEOUT == dwResult)
                {
                    TraceMsg(TF_GENERAL, "A thread hung and we needed to shutdown while it was still running.");
                }
                Sleep(100);
            }
        }

        SHSetInstanceExplorer(NULL);
        CoUninitialize();
    }
}


void CDisplayControlPanel::_ShowDialog(HINSTANCE hInst, HWND hwndParent, LPCTSTR pszCmdline)
{
    HPROPSHEETPAGE hpsp, ahPages[MAX_PAGES];
    HPSXA hpsxa = NULL;
    PROPSHEETPAGE psp;
    PROPSHEETHEADER psh;
    int i;
    DWORD exitparam = 0UL;
    HRESULT hr = S_OK;
    TCHAR szCmdLine[MAX_PATH];

    StrCpyN(szCmdLine, (pszCmdline ? pszCmdline : TEXT("")), ARRAYSIZE(szCmdLine));

    // check if whole sheet is locked out
    if (SHRestricted(REST_NODISPLAYCPL))
    {
        TCHAR szMessage[255],szTitle[255];

        LoadString( hInst, IDS_DISPLAY_DISABLED, szMessage, ARRAYSIZE(szMessage) );
        LoadString( hInst, IDS_DISPLAY_TITLE, szTitle, ARRAYSIZE(szTitle) );

        MessageBox( hwndParent, szMessage, szTitle, MB_OK | MB_ICONINFORMATION );
        return;
    }

    // Create the property sheet
    ZeroMemory(&psh, sizeof(psh));

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = (PSH_PROPTITLE | PSH_USECALLBACK);

    psh.hwndParent = hwndParent;
    psh.hInstance = hInst;

    psh.pszCaption = MAKEINTRESOURCE(IDS_DISPLAY_TITLE);
    psh.nPages = 0;
    psh.phpage = ahPages;
    psh.nStartPage = 0;
    psh.pfnCallback = NULL;

    if (szCmdLine && szCmdLine[0] && (TEXT('@') != szCmdLine[0]))
    {
        psh.nStartPage = UpgradeStartPageMappping(szCmdLine, ARRAYSIZE(szCmdLine));      // We changed the order so do the mapping
    }

    ZeroMemory( &psp, sizeof(psp) );

    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = hInst;

    // Build the property sheet.  If we are under setup, then just include
    // the "settings" page, and no otheres
    if (!g_pThemeUI)
    {
        // CoCreate Themes, Appearance, and Advanced Appearance tabs
        hr = CoCreateInstance(CLSID_ThemeUIPages, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemeUIPages, &g_pThemeUI));
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwExecMode;
        if (g_pThemeUI && (SUCCEEDED(g_pThemeUI->GetExecMode(&dwExecMode))) && (dwExecMode == EM_NORMAL))
        {
            if (!GetSystemMetrics(SM_CLEANBOOT))
            {
                hpsxa = SHCreatePropSheetExtArray(HKEY_LOCAL_MACHINE,
                                                  REGSTR_PATH_CONTROLSFOLDER TEXT("\\Desk"), 8);
            }

            for (i = 0; i < C_PAGES_DESK; i++)
            {
                BOOL fHideThisPage = FALSE;

                if (CheckRestrictionPage(&aPageInfo[i]))
                {
                    // This page is locked out by admin, don't put it up
                    fHideThisPage = TRUE;
                }

                // For Terminal Services, we need to hide the Background tab if a machine
                // policy is set to not allow wallpaper changes for this session.
                if ((aPageInfo[i].pfnDlgProc == BackgroundDlgProc) &&
                      GetSystemMetrics(SM_REMOTESESSION) &&
                      !fHideThisPage)
                {
                    fHideThisPage = HideBackgroundTabOnTermServices();
                }

                if (-1 == aPageInfo[i].nExtensionID)
                {
                    psp.pszTemplate = MAKEINTRESOURCE(aPageInfo[i].id);
                    psp.pfnDlgProc = aPageInfo[i].pfnDlgProc;
                    psp.dwFlags = PSP_DEFAULT;
                    psp.lParam = 0L;

                    if (!fHideThisPage && (psp.pfnDlgProc == BackgroundDlgProc))
                    {
                        // This page can be overridden by extensions
                        if( hpsxa )
                        {
                            UINT cutoff = psh.nPages;
                            UINT added = 0;
                            HPSXA hpsxaReplace = CreateReplaceableHPSXA(hpsxa);
                            if (hpsxaReplace)
                            {
                                added = SHReplaceFromPropSheetExtArray( hpsxaReplace, CPLPAGE_DISPLAY_BACKGROUND,
                                    _AddDisplayPropSheetPage, (LPARAM)&psh);
                                DestroyReplaceableHPSXA(hpsxaReplace);
                            }

                            if (added)
                            {
                                if (psh.nStartPage >= cutoff)
                                    psh.nStartPage += added-1;
                                continue;
                            }
                        }
                    }

                    if (!fHideThisPage && (hpsp = CreatePropertySheetPage(&psp)))
                    {
                        psh.phpage[psh.nPages++] = hpsp;
                    }
                }
                else if (g_pThemeUI && !fHideThisPage)
                {
                    IBasePropPage * pBasePage = NULL;

                    // add extensions from the registry
                    // CAUTION: Do not check for "fHideThisPage" here. We need to add the pages for 
                    // property sheet extensions even if the "Settings" page is hidden.
                    if (i == IPI_SETTINGS && hpsxa)
                    {
                        UINT cutoff = psh.nPages;
                        UINT added = SHAddFromPropSheetExtArray(hpsxa, _AddDisplayPropSheetPage, (LPARAM)&psh);

                        if (psh.nStartPage >= cutoff)
                            psh.nStartPage += added;
                    }

                    switch (aPageInfo[i].id)
                    {
                    case 0:
                        hr = g_pThemeUI->AddPage(_AddDisplayPropSheetPage, (LPARAM)&psh, aPageInfo[i].nExtensionID);
                        break;
                    case DLG_SCREENSAVER:
                        hr = CoCreateInstance(CLSID_ScreenSaverPage, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBasePropPage, &pBasePage));
                        break;
                    case DLG_BACKGROUND:
                        hr = CoCreateInstance(CLSID_CDeskHtmlProp, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBasePropPage, &pBasePage));
                        break;
                    default:
                        AssertMsg(0, TEXT("The value must be specified"));
                        break;
                    };

                    if (pBasePage)
                    {
                        IShellPropSheetExt * pspse = NULL;

                        // If they implement IShellPropSheetExt, then add their base pages.
                        if (SUCCEEDED(pBasePage->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &pspse))))
                        {
                            hr = pspse->AddPages(_AddDisplayPropSheetPage, (LPARAM)&psh);
                            pspse->Release();
                        }

                        hr = g_pThemeUI->AddBasePage(pBasePage);
                        pBasePage->Release();
                    }
                }
            }

            if (hpsxa)
            {
                // Have the dynamically added pages added to IThemeUIPages.
                AddPropSheetExtArrayToThemePageUI(g_pThemeUI, hpsxa);
            }

            // add a fake settings page to fool OEM extensions
            // !!! this page must be last !!!
            if (hpsxa)
            {
                g_pThemeUI->AddFakeSettingsPage((LPVOID)&psh);
            }
        }
        else
        {
            // For the SETUP case, only the display page should show up.
            hr = g_pThemeUI->AddPage(_AddDisplayPropSheetPage, (LPARAM)&psh, aPageInfo[IPI_SETTINGS].nExtensionID);
        }

        if (psh.nStartPage >= psh.nPages)
            psh.nStartPage = 0;

        if (psh.nPages)
        {
            DWORD dwAction = DESKACTION_NONE;
            TCHAR szStartPage[MAX_PATH];
            WCHAR szOpenPath[MAX_PATH];
            IPropertyBag * pPropertyBag;

            SetStartPage(&psh, szCmdLine, &dwAction, szOpenPath, ARRAYSIZE(szOpenPath), szStartPage, ARRAYSIZE(szStartPage));

            hr = g_pThemeUI->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                VARIANT var;

                if (DESKACTION_NONE != dwAction)
                {
                    var.vt = VT_LPWSTR;
                    var.bstrVal = szOpenPath;
                    hr = pPropertyBag->Write(((DESKACTION_OPENTHEME == dwAction) ? SZ_PBPROP_THEME_LAUNCHTHEME : SZ_PBPROP_APPEARANCE_LAUNCHMSTHEME), &var);
                }

                // The following SZ_PBPROP_PREOPEN call will save a "Custom.theme" so users can always go back to
                // their settings if they don't like changes they make in the CPL.
                pPropertyBag->Write(SZ_PBPROP_PREOPEN, NULL);
                pPropertyBag->Release();
            }

            if (PropertySheet(&psh) == ID_PSRESTARTWINDOWS)
            {
                exitparam = EWX_REBOOT;
            }
        }

        if (g_pThemeUI)
        {
            IUnknown_SetSite(g_pThemeUI, NULL); // Tell him to break the ref-count cycle with his children.
            g_pThemeUI->Release();
            g_pThemeUI = NULL;
        }

        // free any loaded extensions
        if (hpsxa)
        {
            SHDestroyPropSheetExtArray(hpsxa);
        }

        if (exitparam == EWX_REBOOT)
        {
            RestartDialogEx(hwndParent, NULL, exitparam, (SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_RECONFIG));
        }
    }

    return;
}




DWORD gdwCoverStyle = WS_EX_TOPMOST | WS_EX_TOOLWINDOW;
#if 0 // This code creates another thread for the cover window, which we don't really need
      // and is causing a problem. I am not sure if this is needed for NT, so leave it here....

///////////////////////////////////////////////////////////////////////////////
//
// CreateCoverWindow
//
// creates a window which obscures the display
//  flags:
//      0 means erase to black
//      COVER_NOPAINT means "freeze" the display
//
// just post it a WM_CLOSE when you're done with it
//
///////////////////////////////////////////////////////////////////////////////
typedef struct {
    DWORD   flags;
    HWND    hwnd;
    HANDLE  heRetvalSet;
} CVRWNDPARM, * PCVRWNDPARM;

DWORD WINAPI CreateCoverWindowThread( LPVOID pv )
{
    PCVRWNDPARM pcwp = (PCVRWNDPARM)pv;
    MSG msg;

    pcwp->hwnd = CreateWindowEx( gdwCoverStyle,
        sc_szCoverClass, g_szNULL, WS_POPUP | WS_VISIBLE | pcwp->flags, 0, 0,
        GetSystemMetrics( SM_CXSCREEN ), GetSystemMetrics( SM_CYSCREEN ),
        NULL, NULL, hInstance, NULL );


    if( pcwp->hwnd )
    {
        SetForegroundWindow( pcwp->hwnd );
        UpdateWindow( pcwp->hwnd );
    }

    // return wnd;
    SetEvent(pcwp->heRetvalSet);

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg, NULL, 0L, 0L)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    ExitThread(0);

    return 0;
}

void DestroyCoverWindow(HWND hwndCover)
{
    if (hwndCover)
        PostMessage(hwndCover, WM_CLOSE, 0, 0L);
}

HWND FAR PASCAL
CreateCoverWindow( DWORD flags )
{
    CVRWNDPARM cwp;
    HANDLE hThread;
    DWORD  idTh;
    DWORD dwWaitResult  = 0;

    // Init params
    cwp.flags = flags;
    cwp.hwnd = NULL;
    cwp.heRetvalSet = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (cwp.heRetvalSet == NULL)
        return NULL;

    // CreateThread
    hThread = CreateThread(NULL, 0, CreateCoverWindowThread, &cwp, 0, &idTh);

    CloseHandle(hThread);

    // Wait for Thread to return the handle to us
    do
    {
        dwWaitResult = MsgWaitForMultipleObjects(1,
                                                 &cwp.heRetvalSet,
                                                 FALSE,
                                                 INFINITE,
                                                 QS_ALLINPUT);
        switch(dwWaitResult)
        {
            case WAIT_OBJECT_0 + 1:
            {
                MSG msg ;
                //
                // Allow blocked thread to respond to sent messages.
                //
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if ( WM_QUIT != msg.message )
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                    else
                    {
                        //
                        // Received WM_QUIT.
                        // Don't wait for event.
                        //
                        dwWaitResult = WAIT_FAILED;
                    }
                }
                break;
            }

            default:
                break;
        }
    }
    while((WAIT_OBJECT_0 + 1) == dwWaitResult);

    CloseHandle(cwp.heRetvalSet);
    return cwp.hwnd;
}

#endif

void DestroyCoverWindow(HWND hwndCover)
{
    DestroyWindow(hwndCover);
}

HWND FAR PASCAL CreateCoverWindow( DWORD flags )
{
    HWND hwndCover = CreateWindowEx( gdwCoverStyle,
                                     sc_szCoverClass, g_szNULL, WS_POPUP | WS_VISIBLE | flags, 
                                     GetSystemMetrics( SM_XVIRTUALSCREEN ), 
                                     GetSystemMetrics( SM_YVIRTUALSCREEN ), 
                                     GetSystemMetrics( SM_CXVIRTUALSCREEN ), 
                                     GetSystemMetrics( SM_CYVIRTUALSCREEN ),
                                     NULL, NULL, hInstance, NULL );
    if( hwndCover )
    {
        SetForegroundWindow( hwndCover );
        if (flags & COVER_NOPAINT)
            SetCursor(LoadCursor(NULL, IDC_WAIT));
        UpdateWindow( hwndCover);
    }

    return hwndCover;
}

///////////////////////////////////////////////////////////////////////////////
// CoverWndProc (see CreateCoverWindow)
///////////////////////////////////////////////////////////////////////////////

#define WM_PRIV_KILL_LATER  (WM_APP + 100)  //Private message to kill ourselves later.

LRESULT CALLBACK
CoverWindowProc( HWND window, UINT message, WPARAM wparam, LPARAM lparam )
{
    switch( message )
    {
        case WM_CREATE:
            SetTimer( window, ID_CVRWND_TIMER, CMSEC_COVER_WINDOW_TIMEOUT, NULL );
            break;

        case WM_TIMER:
            // Times up... Shut ourself down
            if (wparam == ID_CVRWND_TIMER)
                DestroyWindow(window);
            break;

        case WM_ERASEBKGND:
            // NOTE: assumes our class brush is the NULL_BRUSH stock object
            if( !( GetWindowLong( window, GWL_STYLE ) & COVER_NOPAINT ) )
            {
                HDC dc = (HDC)wparam;
                RECT rc;

                if( GetClipBox( dc, (LPRECT)&rc ) != NULLREGION )
                {
                    FillRect( dc, (LPRECT)&rc, (HBRUSH) GetStockObject( BLACK_BRUSH ) );

                    // HACK: make sure fillrect is done before we return
                    // this is to better hide flicker during dynares-crap
                    GetPixel( dc, rc.left + 1, rc.top + 1 );
                }
            }
            break;


        // We post a private message to ourselves because:
        // When WM_CLOSE is processed by this window, it calls DestroyWindow() which results in
        // WM_ACTIVATE (WA_INACTIVE) message to be sent to this window. If this code calls
        // DestroyWindow again, it causes a loop. So, instead of calling DestroyWindow immediately,
        // we post ourselves a message and destroy us letter.
        case WM_ACTIVATE:
            if( GET_WM_ACTIVATE_STATE( wparam, lparam ) == WA_INACTIVE )
            {
                PostMessage( window, WM_PRIV_KILL_LATER, 0L, 0L );
                return 1L;
            }
            break;

        case WM_PRIV_KILL_LATER:
            DestroyWindow(window);
            break;

        case WM_DESTROY:
            KillTimer(window, ID_CVRWND_TIMER);
            break;
    }

    return DefWindowProc( window, message, wparam, lparam );
}

BOOL _FindCoverWindowCallback(HWND hwnd, LPARAM lParam)
{
    TCHAR szClass[MAX_PATH];
    HWND *phwnd = (HWND*)lParam;

    if( !GetClassName(hwnd, szClass, ARRAYSIZE(szClass)) )
        return TRUE;

    if( StrCmp(szClass, sc_szCoverClass) == 0 )
    {
        if( phwnd )
            *phwnd = hwnd;
        return FALSE;
    }
    return TRUE;
}


BYTE WINAPI MyStrToByte(LPCTSTR sz)
{
    BYTE l=0;

    while (*sz >= TEXT('0') && *sz <= TEXT('9'))
    {
        l = l*10 + (*sz++ - TEXT('0'));
    }

    return l;
}


COLORREF ConvertColor(LPTSTR lpColor)
{
    BYTE RGBTemp[3];
    LPTSTR lpTemp = lpColor;
    UINT i;

    if (!lpColor || !*lpColor)
    {
        return RGB(0,0,0);
    }

    for (i =0; i < 3; i++)
    {
        // Remove leading spaces
        while (*lpTemp == TEXT(' '))
        {
            lpTemp++;
        }

        // Set lpColor to the beginning of the number
        lpColor = lpTemp;

        // Find the end of the number and null terminate
        while ((*lpTemp) && (*lpTemp != TEXT(' ')))
        {
            lpTemp++;
        }

        if (*lpTemp != TEXT('\0'))
        {
            *lpTemp = TEXT('\0');
        }

        lpTemp++;
        RGBTemp[i] = MyStrToByte(lpColor);
    }

    return (RGB(RGBTemp[0], RGBTemp[1], RGBTemp[2]));
}



LONG APIENTRY CPlApplet(
    HWND  hwnd,
    WORD  message,
    LPARAM  wParam,
    LPARAM  lParam)
{
    LPCPLINFO lpCPlInfo;
    LPNEWCPLINFO lpNCPlInfo;
    HWND hwndCover;

    switch (message)
    {
      case CPL_INIT:          // Is any one there ?

        // Init the common controls
        if (!DeskInitCpl())
            return 0;

        // Load ONE string for emergencies.
        LoadString (hInstance, IDS_DISPLAY_TITLE, gszDeskCaption, ARRAYSIZE(gszDeskCaption));
        return !0;

      case CPL_GETCOUNT:        // How many applets do you support ?
        return 1;

      case CPL_INQUIRE:         // Fill CplInfo structure
        lpCPlInfo = (LPCPLINFO)lParam;

        lpCPlInfo->idIcon = IDI_DISPLAY;
        lpCPlInfo->idName = IDS_NAME;
        lpCPlInfo->idInfo = IDS_INFO;
        lpCPlInfo->lData  = 0;
        break;

    case CPL_NEWINQUIRE:

        lpNCPlInfo = (LPNEWCPLINFO)lParam;

        lpNCPlInfo->hIcon = LoadIcon(hInstance, (LPTSTR) MAKEINTRESOURCE(IDI_DISPLAY));
        LoadString(hInstance, IDS_NAME, lpNCPlInfo->szName, ARRAYSIZE(lpNCPlInfo->szName));

        if (!LoadString(hInstance, IDS_INFO, lpNCPlInfo->szInfo, ARRAYSIZE(lpNCPlInfo->szInfo)))
            lpNCPlInfo->szInfo[0] = (TCHAR) 0;

        lpNCPlInfo->dwSize = sizeof( NEWCPLINFO );
        lpNCPlInfo->lData  = 0;
#if 0
        lpNCPlInfo->dwHelpContext = IDH_CHILD_DISPLAY;
        lstrcpy(lpNCPlInfo->szHelpFile, xszControlHlp);
#else
        lpNCPlInfo->dwHelpContext = 0;
        lstrcpy(lpNCPlInfo->szHelpFile, TEXT(""));
#endif

        return TRUE;

      case CPL_DBLCLK:          // You have been chosen to run
        /*
         * One of your applets has been double-clicked.
         *      wParam is an index from 0 to (NUM_APPLETS-1)
         *      lParam is the lData value associated with the applet
         */
        lParam = 0L;
        // fall through...

      case CPL_STARTWPARMS:
        DeskShowPropSheet( hInstance, hwnd, (LPTSTR)lParam );

        // ensure that any cover windows we've created have been destroyed
        do
        {
            hwndCover = 0;
            EnumWindows( _FindCoverWindowCallback, (LPARAM)&hwndCover );
            if( hwndCover )
            {
                DestroyWindow( hwndCover );
            }
        }
        while( hwndCover );

        return TRUE;            // Tell RunDLL.exe that I succeeded

      case CPL_EXIT:            // You must really die
          if (g_hdcMem)
          {
              ReleaseDC(NULL, g_hdcMem);
              g_hdcMem = NULL;
          }
          // Fall thru...
      case CPL_STOP:            // You must die
        if (g_pThemeUI)
        {
            IUnknown_SetSite(g_pThemeUI, NULL); // Tell him to break the ref-count cycle with his children.
            g_pThemeUI->Release();
            g_pThemeUI = NULL;
        }
        break;

      case CPL_SELECT:          // You have been selected
        /*
         * Sent once for each applet prior to the CPL_EXIT msg.
         *      wParam is an index from 0 to (NUM_APPLETS-1)
         *      lParam is the lData value associated with the applet
         */
        break;

      //
      //  Private message sent when this applet is running under "Setup"
      //
      case CPL_SETUP:
      if (g_pThemeUI)
      {
        g_pThemeUI->SetExecMode(EM_SETUP);
      }
      break;

      // Private message used by userenv.dll to refresh the display colors
      case CPL_POLICYREFRESH:
        if (g_pThemeUI) // If this object doesn't exist, then we don't need to refresh anything.
        {
            IPreviewSystemMetrics * ppsm;

            if (SUCCEEDED(g_pThemeUI->QueryInterface(IID_PPV_ARG(IPreviewSystemMetrics, &ppsm))))
            {
                ppsm->RefreshColors();
                ppsm->Release();
            }
        }
        SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, 0, FALSE);
        break;
        
    }

    return 0L;
}


BOOL WINAPI DeskSetCurrentSchemeW(IN LPCWSTR pwzSchemeName)
{
    BOOL fSuccess = FALSE;
    IThemeUIPages * pThemeUI = NULL;
    HRESULT hr;

    HRESULT hrOle = SHCoInitialize();
    if (g_pThemeUI)
    {
        hr = g_pThemeUI->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUI));
    }
    else
    {
        hr = CoCreateInstance(CLSID_ThemeManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemeUIPages, &pThemeUI));
    }

    if (SUCCEEDED(hr))
    {
        IPreviewSystemMetrics * ppsm;

        hr = pThemeUI->QueryInterface(IID_PPV_ARG(IPreviewSystemMetrics, &ppsm));
        if (SUCCEEDED(hr))
        {
            hr = ppsm->DeskSetCurrentScheme(pwzSchemeName);
            ppsm->Release();
        }
        fSuccess = SUCCEEDED(hr);

        pThemeUI->Release();
    }

    SHCoUninitialize(hrOle);
    return fSuccess;
}


//------------------------------------------------------------------------------------------------
//  This function gets the current DPI, reads the last updated DPI from registry and compares 
// these two. If these two are equal, it returns immediately.
//  If these two DPI values are different, then it updates the size of UI fonts to reflect the
// change in the DPI values.
//  
//  This function is called from explorer sothat when DPI value is changed by admin and then every
// other user who logs-in gets this change.
//------------------------------------------------------------------------------------------------
void WINAPI UpdateUIfontsDueToDPIchange(int iOldDPI, int iNewDPI)
{
    BOOL fSuccess = FALSE;
    IThemeManager * pThemeMgr = NULL;
    HRESULT hr;

    HRESULT hrOle = SHCoInitialize();
    if (g_pThemeUI)
    {
        hr = g_pThemeUI->QueryInterface(IID_PPV_ARG(IThemeManager, &pThemeMgr));
    }
    else
    {
        hr = CoCreateInstance(CLSID_ThemeManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemeManager, &pThemeMgr));
    }

    if (SUCCEEDED(hr))
    {
        IPropertyBag * pPropertyBag;

        hr = GetPageByCLSID(pThemeMgr, &PPID_BaseAppearance, &pPropertyBag);
        if (SUCCEEDED(hr))
        {
            hr = SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_DPI_APPLIED_VALUE, iOldDPI);        // We are going to pretend we had the old DPI to force the scale to happen.
            hr = SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_DPI_MODIFIED_VALUE, iNewDPI);
            if (SUCCEEDED(hr))
            {
                hr = pThemeMgr->ApplyNow();
            }
            pPropertyBag->Release();
        }
        fSuccess = SUCCEEDED(hr);

        pThemeMgr->Release();
    }

    SHCoUninitialize(hrOle);
}


BOOL DeskSetCurrentSchemeA(IN LPCSTR pszSchemeName)
{
    WCHAR wzSchemeName[MAX_PATH];

    MultiByteToWideChar(CP_ACP, 0, pszSchemeName, -1, wzSchemeName, ARRAYSIZE(wzSchemeName));
    return DeskSetCurrentSchemeW(wzSchemeName);
}


STDAPI UpdateCharsetChanges(void)
{
    BOOL fSuccess = FALSE;
    IThemeUIPages * pThemeUI = NULL;
    HRESULT hr;

    HRESULT hrOle = SHCoInitialize();
    if (g_pThemeUI)
    {
        hr = g_pThemeUI->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUI));
    }
    else
    {
        hr = CoCreateInstance(CLSID_ThemeUIPages, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemeUIPages, &pThemeUI));
    }

    if (SUCCEEDED(hr))
    {
        IPreviewSystemMetrics * ppsm;

        hr = pThemeUI->QueryInterface(IID_PPV_ARG(IPreviewSystemMetrics, &ppsm));
        if (SUCCEEDED(hr))
        {
            hr = ppsm->UpdateCharsetChanges();
            ppsm->Release();
        }
        pThemeUI->Release();
    }

    SHCoUninitialize(hrOle);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\desk.h ===
#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif

#ifdef SIZEOF
#undef SIZEOF
#endif

#define CCH_MAX_STRING    256
#define CCH_NONE          20        /* ARRAYSIZE( "(None)" ), big enough for German */

#define CMSEC_COVER_WINDOW_TIMEOUT  (15 * 1000)     // 15 second timeout
#define ID_CVRWND_TIMER             0x96F251CC      // somewhat uniq id

//
// Extra bits for the TraceMsg function
//

#define TF_DUMP_DEVMODE     0x20000000
#define TF_DUMP_CSETTINGS   0x40000000
#define TF_DUMP_DEVMODELIST 0x80000000
#define TF_OC               0x01000000
#define TF_SETUP            0x02000000

// Maximum number of pages we will put in the PropertySheets
#define MAX_PAGES 24


// information about the monitor bitmap
// x, y, dx, dy define the size of the "screen" part of the bitmap
// the RGB is the color of the screen's desktop
// these numbers are VERY hard-coded to a monitor bitmap
#define MON_X   16
#define MON_Y   17
#define MON_DX  152
#define MON_DY  112
#define MON_W   184
#define MON_H   170
#define MON_RGB RGB(0, 128, 128)
#define MON_TRAY 8

#define CDPI_NORMAL     96      // Arbitrarily, 96dpi is "Normal"



BOOL DeskInitCpl(void);
void DeskShowPropSheet( HINSTANCE hInst, HWND hwndParent, LPCTSTR szCmdLine );
BOOL CALLBACK _AddDisplayPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam);

INT_PTR APIENTRY BackgroundDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ScreenSaverDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AppearanceDlgProc  (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AdvancedAppearanceDlgProc  (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK GeneralPageProc    (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK MultiMonitorDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


BOOL GetAdvMonitorPropPage(LPVOID lpv, LPFNADDPROPSHEETPAGE lpfnAdd, LPARAM lparam);
BOOL GetAdvMonitorPropPageParam(LPVOID lpv, LPFNADDPROPSHEETPAGE lpfnAdd, LPARAM lparam, LPARAM lparamPage);

INT_PTR APIENTRY DeskDefPropPageProc( HWND hDlg, UINT message, UINT wParam, LONG lParam);

// logging API
#define DeskOpenLog()   SetupOpenLog(FALSE)
#define DeskCloseLog()  SetupCloseLog()

BOOL
CDECL
DeskLogError(
    LogSeverity Severity,
    UINT MsgId,
    ...
    ) ;


// fixreg.c
void FixupRegistryHandlers(void);
BOOL GetDisplayKey(int i, LPTSTR szKey, DWORD cb);
void NukeDisplaySettings(void);

// background previewer includes

#define BP_NEWPAT       0x01    // pattern changed
#define BP_NEWWALL      0x02    // wallpaper changed
#define BP_TILE         0x04    // tile the wallpaper (center otherwise)
#define BP_REINIT       0x08    // reload the image (system colors changed)

#define WM_SETBACKINFO (WM_USER + 1)

#define BACKPREV_CLASS TEXT("BackgroundPreview")

BOOL FAR PASCAL RegisterLookPreviewClass(HINSTANCE hInst);

HBITMAP FAR LoadMonitorBitmap( BOOL bFillDesktop );



//#define Assert(p)   /* nothing */

#define ARRAYSIZE( a )  (sizeof(a) / sizeof(a[0]))
#define SIZEOF( a )     sizeof(a)


//
// CreateCoverWindow
//
// creates a window which obscures the display
//  flags:
//      0 means erase to black
//      COVER_NOPAINT means "freeze" the display
//
// just post it a WM_CLOSE when you're done with it
//
#define COVER_NOPAINT (0x1)
//
HWND FAR PASCAL CreateCoverWindow( DWORD flags );
void DestroyCoverWindow(HWND hwndCover);
int FmtMessageBox(HWND hwnd, UINT fuStyle, DWORD dwTitleID, DWORD dwTextID);

typedef struct tagREPLACEPAGE_LPARAM
{
    PROPSHEETHEADER FAR * ppsh;
    IThemeUIPages * ptuiPages;
} REPLACEPAGE_LPARAM;

//
// Macro to replace MAKEPOINT() since points now have 32 bit x & y
//
#define LPARAM2POINT( lp, ppt ) \
    ((ppt)->x = (int)(short)LOWORD(lp), (ppt)->y = (int)(short)HIWORD(lp))

//
// Globals
//
extern HINSTANCE hInstance;
extern TCHAR gszDeskCaption[CCH_MAX_STRING];

extern TCHAR g_szNULL[];
extern TCHAR g_szNone[CCH_NONE];
extern TCHAR g_szControlIni[];
extern TCHAR g_szPatterns[];

extern TCHAR g_szCurPattern[];   // name of currently selected pattern
extern TCHAR g_szCurWallpaper[]; // name of currently selected wallpaper
extern BOOL g_bValidBitmap;     // whether or not wallpaper is valid

extern TCHAR g_szBoot[];
extern TCHAR g_szSystemIni[];
extern TCHAR g_szWindows[];

extern HDC g_hdcMem;
extern HBITMAP g_hbmDefault;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\deskid.h ===
#ifndef _DESKID_H
#define _DESKID_H


///////////////////////////////////////////////////////////////////////////////
// Icons

#define IDI_DISPLAY              100


///////////////////////////////////////////////////////////////////////////////
// Strings

#define IDS_DISPLAY_TITLE        100
#define IDS_DISPLAY_DISABLED     102

#define IDC_STATIC  -1

#define DLG_SCREENSAVER          150
#define DLG_BACKGROUND           151
#define DLG_WIZPAGE              164

#define IDS_ICON                  40
#define IDS_NAME                  41
#define IDS_INFO                  42
#define IDS_RETURNTOWELCOME       43

#define IDB_ENERGYSTAR           120

#define IDC_NO_HELP_1            200     // Used in place of IDC_STATIC when context Help
#define IDC_NO_HELP_2            201     // should be disabled for a control

// background controls
#define IDC_PATLIST             1100
#define IDC_WALLLIST            1101
#define IDC_EDITPAT             1102
#define IDC_BROWSEWALL          1103
#define IDC_CENTER              1104
#define IDC_TILE                1105
#define IDC_PATTERN             1106
#define IDC_WALLPAPER           1107
#define IDC_BACKPREV            1108
#define IDC_TXT_DISPLAY         1109

// background dialog strings
#define IDS_NONE                1100
#define IDS_UNLISTEDPAT         1101
#define IDS_BITMAPOPENERR       1102
#define IDS_DIB_NOOPEN          1103
#define IDS_DIB_INVALID         1104
#define IDS_BADWALLPAPER        1106
#define IDS_BROWSETITLE         1107
#define IDS_BROWSEFILTER        1108

// patern edit dialog

#define IDS_PAT_REMOVE          1231
#define IDS_PAT_CHANGE          1232
#define IDS_PAT_CREATE          1233
#define IDS_REMOVEPATCAPTION    1234
#define IDS_CHANGEPATCAPTION    1235

#define IDS_TAB_THEMES          1240
#define IDS_TAB_DESKTOP         1241
#define IDS_TAB_SCREENSAVER     1242
#define IDS_TAB_APPEARANCE      1243
#define IDS_TAB_SETTINGS        1244


#define IDD_PATTERN             1700
#define IDD_PATTERNCOMBO        1701
#define IDD_ADDPATTERN          1702
#define IDD_CHANGEPATTERN       1703
#define IDD_DELPATTERN          1704
#define IDD_PATSAMPLE           1705
#define IDD_PATSAMPLE_TXT       1706
#define IDD_PATTERN_TXT         1707

// Keep the old value
#define IDC_COLORBOX            1807 // used to be ID_DSP_COLORBOX
#define IDC_SCREENSIZE          1808 // used to be ID_DSP_AREA_SB

//
// String IDs
//

// install2.c

#define ID_DSP_TXT_INSTALL_DRIVER           3030
#define ID_DSP_TXT_BAD_INF                  3031
#define ID_DSP_TXT_DRIVER_INSTALLED         3032
#define ID_DSP_TXT_DRIVER_INSTALLED_FAILED  3033
#define ID_DSP_TXT_NO_USE_UPGRADE           3034


// ocpage.cpp
#define IDC_DSP_CLRPALGRP                   3100 
#define IDC_DSP_COLORBAR                    3102 
#define IDC_DSP_DSKAREAGRP                  3103 
#define IDC_REFRESH_RATE                    3106   
#define IDC_MONITOR_BITMAP                  3108 

#define ID_DSP_TXT_COMPATABLE_DEV           3150
#define ID_DSP_TXT_ADMIN_CHANGE             3151
#define ID_DSP_TXT_COLOR                    3153
#define IDS_DEFFREQ                         3154
#define IDS_INTERLACED                      3155
#define IDS_FREQ                            3156
#define IDS_COLOR_RED                       3157
#define IDS_COLOR_GREEN                     3158
#define IDS_COLOR_BLUE                      3159
#define IDS_COLOR_YELLOW                    3160
#define IDS_COLOR_MAGENTA                   3161
#define IDS_COLOR_CYAN                      3162
#define IDS_PATTERN_HORZ                    3163
#define IDS_PATTERN_VERT                    3164
#define MSG_SETTING_KB                      3165
#define MSG_SETTING_MB                      3166
#define IDS_RED_SHADES                      3167
#define IDS_GREEN_SHADES                    3168
#define IDS_BLUE_SHADES                     3169
#define IDS_GRAY_SHADES                     3170
#define ID_DSP_TXT_TEST_MODE                3171
#define ID_DSP_TXT_DID_TEST_WARNING         3172
#define ID_DSP_TXT_DID_TEST_RESULT          3173
#define ID_DSP_TXT_TEST_FAILED              3174
#define IDS_DISPLAY_WIZ_TITLE               3175
#define IDS_DISPLAY_WIZ_SUBTITLE            3176
#define ID_DSP_TXT_DID_TEST_WARNING_LONG    3177
#define ID_DSP_TXT_XBYY                     3178

// setupact.log messages

#define IDS_SETUPLOG_MSG_000                3300
#define IDS_SETUPLOG_MSG_004                3304
#define IDS_SETUPLOG_MSG_006                3306
#define IDS_SETUPLOG_MSG_008                3308
#define IDS_SETUPLOG_MSG_009                3309
#define IDS_SETUPLOG_MSG_010                3310
#define IDS_SETUPLOG_MSG_011                3311
#define IDS_SETUPLOG_MSG_012                3312
#define IDS_SETUPLOG_MSG_013                3313
#define IDS_SETUPLOG_MSG_014                3314
#define IDS_SETUPLOG_MSG_015                3315
#define IDS_SETUPLOG_MSG_016                3316
#define IDS_SETUPLOG_MSG_017                3317
#define IDS_SETUPLOG_MSG_018                3318
#define IDS_SETUPLOG_MSG_019                3319
#define IDS_SETUPLOG_MSG_020                3320
#define IDS_SETUPLOG_MSG_021                3321
#define IDS_SETUPLOG_MSG_022                3322
#define IDS_SETUPLOG_MSG_023                3323
#define IDS_SETUPLOG_MSG_024                3324
#define IDS_SETUPLOG_MSG_025                3325
#define IDS_SETUPLOG_MSG_031                3331
#define IDS_SETUPLOG_MSG_032                3332
#define IDS_SETUPLOG_MSG_033                3333
#define IDS_SETUPLOG_MSG_034                3334
#define IDS_SETUPLOG_MSG_035                3335
#define IDS_SETUPLOG_MSG_039                3339
#define IDS_SETUPLOG_MSG_040                3340
#define IDS_SETUPLOG_MSG_041                3341
#define IDS_SETUPLOG_MSG_046                3346
#define IDS_SETUPLOG_MSG_047                3347
#define IDS_SETUPLOG_MSG_048                3348
#define IDS_SETUPLOG_MSG_057                3357
#define IDS_SETUPLOG_MSG_060                3360
#define IDS_SETUPLOG_MSG_062                3362
#define IDS_SETUPLOG_MSG_064                3364
#define IDS_SETUPLOG_MSG_065                3365
#define IDS_SETUPLOG_MSG_067                3367
#define IDS_SETUPLOG_MSG_068                3368
#define IDS_SETUPLOG_MSG_069                3369
#define IDS_SETUPLOG_MSG_075                3375
#define IDS_SETUPLOG_MSG_076                3376
#define IDS_SETUPLOG_MSG_096                3396
#define IDS_SETUPLOG_MSG_097                3397
#define IDS_SETUPLOG_MSG_098                3398
#define IDS_SETUPLOG_MSG_099                3399
#define IDS_SETUPLOG_MSG_100                3400
#define IDS_SETUPLOG_MSG_101                3401
#define IDS_SETUPLOG_MSG_102                3402
#define IDS_SETUPLOG_MSG_103                3403
#define IDS_SETUPLOG_MSG_104                3404
#define IDS_SETUPLOG_MSG_105                3405
#define IDS_SETUPLOG_MSG_106                3406
#define IDS_SETUPLOG_MSG_107                3407
#define IDS_SETUPLOG_MSG_108                3408
#define IDS_SETUPLOG_MSG_109                3409
#define IDS_SETUPLOG_MSG_110                3410
#define IDS_SETUPLOG_MSG_111                3411
#define IDS_SETUPLOG_MSG_112                3412
#define IDS_SETUPLOG_MSG_113                3413
#define IDS_SETUPLOG_MSG_114                3414
#define IDS_SETUPLOG_MSG_115                3415
#define IDS_SETUPLOG_MSG_116                3416
#define IDS_SETUPLOG_MSG_117                3417
#define IDS_SETUPLOG_MSG_118                3418
#define IDS_SETUPLOG_MSG_119                3419
#define IDS_SETUPLOG_MSG_120                3420
#define IDS_SETUPLOG_MSG_121                3421
#define IDS_SETUPLOG_MSG_122                3422
#define IDS_SETUPLOG_MSG_123                3423
#define IDS_SETUPLOG_MSG_124                3424
#define IDS_SETUPLOG_MSG_125                3425
#define IDS_SETUPLOG_MSG_126                3426
#define IDS_SETUPLOG_MSG_127                3427
#define IDS_SETUPLOG_MSG_128                3428
#define IDS_SETUPLOG_MSG_129                3429
#define IDS_SETUPLOG_MSG_130                3430

//
// Help defines
//

#endif // _DESKID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\look.h ===
#define FONT_NONE	-1
#define FONT_CAPTION	0
#define FONT_SMCAPTION	1
#define FONT_MENU	2
#define FONT_ICONTITLE	3
#define FONT_STATUS	4
#define FONT_MSGBOX	5

#define NUM_FONTS	6
typedef struct {
    HFONT hfont;
    LOGFONT lf;
} LOOK_FONT;
extern LOOK_FONT g_fonts[];

#define COLOR_NONE	-1
extern COLORREF g_rgb[];
extern HBRUSH g_brushes[];
extern HPALETTE g_hpal3D;

#define SIZE_NONE	-1
#define SIZE_FRAME	0
#define SIZE_SCROLL	1
#define SIZE_CAPTION	2
#define SIZE_SMCAPTION	3
#define SIZE_MENU	4
#define SIZE_DXICON     5
#define SIZE_DYICON     6
#define SIZE_ICON       7
#define SIZE_SMICON     8

#define NUM_SIZES	9

typedef struct {
    int CurSize;
    int MinSize;
    int MaxSize;
} LOOK_SIZE;
extern LOOK_SIZE g_sizes[];

typedef struct {
    int iMainColor;
    int iSize;
    BOOL fLinkSizeToFont;
    int iTextColor;
    int iFont;
    int iResId;		// id of name in resource (or -1 if duplicate)
    int iBaseElement;	// index of element that this overlaps (or -1)
    int iGradientColor; // index of element for Gradient Caption Bar (or -1)
    RECT rc;
} LOOK_ELEMENT;

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//this order has to match the array order in lookdlg.c
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
enum _ELEMENTS {
    ELEMENT_APPSPACE = 0,
    ELEMENT_DESKTOP,
    ELEMENT_INACTIVEBORDER,
    ELEMENT_ACTIVEBORDER,
    ELEMENT_INACTIVECAPTION,
    ELEMENT_INACTIVESYSBUT1,
    ELEMENT_INACTIVESYSBUT2,
    ELEMENT_ACTIVECAPTION,
    ELEMENT_ACTIVESYSBUT1,
    ELEMENT_ACTIVESYSBUT2,
    ELEMENT_MENUNORMAL,
    ELEMENT_MENUSELECTED,
    ELEMENT_MENUDISABLED,
    ELEMENT_WINDOW,
    ELEMENT_MSGBOX,
    ELEMENT_MSGBOXCAPTION,
    ELEMENT_MSGBOXSYSBUT,
    ELEMENT_SCROLLBAR,
    ELEMENT_SCROLLUP,
    ELEMENT_SCROLLDOWN,
    ELEMENT_BUTTON,
    ELEMENT_SMCAPTION,
    ELEMENT_ICON,
    ELEMENT_ICONHORZSPACING,
    ELEMENT_ICONVERTSPACING,
    ELEMENT_INFO
};
// BOGUS:  need to get a size from somewhere
#define NUM_ELEMENTS ELEMENT_INFO+1

#if 0
// go fix lookdlg.c if you decide to add this back in
    ELEMENT_SMICON,
#endif


#define CPI_VGAONLY	0x0001
#define CPI_PALETTEOK	0x0002

typedef struct {
    HWND hwndParent;    // parent for any modal dialogs (choosecolor et al)
    HWND hwndOwner;     // control that owns mini color picker
    COLORREF rgb;
    UINT flags;
    HPALETTE hpal;
} COLORPICK_INFO, FAR * LPCOLORPICK_INFO;

#define WM_RECREATEBITMAP (WM_USER)
extern int cyBorder;
extern int cxBorder;
extern int cyEdge;
extern int cxEdge;

// NOTE: the order in g_elements must match the enum order above
extern LOOK_ELEMENT g_elements[];

void FAR PASCAL LookPrev_Recalc(HWND hwnd);
void FAR PASCAL LookPrev_Repaint(HWND hwnd);

void FAR PASCAL Look_SelectElement(HWND hDlg, int iElement, DWORD dwFlag);

BOOL WINAPI ChooseColorMini(LPCOLORPICK_INFO lpcpi);

DWORD FAR PASCAL DarkenColor(DWORD rgb, int n);
DWORD FAR PASCAL BrightenColor(DWORD rgb, int n);

DWORD FAR PASCAL AdjustLuma(DWORD rgb, int n, BOOL fScale);


#define LF32toLF(lplf32, lplf)  (*(lplf) = *(lplf32))
#define LFtoLF32(lplf, lplf32)  (*(lplf32) = *(lplf))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\ntreg.cpp ===
/**************************************************************************\
* Module Name: ntreg.cpp
*
* CRegistrySettings class
*
*  This class handles getting registry information for display driver
*  information.
*
* Copyright (c) Microsoft Corp.  1992-1998 All Rights Reserved
*
\**************************************************************************/

#include "precomp.h"
#include <tchar.h>
#include "ntreg.hxx"
#include <devguid.h>

#ifdef WINNT


//
// CRegistrySettings constructor
//

CRegistrySettings::CRegistrySettings(LPTSTR pstrDeviceKey)
    : _hkVideoReg(NULL)
    , _pszDrvName(NULL)
    , _pszKeyName(NULL)
    , _pszDeviceInstanceId(NULL)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR pszPath;
    HKEY hkeyCommon, hkeyDriver;
    DWORD cb;
    LPTSTR pszName = NULL;
    LPTSTR pszEnd;

    ASSERT(lstrlen(pstrDeviceKey) < MAX_PATH);
    
    //
    // Copy the data to local buffer.
    //

    lstrcpy(szBuffer, pstrDeviceKey);

    //
    // Initialize the device instance id
    // 
    
    InitDeviceInstanceID(szBuffer);

    //
    // At this point, szBuffer has something like:
    //  \REGISTRY\Machine\System\ControlSet001\...
    //
    // To use the Win32 registry calls, we have to strip off the \REGISTRY
    // and convert \Machine to HKEY_LOCAL_MACHINE
    //

    pszPath = SubStrEnd(SZ_REGISTRYMACHINE, szBuffer);

    //
    // Try to open the registry key
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pszPath,
                     0,
                     KEY_READ,
                     &_hkVideoReg) != ERROR_SUCCESS) {

        _hkVideoReg = 0;
    }

    //
    // Go to the video subkey
    //

    pszEnd = pszPath + lstrlen(pszPath);

    while (pszEnd != pszPath && *pszEnd != TEXT('\\')) {

        pszEnd--;
    }

    *pszEnd = UNICODE_NULL;

    lstrcat(pszPath, SZ_COMMON_SUBKEY);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pszPath,
                     0,
                     KEY_READ,
                     &hkeyCommon) == ERROR_SUCCESS) {

        cb = sizeof(szBuffer);
        ZeroMemory(szBuffer, cb);

        if (RegQueryValueEx(hkeyCommon,
                            SZ_SERVICE,
                            NULL,
                            NULL,
                            (LPBYTE)szBuffer,
                            &cb) == ERROR_SUCCESS) {

            //
            // Save the key name
            //

            _pszKeyName = (LPTSTR)LocalAlloc(LPTR, 
                                             (lstrlen(szBuffer) + 1) * sizeof(TCHAR));

            if (_pszKeyName != NULL) {

                lstrcpy(_pszKeyName, szBuffer);
            
                lstrcpy(szBuffer, SZ_SERVICES_PATH);
                lstrcat(szBuffer, _pszKeyName);

                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 szBuffer,
                                 0,
                                 KEY_READ,
                                 &hkeyDriver) == ERROR_SUCCESS) {
        
                    cb = sizeof(szBuffer);
                    ZeroMemory(szBuffer, cb);

                    if (RegQueryValueEx(hkeyDriver,
                                        L"ImagePath",
                                        NULL,
                                        NULL,
                                        (LPBYTE)szBuffer,
                                        &cb) == ERROR_SUCCESS) {
        
                        //
                        // This is a binary.
                        // Extract the name, which will be of the form ...\driver.sys
                        //
        
                        LPTSTR pszDriver, pszDriverEnd;
    
                        pszDriver = szBuffer;
                        pszDriverEnd = pszDriver + lstrlen(pszDriver);
    
                        while(pszDriverEnd != pszDriver &&
                              *pszDriverEnd != TEXT('.')) {
                            pszDriverEnd--;
                        }
    
                        *pszDriverEnd = UNICODE_NULL;
    
                        while(pszDriverEnd != pszDriver &&
                              *pszDriverEnd != TEXT('\\')) {
                            pszDriverEnd--;
                        }
    
                        //
                        // If pszDriver and pszDriverEnd are different, we now
                        // have the driver name.
                        //
    
                        if (pszDriverEnd > pszDriver) {
                            
                            pszDriverEnd++;
                            pszName = pszDriverEnd;
    
                        }
                    }
        
                    RegCloseKey(hkeyDriver);
                }
            
                if (!pszName) {

                    //
                    // Something failed trying to get the binary name.just get the device name
                    //

                    _pszDrvName = _pszKeyName;

                } else {

                    _pszDrvName = (LPTSTR)LocalAlloc(LPTR,
                                                     (lstrlen(pszName) + 1) * sizeof(TCHAR));

                    if (_pszDrvName != NULL) {

                        lstrcpy(_pszDrvName, pszName);

                    }
                }
            }
        }

        RegCloseKey(hkeyCommon);
    }
}

//
// CRegistrySettings destructor
//

CRegistrySettings::~CRegistrySettings() 
{
    //
    // Close the registry
    //

    if (_hkVideoReg) {
        RegCloseKey(_hkVideoReg);
    }

    //
    // Free the strings
    //
    if (_pszKeyName) {
        LocalFree(_pszKeyName);
    }

    if ((_pszKeyName != _pszDrvName) && _pszDrvName) {
        LocalFree(_pszDrvName);
    }

    if(_pszDeviceInstanceId) {
        LocalFree(_pszDeviceInstanceId);
    }
}


//
// Method to get the hardware information fields.
//

VOID
CRegistrySettings::GetHardwareInformation(
    PDISPLAY_REGISTRY_HARDWARE_INFO pInfo)
{

    DWORD cb, dwType;
    DWORD i;
    LONG lRet;

    LPWSTR pKeyNames[5] = {
        L"HardwareInformation.MemorySize",
        L"HardwareInformation.ChipType",
        L"HardwareInformation.DacType",
        L"HardwareInformation.AdapterString",
        L"HardwareInformation.BiosString"
    };

    ZeroMemory(pInfo, sizeof(DISPLAY_REGISTRY_HARDWARE_INFO));

    //
    // Query each entry one after the other.
    //

    for (i = 0; i < 5; i++) {

        //
        // query the size of the string
        //

        cb = 256;
        lRet = RegQueryValueExW(_hkVideoReg,
                                pKeyNames[i],
                                NULL,
                                &dwType,
                                NULL,
                                &cb);

        if (lRet == ERROR_SUCCESS) {

            if (i == 0) {

                ULONG mem;

                cb = 4;

                RegQueryValueExW(_hkVideoReg,
                                 pKeyNames[i],
                                 NULL,
                                 &dwType,
                                 (PUCHAR) (&mem),
                                 &cb);

                //
                // If we queried the memory size, we actually have
                // a DWORD.  Transform the DWORD to a string
                //

                // Divide down to Ks

                mem =  mem >> 10;

                // if a MB multiple, divide again.

                if ((mem & 0x3FF) != 0) {

                    wsprintf((LPWSTR)pInfo, L"%d KB", mem );

                } else {

                    wsprintf((LPWSTR)pInfo, L"%d MB", mem >> 10 );

                }

            } else {

                cb = 256;

                //
                // get the string
                //

                RegQueryValueExW(_hkVideoReg,
                                 pKeyNames[i],
                                 NULL,
                                 &dwType,
                                 (LPBYTE) pInfo,
                                 &cb);

            }
        }
        else
        {
            //
            // Put in the default string
            //

            LoadString(hInstance,
                       IDS_UNAVAILABLE,
                       (LPWSTR)pInfo,
                       256);
        }

        pInfo = (PDISPLAY_REGISTRY_HARDWARE_INFO)((PUCHAR)pInfo + 256);
    }


    return;
}


VOID CRegistrySettings::InitDeviceInstanceID(
    LPTSTR pstrDeviceKey
    ) 
{
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE ;
    SP_DEVINFO_DATA DevInfoData;
    ULONG InstanceIDSize = 0;
    BOOL bSuccess = FALSE;
    LPWSTR pwInterfaceName = NULL;
    LPWSTR pwInstanceID = NULL;

    ASSERT (pstrDeviceKey != NULL);
    ASSERT (_pszDeviceInstanceId == NULL);

    if (AllocAndReadInterfaceName(pstrDeviceKey, &pwInterfaceName)) {

        bSuccess = GetDevInfoDataFromInterfaceName(pwInterfaceName,
                                                   &hDevInfo,
                                                   &DevInfoData);
        if (bSuccess) {

            InstanceIDSize = 0;

            bSuccess = 

                ((CM_Get_Device_ID_Size(&InstanceIDSize, 
                                        DevInfoData.DevInst, 
                                        0) == CR_SUCCESS) &&

                 ((_pszDeviceInstanceId = (LPTSTR)LocalAlloc(LPTR, 
                     (InstanceIDSize + 1) * sizeof(TCHAR))) != NULL) &&

                 (CM_Get_Device_ID(DevInfoData.DevInst, 
                                   _pszDeviceInstanceId,
                                   InstanceIDSize,
                                   0) == CR_SUCCESS));

            if (!bSuccess) {

                //
                // Clean-up
                //

                if (NULL != _pszDeviceInstanceId) {
                    LocalFree(_pszDeviceInstanceId);
                    _pszDeviceInstanceId = NULL;
                }
            }

            SetupDiDestroyDeviceInfoList(hDevInfo);
        }

        LocalFree(pwInterfaceName);
    }

    if ((!bSuccess) &&
        AllocAndReadInstanceID(pstrDeviceKey, &pwInstanceID)) {

#ifdef UNICODE
        _pszDeviceInstanceId = pwInstanceID;
#else
        SIZE_T cch = wcslen(pwInstanceID) + 1;
        _pszDeviceInstanceId = LocalAlloc(LPTR, cch);
        if (_pszDeviceInstanceId != NULL) {
            WideCharToMultiByte(CP_ACP, 0, 
                                pwInstanceID, -1, 
                                _pszDeviceInstanceId, 
                                cch, NULL, NULL);
        }

        LocalFree(pwInstanceID);
#endif

    }

} // InitDeviceInstanceID


BOOL
CRegistrySettings::GetDevInfoDataFromInterfaceName(
    IN  LPWSTR pwInterfaceName,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfoData
    )

/*

    Note: If this function retuns success, the caller is responsible
          to destroy the device info list returned in phDevInfo

*/

{
    LPWSTR pwDevicePath = NULL;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DevInfoData;
    SP_DEVICE_INTERFACE_DATA InterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pInterfaceDetailData = NULL;
    DWORD InterfaceIndex = 0;
    DWORD InterfaceSize = 0;
    BOOL bMatch = FALSE;

    ASSERT (pwInterfaceName != NULL);
    ASSERT (phDevInfo != NULL);
    ASSERT (pDevInfoData != NULL);

    //
    // Enumerate all display adapter interfaces
    //

    hDevInfo = SetupDiGetClassDevs(&GUID_DISPLAY_ADAPTER_INTERFACE,
                                   NULL,
                                   NULL,
                                   DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (hDevInfo == INVALID_HANDLE_VALUE) {
        goto Cleanup;
    }

    InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
    while (SetupDiEnumDeviceInterfaces(hDevInfo,
                                       NULL,
                                       &GUID_DISPLAY_ADAPTER_INTERFACE,
                                       InterfaceIndex,
                                       &InterfaceData)) {

        //
        // Get the required size for the interface
        //

        InterfaceSize = 0;
        SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                        &InterfaceData,
                                        NULL,
                                        0,
                                        &InterfaceSize,
                                        NULL);

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Cleanup;
        }

        //
        // Alloc memory for the interface
        //

        pInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)
            LocalAlloc(LPTR, InterfaceSize);
        if (pInterfaceDetailData == NULL)
            goto Cleanup;

        //
        // Get the interface
        //

        pInterfaceDetailData->cbSize =
            sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                            &InterfaceData,
                                            pInterfaceDetailData,
                                            InterfaceSize,
                                            &InterfaceSize,
                                            &DevInfoData)) {

            //
            // Is the InterfaceName the same as the DevicePath?
            //

#ifdef UNICODE
            pwDevicePath = pInterfaceDetailData->DevicePath;
#else
            {
                SIZE_T cch = strlen(pInterfaceDetailData->DevicePath) + 1;
                pwDevicePath = LocalAlloc(LPTR, cch * sizeof(WCHAR));
                if (pwDevicePath == NULL) {
                    goto Cleanup;
                }
                MultiByteToWideChar(CP_ACP, 0,
                                    pInterfaceDetailData->DevicePath,
                                    -1, pwDevicePath, cch);
            }
#endif

            //
            // The first 4 characters of the interface name are different
            // between user mode and kernel mode (e.g. "\\?\" vs "\\.\")
            // Therefore, ignore them.
            //

            bMatch = (_wcsnicmp(pwInterfaceName + 4,
                                pwDevicePath + 4,
                                wcslen(pwInterfaceName + 4)) == 0);

#ifndef UNICODE
            LocalFree(pwDevicePath);
            pwDevicePath = NULL;
#endif

            if (bMatch) {

                //
                // We found the device
                //

                *phDevInfo = hDevInfo;
                CopyMemory(pDevInfoData, &DevInfoData, sizeof(SP_DEVINFO_DATA));

                break;
            }
        }

        //
        // Clean-up
        //

        LocalFree(pInterfaceDetailData);
        pInterfaceDetailData = NULL;

        //
        // Next interface ...
        //

        InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        ++InterfaceIndex;
    }

Cleanup:

    if (pInterfaceDetailData != NULL) {
        LocalFree(pInterfaceDetailData);
    }

    //
    // Upon success, the caller is responsible to destroy the list
    //

    if (!bMatch && (hDevInfo != INVALID_HANDLE_VALUE)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    return bMatch;
}


#endif // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\init.cpp ===
#include "precomp.h"
#include <shlwapi.h> // for DllInstall prototype
#include "advpub.h"

#define GUID_STR_LEN    40

// global variables
HINSTANCE hInstance;

STDAPI DllUnregisterServer(void)
{
    // This DLL does not need to unregister anything now.
    // So, we simply return success here.
    return NOERROR;
}

STDAPI DllRegisterServer(void)
{

    // This DLL does not need to register anything now.
    // So, we simply return success here.
    return NOERROR;
}

EXTERN_C BOOL DllInitialize(IN PVOID hmod, IN ULONG ulReason, IN PCONTEXT pctx OPTIONAL)
{
    UNREFERENCED_PARAMETER(pctx);
    if (ulReason == DLL_PROCESS_ATTACH)
    {
        hInstance = (HINSTANCE) hmod;
        DisableThreadLibraryCalls(hInstance);
        SHFusionInitializeFromModuleID(hInstance, 124);
#ifdef DEBUG
        CcshellGetDebugFlags();
#endif
    }
    else if (ulReason == DLL_PROCESS_DETACH) 
    {
#ifdef DEBUG
        DeskCheckForLeaks();
#endif       
        SHFusionUninitialize();
    }

    return TRUE;
}

BOOL APIENTRY DllMain(IN HANDLE hDll, IN DWORD dwReason, IN LPVOID lpReserved)
{
    ASSERT(0);
    return TRUE;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    // No Com object is registered by this DLL. So, let's fail!
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;;
}

STDAPI DllCanUnloadNow(void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <regstr.h>
#include <help.h>
#include <scrnsave.h>

#include <shlobj.h>
#include <cpl.h>
#include <shsemip.h>
#include <shellp.h>

#include <commdlg.h>
#include <commctrl.h>
#include <setupapi.h>
#include <syssetup.h>
#include <setupbat.h>
#include <cfgmgr32.h>
#include <newexe.h>
#include <winuser.h>
#include <winuserp.h>
#include <wingdi.h>
#include <ccstock.h>
#include <objsafe.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shellapi.h>

#include <shsemip.h>
#include <shpriv.h>

#include <ocmanage.h>

#include <debug.h>

#include "deskid.h"
#include "desk.h"
#include "deskdbg.h"
#include "look.h"
#include "util.h"
#include "..\common\deskcplext.h"
#include "..\common\deskcmmn.h"
#include "shfusion.h"


// With this feature on, we demote the advanced appearances
// options into an "Advanced" subdialog.
#define FEATURE_DEMOTE_ADVANCED_APPEAROPTIONS



#define CH_HTML_ESCAPE             L'%'


#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETPATH      = obj
TARGETTYPE      = DYNLINK
TARGETEXT       = cpl

#VERIFY_LC       = 1
LC_PATH         = $(PROJECT_ROOT)\lcinf

DLLDEF          = $(O)\desk.def

INCLUDES=$(INCLUDES);..\;$(TERMSRV_INC_PATH);$(DS_INC_PATH);$(SDK_LIB_PATH);$(PROJECT_ROOT)\lib\$(0);$(O)

SOURCES         = ..\desk.rc      \
                  ..\backdlg.cpp  \
                  ..\debug.cpp    \
                  ..\desk.cpp     \
                  ..\deskcmmn.cpp \
                  ..\init.cpp     \
                  ..\install2.cpp \
                  ..\ocpage.cpp   \
                  ..\util.cpp

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

TARGETLIBS      = \
                  $(SDK_LIB_PATH)\kernel32.lib      \
                  $(WINDOWS_LIB_PATH)\user32p.lib   \
                  $(SDK_LIB_PATH)\gdi32.lib         \
                  $(SHELL_LIB_PATH)\shfusion.lib    \
                  $(SDK_LIB_PATH)\setupapi.lib      \
                  $(SHELL_LIB_PATH)\shlwapip.lib    \
                  $(SHELL_LIB_PATH)\shell32p.lib    \
                  $(SDK_LIB_PATH)\mpr.lib           \
                  $(SDK_LIB_PATH)\version.lib       \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(SDK_LIB_PATH)\uuid.lib          \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\oleaut32.lib      \
                  $(CCSHELL_DIR)\lib\$(O)\shguidp.lib \
                  $(CCSHELL_DIR)\lib\$(O)\stock.lib

DLLENTRY        = DllInitialize

DELAYLOAD=SETUPAPI.DLL;MPR.DLL

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
 
 
# 
# Fusionized
# 
SXS_MANIFEST_RESOURCE_ID=124
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\install2.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    install2.cpp

Abstract:

    This file implements the display class installer.

Environment:

    WIN32 User Mode

--*/


#include <initguid.h>

#include "precomp.h" 
#pragma hdrstop

#include <tchar.h>
#include <devguid.h>

//
// Defines
//

#define INSETUP         1
#define INSETUP_UPGRADE 2

#define SZ_UPGRADE_DESCRIPTION TEXT("_RealDescription")
#define SZ_UPGRADE_MFG         TEXT("_RealMfg")

#define SZ_DEFAULT_DESCRIPTION TEXT("Video Display Adapter")
#define SZ_DEFAULT_MFG         TEXT("Microsoft")

#define SZ_LEGACY_UPGRADE      TEXT("_LegacyUpgradeDevice")

#define SZ_ROOT_LEGACY         TEXT("ROOT\\LEGACY_")
#define SZ_ROOT                TEXT("ROOT\\")

#define SZ_BINARY_LEN 32

#define ByteCountOf(x)  ((x) * sizeof(TCHAR))


//
// Data types
//

typedef struct _DEVDATA {
    SP_DEVINFO_DATA did;
    TCHAR szBinary[SZ_BINARY_LEN];
    TCHAR szService[SZ_BINARY_LEN];
} DEVDATA, *PDEVDATA;


//
// Forward declarations
//

BOOL CDECL
DeskLogError(
    LogSeverity Severity,
    UINT MsgId,
    ...
    ); 

DWORD 
DeskGetSetupFlags(
    VOID
    );

BOOL
DeskIsLegacyDevNodeByPath(
    const PTCHAR szRegPath
    );

BOOL
DeskIsLegacyDevNodeByDevInfo(
    PSP_DEVINFO_DATA pDid
    );
 
BOOL
DeskIsRootDevNodeByDevInfo(
    PSP_DEVINFO_DATA pDid
    );

BOOL
DeskGetDevNodePath(
    IN PSP_DEVINFO_DATA pDid,
    IN OUT PTCHAR szPath,
    IN LONG len
    );

VOID
DeskSetServiceStartType(
    LPTSTR ServiceName,
    DWORD dwStartType
    );

DWORD
DeskInstallService(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL,
    IN LPTSTR pServiceName
    );

DWORD
DeskInstallServiceExtensions(
    IN HWND hwnd,
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PSP_DRVINFO_DATA DriverInfoData,
    IN PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData,
    IN LPTSTR pServiceName
    );

VOID
DeskMarkUpNewDevNode(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    );

VOID
DeskNukeDevNode(
    LPTSTR szService,
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData
    );

PTCHAR 
DeskFindMatchingId(
    PTCHAR DeviceId,    
    PTCHAR IdList
    );

UINT
DeskDisableLegacyDeviceNodes(
    VOID 
    );

VOID
DeskDisableServices(
    );

DWORD
DeskPerformDatabaseUpgrade(
    HINF hInf,
    PINFCONTEXT pInfContext,
    BOOL bUpgrade,
    PTCHAR szDriverListSection,
    BOOL* pbForceDeleteAppletExt
    );

DWORD 
DeskCheckDatabase(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    BOOL* pbDeleteAppletExt
    );

VOID
DeskGetUpgradeDeviceStrings(
    PTCHAR Description,
    PTCHAR MfgName,
    PTCHAR ProviderName
    );

DWORD
OnAllowInstall(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    );

DWORD
OnSelectBestCompatDrv(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    );

DWORD
OnSelectDevice(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL
    );

DWORD
OnInstallDevice(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData 
    );

BOOL
DeskGetVideoDeviceKey(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN LPTSTR pServiceName,
    IN DWORD DeviceX,
    OUT HKEY* phkDevice
    );

BOOL
DeskIsServiceDisableable(
    PTCHAR szService
    );

VOID
DeskDeleteAppletExtensions(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData 
    );

VOID
DeskAEDelete(
    PTCHAR szDeleteFrom,
    PTCHAR mszExtensionsToRemove
    );

VOID
DeskAEMove(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData,
    HKEY hkMoveFrom,
    PAPPEXT pAppExtBefore,
    PAPPEXT pAppExtAfter
    );


//
// Display class installer
//

DWORD
DisplayClassInstaller(
    IN DI_FUNCTION InstallFunction,
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL
    )

/*++

Routine Description:

  This routine acts as the class installer for Display devices.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    pDeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    DWORD retVal = ERROR_DI_DO_DEFAULT;
    BOOL bHandled = TRUE;
    TCHAR szDevNode[LINE_LEN];

    DeskOpenLog();

    switch(InstallFunction) {

    case DIF_SELECTDEVICE : 

        retVal = OnSelectDevice(hDevInfo, pDeviceInfoData);
        break;

    case DIF_SELECTBESTCOMPATDRV :

        retVal = OnSelectBestCompatDrv(hDevInfo, pDeviceInfoData);
        break;

    case DIF_ALLOW_INSTALL :

        retVal = OnAllowInstall(hDevInfo, pDeviceInfoData);
        break;

    case DIF_INSTALLDEVICE :
        
        retVal = OnInstallDevice(hDevInfo, pDeviceInfoData);
        break;

    default:

        bHandled = FALSE;
        break;
    }

    if (bHandled && 
        (pDeviceInfoData != NULL) &&
        (DeskGetDevNodePath(pDeviceInfoData, szDevNode, LINE_LEN-1)))
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_125, 
                     retVal, 
                     InstallFunction,
                     szDevNode);
    }
    else
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_057, 
                     retVal, 
                     InstallFunction);
    }

    DeskCloseLog();

    //
    // If we did not exit from the routine by handling the call, 
    // tell the setup code to handle everything the default way.
    //

    return retVal;
}

/*
void StrClearHighBits(LPTSTR pszString, DWORD cchSize)
{
    // This string can not have any high bits set
}
*/

// Monitor class installer
DWORD
MonitorClassInstaller(
    IN DI_FUNCTION InstallFunction,
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL
    )

/*++

Routine Description:

  This routine acts as the class installer for Display devices.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    pDeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    return ERROR_DI_DO_DEFAULT;
}


//
// Handler functions
//

DWORD
OnAllowInstall(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    DWORD cbOutputSize;
    HINF hInf = INVALID_HANDLE_VALUE;
    TCHAR ActualInfSection[LINE_LEN];
    INFCONTEXT InfContext;
    ULONG DevStatus = 0, DevProblem = 0;
    CONFIGRET Result;
    DWORD dwRet = ERROR_DI_DO_DEFAULT;
    
    ASSERT (pDeviceInfoData != NULL);

    //
    // Do not allow install if the device is to be removed.
    //
    
    Result = CM_Get_DevNode_Status(&DevStatus,
                                   &DevProblem,
                                   pDeviceInfoData->DevInst,
                                   0);

    if ((Result == CR_SUCCESS) &&
        ((DevStatus & DN_WILL_BE_REMOVED) != 0)) {
        
        //
        // Message Box?
        //

        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_099);
        dwRet = ERROR_DI_DONT_INSTALL;
        goto Fallout;
    }

    //
    // Check for a Win95 Driver
    //

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver(hDevInfo,
                                  pDeviceInfoData,
                                  &DriverInfoData))
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnAllowInstall: SetupDiGetSelectedDriver"),
                     GetLastError());
        goto Fallout;
    }

    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!(SetupDiGetDriverInfoDetail(hDevInfo,
                                     pDeviceInfoData,
                                     &DriverInfoData,
                                     &DriverInfoDetailData,
                                     DriverInfoDetailData.cbSize,
                                     &cbOutputSize)) &&
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnAllowInstall: SetupDiGetDriverInfoDetail"),
                     GetLastError());
        goto Fallout;
    }

    //
    // Open the INF that installs this driver node, so we can 'pre-run' the
    // AddService/DelService entries in its install service install section.
    //

    hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE)
    {
        //
        // For some reason we couldn't open the INF--this should never happen.
        //

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("OnAllowInstall: SetupOpenInfFile"));
        goto Fallout;
    }

    //
    // Now find the actual (potentially OS/platform-specific) install section name.
    //

    if (!SetupDiGetActualSectionToInstall(hInf,
                                          DriverInfoDetailData.SectionName,
                                          ActualInfSection,
                                          ARRAYSIZE(ActualInfSection),
                                          NULL,
                                          NULL))
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnAllowInstall: SetupDiGetActualSectionToInstall"),
                     GetLastError());
        goto Fallout;
    }

    //
    // Append a ".Services" to get the service install section name.
    //

    lstrcat(ActualInfSection, TEXT(".Services"));

    //
    // See if the section exists.
    //

    if (!SetupFindFirstLine(hInf,
                            ActualInfSection,
                            NULL,
                            &InfContext))
    {
        //
        // Message Box?
        //

        DeskLogError(LogSevError, 
                     IDS_SETUPLOG_MSG_041, 
                     DriverInfoDetailData.InfFileName);
        dwRet = ERROR_NON_WINDOWS_NT_DRIVER;
    }

Fallout:

    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    return dwRet;
}

VOID
DeskModifyDriverRank(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )
{
    //
    // Regardless of whether a driver is properly signed or not
    // we don't want any W2K drivers to be choosen by default.  We have
    // simply found to many w2k drivers that don't work well on
    // windows XP.  So instead lets treat all drivers signed or not
    // as unsigned if they were released before we started signing
    // windows xp drivers.  [We have to do this because some w2k
    // drivers were incorrectly signed as winxp (5.x) drivers]
    //

    ULONG i=0;
    SP_DRVINFO_DATA_V2 DrvInfoData;
    SP_DRVINSTALL_PARAMS DrvInstallParams;
    SYSTEMTIME SystemTime;

    DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA_V2);

    while (SetupDiEnumDriverInfo(hDevInfo,
           pDeviceInfoData,
           SPDIT_COMPATDRIVER,
           i++,
           &DrvInfoData)) {

        if (FileTimeToSystemTime(&DrvInfoData.DriverDate, &SystemTime)) {

            if (((SystemTime.wYear < 2001) ||
                 ((SystemTime.wYear == 2001) && (SystemTime.wMonth < 6)))) {

                //
                // If this was created before Jun. 2001 then we want to make it a
                // worse match than our in the box driver.  We'll do this by
                // treating it as unsigned.
                //

                ZeroMemory(&DrvInstallParams, sizeof(SP_DRVINSTALL_PARAMS));
                DrvInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);

                if (SetupDiGetDriverInstallParams(hDevInfo,
                                                  pDeviceInfoData,
                                                  &DrvInfoData,
                                                  &DrvInstallParams)) {

                    DrvInstallParams.Rank |= DRIVER_UNTRUSTED_RANK;

                    SetupDiSetDriverInstallParams(hDevInfo,
                                                  pDeviceInfoData,
                                                  &DrvInfoData,
                                                  &DrvInstallParams);
                }
            }
        }
    }
}

DWORD
OnSelectBestCompatDrv(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )
{
    SP_DEVINSTALL_PARAMS DevInstParam;
    SP_DRVINFO_DATA DrvInfoData;
    PTCHAR szDesc = NULL, szMfg = NULL;
    HKEY hKey;
    DWORD dwFailed;
    BOOL bDummy = FALSE;
    DWORD dwLegacyUpgrade = 1;
    DWORD dwRet = ERROR_DI_DO_DEFAULT; 

    DeskModifyDriverRank(hDevInfo, pDeviceInfoData);

    if (DeskIsLegacyDevNodeByDevInfo(pDeviceInfoData)) {

        //
        // Always allow root devices in select
        //

        goto Fallout;
    }

    //
    // Check the database to see if this is an approved driver.
    // We need the test only during an upgrade.
    //

    if (((DeskGetSetupFlags() & INSETUP_UPGRADE) == 0) ||
        (DeskCheckDatabase(hDevInfo, 
                           pDeviceInfoData,
                           &bDummy) == ERROR_SUCCESS)) {

        //
        // It is, no other work is necessary
        //
        
        goto Fallout;
    }

    //
    // This particular vid card is not allowed to run with drivers out 
    // of the box.  Note this event in the reg and save off other values.
    // Also, install a fake device onto the devnode so that the user doesn't 
    // get PnP popus upon first (real) boot
    //
    
    DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_046);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_UPDATE_SETTINGS,
                     0,
                     KEY_ALL_ACCESS,
                     &hKey) == ERROR_SUCCESS) {

        // 
        // Save off the fact that upgrade was not allowed (used in migrated 
        // display settings in the display OC
        // 

        dwFailed = 1;
        RegSetValueEx(hKey, 
                      SZ_UPGRADE_FAILED_ALLOW_INSTALL,
                      0,
                      REG_DWORD, 
                      (PBYTE) &dwFailed,
                      sizeof(DWORD));

        RegCloseKey(hKey);
    }

    //
    // Grab the description of the device so we can give it to the devnode
    // after a succesfull install of the fake devnode
    //

    ZeroMemory(&DrvInfoData, sizeof(DrvInfoData));
    DrvInfoData.cbSize = sizeof(DrvInfoData);

    if (SetupDiEnumDriverInfo(hDevInfo,
                              pDeviceInfoData,
                              SPDIT_COMPATDRIVER,
                              0,
                              &DrvInfoData)) {

        if (lstrlen(DrvInfoData.Description)) {
            szDesc = DrvInfoData.Description;
        }
        
        if (lstrlen(DrvInfoData.MfgName)) {
            szMfg = DrvInfoData.MfgName;
        }
    
    } else {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_047);
    }

    if (!szDesc) {
        szDesc = SZ_DEFAULT_DESCRIPTION;
    }

    if (!szMfg) {
        szMfg = SZ_DEFAULT_MFG;
    }

    //
    // Save the description of the device under the device registry key
    //

    if ((hKey = SetupDiCreateDevRegKey(hDevInfo,
                                       pDeviceInfoData,
                                       DICS_FLAG_GLOBAL,
                                       0,
                                       DIREG_DEV,
                                       NULL,
                                       NULL)) != INVALID_HANDLE_VALUE) {

        RegSetValueEx(hKey,
                      SZ_UPGRADE_DESCRIPTION,
                      0,
                      REG_SZ,
                      (PBYTE) szDesc, 
                      ByteCountOf(lstrlen(szDesc) + 1));

        RegSetValueEx(hKey,
                      SZ_UPGRADE_MFG,
                      0,
                      REG_SZ,
                      (PBYTE) szMfg, 
                      ByteCountOf(lstrlen(szMfg) + 1));

        RegSetValueEx(hKey,
                      SZ_LEGACY_UPGRADE,
                      0,
                      REG_DWORD,
                      (PBYTE)&dwLegacyUpgrade, 
                      sizeof(DWORD));

        RegCloseKey(hKey);
    
    } else {

        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_048);
    }

    //
    // Make sure there isn't already a class driver list built for this 
    // device information element
    //

    if (!SetupDiDestroyDriverInfoList(hDevInfo, pDeviceInfoData, SPDIT_CLASSDRIVER)) {

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("OnSelectBestCompatDrv: SetupDiDestroyDriverInfoList"));
    }

    //
    // Build a class driver list off of display.inf.
    //

    DevInstParam.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (!SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DevInstParam)) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnSelectBestCompatDrv: SetupDiGetDeviceInstallParams"),
                     GetLastError());
        goto Fallout;
    }

    DevInstParam.Flags |= DI_ENUMSINGLEINF;
    lstrcpy(DevInstParam.DriverPath, TEXT("display.inf"));
    
    if (!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DevInstParam)) {

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnSelectBestCompatDrv: SetupDiSetDeviceInstallParams"),
                     GetLastError());
        goto Fallout;
    }

    if (!SetupDiBuildDriverInfoList(hDevInfo, pDeviceInfoData, SPDIT_CLASSDRIVER)) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnSelectBestCompatDrv: SetupDiBuildDriverInfoList"),
                     GetLastError());
        goto Fallout;
    }

    //
    // Now select the fake node.
    // All strings here match the inf fake device entry section.  
    // If the INF is modified in any way WRT to these strings, 
    // these to be changed as well
    //

    ZeroMemory(&DrvInfoData, sizeof(SP_DRVINFO_DATA));
    DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    DrvInfoData.DriverType = SPDIT_CLASSDRIVER;
    
    DeskGetUpgradeDeviceStrings(DrvInfoData.Description,
                                DrvInfoData.MfgName,
                                DrvInfoData.ProviderName);

    if (!SetupDiSetSelectedDriver(hDevInfo, pDeviceInfoData, &DrvInfoData)) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnSelectBestCompatDrv: SetupDiSetSelectedDriver"),
                     GetLastError());
        goto Fallout;
    }

    dwRet = NO_ERROR;

Fallout:

    return dwRet;
}


DWORD
OnSelectDevice(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL
    )
{
    DWORD retVal = ERROR_DI_DO_DEFAULT;
    DWORD index = 0, reqSize = 0, curSize = 0;
    PSP_DRVINFO_DETAIL_DATA pDrvInfoDetailData = NULL;
    SP_DRVINFO_DATA DrvInfoData;
    SP_DRVINSTALL_PARAMS DrvInstallParams;

    //
    // Build the list of drivers
    //

    if (!SetupDiBuildDriverInfoList(hDevInfo, 
                                    pDeviceInfoData, 
                                    SPDIT_CLASSDRIVER)) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("OnSelectDevice: SetupDiBuildDriverInfoList"),
                     GetLastError());
        goto Fallout;
    }

    ZeroMemory(&DrvInfoData, sizeof(SP_DRVINFO_DATA));
    DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    while (SetupDiEnumDriverInfo(hDevInfo,
                                 pDeviceInfoData,
                                 SPDIT_CLASSDRIVER,
                                 index,
                                 &DrvInfoData)) {

        //
        // Get the required size
        //

        reqSize = 0;
        SetupDiGetDriverInfoDetail(hDevInfo,
                                   pDeviceInfoData,
                                   &DrvInfoData,
                                   NULL,
                                   0,
                                   &reqSize);
        
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_126,
                         TEXT("OnSelectDevice: SetupDiGetDriverInfoDetail"),
                         GetLastError());
            goto Fallout;
        }

        //
        // Allocate memory, if needed
        //

        if ((reqSize > curSize) || (pDrvInfoDetailData == NULL)) {
        
            curSize = reqSize;
    
            if (pDrvInfoDetailData != NULL) {
                LocalFree(pDrvInfoDetailData);
            }
    
            pDrvInfoDetailData = (PSP_DRVINFO_DETAIL_DATA)LocalAlloc(LPTR, curSize);
    
            if (pDrvInfoDetailData == NULL) {
    
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_127,
                             TEXT("OnSelectDevice: LocalAlloc"));
                goto Fallout; 
            }
        
        } else {

            ZeroMemory(pDrvInfoDetailData, reqSize);
        }

        //
        // Get the driver detail info
        //

        pDrvInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

        if (!SetupDiGetDriverInfoDetail(hDevInfo,
                                        pDeviceInfoData,
                                        &DrvInfoData,
                                        pDrvInfoDetailData,
                                        reqSize,
                                        NULL)) {
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_126,
                         TEXT("OnSelectDevice: SetupDiGetDriverInfoDetail"),
                         GetLastError());
            goto Fallout;
        }
            
        if (lstrcmpi(pDrvInfoDetailData->HardwareID, 
                     TEXT("LEGACY_UPGRADE_ID")) == 0) {

            //
            // Mark the legacy upgrade drv. info as "bad" so that it is 
            // not shown when the user is prompted to select the driver
            //
            
            ZeroMemory(&DrvInstallParams, sizeof(SP_DRVINSTALL_PARAMS));
            DrvInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
            
            if (SetupDiGetDriverInstallParams(hDevInfo,
                                              pDeviceInfoData,
                                              &DrvInfoData,
                                              &DrvInstallParams)) {
                
                DrvInstallParams.Flags |=  DNF_BAD_DRIVER;
                
                SetupDiSetDriverInstallParams(hDevInfo,
                                              pDeviceInfoData,
                                              &DrvInfoData,
                                              &DrvInstallParams);
            }
        }

        //
        // Get the next driver info
        //

        ZeroMemory(&DrvInfoData, sizeof(SP_DRVINFO_DATA));
        DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

        ++index;
    }

Fallout:
    
    if (pDrvInfoDetailData) {
        LocalFree(pDrvInfoDetailData);
    }

    return retVal;
}


DWORD
OnInstallDevice(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData 
    )
{
    DWORD retVal = ERROR_DI_DO_DEFAULT;
    DWORD dwLegacyUpgrade, dwSize;
    DISPLAY_DEVICE displayDevice;
    TCHAR szBuffer[LINE_LEN];
    PTCHAR szHardwareIds = NULL;
    BOOL bDisableLegacyDevices = TRUE;
    ULONG len = 0;
    HKEY hkDevKey;

    //
    // Disable legacy devices if pDeviceInfoData is not:
    //     - a root device or
    //     - legacy upgrade device
    //

    if (DeskIsRootDevNodeByDevInfo(pDeviceInfoData)) {
    
        //
        // Root device
        //

        bDisableLegacyDevices = FALSE;
    
    } else {
    
        //
        // Is this the legacy upgrade device?
        //

        hkDevKey = SetupDiOpenDevRegKey(hDevInfo,
                                        pDeviceInfoData,
                                        DICS_FLAG_GLOBAL,
                                        0,
                                        DIREG_DEV,
                                        KEY_ALL_ACCESS);

        if (hkDevKey != INVALID_HANDLE_VALUE) {
        
            dwSize = sizeof(DWORD);
            if (RegQueryValueEx(hkDevKey,
                                 SZ_LEGACY_UPGRADE,
                                 0,
                                 NULL,
                                 (PBYTE)&dwLegacyUpgrade,
                                 &dwSize) == ERROR_SUCCESS) {
                 
                if (dwLegacyUpgrade == 1) {

                    //
                    // Legacy upgrade device
                    //
    
                    bDisableLegacyDevices = FALSE;
                }

                RegDeleteValue(hkDevKey, SZ_LEGACY_UPGRADE);
            }

            RegCloseKey(hkDevKey);
        }
    }

    if (bDisableLegacyDevices) {

        if ((DeskGetSetupFlags() & INSETUP_UPGRADE) != 0) {
        
            //
            // Delete legacy applet extensions
            //

            DeskDeleteAppletExtensions(hDevInfo, pDeviceInfoData);
        }
        
        //
        // Disable legacy devices
        //

        DeskDisableLegacyDeviceNodes();
    }

    retVal = DeskInstallService(hDevInfo,
                                pDeviceInfoData,
                                szBuffer);

    if ((retVal == ERROR_NO_DRIVER_SELECTED) &&
        (DeskGetSetupFlags() & INSETUP_UPGRADE) &&
        DeskIsLegacyDevNodeByDevInfo(pDeviceInfoData)) {
        
        //
        // If this is a legacy device and no driver is selected,
        // let the default handler install a NULL driver.
        //
        
        retVal = ERROR_DI_DO_DEFAULT;
    }

    //
    // Calling EnumDisplayDevices will rescan the devices, and if a
    // new device is detected, we will disable and reenable the main
    // device. This reset of the display device will clear up any 
    // mess caused by installing a new driver
    //

    displayDevice.cb = sizeof(DISPLAY_DEVICE);
    EnumDisplayDevices(NULL, 0, &displayDevice, 0);

    return retVal;
}


//
// Logging function
//

BOOL CDECL
DeskLogError(
    LogSeverity Severity,
    UINT MsgId,
    ...
    ) 
/*++

Outputs a message to the setup log.  Prepends "desk.cpl  " to the strings and 
appends the correct newline chars (\r\n)

--*/
{
    int cch;
    TCHAR ach[1024+40];    // Largest path plus extra
    TCHAR szMsg[1024];     // MsgId
    va_list vArgs;

    static int setupState = 0;

    if (setupState == 0) {

        if (DeskGetSetupFlags() & (INSETUP | INSETUP_UPGRADE)) {
            
            setupState = 1;
        
        } else {
            
            setupState = 2;
        }
    }

    if (setupState == 1) {
        
        *szMsg = 0;
        if (LoadString(hInstance,
                       MsgId,
                       szMsg,
                       ARRAYSIZE(szMsg))) {

            *ach = 0;
            LoadString(hInstance,
                       IDS_SETUPLOG_MSG_000,
                       ach,
                       ARRAYSIZE(ach));
                       
            cch = lstrlen(ach);
            va_start(vArgs, MsgId);
            wvsprintf(&ach[cch], szMsg, vArgs);
            lstrcat(ach, TEXT("\r\n"));
            va_end(vArgs);
    
            return SetupLogError(ach, Severity);
        
        } else {
            
            return FALSE;
        }
    
    } else {

        va_start(vArgs, MsgId);
        va_end(vArgs);
        
        return TRUE;
    }
}


//
// Service Controller stuff
//

VOID
DeskSetServiceStartType(
    LPTSTR ServiceName,
    DWORD dwStartType
    )
{
    SC_HANDLE SCMHandle;
    SC_HANDLE ServiceHandle;
    ULONG Attempts;
    SC_LOCK SCLock = NULL;
    ULONG ServiceConfigSize = 0;
    LPQUERY_SERVICE_CONFIG ServiceConfig;

    //
    // Open the service controller
    // Open the service
    // Change the service.
    //

    if (SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))
    {
        if (ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS))
        {
            QueryServiceConfig(ServiceHandle,
                               NULL,
                               0,
                               &ServiceConfigSize);

            ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);

            if (ServiceConfig = (LPQUERY_SERVICE_CONFIG)
                                 LocalAlloc(LPTR, ServiceConfigSize))
            {
                if (QueryServiceConfig(ServiceHandle,
                                       ServiceConfig,
                                       ServiceConfigSize,
                                       &ServiceConfigSize))
                {
                    //
                    // Attempt to acquite the database lock.
                    //

                    for (Attempts = 20;
                         ((SCLock = LockServiceDatabase(SCMHandle)) == NULL) && Attempts;
                         Attempts--)
                    {
                        //
                        // Lock SC database locked
                        // 

                        Sleep(500);
                    }

                    //
                    // Change the service to demand start
                    //

                    if (!ChangeServiceConfig(ServiceHandle,
                                             SERVICE_NO_CHANGE,
                                             dwStartType,
                                             SERVICE_NO_CHANGE,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL))
                    {
                        DeskLogError(LogSevInformation, 
                                     IDS_SETUPLOG_MSG_126,
                                     TEXT("DeskSetServiceStartType: ChangeServiceConfig"),
                                     GetLastError());
                    }

                    if (SCLock)
                    {
                        UnlockServiceDatabase(SCLock);
                    }
                
                } else {
                
                    DeskLogError(LogSevInformation, 
                                 IDS_SETUPLOG_MSG_126,
                                 TEXT("DeskSetServiceStartType: QueryServiceConfig"),
                                 GetLastError());
                }

                LocalFree(ServiceConfig);
            
            } else {
            
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_127,
                             TEXT("DeskSetServiceStartType: LocalAlloc"));
            }

            CloseServiceHandle(ServiceHandle);
        
        } else {
        
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_126,
                         TEXT("DeskSetServiceStartType: OpenService"),
                         GetLastError());
        }

        CloseServiceHandle(SCMHandle);
    
    } else {

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskSetServiceStartType: OpenSCManager"),
                     GetLastError());

    }
}


//
// Service Installation
//


DWORD
DeskInstallServiceExtensions(
    IN HWND hwnd,
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PSP_DRVINFO_DATA DriverInfoData,
    IN PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData,
    IN LPTSTR pServiceName
    )
{
    DWORD retVal = NO_ERROR;
    HINF InfFileHandle;
    INFCONTEXT tmpContext;
    TCHAR szSoftwareSection[LINE_LEN];
    INT maxmem;
    INT numDev;
#ifndef _WIN64
    SP_DEVINSTALL_PARAMS   DeviceInstallParams;
#endif
    TCHAR keyName[LINE_LEN];
    DWORD disposition;
    HKEY hkey;

    //
    // Open the inf so we can run the sections in the inf, more or less manually.
    //

    InfFileHandle = SetupOpenInfFile(DriverInfoDetailData->InfFileName,
                                     NULL,
                                     INF_STYLE_WIN4,
                                     NULL);

    if (InfFileHandle == INVALID_HANDLE_VALUE)
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("DeskInstallServiceExtensions: SetupOpenInfFile"));

        return ERROR_INVALID_PARAMETER;
    }


    //
    // Get any interesting configuration data for the inf file.
    //

    maxmem = 8;
    numDev = 1;

    wsprintf(szSoftwareSection,
             TEXT("%ws.GeneralConfigData"),
             DriverInfoDetailData->SectionName);

    if (SetupFindFirstLine(InfFileHandle,
                           szSoftwareSection,
                           TEXT("MaximumNumberOfDevices"),
                           &tmpContext))
    {
        SetupGetIntField(&tmpContext,
                         1,
                         &numDev);
    }

    if (SetupFindFirstLine(InfFileHandle,
                           szSoftwareSection,
                           TEXT("MaximumDeviceMemoryConfiguration"),
                           &tmpContext))
    {
        SetupGetIntField(&tmpContext,
                         1,
                         &maxmem);
    }

    //
    // Create the <Service> key.
    //

    wsprintf(keyName,
             TEXT("System\\CurrentControlSet\\Services\\%ws"),
             pServiceName);

    RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                   keyName,
                   0,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ | KEY_WRITE,
                   NULL,
                   &hkey,
                   &disposition);

#ifndef _WIN64

    //
    // Increase the number of system PTEs if we have cards that will need
    // more than 10 MB of PTE mapping space.  This only needs to be done for
    // 32-bit NT as virtual address space is limited.  On 64-bit NT there is
    // always enough PTE mapping address space so don't do anything as you're
    // likely to get it wrong.
    //

    if ((maxmem = maxmem * numDev) > 10)
    {
        //
        // On x86, 1K PTEs support 4 MB.
        // Then add 50% for other devices this type of machine may have.
        // NOTE - in the future, we may want to be smarter and try
        // to merge with whatever someone else put in there.
        //

        maxmem = maxmem * 0x400 * 3/2 + 0x3000;

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE,
                           NULL,
                           &hkey,
                           &disposition) == ERROR_SUCCESS)
        {
            //
            // Check if we already set maxmem in the registry.
            //

            DWORD data;
            DWORD cb = sizeof(data);

            if ((RegQueryValueEx(hkey,
                                 TEXT("SystemPages"),
                                 NULL,
                                 NULL,
                                 (LPBYTE)(&data),
                                 &cb) != ERROR_SUCCESS) ||
                 (data < (DWORD) maxmem))
            {
                //
                // Set the new value
                //

                RegSetValueEx(hkey,
                              TEXT("SystemPages"),
                              0,
                              REG_DWORD,
                              (LPBYTE) &maxmem,
                              sizeof(DWORD));

                //
                // Tell the system we must reboot before running this driver
                // in case the system has less than 128M.
                //

                MEMORYSTATUSEX MemStatus;
                SYSTEM_INFO SystemInfo;

                GetSystemInfo(&SystemInfo);
                MemStatus.dwLength = sizeof(MemStatus);

                if ((SystemInfo.dwPageSize == 0) ||
                    (!GlobalMemoryStatusEx(&MemStatus)) ||
                    ((MemStatus.ullTotalPhys  / SystemInfo.dwPageSize) <= 0x7F00))
                {
                    ZeroMemory(&DeviceInstallParams, sizeof(DeviceInstallParams));
                    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    
                    if (SetupDiGetDeviceInstallParams(hDevInfo,
                                                      pDeviceInfoData,
                                                      &DeviceInstallParams)) {
    
                        DeviceInstallParams.Flags |= DI_NEEDREBOOT;
    
                        if (!SetupDiSetDeviceInstallParams(hDevInfo,
                                                           pDeviceInfoData,
                                                           &DeviceInstallParams)) {
                            
                            DeskLogError(LogSevInformation, 
                                         IDS_SETUPLOG_MSG_126,
                                         TEXT("DeskInstallServiceExtensions: SetupDiSetDeviceInstallParams"),
                                         GetLastError());
                        }
    
                    } else {
    
                        DeskLogError(LogSevInformation, 
                                     IDS_SETUPLOG_MSG_126,
                                     TEXT("DeskInstallServiceExtensions: SetupDiGetDeviceInstallParams"),
                                     GetLastError());
                    }
                }
            }

            RegCloseKey(hkey);
        }
    }
#endif

    //
    // We may have to do this for multiple adapters at this point.
    // So loop throught the number of devices, which has 1 as the default value.
    // For dual view, videoprt.sys will create [GUID]\000X entries as needed 
    // and will copy all the entries from the "Settings" key to [GUID]\000X.
    //

    DWORD dwSoftwareSettings = 1;
    DWORD dwDeviceX = 0;

    do {

        if (dwSoftwareSettings == 1)
        {
            //
            // Install everything under the old video device key:
            //     HKLM\System\CCS\Services\[SrvName]\DeviceX
            //

            numDev--;
            
            if (numDev == 0) 
                dwSoftwareSettings++;

            //
            // For all drivers, install the information under DeviceX
            // We do this for legacy purposes since many drivers rely on
            // information written to this key.
            //

            wsprintf(keyName,
                     TEXT("System\\CurrentControlSet\\Services\\%ws\\Device%d"),
                     pServiceName, numDev);

            if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                               keyName,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_READ | KEY_WRITE,
                               NULL,
                               &hkey,
                               &disposition) != ERROR_SUCCESS) {
                hkey = (HKEY) INVALID_HANDLE_VALUE;
            }
        }
        else if (dwSoftwareSettings == 2) 
        {
            //
            // Install everything under the new video device key:
            //     HKLM\System\CCS\Control\Video\[GUID]\000X
            //

            if (DeskGetVideoDeviceKey(hDevInfo,
                                      pDeviceInfoData,
                                      pServiceName,
                                      dwDeviceX,
                                      &hkey)) 
            {
                dwDeviceX++;
            }
            else
            {
                hkey = (HKEY) INVALID_HANDLE_VALUE;
                dwSoftwareSettings++;
            }
        }
        else if (dwSoftwareSettings == 3)
        {

            dwSoftwareSettings++;

            //
            // Install everything under the driver (aka software) key:
            //     HKLM\System\CCS\Control\Class\[Display class]\000X\Settings
            //

            hkey = (HKEY) INVALID_HANDLE_VALUE;

            HKEY hKeyDriver = SetupDiOpenDevRegKey(hDevInfo,
                                                  pDeviceInfoData,
                                                  DICS_FLAG_GLOBAL,
                                                  0,
                                                  DIREG_DRV,
                                                  KEY_ALL_ACCESS);

            if (hKeyDriver != INVALID_HANDLE_VALUE) {

                //
                // Delete the old settings and applet extensions before 
                // installing the new driver
                //

                SHDeleteKey(hKeyDriver, TEXT("Settings"));
                SHDeleteKey(hKeyDriver, TEXT("Display"));
                
                //
                // Create/open the settings key
                //

                if (RegCreateKeyEx(hKeyDriver,
                                   TEXT("Settings"),
                                   0,
                                   NULL,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hkey,
                                   NULL) != ERROR_SUCCESS) {

                    hkey = (HKEY)INVALID_HANDLE_VALUE;
                }

                RegCloseKey(hKeyDriver);
            }
        } 

        if (hkey != INVALID_HANDLE_VALUE)
	{
	    //
            // Delete the CapabilityOverride key.
            //

            RegDeleteValue(hkey,
                           TEXT("CapabilityOverride"));

            wsprintf(szSoftwareSection,
                     TEXT("%ws.SoftwareSettings"),
                     DriverInfoDetailData->SectionName);

            if (!SetupInstallFromInfSection(hwnd,
                                            InfFileHandle,
                                            szSoftwareSection,
                                            SPINST_REGISTRY,
                                            hkey,
                                            NULL,
                                            0,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL))
            {
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_126,
                             TEXT("DeskInstallServiceExtensions: SetupInstallFromInfSection"),
                             GetLastError());

                RegCloseKey(hkey);
                return ERROR_INVALID_PARAMETER;
            }

            //
            // Write the description of the device 
            //

            RegSetValueEx(hkey,
                          TEXT("Device Description"),
                          0,
                          REG_SZ,
                          (LPBYTE) DriverInfoDetailData->DrvDescription,
			  ByteCountOf(lstrlen(DriverInfoDetailData->DrvDescription) + 1));

	    RegCloseKey(hkey);
        }

    } while (dwSoftwareSettings <= 3);

    //
    // Optionally run the OpenGl section in the inf.
    // Ignore any errors at this point since this is an optional entry.
    //

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\OpenGLDrivers"),
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE,
                       NULL,
                       &hkey,
                       &disposition) == ERROR_SUCCESS)
    {
        wsprintf(szSoftwareSection,
                 TEXT("%ws.OpenGLSoftwareSettings"),
                 DriverInfoDetailData->SectionName);

        SetupInstallFromInfSection(hwnd,
                                   InfFileHandle,
                                   szSoftwareSection,
                                   SPINST_REGISTRY,
                                   hkey,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL);

        RegCloseKey(hkey);
    }

    SetupCloseInfFile(InfFileHandle);

    return retVal;
}


DWORD
DeskInstallService(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData OPTIONAL,
    IN LPTSTR pServiceName
    )
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    DWORD cbOutputSize;
    HINF hInf = INVALID_HANDLE_VALUE;
    TCHAR ActualInfSection[LINE_LEN];
    INFCONTEXT infContext;
    DWORD status = NO_ERROR;
    PAPPEXT pAppExtDisplayBefore = NULL, pAppExtDisplayAfter = NULL;
    PAPPEXT pAppExtDeviceBefore = NULL, pAppExtDeviceAfter = NULL;
    HKEY hkDisplay = 0, hkDevice = 0;

    //
    // Get the params so we can get the window handle.
    //

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    SetupDiGetDeviceInstallParams(hDevInfo,
                                  pDeviceInfoData,
                                  &DeviceInstallParams);

    //
    // Retrieve information about the driver node selected for this device.
    //

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if (!SetupDiGetSelectedDriver(hDevInfo,
                                  pDeviceInfoData,
                                  &DriverInfoData)) {

        status = GetLastError();
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskInstallService: SetupDiGetSelectedDriver"),
                     status);

        goto Fallout;
    }

    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    if (!(SetupDiGetDriverInfoDetail(hDevInfo,
                                     pDeviceInfoData,
                                     &DriverInfoData,
                                     &DriverInfoDetailData,
                                     DriverInfoDetailData.cbSize,
                                     &cbOutputSize)) &&
        (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        
        status = GetLastError();
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskInstallService: SetupDiGetDriverInfoDetail"),
                     status);
        goto Fallout;
    }

    //
    // Open the INF that installs this driver node, so we can 'pre-run' the
    // AddService/DelService entries in its install service install section.
    //

    hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        
        //
        // For some reason we couldn't open the INF--this should never happen.
        //

        status = ERROR_INVALID_HANDLE;
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("DeskInstallService: SetupOpenInfFile"));
        goto Fallout;
    }

    //
    // Now find the actual (potentially OS/platform-specific) install section name.
    //

    if (!SetupDiGetActualSectionToInstall(hInf,
                                          DriverInfoDetailData.SectionName,
                                          ActualInfSection,
                                          sizeof(ActualInfSection) / sizeof(TCHAR),
                                          NULL,
                                          NULL)) {

        status = GetLastError();
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskInstallService: SetupDiGetActualSectionToInstall"),
                     status);
        goto Fallout;
    }
    
    //
    // Append a ".Services" to get the service install section name.
    //

    lstrcat(ActualInfSection, TEXT(".Services"));

    //
    // Now run the service modification entries in this section...
    //

    if (!SetupInstallServicesFromInfSection(hInf,
                                            ActualInfSection,
                                            0))
    {
        status = GetLastError();
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskInstallService: SetupInstallServicesFromInfSection"),
                     status);
        goto Fallout;
    }

    //
    // Get the service Name if needed (detection)
    //

    if (SetupFindFirstLine(hInf,
                           ActualInfSection,
                           TEXT("AddService"),
                           &infContext))
    {
        SetupGetStringField(&infContext,
                            1,
                            pServiceName,
                            LINE_LEN,
                            NULL);
    }

    //
    // Get a snapshot of the applet extensions installed under generic 
    // Device and Display keys
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_CONTROLSFOLDER_DISPLAY_SHEX_PROPSHEET,
                     0,
                     KEY_ALL_ACCESS,
                     &hkDisplay) == ERROR_SUCCESS) {

        DeskAESnapshot(hkDisplay, &pAppExtDisplayBefore);
    
    } else {

        hkDisplay = 0;
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_CONTROLSFOLDER_DEVICE_SHEX_PROPSHEET,
                     0,
                     KEY_ALL_ACCESS,
                     &hkDevice) == ERROR_SUCCESS) {

        DeskAESnapshot(hkDevice, &pAppExtDeviceBefore);
    
    } else {

        hkDevice = 0;
    }
    
    //
    // Now that the basic install has been performed (without starting the
    // device), write the extra data to the registry.
    //

    status = DeskInstallServiceExtensions(DeviceInstallParams.hwndParent,
                                          hDevInfo,
                                          pDeviceInfoData,
                                          &DriverInfoData,
                                          &DriverInfoDetailData,
                                          pServiceName);

    if (status != NO_ERROR)
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskInstallService: DeskInstallServiceExtensions"),
                     status);

        goto Fallout;
    }

    //
    // Do the full device install
    // If some of the flags (like paged pool) needed to be changed,
    // let's ask for a reboot right now.
    // Otherwise, we can actually try to start the device at this point.
    //

    if (!SetupDiInstallDevice(hDevInfo, pDeviceInfoData))
    {
        //
        // Remove the device !??
        //

        status = GetLastError();
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskInstallService: SetupDiInstallDevice"),
                     status);
        goto Fallout;
    }
        
    //
    // Get a snapshot of the applet extensions after the device was installed
    // Move the new added extensions under the driver key
    //

    if (hkDisplay != 0) {

        DeskAESnapshot(hkDisplay, &pAppExtDisplayAfter);

        DeskAEMove(hDevInfo,
                   pDeviceInfoData,
                   hkDisplay,
                   pAppExtDisplayBefore,
                   pAppExtDisplayAfter);

        DeskAECleanup(pAppExtDisplayBefore);
        DeskAECleanup(pAppExtDisplayAfter);
    }

    if (hkDevice != 0) {

        DeskAESnapshot(hkDevice, &pAppExtDeviceAfter);

        DeskAEMove(hDevInfo,
                   pDeviceInfoData,
                   hkDevice,
                   pAppExtDeviceBefore,
                   pAppExtDeviceAfter);
        
        DeskAECleanup(pAppExtDeviceBefore);
        DeskAECleanup(pAppExtDeviceAfter);
    }

    //
    // For a PnP Device which will never do detection, we want to mark
    // the device as DemandStart.
    //

    DeskSetServiceStartType(pServiceName, SERVICE_DEMAND_START);

    //
    // Make sure the device description and mfg are the original values
    // and not the marked up ones we might have made during select bext
    // compat drv
    //

    DeskMarkUpNewDevNode(hDevInfo, pDeviceInfoData);

    status = NO_ERROR;

Fallout:
    
    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    if (hkDisplay != 0) {
        RegCloseKey(hkDisplay);
    }

    if (hkDevice != 0) {
        RegCloseKey(hkDevice);
    }
    
    return status;
}


VOID
DeskMarkUpNewDevNode(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )
{
    HKEY hKey;
    PTCHAR szProperty;
    DWORD dwSize;

    //
    // Make sure the device desc is "good". 
    //
    
    if (DeskIsLegacyDevNodeByDevInfo(pDeviceInfoData)) {
        
        //
        // Don't do this to legacy devnode.
        //

        return;
    }
        
    //
    // Open the device registry key.
    // The real manufacturer and description were stored here
    // by the handler of DIF_SELECTBESTCOMPATDRV
    //

    hKey = SetupDiCreateDevRegKey(hDevInfo,
                                  pDeviceInfoData,
                                  DICS_FLAG_GLOBAL,
                                  0,
                                  DIREG_DEV,
                                  NULL,
                                  NULL);

    if (hKey == INVALID_HANDLE_VALUE) {

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskMarkUpNewDevNode: SetupDiCreateDevRegKey"),
                     GetLastError());
        return;
    }

    //
    // Set Description
    //

    dwSize = 0;
    if (RegQueryValueEx(hKey,
                        SZ_UPGRADE_DESCRIPTION,
                        0,
                        NULL,
                        NULL,
                        &dwSize) != ERROR_SUCCESS) {

        goto Fallout;
    }

    ASSERT(dwSize != 0);
    
    dwSize *= sizeof(TCHAR);
    szProperty = (PTCHAR) LocalAlloc(LPTR, dwSize);

    if ((szProperty != NULL) &&  
        (RegQueryValueEx(hKey,
                         SZ_UPGRADE_DESCRIPTION,
                         0,
                         NULL,
                         (PBYTE) szProperty,
                         &dwSize) == ERROR_SUCCESS))
    {
        SetupDiSetDeviceRegistryProperty(hDevInfo,
                                         pDeviceInfoData,
                                         SPDRP_DEVICEDESC,
                                         (PBYTE) szProperty,
                                         ByteCountOf(lstrlen(szProperty)+1));

        RegDeleteValue(hKey, SZ_UPGRADE_DESCRIPTION);

        DeskLogError(LogSevInformation,
                     IDS_SETUPLOG_MSG_004, 
                     szProperty);
    }

    LocalFree(szProperty);
    szProperty = NULL;

    //
    // Set Manufacturer
    //

    dwSize = 0;
    if (RegQueryValueEx(hKey,
                        SZ_UPGRADE_MFG,
                        0,
                        NULL,
                        NULL,
                        &dwSize) != ERROR_SUCCESS) {

        goto Fallout;
    }

    ASSERT(dwSize != 0);
    
    dwSize *= sizeof(TCHAR);
    szProperty = (PTCHAR) LocalAlloc(LPTR, dwSize);
    
    if ((szProperty != NULL) &&  
        (RegQueryValueEx(hKey,
                         SZ_UPGRADE_MFG,
                         0,
                         NULL,
                         (PBYTE) szProperty,
                         &dwSize) == ERROR_SUCCESS))
    {
        SetupDiSetDeviceRegistryProperty(hDevInfo,
                                         pDeviceInfoData,
                                         SPDRP_MFG,
                                         (PBYTE) szProperty,
                                         ByteCountOf(lstrlen(szProperty)+1));

        RegDeleteValue(hKey, SZ_UPGRADE_MFG);

        DeskLogError(LogSevInformation,
                     IDS_SETUPLOG_MSG_006, 
                     szProperty);
    }
    
    LocalFree(szProperty);
    szProperty = NULL;

Fallout:

    RegCloseKey(hKey);
}


//
// Helper functions
//

BOOL
DeskIsLegacyDevNodeByPath(
    const PTCHAR szRegPath
    )
{
    return (_tcsncicmp(SZ_ROOT_LEGACY, szRegPath, _tcslen(SZ_ROOT_LEGACY)) == 0);
}


BOOL
DeskIsLegacyDevNodeByDevInfo(
    PSP_DEVINFO_DATA pDevInfoData
    )
{
    TCHAR szBuf[LINE_LEN];

    return (DeskGetDevNodePath(pDevInfoData, szBuf, LINE_LEN - 1) &&
            DeskIsLegacyDevNodeByPath(szBuf));
}
 

BOOL
DeskIsRootDevNodeByDevInfo(
    PSP_DEVINFO_DATA pDevInfoData
    )
{
    TCHAR szBuf[LINE_LEN];
    
    return (DeskGetDevNodePath(pDevInfoData, szBuf, LINE_LEN - 1) &&
            (_tcsncicmp(SZ_ROOT, szBuf, _tcslen(SZ_ROOT)) == 0));
}


BOOL
DeskGetDevNodePath(
    PSP_DEVINFO_DATA pDid,
    PTCHAR szPath,
    LONG len
    )
{
    return (CR_SUCCESS == CM_Get_Device_ID(pDid->DevInst, szPath, len, 0));
}


VOID
DeskNukeDevNode(
    LPTSTR szService,
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData
    )
{
    SP_REMOVEDEVICE_PARAMS rdParams;
    TCHAR szPath[LINE_LEN];

    // Disable the service
    if (szService)
    {
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_008, szService);
        DeskSetServiceStartType(szService, SERVICE_DISABLED);
    }
    else
    {
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_009);
    }

    // Remove the devnode
    if (DeskGetDevNodePath(pDeviceInfoData, szPath, LINE_LEN))
    {
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_010, szPath);
    }

    ZeroMemory(&rdParams, sizeof(SP_REMOVEDEVICE_PARAMS));
    rdParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    rdParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
    rdParams.Scope = DI_REMOVEDEVICE_GLOBAL;

    if (SetupDiSetClassInstallParams(hDevInfo,
                                     pDeviceInfoData,
                                     &rdParams.ClassInstallHeader,
                                     sizeof(SP_REMOVEDEVICE_PARAMS)))
    {
        if (!SetupDiCallClassInstaller(DIF_REMOVE, hDevInfo, pDeviceInfoData))
        {
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_011, GetLastError());
        }
    }
    else
    {
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_012, GetLastError());
    }
}


PTCHAR 
DeskFindMatchingId(
    PTCHAR DeviceId,    
    PTCHAR IdList // a multi sz
    )
{
    PTCHAR currentId;

    if (!IdList) {
        return NULL;
    }

    for (currentId = IdList; *currentId; ) {

        if (lstrcmpi(currentId, DeviceId) == 0) {

            //
            // We have a match
            //

            return currentId;
        
        } else {

            //
            // Get to the next string in the multi sz
            //

            while (*currentId) {
                currentId++;
            }

            //
            // Jump past the null
            //

            currentId++;
        }
    }

    return NULL;
}


UINT
DeskDisableLegacyDeviceNodes(
    VOID 
    )
{
    DWORD index = 0, dwSize;
    UINT count = 0;
    HDEVINFO hDevInfo;
    SP_DEVINFO_DATA did;
    TCHAR szRegProperty[256];
    PTCHAR szService;
    
    //
    // Let's find all the video drivers that are installed in the system
    //

    hDevInfo = SetupDiGetClassDevs((LPGUID) &GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   0);

    if (hDevInfo == INVALID_HANDLE_VALUE)
    {
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_126,
                     TEXT("DeskDisableLegacyDeviceNodes: SetupDiGetClassDevs"),
                     GetLastError());
        goto Fallout;
    }

    ZeroMemory(&did, sizeof(SP_DEVINFO_DATA));
    did.cbSize = sizeof(SP_DEVINFO_DATA);

    while (SetupDiEnumDeviceInfo(hDevInfo, index, &did))
    {
        // If we have a root legacy device, then don't install any new
        // devnode (until we get better at this).
        if (CR_SUCCESS == CM_Get_Device_ID(did.DevInst,
                                           szRegProperty,
                                           ARRAYSIZE(szRegProperty),
                                           0))
        {
            if (DeskIsLegacyDevNodeByPath(szRegProperty))
            {
                // We have a legacy DevNode, lets disable its service and 
                // remove its devnode 
                szService = NULL;
                
                dwSize = sizeof(szRegProperty);
                if (CM_Get_DevNode_Registry_Property(did.DevInst,
                                                     CM_DRP_SERVICE,
                                                     NULL,
                                                     szRegProperty,
                                                     &dwSize,
                                                     0) == CR_SUCCESS)
                {
                    // Make sure we don't disable vga or VgaSave
                    if (!DeskIsServiceDisableable(szRegProperty))
                    {
                        goto NextDevice;
                    }

                    szService = szRegProperty;
                }

                DeskNukeDevNode(szService, hDevInfo, &did);
                count++;
            }
        }
        
NextDevice:

        ZeroMemory(&did, sizeof(SP_DEVINFO_DATA));
        did.cbSize = sizeof(SP_DEVINFO_DATA);
        index++;
    }

    DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_013, count, index);
    SetupDiDestroyDeviceInfoList(hDevInfo);
    
Fallout:

    if ((DeskGetSetupFlags() & INSETUP_UPGRADE) != 0) {
        DeskDisableServices();
    }

    return count;
}


VOID
DeskDisableServices(
    )
{
    HKEY hKey = 0;
    PTCHAR mszBuffer = NULL, szService = NULL;
    DWORD cbSize = 0;

    //
    // Retrieve the services we want to disable from the registry
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_UPDATE_SETTINGS,
                     0,
                     KEY_ALL_ACCESS,
                     &hKey) != ERROR_SUCCESS) {
        
        hKey = 0;
        goto Fallout;
    }

    //
    // Get the size
    //

    if (RegQueryValueEx(hKey,
                        SZ_SERVICES_TO_DISABLE,
                        0,
                        NULL,
                        NULL,
                        &cbSize) != ERROR_SUCCESS) {
        
        goto Fallout;
    }

    //
    // Allocate the memory
    //

    mszBuffer = (PTCHAR)LocalAlloc(LPTR, cbSize);
    
    if (mszBuffer == NULL) {
        goto Fallout;
    }

    //
    // Get the services
    //

    if (RegQueryValueEx(hKey,
                        SZ_SERVICES_TO_DISABLE,
                        0,
                        NULL,
                        (BYTE*)mszBuffer,
                        &cbSize) != ERROR_SUCCESS) {
        
        goto Fallout;
    }

    //
    // Scan through all the services
    //

    szService = mszBuffer;
    while (*szService != TEXT('\0')) {

        //
        // Make sure this service is not vga
        //

        if (DeskIsServiceDisableable(szService)) {

            //
            // Disable the service
            //

            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_008, szService);
            DeskSetServiceStartType(szService, SERVICE_DISABLED);
        } 

        //
        // Go to next service
        //

        while (*szService != TEXT('\0')) {
            szService++;
        }
        szService++;
    }

Fallout:

    if (mszBuffer != NULL) {
        LocalFree(mszBuffer);
    }

    if (hKey != 0) {

        //
        // Delete the SERVICES_TO_DISABLE value
        //

        RegDeleteValue(hKey, SZ_SERVICES_TO_DISABLE);

        //
        // Close the key
        //

        RegCloseKey(hKey);
    }
}
 


DWORD
DeskPerformDatabaseUpgrade(
    HINF hInf,
    PINFCONTEXT pInfContext,
    BOOL bUpgrade,
    PTCHAR szDriverListSection,
    BOOL* pbDeleteAppletExt
    )

/*--

Remarks:
    This function is called once the ID of the device in question matches an ID
    contained in the upgrade database. We then compare the state of the system 
    with what is contained in the database. The following algorithm is followed.
   
    If szDriverListSection is NULL or cannot be found, then bUpgrade is used
    If szDriverListSection is not NUL, then following table is used
    
    bUpgrade    match found in DL           return value
    TRUE        no                          upgrade
    TRUE        yes                         no upgrade
    FALSE       no                          no upgrade
    FALSE       yes                         upgrade
  
    essentially, a match in the DL negates bUpgrade 
    
++*/

{
    HKEY hKey;
    DWORD dwRet = ERROR_SUCCESS, dwSize;
    INFCONTEXT driverListContext;
    TCHAR szService[32], szProperty[128];
    TCHAR szRegPath[128];
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    PDEVDATA rgDevData = NULL;
    PSP_DEVINFO_DATA pDid;
    UINT iData, numData, maxData = 5, iEnum;
    BOOL foundMatch = FALSE;
    INT DeleteAppletExt = 0;

    UNREFERENCED_PARAMETER(pInfContext);

    // If no Driver list is given, life is quite simple: 
    // just disable all legacy drivers and succeed
    if (!szDriverListSection)
    {
        ASSERT (pbDeleteAppletExt == NULL);
        DeskLogError(LogSevInformation, (bUpgrade ? IDS_SETUPLOG_MSG_014 : IDS_SETUPLOG_MSG_015));

        return bUpgrade ? ERROR_SUCCESS : ERROR_DI_DONT_INSTALL;
    }

    // By default, do not disable applet extensions 
    ASSERT (pbDeleteAppletExt != NULL);
    *pbDeleteAppletExt = FALSE;

    // Find the specified section in the inf
    DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_016, szDriverListSection);

    if (!SetupFindFirstLine(hInf,
                            szDriverListSection,
                            NULL,
                            &driverListContext))
    {
        // The section listed in the database doesn't exist!  
        // Behave as though it wasn't there
        DeskLogError(LogSevInformation, (bUpgrade ? IDS_SETUPLOG_MSG_017 
                                                  : IDS_SETUPLOG_MSG_018));

        return bUpgrade ? ERROR_SUCCESS : ERROR_DI_DONT_INSTALL;
    }

    // Get all the video devices in the system
    hDevInfo = SetupDiGetClassDevs((LPGUID) &GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   0);

    if (hDevInfo == INVALID_HANDLE_VALUE)
    {
        // If no display devices are found, treat this as the case where 
        // no match was made
        DeskLogError(LogSevInformation, 
                     (bUpgrade ? IDS_SETUPLOG_MSG_019 : IDS_SETUPLOG_MSG_020));

        return bUpgrade ? ERROR_SUCCESS : ERROR_DI_DONT_INSTALL;
    }

    rgDevData = (PDEVDATA) LocalAlloc(LPTR, maxData * sizeof(DEVDATA));
    
    if (!rgDevData) {
        
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return bUpgrade ? ERROR_SUCCESS : ERROR_DI_DONT_INSTALL;
    }

    iEnum = numData = 0;
    
    do
    {
        pDid = &rgDevData[numData].did;

        pDid->cbSize = sizeof(SP_DEVINFO_DATA);
        if (!SetupDiEnumDeviceInfo(hDevInfo, ++iEnum, pDid))
        {
            break;
        }

        // If it isn't a legacy devnode, then ignore it
        if (CM_Get_Device_ID(pDid->DevInst, szProperty, ARRAYSIZE(szProperty), 0)
            == CR_SUCCESS && !DeskIsLegacyDevNodeByPath(szProperty))
        {
            continue;
        }
                                            
        // Initially grab the service name
        dwSize = SZ_BINARY_LEN;
        if (CM_Get_DevNode_Registry_Property(pDid->DevInst,
                                             CM_DRP_SERVICE,
                                             NULL,
                                             rgDevData[numData].szService,
                                             &dwSize,
                                             0) != CR_SUCCESS)
        {
            // couldn't get the service, ignore this device
            continue;
        }

        szRegPath[0] = TEXT('\0');
        lstrcat(szRegPath, TEXT("System\\CurrentControlSet\\Services\\"));
        lstrcat(szRegPath, rgDevData[numData].szService);

        // Try to grab the real binary name of the service
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         szRegPath,
                         0,
                         KEY_READ,
                         &hKey) == ERROR_SUCCESS)
        {
            // Parse the device map and open the registry.
            dwSize = ARRAYSIZE(szProperty);
            if (RegQueryValueEx(hKey,
                                TEXT("ImagePath"),
                                NULL,
                                NULL,
                                (LPBYTE) szProperty,
                                &dwSize) == ERROR_SUCCESS)
            {
                // The is a binary, extract the name, which will be of the form
                // ...\driver.sys
                LPTSTR pszDriver, pszDriverEnd;

                pszDriver = szProperty;
                pszDriverEnd = szProperty + lstrlen(szProperty);

                while(pszDriverEnd != pszDriver &&
                      *pszDriverEnd != TEXT('.')) {
                    pszDriverEnd--;
                }

                *pszDriverEnd = UNICODE_NULL;

                while(pszDriverEnd != pszDriver &&
                      *pszDriverEnd != TEXT('\\')) {
                    pszDriverEnd--;
                }

                pszDriverEnd++;

                //
                // If pszDriver and pszDriverEnd are different, we now
                // have the driver name.
                //

                if (pszDriverEnd > pszDriver &&
                    lstrlen(pszDriverEnd) < SZ_BINARY_LEN) {
                    lstrcpy(rgDevData[numData].szBinary, pszDriverEnd);
                }
            }
    
            RegCloseKey(hKey);
        
        } else {
            
            //
            // no service at all, consider it bogus
            //

            continue;
        }

        if (++numData == maxData) {

            DEVDATA *tmp;
            UINT oldMax = maxData;

            maxData <<= 1;

            //
            // Alloc twice as many, copy them over, zero out the new memory
            // and free the old list
            //

            tmp = (PDEVDATA) LocalAlloc(LPTR, maxData * sizeof(DEVDATA));
            memcpy(tmp, rgDevData, oldMax * sizeof(DEVDATA));
            ZeroMemory(tmp + oldMax, sizeof(DEVDATA) * oldMax);
            LocalFree(rgDevData);
            rgDevData = tmp;
        }
    
    } while (1);

    DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_021, numData);

    //
    // Assume that no matches have been made
    //

    dwRet =  (bUpgrade ? ERROR_SUCCESS : ERROR_DI_DONT_INSTALL);
    
    if (numData != 0) {

        //
        // There are legacy devices to check against...
        //

        do {
            LPTSTR szValue;

            memset(szService, 0, sizeof(szService));
            dwSize = sizeof(szService) / sizeof(TCHAR);
            if ((SetupGetFieldCount(&driverListContext) < 1) ||
                !SetupGetStringField(&driverListContext, 
                                     1, 
                                     szService, 
                                     dwSize, 
                                     &dwSize)) {
                continue;
            }
    
            if (szService[0] == TEXT('\0')) {
                continue;
            }
    
            for (iData = 0; iData < numData; iData++) {

                if (rgDevData[iData].szBinary[0] != TEXT('\0')) {
                    
                    szValue = rgDevData[iData].szBinary;
                
                } else {
                    
                    szValue = rgDevData[iData].szService;
                }

                if (lstrcmpi(szService, szValue) == 0)
                {
                    DeskLogError(LogSevInformation, 
                                 (bUpgrade ? IDS_SETUPLOG_MSG_022 
                                           : IDS_SETUPLOG_MSG_023));

                    dwRet = (bUpgrade ? ERROR_DI_DONT_INSTALL : ERROR_SUCCESS);
                    foundMatch = TRUE;
                    
                    //
                    // In case we fail upgrade, do we want to disable applet 
                    // extensions?
                    //

                    if ((dwRet == ERROR_DI_DONT_INSTALL) &&
                        (SetupGetFieldCount(&driverListContext) >= 2) &&
                        SetupGetIntField(&driverListContext, 2,
                                         &DeleteAppletExt)) {

                        *pbDeleteAppletExt = 
                            (DeleteAppletExt != 0);
                    }

                    break;
                }
            }
        } while (SetupFindNextLine(&driverListContext, &driverListContext));
    }

    SetupDiDestroyDeviceInfoList(hDevInfo);
    LocalFree(rgDevData);

    if (!foundMatch)
    {
        DeskLogError(LogSevInformation, 
                     (bUpgrade ? IDS_SETUPLOG_MSG_024 : IDS_SETUPLOG_MSG_025),
                     szDriverListSection);
    }

    return dwRet;
}


DWORD 
DeskCheckDatabase(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    BOOL* pbDeleteAppletExt
    )
{
    DWORD dwRet = ERROR_SUCCESS, dwSize, dwValue;
    HINF hInf;
    HKEY hKeyUpdate;
    INFCONTEXT infContext;
    BOOL foundMatch = FALSE;
    TCHAR szDatabaseId[200];
    TCHAR szDriverListSection[100];
    PTCHAR szHardwareIds = NULL, szCompatIds = NULL;
    CONFIGRET cr;
    ULONG len;
    PTCHAR szMatchedId = NULL;
    int upgrade = FALSE;
    BOOL IsNTUpgrade = FALSE;
    TCHAR szDatabaseInf[] = TEXT("display.inf");
    TCHAR szDatabaseSection[] = TEXT("VideoUpgradeDatabase");

    ASSERT (pDeviceInfoData != NULL);
    ASSERT (pbDeleteAppletExt != NULL);
    ASSERT ((DeskGetSetupFlags() & INSETUP_UPGRADE) != 0);
    
    *pbDeleteAppletExt = FALSE;

    //
    // All of the following values were placed here by our winnt32 migration dll
    // Find out what version of windows we are upgrading from
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_UPDATE_SETTINGS,
                     0,
                     KEY_READ,
                     &hKeyUpdate) == ERROR_SUCCESS) {

        dwSize = sizeof(DWORD);
        if ((RegQueryValueEx(hKeyUpdate, 
                            SZ_UPGRADE_FROM_PLATFORM, NULL, NULL,
                            (PBYTE) 
                            &dwValue, 
                            &dwSize) == ERROR_SUCCESS) && 
            (dwValue == VER_PLATFORM_WIN32_NT)) {

            IsNTUpgrade = TRUE;
        }

        RegCloseKey(hKeyUpdate);
    }

    if (!IsNTUpgrade) {

        return ERROR_SUCCESS;
    }

    //
    // Get the hardware ID
    //

    len = 0;
    cr = CM_Get_DevNode_Registry_Property(pDeviceInfoData->DevInst,
                                           CM_DRP_HARDWAREID,
                                           NULL,
                                           NULL,
                                           &len,
                                           0);

    if (cr == CR_BUFFER_SMALL) {

        szHardwareIds = (PTCHAR) LocalAlloc(LPTR, len * sizeof(TCHAR));
        
        if (szHardwareIds) {

            CM_Get_DevNode_Registry_Property(pDeviceInfoData->DevInst,
                                             CM_DRP_HARDWAREID,
                                             NULL,
                                             szHardwareIds,
                                             &len,
                                             0);

            if (DeskFindMatchingId(TEXT("LEGACY_UPGRADE_ID"), szHardwareIds)) {

                DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_031);
                LocalFree(szHardwareIds);
                return ERROR_SUCCESS;
            }
        }
    }

    //
    // Get the compatible ID
    //

    len = 0;
    cr = CM_Get_DevNode_Registry_Property(pDeviceInfoData->DevInst,
                                          CM_DRP_COMPATIBLEIDS,
                                          NULL,
                                          NULL,
                                          &len,
                                          0);

    if (cr == CR_BUFFER_SMALL) {

        szCompatIds = (PTCHAR) LocalAlloc(LPTR, len * sizeof(TCHAR));
        
        if (szCompatIds) {
            
            CM_Get_DevNode_Registry_Property(pDeviceInfoData->DevInst,
                                             CM_DRP_COMPATIBLEIDS,
                                             NULL,
                                             szCompatIds,
                                             &len,
                                             0);
        }
    }

    if (!szHardwareIds && !szCompatIds)
    {
        // No IDs to look up!  Assume success.
        DeskLogError(LogSevWarning, IDS_SETUPLOG_MSG_032);
        return ERROR_SUCCESS;
    }

    hInf = SetupOpenInfFile(szDatabaseInf,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE)
    {
        // Couldn't open the inf. This shouldn't happen.  
        // Use default upgrade logic
        DeskLogError(LogSevWarning, IDS_SETUPLOG_MSG_033);
        return ERROR_SUCCESS;
    }

    if (!SetupFindFirstLine(hInf,
                            szDatabaseSection,
                            NULL,
                            &infContext))
    {
        // Couldn't find the section or there are no entries in it.  
        // Use default upgrade logic
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_034, szDatabaseSection);
    }
    else
    {
        do
        {
            dwSize = ARRAYSIZE(szDatabaseId);
            if (!SetupGetStringField(&infContext, 0, szDatabaseId, dwSize, &dwSize))
            {
                continue;
            }

            szMatchedId = DeskFindMatchingId(szDatabaseId, szHardwareIds);
            if (!szMatchedId)
            {
                szMatchedId = DeskFindMatchingId(szDatabaseId, szCompatIds);
            }

            if (szMatchedId)
            {
                DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_035, szMatchedId);

                // Do something here and then get out of the loop
                SetupGetIntField(&infContext, 1, &upgrade);

                if (SetupGetFieldCount(&infContext) >= 2)
                {
                    dwSize = ARRAYSIZE(szDriverListSection);
                    SetupGetStringField(&infContext, 2, szDriverListSection, dwSize, &dwSize);

                    dwRet = DeskPerformDatabaseUpgrade(hInf, 
                                                       &infContext, 
                                                       upgrade, 
                                                       szDriverListSection, 
                                                       pbDeleteAppletExt);
                }
                else
                {
                    dwRet = DeskPerformDatabaseUpgrade(hInf, 
                                                       &infContext, 
                                                       upgrade, 
                                                       NULL, 
                                                       NULL);
                }
    
                break;
            }
    
        } while (SetupFindNextLine(&infContext, &infContext));
    }

    if (szHardwareIds) {
        LocalFree(szHardwareIds);
    }
    if (szCompatIds) {
        LocalFree(szCompatIds);
    }

    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    if (dwRet == ERROR_SUCCESS)
    {
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_039);
    }
    else {
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_040);
    }

    return dwRet;
}


VOID
DeskGetUpgradeDeviceStrings(
    PTCHAR Description,
    PTCHAR MfgName,
    PTCHAR ProviderName
    )
{
    TCHAR szDisplay[] = TEXT("display.inf");
    TCHAR szDeviceStrings[] = TEXT("SystemUpgradeDeviceStrings");
    TCHAR szValue[LINE_LEN];
    HINF hInf;
    INFCONTEXT infContext;
    DWORD dwSize;

    hInf = SetupOpenInfFile(szDisplay, NULL, INF_STYLE_WIN4, NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        goto GetStringsError;
    }

    if (!SetupFindFirstLine(hInf, szDeviceStrings, NULL, &infContext)) 
        goto GetStringsError;

    do {
        dwSize = ARRAYSIZE(szValue);
        if (!SetupGetStringField(&infContext, 0, szValue, dwSize, &dwSize)) {
            continue;
        }

        dwSize = LINE_LEN;
        if (lstrcmp(szValue, TEXT("Mfg")) ==0) {
            SetupGetStringField(&infContext, 1, MfgName, dwSize, &dwSize);
        }
        else if (lstrcmp(szValue, TEXT("Provider")) == 0) {
            SetupGetStringField(&infContext, 1, ProviderName, dwSize, &dwSize);
        }
        else if (lstrcmp(szValue, TEXT("Description")) == 0) {
            SetupGetStringField(&infContext, 1, Description, dwSize, &dwSize);
        }
    } while (SetupFindNextLine(&infContext, &infContext));

    SetupCloseInfFile(hInf);
    return;

GetStringsError:

    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    lstrcpy(Description, TEXT("Video Upgrade Device"));
    lstrcpy(MfgName, TEXT("(Standard display types)"));
    lstrcpy(ProviderName, TEXT("Microsoft"));
}


DWORD
DeskGetSetupFlags(
    VOID
    )
{
    HKEY hkey;
    DWORD retval = 0;
    TCHAR data[256];
    DWORD cb;
    LPTSTR regstring;

    hkey = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("System\\Setup"),
                     0,
                     KEY_READ | KEY_WRITE,
                     &hkey) == ERROR_SUCCESS) {
        
        cb = 256;

        if (RegQueryValueEx(hkey,
                            TEXT("SystemSetupInProgress"),
                            NULL,
                            NULL,
                            (LPBYTE)(data),
                            &cb) == ERROR_SUCCESS) {
            
            retval |= *((LPDWORD)(data)) ? INSETUP : 0;
            regstring = TEXT("System\\Video_Setup");
        
        } else {
            
            regstring = TEXT("System\\Video_NO_Setup");
        }

        cb = 256;

        if (RegQueryValueEx(hkey,
                            TEXT("UpgradeInProgress"),
                            NULL,
                            NULL,
                            (LPBYTE)(data),
                            &cb) == ERROR_SUCCESS) {
            
            retval |= *((LPDWORD)(data)) ? INSETUP_UPGRADE : 0;
            regstring = TEXT("System\\Video_Setup_Upgrade");
        
        } else {

            regstring = TEXT("System\\Video_Setup_Clean");
        }

        if (hkey) {
            RegCloseKey(hkey);
        }
    }

    return retval;
}


BOOL
DeskGetVideoDeviceKey(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN LPTSTR pServiceName,
    IN DWORD DeviceX,
    OUT HKEY* phkDevice
    )
{
    BOOL retVal = FALSE;
    HKEY hkPnP = (HKEY)INVALID_HANDLE_VALUE;
    HKEY hkCommonSubkey = (HKEY)INVALID_HANDLE_VALUE;
    GUID DeviceKeyGUID;
    LPWSTR pwstrGUID= NULL;
    LPTSTR ptstrGUID= NULL;
    LPTSTR pBuffer = NULL;
    DWORD dwSize, len;

    //
    // Open the PnP key
    //

    hkPnP = SetupDiCreateDevRegKey(hDevInfo,
                                   pDeviceInfoData,
                                   DICS_FLAG_GLOBAL,
                                   0,
                                   DIREG_DEV,
                                   NULL,
                                   NULL);

    if (hkPnP == INVALID_HANDLE_VALUE) {

        //
        // Videoprt.sys handles the legacy device case.
        //

        goto Fallout;
    }

    //
    // Try to get the GUID from the PnP key
    //

    dwSize = 0;
    if (RegQueryValueEx(hkPnP,
                        SZ_GUID,
                        0,
                        NULL,
                        NULL,
                        &dwSize) == ERROR_SUCCESS) {
        
        //
        // The GUID is there so use it.
        //

        len = lstrlen(SZ_VIDEO_DEVICES);
        
        pBuffer = (LPTSTR)LocalAlloc(LPTR, 
                                     dwSize + (len + 6) * sizeof(TCHAR));
        
        if (pBuffer == NULL)
        {
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("LocalAlloc"));
            goto Fallout;
        }
        
        lstrcpy(pBuffer, SZ_VIDEO_DEVICES);

        if (RegQueryValueEx(hkPnP,
                            SZ_GUID,
                            0,
                            NULL,
                            (PBYTE)(pBuffer + len),
                            &dwSize) != ERROR_SUCCESS) {
            
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegQueryValueEx"));
    
            goto Fallout;
        }

        _stprintf(pBuffer + lstrlen(pBuffer), 
                  TEXT("\\%04d"), 
                  DeviceX);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         pBuffer,
                         0,
                         KEY_ALL_ACCESS,
                         phkDevice) != ERROR_SUCCESS) {

            if (DeviceX == 0) {
            
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_128,
                             TEXT("RegOpenKeyEx"));
            }
    
            goto Fallout;
        }

        retVal = TRUE;
    
    } else {

        if (DeviceX > 0) {

            //
            // For dual-view, the class installer handles only the primary view. 
            // Secondary views are handled by videoprt.sys
            //

            goto Fallout;
        }

        //
        // The GUID is not there so create a new one.
        //

        if (CoCreateGuid(&DeviceKeyGUID) != S_OK) {
    
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("CoCreateGuid"));
    
            goto Fallout;
        }
        
        if (StringFromIID(DeviceKeyGUID, &pwstrGUID) != S_OK) {
        
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("StringFromIID"));
    
            pwstrGUID = NULL;
            goto Fallout;
        }
    
        //
        // Convert the string if necessary
        //

#ifdef UNICODE
        ptstrGUID = pwstrGUID;
#else
        SIZE_T cch = wcslen(pwstrGUID) + 1;
        ptstrGUID = LocalAlloc(LPTR, cch);
        if (ptstrGUID == NULL) 
            goto Fallout;
        WideCharToMultiByte(CP_ACP, 0, pwstrGUID, -1, ptstrGUID, cch, NULL, NULL);
#endif

        //
        // Upcase the string
        //

        CharUpper(ptstrGUID);
        
        //
        // Allocate the memory
        //

        len = max((lstrlen(SZ_VIDEO_DEVICES) + 
                   lstrlen(ptstrGUID) + 
                   max(6, lstrlen(SZ_COMMON_SUBKEY) + 1)),
                  (lstrlen(SZ_SERVICES_PATH) +
                   lstrlen(pServiceName) +
                   lstrlen(SZ_COMMON_SUBKEY) + 1));

        
        pBuffer = (LPTSTR)LocalAlloc(LPTR, len * sizeof(TCHAR));
        
        if (pBuffer == NULL) {

            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("LocalAlloc"));
    
            goto Fallout;
        }

        //
        // Save the service name 
        //

        lstrcpy(pBuffer, SZ_VIDEO_DEVICES);
        lstrcat(pBuffer, ptstrGUID);
        lstrcat(pBuffer, SZ_COMMON_SUBKEY);

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           pBuffer,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE,
                           NULL,
                           &hkCommonSubkey,
                           NULL) != ERROR_SUCCESS) {
    
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegCreateKeyEx"));
            
            hkCommonSubkey = (HKEY)INVALID_HANDLE_VALUE;
            goto Fallout;
        }

        if (RegSetValueEx(hkCommonSubkey,
                          SZ_SERVICE,
                          0,
                          REG_SZ,
                          (LPBYTE)pServiceName,
                          (lstrlen(pServiceName) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS) {
        
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegSetValueEx"));
            goto Fallout;
        }
        
        RegCloseKey(hkCommonSubkey);
        hkCommonSubkey = (HKEY)INVALID_HANDLE_VALUE;

        lstrcpy(pBuffer, SZ_SERVICES_PATH);
        lstrcat(pBuffer, pServiceName);
        lstrcat(pBuffer, SZ_COMMON_SUBKEY);

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           pBuffer,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE,
                           NULL,
                           &hkCommonSubkey,
                           NULL) != ERROR_SUCCESS) {
    
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegCreateKeyEx"));
            
            hkCommonSubkey = (HKEY)INVALID_HANDLE_VALUE;
            goto Fallout;
        }

        if (RegSetValueEx(hkCommonSubkey,
                          SZ_SERVICE,
                          0,
                          REG_SZ,
                          (LPBYTE)pServiceName,
                          (lstrlen(pServiceName) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS) {
        
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegSetValueEx"));
            goto Fallout;
        }
        
        //
        // Build the new registry key 
        //

        lstrcpy(pBuffer, SZ_VIDEO_DEVICES);
        lstrcat(pBuffer, ptstrGUID);
        lstrcat(pBuffer, TEXT("\\0000"));

        //
        // Create the key
        //

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           pBuffer,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE,
                           NULL,
                           phkDevice,
                           NULL) != ERROR_SUCCESS) {
    
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegCreateKeyEx"));
    
            goto Fallout;
        }

        //
        // Store the GUID under the PnP key
        //

        if (RegSetValueEx(hkPnP,
                          SZ_GUID,
                          0,
                          REG_SZ,
                          (LPBYTE)ptstrGUID,
                          (lstrlen(ptstrGUID) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS) {
            
            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_128,
                         TEXT("RegSetValueEx"));
    
            RegCloseKey(*phkDevice);
            *phkDevice = (HKEY)INVALID_HANDLE_VALUE;
            goto Fallout;
        }

        retVal = TRUE;
    }

Fallout:

    //
    // Clean-up
    //

    if (hkCommonSubkey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkCommonSubkey);
    }

    if (pBuffer != NULL) {
        LocalFree(pBuffer);
    }

#ifndef UNICODE
    
    if (ptstrGUID != NULL) {
        LocalFree(ptstrGUID);
    }

#endif

    if (pwstrGUID != NULL) {
        CoTaskMemFree(pwstrGUID);
    }
    
    if (hkPnP != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkPnP);
    }

    return retVal;

} // DeskGetVideoDeviceKey


BOOL
DeskIsServiceDisableable(
    PTCHAR szService
    )
{
    return ((lstrcmp(szService, TEXT("vga")) != 0) &&
            (lstrcmp(szService, TEXT("VgaSave")) != 0));
}

VOID
DeskDeleteAppletExtensions(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData 
    )
{
    PTCHAR mszBuffer = NULL;
    HKEY  hKeyUpdate;
    DWORD dwSize, dwPlatform = VER_PLATFORM_WIN32_NT, dwMajorVer = 5;
    BOOL bDeleteAppletExt = FALSE;
    DWORD cbSize = 0;

    //
    // Open the upgrade registry key
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_UPDATE_SETTINGS,
                     0,
                     KEY_READ,
                     &hKeyUpdate) != ERROR_SUCCESS) {

        //
        // No big deal
        //

        return;
    }

    //
    // Retrieve the applet extensions we want to delete from the registry
    // Get the size first.
    //

    if (RegQueryValueEx(hKeyUpdate,
                        SZ_APPEXT_TO_DELETE,
                        0,
                        NULL,
                        NULL,
                        &cbSize) != ERROR_SUCCESS) {
        
        goto Fallout;
    }

    //
    // Allocate the memory
    //

    mszBuffer = (PTCHAR)LocalAlloc(LPTR, cbSize);
    
    if (mszBuffer == NULL) {
        goto Fallout;
    }

    //
    // Get the extensions
    //

    if ((RegQueryValueEx(hKeyUpdate,
                         SZ_APPEXT_TO_DELETE,
                         0,
                         NULL,
                         (BYTE*)mszBuffer,
                         &cbSize) != ERROR_SUCCESS) ||
        (*mszBuffer == TEXT('\0'))) {
        
        goto Fallout;
    }

    //
    // Read the OS version we are upgrading from from the registry
    //

    dwSize = sizeof(DWORD);
    RegQueryValueEx(hKeyUpdate, 
                    SZ_UPGRADE_FROM_PLATFORM, 
                    NULL, 
                    NULL,
                    (PBYTE) &dwPlatform, &dwSize);

    dwSize = sizeof(DWORD);
    RegQueryValueEx(hKeyUpdate, 
                    SZ_UPGRADE_FROM_MAJOR_VERSION, 
                    NULL, 
                    NULL,
                    (PBYTE) &dwMajorVer, &dwSize);

    //
    // Don't do anything for Win3x or Win9x 
    //

    if (dwPlatform != VER_PLATFORM_WIN32_NT) {
        goto Fallout;
    }


    if ((dwMajorVer < 5) &&
        (DeskCheckDatabase(hDevInfo, 
                           pDeviceInfoData,
                           &bDeleteAppletExt) != ERROR_SUCCESS) &&
        (!bDeleteAppletExt)) {

        goto Fallout;
    }

    DeskAEDelete(REGSTR_PATH_CONTROLSFOLDER_DISPLAY_SHEX_PROPSHEET,
                 mszBuffer);

Fallout:

    RegCloseKey(hKeyUpdate);

    if (mszBuffer != NULL) {
        LocalFree(mszBuffer);
    }
}


VOID
DeskAEDelete(
    PTCHAR szDeleteFrom,
    PTCHAR mszExtensionsToRemove
    )
{
    TCHAR szKeyName[MAX_PATH];
    HKEY  hkDeleteFrom, hkExt;
    DWORD cSubKeys = 0, cbSize = 0;
    TCHAR szDefaultValue[MAX_PATH];
    PTCHAR szValue;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     szDeleteFrom, 
                     0,
                     KEY_ALL_ACCESS,
                     &hkDeleteFrom) == ERROR_SUCCESS) {

        if (RegQueryInfoKey(hkDeleteFrom, 
                            NULL,
                            NULL,
                            NULL,
                            &cSubKeys,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL) == ERROR_SUCCESS) {
        
            while (cSubKeys--) {
        
                if (RegEnumKey(hkDeleteFrom, 
                               cSubKeys, 
                               szKeyName, 
                               ARRAYSIZE(szKeyName)) == ERROR_SUCCESS) {
        
                    int iComp = -1;
        
                    if (RegOpenKeyEx(hkDeleteFrom,
                                     szKeyName,
                                     0,
                                     KEY_READ,
                                     &hkExt) == ERROR_SUCCESS) {
        
                        cbSize = sizeof(szDefaultValue);
                        if ((RegQueryValueEx(hkExt,
                                             NULL,
                                             0,
                                             NULL,
                                             (PBYTE)szDefaultValue,
                                             &cbSize) == ERROR_SUCCESS) &&
                            (szDefaultValue[0] != TEXT('\0'))) {
        
                            szValue = mszExtensionsToRemove;
        
                            while (*szValue != TEXT('\0')) {
                            
                                iComp = lstrcmpi(szDefaultValue, szValue);
        
                                if (iComp <= 0) {
                                    break;
                                }
        
                                while (*szValue != TEXT('\0')) 
                                    szValue++;

                                szValue++;
                            }
                        }
        
                        RegCloseKey(hkExt);
                    }
        
                    if (iComp == 0) {
                    
                        if (SHDeleteKey(hkDeleteFrom, szKeyName) == ERROR_SUCCESS) {
                            
                            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_098, szKeyName);
                        
                        } else {
                            
                            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_097);
                        }
                    }
                }
            }
        }

        RegCloseKey(hkDeleteFrom);
    }
} 


VOID
DeskAEMove(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData,
    HKEY hkMoveFrom,
    PAPPEXT pAppExtBefore,
    PAPPEXT pAppExtAfter
    )
{
    HKEY hkDrvKey = (HKEY)INVALID_HANDLE_VALUE;
    HKEY hkMoveTo = 0, hkMovedKey;
    PAPPEXT pAppExtMove = NULL;

    hkDrvKey = SetupDiOpenDevRegKey(hDevInfo,
                                    pDeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_ALL_ACCESS);

    if (hkDrvKey == INVALID_HANDLE_VALUE) {
        goto Fallout;
    }

    while (pAppExtAfter != NULL) {

        BOOL bMove = FALSE;
        pAppExtMove = pAppExtAfter;

        if (pAppExtBefore != NULL) {
        
            int iComp = lstrcmpi(pAppExtBefore->szDefaultValue, pAppExtAfter->szDefaultValue);
            
            if (iComp < 0) {
    
                pAppExtBefore = pAppExtBefore->pNext;
            
            } else if (iComp == 0) {
    
                pAppExtBefore = pAppExtBefore->pNext;
                pAppExtAfter = pAppExtAfter->pNext;
            
            } else {

                bMove = TRUE;
                pAppExtAfter = pAppExtAfter->pNext;
            }
        
        } else {
            
            bMove = TRUE;
            pAppExtAfter = pAppExtAfter->pNext;
        }

        if (bMove) {

            SHDeleteKey(hkMoveFrom, pAppExtMove->szKeyName);
    
            if (hkMoveTo == 0) {
            
                if (RegCreateKeyEx(hkDrvKey,
                                   TEXT("Display\\") STRREG_SHEX_PROPSHEET,
                                   0,
                                   NULL,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hkMoveTo,
                                   NULL) != ERROR_SUCCESS) {
    
                    hkMoveTo = 0;
                    goto Fallout;
                }
            }

            if (RegCreateKeyEx(hkMoveTo,
                               pAppExtMove->szKeyName,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hkMovedKey,
                               NULL) == ERROR_SUCCESS) {

                RegSetValueEx(hkMovedKey, 
                              NULL,
                              0,
                              REG_SZ, 
                              (PBYTE)(pAppExtMove->szDefaultValue),
                              (lstrlen(pAppExtMove->szDefaultValue) + 1) * sizeof(TCHAR));

                //
                // Make sure we check for duplicate applet extension when  
                // the advanced page is opened for the first time
                //

                DWORD CheckForDuplicates = 1;
                RegSetValueEx(hkDrvKey,
                              TEXT("DeskCheckForDuplicates"),
                              0,
                              REG_DWORD,
                              (LPBYTE)&CheckForDuplicates,
                              sizeof(DWORD));

                RegCloseKey(hkMovedKey);
            }
        }
    }

Fallout:
    
    if (hkMoveTo != 0) {
        RegCloseKey(hkMoveTo);
    }

    if (hkDrvKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkDrvKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\ocpage.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ocpage.cpp

Abstract:

    This file implements the display page setup.

Environment:

    WIN32 User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <stdio.h>
#include <tchar.h>
#include <devguid.h>


//
// Defines
//

#define DEFAULT_XRESOLUTION    640
#define DEFAULT_YRESOLUTION    480
#define DEFAULT_BPP            15
#define DEFAULT_VREFRESH       60
#define MIN_XRESOLUTION        800
#define MIN_YRESOLUTION        600


//
// Global Data
//

BOOL g_IsSetupInitComponentInitialized = FALSE;
SETUP_INIT_COMPONENT g_SetupInitComponent;


//
// Function prototypes
//

DWORD
HandleOcInitComponent(
    PSETUP_INIT_COMPONENT SetupInitComponent
    );

DWORD
HandleOcCompleteInstallation(
    VOID
    );

BOOL 
MigrateUnattendedSettings(
    HDEVINFO hDevInfo
    );

VOID
MigrateRegistrySettings(
    HDEVINFO hDevInfo
    );

VOID
MigrateRegistrySettingsBasedOnBusLocation(
    HDEVINFO hDevInfo,
    HKEY hPhysicalDeviceKey,
    DWORD LogicalDevicesCount,
    DWORD BusNumber,
    DWORD Address
    );

VOID
MigrateRegistrySettingsLegacy(
    HDEVINFO hDevInfo,
    HKEY hPhysicalDeviceKey
    );

VOID
MigrateRegistrySettingsHelper(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    HKEY hPhysicalDeviceKey,
    DWORD LogicalDevicesCount
    );

VOID
MigrateDeviceKeySettings(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    HKEY hLogicalDeviceKey,
    DWORD Index
    );


//
// Implementation
//


extern "C" {

DWORD
DisplayOcSetupProc(
    IN LPCVOID ComponentId,
    IN LPCVOID SubcomponentId,
    IN UINT Function,
    IN UINT_PTR Param1,
    IN OUT PVOID Param2
    )
{
    switch (Function) {
    
    case OC_PREINITIALIZE:
        return OCFLAG_UNICODE;

    case OC_INIT_COMPONENT:
        return HandleOcInitComponent((PSETUP_INIT_COMPONENT)Param2);

    case OC_QUERY_STATE:
        return SubcompOn; // we are always installed

    case OC_COMPLETE_INSTALLATION:
        return HandleOcCompleteInstallation();

    default:
        break;
    }

    return ERROR_SUCCESS;
}

} // extern "C"


DWORD
HandleOcInitComponent(
    PSETUP_INIT_COMPONENT SetupInitComponent
    )
{
    DWORD retValue = ERROR_SUCCESS;

    if (OCMANAGER_VERSION <= SetupInitComponent->OCManagerVersion) {

        SetupInitComponent->ComponentVersion = OCMANAGER_VERSION;
        
        g_IsSetupInitComponentInitialized = TRUE;
        CopyMemory(
            &g_SetupInitComponent,
            (LPVOID)SetupInitComponent,
            sizeof(SETUP_INIT_COMPONENT));
    
    } else {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_100);

        retValue = ERROR_CALL_NOT_IMPLEMENTED;
    }

    return retValue;
}


DWORD
HandleOcCompleteInstallation(
    VOID
    )
{
    BOOL bUnattended = FALSE;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    HKEY hKey;
    
    DeskOpenLog();
    
    hDevInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   DIGCF_PRESENT);

    if (hDevInfo == INVALID_HANDLE_VALUE) {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_101);
        goto Cleanup;
    }

    if ((g_SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) != 0) {
        
        //
        // Unattended settings
        //

        bUnattended = MigrateUnattendedSettings(hDevInfo);
    }

    if ((!bUnattended) && 
        ((g_SetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) != 0)) {

        //
        // Registry settings
        //

        MigrateRegistrySettings(hDevInfo);
    }
    
Cleanup:

    RegDeleteKey(HKEY_LOCAL_MACHINE, SZ_DETECT_DISPLAY);
    RegDeleteKey(HKEY_LOCAL_MACHINE, SZ_NEW_DISPLAY);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     SZ_UPDATE_SETTINGS_PATH,
                     0,
                     KEY_WRITE,
                     &hKey) == ERROR_SUCCESS) {
    
        SHDeleteKey(hKey, SZ_UPDATE_SETTINGS_KEY);
        RegCloseKey(hKey);
    
    } else {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_102);
    }
    
    if (hDevInfo != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    DeskCloseLog();
    
    return ERROR_SUCCESS;
}


BOOL
MigrateUnattendedSettings(
    HDEVINFO hDevInfo
    )
{
    INFCONTEXT context;
    HINF hInf;
    TCHAR szName[128];
    DWORD value;
    DWORD cFields = 0;
    DWORD BitsPerPel = 0, XResolution = 0, YResolution = 0, VRefresh = 0;
    DWORD UsePreferredMode = 0;
    DWORD AttachedToDesktop = 0;
    SP_DEVINFO_DATA DevInfoData;
    SP_DEVICE_INTERFACE_DATA InterfaceData;
    HKEY hInterfaceKey = (HKEY)INVALID_HANDLE_VALUE;
    HKEY hInterfaceLogicalDeviceKey = (HKEY)INVALID_HANDLE_VALUE;
    DWORD DevInfoIndex = 0;

    //
    // Get the handle to the answer file
    //

    hInf = g_SetupInitComponent.HelperRoutines.GetInfHandle(
        INFINDEX_UNATTENDED,
        g_SetupInitComponent.HelperRoutines.OcManagerContext);

    if ((hInf == NULL) || 
        (hInf == (HINF)INVALID_HANDLE_VALUE)) {
        
        return FALSE;
    }
    
    //
    // Read the settings from the answer file
    //

    if (SetupFindFirstLine(hInf, TEXT("Display"), NULL, &context)) {
        
        do {

            if (SetupGetStringField(&context,
                                    0,
                                    szName,
                                    ARRAYSIZE(szName),
                                    &value)) {
    
                if (lstrcmpi(szName, TEXT("BitsPerPel")) == 0) {

                    if (SetupGetIntField(&context, 1, (PINT)&value)) {

                        ++cFields;
                        BitsPerPel = value;
                    
                    } else {

                        SetupGetStringField(&context,
                                            1,
                                            szName,
                                            ARRAYSIZE(szName),
                                            &value);
                        DeskLogError(LogSevInformation,
                                     IDS_SETUPLOG_MSG_096,
                                     szName);
                    }
                
                } else if (lstrcmpi(szName, TEXT("Xresolution")) == 0) {

                    if (SetupGetIntField(&context, 1, (PINT)&value)) {

                        ++cFields;
                        XResolution = value;
                    
                    } else {
                        
                        SetupGetStringField(&context,
                                            1,
                                            szName,
                                            ARRAYSIZE(szName),
                                            &value);
                        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_060);
                    }
                
                } else if (lstrcmpi(szName, TEXT("YResolution")) == 0) {

                    if (SetupGetIntField(&context, 1, (PINT) &value)) {

                        ++cFields;
                        YResolution = value;
                    
                    } else {
                        
                        SetupGetStringField(&context,
                                            1,
                                            szName,
                                            ARRAYSIZE(szName),
                                            &value);
                        DeskLogError(LogSevInformation,
                                     IDS_SETUPLOG_MSG_062,
                                     szName);
                    }
                
                } else if (lstrcmpi( szName, TEXT("VRefresh")) == 0) {
                    
                    if (SetupGetIntField(&context, 1, (PINT) &value)) {
                        
                        ++cFields;
                        VRefresh = value;
                    
                    } else {
                        
                        SetupGetStringField(&context,
                                            1,
                                            szName,
                                            ARRAYSIZE(szName),
                                            &value);
                        DeskLogError(LogSevInformation,
                                     IDS_SETUPLOG_MSG_064,
                                     szName);
                    }
                
                } else {

                    DeskLogError(LogSevInformation,
                                 IDS_SETUPLOG_MSG_065,
                                 szName);
                }
            }
    
        } while (SetupFindNextLine(&context, &context));

    }

    if (cFields == 0) {

        //
        // The answer file doesn't contain any display settings
        //

        goto Fallout;
    }

    //
    // "Normalize" the display settings
    //

    AttachedToDesktop = 1;

    if (BitsPerPel == 0) {

        DeskLogError(LogSevInformation,
                     IDS_SETUPLOG_MSG_069,
                     DEFAULT_BPP);

        BitsPerPel = DEFAULT_BPP;
    }

    if ((XResolution == 0) || (YResolution == 0)) {

        DeskLogError(LogSevInformation,
                     IDS_SETUPLOG_MSG_067,
                     DEFAULT_XRESOLUTION, 
                     DEFAULT_YRESOLUTION);

        XResolution = DEFAULT_XRESOLUTION;
        YResolution = DEFAULT_YRESOLUTION;
    }                                                  

    if (VRefresh == 0) {
        
        DeskLogError(LogSevInformation,
                     IDS_SETUPLOG_MSG_068,
                     DEFAULT_VREFRESH);

        VRefresh = DEFAULT_VREFRESH;
    }

    //
    // Apply the display settings to all video cards
    //

    DevInfoIndex = 0;
    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    
    while (SetupDiEnumDeviceInfo(hDevInfo, DevInfoIndex, &DevInfoData)) {

        InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        if (!SetupDiCreateDeviceInterface(hDevInfo,
                                          &DevInfoData,
                                          &GUID_DISPLAY_ADAPTER_INTERFACE,
                                          NULL,  
                                          0,
                                          &InterfaceData)) {
            
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_103);
            goto NextDevice;
        }

        hInterfaceKey = SetupDiCreateDeviceInterfaceRegKey(hDevInfo,
                                                           &InterfaceData, 
                                                           0,
                                                           KEY_SET_VALUE,
                                                           NULL,
                                                           NULL);

        if (hInterfaceKey == INVALID_HANDLE_VALUE) {
            
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_104);
            goto NextDevice;
        }

        if (RegCreateKeyEx(hInterfaceKey, 
                           TEXT("0"),
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hInterfaceLogicalDeviceKey,
                           NULL) != ERROR_SUCCESS) {

            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_105, 0);
            hInterfaceLogicalDeviceKey = (HKEY)INVALID_HANDLE_VALUE;
            goto NextDevice;
        }

        //
        // Do not use the preferred mode for unattended installs
        //

        UsePreferredMode = 0;
        
        RegSetValueEx(hInterfaceLogicalDeviceKey, 
                      SZ_VU_PREFERRED_MODE, 
                      0, 
                      REG_DWORD, 
                      (PBYTE)&UsePreferredMode, 
                      sizeof(UsePreferredMode));

        //
        // AttachedToDesktop
        //

        RegSetValueEx(hInterfaceLogicalDeviceKey, 
                      SZ_VU_ATTACHED_TO_DESKTOP, 
                      0, 
                      REG_DWORD, 
                      (PBYTE)&AttachedToDesktop, 
                      sizeof(AttachedToDesktop));

        //
        // BitsPerPel
        //

        if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                          SZ_VU_BITS_PER_PEL, 
                          0, 
                          REG_DWORD, 
                          (PBYTE)&BitsPerPel, 
                          sizeof(BitsPerPel)) == ERROR_SUCCESS) {

            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_106, 
                         BitsPerPel);
        }

        //
        // XResolution
        //

        if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                          SZ_VU_X_RESOLUTION, 
                          0, 
                          REG_DWORD, 
                          (PBYTE)&XResolution, 
                          sizeof(XResolution)) == ERROR_SUCCESS) {

            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_107, 
                         XResolution);
        }

        //
        // dwYResolution
        //

        if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                          SZ_VU_Y_RESOLUTION, 
                          0, 
                          REG_DWORD, 
                          (PBYTE)&YResolution, 
                          sizeof(YResolution)) == ERROR_SUCCESS) {

            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_108, 
                         YResolution);
        }

        //
        // dwVRefresh
        //

        if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                          SZ_VU_VREFRESH, 
                          0, 
                          REG_DWORD, 
                          (PBYTE)&VRefresh, 
                          sizeof(VRefresh)) == ERROR_SUCCESS) {

            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_109, 
                         VRefresh);
        }

NextDevice:

        if (hInterfaceLogicalDeviceKey != INVALID_HANDLE_VALUE) {
        
            RegCloseKey(hInterfaceLogicalDeviceKey);
            hInterfaceLogicalDeviceKey = (HKEY)INVALID_HANDLE_VALUE;
        }

        if (hInterfaceKey != INVALID_HANDLE_VALUE) {
        
            RegCloseKey(hInterfaceKey);
            hInterfaceKey = (HKEY)INVALID_HANDLE_VALUE;
        }

        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        ++DevInfoIndex;
    }

Fallout:

    return (cFields != 0);
}


VOID
MigrateRegistrySettings(
    HDEVINFO hDevInfo
    )
{
    HKEY hKey = 0, hPhysicalDeviceKey = 0;
    DWORD PhysicalDevicesCount = 0, LogicalDevicesCount = 0;
    DWORD cb = 0, PhysicalDevice = 0, Failed = 0;
    TCHAR Buffer[20];
    BOOL IsLegacy;
    DWORD BusNumber = 0, Address = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     SZ_UPDATE_SETTINGS,
                     0,
                     KEY_READ,
                     &hKey) != ERROR_SUCCESS) {

        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_075);

        hKey = 0;
        goto Cleanup;
    }

    cb = sizeof(DWORD);
    if ((RegQueryValueEx(hKey,
                         SZ_UPGRADE_FAILED_ALLOW_INSTALL,
                         NULL,
                         NULL,
                         (LPBYTE)&Failed,
                         &cb) == ERROR_SUCCESS) &&
         (Failed != 0)) {

        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_076);
        goto Cleanup;
    }

    cb = sizeof(PhysicalDevicesCount);
    if (RegQueryValueEx(hKey,        
                        SZ_VU_COUNT,
                        0,
                        NULL,
                        (PBYTE)&PhysicalDevicesCount,
                        &cb) != ERROR_SUCCESS) {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_110);
        goto Cleanup;
    }

    for(PhysicalDevice = 0; 
        PhysicalDevice < PhysicalDevicesCount; 
        PhysicalDevice++) {
        
        _tcscpy(Buffer, SZ_VU_PHYSICAL);
        _stprintf(Buffer + _tcslen(Buffer), TEXT("%d"), PhysicalDevice);

        if (RegOpenKeyEx(hKey, 
                         Buffer,
                         0,
                         KEY_READ,
                         &hPhysicalDeviceKey) != ERROR_SUCCESS) {
        
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_111);
            hPhysicalDeviceKey = 0;
            goto NextPhysicalDevice;
        }

        //
        // Get the count of logical devices 
        //

        cb = sizeof(LogicalDevicesCount);
        if (RegQueryValueEx(hPhysicalDeviceKey,
                            SZ_VU_COUNT,
                            0,
                            NULL,
                            (PBYTE)&LogicalDevicesCount,
                            &cb) != ERROR_SUCCESS) {
            
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_112);
            goto NextPhysicalDevice;
        }

        //
        // Get the bus number and address 
        //

        IsLegacy = TRUE;
        cb = sizeof(BusNumber);
        if (RegQueryValueEx(hPhysicalDeviceKey,
                            SZ_VU_BUS_NUMBER,
                            0,
                            NULL,
                            (PBYTE)&BusNumber,
                            &cb) == ERROR_SUCCESS) {

            cb = sizeof(Address);
            if (RegQueryValueEx(hPhysicalDeviceKey,
                            SZ_VU_ADDRESS,
                            0,
                            NULL,
                            (PBYTE)&Address,
                            &cb) == ERROR_SUCCESS) {
            
                IsLegacy = FALSE;
            }
        }

        if (!IsLegacy) {

            MigrateRegistrySettingsBasedOnBusLocation(hDevInfo,
                                                      hPhysicalDeviceKey, 
                                                      LogicalDevicesCount,
                                                      BusNumber,
                                                      Address);
        
        } else if ((PhysicalDevicesCount == 1) &&
                   (LogicalDevicesCount == 1)) {

            //
            // If legacy, we support migration of a single device.
            //

            MigrateRegistrySettingsLegacy(hDevInfo,
                                          hPhysicalDeviceKey);
        }

NextPhysicalDevice:

        if (hPhysicalDeviceKey != 0) {
        
            RegCloseKey(hPhysicalDeviceKey);
            hPhysicalDeviceKey = 0;
        }
    }

Cleanup:

    if (hKey != 0) {
        RegCloseKey(hKey);
    }

    return;
}


VOID
MigrateRegistrySettingsBasedOnBusLocation(
    HDEVINFO hDevInfo,
    HKEY hPhysicalDeviceKey,
    DWORD LogicalDevicesCount,
    DWORD BusNumber,
    DWORD Address
    )
{
    SP_DEVINFO_DATA DevInfoData;
    DWORD CurrentBusNumber = 0, CurrentAddress = 0;
    DWORD DevInfoIndex = 0;
    BOOL bFound = FALSE;

    //
    // Let's find the device with the same bus number and address
    //

    DevInfoIndex = 0;
    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    
    while (SetupDiEnumDeviceInfo(hDevInfo, DevInfoIndex, &DevInfoData)) {

        if (SetupDiGetDeviceRegistryProperty(hDevInfo,
                                             &DevInfoData,
                                             SPDRP_BUSNUMBER,
                                             NULL,
                                             (PBYTE)&CurrentBusNumber,
                                             sizeof(CurrentBusNumber),
                                             NULL) && 
            
            (CurrentBusNumber == BusNumber) &&

            SetupDiGetDeviceRegistryProperty(hDevInfo,
                                             &DevInfoData,
                                             SPDRP_ADDRESS,
                                             NULL,
                                             (PBYTE)&CurrentAddress,
                                             sizeof(CurrentAddress),
                                             NULL) &&

            (CurrentAddress == Address)) {
            
            //
            // We found the device with the same bus number and address
            // So ... migrate the settings 
            //
                        
            MigrateRegistrySettingsHelper(hDevInfo,
                                          &DevInfoData,
                                          hPhysicalDeviceKey,
                                          LogicalDevicesCount);
            
            //
            // We are done
            //

            bFound = TRUE;
            break;
        }

        //
        // Next device
        //

        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        ++DevInfoIndex;
    }

    if (!bFound) {

        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_113);
    }

    return;
}


VOID
MigrateRegistrySettingsLegacy(
    HDEVINFO hDevInfo,
    HKEY hPhysicalDeviceKey
    )
{
    SP_DEVINFO_DATA DevInfoData0, DevInfoData1;
    
    DevInfoData0.cbSize = sizeof(SP_DEVINFO_DATA);
    if (!SetupDiEnumDeviceInfo(hDevInfo, 0, &DevInfoData0)) {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_115);
        return;
    }

    DevInfoData1.cbSize = sizeof(SP_DEVINFO_DATA);
    if (SetupDiEnumDeviceInfo(hDevInfo, 1, &DevInfoData1)) {
        
        //
        // There are at least 2 video devices in the system
        // We don't know which device to apply the settings to.
        // So, just ignore this case
        //
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_114);
        return;
    }

    MigrateRegistrySettingsHelper(hDevInfo,
                                  &DevInfoData0,
                                  hPhysicalDeviceKey,
                                  1); // there is only one logical device
}


VOID
MigrateRegistrySettingsHelper(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    HKEY hPhysicalDeviceKey,
    DWORD LogicalDevicesCount
    )
{
    SP_DEVICE_INTERFACE_DATA InterfaceData;
    HKEY hInterfaceKey = 0;
    HKEY hInterfaceLogicalDeviceKey = 0;
    HKEY hLogicalDeviceKey = 0;
    TCHAR Buffer[20];
    DWORD cb = 0, LogicalDevice = 0;
    DWORD UsePreferredMode = 0;
    DWORD AttachedToDesktop = 0;
    DWORD RelativeX = 0;
    DWORD RelativeY = 0;
    DWORD BitsPerPel = 0;
    DWORD XResolution = 0;
    DWORD YResolution = 0;
    DWORD VRefresh = 0;
    DWORD Flags = 0;

    InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
    if (!SetupDiCreateDeviceInterface(hDevInfo,
                                      pDevInfoData,
                                      &GUID_DISPLAY_ADAPTER_INTERFACE,
                                      NULL,  
                                      0,
                                      &InterfaceData)) {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_103);
        return;
    }

    hInterfaceKey = SetupDiCreateDeviceInterfaceRegKey(hDevInfo,
                                                       &InterfaceData, 
                                                       0,
                                                       KEY_SET_VALUE,
                                                       NULL,
                                                       NULL);

    if (hInterfaceKey == INVALID_HANDLE_VALUE) {
        
        DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_104);
        return;
    }

    for (LogicalDevice = 0;
         LogicalDevice < LogicalDevicesCount;
         ++LogicalDevice) {

        _tcscpy(Buffer, SZ_VU_LOGICAL);
        _stprintf(Buffer + _tcslen(Buffer),  TEXT("%d"), LogicalDevice);

        if (RegOpenKeyEx(hPhysicalDeviceKey, 
                        Buffer,
                        0,
                        KEY_READ,
                        &hLogicalDeviceKey) != ERROR_SUCCESS) {
            
            //
            // We can not go on with this physical device
            // The LogicalDevices order is important for DualView
            //
            
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_116);
            break;
        }

        _stprintf(Buffer,  TEXT("%d"), LogicalDevice);
        if (RegCreateKeyEx(hInterfaceKey, 
                           Buffer,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hInterfaceLogicalDeviceKey,
                           NULL) != ERROR_SUCCESS) {

            //
            // We can not go on with this physical device
            // The LogicalDevices order is important for DualView
            //
            
            DeskLogError(LogSevInformation, IDS_SETUPLOG_MSG_105, LogicalDevice);
            RegCloseKey(hLogicalDeviceKey);
            break;
        }

        //
        // Use preferred mode?
        //

        cb = sizeof(XResolution);
        if (RegQueryValueEx(hLogicalDeviceKey,
                            SZ_VU_X_RESOLUTION,
                            0,
                            NULL,
                            (PBYTE)&XResolution,
                            &cb) != ERROR_SUCCESS) {
    
            XResolution = DEFAULT_XRESOLUTION;
        }
    
        cb = sizeof(YResolution);
        if (RegQueryValueEx(hLogicalDeviceKey,
                            SZ_VU_Y_RESOLUTION,
                            0,
                            NULL,
                            (PBYTE)&YResolution,
                            &cb) != ERROR_SUCCESS) {
    
            YResolution = DEFAULT_YRESOLUTION;
        }

        UsePreferredMode = ((XResolution < MIN_XRESOLUTION) || 
                            (YResolution < MIN_YRESOLUTION));
        
        RegSetValueEx(hInterfaceLogicalDeviceKey, 
                      SZ_VU_PREFERRED_MODE, 
                      0, 
                      REG_DWORD, 
                      (PBYTE)&UsePreferredMode, 
                      sizeof(UsePreferredMode));

        if (UsePreferredMode) {

            DeskLogError(LogSevInformation, 
                         IDS_SETUPLOG_MSG_130);

        } else {

            //
            // AttachedToDesktop
            //
        
            cb = sizeof(AttachedToDesktop);
            if (RegQueryValueEx(hLogicalDeviceKey,
                                SZ_VU_ATTACHED_TO_DESKTOP,
                                0,
                                NULL,
                                (PBYTE)&AttachedToDesktop,
                                &cb) == ERROR_SUCCESS) {
        
                if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                                  SZ_VU_ATTACHED_TO_DESKTOP, 
                                  0, 
                                  REG_DWORD, 
                                  (PBYTE)&AttachedToDesktop, 
                                  sizeof(AttachedToDesktop)) == ERROR_SUCCESS) {
    
                    DeskLogError(LogSevInformation, 
                                 IDS_SETUPLOG_MSG_117, 
                                 AttachedToDesktop);
                }
            }
    
            //
            // RelativeX
            //
        
            cb = sizeof(RelativeX);
            if (RegQueryValueEx(hLogicalDeviceKey,
                            SZ_VU_RELATIVE_X,
                            0,
                            NULL,
                            (PBYTE)&RelativeX,
                            &cb) == ERROR_SUCCESS) {
        
                if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                                  SZ_VU_RELATIVE_X, 
                                  0, 
                                  REG_DWORD, 
                                  (PBYTE)&RelativeX, 
                                  sizeof(RelativeX)) == ERROR_SUCCESS) {
    
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_118, 
                             RelativeX);
                }
    
            }
        
            //
            // RelativeY
            //
        
            cb = sizeof(RelativeY);
            if (RegQueryValueEx(hLogicalDeviceKey,
                                SZ_VU_RELATIVE_Y,
                                0,
                                NULL,
                                (PBYTE)&RelativeY,
                                &cb) == ERROR_SUCCESS) {
        
                if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                                  SZ_VU_RELATIVE_Y, 
                                  0, 
                                  REG_DWORD, 
                                  (PBYTE)&RelativeY, 
                                  sizeof(RelativeY)) == ERROR_SUCCESS) {
                
                    DeskLogError(LogSevInformation, 
                                 IDS_SETUPLOG_MSG_119, 
                                 RelativeY);
                }
            }
    
            //
            // BitsPerPel
            //
        
            cb = sizeof(BitsPerPel);
            if (RegQueryValueEx(hLogicalDeviceKey,
                                SZ_VU_BITS_PER_PEL,
                                0,
                                NULL,
                                (PBYTE)&BitsPerPel,
                                &cb) == ERROR_SUCCESS) {
        
                if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                                  SZ_VU_BITS_PER_PEL, 
                                  0, 
                                  REG_DWORD, 
                                  (PBYTE)&BitsPerPel, 
                                  sizeof(BitsPerPel)) == ERROR_SUCCESS) {
                    
                    DeskLogError(LogSevInformation, 
                                 IDS_SETUPLOG_MSG_120, 
                                 BitsPerPel);
                }
            }
        
            //
            // XResolution
            //
        
            if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                              SZ_VU_X_RESOLUTION, 
                              0, 
                              REG_DWORD, 
                              (PBYTE)&XResolution, 
                              sizeof(XResolution)) == ERROR_SUCCESS) {
                
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_121, 
                             XResolution);
            }
        
            //
            // dwYResolution
            //
        
            if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                              SZ_VU_Y_RESOLUTION, 
                              0, 
                              REG_DWORD, 
                              (PBYTE)&YResolution, 
                              sizeof(YResolution)) == ERROR_SUCCESS) {
                
                DeskLogError(LogSevInformation, 
                             IDS_SETUPLOG_MSG_122, 
                             YResolution);
            }
        
            //
            // dwVRefresh
            //
        
            cb = sizeof(VRefresh);
            if (RegQueryValueEx(hLogicalDeviceKey,
                                SZ_VU_VREFRESH,
                                0,
                                NULL,
                                (PBYTE)&VRefresh,
                                &cb) == ERROR_SUCCESS) {
            
                if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                                  SZ_VU_VREFRESH, 
                                  0, 
                                  REG_DWORD, 
                                  (PBYTE)&VRefresh, 
                                  sizeof(VRefresh)) == ERROR_SUCCESS) {
                    
                    DeskLogError(LogSevInformation, 
                                 IDS_SETUPLOG_MSG_123, 
                                 VRefresh);
                }
            }
        
            //
            // Flags
            //
        
            cb = sizeof(Flags);
            if (RegQueryValueEx(hLogicalDeviceKey,
                                SZ_VU_FLAGS,
                                0,
                                NULL,
                                (PBYTE)&Flags,
                                &cb) == ERROR_SUCCESS) {
        
                if (RegSetValueEx(hInterfaceLogicalDeviceKey, 
                                  SZ_VU_FLAGS, 
                                  0, 
                                  REG_DWORD, 
                                  (PBYTE)&Flags, 
                                  sizeof(Flags)) == ERROR_SUCCESS) {
                    
                    DeskLogError(LogSevInformation, 
                                 IDS_SETUPLOG_MSG_124, 
                                 Flags);
                }
            }
        }
    
        //
        // Migrate the hardware acceleration and the pruning mode
        //

        MigrateDeviceKeySettings(hDevInfo,
                                 pDevInfoData,
                                 hLogicalDeviceKey,
                                 LogicalDevice);

        RegCloseKey(hLogicalDeviceKey);
        RegCloseKey(hInterfaceLogicalDeviceKey);
    }

    RegCloseKey(hInterfaceKey);
}


VOID
MigrateDeviceKeySettings(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    HKEY hLogicalDeviceKey,
    DWORD Index
    )
{
    HKEY hkPnP = (HKEY)INVALID_HANDLE_VALUE;
    HKEY hkDevice = (HKEY)INVALID_HANDLE_VALUE;
    LPTSTR pBuffer = NULL;
    DWORD dwSize, len, cb;
    DWORD HwAcceleration, PruningMode;

    //
    // Open the PnP key
    //

    hkPnP = SetupDiOpenDevRegKey(hDevInfo,
                                 pDevInfoData,
                                 DICS_FLAG_GLOBAL,
                                 0,
                                 DIREG_DEV,
                                 KEY_READ);

    if (hkPnP == INVALID_HANDLE_VALUE) {

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("SetupDiOpenDevRegKey"));

        goto Fallout;
    }

    //
    // Try to get the GUID from the PnP key
    //

    dwSize = 0;
    if (RegQueryValueEx(hkPnP,
                        SZ_GUID,
                        0,
                        NULL,
                        NULL,
                        &dwSize) != ERROR_SUCCESS) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("RegQueryValueEx"));

        goto Fallout;
    }

    len = _tcslen(SZ_VIDEO_DEVICES);
    
    pBuffer = (LPTSTR)LocalAlloc(LPTR, 
                                 dwSize + (len + 6) * sizeof(TCHAR));
    
    if (pBuffer == NULL) {

        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("LocalAlloc"));

        goto Fallout;
    }
    
    _tcscpy(pBuffer, SZ_VIDEO_DEVICES);

    if (RegQueryValueEx(hkPnP,
                        SZ_GUID,
                        0,
                        NULL,
                        (PBYTE)(pBuffer + len),
                        &dwSize) != ERROR_SUCCESS) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("RegQueryValueEx"));

        goto Fallout;
    }

    _stprintf(pBuffer + _tcslen(pBuffer), L"\\%04d", Index);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     pBuffer,
                     0,
                     KEY_WRITE,
                     &hkDevice) != ERROR_SUCCESS) {
        
        DeskLogError(LogSevInformation, 
                     IDS_SETUPLOG_MSG_127,
                     TEXT("RegOpenKeyEx"));

        hkDevice = (HKEY)INVALID_HANDLE_VALUE;
        goto Fallout;
    }

    //
    // Hardware acceleration
    //

    cb = sizeof(HwAcceleration);
    if (RegQueryValueEx(hLogicalDeviceKey,
                        SZ_HW_ACCELERATION,
                        0,
                        NULL,
                        (PBYTE)&HwAcceleration,
                        &cb) == ERROR_SUCCESS) {

        RegSetValueEx(hkDevice, 
                      SZ_HW_ACCELERATION, 
                      0, 
                      REG_DWORD, 
                      (PBYTE)&HwAcceleration, 
                      sizeof(HwAcceleration));
    }

    //
    // Pruning mode
    //

    cb = sizeof(PruningMode);
    if (RegQueryValueEx(hLogicalDeviceKey,
                        SZ_PRUNNING_MODE,
                        0,
                        NULL,
                        (PBYTE)&PruningMode,
                        &cb) == ERROR_SUCCESS) {

        RegSetValueEx(hkDevice, 
                      SZ_PRUNNING_MODE, 
                      0, 
                      REG_DWORD, 
                      (PBYTE)&PruningMode, 
                      sizeof(PruningMode));
    }

Fallout:

    if (hkPnP != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkPnP);
    }

    if (pBuffer != NULL) {
        LocalFree(pBuffer);
    }
    
    if (hkDevice != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkDevice);
    }
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


// type constants for DrawArrow

#define AW_TOP      1   // top
#define AW_BOTTOM   2   // bottom
#define AW_LEFT     3   // left
#define AW_RIGHT    4   // right

#define CCH_MAX_STRING          256

typedef struct _NEW_DESKTOP_PARAM {
    LPDEVMODE lpdevmode;
    LPTSTR pwszDevice;
    DWORD  dwTimeout;
} NEW_DESKTOP_PARAM, *PNEW_DESKTOP_PARAM;

// table of resolutions that we show off.
// if the resolution is larger, then we show that one too.

typedef struct tagRESTAB {
    INT xRes;
    INT yRes;
    COLORREF crColor;           // color to paint this resolution
} RESTAB;

RESTAB ResTab[] ={
   { 1600, 1200, RGB(255,0,0)},
   { 1280, 1024, RGB(0,255,0)},
   { 1152,  900, RGB(0,0,255)},
   { 1024,  768, RGB(255,0,0)},
   {  800,  600, RGB(0,255,0)},
   // 640x480 or 640x400 handled specially
   { 0, 0, 0}         // end of table
   };

DWORD WINAPI
ApplyNowThd(
    LPVOID lpThreadParameter
    );

void
DrawBmp(
    HDC hDC
    );

VOID 
LabelResolution( 
    HDC hDC, 
    INT xmin, 
    INT ymin, 
    INT xmax, 
    INT ymax 
    );

static VOID 
PaintRect(
    HDC hDC,       
    INT lowx,      
    INT lowy,      
    INT highx,     
    INT highy,     
    COLORREF rgb,  
    UINT idString  
    );

VOID 
DrawArrows( 
    HDC hDC, 
    INT xRes, 
    INT yRes 
    );

static VOID 
LabelRect(
    HDC hDC, 
    PRECT pRect, 
    UINT idString 
    );

static VOID 
DrawArrow( 
    HDC hDC, 
    INT type, 
    INT xPos, 
    INT yPos, 
    COLORREF crPenColor 
    );

VOID 
MakeRect( 
    PRECT pRect, 
    INT xmin, 
    INT ymin, 
    INT xmax, 
    INT ymax
    );

DWORD
DisplayTestSettingsW(
    LPDEVMODEW lpDevMode,
    LPWSTR     pwszDevice,
    DWORD      dwTimeout
    )
{
    HANDLE hThread;
    DWORD idThread;
    DWORD bTest;
    NEW_DESKTOP_PARAM desktopParam;

    if (!lpDevMode || !pwszDevice) 
        return FALSE;

    if (dwTimeout == 0) 
        dwTimeout = NORMAL_TIMEOUT;

    desktopParam.lpdevmode = lpDevMode; 
    desktopParam.pwszDevice = pwszDevice;
    desktopParam.dwTimeout = dwTimeout;

    hThread = CreateThread(NULL,
                           4096,
                           ApplyNowThd,
                           (LPVOID) &desktopParam,
                           SYNCHRONIZE | THREAD_QUERY_INFORMATION,
                           &idThread
                           );

    WaitForSingleObject(hThread, INFINITE);
    GetExitCodeThread(hThread, &bTest);
    CloseHandle(hThread);

    return bTest;
}


DWORD WINAPI
ApplyNowThd(
    LPVOID lpThreadParameter
    )
{
    PNEW_DESKTOP_PARAM lpDesktopParam = (PNEW_DESKTOP_PARAM) lpThreadParameter;
    HDESK hdsk = NULL;
    HDESK hdskDefault = NULL;
    BOOL bTest = FALSE;
    HDC hdc;


    //
    // HACK:
    // We need to make a USER call before calling the desktop stuff so we can
    // sure our threads internal data structure are associated with the default
    // desktop.
    // Otherwise USER has problems closing the desktop with our thread on it.
    //
    GetSystemMetrics(SM_CXSCREEN);

    //
    // Create the desktop
    //
    hdskDefault = GetThreadDesktop(GetCurrentThreadId());

    if (hdskDefault != NULL) {
        hdsk = CreateDesktop(TEXT("Display.Cpl Desktop"),
                             lpDesktopParam->pwszDevice,
                             lpDesktopParam->lpdevmode,
                             0,
                             MAXIMUM_ALLOWED,
                             NULL);

        if (hdsk != NULL) {
            //
            // use the desktop for this thread
            //
            if (SetThreadDesktop(hdsk)) {
                hdc = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
                if (hdc) {
                    DrawBmp(hdc);
                    DeleteDC(hdc);
                    bTest = TRUE;
                }

                //
                // Sleep for some seconds so you have time to look at the screen.
                //
                Sleep(lpDesktopParam->dwTimeout);
            }
        }

        //
        // Reset the thread to the right desktop
        //
        SetThreadDesktop(hdskDefault);
        SwitchDesktop(hdskDefault);

        //
        // Can only close the desktop after we have switched to the new one.
        //
        if (hdsk != NULL) {
            CloseDesktop(hdsk);
        }
    }

    ExitThread((DWORD) bTest);
    return 0;
}


/****************************************************************************

    FUNCTION: DrawBmp

    PURPOSE:  Show off a fancy screen so the user has some idea
              of what will be seen given this resolution, colour
              depth and vertical refresh rate.  Note that we do not
              try to simulate the font sizes.

****************************************************************************/
void
DrawBmp(
    HDC hDC
    )
{
    INT    nBpp;          // bits per pixel
    INT    nWidth;        // width of screen in pixels
    INT    nHeight;       // height of screen in pixels
    INT    xUsed,yUsed;   // amount of x and y to use for dense bitmap
    INT    dx,dy;         // delta x and y for color bars
    RECT   rct;           // rectangle for passing bounds
    HFONT  hPrevFont=0;   // previous font in DC
    HFONT  hNewFont;      // new font if possible
    HPEN   hPrevPen;      // previous pen handle
    INT    x,y,i;
    INT    off;           // offset in dx units

    hNewFont = (HFONT)NULL;

    if (hNewFont)                              // if no font, use old
        hPrevFont= (HFONT) SelectObject(hDC, hNewFont);

    // get surface information
    nBpp= GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES);
    nWidth= GetDeviceCaps(hDC, HORZRES);
    nHeight= GetDeviceCaps(hDC, VERTRES);

    // background for everything is yellow.
    PaintRect(hDC, 0, 0, nWidth, nHeight, RGB(255,255,0), 0);
    LabelResolution( hDC, 0,0,nWidth, nHeight );

    // Background for various resolutions
    // biggest ones first
    for(i = 0; ResTab[i].xRes !=0; i++) {

        // Only draw if it will show
        //if ((nWidth >= ResTab[i].xRes) | ( nHeight>=ResTab[i].yRes ) )
        if ((nWidth >= ResTab[i].xRes) || (nHeight >= ResTab[i].yRes)) {
           PaintRect(hDC, 0, 0, ResTab[i].xRes, ResTab[i].yRes, ResTab[i].crColor, 0);
           LabelResolution(hDC, 0, 0, ResTab[i].xRes, ResTab[i].yRes);
        }
    }

    // color bars - only in standard vga area

    xUsed= min(nWidth, 640);    // only use vga width
    yUsed= min(nHeight, 480);   // could be 400 on some boards
    dx = xUsed / 2;
    dy = yUsed / 6;

    PaintRect(hDC, 0,    0, dx, dy*1,  RGB(255,0,0),   IDS_COLOR_RED);
    PaintRect(hDC, 0, dy*1, dx, dy*2,  RGB(0,255,0),   IDS_COLOR_GREEN);
    PaintRect(hDC, 0, dy*2, dx, dy*3,  RGB(0,0,255),   IDS_COLOR_BLUE);
    PaintRect(hDC, 0, dy*3, dx, dy*4,  RGB(255,255,0), IDS_COLOR_YELLOW);
    PaintRect(hDC, 0, dy*4, dx, dy*5,  RGB(255,0,255), IDS_COLOR_MAGENTA);
    PaintRect(hDC, 0, dy*5, dx, yUsed, RGB(0,255,255), IDS_COLOR_CYAN);

    // gradations of colors for true color detection
    for (x = dx; x < xUsed; x++) {
        int level;

        level = 255 - (256 * (x-dx)) / dx;
        PaintRect(hDC, x, dy*0, x+1,  dy*1, RGB(level,0,0 ), 0);
        PaintRect(hDC, x, dy*1, x+1,  dy*2, RGB(0,level,0 ), 0);
        PaintRect(hDC, x, dy*2, x+1,  dy*3, RGB(0,0,level ), 0);
        PaintRect(hDC, x, dy*5, x+1,  dy*6, RGB(level,level,level), 0);
    }

    MakeRect(&rct, dx, 0, dx * 2, dy * 1);
    LabelRect(hDC, &rct, IDS_RED_SHADES);
    MakeRect(&rct, dx, dy, dx * 2, dy * 2);
    LabelRect(hDC, &rct, IDS_GREEN_SHADES);
    MakeRect(&rct, dx, 2 * dy, dx * 2, dy * 3);
    LabelRect(hDC, &rct, IDS_BLUE_SHADES);
    MakeRect(&rct, dx, 5 * dy, dx * 2, dy * 6);
    LabelRect(hDC, &rct, IDS_GRAY_SHADES);

    // horizontal lines for interlace detection
    off = 3;
    PaintRect(hDC, dx, dy*off, xUsed, dy * (off+1), RGB(255,255,255), 0); // white
    hPrevPen = (HPEN) SelectObject(hDC, GetStockObject(BLACK_PEN));

    for (y = dy * off; y < dy * (off+1); y = y+2) {
        MoveToEx(hDC, dx,     y, NULL);
        LineTo(  hDC, dx * 2, y);
    }

    SelectObject(hDC, hPrevPen);
    MakeRect(&rct, dx, dy * off, dx * 2, dy * (off+1));
    LabelRect(hDC, &rct, IDS_PATTERN_HORZ);

    // vertical lines for bad dac detection
    off = 4;
    PaintRect(hDC, dx, dy * off, xUsed,dy * (off+1), RGB(255,255,255), 0); // white
    hPrevPen= (HPEN) SelectObject(hDC, GetStockObject(BLACK_PEN));

    for (x = dx; x < xUsed; x = x+2) {
        MoveToEx(hDC, x, dy * off, NULL);
        LineTo(  hDC, x, dy * (off+1));
    }

    SelectObject(hDC, hPrevPen);
    MakeRect(&rct, dx, dy * off, dx * 2, dy * (off+1));
    LabelRect(hDC, &rct, IDS_PATTERN_VERT);

    DrawArrows(hDC, nWidth, nHeight);

    LabelResolution(hDC, 0, 0, xUsed, yUsed);

    // delete created font if one was created
    if (hPrevFont) {
        hPrevFont = (HFONT) SelectObject(hDC, hPrevFont);
        DeleteObject(hPrevFont);
    }
}


/****************************************************************************

    FUNCTION: LabelResolution

    PURPOSE:  Labels the resolution in a form a user may understand.
              FEATURE: We could label vertically too.

****************************************************************************/

VOID 
LabelResolution( 
    HDC hDC, 
    INT xmin, 
    INT ymin, 
    INT xmax, 
    INT ymax 
    )
{
   TCHAR szRes[120];    // text for resolution
   TCHAR szFmt[CCH_MAX_STRING];    // format string
   SIZE  size;
   INT iStatus;

   iStatus = LoadString(hInstance, ID_DSP_TXT_XBYY /* remove IDS_RESOLUTION_FMT */, szFmt, ARRAYSIZE(szFmt) );
   if (!iStatus || iStatus == sizeof(szFmt)) {
       lstrcpy(szFmt,TEXT("%d x %d"));   // make sure we get something
   }

   wsprintf(szRes, szFmt, xmax, ymax);

   SetBkMode(hDC, TRANSPARENT);
   SetTextColor(hDC, RGB(0,0,0));

   GetTextExtentPoint32(hDC, szRes, lstrlen(szRes), &size);

   // Text near bottom of screen ~10 pixels from bottom
   TextOut(hDC, xmax/2 - size.cx/2, ymax - 10-size.cy, szRes, lstrlen(szRes));
}


/****************************************************************************

    FUNCTION: PaintRect

    PURPOSE:  Color in a rectangle and label it.

****************************************************************************/

static VOID 
PaintRect(
    HDC hDC,         // DC to paint
    INT lowx,        // coordinates describing rectangle to fill
    INT lowy,        //
    INT highx,       //
    INT highy,       //
    COLORREF rgb,    // color to fill in rectangle with
    UINT idString    // resource ID to use to label or 0 is none
    )  
{
    RECT rct;
    HBRUSH hBrush;

    MakeRect(&rct, lowx, lowy, highx, highy);

    hBrush = CreateSolidBrush(rgb);
    if (hBrush)
    {
        FillRect(hDC, &rct, hBrush);
        DeleteObject(hBrush);
    }

    LabelRect(hDC, &rct, idString);
}


/****************************************************************************

    FUNCTION: DrawArrows

    PURPOSE:  Draw all the arrows showing edges of resolution.

****************************************************************************/

VOID 
DrawArrows( 
    HDC hDC, 
    INT xRes, 
    INT yRes 
    )
{
    INT dx,dy;
    INT x,y;
    COLORREF color= RGB(0,0,0);    // color of arrow

    dx= xRes/8;
    dy= yRes/8;

    for (x = 0; x < xRes; x += dx) {
        DrawArrow(hDC, AW_TOP,    dx/2+x,   0,      color);
        DrawArrow(hDC, AW_BOTTOM, dx/2+x,   yRes-1, color);
    }

    for (y = 0; y < yRes; y += dy) {
        DrawArrow(hDC, AW_LEFT,       0, dy/2+y,   color);
        DrawArrow(hDC, AW_RIGHT, xRes-1, dy/2+y,   color);
    }
}


/****************************************************************************

    FUNCTION: LabelRect

    PURPOSE:  Label a rectangle with centered text given resource ID.

****************************************************************************/

static VOID 
LabelRect(
    HDC hDC, 
    PRECT pRect, 
    UINT idString 
    )
{
    UINT iStatus;
    INT xStart, yStart;
    SIZE size;              // for size of string
    TCHAR szMsg[CCH_MAX_STRING];

    if (idString == 0)     // make it easy to ignore call
        return;

    SetBkMode(hDC, OPAQUE);
    SetBkColor(hDC, RGB(0,0,0));
    SetTextColor(hDC, RGB(255,255,255));

    // center
    xStart = (pRect->left + pRect->right) / 2;
    yStart = (pRect->top + pRect->bottom) / 2;

    iStatus = LoadString(hInstance, idString, szMsg, ARRAYSIZE(szMsg));
    if (!iStatus) {
        return;      // can't find string - print nothing
    }

    GetTextExtentPoint32(hDC, szMsg, lstrlen(szMsg), &size);
    TextOut(hDC, xStart-size.cx/2, yStart-size.cy/2, szMsg, lstrlen(szMsg));
}


/****************************************************************************

    FUNCTION: DrawArrow

    PURPOSE:  Draw one arrow in a given color.

****************************************************************************/

static VOID 
DrawArrow( 
    HDC hDC, 
    INT type, 
    INT xPos, 
    INT yPos, 
    COLORREF crPenColor 
    )
{
    INT shaftlen=30;         // length of arrow shaft
    INT headlen=15;          // height or width of arrow head (not length)
    HPEN hPen, hPrevPen = NULL;   // pens
    INT x,y;
    INT xdir, ydir;          // directions of x and y (1,-1)

    hPen= CreatePen( PS_SOLID, 1, crPenColor );
    if( hPen )
        hPrevPen= (HPEN) SelectObject( hDC, hPen );

    MoveToEx( hDC, xPos, yPos, NULL );

    xdir= ydir= 1;   // defaults
    switch( type )
    {
        case AW_BOTTOM:
            ydir= -1;
        case AW_TOP:
            LineTo(hDC, xPos, yPos+ydir*shaftlen);

            for( x=0; x<3; x++ )
            {
                MoveToEx( hDC, xPos,             yPos+ydir*x, NULL );
                LineTo(   hDC, xPos-(headlen-x), yPos+ydir*headlen );
                MoveToEx( hDC, xPos,             yPos+ydir*x, NULL );
                LineTo(   hDC, xPos+(headlen-x), yPos+ydir*headlen );
            }
            break;

        case AW_RIGHT:
            xdir= -1;
        case AW_LEFT:
            LineTo( hDC, xPos + xdir*shaftlen, yPos );

            for( y=0; y<3; y++ )
            {
                MoveToEx( hDC, xPos + xdir*y, yPos, NULL );
                LineTo(   hDC, xPos + xdir*headlen, yPos+(headlen-y));
                MoveToEx( hDC, xPos + xdir*y, yPos, NULL );
                LineTo(   hDC, xPos + xdir*headlen, yPos-(headlen-y));
            }
            break;
    }

    if( hPrevPen )
        SelectObject( hDC, hPrevPen );

    if (hPen)
        DeleteObject(hPen);

}


/****************************************************************************

    FUNCTION: MakeRect

    PURPOSE:  Fill in RECT structure given contents.

****************************************************************************/

VOID 
MakeRect( 
    PRECT pRect, 
    INT xmin, 
    INT ymin, 
    INT xmax, 
    INT ymax
    )
{
    pRect->left= xmin;
    pRect->right= xmax;
    pRect->bottom= ymin;
    pRect->top= ymax;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\util.cpp ===
/*****************************************************************************\
    FILE: util.cpp

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 5/30/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "util.h"
#include <comdef.h>

/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////

HINSTANCE g_hinst;              // My instance handle



#ifdef DEBUG
DWORD g_TLSliStopWatchStartHi = 0;
DWORD g_TLSliStopWatchStartLo = 0;
LARGE_INTEGER g_liStopWatchFreq = {0};
#endif // DEBUG

/////////////////////////////////////////////////////////////////////
// Debug Timing Helpers
/////////////////////////////////////////////////////////////////////

#ifdef DEBUG
void DebugStartWatch(void)
{
    LARGE_INTEGER liStopWatchStart;
    
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));

//    ASSERT(!liStopWatchStart.QuadPart); // If you hit this, then the stopwatch is nested.
    QueryPerformanceFrequency(&g_liStopWatchFreq);
    QueryPerformanceCounter(&liStopWatchStart);

    TlsSetValue(g_TLSliStopWatchStartHi, IntToPtr(liStopWatchStart.HighPart));
    TlsSetValue(g_TLSliStopWatchStartLo, IntToPtr(liStopWatchStart.LowPart));
}

DWORD DebugStopWatch(void)
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liStopWatchStart;
    
    QueryPerformanceCounter(&liDiff);
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    liDiff.QuadPart -= liStopWatchStart.QuadPart;

    ASSERT(0 != g_liStopWatchFreq.QuadPart);    // I don't like to fault with div 0.
    DWORD dwTime = (DWORD)((liDiff.QuadPart * 1000) / g_liStopWatchFreq.QuadPart);
    
    TlsSetValue(g_TLSliStopWatchStartHi, (LPVOID) 0);
    TlsSetValue(g_TLSliStopWatchStartLo, (LPVOID) 0);

    return dwTime;
}
#endif // DEBUG






/////////////////////////////////////////////////////////////////////
// String Helpers
/////////////////////////////////////////////////////////////////////
#undef SysAllocStringA
BSTR SysAllocStringA(LPCSTR pszStr)
{
    BSTR bstrOut = NULL;

    if (pszStr)
    {
        DWORD cchSize = (lstrlenA(pszStr) + 1);
        LPWSTR pwszThunkTemp = (LPWSTR) LocalAlloc(LPTR, (sizeof(pwszThunkTemp[0]) * cchSize));  // assumes INFOTIPSIZE number of chars max

        if (pwszThunkTemp)
        {
            SHAnsiToUnicode(pszStr, pwszThunkTemp, cchSize);
            bstrOut = SysAllocString(pwszThunkTemp);
            LocalFree(pwszThunkTemp);
        }
    }

    return bstrOut;
}


HRESULT HrSysAllocStringA(IN LPCSTR pszSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocStringA(pszSource);
        if (pszSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT BSTRFromStream(IStream * pStream, BSTR * pbstr)
{
    STATSTG statStg = {0};
    HRESULT hr = pStream->Stat(&statStg, STATFLAG_NONAME);

    if (S_OK == hr)
    {
        DWORD cchSize = statStg.cbSize.LowPart;
        *pbstr = SysAllocStringLen(NULL, cchSize + 4);

        if (*pbstr)
        {
            LPSTR pszTemp = (LPSTR) LocalAlloc(LPTR, sizeof(pszTemp[0]) * (cchSize + 4));

            if (pszTemp)
            {
                ULONG cbRead;

                hr = pStream->Read(pszTemp, cchSize, &cbRead);
                pszTemp[cchSize] = 0;
                SHAnsiToUnicode(pszTemp, *pbstr, (cchSize + 1));

                LocalFree(pszTemp);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


// --------------------------------------------------------------------------------
// HrCopyStream
// --------------------------------------------------------------------------------
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb)
{
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead=0,
                   cbTotal=0;

    do
    {
        hr = pstmIn->Read(buf, sizeof(buf), &cbRead);
        if (FAILED(hr) || cbRead == 0)
        {
            break;
        }
        hr = pstmOut->Write(buf, cbRead, NULL);
        if (FAILED(hr))
        {
            break;
        }
        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));
 
    if (pcb && SUCCEEDED(hr))
        *pcb = cbTotal;

    return hr;
}


HRESULT CreateBStrVariantFromWStr(IN OUT VARIANT * pvar, IN LPCWSTR pwszString)
{
    HRESULT hr = E_INVALIDARG;

    if (pvar)
    {
        pvar->bstrVal = SysAllocString(pwszString);
        if (pvar->bstrVal)
        {
            pvar->vt = VT_BSTR;
            hr = S_OK;
        }
        else
        {
            pvar->vt = VT_EMPTY;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT UnEscapeHTML(BSTR bstrEscaped, BSTR * pbstrUnEscaped)
{
    HRESULT hr = HrSysAllocString(bstrEscaped, pbstrUnEscaped);

    if (SUCCEEDED(hr))
    {
        // Find %xx and replace.
        LPWSTR pwszEscapedSequence = StrChrW(*pbstrUnEscaped, CH_HTML_ESCAPE);
        WCHAR wzEscaped[5] = L"0xXX";

        while (pwszEscapedSequence && (3 <= lstrlenW(pwszEscapedSequence)))
        {
            int nCharCode;

            wzEscaped[2] = pwszEscapedSequence[1];
            wzEscaped[3] = pwszEscapedSequence[2];
            StrToIntExW(wzEscaped, STIF_SUPPORT_HEX, &nCharCode);

            // Replace the '%' with the real char.
            pwszEscapedSequence[0] = (WCHAR) nCharCode;

            pwszEscapedSequence = CharNextW(pwszEscapedSequence);   // Skip pasted the replaced char.

            // Over write the 0xXX value.
            StrCpyW(pwszEscapedSequence, &pwszEscapedSequence[2]);

            // Next...
            pwszEscapedSequence = StrChrW(pwszEscapedSequence, CH_HTML_ESCAPE);
        }
    }

    return hr;
}



/*****************************************************************************\
    PARAMETERS:
        If fBoolean is TRUE, return "True" else "False".
HRESULT BOOLToString(BOOL fBoolean, BSTR * pbstrValue)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrValue)
    {
        LPCWSTR pwszValue;

        *pbstrValue = NULL;
        if (TRUE == fBoolean)
        {
            pwszValue = SZ_QUERYDATA_TRUE;
        }
        else
        {
            pwszValue = SZ_QUERYDATA_FALSE;
        }

        hr = HrSysAllocString(pwszValue, pbstrValue);
    }

    return hr;
}
\*****************************************************************************/



#define SZ_VALID_XML      L"<?xml"

/////////////////////////////////////////////////////////////////////
// XML Related Helpers
/////////////////////////////////////////////////////////////////////
HRESULT XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc)
{
    HRESULT hr = E_FAIL;
    
    // We don't even want to
    // bother passing it to the XML DOM because they throw exceptions.  These
    // are caught and handled but we still don't want this to happen.  We try
    // to get XML from the web server, but we get HTML instead if the web server
    // fails or the web proxy returns HTML if the site isn't found.
    if (!StrCmpNIW(SZ_VALID_XML, bstrXML, (ARRAYSIZE(SZ_VALID_XML) - 1)))
    {
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, ppXMLDoc));

        if (SUCCEEDED(hr))
        {
            VARIANT_BOOL fIsSuccessful;

            // NOTE: This will throw an 0xE0000001 exception in MSXML if the XML is invalid.
            //    This is not good but there isn't much we can do about it.  The problem is
            //    that web proxies give back HTML which fails to parse.
            hr = (*ppXMLDoc)->loadXML(bstrXML, &fIsSuccessful);
            if (SUCCEEDED(hr))
            {
                if (VARIANT_TRUE != fIsSuccessful)
                {
                    hr = E_FAIL;
                }
            }
        }

        if (FAILED(hr))
        {
            (*ppXMLDoc)->Release();
            *ppXMLDoc = NULL;
        }
    }

    return hr;
}


HRESULT XMLBStrFromDOM(IXMLDOMDocument * pXMLDoc, BSTR * pbstrXML)
{
    IStream * pStream;
    HRESULT hr = pXMLDoc->QueryInterface(IID_PPV_ARG(IStream, &pStream)); // check the return value

    if (S_OK == hr)
    {
        hr = BSTRFromStream(pStream, pbstrXML);
        pStream->Release();
    }

    return hr;
}


HRESULT XMLAppendElement(IXMLDOMElement * pXMLElementRoot, IXMLDOMElement * pXMLElementToAppend)
{
    IXMLDOMNode * pXMLNodeRoot;
    HRESULT hr = pXMLElementRoot->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pXMLNodeRoot));

    if (EVAL(SUCCEEDED(hr)))
    {
        IXMLDOMNode * pXMLNodeToAppend;
        
        hr = pXMLElementToAppend->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pXMLNodeToAppend));
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = pXMLNodeRoot->appendChild(pXMLNodeToAppend, NULL);
            pXMLNodeToAppend->Release();
        }

        pXMLNodeRoot->Release();
    }

    return hr;
}


HRESULT XMLDOMFromFile(IN LPCWSTR pwzPath, OUT IXMLDOMDocument ** ppXMLDOMDoc)
{
    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, ppXMLDOMDoc));

    if (SUCCEEDED(hr))
    {
        VARIANT xmlSource;

        xmlSource.vt = VT_BSTR;
        xmlSource.bstrVal = SysAllocString(pwzPath);

        if (xmlSource.bstrVal)
        {
            VARIANT_BOOL fIsSuccessful = VARIANT_TRUE;

            hr = (*ppXMLDOMDoc)->load(xmlSource, &fIsSuccessful);
            if ((S_FALSE == hr) || (VARIANT_FALSE == fIsSuccessful))
            {
                // This happens when the file isn't a valid XML file.
                hr = E_FAIL;
            }

            VariantClear(&xmlSource);
        }

        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppXMLDOMDoc);
        }
    }

    return hr;
}


HRESULT XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName)
{
    BSTR bstrTagName;
    HRESULT hr = pXMLElementMessage->get_tagName(&bstrTagName);

    if (S_FALSE == hr)
    {
        hr = E_FAIL;
    }
    else if (SUCCEEDED(hr))
    {
        if (!bstrTagName || !pwszTagName || StrCmpIW(bstrTagName, pwszTagName))
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}

HRESULT XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList)
{
    BSTR bstrTagName = SysAllocString(pwszTagName);
    HRESULT hr = E_OUTOFMEMORY;

    *ppNodeList = NULL;
    if (bstrTagName)
    {
        hr = pXMLElementMessage->getElementsByTagName(bstrTagName, ppNodeList);
        if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}


HRESULT XMLNode_GetAttributeValue(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszAttributeName, OUT BSTR * pbstrValue)
{
    BSTR bstrAttributeName = SysAllocString(pwszAttributeName);
    HRESULT hr = E_OUTOFMEMORY;

    *pbstrValue = NULL;
    if (bstrAttributeName)
    {
        IXMLDOMNamedNodeMap * pNodeAttributes;

        hr = pXMLNode->get_attributes(&pNodeAttributes);
        if (S_FALSE == hr)  hr = E_FAIL;
        if (SUCCEEDED(hr))
        {
            IXMLDOMNode * pTypeAttribute;

            hr = pNodeAttributes->getNamedItem(bstrAttributeName, &pTypeAttribute);
            if (S_FALSE == hr)  hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            if (SUCCEEDED(hr))
            {
                VARIANT varAtribValue = {0};

                hr = pTypeAttribute->get_nodeValue(&varAtribValue);
                if (S_FALSE == hr)  hr = E_FAIL;
                if (SUCCEEDED(hr) && (VT_BSTR == varAtribValue.vt))
                {
                    *pbstrValue = SysAllocString(varAtribValue.bstrVal);
                }

                VariantClear(&varAtribValue);
                pTypeAttribute->Release();
            }

            pNodeAttributes->Release();
        }

        SysFreeString(bstrAttributeName);
    }

    return hr;
}


HRESULT XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode)
{
    HRESULT hr = E_INVALIDARG;

    *ppChildNode = NULL;
    if (pXMLNode)
    {
        IXMLDOMElement * pXMLElement;

        hr = pXMLNode->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pXMLElement));
        if (SUCCEEDED(hr))
        {
            IXMLDOMNodeList * pNodeList;

            hr = XMLElem_GetElementsByTagName(pXMLElement, pwszTagName, &pNodeList);
            if (SUCCEEDED(hr))
            {
                hr = XMLNodeList_GetChild(pNodeList, 0, ppChildNode);
                pNodeList->Release();
            }

            pXMLElement->Release();
        }
    }

    return hr;
}


HRESULT XMLNode_GetTagText(IN IXMLDOMNode * pXMLNode, OUT BSTR * pbstrValue)
{
    DOMNodeType nodeType = NODE_TEXT;
    HRESULT hr = pXMLNode->get_nodeType(&nodeType);

    *pbstrValue = NULL;

    if (S_FALSE == hr)  hr = E_FAIL;
    if (SUCCEEDED(hr))
    {
        if (NODE_TEXT == nodeType)
        {
            VARIANT varAtribValue = {0};

            hr = pXMLNode->get_nodeValue(&varAtribValue);
            if (S_FALSE == hr)  hr = E_FAIL;
            if (SUCCEEDED(hr) && (VT_BSTR == varAtribValue.vt))
            {
                *pbstrValue = SysAllocString(varAtribValue.bstrVal);
            }

            VariantClear(&varAtribValue);
        }
        else
        {
            hr = pXMLNode->get_text(pbstrValue);
        }
    }

    return hr;
}


HRESULT XMLNodeList_GetChild(IN IXMLDOMNodeList * pNodeList, IN DWORD dwIndex, OUT IXMLDOMNode ** ppXMLChildNode)
{
    HRESULT hr = pNodeList->get_item(dwIndex, ppXMLChildNode);

    if (S_FALSE == hr)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return hr;
}


HRESULT XMLNode_GetChildTagTextValue(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BSTR * pbstrValue)
{
    IXMLDOMNode * pNodeType;
    HRESULT hr = XMLNode_GetChildTag(pXMLNode, bstrChildTag, &pNodeType);

    if (SUCCEEDED(hr))
    {
        hr = XMLNode_GetTagText(pNodeType, pbstrValue);
        pNodeType->Release();
    }

    return hr;
}


HRESULT XMLNode_GetChildTagTextValueToBool(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BOOL * pfBoolean)
{
    BSTR bstr;
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNode, bstrChildTag, &bstr);

    if (SUCCEEDED(hr))
    {
        if (!StrCmpIW(bstr, L"on"))
        {
            *pfBoolean = TRUE;
        }
        else
        {
            *pfBoolean = FALSE;
        }

        SysFreeString(bstr);
    }

    return hr;
}


BOOL XML_IsChildTagTextEqual(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, IN BSTR bstrText)
{
    BOOL fIsChildTagTextEqual = FALSE;
    BSTR bstrChildText;
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNode, bstrChildTag, &bstrChildText);

    if (SUCCEEDED(hr))
    {
        // Is this <TYPE>email</TYPE>?
        if (!StrCmpIW(bstrChildText, bstrText))
        {
            // No, so keep looking.
            fIsChildTagTextEqual = TRUE;
        }

        SysFreeString(bstrChildText);
    }

    return fIsChildTagTextEqual;
}




#define EMPTYSTR_FOR_NULL(str)      ((!str) ? TEXT("") : (str))


/////////////////////////////////////////////////////////////////////
// File System Wrapping Helpers
/////////////////////////////////////////////////////////////////////
HRESULT CreateFileHrWrap(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                       DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE * phFileHandle)
{
    HRESULT hr = S_OK;
    HANDLE hTemp = NULL;
    DWORD dwError = 0;

    if (!phFileHandle)
        phFileHandle = &hTemp;

    *phFileHandle = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
    if (INVALID_HANDLE_VALUE == *phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    if (hTemp)
        CloseHandle(hTemp);

    return hr;
}


HRESULT WriteFileWrap(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT DeleteFileHrWrap(LPCWSTR pszPath)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    if (!DeleteFileW(pszPath))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT GetPrivateProfileStringHrWrap(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
{
    HRESULT hr = S_OK;
    DWORD chGot = GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);

    // What else can indicate an error value?
    if (0 == chGot)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(hr))
            hr = E_FAIL;
    }

    return hr;
}





/////////////////////////////////////////////////////////////////////
// Registry Helpers
/////////////////////////////////////////////////////////////////////
HRESULT HrRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
    DWORD dwError = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, 
       REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
    DWORD dwError = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegQueryValueEx(IN HKEY hKey, IN LPCTSTR lpValueName, IN LPDWORD lpReserved, IN LPDWORD lpType, IN LPBYTE lpData, IN LPDWORD lpcbData)
{
    DWORD dwError = RegQueryValueEx(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegSetValueEx(IN HKEY hKey, IN LPCTSTR lpValueName, IN DWORD dwReserved, IN DWORD dwType, IN CONST BYTE *lpData, IN DWORD cbData)
{
    DWORD dwError = RegSetValueEx(hKey, lpValueName, dwReserved, dwType, lpData, cbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegEnumKey(HKEY hKey, DWORD dwIndex, LPTSTR lpName, DWORD cbName)
{
    DWORD dwError = RegEnumKey(hKey, dwIndex, lpName, cbName);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegEnumValue(HKEY hKey, DWORD dwIndex, LPTSTR lpValueName, LPDWORD lpcValueName, LPDWORD lpReserved,
        LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
    DWORD dwError = RegEnumValue(hKey, dwIndex, lpValueName, lpcValueName, lpReserved, lpType, lpData, lpcbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegQueryInfoKey(HKEY hKey, LPTSTR lpClass, LPDWORD lpcClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcMaxSubKeyLen, 
            LPDWORD lpcMaxClassLen, LPDWORD lpcValues, LPDWORD lpcMaxValueNameLen, LPDWORD lpcMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
{
    DWORD dwError = RegQueryInfoKey(hKey, lpClass, lpcClass, lpReserved, lpcSubKeys, lpcMaxSubKeyLen, 
            lpcMaxClassLen, lpcValues, lpcMaxValueNameLen, lpcMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrBStrRegQueryValue(IN HKEY hKey, IN LPCTSTR lpValueName, OUT BSTR * pbstr)
{
    TCHAR szValue[MAX_PATH];
    DWORD dwType;
    DWORD cbSize = sizeof(szValue);
    HRESULT hr = HrRegQueryValueEx(hKey, lpValueName, 0, &dwType, (BYTE *)szValue, &cbSize);

    *pbstr = NULL;
    if (SUCCEEDED(hr))
    {
        hr = HrSysAllocStringW(szValue, pbstr);
    }

    return hr;
}


HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType,
                    OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData)
{
    DWORD dwError = SHGetValue(hKey, pszSubKey, pszValue, pdwType, pvData, pcbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrSHSetValue(IN HKEY hkey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwType, OPTIONAL OUT LPVOID pvData, IN DWORD cbData)
{
    DWORD dwError = SHSetValue(hkey, pszSubKey, pszValue, dwType, pvData, cbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrBStrRegSetValue(IN HKEY hKey, IN LPCTSTR lpValueName, OUT BSTR bstr)
{
    DWORD cbSize = ((lstrlenW(bstr) + 1) * sizeof(bstr[0]));

    return  HrRegSetValueEx(hKey, lpValueName, 0, REG_SZ, (BYTE *)bstr, cbSize);
}






/////////////////////////////////////////////////////////////////////
// Palette Helpers
/////////////////////////////////////////////////////////////////////
COLORREF GetNearestPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    PALETTEENTRY pe;
    GetPaletteEntries(hpal, GetNearestPaletteIndex(hpal, rgb & 0x00FFFFFF), 1, &pe);
    return RGB(pe.peRed, pe.peGreen, pe.peBlue);
}


BOOL IsPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    return GetNearestPaletteColor(hpal, rgb) == (rgb & 0xFFFFFF);
}





/////////////////////////////////////////////////////////////////////
// Other Helpers
/////////////////////////////////////////////////////////////////////
HRESULT HrRewindStream(IStream * pstm)
{
    LARGE_INTEGER  liOrigin = {0,0};

    return pstm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
}



#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))





// PERFPERF 
// This routine used to copy 512 bytes at a time, but that had a major negative perf impact.
// I have measured a 2-3x speedup in copy times by increasing this buffer size to 16k.
// Yes, its a lot of stack, but it is memory well spent.                    -saml
#define STREAM_COPY_BUF_SIZE        16384
#define STREAM_PROGRESS_INTERVAL    (100*1024/STREAM_COPY_BUF_SIZE) // display progress after this many blocks

HRESULT StreamCopyWithProgress(IStream *pstmFrom, IStream *pstmTo, ULARGE_INTEGER cb, PROGRESSINFO * ppi)
{
    BYTE buf[STREAM_COPY_BUF_SIZE];
    ULONG cbRead;
    HRESULT hres = NOERROR;
    int nSection = 0;         // How many buffer sizes have we copied?
    ULARGE_INTEGER uliNewCompleted;

    if (ppi)
    {
        uliNewCompleted.QuadPart = ppi->uliBytesCompleted.QuadPart;
    }

    while (cb.QuadPart)
    {
        if (ppi && ppi->ppd)
        {
            if (0 == (nSection % STREAM_PROGRESS_INTERVAL))
            {
                EVAL(SUCCEEDED(ppi->ppd->SetProgress64(uliNewCompleted.QuadPart, ppi->uliBytesTotal.QuadPart)));

                if (ppi->ppd->HasUserCancelled())
                {
                    hres = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    break;
                }
            }
        }

        hres = pstmFrom->Read(buf, min(cb.LowPart, SIZEOF(buf)), &cbRead);
        if (FAILED(hres) || (cbRead == 0))
        {
            //  sometimes we are just done.
            if (SUCCEEDED(hres))
                hres = S_OK;
            break;
        }


        if (ppi)
        {
            uliNewCompleted.QuadPart += (ULONGLONG) cbRead;
        }

        cb.QuadPart -= cbRead;

        hres = pstmTo->Write(buf, cbRead, &cbRead);
        if (FAILED(hres) || (cbRead == 0))
            break;

        nSection++;
    }

    return hres;
}

/*
// These are needed for COM/COM+ interop

void __stdcall
_com_raise_error(HRESULT hr, IErrorInfo* perrinfo) throw(_com_error)
{
        throw _com_error(hr, perrinfo);
}

void __stdcall
_com_issue_error(HRESULT hr) throw(_com_error)
{
        _com_raise_error(hr, NULL);
}

void __stdcall
_com_issue_errorex(HRESULT hr, IUnknown* punk, REFIID riid) throw(_com_error)
{
        IErrorInfo* perrinfo = NULL;
        if (punk == NULL) {
                goto exeunt;
        }
        ISupportErrorInfo* psei;
        if (FAILED(punk->QueryInterface(__uuidof(ISupportErrorInfo),
                           (void**)&psei))) {
                goto exeunt;
        }
        HRESULT hrSupportsErrorInfo;
        hrSupportsErrorInfo = psei->InterfaceSupportsErrorInfo(riid);
        psei->Release();
        if (hrSupportsErrorInfo != S_OK) {
                goto exeunt;
        }
        if (GetErrorInfo(0, &perrinfo) != S_OK) {
                perrinfo = NULL;
        }
exeunt:
        _com_raise_error(hr, perrinfo);
}
*/
// needed by smtpserv:

HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb)
{
    // Locals
    HRESULT hr=S_OK;
    LARGE_INTEGER  liOrigin = {0,0};

    // Create H Global Stream
    hr = CreateStreamOnHGlobal (NULL, TRUE, lppstm);
    if (FAILED(hr))
        goto exit;

    // Write String
    hr = (*lppstm)->Write (lpb, cb, NULL);
    if (FAILED(hr))
        goto exit;

    // Rewind the steam
    hr = (*lppstm)->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    if (FAILED(hr))
        goto exit;

exit:
    // Done
    return hr;
}

const char szDayOfWeekArray[7][4] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" } ;
const char szMonthOfYearArray[12][4] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" } ;

void GetDateString(char * szSentDateString, ULONG stringLen)
{
    // Sent Date
    SYSTEMTIME stSentTime;
    CHAR szMonth[10], szWeekDay[12] ; 

    GetSystemTime(&stSentTime);

    lstrcpynA(szWeekDay, szDayOfWeekArray[stSentTime.wDayOfWeek], ARRAYSIZE(szWeekDay)) ;
    lstrcpynA(szMonth, szMonthOfYearArray[stSentTime.wMonth-1], ARRAYSIZE(szMonth)) ;

    wnsprintfA(szSentDateString, stringLen, "%s, %u %s %u %2d:%02d:%02d ", (LPSTR) szWeekDay, stSentTime.wDay, 
                                (LPSTR) szMonth, stSentTime.wYear, stSentTime.wHour, 
                                stSentTime.wMinute, stSentTime.wSecond) ;
}


/*****************************************************************************\
    PARAMETERS:
        RETURN: Win32 HRESULT (Not Script Safe).
            SUCCEEDED(hr) for OK and out params filled in.
            FAILED(hr) for all errors.
\*****************************************************************************/
HRESULT GetQueryStringValue(BSTR bstrURL, LPCWSTR pwszValue, LPWSTR pwszData, int cchSizeData)
{
    HRESULT hr = E_FAIL;
    LPCWSTR pwszIterate = bstrURL;

    pwszIterate = StrChrW(pwszIterate, L'?');   // Advance to Query part of URL.
    while (pwszIterate && pwszIterate[0])
    {
        pwszIterate++;  // Start at first value
        
        LPCWSTR pwszEndOfValue = StrChrW(pwszIterate, L'=');
        if (!pwszEndOfValue)
            break;
        
        int cchValueSize = (INT)(UINT)(pwszEndOfValue - pwszIterate);
        if (0 == StrCmpNIW(pwszValue, pwszIterate, cchValueSize))
        {
            int cchSizeToCopy = cchSizeData;  // Copy rest of line by default.

            pwszIterate = StrChrW(pwszEndOfValue, L'&');
            if (pwszIterate)
            {
                cchSizeToCopy = (INT)(UINT)(pwszIterate - pwszEndOfValue);
            }

            // It matches, now get the Data.
            StrCpyNW(pwszData, (pwszEndOfValue + 1), cchSizeToCopy);
            hr = S_OK;
            break;
        }
        else
        {
            pwszIterate = StrChrW(pwszEndOfValue, L'&');
        }
    }

    return hr;
}


BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = (ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES | ICC_COOL_CLASSES | ICC_INTERNET_CLASSES | ICC_PAGESCROLLER_CLASS | ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES);
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}


HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd)
{
    ULARGE_INTEGER uiResult;

    uiResult.QuadPart = (ULONGLONG) ShellExecute(hwnd, lpVerb, lpFile, lpParameters, lpDirectory, nShowCmd);
    if (32 < uiResult.QuadPart)
    {
        uiResult.LowPart = ERROR_SUCCESS;
    }

    return HRESULT_FROM_WIN32(uiResult.LowPart);
}


HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPTSTR pszTempLastHalf = NULL;
    LPTSTR pszNextToken = pszString;

    while (pszNextToken = StrStrI(pszNextToken, pszToken))
    {
        // We found one.
        LPTSTR pszPastToken = pszNextToken + lstrlen(pszToken);

        Str_SetPtr(&pszTempLastHalf, pszPastToken);      // Keep a copy because we will overwrite it.

        pszNextToken[0] = 0;    // Remove the rest of the string.
        StrCatBuff(pszString, pszReplaceValue, cchSize);
        StrCatBuff(pszString, pszTempLastHalf, cchSize);

        pszNextToken += lstrlen(pszReplaceValue);
    }

    Str_SetPtr(&pszTempLastHalf, NULL);

    return hr;
}


BOOL IUnknown_CompareCLSID(IN IUnknown * punk, IN CLSID clsid)
{
    BOOL fIsEqual = FALSE;

    if (punk)
    {
        CLSID clsidPageID;
        HRESULT hr = IUnknown_GetClassID(punk, &clsidPageID);

        if (SUCCEEDED(hr) && IsEqualCLSID(clsidPageID, clsid))
        {
            fIsEqual = TRUE;
        }
    }

    return fIsEqual;
}


HRESULT IEnumUnknown_FindCLSID(IN IUnknown * punk, IN CLSID clsid, OUT IUnknown ** ppunkFound)
{
    HRESULT hr = E_INVALIDARG;

    if (punk && ppunkFound)
    {
        IEnumUnknown * pEnum;

        *ppunkFound = NULL;
        hr = punk->QueryInterface(IID_PPV_ARG(IEnumUnknown, &pEnum));
        if (SUCCEEDED(hr))
        {
            IUnknown * punkToTry;
            ULONG ulFetched;

            while (SUCCEEDED(pEnum->Next(1, &punkToTry, &ulFetched)) &&
                (1 == ulFetched))
            {
                if (IUnknown_CompareCLSID(punkToTry, clsid))
                {
                    *ppunkFound = punkToTry;
                    break;
                }

                punkToTry->Release();
            }

            pEnum->Release();
        }
    }

    return hr;
}


HRESULT GetPageByCLSID(IUnknown * punkSite, const GUID * pClsid, IPropertyBag ** ppPropertyBag)
{
    HRESULT hr = E_FAIL;

    *ppPropertyBag = NULL;
    if (punkSite)
    {
        IThemeUIPages * pThemeUI;

        hr = punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUI));
        if (SUCCEEDED(hr))
        {
            IEnumUnknown * pEnumUnknown;

            hr = pThemeUI->GetBasePagesEnum(&pEnumUnknown);
            if (SUCCEEDED(hr))
            {
                IUnknown * punk;

                // This may not exit due to policy
                hr = IEnumUnknown_FindCLSID(pEnumUnknown, *pClsid, &punk);
                if (SUCCEEDED(hr))
                {
                    hr = punk->QueryInterface(IID_PPV_ARG(IPropertyBag, ppPropertyBag));
                    punk->Release();
                }

                pEnumUnknown->Release();
            }

            pThemeUI->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskpan\propsext.cpp ===
#include "deskpan.h"

#include "..\..\common\propsext.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskpan\deskpan.h ===
/******************************************************************************

  Source File:  deskpan.h

  General include file

  Copyright (c) 1997-1998 by Microsoft Corporation

  Change History:

  12-01-97 AndreVa - Created It

******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shsemip.h>
#include <stdlib.h>
#include <shlobjp.h>
#include <shellp.h>
#include <string.h>

#include <initguid.h>
#include <help.h>
#include "..\..\common\deskcplext.h"
#include "..\..\common\propsext.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskpan\deskpan.cpp ===
/******************************************************************************

  Source File:  deskpan.cpp

  Main code for the advanced desktop Panning page

  Copyright (c) 1997-1998 by Microsoft Corporation

  Change History:

  12-16-97 AndreVa - Created It

******************************************************************************/


#include    "deskpan.h"
#define DECL_CRTFREE
#include <crtfree.h>

// OLE-Registry magic number
// 42071714-76d4-11d1-8b24-00a0c9068ff3
//
GUID g_CLSID_CplExt = { 0x42071714, 0x76d4, 0x11d1,
                        { 0x8b, 0x24, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3}
                      };


DESK_EXTENSION_INTERFACE DeskInterface;

static const DWORD sc_PanningHelpIds[] =
{
   0, 0
};

///////////////////////////////////////////////////////////////////////////////
//
// Messagebox wrapper
//
///////////////////////////////////////////////////////////////////////////////


int
FmtMessageBox(
    HWND hwnd,
    UINT fuStyle,
    DWORD dwTitleID,
    DWORD dwTextID)
{
    TCHAR Title[256];
    TCHAR Text[2000];

    LoadString(g_hInst, dwTextID, Text, SIZEOF(Text));
    LoadString(g_hInst, dwTitleID, Title, SIZEOF(Title));

    return (MessageBox(hwnd, Text, Title, fuStyle));
}


//---------------------------------------------------------------------------
//
// PropertySheeDlgProc()
//
//  The dialog procedure for the "Panning" property sheet page.
//
//---------------------------------------------------------------------------
INT_PTR
CALLBACK
PropertySheeDlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskpan\resource.h ===
/******************************************************************************

  Source File:  Resource.H

  Resource Identifier Definitions for desktop monitor information

  Copyright (c) 1998 by Microsoft Corporation


******************************************************************************/


// Property sheet

#define PROP_SHEET_DLG        200

// Strings

#define IDS_PAGE_TITLE          1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\desknt5\util.h ===
/*****************************************************************************\
    FILE: util.h

    DESCRIPTION:
        Shared stuff that operates on all classes.

    BryanSt 5/30/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

#define HINST_THISDLL       hInstance



// String Helpers
HRESULT HrSysAllocStringA(IN LPCSTR pszSource, OUT BSTR * pbstrDest);
HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT BSTRFromStream(IStream * pStream, BSTR * pbstrXML);
HRESULT CreateBStrVariantFromWStr(IN OUT VARIANT * pvar, IN LPCWSTR pwszString);
HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest);
HRESULT BOOLToString(BOOL fBoolean, BSTR * pbstrValue);
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb);

#ifdef UNICODE
#define SysAllocStringT(pszString)    SysAllocString(pszString)
#else
extern BSTR SysAllocStringA(LPCSTR pszString);
#define SysAllocStringT(pszString)    SysAllocStringA(pszString)
#endif

HRESULT GetQueryStringValue(BSTR bstrURL, LPCWSTR pwszValue, LPWSTR pwszData, int cchSizeData);
HRESULT UnEscapeHTML(BSTR bstrEscaped, BSTR * pbstrUnEscaped);
HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize);


// XML Related Helpers
HRESULT XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc);
HRESULT XMLBStrFromDOM(IXMLDOMDocument * pXMLDoc, BSTR * pbstrXML);
HRESULT XMLAppendElement(IXMLDOMElement * pXMLElementRoot, IXMLDOMElement * pXMLElementToAppend);
HRESULT XMLDOMFromFile(IN LPCWSTR pwzPath, OUT IXMLDOMDocument ** ppXMLDOMDoc);
HRESULT XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName);
HRESULT XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList);
HRESULT XMLNodeList_GetChild(IXMLDOMNodeList * pNodeList, DWORD dwIndex, IXMLDOMNode ** ppXMLChildNode);
HRESULT XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode);
HRESULT XMLNode_GetTagText(IN IXMLDOMNode * pXMLNode, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetAttributeValue(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszAttributeName, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetChildTagTextValue(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BSTR * pbstrValue);
HRESULT XMLNode_GetChildTagTextValueToBool(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BOOL * pfBoolean);
BOOL XML_IsChildTagTextEqual(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, IN BSTR bstrText);




// Registry Helpers
HRESULT HrRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
HRESULT HrRegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, 
       REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
HRESULT HrRegQueryValueEx(HKEY hKey, LPCTSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HRESULT HrRegSetValueEx(IN HKEY hKey, IN LPCTSTR lpValueName, IN DWORD dwReserved, IN DWORD dwType, IN CONST BYTE *lpData, IN DWORD cbData);
HRESULT HrRegEnumKey(HKEY hKey, DWORD dwIndex, LPTSTR lpName, DWORD cbName);
HRESULT HrRegEnumValue(HKEY hKey, DWORD dwIndex, LPTSTR lpValueName, LPDWORD lpcValueName, LPDWORD lpReserved,
        LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HRESULT HrRegQueryInfoKey(HKEY hKey, LPTSTR lpClass, LPDWORD lpcClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcMaxSubKeyLen, 
            LPDWORD lpcMaxClassLen, LPDWORD lpcValues, LPDWORD lpcMaxValueNameLen, LPDWORD lpcMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);

HRESULT HrBStrRegQueryValue(IN HKEY hKey, IN LPCTSTR lpValueName, OUT BSTR * pbstr);
HRESULT HrBStrRegSetValue(IN HKEY hKey, IN LPCTSTR lpValueName, OUT BSTR bstr);
HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType, OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData);
HRESULT HrSHSetValue(IN HKEY hkey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwType, OPTIONAL OUT LPVOID pvData, IN DWORD cbData);



// Palette Helpers
COLORREF GetNearestPaletteColor(HPALETTE hpal, COLORREF rgb);
BOOL IsPaletteColor(HPALETTE hpal, COLORREF rgb);



HRESULT GetPageByCLSID(IUnknown * punkSite, const GUID * pClsid, IPropertyBag ** ppPropertyBag);


// Other Helpers
HRESULT GetPrivateProfileStringHrWrap(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
BOOL _InitComCtl32();
HRESULT HrRewindStream(IStream * pstm);
HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd);
COLORREF ConvertColor(LPTSTR pszColor);
BOOL IUnknown_CompareCLSID(IN IUnknown * punk, IN CLSID clsid);
HRESULT IEnumUnknown_FindCLSID(IN IUnknown * punk, IN CLSID clsid, OUT IUnknown ** ppunkFound);




typedef struct tagPROGRESSINFO
{
    IProgressDialog * ppd;
    ULARGE_INTEGER uliBytesCompleted;
    ULARGE_INTEGER uliBytesTotal;
} PROGRESSINFO, * LPPROGRESSINFO;

HRESULT StreamCopyWithProgress(IStream *pstmFrom, IStream *pstmTo, ULARGE_INTEGER cb, PROGRESSINFO * ppi);

HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb);
void    GetDateString(char * szSentDateString, ULONG stringLen);




#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskperf\deskcmmn.cpp ===
#include "deskperf.h"

#include "..\..\common\deskcmmn.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskpan\sources.inc ===
TARGETNAME = deskpan
TARGETPATH = obj
TARGETTYPE = DYNLINK
TARGETEXT  = dll

COFFBASE   = desk

INCLUDES=$(INCLUDES);..;$(SDK_LIB_PATH);$(PROJECT_ROOT)\lib\$(O);$(PROJECT_ROOT)\inc\$(O);

SOURCES = ..\deskpan.rc   \
          ..\deskpan.cpp  \
          ..\propsext.cpp


# Dynamically loading comctl32 through shfusion.  Need to ignore "locally defined symbol imported" error. (LAmadio)
LINKER_FLAGS    = $(LINKER_FLAGS) -ignore:4049 -ignore:4217

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib         \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\gdi32.lib            \
           $(SDK_LIB_PATH)\ole32.lib            \
           $(SDK_LIB_PATH)\shell32.lib          \
           $(SDK_LIB_PATH)\shlwapi.lib          \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\uuid.lib             \
           $(WINDOWS_LIB_PATH)\user32p.lib      \
           $(SHELL_LIB_PATH)\shfusion.lib



UMTYPE     = windows

USE_MSVCRT = 1

DLLENTRY   = DllMain

DLLDEF=$(O)\deskpan.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskperf\propsext.cpp ===
#include "deskperf.h"

#include "..\..\common\propsext.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskperf\resource.h ===
// Static control

#ifndef IDC_STATIC
#define IDC_STATIC               (-1)
#endif

// Icon

#define IDI_MONITOR              100

// Property sheet

#define PROP_SHEET_DLG           200
#define IDC_ACCELERATION_SLIDER  201
#define IDC_ACCELERATION_TEXT    202
#define IDC_TROUBLE_SHOOTER      203
#define IDC_DESCRIPTION          204
#define IDC_ENABLE_USWC          205

// dialog box

#define DLG_ASKDYNACDS           250
#define IDC_NODYNA               251
#define IDC_YESDYNA              252
#define IDC_SHUTUP               253

// Strings

#define IDS_PAGE_TITLE             1
#define IDS_LEVEL0               300
#define IDS_LEVEL1               301
#define IDS_LEVEL2               302 
#define IDS_LEVEL3               303
#define IDS_LEVEL4               304
#define IDS_LEVEL5               305
#define IDS_WC_CAPTION           310
#define IDS_WC_MESSAGE           311
#define IDS_ERR_CAPTION          312
#define IDS_ERR_MESSAGE          313

// Help

#define IDH_NOHELP               ((DWORD)-1)
#define IDH_DISPLAY_SETTINGS_ADVANCED_TROUBLESHOOT_ACCELERATION     4175
#define IDH_DISPLAY_SETTINGS_ADVANCED_TROUBLESHOOT_WRITE_COMBINING  4176
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskperf\deskperf.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shsemip.h>
#include <stdlib.h>
#include <shlobjp.h>
#include <shellp.h>
#include <string.h>
#include <htmlhelp.h>
#include <stdlib.h>
#include <tchar.h>
#include <string.h>

#include <initguid.h>
#include <help.h>
#include <commctrl.h>

#include <winuser.h>
#include <winuserp.h>

#include "..\..\common\deskcplext.h"
#include "..\..\common\propsext.h"
#include "..\..\common\deskcmmn.h"

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskperf\deskperf.cpp ===
//
// [Display Troubleshooter Control Panel Extenstion]
//
//
// - Aug.25.1998
//
//    Created by Hideyuki Nagase [hideyukn]
// 

#include    "deskperf.h"
#define DECL_CRTFREE
#include <crtfree.h>

//
// Defines
//

#define ACCELERATION_FULL  0
#define ACCELERATION_NONE  5

#define SLIDER_POS_TO_ACCEL_LEVEL(x) (ACCELERATION_NONE - (x))
#define ACCEL_LEVEL_TO_SLIDER_POS(x) (ACCELERATION_NONE - (x))

#define REGSTR_GRAPHICS_DRIVERS  TEXT("System\\CurrentControlSet\\Control\\GraphicsDrivers")
#define REGSTR_DISABLE_USWC      TEXT("DisableUSWC")


//
// Guid for "Troubleshooter" shell extentions
//

GUID g_CLSID_CplExt = { 0xf92e8c40, 0x3d33, 0x11d2,
                        { 0xb1, 0xaa, 0x08, 0x00, 0x36, 0xa7, 0x5b, 0x03}
                      };

//
// Global variables
//

//
// Dos display device name
//

TCHAR gszWinDisplayDevice[MAX_PATH];

//
// NT display device name
//

TCHAR gszNtDisplayDevice[MAX_PATH];

//
// Registry path for current device
//

TCHAR gszRegistryPath[MAX_PATH];

//
// Current acceleration level.
//

DWORD AccelLevel = ACCELERATION_FULL;

//
// Last saved acceleration level.
//

DWORD AccelLevelInReg = ACCELERATION_FULL;

//
// Registry security.
//

BOOL  gbReadOnly = FALSE;

//
// Is DisableUSWC key present?.
//

BOOL gbDisableUSWC = FALSE;

//
// Context-sentitive help
//

static const DWORD sc_PerformanceHelpIds[] =
{
   IDI_MONITOR,             IDH_NOHELP,
   IDC_DESCRIPTION,         IDH_NOHELP,
   IDC_ACCELERATION_SLIDER, IDH_DISPLAY_SETTINGS_ADVANCED_TROUBLESHOOT_ACCELERATION,
   IDC_ACCELERATION_TEXT,   IDH_DISPLAY_SETTINGS_ADVANCED_TROUBLESHOOT_ACCELERATION,
   IDC_ENABLE_USWC,         IDH_DISPLAY_SETTINGS_ADVANCED_TROUBLESHOOT_WRITE_COMBINING,
   0, 0
};

void
UpdateGraphicsText(HWND hDlg, DWORD AccelPos)
{
    TCHAR MessageBuffer[200];

    LoadString(g_hInst, IDS_LEVEL0 + AccelPos, MessageBuffer, ARRAYSIZE(MessageBuffer));

    SetDlgItemText(hDlg, IDC_ACCELERATION_TEXT, (LPTSTR) MessageBuffer);
}

BOOL GetDeviceKey(LPCTSTR pszDisplay, LPTSTR pszDeviceKey, int cChars)
{
    DISPLAY_DEVICE DisplayDevice;
    BOOL fFound = FALSE;
    BOOL fSuccess = TRUE;
    int iEnum = 0;

    // Enumerate all the devices in the system.
    while(fSuccess && !fFound)
    {
        ZeroMemory(&DisplayDevice, sizeof(DISPLAY_DEVICE));
        DisplayDevice.cb = sizeof(DISPLAY_DEVICE);
        fSuccess = EnumDisplayDevices(NULL, iEnum, &DisplayDevice, 0);
        if(fSuccess)
        {
            if(0 == lstrcmp(&DisplayDevice.DeviceName[0], pszDisplay))
            {
                ASSERT(lstrlen(DisplayDevice.DeviceKey) < cChars);
                fSuccess = (lstrlen(DisplayDevice.DeviceKey) < cChars);
                if(fSuccess)
                {
                    lstrcpy(pszDeviceKey, DisplayDevice.DeviceKey);
                    fFound = TRUE;
                }
            }
            ++iEnum;
        }
    }
    
    return fFound;
}


INT_PTR
CALLBACK
AskDynamicApply(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    int *pTemp;

    switch (msg)
    {
    case WM_INITDIALOG:
        if ((pTemp = (int *)lp) != NULL)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pTemp);
            CheckDlgButton(hDlg, (*pTemp & DCDSF_DYNA)?
                           IDC_YESDYNA : IDC_NODYNA, BST_CHECKED);
        }
        else
            EndDialog(hDlg, -1);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wp, lp))
        {
        case IDOK:
            if ((pTemp = (int *)GetWindowLongPtr(hDlg, DWLP_USER)) != NULL)
            {
                *pTemp = IsDlgButtonChecked(hDlg, IDC_YESDYNA)? DCDSF_DYNA : 0;

                if (!IsDlgButtonChecked(hDlg, IDC_SHUTUP))
                    *pTemp |= DCDSF_ASK;

                SetDisplayCPLPreference(REGSTR_VAL_DYNASETTINGSCHANGE, *pTemp);
            }

            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


INT_PTR
CALLBACK
PropertySheeDlgProc(
    HWND hDlg,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMessage)
    {
    case WM_INITDIALOG:

        if (!g_lpdoTarget)
        {
            return FALSE;
        }
        else
        {
            BOOL bSuccess = FALSE;
            BOOL bDisableUSWCReadOnly = TRUE;

            //
            // LATER: Check we are on Terminal Server client or not.
            //

            BOOL bLocalConsole = TRUE;

            if (bLocalConsole)
            {
                //
                // Get the display device name from IDataObject.
                //

                FORMATETC fmte = {(CLIPFORMAT)RegisterClipboardFormat(DESKCPLEXT_DISPLAY_DEVICE),
                                  (DVTARGETDEVICE FAR *) NULL,
                                  DVASPECT_CONTENT,
                                  -1,
                                  TYMED_HGLOBAL};

                STGMEDIUM stgm;

                HRESULT hres = g_lpdoTarget->GetData(&fmte, &stgm);

                if (SUCCEEDED(hres) && stgm.hGlobal)
                {
                    //
                    // The storage now contains Display device path (\\.\DisplayX) in UNICODE.
                    //

                    PWSTR pDisplayDevice = (PWSTR) GlobalLock(stgm.hGlobal);

                    if (pDisplayDevice)
                    {
                        //
                        // Copy the data to local buffer.
                        //

                    #ifdef UNICODE

                        lstrcpy(gszWinDisplayDevice,pDisplayDevice);
                        bSuccess = TRUE;

                    #else

                        bSuccess = (BOOL) WideCharToMultiByte(
                                            CP_ACP,0,
                                            pDisplayDevice,lstrlenW(pDisplayDevice)+1,
                                            gszWinDisplayDevice,MAX_PATH,
                                            NULL,NULL);

                    #endif

                        GlobalUnlock(stgm.hGlobal);
                    }  
                }

                //
                // let's build registry path for its hardware profile.
                //

                if (bSuccess)
                {
                    TCHAR szServicePath[MAX_PATH];

                    bSuccess = FALSE;

                    if(GetDeviceKey(gszWinDisplayDevice, szServicePath, sizeof(szServicePath) / sizeof(TCHAR)))
                    {
                        //
                        // Upcase all character.
                        //

                        TCHAR *psz = szServicePath;

                        while (*psz)
                        {
                            *psz = _totupper(*psz);
                            psz++;
                        }

                        //
                        // Find \SYSTEM from service path
                        //

                        psz = _tcsstr(szServicePath,TEXT("\\SYSTEM"));

                        //
                        // Skip '\'
                        //

                        psz++;

                        lstrcpy(gszRegistryPath,psz);

                        bSuccess = TRUE;
                    }
                }

                if (bSuccess)
                {
                    //
                    // Read current acceleration level from registry.
                    //

                    HKEY hKeyAccelLevel = NULL;

                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     gszRegistryPath,
                                     0,
                                     KEY_ALL_ACCESS,
                                     &hKeyAccelLevel) != ERROR_SUCCESS)
                    {
                        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                         gszRegistryPath,
                                         0,
                                         KEY_READ,
                                         &hKeyAccelLevel) != ERROR_SUCCESS)
                        {
                            hKeyAccelLevel = NULL;
                        }
                        else
                        {
                            gbReadOnly = TRUE;
                        }
                    }

                    if (hKeyAccelLevel)
                    {
                        DWORD cb = sizeof(AccelLevel);

                        if (RegQueryValueEx(hKeyAccelLevel,
                                            SZ_HW_ACCELERATION,
                                            NULL,NULL,
                                            (LPBYTE) &AccelLevel,
                                            &cb) == ERROR_SUCCESS)
                        {
                            //
                            // Update last saved accel level.
                            //

                            AccelLevelInReg = AccelLevel;
                        }
                        else
                        {
                            //
                            // If there is no registry value, assume full acceleration.
                            //

                            AccelLevelInReg = AccelLevel = ACCELERATION_FULL;
                        }

                        RegCloseKey(hKeyAccelLevel);

                        bSuccess = TRUE;
                    }
                }
            
                //
                // Read current DisableUSWC status.
                //

                HKEY hKeyGraphicsDrivers = NULL;
                bDisableUSWCReadOnly = FALSE;
                
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 REGSTR_GRAPHICS_DRIVERS,
                                 0,
                                 KEY_ALL_ACCESS,
                                 &hKeyGraphicsDrivers) != ERROR_SUCCESS)
                {
                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     REGSTR_GRAPHICS_DRIVERS,
                                     0,
                                     KEY_READ,
                                     &hKeyGraphicsDrivers) != ERROR_SUCCESS)
                    {
                        hKeyGraphicsDrivers = NULL;
                    }
                    else
                    {
                        bDisableUSWCReadOnly = TRUE;
                    }
                }

                if (NULL != hKeyGraphicsDrivers) 
                {
                    HKEY hKeyDisableUSWC = NULL;
                    gbDisableUSWC = 
                        (RegOpenKeyEx(hKeyGraphicsDrivers,
                                      REGSTR_DISABLE_USWC,
                                      0,
                                      KEY_READ,
                                      &hKeyDisableUSWC) == ERROR_SUCCESS);
                    
                    if (NULL != hKeyDisableUSWC)
                        RegCloseKey(hKeyDisableUSWC);

                    RegCloseKey(hKeyGraphicsDrivers);
                }
            }

            //
            // Setup slider.
            //

            HWND hSlider = GetDlgItem(hDlg, IDC_ACCELERATION_SLIDER);

            //
            // Slider range is between ACCEL_FULL and ACCEL_NONE.
            //

            SendMessage(hSlider, TBM_SETRANGE, (WPARAM)FALSE,
                        MAKELPARAM(ACCELERATION_FULL, ACCELERATION_NONE));

            //
            // Set currect slider position based on current accel level.
            //
 
            SendMessage(hSlider, TBM_SETPOS, (WPARAM)TRUE,
                        (LPARAM) ACCEL_LEVEL_TO_SLIDER_POS(AccelLevel));

            //
            // Update message based on current acceleration level.
            //

            UpdateGraphicsText(hDlg, AccelLevel);

            if (!bSuccess || gbReadOnly)
            {
                // 
                // Disable slider control
                //

                EnableWindow(hSlider, FALSE);
            }

            
            //
            // Setup DisableUSWC combobox
            //

            HWND hEnableUSWC = GetDlgItem(hDlg, IDC_ENABLE_USWC);
            if (NULL != hEnableUSWC)
            {
                CheckDlgButton(hDlg, IDC_ENABLE_USWC, !gbDisableUSWC);
                EnableWindow(hEnableUSWC, !bDisableUSWCReadOnly);
            }
        }

        break;

    case WM_HSCROLL:

        if (GetWindowLongPtr((HWND)lParam, GWLP_ID) == IDC_ACCELERATION_SLIDER)
        {
            //
            // Slider has been moved.
            //

            HWND hSlider = (HWND) lParam;

            //
            // Obtain currect slider position.
            //

            DWORD dwSliderPos = (DWORD) SendMessage(hSlider, TBM_GETPOS, 0, 0L);

            //
            // Convert slider position to accel level.
            //

            DWORD AccelNew = SLIDER_POS_TO_ACCEL_LEVEL(dwSliderPos); 

            //
            // If accleration level has been changed, update description, and
            // enable apply button.
            //

            if (AccelNew != AccelLevel)
            {
                AccelLevel = AccelNew;
                UpdateGraphicsText(hDlg, AccelNew);
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }
        }

        break;

    case WM_COMMAND:
        
        if (IDC_ENABLE_USWC == GET_WM_COMMAND_ID(wParam, lParam))
        {
            BOOL bDisableUSWC = 
                (BST_UNCHECKED == IsDlgButtonChecked(hDlg, IDC_ENABLE_USWC));
            
            if (gbDisableUSWC != bDisableUSWC) 
            {
                //
                // Enable Apply button
                //

                PropSheet_Changed(GetParent(hDlg), hDlg);
            }
        }
        break;

    case WM_NOTIFY:

        if (((NMHDR *)lParam)->code == PSN_APPLY)
        {
            TCHAR szCaption[128];
            TCHAR szMessage[256];
            BOOL bSuccess = TRUE;
            int val = 0;
            BOOL bCancel = FALSE;
            BOOL bAccelLevelDirty;
            BOOL bDisableUSWC;
            BOOL bUSWCDirty;

            bDisableUSWC = 
                (BST_UNCHECKED == IsDlgButtonChecked(hDlg, IDC_ENABLE_USWC));
            bUSWCDirty = (gbDisableUSWC != bDisableUSWC);
            bAccelLevelDirty = (AccelLevel != AccelLevelInReg);

            //
            // Popup dialogs to ask user to apply it dynamically or not.
            //

            if (bAccelLevelDirty)
            {
                val = GetDynaCDSPreference();

                if (val & DCDSF_ASK)
                {
                    if (!bUSWCDirty)
                    {
                        switch (DialogBoxParam(g_hInst, 
                                               MAKEINTRESOURCE(DLG_ASKDYNACDS),
                                               hDlg, 
                                               AskDynamicApply, 
                                               (LPARAM)&val))
                        {
                        case 0:         // user cancelled
                        case -1:        // dialog could not be displayed
                            bCancel = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        val = 0;
                    }
                }
            }

            if ((!(bUSWCDirty || bAccelLevelDirty)) || 
                bCancel)
            {
                //
                // Nothing to do
                //

                SetWindowLongPtr(hDlg, 
                                 DWLP_MSGRESULT, 
                                 ((!(bUSWCDirty || bAccelLevelDirty)) ? 
                                     PSNRET_NOERROR : 
                                     PSNRET_INVALID_NOCHANGEPAGE));

                break;
            }
            
            //
            // Acceleration Level 
            //

            if (AccelLevel != AccelLevelInReg)
            {
                //
                // AccelLevel has been changed. save it to registry.
                //

                HKEY hKeyAccelLevel;
                
                bSuccess = FALSE;
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 gszRegistryPath,
                                 0,
                                 KEY_ALL_ACCESS,
                                 &hKeyAccelLevel) == ERROR_SUCCESS)
                {
                    if (AccelLevel == ACCELERATION_FULL)
                    {
                        //
                        // If acceration is set to ACCELERATION_FULL (default)
                        // remove registry value.
                        //

                        if (RegDeleteValue(hKeyAccelLevel,
                                           SZ_HW_ACCELERATION) == ERROR_SUCCESS)
                        {
                            bSuccess = TRUE;
                        }
                    }
                    else
                    {
                        //
                        // Otherwise, save it to registry.
                        //

                        if (RegSetValueEx(hKeyAccelLevel,
                                          SZ_HW_ACCELERATION,
                                          NULL, REG_DWORD,
                                          (LPBYTE) &AccelLevel,
                                          sizeof(AccelLevel)) == ERROR_SUCCESS)
                        {
                            bSuccess = TRUE;
                        }
                    }

                    RegCloseKey(hKeyAccelLevel);
                }

                if (bSuccess)
                {
                    //
                    // Update last saved data.
                    //

                    AccelLevelInReg = AccelLevel;

                    //
                    // Apply it dynamically?
                    //

                    if ((val & DCDSF_DYNA) == DCDSF_DYNA)
                    {
                        // Apply it dynamically.

                        ChangeDisplaySettings(NULL, CDS_RAWMODE);
                    }
                }
            }

            //
            // Disable USWC
            //

            if (bSuccess && bUSWCDirty) 
            {
                HKEY hKeyGraphicsDrivers = NULL;
                bSuccess = FALSE;
                
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 REGSTR_GRAPHICS_DRIVERS,
                                 0,
                                 KEY_ALL_ACCESS,
                                 &hKeyGraphicsDrivers) == ERROR_SUCCESS)
                {
                    if (bDisableUSWC)
                    {
                        //
                        // Create the key
                        //
                          
                        HKEY hKeyDisableUSWC = NULL;
                        DWORD Disposition;
        
                        bSuccess = (RegCreateKeyEx(hKeyGraphicsDrivers,
                                                   REGSTR_DISABLE_USWC,
                                                   0,
                                                   NULL,
                                                   REG_OPTION_NON_VOLATILE,
                                                   KEY_READ,
                                                   NULL,
                                                   &hKeyDisableUSWC,
                                                   &Disposition) == ERROR_SUCCESS);
                        
                        if (bSuccess)
                            RegCloseKey(hKeyDisableUSWC);
        
                    }
                    else
                    {
                        //
                        // Delete the key
                        //
        
                        bSuccess = 
                            (RegDeleteKey(hKeyGraphicsDrivers, 
                                          REGSTR_DISABLE_USWC) == ERROR_SUCCESS);
                    }
                
                    if (bSuccess) 
                        gbDisableUSWC = bDisableUSWC;
                    
                    RegCloseKey(hKeyGraphicsDrivers);
                }


                if (bSuccess)
                {
                    //
                    // Notify the user it a reboot is needed
                    //
    
                    if ((LoadString(g_hInst, 
                                    IDS_WC_CAPTION, 
                                    szCaption, 
                                    SIZEOF(szCaption) / sizeof(TCHAR)) != 0) &&
                        (LoadString(g_hInst, 
                                   IDS_WC_MESSAGE, 
                                   szMessage, 
                                   SIZEOF(szMessage) / sizeof(TCHAR)) !=0))
                    {
                        MessageBox(hDlg,
                                   szMessage,
                                   szCaption,
                                   MB_OK | MB_ICONINFORMATION);
                    }
                }
            }

            if (bSuccess)
            {
                if (bUSWCDirty || (0 == val))
                    PropSheet_RestartWindows(GetParent(hDlg));
                
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            } 
            else
            {
                //
                // Notify the user that an unexpected error occured
                //

                if ((LoadString(g_hInst, 
                                IDS_ERR_CAPTION, 
                                szCaption, 
                                SIZEOF(szCaption) / sizeof(TCHAR)) != 0) &&
                    (LoadString(g_hInst, 
                               IDS_ERR_MESSAGE, 
                               szMessage, 
                               SIZEOF(szMessage) / sizeof(TCHAR)) !=0))
                {
                    MessageBox(hDlg,
                               szMessage,
                               szCaption,
                               MB_OK | MB_ICONERROR);
                }

                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            }
        }

        break;

    case WM_HELP:

        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                TEXT("display.hlp"),
                HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)sc_PerformanceHelpIds);

        break;


    case WM_CONTEXTMENU:

        WinHelp((HWND)wParam,
                TEXT("display.hlp"),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR)sc_PerformanceHelpIds);

        break;

    default:

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\deskperf\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

TARGETNAME = deskperf
TARGETPATH = obj
TARGETTYPE = DYNLINK
TARGETEXT  = dll

COFFBASE   = desk

DLLDEF=$(O)\deskperf.def

INCLUDES=$(INCLUDES);..;$(SDK_LIB_PATH);$(PROJECT_ROOT)\lib\$(O);$(PROJECT_ROOT)\inc\$(O);

SOURCES = ..\deskperf.rc    \
          ..\deskperf.cpp   \
          ..\propsext.cpp   \
          ..\deskcmmn.cpp


# Dynamically loading comctl32 through shfusion.  Need to ignore "locally defined symbol imported" error. (LAmadio)
LINKER_FLAGS    = $(LINKER_FLAGS) -ignore:4049 -ignore:4217

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib         \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\shlwapi.lib          \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\uuid.lib             \
           $(WINDOWS_LIB_PATH)\user32p.lib      \
           $(SHELL_LIB_PATH)\shfusion.lib

UMTYPE     = windows

USE_MSVCRT = 1

DLLENTRY   = DllMain


 
# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=WindowsShell 
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE=0000 
SXS_MANIFEST=WindowsShell.Manifest 
SXS_MANIFEST_IN_RESOURCES= 
SXS_MANIFEST_RESOURCE_ID=124 
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\aliases.cpp ===
/****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1994
 *  All rights reserved
 *
 ***************************************************************************/

#ifdef UNIX_FEATURE_ALIAS

#undef UNICODE

#include "inetcplp.h"
#include "shalias.h"

#include "mluisupp.h"

STDAPI RefreshGlobalAliasList();

#define  GETALIASLIST(hDlg)     ((LPALIASINFO )GetWindowLong(hDlg, DWL_USER))->aliasList
#define  GETALIASDELLIST(hDlg)  ((LPALIASINFO )GetWindowLong(hDlg, DWL_USER))->aliasDelList

BOOL CALLBACK AlEditDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID WINAPI InitAliasListStyle(HWND hwndLV, DWORD dwView);

static TCHAR g_szAliasKey[]     = TEXT("Software\\Microsoft\\Internet Explorer\\Unix\\Alias");

// InitListViewImageLists - creates image lists for a list view. 
// Returns TRUE if successful, or FALSE otherwise. 
// hwndLV - handle to the list view control. 
BOOL WINAPI InitAliasListImageLists(HWND hwndLV)     
{ 
    HICON hiconItem;        // icon for list view items 
    HIMAGELIST himlLarge;   // image list for icon view 
    HIMAGELIST himlSmall;   // image list for other views  

    // Create the full-sized and small icon image lists. 
    himlLarge = ImageList_Create(GetSystemMetrics(SM_CXICON), 
        GetSystemMetrics(SM_CYICON), TRUE, 1, 1); 
    himlSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON), 
        GetSystemMetrics(SM_CYSMICON), TRUE, 1, 1);  
    
    // Add an icon to each image list. 
    // note that IDI_WALLET has to live in inetcplc.rc because
    // it's used by a localizable dialog, hence the MLGetHinst()
    hiconItem = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_WALLET));
    ImageList_AddIcon(himlLarge, hiconItem); 
    ImageList_AddIcon(himlSmall, hiconItem);     
    DeleteObject(hiconItem);  
    
    // Assign the image lists to the list view control. 
    ListView_SetImageList(hwndLV, himlLarge, LVSIL_NORMAL); 
    ListView_SetImageList(hwndLV, himlSmall, LVSIL_SMALL);     

    return TRUE;     
} 

    
// InitListViewItems - adds items and subitems to a list view. 
// Returns TRUE if successful, or FALSE otherwise. 
// hwndLV - handle to the list view control. 
// pfData - text file containing list view items with columns 
//          separated by semicolons. 
BOOL WINAPI InitAliasListItems(HWND hwndLV, HDPA aliasList)     
{ 
    PSTR pszEnd;
    int iItem;
    int iSubItem;
    LVITEM lvi;  
    
    // Initialize LVITEM members that are common to all items. 
    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE; 
    lvi.state = 0;     lvi.stateMask = 0; 
    lvi.pszText = LPSTR_TEXTCALLBACK;   // app. maintains text 
    lvi.iImage = 0;                     // image list index  
    
    int aliasCount = DPA_GetPtrCount( aliasList );

    for (int i = 0; i< aliasCount; i++)
    { 
        CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasList, i );

        // Initialize item-specific LVITEM members.         
        lvi.iItem = i; 
        lvi.iSubItem = 0;
        lvi.lParam = (LPARAM) NULL;    // item data  
        // Add the item.       
        ListView_InsertItem(hwndLV, &lvi);  

        // Initialize item-specific LVITEM members.         
        ListView_SetItemText(hwndLV, i, 0, (TCHAR*)GetAliasName(ptr));  
        ListView_SetItemText(hwndLV, i, 1, (TCHAR*)GetAliasUrl(ptr));  
    }      
    
    return TRUE;
}  


// InitListViewColumns - adds columns to a list view control. 
// Returns TRUE if successful, or FALSE otherwise. 
// hwndLV - handle to the list view control. 
BOOL WINAPI InitAliasListColumns(HWND hwndLV)     
{ 
    TCHAR g_achTemp[256];         // temporary buffer     
    LVCOLUMN lvc; 
    int iCol;      
    
    // Initialize the LVCOLUMN structure. 
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; 
    lvc.fmt = LVCFMT_LEFT;     
    lvc.pszText = g_achTemp;  
    
    // Add the columns.     
    for (iCol = 0; iCol < ALIASLIST_COLUMNS; iCol++) 
    { 
        lvc.iSubItem = iCol; 
        lvc.cx = 100 + (iCol*150);     
        MLLoadString(IDS_FIRSTCOLUMN + iCol, 
                g_achTemp, sizeof(g_achTemp)); 
        if (ListView_InsertColumn(hwndLV, iCol, &lvc) == -1) 
            return FALSE;     
    } 

    return TRUE;
}

// SetView - sets a list view's window style to change the view. 
// hwndLV - handle to the list view control. 
// dwView - value specifying a view style.      
VOID WINAPI InitAliasListStyle(HWND hwndLV, DWORD dwView)     
{ 
    // Get the current window style. 
    DWORD dwStyle = ListView_GetExtendedListViewStyle(hwndLV);  

    ListView_SetExtendedListViewStyle( hwndLV, (dwStyle|dwView) );
    // SetWindowLong(hwndLV, GWL_EXSTYLE, (dwStyle | dwView)); 
} 

// AliasDel - deletes alias from active list and moves it to the
//            del list to be delete later. 
// hDlg - handle of the propertysheet dialog.
BOOL WINAPI AliasDel( HWND hDlg )
{
    int index = 0, iItem = 0;
    HWND lb           = GetDlgItem( hDlg, IDC_ALIAS_LIST );
    HDPA aliasList    = GETALIASLIST(hDlg);
    HDPA aliasDelList = GETALIASDELLIST(hDlg);
    BOOL fAsked       = FALSE;
    BOOL fChanged     = FALSE;
    int  count        = ListView_GetItemCount(lb);

    // Get the selection from the Listview and remove it from the
    // active alias list, add it to the aliaslist to be deleted.
    while( (iItem = ListView_GetNextItem( lb, -1, LVNI_SELECTED ) ) != -1 )
    {
        TCHAR str[MAX_URL_STRING]; *str = TEXT('\0');

        if( !fAsked )
        {
            TCHAR question[MAX_PATH];

            wsprintf( question, "Are you Sure you want to delete the selected items?");
            if( MessageBox( GetParent(hDlg), question, TEXT("Delete Alias"), MB_YESNO ) != IDYES )
                return FALSE;

            fAsked = TRUE;
        }

        // if( !ListView_GetCheckState(lb, iItem) ) continue;

        ListView_GetItemText(lb, iItem, 0, str, MAX_URL_STRING );
        if(*str)
        {
            if( (index = FindAliasIndex(aliasList, str) ) != -1 )
            {
                 CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasList, index );
                 if( ptr )
                 {
                    CAlias *pAlias = (CAlias *)DPA_DeletePtr( aliasList, index );

                    // Add to List of deleted entries
                    DPA_InsertPtr( aliasDelList, 0x7FFF, pAlias );
                    ListView_DeleteItem(lb, iItem);
                    fChanged = TRUE;
                    LocalFree( str );
                } 
            }
        }
    }

    if( fChanged )
    {
        InitAliasDialog( hDlg, NULL, FALSE ); 
        PropSheet_Changed(GetParent(hDlg),hDlg);
    }

    return TRUE;
}


// AliasEdit - Called in response to the Edit button pressed.
// hDlg - Handle to the property sheet 
BOOL WINAPI AliasEdit( HWND hDlg )
{
    CAlias * ptr = GetCurrentAlias( hDlg );
    HDPA aliasDelList = GETALIASDELLIST(hDlg);

    if( ptr )
    {
        CAlias *ptrOld = (CAlias *)CreateAlias( (LPTSTR)GetAliasName(ptr) );
        ALIASEDITINFO aliasEditInfo = { GETALIASLIST(hDlg), ptr, hDlg, EDIT_ALIAS };
        if(MLDialogBoxParamWrap( MLGetHinst(), MAKEINTRESOURCE(IDD_ALIAS_EDIT), hDlg, AlEditDlgProc, (LPARAM)&aliasEditInfo ) == 2 )
        {
            // Add old alias to del list if alias name changes.
            LPCTSTR aliasNew = GetAliasName(ptr);
            LPCTSTR aliasOld = GetAliasName(ptrOld);

            if( StrCmp( aliasNew, aliasOld) )
                DPA_InsertPtr( aliasDelList, 0x7FFF, ptrOld );
            else
                DestroyAlias( ptrOld );
            
            InitAliasDialog( hDlg, ptr, FALSE ); 
            PropSheet_Changed(GetParent(hDlg),hDlg);
        }
    }

    return TRUE;
}


// AliasEdit - Called in response to the Add button pressed.
// hDlg - Handle to the property sheet 
BOOL WINAPI AliasAdd( HWND hDlg)
{
    CAlias * ptr = (CAlias *)CreateAlias( TEXT("") );

    if ( ptr )
    {
        ALIASEDITINFO aliasEditInfo = { GETALIASLIST(hDlg), ptr, hDlg, ADD_ALIAS };
        if(MLDialogBoxParamWrap( MLGetHinst(), MAKEINTRESOURCE(IDD_ALIAS_EDIT), hDlg, AlEditDlgProc, (LPARAM)&aliasEditInfo ) == 2)
        {
            InitAliasDialog( hDlg, ptr, FALSE ); 
            PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        DestroyAlias(ptr);
    }

    return TRUE;
}

// GetCurrentAlias - returns currently selected alis from the listview
// Returns - Selected alias
// hDlg - handle to the property sheet.
CAlias * GetCurrentAlias( HWND hDlg )
{
    int index = 0, iItem = 0;
    HDPA aliasList = GETALIASLIST( hDlg );
    HWND lb   = GetDlgItem( hDlg, IDC_ALIAS_LIST );

    if( ListView_GetSelectedCount(lb) == 1  && 
      ( (iItem = ListView_GetNextItem( lb, -1, LVNI_SELECTED ) ) != -1 ) )
    {
        TCHAR str[MAX_URL_STRING]; *str = TEXT('\0');
        ListView_GetItemText(lb, iItem, 0, str, MAX_URL_STRING );
        if(*str)
        {
            if( (index = FindAliasIndex(aliasList, str) ) != -1 )
            {
                CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasList, index );
                return ptr;
            }
        }
    }
    return NULL;
}

// InitAliasDialog - Initalizes the aliases dialog 
// Returns - TRUE if succeeded/FALSE if failed.
// hDlg - handle to the property sheet.
// fFullInit - Init listview columns/styles/etc
BOOL FAR PASCAL InitAliasDialog(HWND hDlg, CAlias * current, BOOL fFullInit)
{
    HRESULT  hr = E_FAIL;
    HKEY     hKey;
    HWND     listBox = GetDlgItem( hDlg, IDC_ALIAS_LIST );
    TCHAR *  displayString;

    // Allocate memory for a structure which will hold all the info
    // gathered from this page
    //
    LPALIASINFO pgti = (LPALIASINFO)GetWindowLong(hDlg, DWL_USER);
    pgti->fInternalChange = FALSE;

    SendMessage( listBox, LVM_DELETEALLITEMS, 0, 0L );

    // Initailize ListView
    if( fFullInit )
    {
        SendDlgItemMessage( hDlg, IDC_ALIAS_EDIT, EM_LIMITTEXT, 255, 0 );
        SendDlgItemMessage( hDlg, IDC_URL_EDIT, EM_LIMITTEXT, MAX_URL_STRING-1, 0 );
        // InitAliasListStyle(listBox, LVS_EX_CHECKBOXES|LVS_EX_FULLROWSELECT );
        InitAliasListStyle(listBox, LVS_EX_FULLROWSELECT );
        InitAliasListImageLists(listBox);     
        InitAliasListColumns(listBox);     
    }

    InitAliasListItems(listBox, GETALIASLIST(hDlg));     
        
    return TRUE;
}

// AliasApply - This function is called in response to  pressing the apply/ok
//              button on the property sheet dialog.
void AliasApply(HWND hDlg)
{
    HDPA aliasDelList = GETALIASDELLIST(hDlg);
    HDPA aliasList    = GETALIASLIST(hDlg);

    ASSERT(aliasList);

    if( aliasDelList )
    {
        int count = DPA_GetPtrCount( aliasDelList );
        
        for(int i=count-1; i>=0; i--)
        {
            CAlias * pAlias = (CAlias *)DPA_DeletePtr( aliasDelList, i );
            if(pAlias) 
            {
                pAlias->Delete();
                DestroyAlias(pAlias);
            }
        }
    }

    // Save the currently changed aliases
    SaveAliases( aliasList );

    // Refresh Global Alias List.
    RefreshGlobalAliasList();
}

// AliasDlgProc - Alias PropertySheet dialog Proc
// Returns BOOL
// hDlg - Handle to the property sheet window
// wParam, lParam - Word/Long param
BOOL CALLBACK AliasDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // get our tab info structure
    LPALIASINFO pgti;

    if (uMsg == WM_INITDIALOG)
    {
        // Allocate memory for a structure which will hold all the info
        // gathered from this page
        //
        LPALIASINFO pgti = (LPALIASINFO)LocalAlloc(LPTR, sizeof(tagALIASINFO));
        if (!pgti)
        {
            EndDialog(hDlg, 0);
            return FALSE;
        }

        pgti->hDlg = hDlg;

        pgti->fInternalChange = FALSE;
        SetWindowLong(hDlg, DWL_USER, (LPARAM)pgti);
        
        if((pgti->aliasList = DPA_Create(4)) != (HDPA)NULL ) 
        {
            pgti->aliasDelList = DPA_Create(4);
            LoadAliases( pgti->aliasList );

            // Initailize dialog 
            if( InitAliasDialog(hDlg, NULL, TRUE) ) 
            {
                return TRUE;
            }
            else
            {
                TCHAR szTitle[MAX_PATH];
                MLLoadString(IDS_ERROR_REGISTRY_TITLE, szTitle, sizeof(szTitle));
                MessageBox( GetParent(hDlg), TEXT("Cannot read aliases from registry."), szTitle, MB_OK ); 
                return FALSE;
            }
        }
        else
            return FALSE;
    }
    else
        pgti = (LPALIASINFO)GetWindowLong(hDlg, DWL_USER);

    if (!pgti)
        return FALSE;

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            switch (lpnm->code)
            {
                case NM_DBLCLK:
                    if(lpnm->idFrom == IDC_ALIAS_LIST)
                          AliasEdit( pgti->hDlg ); 
                    break;
                case PSN_QUERYCANCEL:
                case PSN_KILLACTIVE:
                case PSN_RESET:
                    SetWindowLong( hDlg, DWL_MSGRESULT, FALSE );
                    return TRUE;

                case PSN_APPLY:
                    AliasApply(hDlg);
                    break;
            }
            break;
        }

        case WM_COMMAND:
            { 
                if(HIWORD(wParam) == BN_CLICKED)
                {
                     switch (LOWORD(wParam))
                     { 
                         case IDC_ALIAS_ADD:
                            AliasAdd( pgti->hDlg ); break;
                         case IDC_ALIAS_EDIT:
                             AliasEdit( pgti->hDlg ); break;
                         case IDC_ALIAS_DEL:
                            AliasDel( pgti->hDlg ); break;
                     }
                }
            }
            break;

        case WM_DESTROY:
            // Delete registry information
            if( pgti->aliasList )
            {
                FreeAliases(pgti->aliasList);
                DPA_Destroy(pgti->aliasList);
            }

            if( pgti->aliasDelList )
            {
                FreeAliases(pgti->aliasDelList);
                DPA_Destroy(pgti->aliasDelList);
            }

            if (pgti)
                LocalFree(pgti);

            SetWindowLong(hDlg, DWL_USER, (LONG)NULL);  // make sure we don't re-enter
            break;

    }
    return FALSE;
}


BOOL CALLBACK AlEditDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAlias * pAlias;
    LPALIASEDITINFO pAliasInfo;

    if (uMsg == WM_INITDIALOG)
    {
        TCHAR achTemp[256];
        pAliasInfo = (LPALIASEDITINFO)lParam;
        pAlias = pAliasInfo->alias;
        
        if( !lParam ) 
        {
            EndDialog(hDlg, 0);
            return FALSE;
        }

        SendDlgItemMessage( hDlg, IDC_ALIAS_EDIT, WM_SETTEXT, 0,  (LPARAM)GetAliasName(pAlias));
        SendDlgItemMessage( hDlg, IDC_URL_EDIT, WM_SETTEXT, 0,  (LPARAM)GetAliasUrl(pAlias));

        if( pAliasInfo->dwFlags & EDIT_ALIAS )
        {
            // EnableWindow( GetDlgItem(hDlg, IDC_ALIAS_EDIT ), FALSE );
            MLLoadString(IDS_TITLE_ALIASEDIT, 
                achTemp, sizeof(achTemp)); 
            SendMessage( hDlg, WM_SETTEXT, 0, (LPARAM)achTemp); 
        }
        else
        {
            MLLoadString(IDS_TITLE_ALIASADD, 
                achTemp, sizeof(achTemp)); 
            SendMessage( hDlg, WM_SETTEXT, 0, (LPARAM)achTemp); 
        }

        SetWindowLong(hDlg, DWL_USER, (LPARAM)pAliasInfo);
        EnableWindow( GetDlgItem(hDlg, IDOK), FALSE );
    }
    else
        pAliasInfo = (LPALIASEDITINFO)GetWindowLong(hDlg, DWL_USER);

    if (!pAlias)
        return FALSE;

    switch (uMsg)
    {
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_ALIAS_EDIT:
                case IDC_URL_EDIT:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_UPDATE) 
                    {
                        EnableWindow( GetDlgItem(hDlg, IDOK), TRUE );
                    }
                    break;
                case IDOK:
                {
                    if( pAliasInfo )
                    {
                        TCHAR alias[MAX_URL_STRING];
                        TCHAR szurl[MAX_URL_STRING];
                        SendDlgItemMessage( hDlg, IDC_ALIAS_EDIT, WM_GETTEXT, MAX_URL_STRING, (LPARAM)alias );
                        SendDlgItemMessage( hDlg, IDC_URL_EDIT, WM_GETTEXT, MAX_URL_STRING, (LPARAM)szurl );

                        EatSpaces( alias );
                        
                        if( !*alias ) 
                        {
                            EndDialog( hDlg, 1 );
                            break;
                        }

                        if( pAliasInfo->dwFlags & ADD_ALIAS  && *alias)
                        {
                            if(AddAliasToList( pAliasInfo->aliasList, alias, szurl, hDlg ))
                                EndDialog( hDlg, 2);
                        }
                        else if( pAliasInfo->dwFlags & EDIT_ALIAS )
                        {
                            CAlias * ptr = pAliasInfo->alias;
                            if( StrCmp(GetAliasName(ptr), alias) )
                                if(FindAliasIndex( pAliasInfo->aliasList, alias ) != -1)
                                {
                                    MessageBox( hDlg, 
                                        TEXT("Alias with same name already exists"), 
                                        TEXT("Edit Alias"), 
                                        MB_OK|MB_ICONSTOP );
                                    break;
                                }
                            SetAliasInfo(ptr, alias, szurl);
                            EndDialog( hDlg, 2);
                        }
                        break;
                    }        
                    else
                        EndDialog( hDlg, 1 );
                    break;
                }
                case IDCANCEL:
                {
                    EndDialog( hDlg, 1 );
                }
            }
            break;

        case WM_DESTROY:
            SetWindowLong(hDlg, DWL_USER, (LONG)NULL);  
            break;

    }
    return FALSE;
}

#endif /* UNIX_FEATURE_ALIAS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\advanced.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

//
// ADVANCED.C - "Advanced" Property Sheet
//

// HISTORY:
//
// 6/22/96  t-gpease    created
// 5/27/97  t-ashlm     rewrote
//

#include "inetcplp.h"

#include <mluisupp.h>

//
// Private Calls and structures
//
TCHAR g_szUnderline[3][64];

// Reads a STRING and determines BOOL value: "yes" = TRUE | "no" = FALSE
BOOL RegGetBooleanString(HUSKEY huskey, LPTSTR RegValue, BOOL Value);

// Writes a STRING depending on the BOOL: TRUE = "yes" | FALSE = "no"
BOOL RegSetBooleanString(HUSKEY huskey, LPTSTR RegValue, BOOL Value);

// Reads a STRING of R,G,B values and returns a COLOREF.
COLORREF RegGetColorRefString( HUSKEY huskey, LPTSTR RegValue, COLORREF Value);

// Writes a STRING of R,G,B comma separated values.
COLORREF RegSetColorRefString( HUSKEY huskey, LPTSTR RegValue, COLORREF Value);

BOOL _AorW_GetFileNameFromBrowse(HWND hDlg,
                                 LPWSTR pszFilename,
                                 UINT cchFilename,
                                 LPCWSTR pszWorkingDir,
                                 LPCWSTR pszExt,
                                 LPCWSTR pszFilter,
                                 LPCWSTR pszTitle);

//
// Reg keys
//
#define REGSTR_PATH_ADVANCEDLIST REGSTR_PATH_IEXPLORER TEXT("\\AdvancedOptions")


typedef struct {
    HWND hDlg;              // handle of our dialog
    HWND hwndTree;          // handle to the treeview

    IRegTreeOptions *pTO;   // pointer to RegTreeOptions interface
    BOOL fChanged;
    BOOL fShowIEOnDesktop;
} ADVANCEDPAGE, *LPADVANCEDPAGE;


BOOL IsShowIEOnDesktopEnabled()
{
    HKEY hk;
    if (SUCCEEDED(SHRegGetCLSIDKey(CLSID_Internet, TEXT("ShellFolder"), TRUE, FALSE, &hk)))
    {
        DWORD dwValue = 0, cbSize = SIZEOF(dwValue);
        SHGetValueW(hk, NULL, TEXT("Attributes"), NULL, (BYTE *)&dwValue, &cbSize);
        RegCloseKey(hk);

        return (dwValue & SFGAO_NONENUMERATED) != SFGAO_NONENUMERATED;;
    }
    return TRUE;
}


#define IE_DESKTOP_NAMESPACE_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\Namespace\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}")

void ShowIEOnDesktop(BOOL fShow)
{
    switch (GetUIVersion())
    {
    case 3:
        //  win95 shell
        if (fShow)
        {
            TCHAR szTheInternet[MAX_PATH];

            int cch = MLLoadString(IDS_THE_INTERNET, szTheInternet, ARRAYSIZE(szTheInternet));
            SHSetValue(HKEY_LOCAL_MACHINE, IE_DESKTOP_NAMESPACE_KEY, NULL, REG_SZ, 
                       szTheInternet, (cch + 1) * sizeof(TCHAR));
        }
        else
        {
            SHDeleteKey(HKEY_LOCAL_MACHINE, IE_DESKTOP_NAMESPACE_KEY); 
        }
        break;

    case 4:
        //  IE4 integrated shell
        //  doesnt have peruser, so we need to just 
        //  delete it by marking it NONENUMERATED
        {
            HKEY hk;
            if (SUCCEEDED(SHRegGetCLSIDKey(CLSID_Internet, TEXT("ShellFolder"), FALSE, FALSE, &hk)))
            {
                DWORD dwValue = 0, cbSize = SIZEOF(dwValue);
                SHGetValue(hk, NULL, TEXT("Attributes"), NULL, (BYTE *)&dwValue, &cbSize);

                dwValue = (dwValue & ~SFGAO_NONENUMERATED) | (fShow ? 0 : SFGAO_NONENUMERATED);

                SHSetValueW(hk, NULL, TEXT("Attributes"), REG_DWORD, (BYTE *)&dwValue, SIZEOF(dwValue));
                RegCloseKey(hk);
            }
        }       
        break;

    default:
        //  do nothing since just changing the settings 
        //  in the right place sets up the PER-USER
        //  stuff correctly
        break;
    }
        
}

// AdvancedDlgInit()
//
// Initializes Advanced property sheet
//
// History:
//
// 6/13/96  t-gpease   created
// 5/27/96  t-ashlm    rewrote
//
BOOL AdvancedDlgInit(HWND hDlg)
{
    LPADVANCEDPAGE  pAdv;
    HTREEITEM htvi;
    HRESULT hr;

    pAdv = (LPADVANCEDPAGE)LocalAlloc(LPTR, sizeof(*pAdv));
    if (!pAdv)
    {
        EndDialog(hDlg, 0);
        return FALSE;   // no memory?
    }

    TraceMsg(TF_GENERAL, "\nInitializing Advanced Tab\n");

    pAdv->fShowIEOnDesktop = IsShowIEOnDesktopEnabled();

    InitCommonControls();

    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pAdv);

    // save dialog handle
    pAdv->hDlg = hDlg;
    pAdv->hwndTree = GetDlgItem( pAdv->hDlg, IDC_ADVANCEDTREE );

    CoInitialize(0);
    hr = CoCreateInstance(CLSID_CRegTreeOptions, NULL, CLSCTX_INPROC_SERVER,
                          IID_IRegTreeOptions, (LPVOID *)&(pAdv->pTO));


    if (SUCCEEDED(hr))
    {
#ifdef UNICODE  // InitTree takes Ansi string
        char szRegPath[REGSTR_MAX_VALUE_LENGTH];
        SHTCharToAnsi(REGSTR_PATH_ADVANCEDLIST, szRegPath, ARRAYSIZE(szRegPath));
        hr = pAdv->pTO->InitTree(pAdv->hwndTree, HKEY_LOCAL_MACHINE, szRegPath, NULL);
#else
        hr = pAdv->pTO->InitTree(pAdv->hwndTree, HKEY_LOCAL_MACHINE, REGSTR_PATH_ADVANCEDLIST, NULL);
#endif
    }

        // find the first root and make sure that it is visible
    htvi = TreeView_GetRoot( pAdv->hwndTree );
    TreeView_EnsureVisible( pAdv->hwndTree, htvi );

    if (g_restrict.fAdvanced)
    {
        EnableDlgItem(hDlg, IDC_RESTORE_DEFAULT, FALSE);
    }

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

#define REGKEY_DECLINED_IOD   TEXT("Software\\Microsoft\\Active Setup\\Declined Install On Demand IEv5.PP2")
#define REGKEY_DECLINED_COMPONENTS     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Declined Components IE5.pp2")
//
// AdvancedDlgOnCommand
//
// Handles Advanced property sheet window commands
//
// History:
// 6/13/96  t-gpease   created
// 5/27/97  t-ashlm    rewrote
//
void AdvancedDlgOnCommand(LPADVANCEDPAGE pAdv, UINT id, UINT nCmd)
{
    switch (id)
    {
        case IDC_RESTORE_DEFAULT:
            if (nCmd == BN_CLICKED)
            {
                // forget all Install On Demands that the user requested we
                // never ask again
                // Warning : if you ever have subkeys - these will fail on NT
                RegDeleteKey(HKEY_CURRENT_USER, REGKEY_DECLINED_IOD);
                // forget all code downloads that user said No to
                RegDeleteKey(HKEY_CURRENT_USER, REGKEY_DECLINED_COMPONENTS);

                pAdv->pTO->WalkTree(WALK_TREE_RESTORE);
                pAdv->fChanged = TRUE;
                ENABLEAPPLY(pAdv->hDlg);
            }
            break;
    }
}

//
// AdvancedDlgOnNotify()
//
// Handles Advanced property sheets WM_NOTIFY messages
//
// History:
//
// 6/13/96  t-gpease   created
//
void AdvancedDlgOnNotify(LPADVANCEDPAGE pAdv, LPNMHDR psn)
{
    SetWindowLongPtr( pAdv->hDlg, DWLP_MSGRESULT, (LONG_PTR)0); // handled

    switch (psn->code) {
        case TVN_KEYDOWN:
        {
            TV_KEYDOWN *pnm = (TV_KEYDOWN*)psn;
            if (pnm->wVKey == VK_SPACE)
            {
                if (!g_restrict.fAdvanced)
                {
                    pAdv->pTO->ToggleItem((HTREEITEM)SendMessage(pAdv->hwndTree, TVM_GETNEXTITEM, TVGN_CARET, NULL));
                    ENABLEAPPLY(pAdv->hDlg);
                    pAdv->fChanged = TRUE;

                    // Return TRUE so that the treeview swallows the space key.  Otherwise
                    // it tries to search for an element starting with a space and beeps.
                    SetWindowLongPtr(pAdv->hDlg, DWLP_MSGRESULT, TRUE);
                }
            }
            break;
        }

        case NM_CLICK:
        case NM_DBLCLK:
        {   // is this click in our tree?
            if ( psn->idFrom == IDC_ADVANCEDTREE )
            {   // yes...
                TV_HITTESTINFO ht;

                GetCursorPos( &ht.pt );                         // get where we were hit
                ScreenToClient( pAdv->hwndTree, &ht.pt );       // translate it to our window

                // retrieve the item hit
                if (!g_restrict.fAdvanced)
                {
                    pAdv->pTO->ToggleItem(TreeView_HitTest( pAdv->hwndTree, &ht));
                    ENABLEAPPLY(pAdv->hDlg);
                    pAdv->fChanged = TRUE;
                }
            }
        }
        break;

        case PSN_QUERYCANCEL:
        case PSN_KILLACTIVE:
        case PSN_RESET:
            SetWindowLongPtr(pAdv->hDlg, DWLP_MSGRESULT, FALSE);
            break;

        case PSN_APPLY:
        {
            if (pAdv->fChanged)
            {
                pAdv->pTO->WalkTree( WALK_TREE_SAVE );

                //  Now see if the user changed the "Show Internet Explorer on the Desktop"
                //  setting.
                if (pAdv->fShowIEOnDesktop != IsShowIEOnDesktopEnabled())
                {
                    pAdv->fShowIEOnDesktop = !pAdv->fShowIEOnDesktop;
                    
                    //  They did, so now see if it's integrated shell or not.
                    ShowIEOnDesktop(pAdv->fShowIEOnDesktop);

                    //  Now refresh the desktop
                    SHITEMID mkid = {0};
                    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST | SHCNF_FLUSHNOWAIT, &mkid, NULL);
                }

                InternetSetOption( NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
                UpdateAllWindows();
                pAdv->fChanged = FALSE;
            }
        }
        break;

    }
}

//
// AdvancedDlgProc
//
// SubDialogs:
//    Temporary Internet Files (cache)
//
// History:
//
// 6/12/96    t-gpease    created
// 5/27/97    t-ashlm     rewrote
//
INT_PTR CALLBACK AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPADVANCEDPAGE pAdv;

    if (uMsg == WM_INITDIALOG)
        return AdvancedDlgInit(hDlg);
    else
         pAdv = (LPADVANCEDPAGE)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pAdv)
        return FALSE;

    switch (uMsg)
    {

        case WM_NOTIFY:
            AdvancedDlgOnNotify(pAdv, (LPNMHDR)lParam);
            return TRUE;
            break;

        case WM_COMMAND:
            AdvancedDlgOnCommand(pAdv, LOWORD(wParam), HIWORD(wParam));
            return TRUE;
            break;

        case WM_HELP:                   // F1
        {
            LPHELPINFO lphelpinfo;
            lphelpinfo = (LPHELPINFO)lParam;

            if (lphelpinfo->iCtrlId != IDC_ADVANCEDTREE)
            {
                ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                             HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);

            }
            else
            {
                    HTREEITEM hItem;
                //Is this help invoked throught F1 key
                if (GetAsyncKeyState(VK_F1) < 0)
                {
                    // Yes. WE need to give help for the currently selected item
                    hItem = TreeView_GetSelection(pAdv->hwndTree);
                }
                else
                {
                    //No, We need to give help for the item at the cursor position
                    TV_HITTESTINFO ht;
                    ht.pt =((LPHELPINFO)lParam)->MousePos;
                    ScreenToClient(pAdv->hwndTree, &ht.pt); // Translate it to our window
                    hItem = TreeView_HitTest(pAdv->hwndTree, &ht);
                }

                if (FAILED(pAdv->pTO->ShowHelp(hItem, HELP_WM_HELP)))
                {
                    ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
                }
            }
            break;
        }

        case WM_CONTEXTMENU:        // right mouse click
        {
            TV_HITTESTINFO ht;

            GetCursorPos( &ht.pt );                         // get where we were hit
            ScreenToClient( pAdv->hwndTree, &ht.pt );       // translate it to our window

            // retrieve the item hit
            if (FAILED(pAdv->pTO->ShowHelp(TreeView_HitTest( pAdv->hwndTree, &ht),HELP_CONTEXTMENU)))
            {
                ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                            HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            }
            break;
        }
        case WM_DESTROY:
            // destroying this deliberately flushes its update (see WM_DESTROY in the UpdateWndProc);
#ifndef UNIX
            // Should only be destroyed in Process Detach.
            if (g_hwndUpdate)
                DestroyWindow(g_hwndUpdate);
#endif

            // free the tree
            if (pAdv->pTO)
            {
                pAdv->pTO->WalkTree( WALK_TREE_DELETE );
                pAdv->pTO->Release();
                pAdv->pTO=NULL;
            }

            // free local memory
            ASSERT(pAdv);
            LocalFree(pAdv);

            // make sure we don't re-enter
            SetWindowLongPtr( hDlg, DWLP_USER, (LONG)NULL );
            CoUninitialize();
            break;

    } // switch

    return FALSE; // not handled

} // AdvancedDlgProc


//////////////////////////////////////////////
//
// Buttons on bottom
//
////////////////////////////////////////////////////////////////////////////////////////////

typedef struct tagCOLORSINFO {
    HWND     hDlg;
    BOOL     fUseWindowsDefaults;
    COLORREF colorWindowText;
    COLORREF colorWindowBackground;
    COLORREF colorLinkViewed;
    COLORREF colorLinkNotViewed;
    COLORREF colorLinkHover;
    BOOL     fUseHoverColor;
} COLORSINFO, *LPCOLORSINFO;

VOID Color_DrawButton(HWND hDlg, LPDRAWITEMSTRUCT lpdis, COLORREF the_color )
{
    SIZE thin   = { GetSystemMetrics(SM_CXBORDER), GetSystemMetrics(SM_CYBORDER) };
    RECT rc     = lpdis->rcItem;
    HDC hdc     = lpdis->hDC;
    BOOL bFocus = ((lpdis->itemState & ODS_FOCUS) && !(lpdis->itemState & ODS_DISABLED));

    if (!thin.cx) thin.cx = 1;
    if (!thin.cy) thin.cy = 1;

    FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

    // Draw any caption
    TCHAR szCaption[80];
    int cxButton = 23*(rc.bottom - rc.top)/12;

    if (GetWindowText(lpdis->hwndItem, szCaption, ARRAYSIZE(szCaption)))
    {
        COLORREF crText;

        RECT rcText = rc;
        rcText.right -= cxButton;

        int nOldMode = SetBkMode(hdc, TRANSPARENT);

        if (lpdis->itemState & ODS_DISABLED)
        {
            // Draw disabled text using the embossed look
            crText = SetTextColor(hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
            RECT rcOffset = rcText;
            OffsetRect(&rcOffset, 1, 1);
            DrawText(hdc, szCaption, -1, &rcOffset, DT_VCENTER|DT_SINGLELINE);
            SetTextColor(hdc, GetSysColor(COLOR_BTNSHADOW));
        }
        else
        {
            crText = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        }
        DrawText(hdc, szCaption, -1, &rcText, DT_VCENTER|DT_SINGLELINE);
        SetTextColor(hdc, crText);
        SetBkMode(hdc, nOldMode);
    }
    
    // Draw the button portion
    rc.left = rc.right - cxButton;

    if (lpdis->itemState & ODS_SELECTED)
    {
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
        OffsetRect(&rc, 1, 1);
    }
    else
    {
        DrawEdge(hdc, &rc, EDGE_RAISED, BF_RECT | BF_ADJUST);
    }

    if (bFocus)
    {
        InflateRect(&rc, -thin.cx, -thin.cy);
        DrawFocusRect(hdc, &rc);
        InflateRect(&rc, thin.cx, thin.cy);
    }

    // color sample
    if ( !(lpdis->itemState & ODS_DISABLED) )
    {
        HBRUSH hBrush;

        InflateRect(&rc, -2 * thin.cx, -2 * thin.cy);
        FrameRect(hdc, &rc, GetSysColorBrush(COLOR_BTNTEXT));
        InflateRect(&rc, -thin.cx, -thin.cy);

        hBrush = CreateSolidBrush( the_color );
        FillRect(hdc, &rc, hBrush);
        DeleteObject(hBrush);
    }
}

COLORREF g_CustomColors[16] = { 0 };

// ChooseColorW is yet implemented in comdlg32.dll
BOOL UseColorPicker( HWND hWnd,  COLORREF *the_color, int extra_flags )
{
    // Make a local copy of the custom colors so they are not saved if the 
    // color picker dialog is cancelled
    COLORREF customColors[16];
    memcpy(customColors, g_CustomColors, sizeof(customColors));

    CHOOSECOLORA cc;

    cc.lStructSize      = sizeof(cc);
    cc.hwndOwner        = hWnd;
    cc.hInstance        = NULL;
    cc.rgbResult        = (DWORD) *the_color;
    cc.lpCustColors     = customColors;
    cc.Flags            = CC_RGBINIT | extra_flags;
    cc.lCustData        = (DWORD) NULL;
    cc.lpfnHook         = NULL;
    cc.lpTemplateName   = NULL;

    if (ChooseColorA(&cc))
    {
        *the_color = cc.rgbResult;
        memcpy(g_CustomColors, customColors, sizeof(g_CustomColors));

        InvalidateRect( hWnd, NULL, FALSE );
        return TRUE;
    }
    TraceMsg(TF_GENERAL, "\nChooseColor() return 0\n");

    return FALSE;
}


VOID AppearanceDimFields( HWND hDlg )
{
    // reverse the function of the check.... if CHECKED turn off the color
    // selectors.
    BOOL setting = !IsDlgButtonChecked( hDlg, IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX ) && !g_restrict.fColors;

    EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_TEXT), setting);
    EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_TEXT_LABEL), setting);
    EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND), setting);
    EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND_LABEL), setting);
    EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_HOVER),
                 IsDlgButtonChecked(hDlg, IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX) && !g_restrict.fLinks);
}

BOOL General_DrawItem(HWND hDlg, WPARAM wParam, LPARAM lParam, LPCOLORSINFO pci)
{
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_GENERAL_APPEARANCE_COLOR_TEXT:
            Color_DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam, pci->colorWindowText);
            return TRUE;

        case IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND:
            Color_DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam, pci->colorWindowBackground);
            return TRUE;

        case IDC_GENERAL_APPEARANCE_COLOR_LINKS:
            Color_DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam, pci->colorLinkNotViewed);
            return TRUE;

        case IDC_GENERAL_APPEARANCE_COLOR_VISITED_LINKS:
            Color_DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam, pci->colorLinkViewed);
            return TRUE;

        case IDC_GENERAL_APPEARANCE_COLOR_HOVER:
            Color_DrawButton(hDlg, (LPDRAWITEMSTRUCT)lParam, pci->colorLinkHover);
            return TRUE;
    }
    return FALSE;
}


INT_PTR CALLBACK ColorsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPCOLORSINFO pci = (LPCOLORSINFO) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            DWORD cb = sizeof(DWORD);
            HUSKEY huskey;

            pci = (LPCOLORSINFO)LocalAlloc(LPTR, sizeof(COLORSINFO));
            if (!pci)
            {
                EndDialog(hDlg, IDCANCEL);
                return FALSE;
            }

            // tell dialog where to get info
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pci);

            // save the handle to the page
            pci->hDlg = hDlg;

            // set default values
            pci->fUseWindowsDefaults       = TRUE;
            pci->colorWindowText           = RGB(0,0,0);
            pci->colorWindowBackground     = RGB(192,192,192);
            pci->colorLinkViewed           = RGB(0, 128, 128);
            pci->colorLinkNotViewed        = RGB(0, 0, 255);
            pci->colorLinkHover            = RGB(255, 0, 0);
            pci->fUseHoverColor            = TRUE;

            if (SHRegOpenUSKey(REGSTR_PATH_IEXPLORER,
                               KEY_READ|KEY_WRITE,    // samDesired
                               NULL,    // hUSKeyRelative
                               &huskey,
                               FALSE) == ERROR_SUCCESS)
            {
                HUSKEY huskeySub;

                if (SHRegOpenUSKey(REGSTR_KEY_MAIN,
                                   KEY_READ|KEY_WRITE,
                                   huskey,
                                   &huskeySub,
                                   FALSE) == ERROR_SUCCESS)
                {
                    pci->fUseWindowsDefaults       = RegGetBooleanString(huskeySub,
                        REGSTR_VAL_USEDLGCOLORS, pci->fUseWindowsDefaults);

                    SHRegCloseUSKey(huskeySub);
                }

                if (SHRegOpenUSKey(REGSTR_KEY_IE_SETTINGS,
                                   KEY_READ|KEY_WRITE,
                                   huskey,
                                   &huskeySub,
                                   FALSE) == ERROR_SUCCESS)
                {
                    pci->colorWindowText           = RegGetColorRefString(huskeySub,
                        REGSTR_VAL_TEXTCOLOR, pci->colorWindowText);

                    pci->colorWindowBackground     = RegGetColorRefString(huskeySub,
                        REGSTR_VAL_BACKGROUNDCOLOR, pci->colorWindowBackground);

                    pci->colorLinkViewed           = RegGetColorRefString(huskeySub,
                        REGSTR_VAL_ANCHORCOLORVISITED, pci->colorLinkViewed);

                    pci->colorLinkNotViewed        = RegGetColorRefString(huskeySub,
                        REGSTR_VAL_ANCHORCOLOR, pci->colorLinkNotViewed);

                    pci->colorLinkHover            = RegGetColorRefString(huskeySub,
                        REGSTR_VAL_ANCHORCOLORHOVER, pci->colorLinkHover);

                    pci->fUseHoverColor            = RegGetBooleanString(huskeySub,
                        REGSTR_VAL_USEHOVERCOLOR, pci->fUseHoverColor);

                    SHRegCloseUSKey(huskeySub);
                }
                SHRegCloseUSKey(huskey);
            }

            cb = sizeof(g_CustomColors);
            SHRegGetUSValue(REGSTR_PATH_IE_SETTINGS, REGSTR_VAL_IE_CUSTOMCOLORS, NULL, (LPBYTE)&g_CustomColors,
                            &cb, FALSE, NULL, NULL);

            //
            // select appropriate dropdown item here for underline links
            //

            CheckDlgButton(hDlg, IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX, pci->fUseWindowsDefaults);
            CheckDlgButton(hDlg, IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX, pci->fUseHoverColor);

            AppearanceDimFields(hDlg);

            if (g_restrict.fLinks)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_LINKS), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_VISITED_LINKS), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX), FALSE);
            }

            if (g_restrict.fColors)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_TEXT), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX), FALSE);
            }

            return TRUE;
        }

        case WM_DRAWITEM:
            return General_DrawItem(hDlg, wParam, lParam, pci);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    HUSKEY huskey;
                    if (SHRegOpenUSKey(REGSTR_PATH_IEXPLORER,
                                       KEY_WRITE,    // samDesired
                                       NULL,    // hUSKeyRelative
                                       &huskey,
                                       FALSE) == ERROR_SUCCESS)
                    {
                        HUSKEY huskeySub;

                        if (SHRegOpenUSKey(REGSTR_KEY_MAIN,
                                           KEY_WRITE,
                                           huskey,
                                           &huskeySub,
                                           FALSE) == ERROR_SUCCESS)
                        {
                            pci->fUseWindowsDefaults = RegSetBooleanString(huskeySub,
                                REGSTR_VAL_USEDLGCOLORS, pci->fUseWindowsDefaults);

                            SHRegCloseUSKey(huskeySub);
                        }

                        if (SHRegOpenUSKey(REGSTR_KEY_IE_SETTINGS,
                                           KEY_WRITE,
                                           huskey,
                                           &huskeySub,
                                           FALSE) == ERROR_SUCCESS)
                        {
                            pci->colorWindowText           = RegSetColorRefString(huskeySub,
                                REGSTR_VAL_TEXTCOLOR, pci->colorWindowText);

                            pci->colorWindowBackground     = RegSetColorRefString(huskeySub,
                                REGSTR_VAL_BACKGROUNDCOLOR, pci->colorWindowBackground);

                            pci->colorLinkViewed           = RegSetColorRefString(huskeySub,
                                REGSTR_VAL_ANCHORCOLORVISITED, pci->colorLinkViewed);

                            pci->colorLinkNotViewed        = RegSetColorRefString(huskeySub,
                                REGSTR_VAL_ANCHORCOLOR, pci->colorLinkNotViewed);

                            pci->colorLinkHover            = RegSetColorRefString(huskeySub,
                                REGSTR_VAL_ANCHORCOLORHOVER, pci->colorLinkHover);

                            pci->fUseHoverColor            = RegSetBooleanString(huskeySub,
                                REGSTR_VAL_USEHOVERCOLOR, pci->fUseHoverColor);

                            SHRegCloseUSKey(huskeySub);
                        }
                        SHRegCloseUSKey(huskey);
                    }


                    // custom colors
                    SHRegSetUSValue(REGSTR_PATH_IE_SETTINGS, REGSTR_VAL_IE_CUSTOMCOLORS, REGSTR_VAL_IE_CUSTOMCOLORS_TYPE, (LPBYTE)&g_CustomColors,
                                    sizeof(g_CustomColors), SHREGSET_FORCE_HKCU);

                    // refresh the browser
                    UpdateAllWindows();

                    EndDialog(hDlg, IDOK);
                    break;
                }

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        pci->fUseWindowsDefaults =
                            IsDlgButtonChecked(hDlg, IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX);
                        AppearanceDimFields(hDlg);
                    }
                    break;


                case IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        pci->fUseHoverColor =
                            IsDlgButtonChecked(hDlg, IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX);
                        AppearanceDimFields(hDlg);
                    }
                    break;

                case IDC_GENERAL_APPEARANCE_COLOR_TEXT:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        UseColorPicker( hDlg, &pci->colorWindowText, CC_SOLIDCOLOR);
                    }
                    break;

                case IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        UseColorPicker( hDlg, &pci->colorWindowBackground, CC_SOLIDCOLOR);
                    }
                    break;

                case IDC_GENERAL_APPEARANCE_COLOR_LINKS:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        UseColorPicker( hDlg, &pci->colorLinkNotViewed, CC_SOLIDCOLOR);
                    }
                    break;

                case IDC_GENERAL_APPEARANCE_COLOR_VISITED_LINKS:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        UseColorPicker( hDlg, &pci->colorLinkViewed, CC_SOLIDCOLOR);
                    }
                    break;

                case IDC_GENERAL_APPEARANCE_COLOR_HOVER:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        UseColorPicker( hDlg, &pci->colorLinkHover, CC_SOLIDCOLOR);
                    }
                    break;

                default:
                    return FALSE;
            }
            return TRUE;
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            ASSERT(pci);
            if (pci)
            {
                LocalFree(pci);
            }

            break;
    }
    return FALSE;
}

typedef struct tagACCESSIBILITYINFO
{
    HWND hDlg;
    BOOL fMyColors;
    BOOL fMyFontStyle;
    BOOL fMyFontSize;
    BOOL fMyStyleSheet;
    TCHAR szStyleSheetPath[MAX_PATH];
} ACCESSIBILITYINFO, *LPACCESSIBILITYINFO;

INT_PTR CALLBACK AccessibilityDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPACCESSIBILITYINFO pai = (LPACCESSIBILITYINFO) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            HKEY hkey;
            DWORD cb;

            pai = (LPACCESSIBILITYINFO)LocalAlloc(LPTR, sizeof(ACCESSIBILITYINFO));
            if (!pai)
            {
                EndDialog(hDlg, IDCANCEL);
                return FALSE;
            }

            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pai);
            pai->hDlg = hDlg;

            if (RegCreateKeyEx(HKEY_CURRENT_USER,
                               TEXT("Software\\Microsoft\\Internet Explorer\\Settings"),
                               0, NULL, 0,
                               KEY_READ,
                               NULL,
                               &hkey,
                               NULL) == ERROR_SUCCESS)
            {

                cb = sizeof(pai->fMyColors);
                RegQueryValueEx(hkey, TEXT("Always Use My Colors"), NULL, NULL, (LPBYTE)&(pai->fMyColors), &cb);

                cb = sizeof(pai->fMyFontStyle);
                RegQueryValueEx(hkey, TEXT("Always Use My Font Face"), NULL, NULL, (LPBYTE)&(pai->fMyFontStyle),&cb);

                cb = sizeof(pai->fMyFontSize);
                RegQueryValueEx(hkey, TEXT("Always Use My Font Size"), NULL, NULL, (LPBYTE)&(pai->fMyFontSize),&cb);

                RegCloseKey(hkey);

            }
            if (RegCreateKeyEx(HKEY_CURRENT_USER,
                             TEXT("Software\\Microsoft\\Internet Explorer\\Styles"),
                             0, NULL, 0,
                             KEY_READ,
                             NULL,
                             &hkey,
                             NULL) == ERROR_SUCCESS)
            {
                cb = sizeof(pai->fMyStyleSheet);
                RegQueryValueEx(hkey, TEXT("Use My Stylesheet"), NULL, NULL, (LPBYTE)&(pai->fMyStyleSheet),&cb);

                cb = sizeof(pai->szStyleSheetPath);
                RegQueryValueEx(hkey, TEXT("User Stylesheet"), NULL, NULL, (LPBYTE)&(pai->szStyleSheetPath), &cb);
                RegCloseKey(hkey);
            }

            CheckDlgButton(hDlg, IDC_CHECK_COLOR, pai->fMyColors);
            CheckDlgButton(hDlg, IDC_CHECK_FONT_STYLE, pai->fMyFontStyle);
            CheckDlgButton(hDlg, IDC_CHECK_FONT_SIZE, pai->fMyFontSize);
            CheckDlgButton(hDlg, IDC_CHECK_USE_MY_STYLESHEET, pai->fMyStyleSheet);
            SetDlgItemText(hDlg, IDC_EDIT_STYLESHEET, pai->szStyleSheetPath);
            SHAutoComplete(GetDlgItem(hDlg, IDC_EDIT_STYLESHEET), SHACF_DEFAULT);

            if (!pai->fMyStyleSheet || g_restrict.fAccessibility)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_STATIC_STYLESHEET), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_STYLESHEET), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_STYLESHEET_BROWSE), FALSE);
            }

            if (g_restrict.fAccessibility)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_COLOR), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_FONT_STYLE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_FONT_SIZE), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_USE_MY_STYLESHEET), FALSE);
            }
            break;
        }

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    HKEY hkey;

                    GetDlgItemText(hDlg, IDC_EDIT_STYLESHEET, pai->szStyleSheetPath, sizeof(pai->szStyleSheetPath));
                    if (!PathFileExists(pai->szStyleSheetPath) && IsDlgButtonChecked(hDlg, IDC_CHECK_USE_MY_STYLESHEET))
                    {
                        MLShellMessageBox(hDlg, MAKEINTRESOURCEW(IDS_FILENOTFOUND), NULL, MB_ICONHAND|MB_OK);
                        break;
                    }

                    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Settings"),0, KEY_WRITE, &hkey) == ERROR_SUCCESS)
                    {
                        DWORD cb;

                        cb = sizeof(pai->fMyColors);
                        pai->fMyColors = IsDlgButtonChecked(hDlg, IDC_CHECK_COLOR);
                        RegSetValueEx(hkey, TEXT("Always Use My Colors"), NULL, REG_DWORD, (LPBYTE)&(pai->fMyColors), cb);

                        cb = sizeof(pai->fMyFontStyle);
                        pai->fMyFontStyle = IsDlgButtonChecked(hDlg, IDC_CHECK_FONT_STYLE);
                        RegSetValueEx(hkey, TEXT("Always Use My Font Face"), NULL, REG_DWORD, (LPBYTE)&(pai->fMyFontStyle), cb);

                        cb = sizeof(pai->fMyFontSize);
                        pai->fMyFontSize = IsDlgButtonChecked(hDlg, IDC_CHECK_FONT_SIZE);
                        RegSetValueEx(hkey, TEXT("Always Use My Font Size"), NULL, REG_DWORD, (LPBYTE)&(pai->fMyFontSize),cb);

                        RegCloseKey(hkey);
                    }

                    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Styles"), 0, KEY_WRITE, &hkey) == ERROR_SUCCESS)
                    {
                        DWORD cb;

#ifndef UNIX
                        cb = sizeof(pai->szStyleSheetPath);
#else
                        // We don't know if this is exactly what we need to do, so we ifdef it.
                        cb = (_tcslen(pai->szStyleSheetPath) + 1) * sizeof(TCHAR);
#endif
                        RegSetValueEx(hkey, TEXT("User Stylesheet"), NULL, REG_SZ, (LPBYTE)&(pai->szStyleSheetPath),cb);

                        cb = sizeof(pai->fMyStyleSheet);
                        pai->fMyStyleSheet = IsDlgButtonChecked(hDlg, IDC_CHECK_USE_MY_STYLESHEET);
                        RegSetValueEx(hkey, TEXT("Use My Stylesheet"), NULL, REG_DWORD, (LPBYTE)&(pai->fMyStyleSheet),cb);

                        RegCloseKey(hkey);
                    }

                    UpdateAllWindows();     // refresh the browser

                    EndDialog(hDlg, IDOK);
                    break;
                }

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_CHECK_USE_MY_STYLESHEET:
                {
                    DWORD fChecked;

                    fChecked = IsDlgButtonChecked(hDlg, IDC_CHECK_USE_MY_STYLESHEET);
                    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_STYLESHEET), fChecked);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_STYLESHEET), fChecked);
                    EnableWindow(GetDlgItem(hDlg, IDC_STYLESHEET_BROWSE), fChecked);
                    EnableWindow(GetDlgItem(hDlg,IDOK), IsDlgButtonChecked(hDlg, IDC_CHECK_USE_MY_STYLESHEET) ? (GetWindowTextLength(GetDlgItem(hDlg, IDC_EDIT_STYLESHEET)) ? TRUE:FALSE) : TRUE);
                    break;
                }

                case IDC_EDIT_STYLESHEET:
                    switch(HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            EnableWindow(GetDlgItem(hDlg,IDOK), IsDlgButtonChecked(hDlg, IDC_CHECK_USE_MY_STYLESHEET) ? (GetWindowTextLength(GetDlgItem(hDlg, IDC_EDIT_STYLESHEET)) ? TRUE:FALSE) : TRUE);
                            break;
                    }
                    break;


                case IDC_STYLESHEET_BROWSE:
                {
                    TCHAR szFilenameBrowse[MAX_PATH];
                    int ret;
                    TCHAR szExt[MAX_PATH];
                    TCHAR szFilter[MAX_PATH];

                    szFilenameBrowse[0] = 0;
                    // why is IDS_STYLESHEET_EXT in shdoclc.rc?
                    MLLoadString(IDS_STYLESHEET_EXT, szExt, ARRAYSIZE(szExt));
                    int cchFilter = MLLoadShellLangString(IDS_STYLESHEET_FILTER, szFilter, ARRAYSIZE(szFilter)-1);

                    // Make sure we have a double null termination on the filter
                    szFilter[cchFilter + 1] = 0;

                    ret = _AorW_GetFileNameFromBrowse(hDlg, szFilenameBrowse, ARRAYSIZE(szFilenameBrowse), NULL, szExt,
                        szFilter, NULL);

                    if (ret > 0)
                    {
                        SetDlgItemText(hDlg, IDC_EDIT_STYLESHEET, szFilenameBrowse);
                    }
                    break;
                }

                default:
                    return FALSE;
            }
            return TRUE;
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            ASSERT(pai);
            if (pai)
            {
                LocalFree(pai);
            }
            break;
    }
    return FALSE;
}


#define TEMP_SMALL_BUF_SZ  256
inline BOOL IsNotResource(LPCWSTR pszItem)
{
    return (HIWORD(pszItem) != 0);
}

BOOL WINAPI _AorW_GetFileNameFromBrowse
(
    HWND hwnd,
    LPWSTR pszFilePath,     // IN OUT
    UINT cchFilePath,
    LPCWSTR pszWorkingDir,  //IN OPTIONAL
    LPCWSTR pszDefExt,      //IN OPTIONAL
    LPCWSTR pszFilters,     //IN OPTIONAL
    LPCWSTR pszTitle        //IN OPTIONAL
)
{
    BOOL bResult;

#ifndef UNIX
    // Determine which version of NT or Windows we're running on
    OSVERSIONINFOA osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA(&osvi);

    BOOL fRunningOnNT = (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId);

    if (fRunningOnNT)
    {
#endif
        bResult = GetFileNameFromBrowse(hwnd,
                                    pszFilePath,
                                    cchFilePath,
                                    pszWorkingDir,
                                    pszDefExt,
                                    pszFilters,
                                    pszTitle);
#ifndef UNIX
    }
    else
    {
        // Thunk to ansi
        CHAR szFilters[TEMP_SMALL_BUF_SZ*2];
        CHAR szPath[MAX_PATH];
        CHAR szDir[MAX_PATH];
        CHAR szExt[TEMP_SMALL_BUF_SZ];
        CHAR szTitle[TEMP_SMALL_BUF_SZ];
 
        // Always move pszFilePath stuff to szPath buffer. Should never be a resourceid.
        SHUnicodeToAnsi(pszFilePath, szPath, ARRAYSIZE(szPath));

        if (IsNotResource(pszWorkingDir)) 
        {
            SHUnicodeToAnsi(pszWorkingDir, szDir, ARRAYSIZE(szDir));
            pszWorkingDir = (LPCWSTR)szDir;
        }
        if (IsNotResource(pszDefExt))
        {
            SHUnicodeToAnsi(pszDefExt, szExt, ARRAYSIZE(szExt));
            pszDefExt = (LPCWSTR)szExt;
        }
        if (IsNotResource(pszFilters))
        {
            int nIndex = 1;

            // Find the double terminator
            while (pszFilters[nIndex] || pszFilters[nIndex-1])
                nIndex++;

            // nIndex+1 looks like bunk unless it goes past the terminator
            WideCharToMultiByte(CP_ACP, 0, (LPCTSTR)pszFilters, nIndex+1, szFilters, ARRAYSIZE(szFilters), NULL, NULL);
            pszFilters = (LPCWSTR)szFilters;
        }
        if (IsNotResource(pszTitle))
        {
            SHUnicodeToAnsi(pszTitle, szTitle, ARRAYSIZE(szTitle));
            pszTitle = (LPCWSTR)szTitle;
        }

        bResult = GetFileNameFromBrowse(hwnd, (LPWSTR)szPath, ARRAYSIZE(szPath), pszWorkingDir, pszDefExt, pszFilters, pszTitle);

        SHAnsiToUnicode(szPath, pszFilePath, cchFilePath);
    }
#endif

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow shdocvw to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//


#include "windows.h"       // Don't use precompiled header here
#include "commctrl.h"       // Don't use precompiled header here
#include "prsht.h"
#include "shlwapi.h"

PROPSHEETPAGE* Whistler_CreatePropSheetPageStruct(HINSTANCE hinst)
{
    PROPSHEETPAGE* ppsPage = LocalAlloc(LPTR, sizeof(PROPSHEETPAGE));
    if (ppsPage)
    {
        ppsPage->dwSize = IsOS(OS_WHISTLERORGREATER)? sizeof(PROPSHEETPAGE) : PROPSHEETPAGE_V2_SIZE;
        ppsPage->hInstance = hinst;
        ppsPage->dwFlags = PSP_DEFAULT;
    }

    return ppsPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\cachecpl.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************
//
//      CACHECPL.H - header file for cachecpl
//
//      HISTORY:
//      
//      4/6/98      v-sriran         Moved some definitions from cachecpl.cpp
//                                   to this file, so that it can be easier
//                                   to make unix specific changes to cachecpl.
//

#ifndef _CACHECPL_H_
#define _CACHECPL_H_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

// private structures for cachecpl
//
typedef struct {
    // hold our dialog handle
    HWND hDlg;

    // hold dialog item handles
    HWND hwndTrack;

    // data
    TCHAR szHistoryLocation[MAX_PATH+1];
    INT  iHistoryNumPlaces;
    UINT uiCacheQuota;
    UINT uiDiskSpaceTotal;
    WORD iCachePercent;
    TCHAR szCacheLocation[MAX_PATH+1];
    TCHAR szNewCacheLocation[MAX_PATH+1];
    INT  iCacheUpdFrequency;
    INT  iHistoryExpireDays;

    // something changed
    BOOL bChanged;
    BOOL bChangedLocation;

} TEMPDLG, *LPTEMPDLG;

#define CONTENT 0

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _CACHECPL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_
EXTERN_C PROPSHEETPAGE* Whistler_CreatePropSheetPageStruct(HINSTANCE hinst);

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\cachecpl.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

File Name:

     cachecpl.c

Module :

    inetcpl.cpl

Abstract:

    This file contains code to set cache config information from the internet
    control panel

Author:

    Shishir Pardikar

6/22/96 t-gpease    moved entire dailog to this file from "dialdlg.c"

Environment:

    User Mode - Win32

Revision History:

--*/

#include "inetcplp.h"
#include "cachecpl.h"

#include <mluisupp.h>
#include <winnls.h>

#ifdef unix
#define DIR_SEPARATOR_CHAR TEXT('/')
#else
#define DIR_SEPARATOR_CHAR TEXT('\\')
#endif /* unix */

#define CONSTANT_MEGABYTE   (1024*1024)

INT_PTR CALLBACK 
EmptyCacheDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK 
EmptyCacheCookiesDlgProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam);

#ifdef UNICODE
/* GetDiskInfo
    A nice way to get volume information
*/
BOOL GetDiskInfo(PTSTR pszPath, PDWORD pdwClusterSize, PDWORDLONG pdlAvail, 
PDWORDLONG pdlTotal)
{
    CHAR  szGDFSEXA[MAX_PATH];
    SHUnicodeToAnsi(pszPath, szGDFSEXA, ARRAYSIZE(szGDFSEXA));
    return GetDiskInfoA(szGDFSEXA, pdwClusterSize, pdlAvail, pdlTotal);
}
#else
#define GetDiskInfo     GetDiskInfoA
#endif

/* DispMessage
    A quick and easy way to display messages for the cachecpl
*/

INT DispMessage(HWND hWnd, UINT Msg, UINT Title, UINT Type)
{
    TCHAR szTitle[80];
    TCHAR szMessage[1024];
    
    // something went wrong with the registry
    // notify user
    MLLoadShellLangString(Msg, szMessage, ARRAYSIZE(szMessage));
    MLLoadShellLangString(Title, szTitle, ARRAYSIZE(szTitle));

    return MessageBox(hWnd, szMessage, szTitle, Type);
}

typedef HRESULT (*PFNSHGETFOLDERPATH)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath);

#undef SHGetFolderPath
#ifdef UNICODE
#define SHGETFOLDERPATH_STR "SHGetFolderPathW"
#else
#define SHGETFOLDERPATH_STR "SHGetFolderPathA"
#endif

HRESULT SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath)
{
    HMODULE hmodSHFolder = LoadLibrary(TEXT("shfolder.dll"));
    HRESULT hr = E_FAIL;
    
    if (hmodSHFolder) 
    {
        PFNSHGETFOLDERPATH pfn = (PFNSHGETFOLDERPATH)GetProcAddress(hmodSHFolder, SHGETFOLDERPATH_STR);
        if (pfn)
        {
            hr = pfn(hwnd, csidl, hToken, dwFlags, pszPath);
        }
        FreeLibrary(hmodSHFolder);
    }
    return hr;
}


// Cache maximum/minimum in MB
#define CACHE_SIZE_CAP 32000
#define CACHE_SIZE_MIN 1


DWORD UpdateCacheQuotaInfo(LPTEMPDLG pTmp, BOOL fUpdate)
{
    // The following probably needs to be fixed.
    DWORDLONG cKBLimit = pTmp->uiDiskSpaceTotal, cKBSpare = pTmp->uiCacheQuota;

    if (cKBLimit==0)
    {
        return GetLastError();
    }

    // What's happening in the following sequence:
    // We want to ensure that the cache size is
    // 1.   less than the drive's size (if larger, then reduce to 75% of drive's space
    // 2.   less than 32 GB

    // And adjust percentage accordingly.
    
    if (fUpdate)
    {
        ASSERT(pTmp->iCachePercent<=100);
        if (pTmp->iCachePercent==0)
        {
            cKBSpare = CACHE_SIZE_MIN;
        }
        else
        {
            cKBSpare = (cKBLimit * pTmp->iCachePercent)/ 100;
        }
        if (cKBSpare > cKBLimit)
        {
            pTmp->iCachePercent = 75;
            cKBSpare = (cKBLimit * pTmp->iCachePercent) / 100;
        }
        pTmp->uiCacheQuota = (DWORD)cKBSpare;
        SetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
    }

    if (cKBSpare > CACHE_SIZE_CAP)
    {
        if (fUpdate)
        {
            cKBSpare = pTmp->uiCacheQuota = CACHE_SIZE_CAP;
            SetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
        }
        fUpdate = FALSE;
    }
    else if (cKBSpare < CACHE_SIZE_MIN)
    {
        if (fUpdate)
        {
            cKBSpare = pTmp->uiCacheQuota = CACHE_SIZE_MIN;
            SetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
        }
        fUpdate = FALSE;
    } 
    else if (cKBSpare > cKBLimit)
    {
        if (fUpdate)
        {
            cKBSpare = pTmp->uiCacheQuota = (DWORD)cKBLimit;
            SetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
        }
        fUpdate = FALSE;
    }

    if (!fUpdate)
    {
        pTmp->iCachePercent = (WORD)((cKBSpare * 100 + (cKBLimit/2))/cKBLimit);
        if (pTmp->iCachePercent>100)
        {
            pTmp->iCachePercent = 100;
        }
        SendMessage( pTmp->hwndTrack, TBM_SETPOS, TRUE, pTmp->iCachePercent );
    }
    return ERROR_SUCCESS;
}

VOID AdjustCacheRange(LPTEMPDLG pTmp)
{
    UINT uiMax = 10;
    DWORDLONG dlTotal = 0;

    if (GetDiskInfo(pTmp->bChangedLocation ? pTmp->szNewCacheLocation : pTmp->szCacheLocation, NULL, NULL, &dlTotal))
    {
        dlTotal /= (DWORDLONG)CONSTANT_MEGABYTE;
        uiMax = (dlTotal < CACHE_SIZE_CAP) ? (UINT)dlTotal : CACHE_SIZE_CAP;
    }
    SendDlgItemMessage(pTmp->hDlg, IDC_ADVANCED_CACHE_SIZE_SPIN, UDM_SETRANGE, FALSE, MAKELPARAM(uiMax, CACHE_SIZE_MIN));
}

BOOL InvokeCachevu(HWND hDlg)
{
    TCHAR szCache[MAX_PATH];

    HRESULT hres = SHGetFolderPath(NULL, CSIDL_INTERNET_CACHE | CSIDL_FLAG_CREATE, NULL, 0, szCache);
    if (hres == S_OK)
    {
        DWORD dwAttrib = GetFileAttributes(szCache);

        TCHAR szIniFile[MAX_PATH];
        PathCombine(szIniFile, szCache, TEXT("desktop.ini"));

        if (GetFileAttributes(szIniFile) == -1)
        {
            DWORD dwAttrib = GetFileAttributes(szCache);
            dwAttrib &= ~FILE_ATTRIBUTE_HIDDEN;
            dwAttrib |=  FILE_ATTRIBUTE_SYSTEM;

            // make sure system, but not hidden
            SetFileAttributes(szCache, dwAttrib);

            WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("ConfirmFileOp"), TEXT("0"), szIniFile);
            WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("UICLSID"), TEXT("{7BD29E00-76C1-11CF-9DD0-00A0C9034933}"), szIniFile);
        }

        // All seems well, launch it.
        SHELLEXECUTEINFO ei = { sizeof(SHELLEXECUTEINFO), 0};
        ei.hwnd = hDlg;
        ei.lpFile = szCache;
        ei.nShow = SW_SHOWNORMAL;
        return ShellExecuteEx(&ei);
    }

    return FALSE;
}

// Following flag swiped from wininet
#define FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO    0x2

#define DISK_SPACE_MARGIN   4*1024*1024

// IsEnoughDriveSpace
// verifies that there will enough space for the current contents of the cache
// on the new destination

BOOL IsEnoughDriveSpace(DWORD dwClusterSize, DWORDLONG dlAvailable)
{
    // Adjust dlAvailable to leave some space free
    if ((DISK_SPACE_MARGIN/dwClusterSize) > dlAvailable)
    {
        return FALSE;
    }
    else
    {
        dlAvailable -= DISK_SPACE_MARGIN/dwClusterSize;
    };
    
    // Now, iterate through the cache to discover the actual size.
    INTERNET_CACHE_ENTRY_INFOA cei;
    DWORD dwSize = sizeof(cei);
    DWORDLONG dlClustersNeeded = 0;    
    BOOL fResult = FALSE;
    HANDLE hFind = FindFirstUrlCacheEntryExA(NULL, 
                                    FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO,
                                    NORMAL_CACHE_ENTRY,
                                    NULL,
                                    &cei, 
                                    &dwSize,
                                    NULL,
                                    NULL,
                                    NULL);

    if (hFind!=NULL)
    {
        do
        {
            ULARGE_INTEGER ulFileSize;
            ulFileSize.LowPart = cei.dwSizeLow;
            ulFileSize.HighPart = cei.dwSizeHigh;
            dlClustersNeeded += (ulFileSize.QuadPart / (DWORDLONG)dwClusterSize) + 1;
            fResult = FindNextUrlCacheEntryExA(hFind, &cei, &dwSize, NULL, NULL, NULL) && (dlClustersNeeded < dlAvailable);
        } 
        while (fResult);
        FindCloseUrlCache(hFind);

        if (GetLastError()==ERROR_NO_MORE_ITEMS)
        {
            fResult = dlClustersNeeded < dlAvailable;
        } 
    }
    else
    {
        fResult = TRUE;
    }
    return fResult;
}


//
// SaveTemporarySettings
//
// Save the Temporary Files Dialog (Cache) settings.
//
// History:
//
// 6/14/96  t-gpease  created
//
BOOL SaveTemporarySettings(LPTEMPDLG pTmp)
{
    if ((pTmp->uiCacheQuota<1) || (pTmp->uiCacheQuota>pTmp->uiDiskSpaceTotal))
    {
        TCHAR szError[1024], szTemp[100];
        
        MLLoadShellLangString(IDS_SIZE_FORMAT, szTemp, ARRAYSIZE(szTemp));
        wnsprintf(szError, ARRAYSIZE(szError), szTemp, pTmp->uiDiskSpaceTotal);
        MLLoadShellLangString(IDS_ERROR, szTemp, ARRAYSIZE(szTemp));
        MessageBox(pTmp->hDlg, szError, szTemp, MB_OK | MB_ICONEXCLAMATION);
        SetFocus(GetDlgItem(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT));
        return FALSE;
    }
    
    if (pTmp->bChanged)
    {
        // derive the syncmode for the radio buttons
        if (IsDlgButtonChecked(pTmp->hDlg, IDC_ADVANCED_CACHE_AUTOMATIC))
            
            pTmp->iCacheUpdFrequency = WININET_SYNC_MODE_AUTOMATIC;
        
        else if (IsDlgButtonChecked(pTmp->hDlg, IDC_ADVANCED_CACHE_NEVER))

            pTmp->iCacheUpdFrequency = WININET_SYNC_MODE_NEVER;

        else if (IsDlgButtonChecked(pTmp->hDlg, IDC_ADVANCED_CACHE_ALWAYS))

            pTmp->iCacheUpdFrequency = WININET_SYNC_MODE_ALWAYS;

        else {
            ASSERT(IsDlgButtonChecked(pTmp->hDlg, IDC_ADVANCED_CACHE_ONCEPERSESS));
            pTmp->iCacheUpdFrequency = WININET_SYNC_MODE_ONCE_PER_SESSION;
        }

        // notify IE
        INTERNET_CACHE_CONFIG_INFOA cci;
        cci.dwContainer = CONTENT;
        cci.dwQuota = pTmp->uiCacheQuota * 1024; // Make into KB
        cci.dwSyncMode = pTmp->iCacheUpdFrequency;

        ASSERT(cci.dwQuota);
        SetUrlCacheConfigInfoA(&cci, CACHE_CONFIG_SYNC_MODE_FC | CACHE_CONFIG_QUOTA_FC);
    }

    if (pTmp->bChangedLocation)
    {
        OSVERSIONINFOA VerInfo;
        VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        GetVersionExA(&VerInfo);

        if (g_hwndPropSheet)
        {
            PropSheet_Apply(g_hwndPropSheet);
        }
        
        BOOL fRunningOnNT = (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
        // Well, we're going to have to force a reboot now. Ciao. Confirm.
        if (IDYES==DispMessage(pTmp->hDlg, 
                               fRunningOnNT ? IDS_LOGOFF_WARNING : IDS_REBOOTING_WARNING, 
                               fRunningOnNT ? IDS_LOGOFF_TITLE : IDS_REBOOTING_TITLE, 
                               MB_YESNO | MB_ICONEXCLAMATION))
        {
            // fix registry entries and add RunOnce command
            // NOTE: a REBOOT must be done for changes to take effect
            //       (see SetCacheLocation() ).
            // On NT, we must adjust the token privileges
            BOOL fSuccess = TRUE;
            if (fRunningOnNT) 
            {
                HANDLE hToken;
                TOKEN_PRIVILEGES tkp;
                // get a token from this process
                if (fSuccess=OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
                {
                    // get the LUID for the shutdown privilege
                    LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);

                    tkp.PrivilegeCount = 1;
                    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                    //get the shutdown privilege for this proces
                    fSuccess = AdjustTokenPrivileges( hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0 );
                }
            }
            if (fSuccess)
            {
#ifdef UNICODE  //UpdateUrlCacheContentPath takes LPSTR
                char szNewPath[MAX_PATH];
                SHTCharToAnsi(pTmp->szNewCacheLocation, szNewPath, ARRAYSIZE(szNewPath));
                UpdateUrlCacheContentPath(szNewPath);
#else
                UpdateUrlCacheContentPath(pTmp->szNewCacheLocation);
#endif
                ExitWindowsEx((fRunningOnNT ? EWX_LOGOFF : EWX_REBOOT), 0);
            }
            else
            {
                DispMessage(pTmp->hDlg, IDS_ERROR_MOVE_MSG, IDS_ERROR_MOVE_TITLE, MB_OK | MB_ICONEXCLAMATION);
            }
        }
    }
    return TRUE;
} // SaveTemporarySettings()

//
// IsValidDirectory()
//
// Checks out the path for mistakes... like just machine names...
// SHBrowseForFolder should NOT just return a machine name... BUG is
// shell code.
//
BOOL IsValidDirectory(LPTSTR szDir)
{
    if (szDir)
    {
        if (!*szDir)
            return FALSE;   // it's empty... that's not good
        if (*szDir!= DIR_SEPARATOR_CHAR)
            return TRUE;    // not a machine path... then OK

        // move forward two chars ( the '\''\')
        ++szDir;
        ++szDir;

        while ((*szDir) && (*szDir!=DIR_SEPARATOR_CHAR))
            szDir++;

        if (*szDir==DIR_SEPARATOR_CHAR)
            return TRUE;    // found another '\' so we are happy.

        return FALSE; // machine name only... ERROR!
    }

    return FALSE;

} // IsValidDirecotry()

#define NUM_LEVELS      3   // random dir + cachefile + safety (installed containers)

DWORD g_ccBrandName = 0;

int CALLBACK MoveFolderCallBack(
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    if (uMsg==BFFM_SELCHANGED)
    {
        TCHAR szNewDest[1024];
        TCHAR szStatusText[256];
        UINT uErr = 0;
        LONG fValid = FALSE;
        
        if (SHGetPathFromIDList((LPCITEMIDLIST)lParam, szNewDest))
        {
            // Account for "Temporary Internet Files\Content.IE?\randmdir.ext" + NUM_LEVELS*10
            DWORD ccAvail = MAX_PATH - g_ccBrandName -1 - ARRAYSIZE("CONTENT.IE?\\") - (NUM_LEVELS*10);
            if ((DWORD)lstrlen(szNewDest)>ccAvail) // Win95 limit on how long paths can be
            {
                uErr = IDS_ERROR_ARCHITECTURE;
            }
            else if (StrStrI(szNewDest, TEXT("Content.IE")))
            {
                uErr = IDS_ERROR_WRONG_PLACE;
            }
            else if (!IsValidDirectory(szNewDest))
            {
                uErr = IDS_ERROR_INVALID_PATH_MSG;
            } 
            else if (GetFileAttributes(szNewDest) & FILE_ATTRIBUTE_READONLY)
            {
                uErr = IDS_ERROR_STRANGENESS;
            }
            else
            {
#ifdef UNICODE
                CHAR szAnsiPath[MAX_PATH];
                BOOL fProblems;
                WideCharToMultiByte(CP_ACP, NULL, szNewDest, -1, szAnsiPath, ARRAYSIZE(szAnsiPath),
                                    NULL, &fProblems);
                if (fProblems)
                {
                    uErr = IDS_ERROR_INVALID_PATH;
                }
                else
#endif
                {    
                TCHAR szSystemPath[MAX_PATH+1];

                GetSystemDirectory(szSystemPath, MAX_PATH);
                if (StrStrI(szNewDest, szSystemPath))
                {
                    uErr = IDC_ERROR_USING_SYSTEM_DIR;
                }
                else
                {
                    fValid = TRUE;
                }
                }
            }
        }
        else
        {
            uErr = IDS_ERROR_STRANGENESS;        
        }
        
        if (uErr)
        {
            MLLoadShellLangString(uErr, szStatusText, ARRAYSIZE(szStatusText));
        }
        else
        {
            szStatusText[0] = 0;
        }

        SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)fValid);
        SendMessage(hwnd, BFFM_SETSTATUSTEXT, 0, (LPARAM)szStatusText);
    }

    return 0;
}


//
// MoveFolder()
//
// Handles the moving of the Temporary Files (Cache) Folder to
// another location. It checks for the existence of the new folder.
// It warns the user that a REBOOT is necessary before changes
// are made.
//
// History:
//
// 6/18/96  t-gpease    created.
//
void MoveFolder(LPTEMPDLG pTmp)
{
    TCHAR szTemp [1024];
    TCHAR szWindowsPath [MAX_PATH+1];
    BROWSEINFO biToFolder;

    biToFolder.hwndOwner = pTmp->hDlg;
    biToFolder.pidlRoot = NULL;                 // start on the Desktop
    biToFolder.pszDisplayName = szWindowsPath;  // not used, just making it happy...

    TCHAR szBrandName[MAX_PATH];
    MLLoadString(IDS_BRAND_NAME, szBrandName, ARRAYSIZE(szBrandName));
    g_ccBrandName = lstrlen(szBrandName);
    
    // load the title of the dialog box
    MLLoadShellLangString(IDS_SELECT_CACHE, szTemp, ARRAYSIZE(szTemp));
    biToFolder.lpszTitle = szTemp;

    biToFolder.ulFlags = BIF_RETURNONLYFSDIRS | BIF_STATUSTEXT;  // folders... nothing else
    biToFolder.lpfn = MoveFolderCallBack; // nothing special

    while (1)
    {
        // start shell dialog
        LPITEMIDLIST pidl = SHBrowseForFolder(&biToFolder);
        if (pidl)   // if everything went OK
        {
            DWORD dwClusterSize;
            DWORDLONG dlAvailable;
            DWORD dwError;

            // get the choice the user selected
            SHGetPathFromIDList(pidl, pTmp->szNewCacheLocation);
            SHFree(pidl);

            // Resolve local device to UNC if possible
            if ((GetDriveType(pTmp->szNewCacheLocation)==DRIVE_REMOTE) && (pTmp->szNewCacheLocation[0]!=DIR_SEPARATOR_CHAR))
            {
                TCHAR szPath[MAX_PATH];
                DWORD dwLen = ARRAYSIZE(szPath);

                pTmp->szNewCacheLocation[2] = '\0';

                dwError = WNetGetConnection(pTmp->szNewCacheLocation, szPath, &dwLen);
                if (dwError!=ERROR_SUCCESS)
                {
                    DispMessage(pTmp->hDlg, IDS_ERROR_CANT_CONNECT, IDS_ERROR_MOVE_TITLE, MB_OK | MB_ICONEXCLAMATION);
                    continue;
                }
                memcpy(pTmp->szNewCacheLocation, szPath, dwLen+1);
            }
            
            if (!GetDiskInfo(pTmp->szNewCacheLocation, &dwClusterSize, &dlAvailable, NULL))
            {
                DispMessage(pTmp->hDlg, IDS_ERROR_CANT_CONNECT, IDS_ERROR_MOVE_TITLE, MB_OK | MB_ICONEXCLAMATION);
                continue;
            }

            if (((*pTmp->szNewCacheLocation==*pTmp->szCacheLocation) && (pTmp->szNewCacheLocation[0]!=DIR_SEPARATOR_CHAR))
                ||
                (IsEnoughDriveSpace(dwClusterSize, dlAvailable)
                &&
                (GetLastError()==ERROR_NO_MORE_ITEMS)))
            {
                pTmp->bChangedLocation = TRUE;
            }
            else
            {
                DispMessage(pTmp->hDlg, IDS_ERROR_CANT_MOVE_TIF, IDS_ERROR_MOVE_TITLE, MB_OK | MB_ICONEXCLAMATION);
                continue;
            }
        }
        break;
    }

    if (pTmp->bChangedLocation)
    {
        DWORDLONG cbTotal;

        pTmp->uiDiskSpaceTotal = 0;
        if (GetDiskInfo(pTmp->szNewCacheLocation, NULL, NULL, &cbTotal))
        {
            pTmp->uiDiskSpaceTotal = (UINT)(cbTotal / (DWORDLONG)CONSTANT_MEGABYTE);
        }

        DWORD ccPath = lstrlen(pTmp->szNewCacheLocation);
        if (pTmp->szNewCacheLocation[ccPath-1]!=DIR_SEPARATOR_CHAR)
        {
            pTmp->szNewCacheLocation[ccPath] = DIR_SEPARATOR_CHAR;
            ccPath++;
        }
        memcpy(pTmp->szNewCacheLocation + ccPath, szBrandName, (g_ccBrandName+1)*sizeof(TCHAR));

        if (pTmp->uiCacheQuota > pTmp->uiDiskSpaceTotal)
        {
            pTmp->uiCacheQuota = pTmp->uiDiskSpaceTotal;
            SetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
        }

        SetDlgItemText( pTmp->hDlg, IDC_ADVANCED_CACHE_LOCATION, pTmp->szNewCacheLocation);

        // set dialog text
        MLLoadString(IDS_STATUS_FOLDER_NEW, szTemp, ARRAYSIZE(szTemp));
        SetDlgItemText( pTmp->hDlg, IDC_ADVANCED_CACHE_STATUS, szTemp);

        UpdateCacheQuotaInfo(pTmp, FALSE);
        AdjustCacheRange(pTmp);
    }
} // MoveFolder()


//
// TemporaryInit()
//
// Handles the initialization of Temporary Files Dialog (Cache)
//
// History:
//
// 6/13/96  t-gpease  created
//
BOOL TemporaryInit(HWND hDlg)
{
    LPTEMPDLG pTmp;
    BOOL bAlways, bOnce, bNever, bAuto;

    pTmp = (LPTEMPDLG)LocalAlloc(LPTR, sizeof(*pTmp));
    if (!pTmp)
    {
        EndDialog(hDlg, 0);
        return FALSE;   // no memory?
    }

    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pTmp);

    // get dialog item handles
    pTmp->hDlg = hDlg;
    pTmp->hwndTrack = GetDlgItem( hDlg, IDC_ADVANCED_CACHE_PERCENT );

    INTERNET_CACHE_CONFIG_INFOA icci;
    icci.dwContainer = CONTENT;
    if (GetUrlCacheConfigInfoA(&icci, NULL, CACHE_CONFIG_QUOTA_FC 
                                    | CACHE_CONFIG_DISK_CACHE_PATHS_FC
                                    | CACHE_CONFIG_SYNC_MODE_FC))
    {
        SHAnsiToTChar(icci.CachePath, pTmp->szCacheLocation, ARRAYSIZE(pTmp->szCacheLocation));
        pTmp->iCachePercent = 0;
        pTmp->uiCacheQuota = icci.dwQuota / 1024;
        pTmp->iCacheUpdFrequency = (WORD)icci.dwSyncMode;
    }
    else
    {
        // GUCCIEx CAN NEVER FAIL.
        ASSERT(FALSE);
        pTmp->iCacheUpdFrequency = WININET_SYNC_MODE_DEFAULT;
        pTmp->iCachePercent = 3;  // YUCK, magic number.
        pTmp->uiCacheQuota = 0;
    }
    SetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
//    SendDlgItemMessage(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
    SendDlgItemMessage(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, EM_SETLIMITTEXT, 6, 0);

    // update cache fields
    SendMessage( pTmp->hwndTrack, TBM_SETTICFREQ, 5, 0 );
    SendMessage( pTmp->hwndTrack, TBM_SETRANGE, FALSE, MAKELONG(0, 100) );
    SendMessage( pTmp->hwndTrack, TBM_SETPAGESIZE, 0, 5 );

    DWORDLONG cbTotal;
    pTmp->uiDiskSpaceTotal = 0;
    if (GetDiskInfo(pTmp->szCacheLocation, NULL, NULL, &cbTotal))
    {
        pTmp->uiDiskSpaceTotal = (UINT)(cbTotal / (DWORDLONG)CONSTANT_MEGABYTE);
    }
    UpdateCacheQuotaInfo(pTmp, FALSE);
    AdjustCacheRange(pTmp);

    // set the rest of the dialog's items
    TCHAR szBuf[MAX_PATH];

    // Is the following line necessary? 
    ExpandEnvironmentStrings(pTmp->szCacheLocation,szBuf, ARRAYSIZE(szBuf));

    // NOTE NOTE NOTE The following code might have to be altered if we start using
    // shfolder.dll to gather the location of the cache
    // pszEnd = szBuf + 3 because UNCs are "\\x*" and local drives are "C:\*"

    // Move to the end of the string, before the traiiling slash. (This is how wininet works.)
    PTSTR pszLast = szBuf + lstrlen(szBuf) - 2;
    while ((pszLast>=szBuf) && (*pszLast!=DIR_SEPARATOR_CHAR))
    {
        pszLast--;
    }
    // The terminator should always be placed between the \Temporary Internet Files and the
    // \Content.IE?. This must always be present.
    *(pszLast+1) = TEXT('\0');
    
    SetDlgItemText( hDlg, IDC_ADVANCED_CACHE_LOCATION, szBuf );

    MLLoadString(IDS_STATUS_FOLDER_CURRENT, szBuf, ARRAYSIZE(szBuf));
    SetDlgItemText( hDlg, IDC_ADVANCED_CACHE_STATUS, szBuf );
    
    // activate the correct radio button
    bAlways = bOnce = bNever = bAuto = FALSE;
    if (pTmp->iCacheUpdFrequency == WININET_SYNC_MODE_AUTOMATIC)
        bAuto = TRUE;
    else if (pTmp->iCacheUpdFrequency == WININET_SYNC_MODE_NEVER)
        bNever = TRUE;
    else if (pTmp->iCacheUpdFrequency == WININET_SYNC_MODE_ALWAYS)
        bAlways = TRUE;
    else
        bOnce = TRUE;   // if something got messed up... reset to Once Per Session

    CheckDlgButton(hDlg, IDC_ADVANCED_CACHE_ALWAYS,      bAlways);
    CheckDlgButton(hDlg, IDC_ADVANCED_CACHE_ONCEPERSESS, bOnce);
    CheckDlgButton(hDlg, IDC_ADVANCED_CACHE_AUTOMATIC,   bAuto);
    CheckDlgButton(hDlg, IDC_ADVANCED_CACHE_NEVER,       bNever);

    // nothing has chagned yet...
    pTmp->bChanged = pTmp->bChangedLocation = FALSE;

    if( g_restrict.fCache )
    {
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_ALWAYS), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_ONCEPERSESS), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_AUTOMATIC), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_NEVER), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_PERCENT), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_PERCENT_ACC), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_SIZE_SPIN), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_MOVE_CACHE_LOCATION), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_EMPTY), FALSE );
    }

    return TRUE;    // worked!
}


//
// TemporaryOnCommand()
//
// Handles Temporary Files dialogs WM_COMMAND messages
//
// History:
//
// 6/13/96  t-gpease   created
//
void TemporaryOnCommand(LPTEMPDLG pTmp, UINT id, UINT nCmd)
{
    switch (id) {
        case IDC_ADVANCED_CACHE_TEXT_PERCENT:
        case IDC_ADVANCED_CACHE_SIZE_SPIN:
            if (pTmp && nCmd == EN_CHANGE)
            {
                UINT uiVal;
                BOOL fSuccess;
                uiVal = GetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, &fSuccess, FALSE);
                if (fSuccess)
                {
                    pTmp->uiCacheQuota = uiVal;
                    UpdateCacheQuotaInfo(pTmp, FALSE);
                    pTmp->bChanged = TRUE;
                }
            }
            break;

        case IDC_ADVANCED_CACHE_ALWAYS:
        case IDC_ADVANCED_CACHE_ONCEPERSESS:
        case IDC_ADVANCED_CACHE_AUTOMATIC:
        case IDC_ADVANCED_CACHE_NEVER:
            pTmp->bChanged = TRUE;
            break;

        case IDOK:
            // save it
            if (!SaveTemporarySettings(pTmp))
            {
                break;
            }
            // Fall through

        case IDCANCEL:
            EndDialog(pTmp->hDlg, id);
            break; // IDCANCEL

        case IDC_ADVANCED_CACHE_BROWSE:
            InvokeCachevu(pTmp->hDlg);
            break;

        case IDC_ADVANCED_MOVE_CACHE_LOCATION:
            MoveFolder(pTmp);
            break; // IDC_ADVANCED_MOVE_CACHE_LOCATION

        case IDC_ADVANCED_DOWNLOADED_CONTROLS:
        {
            TCHAR szPath[MAX_PATH];
#ifdef UNIX
            TCHAR szExpPath[MAX_PATH];
#endif
            DWORD cb=SIZEOF(szPath);

            if (SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                           TEXT("ActiveXCache"), NULL, szPath, &cb) == ERROR_SUCCESS)
            {
                SHELLEXECUTEINFO ei;
#ifdef UNIX
                int cbExp = ExpandEnvironmentStrings(szPath,szExpPath,MAX_PATH);
#endif

                ei.cbSize       = sizeof(SHELLEXECUTEINFO);
                ei.hwnd         = pTmp->hDlg;
                ei.lpVerb       = NULL;
#ifndef UNIX
                ei.lpFile        = szPath;
#else
                if( cbExp > 0 && cbExp < MAX_PATH )
                    ei.lpFile = szExpPath;
                else
                    ei.lpFile = szPath;
#endif
                ei.lpParameters    = NULL;
                ei.lpDirectory    = NULL;
                ei.nShow        = SW_SHOWNORMAL;
                ei.fMask        = 0;
                ShellExecuteEx(&ei);
            }
            break;
        }

    } // switch

} // TemporaryOnCommand()

//
// TemporaryDlgProc
//
// Take care of "Temporary Files" (Cache)
//
// History:
//
// ??/??/??   God      created
// 6/13/96  t-gpease   cleaned up code, separated functions, and
//                     changed it into a Dialog (was property
//                     sheet).
//
INT_PTR CALLBACK TemporaryDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, 
                                  LPARAM lParam)
{
    LPTEMPDLG pTmp = (LPTEMPDLG) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {

    case WM_INITDIALOG:
        return TemporaryInit(hDlg);

    case WM_HSCROLL:
        pTmp->iCachePercent = (WORD)SendMessage( pTmp->hwndTrack, TBM_GETPOS, 0, 0 );
        UpdateCacheQuotaInfo(pTmp, TRUE);
        pTmp->bChanged = TRUE;
        return TRUE;

    case WM_COMMAND:
        TemporaryOnCommand(pTmp, LOWORD(wParam), HIWORD(wParam));
        return TRUE;

    case WM_HELP:                   // F1
        ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                    HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
    break;

    case WM_CONTEXTMENU:        // right mouse click
        ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                    HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
    break;

    case WM_DESTROY:
        ASSERT(pTmp);
        LocalFree(pTmp);
        break;

   }
    return FALSE;
}

INT_PTR CALLBACK EmptyCacheDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                   LPARAM lParam)
{
    switch (uMsg) {
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;
        case IDOK:
#ifndef UNIX
            if (Button_GetCheck(GetDlgItem(hDlg, IDC_DELETE_SUB)))
                EndDialog(hDlg, 3);
            else
                EndDialog(hDlg, 1);
#else
            // On Unix we alway return from this dialog with delete channel content
            // option set, though we have removed this option from the UI.
            EndDialog(hDlg, 3);
#endif
            break;
        }
        return TRUE;
   }
    return FALSE;
}

INT_PTR CALLBACK EmptyCacheCookiesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                    LPARAM lParam)
{
    switch (uMsg) {
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;
        case IDOK:
            EndDialog(hDlg, 1);
            break;
        }
        return TRUE;
   }
    return FALSE;
}

BOOL DeleteCacheCookies()
{
    BOOL bRetval = TRUE;
    DWORD dwEntrySize, dwLastEntrySize;
    LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntry;
    
    HANDLE hCacheDir = NULL;
    dwEntrySize = dwLastEntrySize = MAX_CACHE_ENTRY_INFO_SIZE;
    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) new BYTE[dwEntrySize];
    if( lpCacheEntry == NULL)
    {
        bRetval = FALSE;
        goto Exit;
    }
    lpCacheEntry->dwStructSize = dwEntrySize;

Again:
    if (!(hCacheDir = FindFirstUrlCacheEntryA("cookie:",lpCacheEntry,&dwEntrySize)))
    {
        delete [] lpCacheEntry;
        switch(GetLastError())
        {
            case ERROR_NO_MORE_ITEMS:
                goto Exit;
            case ERROR_INSUFFICIENT_BUFFER:
                lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                new BYTE[dwEntrySize];
                if( lpCacheEntry == NULL)
                {
                    bRetval = FALSE;
                    goto Exit;
                }
                lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                goto Again;
            default:
                bRetval = FALSE;
                goto Exit;
        }
    }

    do 
    {
        if (lpCacheEntry->CacheEntryType & COOKIE_CACHE_ENTRY)
            DeleteUrlCacheEntryA(lpCacheEntry->lpszSourceUrlName);
            
        dwEntrySize = dwLastEntrySize;
Retry:
        if (!FindNextUrlCacheEntryA(hCacheDir,lpCacheEntry, &dwEntrySize))
        {
            delete [] lpCacheEntry;
            switch(GetLastError())
            {
                case ERROR_NO_MORE_ITEMS:
                    goto Exit;
                case ERROR_INSUFFICIENT_BUFFER:
                    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                    new BYTE[dwEntrySize];
                    if( lpCacheEntry == NULL)
                    {
                        bRetval = FALSE;
                        goto Exit;
                    }
                    lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                    goto Retry;
                default:
                    bRetval = FALSE;
                    goto Exit;
            }
        }
    }
    while (TRUE);

Exit:
    if (hCacheDir)
        FindCloseUrlCache(hCacheDir);
    return bRetval;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\apithk.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETNAME      = apithk
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\apithk.c

INCLUDES        = $(INCLUDES);$(INETCORE_INC_PATH);$(DS_INC_PATH);


# We don't use a precompiled header until there are enough files to
# merit it.
#PRECOMPILED_INCLUDE = ..\inetcplp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\clsutil.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CLSUTIL.C - some small, useful C++ classes to wrap memory allocation,
//              registry access, etc.
//

//  HISTORY:
//  
//  12/07/94    jeremys        Borrowed from WNET common library
//

#include "inetcplp.h"
#define DECL_CRTFREE
#include <crtfree.h>

BOOL BUFFER::Alloc( UINT cbBuffer )
{
    _lpBuffer = (LPTSTR)::GlobalAlloc(GPTR,cbBuffer);
    if (_lpBuffer != NULL) {
        _cb = cbBuffer;
        return TRUE;
    }
    return FALSE;
}

BOOL BUFFER::Realloc( UINT cbNew )
{
    LPVOID lpNew = ::GlobalReAlloc((HGLOBAL)_lpBuffer, cbNew,
        GMEM_MOVEABLE | GMEM_ZEROINIT);
    if (lpNew == NULL)
        return FALSE;

    _lpBuffer = (LPTSTR)lpNew;
    _cb = cbNew;
    return TRUE;
}

BUFFER::BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
    _lpBuffer( NULL )
{
    if (cbInitial)
        Alloc( cbInitial );
}

BUFFER::~BUFFER()
{
    if (_lpBuffer != NULL) {
        GlobalFree((HGLOBAL) _lpBuffer);
        _lpBuffer = NULL;
    }
}

BOOL BUFFER::Resize( UINT cbNew )
{
    BOOL fSuccess;

    if (QuerySize() == 0)
        fSuccess = Alloc( cbNew );
    else {
        fSuccess = Realloc( cbNew );
    }
    if (fSuccess)
        _cb = cbNew;
    return fSuccess;
}

RegEntry::RegEntry(const TCHAR *pszSubKey, HKEY hkey, REGSAM regsam)
{
    _error = RegCreateKeyEx(hkey, pszSubKey, 0, NULL, 0, regsam, NULL, &_hkey, NULL);
    if (_error) {
        bhkeyValid = FALSE;
    }
    else {
        bhkeyValid = TRUE;
    }
}

RegEntry::~RegEntry()
{ 
    if (bhkeyValid) {
        RegCloseKey(_hkey); 
    }
}

long RegEntry::SetValue(const TCHAR *pszValue, const TCHAR *string)
{
    if (bhkeyValid) {
        _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
                    (LPBYTE)string, (lstrlen(string)+1)*sizeof(TCHAR));
    }
    return _error;
}

long RegEntry::SetValue(const TCHAR *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
        _error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
                    (LPBYTE)&dwNumber, sizeof(dwNumber));
    }
    return _error;
}

long RegEntry::DeleteValue(const TCHAR *pszValue)
{
    if (bhkeyValid) {
        _error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
    }
    return _error;
}


TCHAR *RegEntry::GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length)
{
    DWORD     dwType;   
    
    if (bhkeyValid) {
        _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
                    &length);
    }
    if (_error) {
        *string = '\0';
         return NULL;
    }

    return string;
}

long RegEntry::GetNumber(const TCHAR *pszValue, long dwDefault)
{
     DWORD     dwType;  
     long    dwNumber = 0L;
     DWORD    dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
        _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
                    &dwSize);
    }
    if (_error)
        dwNumber = dwDefault;
    
    return dwNumber;
}

long RegEntry::MoveToSubKey(const TCHAR *pszSubKeyName)
{
    HKEY    _hNewKey;

    if (bhkeyValid) {
        _error = RegOpenKeyEx ( _hkey,
                                pszSubKeyName,
                                0,
                                KEY_READ|KEY_WRITE,
                                &_hNewKey );
        if (_error == ERROR_SUCCESS) {
            RegCloseKey(_hkey);
            _hkey = _hNewKey;
        }
    }

    return _error;
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
        _error = RegFlushKey(_hkey);
    }
    return _error;
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    _error = pRegEntry->GetError();
    if (_error == ERROR_SUCCESS) {
        _error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new TCHAR[cMaxValueName];
            if (!pchName) {
                _error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        _error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete pchName;
    delete pbValue;
}

long RegEnumValues::Next()
{
    if (_error != ERROR_SUCCESS) {
        return _error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    _error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return _error;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAccessibleWrapper implementation
//
//////////////////////////////////////////////////////////////////////////////



CAccessibleWrapper::CAccessibleWrapper( IAccessible * pAcc )
    : m_ref( 1 ),
      m_pAcc( pAcc ),
      m_pEnumVar( NULL ),
      m_pOleWin( NULL )
{
    m_pAcc->AddRef();
}

CAccessibleWrapper::~CAccessibleWrapper()
{
    m_pAcc->Release();
    if( m_pEnumVar )
        m_pEnumVar->Release();
    if( m_pOleWin )
        m_pOleWin->Release();
}


// IUnknown
// Implement refcounting ourselves
// Also implement QI ourselves, so that we return a ptr back to the wrapper.
STDMETHODIMP  CAccessibleWrapper::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr;
    *ppv = NULL;

    if ((riid == IID_IUnknown)  ||
        (riid == IID_IDispatch) ||
        (riid == IID_IAccessible))
    {
        *ppv = (IAccessible *) this;
    }
    else if( riid == IID_IEnumVARIANT )
    {
        // Get the IEnumVariant from the object we are sub-classing so we can delegate
        // calls.
        if( ! m_pEnumVar )
        {
            hr = m_pAcc->QueryInterface( IID_IEnumVARIANT, (void **) & m_pEnumVar );
            if( FAILED( hr ) )
            {
                m_pEnumVar = NULL;
                return hr;
            }
            // Paranoia (in case QI returns S_OK with NULL...)
            if( ! m_pEnumVar )
                return E_NOINTERFACE;
        }

        *ppv = (IEnumVARIANT *) this;
    }
    else if( riid == IID_IOleWindow )
    {
        // Get the IOleWindow from the object we are sub-classing so we can delegate
        // calls.
        if( ! m_pOleWin )
        {
            hr = m_pAcc->QueryInterface( IID_IOleWindow, (void **) & m_pOleWin );
            if( FAILED( hr ) )
            {
                m_pOleWin = NULL;
                return hr;
            }
            // Paranoia (in case QI returns S_OK with NULL...)
            if( ! m_pOleWin )
                return E_NOINTERFACE;
        }

        *ppv = (IOleWindow*) this;
    }
    else
        return(E_NOINTERFACE);

    AddRef();
    return(NOERROR);
}


STDMETHODIMP_(ULONG) CAccessibleWrapper::AddRef()
{
    return ++m_ref;
}


STDMETHODIMP_(ULONG) CAccessibleWrapper::Release()
{
    ULONG ulRet = --m_ref;

    if( ulRet == 0 )
        delete this;

    return ulRet;
}


// IDispatch
// - pass all through m_pAcc

STDMETHODIMP  CAccessibleWrapper::GetTypeInfoCount(UINT* pctinfo)
{
    return m_pAcc->GetTypeInfoCount(pctinfo);
}


STDMETHODIMP  CAccessibleWrapper::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{
    return m_pAcc->GetTypeInfo(itinfo, lcid, pptinfo);
}


STDMETHODIMP  CAccessibleWrapper::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid)
{
    return m_pAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

STDMETHODIMP  CAccessibleWrapper::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
            UINT* puArgErr)
{
    return m_pAcc->Invoke(dispidMember, riid, lcid, wFlags,
            pdispparams, pvarResult, pexcepinfo,
            puArgErr);
}


// IAccessible
// - pass all through m_pAcc

STDMETHODIMP  CAccessibleWrapper::get_accParent(IDispatch ** ppdispParent)
{
    return m_pAcc->get_accParent(ppdispParent);
}


STDMETHODIMP  CAccessibleWrapper::get_accChildCount(long* pChildCount)
{
    return m_pAcc->get_accChildCount(pChildCount);
}


STDMETHODIMP  CAccessibleWrapper::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
    return m_pAcc->get_accChild(varChild, ppdispChild);
}



STDMETHODIMP  CAccessibleWrapper::get_accName(VARIANT varChild, BSTR* pszName)
{
    return m_pAcc->get_accName(varChild, pszName);
}



STDMETHODIMP  CAccessibleWrapper::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    return m_pAcc->get_accValue(varChild, pszValue);
}


STDMETHODIMP  CAccessibleWrapper::get_accDescription(VARIANT varChild, BSTR* pszDescription)
{
    return m_pAcc->get_accDescription(varChild, pszDescription);
}


STDMETHODIMP  CAccessibleWrapper::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    return m_pAcc->get_accRole(varChild, pvarRole);
}


STDMETHODIMP  CAccessibleWrapper::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    return m_pAcc->get_accState(varChild, pvarState);
}


STDMETHODIMP  CAccessibleWrapper::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    return m_pAcc->get_accHelp(varChild, pszHelp);
}


STDMETHODIMP  CAccessibleWrapper::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{
    return m_pAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
}


STDMETHODIMP  CAccessibleWrapper::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{
    return m_pAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
}


STDMETHODIMP  CAccessibleWrapper::get_accFocus(VARIANT * pvarFocusChild)
{
    return m_pAcc->get_accFocus(pvarFocusChild);
}


STDMETHODIMP  CAccessibleWrapper::get_accSelection(VARIANT * pvarSelectedChildren)
{
    return m_pAcc->get_accSelection(pvarSelectedChildren);
}


STDMETHODIMP  CAccessibleWrapper::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{
    return m_pAcc->get_accDefaultAction(varChild, pszDefaultAction);
}



STDMETHODIMP  CAccessibleWrapper::accSelect(long flagsSel, VARIANT varChild)
{
    return m_pAcc->accSelect(flagsSel, varChild);
}


STDMETHODIMP  CAccessibleWrapper::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    return m_pAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
}


STDMETHODIMP  CAccessibleWrapper::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    return m_pAcc->accNavigate(navDir, varStart, pvarEndUpAt);
}


STDMETHODIMP  CAccessibleWrapper::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    return m_pAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
}


STDMETHODIMP  CAccessibleWrapper::accDoDefaultAction(VARIANT varChild)
{
    return m_pAcc->accDoDefaultAction(varChild);
}



STDMETHODIMP  CAccessibleWrapper::put_accName(VARIANT varChild, BSTR szName)
{
    return m_pAcc->put_accName(varChild, szName);
}


STDMETHODIMP  CAccessibleWrapper::put_accValue(VARIANT varChild, BSTR pszValue)
{
    return m_pAcc->put_accValue(varChild, pszValue);
}


// IEnumVARIANT
// - pass all through m_pEnumVar

STDMETHODIMP  CAccessibleWrapper::Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched)
{
    return m_pEnumVar->Next(celt, rgvar, pceltFetched);
}


STDMETHODIMP  CAccessibleWrapper::Skip(ULONG celt)
{
    return m_pEnumVar->Skip(celt);
}


STDMETHODIMP  CAccessibleWrapper::Reset()
{
    return m_pEnumVar->Reset();
}


STDMETHODIMP  CAccessibleWrapper::Clone(IEnumVARIANT ** ppenum)
{
    return m_pEnumVar->Clone(ppenum);
}

// IOleWindow
// - pass all through m_pOleWin

STDMETHODIMP  CAccessibleWrapper::GetWindow(HWND* phwnd)
{
    return m_pOleWin->GetWindow(phwnd);
}


STDMETHODIMP  CAccessibleWrapper::ContextSensitiveHelp(BOOL fEnterMode)
{
    return m_pOleWin->ContextSensitiveHelp(fEnterMode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\clsutil.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CLSUTIL.H - header file for utility C++ classes
//

//  HISTORY:
//  
//  12/07/94    jeremys     Borrowed from WNET common library
//

#ifndef _CLSUTIL_H_
#define _CLSUTIL_H_

/*************************************************************************

    NAME:       BUFFER_BASE

    SYNOPSIS:   Base class for transient buffer classes

    INTERFACE:  BUFFER_BASE()
                    Construct with optional size of buffer to allocate.

                Resize()
                    Resize buffer to specified size.  Returns TRUE if
                    successful.

                QuerySize()
                    Return the current size of the buffer in bytes.

                QueryPtr()
                    Return a pointer to the buffer.

    PARENT:     None

    USES:       None

    CAVEATS:    This is an abstract class, which unifies the interface
                of BUFFER, GLOBAL_BUFFER, etc.

    NOTES:      In standard OOP fashion, the buffer is deallocated in
                the destructor.

    HISTORY:
        03/24/93    gregj   Created base class

**************************************************************************/

class BUFFER_BASE
{
protected:
    UINT _cb;

    virtual BOOL Alloc( UINT cbBuffer ) = 0;
    virtual BOOL Realloc( UINT cbBuffer ) = 0;

public:
    BUFFER_BASE()
        { _cb = 0; }    // buffer not allocated yet
    ~BUFFER_BASE()
        { _cb = 0; }    // buffer size no longer valid
    BOOL Resize( UINT cbNew );
    UINT QuerySize() const { return _cb; };
};

#define GLOBAL_BUFFER   BUFFER

/*************************************************************************

    NAME:       BUFFER

    SYNOPSIS:   Wrapper class for new and delete

    INTERFACE:  BUFFER()
                    Construct with optional size of buffer to allocate.

                Resize()
                    Resize buffer to specified size.  Only works if the
                    buffer hasn't been allocated yet.

                QuerySize()
                    Return the current size of the buffer in bytes.

                QueryPtr()
                    Return a pointer to the buffer.

    PARENT:     BUFFER_BASE

    USES:       operator new, operator delete

    CAVEATS:

    NOTES:      In standard OOP fashion, the buffer is deallocated in
                the destructor.

    HISTORY:
        03/24/93    gregj   Created

**************************************************************************/

class BUFFER : public BUFFER_BASE
{
protected:
    TCHAR *_lpBuffer;

    virtual BOOL Alloc( UINT cbBuffer );
    virtual BOOL Realloc( UINT cbBuffer );

public:
    BUFFER( UINT cbInitial=0 );
    ~BUFFER();
    BOOL Resize( UINT cbNew );
    TCHAR * QueryPtr() const { return (TCHAR *)_lpBuffer; }
    operator TCHAR *() const { return (TCHAR *)_lpBuffer; }
};

class RegEntry
{
    public:
        RegEntry(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER, REGSAM regsam = KEY_READ|KEY_WRITE);
        ~RegEntry();
        
        long    GetError()  { return _error; }
        long    SetValue(const TCHAR *pszValue, const TCHAR *string);
        long    SetValue(const TCHAR *pszValue, unsigned long dwNumber);
        TCHAR * GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length);
        long    GetNumber(const TCHAR *pszValue, long dwDefault = 0);
        long    DeleteValue(const TCHAR *pszValue);
        long    FlushKey();
        long    MoveToSubKey(const TCHAR *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; }

    private:
        HKEY    _hkey;
        long    _error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
    public:
        RegEnumValues(RegEntry *pRegEntry);
        ~RegEnumValues();
        long    Next();
        TCHAR * GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}
        long    GetError()  { return _error; }

    private:
        RegEntry * pRegEntry;
        DWORD   iEnum;
        DWORD   cEntries;
        TCHAR *  pchName;
        LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    _error;
};

/*************************************************************************

    NAME:       WAITCURSOR

    SYNOPSIS:   Sets the cursor to an hourclass until object is destructed

**************************************************************************/
class WAITCURSOR
{
private:
    HCURSOR m_curOld;
    HCURSOR m_curNew;

public:
    WAITCURSOR() { m_curNew = ::LoadCursor( NULL, IDC_WAIT ); m_curOld = ::SetCursor( m_curNew ); }
    ~WAITCURSOR() { ::SetCursor( m_curOld ); }
};





/*************************************************************************

    NAME:       CAccessibleWrapper

    SYNOPSIS:   Sets the cursor to an hourclass until object is destructed

**************************************************************************/

// Generic CAccessibleWrapper class - just calls through on all methods.
// Add overriding behavior in classes derived from this.

class CAccessibleWrapper: public IAccessible,
                         public IOleWindow,
                         public IEnumVARIANT
{
        // We need to do our own refcounting for this wrapper object
        ULONG          m_ref;

        // Need ptr to the IAccessible - also keep around ptrs to EnumVar and
        // OleWindow as part of this object, so we can filter those interfaces
        // and trap their QI's...
        // (We leave pEnumVar and OleWin as NULL until we need them)
        IAccessible *  m_pAcc;
        IEnumVARIANT * m_pEnumVar;
        IOleWindow *   m_pOleWin;
public:
        CAccessibleWrapper( IAccessible * pAcc );
        virtual ~CAccessibleWrapper();

        // IUnknown
        // (We do our own ref counting)
        virtual STDMETHODIMP            QueryInterface(REFIID riid, void** ppv);
        virtual STDMETHODIMP_(ULONG)    AddRef();
        virtual STDMETHODIMP_(ULONG)    Release();

        // IDispatch
        virtual STDMETHODIMP            GetTypeInfoCount(UINT* pctinfo);
        virtual STDMETHODIMP            GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        virtual STDMETHODIMP            GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid);
        virtual STDMETHODIMP            Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
            UINT* puArgErr);

        // IAccessible
        virtual STDMETHODIMP            get_accParent(IDispatch ** ppdispParent);
        virtual STDMETHODIMP            get_accChildCount(long* pChildCount);
        virtual STDMETHODIMP            get_accChild(VARIANT varChild, IDispatch ** ppdispChild);

        virtual STDMETHODIMP            get_accName(VARIANT varChild, BSTR* pszName);
        virtual STDMETHODIMP            get_accValue(VARIANT varChild, BSTR* pszValue);
        virtual STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR* pszDescription);
        virtual STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT *pvarRole);
        virtual STDMETHODIMP            get_accState(VARIANT varChild, VARIANT *pvarState);
        virtual STDMETHODIMP            get_accHelp(VARIANT varChild, BSTR* pszHelp);
        virtual STDMETHODIMP            get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
        virtual STDMETHODIMP            get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);
        virtual STDMETHODIMP            get_accFocus(VARIANT * pvarFocusChild);
        virtual STDMETHODIMP            get_accSelection(VARIANT * pvarSelectedChildren);
        virtual STDMETHODIMP            get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

        virtual STDMETHODIMP            accSelect(long flagsSel, VARIANT varChild);
        virtual STDMETHODIMP            accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        virtual STDMETHODIMP            accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
        virtual STDMETHODIMP            accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
        virtual STDMETHODIMP            accDoDefaultAction(VARIANT varChild);

        virtual STDMETHODIMP            put_accName(VARIANT varChild, BSTR szName);
        virtual STDMETHODIMP            put_accValue(VARIANT varChild, BSTR pszValue);

        // IEnumVARIANT
        virtual STDMETHODIMP            Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP            Skip(ULONG celt);
        virtual STDMETHODIMP            Reset(void);
        virtual STDMETHODIMP            Clone(IEnumVARIANT ** ppenum);

        // IOleWindow
        virtual STDMETHODIMP            GetWindow(HWND* phwnd);
        virtual STDMETHODIMP            ContextSensitiveHelp(BOOL fEnterMode);
};



#endif  // _CLSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\connectn.cpp ===
///////////////////////////////////////////////////////////////////////
//                   Microsoft Windows                               //
//             Copyright(c) Microsoft Corp., 1995                    //
///////////////////////////////////////////////////////////////////////
//
// CONNECTN.C - "Connection" Property Sheet
//
// HISTORY:
//
// 6/22/96  t-gpease    moved to this file
//

#include "inetcplp.h"
#include <inetcpl.h>
#include <rasdlg.h>

#include <mluisupp.h>

HINSTANCE   hInstRNADll = NULL;
DWORD       dwRNARefCount = 0;
BOOL        g_fWin95 = TRUE;
BOOL        g_fMillennium = FALSE;
BOOL        g_fWin2K = FALSE;

static const TCHAR g_szSensPath[]            = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Webcheck");

// clsids used to jit in features
static const CLSID clsidFeatureICW = {      // {5A8D6EE0-3E18-11D0-821E-444553540000}
    0x5A8D6EE0, 0x3E18, 0x11D0, {0x82, 0x1E, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00}};

static const CLSID clsidFeatureMobile = {   // {3af36230-a269-11d1-b5bf-0000f8051515}
    0x3af36230, 0xa269, 0x11d1, {0xb5, 0xbf, 0x00, 0x00, 0xf8, 0x05, 0x15, 0x15}};

// RNA api function names
static const CHAR szRasEditPhonebookEntryA[]   = "RasEditPhonebookEntryA";
static const CHAR szRasEditPhonebookEntryW[]   = "RasEditPhonebookEntryW";
static const CHAR szRasEnumEntriesA[]          = "RasEnumEntriesA";
static const CHAR szRasEnumEntriesW[]          = "RasEnumEntriesW";
static const CHAR szRasDeleteEntryA[]          = "RasDeleteEntryA";
static const CHAR szRasDeleteEntryW[]          = "RasDeleteEntryW";
static const CHAR szRasGetEntryDialParamsA[]   = "RasGetEntryDialParamsA";
static const CHAR szRasGetEntryDialParamsW[]   = "RasGetEntryDialParamsW";
static const CHAR szRasSetEntryDialParamsA[]   = "RasSetEntryDialParamsA";
static const CHAR szRasSetEntryDialParamsW[]   = "RasSetEntryDialParamsW";
static const CHAR szRasCreatePhonebookEntryA[] = "RasCreatePhonebookEntryA";
static const CHAR szRasGetEntryPropertiesW[]   = "RasGetEntryPropertiesW";
static const CHAR szRnaActivateEngine[]        = "RnaActivateEngine";
static const CHAR szRnaDeactivateEngine[]      = "RnaDeactivateEngine";
static const CHAR szRnaDeleteEntry[]           = "RnaDeleteConnEntry";

RASEDITPHONEBOOKENTRYA   lpRasEditPhonebookEntryA   = NULL;
RASEDITPHONEBOOKENTRYW   lpRasEditPhonebookEntryW   = NULL;
RASENUMENTRIESA          lpRasEnumEntriesA          = NULL;
RASENUMENTRIESW          lpRasEnumEntriesW          = NULL;
RASDELETEENTRYA          lpRasDeleteEntryA          = NULL;
RASDELETEENTRYW          lpRasDeleteEntryW          = NULL;
RASGETENTRYDIALPARAMSA   lpRasGetEntryDialParamsA   = NULL;
RASGETENTRYDIALPARAMSW   lpRasGetEntryDialParamsW   = NULL;
RASSETENTRYDIALPARAMSA   lpRasSetEntryDialParamsA   = NULL;
RASSETENTRYDIALPARAMSW   lpRasSetEntryDialParamsW   = NULL;
RASCREATEPHONEBOOKENTRYA lpRasCreatePhonebookEntryA = NULL;
RASGETENTRYPROPERTIESW   lpRasGetEntryPropertiesW   = NULL;
RNAACTIVATEENGINE        lpRnaActivateEngine        = NULL;
RNADEACTIVATEENGINE      lpRnaDeactivateEngine      = NULL;
RNADELETEENTRY           lpRnaDeleteEntry           = NULL;

#define NUM_RNAAPI_PROCS        15
APIFCN RasApiList[NUM_RNAAPI_PROCS] = {
    { (PVOID *) &lpRasEditPhonebookEntryA,   szRasEditPhonebookEntryA},
    { (PVOID *) &lpRasEditPhonebookEntryW,   szRasEditPhonebookEntryW},
    { (PVOID *) &lpRasEnumEntriesA,          szRasEnumEntriesA},
    { (PVOID *) &lpRasEnumEntriesW,          szRasEnumEntriesW},
    { (PVOID *) &lpRasGetEntryDialParamsA,   szRasGetEntryDialParamsA},
    { (PVOID *) &lpRasGetEntryDialParamsW,   szRasGetEntryDialParamsW},
    { (PVOID *) &lpRasSetEntryDialParamsA,   szRasSetEntryDialParamsA},
    { (PVOID *) &lpRasSetEntryDialParamsW,   szRasSetEntryDialParamsW},
    { (PVOID *) &lpRasDeleteEntryA,          szRasDeleteEntryA},
    { (PVOID *) &lpRasDeleteEntryW,          szRasDeleteEntryW},
    { (PVOID *) &lpRasCreatePhonebookEntryA, szRasCreatePhonebookEntryA},
    { (PVOID *) &lpRasGetEntryPropertiesW,   szRasGetEntryPropertiesW},
    { (PVOID *) &lpRnaActivateEngine,        szRnaActivateEngine},
    { (PVOID *) &lpRnaDeactivateEngine,      szRnaDeactivateEngine},
    { (PVOID *) &lpRnaDeleteEntry,           szRnaDeleteEntry}
};


//
// Connection dialog needs info
//
typedef struct _conninfo {

    HTREEITEM   hDefault;
    TCHAR       szEntryName[RAS_MaxEntryName+1];

} CONNINFO, *PCONNINFO;

//
// dial dialog needs some info asssociated with its window
//
typedef struct _dialinfo {

    PROXYINFO   proxy;              // manual proxy info
    BOOL        fClickedAutodetect; // did the user actually click autodetect?
    LPTSTR      pszConnectoid;
#ifdef UNIX
    TCHAR       szEntryName[RAS_MaxEntryName+1];
#endif

} DIALINFO, *PDIALINFO;

//
// Private Functions
//

BOOL ConnectionDlgInit(HWND hDlg, PCONNINFO pConn);
BOOL ConnectionDlgOK(HWND hDlg, PCONNINFO pConn);
VOID EnableConnectionControls(HWND hDlg, PCONNINFO pConn, BOOL fSetText);
BOOL LoadRNADll(VOID);
VOID UnloadRNADll(VOID);
DWORD PopulateRasEntries(HWND hDlg, PCONNINFO pConn);
BOOL MakeNewConnectoid(HWND hDlg, PCONNINFO pConn);
BOOL EditConnectoid(HWND hDlg);
VOID FixAutodialSettings(HWND hDlg, PCONNINFO pConn);

INT_PTR CALLBACK DialupDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK AdvDialupDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK AdvAutocnfgDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);

// Handy stuff for looking at proxy exceptions (from proxysup.cpp)
BOOL RemoveLocalFromExceptionList(IN LPTSTR lpszExceptionList);

extern const TCHAR cszLocalString[];

// defines for tree view image list
#define BITMAP_WIDTH    16
#define BITMAP_HEIGHT   16
#define CONN_BITMAPS    2
#define IMAGE_LAN       0
#define IMAGE_MODEM     1

void GetConnKey(LPTSTR pszConn, LPTSTR pszBuffer, int iBuffLen)
{
    if(NULL == pszConn || 0 == *pszConn) {
        // use lan reg location
        StrCpyN(pszBuffer, REGSTR_PATH_INTERNET_LAN_SETTINGS, iBuffLen);
    } else {
        // use connectoid reg location
        wnsprintf(pszBuffer, iBuffLen, TEXT("%s\\Profile\\%s"), REGSTR_PATH_REMOTEACCESS, pszConn);
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// JitFeature - decide if a feature is present, not present but
//              jitable, or not present and not jitable.  Actually JIT it
//              in if requested
//
/////////////////////////////////////////////////////////////////////////////
#define JIT_PRESENT         0           // Installed
#define JIT_AVAILABLE       1           // Can be JIT'ed
#define JIT_NOT_AVAILABLE   2           // You're in trouble - can't be JIT'ed

DWORD JitFeature(HWND hwnd, REFCLSID clsidFeature, BOOL fCheckOnly)
{
    HRESULT     hr  = REGDB_E_CLASSNOTREG;
    uCLSSPEC    classpec;
    DWORD       dwFlags = 0;

    // figure out struct and flags
    classpec.tyspec = TYSPEC_CLSID;
    classpec.tagged_union.clsid = clsidFeature;

    if(fCheckOnly)
        dwFlags = FIEF_FLAG_PEEK;

    //
    // since we only come to install of JIT features
    // only via a UI code path in inetcpl, we want to
    // simply ignore any previous UI action
    //
    dwFlags |= FIEF_FLAG_FORCE_JITUI;
    // call jit code
    hr = FaultInIEFeature(hwnd, &classpec, NULL, dwFlags);

    if(S_OK == hr) {
        // feature present
        return JIT_PRESENT;
    }

    if(S_FALSE == hr || E_ACCESSDENIED == hr) {
        // jit doesn't know about this feature.  Assume it's present.
        return JIT_PRESENT;
    }

    if(HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) {
        // user didn't want it - may try again sometime, however
        return JIT_AVAILABLE;
    }

    if(fCheckOnly) {
        if(HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED) == hr) {
            // not present but can get it
            return JIT_AVAILABLE;
        }
    }

    //
    // Actually tried to get it but didn't - return not available
    //
    return JIT_NOT_AVAILABLE;
}


/////////////////////////////////////////////////////////////////////////////
//
// RasEnumHelp
//
// Abstract grusome details of getting a correct enumeration of entries 
// from RAS.  Works on all 9x and NT platforms correctly, maintaining unicode
// whenever possible.
//
/////////////////////////////////////////////////////////////////////////////

class RasEnumHelp
{
private:
    
    //
    // Win2k version of RASENTRYNAMEW struct
    //
    #define W2KRASENTRYNAMEW struct tagW2KRASENTRYNAMEW
    W2KRASENTRYNAMEW
    {
        DWORD dwSize;
        WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
        DWORD dwFlags;
        WCHAR szPhonebookPath[MAX_PATH + 1];
    };
    #define LPW2KRASENTRYNAMEW W2KRASENTRYNAMEW*

    //
    // Possible ways we got info from RAS
    //
    typedef enum {
        ENUM_MULTIBYTE,             // Win9x
        ENUM_UNICODE,               // NT4
        ENUM_WIN2K                  // Win2K
    } ENUM_TYPE;

    //
    // How we got the info
    //
    ENUM_TYPE       _EnumType;     

    //
    // Any error we got during enumeration
    //
    DWORD           _dwLastError;

    //
    // Number of entries we got
    //
    DWORD           _dwEntries;

    //
    // Pointer to info retrieved from RAS
    //
    RASENTRYNAMEA * _preList;

    //
    // Last entry returned as multibyte or unicode when conversion required
    //
    WCHAR           _szCurrentEntryW[RAS_MaxEntryName + 1];


public:
    RasEnumHelp();
    ~RasEnumHelp();

    DWORD   GetError();
    DWORD   GetEntryCount();
    LPWSTR  GetEntryW(DWORD dwEntry);
};



RasEnumHelp::RasEnumHelp()
{
    DWORD           dwBufSize, dwStructSize;
    OSVERSIONINFO   ver;

    // init
    _dwEntries = 0;
    _dwLastError = 0;

    // figure out which kind of enumeration we're doing - start with multibyte
    _EnumType = ENUM_MULTIBYTE;
    dwStructSize = sizeof(RASENTRYNAMEA);

    ver.dwOSVersionInfoSize = sizeof(ver);
    if(GetVersionEx(&ver))
    {
        if(VER_PLATFORM_WIN32_NT == ver.dwPlatformId)
        {
            _EnumType = ENUM_UNICODE;
            dwStructSize = sizeof(RASENTRYNAMEW);

            if(ver.dwMajorVersion >= 5)
            {
                _EnumType = ENUM_WIN2K;
                dwStructSize = sizeof(W2KRASENTRYNAMEW);
            }
        }
    }

    // allocate space for 16 entries
    dwBufSize = 16 * dwStructSize;
    _preList = (LPRASENTRYNAMEA)GlobalAlloc(LMEM_FIXED, dwBufSize);
    if(_preList)
    {
        do
        {
            // set up list
            _preList[0].dwSize = dwStructSize;

            // call ras to enumerate
            _dwLastError = ERROR_UNKNOWN;
            if(ENUM_MULTIBYTE == _EnumType)
            {
                if(lpRasEnumEntriesA)
                {
                    _dwLastError = lpRasEnumEntriesA(
                                    NULL,
                                    NULL,
                                    (LPRASENTRYNAMEA)_preList,
                                    &dwBufSize,
                                    &_dwEntries
                                    );
                }
            }
            else
            {
                if(lpRasEnumEntriesW)
                {
                    _dwLastError = lpRasEnumEntriesW(
                                    NULL,
                                    NULL,
                                    (LPRASENTRYNAMEW)_preList,
                                    &dwBufSize,
                                    &_dwEntries
                                    );
                }
            }
       
            // reallocate buffer if necessary
            if(ERROR_BUFFER_TOO_SMALL == _dwLastError)
            {
                GlobalFree(_preList);
                _preList = (LPRASENTRYNAMEA)GlobalAlloc(LMEM_FIXED, dwBufSize);
                if(NULL == _preList)
                {
                    _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            else
            {
                break;
            }

        } while(TRUE);
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(_preList && (ERROR_SUCCESS != _dwLastError))
    {
        GlobalFree(_preList);
        _preList = NULL;
        _dwEntries = 0;
    }

    return;
}

RasEnumHelp::~RasEnumHelp()
{
    if(_preList)
    {
        GlobalFree(_preList);
    }
}

DWORD
RasEnumHelp::GetError()
{
    return _dwLastError;
}

DWORD
RasEnumHelp::GetEntryCount()
{
    return _dwEntries;
}

LPWSTR
RasEnumHelp::GetEntryW(
    DWORD dwEntryNum
    )
{
    LPWSTR  pwszName = NULL;

    if(dwEntryNum >= _dwEntries)
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        MultiByteToWideChar(CP_ACP, 0, _preList[dwEntryNum].szEntryName,
            -1, _szCurrentEntryW, RAS_MaxEntryName + 1);
        pwszName = _szCurrentEntryW;
        break;
    case ENUM_UNICODE:
        {
        LPRASENTRYNAMEW lpTemp = (LPRASENTRYNAMEW)_preList;
        pwszName = lpTemp[dwEntryNum].szEntryName;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYNAMEW lpTemp = (LPW2KRASENTRYNAMEW)_preList;
        pwszName = lpTemp[dwEntryNum].szEntryName;
        break;
        }
    }

    return pwszName;
}

/////////////////////////////////////////////////////////////////////////////
//
//        NAME:           MakeNewConnectoid
//
//        SYNOPSIS:       Launches RNA new connectoid wizard; selects newly
//                                created connectoid (if any) in combo box
//
/////////////////////////////////////////////////////////////////////////////

typedef BOOL (*PFRED)(LPTSTR, LPTSTR, LPRASENTRYDLG);

BOOL MakeNewConnectoid(HWND hDlg, PCONNINFO pConn)
{
    BOOL fRet = FALSE, fDone = FALSE;
    DWORD dwRes = 0;

    ASSERT(lpRasCreatePhonebookEntryA);

    if(FALSE == g_fWin95) {
        // on NT, use RasEntryDlg so we know who we created and can edit
        // proxy info for that connectoid
        HMODULE hRasDlg = LoadLibrary(TEXT("rasdlg.dll"));
        if(hRasDlg) {
#ifdef UNICODE
            PFRED pfred = (PFRED)GetProcAddress(hRasDlg, "RasEntryDlgW");
#else
            PFRED pfred = (PFRED)GetProcAddress(hRasDlg, "RasEntryDlgA");
#endif
            if(pfred) {
                RASENTRYDLG info;

                memset(&info, 0, sizeof(RASENTRYDLG));
                info.dwSize = sizeof(RASENTRYDLG);
                info.hwndOwner = hDlg;
                info.dwFlags = RASEDFLAG_NewEntry;

                dwRes = (pfred)(NULL, NULL, &info);
                if(dwRes) {
                    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_DIALUP), hDlg,
                        DialupDlgProc, (LPARAM)info.szEntry);
                    dwRes = ERROR_SUCCESS;

                    // save name as default
                    lstrcpyn(pConn->szEntryName, info.szEntry, RAS_MaxEntryName);
                } else {
                    dwRes = info.dwError;
                }
                fDone = TRUE;
            }

            FreeLibrary(hRasDlg);
        }
    }

    if(FALSE == fDone) {
        // on win95, show the ui to make new entry
        if(lpRasCreatePhonebookEntryA)
        {
            dwRes = (lpRasCreatePhonebookEntryA)(hDlg,NULL);
        }

        // if we're on millennium, refresh default
        if(g_fMillennium)
        {
            FixAutodialSettings(hDlg, pConn);
        }
    }

    if(ERROR_SUCCESS == dwRes) {
        // make sure dial default is turned on.  If this is NT, default entry
        // is set above to new entry.
        if(IsDlgButtonChecked(hDlg, IDC_DIALUP_NEVER))
        {
            CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, IDC_DIALUP);
        }
        PopulateRasEntries(hDlg, pConn);
        EnableConnectionControls(hDlg, pConn, FALSE);
        fRet = TRUE;
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////
//
//        NAME:           PopulateRasEntries
//
//        ENTRY:          hwndDlg - dlg box window handle
//
//        SYNOPSIS:       Fills specified combo box with list of existing RNA
//                                connectoids
//
///////////////////////////////////////////////////////////////////////////

#define DEF_ENTRY_BUF_SIZE      8192

DWORD PopulateRasEntries(HWND hDlg, PCONNINFO pConn)
{
    HWND hwndTree = GetDlgItem(hDlg, IDC_CONN_LIST);
    DWORD i;
    DWORD dwBufSize = 16 * sizeof(RASENTRYNAMEA);
    DWORD dwEntries = 0;
    TVITEM tvi;
    TVINSERTSTRUCT tvins;
    HTREEITEM hFirst = NULL;

    ASSERT(hwndTree);

    // init tvi and tvins
    tvi.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvi.lParam = 0;
    tvins.hInsertAfter = (HTREEITEM)TVI_SORT;
    tvins.hParent = TVI_ROOT;

    // clear list
    TreeView_DeleteAllItems(hwndTree);

    // any old htree is now bogus - we'll get a new one
    pConn->hDefault = NULL;

    // enumerate
    RasEnumHelp reh;

    if(ERROR_SUCCESS == reh.GetError())
    {
        TCHAR szTemp[RAS_MaxEntryName + 64];
        BOOL fDefault, fFoundDefault = FALSE;
        LPTSTR pszEntryName;

        // insert connectoid names from buffer into combo box
        for(i=0; i<reh.GetEntryCount(); i++)
        {
            pszEntryName = reh.GetEntryW(i);
            fDefault = FALSE;

            // if there's only one entry, force it to be the default
            if(1 == dwEntries)
            {
                StrCpyN(pConn->szEntryName, pszEntryName, RAS_MaxEntryName);
            }

            if(*pConn->szEntryName && 0 == StrCmp(pszEntryName, pConn->szEntryName)) {
                // this is the default entry - stick it in the default
                // text control and append (Default) to it
                SetWindowText(GetDlgItem(hDlg, IDC_DIAL_DEF_ISP), pConn->szEntryName);
                StrCpyN(szTemp, pszEntryName, RAS_MaxEntryName);
                MLLoadString(IDS_DEFAULT_TEXT, szTemp + lstrlen(szTemp), 64);
                tvi.pszText = szTemp;
                fDefault = TRUE;
                fFoundDefault = TRUE;
            } else {
                tvi.pszText = pszEntryName;
            }
            tvi.iImage = IMAGE_MODEM;
            tvi.iSelectedImage = IMAGE_MODEM;
            tvi.lParam = i;
            tvins.item = tvi;
            HTREEITEM hItem = TreeView_InsertItem(hwndTree, &tvins);
            if(NULL == hFirst)
                hFirst = hItem;
            if(fDefault)
                pConn->hDefault = hItem;
        }

        // if we didn't match our default with a connectoid, kill it
        if(FALSE == fFoundDefault)
        {
            *pConn->szEntryName = 0;
            MLLoadString(IDS_NONE, szTemp, 64);
            SetWindowText(GetDlgItem(hDlg, IDC_DIAL_DEF_ISP), szTemp);
        }
    }

    // select default or first entry if there is one
    if(pConn->hDefault)
    {
        TreeView_Select(hwndTree, pConn->hDefault, TVGN_CARET);
    }
    else if(hFirst)
    {
        TreeView_Select(hwndTree, hFirst, TVGN_CARET);
    }

    return reh.GetEntryCount();
}

void PopulateProxyControls(HWND hDlg, LPPROXYINFO pInfo, BOOL fSetText)
{
    BOOL fManual = FALSE, fScript = FALSE, fDisable, fTemp;

    // decide if everything is disabled
    fDisable = IsDlgButtonChecked(hDlg, IDC_DONT_USE_CONNECTION);

    //
    // disable proxy enable check box if proxy restricted
    //
    fTemp = fDisable || g_restrict.fProxy;
    EnableDlgItem(hDlg, IDC_MANUAL, !fTemp);
    if(FALSE == g_restrict.fProxy)
    {
        fManual = !fDisable && pInfo->fEnable;
    }

    //
    // Disable autoconfig if restricted
    //
    fScript = !fDisable && IsDlgButtonChecked(hDlg, IDC_CONFIGSCRIPT);

    fTemp = fDisable || g_restrict.fAutoConfig;
    EnableDlgItem(hDlg, IDC_CONFIGSCRIPT, !fTemp);
    EnableDlgItem(hDlg, IDC_AUTODISCOVER, !fTemp);
    if(fTemp)
    {
        fScript = FALSE;
    }

    // enable config script controls
    EnableDlgItem(hDlg, IDC_CONFIG_ADDR, fScript);
    EnableDlgItem(hDlg, IDC_CONFIGADDR_TX, fScript);
    EnableDlgItem(hDlg, IDC_AUTOCNFG_ADVANCED, fScript);

    // Button is always on and omit local addresses is available if proxy is checked
    EnableDlgItem(hDlg, IDC_PROXY_ADVANCED, fManual);
    EnableDlgItem(hDlg, IDC_PROXY_OMIT_LOCAL_ADDRESSES, fManual);

    // Enable dial controls as necessary
    EnableDlgItem(hDlg, IDC_USER, !fDisable && !pInfo->fCustomHandler);
    EnableDlgItem(hDlg, IDC_PASSWORD, !fDisable && !pInfo->fCustomHandler);
    EnableDlgItem(hDlg, IDC_DOMAIN, !fDisable && !pInfo->fCustomHandler);
    EnableDlgItem(hDlg, IDC_TX_USER, !fDisable && !pInfo->fCustomHandler);
    EnableDlgItem(hDlg, IDC_TX_PASSWORD, !fDisable && !pInfo->fCustomHandler);
    EnableDlgItem(hDlg, IDC_TX_DOMAIN, !fDisable && !pInfo->fCustomHandler);
    EnableDlgItem(hDlg, IDC_RAS_SETTINGS, !fDisable);
    EnableDlgItem(hDlg, IDC_DIAL_ADVANCED, !fDisable && !pInfo->fCustomHandler);

    // settings changed in here are enabled/disabled based on the actual proxy settings
    if(StrChr(pInfo->szProxy, TEXT('=')))
    {
        // different servers for each - disable fields on this dialog
        fManual = FALSE;
        if (fSetText)
        {
            SetWindowText(GetDlgItem(hDlg, IDC_PROXY_ADDR), TEXT(""));
            SetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), TEXT(""));
        }
    }
    else if (fSetText)
    {
        TCHAR       *pszColon, *pszColon2;
        //Is there a : in the proxy string ?
        pszColon = StrChr(pInfo->szProxy, TEXT(':'));
        if(pszColon)
        {
            //Yes, Find if we have another ':'
            pszColon2 = StrChr(pszColon + 1, TEXT(':'));
            if(pszColon2)
            {
                //Yes, so we have strig like http://itgproxy:80
                pszColon = pszColon2;
                SetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), pszColon + 1);
                *pszColon = 0;
            }
            else
            {
                //No, We dont have a second ':'

                int ilength =  (int) (pszColon - pInfo->szProxy);
                //Are there atleast two characters  left beyond the first ':'
                if (lstrlen(pInfo->szProxy) - ilength >= 2 )
                {
                    //Yes, Are Those characters equal //
                    if((pInfo->szProxy[++ilength] == TEXT('/')) &&
                        (pInfo->szProxy[++ilength] == TEXT('/')))
                    {
                        //Yes then we have string like http://itgproxy
                        //make the whole thing as the server and make port fiel empty
                       SetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), TEXT(""));
                    }
                    else
                    {
                        //No, so we have string like itgproxy:80.
                        SetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), pszColon + 1);
                        *pszColon = 0;
                    }
                }
                else
                {
                  //No We dont have atleast two character so lets parse this as server and port
                  // Assuming this strign to be something like itgproxy:8
                  SetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), pszColon + 1);
                  *pszColon = 0;
                }

            }
        }
        else
        {
            //No we dont have a : so treat the string as just the proxy server.
            //Case itgproxy
            SetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), TEXT(""));
        }
        SetWindowText(GetDlgItem(hDlg, IDC_PROXY_ADDR), pInfo->szProxy);
    }


    EnableDlgItem(hDlg, IDC_ADDRESS_TEXT,   fManual);
    EnableDlgItem(hDlg, IDC_PORT_TEXT,      fManual);
    EnableDlgItem(hDlg, IDC_PROXY_ADDR,     fManual);
    EnableDlgItem(hDlg, IDC_PROXY_PORT,     fManual);
}

void GetProxyInfo(HWND hDlg, PDIALINFO pDI)
{
    pDI->proxy.fEnable = IsDlgButtonChecked(hDlg, IDC_MANUAL);

    if(NULL == StrChr(pDI->proxy.szProxy, TEXT('=')))
    {
        //
        // not per-protocol, so read edit boxes
        //
        TCHAR szProxy[MAX_URL_STRING];
        TCHAR szPort[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];

        GetWindowText(GetDlgItem(hDlg, IDC_PROXY_ADDR), szProxy, ARRAYSIZE(szProxy) );
        GetWindowText(GetDlgItem(hDlg, IDC_PROXY_PORT), szPort, ARRAYSIZE(szPort) );

        // if we got a proxy and a port, combine in to one string
        if(*szProxy && *szPort)
            wnsprintf(pDI->proxy.szProxy, ARRAYSIZE(pDI->proxy.szProxy), TEXT("%s:%s"), szProxy, szPort);
        else
            StrCpyN(pDI->proxy.szProxy, szProxy, ARRAYSIZE(pDI->proxy.szProxy));
    }

    //
    // fix manual settings override
    //
    pDI->proxy.fOverrideLocal = IsDlgButtonChecked(hDlg, IDC_PROXY_OMIT_LOCAL_ADDRESSES);

    if(pDI->proxy.fOverrideLocal) {
        RemoveLocalFromExceptionList(pDI->proxy.szOverride);
        if(*pDI->proxy.szOverride)
            wnsprintf(pDI->proxy.szOverride, ARRAYSIZE(pDI->proxy.szOverride), TEXT("%s;%s"), pDI->proxy.szOverride, cszLocalString);
        else
            StrCpyN(pDI->proxy.szOverride, cszLocalString, ARRAYSIZE(pDI->proxy.szOverride));
    }
}

//////////////////////////////////////////////////////////////////////
//
//        NAME:       DeleteRasEntry
//
//        SYNOPSIS:   Delete a connectoid
//
//////////////////////////////////////////////////////////////////////
void DeleteRasEntry(LPTSTR pszEntry)
{
    // Use RasDeleteEntryW if possible
    if(lpRasDeleteEntryW)
    {
        (lpRasDeleteEntryW)(NULL, pszEntry);
    }
    else
    {
        CHAR szEntryA[MAX_PATH];
        SHUnicodeToAnsi(pszEntry, szEntryA, ARRAYSIZE(szEntryA));

        // Use RasDeleteEntryA if possible
        if(lpRasDeleteEntryA)
        {
            (lpRasDeleteEntryA)(NULL, szEntryA);
        }
        else
        {
            // no RasDeleteEntry - must by Win95 gold machine.  Use RNA. Ick.
            if( lpRnaActivateEngine &&
                lpRnaDeleteEntry &&
                lpRnaDeactivateEngine &&
                ERROR_SUCCESS == (lpRnaActivateEngine)())
            {
                (lpRnaDeleteEntry)(szEntryA);
                (lpRnaDeactivateEngine)();
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////
//
//        NAME:       ChangeDefault
//
//        SYNOPSIS:   Change default connectoid to currently selected one
//
//////////////////////////////////////////////////////////////////////
void ChangeDefault(HWND hDlg, PCONNINFO pConn)
{
    TVITEM tvi;
    HWND hwndTree = GetDlgItem(hDlg, IDC_CONN_LIST);
    HTREEITEM hCur;

    memset(&tvi, 0, sizeof(TVITEM));

    // find current selection - if there isn't one, bail
    hCur = TreeView_GetSelection(hwndTree);
    if(NULL == hCur)
        return;

    // remove (default) from current default
    if(pConn->hDefault) {
        tvi.mask = TVIF_HANDLE | TVIF_TEXT;
        tvi.hItem = pConn->hDefault;
        tvi.pszText = pConn->szEntryName;
        tvi.cchTextMax = RAS_MaxEntryName;
        TreeView_SetItem(hwndTree, &tvi);
    }

    // get text for current item
    tvi.mask = TVIF_HANDLE | TVIF_TEXT;
    tvi.hItem = hCur;
    tvi.pszText = pConn->szEntryName;
    tvi.cchTextMax = RAS_MaxEntryName;
    TreeView_GetItem(hwndTree, &tvi);

    // fill in default text field
    SetWindowText(GetDlgItem(hDlg, IDC_DIAL_DEF_ISP), pConn->szEntryName);

    // add (default) to current selection
    TCHAR szTemp[RAS_MaxEntryName + 64];

    StrCpyN(szTemp, pConn->szEntryName, RAS_MaxEntryName);
    MLLoadString(IDS_DEFAULT_TEXT, szTemp + lstrlen(szTemp), 64);

    // stick it back in the tree
    tvi.mask = TVIF_HANDLE | TVIF_TEXT;
    tvi.hItem = hCur;
    tvi.pszText = szTemp;
    tvi.cchTextMax = RAS_MaxEntryName;
    TreeView_SetItem(hwndTree, &tvi);

    // save htree
    pConn->hDefault = hCur;
}

//////////////////////////////////////////////////////////////////////
//
//        NAME:       ShowConnProps
//
//        SYNOPSIS:   Show properties for selected connection
//
//////////////////////////////////////////////////////////////////////

HTREEITEM GetCurSel(PCONNINFO pConn, HWND hDlg, LPTSTR pszBuffer, int iLen, BOOL *pfChecked)
{
    HWND    hwndTree = GetDlgItem(hDlg, IDC_CONN_LIST);
    TVITEM  tvi;

    tvi.hItem = TreeView_GetSelection(hwndTree);

    if(tvi.hItem) {
        tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_STATE;
        tvi.stateMask = TVIS_STATEIMAGEMASK;

        // get test if needed
        if(pszBuffer) {
            tvi.mask |= TVIF_TEXT;
            tvi.pszText = pszBuffer;
            tvi.cchTextMax = iLen;
        }
        TreeView_GetItem(hwndTree, &tvi);

        if(pfChecked)
            *pfChecked = (BOOL)(tvi.state >> 12) - 1;
    }

    // if this is the default connectiod, return name without (default) part
    if(pszBuffer && tvi.hItem == pConn->hDefault) {
        StrCpyN(pszBuffer, pConn->szEntryName, iLen);
    }

    return tvi.hItem;
}

void ShowConnProps(HWND hDlg, PCONNINFO pConn, BOOL fLan)
{
    HTREEITEM   hItem = NULL;
    TCHAR       szEntryName[RAS_MaxEntryName+1];
    BOOL        fChecked = FALSE;

    // if not lan, apply current selections
    if(g_fMillennium && !fLan)
    {
        ConnectionDlgOK(hDlg, pConn);
    }

    // default to lan
    *szEntryName = 0;

    // find item of interest
    if(FALSE == fLan)
        hItem = GetCurSel(pConn, hDlg, szEntryName, RAS_MaxEntryName, &fChecked);

    if(hItem || fLan) {
        // show settings
        DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_DIALUP), hDlg,
            DialupDlgProc, (LPARAM)szEntryName);
    }

    // if not lan, some settings may have been changed by RAS UI -- refresh
    if(g_fMillennium && !fLan )
    {
        FixAutodialSettings(hDlg, pConn);
    }
}

BOOL GetConnSharingDll(LPTSTR pszPath)
{
    DWORD cb = SIZEOF(TCHAR) * MAX_PATH;
    return SHGetValue(HKEY_LOCAL_MACHINE, 
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                TEXT("SharingDLL"), NULL, pszPath, &cb) == ERROR_SUCCESS;
}

BOOL IsConnSharingAvail()
{
    TCHAR szPath[MAX_PATH];
    return GetConnSharingDll(szPath);
}

typedef HRESULT (WINAPI *PFNCONNECTIONSHARING)(HWND hwnd, DWORD dwFlags);

void ShowConnSharing(HWND hDlg)
{
    TCHAR szPath[MAX_PATH];
    if (GetConnSharingDll(szPath))
    {
        HMODULE hmod = LoadLibrary(szPath);
        if (hmod)
        {
            PFNCONNECTIONSHARING pfn = (PFNCONNECTIONSHARING)GetProcAddress(hmod, "InternetConnectionSharing");
            if (pfn)
                pfn(hDlg, 0);
            FreeLibrary(hmod);
        }
    }
}

//////////////////////////////////////////////////////////////////////
//
//        NAME:       ConnectionDlgProc
//
//        SYNOPSIS:   Connection property sheet dialog proc.
//
//////////////////////////////////////////////////////////////////////


INT_PTR CALLBACK ConnectionDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam)
{
    PCONNINFO pConn = (PCONNINFO)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    if (NULL == pConn && uMsg != WM_INITDIALOG)
    {
        return FALSE;
    }

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // build and save conninfo struct
            pConn = new CONNINFO;
            if(NULL == pConn)
                return FALSE;
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pConn);
            memset(pConn, 0, sizeof(CONNINFO));

            return ConnectionDlgInit(hDlg, pConn);

        case WM_DESTROY:
        {
            UnloadRNADll();

            // Free the image list used by the connection list
            HWND hwndConnList = GetDlgItem(hDlg, IDC_CONN_LIST);
            HIMAGELIST himl = TreeView_SetImageList(hwndConnList, NULL, TVSIL_NORMAL);
            if (himl)
            {
                ImageList_Destroy(himl);
            }

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)NULL);
            delete pConn;
            return TRUE;
        }
        case WM_NOTIFY:
        {
            NMHDR * lpnm = (NMHDR *) lParam;
            switch (lpnm->code)
            {
                case TVN_KEYDOWN:
                {
                    TV_KEYDOWN *pkey = (TV_KEYDOWN*)lpnm;
                    if(pkey->wVKey == VK_SPACE)
                    {
                        ENABLEAPPLY(hDlg);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // eat the key
                        return TRUE;
                    }
                    break;
                }

                case NM_CLICK:
                case NM_DBLCLK:
                {   // is this click in our tree?
                    if(lpnm->idFrom == IDC_CONN_LIST)
                    {   
                        HWND            hwndTree = GetDlgItem(hDlg, IDC_CONN_LIST);
                        TV_HITTESTINFO  ht;
                        HTREEITEM       hItem;

                        GetCursorPos(&ht.pt);
                        ScreenToClient(hwndTree, &ht.pt);
                        hItem = TreeView_HitTest(hwndTree, &ht);
                        if(hItem)
                        {
                            TreeView_SelectItem(hwndTree, hItem);

                            // If it's a double click, show settings
                            if(NM_DBLCLK == lpnm->code)
                            {
                                PostMessage(hDlg, WM_COMMAND, IDC_MODEM_SETTINGS, 0);
                            }
                        }
                    }
                    EnableConnectionControls(hDlg, pConn, FALSE);
                    break;
                }

                case TVN_SELCHANGEDA:
                case TVN_SELCHANGEDW:
                    EnableConnectionControls(hDlg, pConn, FALSE);
                    break;

                case PSN_QUERYCANCEL:
                case PSN_KILLACTIVE:
                case PSN_RESET:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return TRUE;

                case PSN_APPLY:
                {
                    BOOL fRet = ConnectionDlgOK(hDlg, pConn);
                    SetPropSheetResult(hDlg,!fRet);
                    return !fRet;
                    break;
                }
            }
            break;
        }

        case WM_COMMAND:
            switch  (LOWORD(wParam))
            {
                case IDC_LAN_SETTINGS:
                    ShowConnProps(hDlg, pConn, TRUE);
                    break;

                case IDC_CON_SHARING:
                    ShowConnSharing(hDlg);
                    break;

                case IDC_DIALUP_ADD:
                    MakeNewConnectoid(hDlg, pConn);
                    break;

                case IDC_DIALUP_REMOVE:
                {
                    TCHAR   szEntryName[RAS_MaxEntryName+1];

                    if (GetCurSel(pConn, hDlg, szEntryName, RAS_MaxEntryName, NULL) &&
                        *szEntryName) {
                        if(IDOK == MsgBox(hDlg, IDS_DELETECONNECTOID, MB_ICONWARNING, MB_OKCANCEL)) {
                            DeleteRasEntry(szEntryName);
                            PopulateRasEntries(hDlg, pConn);

                            // fix controls
                            EnableConnectionControls(hDlg, pConn, FALSE);
                        }
                    }
                    break;
                }


                case IDC_DIALUP:
                case IDC_DIALUP_ON_NONET:
                case IDC_DIALUP_NEVER:

                    // fix radio buttons
                    CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, LOWORD(wParam));

                    // enable/disable other controls appropriately
                    EnableConnectionControls(hDlg, pConn, FALSE);
                    ENABLEAPPLY(hDlg);
                    break;

                case IDC_ENABLE_SECURITY:
                    ENABLEAPPLY(hDlg);
                    break;

                case IDC_SET_DEFAULT:
                    ChangeDefault(hDlg, pConn);
                    if(GetFocus() == GetDlgItem(hDlg, IDC_SET_DEFAULT))
                    {
                        // focus is currently on the button and it's about to be disabled
                        SetFocus(GetDlgItem(hDlg, IDC_CONN_LIST));
                    }
                    EnableConnectionControls(hDlg, pConn, FALSE);
                    ENABLEAPPLY(hDlg);
                    break;

                case IDC_MODEM_SETTINGS:
                    ShowConnProps(hDlg, pConn, FALSE);
                    break;

                case IDC_CONNECTION_WIZARD:
                    TCHAR       szICWReg[MAX_PATH];
                    TCHAR       szICWPath[MAX_PATH + 1];
                    DWORD       cbSize = MAX_PATH, dwType;

                    if (IsOS(OS_WHISTLERORGREATER))
                    {
                        // This is the invocation path for the New Connection Wizard in Whistler
                        StrCpy(szICWPath, TEXT("rundll32.exe netshell.dll,StartNCW"));
                    }
                    else
                    {
                        // Try and get ICW from IOD.  If it fails, try to run
                        // ICW anyway.  We may luck out and get an old one.
                        DWORD dwRes = JitFeature(hDlg, clsidFeatureICW, FALSE);

                        // find path of ICW
                        MLLoadString(IDS_ICW_NAME, szICWPath, MAX_PATH);
                        wnsprintf(szICWReg, ARRAYSIZE(szICWReg), TEXT("%s\\%s"), REGSTR_PATH_APPPATHS, szICWPath);

                        // read app paths key
                        if(ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, szICWReg, NULL, &dwType, szICWPath, &cbSize))
                            break;
                    }

                    // run connection wizard
                    STARTUPINFO si;
                    PROCESS_INFORMATION pi;
                    memset(&si, 0, sizeof(si));
                    si.cb = sizeof(si);

                    if(CreateProcess(NULL, szICWPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
                    {
                        // successfully ran ICW - get rid of this dialog
                        CloseHandle(pi.hProcess);
                        CloseHandle(pi.hThread);
                        PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
                    }
                    break;
            }
            break;

        case WM_HELP:      // F1
            ResWinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                       HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            ResWinHelp((HWND)wParam, IDS_HELPFILE,
                       HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

/*******************************************************************

NAME:           ConnectionDlgOK

SYNOPSIS:       OK button handler for connection prop page

********************************************************************/

// prototype for IsNetworkAlive()
typedef BOOL (WINAPI *ISNETWORKALIVE)(LPDWORD);

BOOL ConnectionDlgOK(HWND hDlg, PCONNINFO pConn)
{
    DWORD   dwAutodial;

    RegEntry re(REGSTR_PATH_INTERNETSETTINGS,HKEY_CURRENT_USER);
    if(ERROR_SUCCESS == re.GetError()) {

        // autodial
        dwAutodial = AUTODIAL_MODE_NEVER;
        if(IsDlgButtonChecked(hDlg, IDC_DIALUP))
        {
            dwAutodial = AUTODIAL_MODE_ALWAYS;
        }
        else if(IsDlgButtonChecked(hDlg, IDC_DIALUP_ON_NONET))
        {
            dwAutodial = AUTODIAL_MODE_NO_NETWORK_PRESENT;

            DWORD dwRes = JitFeature(hDlg, clsidFeatureMobile, FALSE);
            if(JIT_PRESENT != dwRes) {
                // user doesn't want MOP, change to dial always.
                dwAutodial = AUTODIAL_MODE_ALWAYS;
            }
            else
            {
                // Call IsNetworkAlive.  This will start sens service
                // and next instance of wininet will use it.
                HINSTANCE hSens;
                ISNETWORKALIVE pfnIsNetworkAlive;
                DWORD dwFlags;

                hSens = LoadLibrary(TEXT("sensapi.dll"));
                if(hSens)
                {
                    pfnIsNetworkAlive = (ISNETWORKALIVE)GetProcAddress(hSens, "IsNetworkAlive");
                    if(pfnIsNetworkAlive)
                    {
                        // Call it.  Don't really care about the result.
                        pfnIsNetworkAlive(&dwFlags);
                    }
                    FreeLibrary(hSens);
                }
            }
        }

        // save autodial mode
        InternetSetOption(NULL, INTERNET_OPTION_AUTODIAL_MODE, &dwAutodial, sizeof(dwAutodial));

        // save default connectoid
        if(*pConn->szEntryName)
        {
            InternetSetOption(NULL, INTERNET_OPTION_AUTODIAL_CONNECTION, pConn->szEntryName, lstrlen(pConn->szEntryName));
        }
    }

    // save security check state on win95
    if(g_fWin95)
    {
        DWORD dwValue = 0;
        if(IsDlgButtonChecked(hDlg, IDC_ENABLE_SECURITY))
        {
            dwValue = 1;
        }
        re.SetValue(REGSTR_VAL_ENABLESECURITYCHECK, dwValue);
    }

    //
    // Have wininet refresh it's connection settings
    //
    InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

    UpdateAllWindows();

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//        NAME:           EnableConnectionControls
//
//        SYNOPSIS:       Enables controls appropriately depending on what
//                                checkboxes are checked.
//
/////////////////////////////////////////////////////////////////////////////

VOID EnableConnectionControls(HWND hDlg, PCONNINFO pConn, BOOL fSetText)
{
    TCHAR   szEntryName[RAS_MaxEntryName + 1];
    BOOL    fList = FALSE, fDial = FALSE, fAutodial = FALSE;
    BOOL    fAdd = FALSE, fSettings = FALSE, fLan = TRUE, fSetDefault = TRUE;
    BOOL    fDialDefault = FALSE, fNT4SP3;
    HTREEITEM   hItem;
    int     iCount;

    fNT4SP3 = IsNTSPx(FALSE, 4, 3);

    if(fNT4SP3)
    {
        // no sens stuff on NT4SP3, so make sure on no net isn't picked
        if(IsDlgButtonChecked(hDlg, IDC_DIALUP_ON_NONET))
        {
            CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, IDC_DIALUP);
        }
    }

    //
    // Check out how much stuff is in the tree view and what's selected
    //
    iCount = TreeView_GetCount(GetDlgItem(hDlg, IDC_CONN_LIST));
    hItem = GetCurSel(pConn, hDlg, szEntryName, RAS_MaxEntryName, NULL);

    if(dwRNARefCount) {
        // Ras is loaded so enable list control
        fList = TRUE;

        // if anything is selected, turn on settings button
        if(hItem)
        {
            fSettings = TRUE;
            if(hItem == pConn->hDefault)
            {
                fSetDefault = FALSE;
            }
        }

        // Ensure ras is loaded
        if(iCount > 0)
            fDial = TRUE;
    }

    // check to see if dial default is checked
    if(fDial)
        fDialDefault = !IsDlgButtonChecked(hDlg, IDC_DIALUP_NEVER);

    if(fList && lpRasCreatePhonebookEntryA)
        fAdd = TRUE;

    // if dialing restriction is present, make sure user can't do nothing.
    if(g_restrict.fDialing)
        fAdd = fList = fDial = fDialDefault = fAutodial = fSettings = fLan = fSetDefault = FALSE;

    // enable list controls
    EnableDlgItem(hDlg, IDC_CONN_LIST,       fList);
    EnableDlgItem(hDlg, IDC_DIALUP_ADD,      fAdd);
    EnableDlgItem(hDlg, IDC_DIALUP_REMOVE,   fSettings);
    EnableDlgItem(hDlg, IDC_MODEM_SETTINGS,  fSettings);

    // enable lan controls
    EnableDlgItem(hDlg, IDC_LAN_SETTINGS,    fLan);

    // enable default controls
    EnableDlgItem(hDlg, IDC_DIALUP_NEVER,    fDial);
    EnableDlgItem(hDlg, IDC_DIALUP_ON_NONET, fDial && !fNT4SP3);
    EnableDlgItem(hDlg, IDC_DIALUP,          fDial);
    EnableDlgItem(hDlg, IDC_DIAL_DEF_TXT,    fDialDefault);
    EnableDlgItem(hDlg, IDC_DIAL_DEF_ISP,    fDialDefault);
    EnableDlgItem(hDlg, IDC_ENABLE_SECURITY, fDialDefault);
    EnableDlgItem(hDlg, IDC_SET_DEFAULT,     fDialDefault && fSetDefault);

    // if autodialing is disabled (no connectoids) make sure it's not checked
    if(FALSE == fDial)
        CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, IDC_DIALUP_NEVER);

    //
    // Fix connection wizard
    //
    if (g_restrict.fConnectionWizard)
    {
        EnableDlgItem(hDlg, IDC_CONNECTION_WIZARD, FALSE);
    }
}

VOID FixAutodialSettings(HWND hDlg, PCONNINFO pConn)
{
    // Find default connectoid
    DWORD dwSize = RAS_MaxEntryName + 1;
    if(FALSE == InternetQueryOption(NULL, INTERNET_OPTION_AUTODIAL_CONNECTION, pConn->szEntryName, &dwSize))
    {
        *pConn->szEntryName = 0;
    }

    // populate connectoids, will do the right thing with the default read above
    PopulateRasEntries(hDlg, pConn);

    // fix autodial radio buttons
    int iSel;
    DWORD dwAutodial;

    dwSize = sizeof(DWORD);
    if(FALSE == InternetQueryOption(NULL, INTERNET_OPTION_AUTODIAL_MODE, &dwAutodial, &dwSize))
    {
        dwAutodial = AUTODIAL_MODE_NEVER;
    }

    switch(dwAutodial)
    {
    case AUTODIAL_MODE_ALWAYS:
        iSel = IDC_DIALUP;
        break;
    case AUTODIAL_MODE_NO_NETWORK_PRESENT:
        iSel = IDC_DIALUP_ON_NONET;
        break;
    default :
        iSel = IDC_DIALUP_NEVER;
        break;
    } /* switch */
    CheckRadioButton(hDlg, IDC_DIALUP_NEVER, IDC_DIALUP, iSel);

    // enable appropriate controls
    EnableConnectionControls(hDlg, pConn, TRUE);
}


BOOL ConnectionDlgInit(HWND hDlg, PCONNINFO pConn)
{
    BOOL        fProxy = FALSE;
    BOOL        fDial = FALSE;
    HIMAGELIST  himl;
    HICON       hIcon;

    // Get platform - we need this as there's no security check on NT.
    OSVERSIONINFOA osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA(&osvi);

    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) 
    {
        g_fWin95 = FALSE;

        if(osvi.dwMajorVersion > 4)
        {
            g_fWin2K = TRUE;
        }
    }
    else
    {
        if(osvi.dwMinorVersion >= 90)
        {
            g_fMillennium = TRUE;
        }
    }

    // load ras (success checked later - see dwRNARefCount in EnableConnectionControls
    LoadRNADll();

    // create image list for tree view
    himl = ImageList_Create(BITMAP_WIDTH, BITMAP_HEIGHT, ILC_COLOR | ILC_MASK, CONN_BITMAPS, 4 );
    hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_LAN));
    ImageList_AddIcon(himl, hIcon);
    hIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_PHONE));
    ImageList_AddIcon(himl, hIcon);

    TreeView_SetImageList(GetDlgItem(hDlg, IDC_CONN_LIST), himl, TVSIL_NORMAL);

    // populate and configure autodial settings
    FixAutodialSettings(hDlg, pConn);

    // fix security check
    if(g_fWin95)
    {
        RegEntry re(REGSTR_PATH_INTERNETSETTINGS,HKEY_CURRENT_USER);
        if (re.GetError() == ERROR_SUCCESS)
        {
            if(re.GetNumber(REGSTR_VAL_ENABLESECURITYCHECK,0))
            {
                CheckDlgButton(hDlg, IDC_ENABLE_SECURITY, TRUE);
            }
        }
    }
    else
    {
        // no security check on NT so hide check box
        ShowWindow(GetDlgItem(hDlg, IDC_ENABLE_SECURITY), SW_HIDE);
    }

    if (!IsConnSharingAvail())
        ShowWindow(GetDlgItem(hDlg, IDC_CON_SHARING), SW_HIDE);

    // disable wizard button if for some reason ICW cannot be JITed in
    DWORD dwRes = JitFeature(hDlg, clsidFeatureICW, TRUE);
    if(JIT_NOT_AVAILABLE == dwRes) {
        // can never get ICW so grey button
        EnableWindow(GetDlgItem(hDlg, IDC_CONNECTION_WIZARD), FALSE);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//
//        NAME:           LoadRNADll
//
//        SYNOPSIS:       Loads RNA dll if not already loaded and obtains pointers
//                        for function addresses.
//
//        NOTES:          Maintains a reference count so we know when to unload
//
///////////////////////////////////////////////////////////////////////////

BOOL LoadRNADll(VOID)
{
    // increase reference count
    dwRNARefCount++;

    if (hInstRNADll)
    {
        // already loaded, nothing to do
        return TRUE;
    }

    // Ask wininet if Ras is installed.  Always make this call even if ras
    // dll doesn't load since it also forces wininet to migrate proxy
    // settings if necessary.
    DWORD dwFlags;
    InternetGetConnectedStateExA(&dwFlags, NULL, 0, 0);
    if(0 == (dwFlags & INTERNET_RAS_INSTALLED)) {
        // not installed - none of the functions will work so bail
        dwRNARefCount--;
        return FALSE;
    }

    // get the file name from resource
    TCHAR szDllFilename[SMALL_BUF_LEN+1];
    if (!MLLoadString(IDS_RNADLL_FILENAME,szDllFilename,ARRAYSIZE(szDllFilename))) {
        dwRNARefCount--;
        return FALSE;
    }

    // load the DLL
    hInstRNADll = LoadLibrary(szDllFilename);
    if (!hInstRNADll) {
        dwRNARefCount--;
        return FALSE;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    UINT nIndex;
    for (nIndex = 0;nIndex < NUM_RNAAPI_PROCS;nIndex++)
    {
        if (!(*RasApiList[nIndex].ppFcnPtr = (PVOID) GetProcAddress(hInstRNADll,
            RasApiList[nIndex].pszName)))
        {
            // no longer fatal - no RasDeleteEntry on Win95 gold.
            TraceMsg(TF_GENERAL, "Unable to get address of function %s", RasApiList[nIndex].pszName);

//          UnloadRNADll();
//          return FALSE;
        }
    }

    if(g_fWin95)
    {
        // make sure we don't use any W versions that may be around on Win9x.
        // They'll almost certainly be stubs.
        lpRasEditPhonebookEntryW   = NULL;
        lpRasEnumEntriesW          = NULL;
        lpRasDeleteEntryW          = NULL;
        lpRasGetEntryDialParamsW   = NULL;
        lpRasSetEntryDialParamsW   = NULL;
        lpRasGetEntryPropertiesW   = NULL;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//        NAME:           UnloadRNADll
//
//        SYNOPSIS:       Decrements RNA dll reference count and unloads it if
//                        zero
//
/////////////////////////////////////////////////////////////////////////////

VOID UnloadRNADll(VOID)
{
    // decrease reference count
    if (dwRNARefCount)
        dwRNARefCount --;

    // unload DLL if reference count hits zero
    if (!dwRNARefCount && hInstRNADll)
    {

        // set function pointers to NULL
        UINT nIndex;
        for (nIndex = 0;nIndex < NUM_RNAAPI_PROCS;nIndex++)
            *RasApiList[nIndex].ppFcnPtr = NULL;

        // free the library
        FreeLibrary(hInstRNADll);
        hInstRNADll = NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//                           Dialup Dialog ie modem settings
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define W2KRASENTRYW struct tagW2KRASENTRYW
W2KRASENTRYW
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    WCHAR       szScript[ MAX_PATH ];
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    DWORD       dwIdleDisconnectSeconds;
    DWORD       dwType;
    DWORD       dwEncryptionType;
    DWORD       dwCustomAuthKey;
    GUID        guidId;
    WCHAR       szCustomDialDll[MAX_PATH];
    DWORD       dwVpnStrategy;
};


BOOL GetConnectoidInfo(HWND hDlg, LPTSTR pszEntryName)
{
    BOOL    fPassword = FALSE;

    if(g_fWin2K && lpRasGetEntryPropertiesW)
    {
        W2KRASENTRYW    re[2];
        DWORD           dwSize;

        // get props for this connectoid and see if it has a custom dial dll
        re[0].dwSize = sizeof(W2KRASENTRYW);
        dwSize = sizeof(re);
        if(ERROR_SUCCESS == (lpRasGetEntryPropertiesW)(NULL, pszEntryName,
                    (LPRASENTRYW)re, &dwSize, NULL, NULL))
        {
            if(0 != re[0].szCustomDialDll[0])
            {
                // Win2K handler exists - flag that we need to grey out
                // credential fields
                return TRUE;
            }
        }
    }
    else
    {
        // on down level platforms, check registry for cdh
        TCHAR   szTemp[MAX_PATH];

        GetConnKey(pszEntryName, szTemp, MAX_PATH);
        RegEntry re(szTemp, HKEY_CURRENT_USER);
        if(ERROR_SUCCESS == re.GetError())
        {
            if(re.GetString(REGSTR_VAL_AUTODIALDLLNAME, szTemp, MAX_PATH) && *szTemp)
            {
                // CDH exists - flag that we need to grey credentials
                return TRUE;
            }
        }
    }

    if(lpRasGetEntryDialParamsW)
    {
        RASDIALPARAMSW params;
        WCHAR  *pszUser = L"", *pszPassword = L"", *pszDomain = L"";

        memset(&params, 0, sizeof(params));
        params.dwSize = sizeof(params);

        StrCpyN(params.szEntryName, pszEntryName, RAS_MaxEntryName);
        if(ERROR_SUCCESS == (lpRasGetEntryDialParamsW)(NULL, (LPRASDIALPARAMSW)&params, &fPassword))
        {
            pszUser = params.szUserName;
            if(' ' != params.szDomain[0] || IsNTSPx(TRUE, 4, 6))  // NT4SP6 or greater?
                pszDomain = params.szDomain;
            if(fPassword)
                pszPassword = params.szPassword;
        }

        SetWindowText(GetDlgItem(hDlg, IDC_USER), pszUser);
        SetWindowText(GetDlgItem(hDlg, IDC_DOMAIN), pszDomain);
        SetWindowText(GetDlgItem(hDlg, IDC_PASSWORD), pszPassword);
    }
    else if(lpRasGetEntryDialParamsA)
    {
        RASDIALPARAMSA  params;
        CHAR            *pszUser = "", *pszPassword = "", *pszDomain = "";

        memset(&params, 0, sizeof(params));
        params.dwSize = sizeof(params);
        SHUnicodeToAnsi(pszEntryName, params.szEntryName, ARRAYSIZE(params.szEntryName));

        if(ERROR_SUCCESS == (lpRasGetEntryDialParamsA)(NULL, &params, &fPassword))
        {
            pszUser = params.szUserName;
            if(' ' != params.szDomain[0] || IsNTSPx(TRUE, 4, 6))  // NT4SP6 or greater?
                pszDomain = params.szDomain;
            if(fPassword)
                pszPassword = params.szPassword;
        }

        SetWindowTextA(GetDlgItem(hDlg, IDC_USER), pszUser);
        SetWindowTextA(GetDlgItem(hDlg, IDC_DOMAIN), pszDomain);
        SetWindowTextA(GetDlgItem(hDlg, IDC_PASSWORD), pszPassword);
    }

    return FALSE;
}

#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL                 0x00400000L // Right to left mirroring
#else
#error "WS_EX_LAYOUTRTL is already defined in winuser.h"
#endif // WS_EX_LAYOUTRTL

///////////////////////////////////////////////////////////////////
//
// NAME:       FixDialogForLan
//
// SYNOPSIS:   Remove dialing section of dialog box
//
///////////////////////////////////////////////////////////////////
void FixDialogForLan(HWND hDlg)
{
    RECT rectParent, rectDial, rectNet, rectCur;
    POINT pt;
    int i;

    static int iHideIDs[] = {
        IDC_GRP_DIAL, IDC_RAS_SETTINGS, IDC_TX_USER, IDC_USER, IDC_TX_PASSWORD,
        IDC_PASSWORD, IDC_TX_DOMAIN, IDC_DOMAIN, IDC_DIAL_ADVANCED,
        IDC_DONT_USE_CONNECTION
      };
#define NUM_HIDE (sizeof(iHideIDs) / sizeof(int))

    static int iMoveIDs[] = {
        IDCANCEL, IDOK
      };
#define NUM_MOVE (sizeof(iMoveIDs) / sizeof(int))

    // hide relevant windows
    for(i=0; i<NUM_HIDE; i++) {
        ShowWindow(GetDlgItem(hDlg, iHideIDs[i]), SW_HIDE);
    }

    // move relevant windows (yuck)
    GetWindowRect(hDlg, &rectParent);
    GetWindowRect(GetDlgItem(hDlg, IDC_GRP_DIAL), &rectDial);
    GetWindowRect(GetDlgItem(hDlg, IDC_GRP_PROXY), &rectNet);

    for(i=0; i<NUM_MOVE; i++) {
        GetWindowRect(GetDlgItem(hDlg, iMoveIDs[i]), &rectCur);
        pt.x = (GetWindowLong(hDlg, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ? rectCur.right : rectCur.left;
        pt.y = rectCur.top;
        ScreenToClient(hDlg, &pt);
        MoveWindow(GetDlgItem(hDlg, iMoveIDs[i]), pt.x,
            pt.y - (rectDial.bottom - rectNet.bottom),
            rectCur.right - rectCur.left,
            rectCur.bottom - rectCur.top,
            TRUE);
    }

    // adjust dialog box size
    MoveWindow(hDlg, rectParent.left, rectParent.top,
        rectParent.right - rectParent.left,
        rectParent.bottom - rectParent.top - (rectDial.bottom - rectNet.bottom),
        TRUE);
}

///////////////////////////////////////////////////////////////////
//
// NAME:       DialupDlgInit
//
// SYNOPSIS:   Does initalization for dialup dialog
//
////////////////////////////////////////////////////////////////////

BOOL DialupDlgInit(HWND hDlg, LPTSTR pszConnectoid)
{
    PDIALINFO pDI;
    TCHAR   szTemp[MAX_PATH], szSettings[64];
    DWORD   dwIEAK = 0, cb;

    // set up dailinfo struct
    pDI = new DIALINFO;
    if(NULL == pDI)
        return FALSE;
    memset(pDI, 0, sizeof(DIALINFO));  // new already zero init?
#ifndef UNIX
    pDI->pszConnectoid = pszConnectoid;
#else
    // Can't pass lparam from PSheet because we put dialup dialog directly
    // on the tab.
    pszConnectoid = TEXT("");
    pDI->pszConnectoid = pDI->szEntryName;

#endif
    SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pDI);

    // Fix window title
    if(0 == *(pDI->pszConnectoid)) {
        if (MLLoadString(IDS_LAN_SETTINGSPROXY, szTemp, MAX_PATH))
        {
            SetDlgItemText(hDlg, IDC_MANUAL, szTemp);
        }
        MLLoadString(IDS_LAN_SETTINGS, szTemp, MAX_PATH);
    } else {
        MLLoadString(IDS_SETTINGS, szSettings, 64);
        wnsprintf(szTemp, ARRAYSIZE(szTemp), TEXT("%s %s"), pDI->pszConnectoid, szSettings);
    }
    SetWindowText(hDlg, szTemp);

#ifndef UNIX
    // Different stuff if we're editing a connectoid vs. lan settings
    if(NULL == pszConnectoid || 0 == *pszConnectoid) {
        // remove dialing goo from dialog
        FixDialogForLan(hDlg);
    } else {
        // fill in username/password/domain
        pDI->proxy.fCustomHandler = GetConnectoidInfo(hDlg, pszConnectoid);
    }
#endif

    // hide advanced button for autoconfig info if IEAK restriction is not set

    cb = sizeof(dwIEAK);
    if ((SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_INETCPL_RESTRICTIONS, REGSTR_VAL_INETCPL_IEAK,
        NULL, (LPVOID)&dwIEAK, &cb) != ERROR_SUCCESS) || !dwIEAK)
        ShowWindow(GetDlgItem(hDlg, IDC_AUTOCNFG_ADVANCED), SW_HIDE);

    // hide advanced button on millennium
    if(g_fMillennium)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_DIAL_ADVANCED), SW_HIDE);
        EnableWindow(GetDlgItem(hDlg, IDC_DIAL_ADVANCED), FALSE);
    }

    //
    // Read proxy and autoconfig settings for this connection
    //
    INTERNET_PER_CONN_OPTION_LIST list;
    DWORD dwBufSize = sizeof(list);

    list.pszConnection = (pszConnectoid && *pszConnectoid) ? pszConnectoid : NULL;
    list.dwSize = sizeof(list);
    list.dwOptionCount = 4;
    list.pOptions = new INTERNET_PER_CONN_OPTION[4];
    if(NULL == list.pOptions)
    {
        return FALSE;
    }

    list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    list.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

    if(FALSE == InternetQueryOption(NULL,
            INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufSize))
    {
        delete [] list.pOptions;
        return FALSE;
    }

    //
    // move options to pDI struct
    //
    pDI->proxy.fEnable = (list.pOptions[0].Value.dwValue & PROXY_TYPE_PROXY);
    if(list.pOptions[1].Value.pszValue)
    {
        StrCpyN(pDI->proxy.szProxy, list.pOptions[1].Value.pszValue, MAX_URL_STRING);
        GlobalFree(list.pOptions[1].Value.pszValue);
        list.pOptions[1].Value.pszValue = NULL;
    }
    if(list.pOptions[2].Value.pszValue)
    {
        StrCpyN(pDI->proxy.szOverride, list.pOptions[2].Value.pszValue, MAX_URL_STRING);
        GlobalFree(list.pOptions[2].Value.pszValue);
        list.pOptions[2].Value.pszValue = NULL;
    }

    //
    // fill in dialog fields
    //

    // proxy enable
    if(pDI->proxy.fEnable)
    {
        CheckDlgButton(hDlg, IDC_MANUAL, TRUE);
    }

    // autoconfig enable and url
    if(list.pOptions[0].Value.dwValue & PROXY_TYPE_AUTO_PROXY_URL)
    {
        CheckDlgButton(hDlg, IDC_CONFIGSCRIPT, TRUE);
    }
    if(list.pOptions[3].Value.pszValue)
    {
        SetWindowText(GetDlgItem(hDlg, IDC_CONFIG_ADDR), list.pOptions[3].Value.pszValue);
        GlobalFree(list.pOptions[3].Value.pszValue);
        list.pOptions[3].Value.pszValue = NULL;
    }

    // autodiscovery enable
    if(list.pOptions[0].Value.dwValue & PROXY_TYPE_AUTO_DETECT)
    {
        CheckDlgButton(hDlg, IDC_AUTODISCOVER, TRUE);
    }

    // all done with options list
    delete [] list.pOptions;

    // check enable and override and parse out server and port
    pDI->proxy.fOverrideLocal = RemoveLocalFromExceptionList(pDI->proxy.szOverride);
    CheckDlgButton(hDlg, IDC_PROXY_ENABLE, pDI->proxy.fEnable);
    CheckDlgButton(hDlg, IDC_PROXY_OMIT_LOCAL_ADDRESSES, pDI->proxy.fOverrideLocal);
    PopulateProxyControls(hDlg, &pDI->proxy, TRUE);

    return TRUE;
}

///////////////////////////////////////////////////////////////////
//
// NAME:       DialupDlgOk
//
// SYNOPSIS:   Apply settings for dial up dialog box
//
////////////////////////////////////////////////////////////////////

BOOL DialupDlgOk(HWND hDlg, PDIALINFO pDI)
{
    DWORD   dwValue = 0;

    //
    // Save proxy settings
    //
    INTERNET_PER_CONN_OPTION_LIST list;
    DWORD   dwBufSize = sizeof(list);
    DWORD   dwOptions = 2;              // always save FLAGS & DISCOVERY_FLAGS
    TCHAR   szAutoConfig[MAX_URL_STRING];
    
    list.pszConnection = (pDI->pszConnectoid && *pDI->pszConnectoid) ? pDI->pszConnectoid : NULL;
    list.dwSize = sizeof(list);
    list.dwOptionCount = 1;
    list.pOptions = new INTERNET_PER_CONN_OPTION[5];
    if(NULL == list.pOptions)
    {
        return FALSE;
    }

    list.pOptions[0].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;

    //
    // Query autodiscover flags - we just need to set one bit in there
    //
    if(FALSE == InternetQueryOption(NULL,
            INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufSize))
    {
        delete [] list.pOptions;
        return FALSE;
    }

    //
    // save off all other options
    //
    list.pOptions[1].dwOption = INTERNET_PER_CONN_FLAGS;
    list.pOptions[1].Value.dwValue = PROXY_TYPE_DIRECT;

    //
    // save proxy settings
    //
    GetProxyInfo(hDlg, pDI);

    if(pDI->proxy.fEnable)
    {
        list.pOptions[1].Value.dwValue |= PROXY_TYPE_PROXY;
    }

    list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    list.pOptions[2].Value.pszValue = pDI->proxy.szProxy;
    list.pOptions[3].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    list.pOptions[3].Value.pszValue = pDI->proxy.szOverride;

    dwOptions += 2;

    //
    // save autodetect
    //
    if(IsDlgButtonChecked(hDlg, IDC_AUTODISCOVER))
    {
        list.pOptions[1].Value.dwValue |= PROXY_TYPE_AUTO_DETECT;
        if(pDI->fClickedAutodetect)
        {
            list.pOptions[0].Value.dwValue |= AUTO_PROXY_FLAG_USER_SET;
        }
    }
    else
    {
        list.pOptions[0].Value.dwValue &= ~AUTO_PROXY_FLAG_DETECTION_RUN;
    }

    //
    // save autoconfig
    //
    if(IsDlgButtonChecked(hDlg, IDC_CONFIGSCRIPT) &&
       GetWindowText(GetDlgItem(hDlg, IDC_CONFIG_ADDR), szAutoConfig, MAX_URL_STRING))
    {
        list.pOptions[1].Value.dwValue |= PROXY_TYPE_AUTO_PROXY_URL;
        list.pOptions[dwOptions].Value.pszValue = szAutoConfig;
        list.pOptions[dwOptions].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
        dwOptions++;
    }

    // update wininet
    list.dwOptionCount = dwOptions;
    InternetSetOption(NULL,
            INTERNET_OPTION_PER_CONNECTION_OPTION, &list, dwBufSize);

    // tell wininet that the proxy info has changed
    InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

    // all done with options list
    delete [] list.pOptions;

    // all done if we're editing lan settings
    if(NULL == pDI->pszConnectoid || 0 == *pDI->pszConnectoid)
        return TRUE;

    // no credentials to store if we have a w2k custom handler
    if(pDI->proxy.fCustomHandler)
    {
        return TRUE;
    }

    //
    // save connectoid information - use wide version if possible
    //
    BOOL            fDeletePassword = FALSE;

    if(lpRasSetEntryDialParamsW)
    {
        RASDIALPARAMSW  params;

        memset(&params, 0, sizeof(RASDIALPARAMSW));
        params.dwSize = sizeof(RASDIALPARAMSW);
        StrCpyN(params.szEntryName, pDI->pszConnectoid, RAS_MaxEntryName+1);
        GetWindowText(GetDlgItem(hDlg, IDC_USER), params.szUserName, UNLEN);
        GetWindowText(GetDlgItem(hDlg, IDC_PASSWORD), params.szPassword, PWLEN);
        if(0 == params.szPassword[0])
            fDeletePassword = TRUE;
        GetWindowText(GetDlgItem(hDlg, IDC_DOMAIN), params.szDomain, DNLEN);
        if(0 == params.szDomain[0] && !IsNTSPx(TRUE, 4, 6)) {    // NT4SP6 or greater?
            // user wants empty domain
            params.szDomain[0] = TEXT(' ');
        }
        (lpRasSetEntryDialParamsW)(NULL, &params, fDeletePassword);

    }
    else if(lpRasSetEntryDialParamsA)
    {
        RASDIALPARAMSA  params;

        memset(&params, 0, sizeof(RASDIALPARAMSA));
        params.dwSize = sizeof(RASDIALPARAMSA);
        SHUnicodeToAnsi(pDI->pszConnectoid, params.szEntryName, ARRAYSIZE(params.szEntryName));
        GetWindowTextA(GetDlgItem(hDlg, IDC_USER), params.szUserName, UNLEN);
        GetWindowTextA(GetDlgItem(hDlg, IDC_PASSWORD), params.szPassword, PWLEN);
        if(0 == params.szPassword[0])
            fDeletePassword = TRUE;
        GetWindowTextA(GetDlgItem(hDlg, IDC_DOMAIN), params.szDomain, DNLEN);
        if(0 == params.szDomain[0] && !IsNTSPx(TRUE, 4, 6)) {      // NT4SP6 or greater?
            // user wants empty domain
            params.szDomain[0] = TEXT(' ');
        }
        (lpRasSetEntryDialParamsA)(NULL, &params, fDeletePassword);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////
//
// NAME:       DialupDlgProc
//
// SYNOPSIS:   Dialog proc for dial up dialog
//
////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK DialupDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    PDIALINFO pDI = (PDIALINFO)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (uMsg) {

        case WM_INITDIALOG:
            ASSERT(lParam);
            DialupDlgInit(hDlg, (LPTSTR)lParam);
            return FALSE;

        case WM_DESTROY:
            delete pDI;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
            case IDC_AUTODISCOVER:
                pDI->fClickedAutodetect = TRUE;
                break;
            case IDC_AUTOCNFG_ADVANCED:
                if(GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
                    break;
                // show advanced dialog box
                DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_AUTOCNFG_SETTINGS), hDlg,
                    AdvAutocnfgDlgProc, (LPARAM) pDI->pszConnectoid);
                break;

            case IDC_PROXY_ADVANCED:
                if(GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
                    break;

                GetProxyInfo(hDlg, pDI);

                // remove local so it doesn't show up in advanced dialog
                RemoveLocalFromExceptionList(pDI->proxy.szOverride);

                // show advanced dialog box
                if (DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_PROXY_SETTINGS), hDlg,
                                ProxyDlgProc, (LPARAM) &pDI->proxy) == IDOK)
                {
                    if(FALSE == pDI->proxy.fEnable)
                    {
                        // user disabled proxy in advanced dialog
                        CheckDlgButton(hDlg, IDC_MANUAL, FALSE);
                    }
                    PopulateProxyControls(hDlg, &pDI->proxy, TRUE);
                }
                break;

            case IDC_RAS_SETTINGS:
                if (g_fWin95) //jeffsi
                {
                    if(lpRasEditPhonebookEntryW)
                    {
                        (lpRasEditPhonebookEntryW)(hDlg, NULL, pDI->pszConnectoid);
                    }
                    else if(lpRasEditPhonebookEntryA)
                    {
                        CHAR  szConnectoid[MAX_PATH];
                        SHUnicodeToAnsi(pDI->pszConnectoid, szConnectoid, ARRAYSIZE(szConnectoid));
                        (lpRasEditPhonebookEntryA)(hDlg, NULL, szConnectoid);
                    }  
                }
                else
                {
                    PFRED pfred = NULL;
                    HMODULE hRasDlg = LoadLibrary(TEXT("rasdlg.dll"));
                    RASENTRYDLG info;

                    if (!hRasDlg)
                    {
                        break;
                    }
#ifdef UNICODE
                    pfred = (PFRED)GetProcAddress(hRasDlg, "RasEntryDlgW");
#else
                    pfred = (PFRED)GetProcAddress(hRasDlg, "RasEntryDlgA");
#endif
                    if (!pfred)
                    {
                        FreeLibrary(hRasDlg);
                        break;
                    }

                    memset(&info, 0, sizeof(RASENTRYDLG));
                    info.dwSize = sizeof(RASENTRYDLG);
                    info.hwndOwner = hDlg;

#ifdef UNICODE
                    (pfred)(NULL, pDI->pszConnectoid, &info);
#else
                    CHAR szConnectoid[MAX_PATH];
                    SHUnicodeToAnsi(pDI->pszConnectoid, szConnectoid, ARRAYSIZE(szConnectoid));
                    (pfred)(NULL, szConnectoid, &info);
#endif

                    FreeLibrary(hRasDlg);
                }
                break;
                
            case IDC_DIAL_ADVANCED:
                DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_DIALUP_ADVANCED), hDlg,
                    AdvDialupDlgProc, (LPARAM) pDI->pszConnectoid);
                break;

            case IDC_MANUAL:
                if(IsDlgButtonChecked(hDlg, IDC_MANUAL))
                {
                    pDI->proxy.fEnable = TRUE;
                    SetFocus(GetDlgItem(hDlg, IDC_PROXY_ADDR));
                    SendMessage(GetDlgItem(hDlg, IDC_PROXY_ADDR), EM_SETSEL, 0, -1);
                }
                else
                {
                    pDI->proxy.fEnable = FALSE;
                }
                PopulateProxyControls(hDlg, &pDI->proxy, FALSE);
#ifdef UNIX
                ENABLEAPPLY(hDlg);
#endif
                break;

            case IDC_CONFIGSCRIPT:
                if(IsDlgButtonChecked(hDlg, IDC_CONFIGSCRIPT))
                {
                    // set focus to config script url
                    SetFocus(GetDlgItem(hDlg, IDC_CONFIG_ADDR));
                    SendMessage(GetDlgItem(hDlg, IDC_CONFIG_ADDR), EM_SETSEL, 0, -1);
                }
                PopulateProxyControls(hDlg, &pDI->proxy, FALSE);
#ifdef UNIX
                ENABLEAPPLY(hDlg);
#endif
                break;


#ifdef UNIX
            case IDC_AUTODISCOVER:
            case IDC_PROXY_OMIT_LOCAL_ADDRESSES:
                ENABLEAPPLY(hDlg);
                break;
            case IDC_PROXY_PORT:
            case IDC_PROXY_ADDR:
            case IDC_CONFIG_ADDR:
                switch (HIWORD(wParam))
                {
                    case EN_CHANGE:
                        ENABLEAPPLY(hDlg);
                        break;
                }
                break;
#endif
            case IDC_DONT_USE_CONNECTION:
                PopulateProxyControls(hDlg, &pDI->proxy, FALSE);
                break;

            case IDOK:
                if(FALSE == DialupDlgOk(hDlg, pDI))
                    // something is wrong... don't exit yet
                    break;

                // fall through
            case IDCANCEL:
                return EndDialog(hDlg, 0);
            }
            break;

        case WM_HELP:      // F1
            ResWinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                       HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            ResWinHelp((HWND)wParam, IDS_HELPFILE,
                       HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
#ifdef UNIX
        case WM_NOTIFY:
        {
            NMHDR * lpnm = (NMHDR *) lParam;
            switch (lpnm->code)
            {
                case PSN_APPLY:
                {
            if(FALSE == DialupDlgOk(hDlg, pDI))
                // something is wrong... don't exit yet
                break;
                // fall through
                }
        }
    }
#endif
    }

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//                  Advanced dial-up settings dialog
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
//
// NAME:       AdvDialupDlgProc
//
// SYNOPSIS:   Dialog proc for dial up dialog
//
////////////////////////////////////////////////////////////////////

void EnableAdvDialControls(HWND hDlg)
{
    BOOL fIdle      = IsDlgButtonChecked(hDlg, IDC_ENABLE_AUTODISCONNECT);

    // on if we have idle disconnect...
    EnableDlgItem(hDlg, IDC_IDLE_TIMEOUT, fIdle);
    EnableDlgItem(hDlg, IDC_IDLE_SPIN, fIdle);
}

BOOL AdvDialupDlgInit(HWND hDlg, LPTSTR pszConnectoid)
{
    TCHAR szTemp[MAX_PATH];
    DWORD dwRedialAttempts, dwRedialInterval, dwAutodisconnectTime;
    BOOL fExit, fDisconnect;

    // save connectoid name
    SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pszConnectoid);

    // figure out our registry key
    GetConnKey(pszConnectoid, szTemp, MAX_PATH);

    // open connectoid or lan settings
    RegEntry reCon(szTemp, HKEY_CURRENT_USER);
    if(ERROR_SUCCESS != reCon.GetError())
        return FALSE;

    //
    // Read autodial / redial stuff
    //
    // We get this stuff from the connectoid if possible.  We assume it's all
    // saved to the connectoid together so if EnableAutodial is present there,
    // read everything from there else read everything from the IE4 settings.
    //
    dwRedialInterval = reCon.GetNumber(REGSTR_VAL_REDIALINTERVAL, DEF_REDIAL_WAIT);
    dwRedialAttempts = reCon.GetNumber(REGSTR_VAL_REDIALATTEMPTS, DEF_REDIAL_TRIES);

    // autodisconnect
    fDisconnect = (BOOL)reCon.GetNumber(REGSTR_VAL_ENABLEAUTODIALDISCONNECT, 0);
    dwAutodisconnectTime = reCon.GetNumber(REGSTR_VAL_DISCONNECTIDLETIME, DEF_AUTODISCONNECT_TIME);
    fExit = (BOOL)reCon.GetNumber(REGSTR_VAL_ENABLEEXITDISCONNECT, 0);

    //
    // Check if the mobile pack is installed and if it is not - then do not have it checked
    //
    DWORD dwRes = JitFeature(hDlg, clsidFeatureMobile, TRUE);
    if(JIT_PRESENT != dwRes)
    {
        fDisconnect = FALSE;
        fExit = FALSE;
        // check to see if offline pack is installed and disable the disconnect
        // options if user has bailed on it
        if(JIT_NOT_AVAILABLE == dwRes) {
            // can't get offline pack so disable options
            CheckDlgButton(hDlg, IDC_ENABLE_AUTODISCONNECT, FALSE);
            CheckDlgButton(hDlg, IDC_EXIT_DISCONNECT, FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ENABLE_AUTODISCONNECT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_TX_AUTODISCONNECT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_EXIT_DISCONNECT), FALSE);
        }
    }

    //
    // Populate controls
    //
    CheckDlgButton(hDlg, IDC_ENABLE_AUTODISCONNECT, fDisconnect);
    CheckDlgButton(hDlg, IDC_EXIT_DISCONNECT, fExit);

    SendDlgItemMessage(hDlg, IDC_IDLE_SPIN, UDM_SETPOS, 0, dwAutodisconnectTime);
    SendDlgItemMessage(hDlg, IDC_CONNECT_SPIN,UDM_SETPOS, 0, dwRedialAttempts);
    SendDlgItemMessage(hDlg, IDC_INTERVAL_SPIN,UDM_SETPOS, 0, dwRedialInterval);

    //
    // Set control limits
    //
    Edit_LimitText(GetDlgItem(hDlg,IDC_IDLE_TIMEOUT), 2);    // limit edit ctrl to 2 chars
    Edit_LimitText(GetDlgItem(hDlg,IDC_IDLE_SPIN), 2);
    Edit_LimitText(GetDlgItem(hDlg,IDC_CONNECT_SPIN), 2);

    // set spin control min/max
    SendDlgItemMessage(hDlg,IDC_IDLE_SPIN,UDM_SETRANGE,0,
                    MAKELPARAM(MAX_AUTODISCONNECT_TIME,MIN_AUTODISCONNECT_TIME));
    SendDlgItemMessage(hDlg,IDC_CONNECT_SPIN,UDM_SETRANGE,0,
                    MAKELPARAM(MAX_REDIAL_TRIES,MIN_REDIAL_TRIES));
    SendDlgItemMessage(hDlg,IDC_INTERVAL_SPIN,UDM_SETRANGE,0,
                    MAKELPARAM(MAX_REDIAL_WAIT,MIN_REDIAL_WAIT));

    // enable controls
    EnableAdvDialControls(hDlg);

    return TRUE;
}

BOOL AdvDialupDlgOk(HWND hDlg, LPTSTR pszConnectoid)
{
    TCHAR szTemp[MAX_PATH];

    GetConnKey(pszConnectoid, szTemp, MAX_PATH);

    // open connectoid or lan settings
    RegEntry reCon(szTemp, HKEY_CURRENT_USER);
    if(ERROR_SUCCESS != reCon.GetError())
        return FALSE;

    // Save autodisconnect values
    BOOL fExit = IsDlgButtonChecked(hDlg,IDC_EXIT_DISCONNECT);
    BOOL fDisconnect = IsDlgButtonChecked(hDlg,IDC_ENABLE_AUTODISCONNECT);

    if(fExit || fDisconnect) {
        // make sure offline pack is installed or this feature won't work.
        DWORD dwRes = JitFeature(hDlg, clsidFeatureMobile, FALSE);
        if(JIT_PRESENT != dwRes) {
            // user doesn't want to download it so turn off autodisconnect
            fExit = FALSE;
            fDisconnect = FALSE;
        }
    }

    reCon.SetValue(REGSTR_VAL_ENABLEAUTODIALDISCONNECT, (DWORD)fDisconnect);
    reCon.SetValue(REGSTR_VAL_ENABLEEXITDISCONNECT, (DWORD)fExit);

    if(fDisconnect)
    {
        // get autodisconnect time from edit control
        // Sundown: coercion to 32b since values are range checked
        DWORD dwAutoDisconnectTime = (DWORD) SendDlgItemMessage(hDlg, IDC_IDLE_SPIN,
                                                                UDM_GETPOS,0,0);

        if(HIWORD(dwAutoDisconnectTime)) {
            MsgBox(hDlg, IDS_INVALID_AUTODISCONNECT_TIME, 0, MB_OK);

            // decide if it's too big or too small and fix it appropriately
            if(GetDlgItemInt(hDlg, IDC_IDLE_TIMEOUT, NULL, FALSE) < MIN_AUTODISCONNECT_TIME)
                dwAutoDisconnectTime = MIN_AUTODISCONNECT_TIME;
            else
                dwAutoDisconnectTime = MAX_AUTODISCONNECT_TIME;
            SendDlgItemMessage(hDlg, IDC_IDLE_SPIN, UDM_SETPOS, 0, dwAutoDisconnectTime);
            SetFocus(GetDlgItem(hDlg, IDC_IDLE_TIMEOUT));
            return FALSE;
        }

        // save it to registry
        reCon.SetValue(REGSTR_VAL_DISCONNECTIDLETIME, dwAutoDisconnectTime);

        // also save this value to MSN autodisconnect value, to
        // avoid confusion.  At some point in the future we'll
        // combine our UI...
        RegEntry reMSN(REGSTR_PATH_MOSDISCONNECT,HKEY_CURRENT_USER);
        if (reMSN.GetError() == ERROR_SUCCESS)
        {
            reMSN.SetValue(REGSTR_VAL_MOSDISCONNECT,dwAutoDisconnectTime);
        }
    }

    // save redial info
    DWORD_PTR dwRedialTry = SendDlgItemMessage(hDlg, IDC_CONNECT_SPIN, UDM_GETPOS, 0, 0);
    DWORD_PTR dwRedialWait = SendDlgItemMessage(hDlg, IDC_INTERVAL_SPIN, UDM_GETPOS, 0, 0);

    if(HIWORD(dwRedialTry)) {
        MsgBox(hDlg, IDS_INVALID_REDIAL_ATTEMPTS, 0, MB_OK);
        if(GetDlgItemInt(hDlg, IDC_CONNECT, NULL, FALSE) < MIN_REDIAL_TRIES)
            dwRedialTry = MIN_REDIAL_TRIES;
        else
            dwRedialTry = MAX_REDIAL_TRIES;
        SendDlgItemMessage(hDlg, IDC_CONNECT_SPIN, UDM_SETPOS, 0, dwRedialTry);
        SetFocus(GetDlgItem(hDlg, IDC_CONNECT));
        return FALSE;
    }

    if(HIWORD(dwRedialWait)) {
        MsgBox(hDlg, IDS_INVALID_REDIAL_WAIT, 0, MB_OK);
        if(GetDlgItemInt(hDlg, IDC_INTERVAL, NULL, FALSE) < MIN_REDIAL_WAIT)
            dwRedialWait = MIN_REDIAL_WAIT;
        else
            dwRedialWait = MAX_REDIAL_WAIT;
        SendDlgItemMessage(hDlg, IDC_INTERVAL_SPIN, UDM_SETPOS, 0, dwRedialWait);
        SetFocus(GetDlgItem(hDlg, IDC_INTERVAL));
        return FALSE;
    }

    reCon.SetValue(REGSTR_VAL_REDIALATTEMPTS, (DWORD) dwRedialTry);
    reCon.SetValue(REGSTR_VAL_REDIALINTERVAL, (DWORD) dwRedialWait);

    return TRUE;
}

INT_PTR CALLBACK AdvDialupDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    LPTSTR pszConn = (LPTSTR) GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (uMsg) {

        case WM_INITDIALOG:
            ASSERT(lParam);
            AdvDialupDlgInit(hDlg, (LPTSTR)lParam);
            return FALSE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
            case IDC_ENABLE_AUTODISCONNECT:
                EnableAdvDialControls(hDlg);
                break;

            case IDOK:
                if(FALSE == AdvDialupDlgOk(hDlg, pszConn))
                    // something is wrong... don't exit yet
                    break;

                // fall through
            case IDCANCEL:
                return EndDialog(hDlg, 0);
            }
            break;

        case WM_HELP:      // F1
            ResWinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                       HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            ResWinHelp((HWND)wParam, IDS_HELPFILE,
                       HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
    }

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//                  Advanced autoconfig settings dialog (only used by IEAK)
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL AdvAutocnfgDlgInit(HWND hDlg, LPTSTR pszConnectoid)
{
    INTERNET_PER_CONN_OPTION_LIST list;
    DWORD dwBufSize = sizeof(list);

    // save connectoid name
    SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pszConnectoid);

    list.pszConnection = (pszConnectoid && *pszConnectoid) ? pszConnectoid : NULL;
    list.dwSize = sizeof(list);
    list.dwOptionCount = 3;
    list.pOptions = new INTERNET_PER_CONN_OPTION[3];
    if(NULL == list.pOptions)
    {
        return FALSE;
    }

    list.pOptions[0].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
    list.pOptions[1].dwOption = INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS;
    list.pOptions[2].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;

    if(FALSE == InternetQueryOption(NULL,
            INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufSize))
    {
        delete [] list.pOptions;
        return FALSE;
    }

    // autoproxy url (js)
    if(list.pOptions[0].Value.pszValue)
    {
        SetWindowText(GetDlgItem(hDlg, IDC_CONFIGJS_ADDR), list.pOptions[0].Value.pszValue);
    }

    
    // autoconfig timer interval
    if(list.pOptions[1].Value.dwValue)
    {
        TCHAR szTimerInterval[16];

        wsprintf(szTimerInterval, TEXT("%d"), list.pOptions[1].Value.dwValue);
        SetWindowText(GetDlgItem(hDlg, IDC_CONFIGTIMER), szTimerInterval);
    }

    // autoconfig optimization
    CheckDlgButton(hDlg, IDC_CONFIGOPTIMIZE, 
        (list.pOptions[2].Value.dwValue & AUTO_PROXY_FLAG_CACHE_INIT_RUN ) ? BST_CHECKED : BST_UNCHECKED);

    // all done with options list
    if (list.pOptions[0].Value.pszValue)
    {
        GlobalFree(list.pOptions[0].Value.pszValue);
    }
    delete [] list.pOptions;

    return TRUE;
}

BOOL AdvAutocnfgDlgOk(HWND hDlg, LPTSTR pszConnectoid)
{
    INTERNET_PER_CONN_OPTION_LIST list;
    DWORD   dwBufSize = sizeof(list);
    TCHAR    szAutoconfig[MAX_URL_STRING];
    TCHAR   szTimerInterval[16];

    list.pszConnection = (pszConnectoid && *pszConnectoid) ? pszConnectoid : NULL;
    list.dwSize = sizeof(list);
    list.dwOptionCount = 1;
    list.pOptions = new INTERNET_PER_CONN_OPTION[3];
    if(NULL == list.pOptions)
    {
        return FALSE;
    }

    list.pOptions[0].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;
    //
    // Query autodiscover flags - we just need to set one bit in there
    //
    if(FALSE == InternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufSize))
    {
        delete [] list.pOptions;
        return FALSE;
    }

    // save autoconfiguration optimization field

    if (IsDlgButtonChecked(hDlg, IDC_CONFIGOPTIMIZE) == BST_CHECKED)
        list.pOptions[0].Value.dwValue |= AUTO_PROXY_FLAG_CACHE_INIT_RUN ;
    else
        list.pOptions[0].Value.dwValue &= ~AUTO_PROXY_FLAG_CACHE_INIT_RUN ;

    //
    // save autoproxy url
    //
    list.pOptions[1].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
    GetWindowText(GetDlgItem(hDlg, IDC_CONFIGJS_ADDR), szAutoconfig, sizeof(szAutoconfig));
    list.pOptions[1].Value.pszValue = szAutoconfig;

    //
    // save autoconfig timer
    //
    list.pOptions[2].dwOption = INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS;
    list.pOptions[2].Value.dwValue = 0;
        
    if(GetWindowText(GetDlgItem(hDlg, IDC_CONFIGTIMER), szTimerInterval, sizeof(szTimerInterval)))
        list.pOptions[2].Value.dwValue = StrToInt(szTimerInterval);
    
    // update wininet
    list.dwOptionCount = 3;
    InternetSetOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, dwBufSize);

    // tell wininet that the proxy info has changed
    InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

    delete [] list.pOptions;

    return TRUE;
}

///////////////////////////////////////////////////////////////////
//
// NAME:       AdvAutocnfgProc
//
// SYNOPSIS:   Dialog proc for autoconfig dialog
//
////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK AdvAutocnfgDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    LPTSTR pszConn = (LPTSTR) GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (uMsg) {

        case WM_INITDIALOG:
            AdvAutocnfgDlgInit(hDlg, (LPTSTR)lParam);
            return FALSE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
            case IDOK:
                if(FALSE == AdvAutocnfgDlgOk(hDlg, pszConn))
                    // something is wrong... don't exit yet
                    break;

                // fall through
            case IDCANCEL:
                return EndDialog(hDlg, 0);
            }
            break;

        case WM_HELP:      // F1
            ResWinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                       HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            ResWinHelp((HWND)wParam, IDS_HELPFILE,
                       HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\debug.cpp ===
#include "inetcplp.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "shellext.ini"
#define SZ_DEBUGSECTION     "inetcpl"
#define SZ_MODULE           "INETCPL"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\dlylddll.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1996               **
//*********************************************************************
//
// DLYLDDLL.H - globals for delay loading of DLLs
//

extern HINSTANCE g_hinstWinInet;
extern HINSTANCE g_hinstCrypt32;

extern HINSTANCE g_hinstCryptui;

extern HINSTANCE g_hinstRatings;
extern const TCHAR c_tszRatingsDLL[];

extern HINSTANCE g_hinstUrlMon;

extern HINSTANCE g_hinstMSHTML;
extern const TCHAR c_tszMSHTMLDLL[];

extern HINSTANCE g_hinstMPR;
extern const TCHAR c_tszMPRDLL[];

extern HINSTANCE g_hinstShdocvw;
extern const TCHAR c_tszShdocvw[];
#define URLSUB_ALL     0xFFFFFFFF

HRESULT URLSubRegQueryA(LPCSTR pszKey, LPCSTR pszValue, BOOL fUseHKCU, LPSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions);

extern HINSTANCE g_hinstOCCache;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\dlylddll.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1996               **
//*********************************************************************
//
// DLYLDDLL.C - uses macros for delay loading of DLLs
//

#include "inetcplp.h"
#include <cryptui.h>

// coded copied from SHDOCVW's dllload.c file

#pragma warning(disable:4229)  // No warnings when modifiers used on data


// Exporting by ordinal is not available on UNIX.
// But we have all these symbols exported because it's UNIX default.
#ifdef UNIX
#define GET_PRIVATE_PROC_ADDRESS(_hinst, _fname, _ord) GetProcAddress(_hinst, #_fname)
#else
#define GET_PRIVATE_PROC_ADDRESS(_hinst, _fname, _ord) GetProcAddress(_hinst, (LPSTR) _ord)
#endif


#define ENSURE_LOADED(_hinst, _dll)   ( _hinst ? TRUE : NULL != (_hinst=LoadLibraryA(#_dll)) )
#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll))   \
    {                                   \
        ASSERT(_hinst); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        ASSERT(_pfn##_fn); \
        if (_pfn##_fn == NULL)      \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll))   \
    {                                   \
        ASSERT((BOOL)_hinst); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        ASSERT((BOOL)_pfn##_fn); \
        if (_pfn##_fn == NULL)      \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }



// For private entrypoints exported by ordinal.
#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll))   \
    {                                   \
        ASSERT(_hinst); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GET_PRIVATE_PROC_ADDRESS(_hinst, _fn, _ord); \
        ASSERT(_pfn##_fn); \
        if (_pfn##_fn == NULL)      \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL)

#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)


#define DELAY_LOAD_VOID_ORD(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll))   \
    {                                   \
        ASSERT((BOOL)_hinst); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) =  GET_PRIVATE_PROC_ADDRESS(_hinst, _fn, _ord); \
        ASSERT((BOOL)_pfn##_fn); \
        if (_pfn##_fn == NULL)      \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }

//--------- wininet.dll -----------------

HINSTANCE g_hinstWinInet = NULL;

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, InternetSetOption, 
           (IN HINTERNET hInternet OPTIONAL,IN DWORD dwOption,IN LPVOID lpBuffer,
            IN DWORD dwBufferLength),
           (hInternet,dwOption,lpBuffer,dwBufferLength));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, InternetQueryOption, 
           (IN HINTERNET hInternet OPTIONAL,IN DWORD dwOption,IN LPVOID lpBuffer,
            IN OUT LPDWORD lpdwBufferLength),
           (hInternet,dwOption,lpBuffer,lpdwBufferLength));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, DWORD, ShowX509EncodedCertificate, 
           (IN HWND    hWndParent,IN LPBYTE  lpCert,IN DWORD   cbCert),
           (hWndParent,lpCert,cbCert));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, DWORD, ParseX509EncodedCertificateForListBoxEntry,
           (IN LPBYTE  lpCert,IN DWORD  cbCert,OUT LPSTR lpszListBoxEntry,IN LPDWORD lpdwListBoxEntry),
           (lpCert,cbCert,lpszListBoxEntry,lpdwListBoxEntry));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, GetUrlCacheConfigInfoA,
           (
            OUT LPINTERNET_CACHE_CONFIG_INFOA lpCacheConfigInfo,
            IN OUT LPDWORD lpdwCacheConfigInfoBufferSize,
            IN DWORD dwFieldControl
           ),
           (lpCacheConfigInfo,lpdwCacheConfigInfoBufferSize,dwFieldControl));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, SetUrlCacheConfigInfoA,
           (
            IN LPINTERNET_CACHE_CONFIG_INFOA lpCacheConfigInfo,
            IN DWORD dwFieldControl
           ),
           (lpCacheConfigInfo,dwFieldControl));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, FreeUrlCacheSpaceA,
           (
            IN LPCSTR lpszCachePath,
            IN DWORD dwSize,
            IN DWORD dwReserved
           ),
           (lpszCachePath,dwSize,dwReserved));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, UpdateUrlCacheContentPath,
           (
            IN LPSTR lpszCachePath
           ),
           (lpszCachePath));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, FindCloseUrlCache,
           (
            IN HANDLE hEnumHandle
           ),
           (hEnumHandle));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, HANDLE, FindFirstUrlCacheEntryA,
           (
            IN     LPCSTR    lpszUrlSearchPattern,
            OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
            IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize
           ),
           (lpszUrlSearchPattern, lpFirstCacheEntryInfo, 
            lpdwFirstCacheEntryInfoBufferSize));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, FindNextUrlCacheEntryA,
           (
            IN     HANDLE    hEnumHandle,
            OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
            IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize
           ),
           (hEnumHandle, lpFirstCacheEntryInfo, 
            lpdwFirstCacheEntryInfoBufferSize));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, DeleteUrlCacheEntryA,
           (
            IN     LPCSTR    lpszUrlName
           ),
           (lpszUrlName));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, HANDLE, FindFirstUrlCacheEntryExA,
           (
            IN     LPCSTR    lpszUrlSearchPattern,
            IN     DWORD     dwFlags,
            IN     DWORD     dwFilter,
            IN     GROUPID   GroupId,
            OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
            IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
            OUT    LPVOID    lpReserved,     // must pass NULL
            IN OUT LPDWORD   pcbReserved2,   // must pass NULL
            IN     LPVOID    lpReserved3     // must pass NULL
           ),
           (lpszUrlSearchPattern, dwFlags, dwFilter, GroupId, lpFirstCacheEntryInfo, 
            lpdwFirstCacheEntryInfoBufferSize, lpReserved, pcbReserved2, lpReserved3));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, FindNextUrlCacheEntryExA,
           (
            IN     HANDLE    hEnumHandle,
            OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
            IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
            OUT    LPVOID    lpReserved,     // must pass NULL
            IN OUT LPDWORD   pcbReserved2,   // must pass NULL
            IN     LPVOID    lpReserved3     // must pass NULL
           ),
           (hEnumHandle, lpFirstCacheEntryInfo, lpdwFirstCacheEntryInfoBufferSize, lpReserved, pcbReserved2, lpReserved3));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, InternetGetConnectedStateExA,
            (
             OUT LPDWORD lpdwFlags,
             IN LPSTR lpszConnectionName,
             IN DWORD dwNameSize,
             IN DWORD dwReserved
            ),
            (lpdwFlags, lpszConnectionName, dwNameSize, dwReserved));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, IncrementUrlCacheHeaderData,
           (
            IN  DWORD nIdx,
            OUT LPDWORD lpdwData
           ),
           (nIdx, lpdwData));

DELAY_LOAD_ORD(g_hinstWinInet, WININET.DLL, BOOL, GetDiskInfoA, 102,
            (
             IN PSTR pszPath, 
             IN OUT PDWORD pdwClusterSize, 
             IN OUT PDWORDLONG pdlAvail, 
             IN OUT PDWORDLONG pdlTotal
            ),
            (pszPath, pdwClusterSize, pdlAvail, pdlTotal));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, DWORD, PrivacyGetZonePreferenceW,
            (
             DWORD      dwZone,
             DWORD      dwType,
             LPDWORD    pdwTemplate,
             LPWSTR     pszBuffer,
             LPDWORD    pdwBufferLength
            ),
            (dwZone, dwType, pdwTemplate, pszBuffer, pdwBufferLength));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, DWORD, PrivacySetZonePreferenceW,
            (
             DWORD      dwZone,
             DWORD      dwType,
             DWORD      dwTemplate,
             LPCWSTR    pszPreference
            ),
            (dwZone, dwType, dwTemplate, pszPreference));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, InternetEnumPerSiteCookieDecisionW,
            (
             OUT    LPWSTR pwszSiteName, 
             IN OUT unsigned long *pcbName, 
             OUT    unsigned long *pdwDecision, 
             IN     unsigned long dwIndex
            ),
            (pwszSiteName, pcbName, pdwDecision, dwIndex));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, InternetClearAllPerSiteCookieDecisions,
           (),
           ());

//BOOLAPI IsDomainLegalCookieDomainW( IN LPCWSTR pwchDomain, IN LPCWSTR pwchFullDomain)

DELAY_LOAD_ORD(g_hinstWinInet, WININET.DLL, BOOL, IsDomainLegalCookieDomainW, 117,
           (
            IN LPCWSTR pwchDomain,
            IN LPCWSTR pwchFullDomain
           ),
           (pwchDomain, pwchFullDomain));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, InternetSetPerSiteCookieDecisionW,
           (
            IN LPCWSTR pwchHostName, 
            DWORD dwDecision
           ),
           (pwchHostName, dwDecision));

//--------- urlmon.dll ------------------

HINSTANCE g_hinstUrlMon = NULL;

DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, UrlMkSetSessionOption,
           (DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD dwReserved),
           (dwOption, pBuffer, dwBufferLength, dwReserved));


DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, CoInternetCreateZoneManager,
           (IServiceProvider *pSP, IInternetZoneManager **ppZM, DWORD dwReserved),
           (pSP, ppZM, dwReserved));

DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, CoInternetCreateSecurityManager,
           (IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved),
           (pSP, ppSM, dwReserved));

DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, CreateURLMoniker,
           (LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk),
           (pMkCtx,szURL,ppmk));

DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, FaultInIEFeature,
            (HWND hWnd, uCLSSPEC *pClassSpec, QUERYCONTEXT *pQuery, DWORD dwFlags),
            (hWnd, pClassSpec, pQuery, dwFlags));

DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, CoInternetParseUrl,
            (LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwFlags, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved),
            (pwzUrl, ParseAction, dwFlags, pszResult, cchResult, pcchResult, dwReserved));


// -------- crypt32.dll ----------------------------


HINSTANCE g_hinstCrypt32 = NULL;

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, HCERTSTORE, CertOpenSystemStoreA,
           (HCRYPTPROV hProv, LPCSTR szSubSystemProtocol),
           (hProv, szSubSystemProtocol));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL , CertCloseStore,
           (IN HCERTSTORE hCertStore, DWORD dwFlags),
           (hCertStore, dwFlags));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertGetEnhancedKeyUsage,
           (IN PCCERT_CONTEXT pCertContext, IN DWORD dwFlags, OUT PCERT_ENHKEY_USAGE pUsage, IN OUT DWORD *pcbUsage),
           (pCertContext, dwFlags, pUsage, pcbUsage));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertSetEnhancedKeyUsage,
           (IN PCCERT_CONTEXT pCertContext, IN PCERT_ENHKEY_USAGE pUsage),
           (pCertContext, pUsage));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertDeleteCertificateFromStore,
           (IN PCCERT_CONTEXT pCertContext),
           (pCertContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertAddEnhancedKeyUsageIdentifier,
           (IN PCCERT_CONTEXT pCertContext, IN LPCSTR pszUsageIdentifier),
           (pCertContext, pszUsageIdentifier));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertRemoveEnhancedKeyUsageIdentifier,
           (IN PCCERT_CONTEXT pCertContext,IN LPCSTR pszUsageIdentifier),
           (pCertContext, pszUsageIdentifier));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL,  PCCERT_CONTEXT, CertFindCertificateInStore,
           (IN HCERTSTORE hCertStore, IN DWORD dwCertEncodingType, IN DWORD dwFindFlags,IN DWORD dwFindType,
            IN const void *pvFindPara, IN PCCERT_CONTEXT pPrevCertContext),
           (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertAddEncodedCertificateToStore,
           (IN HCERTSTORE hCertStore,IN DWORD dwCertEncodingType,IN const BYTE *pbCertEncoded,
            IN DWORD cbCertEncoded,IN DWORD dwAddDisposition, OUT OPTIONAL PCCERT_CONTEXT *ppCertContext),
           (hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL,  BOOL, CertFreeCertificateContext,
           (IN PCCERT_CONTEXT pCertContext),
           (pCertContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertCompareCertificateName,
           (IN DWORD dwCertEncodingType,IN PCERT_NAME_BLOB pCertName1,IN PCERT_NAME_BLOB pCertName2),
           (dwCertEncodingType,pCertName1,pCertName2));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, PCCERT_CONTEXT, CertCreateCertificateContext,
           (IN DWORD dwCertEncodingType, IN const BYTE *pbCertEncoded, IN DWORD cbCertEncoded),
           (dwCertEncodingType,pbCertEncoded,cbCertEncoded));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertAddCertificateContextToStore,
           (IN HCERTSTORE hCertStore,
            IN PCCERT_CONTEXT pCertContext,
            IN DWORD dwAddDisposition,
            OUT OPTIONAL PCCERT_CONTEXT *ppStoreContext),
           (hCertStore,pCertContext,dwAddDisposition,ppStoreContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, PCCERT_CONTEXT, CertEnumCertificatesInStore,
           (IN HCERTSTORE hCertStore,
            IN PCCERT_CONTEXT pPrevCertContext),
           (hCertStore,pPrevCertContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, PFXExportCertStore,
           (HCERTSTORE hStore,
            CRYPT_DATA_BLOB* pPFX,
            LPCWSTR szPassword,
            DWORD   dwFlags),
           (hStore,pPFX, szPassword, dwFlags));


DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, HCERTSTORE, PFXImportCertStore,
           (CRYPT_DATA_BLOB* pPFX,
            LPCWSTR szPassword,
            DWORD   dwFlags),
           (pPFX,szPassword,dwFlags));


DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, HCERTSTORE, CertOpenStore,
           (IN LPCSTR lpszStoreProvider,
            IN DWORD dwEncodingType,
            IN HCRYPTPROV hCryptProv,
            IN DWORD dwFlags,
            IN const void *pvPara),
           (lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvPara));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CryptHashCertificate,
           (IN HCRYPTPROV hCryptProv,
            IN ALG_ID Algid,
            IN DWORD dwFlags,
            IN const BYTE *pbEncoded,
            IN DWORD cbEncoded,
            OUT BYTE *pbComputedHash,
            IN OUT DWORD *pcbComputedHash
           ),
           (hCryptProv,Algid,dwFlags,pbEncoded,cbEncoded,pbComputedHash,pcbComputedHash));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, PCCERT_CONTEXT, CertDuplicateCertificateContext,
           (IN PCCERT_CONTEXT pCertContext),
           (pCertContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertGetCertificateContextProperty,
            (IN PCCERT_CONTEXT pCertContext,
             IN DWORD dwPropId,
             OUT void *pvData,
             IN OUT DWORD *pcbData
            ),
            (pCertContext, dwPropId, pvData, pcbData));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CryptDecodeObject,
            (IN DWORD       dwCertEncodingType,
             IN LPCSTR      lpszStructType,
             IN const BYTE  *pbEncoded,
             IN DWORD       cbEncoded,
             IN DWORD       dwFlags,
             OUT void       *pvStructInfo,
             IN OUT DWORD   *pcbStructInfo
             ),
             (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, PCERT_EXTENSION, CertFindExtension,
           (IN LPCSTR           pszObjId,
            IN DWORD            cExtensions,
            IN CERT_EXTENSION   rgExtensions[]
            ),
            (pszObjId, cExtensions, rgExtensions));

// -------- cryptui.dll ----------------------------

HINSTANCE g_hinstCryptui = NULL;

DELAY_LOAD(g_hinstCryptui, CRYPTUI.DLL, BOOL, CryptUIDlgCertMgr,
           (PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr),
           (pCryptUICertMgr));

//--------- shdocvw.dll ------------------

HINSTANCE g_hinstShdocvw = NULL;
const TCHAR c_tszShdocvw[] = TEXT("SHDOCVW.DLL");

// HRESULT URLSubRegQueryA(LPCSTR pszKey, LPCSTR pszValue, BOOL fUseHKCU, LPSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions);
DELAY_LOAD_ORD_HRESULT(g_hinstShdocvw, SHDOCVW.DLL, URLSubRegQueryA, 151,
                       (LPCSTR pszKey, LPCSTR pszValue, BOOL fUseHKCU, LPSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions),
                       (pszKey, pszValue, fUseHKCU, pszUrlOut, cchSize, dwSubstitutions));

// HRESULT ResetProfileSharing(HWND hwin);
DELAY_LOAD_ORD_HRESULT(g_hinstShdocvw, SHDOCVW.DLL, ResetProfileSharing, 164,
                        (HWND hwnd),
                        (hwnd));

// HRESULT ClearAutoSuggestForForms(DWORD dwClear);
DELAY_LOAD_ORD_HRESULT(g_hinstShdocvw, SHDOCVW.DLL, ClearAutoSuggestForForms, 211,
                        (DWORD dwClear),
                        (dwClear));

// HRESULT ResetWebSettings(HWND hwnd)
DELAY_LOAD_ORD_HRESULT(g_hinstShdocvw, SHDOCVW.DLL, ResetWebSettings, 223,
                        (HWND hwnd, BOOL *pfChangedHomePage),
                        (hwnd,pfChangedHomePage));

DELAY_LOAD( g_hinstShdocvw, SHDOCVW.DLL, BOOL, 
            ImportPrivacySettings,
            (LPCWSTR szFilename),
            (szFilename));

#ifdef UNIX_FEATURE_ALIAS
DELAY_LOAD_ORD_HRESULT(g_hinstShdocvw, SHDOCVW.DLL, RefreshGlobalAliasList, 164,
                        (),
                        ());
#endif /* UNIX_FEATURE_ALIAS */

//--------- msrating.dll ----------------

HINSTANCE g_hinstRatings = NULL;
const TCHAR c_tszRatingsDLL[] = TEXT("MSRATING.DLL");

DELAY_LOAD(g_hinstRatings, MSRATING.DLL, HRESULT, RatingEnable,
           (HWND hwndParent, LPCSTR pszUsername, BOOL fEnable),
           (hwndParent,pszUsername,fEnable));


DELAY_LOAD(g_hinstRatings, MSRATING.DLL, HRESULT, RatingSetupUI,
           (HWND hDlg, LPCSTR pszUsername),
           (hDlg, pszUsername));

DELAY_LOAD(g_hinstRatings, MSRATING.DLL, HRESULT, RatingEnabledQuery,
           (), ());

// --------- mshtml.dll --------------------

HINSTANCE g_hinstMSHTML = NULL;
const TCHAR c_tszMSHTMLDLL[] = TEXT("MSHTML.DLL");

DELAY_LOAD(g_hinstMSHTML, MSHTML.DLL, HRESULT, ShowModalDialog,
           (HWND hwndParent, IMoniker *pmk, VARIANT *pvarArgIn, TCHAR* pchOptions, VARIANT *pvarArgOut),
           (hwndParent,pmk,pvarArgIn,pchOptions,pvarArgOut));

//
//         We don't need to delay load anything from MSHTML, 
//         but we are using this still to determine if 
//         MSHTML.DLL is around.
//


HINSTANCE g_hinstOCCache = NULL;

DELAY_LOAD_HRESULT(g_hinstOCCache, OCCache.DLL, RemoveExpiredControls,
                   (DWORD dwFlags, DWORD dwReserved),
                   ( dwFlags, dwReserved));

// --------- mpr.dll --------------------

HINSTANCE g_hinstMPR = NULL;
const TCHAR c_tszMPRDLL[] = TEXT("MPR.DLL");

#ifndef UNICODE
DELAY_LOAD(g_hinstMPR, MPR.DLL, DWORD, WNetGetConnectionA,
           (LPCSTR pszLocalDevice, LPSTR pszUNC, LPDWORD pcbUNC),
           (pszLocalDevice, pszUNC, pcbUNC));
#else
DELAY_LOAD(g_hinstMPR, MPR.DLL, DWORD, WNetGetConnectionW,
           (LPCTSTR pszLocalDevice, LPTSTR pszUNC, LPDWORD pcbUNC),
           (pszLocalDevice, pszUNC, pcbUNC));
#endif
// ---------- end of DLL definitions --------

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\fonts.cpp ===
//
// FONTS.C  - Selecting character set default fonts dialog
//
//      Copyright(c) Microsoft Corp., 1996 All rights reserved.
//
// History:
// 7/11/96  t-gpease    trashed old International subdialog to create the new
//                      improved codepage compatiable Fonts dialog.

// WAS

//
//  INTL.C - international dialog proc for inetcpl applet.
// 
//      Copyright(c) Microsoft Corp., 1996  All rights reserved.
//
//  HISTORY:
//  2/2/96  yutakan     created.
//  2/6/96  yutakan     ported most of functions from IE2.0i.
//  8/20/98 weiwu       add script base font dialog proc (UNICODE version only)

#include "inetcplp.h"

#include <mlang.h>
#include <mluisupp.h>

#ifdef UNIX
#include <mainwin.h>
#endif /*UNIX */

// Used for window property to remember the font created
static const TCHAR c_szPropDlgFont[] = TEXT("DefaultDlgFont");

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifdef UNICODE
PMIMECPINFO g_pCPInfo   = NULL;
#else
PMIMECPINFO g_pCPInfoW = NULL;

typedef struct tagMIMECPINFOA
{
    DWORD   dwFlags;
    UINT    uiCodePage;
    UINT    uiFamilyCodePage;
    CHAR    wszDescription[MAX_MIMECP_NAME];        // NOTE: 
    CHAR    wszWebCharset[MAX_MIMECSET_NAME];       // To make it simple, it has wsz 
    CHAR    wszHeaderCharset[MAX_MIMECSET_NAME];    // prefix even though it's CHAR. So,
    CHAR    wszBodyCharset[MAX_MIMECSET_NAME];      //  we don't need to put #ifdef UNICODE
    CHAR    wszFixedWidthFont[MAX_MIMEFACE_NAME];   // in below code anymore except 
    CHAR    wszProportionalFont[MAX_MIMEFACE_NAME]; // conversion time.
    BYTE    bGDICharset;                               
} MIMECPINFOA, *PMIMECPINFOA;

PMIMECPINFOA g_pCPInfo = NULL;
#endif

ULONG g_cCPInfo     = 0;
ULONG g_cSidInfo    = 0;
IMLangFontLink2     *g_pMLFlnk2 = NULL;

typedef HRESULT (* PCOINIT) (LPVOID);
typedef VOID (* PCOUNINIT) (VOID);
typedef VOID (* PCOMEMFREE) (LPVOID);
typedef HRESULT (* PCOCREINST) (REFCLSID, LPUNKNOWN, DWORD,     REFIID, LPVOID * );

extern HMODULE hOLE32;
extern PCOINIT pCoInitialize;
extern PCOUNINIT pCoUninitialize;
extern PCOMEMFREE pCoTaskMemFree;
extern PCOCREINST pCoCreateInstance;

BOOL _StartOLE32();

#define IsVerticalFont(p)    (*(p) == '@')

typedef struct {
    TCHAR   szPropFont[MAX_MIMEFACE_NAME];
    TCHAR   szFixedFont[MAX_MIMEFACE_NAME];
    TCHAR   szFriendlyName[MAX_MIMECP_NAME];
    TCHAR   szMIMEFont[MAX_MIMECP_NAME];
    DWORD   dwFontSize;
}   CODEPAGEDATA;

typedef struct {
    HWND    hDlg;
    HWND    hwndPropCB;
    HWND    hwndFixedCB;
    HWND    hwndSizeCB;
    HWND    hwndMIMECB;
    HWND    hwndNamesLB;

    DWORD   dwDefaultCodePage;

    BOOL    bChanged;

    CODEPAGEDATA    *page;

    LPCTSTR lpszKeyPath;

}   FONTSDATA, *LPFONTSDATA;


typedef struct {
    HWND        hDlg;
    HWND        hwndPropLB;
    HWND        hwndFixedLB;
    HWND        hwndNamesCB;

    SCRIPT_ID   sidDefault;

    BOOL        bChanged;

    PSCRIPTINFO pSidInfo;

    LPCTSTR     lpszKeyPath;

}   FONTSCRIPTDATA, *LPFONTSCRIPTDATA;

const struct {
    SCRIPT_ID   Sid;
    BYTE        nCharSet;
    UINT        uiCp;
} g_CharSetTransTable[] = 
{
    sidAsciiLatin,  ANSI_CHARSET,       1252,
    sidLatin,       ANSI_CHARSET,       1252,   
    sidCyrillic,    RUSSIAN_CHARSET,    1251,
    sidGreek,       GREEK_CHARSET,      1253,
    sidHebrew,      HEBREW_CHARSET,     1255,
    sidArabic,      ARABIC_CHARSET,     1256,
    sidThai,        THAI_CHARSET,       874,
    sidKana,        SHIFTJIS_CHARSET,   932,
    sidHan,         GB2312_CHARSET,     936,
    sidBopomofo,    CHINESEBIG5_CHARSET,950,
    sidHangul,      HANGEUL_CHARSET,    949,
};

//
// Map script ID to charset
// We should use MLang service when it is available
//
BYTE CharSetFromSid(SCRIPT_ID Sid)
{
    for (int i=0; i<ARRAYSIZE(g_CharSetTransTable); i++)
    {
        if (Sid == g_CharSetTransTable[i].Sid)
            return g_CharSetTransTable[i].nCharSet;
    }

    return DEFAULT_CHARSET;
}

// SHLWAPI StrCmp/StrCmpI doesn't work.
// Make this simple function to tell if string is equal in character value
BOOL IsStringEqual(LPCTSTR lpString1, LPCTSTR lpString2)
{
    
    if (lstrlen(lpString1) != lstrlen(lpString2))
        return FALSE;

    while(*lpString1 && *lpString2)
    {
        if (*lpString1 != *lpString2)
        {
            return FALSE;
        }
        lpString1++;
        lpString2++;
    }

    return TRUE;
}

//
// Initialize script table with resource string
//
BOOL InitScriptTable(LPFONTSCRIPTDATA pFnt)
{

    HRESULT hr;
    BOOL    bRet = FALSE;
    IMultiLanguage2 *   pML2;

    ASSERT(IS_VALID_CODE_PTR(pCoInitialize, PCOINIT));
    ASSERT(IS_VALID_CODE_PTR(pCoUninitialize, PCOUNINIT));
    ASSERT(IS_VALID_CODE_PTR(pCoTaskMemFree, PCOMEMFREE));
    ASSERT(IS_VALID_CODE_PTR(pCoCreateInstance, PCOCREINST));

    hr = pCoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (LPVOID *) &pML2);

    if (SUCCEEDED(hr))
    {
        hr = pML2->QueryInterface(IID_IMLangFontLink2, (LPVOID *) &g_pMLFlnk2);

        if (SUCCEEDED(hr))
        {
            IEnumScript *pEnumScript;

            if (SUCCEEDED(pML2->EnumScripts(SCRIPTCONTF_SCRIPT_USER, INETCPL_GetUILanguage(), &pEnumScript)))
            {
                UINT cNum = 0;

                pML2->GetNumberOfScripts(&cNum);

                pFnt->pSidInfo = (PSCRIPTINFO)LocalAlloc(LPTR, sizeof(SCRIPTINFO) * cNum);
                if (NULL != pFnt->pSidInfo)
                {
                    hr = pEnumScript->Next(cNum, pFnt->pSidInfo, &g_cSidInfo);
                    if (SUCCEEDED(hr))
                    {
                        bRet = TRUE;
                    }
                    else
                    {
                        LocalFree(pFnt->pSidInfo);
                        pFnt->pSidInfo = NULL;
                    }
                }
                pEnumScript->Release();
            }
        }

        if (pML2)
            pML2->Release();
    }

    return bRet;
}

//
// DrawSampleString()
//
// Draw the sample string with current font
//

void DrawSampleString(LPFONTSDATA pFnt, int idSample, LPCTSTR lpFace, SCRIPT_ID ScriptId)
{
    HDC hDC;
    HFONT hFont, hTemp;
    LOGFONT lf = {0};
    DWORD rgbText, rgbBack;
    RECT rc;
    SIZE TextExtent;
    TEXTMETRIC tm;
    int len, x, y;
    TCHAR szFontSample[1024];

    if (!lpFace)
        return;

    MLLoadString(IDS_FONT_SAMPLE_DEFAULT+ScriptId, szFontSample, ARRAYSIZE(szFontSample));

    GetWindowRect(GetDlgItem(pFnt->hDlg, idSample), &rc);
    // Use MapWindowPoints() as it works for mirrored windows as well.
    MapWindowRect(NULL, pFnt->hDlg, &rc);  
    // ScreenToClient(pFnt->hDlg, (LPPOINT)&rc.left);
    // ScreenToClient(pFnt->hDlg, (LPPOINT)&rc.right);

    hDC = GetDC(pFnt->hDlg);

    rgbBack = SetBkColor(hDC, GetSysColor(COLOR_3DFACE));
    rgbText = GetSysColor(COLOR_WINDOWTEXT);
    rgbText = SetTextColor(hDC, rgbText);

    hFont = GetWindowFont(pFnt->hDlg);
    GetObject(hFont, sizeof(LOGFONT), &lf);

    lf.lfCharSet = CharSetFromSid(ScriptId);
    lf.lfHeight += lf.lfHeight/2;
    lf.lfWidth += lf.lfWidth/2;

    StrCpyN(lf.lfFaceName, lpFace, LF_FACESIZE);
    hFont = CreateFontIndirect(&lf);
    hTemp = (HFONT)SelectObject(hDC, hFont);

    GetTextMetrics(hDC, &tm);

    len = lstrlen(szFontSample);
    
    GetTextExtentPoint32(hDC, szFontSample, len, &TextExtent);
    TextExtent.cy = tm.tmAscent - tm.tmInternalLeading;

    DrawEdge(hDC, &rc, BDR_SUNKENOUTER, BF_RECT | BF_ADJUST);

    if ((TextExtent.cx >= (rc.right - rc.left)) || (TextExtent.cx <= 0))
        x = rc.left;
    else
        x = rc.left + ((rc.right - rc.left) - TextExtent.cx) / 2;

    y = min(rc.bottom, rc.bottom - ((rc.bottom - rc.top) - TextExtent.cy) / 2);

    if (lpFace[0])
        ExtTextOut(hDC, x, y - (tm.tmAscent), ETO_OPAQUE | ETO_CLIPPED,
                &rc, szFontSample, len, NULL );
    else
        ExtTextOut(hDC, x, y - (tm.tmAscent), ETO_OPAQUE | ETO_CLIPPED,
               &rc, TEXT(" "), 1, NULL );

    SetBkColor(hDC, rgbBack);
    SetTextColor(hDC, rgbText);

    if (hTemp)
        DeleteObject(SelectObject(hDC, hTemp));

    ReleaseDC(pFnt->hDlg, hDC);
}


//
// FillCharsetListBoxes()
//
// Fills the Web page and Plain text ListBoxes with the appropriate
// font data
//
BOOL FillScriptListBoxes(LPFONTSCRIPTDATA pFnt, SCRIPT_ID sid)
{

    
    UINT    i;
    UINT    nFonts = 0;
    int     iSidInfo = -1;
    PSCRIPTFONTINFO pSidFont = NULL;

    if (!pFnt->pSidInfo)
        return FALSE;

    // erase all the listboxes to start fresh
    SendMessage(pFnt->hwndPropLB,  LB_RESETCONTENT, 0, 0);
    SendMessage(pFnt->hwndFixedLB, LB_RESETCONTENT, 0, 0);


    for(i=0; i < g_cSidInfo; i++)
    {
        if (pFnt->pSidInfo[i].ScriptId == sid)
        {
            iSidInfo = i; 
            break;
        }
    }

    if (-1 == iSidInfo)
        return FALSE;

    if (g_pMLFlnk2)
    {

        g_pMLFlnk2->GetScriptFontInfo(sid, SCRIPTCONTF_PROPORTIONAL_FONT, &nFonts, NULL);

        if (nFonts)
        {            

            pSidFont = (PSCRIPTFONTINFO) LocalAlloc(LPTR, sizeof(SCRIPTFONTINFO)*nFonts);
            if (pSidFont)
            {
                g_pMLFlnk2->GetScriptFontInfo(sid, SCRIPTCONTF_PROPORTIONAL_FONT, &nFonts, pSidFont);
                for (i=0; i<nFonts; i++)
                {
                    if (LB_ERR == SendMessage(pFnt->hwndPropLB, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)((pSidFont+i)->wszFont)))
                    {
                        // add the font name to the combobox
                        SendMessage(pFnt->hwndPropLB, LB_ADDSTRING, 0, (LPARAM)((pSidFont+i)->wszFont));
                    }

                }
                // Hack PRC font problems on Win9x and NT4 (Bug #24641, #39946)
                // Win9x does not ship with GBK-supporting fixed-pitch fonts,
                // We provide user proportional fonts as plain text font candidates.
                if (sid == sidHan && GetACP() == 936 && !IsOS(OS_WIN2000ORGREATER))
                {
                    for (i=0; i<nFonts; i++)
                    {
                        // add the font name to the combobox
                        SendMessage(pFnt->hwndFixedLB, LB_ADDSTRING, 0, (LPARAM)((pSidFont+i)->wszFont));
                    }
                }

                LocalFree(pSidFont);
                pSidFont = NULL;
            }
        }

        // Get number of available fonts
        g_pMLFlnk2->GetScriptFontInfo(sid, SCRIPTCONTF_FIXED_FONT, &nFonts, NULL);
        if (nFonts)
        {
            pSidFont = (PSCRIPTFONTINFO) LocalAlloc(LPTR, sizeof(SCRIPTFONTINFO)*nFonts);
            if (pSidFont)
            {
                g_pMLFlnk2->GetScriptFontInfo(sid, SCRIPTCONTF_FIXED_FONT, &nFonts, pSidFont);

                if (!pFnt->pSidInfo[iSidInfo].wszFixedWidthFont[0])
                {
                    StrCpyN(pFnt->pSidInfo[iSidInfo].wszFixedWidthFont, pSidFont->wszFont, LF_FACESIZE);
                    pFnt->bChanged = TRUE;
                }

                // All fixedwidth and proportional fonts are web page font candidates
                for (i=0; i<nFonts; i++)
                {
                    if (LB_ERR == SendMessage(pFnt->hwndFixedLB, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)((pSidFont+i)->wszFont)))
                    {
                        // add the font name to the combobox
                        SendMessage(pFnt->hwndFixedLB, LB_ADDSTRING, 0, (LPARAM)((pSidFont+i)->wszFont));
                    }
                    if (LB_ERR == SendMessage(pFnt->hwndPropLB, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)((pSidFont+i)->wszFont)))
                    {
                        // add the font name to the combobox
                        SendMessage(pFnt->hwndPropLB, LB_ADDSTRING, 0, (LPARAM)((pSidFont+i)->wszFont));
                    }
                }

                LocalFree(pSidFont);
            }
        }
    }



    // Add fonts to combobox

#ifdef UNIX
    /* We would have called EnumFontFamiliesEx wherein we would have
     * have populated the fonts list boxes with substitute fonts if any
     *
     * So, before we populate the proportional and the fixed fonts below,
     * we must query and use substitute fonts if avbl.
     */
     {
        CHAR szSubstFont[MAX_MIMEFACE_NAME+1];
        DWORD cchSubstFont = MAX_MIMEFACE_NAME + 1;
        CHAR szFont[MAX_MIMEFACE_NAME + 1];
           
        WideCharToMultiByte(CP_ACP, 0, pFnt->pSidInfo[iSidInfo].wszProportionalFont, -1, szFont, 
               MAX_MIMEFACE_NAME + 1, NULL, NULL);
        if ((ERROR_SUCCESS == MwGetSubstituteFont(szFont, szSubstFont, &cchSubstFont)) && 
            cchSubstFont) 
        {
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szSubstFont, -1, 
               pFnt->pSidInfo[iSidInfo].wszProportionalFont, MAX_MIMEFACE_NAME + 1);
        }

        WideCharToMultiByte(CP_ACP, 0, pFnt->pSidInfo[iSidInfo].wszFixedWidthFont, -1, szFont, 
               MAX_MIMEFACE_NAME + 1, NULL, NULL);
        cchSubstFont = MAX_MIMEFACE_NAME + 1;
        if ((ERROR_SUCCESS == MwGetSubstituteFont(szFont, szSubstFont, &cchSubstFont)) && 
            cchSubstFont) 
        {
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szSubstFont, -1, 
               pFnt->pSidInfo[iSidInfo].wszFixedWidthFont, MAX_MIMEFACE_NAME + 1);
        }
    }
#endif /* UNIX */

    // select the current prop default
    if (pFnt->pSidInfo[iSidInfo].wszProportionalFont[0])
    {
        if (LB_ERR == SendMessage(pFnt->hwndPropLB, LB_SELECTSTRING, (WPARAM)-1,
            (LPARAM)pFnt->pSidInfo[iSidInfo].wszProportionalFont))
            pFnt->pSidInfo[iSidInfo].wszProportionalFont[0] = 0;
    }
    // Draw sample strings with current font
    DrawSampleString((FONTSDATA *)pFnt, IDC_FONTS_PROP_SAMPLE, pFnt->pSidInfo[iSidInfo].wszProportionalFont, pFnt->pSidInfo[iSidInfo].ScriptId);

    // select the current fixed default
    if (pFnt->pSidInfo[iSidInfo].wszFixedWidthFont[0])
    {
        if (LB_ERR == SendMessage(pFnt->hwndFixedLB, LB_SELECTSTRING, (WPARAM)-1,
            (LPARAM)pFnt->pSidInfo[iSidInfo].wszFixedWidthFont))
            pFnt->pSidInfo[iSidInfo].wszFixedWidthFont[0] = 0;
    }
    // Draw sample strings with current font
    DrawSampleString((FONTSDATA *)pFnt, IDC_FONTS_FIXED_SAMPLE, pFnt->pSidInfo[iSidInfo].wszFixedWidthFont, pFnt->pSidInfo[iSidInfo].ScriptId);


    // we handled it
    return TRUE;


}   // FillScriptListBoxes()

//
// FontsDlgInitEx()
//
// Initializes the script based font dialog, use same dialog box template.
//
BOOL FontsDlgInitEx(IN HWND hDlg, LPCTSTR lpszKeyPath)
{
    HKEY    hkey;
//  DWORD   dw;
    DWORD   cb;
    DWORD   i;

    TCHAR   szKey[1024];

    LPFONTSCRIPTDATA  pFnt;  // localize data

    if (!hDlg)
        return FALSE;   // nothing to initialize

    // get some space to store local data
    // NOTE: LocalAlloc already zeroes the memory
    pFnt = (LPFONTSCRIPTDATA)LocalAlloc(LPTR, sizeof(*pFnt));
    if (!pFnt)
    {
        EndDialog(hDlg, 0);
        return FALSE;
    }

    if (!InitScriptTable(pFnt))
    {
        EndDialog(hDlg, 0);
        return FALSE;
    }

    // associate the memory with the dialog window
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pFnt);

    // save the dialog handle
    pFnt->hDlg = hDlg;

    // get the dialog items
    pFnt->hwndPropLB  = GetDlgItem(pFnt->hDlg, IDC_FONTS_PROP_FONT_LIST);
    pFnt->hwndFixedLB = GetDlgItem(pFnt->hDlg, IDC_FONTS_FIXED_FONT_LIST);
    pFnt->hwndNamesCB = GetDlgItem(pFnt->hDlg, IDC_FONTS_CHAR_SET_COMBO);
    pFnt->lpszKeyPath = lpszKeyPath ? lpszKeyPath: REGSTR_PATH_INTERNATIONAL_SCRIPTS;

    if (!g_pMLFlnk2 || FAILED(g_pMLFlnk2->CodePageToScriptID(GetACP(), &(pFnt->sidDefault))))
        pFnt->sidDefault = sidAsciiLatin;
    
    // We shouldn't consider default script in registry since we no longer have UI to allow user to change default script
#if 0    
    // get values from registry
    if (RegOpenKeyEx(HKEY_CURRENT_USER, pFnt->lpszKeyPath, NULL, KEY_READ, &hkey)
        == ERROR_SUCCESS)
    {
        cb = sizeof(dw);
        if (RegQueryValueEx(hkey, REGSTR_VAL_DEFAULT_SCRIPT, NULL, NULL, (LPBYTE)&dw, &cb)
          == ERROR_SUCCESS)
        {
            pFnt->sidDefault = (SCRIPT_ID)dw;
        }
        RegCloseKey(hkey);
    }
#endif

    for (i = 0; i < g_cSidInfo; i++)
    {
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\%u"), pFnt->lpszKeyPath, pFnt->pSidInfo[i].ScriptId);
        if (RegOpenKeyEx(HKEY_CURRENT_USER, szKey, NULL, KEY_READ, &hkey) == ERROR_SUCCESS)
        {
            TCHAR szFont[MAX_MIMEFACE_NAME];

            cb = sizeof(szFont);

            if (RegQueryValueEx(hkey, REGSTR_VAL_FIXED_FONT, NULL, NULL,
                    (LPBYTE)szFont, &cb) == ERROR_SUCCESS)
            {
                StrCpyN(pFnt->pSidInfo[i].wszFixedWidthFont, szFont, ARRAYSIZE(pFnt->pSidInfo[i].wszFixedWidthFont));
            }
            
            cb = sizeof(szFont);
            if (RegQueryValueEx(hkey, REGSTR_VAL_PROP_FONT, NULL, NULL,
                    (LPBYTE)szFont, &cb) == ERROR_SUCCESS)
            {
                StrCpyN(pFnt->pSidInfo[i].wszProportionalFont, szFont, ARRAYSIZE(pFnt->pSidInfo[i].wszProportionalFont));
            }
            RegCloseKey(hkey);

        }

        // add the name to the listbox
        SendMessage(pFnt->hwndNamesCB, CB_ADDSTRING, 0, 
            (LPARAM)pFnt->pSidInfo[i].wszDescription);

        // check to see if it is the default code page
        if (pFnt->sidDefault == pFnt->pSidInfo[i].ScriptId)
        {
            SendMessage(pFnt->hwndNamesCB, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)pFnt->pSidInfo[i].wszDescription);
        }

    }

    pFnt->bChanged = FALSE;

    FillScriptListBoxes(pFnt, pFnt->sidDefault);
    

    if( g_restrict.fFonts )
    {
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_PROP_FONT_LIST ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_FIXED_FONT_LIST ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_CHAR_SET_COMBO ), FALSE);
#ifdef UNIX
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_UPDATE_BUTTON ), FALSE);
#endif
    }

    // everything ok
    return TRUE;

}   // FontsDlgInit()

//
// SaveFontsDataEx()
//
// Save the new fonts settings into regestry
//
void SaveFontsDataEx(LPFONTSCRIPTDATA pFnt)
{
    HKEY    hkeyScript;
    TCHAR   szScript[MAX_SCRIPT_NAME];

    HKEY    hkey;
    DWORD   dw;

    // get values from registry
    if (RegCreateKeyEx(HKEY_CURRENT_USER, pFnt->lpszKeyPath, NULL, NULL, NULL, KEY_WRITE, NULL, &hkey, &dw)
        == ERROR_SUCCESS)
    {
        UINT i;
 
        RegSetValueEx(hkey, REGSTR_VAL_DEFAULT_SCRIPT, NULL, REG_BINARY, (LPBYTE)&pFnt->sidDefault, sizeof(pFnt->sidDefault));
        
        for(i = 0; i < g_cSidInfo; i++)
        {
            wnsprintf(szScript, ARRAYSIZE(szScript), TEXT("%u"), pFnt->pSidInfo[i].ScriptId);
            if (RegCreateKeyEx(hkey, szScript, NULL, NULL, NULL, KEY_WRITE, NULL, &hkeyScript, &dw) == ERROR_SUCCESS)
            {
                // Currently, no need for script name, save registry space
#if 0
                RegSetValueEx(hkeyScript, REGSTR_VAL_FONT_SCRIPT_NAME, NULL, REG_SZ,
                            (LPBYTE)&pFnt->pSidInfo[i].wszDescription, 
                            (lstrlen(pFnt->pSidInfo[i].wszDescription)+1)*sizeof(TCHAR));
#endif
                    
                RegSetValueEx(hkeyScript, REGSTR_VAL_SCRIPT_FIXED_FONT, NULL, REG_SZ,
                            (LPBYTE)pFnt->pSidInfo[i].wszFixedWidthFont, 
                            (lstrlen(pFnt->pSidInfo[i].wszFixedWidthFont)+1)*sizeof(TCHAR));
                    
                RegSetValueEx(hkeyScript, REGSTR_VAL_SCRIPT_PROP_FONT, NULL, REG_SZ,
                            (LPBYTE)pFnt->pSidInfo[i].wszProportionalFont, 
                            (lstrlen(pFnt->pSidInfo[i].wszProportionalFont)+1)*sizeof(TCHAR));

                RegCloseKey(hkeyScript);
                    
            }   // if RegCreateKeyEx


        }   // for

        RegCloseKey(hkey);
  
    }   // if RegCreateKeyEx

}   // SaveFontsDataEx()

//
// FontsOnCommandEx()
//
// Handles WM_COMMAND message for the script based Fonts subdialog
//
BOOL FontsOnCommandEx(LPFONTSCRIPTDATA pFnt, UINT id, UINT nCmd)
{
    switch(id)
    {
        case IDOK:
            if (pFnt->bChanged)
            {
                SaveFontsDataEx(pFnt);
                
                // tell MSHTML to pick up changes and update
                UpdateAllWindows();
            }
            return TRUE;    // exit dialog

        case IDCANCEL:
            return TRUE;    // exit dialog

        case IDC_FONTS_PROP_FONT_LIST:
        case IDC_FONTS_FIXED_FONT_LIST:
            if (nCmd==LBN_SELCHANGE)
            {
                UINT i;
                TCHAR   szScript[MAX_SCRIPT_NAME];

                pFnt->bChanged = TRUE;  // we need to save
                
                // find the currently selected item in the list box
                GetDlgItemText(pFnt->hDlg, IDC_FONTS_CHAR_SET_COMBO, szScript, ARRAYSIZE(szScript));
                
                // find the code page from the text
                for(i=0; i < g_cSidInfo; i++)
                {
                    INT_PTR j;
                    if (IsStringEqual(szScript, pFnt->pSidInfo[i].wszDescription))
                    {             
                        // grab the new values
                        j = SendMessage(pFnt->hwndPropLB, LB_GETCURSEL, 0, 0);
                        SendMessage(pFnt->hwndPropLB, LB_GETTEXT, j, (LPARAM)(pFnt->pSidInfo[i].wszProportionalFont));
                        j = SendMessage(pFnt->hwndFixedLB, LB_GETCURSEL, 0, 0);
                        SendMessage(pFnt->hwndFixedLB, LB_GETTEXT, j, (LPARAM)(pFnt->pSidInfo[i].wszFixedWidthFont));
                        break;
                    }
                }

                // Redraw sample strings                
                DrawSampleString((LPFONTSDATA)pFnt, IDC_FONTS_PROP_SAMPLE, pFnt->pSidInfo[i].wszProportionalFont, pFnt->pSidInfo[i].ScriptId);
                DrawSampleString((LPFONTSDATA)pFnt, IDC_FONTS_FIXED_SAMPLE, pFnt->pSidInfo[i].wszFixedWidthFont, pFnt->pSidInfo[i].ScriptId);

                // if we don't find it... we are going to keep the default

                ASSERT(i < g_cSidInfo);  // something went wrong

            }
            break;

        case IDC_FONTS_CHAR_SET_COMBO:
            if (nCmd==CBN_SELCHANGE)
            {
                UINT i;
                TCHAR   szScript[MAX_SCRIPT_NAME];

                GetDlgItemText(pFnt->hDlg, IDC_FONTS_CHAR_SET_COMBO, szScript, ARRAYSIZE(szScript));
                
                // find the code page from the text
                for(i=0; i < g_cSidInfo; i++)
                {
                    if (IsStringEqual(szScript, pFnt->pSidInfo[i].wszDescription))
                    {
                        FillScriptListBoxes(pFnt, pFnt->pSidInfo[i].ScriptId);
                        break;
                    }
                }
            }
            break;
#ifdef UNIX
        case IDC_FONTS_UPDATE_BUTTON: 
    {
        HCURSOR hOldCursor = NULL;
        HCURSOR hNewCursor = NULL;

        hNewCursor = LoadCursor(NULL, IDC_WAIT);
        if (hNewCursor) 
            hOldCursor = SetCursor(hNewCursor);

        DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_FONTUPD_PROG), pFnt->hDlg,FontUpdDlgProc, NULL);

        if(hOldCursor)
            SetCursor(hOldCursor);
    }
        break; 
#endif
    }
    
    // don't exit dialog
    return FALSE;
}

//
// FontsDlgProcEx()
//
// Message handler for the script based "Fonts" subdialog.
//
INT_PTR CALLBACK FontsDlgProcEx(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPFONTSCRIPTDATA pFnt = (LPFONTSCRIPTDATA) GetWindowLongPtr(hDlg, DWLP_USER);
    PAINTSTRUCT ps;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            return FontsDlgInitEx(hDlg, (LPTSTR)lParam);
            break;

        case WM_DESTROY:
            // Free memory
            if (pFnt)
            {
                if (pFnt->pSidInfo)
                    LocalFree(pFnt->pSidInfo);
                LocalFree(pFnt);
            }

            break;
            
        case WM_PAINT:

            if (BeginPaint(hDlg, &ps))
            {
                UINT i;
                SCRIPT_ID sid = 0;
                TCHAR szScript[MAX_SCRIPT_NAME];

                GetDlgItemText(hDlg, IDC_FONTS_CHAR_SET_COMBO, szScript, ARRAYSIZE(szScript));
                
                // find the script id from the text
                for(i = 0; i < g_cSidInfo; i++)
                {
                    if (IsStringEqual(szScript, pFnt->pSidInfo[i].wszDescription))
                    {
                        sid = pFnt->pSidInfo[i].ScriptId;
                        break;
                    }
                }


                if (i < g_cSidInfo)
                {
                    // show sample strings with current font
                    DrawSampleString((LPFONTSDATA)pFnt, IDC_FONTS_PROP_SAMPLE, pFnt->pSidInfo[i].wszProportionalFont, pFnt->pSidInfo[i].ScriptId);
                    DrawSampleString((LPFONTSDATA)pFnt, IDC_FONTS_FIXED_SAMPLE, pFnt->pSidInfo[i].wszFixedWidthFont, pFnt->pSidInfo[i].ScriptId);
                }
                EndPaint(hDlg, &ps);
            }
            break;

        case WM_COMMAND:
            if (FontsOnCommandEx(pFnt, LOWORD(wParam), HIWORD(wParam)))
                EndDialog(hDlg, LOWORD(wParam) == IDOK? 1: 0);
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);        
            break;

#ifdef UNIX
        case WM_DRAWITEM:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_FONTS_UPDATE_BUTTON:
            DrawXFontButton(hDlg, (LPDRAWITEMSTRUCT)lParam);
            return TRUE;
        }
        return FALSE;
#endif

        default:
            return FALSE;
    }
    return TRUE;
}


//
// Back out old font dialog for OE4
//



//
// InitMimeCsetTable()
//
// Initialize MimeCharsetTable[]'s string field with resource string
//
BOOL InitMimeCsetTable(BOOL bIsOE5)
{
    IMultiLanguage *pML=NULL;
    IMultiLanguage2 *pML2=NULL;
    HRESULT hr;

    if(!hOLE32)
    {
        if(!_StartOLE32())
        {
            ASSERT(FALSE);
            return FALSE;
        }
    }
    hr = pCoInitialize(NULL);
    if (FAILED(hr))
        return FALSE;

    if (bIsOE5)        
        hr = pCoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (LPVOID *) &pML2);
    else
        hr = pCoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage, (LPVOID *) &pML);
    
    if (SUCCEEDED(hr))
    {
        IEnumCodePage *pEnumCP;

        if (bIsOE5)
        {
            // Ignore MUI if cross code page, otherwise, we won't be able to save data in registry
            char szUICP[1024] = {0};
            LANGID uiLangId = INETCPL_GetUILanguage();

            // We always support English (US)
            if (uiLangId != 0x0409)
                GetLocaleInfoA(MAKELCID(uiLangId, SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szUICP, ARRAYSIZE(szUICP));

            if (szUICP[0] && (UINT)StrToIntA(szUICP) != GetACP())
                hr = pML2->EnumCodePages(MIMECONTF_VALID, GetSystemDefaultLangID(), &pEnumCP);
            else
                hr = pML2->EnumCodePages(MIMECONTF_VALID, uiLangId, &pEnumCP);

        }
        else
            hr = pML->EnumCodePages(MIMECONTF_VALID, &pEnumCP);
        

        if (SUCCEEDED(hr))
        {
            UINT cNum = 0;
            if (bIsOE5)
                pML2->GetNumberOfCodePageInfo(&cNum);
            else
                pML->GetNumberOfCodePageInfo(&cNum);

#ifdef UNICODE
            g_pCPInfo = (PMIMECPINFO)LocalAlloc(LPTR, sizeof(MIMECPINFO) * cNum);
            if (NULL != g_pCPInfo)
            {
                hr = pEnumCP->Next(cNum, g_pCPInfo, &g_cCPInfo);
                if (SUCCEEDED(hr))
                {
                    g_pCPInfo = (PMIMECPINFO)LocalReAlloc(g_pCPInfo, sizeof(MIMECPINFO) * g_cCPInfo, LMEM_MOVEABLE);
                }
                else
                {
                    LocalFree(g_pCPInfo);
                    g_pCPInfo = NULL;
                }
#else
            g_pCPInfoW = (PMIMECPINFO)LocalAlloc(LPTR, sizeof(MIMECPINFO) * cNum);
            if (NULL != g_pCPInfoW)
            {
                hr = pEnumCP->Next(cNum, g_pCPInfoW, &g_cCPInfo);
                if (SUCCEEDED(hr))
                {
                    g_pCPInfo = (PMIMECPINFOA)LocalAlloc(LPTR, sizeof(MIMECPINFOA) * g_cCPInfo);
                    if (NULL != g_pCPInfo)
                    {
                        UINT i;

                        for (i = 0; i < g_cCPInfo; i++)
                        {
                            g_pCPInfo[i].dwFlags = g_pCPInfoW[i].dwFlags;
                            g_pCPInfo[i].uiCodePage = g_pCPInfoW[i].uiCodePage;
                            g_pCPInfo[i].uiFamilyCodePage = g_pCPInfoW[i].uiFamilyCodePage;
                            WideCharToMultiByte(CP_ACP, 0, (WCHAR *)g_pCPInfoW[i].wszDescription, -1, g_pCPInfo[i].wszDescription, sizeof(g_pCPInfo[i].wszDescription), NULL, NULL);
                            WideCharToMultiByte(CP_ACP, 0, (WCHAR *)g_pCPInfoW[i].wszWebCharset, -1, g_pCPInfo[i].wszWebCharset, sizeof(g_pCPInfo[i].wszWebCharset), NULL, NULL);
                            WideCharToMultiByte(CP_ACP, 0, (WCHAR *)g_pCPInfoW[i].wszHeaderCharset, -1, g_pCPInfo[i].wszHeaderCharset, sizeof(g_pCPInfo[i].wszHeaderCharset), NULL, NULL);
                            WideCharToMultiByte(CP_ACP, 0, (WCHAR *)g_pCPInfoW[i].wszBodyCharset, -1, g_pCPInfo[i].wszBodyCharset, sizeof(g_pCPInfo[i].wszBodyCharset), NULL, NULL);
                            WideCharToMultiByte(CP_ACP, 0, (WCHAR *)g_pCPInfoW[i].wszFixedWidthFont, -1, g_pCPInfo[i].wszFixedWidthFont, sizeof(g_pCPInfo[i].wszFixedWidthFont), NULL, NULL);
                            WideCharToMultiByte(CP_ACP, 0, (WCHAR *)g_pCPInfoW[i].wszProportionalFont, -1, g_pCPInfo[i].wszProportionalFont, sizeof(g_pCPInfo[i].wszProportionalFont), NULL, NULL);
                            g_pCPInfo[i].bGDICharset = g_pCPInfoW[i].bGDICharset;                            
                        }
                    }                    
                }
                LocalFree(g_pCPInfoW);
                g_pCPInfoW = NULL;
#endif
            }
            pEnumCP->Release();
        }
        if (bIsOE5)        
            pML2->Release();
        else
            pML->Release();
    }
    pCoUninitialize();

    return TRUE;
}

//
// FreeMimeCsetTable()
//
// Free string buffer of MimeCharsetTable[]'s string field
//
void FreeMimeCsetTable(void)
{
    if (NULL != g_pCPInfo)
    {
        LocalFree(g_pCPInfo);
        g_pCPInfo = NULL;
        g_cCPInfo = 0;
    }
}

//
// EnumFontsProc()
//
// Selects only one font per style
//
int CALLBACK EnumFontsProc(
    ENUMLOGFONTEX FAR*  elf,    // address of logical-font data 
    TEXTMETRIC FAR*  tm,    // address of physical-font data 
    DWORD  dwFontType,  // type of font 
    LPARAM  lParam  // address of application-defined data  
   )
{
    LOGFONT FAR*  lf;
        LPFONTSDATA pFnt;

    ASSERT(lParam);
    ASSERT(elf);
    pFnt = (LPFONTSDATA)lParam;

    lf = &(elf->elfLogFont);
    if ( dwFontType == DEVICE_FONTTYPE || dwFontType == RASTER_FONTTYPE )
        return TRUE; // keep going but don't use this font

    /* We don't use the SYMBOL fonts */
    if( lf->lfCharSet == SYMBOL_CHARSET )
        return TRUE;

    // we don't handle Mac Charset
    if (lf->lfCharSet == MAC_CHARSET )
        return TRUE;

    if ( IsVerticalFont(lf->lfFaceName) )
        return TRUE;  // keep going but don't use this font

    if ( lf->lfPitchAndFamily & FIXED_PITCH  )
    {
        if (CB_ERR == SendMessage(pFnt->hwndFixedCB, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)elf->elfLogFont.lfFaceName))
        {
            // add the font name to the combobox
            SendMessage(pFnt->hwndFixedCB, CB_ADDSTRING, 0, (LPARAM)elf->elfLogFont.lfFaceName);            
        }
    }

    if (CB_ERR == SendMessage(pFnt->hwndPropCB, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)elf->elfLogFont.lfFaceName))
    {
        // add the font name to the combobox
        SendMessage(pFnt->hwndPropCB, CB_ADDSTRING, 0, (LPARAM)elf->elfLogFont.lfFaceName);
    }
    return TRUE;
}

//
// FillFontComboBox()
//
// Fills hwndCB with the names of fonts of family dwCodePage.
//
BOOL FillFontComboBox(IN LPFONTSDATA pFnt, IN BYTE CodePage)
{
    HDC     hDC;
    LOGFONT lf;
    HWND    hWnd;
    BOOL    fReturn = FALSE;

    // get system font info
    hWnd = GetTopWindow(GetDesktopWindow());
    hDC = GetDC(hWnd);

    if (hDC)
    {
        lf.lfFaceName[0]    = 0;
        lf.lfPitchAndFamily = 0;
        lf.lfCharSet = CodePage;

        EnumFontFamiliesEx(hDC, &lf, (FONTENUMPROC)EnumFontsProc,
            (LPARAM)pFnt, 0);

        // everthing went fine
        fReturn = TRUE;
    }

    ReleaseDC(hWnd, hDC);

    return fReturn;

}   // FillFontComboBox()

//
// FillSizeComboBox()
//
// Fills font size combobox with the size of fonts.
//
BOOL FillSizeComboBox(IN LPFONTSDATA pFnt)
{
    int i;

    for (i = IDS_FONT_SIZE_SMALLEST; i <= IDS_FONT_SIZE_LARGEST ; i++)
    {
        TCHAR szSize[MAX_MIMEFACE_NAME];

        MLLoadString(i, szSize, sizeof(szSize));
        SendMessage(pFnt->hwndSizeCB, CB_ADDSTRING, 0, (LPARAM)szSize);
    }

    return TRUE;
}

//
// FillCharsetComboBoxes()
//
// Fills the Fixed, Prop, and MIME comboboxes with the appropriate
// font data
//
BOOL FillCharsetComboBoxes(LPFONTSDATA pFnt, DWORD dwCodePage)
{
    UINT i;
    int iPageInfo = -1;
    DWORD grfFlag;

    // erase all the comboboxes to start fresh
    SendMessage(pFnt->hwndPropCB,  CB_RESETCONTENT, 0, 0);
    SendMessage(pFnt->hwndFixedCB, CB_RESETCONTENT, 0, 0);
    SendMessage(pFnt->hwndSizeCB, CB_RESETCONTENT, 0, 0);
    SendMessage(pFnt->hwndMIMECB,  CB_RESETCONTENT, 0, 0);

    // What happens if other one calls OpenFontDialog except Athena?
    grfFlag = StrCmpI(pFnt->lpszKeyPath, REGSTR_PATH_INTERNATIONAL)? MIMECONTF_MAILNEWS: MIMECONTF_BROWSER;

    for(i=0; i < g_cCPInfo; i++)
    {
        // find the codepage in our table
        if (g_pCPInfo[i].uiFamilyCodePage == (UINT)dwCodePage)
        {
            //
            // populate MIME combobox
            //

            if (g_pCPInfo[i].uiCodePage == (UINT)dwCodePage)
                iPageInfo = i;          // we store info per family codepage here

            // add mime type to combobox
            if (grfFlag & g_pCPInfo[i].dwFlags)
            {
                // HACK: We need to remove Japanese JIS 1 Byte Kana and Korean for MAILNEWS.
                //         949 : Korean. We are using Korean (Auto Detect) instead
                //       50225 : Korean ISO
                //       50221 : Japanese JIS 1 byte Kana-ESC
                //       50222 : Japanese JIS 1 byte Kana-SIO
                if (grfFlag & MIMECONTF_MAILNEWS)
                {
                    if (g_pCPInfo[i].uiCodePage == 949 || g_pCPInfo[i].uiCodePage == 50221 || g_pCPInfo[i].uiCodePage == 50222 || g_pCPInfo[i].uiCodePage == 50225)
                        continue;
                }
                SendMessage(pFnt->hwndMIMECB, CB_ADDSTRING, 0, (LPARAM)g_pCPInfo[i].wszDescription);
            }

        }   // if CodePage

    }   // for i

    if (-1 != iPageInfo)
    {
        // if nothing is defined, then copy the first possible value that
        // we know of from our table
        if (!pFnt->page[iPageInfo].szMIMEFont[0])
        {
            if (grfFlag & g_pCPInfo[iPageInfo].dwFlags)
                StrCpyN(pFnt->page[iPageInfo].szMIMEFont, g_pCPInfo[iPageInfo].wszDescription, ARRAYSIZE(pFnt->page[iPageInfo].szMIMEFont));
            else
            {
                for (i = 0; i < g_cCPInfo; i++)
                {
                    if (g_pCPInfo[iPageInfo].uiCodePage == g_pCPInfo[i].uiFamilyCodePage)
                    {
                        if (grfFlag & g_pCPInfo[i].dwFlags)
                        {
                            StrCpyN(pFnt->page[iPageInfo].szMIMEFont, g_pCPInfo[i].wszDescription, ARRAYSIZE(pFnt->page[iPageInfo].szMIMEFont));
                            break;
                        }
                    }                        
                }
            }
        }

        // select the current default
        SendMessage(pFnt->hwndMIMECB, CB_SELECTSTRING, (WPARAM)-1,
            (LPARAM)pFnt->page[iPageInfo].szMIMEFont);

        // Enable/disable MIME is when there is only one possibility
        EnableWindow(pFnt->hwndMIMECB, (1 < SendMessage(pFnt->hwndMIMECB, CB_GETCOUNT, 0, (LPARAM)0)) && !g_restrict.fFonts);
                        
        // Add fonts to combobox
        FillFontComboBox(pFnt, g_pCPInfo[iPageInfo].bGDICharset);

#ifdef UNIX
        /* We would have called EnumFontFamiliesEx wherein we would have
         * have populated the fonts list boxes with substitute fonts if any
         *
         * So, before we populate the proportional and the fixed fonts below,
         * we must query and use substitute fonts if avbl.
         */
        {
            CHAR szSubstFont[MAX_MIMEFACE_NAME+1];
            DWORD cchSubstFont = MAX_MIMEFACE_NAME + 1;
        CHAR szFont[MAX_MIMEFACE_NAME + 1];
           
            WideCharToMultiByte(CP_ACP, 0, pFnt->page[iPageInfo].szPropFont, -1, szFont, 
                   MAX_MIMEFACE_NAME + 1, NULL, NULL);
            if ((ERROR_SUCCESS == MwGetSubstituteFont(szFont, szSubstFont, &cchSubstFont)) && 
                cchSubstFont) 
            {
                MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szSubstFont, -1, 
                   pFnt->page[iPageInfo].szPropFont, MAX_MIMEFACE_NAME + 1);
            }

            WideCharToMultiByte(CP_ACP, 0, pFnt->page[iPageInfo].szFixedFont, -1, szFont, 
                   MAX_MIMEFACE_NAME + 1, NULL, NULL);
            cchSubstFont = MAX_MIMEFACE_NAME + 1;
            if ((ERROR_SUCCESS == MwGetSubstituteFont(szFont, szSubstFont, &cchSubstFont)) && 
                cchSubstFont) 
            {
                MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szSubstFont, -1, 
                   pFnt->page[iPageInfo].szFixedFont, MAX_MIMEFACE_NAME + 1);
            }
        }
#endif /* UNIX */

        // select the current prop default
        SendMessage(pFnt->hwndPropCB, CB_SELECTSTRING, (WPARAM)-1,
            (LPARAM)pFnt->page[iPageInfo].szPropFont);

        // select the current fixed default
        SendMessage(pFnt->hwndFixedCB, CB_SELECTSTRING, (WPARAM)-1,
            (LPARAM)pFnt->page[iPageInfo].szFixedFont);

        // Add font sizes to combobox
        FillSizeComboBox(pFnt);

        // select the current size default
        SendMessage(pFnt->hwndSizeCB, CB_SETCURSEL, (WPARAM)pFnt->page[iPageInfo].dwFontSize, (LPARAM)0);

        // we handled it
        return TRUE;
    }

    return FALSE;

}   // FillCharsetComboBoxes()

//
// FontsDlgInit()
//
// Initializes the Fonts dialog.
//
BOOL FontsDlgInit(IN HWND hDlg, LPCTSTR lpszKeyPath)
{
    HKEY    hkey;
    DWORD   grfFlag;
    DWORD   dw;
    DWORD   cb;
    DWORD   i;
    BOOL    bIsOE5 = FALSE;

    TCHAR   szKey[1024];

    LPFONTSDATA  pFnt;  // localize data

    if (!hDlg)
        return FALSE;   // nothing to initialize

    // set system default character set where we possibly show
    // the strings in native language.
    SHSetDefaultDialogFont(hDlg, IDC_FONTS_PROP_FONT_COMBO);
    SHSetDefaultDialogFont(hDlg, IDC_FONTS_FIXED_FONT_COMBO);
    SHSetDefaultDialogFont(hDlg, IDC_FONTS_MIME_FONT_COMBO);
    SHSetDefaultDialogFont(hDlg, IDC_FONTS_DEFAULT_LANG_TEXT);
    SHSetDefaultDialogFont(hDlg, IDC_FONTS_CODE_PAGES_LIST);

    // get some space to store local data
    // NOTE: LocalAlloc already zeroes the memory
    pFnt = (LPFONTSDATA)LocalAlloc(LPTR, sizeof(*pFnt));
    if (!pFnt)
    {
        EndDialog(hDlg, 0);
        return FALSE;
    }

    // We distinguish OE5 and OE4 by searching for "5.0" in its registry path, 
    // It works as long as there is no spec. change in OE5
    if (NULL != StrStr(lpszKeyPath, TEXT("5.0")))
        bIsOE5 = TRUE;

    if (!InitMimeCsetTable(bIsOE5))
    {
        EndDialog(hDlg, 0);
        return FALSE;
    }

    if (NULL == pFnt->page)
    {
        pFnt->page = (CODEPAGEDATA*)LocalAlloc(LPTR, sizeof(CODEPAGEDATA) * g_cCPInfo);
        if (NULL == pFnt->page)
        {
            EndDialog(hDlg, 0);
            return FALSE;
        }
    }

    // associate the memory with the dialog window
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pFnt);

    // save the dialog handle
    pFnt->hDlg = hDlg;

    // get the dialog items
    pFnt->hwndPropCB  = GetDlgItem(pFnt->hDlg, IDC_FONTS_PROP_FONT_COMBO);
    pFnt->hwndFixedCB = GetDlgItem(pFnt->hDlg, IDC_FONTS_FIXED_FONT_COMBO);
    pFnt->hwndSizeCB = GetDlgItem(pFnt->hDlg, IDC_FONTS_SIZE_FONT_COMBO);
    pFnt->hwndMIMECB  = GetDlgItem(pFnt->hDlg, IDC_FONTS_MIME_FONT_COMBO);    
    pFnt->hwndNamesLB = GetDlgItem(pFnt->hDlg, IDC_FONTS_CODE_PAGES_LIST);    
    pFnt->lpszKeyPath = lpszKeyPath ? lpszKeyPath: REGSTR_PATH_INTERNATIONAL;
    pFnt->dwDefaultCodePage = GetACP();
    // get values from registry
    if (RegOpenKeyEx(HKEY_CURRENT_USER, pFnt->lpszKeyPath, NULL, KEY_READ, &hkey)
        == ERROR_SUCCESS)
    {
        cb = sizeof(dw);
        if (RegQueryValueEx(hkey, REGSTR_VAL_DEFAULT_CODEPAGE, NULL, NULL, (LPBYTE)&dw, &cb)
          == ERROR_SUCCESS)
        {
            pFnt->dwDefaultCodePage = dw;
        }
        RegCloseKey(hkey);
    }

    // What happens if other one calls OpenFontDialog except Athena?
    grfFlag = StrCmpI(pFnt->lpszKeyPath, REGSTR_PATH_INTERNATIONAL)? MIMECONTF_MAILNEWS: MIMECONTF_BROWSER;

    for (i = 0; i < g_cCPInfo; i++)
    {
        if (g_pCPInfo[i].uiCodePage == g_pCPInfo[i].uiFamilyCodePage)
        {
            int iDef;
            UINT j;

            iDef = -1;
            if (0 == (grfFlag & g_pCPInfo[i].dwFlags))
            {
                for (j = 0; j < g_cCPInfo; j++)
                {
                    if (g_pCPInfo[i].uiCodePage == g_pCPInfo[j].uiFamilyCodePage)
                    {
                        if (grfFlag & g_pCPInfo[j].dwFlags)
                        {
                            iDef = j;
                            break;
                        }
                    }
                }
                if (-1 == iDef)
                    continue;
            }

            if (g_pCPInfo[i].uiCodePage == 50001) // skip CP_AUTO
                continue;

            wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\%u"), pFnt->lpszKeyPath, g_pCPInfo[i].uiCodePage);
            if (RegOpenKeyEx(HKEY_CURRENT_USER, szKey, NULL, KEY_READ, &hkey) == ERROR_SUCCESS)
            {
                cb = sizeof(pFnt->page[i].szFriendlyName);
                if (RegQueryValueEx(hkey, REGSTR_VAL_FONT_SCRIPT, NULL, NULL,
                        (LPBYTE)&pFnt->page[i].szFriendlyName, &cb)
                    != ERROR_SUCCESS)
                {
                    TCHAR *p;

                    StrCpyN(pFnt->page[i].szFriendlyName, g_pCPInfo[i].wszDescription, ARRAYSIZE(pFnt->page[i].szFriendlyName));
                    for (p = pFnt->page[i].szFriendlyName; *p != TEXT('\0'); p = CharNext(p))
                    {
                        // We'd better have a source of this string else where.
                        if (*p == TEXT('('))
                        {
                            *p = TEXT('\0');
                            break;
                        }
                    }
                }

                cb = sizeof(dw);
                if (RegQueryValueEx(hkey, REGSTR_VAL_DEF_INETENCODING, NULL, NULL, (LPBYTE)&dw, &cb)
                    != ERROR_SUCCESS)
                {
                    dw = (DWORD)g_pCPInfo[i].uiCodePage;
                    // HACK ! It's only for Japanese Auto Select as Japanese default.
                    if (dw == 932)      // 932 : Japanese Windows CodePage
                        dw = 50932;     // 50932 : Japanese Auto Select InternetEncoding
                }
                for (j = 0; j < g_cCPInfo; j++)
                {
                    if (g_pCPInfo[j].uiCodePage == (UINT)dw)
                    {
                        if (grfFlag & g_pCPInfo[j].dwFlags)
                            StrCpyN(pFnt->page[i].szMIMEFont, g_pCPInfo[j].wszDescription, ARRAYSIZE(pFnt->page[i].szMIMEFont));
                        else if (-1 != iDef)
                            StrCpyN(pFnt->page[i].szMIMEFont, g_pCPInfo[iDef].wszDescription, ARRAYSIZE(pFnt->page[i].szMIMEFont));
                        else
                            pFnt->page[i].szMIMEFont[0] = TEXT('\0');
                        break;
                    }
                }
            
                cb = sizeof(pFnt->page[i].szFixedFont);
                if (RegQueryValueEx(hkey, REGSTR_VAL_FIXED_FONT, NULL, NULL,
                        (LPBYTE)pFnt->page[i].szFixedFont, &cb)
                    != ERROR_SUCCESS)
                {
                    StrCpyN(pFnt->page[i].szFixedFont, g_pCPInfo[i].wszFixedWidthFont, ARRAYSIZE(pFnt->page[i].szFixedFont));
                }
            
                cb = sizeof(pFnt->page[i].szPropFont);
                if (RegQueryValueEx(hkey, REGSTR_VAL_PROP_FONT, NULL, NULL,
                        (LPBYTE)pFnt->page[i].szPropFont, &cb)
                    != ERROR_SUCCESS)
                {
                    StrCpyN(pFnt->page[i].szPropFont, g_pCPInfo[i].wszProportionalFont, ARRAYSIZE(pFnt->page[i].szPropFont));
                }

                cb = sizeof(pFnt->page[i].dwFontSize);
                if (RegQueryValueEx(hkey, REGSTR_VAL_FONT_SIZE, NULL, NULL,
                        (LPBYTE)&pFnt->page[i].dwFontSize, &cb)
                    != ERROR_SUCCESS)
                {
                    pFnt->page[i].dwFontSize = REGSTR_VAL_FONT_SIZE_DEF;
                }
                RegCloseKey(hkey);

            }
            else
            {
                UINT j;
                TCHAR *p;

                StrCpyN(pFnt->page[i].szFriendlyName, g_pCPInfo[i].wszDescription, ARRAYSIZE(pFnt->page[i].szFriendlyName));
                for (p = pFnt->page[i].szFriendlyName; *p != TEXT('\0'); p = CharNext(p))
                {
                    if (*p == TEXT('('))
                    {
                        *p = TEXT('\0');
                        break;
                    }
                }
                j = (grfFlag & g_pCPInfo[i].dwFlags)? i: iDef;
                // HACK ! It's only for Japanese Auto Select as Japanese default.
                if (g_pCPInfo[j].uiCodePage == 932) // 932 : Japanese Windows CodePage
                {
                    for (j = 0; j < g_cCPInfo; j++)
                    {
                        if (g_pCPInfo[j].uiCodePage == 50932)   // 50932 : Japanese Auto Select InternetEncoding
                            break;
                    }
                }
                StrCpyN(pFnt->page[i].szMIMEFont, g_pCPInfo[j].wszDescription, ARRAYSIZE(pFnt->page[i].szMIMEFont));
                StrCpyN(pFnt->page[i].szFixedFont, g_pCPInfo[i].wszFixedWidthFont, ARRAYSIZE(pFnt->page[i].szFixedFont));
                StrCpyN(pFnt->page[i].szPropFont, g_pCPInfo[i].wszProportionalFont, ARRAYSIZE(pFnt->page[i].szPropFont));
                pFnt->page[i].dwFontSize = REGSTR_VAL_FONT_SIZE_DEF;
            }

            // add the name to the listbox            
            SendMessage(pFnt->hwndNamesLB, LB_ADDSTRING, 0, (LPARAM)pFnt->page[i].szFriendlyName);            

            // check to see if it is the default code page
            if (pFnt->dwDefaultCodePage == g_pCPInfo[i].uiCodePage)
            {
                if (LB_ERR == SendMessage(pFnt->hwndNamesLB, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)pFnt->page[i].szFriendlyName))
                {
                    // Hack shlwapi problems for Win9x.
                    CHAR szAnsiString[1024] = {0};
                    WideCharToMultiByte(CP_ACP, 0, pFnt->page[i].szFriendlyName, -1, szAnsiString, 1024, NULL, NULL);
                    SendMessageA(pFnt->hwndNamesLB, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)szAnsiString);
                }

                SetDlgItemText(pFnt->hDlg, IDC_FONTS_DEFAULT_LANG_TEXT, pFnt->page[i].szFriendlyName);
            }
        }
    }
    
    FillCharsetComboBoxes(pFnt, pFnt->dwDefaultCodePage);

    pFnt->bChanged = FALSE;

    if( g_restrict.fFonts )
    {
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_PROP_FONT_COMBO ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_FIXED_FONT_COMBO ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_SIZE_FONT_COMBO ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_MIME_FONT_COMBO ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_CODE_PAGES_LIST ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_SETDEFAULT_BUTTON ), FALSE);

    }

    // everything ok
    return TRUE;

}   // FontsDlgInit()


//
// SaveFontsData()
//
// Save the new fonts settings into regestry
//
void SaveFontsData(LPFONTSDATA pFnt)
{
    HKEY    hkeyCodePage;
    TCHAR   szCodePage      [MAX_MIMEFACE_NAME];

    HKEY    hkey;
    DWORD   dw;

    // get values from registry
    if (RegCreateKeyEx(HKEY_CURRENT_USER, pFnt->lpszKeyPath, NULL, NULL, NULL, KEY_WRITE, NULL, &hkey, &dw)
        == ERROR_SUCCESS)
    {
        UINT i;
 
        RegSetValueEx(hkey, REGSTR_VAL_DEFAULT_CODEPAGE, NULL, REG_BINARY, (LPBYTE)&pFnt->dwDefaultCodePage, sizeof(pFnt->dwDefaultCodePage));
        
        for(i = 0; i < g_cCPInfo; i++)
        {
            if (g_pCPInfo[i].uiCodePage == g_pCPInfo[i].uiFamilyCodePage)
            {
                wnsprintf(szCodePage, ARRAYSIZE(szCodePage), TEXT("%u"), g_pCPInfo[i].uiCodePage);
                if (RegCreateKeyEx(hkey, szCodePage, NULL, NULL, NULL, KEY_WRITE, NULL, &hkeyCodePage, &dw) == ERROR_SUCCESS)
                {
                    UINT j;

                    RegSetValueEx(hkeyCodePage, REGSTR_VAL_FONT_SCRIPT, NULL, REG_SZ,
                            (LPBYTE)&pFnt->page[i].szFriendlyName, 
                            (lstrlen(pFnt->page[i].szFriendlyName)+1)*sizeof(TCHAR));
                    
                    for (j = 0; j < g_cCPInfo; j++)
                    {
                        if (!StrCmpI(g_pCPInfo[j].wszDescription, pFnt->page[i].szMIMEFont))
                        {
                            dw = g_pCPInfo[j].uiCodePage;
                            break;
                        }
                    }
                    RegSetValueEx(hkeyCodePage, REGSTR_VAL_DEF_INETENCODING, NULL, REG_BINARY,
                            (LPBYTE)&dw, sizeof(dw));
                    
                    RegSetValueEx(hkeyCodePage, REGSTR_VAL_FIXED_FONT, NULL, REG_SZ,
                            (LPBYTE)pFnt->page[i].szFixedFont, 
                            (lstrlen(pFnt->page[i].szFixedFont)+1)*sizeof(TCHAR));
                    
                    RegSetValueEx(hkeyCodePage, REGSTR_VAL_PROP_FONT, NULL, REG_SZ,
                            (LPBYTE)pFnt->page[i].szPropFont, 
                            (lstrlen(pFnt->page[i].szPropFont)+1)*sizeof(TCHAR));
                    
                    RegSetValueEx(hkeyCodePage, REGSTR_VAL_FONT_SIZE, NULL, REG_BINARY,
                            (LPBYTE)&pFnt->page[i].dwFontSize,
                            sizeof(pFnt->page[i].dwFontSize));

                    RegCloseKey(hkeyCodePage);
                    
                }   // if RegCreateKeyEx

            }   // if uiCodePage == uiFamilyCodePage

        }   // for

        RegCloseKey(hkey);

    }   // if RegCreateKeyEx

}   // SaveFontsData()

//
// FontsOnCommand()
//
// Handles WM_COMMAN Dmessage for the Fonts subdialog
//
BOOL FontsOnCommand(LPFONTSDATA pFnt, UINT id, UINT nCmd)
{
    switch(id)
    {
        case IDOK:
            if (pFnt->bChanged)
            {
                SaveFontsData(pFnt);
                
                // tell MSHTML to pick up changes and update
                UpdateAllWindows();
            }
            return TRUE;    // exit dialog

        case IDCANCEL:
            return TRUE;    // exit dialog

        case IDC_FONTS_MIME_FONT_COMBO:
            if (nCmd==CBN_SELCHANGE)
            {
                g_fChangedMime = TRUE;   // tell MSHTML that the Mime has changed
            }
            // fall thru...

        case IDC_FONTS_PROP_FONT_COMBO:
        case IDC_FONTS_FIXED_FONT_COMBO:
        case IDC_FONTS_SIZE_FONT_COMBO:
            if (nCmd==CBN_SELCHANGE)
            {
                UINT i;
                TCHAR   szCodePage[MAX_MIMECP_NAME];

                pFnt->bChanged = TRUE;  // we need to save
                
                // find the currently selected item in the list box
                INT_PTR itmp = SendMessage(pFnt->hwndNamesLB, LB_GETCURSEL, 0, 0);
                SendMessage(pFnt->hwndNamesLB, LB_GETTEXT, itmp, (LPARAM)szCodePage);
                
                // find the code page from the text
                for(i=0; i < g_cCPInfo; i++)
                {
                    if (!StrCmpI(szCodePage, pFnt->page[i].szFriendlyName))
                    {             
                        // grab the new values
                        GetDlgItemText(pFnt->hDlg, IDC_FONTS_PROP_FONT_COMBO,
                            pFnt->page[i].szPropFont, ARRAYSIZE(pFnt->page[i].szPropFont));
                        GetDlgItemText(pFnt->hDlg, IDC_FONTS_FIXED_FONT_COMBO,
                            pFnt->page[i].szFixedFont, ARRAYSIZE(pFnt->page[i].szFixedFont));
                        pFnt->page[i].dwFontSize = (int) SendMessage(pFnt->hwndSizeCB, CB_GETCURSEL, 0, 0);
                        GetDlgItemText(pFnt->hDlg, IDC_FONTS_MIME_FONT_COMBO,
                            pFnt->page[i].szMIMEFont, ARRAYSIZE(pFnt->page[i].szMIMEFont));
                        break;
                    }
                }
                // if we don't find it... we are going to keep the default

                ASSERT(i < g_cCPInfo);  // something went wrong

            }
            break;

        case IDC_FONTS_SETDEFAULT_BUTTON:
            {
                UINT i;
                TCHAR   szCodePage[MAX_MIMECP_NAME];

                pFnt->bChanged = TRUE;  // we need to save

                // get the newly selected charset
                INT_PTR itmp = SendMessage(pFnt->hwndNamesLB, LB_GETCURSEL, 0, 0);
                SendMessage(pFnt->hwndNamesLB, LB_GETTEXT, itmp, (LPARAM)szCodePage);

                // set the newly selected charset text
                SetDlgItemText(pFnt->hDlg, IDC_FONTS_DEFAULT_LANG_TEXT, szCodePage);

                // find the code page from the text
                for (i = 0; i < g_cCPInfo; i++)
                {
                    if (!StrCmpI(szCodePage, pFnt->page[i].szFriendlyName))
                    {
                        pFnt->dwDefaultCodePage = g_pCPInfo[i].uiFamilyCodePage;
                        g_fChangedMime = TRUE;
                        break;
                    }
                }
                // if we don't find it... we are going to keep the default

                ASSERT(i < g_cCPInfo);  // something went wrong
            }
            break;
        
        case IDC_FONTS_CODE_PAGES_LIST:
            if (nCmd==LBN_SELCHANGE)
            {
                UINT i;
                TCHAR   szCodePage[MAX_MIMECP_NAME];

                INT_PTR itmp = SendMessage(pFnt->hwndNamesLB, LB_GETCURSEL, 0, 0);
                SendMessage(pFnt->hwndNamesLB, LB_GETTEXT, itmp, (LPARAM)szCodePage);
                
                // find the code page from the text
                for(i=0; i < g_cCPInfo; i++)
                {
                    if (!StrCmpI(szCodePage, pFnt->page[i].szFriendlyName))
                    {
                        FillCharsetComboBoxes(pFnt, g_pCPInfo[i].uiFamilyCodePage);
                        break;
                    }
                }
            }
            break;

    }
    
    // don't exit dialog
    return FALSE;
}

//
// FontsDlgProc()
//
// Message handler for the "Fonts" subdialog.
//
INT_PTR CALLBACK FontsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPFONTSDATA pFnt = (LPFONTSDATA) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            return FontsDlgInit(hDlg, (LPTSTR)lParam);
            
        case WM_DESTROY:
            // give back the memory
            FreeMimeCsetTable();

            // destroy font if we created
            SHRemoveDefaultDialogFont(hDlg);

            if (pFnt)
            {
                if (pFnt->page)
                    LocalFree(pFnt->page);
                LocalFree(pFnt);
            }
            break;

        case WM_COMMAND:
            if (FontsOnCommand(pFnt, LOWORD(wParam), HIWORD(wParam)))
                EndDialog(hDlg, LOWORD(wParam) == IDOK? 1: 0);
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


//
// EXTERNAL API
//
STDAPI_(INT_PTR) OpenFontsDialog(HWND hDlg, LPCSTR lpszKeyPath)
{
#ifdef UNICODE
    WCHAR   wszKeyPath[1024];
    MultiByteToWideChar(CP_ACP, 0, (char *)lpszKeyPath, -1, wszKeyPath, ARRAYSIZE(wszKeyPath));
    return DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_FONTS_IE4), hDlg, FontsDlgProc, (LPARAM) wszKeyPath);
#else
    return DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_FONTS_IE4), hDlg, FontsDlgProc, (LPARAM) lpszKeyPath);
#endif // UNICODE
}

// provide script based font dialog
STDAPI_(INT_PTR) OpenFontsDialogEx(HWND hDlg, LPCTSTR lpszKeyPath)
{
    INT_PTR nRet = -1;
    HRESULT hr;
    BOOL    fOLEPresent;

    if (hOLE32 != NULL)
    {
        fOLEPresent = TRUE;
    }
    else
    {
        fOLEPresent = _StartOLE32();
    }

    ASSERT(fOLEPresent);
    if (fOLEPresent)
    {
        ASSERT(IS_VALID_HANDLE(hOLE32, MODULE));
        ASSERT(IS_VALID_CODE_PTR(pCoInitialize, PCOINIT));

        hr = pCoInitialize(NULL);
        if (SUCCEEDED(hr))
        {
            nRet = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_FONTS), hDlg, FontsDlgProcEx, (LPARAM) lpszKeyPath);
        }
    }

    // Release interface
    if (g_pMLFlnk2)
    {
        g_pMLFlnk2->Release();
        g_pMLFlnk2 = NULL;
    }

    ASSERT(IS_VALID_CODE_PTR(pCoUninitialize, PCOUNIT));
    pCoUninitialize();

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\content.cpp ===
//*********************************************************************
//*          Microsoft Windows                                       **
//*        Copyright(c) Microsoft Corp., 1995                        **
//*********************************************************************

//
// content.cpp - "Content" property sheet
//

// HISTORY:
//
// 5/17/97  t-ashlm created

#include "inetcplp.h"
#include <wab.h>
#include <cryptui.h>
#include <msiehost.h>
#include <schannel.h>

#include <mluisupp.h>

//
// Private Functions and Structures
//

// WINTRUST / SOFTPUB
// definition from WINTRUST.H
// extern "C" BOOL WINAPI OpenPersonalTrustDBDialog(HWND hwndParent);
typedef BOOL (WINAPI *WINTRUSTDLGPROC)(HWND hwndParent);
WINTRUSTDLGPROC g_WinTrustDlgProc = (WINTRUSTDLGPROC)NULL;
SSL_EMPTY_CACHE_FN_W g_pfnSslEmptyCacheW = (SSL_EMPTY_CACHE_FN_W)NULL;
#ifdef WALLET
BOOL IsWallet3Installed();
BOOL IsWalletAddressAvailable(VOID);
BOOL IsWalletPaymentAvailable(VOID);
#endif
HRESULT ShowModalDialog(HWND hwndParent, IMoniker *pmk, VARIANT *pvarArgIn, TCHAR* pchOptions, VARIANT *pvArgOut);
HCERTSTORE PFXImportCertStore(CRYPT_DATA_BLOB* pPFX, LPCWSTR szPassword, DWORD   dwFlags);
BOOL PFXExportCertStore(HCERTSTORE hStore, CRYPT_DATA_BLOB* pPFX, LPCWSTR szPassword, DWORD   dwFlags);
BOOL _AorW_GetFileNameFromBrowse(HWND hDlg,
                                 LPWSTR pszFilename,
                                 UINT cchFilename,
                                 LPCWSTR pszWorkingDir,
                                 LPCWSTR pszExt,
                                 LPCWSTR pszFilter,
                                 LPCWSTR pszTitle);

INT_PTR CALLBACK AutoSuggestDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK WalletDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


//BUBUG: The following prototype should be rermoved when we have updated our Crypto API to latest version
BOOL WINAPI WTHelperIsInRootStore(PCCERT_CONTEXT pCertContext);

//////////////////////////////////////////////
// stolen from \inet\schannel\sspi\spreg.h
#define REG_SITECERT_BASE     TEXT("System\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\CertificationAuthorities")
#define REG_SITECERT_CERT_VAL TEXT("CACert")

#define SITECERTKEYLEN        80    // FEATURE: should probably grab this value somewhere
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#include <initguid.h>

// Use the wallet "payment" guid for JIT (different for alpha and x86...)
#ifdef _ALPHA_
// {B7FB4D5C-9FBE-11D0-8965-0000F822DEA9}
DEFINE_GUID(CLSID_WalletPayment, 0xb7fb4d5c, 0x9fbe, 0x11d0, 0x89, 0x65, 0x0, 0x0, 0xf8, 0x22, 0xde, 0xa9);
#else
// {87D3CB66-BA2E-11CF-B9D6-00A0C9083362}
DEFINE_GUID(CLSID_WalletPayment, 0x87d3cb66, 0xba2e, 0x11cf, 0xb9, 0xd6, 0x0, 0xa0, 0xc9, 0x08, 0x33, 0x62);
#endif

// WAB GUID for JIT
DEFINE_GUID(CLSID_WAB, 0x32714800, 0x2E5F, 0x11d0, 0x8B, 0x85, 0x00, 0xAA, 0x00, 0x44, 0xF9, 0x41);

#define EKU_CODESIGN_OFF    0
#define EKU_EMAIL_OFF       1
#define EKU_CLIENT_OFF      2
#define EKU_SERVER_OFF      3
#define EKU_DISABLE_OFF     4


const LPSTR g_rgszEnhkeyUsage[] =
{
    szOID_PKIX_KP_CODE_SIGNING,
    szOID_PKIX_KP_EMAIL_PROTECTION,
    szOID_PKIX_KP_CLIENT_AUTH,
    szOID_PKIX_KP_SERVER_AUTH,
    szOID_YESNO_TRUST_ATTR,
    NULL
};


typedef struct {
    HWND hDlg;              // handle to window
    HRESULT hrUseRatings;   // error=not installed; S_OK=enabled; S_FALSE=disabled
    HINSTANCE   hWinTrust;      // WINTRUST/SOFTPUB library handle
    HINSTANCE   hSChannel;  // schannel library handle

} CONTENTPAGE, *LPCONTENTPAGE;

BOOL ContentDlgApplyNow(  LPCONTENTPAGE pCon     );
BOOL ContentDlgEnableControls(   IN HWND hDlg  );
BOOL ContentDlgInit(  IN HWND hDlg  );

VOID DisplayWalletPaymentDialog(HWND hWnd);
VOID DisplayWalletAddressDialog(HWND hWnd);

STDAPI ResetProfileSharing(HWND hwnd);
EXTERN_C HRESULT ClearAutoSuggestForForms(DWORD dwClear);


//
// SecurityDlgEnableControls()
//
// Does initalization for Security Dlg.
//
// History:
//
// 6/17/96  t-gpease   moved
//
BOOL ContentDlgEnableControls( IN HWND hDlg  )
{
    HKEY hkey=NULL;
    
    if( g_restrict.fRatings )
    {
        EnableWindow( GetDlgItem(hDlg, IDC_RATINGS_TURN_ON), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_RATINGS_BUTTON), FALSE );
#if 0   // don't diable the text
        EnableDlgItem( hDlg, IDC_RATINGS_TEXT, FALSE);
        EnableDlgItem( hDlg, IDC_ADVANCED_RATINGS_GROUPBOX, FALSE);
#endif
    }

    if( g_restrict.fCertif || g_restrict.fCertifPub)
        EnableWindow( GetDlgItem(hDlg, IDC_SECURITY_PUBLISHERS_BUTTON), FALSE );

    if( g_restrict.fCertif || g_restrict.fCertifPers || g_restrict.fCertifSite)
        EnableWindow( GetDlgItem(hDlg, IDC_SECURITY_SITES_BUTTON), FALSE );
        
    if( g_restrict.fProfiles )
    {
        EnableWindow(GetDlgItem(hDlg,  IDC_EDIT_PROFILE), FALSE);
    }

    if (hkey)
        RegCloseKey(hkey);
    
#ifdef WALLET
    if (g_restrict.fWallet)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PROGRAMS_WALLET_SETTINGS), FALSE);
    }
#endif

    return TRUE;
}


void InitRatingsButton(HWND hDlg, HRESULT hrEnabled)
{
    TCHAR szBuf[MAX_RES_LEN+1];

    UINT idString;
    BOOL fEnableSettingsButton;

    if (FAILED(hrEnabled)) {
        /* Ratings are not installed.  Disable the Settings button and
         * set the other button to say "Enable".
         */
        idString = IDS_RATINGS_TURN_ON;
        fEnableSettingsButton = FALSE;
    }
    else {
        idString = (hrEnabled == S_OK) ? IDS_RATINGS_TURN_OFF : IDS_RATINGS_TURN_ON;
        fEnableSettingsButton = TRUE;
    }
    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_RATINGS_BUTTON), fEnableSettingsButton);

    if (MLLoadString(
                   idString,
                   szBuf, sizeof(szBuf)) > 0) {
        SetDlgItemText(hDlg, IDC_RATINGS_TURN_ON, szBuf);
    }

}

//
// ContentDlgInit()
//
// Does initalization for Content Dlg.
//
//
BOOL ContentDlgInit( HWND hDlg)
{
    LPCONTENTPAGE pCon;

    pCon = (LPCONTENTPAGE)LocalAlloc(LPTR, sizeof(*pCon));
    if (!pCon)
    {
        EndDialog(hDlg, 0);
        return FALSE;   // no memory?
    }

    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pCon);

    // save the handle to the page
    pCon->hDlg = hDlg;

    // Load the Ratings DLL (if possible)
    g_hinstRatings = LoadLibrary(c_tszRatingsDLL);

    // if not..
    if (!g_hinstRatings)
        g_restrict.fRatings = TRUE;     // disable Ratings section


    // set ratings dialog items... 

    // if MSRATING.DLL not around, then don't do this call.  By not
    // doing this, it will keep the "Enable Ratings" text on the button 
    // but greyed off.
    if (g_hinstRatings)
        pCon->hrUseRatings = RatingEnabledQuery();

    InitRatingsButton(hDlg, pCon->hrUseRatings);


    // if we can't find WINTRUST or SOFTPUB disable the
    // "Publishers" button.
    pCon->hWinTrust = LoadLibrary(TEXT("wintrust.dll"));

    if ( pCon->hWinTrust )
    {
        g_WinTrustDlgProc =
                           (WINTRUSTDLGPROC) GetProcAddress(pCon->hWinTrust, "OpenPersonalTrustDBDialog");

        // didn't find the procecdure
        if (!g_WinTrustDlgProc)
        {
            // release library and try the other DLL.
            FreeLibrary(pCon->hWinTrust);

            //
            // We can also find the same function on NT machines (and
            // possibly future Win95s) in SOFTPUB.DLL so make another
            // check there too.
            //
            pCon->hWinTrust = LoadLibrary(TEXT("softpub.dll"));
        }
    }

    if (pCon->hWinTrust && !g_WinTrustDlgProc)
        g_WinTrustDlgProc = (WINTRUSTDLGPROC) 
                            GetProcAddress(pCon->hWinTrust, "OpenPersonalTrustDBDialog");

    // if after all this, we can't find the procedure...
    if (!g_WinTrustDlgProc)
    {
        // disable the button
        EnableDlgItem(hDlg, IDC_SECURITY_PUBLISHERS_BUTTON, FALSE);
    }

    // Only present UI for flushing the SSL cache on Whistler or greater
    // This is the minimum version which has the default behavior of
    // maintaining the SSL cache for all processes in a logon session.
    //
    // Note:  This support was also added for Win2K SP2, but no cache
    //        clearing functionality was added.  It's also not enabled
    //        by default.
    if (IsOS(OS_WHISTLERORGREATER))
    {
        pCon->hSChannel = LoadLibrary(TEXT("SCHANNEL.DLL"));
        if (pCon->hSChannel)
        {
            g_pfnSslEmptyCacheW = (SSL_EMPTY_CACHE_FN_W) GetProcAddress(pCon->hSChannel, "SslEmptyCacheW");
        }
    }
                    
    if(!g_pfnSslEmptyCacheW)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_SECURITY_CLEAR_SSL_CACHE_BUTTON), SW_HIDE);
        EnableWindow( GetDlgItem(hDlg, IDC_SECURITY_CLEAR_SSL_CACHE_BUTTON), FALSE );
    }

#ifdef WALLET
    EnableDlgItem(hDlg, IDC_PROGRAMS_WALLET_SETTINGS, TRUE);    
#endif

    ContentDlgEnableControls(hDlg);

    return TRUE;
}



//
// ContentOnCommand()
//
// Handles Content Dialog's window messages
//
// History:
//
// 6/17/96  t-gpease   created
//
void ContentOnCommand(LPCONTENTPAGE pCon, UINT id, UINT nCmd)
{
    switch (id) {

        case IDC_ADVANCED_RATINGS_BUTTON:
        {
            RatingSetupUI(pCon->hDlg, (LPCSTR) NULL);        
        }
        break; // IDC_ADVANCED_RATINGS_BUTTON

        case IDC_RATINGS_TURN_ON:
        {
            if (SUCCEEDED(RatingEnable(pCon->hDlg, (LPCSTR)NULL,
                                       pCon->hrUseRatings != S_OK))) 
            {
                pCon->hrUseRatings = RatingEnabledQuery();
                InitRatingsButton(pCon->hDlg, pCon->hrUseRatings);
            }
        }
        break;

        case IDC_SECURITY_CLEAR_SSL_CACHE_BUTTON:
        {
            if (g_pfnSslEmptyCacheW && (*g_pfnSslEmptyCacheW)(NULL, 0))
            {
                DWORD dwCount;
                // Leverage a private cache header data counter
                // that was never used to avoid passing a reg value.
                if (IncrementUrlCacheHeaderData(CACHE_HEADER_DATA_DOWNLOAD_PARTIAL, &dwCount))
                {
                    // Display message about clearing the cache OK.
                    TCHAR szText[MAX_PATH], szTitle[80];

                    MLLoadShellLangString(IDS_CLEAR_SSL_CACHE_TEXT, szText, ARRAYSIZE(szText));
                    MLLoadShellLangString(IDS_CLEAR_SSL_CACHE_TITLE, szTitle, ARRAYSIZE(szTitle));
                    
                    MessageBox(pCon->hDlg, szText, szTitle, MB_ICONINFORMATION | MB_OK);
                }
            }
        }
        break;

        case IDC_SECURITY_SITES_BUTTON:
        {
            CRYPTUI_CERT_MGR_STRUCT ccm = {0};
            ccm.dwSize = sizeof(ccm);
            ccm.hwndParent = pCon->hDlg;
            CryptUIDlgCertMgr(&ccm);
//          if (!g_hinstCryptui)
//          {
//              EnableWindow(GetDlgItem(pCon->hDlg, IDC_SECURITY_SITES_BUTTON), FALSE);
//          }
        }
            break;

        case IDC_SECURITY_PUBLISHERS_BUTTON:
        {
            if (g_WinTrustDlgProc)
            {
                g_WinTrustDlgProc(pCon->hDlg);
            }
        }
        break;

#ifdef WALLET
        case IDC_PROGRAMS_WALLET_SETTINGS:
        {
            HRESULT hr = S_OK;

            // See if wallet is installed at all
            if (!IsWalletPaymentAvailable())
            {
                uCLSSPEC clsspec;

                clsspec.tyspec = TYSPEC_CLSID;
                clsspec.tagged_union.clsid = CLSID_WalletPayment;

                // If wallet isn't installed, ask user if they'd like to install it
                hr = FaultInIEFeature(NULL, &clsspec, NULL, FIEF_FLAG_FORCE_JITUI);
            }

            if (SUCCEEDED(hr))
            {
                // Wallet is installed
                if (IsWallet3Installed())
                {
                    // if wallet 3.0 is installed, we want to invoke the wallet UI directly
                    DisplayWalletPaymentDialog(pCon->hDlg);
                }
                else
                {
                    // otherwise we need to pop up this intermediate dialog
                    DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_WALLET_SETTINGS), pCon->hDlg, WalletDlgProc);
                }
            }
        }
        break;
#endif

        case IDC_AUTOSUGGEST_SETTINGS:
        {
            DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_AUTOSUGGEST_SETTINGS), pCon->hDlg, AutoSuggestDlgProc);
        }
        break;

        case IDC_EDIT_PROFILE:
        {
            HMODULE hInstWAB = NULL;
            LPWABOBJECT  lpWABObject = NULL;
            LPADRBOOK lpAdrBook = NULL;
            HRESULT hr=S_OK;

            // Ask user to JIT in WAB if it's not installed
            uCLSSPEC clsspec;

            clsspec.tyspec = TYSPEC_CLSID;
            clsspec.tagged_union.clsid = CLSID_WAB;

            // If WAB isn't installed, ask user if they'd like to install it
            hr = FaultInIEFeature(NULL, &clsspec, NULL, FIEF_FLAG_FORCE_JITUI);

            if (FAILED(hr))
            {
                break;
            }
                
            // Figure out the location of the wab dll and try opening it.
            TCHAR szWABDllPath[MAX_PATH];
            DWORD dwType = 0;
            ULONG cbData = sizeof(szWABDllPath) * sizeof(TCHAR);
            HKEY hKey = NULL;
            SBinary SBMe = { 0, 0};

            *szWABDllPath = '\0';
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
            {
                RegQueryValueEx( hKey, TEXT(""), NULL, &dwType, (LPBYTE) szWABDllPath, &cbData);
                RegCloseKey(hKey);
            }

            if (lstrlen(szWABDllPath) > 0 )
            {
                hInstWAB = LoadLibrary(szWABDllPath);
            }

            if (hInstWAB)
            {
                LPWABOPEN lpfnWABOpen = (LPWABOPEN) GetProcAddress(hInstWAB, "WABOpen");

                if (lpfnWABOpen)
                {
                    hr = lpfnWABOpen(&lpAdrBook, &lpWABObject, NULL, 0);

                    if (NULL == lpAdrBook || NULL == lpWABObject)
                        hr = E_UNEXPECTED;
                }
                else 
                {
                    hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);  // Not the right dll anyway!!
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);
            }

            DWORD dwAction = 0;

            // Good so far, call GetMe. WAB may create a new entry in this call.
            if (SUCCEEDED(hr))
            {
                hr = lpWABObject->GetMe(lpAdrBook, 0, &dwAction, &SBMe, 0);

                if (0 == SBMe.cb || NULL == SBMe.lpb)
                    hr = E_UNEXPECTED;
            }     

            // This shows the final UI. If WAB created a new entry in GetMe, they
            //   already showed this UI and we don't need to do it again.
            if (SUCCEEDED(hr) && !(dwAction & WABOBJECT_ME_NEW))
            {
                hr = lpAdrBook->Details(  (LPULONG) &pCon->hDlg,
                                          NULL,
                                          NULL,
                                          SBMe.cb,
                                          (LPENTRYID)SBMe.lpb,
                                          NULL,
                                          NULL,
                                          NULL,
                                          0);

            }
            if (lpWABObject)
            {
                if (SBMe.lpb != NULL)
                    lpWABObject->FreeBuffer(SBMe.lpb);

                lpWABObject->Release();
            }

            if (lpAdrBook)
                lpAdrBook->Release();

            if (hInstWAB)
                FreeLibrary(hInstWAB);
        }        
    }

} // ContentOnCommand()


/****************************************************************
Name: ContentDlgProc

SYNOPSIS: Set various security issue settings.

****************************************************************/

INT_PTR CALLBACK ContentDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPCONTENTPAGE pCon;

    if (uMsg == WM_INITDIALOG)
        return ContentDlgInit( hDlg );
    else
        pCon = (LPCONTENTPAGE) GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pCon)
        return FALSE;
    
    switch (uMsg)
    {
        case WM_COMMAND:
            ContentOnCommand(pCon, LOWORD(wParam), HIWORD(wParam));
            return TRUE;

        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            ASSERT(lpnm);
            switch (lpnm->code) {
                case PSN_QUERYCANCEL:
                case PSN_KILLACTIVE:
                case PSN_RESET:
                    SetWindowLongPtr( pCon->hDlg, DWLP_MSGRESULT, FALSE );
                    return TRUE;

                case PSN_APPLY:
                    break;
            }
            break;
        }

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            ASSERT(pCon);
            if (pCon)
            {
                if (pCon->hWinTrust)
                {
                    FreeLibrary(pCon->hWinTrust);
                    g_WinTrustDlgProc = NULL;
                }
                if (pCon->hSChannel)
                {
                    FreeLibrary(pCon->hSChannel);
                    g_pfnSslEmptyCacheW = NULL;
                }
                LocalFree(pCon);
            }
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            break;
    }
    return FALSE;
}


typedef struct tagSITECERTDIALOGINFO {    
    HWND hDlg;
    HWND hwndList;
    HWND hwndCombo;
    int  iSel;
    HCERTSTORE hCertStore;
    BOOL    fInitializing;
} SITECERTDIALOGINFO, *LPSITECERTDIALOGINFO;

BOOL _SearchKeyUsage(CERT_ENHKEY_USAGE *pUsage, LPSTR pszUsageIdentifier)
{
    DWORD   i;

    for (i = 0; i < pUsage->cUsageIdentifier; i++)
    {
        if (StrCmpA(pUsage->rgpszUsageIdentifier[i], pszUsageIdentifier) == 0)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

BOOL _IsKnownUsage(char *pszTest)
{
    char    **ppszKnown;

    ppszKnown = (char **)g_rgszEnhkeyUsage;

    while (*ppszKnown)
    {
        if (StrCmpA(*ppszKnown, pszTest) == 0)
        {
            return(TRUE);
        }

        ppszKnown++;
    }

    return(FALSE);
}

void __AddAllKnownEKU(PCCERT_CONTEXT pCert)
{
    char    **ppszKnown;

    ppszKnown = (char **)g_rgszEnhkeyUsage;

    while (*ppszKnown)
    {
       CertAddEnhancedKeyUsageIdentifier(pCert, *ppszKnown);

       ppszKnown++;
    }
}

BOOL _AnyKnownUsage(CERT_ENHKEY_USAGE *pUsage)
{
    DWORD   i;

    for (i = 0; i < pUsage->cUsageIdentifier; i++)
    {
        if (_IsKnownUsage(pUsage->rgpszUsageIdentifier[i]))
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

BOOL _IsUsageEnabled(PCCERT_CONTEXT pCertContext, LPSTR pszUsageIdentifier, BOOL * pfFound)
{
    CERT_ENHKEY_USAGE   *pUsage;
    DWORD               cbUsage;


    *pfFound = FALSE;

    //
    // first, check the Extensions to see if we should even display it!
    //
    cbUsage = 0;
    CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, NULL, &cbUsage);

    if (cbUsage > 0)
    {
        //
        //  we have some... make sure ours is in the list
        //
        if (!(pUsage = (CERT_ENHKEY_USAGE *)LocalAlloc(LPTR, cbUsage)))
        {
            return(FALSE);
        }

        CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, pUsage, &cbUsage);

        if (!(_SearchKeyUsage(pUsage, pszUsageIdentifier)))
        {
            LocalFree((void *)pUsage);
            return(FALSE);
        }

        LocalFree((void *)pUsage);
    }

    *pfFound = TRUE;    // the cert should go in the list!

    //
    //  ethier there where no assertions made by the CA or we found it!  continue on...
    //

    //
    //  second, check the properties to see if we should check the box
    //
    cbUsage = 0;
    CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, NULL, &cbUsage);

    if (cbUsage > 0)
    {
        // 
        //  we have properties... make sure we aren't disabled
        //
        if (!(pUsage = (CERT_ENHKEY_USAGE *)LocalAlloc(LPTR, cbUsage)))
        {
            return(FALSE);
        }

        CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, pUsage, &cbUsage);

        if (_SearchKeyUsage(pUsage, g_rgszEnhkeyUsage[EKU_DISABLE_OFF]))
        {
            //
            //  the user has disabled the cert... keep it in the list un-checked
            //
            LocalFree((void *)pUsage);

            return(FALSE);
        }

        if (!(_SearchKeyUsage(pUsage, pszUsageIdentifier)))
        {
            //
            //  the user has set some, but, disabled this one... keep in the list un-checked
            //
            LocalFree((void *)pUsage);

            return(FALSE);
        }

        LocalFree((void *)pUsage);
    }

    return(TRUE);
}


BOOL SiteCert_InitListView(LPSITECERTDIALOGINFO pscdi)
{
    PCCERT_CONTEXT  pCertContext = NULL;
    
    // delete all items currently in the listview
    // we'll get called back via LVN_DELETEITEM with the lParam so we can free the cert context
    ListView_DeleteAllItems(pscdi->hwndList);
    
    pscdi->hCertStore = CertOpenSystemStoreA(NULL, "ROOT");
    
    if (pscdi->hCertStore)
    {
        LPSTR pszEnhkeyUsage;
        
        INT_PTR iSel;
        
        iSel = SendMessage(pscdi->hwndCombo, CB_GETCURSEL, 0,0);
        
        pszEnhkeyUsage = (LPSTR)SendMessage(pscdi->hwndCombo, CB_GETITEMDATA, iSel, 0);
       
        while (pCertContext = CertEnumCertificatesInStore(pscdi->hCertStore, pCertContext))
        {
            CHAR  szCertA[MAX_PATH];
            TCHAR szCert[MAX_PATH];
            DWORD cbszCert = ARRAYSIZE(szCertA);
            DWORD dwEnabled;
            BOOL fFound;

            dwEnabled = _IsUsageEnabled(pCertContext, (LPSTR)pszEnhkeyUsage, &fFound);     

            // if not found, then continue with next
            if (!fFound)
                continue;
            
            //ParseX509EncodedCertificateForListBoxEntry(pCertContext->pbCertEncoded, pCertContext->cbCertEncoded, szCert, &cbszCert);
            ParseX509EncodedCertificateForListBoxEntry((BYTE *)pCertContext, -1, szCertA, &cbszCert);
#ifdef UNICODE
            SHAnsiToUnicode(szCertA, szCert, ARRAYSIZE(szCert));
#else
            StrCpy(szCert, szCertA);
#endif
            LV_ITEM lvi = { 0 };

            lvi.mask       = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
            lvi.iItem      = -1;
            lvi.pszText    = szCert; // (LPSTR)pCertContext->pCertInfo->Subject.pbData;
            lvi.cchTextMax = ARRAYSIZE(szCert); // pCertContext->pCertInfo->Subject.cbData;

            lvi.stateMask  = LVIS_STATEIMAGEMASK;
            lvi.state      = dwEnabled ? 0x00002000 : 0x00001000;
            lvi.lParam     = (LPARAM)CertDuplicateCertificateContext(pCertContext);
            
            // insert and set state
            ListView_SetItemState(pscdi->hwndList,
                                  ListView_InsertItem(pscdi->hwndList, &lvi),
                                  dwEnabled ? 0x00002000 : 0x00001000,
                                  LVIS_STATEIMAGEMASK);
            
        }
        // show the items
        ListView_RedrawItems(pscdi->hwndList, 0, ListView_GetItemCount(pscdi->hwndList));
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
////
////    08-Sep-1997: pberkman
////
////    PRIVATE function: _SiteCertAdjustProperties
////
////        based on what the user just checked/unchecked, set the 
////        appropriate OID usage or remove it.
////        
void _SiteCertAdjustProperties(LPSITECERTDIALOGINFO pscdi, NM_LISTVIEW *pListView)
{
    DWORD_PTR           dwSel;
    char                *pszOID;
    DWORD               cbUsage;
    CERT_ENHKEY_USAGE   *pUsage;


    //
    //  if we are in the initdialog get out!
    //
    if (pscdi->fInitializing)
    {
        return;
    }

    // 
    // make sure we have the property set
    //
    dwSel = SendMessage(pscdi->hwndCombo, CB_GETCURSEL, 0, 0);

    if (dwSel == CB_ERR)
    {
        return;
    }

    pszOID = (char*) SendMessage(pscdi->hwndCombo, CB_GETITEMDATA, (WPARAM)dwSel, 0);

    if (!(pszOID) || ((DWORD_PTR)pszOID == CB_ERR))
    {
        return;
    }

    if (pListView->uNewState & 0x00001000)  // unchecked
    {

        //
        //  the user unchecked one of the certs.
        //  
        //  1. if there are no properties, add all others -- HACKHACK!
        //
        cbUsage = 0;
        CertGetEnhancedKeyUsage((PCCERT_CONTEXT)pListView->lParam, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, 
                                NULL, &cbUsage);

        if (cbUsage == 0)
        {
            //  add all
            __AddAllKnownEKU((PCCERT_CONTEXT)pListView->lParam);

            //  remove this one
            CertRemoveEnhancedKeyUsageIdentifier((PCCERT_CONTEXT)pListView->lParam, pszOID);
        }
        else
        {
            if (!(pUsage = (CERT_ENHKEY_USAGE *)LocalAlloc(LPTR, cbUsage)))
            {
                return;
            }

            CertGetEnhancedKeyUsage((PCCERT_CONTEXT)pListView->lParam, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, 
                                        pUsage, &cbUsage);
            //
            //  2. if there are properties.
            //      a. if this is the last known one, and it matches this, delete it and add the "disable"
            //
            if (pUsage->cUsageIdentifier == 1)
            {
                if (StrCmpA(pUsage->rgpszUsageIdentifier[0], pszOID) ==  0)
                {
                    CertRemoveEnhancedKeyUsageIdentifier((PCCERT_CONTEXT)pListView->lParam, pszOID);
                    CertAddEnhancedKeyUsageIdentifier((PCCERT_CONTEXT)pListView->lParam, 
                                                        g_rgszEnhkeyUsage[EKU_DISABLE_OFF]);
                }
            }
            else
            {
                //
                //  b. if there are more than one, just try to remove this one
                //
                CertRemoveEnhancedKeyUsageIdentifier((PCCERT_CONTEXT)pListView->lParam, pszOID);
            }

            LocalFree((void *)pUsage);
        }

        return;
    }

    if (pListView->uNewState & 0x00002000)  // checked
    {
        CertAddEnhancedKeyUsageIdentifier((PCCERT_CONTEXT)pListView->lParam, pszOID);

        //
        //  just in case, remove the disable!
        //
        CertRemoveEnhancedKeyUsageIdentifier((PCCERT_CONTEXT)pListView->lParam, 
                                                    g_rgszEnhkeyUsage[EKU_DISABLE_OFF]);
    }
}

BOOL SiteCert_OnNotify(LPSITECERTDIALOGINFO pscdi, WPARAM wParam, LPARAM lParam)
{
    NM_LISTVIEW *pnmlv = (NM_LISTVIEW *)lParam;
    
    switch (pnmlv->hdr.code) {
        case LVN_ITEMCHANGED:
        {
            // check the current state of selection
            int iSel = ListView_GetNextItem(pscdi->hwndList, -1, LVNI_SELECTED);

            // check to see if we need to enable/disable the "DELETE" and "VIEW" buttons
            EnableWindow(GetDlgItem(pscdi->hDlg, IDC_DELETECERT), iSel != -1);
            EnableWindow(GetDlgItem(pscdi->hDlg, IDC_VIEWCERT), iSel != -1);
            
            if ((pnmlv->uChanged & LVIF_STATE) && (GetFocus() == pscdi->hwndList))
            {
                _SiteCertAdjustProperties(pscdi, pnmlv);
            }
            break;
        }
        case LVN_DELETEITEM:
            CertFreeCertificateContext((PCCERT_CONTEXT)pnmlv->lParam);
            break;
    }
    return TRUE;
}

typedef struct tagNEWSITECERTINFO
{
    LPVOID  lpvCertData;
    DWORD   cbCert;

    BOOL    fCertEnabled;
    BOOL    fNetworkClient;
    BOOL    fNetworkServer;
    BOOL    fSecureEmail;
    BOOL    fSoftwarePublishing; 

} NEWSITECERTINFO, *LPNEWSITECERTINFO;


BOOL NewSiteCert_AddCert(LPNEWSITECERTINFO pnsci)
{

    HCERTSTORE      hCertStore = NULL;
    PCCERT_CONTEXT  pCertContext;
    BOOL            fRet = FALSE;

    hCertStore = CertOpenSystemStoreA(NULL, "ROOT");

    if (hCertStore)
    {
        pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                    (LPBYTE)(pnsci->lpvCertData),
                                                    pnsci->cbCert);

        if (pCertContext)
        {
            if (CertCompareCertificateName(X509_ASN_ENCODING,
                                           &pCertContext->pCertInfo->Subject,
                                           &pCertContext->pCertInfo->Issuer))
            {

                CertFreeCertificateContext(pCertContext);
                
                fRet = CertAddEncodedCertificateToStore(hCertStore,
                                                        X509_ASN_ENCODING,
                                                        (LPBYTE)(pnsci->lpvCertData),
                                                        pnsci->cbCert,
                                                        CERT_STORE_ADD_REPLACE_EXISTING,
                                                        &pCertContext);
                if (fRet)
                {
#                   define l_USAGE_MAX      24

                    CERT_ENHKEY_USAGE ceku = {0};
                    LPSTR rgpszUsageIdentifier[l_USAGE_MAX];
                    
                    if (pnsci->fNetworkClient)
                    {
                        rgpszUsageIdentifier[ceku.cUsageIdentifier] = g_rgszEnhkeyUsage[EKU_CLIENT_OFF];
                        if (rgpszUsageIdentifier[ceku.cUsageIdentifier])
                            ceku.cUsageIdentifier++;
                    }
                    if (pnsci->fNetworkServer)
                    {
                        rgpszUsageIdentifier[ceku.cUsageIdentifier] = g_rgszEnhkeyUsage[EKU_SERVER_OFF];
                        if (rgpszUsageIdentifier[ceku.cUsageIdentifier])
                            ceku.cUsageIdentifier++;
                    }
                    if (pnsci->fSecureEmail)
                    {
                        rgpszUsageIdentifier[ceku.cUsageIdentifier] = g_rgszEnhkeyUsage[EKU_EMAIL_OFF];
                        if (rgpszUsageIdentifier[ceku.cUsageIdentifier])
                            ceku.cUsageIdentifier++;
                    }
                    if (pnsci->fSoftwarePublishing)
                    {
                        rgpszUsageIdentifier[ceku.cUsageIdentifier] = g_rgszEnhkeyUsage[EKU_CODESIGN_OFF];
                        if (rgpszUsageIdentifier[ceku.cUsageIdentifier])
                            ceku.cUsageIdentifier++;
                    }

                    if (!(pnsci->fCertEnabled))
                    {
                        // turn everything off!!!
                        rgpszUsageIdentifier[ceku.cUsageIdentifier] = g_rgszEnhkeyUsage[EKU_DISABLE_OFF];
                        if (rgpszUsageIdentifier[ceku.cUsageIdentifier])
                            ceku.cUsageIdentifier++;
                    }

                    //
                    //  now, add any "unknown" extensions that the CA may have put on just
                    //  so verification will succeed!
                    //
                    CERT_ENHKEY_USAGE   *pUsage;
                    DWORD               cbUsage;
                    DWORD               i;

                    pUsage  = NULL;
                    cbUsage = 0;
                    CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, NULL, &cbUsage);

                    if (cbUsage > 0)
                    {
                        if (pUsage = (PCERT_ENHKEY_USAGE)LocalAlloc(LMEM_FIXED, cbUsage))
                        {
                            CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, 
                                                    pUsage, &cbUsage);

                            for (i = 0; i < pUsage->cUsageIdentifier; i++)
                            {
                                if (ceku.cUsageIdentifier >= l_USAGE_MAX)
                                {
                                    break;
                                }

                                if (pUsage->rgpszUsageIdentifier[i])
                                {
                                    if (!(_IsKnownUsage(pUsage->rgpszUsageIdentifier[i])))
                                    {
                                        rgpszUsageIdentifier[ceku.cUsageIdentifier] = pUsage->rgpszUsageIdentifier[i];
                                        ceku.cUsageIdentifier++;
                                    }
                                }
                            }
                        }
                    }

                    ceku.rgpszUsageIdentifier = (LPSTR *)rgpszUsageIdentifier;
                    fRet = CertSetEnhancedKeyUsage(pCertContext, &ceku);
                    
                    if (pUsage)
                    {
                        LocalFree((void *)pUsage);
                    }

                    CertFreeCertificateContext(pCertContext);
                }
            }
        }
        CertCloseStore(hCertStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return fRet;
}

//////////////////////////////////////////////////////////////////////////
////
////    15-Aug-1997: pberkman
////
////    PRIVATE function: NewSiteCert_SetAvailableAuthorityCheckboxes
////
////        set the check boxes in the "New Site Certificate" dialog box
////        based on the Authority Extensions and Properties.
////
////        if there are no Authority Ext or Prop's, then the certificate
////        has the potential for the user to enable for all.  Otherwise,
////        the user can ONLY select the ones that the issuer (or MS) has
////        entrusted the certificate for.
////        
typedef struct l_CERTUSAGES_
{
    char        *pszOID;
    DWORD       dwControlId;
    BOOL        fEnabled;

} l_CERTUSAGES;

BOOL NewSiteCert_SetAvailableAuthorityCheckboxes(HWND hDlg, LPNEWSITECERTINFO pnsci,
                                                 BOOL fInitialize)
{
    l_CERTUSAGES    asUsages[] =
    {
        szOID_PKIX_KP_CLIENT_AUTH,      IDC_CHECK_NETWORK_CLIENT,       FALSE,
        szOID_PKIX_KP_SERVER_AUTH,      IDC_CHECK_NETWORK_SERVER,       FALSE,
        szOID_PKIX_KP_EMAIL_PROTECTION, IDC_CHECK_SECURE_EMAIL,         FALSE,
        szOID_PKIX_KP_CODE_SIGNING,     IDC_CHECK_SOFTWARE_PUBLISHING,  FALSE,
        NULL, 0, FALSE
    };

    l_CERTUSAGES        *psUsages;
    PCCERT_CONTEXT      pCertContext;
    DWORD               cbUsage;
    PCERT_ENHKEY_USAGE  pUsage;
    
    if (fInitialize)
    {
        CheckDlgButton(hDlg, IDC_CHECK_ENABLE_CERT,         BST_CHECKED);
        
        CheckDlgButton(hDlg, IDC_CHECK_NETWORK_CLIENT,      BST_CHECKED);
        CheckDlgButton(hDlg, IDC_CHECK_NETWORK_SERVER,      BST_CHECKED);
        CheckDlgButton(hDlg, IDC_CHECK_SECURE_EMAIL,        BST_CHECKED);
        CheckDlgButton(hDlg, IDC_CHECK_SOFTWARE_PUBLISHING, BST_CHECKED);
    }

    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                (LPBYTE)(pnsci->lpvCertData),
                                                 pnsci->cbCert);

    if (!(pCertContext))
    {
        psUsages = &asUsages[0];

        while (psUsages->pszOID)
        {
            EnableWindow(GetDlgItem(hDlg, psUsages->dwControlId), TRUE);

            psUsages++;
        }

        return(FALSE);
    }

    cbUsage = 0;

    CertGetEnhancedKeyUsage(pCertContext, 0, NULL, &cbUsage);

    if (cbUsage < 1)
    {
        // none defined... leave all enabled.
        CertFreeCertificateContext(pCertContext);
        psUsages = &asUsages[0];

        while (psUsages->pszOID)
        {
            EnableWindow(GetDlgItem(hDlg, psUsages->dwControlId), TRUE);

            psUsages++;
        }

        return(TRUE);
    }

    if (!(pUsage = (PCERT_ENHKEY_USAGE)LocalAlloc(LMEM_FIXED, cbUsage)))
    {
        CertFreeCertificateContext(pCertContext);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (!(CertGetEnhancedKeyUsage(pCertContext, 0, pUsage, &cbUsage)))
    {
        CertFreeCertificateContext(pCertContext);
        LocalFree(pUsage);
        return(FALSE);
    }

    if (pUsage->cUsageIdentifier == 0)
    {
        CertFreeCertificateContext(pCertContext);
        LocalFree(pUsage);
        // none defined... leave all enabled.
        return(TRUE);
    }

    CertFreeCertificateContext(pCertContext);

    for (int i = 0; i < (int)pUsage->cUsageIdentifier; i++)
    {
        psUsages = &asUsages[0];

        while (psUsages->pszOID)
        {
            if (StrCmpA(pUsage->rgpszUsageIdentifier[i], psUsages->pszOID) == 0)
            {
                psUsages->fEnabled = TRUE;
            }
            psUsages++;
        }
    }

    LocalFree(pUsage);

    psUsages = &asUsages[0];

    while (psUsages->pszOID)
    {
        if (fInitialize)
        {
            CheckDlgButton(hDlg, psUsages->dwControlId,      
                           (psUsages->fEnabled) ? BST_CHECKED : BST_UNCHECKED);
        }

        EnableWindow(GetDlgItem(hDlg, psUsages->dwControlId), psUsages->fEnabled);

        psUsages++;
    }

    return(TRUE);
}

void NewSiteCert_CenterDialog(HWND hDlg)
{
    RECT    rcDlg;
    RECT    rcArea;
    RECT    rcCenter;
    HWND    hWndParent;
    HWND    hWndCenter;
    DWORD   dwStyle;
    int     w_Dlg;
    int     h_Dlg;
    int     xLeft;
    int     yTop;

    GetWindowRect(hDlg, &rcDlg);

    dwStyle = (DWORD)GetWindowLong(hDlg, GWL_STYLE);

    if (dwStyle & WS_CHILD)
    {
        hWndCenter = GetParent(hDlg);

        hWndParent = GetParent(hDlg);

        GetClientRect(hWndParent, &rcArea);
        GetClientRect(hWndCenter, &rcCenter);
        MapWindowPoints(hWndCenter, hWndParent, (POINT *)&rcCenter, 2);
    }
    else
    {
        hWndCenter = GetWindow(hDlg, GW_OWNER);

        if (hWndCenter)
        {
            dwStyle = (DWORD)GetWindowLong(hWndCenter, GWL_STYLE);

            if (!(dwStyle & WS_VISIBLE) || (dwStyle & WS_MINIMIZE))
            {
                hWndCenter = NULL;
            }
        }

        SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);

        if (hWndCenter)
        {
            GetWindowRect(hWndCenter, &rcCenter);
        }
        else
        {
            rcCenter = rcArea;
        }
        
    }

    w_Dlg   = rcDlg.right - rcDlg.left;
    h_Dlg   = rcDlg.bottom - rcDlg.top;

    xLeft   = (rcCenter.left + rcCenter.right) / 2 - w_Dlg / 2;
    yTop    = (rcCenter.top + rcCenter.bottom) / 2 - h_Dlg / 2;
    
    if (xLeft < rcArea.left)
    {
        xLeft = rcArea.left;
    }
    else if ((xLeft + w_Dlg) > rcArea.right)
    {
        xLeft = rcArea.right - w_Dlg;
    }

    if (yTop < rcArea.top)
    {
        yTop = rcArea.top;
    }
    else if ((yTop + h_Dlg) > rcArea.bottom)
    {
        yTop = rcArea.bottom - h_Dlg;
    }

    SetWindowPos(hDlg, NULL, xLeft, yTop, -1, -1, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
}


INT_PTR CALLBACK NewSiteCert_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPNEWSITECERTINFO pnsci = (LPNEWSITECERTINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {
        case WM_INITDIALOG:
        {
            DWORD  dwFileSize;
            DWORD  cbRead;
            HANDLE hf;
            LPTSTR lpszCmdLine = (LPTSTR)lParam;
            DWORD  dwError;

            hf = CreateFile(lpszCmdLine, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0,  NULL);
            if (hf == INVALID_HANDLE_VALUE)
            {
                dwError = GetLastError();
                goto initError;
            }

            dwFileSize = GetFileSize(hf, NULL);
            if (dwFileSize == (unsigned)-1)
                goto initError;

            pnsci = (LPNEWSITECERTINFO)LocalAlloc(LPTR, sizeof(*pnsci));
            if (!pnsci)
                goto initError;

            pnsci->lpvCertData = LocalAlloc(LPTR, dwFileSize);
            if (!pnsci->lpvCertData)
                goto initError;

            pnsci->cbCert      = dwFileSize;

            if (!ReadFile(hf, pnsci->lpvCertData, dwFileSize, &cbRead, NULL) || cbRead != dwFileSize)
                goto initError;

            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pnsci);  // save pointer to cert

            //
            //  ok check to make sure that 1) it's a cert file and 2) it's a root!
            //
            PCCERT_CONTEXT  pCertContext;

            dwError = S_FALSE;

            pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                        (LPBYTE)(pnsci->lpvCertData),
                                                        pnsci->cbCert);

            if (pCertContext)
            {
                if (CertCompareCertificateName(X509_ASN_ENCODING,
                                               &pCertContext->pCertInfo->Subject,
                                               &pCertContext->pCertInfo->Issuer))
                {
                    dwError = S_OK;
                }
             
                CertFreeCertificateContext(pCertContext);
            }

            if (dwError != S_OK)
            {
                goto initError;
            }

            NewSiteCert_SetAvailableAuthorityCheckboxes(hDlg, pnsci, TRUE);

            NewSiteCert_CenterDialog(hDlg);

            break;

initError:
            TCHAR   szTitle[MAX_PATH + 1];
            TCHAR   szError[MAX_PATH + 1];

            MLLoadShellLangString(IDS_CERT_FILE_INVALID, &szError[0], MAX_PATH);
            MLLoadShellLangString(IDS_ERROR, &szTitle[0], MAX_PATH);
            MessageBox(GetFocus(), &szError[0], &szTitle[0], MB_OK | MB_ICONERROR);

            EndDialog(hDlg, IDCANCEL);
            return FALSE;            
        }

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    pnsci->fCertEnabled         = IsDlgButtonChecked(hDlg, IDC_CHECK_ENABLE_CERT);
                    pnsci->fNetworkClient       = IsDlgButtonChecked(hDlg, IDC_CHECK_NETWORK_CLIENT);
                    pnsci->fNetworkServer       = IsDlgButtonChecked(hDlg, IDC_CHECK_NETWORK_SERVER);
                    pnsci->fSecureEmail         = IsDlgButtonChecked(hDlg, IDC_CHECK_SECURE_EMAIL);
                    pnsci->fSoftwarePublishing  = IsDlgButtonChecked(hDlg, IDC_CHECK_SOFTWARE_PUBLISHING);

                    NewSiteCert_AddCert(pnsci);

                    EndDialog(hDlg, IDOK);
                    break;
                }

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_VIEWCERT:
                    ShowX509EncodedCertificate(hDlg, (LPBYTE)pnsci->lpvCertData, pnsci->cbCert);
                    break;

                case IDC_CHECK_ENABLE_CERT:

                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        BOOL    fEnableCert;

                        fEnableCert = IsDlgButtonChecked(hDlg, IDC_CHECK_ENABLE_CERT);

                        if (!(fEnableCert))
                        {
                            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_NETWORK_CLIENT),        fEnableCert);
                            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_NETWORK_SERVER),        fEnableCert);
                            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_SECURE_EMAIL),          fEnableCert);
                            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_SOFTWARE_PUBLISHING),   fEnableCert);
                        }
                        else
                        {
                            NewSiteCert_SetAvailableAuthorityCheckboxes(hDlg, pnsci, FALSE);
                        }
                    }

                    return(FALSE);

                default:
                    return FALSE;
            }
            return TRUE;                
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            if (pnsci)
            {
                if (pnsci->lpvCertData)
                    LocalFree(pnsci->lpvCertData);
                LocalFree(pnsci);
            }
            break;
    }
    return FALSE;
}

STDAPI SiteCert_RunFromCmdLine(HINSTANCE hinst, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow)
{

    if ((!lpszCmdLine) || (*lpszCmdLine == TEXT('\0')))
        return -1;

    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_NEWSITECERT),
                   NULL, NewSiteCert_DlgProc, (LPARAM)lpszCmdLine);

    return 0;
}



// Helper function for ExportPFX
#define NUM_KNOWN_STORES 5
BOOL OpenAndAllocKnownStores(DWORD *pchStores, HCERTSTORE  **ppahStores)
{
    HCERTSTORE  hStore;
    int i;
    static const LPCTSTR rszStoreNames[NUM_KNOWN_STORES] = {
        TEXT("ROOT"), 
        TEXT("TRUST"),
        TEXT("CA"),
        TEXT("MY"),
        TEXT("SPC")
    };
    
    *pchStores = 0;

    if (NULL == ((*ppahStores) = (HCERTSTORE *) LocalAlloc(LPTR, sizeof(HCERTSTORE) * NUM_KNOWN_STORES)))
    {
         return (FALSE);
    }

    for (i=0; i< NUM_KNOWN_STORES; i++)
    {
        (*ppahStores)[i] = NULL;
        if (hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                    0,
                                    0,
                                    CERT_SYSTEM_STORE_CURRENT_USER |
                                    CERT_STORE_READONLY_FLAG |
                                    CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                    rszStoreNames[i]))
            (*ppahStores)[(*pchStores)++] = hStore;
    }
    
    return(TRUE);
}

// Helper function for ExportPFX
void CloseAndFreeKnownStores(HCERTSTORE  *pahStores)
{ 
    int i;

    for (i=0; i<NUM_KNOWN_STORES; i++)
    {
        if (pahStores[i] != NULL)
        {
           CertCloseStore(pahStores[i], 0);
        }
    }

    LocalFree(pahStores);
}



enum {PFX_IMPORT, PFX_EXPORT};

typedef struct 
{
    HWND            hDlg;                     // handle to window
    DWORD           dwImportExport;           // import or export?
    BOOL            fUseExisting;             // use existing cert if collision on import
    PCCERT_CONTEXT  pCertContext;    // context to export or NULL
    LPWSTR          pwszPassword;             // password for import/export
    LPWSTR          pwszPassword2;          // prompt user twice on exports!
    LPTSTR          pszPath;                 // file for import/export

} IMPORTEXPORT, *LPIMPORTEXPORT;

#define MAX_PASSWORD 32

// CreateCertFile: change working directory to "MyDocs", do CreateFile, restore old working directory
HANDLE CreateCertFile(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
        DWORD dwCreationDistribution, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
    TCHAR szOldDir[MAX_PATH];
    TCHAR szCertDir[MAX_PATH];
    HANDLE hFile;
    LPITEMIDLIST pidl;
    
    GetCurrentDirectory(ARRAYSIZE(szOldDir), szOldDir);
    if (SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl) == NOERROR)
    {
        SHGetPathFromIDList(pidl, szCertDir);
        SetCurrentDirectory(szCertDir);
        ILFree(pidl);                        
    }
    hFile = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, 
        dwCreationDistribution, dwFlagsAndAttributes, hTemplateFile);
    SetCurrentDirectory(szOldDir);
    
    return hFile;
}

//////////////////////////////////////////////////////////////////////////
//
//  09-Sep-1997 pberkman:
//          determine if the exact cert is in the passed store
//

BOOL __IsCertInStore(PCCERT_CONTEXT pCertContext, HCERTSTORE hStore)
{
    //
    //  can't do it the fast way -- do it the slow way!
    //
    BYTE            *pbHash;
    DWORD           cbHash;
    CRYPT_HASH_BLOB sBlob;
    PCCERT_CONTEXT  pWorkContext;

    cbHash = 0;

    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, NULL, &cbHash)))
    {
        return(FALSE);
    }

    if (cbHash < 1)
    {
        return(FALSE);
    }

    if (!(pbHash = new BYTE[cbHash]))
    {
        return(FALSE);
    }

    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, pbHash, &cbHash)))
    {
        delete pbHash;
        return(FALSE);
    }

    sBlob.cbData    = cbHash;
    sBlob.pbData    = pbHash;

    pWorkContext = CertFindCertificateInStore(hStore, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,
                                              CERT_FIND_SHA1_HASH, &sBlob, NULL);

    delete pbHash;

    if (pWorkContext)
    {
        CertFreeCertificateContext(pWorkContext);
        return(TRUE);
    }

    return(FALSE);
}

//////////////////////////////////////////////////////////////////////////
//
//  09-Sep-1997 pberkman:
//          importing a cert from a file.
//

BOOL ImportPFX(LPIMPORTEXPORT pImp)
{   
#   define MY_STORE         0
#   define CA_STORE         1
#   define ROOT_STORE       2
#   define MAX_STORE        3
    HCERTSTORE          pahStores[MAX_STORE];
    HCERTSTORE          hCertStore;
    BOOL                fAdded;
    DWORD               dwAddFlags;
    
    HANDLE              hFile;
    CRYPT_DATA_BLOB     sData;  
    
    BOOL                fRet;
    PCCERT_CONTEXT      pCertCtxt;
    DWORD               cbRead;
    DWORD               dwImportFlags;
    int                 i;

    fRet            = FALSE;
    dwImportFlags   = CRYPT_EXPORTABLE;
    pCertCtxt       = NULL;
    hCertStore      = NULL;

    for (i = 0; i < MAX_STORE; i++)
    {
        pahStores[i] = NULL;
    }

    ZeroMemory(&sData, sizeof(CRYPT_DATA_BLOB));
    
    hFile = CreateCertFile(pImp->pszPath, GENERIC_READ, FILE_SHARE_READ,
                           NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        goto Cleanup;
    }
        
    dwAddFlags      = (pImp->fUseExisting) ? CERT_STORE_ADD_USE_EXISTING :
                                             CERT_STORE_ADD_REPLACE_EXISTING;
    
    sData.cbData = GetFileSize(hFile, NULL);
    sData.pbData = (PBYTE)LocalAlloc(LMEM_FIXED, sData.cbData);

    if (!(sData.pbData))
    {
        goto Cleanup;
    }

    if (!(ReadFile(hFile, sData.pbData, sData.cbData, &cbRead, NULL)))
    {
        goto Cleanup;
    }
    
    if ((pImp->pwszPassword) && (!(*pImp->pwszPassword)))     // if no password, use null.
    {
        pImp->pwszPassword = NULL;
    }
    
    if (!(hCertStore = PFXImportCertStore(&sData, pImp->pwszPassword, dwImportFlags)))
    {
        goto Cleanup;
    }

    //
    //  now we have in memory hStore enumerate the cert contexts
    //  and drop them into destination store
    //
    if (!(pahStores[MY_STORE]   = CertOpenSystemStoreA(NULL, "MY")) ||
        !(pahStores[CA_STORE]   = CertOpenSystemStoreA(NULL, "CA")) ||
        !(pahStores[ROOT_STORE] = CertOpenSystemStoreA(NULL, "ROOT")))
    {
        goto Cleanup;
    }

    while (pCertCtxt = CertEnumCertificatesInStore(hCertStore, pCertCtxt))
    {
        fAdded = FALSE;
        cbRead = 0;
        CertGetCertificateContextProperty(pCertCtxt, CERT_KEY_PROV_INFO_PROP_ID, NULL, &cbRead);
        
        if (cbRead > 0) // pfx added a public key prop
        {
            CertAddCertificateContextToStore(pahStores[MY_STORE], pCertCtxt, dwAddFlags, NULL);
            continue;
        }

        //
        //  first, check if we already have this cert in one of our stores
        //
        for (i = 0; i < MAX_STORE; i++)
        {
            if (__IsCertInStore(pCertCtxt, pahStores[i]))
            {
                //
                // the same cert, exactly, is already in one of our stores!
                //
                fAdded = TRUE;
                break;
            }
        }

        if (!(fAdded))
        {
            CertAddCertificateContextToStore(pahStores[CA_STORE], pCertCtxt, dwAddFlags, NULL);
        }
    }

    fRet = TRUE;

Cleanup:
    
    if (sData.pbData)
    {
        LocalFree(sData.pbData);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    if (hCertStore)
    {
        CertCloseStore(hCertStore, 0);
    }

    for (i = 0; i < MAX_STORE; i++)
    {
        if (pahStores[i])
        {
            CertCloseStore(pahStores[i], 0);
        }
    }
    
    return(fRet);
}

typedef PCCERT_CONTEXT (* PFNWTHELPER) (PCCERT_CONTEXT /* pChildContext */, 
                                        DWORD          /* chStores      */,
                                        HCERTSTORE *   /* pahStores     */,
                                        FILETIME *     /* psftVerifyAsOf*/,
                                        DWORD          /* dwEncoding    */,
                                        DWORD *        /* pdwConfidence */,
                                        DWORD *        /* pdwError      */ );



BOOL ExportPFX(LPIMPORTEXPORT pImp)
{
    BOOL                    fRet = FALSE;
    HANDLE                  hFile = NULL;
    CRYPT_DATA_BLOB         sData;  
    DWORD                   cbRead;
    HCERTSTORE              hSrcCertStore;        
    DWORD                   dwExportFlags = 4; //  4 == EXPORT_PRIVATE_KEYS;
    TCHAR                   szText[MAX_PATH], szTitle[80];
    PCCERT_CONTEXT pTempCertContext;
    HCERTSTORE	*phCertStores = NULL;
    DWORD		chCertStores = 0;
    DWORD		dwConfidence;
    DWORD		dwError;
    HINSTANCE hiWintrust = NULL;
    PFNWTHELPER WTHelperCertFindIssuerCertificate;
    

    if (!pImp->pCertContext)
        return FALSE;

    ZeroMemory(&sData, sizeof(CRYPT_DATA_BLOB));

    // create an in memory store
    hSrcCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY,
                                  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                  0,
                                  0,
                                  NULL);

    if (!CertAddCertificateContextToStore(hSrcCertStore, pImp->pCertContext, CERT_STORE_ADD_REPLACE_EXISTING, NULL))
        goto Cleanup;
    
    // Load helper function from wintrust.dll
    hiWintrust = LoadLibrary(TEXT("WINTRUST.DLL"));
    WTHelperCertFindIssuerCertificate = (PFNWTHELPER) GetProcAddress(hiWintrust,"WTHelperCertFindIssuerCertificate");
    if (WTHelperCertFindIssuerCertificate)
    {
        // Load all the top level stores, so we can export from them if necessary
        if (OpenAndAllocKnownStores(&chCertStores, &phCertStores))
        {
            // Find the intermediate certifcates, and add them to the store that we will be exporting
            pTempCertContext = pImp->pCertContext;
            while (NULL != ( pTempCertContext = WTHelperCertFindIssuerCertificate(pTempCertContext,
                                                    chCertStores,
                                                    phCertStores,
                                                    NULL,
                                                    X509_ASN_ENCODING,
                                                    &dwConfidence,
                                                    &dwError)))
            {
                CertAddCertificateContextToStore(hSrcCertStore, pTempCertContext, CERT_STORE_ADD_REPLACE_EXISTING, NULL);

                // Break out if we find a root (self-signed) cert
                if (CertCompareCertificateName(X509_ASN_ENCODING,
                                               &pTempCertContext->pCertInfo->Subject,
                                               &pTempCertContext->pCertInfo->Issuer))
                    break;
            } 

            CloseAndFreeKnownStores(phCertStores);
        }
    }

    //
    //  This first call simply gets the size of the crypt blob
    //
    if (!PFXExportCertStore(hSrcCertStore, &sData, pImp->pwszPassword, dwExportFlags))
    {
        goto Cleanup;
    }

    //  Alloc based on cbData
    sData.pbData = (PBYTE)LocalAlloc(LMEM_FIXED, sData.cbData);

    //
    //  Now actually get the data
    //
    if (!(*pImp->pwszPassword))         // no password use null
        pImp->pwszPassword = NULL;
    
    if (!PFXExportCertStore(hSrcCertStore, &sData, pImp->pwszPassword, dwExportFlags))
    {
        goto Cleanup;
    }

    //  Open the PFX file
    hFile = CreateCertFile(pImp->pszPath,
                       GENERIC_WRITE,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)  {
        goto Cleanup;
    }

    //  Write to it
    if (!WriteFile(hFile,
                   sData.pbData,
                   sData.cbData,
                   &cbRead,
                   NULL)) {
        goto Cleanup;
    }

    // Display message about certs exporting OK.
    MLLoadShellLangString(IDS_CERT_EXPORTOKTEXT, szText, ARRAYSIZE(szText));
    MLLoadShellLangString(IDS_CERT_EXPORTOKTITLE, szTitle, ARRAYSIZE(szTitle));

    MessageBox(pImp->hDlg, szText, szTitle, MB_ICONINFORMATION | MB_OK);

    fRet = TRUE;

Cleanup:
    if (hiWintrust)
        FreeLibrary(hiWintrust);
    if (hSrcCertStore)
        CertCloseStore(hSrcCertStore, 0);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (sData.pbData)
        LocalFree(sData.pbData);

    return fRet;
}
 
INT_PTR CALLBACK ImportExportDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPIMPORTEXPORT pImp;

    if (uMsg == WM_INITDIALOG)
    {
        pImp = (LPIMPORTEXPORT)lParam;    // this is passed in to us
        if (!pImp)
        {
            EndDialog(hDlg, 0);
            return FALSE;
        }

        // tell dialog where to get info
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pImp);

        // save handle to the page
        pImp->hDlg           = hDlg;

        // limit the password to 32 chars
        SendMessage(GetDlgItem(hDlg, IDC_PASSWORD), EM_LIMITTEXT, MAX_PASSWORD, 0);

        //
        // 03-Oct-1997 pberkman: always verify password!
        //
        if (pImp->dwImportExport == PFX_EXPORT)
        {
            SendMessage(GetDlgItem(hDlg, IDC_PASSWORD2), EM_LIMITTEXT, MAX_PASSWORD, 0);
        }

        SHAutoComplete(GetDlgItem(hDlg, IDC_FILENAME), SHACF_DEFAULT);      // This control exists in both IDD_PFX_IMPORT and IDD_PFX_EXPORT
        
        // only set these on import, since they don't exist on export =)
        // =========================================================================
        //  03-Oct-1997 pberkman: no user decisions!
        //
        // if (pImp->dwImportExport == PFX_IMPORT)
        // {
        //     CheckRadioButton(hDlg, IDC_USE_EXISTING, IDC_USE_FILE, IDC_USE_EXISTING);                        
        // }            
        // ==========================================================================
        SetFocus(GetDlgItem(hDlg, IDC_PASSWORD));

    }   // WM_INITDIALOG
    
    else
        pImp = (LPIMPORTEXPORT)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pImp)
        return FALSE;
    
    switch (uMsg)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_CERT_BROWSE:
                {
                    TCHAR szFilenameBrowse[MAX_PATH];
                    TCHAR szExt[MAX_PATH];
                    TCHAR szFilter[MAX_PATH];
                    int   ret;
                    LPITEMIDLIST pidl;
                    TCHAR szWorkingDir[MAX_PATH];
                   
                    szFilenameBrowse[0] = 0;
                    MLLoadString(IDS_PFX_EXT, szExt, ARRAYSIZE(szExt));
                    int cchFilter = MLLoadString(IDS_PFX_FILTER, szFilter, ARRAYSIZE(szFilter)-1);

                    // Make sure we have a double null termination on the filter
                    szFilter[cchFilter + 1] = 0;

                    if (SHGetSpecialFolderLocation(hDlg, CSIDL_PERSONAL, &pidl) == NOERROR)
                    {
                        SHGetPathFromIDList(pidl, szWorkingDir);
                        ILFree(pidl);                        
                    }

                    ret = _AorW_GetFileNameFromBrowse(hDlg, szFilenameBrowse, ARRAYSIZE(szFilenameBrowse), szWorkingDir, 
                        szExt, szFilter, NULL);
                    
                    if (ret > 0)
                    {
                        SetDlgItemText(hDlg, IDC_FILENAME, szFilenameBrowse);
                    }
                    break;
                }
                
                case IDOK:
                {
                    TCHAR szPassword[MAX_PASSWORD];
                    TCHAR szPassword2[MAX_PASSWORD];
                    TCHAR szPath[MAX_PATH];
                    BOOL bRet;
                    
                    szPassword[0] = NULL;
                    GetWindowText(GetDlgItem(hDlg, IDC_PASSWORD), szPassword, ARRAYSIZE(szPassword));
                    GetWindowText(GetDlgItem(hDlg, IDC_FILENAME), szPath,     ARRAYSIZE(szPath));

                    //
                    //  03-Oct-1997 pberkman: always double check password!
                    //
                    if (pImp->dwImportExport == PFX_EXPORT)
                    {
                        szPassword2[0] = NULL;
                        GetWindowText(GetDlgItem(hDlg, IDC_PASSWORD2), szPassword2, ARRAYSIZE(szPassword2));

                        if (StrCmp(szPassword, szPassword2) != 0)
                        {
                            TCHAR   szTitle[MAX_PATH + 1];
                            TCHAR   szError[MAX_PATH + 1];

                            MLLoadShellLangString(IDS_PASSWORDS_NOMATCH, &szError[0], MAX_PATH);
                            MLLoadShellLangString(IDS_ERROR, &szTitle[0], MAX_PATH);
                            MessageBox(GetFocus(), &szError[0], &szTitle[0], MB_OK | MB_ICONERROR);

                            SetFocus(GetDlgItem(hDlg, IDC_PASSWORD));

                            break;
                        }
                    }

                    // Add a default extension on export
                    if (pImp->dwImportExport == PFX_EXPORT)
                        if (szPath[0] != TEXT('\0') && PathAddExtension(szPath, TEXT(".PFX")))
                            SetWindowText(GetDlgItem(hDlg, IDC_FILENAME), szPath);

#ifndef UNICODE
                    WCHAR wszPassword[MAX_PASSWORD];
                    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szPassword, -1, wszPassword, ARRAYSIZE(wszPassword));
                    pImp->pwszPassword = wszPassword;
#else
                    pImp->pwszPassword = szPassword;
#endif
                    pImp->pszPath = szPath;
                    
                    if (pImp->dwImportExport == PFX_IMPORT)
                    {
                        // =========================================================================
                        //  03-Oct-1997 pberkman: no user decisions!
                        //
                        // pImp->fUseExisting = IsDlgButtonChecked(hDlg, IDC_USE_EXISTING);
                        // =========================================================================
                        pImp->fUseExisting = FALSE;
                        bRet = ImportPFX(pImp);

                        if (!(bRet) && (GetLastError() == NTE_BAD_DATA))
                        {
                            // message....
                        }
                    }
                    else
                    {
                        bRet = ExportPFX(pImp);
                    }
                    
                    EndDialog(hDlg, bRet);
                    break;
                }
                
                case IDCANCEL:
                    EndDialog(hDlg, TRUE); // Cancel is not an error
                    break;

            }
            break;
            
        case WM_NOTIFY:
            break;
// No context sensitive help yet...
#if 0
        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
#endif
        case WM_DESTROY:
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            break;
    }
    return FALSE;
}


#ifdef UNIX
EXTERN_C
#endif
INT_PTR ImportExportPFX(HWND hwndParent, DWORD dwImportExport, LPBYTE pbCert, DWORD cbCert)
{
    IMPORTEXPORT    imp;

    if (pbCert)
    {
        CRYPT_HASH_BLOB  hashBlob;
        HCERTSTORE       hMy = CertOpenSystemStoreA(NULL, "MY");
        DWORD            cbSHA1Hash;
        LPBYTE           pbSHA1Hash;

        if (!hMy)
            return FALSE;
        
        if (CryptHashCertificate(NULL, 0, 0, pbCert, cbCert, NULL, &cbSHA1Hash))
        {
            pbSHA1Hash = (LPBYTE)LocalAlloc(LPTR, cbSHA1Hash);
            if (!pbSHA1Hash)
                return FALSE;

            if (CryptHashCertificate(NULL, 0, 0, pbCert, cbCert, pbSHA1Hash, &cbSHA1Hash))
            {                                
                hashBlob.cbData = cbSHA1Hash;
                hashBlob.pbData = pbSHA1Hash;
                imp.pCertContext = CertFindCertificateInStore(hMy, X509_ASN_ENCODING, 0, CERT_FIND_HASH, &hashBlob, NULL);
                if (!(imp.pCertContext))
                    return FALSE;
            }

            LocalFree(pbSHA1Hash);
        }

        CertCloseStore(hMy, 0);
    }

    imp.dwImportExport = dwImportExport;
    
    return DialogBoxParam(MLGetHinst(),
                   dwImportExport == PFX_IMPORT ? MAKEINTRESOURCE(IDD_PFX_IMPORT) : MAKEINTRESOURCE(IDD_PFX_EXPORT),
                   hwndParent, ImportExportDlgProc, (LPARAM)&imp);
}

//BUBUG: The following function should be rermoved when we have updated our Crypto API to latest
BOOL WINAPI WTHelperIsInRootStore(PCCERT_CONTEXT pCertContext)
{
    HCERTSTORE  hStore;

    if (!(hStore = CertOpenStore(   CERT_STORE_PROV_SYSTEM_A,
                                    0,
                                    NULL,
                                    CERT_SYSTEM_STORE_CURRENT_USER |
                                    CERT_STORE_READONLY_FLAG |
                                    CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                    "ROOT")))
    {
        return(FALSE);
    }


    //
    //  can't do it the fast way -- do it the slow way!
    //
    BYTE            *pbHash;
    DWORD           cbHash;
    CRYPT_HASH_BLOB sBlob;
    PCCERT_CONTEXT  pWorkContext;

    cbHash = 0;

    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, NULL, &cbHash)))
    {
        CertCloseStore(hStore, 0);
        return(FALSE);
    }

    if (cbHash < 1)
    {
        CertCloseStore(hStore, 0);
        return(FALSE);
    }

    if (!(pbHash = new BYTE[cbHash]))
    {
        CertCloseStore(hStore, 0);
        return(FALSE);
    }

    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, pbHash, &cbHash)))
    {
        delete pbHash;
        CertCloseStore(hStore, 0);
        return(FALSE);
    }

    sBlob.cbData    = cbHash;
    sBlob.pbData    = pbHash;

    pWorkContext = CertFindCertificateInStore(hStore, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,
                                              CERT_FIND_SHA1_HASH, &sBlob, NULL);

    delete pbHash;

    if (pWorkContext)
    {
        CertFreeCertificateContext(pWorkContext);
        CertCloseStore(hStore, 0);
        return(TRUE);
    }

    CertCloseStore(hStore, 0);

    return(FALSE);
}


//============================================================================
const TCHAR c_szRegKeySMIEM[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
const TCHAR c_szRegValFormSuggest[] = TEXT("Use FormSuggest");
const TCHAR c_szRegValFormSuggestPW[] = TEXT("FormSuggest Passwords");
const TCHAR c_szRegValFormSuggestPWAsk[] = TEXT("FormSuggest PW Ask");

const TCHAR c_szYes[] = TEXT("yes");
const TCHAR c_szNo[] = TEXT("no");

inline void SetValueHelper(HWND hDlg, int id, LPTSTR *ppszData, DWORD *pcbData)
{
    if (IsDlgButtonChecked(hDlg, id))
    {
        *ppszData = (LPTSTR)c_szYes;
        *pcbData = sizeof(c_szYes);
    }
    else
    {
        *ppszData = (LPTSTR)c_szNo;
        *pcbData = sizeof(c_szNo);
    }
}

INT_PTR CALLBACK AutoSuggestDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            CheckDlgButton(hDlg, IDC_AUTOSUGGEST_ENABLEADDR,
                (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE)) ?
                BST_CHECKED : BST_UNCHECKED);

            if (g_restrict.fFormSuggest)
            {
                EnableDlgItem(hDlg, IDC_AUTOSUGGEST_ENABLEFORM, FALSE);
            }
            else
            {
                CheckDlgButton(hDlg, IDC_AUTOSUGGEST_ENABLEFORM,
                    (SHRegGetBoolUSValue(c_szRegKeySMIEM, c_szRegValFormSuggest, FALSE, /*default:*/FALSE)) ?
                    BST_CHECKED : BST_UNCHECKED);
            }

            if (g_restrict.fFormPasswords)
            {
                EnableDlgItem(hDlg, IDC_AUTOSUGGEST_SAVEPASSWORDS, FALSE);
                EnableDlgItem(hDlg, IDC_AUTOSUGGEST_PROMPTPASSWORDS, FALSE);
            }
            else
            {
                CheckDlgButton(hDlg, IDC_AUTOSUGGEST_PROMPTPASSWORDS,
                    (SHRegGetBoolUSValue(c_szRegKeySMIEM, c_szRegValFormSuggestPWAsk, FALSE, /*default:*/TRUE)) ?
                    BST_CHECKED : BST_UNCHECKED);
            
                if (SHRegGetBoolUSValue(c_szRegKeySMIEM, c_szRegValFormSuggestPW, FALSE, /*default:*/TRUE))
                {
                    CheckDlgButton(hDlg, IDC_AUTOSUGGEST_SAVEPASSWORDS, BST_CHECKED);
                }
                else
                {
                    EnableDlgItem(hDlg, IDC_AUTOSUGGEST_PROMPTPASSWORDS, FALSE);
                }
            }
        }

        return TRUE;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_AUTOSUGGEST_SAVEPASSWORDS:
                    EnableDlgItem(hDlg, IDC_AUTOSUGGEST_PROMPTPASSWORDS,
                        IsDlgButtonChecked(hDlg, IDC_AUTOSUGGEST_SAVEPASSWORDS));
                    break;
                    
                case IDC_AUTOSUGGEST_CLEARFORM:
                case IDC_AUTOSUGGEST_CLEARPASSWORDS:
                {
                    BOOL fPasswords = (LOWORD(wParam) == IDC_AUTOSUGGEST_CLEARPASSWORDS);
                    DWORD dwClear = (fPasswords) ?
                            IECMDID_ARG_CLEAR_FORMS_PASSWORDS_ONLY : IECMDID_ARG_CLEAR_FORMS_ALL_BUT_PASSWORDS;

                    if (IDOK == MsgBox(hDlg, ((fPasswords) ? IDS_CLEAR_FORMPASSWORDS : IDS_CLEAR_FORMSUGGEST), MB_ICONQUESTION, MB_OKCANCEL))
                    {
                        HCURSOR hOldCursor = NULL;
                        HCURSOR hNewCursor = NULL;

#ifndef UNIX
                        hNewCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));
#else
                        // IEUNIX - Getting rid of redundant MAKEINTRESOURCE 
                        hNewCursor = LoadCursor(NULL, IDC_WAIT);
#endif

                        if (hNewCursor) 
                            hOldCursor = SetCursor(hNewCursor);

                        // Clear all strings
                        ClearAutoSuggestForForms(dwClear);

                        // Also reset profile assistant sharing (very discoverable here)
                        if (!g_restrict.fProfiles)
                        {
                            ResetProfileSharing(hDlg);
                        }

                        if(hOldCursor)
                            SetCursor(hOldCursor);
                    }
                }
                break;

                case IDOK:
                {
                    DWORD cbData; LPTSTR pszData;

                    SetValueHelper(hDlg, IDC_AUTOSUGGEST_ENABLEADDR, &pszData, &cbData);
                    SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST,
                        REG_SZ, pszData, cbData);

                    if (!g_restrict.fFormSuggest)
                    {
                        SetValueHelper(hDlg, IDC_AUTOSUGGEST_ENABLEFORM, &pszData, &cbData);
                        SHSetValue(HKEY_CURRENT_USER, c_szRegKeySMIEM, c_szRegValFormSuggest,
                            REG_SZ, pszData, cbData);
                    }

                    if (!g_restrict.fFormPasswords)
                    {
                        SetValueHelper(hDlg, IDC_AUTOSUGGEST_SAVEPASSWORDS, &pszData, &cbData);
                        SHSetValue(HKEY_CURRENT_USER, c_szRegKeySMIEM, c_szRegValFormSuggestPW,
                            REG_SZ, pszData, cbData);
                            
                        SetValueHelper(hDlg, IDC_AUTOSUGGEST_PROMPTPASSWORDS, &pszData, &cbData);
                        SHSetValue(HKEY_CURRENT_USER, c_szRegKeySMIEM, c_szRegValFormSuggestPWAsk,
                            REG_SZ, pszData, cbData);
                    }
                }
                // fall through
                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                }
                break;
            }
        }
        return TRUE;

    case WM_HELP:                   // F1
        ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                    HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
    break;

    case WM_CONTEXTMENU:        // right mouse click
        ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                    HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
    break;

    case WM_DESTROY:
        break;

    }

    return FALSE;
}

#ifdef WALLET
// This intermediate dialog is only displayed for wallet 2.x users
INT_PTR CALLBACK WalletDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            EnableDlgItem(hDlg, IDC_PROGRAMS_WALLET_PAYBUTTON, IsWalletPaymentAvailable());
            EnableDlgItem(hDlg, IDC_PROGRAMS_WALLET_ADDRBUTTON, IsWalletAddressAvailable());
        }
        return TRUE;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_PROGRAMS_WALLET_PAYBUTTON:
                    DisplayWalletPaymentDialog(hDlg);
                    break;

                case IDC_PROGRAMS_WALLET_ADDRBUTTON:
                    DisplayWalletAddressDialog(hDlg);
                    break;

                case IDOK:
                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                }
                break;
            }
        }
        return TRUE;

    case WM_HELP:                   // F1
        ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                    HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
    break;

    case WM_CONTEXTMENU:        // right mouse click
        ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                    HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
    break;

    case WM_DESTROY:
        break;

    }

    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\inetcpl.inc ===
#
# Common makefile include for this project
#

!include $(CCSHELL_DIR)\common.inc

C_DEFINES       = $(C_DEFINES) \
                  -DMLUI_SUPPORT \
                  -DMLUI_MESSAGEBOX \

!if !defined(TARGET_WIN95)
USE_NEW_COMMCTRL=1
!endif

!if defined(USE_NEW_COMMCTRL)
C_DEFINES= $(C_DEFINES) -DUXCTRL_VERSION=0x0100
!endif


SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\general.cpp ===
///////////////////////////////////////////////////////////////////////
//           Microsoft Windows                   //
//         Copyright(c) Microsoft Corp., 1995            //
///////////////////////////////////////////////////////////////////////
//
// GENERAL.C - "General" property page for InetCpl
//

// HISTORY:
//
// 6/22/96  t-gpease    moved code from dialdlg.c - no changes
//

#include "inetcplp.h"

#include <urlhist.h>
#include <initguid.h>
#include <shlguid.h>
#include <cleanoc.h>

#include <mluisupp.h>

//#include <shdocvw.h>
SHDOCAPI_(BOOL) ParseURLFromOutsideSourceA (LPCSTR psz, LPSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
SHDOCAPI_(BOOL) ParseURLFromOutsideSourceW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
#ifdef UNICODE
#define ParseURLFromOutsideSource ParseURLFromOutsideSourceW 
#else
#define ParseURLFromOutsideSource ParseURLFromOutsideSourceA 
#endif

// 
// See inetcplp.h for documentation on this flag
//
BOOL g_fReloadHomePage = FALSE;

// 
// Private Functions and Structures
//
// from cachecpl.c
#define CONTENT 0
BOOL InvokeCachevu(HWND hDlg);
INT_PTR CALLBACK EmptyCacheDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK EmptyCacheCookiesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
BOOL DeleteCacheCookies();

INT_PTR CALLBACK ColorsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK AccessibilityDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

/////// General Tab Info Structure ///////

typedef struct _GeneralTabInfo {
    HWND  hDlg;
    HWND  hwndUrl;
    TCHAR szCurrentURL[INTERNET_MAX_URL_LENGTH];   // current url in browser
    TCHAR szStartPageURL[INTERNET_MAX_URL_LENGTH]; // current url for start page

    BOOL    fInternalChange;
    BOOL    fChanged;

    HRESULT hrOle;                              // result of com initialization
} GeneralTabInfo, *LPGENERALTABINFO, GENERALTABINFO;

void SetandSelectText(LPGENERALTABINFO pgti, HWND hwnd, LPTSTR psz);
BOOL GetHistoryFolderPath(LPTSTR pszPath);
void EmptyHistory(LPGENERALTABINFO pgti);
void HistorySave(LPGENERALTABINFO pgti);
static DWORD GetDaysToKeep(VOID);
VOID SetDaysToKeep(DWORD dwDays);
void GetDefaultStartPage(LPGENERALTABINFO pgti);
HRESULT _GetStdLocation(LPTSTR pszPath, DWORD cbPathSize, UINT id);
HRESULT _SetStdLocation(LPTSTR szPath, UINT id);

// from shdocvw
#define IDS_DEF_HOME    998  //// WARNING!!! DO NOT CHANGE THESE VALUES
#define IDS_DEF_SEARCH  999 //// WARNING!!!  INETCPL RELIES ON THEM

#define IDS_SEARCHPAGE                  IDS_DEF_SEARCH
#define IDS_STARTPAGE                   IDS_DEF_HOME

#if defined(ux10) && defined(UNIX)
//Work around for mmap limitation in hp-ux10
#define MAX_HISTORY_DAYS        30
#else
#define MAX_HISTORY_DAYS        999
#endif

#define DEFAULT_DAYS_TO_KEEP    14
#define SAFERELEASE(p)      if(p) {(p)->Release(); (p) = NULL;}

TCHAR szDefURLValueNames[] = TEXT("Default_Page_URL");

//
// Functions
//
BOOL General_InitDialog(HWND hDlg)
{
    DWORD cb = sizeof(DWORD);
    LPGENERALTABINFO pgti;
#ifdef UNIX
    BOOL  bCacheIsReadOnly = FALSE;
#endif /* UNIX */

    // allocate memory for a structure which will hold all the info
    // gathered from this page
    //
    pgti = (LPGENERALTABINFO)LocalAlloc(LPTR, sizeof(GENERALTABINFO));
    if (!pgti)
    {
        EndDialog(hDlg, 0);
        return FALSE;
    }
    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pgti);

    // NOTE (andrewgu): ie5.5 b#106468 - need to initialize COM before calling SHAutoComplete.
    // it will be uninitialized during WM_DESTROY.
    pgti->hrOle = SHCoInitialize();

    // cross-lang platform support
    SHSetDefaultDialogFont(hDlg, IDC_START_ADDRESS);
    SHAutoComplete(GetDlgItem(hDlg, IDC_START_ADDRESS), SHACF_DEFAULT);                

    pgti->hDlg = hDlg;
    // enable the "Use Current" button if we have a current url
    StrCpyN(pgti->szCurrentURL, g_szCurrentURL, ARRAYSIZE(pgti->szCurrentURL));
    EnableWindow(GetDlgItem(hDlg, IDC_USECURRENT), pgti->szCurrentURL[0]);

    // get the url edit control and set the text limit
    pgti->hwndUrl = GetDlgItem(hDlg, IDC_START_ADDRESS);
    SendMessage(pgti->hwndUrl, EM_LIMITTEXT, ARRAYSIZE(pgti->szStartPageURL)-1, 0);

    GetDefaultStartPage(pgti);
    _GetStdLocation(pgti->szStartPageURL, ARRAYSIZE(pgti->szStartPageURL), IDS_STARTPAGE);
    SetandSelectText(pgti, pgti->hwndUrl, (LPTSTR)pgti->szStartPageURL);
    // set restrictions on history controls
    SendDlgItemMessage(pgti->hDlg, IDC_HISTORY_SPIN,
                       UDM_SETRANGE, 0, MAKELPARAM(MAX_HISTORY_DAYS, 0));

    SendDlgItemMessage(pgti->hDlg, IDC_HISTORY_SPIN,
                       UDM_SETPOS, 0, MAKELPARAM((WORD) GetDaysToKeep(), 0));

    Edit_LimitText(GetDlgItem(hDlg,IDC_HISTORY_DAYS),3);    // limit edit ctrl to 3 chars

    // only when invoked from View|Options
    if (g_szCurrentURL[0])
    {
        TCHAR szTitle[128];
        MLLoadString(IDS_INTERNETOPTIONS, szTitle, ARRAYSIZE(szTitle));
        SendMessage(GetParent(hDlg), WM_SETTEXT, 0, (LPARAM)szTitle);
    }

    // disable stuff based on restrictions
    if (g_restrict.fPlaces)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_START_ADDRESS), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_USEDEFAULT), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_USEBLANK), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_USECURRENT), FALSE);
    }
    
    if (g_restrict.fCacheReadOnly)
    {
       EnableWindow(GetDlgItem(hDlg, IDC_CACHE_DELETE_COOKIES), FALSE);
       EnableWindow(GetDlgItem(hDlg, IDC_CACHE_DELETE_FILES), FALSE);
       EnableWindow(GetDlgItem(hDlg, IDC_CACHE_SETTINGS), FALSE);
    }
    
#ifdef UNIX
    bCacheIsReadOnly = IsCacheReadOnly();

    if (bCacheIsReadOnly)
    {
       EnableWindow(GetDlgItem(hDlg, IDC_CACHE_DELETE_COOKIES), FALSE);
       EnableWindow(GetDlgItem(hDlg, IDC_CACHE_DELETE_FILES), FALSE);
       EnableWindow(GetDlgItem(hDlg, IDC_CACHE_SETTINGS), FALSE);
    }

    if (g_restrict.fCache || bCacheIsReadOnly)
    {
       TCHAR szText[1024];
 
       MLLoadString(IDS_READONLY_CACHE_TEXT,  szText, ARRAYSIZE(szText));
 
       SetWindowText(GetDlgItem(hDlg, IDC_READONLY_CACHE_WARNING), szText);
       ShowWindow( GetDlgItem(hDlg, IDC_READONLY_CACHE_WARNING), SW_SHOW );
 
       ShowWindow( GetDlgItem(hDlg, IDC_TEMP_INTERNET_TEXT), SW_HIDE);
    }
#endif /* !UNIX */
    if (g_restrict.fHistory)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_HISTORY_DAYS), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_HISTORY_SPIN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_HISTORY_CLEAR), FALSE);
    }
    return TRUE;
}

BOOL General_OnCommand(LPGENERALTABINFO pgti, UINT id, UINT nCmd)
{
    switch (id)
    { 

        case IDC_START_ADDRESS:
            switch (nCmd)
            {
                case EN_CHANGE:
                    if (!pgti->fInternalChange)
                    {
                        PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
                        pgti->fChanged = TRUE;
                    }
                    break;
            }
            break;

        case IDC_USECURRENT:
            if (nCmd == BN_CLICKED)
            {
                StrCpyN(pgti->szStartPageURL, pgti->szCurrentURL, ARRAYSIZE(pgti->szStartPageURL));
                SetandSelectText(pgti, pgti->hwndUrl,  pgti->szStartPageURL);
                PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
                pgti->fChanged = TRUE;
            }
            break;

        case IDC_USEDEFAULT:
            if (nCmd == BN_CLICKED)
            {
                GetDefaultStartPage(pgti);
                SetandSelectText(pgti, pgti->hwndUrl,  pgti->szStartPageURL);
                PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
                pgti->fChanged = TRUE;
            }
            break;

        case IDC_USEBLANK:
            if (nCmd == BN_CLICKED)
            {
                StrCpyN(pgti->szStartPageURL, TEXT("about:blank"), ARRAYSIZE(pgti->szStartPageURL));
                SetandSelectText(pgti, pgti->hwndUrl,  pgti->szStartPageURL);
                PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
                pgti->fChanged = TRUE;
            }
            break;

        case IDC_HISTORY_SPIN:
        case IDC_HISTORY_DAYS:
            if (pgti && (nCmd == EN_CHANGE))
            {
                PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
                pgti->fChanged = TRUE;
            }
            break;

        case IDC_HISTORY_VIEW:
        {
            TCHAR szPath[MAX_PATH];

            if (!GetHistoryFolderPath(szPath))
            {
                GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
                PathAppend(szPath, TEXT("history"));
            }

            SHELLEXECUTEINFO shei= { 0 };

            shei.cbSize     = sizeof(shei);
            shei.lpFile     = szPath;
            shei.lpClass    = TEXT("Folder");
            shei.fMask      = SEE_MASK_CLASSNAME;
            shei.nShow      = SW_SHOWNORMAL;
            ShellExecuteEx(&shei);

            break;
        }

        case IDC_HISTORY_CLEAR:
            if (MsgBox(pgti->hDlg, IDS_ClearHistory, MB_ICONQUESTION,
                       MB_YESNO | MB_DEFBUTTON2 )
                == IDYES)
            {

                HCURSOR hOldCursor = NULL;
                HCURSOR hNewCursor = NULL;

                // IEUNIX-Removing redundant use of MAKEINTRESOURCE
#ifndef UNIX
                hNewCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));
#else
                hNewCursor = LoadCursor(NULL, IDC_WAIT);
#endif

                if (hNewCursor) 
                    hOldCursor = SetCursor(hNewCursor);

                EmptyHistory(pgti);

                if(hOldCursor)
                    SetCursor(hOldCursor);

            }
            break;

        case IDC_CACHE_SETTINGS:
            DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_TEMP_FILES),
                      pgti->hDlg, TemporaryDlgProc);

            break; // IDC_ADVANCED_CACHE_FILES_BUTTON

        case IDC_CACHE_DELETE_COOKIES:
        {
            INT_PTR iRet = DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_CACHE_COOKIES_EMPTY),
                             pgti->hDlg, EmptyCacheCookiesDlgProc);

            if (iRet == 1)
            {
                HCURSOR hOldCursor      = NULL;
                HCURSOR hAdvancedCursor = NULL;
#ifndef UNIX
                hAdvancedCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));
#else
                //IEUNIX-Removing redundant use of MAKEINTRESOURCE
                hAdvancedCursor = LoadCursor(NULL, IDC_WAIT);
#endif
                if (hAdvancedCursor)
                    hOldCursor = SetCursor(hAdvancedCursor);
                    
                DeleteCacheCookies();

                if (hOldCursor)
                    SetCursor(hOldCursor);
            }
            break;
        }
        case IDC_CACHE_DELETE_FILES:
        {
            INT_PTR iRet = DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_CACHE_EMPTY),
                             pgti->hDlg, EmptyCacheDlgProc);

            if ((iRet == 1) || (iRet == 3))
            {
                HCURSOR hOldCursor      = NULL;
                HCURSOR hAdvancedCursor = NULL;
                INTERNET_CACHE_CONFIG_INFOA icci;
                icci.dwContainer = CONTENT;

                GetUrlCacheConfigInfoA(&icci, NULL, CACHE_CONFIG_DISK_CACHE_PATHS_FC);

#ifndef UNIX
                hAdvancedCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));
#else
                //IEUNIX-Removing redundant use of MAKEINTRESOURCE
                hAdvancedCursor = LoadCursor(NULL, IDC_WAIT);
#endif

                if (hAdvancedCursor)
                    hOldCursor = SetCursor(hAdvancedCursor);

                switch (iRet)   {
                    case 1:
                        FreeUrlCacheSpaceA(icci.CachePath, 100, STICKY_CACHE_ENTRY);
                        TraceMsg(TF_GENERAL, "Call FreeUrlCacheSpace with 0x%x",STICKY_CACHE_ENTRY);
                        break;
                    case 3:
                        FreeUrlCacheSpaceA(icci.CachePath, 100, 0 /*remove all*/);
                        TraceMsg(TF_GENERAL, "Call FreeUrlCacheSpace with 0");
                        break;
                    default:
                        break;
                }

                // Remove expired controls from Downloaded Program Files ( OCCache )
                // We'll do this silently, which leaves uncertain stuff behing, cuz
                // this is preferrable to raising a variable number of confirmation dialogs.
                RemoveExpiredControls( REC_SILENT, 0);
                TraceMsg(TF_GENERAL, "Call RemoveExpiredControls (silent)");

                if (hOldCursor)
                    SetCursor(hOldCursor);

            } 
            break;
        }

        case IDC_LANGUAGES:
            if (nCmd == BN_CLICKED)
            {
                KickLanguageDialog(pgti->hDlg);
            }
            break;

        case IDC_FONTS:
            if (nCmd == BN_CLICKED)
                OpenFontsDialogEx( pgti->hDlg, NULL );
            break;

        case IDC_COLORS:
            if (nCmd == BN_CLICKED)
                DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_COLORS), pgti->hDlg, ColorsDlgProc);
            break;

        case IDC_ACCESSIBILITY:
            if (nCmd == BN_CLICKED)
                DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_ACCESSIBILITY), pgti->hDlg, AccessibilityDlgProc);
            break;            
        
    }
    return TRUE;
}


void General_Apply(HWND hDlg)
{
    LPGENERALTABINFO pgti = (LPGENERALTABINFO) GetWindowLongPtr(hDlg, DWLP_USER);

    if (pgti->fChanged)
    {
        INT_PTR iDays = SendDlgItemMessage(pgti->hDlg, IDC_HISTORY_SPIN, UDM_GETPOS, 0, 0 );
        TCHAR szStartPageURL[MAX_URL_STRING];
        
        SendMessage(pgti->hwndUrl, WM_GETTEXT, (WPARAM)ARRAYSIZE(szStartPageURL), (LPARAM)(szStartPageURL));
        
        if (szStartPageURL[0])
        {
            StrCpyN(pgti->szStartPageURL, szStartPageURL, ARRAYSIZE(pgti->szStartPageURL));
            PathRemoveBlanks(pgti->szStartPageURL);
            _SetStdLocation(pgti->szStartPageURL, IDS_STARTPAGE);
        }
        else
        {
            SendMessage(pgti->hwndUrl, WM_SETTEXT, (WPARAM)ARRAYSIZE(pgti->szStartPageURL), (LPARAM)(pgti->szStartPageURL));
        }

        // make sure that the edit box is not beyond the maximum allowed value
        if (iDays>=0xFFFF)
            iDays = MAX_HISTORY_DAYS;
        SetDaysToKeep((DWORD)iDays);

        UpdateAllWindows();
        // reset this flag, now that we've applied the changes
        pgti->fChanged = FALSE;
    }
}

void ReloadHomePageIfNeeded(LPGENERALTABINFO pgti)
{
    ASSERT(pgti);
    if (!pgti)
        return;

    if (g_fReloadHomePage)
    {
        //
        // If needed, reload the homepage url from the registry
        //
        _GetStdLocation(pgti->szStartPageURL, ARRAYSIZE(pgti->szStartPageURL), IDS_STARTPAGE);
        SetandSelectText(pgti, pgti->hwndUrl, (LPTSTR)pgti->szStartPageURL);

        g_fReloadHomePage = FALSE;
    }
}

INT_PTR CALLBACK General_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    // get our tab info structure
    LPGENERALTABINFO pgti;

    if (uMsg == WM_INITDIALOG)
        return General_InitDialog(hDlg);

    else
        pgti = (LPGENERALTABINFO) GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pgti)
        return FALSE;
    
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:
                    ReloadHomePageIfNeeded(pgti);
                    return TRUE;

                case PSN_KILLACTIVE:
#if defined(ux10) && defined(UNIX)
//Work around for mmap limitation in hp-ux10
                    INT_PTR iDays = SendDlgItemMessage(pgti->hDlg, IDC_HISTORY_SPIN, UDM_GETPOS, 0, 0 );
                    if (iDays > MAX_HISTORY_DAYS)
                    {
                      MessageBox(pgti->hDlg, TEXT("Days to keep pages in history cannot be greater 30."), NULL, MB_OK);
                      Edit_SetText(GetDlgItem(hDlg,IDC_HISTORY_DAYS), TEXT("30"));
                      SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                      return TRUE;
                    }
                    else
                    {
                      SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                      return TRUE;
                    }
#endif
                case PSN_QUERYCANCEL:
                case PSN_RESET:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return TRUE;

                case PSN_APPLY:
                    ReloadHomePageIfNeeded(pgti);
                    General_Apply(hDlg);
                    break;
            }
            break;                  
        }

        case WM_COMMAND:
            General_OnCommand(pgti, LOWORD(wParam), HIWORD(wParam));
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            // destroying this deliberately flushes its update (see WM_DESTROY in the UpdateWndProc);
            SHRemoveDefaultDialogFont(hDlg);

#ifndef UNIX
            // Should only be destroyed in process detach
            if (g_hwndUpdate)
                DestroyWindow(g_hwndUpdate);
#endif

            SHCoUninitialize(pgti->hrOle);

            if (pgti)
                LocalFree(pgti);

            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);  // make sure we don't re-enter
            break;

    }
    return FALSE;
}


////////////////////////////////////////////////////////
//
// helper functions
//
////////////////////////////////////////////////////////

VOID SetDaysToKeep(DWORD dwDays)
{
    HKEY hk;
    DWORD dwDisp;

    DWORD Error = RegCreateKeyEx(
                                 HKEY_CURRENT_USER,
                                 REGSTR_PATH_URLHISTORY,
                                 0, NULL, 0,
                                 KEY_WRITE,
                                 NULL,
                                 &hk,
                                 &dwDisp);

    if(ERROR_SUCCESS != Error)
    {
        ASSERT(FALSE);
        return;
    }

    Error = RegSetValueEx(
                          hk,
                          REGSTR_VAL_DAYSTOKEEP,
                          0,
                          REG_DWORD,
                          (LPBYTE) &dwDays,
                          sizeof(dwDays));

    ASSERT(ERROR_SUCCESS == Error);

    RegCloseKey(hk);

    return;
}

static DWORD GetDaysToKeep(VOID)
{
    HKEY hk;
    DWORD cbDays = sizeof(DWORD);
    DWORD dwDays  = DEFAULT_DAYS_TO_KEEP;


    DWORD Error = RegOpenKeyEx(
                               HKEY_CURRENT_USER,
                               REGSTR_PATH_URLHISTORY,
                               0,
                               KEY_READ,
                               &hk);


    if(Error)
    {
        Error = RegOpenKeyEx(
                             HKEY_LOCAL_MACHINE,
                             REGSTR_PATH_URLHISTORY,
                             0,
                             KEY_READ,
                             &hk);
    }


    if(!Error)
    {

        Error = RegQueryValueEx(
                                hk,
                                REGSTR_VAL_DAYSTOKEEP,
                                0,
                                NULL,
                                (LPBYTE) &dwDays,
                                &cbDays);


        RegCloseKey(hk);
    }

    return dwDays;
}

typedef HRESULT (* PCOINIT) (LPVOID);
typedef VOID (* PCOUNINIT) (VOID);
typedef VOID (* PCOMEMFREE) (LPVOID);
typedef HRESULT (* PCOCREINST) (REFCLSID, LPUNKNOWN, DWORD,     REFIID, LPVOID * );

HMODULE hOLE32 = NULL;
PCOINIT pCoInitialize = NULL;
PCOUNINIT pCoUninitialize = NULL;
PCOMEMFREE pCoTaskMemFree = NULL;
PCOCREINST pCoCreateInstance = NULL;

BOOL _StartOLE32()
{
    if (!hOLE32)
        hOLE32 = LoadLibrary(TEXT("OLE32.DLL"));

    if(!hOLE32)
        return FALSE;

    pCoInitialize = (PCOINIT) GetProcAddress(hOLE32, "CoInitialize");
    pCoUninitialize = (PCOUNINIT) GetProcAddress(hOLE32, "CoUninitialize");
    pCoTaskMemFree = (PCOMEMFREE) GetProcAddress(hOLE32, "CoTaskMemFree");
    pCoCreateInstance = (PCOCREINST) GetProcAddress(hOLE32, "CoCreateInstance");


    if(!pCoInitialize || !pCoUninitialize || !pCoTaskMemFree || !pCoCreateInstance)
        return FALSE;

    return TRUE;
}


void EmptyHistory(LPGENERALTABINFO pgti)
{
    HRESULT hr = S_OK;
    IUrlHistoryStg2 *piuhs = NULL;

#ifdef UNIX
    LONG  lResult;
    HKEY  hkSubKey;
    DWORD dwIndex;
    TCHAR szSubKeyName[MAX_PATH + 1];
    DWORD cchSubKeyName = ARRAYSIZE(szSubKeyName);
    TCHAR szClass[MAX_PATH];
    DWORD cbClass = ARRAYSIZE(szClass);

    /* v-sriran: 12/18/97
     * In shdocvw/aclmru.cpp, we keep m_hKey as a handle to the key TypedURLs.
     * After deleting history, if somebody types something in the address bar,
     * we create the key again. So, here we are just deleting the contents of
     * the key TypedURLs and not the key itself.
     */
    /* Open the subkey so we can enumerate any children */
    lResult = RegOpenKeyEx(HKEY_CURRENT_USER,
                           TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs"),
                           0,
                           KEY_ALL_ACCESS,
                           &hkSubKey);
    if (ERROR_SUCCESS == lResult)
    {
       /* I can't just call RegEnumKey with an ever-increasing index, because */
       /* I'm deleting the subkeys as I go, which alters the indices of the   */
       /* remaining subkeys in an implementation-dependent way.  In order to  */
       /* be safe, I have to count backwards while deleting the subkeys.      */

       /* Find out how many subkeys there are */
       lResult = RegQueryInfoKey(hkSubKey,
                                 szClass,
                                 &cbClass,
                                 NULL,
                                 &dwIndex, /* The # of subkeys -- all we need */
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL);
         
       if (ERROR_SUCCESS == lResult) {
          /* dwIndex is now the count of subkeys, but it needs to be  */
          /* zero-based for RegEnumKey, so I'll pre-decrement, rather */
          /* than post-decrement. */
          while (ERROR_SUCCESS == RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
          {
                RegDeleteKey(hkSubKey, szSubKeyName);
          }
       }
  
       RegCloseKey(hkSubKey);
    }
#else
    // Warning : if you ever have subkeys - this will fail on NT
    RegDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs"));
#endif

    // Warning : if you ever have subkeys - this will fail on NT
    RegDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU"));

    // this broadcast will nuke the address bars
    SendBroadcastMessage(WM_SETTINGCHANGE, 0, (LPARAM)TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs"));
    SendBroadcastMessage(WM_SETTINGCHANGE, 0, (LPARAM)TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU"));

    //
    // As requested (bug 60089) we remove these reg values when history is
    // cleared.  This will reset the encoding menu UI to the defaults.
    //
    HKEY hkeyInternational = NULL;

    if (ERROR_SUCCESS == 
            RegOpenKeyEx(
                HKEY_CURRENT_USER,
                REGSTR_PATH_INTERNATIONAL,
                0,
                KEY_WRITE,
                &hkeyInternational))
    {

        ASSERT(hkeyInternational);

        RegDeleteValue(hkeyInternational, TEXT("CpCache"));
        RegDeleteValue(hkeyInternational, TEXT("CNum_CpCache"));
        
        RegCloseKey(hkeyInternational);

    }

    //  we will enumerate and kill each entry.  <gryn>
    //  this way we only kill peruser
    if (FAILED(pgti->hrOle))
        return;

    hr = SHCoCreateInstance(NULL, &CLSID_CUrlHistory, NULL, IID_IUrlHistoryStg2, (LPVOID *)&piuhs);
    if (SUCCEEDED(hr))
        piuhs->ClearHistory();

    else
        AssertMsg(FALSE, TEXT("Couldn't create CLSID_CUrlHistory object!"));

    SAFERELEASE(piuhs);
}

#define HISTORY 2

BOOL GetHistoryFolderPath(LPTSTR pszPath)
{
    INTERNET_CACHE_CONFIG_INFOA cci;
    cci.dwContainer = HISTORY;

    if (GetUrlCacheConfigInfoA(&cci, NULL, CACHE_CONFIG_DISK_CACHE_PATHS_FC))
    {
#ifdef UNICODE
        SHAnsiToUnicode(cci.CachePath, pszPath, MAX_PATH);
#else
        StrCpyN(pszPath, cci.CachePath, MAX_PATH);
#endif
        return TRUE;
    }
    return FALSE;
}

void SetandSelectText(LPGENERALTABINFO pgti, HWND hwnd, LPTSTR psz)
{
    pgti->fInternalChange = TRUE;
    SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM)psz);
    Edit_SetSel(hwnd, 0, 0);    // makesure everything is scrolled over first
    Edit_SetSel(hwnd, 0, -1);    // select everything
    pgti->fInternalChange = FALSE;
}

void GetDefaultStartPage(LPGENERALTABINFO pgti)
{
#ifdef UNICODE
    CHAR szPath[MAX_PATH];
    CHAR szValue[MAX_PATH];
    CHAR szURL[INTERNET_MAX_URL_LENGTH];

    SHUnicodeToAnsi(REGSTR_PATH_MAIN,szPath,ARRAYSIZE(szPath));
    SHUnicodeToAnsi(szDefURLValueNames,szValue,ARRAYSIZE(szValue));
    URLSubRegQueryA(szPath,
                    szValue,
                    TRUE,
                    szURL,
                    ARRAYSIZE(pgti->szStartPageURL),
                    URLSUB_ALL);
    SHAnsiToUnicode(szURL,pgti->szStartPageURL,ARRAYSIZE(pgti->szStartPageURL)); 
#else
    URLSubRegQueryA(REGSTR_PATH_MAIN,
                    szDefURLValueNames,
                    TRUE,
                    pgti->szStartPageURL,
                    ARRAYSIZE(pgti->szStartPageURL),
                    URLSUB_ALL);
#endif
}

HRESULT _GetStdLocation(LPTSTR pszPath, DWORD cbPathSize, UINT id)
{
    HRESULT hres = E_FAIL;
    LPCTSTR pszName;

    switch(id) {
        case IDS_STARTPAGE:
            pszName = REGSTR_VAL_STARTPAGE;
            break;

        case IDS_SEARCHPAGE:
            pszName = REGSTR_VAL_SEARCHPAGE;
            break;
#if 0
        case IDM_GOLOCALPAGE:
            pszName = REGSTR_VAL_LOCALPAGE;
            break;
#endif
        default:
            return E_INVALIDARG;
    }

#ifdef UNICODE
    CHAR szPath[MAX_PATH];
    CHAR szValue[MAX_PATH];
    CHAR szURL[INTERNET_MAX_URL_LENGTH];

    SHUnicodeToAnsi(REGSTR_PATH_MAIN,szPath,ARRAYSIZE(szPath));
    SHUnicodeToAnsi(pszName,szValue,ARRAYSIZE(szValue));
    if (SUCCEEDED(hres = URLSubRegQueryA(szPath, szValue, TRUE, 
                                         szURL, ARRAYSIZE(szURL), URLSUB_ALL)))
#else
    TCHAR szPath[MAX_URL_STRING];
    if (SUCCEEDED(hres = URLSubRegQueryA(REGSTR_PATH_MAIN, pszName, TRUE, 
                                         szPath, ARRAYSIZE(szPath), URLSUB_ALL)))
#endif
    {
#ifdef UNICODE
        SHAnsiToUnicode(szURL,pszPath,cbPathSize); 
#else
        StrCpyN(pszPath, szPath, cbPathSize);
#endif
    }
    return hres;
}

HRESULT _SetStdLocation(LPTSTR szPath, UINT id)
{
    HRESULT hres = E_FAIL;
    HKEY hkey;
    TCHAR szPage[MAX_URL_STRING];
    TCHAR szNewPage[MAX_URL_STRING];

    DWORD cchNewPage = ARRAYSIZE(szNewPage);
    BOOL bSearch = FALSE;

    // FEATURE: Share this code!!!
    // This is Internet Explorer Specific

    _GetStdLocation(szPage, ARRAYSIZE(szPage), IDS_STARTPAGE);

    if ( ParseURLFromOutsideSource(szPath, szNewPage, &cchNewPage, &bSearch) &&
            (StrCmp(szPage, szNewPage) != 0) )
    {
        if (RegOpenKeyEx(HKEY_CURRENT_USER,
                         REGSTR_PATH_MAIN,
                         0,
                         KEY_WRITE,
                         &hkey)==ERROR_SUCCESS)
        {
            DWORD cbSize = (lstrlen(szNewPage)+1)*sizeof(TCHAR);
            if (RegSetValueEx(hkey,
                              REGSTR_VAL_STARTPAGE,
                              0,
                              REG_SZ,
                              (LPBYTE)szNewPage, cbSize)==ERROR_SUCCESS)
            {
                hres = S_OK;
            }
            RegCloseKey(hkey);
        }
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\inetcver.h ===
#if WINNT  // versioninfo
#include <winver.h>
#include <ntverp.h>
#else
#include <version.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\inetcplp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************
//
//      INETCPL.H - central header file for Internet control panel
//
//      HISTORY:
//
//      4/3/95      jeremys         Created.
//      6/25/96     t-ashlem        condensed most header files into here
//                                    and other cleanup
//

#ifndef _INETCPL_H_
#define _INETCPL_H_

// Extra error checking (catches false errors, but useful to run every so often)
#if 1
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4709)   // command operator w/o index expression
#endif

// IEUNIX - removing warning for redefinition of STRICT
#ifdef STRICT
#undef STRICT
#endif

#define STRICT                      // Use strict handle types
#define _SHELL32_

#define _CRYPT32_    // get DECLSPEC_IMPORT stuff right for Cert API


#include <windows.h>
#include <windowsx.h>

#ifdef WINNT
#include <shellapi.h>
#endif // WINNT


#include <shlobj.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <prsht.h>
#include <cpl.h>
#include <regstr.h>
#include <ccstock.h>
#include <validate.h>
#include <debug.h>
#include <mshtml.h>
#include <wincrypt.h>
#include <shfusion.h>
    //
    // All HKEYs are defined in this library: INETREG.LIB
    // please change/add any HKEYs to this library. Thanks!
    //
#include <inetreg.h>

    //
    // Delay load DLLs' globals (see DLYLDDLL.C for details)
    //
#include "dlylddll.h"

#include <ratings.h>

#include <commdlg.h>
#include <olectl.h>

#define _WINX32_  // get DECLSPEC_IMPORT stuff right for WININET API
#include <urlmon.h>
#include <wininet.h>

#define _URLCACHEAPI_  // get DECLSPEC_IMPORT stuff right for wininet urlcache
#ifdef WINNT
#include <winineti.h>
#endif // WINNT

#define MAX_URL_STRING    INTERNET_MAX_URL_LENGTH
#include <shlwapi.h>

#include "ieguidp.h"

#include "oleacc.h"
// Hack. winuserp.h and winable.h both define the flag WINEVENT_VALID. Since
// no one in inetcpl uses this value we undef it to make the compile work.
#undef WINEVENT_VALID
#include "winable.h"

#ifdef UNICODE
#define POST_IE5_BETA
#include <w95wraps.h>
#endif


#include <ras.h>
#include <raserror.h>

//
// When a user clicks "reset web defaults" (on the programs tab), we may need
// to update the url shown in the general tab.  The general tab will check this
// flag each time it's made active, and also when we hit ok or apply.
//
extern BOOL g_fReloadHomePage;

///////////////////////////////////////////////////////////////////////
//
// Structure Defintions and other typedefs
//
///////////////////////////////////////////////////////////////////////

typedef struct _RESTRICT_FLAGS
{
    BOOL fGeneralTab;               // Enable/disable "General" tab
    BOOL fSecurityTab;              // Enable/disable "Security" tab
    BOOL fContentTab;               // Enable/disable "Content" tab
    BOOL fConnectionsTab;           // Enable/disable "Programs" tab
    BOOL fProgramsTab;              // Enable/disable "Connections" tab
    BOOL fAdvancedTab;              // Enable/disable "Advanced" tab
    BOOL fPrivacyTab;               // Enable/disable "Privacy" tab
    BOOL fColors;                   // Colors section of Colors dialog
    BOOL fLinks;                    // Links section of Links dialog
    BOOL fFonts;                    // Fonts dialog
    BOOL fInternational;            // Languages dialog
    BOOL fDialing;                  // Connection section of Connection tab (incl Settings subdialog)
    BOOL fProxy;                    // Proxy section of Connection tab (incl Advanced subdialog)
    BOOL fPlaces;                   // Home page section of General tab
    BOOL fHistory;                  // History section of General tab
    BOOL fMailNews;                 // Messaging section of the Programs tab
    BOOL fRatings;                  // Ratings buttons on Content tab
    BOOL fCertif;                   // Certificate section of Content tab
    BOOL fCertifPers;               // Personal Cert button
    BOOL fCertifSite;               // Site Cert button
    BOOL fCertifPub;                // Publishers button
    BOOL fCache;                    // Temporary Internet Files section of General tab
    BOOL fAutoConfig;               // Autoconig section of Connection tab
    BOOL fAccessibility;            // Accessibility dialog
    BOOL fSecChangeSettings;        // can't change level
    BOOL fSecAddSites;              // can't add/remove sites
    BOOL fProfiles;                 // Profile Asst section of Content tab
    BOOL fFormSuggest;              // AutoSuggest for forms on Content tab
    BOOL fFormPasswords;            // AutoSuggest for form passwords on Content tab
#ifdef WALLET
    BOOL fWallet;                   // MS Wallet section of Content tab
#endif
    BOOL fConnectionWizard;         // Connection Wizard section of Connection tab
    BOOL fCalContact;               // Cal/Contact section of Programs tab
    BOOL fAdvanced;                 // Advanced page
    BOOL fCacheReadOnly;            // Disables the delete and Settings buttons on the general panel
    BOOL fResetWebSettings;         // Disables the "reset web settings" feature
    BOOL fDefault;                  // IE should check if it's the default browser
    BOOL fPrivacySettings;          // Disables privacy settings

#if 0
    BOOL fMultimedia;               // OBSOLETE: do not use
    BOOL fToolbar;                  // OBSOLETE: do not use
    BOOL fFileTypes;                // OBSOLETE: do not use
    BOOL fActiveX;                  // OBSOLETE: do not use
    BOOL fActiveDownload;           // OBSOLETE: do not use
    BOOL fActiveControls;           // OBSOLETE: do not use
    BOOL fActiveScript;             // OBSOLETE: do not use
    BOOL fActiveJava;               // OBSOLETE: do not use
    BOOL fActiveSafety;             // OBSOLETE: do not use
    BOOL fWarnings;                 // OBSOLETE: do not use
    BOOL fOther;                    // OBSOLETE: do not use
    BOOL fCrypto;                   // OBSOLETE: do not use
    BOOL fPlacesDefault;            // OBSOLETE: do not use
#endif

} RESTRICT_FLAGS, *LPRESTRICT_FLAGS;

typedef struct tagPROXYINFO
{
    BOOL    fEnable;
    BOOL    fEditCurrentProxy;
    BOOL    fOverrideLocal;
    BOOL    fCustomHandler;
    TCHAR   szProxy[MAX_URL_STRING];
    TCHAR   szOverride[MAX_URL_STRING];
} PROXYINFO, *LPPROXYINFO;


// function pointer typedefs
typedef DWORD   (WINAPI * RASENUMENTRIESA) (LPSTR, LPSTR, LPRASENTRYNAMEA, LPDWORD, LPDWORD);
typedef DWORD   (WINAPI * RASENUMENTRIESW) (LPSTR, LPSTR, LPRASENTRYNAMEW, LPDWORD, LPDWORD);
typedef DWORD   (WINAPI * RASCREATEPHONEBOOKENTRYA) (HWND,LPSTR);
typedef DWORD   (WINAPI * RASEDITPHONEBOOKENTRYA) (HWND,LPSTR,LPSTR);
typedef DWORD   (WINAPI * RASEDITPHONEBOOKENTRYW) (HWND,LPWSTR,LPWSTR);
typedef DWORD   (WINAPI * RASGETENTRYDIALPARAMSA) (LPSTR, LPRASDIALPARAMSA, LPBOOL);
typedef DWORD   (WINAPI * RASGETENTRYDIALPARAMSW) (LPWSTR, LPRASDIALPARAMSW, LPBOOL);
typedef DWORD   (WINAPI * RASSETENTRYDIALPARAMSA) (LPSTR, LPRASDIALPARAMSA, BOOL);
typedef DWORD   (WINAPI * RASSETENTRYDIALPARAMSW) (LPWSTR, LPRASDIALPARAMSW, BOOL);
typedef DWORD   (WINAPI * RASDELETEENTRYA) (LPSTR, LPSTR);
typedef DWORD   (WINAPI * RASDELETEENTRYW) (LPWSTR, LPWSTR);
typedef DWORD   (WINAPI * RASGETENTRYPROPERTIESW) (LPCWSTR, LPCWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD);
typedef DWORD   (WINAPI * RNAACTIVATEENGINE) (void);
typedef DWORD   (WINAPI * RNADEACTIVATEENGINE) (void);
typedef DWORD   (WINAPI * RNADELETEENTRY) (LPSTR);

///////////////////////////////////////////////////////////////////////
//
// #defines
//
///////////////////////////////////////////////////////////////////////

#define IDC_NOTUSED             ((unsigned) IDC_UNUSED)
#define INM_UPDATE              (WM_USER + 100)

#define MAX_RES_LEN             255
#define SMALL_BUF_LEN           48
#define MAX_PATH_URL    INTERNET_MAX_URL_LENGTH

// NOTE: If you change these max values to something other than two digits, then you'll need to change
// the call in connectn.cpp:DialupDlgInit which sets the limittext to 2 chars.
#define DEF_AUTODISCONNECT_TIME 20      // default disconnect timeout is 20 mins
#define MIN_AUTODISCONNECT_TIME 3       // minimum disconnect timeout is 3 mins
#define MAX_AUTODISCONNECT_TIME 59      // maximum disconnect timeout is 59 mins

// NOTE: If you change these max values to something other than two digits, then you'll need to change
// the call in connectn.cpp:DialupDlgInit which sets the limittext to 2 chars.
#define DEF_REDIAL_TRIES        10
#define MAX_REDIAL_TRIES        99
#define MIN_REDIAL_TRIES        1

#define CO_INTERNET             1
#define CO_INTRANET             2

// NOTE: If you change these max values to something other than two digits, then you'll need to change
// the call in connectn.cpp:DialupDlgInit which sets the limittext to 2 chars.
#define DEF_REDIAL_WAIT         5
#define MAX_REDIAL_WAIT         99
#define MIN_REDIAL_WAIT         5

#define MESSAGE_SIZE    255
#define BITMAP_WIDTH    16
#define BITMAP_HEIGHT   16
#define NUM_BITMAPS     5
#define MAX_KEY_NAME    64
#define COLOR_BG        0
//
#define IDCHECKED       0
#define IDUNCHECKED     1
#define IDRADIOON       2
#define IDRADIOOFF      3
#define IDUNKNOWN       4
//
#define SZDEFAULTBITMAP TEXT("DefaultBitmap")
#define SZHT_RADIO      TEXT("radio")
#define SZHT_CHECKBOX   TEXT("checkbox")
//
#define RET_CHECKBOX    0
#define RET_RADIO       1
//
#define TREE_NEITHER    1
#define TREE_CHECKBOX   2
#define TREE_RADIO      4
//
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
//
#define RCS_GETSTATE    1
#define RCS_SETSTATE    2

// Used with the various registry functions to detect when a value isn't
// present
#define VALUE_NOT_PRESENT   -255

#define DEFAULT_CPL_PAGE    -1

///////////////////////////////////////////////////////////////////////
//
// Macros
//
///////////////////////////////////////////////////////////////////////

#define ENABLEAPPLY(hDlg) SendMessage( GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L )
#define SetPropSheetResult( hwnd, result ) SetWindowLongPtr(hwnd, DWLP_MSGRESULT, result)

#undef DATASEG_READONLY
#define DATASEG_READONLY        ".rdata"
#include "resource.h"
#include "clsutil.h"

///////////////////////////////////////////////////////////////////////
//
// Read-Only Global Variables
//
///////////////////////////////////////////////////////////////////////

extern HINSTANCE      ghInstance;       // global module instance handle
extern const DWORD    mapIDCsToIDHs[];  // Help IDC to IDH map
extern RESTRICT_FLAGS g_restrict;       // var to restrict access to pages


// functions in UTIL.C
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons);
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...);
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);
BOOL EnableDlgItem(HWND hDlg,UINT uID,BOOL fEnable);
VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
                                UINT uErrorClass,UINT uIcon,...);
BOOL WarnFieldIsEmpty(HWND hDlg,UINT uCtrlID,UINT uStrID);
VOID DisplayFieldErrorMsg(HWND hDlg,UINT uCtrlID,UINT uStrID);
VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
                         UINT uError,UINT uErrorClass);
BOOL IsNTSPx(BOOL fEqualOrGreater, UINT uMajorVer, UINT uSPVer);

// functions in RNACALL.C
BOOL InitRNA(HWND hWnd);
VOID DeInitRNA();

// structure for getting proc addresses of api functions
typedef struct APIFCN {
    PVOID * ppFcnPtr;
    LPCSTR pszName;
} APIFCN;


#undef  DATASEG_PERINSTANCE
#define DATASEG_PERINSTANCE     ".instance"
#undef  DATASEG_SHARED
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT         DATASEG_SHARED


///////////////////////////////////////////////////////////////////////
//
// Global Variables
//
///////////////////////////////////////////////////////////////////////

extern TCHAR g_szCurrentURL[INTERNET_MAX_URL_LENGTH];
extern HWND g_hwndUpdate;
extern HWND g_hwndPropSheet;
extern BOOL g_fChangedMime;

///////////////////////////////////////////////////////////////////////
//
// Dialog Procs
//
///////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                              LPARAM lParam);

INT_PTR CALLBACK TemporaryDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                               LPARAM lParam);

INT_PTR CALLBACK ConnectionDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam);

INT_PTR CALLBACK General_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                              LPARAM lParam);

#ifdef UNIX
BOOL CALLBACK AssocDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                              LPARAM lParam);
BOOL CALLBACK AliasDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                              LPARAM lParam);
#endif

STDAPI_(INT_PTR) OpenFontsDialog(HWND hDlg, LPCSTR lpszKeyPath);
STDAPI_(INT_PTR) OpenFontsDialogEx(HWND hDlg, LPCTSTR lpszKeyPath);

INT_PTR CALLBACK FontsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LanguageDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK PlacesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

INT_PTR CALLBACK ProgramsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                              LPARAM lParam);

INT_PTR CALLBACK ProxyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                           LPARAM lParam);

INT_PTR CALLBACK SafetyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

INT_PTR CALLBACK SecurityDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

INT_PTR CALLBACK PrintDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK ContentDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK PrivacyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

extern "C" void CALLBACK OpenLanguageDialog(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);
void KickLanguageDialog(HWND hDlg);
///////////////////////////////////////////////////////////////////////
//
// Dialog Proc Helpers
//
///////////////////////////////////////////////////////////////////////

// hunts down all windows and notifies them that they should update themselves
void UpdateAllWindows();

// Windows Help helper
void ResWinHelp( HWND hwnd, int ids, int id2, DWORD_PTR dwp);

#ifdef UNIX

void FindEditClient(LPTSTR szProtocol, HWND hwndDlg, int nIDDlgItem, LPTSTR szPath);
BOOL EditScript(HKEY hkeyProtocol);
BOOL FindScript(HWND hwndLable, HKEY hkeyProtocol);
#define DIR_SEPR FILENAME_SEPARATOR

#include <tchar.h>
#include <platform.h>
#include "unixstuff.h"

inline
BOOL
HAS_DRIVE_LETTER(LPCTSTR pszPath)
{
    ASSERT(pszPath!=NULL);
    return (pszPath[0] == '/');
}

#else

#define DIR_SEPR '\\'
inline
BOOL
HAS_DRIVE_LETTER(LPCTSTR pszPath)
{
    ASSERT(pszPath!=NULL);
    ASSERT(pszPath[0]!='\0');
    return (pszPath[1] == ':');
}

#endif

//
// We can be hung if we use sendMessage, and you can not use pointers with asynchronous
// calls such as PostMessage or SendNotifyMessage.  So we resort to using a timeout.
// This function should be used to broadcast notification messages, such as WM_SETTINGCHANGE,
// that pass pointers.
//
inline LRESULT SendBroadcastMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return SHSendMessageBroadcastW(uMsg, wParam, lParam);
}

// struct used in security.cpp as tls in a hack to get around bad dialog creation situation
struct SECURITYINITFLAGS
{
    DWORD    dwZone;
    BOOL     fForceUI;
    BOOL     fDisableAddSites;
    SECURITYINITFLAGS()
    {
        dwZone = 0;
        fForceUI = FALSE;
        fDisableAddSites = FALSE;
    }
};

LANGID INETCPL_GetUILanguage();

#endif // _INETCPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\inethelp.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp.,                     **
//*********************************************************************

//
// HELP.C - Mappings for IDHs to IDCs
//

#include "inetcplp.h"
#include "iehelpid.h"

#define IDH_IGNORE  (-1)

const DWORD mapIDCsToIDHs[] = {

    IDC_PLACES_CUSTOMIZE_GROUPBOX       , IDH_GROUPBOX,
    IDC_START_ADDRESS                   , IDH_CUST_ADDRESS,
    IDC_USECURRENT                      , IDH_CUST_CURR,
    IDC_USEDEFAULT                      , IDH_CUST_DEF,
    IDC_USEBLANK                        , IDH_CPL_GEN_USEBLANK,
    IDC_CACHE_VIEW_FILES                , IDH_TIF_VIEW,
    IDC_CACHE_DELETE_FILES              , IDH_TEMP_EMPTY,
    IDC_CACHE_DELETE_COOKIES            , IDH_DEL_COOKIE_THIRD_PARTY,
    IDC_CACHE_SETTINGS                  , IDH_TIF_SETTINGS,

    IDC_ADVANCED_CACHE_STATUS           , IDH_IGNORE,
    IDC_ADVANCED_CACHE_LOCATION         , IDH_IGNORE,
    IDC_ADVANCED_CACHE_SIZE_SPIN        , IDH_IGNORE,

    IDC_TEMPORARY_INTERNET_FILES_SETTINGS_GROUPBOX         ,IDH_GROUPBOX,
    IDC_ADVANCED_TEMP_FILES_GROUPBOX                       ,IDH_GROUPBOX,
    IDC_ADVANCED_CACHE_BROWSE                              ,IDH_TIF_VIEW,
    IDC_ADVANCED_CACHE_PERCENT_ACC                         ,IDH_TEMP_AMOUNT,
    IDC_ADVANCED_CACHE_PERCENT                             ,IDH_TEMP_AMOUNT,
    IDC_ADVANCED_CACHE_TEXT_PERCENT                        ,IDH_TEMP_AMOUNT,
    IDC_ADVANCED_CACHE_MB                                  ,IDH_TEMP_AMOUNT,
    IDC_ADVANCED_CACHE_EMPTY                               ,IDH_TEMP_EMPTY,
    IDC_ADVANCED_CACHE_ONCEPERSESS                         ,IDH_TEMP_START,
    IDC_ADVANCED_CACHE_AUTOMATIC                           ,IDH_TEMP_AUTO,
    IDC_ADVANCED_CACHE_NEVER                               ,IDH_TEMP_NEVER,
    IDC_ADVANCED_CACHE_ALWAYS                              ,IDH_TEMP_EVERY,
    IDC_ADVANCED_DOWNLOADED_CONTROLS                       ,IDH_TEMP_INTERNET_VIEW_OBJECTS_BTN,
    IDC_ADVANCED_MOVE_CACHE_LOCATION                       ,IDH_TEMP_MOVE,
    IDC_PLACES_HISTORY_GROUPBOX         , IDH_GROUPBOX,
    IDC_HISTORY_DAYS                    , IDH_HIST_NUM,
    IDC_HISTORY_SPIN                    , IDH_HIST_NUM,
//    IDC_HISTORY_VIEW                    , IDH_HIST_VIEW,
    IDC_HISTORY_CLEAR                   , IDH_HIST_CLEAR,
    //------------------------------------------------------------------------
    // Security tab
    //------------------------------------------------------------------------
    IDC_COMBO_ZONE                      , IDH_CPL_SEC_ZONE_DROPLIST,
    IDC_ZONE_RESET                      , IDH_SECURITY_RESET_ZONE_DEFAULTS,
    IDC_ZONE_GROUPBOX                   , IDH_GROUPBOX,
    IDC_LIST_ZONE                       , IDH_SEC_ZONE_LIST,
    IDC_BUTTON_ADD_SITES                , IDH_CPL_SEC_ADDSITES,
    IDC_SLIDER                          , IDH_SEC_LVL_SLIDER,
    IDC_LEVEL_NAME                      , IDH_SEC_LVL_SLIDER,
    IDC_LEVEL_DESCRIPTION               , IDH_SEC_LVL_SLIDER,
    IDC_RADIO_HIGH                      , IDH_SAFE_EXPERT,
    IDC_RADIO_MEDIUM                    , IDH_SAFE_NORM,
    IDC_RADIO_LOW                       , IDH_SAFE_NONE,
    IDC_RADIO_CUSTOM                    , IDH_CPL_SEC_CUSTOM_LEVEL,
    IDC_BUTTON_SETTINGS                 , IDH_CPL_SEC_SETTINGS,
    IDC_ZONE_ICON                       , IDH_GROUPBOX,
    IDC_ZONELABEL                       , IDH_GROUPBOX,
    IDC_STATIC_EMPTY                    , IDH_GROUPBOX,
    IDC_ZONE_DESCRIPTION                , IDH_GROUPBOX,
    IDC_LEVEL_GROUPBOX                  , IDH_GROUPBOX,
    IDC_STATIC_SLIDERMOVETEXT           , IDH_IGNORE,

    IDC_LIST_WEBSITES                   , IDH_CPL_WEB_SITES_LIST,
    IDC_BUTTON_REMOVE                   , IDH_CPL_WEB_SITES_REMOVE,
    IDC_CHECK_REQUIRE_SERVER_VERIFICATION, IDH_CPL_REQ_VERIFICATION_CHKBOX,
    IDC_EDIT_ADD_SITE                   , IDH_CPL_WEB_SITES_ADD_THIS_TXT,
    IDC_BUTTON_ADD                      , IDH_CPL_WEB_SITES_ADD_BUTTON,

    IDC_GROUP_CURRENT_SETTINGS          , IDH_GROUPBOX,
    IDC_TREE_SECURITY_SETTINGS          , IDH_CPL_SEC_SETTINGS_CURRENT,

    //------------------------------------------------------------------------
    // Content tab
    //------------------------------------------------------------------------
    IDC_ADVANCED_RATINGS_GROUPBOX       , IDH_GROUPBOX,
    IDC_RATINGS_TURN_ON                 , IDH_RATE_TOGGLE,
    IDC_ADVANCED_RATINGS_BUTTON         , IDH_RATE_PROP,
    IDC_RATINGS_TEXT                    , IDH_GROUPBOX,
    IDC_RATINGS_ICON                    , IDH_GROUPBOX,
    IDC_SECURITY_ACTIVE_CONTENT_GROUPBOX, IDH_GROUPBOX,
    IDC_SECURITY_SITES_BUTTON           , IDH_CERT_SITE,
    IDC_SECURITY_PUBLISHERS_BUTTON      , IDH_CERT_PUB,
    IDC_SECURITY_CLEAR_SSL_CACHE_BUTTON , IDH_ADV_CLEAR_SSL_CACHE,
    IDC_PROGRAMS_WALLET_GROUPBOX        , IDH_GROUPBOX,
    IDC_RESET_SHARING                   , IDH_RESET_SHARING_OPS,    // n/a
    IDC_EDIT_PROFILE                    , IDH_EDIT_PROFILE_BTN,
    IDC_AUTOSUGGEST_SETTINGS            , IDH_OPTS_PROG_AUTOSUGGEST_BUT,
    IDC_AUTOSUGGEST_ENABLEADDR          , IDH_AUTOCOMP,
    IDC_AUTOSUGGEST_ENABLEFORM          , IDH_INTELLIFORM,
    IDC_AUTOSUGGEST_SAVEPASSWORDS       , IDH_INTELLIFORM_PW,
    IDC_AUTOSUGGEST_PROMPTPASSWORDS     , IDH_INTELLIFORM_PW_PROMPT,
    IDC_AUTOSUGGEST_CLEARFORM           , IDH_CLEAR_INTELLIFORM,
    IDC_AUTOSUGGEST_CLEARPASSWORDS      , IDH_CLEAR_INTELLIFORM_PW,
    IDC_AUTOSUGGEST_CLEAR_TEXT          , IDH_IGNORE,
    IDC_AUTOSUGGEST_STATIC_TEXT         , IDH_IGNORE,
    IDC_AUTOSUGGEST_FOR_GROUP           , IDH_GROUPBOX,
    IDC_AUTOSUGGEST_HISTORY_GROUP       , IDH_GROUPBOX,
#ifdef WALLET
    IDC_PROGRAMS_WALLET_SETTINGS        , IDH_OPTS_PROG_WALLET_BUT,
    IDC_PROGRAMS_WALLET_ADDRBUTTON      , IDH_OPTS_PROG_ADDRMGR_BUT,
    IDC_PROGRAMS_WALLET_PAYBUTTON       , IDH_OPTS_PROG_PAYMENTMGR_BUT,
#endif
    IDC_COMBO_RESETLEVEL                , IDH_SECURITY_RESET_LEVEL_DEFAULTS,
    IDC_BUTTON_APPLY                    , IDH_SECURITY_RESET_LEVEL_DEFAULTS,

    IDC_DEFAULT_SETTINGS_GROUPBOX       , IDH_GROUPBOX,
    IDC_GRP_DIALUPSETTINGS              , IDH_GROUPBOX,
    IDC_GRP_LANSETTINGS                 , IDH_GROUPBOX,
    IDC_CONNECTION_WIZARD               , IDH_CPL_CNX_WIZARD,
    IDC_LAN_SETTINGS                    , IDH_PROX_SETTINGS,
    IDC_CON_SHARING                     , IDH_CONNECTION_SHARING,
    IDC_CONN_LIST                       , IDH_CONNECTION_TAB_CONNECTOID_LIST,
    IDC_DIALUP                          , IDH_DIAL_USE,
    IDC_DIALUP_NEVER                    , IDH_NEVERDIAL,
    IDC_DIALUP_ON_NONET                 , IDH_DIALIF_NETCNX_GONE,
    IDC_DIALUP_ADD                      , IDH_DIAL_ADD,
    IDC_DIALUP_REMOVE                   , IDH_CONNECTION_TAB_REMOVE_CONNECTOID,
    IDC_SET_DEFAULT                     , IDH_DIAL_DEFAULT,
    IDC_DIAL_DEF_TXT                    , IDH_CNX_CURRENT_DEFAULT_LBL_N_DISP,
    IDC_DIAL_DEF_ISP                    , IDH_CNX_CURRENT_DEFAULT_LBL_N_DISP,
    IDC_MODEM_SETTINGS                  , IDH_CPL_CNX_SETTINGS,
    IDC_ENABLE_SECURITY                 , IDH_CONNECT_TAB_PERFORM_SECUR_CHECKB4_DIALING,
    IDC_CON_SHARING                     , IDH_CONNECTION_SHARING,

    IDC_PROXY_ICON1                     , IDH_IGNORE,
    IDC_PROXY_ICON2                     , IDH_IGNORE,
    IDC_GRP_SETTINGS2                   , IDH_GROUPBOX,
    IDC_PROXY_EXCEPTIONS_GROUPBOX       , IDH_GROUPBOX,
    IDC_GRP_AUTO                        , IDH_GROUPBOX,
    IDC_AUTODISCOVER                    , IDH_PROX_SERV_AUTO,
    IDC_CONFIGSCRIPT                    , IDH_AUTOCONFIG_BUTTON,
    IDC_CONFIG_ADDR                     , IDH_AUTOCONFIG_TEXT,
    IDC_CONFIGADDR_TX                   , IDH_AUTOCONFIG_TEXT,
    IDC_GRP_PROXY                       , IDH_GROUPBOX,
    IDC_MANUAL                          , IDH_PROX_SERV,
    IDC_ADDRESS_TEXT                    , IDH_CPL_CNX_PROXY_ADDR_PORT,
    IDC_PROXY_ADDR                      , IDH_CPL_CNX_PROXY_ADDR_PORT,
    IDC_PORT_TEXT                       , IDH_CPL_CNX_PROXY_ADDR_PORT,
    IDC_PROXY_PORT                      , IDH_CPL_CNX_PROXY_ADDR_PORT,
    IDC_PROXY_ADVANCED                  , IDH_PROX_SETTINGS_ADV,
    IDC_PROXY_OMIT_LOCAL_ADDRESSES      , IDH_EXCEPT_LOCAL,
    IDC_GRP_DIAL                        , IDH_GROUPBOX,
    IDC_USER                            , IDH_CPL_DUN_USERNAME,
    IDC_TX_USER                         , IDH_CPL_DUN_USERNAME,
    IDC_PASSWORD                        , IDH_CPL_DUN_PASSWORD,
    IDC_TX_PASSWORD                     , IDH_CPL_DUN_PASSWORD,
    IDC_DOMAIN                          , IDH_CPL_DUN_DOMAIN,
    IDC_TX_DOMAIN                       , IDH_CPL_DUN_DOMAIN,
    IDC_RAS_SETTINGS                    , IDH_DIAL_PROP,
    IDC_DIAL_ADVANCED                   , IDH_DIAL_PROP_ADV,
    IDC_DONT_USE_CONNECTION             , IDH_CPL_DUN_SEND_MY_LOGIN,

    IDC_TX_CONNECT                      , IDH_CPL_DUN_ATTEMPT_X_TIMES,
    IDC_TX_TIMES                        , IDH_CPL_DUN_ATTEMPT_X_TIMES,
    IDC_CONNECT                         , IDH_CPL_DUN_ATTEMPT_X_TIMES,
    IDC_CONNECT_SPIN                    , IDH_CPL_DUN_ATTEMPT_X_TIMES,
    IDC_TX_INTERVAL                     , IDH_CPL_DUN_WAIT_X_SECS,
    IDC_INTERVAL                        , IDH_CPL_DUN_WAIT_X_SECS,
    IDC_INTERVAL_SPIN                   , IDH_CPL_DUN_WAIT_X_SECS,
    IDC_TX_SECONDS                      , IDH_CPL_DUN_WAIT_X_SECS,
    IDC_IDLE_TIMEOUT                    , IDH_DIAL_DIS,
    IDC_IDLE_SPIN                       , IDH_DIAL_DIS,
    IDC_ENABLE_AUTODISCONNECT           , IDH_DIAL_DIS,
    IDC_TX_AUTODISCONNECT               , IDH_DIAL_DIS,
    IDC_EXIT_DISCONNECT                 , IDH_DISCONNECT_ON_IEEXIT,

    IDC_TYPE_TEXT                       , IDH_SERV_INFO,
    IDC_ADDR_TEXT                       , IDH_SERV_INFO,
    IDC_PROXY_ENABLE                                       ,IDH_PROX_SERV,
    IDC_PROXY_HTTP_ADDRESS                                 ,IDH_SERV_INFO,
    IDC_EXCEPT_TEXT                                        ,IDH_EXCEPT_PROX,
    IDC_EXCEPT2_TEXT                                       ,IDH_EXCEPT_PROX,
    IDC_PROXY_OVERRIDE                                     ,IDH_EXCEPT_PROX,
    IDC_PROXY_SECURITY_ADDRESS                             ,IDH_SERV_INFO,
    IDC_PROXY_FTP_ADDRESS                                  ,IDH_SERV_INFO,
    IDC_PROXY_GOPHER_ADDRESS                               ,IDH_SERV_INFO,
    IDC_PROXY_HTTP_PORT                                    ,IDH_SERV_INFO,
    IDC_PROXY_SECURITY_PORT                                ,IDH_SERV_INFO,
    IDC_PROXY_FTP_PORT                                     ,IDH_SERV_INFO,
    IDC_PROXY_GOPHER_PORT                                  ,IDH_SERV_INFO,
    IDC_PROXY_SOCKS_ADDRESS                                ,IDH_SERV_INFO,
    IDC_PROXY_SOCKS_PORT                                   ,IDH_SERV_INFO,
    IDC_PROXY_HTTP_CAPTION                                 ,IDH_SERV_INFO,
    IDC_PROXY_SECURITY_CAPTION                             ,IDH_SERV_INFO,
    IDC_PROXY_FTP_CAPTION                                  ,IDH_SERV_INFO,
    IDC_PROXY_GOPHER_CAPTION                               ,IDH_SERV_INFO,
    IDC_PROXY_USE_SAME_SERVER                              ,IDH_SERV_SAME,
    IDC_PROXY_OMIT_LOCAL_ADDRESSES                         ,IDH_EXCEPT_LOCAL,
    IDC_PROXY_SOCKS_CAPTION                                ,IDH_SERV_INFO,

    IDC_PROGRAMS_MAILANDNEWS_GROUPBOX   , IDH_GROUPBOX,
#ifndef UNIX
    IDC_PROGRAMS_MAIL_COMBO             , IDH_MAIL,
    IDC_PROGRAMS_NEWS_COMBO             , IDH_NEWS,
    IDC_PROGRAMS_CALL_COMBO             , IDH_CPL_PROGRAMS_INTERNET_CALL,
    IDC_PROGRAMS_HTMLEDITOR_COMBO       , IDH_HTML_EDITOR,
#else
    IDC_EDIT_PROGRAMS_MAIL              , IDH_MAIL,
    IDC_EDIT_PROGRAMS_NEWS              , IDH_NEWS,
#endif
    IDC_CONTACT_LIST_GROUPBOX           , IDH_GROUPBOX,
    IDC_PROGRAMS_CONTACT_COMBO          , IDH_CPL_PROGRAMS_CONTACTS,
    IDC_PROGRAMS_CALENDAR_COMBO         , IDH_CPL_PROGRAMS_CAL,
    IDC_INTERNET_CALLS_GROUPBOX         , IDH_GROUPBOX,
    IDC_CHECK_ASSOCIATIONS_CHECKBOX     , IDH_IE_DEF,

    IDC_ADVANCED_STATIC                 , IDH_IGNORE,
//    IDC_ADVANCEDTREE                    , IDH_OPTS_PROG_ADV_ADV,
    IDC_COLORS                          , IDH_CPL_ADV_COLORS,
    IDC_FONTS                           , IDH_FONT_INT,
    IDC_LANGUAGES                       , IDH_OPTS_GEN_LANG_BUT,
    IDC_ACCESSIBILITY                   , IDH_CPL_ADV_ACCESSIBILITY,
    IDC_RESTORE_DEFAULT                 , IDH_RESTORE_DEFS,

    IDC_GENERAL_APPEARANCE_GROUPBOX                        ,IDH_GROUPBOX,
    IDC_GENERAL_APPEARANCE_COLOR_TEXT_LABEL                ,IDH_APPEAR_OPTION,
    IDC_GENERAL_APPEARANCE_COLOR_TEXT                      ,IDH_APPEAR_OPTION,
    IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND_LABEL          ,IDH_APPEAR_OPTION,
    IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND                ,IDH_APPEAR_OPTION,
    IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX      ,IDH_APPEAR_OPTION,

    IDC_GENERAL_LINKS_GROUPBOX                             ,IDH_GROUPBOX,
    IDC_GENERAL_APPEARANCE_COLOR_LINKS                     ,IDH_APPEAR_LINK,
    IDC_GENERAL_APPEARANCE_COLOR_VISITED_LINKS             ,IDH_APPEAR_LINK,
//    IDC_GENERAL_APPEARANCE_UNDERLINE_LINKS_CHECKBOX        ,IDH_APPEAR_UNDERLINE,
    IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX        ,IDH_HOVERCOLOR,
    IDC_GENERAL_APPEARANCE_COLOR_HOVER                     ,IDH_HOVERCOLOR,
    IDC_FONTS_SCRIPTS_GROUPBOX          , IDH_GROUPBOX,
    IDC_FONTS_CHAR_SET_COMBO            , IDH_CHAR_SET,
    IDC_FONTS_PROP_FONT_LIST            , IDH_INTL_FONT_PROP,
    IDC_FONTS_FIXED_FONT_LIST           , IDH_INTL_FONT_FIXED,

    IDC_FONTS_SETDEFAULT_BUTTON         , IDH_INTL_DEFAULT_OE,
    IDC_FONTS_CODE_PAGES_LIST           , IDH_CHAR_SET_OE,
    IDC_FONTS_PROP_FONT_COMBO           , IDH_INTL_FONT_PROP_OE,
    IDC_FONTS_FIXED_FONT_COMBO          , IDH_INTL_FONT_FIXED_OE,
    IDC_FONTS_SIZE_FONT_COMBO           , IDH_OPTS_GEN_FONTS_FONTSIZE,
    IDC_FONTS_MIME_FONT_COMBO           , IDH_FONT_MIME_OE,

    IDC_LANG_ACCEPT_LIST                , IDH_LANG_PREFS_LIST,
    IDC_LANG_MOVE_UP_BUTTON             , IDH_LANG_PREFS_UP,
    IDC_LANG_MOVE_DOWN_BUTTON           , IDH_LANG_PREFS_DOWN,
    IDC_LANG_REMOVE_BUTTON              , IDH_LANG_PREFS_REMOVE,
    IDC_LANG_ADD_BUTTON                 , IDH_LANG_PREFS_ADD,
    IDC_LANG_UI_PREF                    , IDH_LANG_UI_PREF,
    IDC_LANG_ADDSPK                     , IDH_LANG_ADDSPK,

    IDC_LANG_AVAILABLE_LIST             , IDH_ADD_LANGUAGE_LANGUAGE_LIST,
    IDC_LANG_USER_DEFINED_EDIT          , IDH_ADD_LANGUAGE_USER_DEFINED,

    IDC_COMBO_UILANG                    , IDH_COMBO_UILANG,

    IDC_GROUP_FORMATTING                , IDH_GROUPBOX,
    IDC_GROUP_STYLESHEET                , IDH_GROUPBOX,
    IDC_CHECK_COLOR                     , IDH_CPL_ACCESS_USE_MY_COLORS,
    IDC_CHECK_FONT_SIZE                 , IDH_CPL_ACCESS_USE_MY_F_SIZE,
    IDC_CHECK_FONT_STYLE                , IDH_CPL_ACCESS_USE_MY_F_STYLE,
    IDC_CHECK_USE_MY_STYLESHEET         , IDH_CPL_ACCESS_USE_MY_STYLESHEETS,
    IDC_STATIC_STYLESHEET               , IDH_IGNORE,
    IDC_EDIT_STYLESHEET                 , IDH_CPL_ACCESS_USE_MY_STYLESHEETS,
    IDC_STYLESHEET_BROWSE               , IDH_RUNBROWSE,

    IDC_VIEWCERT                        ,IDH_VIEW_CERT,
    IDC_DELETECERT                      ,IDH_DEL_CERT,
    IDC_CERTLIST                        ,IDH_LIST_CERT,
    IDC_COMBO_SERVICE                   ,IDH_SITE_CERTS_ISSUER_TYPE,

    IDC_INTRANET_ADVANCED               ,IDH_ADD_SITES_ADVANCED_BTN,
    IDC_CHECK_USEINTRANET               ,IDH_LOCAL_INTRA_INCLUDE_ALL_NOT_LISTED,
    IDC_CHECK_PROXY                     ,IDH_LOCAL_INTRA_INCLUDE_ALL_THAT_BYPASS_PROXY,
    IDC_CHECK_UNC                       ,IDH_LOCAL_INTRA_INCLUDE_ALL_UNCS,

    IDC_JAVACUSTOM                      ,IDH_JAVA_CUST_SETTINGS_BTN,

    IDC_RESETWEBSETTINGS                ,IDH_RESET_WEBSTGS_BUTTON,
    IDC_RESETWEBSETTINGS_TEXT           ,IDH_RESET_WEBSTGS_BUTTON,

//------------------------------------------------------------------------
// Privacy tab
//------------------------------------------------------------------------

    IDC_LEVEL_SLIDER,                   IDH_PRIVACY_SLIDER,
    IDC_PRIVACY_IMPORT,                 IDH_PRIVACY_IMPORT,
    IDC_PRIVACY_DEFAULT,                IDH_PRIVACY_RESET_DEFAULTS,
    IDC_PRIVACY_ADVANCED,               IDH_PRIVACY_ADVANCED,

    IDC_USE_ADVANCED,                   IDH_PRIVADV_OVERRIDE,
    IDC_SESSION_OVERRIDE,               IDH_PRIVACYADV_ALLOW_SESSION,
    IDC_FIRST_ACCEPT,                   IDH_PRIVADV_FIRST_PARTY,
    IDC_FIRST_DENY,                     IDH_PRIVADV_FIRST_PARTY,
    IDC_FIRST_PROMPT,                   IDH_PRIVADV_FIRST_PARTY,
    IDC_THIRD_ACCEPT,                   IDH_PRIVACYADV_THIRD_PARTY,
    IDC_THIRD_DENY,                     IDH_PRIVACYADV_THIRD_PARTY,
    IDC_THIRD_PROMPT,                   IDH_PRIVACYADV_THIRD_PARTY,
    IDC_PRIVACY_EDIT,                   IDH_PRIVACYADV_EDIT,

    IDC_PRIVACYPS_ACCEPTBTN,            IDH_PRIVADV_ALLOW,
    IDC_PRIVACYPS_REJECTBTN,            IDH_PRIVADV_REJECT,
    IDC_PRIVACYPS_REMOVEBTN,            IDH_PRIVADV_REMOVE,
    IDC_PRIVACYPS_SITETOSET,            IDH_PRIVADV_ADDRESS,
    IDC_PRIVACYPS_LISTBOX,              IDH_PRIVADV_WEBSITES,
    IDC_PRIVACYPS_REMOVEALLBTN,         IDH_PRIVADV_REMOVE_ALL,
0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\pch.cpp ===
#include "inetcplp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\init.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************

//
//    INIT.C - Initialization code for Internet control panel
//

//    HISTORY:
//    
//    4/3/95    jeremys        Created.
//

#include "inetcplp.h"
// external calls and defs
#include <inetcpl.h>

#define MLUI_INIT
#include <mluisupp.h>

HINSTANCE ghInstance=NULL;

extern HMODULE hOLE32;
DWORD g_dwtlsSecInitFlags;
BOOL g_bMirroredOS = FALSE;
HMODULE g_hOleAcc;
BOOL g_fAttemptedOleAccLoad = FALSE;

STDAPI_(BOOL) LaunchInternetControlPanelAtPage(HWND hDlg, UINT nStartPage);
BOOL IsCompatModeProcess(void);

/*******************************************************************

    NAME:        DllEntryPoint

    SYNOPSIS:    Entry point for DLL.

********************************************************************/
STDAPI_(BOOL) DllMain(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
    if( fdwReason == DLL_PROCESS_ATTACH )
    {
        SHFusionInitializeFromModule(hInstDll);

        if (IsCompatModeProcess())
            // Fail loading in compat mode process
            return 0;
        ghInstance = hInstDll;
        MLLoadResources(ghInstance, TEXT("inetcplc.dll"));
#ifndef REPLACE_PROPSHEET_TEMPLATE
        InitMUILanguage(INETCPL_GetUILanguage());
#endif

#ifdef DEBUG
        CcshellGetDebugFlags();
#endif
        // Thread local storage used in security.cpp
        g_dwtlsSecInitFlags = TlsAlloc();
        g_bMirroredOS = IS_MIRRORING_ENABLED();
        TlsSetValue(g_dwtlsSecInitFlags, (void *) new SECURITYINITFLAGS);

    }
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        MLFreeResources(ghInstance);

        if (g_hwndUpdate) 
        {
            // we've got this subclassed.
            // if it's still valid as we leave, we need 
            // to destroy it so that it doesn't fault trying to access our info
            DestroyWindow(g_hwndUpdate);
        }
        
        if(hOLE32)
        {
            FreeLibrary(hOLE32);
            hOLE32 = NULL;

        }

        if (g_hOleAcc)
        {
            FreeLibrary(g_hOleAcc);
            g_hOleAcc = NULL;
            g_fAttemptedOleAccLoad = FALSE;
        }

        // free tls used in security.cpp
        if(g_dwtlsSecInitFlags != (DWORD) -1)
        {
            SECURITYINITFLAGS * psif = NULL;
            psif = (SECURITYINITFLAGS *) TlsGetValue(g_dwtlsSecInitFlags);
            if(psif)
            {
                delete psif;
                psif = NULL;
            }
            TlsFree(g_dwtlsSecInitFlags);
        }
        SHFusionUninitialize();
    }
    return TRUE;
}


BOOL RunningOnNT()
{
    return !(::GetVersion() & 0x80000000);
}


/*******************************************************************

    NAME:        CPlApplet

    SYNOPSIS:    Entry point for control panel.

********************************************************************/
STDAPI_(LRESULT) CPlApplet         // Control panel applet procedure
(
    HWND        hwndCpl,            // Control panel parent window
    UINT        uMsg,               // message
    LPARAM      lParam1,            // value depends on message
    LPARAM      lParam2             // value depends on message
)
{

    LPNEWCPLINFO lpNewCplInfo = (LPNEWCPLINFO) lParam2;
    LPCPLINFO lpCplInfo = (LPCPLINFO) lParam2;
    DWORD dwNIcons;

    switch (uMsg)
    {
    case CPL_INIT:
        //  Initialization message from Control Panel
        return TRUE;

    case CPL_GETCOUNT:
        /* We always have the main internet CPL icon; on Win95 platforms,
         * we also have the Users icon if mslocusr.dll is present.
         */
        dwNIcons = 1;
        if (!RunningOnNT())
        {
            TCHAR szPath[MAX_PATH];

            // check if mslocusr.dll is present in the system dir
            if (GetSystemDirectory(szPath, ARRAYSIZE(szPath)))
            {
                PathAppend(szPath, TEXT("mslocusr.dll"));
                if (PathFileExists(szPath))
                    dwNIcons++;
            }
        }
        return dwNIcons;

    case CPL_INQUIRE:
        /* CPL #0 is the main Internet CPL, #1 (the only other one we'll ever
         * be asked about) is the Users CPL.
         */
        if (!lParam1) {
            lpCplInfo->idIcon = IDI_INTERNET;
            lpCplInfo->idName = IDS_INTERNET;
            lpCplInfo->idInfo = IDS_DESCRIPTION;
            lpCplInfo->lData = 0;
        }
        else {
            lpCplInfo->idIcon = IDI_USERS;
            lpCplInfo->idName = IDS_USERS;
            lpCplInfo->idInfo = IDS_USERS_DESCRIPTION;
            lpCplInfo->lData = 0;
        }
        return FALSE;

    case CPL_NEWINQUIRE:

        // Return new-style info structure for Control Panel

        // By not responding to NEWINQUIRE, Win95 will not preload our
        // .cpl file; by extension, since we are statically linked to MSHTML's
        // import library, MSHTML will also not be loaded.  If we respond to
        // this, then our cpl and MSHTML (>600k) are both loaded when the
        // control panel is just open.  (IE, they will be loaded even if the
        // user has not selected to invoke our specific cpl applet.

        return TRUE;   // TRUE == we are NOT responding to this
        break;

    case CPL_DBLCLK:

        //
        // This means the user did not specify a particular page
        //
        lParam2 = 0;

        // fall through

    case CPL_STARTWPARMSA:
    case CPL_STARTWPARMSW:

        /* CPL #0 is the main Internet CPL, #1 (the only other one we'll ever
         * be asked about) is the Users CPL.  The Users CPL is loaded from
         * mslocusr.dll dynamically.  The entrypoint is structured as a
         * rundll32 entrypoint.
         */
        if (!lParam1) {
        
            //
            // If lParam2!=NULL, then the user specified a page on the command line
            //
            if (lParam2)
            {
                UINT nPage;
                if (CPL_STARTWPARMSA == uMsg)
                    nPage = StrToIntA((LPSTR)lParam2);
                else
                    nPage = StrToIntW((LPWSTR)lParam2);

                LaunchInternetControlPanelAtPage(hwndCpl, nPage);
                
            }

            //
            // Otherwise request the default page
            //
            else
                LaunchInternetControlPanelAtPage(hwndCpl,DEFAULT_CPL_PAGE);
            
            

        }
        else {
            HINSTANCE hinstMSLU = LoadLibrary(TEXT("mslocusr.dll"));
            if (hinstMSLU != NULL) {
                typedef void (*PFNRUNDLL)(HWND hwndParent, HINSTANCE hinstEXE, LPSTR pszCmdLine, int nCmdShow);
                PFNRUNDLL pfn = (PFNRUNDLL)GetProcAddress(hinstMSLU, "UserCPL");
                if (pfn != NULL) {
                    (*pfn)(hwndCpl, NULL, "", SW_SHOW);
                }
                FreeLibrary(hinstMSLU);
            }
        }
        return TRUE;

    case CPL_EXIT:
        // Control Panel is exiting
        break;

    default:
        break;
    }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\lang.cpp ===
///////////////////////////////////////////////////////////////////////
//                     Microsoft Windows                             //
//              Copyright(c) Microsoft Corp., 1995                   //
///////////////////////////////////////////////////////////////////////
//
// LANG.CPP - "Language" property page for InetCpl
//

// HISTORY:
//
// 1/10/97  beomoh      created
//

#include "inetcplp.h"

#include <tchar.h>
#include <mlang.h>
#include "psapi.h"
#include "tlhelp32.h"
#include "process.h"
#include <mluisupp.h>
#include <shdocvw.h>

#define ARRAYSIZE(a)        (sizeof(a)/sizeof(a[0]))
#define FORMAT_STR          TEXT("%s [%s]")
#define MAX_LIST_STRING_LEN MAX_LOCALE_NAME + MAX_RFC1766_NAME + 3
#define MAX_ACCEPT_LANG_LEN 2048

#define CP_THAI     874
#define CP_ARABIC   1256
#define CP_HEBREW   1255

// used as the return value from setlang dialog
#define RETURN_SETLANG_ENDLANGDIALOG    2
#define RETURN_SETLANG_CLOSEDNORMAL     1
#define RETURN_SETLANG_CANCELED         0

typedef HRESULT (* PCOINIT) (LPVOID);
typedef VOID (* PCOUNINIT) (VOID);
typedef VOID (* PCOMEMFREE) (LPVOID);
typedef HRESULT (* PCOCREINST) (REFCLSID, LPUNKNOWN, DWORD,     REFIID, LPVOID * );

extern HMODULE hOLE32;
extern PCOINIT pCoInitialize;
extern PCOUNINIT pCoUninitialize;
extern PCOMEMFREE pCoTaskMemFree;
extern PCOCREINST pCoCreateInstance;

extern BOOL _StartOLE32();

class CUILangList;
INT_PTR KickSetLang(HWND hDlg, CUILangList * pLangList);

static const TCHAR s_szResourceLocale[] = TEXT("ResourceLocale");
// HKLM\Software\Microsoft\Internet Explorer\International used for url string
static const TCHAR s_szUrlSPK[] 
= TEXT("http://www.microsoft.com/isapi/redir.dll?prd=ie&pver=6&ar=plugui&sba=install");
static const TCHAR c_szInstall[] 
= TEXT("Software\\Microsoft\\Active Setup\\Installed Components\\{89820200-ECBD-11CF-8B85-00AA005B4383}");
static const TCHAR c_szLocale[] = TEXT("Locale");
static const TCHAR s_szLangPackPath[]   = TEXT("Software\\Microsoft\\Internet Explorer");
static const TCHAR s_szVersion[] = TEXT("LPKInstalled");

typedef struct 
{
    WORD wlangid;
    BOOL fValid;
    TCHAR szName[MAX_LOCALE_NAME];
} LANGLIST;

static LANGLIST s_arryLangList[] = 
{
    {0x0409, FALSE, {0}},
    {0x0407, FALSE, {0}},
    {0x0411, FALSE, {0}},
    {0x0412, FALSE, {0}},
    {0x0404, FALSE, {0}},
    {0x0804, FALSE, {0}},
    {0x040c, FALSE, {0}},
    {0x0c0a, FALSE, {0}},
    {0x0416, FALSE, {0}},
    {0x0410, FALSE, {0}},
    {0x0413, FALSE, {0}},
    {0x041d, FALSE, {0}},
    {0x0406, FALSE, {0}},
    {0x040b, FALSE, {0}},
    {0x040e, FALSE, {0}},
    {0x0414, FALSE, {0}},
    {0x0408, FALSE, {0}},
    {0x0415, FALSE, {0}},
    {0x0419, FALSE, {0}},
    {0x0405, FALSE, {0}},
    {0x0816, FALSE, {0}},
    {0x041f, FALSE, {0}},
    {0x041b, FALSE, {0}},
    {0x0424, FALSE, {0}},
    {0x0401, FALSE, {0}},
    {0x040d, FALSE, {0}},
    {0x042d, FALSE, {0}},
    {0x040f, FALSE, {0}},
};

//
//  ISO639 ID table
//
typedef struct tagISO639
{
    LPCTSTR ISO639;
    LANGID LangID;
}   ISO639, *LPISO639;

const ISO639 c_ISO639[] =
{
    { TEXT("EN"), 0x0409 },
    { TEXT("DE"), 0x0407 },
    { TEXT("JA"), 0x0411 },
    { TEXT("KO"), 0x0412 },
    { TEXT("TW"), 0x0404 },
    { TEXT("CN"), 0x0804 },
    { TEXT("FR"), 0x040C },
    { TEXT("ES"), 0x0C0A },
    { TEXT("BR"), 0x0416 },
    { TEXT("IT"), 0x0410 },
    { TEXT("NL"), 0x0413 },
    { TEXT("SV"), 0x041D },
    { TEXT("DA"), 0x0406 },
    { TEXT("FI"), 0x040B },
    { TEXT("HU"), 0x040E },
    { TEXT("NO"), 0x0414 },
    { TEXT("EL"), 0x0408 },
    { TEXT("PL"), 0x0415 },
    { TEXT("RU"), 0x0419 },
    { TEXT("CS"), 0x0405 },
    { TEXT("PT"), 0x0816 },
    { TEXT("TR"), 0x041F },
    { TEXT("SK"), 0x041B },
    { TEXT("SL"), 0x0424 },
    { TEXT("AR"), 0x0401 },
    { TEXT("HE"), 0x040D },
    { TEXT("EU"), 0x042D },
    { TEXT("IS"), 0x040F },
};

// GetInstallLanguage
//
// synopsis - borrowed this function from shlwapi. we can remove this
//            once we have it exported from shlwapi.dll
//
LANGID GetInstallLanguage(void)
{
    static LANGID LangID = 0;
    TCHAR szISO639[3];
    DWORD cb;

    if (0 == LangID)
    {
        cb = sizeof(szISO639);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szInstall, c_szLocale, NULL, szISO639, &cb))
        {
            int i;

            for (i = 0; i < ARRAYSIZE(c_ISO639); i++)
            {
                if (!StrCmpNI(szISO639, c_ISO639[i].ISO639, ARRAYSIZE(szISO639)))
                {
                    LangID = c_ISO639[i].LangID;
                    break;
                }
            }
        }
    }
    return LangID;
}

// CUILangList
// 
// maintains the list of UI languages for user to choose
//
class CUILangList
{
public:
    CUILangList() {_iLangIdx = -1; lang = s_arryLangList; 
                   _nLangList = ARRAYSIZE(s_arryLangList);
                   _fOffice9Installed = -1;};
    
    void    ValidateLangList();
    BOOL    IsValidLang(int idx) { return (idx < _nLangList) ? lang[idx].fValid: FALSE; };
    int     GetCurrentLangIdx();
    void    SetCurrentLangIdx(int idx);
    LPCTSTR GetCurrentLangName();
    LPCTSTR GetLangNameOfIdx(int idx);
    WORD    GetLangIdOfIdx(int idx) { return (idx < _nLangList) ? lang[idx].wlangid:0; };
    UINT    GetIds(int idx); 
    int     GetListSize() {return _nLangList;};
    BOOL    IsOffice9Installed();
    static  HRESULT GetLangList(HWND hdlg, CUILangList ** ppLangList);
    static  HRESULT RemoveLangList(HWND hdlg);
private:
    int _iLangIdx;
    int _nLangList;
    int _fOffice9Installed;
    LANGLIST *lang;
};

// CShutDownProcInfo
// 
// manages information about processes we want
// to shutdown/restart.
//
typedef enum 
{
    PS_UNKNOWN=0, 
    PS_CANDIDATE, 
    PS_TO_BE_SHUTDOWN, 
    PS_IGNORE, 
    PS_SHUTDOWN_OK, 
    PS_WAITING, 
    PS_TO_BE_SHUTDOWN_WITH_NO_RELAUNCH, 
    PS_SHUTDOWN_OK_NO_RELAUNCH_NEEDED, 
} PROCSTATE; 

class CShutDownProcInfo : public CProcessInfo
{
public:
    CShutDownProcInfo(HWND hdlgParent);
    ~CShutDownProcInfo();
    HRESULT EnsureProcList();
    HRESULT IncreaseProcList();
    HRESULT NotifyShutDownToFolks(int *nProccess);
    HRESULT AddToProcList(HWND hwndShutDown);
    HRESULT WaitForOneProcess(int iProc);
    HRESULT WaitForFolksShutDown();
    HRESULT GetRestartAppPath(LPTSTR szPath, int cchPath, int iProc);
    HRESULT RestartFolks();
    static DWORD CALLBACK ShutDownThreadProc(void *pv);
protected:
    typedef struct
    {
        DWORD dwPID;
        TCHAR szExeName[32];
        PROCSTATE State; 
    } PROCLIST;
    PROCLIST *_pProcList;
    int _nAlloced;
    int _iProcList;
    HWND _hdlgParent;
    BOOL _fAllShutDown;
};
// this always fills '0' to empty digits
// caller has to make sure sz has cdigit+1 of buffer
void IntToHex(OUT LPTSTR sz, IN int cdigit, IN int value)
{
    int i, idigit;

    if (sz && value > 0 && cdigit > 0)
    {
        // nul terminate the buffer
        sz[cdigit] = TEXT('\0');
        
        for (i = cdigit-1; i >= 0; i--, value /= 16)
        {
            idigit = value%16;
            if (idigit < 10)
                sz[i] = (TCHAR)idigit + TEXT('0');
            else 
                sz[i] = (TCHAR)idigit - 10 + TEXT('A');
        }
    }
} 

// set valid flags for the lang list
// very expensive so expects to be called only once in a session
// from CUILangList::GetLangList
//
#define MAX_SATELLITEPACKS 30 // 30 must be a practical number for satellite packs
void CUILangList::ValidateLangList()
{
    HKEY hKey;
    HRESULT hr;
    TCHAR szValueName[32];
    WORD aryValidLang[MAX_SATELLITEPACKS +1+1] = {0}; // +1 for install lang, 
                                                      // +1 for terminator

    int  nMaxValidLang = ARRAYSIZE(aryValidLang)-1;   // -1 for terminator
    WORD *pwValid = aryValidLang;
    
    // make the install language always valid
    *pwValid = GetInstallLanguage();
    if (*pwValid != 0)
    {
       *(pwValid+1) = 0; // terminator
       pwValid++;
       nMaxValidLang--;
    }

    if (ERROR_SUCCESS == 
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_INTERNATIONAL, NULL, KEY_READ, &hKey))
    {
        int i = 0;
        do {
            // see if the value has a match in the list
            DWORD dwType;
            DWORD cb = ARRAYSIZE(szValueName)-2;

            hr = SHEnumValue(hKey, i++, szValueName+2, &cb, &dwType, NULL, NULL);
            if (SUCCEEDED(hr) && dwType == REG_SZ)
            {
                UINT uiInstalled ;

                szValueName[0] = TEXT('0');
                szValueName[1] = TEXT('x');
                StrToIntEx(szValueName, STIF_SUPPORT_HEX, (LPINT)&uiInstalled);
                if (uiInstalled > 0)
                {
                    *pwValid     = (unsigned short) uiInstalled;
                    *(pwValid+1) = 0; // terminator
                    pwValid++;
                }
            }
        } while(hr == ERROR_SUCCESS && i < nMaxValidLang);
        RegCloseKey(hKey);
    }

    // this assumes we can use StrChrW to search a value in 
    // a word array, it also assumes we never have 0 as a langid
    //
    Assert(sizeof(WORD) == sizeof(WCHAR)); // unix?

    int nValidLang = (int)(pwValid-aryValidLang);
    for(int idx = 0; idx < GetListSize(); idx++ )
    {
        // abusing the string function but this is a fast way
        if (StrChrW((WCHAR *)aryValidLang, (WCHAR)lang[idx].wlangid))
        {
            lang[idx].fValid = TRUE;
            if(--nValidLang <= 0)
                break;
        }
    }
}

static const TCHAR s_szPropLangList[] = TEXT("langlist");
HRESULT CUILangList::GetLangList(HWND hdlg, CUILangList ** ppLangList)
{
    HRESULT hr=S_OK;
    
    CUILangList *pLangList = (CUILangList *)GetProp(hdlg, s_szPropLangList);
    if (!pLangList)
    {
        pLangList = new CUILangList();
        if (pLangList)
        {
            pLangList->ValidateLangList();
            SetProp(hdlg, s_szPropLangList, (HANDLE)pLangList);
        }
        else
            hr = E_FAIL;
    }
    
    ASSERT(ppLangList);
    if (ppLangList)
        *ppLangList = pLangList;
    
    return hr;
}

HRESULT CUILangList::RemoveLangList(HWND hdlg)
{
    HRESULT hr = S_OK;
    CUILangList *pLangList = (CUILangList *)GetProp(hdlg, s_szPropLangList);

    if (pLangList)
    {
        delete pLangList;
        RemoveProp(hdlg, s_szPropLangList);    
    }
    else
        hr = S_FALSE;

    return hr;
}

void CUILangList::SetCurrentLangIdx(int idx)
{
    TCHAR sz[4+1];
    if (idx != _iLangIdx)
    {
        // the resource id is always 4 digit
        IntToHex(sz, 4, lang[idx].wlangid);
        SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL, 
                   s_szResourceLocale, REG_SZ, (void *)sz, sizeof(sz));
        _iLangIdx = idx;
    }
}
// returns idx to the lang array
int CUILangList::GetCurrentLangIdx()
{
    // show the current selection
    TCHAR sz[64];
    DWORD dwType;
    int   isel;
    
    // see if it's cached already
    if (_iLangIdx == -1)
    {
        // We basically wants what we've set in the registry,
        // but if Office9 is installed we'll show whatever
        // Office sets, and we can't change the Office setting anyway
        // MLGetUILanguage returns Office's setting if its there
        // Also I suppose we want to show NT5's UI language here
        //
        if (IsOffice9Installed() || IsOS(OS_WIN2000ORGREATER))
            isel = INETCPL_GetUILanguage();
        else
        {
            DWORD dwcbData = sizeof(sz);

            HRESULT hr =  SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL, 
                                  s_szResourceLocale, &dwType, (void *)&sz[2], &dwcbData);
                   
            if (hr == ERROR_SUCCESS && dwType == REG_SZ)
            {
                sz[0] = TEXT('0');
                sz[1] = TEXT('x');
                StrToIntEx(sz, STIF_SUPPORT_HEX, (LPINT)&isel);
            }
            else
            {
                isel = GetInstallLanguage();
            }
        }
        
        for(int i = 0; i < GetListSize(); i++ )
        {
            if (isel == lang[i].wlangid)
            {
                _iLangIdx = i;
                break;
            }
        }
            
        // english for error case
        if (_iLangIdx < 0) 
            _iLangIdx = 0;
    }
    return _iLangIdx;
}

LPCTSTR CUILangList::GetLangNameOfIdx(int idx)
{
    LPCTSTR pszRet = NULL;
    IMultiLanguage2 *pML2;
    HRESULT hr;
    RFC1766INFO Rfc1766Info={0};

    if(!hOLE32)
    {
        if(!_StartOLE32())
        {
            ASSERT(FALSE);
            return NULL;
        }
    }
    hr = pCoInitialize(NULL);

    if (FAILED(hr))
        return NULL;

    hr = pCoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (LPVOID *) &pML2);

    if (SUCCEEDED(hr))
    {
        if (idx >= 0)
        {
            if (!lang[idx].szName[0])
            {
                pML2->GetRfc1766Info(lang[idx].wlangid, INETCPL_GetUILanguage(), &Rfc1766Info);
                StrCpyNW(lang[idx].szName, Rfc1766Info.wszLocaleName, ARRAYSIZE(lang[0].szName));            
            }
            pszRet = lang[idx].szName;        
        }
        pML2->Release();
    }

    pCoUninitialize();
    return pszRet;
}
 
LPCTSTR CUILangList::GetCurrentLangName()
{
    int idx = GetCurrentLangIdx();
    return GetLangNameOfIdx(idx);
}

BOOL CUILangList::IsOffice9Installed()
{
    DWORD dwVersion;
    DWORD cb = sizeof(dwVersion);
    if (_fOffice9Installed < 0)
    {
        _fOffice9Installed ++;
        if (ERROR_SUCCESS ==
            SHGetValue(HKEY_LOCAL_MACHINE, s_szLangPackPath, s_szVersion, NULL, &dwVersion, &cb)
          && dwVersion > 0) // magic number - christw tells me so
            _fOffice9Installed ++;
    }
    return (BOOL)_fOffice9Installed;
}

void InitCurrentUILang(HWND hDlg)
{
    BOOL fChanged = FALSE;
    CUILangList *pLangList;  
    LPCTSTR pszLangSel = NULL;
    HRESULT hr;
    
    hr = CUILangList::GetLangList(hDlg, &pLangList);
    
    if (SUCCEEDED(hr))
        pszLangSel = pLangList->GetCurrentLangName();
    
    if (pszLangSel)
    {
        TCHAR szBig[1024], szSmall[256];

        GetDlgItemText(hDlg, IDC_LANG_CURSEL, szBig, ARRAYSIZE(szBig));
        if (szBig[0])
            fChanged = (StrStr(szBig, pszLangSel) == NULL); 

        if (MLLoadString((fChanged)? IDS_LANG_FUTUREUSE: IDS_LANG_CURRENTUSE, szSmall, ARRAYSIZE(szSmall)) > 0)
        {
            wnsprintf(szBig, ARRAYSIZE(szBig), szSmall, pszLangSel);
            Static_SetText(GetDlgItem(hDlg, IDC_LANG_CURSEL), szBig);
        }
    }
}


//
// FillAcceptListBox()
//
// Fills the accept language listbox with names of selected language
//
void FillAcceptListBox(IN HWND hDlg)
{
    IMultiLanguage2 *pML2;
    HRESULT hr;
    HKEY hKey;
    DWORD cb;
    TCHAR sz[MAX_LIST_STRING_LEN], szBuf[MAX_ACCEPT_LANG_LEN], *p1, *p2, *p3;
    HWND hwndList = GetDlgItem(hDlg, IDC_LANG_ACCEPT_LIST);

    if(!hOLE32)
    {
        if(!_StartOLE32())
        {
            ASSERT(FALSE);
            return;
        }
    }
    hr = pCoInitialize(NULL);
    if (FAILED(hr))
        return;

    hr = pCoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (LPVOID *) &pML2);
    if (SUCCEEDED(hr))
    {
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL, NULL, NULL, NULL, KEY_SET_VALUE|KEY_READ, NULL, &hKey, NULL))
        {
            LCID lcid;
            RFC1766INFO Rfc1766Info;
            TCHAR sz1[MAX_LIST_STRING_LEN], sz2[MAX_RFC1766_NAME];

            cb = sizeof(szBuf);
            if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_ACCEPT_LANGUAGE, NULL, NULL, (LPBYTE)szBuf, &cb))
            {
                p1 = p2 = szBuf;
                while (NULL != *p1)
                {
                    WCHAR wsz[MAX_LIST_STRING_LEN];
                    BOOL bEnd = FALSE;

                    while (TEXT(',') != *p2 && NULL != *p2)
                        p2 = CharNext(p2);
                    if (NULL != *p2)
                        *p2 = NULL;
                    else
                        bEnd = TRUE;
                    p3 = p1;
                    while (TEXT(';') != *p3 && NULL != *p3)
                        p3 = CharNext(p3);
                    if (NULL != *p3)
                        *p3 = NULL;
#ifdef UNICODE
                    StrCpyN(wsz, p1, ARRAYSIZE(wsz));
#else
                    MultiByteToWideChar(CP_ACP, 0, p1, -1, wsz, MAX_RFC1766_NAME);
#endif
                    hr = pML2->GetLcidFromRfc1766(&lcid, wsz);
                    if (SUCCEEDED(hr))
                    {
                        hr = pML2->GetRfc1766Info(lcid, INETCPL_GetUILanguage(), &Rfc1766Info);
                        if (SUCCEEDED(hr))
                        {
#ifdef UNICODE
                            StrCpyN(sz1, Rfc1766Info.wszLocaleName, ARRAYSIZE(sz1));
#else
                            WideCharToMultiByte(CP_ACP, 0, Rfc1766Info.wszLocaleName, -1, sz1, MAX_LIST_STRING_LEN, NULL, NULL);
#endif
                            wnsprintf(sz, ARRAYSIZE(sz), FORMAT_STR, sz1, p1);
                        }
                    }
                    else
                    {
                        MLLoadString(IDS_USER_DEFINED, sz1, ARRAYSIZE(sz1));
                        wnsprintf(sz, ARRAYSIZE(sz), FORMAT_STR, sz1, p1);
                    }
                    ListBox_AddString(hwndList, sz);
                    if (TRUE == bEnd)
                        p1 = p2;
                    else
                        p1 = p2 = p2 + 1;
                }
            }
            else
            {
                lcid = GetUserDefaultLCID();

                hr = pML2->GetRfc1766Info(lcid, INETCPL_GetUILanguage(), &Rfc1766Info);
                if (SUCCEEDED(hr))
                {
#ifdef UNICODE
                    StrCpyN(sz1, Rfc1766Info.wszLocaleName,  ARRAYSIZE(sz1));
                    StrCpyN(sz2, Rfc1766Info.wszRfc1766,  ARRAYSIZE(sz2));
#else
                    WideCharToMultiByte(CP_ACP, 0, Rfc1766Info.wszLocaleName, -1, sz1, MAX_LIST_STRING_LEN, NULL, NULL);
                    WideCharToMultiByte(CP_ACP, 0, Rfc1766Info.wszRfc1766, -1, sz2, MAX_RFC1766_NAME, NULL, NULL);
#endif
                    wnsprintf(sz, ARRAYSIZE(sz), FORMAT_STR, sz1, sz2);
                    ListBox_AddString(hwndList, sz);
                }
            }
            RegCloseKey(hKey);
        }
        pML2->Release();
    }
    pCoUninitialize();
}

//
// LanguageDlgInit()
//
// Initializes the Language dialog.
//
BOOL LanguageDlgInit(IN HWND hDlg)
{
    if (!hDlg)
        return FALSE;   // nothing to initialize

    FillAcceptListBox(hDlg);

    EnableWindow(GetDlgItem(hDlg, IDC_LANG_REMOVE_BUTTON), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_UP_BUTTON), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_DOWN_BUTTON), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_LANG_ADD_BUTTON), !g_restrict.fInternational);
    
    // On NT5, we use NT5's MUI feature instead of IE5 plugui
    if (IsOS(OS_WIN2000ORGREATER))
        ShowWindow(GetDlgItem(hDlg, IDC_LANG_UI_PREF), SW_HIDE);
    else
    {
        UINT uiACP = GetACP();

        // We don't support PlugUI on these platforms
        if (uiACP == CP_ARABIC || uiACP == CP_HEBREW || uiACP == CP_THAI)
            ShowWindow(GetDlgItem(hDlg, IDC_LANG_UI_PREF), SW_HIDE);
        else
            EnableWindow(GetDlgItem(hDlg, IDC_LANG_UI_PREF), !g_restrict.fInternational);
    }

    // show the current UI lang
    InitCurrentUILang(hDlg);
    
    // everything ok
    return TRUE;
}

//
// SaveLanguageData()
//
// Save the new language settings into regestry
//
void SaveLanguageData(IN HWND hDlg)
{
    HKEY hKey;
    DWORD dw;
    int i, iNumItems, iQ, n;
    TCHAR szBuf[MAX_ACCEPT_LANG_LEN];

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL, NULL, NULL, NULL, KEY_WRITE, NULL, &hKey, &dw ))
    {
        HWND hwndList = GetDlgItem(hDlg, IDC_LANG_ACCEPT_LIST);

        iNumItems = ListBox_GetCount(hwndList);

        for (n = 1, iQ = 10; iQ < iNumItems; iQ *= 10, n++)
            ;

        szBuf[0] = NULL;
        for (i = 0; i < iNumItems; i++)
        {
            TCHAR sz[MAX_LIST_STRING_LEN], *p1, *p2;

            ListBox_GetText(hwndList, i, sz);
            p1 = sz;
            // We can assume safely there is '[' and ']' in this string.
            while (TEXT('[') != *p1)
                p1 = CharNext(p1);
            p1 = p2 = p1 + 1;
            while (TEXT(']') != *p2)
                p2 = CharNext(p2);
            *p2 = NULL;
            if (0 == i)
                StrCpyN(szBuf, p1, ARRAYSIZE(szBuf));
            else
            {
                TCHAR szF[MAX_ACCEPT_LANG_LEN], szQ[MAX_ACCEPT_LANG_LEN];

                int len = lstrlen(szBuf);
                StrCpyN(szBuf + len, TEXT(","), ARRAYSIZE(szBuf) - len);
                len++;
                StrCpyN(szBuf + len, p1, ARRAYSIZE(szBuf) - len);
                wnsprintf(szF, ARRAYSIZE(szF), TEXT(";q=0.%%0%dd"), n);
                wnsprintf(szQ, ARRAYSIZE(szQ), szF, ((iNumItems - i) * iQ + (iNumItems / 2)) / iNumItems);
                len = lstrlen(szBuf);
                StrCpyN(szBuf + len , szQ, ARRAYSIZE(szBuf) - len);
            }
        }
        RegSetValueEx(hKey, REGSTR_VAL_ACCEPT_LANGUAGE, NULL, REG_SZ, (LPBYTE)szBuf, (lstrlen(szBuf)+1)*sizeof(TCHAR));
        RegCloseKey(hKey);
    }
}

// MoveUpDownListItem()
//
// Move selected list item up or down
//
void MoveUpDownListItem(HWND hDlg, HWND hwndList, BOOL bUp)
{
    int i, iNumItems;
    TCHAR sz[MAX_LIST_STRING_LEN];

    i = ListBox_GetCurSel(hwndList);
    iNumItems = ListBox_GetCount(hwndList);
    ListBox_GetText(hwndList, i, sz);
    ListBox_DeleteString(hwndList, i);

    i += (bUp)? -1: 1;
    if (i < 0)
        i = 0;
    else if (i >= iNumItems)
        i = iNumItems - 1;
    ListBox_InsertString(hwndList, i, sz);
    ListBox_SetSel(hwndList, TRUE, i);
    ListBox_SetCurSel(hwndList, i);

    EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_UP_BUTTON), i != 0);
    EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_DOWN_BUTTON), i < iNumItems - 1);

    if (NULL == GetFocus()) // This prevent keyboard access disable
        SetFocus(hwndList);
}


//
// FillLanguageListBox()
//
// Fills the language listbox with the names of available languages
//
BOOL FillLanguageListBox(IN HWND hDlg)
{
    IMultiLanguage2 *pML2;
    HRESULT hr;
    TCHAR sz[MAX_LIST_STRING_LEN], sz1[MAX_LOCALE_NAME], sz2[MAX_RFC1766_NAME];
    HWND hwndEdit = GetDlgItem(hDlg, IDC_LANG_USER_DEFINED_EDIT);
    HWND hwndList = GetDlgItem(hDlg, IDC_LANG_AVAILABLE_LIST);
    HWND hwndAccept = GetDlgItem(GetParent(hDlg), IDC_LANG_ACCEPT_LIST);
    
    SendMessage(hwndEdit, EM_SETLIMITTEXT, 16, 0L); // Set Limit text as 16 characters

    if(!hOLE32)
    {
        if(!_StartOLE32())
        {
            ASSERT(FALSE);
            return FALSE;
        }
    }
    hr = pCoInitialize(NULL);
    if (FAILED(hr))
        return FALSE;

    hr = pCoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (LPVOID *) &pML2);
    if (SUCCEEDED(hr))
    {
        IEnumRfc1766 *pEnumRfc1766;
        RFC1766INFO Rfc1766Info;

        if (SUCCEEDED(pML2->EnumRfc1766(INETCPL_GetUILanguage(), &pEnumRfc1766)))
        {
            while (S_OK == pEnumRfc1766->Next(1, &Rfc1766Info, NULL))
            {
#ifdef UNICODE
                StrCpyN(sz1, Rfc1766Info.wszLocaleName, ARRAYSIZE(sz1));
                StrCpyN(sz2, Rfc1766Info.wszRfc1766,  ARRAYSIZE(sz2));
#else
                WideCharToMultiByte(CP_ACP, 0, Rfc1766Info.wszLocaleName, -1, sz1, MAX_LOCALE_NAME, NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, Rfc1766Info.wszRfc1766, -1, sz2, MAX_RFC1766_NAME, NULL, NULL);
#endif
                wnsprintf(sz, ARRAYSIZE(sz), FORMAT_STR, sz1, sz2);
                if (LB_ERR == ListBox_FindStringExact(hwndAccept, -1, sz))
                    ListBox_AddString(hwndList, sz);
            }
            pEnumRfc1766->Release();
        }
        pML2->Release();
    }
    pCoUninitialize();
    
    // everything ok
    return TRUE;
}

//
// AddLanguage()
//
// Add selected language to accept language listbox.
//
void AddLanguage(IN HWND hDlg)
{
    int i, j, *pItems, iNumItems, iIndex;
    TCHAR sz[MAX_LIST_STRING_LEN];
    HWND hdlgParent = GetParent(hDlg);
    HWND hwndFrom = GetDlgItem(hDlg, IDC_LANG_AVAILABLE_LIST);
    HWND hwndTo = GetDlgItem(hdlgParent, IDC_LANG_ACCEPT_LIST);

    i = ListBox_GetSelCount(hwndFrom);
    if (0 < i && (pItems = (PINT)LocalAlloc(LPTR, sizeof(int)*i)))
    {
        ListBox_GetSelItems(hwndFrom, i, pItems);
        for (j = 0; j < i; j++)
        {
            ListBox_GetText(hwndFrom, pItems[j], sz);
            ListBox_AddString(hwndTo, sz);
        }
        LocalFree(pItems);
    }
    if (GetWindowTextLength(GetDlgItem(hDlg, IDC_LANG_USER_DEFINED_EDIT)))
    {
        TCHAR *p, sz1[MAX_LIST_STRING_LEN], sz2[MAX_LIST_STRING_LEN];
        BOOL fValid = TRUE;

        GetWindowText(GetDlgItem(hDlg, IDC_LANG_USER_DEFINED_EDIT), sz2, ARRAYSIZE(sz2));
        p = sz2;
        while (NULL != *p && TRUE == fValid)
        {
            switch (*p)
            {
                // Invalid characters for user-defined string
                case TEXT(','):
                case TEXT(';'):
                case TEXT('['):
                case TEXT(']'):
                case TEXT('='):
                    fValid = FALSE;
                    break;

                default:
                    p = CharNext(p);
            }
        }
        if (FALSE == fValid)
        {
            TCHAR szTitle[256], szErr[1024];

            MLLoadShellLangString(IDS_USER_DEFINED_ERR, szErr, ARRAYSIZE(szErr));
            GetWindowText(hDlg, szTitle, ARRAYSIZE(szTitle));
            MessageBox(hDlg, szErr, szTitle, MB_OK | MB_ICONHAND);
        }
        else
        {
            MLLoadString(IDS_USER_DEFINED, sz1, ARRAYSIZE(sz1));
            wnsprintf(sz, ARRAYSIZE(sz), FORMAT_STR, sz1, sz2);
            ListBox_AddString(hwndTo, sz);
        }
    }
    iIndex = ListBox_GetCurSel(hwndTo);
    if (LB_ERR != iIndex)
    {
        iNumItems = ListBox_GetCount(hwndTo);
        EnableWindow(GetDlgItem(hdlgParent, IDC_LANG_REMOVE_BUTTON), iNumItems > 0);
        EnableWindow(GetDlgItem(hdlgParent, IDC_LANG_MOVE_UP_BUTTON), iIndex > 0);
        EnableWindow(GetDlgItem(hdlgParent, IDC_LANG_MOVE_DOWN_BUTTON), iIndex < iNumItems - 1);
    }
}

int ComboBoxEx_AddString(IN HWND hwndCtl, IN LPCTSTR sz)
{
    COMBOBOXEXITEM cbexItem = {0};
    
    int csz = _tcslen(sz);

    cbexItem.mask = CBEIF_TEXT;
    cbexItem.pszText = (LPTSTR)sz;
    cbexItem.cchTextMax = csz;
    
    // sort the string based on the current locale
    // we don't bother to use binary search because
    // the list is up to 25 item
    TCHAR szItem[MAX_LOCALE_NAME];
    int i, itemCount = ComboBox_GetCount(hwndCtl);
    for (i = 0; i < itemCount; i++)
    {
        ComboBox_GetLBText(hwndCtl, i, szItem);
        if (CompareString(INETCPL_GetUILanguage(), 
                          0,
                          sz,
                          csz,
                          szItem,
                          ARRAYSIZE(szItem)) == CSTR_LESS_THAN)
        {
            break;
        }
    }
    cbexItem.iItem = i;
    
    SendMessage(hwndCtl, CBEM_INSERTITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);
    return i;
}

BOOL FillUILangListBox(IN HWND hDlg, CUILangList *pLangList)
{
    HWND hwndCombo = GetDlgItem(hDlg, IDC_COMBO_UILANG);
    BOOL bNT5 = IsOS(OS_WIN2000ORGREATER);
    DWORD dwAcp = GetACP();
    LPCTSTR pszLangName;
    
    if (!pLangList)
        return FALSE;

    // fill the list up.
    for (int i = 0; i < pLangList->GetListSize(); i++)
    {
        if (!pLangList->IsValidLang(i))
            continue;

        if (!bNT5)
        {
            LANGID lid = pLangList->GetLangIdOfIdx(i);

            if (dwAcp == CP_THAI || dwAcp == CP_ARABIC || dwAcp == CP_HEBREW)
            {
                // do not support cross codepage PlugUI
                // on Thai or Middle East platform(Arabic/Hebrew)
                static DWORD dwDefCP = 0;

                if (dwDefCP == 0)
                {
                    TCHAR szLcData[6+1]; // +2 for '0x' +1 for terminator

                    GetLocaleInfo( MAKELCID(lid, SUBLANG_NEUTRAL),
                        LOCALE_IDEFAULTANSICODEPAGE, szLcData, ARRAYSIZE(szLcData));
                                       
                    dwDefCP = StrToInt(szLcData);
                }
                if (dwDefCP != dwAcp && lid != 0x0409 && lid != GetInstallLanguage())
                    continue;
            }
            else
            {
                // skip Arabic and Hebrew on non-supporting platform
                if (lid == 0x401 || lid == 0x40d)
                    continue;
            }
        }

        pszLangName = pLangList->GetLangNameOfIdx(i);

        // ComboBox_FindStringExact has problems to handle DBCS Unicode characters 
        if (pszLangName)
        {
            int ipos = ComboBoxEx_AddString(hwndCombo, pszLangName);
            if (ipos >= 0)
            {
                ComboBox_SetItemData(hwndCombo, ipos, i);
            }
        }
    }

    // show the current selection
    int iLangIdx = pLangList->GetCurrentLangIdx();
    if (iLangIdx >= 0)
    {
        int iCBPos;
        int iCBSize = ComboBox_GetCount(hwndCombo);
        for (iCBPos = 0; iCBPos < iCBSize; iCBPos++)
        {
            if (iLangIdx == ComboBox_GetItemData(hwndCombo, iCBPos))
                break;
        }

        if (iCBPos < iCBSize)
            ComboBox_SetCurSel(hwndCombo, iCBPos);
    }
    return TRUE;
}

//
// Shutdown/reboot procedures implementation
//
// synopsis: CShutDownInfo class implements the method and the process list
//           which handle the sequence.
//           s_arryClsNames[] holds the list of target application
//           ChangeLanguage() (global) triggers the sequence being called from
//           LangChangeDlgProc().
//
static const LPTSTR s_arryClsNames[] =  
{
    TEXT("IEFrame"),                       // browser instance
    TEXT("ThorBrowserWndClass"),           // OE 
    TEXT("HH Parent"),                     // Html Help
    TEXT("MPWClass"),                      // 
    TEXT("Outlook Express Browser Class"), // OE
    TEXT("ATH_Note"),                      // OE?
    TEXT("WABBrowseView"),                 // WAB
    TEXT("Afx:400000:8:10008:0:900d6"),
    TEXT("Media Player 2"),
    TEXT("FrontPageExpressWindow"), 
    TEXT("MSBLUIManager"),                 // Messenger
};

//
// CShutDownInfo
// class methods implementation
//
#define SHUTDOWN_TIMEOUT 2000 // 2 sec
#define RELAUNCH_TIMEOUT 1000 // 1 sec
CShutDownProcInfo::CShutDownProcInfo(HWND hDlg)
{
    _pProcList = NULL;
    _nAlloced = 0;
    _iProcList = 0;
    _hdlgParent = hDlg;
    _fAllShutDown = FALSE;
}

CShutDownProcInfo::~CShutDownProcInfo()
{
    if (_pProcList)
        LocalFree(_pProcList);
}


HRESULT CShutDownProcInfo::EnsureProcList()
{
    HRESULT hr = S_OK;
    if (!_pProcList)
    {
        // alloc mem for practical # of processes
        _nAlloced = ARRAYSIZE(s_arryClsNames);
        _pProcList = (PROCLIST *)LocalAlloc(LPTR, sizeof(PROCLIST)*_nAlloced);
    }
    if (!_pProcList) 
    {
        _nAlloced = 0;
        hr = E_FAIL;
    }

    return hr;
}
HRESULT CShutDownProcInfo::IncreaseProcList()
{
    HRESULT hr = S_OK;
    PROCLIST * pl = NULL;
    // realloc mem every so often
    if (_iProcList+1 > _nAlloced)
    {
        pl = (PROCLIST *)LocalReAlloc(_pProcList, sizeof(PROCLIST)*(ARRAYSIZE(s_arryClsNames)+_nAlloced), 
                                      LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (pl)
        {
            _nAlloced += ARRAYSIZE(s_arryClsNames);
            _pProcList =  pl;
        }
        else
           hr = E_FAIL;
    }

    if (hr == S_OK)
        _iProcList++;

    return hr;
}
// CShutDownProcInfo::AddToProcList()
//
// synopsis: Get process info from given window handle
//           store it for shutdown procedure
//
//
//
HRESULT CShutDownProcInfo::AddToProcList(HWND hwnd)
{
    HRESULT hr = S_OK;

    hr = EnsureProcList();
    if (SUCCEEDED(hr) && hwnd)
    {
        DWORD dwPID;
        BOOL  fFoundDup = FALSE;

        GetWindowThreadProcessId(hwnd, &dwPID);
        
        // check to see if we already have the PID in the list
        for (int i=0; i < _iProcList; i++)
        {
            if (_pProcList[i].dwPID == dwPID)
            {
                fFoundDup = TRUE;
                break;
            }
        }

        // add proccess info only if we don't have it already
        if (!fFoundDup)
        {
            hr = IncreaseProcList();
            if (SUCCEEDED(hr))
            {
                int iCur = _iProcList-1;

                GetExeNameFromPID(dwPID, 
                    _pProcList[iCur].szExeName, 
                    ARRAYSIZE(_pProcList[iCur].szExeName));

                _pProcList[iCur].dwPID = dwPID;
                _pProcList[iCur].State = PS_UNKNOWN;
            }
        }
    }
    return hr;    
}

// CShutDownProcInfo::WaitForOneProcess
//
// synopsis: ensures the given process 
//           has terminated
//
//
HRESULT CShutDownProcInfo::WaitForOneProcess(int iProc)
{
    HRESULT hr = S_OK;
    if (iProc < _iProcList && _pProcList[iProc].State != PS_SHUTDOWN_OK)
    {
        DWORD dwProcessFlags = PROCESS_ALL_ACCESS | 
                               (_fNT ? SYNCHRONIZE : 0 );

        HANDLE hProc = OpenProcess(dwProcessFlags,
                                   FALSE,    
                                   _pProcList[iProc].dwPID);

        // pressume it has terminated, get it marked so
        _pProcList[iProc].State = PS_SHUTDOWN_OK;

        if (hProc) 
        {
            // if the proccess in query is still alive,
            // we'll wait with time out here
            //
            DWORD dwRet = WaitForSingleObject (hProc, SHUTDOWN_TIMEOUT);
            if (dwRet == WAIT_TIMEOUT)
            {
                _pProcList[iProc].State = PS_WAITING;
            }
            
            CloseHandle(hProc);
        }
    }
    return hr;
}

// CShutDownProcInfo::WaitForFolksShutDown
//
// synopsis: ensure the nominated processes terminate. If anyone 
//           doesn't want to terminate, wait for her retrying a couple of
//           times and note her name so we can show it to the user. 
//          
//
#define MAXSHUTDOWNTRY 10
HRESULT CShutDownProcInfo::WaitForFolksShutDown()
{
    HRESULT hr = S_OK;
    int    iTry = 0;
    do
    {
        // pressume all will be fine
        _fAllShutDown = TRUE;
        // waiting loop
        for (int i = 0; i < _iProcList; i++)
        {
            WaitForOneProcess(i);
            if (_pProcList[i].State != PS_SHUTDOWN_OK)
                _fAllShutDown = FALSE;
        }
    }
    while( !_fAllShutDown && iTry++ < MAXSHUTDOWNTRY  );
    // FEATURE: here we should put up a dialog
    //         to ask user if they want to wait
    //         for the apps 

    return hr;
}

// CShutDownProcInfo::NotifyShutDownToFolks
//
// synopsis: send POI_OFFICE_COMMAND to possible candidates on the desktop
//           if a candidate replies with valid value, save the proccess
//           information for the later restart procedure.
//
HRESULT CShutDownProcInfo::NotifyShutDownToFolks(int *pnProcess)
{
    HWND hwndShutDown, hwndAfter;
    PLUGUI_QUERY pq;
    HRESULT hr = S_OK;
    int     nProcToShutDown = 0;

    for (int i = 0; i < ARRAYSIZE(s_arryClsNames); i++)
    {
        hwndAfter = NULL; 
        while (hwndShutDown = FindWindowEx(NULL, hwndAfter, s_arryClsNames[i], NULL))
        {
            pq.uQueryVal = (UINT)SendMessage(hwndShutDown, PUI_OFFICE_COMMAND, PLUGUI_CMD_QUERY, 0);
            if (pq.uQueryVal)
            {
                if(pq.PlugUIInfo.uMajorVersion == OFFICE_VERSION_9)
                {
                    PostMessage(hwndShutDown, PUI_OFFICE_COMMAND, (WPARAM)PLUGUI_CMD_SHUTDOWN, 0);

                    // store the information about the process which this window belongs to
                    // we only need to remember non OLE processes here for re-starting.
                    if (!pq.PlugUIInfo.uOleServer)
                    {
                        AddToProcList(hwndShutDown);
                        nProcToShutDown ++;
                    }
                }
            }
            hwndAfter = hwndShutDown;
        }
    }
    if (!nProcToShutDown)
        hr = S_FALSE;

    if (pnProcess)
        *pnProcess = nProcToShutDown;

    return hr;
}

const TCHAR c_szRegAppPaths[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\");
HRESULT CShutDownProcInfo::GetRestartAppPath(LPTSTR szPath, int cchPath, int iProc)
{
    HRESULT hr = S_OK;
    TCHAR szAppPath[MAX_PATH];
    TCHAR szRegKey[MAX_PATH];

    ASSERT(szPath && cchPath > 0);

    if (iProc < _iProcList)
    {
        _tcscpy(szRegKey, c_szRegAppPaths);
        _tcscat(szRegKey, _pProcList[iProc].szExeName);
        
        DWORD cb = sizeof(szAppPath);
        if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, szRegKey, NULL, NULL, szAppPath, &cb))
        {
            szPath[0] = TEXT('0');
            hr = E_FAIL;
        }
        else
            _tcsncpy(szPath, szAppPath, cchPath);
    }
    return hr;
}

HRESULT CShutDownProcInfo::RestartFolks()
{
    PROCESS_INFORMATION pi;
    for (int i = 0; i < _iProcList; i++)
    {
        STARTUPINFO si = {0};
        si.cb = sizeof(si);
        if (_pProcList[i].State == PS_SHUTDOWN_OK)
        {
            TCHAR szAppPath[MAX_PATH];    
            HRESULT hr = GetRestartAppPath(szAppPath, ARRAYSIZE(szAppPath), i);
            if (hr == S_OK)
            {
                BOOL fLaunchedOK = 
                CreateProcess (szAppPath,               // name of app to launch
                                NULL,                   // lpCmdLine
                                NULL,                   // lpProcessAttributes
                                NULL,                   // lpThreadAttributes
                                TRUE,                   // bInheritHandles
                                NORMAL_PRIORITY_CLASS,  // dwCreationFlags
                                NULL,                   // lpEnvironment
                                NULL,                   // lpCurrentDirectory
                                &si,                    // lpStartupInfo
                                &pi);                   // lpProcessInformation

                if (fLaunchedOK)
                { 
                    DWORD dwRet = WaitForInputIdle (pi.hProcess,
                                                    RELAUNCH_TIMEOUT);
                    CloseHandle(pi.hProcess);
                    CloseHandle(pi.hThread);
                }
            }
        }
    }
    return S_OK;
}



// 
//   CShutDownProcInfo::ShutDownThreadProc
//
//   synopsis: launched from changelang dialog so the dialog
//             wouldn't get blocked when we're waiting for our apps
//             to shutdown/restart. this is a static proc
//             so we should be able to delete the class instance
//             in this proc.
//
DWORD CALLBACK CShutDownProcInfo::ShutDownThreadProc(void *pv)
{
    CShutDownProcInfo *pspi = (CShutDownProcInfo *)pv;
    
    if (pspi)
    {
        HRESULT hr;
        int     nToShutDown;
        // send PUI_OFFICE_COMMAND to corresponding folks...
        hr = pspi->NotifyShutDownToFolks(&nToShutDown);

        // and wait until all processes shutdown
        if (SUCCEEDED(hr) && nToShutDown > 0)
        {
            hr = pspi->WaitForFolksShutDown();

            // then restart here
            if (SUCCEEDED(hr))
               pspi->RestartFolks();
        }
    
        // now the parent dialog should go away
        int iret = (nToShutDown > 0) ? 
                   RETURN_SETLANG_ENDLANGDIALOG: RETURN_SETLANG_CLOSEDNORMAL;
        
        EndDialog(pspi->_hdlgParent, iret);
    
        // delete this class instance
        delete pspi;
    }
    return 0;
}

void OpenSatelliteDownloadUrl(HWND hDlg)
{
    // get the default Url from registry
    TCHAR szSatelliteUrl[INTERNET_MAX_URL_LENGTH];

    // reg api needs size in byte
    DWORD dwType, dwcbData = sizeof(szSatelliteUrl);
    
    DWORD dwRet =  SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_INTERNATIONAL, 
                             NULL, &dwType, (void *)szSatelliteUrl, &dwcbData);
    if (dwRet != ERROR_SUCCESS || !szSatelliteUrl[0])
    {
       // use the hard coded Url instead
       _tcscpy(szSatelliteUrl, s_szUrlSPK);
    }

    if(!hOLE32)
    {
        if(!_StartOLE32())
        {
            ASSERT(FALSE);
            return;
        }
    }

    HRESULT hr = pCoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        NavToUrlUsingIE(szSatelliteUrl, TRUE);
        pCoUninitialize();
    }
}

INT_PTR CALLBACK LangMsgDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDYES:
                case IDNO:
                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                    break;
            }
            return TRUE;
        }

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);        
            break;
    }
    return FALSE;
}

BOOL ChangeLanguage(IN HWND hDlg, CUILangList *pLangList)
{
    HWND hwndCombo = GetDlgItem(hDlg, IDC_COMBO_UILANG);
    int iSel = ComboBox_GetCurSel(hwndCombo);
    INT_PTR idxSel = 0;
    int idxCur;
    
    if (iSel != CB_ERR)
        idxSel = ComboBox_GetItemData(hwndCombo, iSel);

    if ( idxSel != CB_ERR 
        && idxSel < pLangList->GetListSize())
    {
        idxCur = pLangList->GetCurrentLangIdx();

        if (idxCur != idxSel)
        {
            INT_PTR iRet = DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_LANG_WARNING), hDlg, LangMsgDlgProc);

            if (IDCANCEL != iRet)
            {
                pLangList->SetCurrentLangIdx((int)idxSel);

                if (IDYES == iRet)
                {
                    CShutDownProcInfo  *pspi = new CShutDownProcInfo(hDlg);
                    if (!SHCreateThread(pspi->ShutDownThreadProc, (void *)pspi, 0, NULL))
                        delete pspi;

                    // returning TRUE to indicate that we do shutdown/restart
                    return TRUE;
                }
                else
                {
                    DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_LANG_INFO), hDlg, LangMsgDlgProc);
                }
            }
        }
    }
    // returning FALSE to indicate that we haven't changed the language
    return FALSE;
}

//
// LangChangeDlgProc()
//
// Message handler for the "Change Language" subdialog.
//
INT_PTR CALLBACK LangChangeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUILangList *pLangList;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            CUILangList::GetLangList(GetParent(hDlg), &pLangList);
            return FillUILangListBox(hDlg, pLangList);
    
        case WM_DESTROY:
            break;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_LANG_ADDSPK:
                    // open url from resource
                    OpenSatelliteDownloadUrl(hDlg);
                    EndDialog(hDlg, RETURN_SETLANG_ENDLANGDIALOG);
                    break;
                case IDOK:
                    if(!SUCCEEDED(CUILangList::GetLangList(GetParent(hDlg), &pLangList))
                      || !ChangeLanguage(hDlg, pLangList))
                      EndDialog(hDlg, 0);

                    // EndDialog() is called in separate thread 
                    // when shutdown/restart is done
                    // 
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    break;
            }
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);        
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

//
// LangAddDlgProc()
//
// Message handler for the "Add Language" subdialog.
//
INT_PTR CALLBACK LangAddDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return FillLanguageListBox(hDlg);
    
        case WM_DESTROY:
            break;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    AddLanguage(hDlg);
                    EndDialog(hDlg, 0);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    break;
            }
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);        
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

// put any cleanup procedures for language dialog here
void LangDlgCleanup(HWND hDlg)
{
    // also delete and remove the instance of
    // UI language list from window prop
    CUILangList::RemoveLangList(hDlg);
}
//
// LanguageDlgProc()
//
// Message handler for the "Language Preference" subdialog.
//
INT_PTR CALLBACK LanguageDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUILangList *pLangList;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return LanguageDlgInit(hDlg);
    
        case WM_DESTROY:
            LangDlgCleanup(hDlg);
            break;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
                HWND hwndList;
                int iIndex, iNumItems;
                INT_PTR iret;

                case IDOK:
                    SaveLanguageData(hDlg);
                    EndDialog(hDlg, 0);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    break;

                case IDC_LANG_ADD_BUTTON:
                    DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_LANG_ADD), hDlg, LangAddDlgProc);
                    break;

                case IDC_LANG_UI_PREF:
                    CUILangList::GetLangList(hDlg, &pLangList);
                    iret = KickSetLang(hDlg, pLangList);
                    if (iret == RETURN_SETLANG_ENDLANGDIALOG)
                    {
                        // we're outa job
                        EndDialog(hDlg, 0);
                    }
                    else
                    {
                        InitCurrentUILang(hDlg);
                    }
                    break;

                case IDC_LANG_REMOVE_BUTTON:
                    hwndList = GetDlgItem(hDlg, IDC_LANG_ACCEPT_LIST);
                    iIndex = ListBox_GetCurSel(hwndList);
                    ListBox_DeleteString(hwndList, iIndex);
                    iNumItems = ListBox_GetCount(hwndList);
                    if (iNumItems == iIndex)
                        iIndex--;
                    ListBox_SetCurSel(hwndList, iIndex);
                    EnableWindow(GetDlgItem(hDlg, IDC_LANG_REMOVE_BUTTON), (iNumItems > 0) && !g_restrict.fInternational);
                    EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_UP_BUTTON), (iIndex > 0) && !g_restrict.fInternational);
                    EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_DOWN_BUTTON), (iIndex < iNumItems - 1) && !g_restrict.fInternational);

                    if (NULL == GetFocus()) // This prevent keyboard access disable
                        SetFocus(hwndList);
                    break;

                case IDC_LANG_ACCEPT_LIST:
                    hwndList = GetDlgItem(hDlg, IDC_LANG_ACCEPT_LIST);
                    iIndex = ListBox_GetCurSel(hwndList);
                    if (0 <= iIndex)
                    {
                        iNumItems = ListBox_GetCount(hwndList);
                        EnableWindow(GetDlgItem(hDlg, IDC_LANG_REMOVE_BUTTON), (iNumItems > 0) && !g_restrict.fInternational);
                        EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_UP_BUTTON), (iIndex > 0) && !g_restrict.fInternational);
                        EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_DOWN_BUTTON), (iIndex < iNumItems - 1) && !g_restrict.fInternational);
                    }
                    break;

                case IDC_LANG_MOVE_UP_BUTTON:
                    MoveUpDownListItem(hDlg, GetDlgItem(hDlg, IDC_LANG_ACCEPT_LIST), TRUE);
                    break;

                case IDC_LANG_MOVE_DOWN_BUTTON:
                    MoveUpDownListItem(hDlg, GetDlgItem(hDlg, IDC_LANG_ACCEPT_LIST), FALSE);
                    break;
            }
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);        
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


//
// KickLanguageDialog
//
// synopsis : used for launching Language Preference sub dialog.
//            we need to launch the dialogbox as a separate process if inetcpl is 
//            invoked from Tools->Internet options. 
//            The reason: we shutdown every browser instances on desktop
//                        user chooses different UI language than the current,
//                        including the browser that launched inetcpl.
//
static const TCHAR  s_szRunDll32[] = TEXT("RunDll32.exe");
static const TCHAR  s_szKickLangDialog[] = TEXT(" inetcpl.cpl,OpenLanguageDialog");
void KickLanguageDialog(HWND hDlg)
{
    // 1: here we want to check to see if inetcpl was launched 
    //         as a rundll32 process already, which would happen if user 
    //         clicks on it at control panel folder
    //
    //
    BOOL fLaunchedOnBrowser = FALSE;
    
    // this tells me whether we got invoked from Tools->Internet Options...
    if (g_szCurrentURL[0])
    {
        fLaunchedOnBrowser = TRUE;
    }
    
    if (fLaunchedOnBrowser)
    {
        TCHAR szCommandLine[MAX_PATH];
        TCHAR szTitle[MAX_PATH];

        HWND hwndParent = GetParent(hDlg);
        
        StrCpy(szCommandLine, s_szRunDll32);
        StrCat(szCommandLine, s_szKickLangDialog);
        
        if (GetWindowText(hwndParent, szTitle, ARRAYSIZE(szTitle)) > 0)
        {
            StrCat(szCommandLine, TEXT(" "));
            StrCat(szCommandLine, szTitle);
        }
        
#ifdef USE_CREATE_PROCESS
        PROCESS_INFORMATION pi;
        STARTUPINFO si = {0};

        si.cb = sizeof(si);
        BOOL fLaunchedOK = 
        CreateProcess (szCommandLine,          // name of app to launch
                       NULL,                   // lpCmdLine
                       NULL,                   // lpProcessAttributes
                       NULL,                   // lpThreadAttributes
                       TRUE,                   // bInheritHandles
                       NORMAL_PRIORITY_CLASS,  // dwCreationFlags
                       NULL,                   // lpEnvironment
                       NULL,                   // lpCurrentDirectory
                       &si,                    // lpStartupInfo
                       &pi);                   // lpProcessInformation
#else
        char szAnsiPath[MAX_PATH];
        SHUnicodeToAnsi(szCommandLine, szAnsiPath, ARRAYSIZE(szAnsiPath));
        WinExec(szAnsiPath, SW_SHOWNORMAL);
#endif
    }
    else
    {
        DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_LANG), hDlg, LanguageDlgProc, NULL);
    }
}

//
// KickSetLang
//
// synopsis : tries to find setlang.exe of Office9 first, if found it'll be kicked
//            if not, it uses our own setlang dialog.
//
//
static const TCHAR s_szOfficeInstallRoot[] = TEXT("Software\\Microsoft\\Office\\9.0\\Common\\InstallRoot");
static const TCHAR s_szOffice10InstallRoot[] = TEXT("Software\\Microsoft\\Shared");
static const TCHAR s_szPath[] = TEXT("Path");
static const TCHAR s_szOffice10Path[] = TEXT("OfficeSetLangInstallLocation");
static const TCHAR s_szSetLangExe[] = TEXT("setlang.exe");

INT_PTR KickSetLang(HWND hDlg, CUILangList *pLangList)
{
    BOOL fOfficeSetLangInstalled = FALSE;
    INT_PTR iret;
    
    TCHAR szSetLangPath[MAX_PATH];    
    
    //  deleting the key this way makes the key invalid for this process
    //  this way the inetcpl doesnt get bogus cached values
    SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\MUICache"));

    // try to get Office's setlang path
    if(pLangList && pLangList->IsOffice9Installed()) 
    {
        DWORD cb = sizeof(szSetLangPath);
        DWORD dwRet = SHGetValue(HKEY_LOCAL_MACHINE, s_szOffice10InstallRoot, s_szOffice10Path, NULL, szSetLangPath, &cb);

        // fall back to Office9 langpack setting if Office10 langpack setting isn't there
        if (ERROR_SUCCESS != dwRet)
        {
            cb = sizeof(szSetLangPath);            
            dwRet = SHGetValue(HKEY_LOCAL_MACHINE, s_szOfficeInstallRoot, s_szPath, NULL, szSetLangPath, &cb);
        }

        if (ERROR_SUCCESS == dwRet)
        {
            // If last character is a backslash
            if (szSetLangPath[lstrlen(szSetLangPath)-1] == TEXT('\\'))
            {
                // Then concatenate the exe name
                //
                StrCat(szSetLangPath, s_szSetLangExe);
            }
            if (PathFileExists(szSetLangPath) == TRUE)
                fOfficeSetLangInstalled = TRUE;
        }
    }
    
    if (fOfficeSetLangInstalled)
    {
        PROCESS_INFORMATION pi;
        STARTUPINFO si = {0};

        si.cb = sizeof(si);
        BOOL fLaunchedOK = CreateProcess(
                              szSetLangPath,     // name of app to launch
                                       NULL,     // lpCmdLine
                                       NULL,     // lpProcessAttributes
                                       NULL,     // lpThreadAttributes
                                       TRUE,     // bInheritHandles
                      NORMAL_PRIORITY_CLASS,     // dwCreationFlags
                                       NULL,     // lpEnvironment
                                       NULL,     // lpCurrentDirectory
                                       &si,      // lpStartupInfo
                                       &pi);     // lpProcessInformation
        // just wait a while
        if (fLaunchedOK)
        { 
            WaitForInputIdle (pi.hProcess, RELAUNCH_TIMEOUT);
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
        iret = RETURN_SETLANG_ENDLANGDIALOG;
    }
    else
    {
        iret = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_LANG_CHANGE), hDlg, LangChangeDlgProc, NULL);
    }

    return iret;
}

//
// entry point for rundll32
// NOTE: the following function was written intentionally as non-Unicode
//       mainly because we don't have Wide wrapper mechanism for rundll32
//       function on win95
//
extern void GetRestrictFlags(RESTRICT_FLAGS *pRestrict);
void CALLBACK OpenLanguageDialog(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    // hinst is ignored because we set it at our LibMain()
    INITCOMMONCONTROLSEX icex;

    GetRestrictFlags(&g_restrict);
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_USEREX_CLASSES|ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);
    
    if (lpszCmdLine && *lpszCmdLine)
    {
        HWND hwndParent = FindWindowA(NULL, lpszCmdLine);
        if (hwndParent)
            hwnd = hwndParent;
    }
    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_LANG), hwnd, LanguageDlgProc, NULL);
}

// MLGetUILanguage in shlwapi returns current MUI language regardless version.
// MUI architecture doesn't display string correctly when main dll and satellite
// pack versions are mismatched.
// A good example is IE version upgrade without upgrading satellite.
// So here is more clever way to get the MUI language.
//
// 1. Get MLGetUILangauge from shlwapi
// 2. Compare it with current installed language.
// 3. if those are different, try to get resource dll.
// 4. if the resource dll is not in correct path just return current installed
//    language.
// 5. Or return the langid of MLGetUILanguage.
LANGID INETCPL_GetUILanguage()
{
    HINSTANCE hMLInst;
    TCHAR szPath[MAX_PATH], szMUI[16];
    LANGID lidUI = MLGetUILanguage();

    if (IsOS(OS_WIN2000ORGREATER))
        return lidUI;

    if (lidUI != GetInstallLanguage())
    {
        hMLInst = MLGetHinst();
        if (GetModuleFileName(hMLInst, szPath, ARRAYSIZE(szPath)))
        {
            IntToHex(szMUI, 4, lidUI);
            if (StrStrI(szPath, szMUI) == NULL)
                lidUI = GetInstallLanguage();
        }
    }

    return lidUI;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\process.cpp ===
///////////////////////////////////////////////////////////////////////
//                     Microsoft Windows	                         //
//              Copyright(c) Microsoft Corp., 1998                   //
///////////////////////////////////////////////////////////////////////
//
// processs ID related routines 
//

#include "inetcplp.h"

#include <tchar.h>

#include "psapi.h"
#include "tlhelp32.h"
#include "process.h"

CProcessInfo::CProcessInfo()
{
    _fNT = IsOS(OS_NT4ORGREATER);
    // init w95 func pointers
    _lpfnCreateToolhelp32Snapshot = NULL;
    _lpfnProcess32First = NULL;
    _lpfnProcess32Next  = NULL;
    
    // init NT func pointers
    _hPsapiDLL = NULL;
    _lpfnEnumProcesses = NULL;
    _lpfnGetModuleBaseName = NULL;

    // process info array
    _pProcInfoArray  = NULL;
    _nAlloced        = 0;
    _iProcInfoCount  = 0;
}

CProcessInfo::~CProcessInfo()
{
    if(_pProcInfoArray)
        LocalFree(_pProcInfoArray);

    if(_hPsapiDLL)
	    FreeLibrary (_hPsapiDLL);
}

#define ALLOC_STEP 50
HRESULT CProcessInfo::MakeRoomForInfoArray(int n)
{
    HRESULT hr = S_OK;
    if (n > _nAlloced)
    {
        PROCESSINFO *p;
        int nSaved = _nAlloced;

        while(n > _nAlloced)
            _nAlloced += ALLOC_STEP;

        if (!_pProcInfoArray)
        {
            p = (PROCESSINFO *)LocalAlloc(LPTR, sizeof(PROCESSINFO)*_nAlloced);
        }
        else
        {
            p = (PROCESSINFO *)LocalReAlloc(_pProcInfoArray, 
                                            sizeof(PROCESSINFO)*_nAlloced, 
                                            LMEM_MOVEABLE|LMEM_ZEROINIT);
        }

        if (p)
            _pProcInfoArray = p;
        else
        {
            hr        = E_FAIL;
            _nAlloced = nSaved; 
        }
    }
    return hr;
}

HRESULT CProcessInfo::EnsureProcessInfo()
{
    HRESULT hr = S_OK;
    if (!_pProcInfoArray)
    {
        if (_fNT)
        {
            NTCreateProcessList();
        }
        else
        {
            W95CreateProcessList();
        }
    }
    return hr;
}
HRESULT CProcessInfo::GetExeNameFromPID(DWORD dwPID, LPTSTR szFile, int cchFile)
{
    HRESULT hr;

    hr = EnsureProcessInfo();
    if (hr == S_OK)
    {
        for (int i = 0; i < _iProcInfoCount; i++)
        {
            if (_pProcInfoArray[i].dwPID == dwPID)
            {
                _tcsncpy(szFile, _pProcInfoArray[i].szExeName, cchFile);
                break;
            }
        }
    }
    return hr;
}
HRESULT CProcessInfo::NTCreateProcessList()
// Testing routine to see if we can get Process IDs.
{
	HRESULT hr = E_FAIL;

    hr = NTInitPsapi();
    if (hr == S_OK)
    {

        UINT iIndex;

        DWORD aProcesses[100], cbNeeded;

        if (_lpfnEnumProcesses((DWORD * )aProcesses, sizeof(aProcesses), (DWORD *)&cbNeeded))
        {
            // Calculate how many process IDs were returned
            DWORD cProcesses = cbNeeded / sizeof(DWORD);
            
            hr = MakeRoomForInfoArray(cProcesses);
            if (S_OK == hr)
            {
                // Spit out the information for each ID
                for ( iIndex = 0; iIndex < cProcesses; iIndex++ )
                {
                    hr = NTFillProcessList(aProcesses[iIndex], iIndex);
                }

                if (hr == S_OK)
                    _iProcInfoCount = iIndex;
            }
        }
    }
    return hr;
}

HRESULT CProcessInfo::NTInitPsapi()
{
    HRESULT hr;
    // First, load the NT specific library, PSAPI.DLL.
    if (!_hPsapiDLL)
        _hPsapiDLL = LoadLibrary(TEXT("PSAPI.DLL"));

    if (_hPsapiDLL)
    {
        _lpfnEnumProcesses 
        = (LPFNENUMPROCESSES)GetProcAddress(_hPsapiDLL, "EnumProcesses");


        _lpfnGetModuleBaseName 
        = (LPFNGETMODULEBASENAMEW)GetProcAddress(_hPsapiDLL, "GetModuleBaseNameW");
    }

    Assert(_lpfnEnumProcesses && _lpfnGetModuleBaseName);

    hr = (_lpfnEnumProcesses 
        && _lpfnGetModuleBaseName) ? S_OK : E_FAIL;

    return hr;
}

HRESULT CProcessInfo::NTFillProcessList(DWORD dwProcessID, int iIndex)
{
	HRESULT hr = E_FAIL;
    TCHAR szProcessName[MAX_PATH] = TEXT("unknown");
	int i = -1;

    HANDLE hProcess = OpenProcess(  PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwProcessID );
    if ( hProcess )
    {
        DWORD dw = _lpfnGetModuleBaseName( hProcess, NULL, szProcessName, sizeof(szProcessName) );
        if (dw > 0)
                hr = S_OK;
        CloseHandle (hProcess);
    }

    if (hr == S_OK)
    {
        // Add PID and associated .EXE file info to list...
        _pProcInfoArray[iIndex].dwPID = dwProcessID;
        
        _tcsncpy (_pProcInfoArray[iIndex].szExeName, szProcessName, 
                  ARRAYSIZE(_pProcInfoArray[iIndex].szExeName));
    }	
    return hr;
}

HRESULT CProcessInfo::W95CreateProcessList()
{
	HRESULT hr = E_FAIL;

	if (S_OK == W95InitToolhelp32())
	{
		hr = W95FillProcessList();
	}

	return (hr);
}

HRESULT CProcessInfo::W95InitToolhelp32()
// Win95 specific, sets up the things we need to get the process IDs.
{
    HRESULT hr      = E_FAIL;
    HMODULE hKernel = NULL;

    // Obtain a module handle to KERNEL so that we can get the addresses of
    // the 32-bit Toolhelp functions we need.

    hKernel = GetModuleHandle(TEXT("KERNEL32.DLL"));

    if (hKernel)
    {
        _lpfnCreateToolhelp32Snapshot =
          (CREATESNAPSHOT)GetProcAddress(hKernel, "CreateToolhelp32Snapshot");

        _lpfnProcess32First = (PROCESSWALK)GetProcAddress(hKernel, "Process32First");
        _lpfnProcess32Next  = (PROCESSWALK)GetProcAddress(hKernel, "Process32Next");

        // All of our addresses must be non-NULL in order for us to be
        // successful.  If even one of these addresses is NULL, then we
        // must fail because we won't be able to walk one of the lists
        // we need to.
        if (_lpfnProcess32First && _lpfnProcess32Next && _lpfnCreateToolhelp32Snapshot)
            hr = S_OK;
    }

    return (hr);
}
#ifdef UNICODE
#undef PROCESSENTRY32
#endif  // !UNICODE
HRESULT CProcessInfo::W95FillProcessList()
// Fills in the array of process info, and also set the count of the items
{
    HRESULT hr = E_FAIL;
    HANDLE         hProcessSnap = NULL;
    PROCESSENTRY32 pe32         = {0};

    // Take a snapshot of all processes currently in the system.
    hProcessSnap = _lpfnCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap == (HANDLE)-1)
        return hr;

    // Size of the PROCESSENTRY32 structure must be filled out before use.
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // Walk the snapshot of processes and for each process, get information
    // to display.
    if (_lpfnProcess32First(hProcessSnap, &pe32))
    {
        int iIndex = 0;

        do // Add PID and associated .EXE file info to list...
        {
            hr = MakeRoomForInfoArray(iIndex+1);
            if (hr != S_OK)
                break;

            _pProcInfoArray[iIndex].dwPID = pe32.th32ProcessID;
            LPSTR pszFile = PathFindFileNameA(pe32.szExeFile);
            if (pszFile)
            {
                SHAnsiToUnicode( pszFile, _pProcInfoArray[iIndex].szExeName, 
                                 ARRAYSIZE(_pProcInfoArray[iIndex].szExeName)); 
            }
            iIndex++;
        }
        while (_lpfnProcess32Next(hProcessSnap, &pe32));

        _iProcInfoCount = iIndex; // takes care of the last failure
        hr = S_OK;
    }

    CloseHandle (hProcessSnap);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\mainwnd.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************

//
//      OPENCPL.C - The is the heart of starting the "Internet Control Panel".
//  was DIALDLG.C

//      HISTORY:
//
//      4/5/95  jeremys         Created.
//
//      6/22/96 t-gpease        Moved everything that wasn't need (or global) 
//                              to start the control panel into separate, 
//                              managable pieces. This was part of the massive 
//                              (now defuncted) "dialdlg.c" that had just 
//                              about every property sheet written into it. 
//                              This completes the tearing apart of this 
//                              ("dialdlg.c") file. Whew!
//
//
// [arthurbi]
// WARNING - DO NOT ADD "static" variables to Dlg Procs!!!!
//      This code is designed to put up the same dlg in multi
//      threaded environments.  Using globals that maintain
//      state is dangerous.
//
//      State needs to be maintained in the hWin otherwise
//      it will generate bugs.
//

//
// [arthurbi]
// "REMOVED_ID", or DEAD Id: are based on PM decisions to no longer
//      have URLs Underlined.  Left around because PMs may always
//      change their mind.  In the meantime registry is always
//      there for people to change things.
//

#include "inetcplp.h"
#include <inetcpl.h>   // public header for INETCPL
#include "apithk.h"

#include <mluisupp.h>

extern HMODULE hOLE32;
typedef HRESULT (* PCOINIT) (LPVOID);
extern PCOINIT pCoInitialize;
extern BOOL _StartOLE32(); // initializes OLE

#define MAX_NUM_OPTION_PAGES    24

#ifndef UNIX
#define NUM_OPTION_PAGES        6
#else

#ifdef UNIX_FEATURE_ALIAS
#define NUM_OPTION_PAGES        8
#else
#define NUM_OPTION_PAGES        7
#endif /* UNIX_FEATURE_ALIAS */

#endif

RESTRICT_FLAGS g_restrict = {0};

//
// Warning!  LaunchConnectionDialog() below is sensitive to the order of
// this list - it assumes connection tab is 4th in list.  If you change it,
// fix the function.
//
#ifdef UNIX
extern INT_PTR CALLBACK DialupDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
#endif
const struct {
    DWORD dwPageFlag;
    int idRes;
    DLGPROC pfnDlgProc;
    BOOL *pfDisabled;
} c_PropInfo[] = {
    { INET_PAGE_GENERAL,    IDD_GENERAL,       General_DlgProc,     &g_restrict.fGeneralTab     },
    { INET_PAGE_SECURITY,   IDD_SECURITY,      SecurityDlgProc,     &g_restrict.fSecurityTab    },
    { INET_PAGE_PRIVACY,    IDD_PRIVACY,       PrivacyDlgProc,      &g_restrict.fPrivacyTab     },
    { INET_PAGE_CONTENT,    IDD_CONTENT,       ContentDlgProc,      &g_restrict.fContentTab     },
#ifndef UNIX
    { INET_PAGE_CONNECTION, IDD_CONNECTION,    ConnectionDlgProc,   &g_restrict.fConnectionsTab },
#else
    { INET_PAGE_CONNECTION, IDD_CONNECTION,    DialupDlgProc,       &g_restrict.fConnectionsTab },
#endif
    { INET_PAGE_PROGRAMS,   IDD_PROGRAMS,      ProgramsDlgProc,     &g_restrict.fProgramsTab    },
    { INET_PAGE_ADVANCED,   IDD_ADVANCED,      AdvancedDlgProc,     &g_restrict.fAdvancedTab    },
#ifdef UNIX
    { INET_PAGE_ASSOC,      IDD_ASSOCIATIONS,  AssocDlgProc,        NULL                        },
#ifdef UNIX_FEATURE_ALIAS
    { INET_PAGE_ALIAS,      IDD_ALIASDLG,      AliasDlgProc,        NULL                        },
#endif /* UNIX_FEATURE_ALIAS */
#endif
};

#define IsPropPageEnabled(iPage)  (c_PropInfo[iPage].pfDisabled==NULL || *c_PropInfo[iPage].pfDisabled==FALSE)

#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif

#define ARRAYSIZE(arr) (sizeof(arr)/sizeof(arr[0]))


TCHAR g_szCurrentURL[INTERNET_MAX_URL_LENGTH] = {0};


WNDPROC pfnStaticWndProc = NULL;
HWND g_hwndUpdate = NULL;
BOOL g_fChangedMime = FALSE;     // needed to indicate to MSHTML to
// refresh the current page with a 
// new MIME and/or code page.
BOOL g_fSecurityChanged = FALSE;    // needed to indicate if a Active Security
// has changed.

HWND g_hwndPropSheet = NULL;
PFNPROPSHEETCALLBACK g_PropSheetCallback2 = NULL;

int CALLBACK PropSheetCallback(
    HWND hwndDlg,
    UINT uMsg,
    LPARAM lParam
)
{
    if (uMsg==PSCB_INITIALIZED)
    {
        ASSERT(hwndDlg);
        g_hwndPropSheet = hwndDlg;
    }
#ifdef REPLACE_PROPSHEET_TEMPLATE
    return g_PropSheetCallback2 ? g_PropSheetCallback2(hwndDlg, uMsg, lParam)
                                 : PropSheetProc(hwndDlg, uMsg, lParam);
#else
    return g_PropSheetCallback2 ? g_PropSheetCallback2(hwndDlg, uMsg, lParam)
                                 : 0;
#endif
}


// begin ui restrictions stuff 
// key below used to be \software\microsoft\intenet explorer\restrictui
//
const TCHAR c_szKeyRestrict[]       = REGSTR_PATH_INETCPL_RESTRICTIONS;

const TCHAR c_szGeneralTab[]        = REGSTR_VAL_INETCPL_GENERALTAB;
const TCHAR c_szSecurityTab[]       = REGSTR_VAL_INETCPL_SECURITYTAB;
const TCHAR c_szContentTab[]        = REGSTR_VAL_INETCPL_CONTENTTAB;
const TCHAR c_szConnectionsTab[]    = REGSTR_VAL_INETCPL_CONNECTIONSTAB;
const TCHAR c_szProgramsTab[]       = REGSTR_VAL_INETCPL_PROGRAMSTAB;
const TCHAR c_szAdvancedTab[]       = REGSTR_VAL_INETCPL_ADVANCEDTAB;
const TCHAR c_szPrivacyTab[]        = REGSTR_VAL_INETCPL_PRIVACYTAB;
const TCHAR c_szColors[]            = TEXT("Colors");        
const TCHAR c_szLinks[]             = TEXT("Links");         
const TCHAR c_szFonts[]             = TEXT("Fonts");         
const TCHAR c_szInternational[]     = TEXT("Languages");                   // used to be International
const TCHAR c_szDialing[]           = TEXT("Connection Settings");         // used to be Dialing
const TCHAR c_szProxy[]             = TEXT("Proxy");         
const TCHAR c_szPlaces[]            = TEXT("HomePage");                    // used to be Places
const TCHAR c_szHistory[]           = TEXT("History");       
const TCHAR c_szMailNews[]          = TEXT("Messaging");                   // used to be MailNews
const TCHAR c_szResetWebSettings[]  = TEXT("ResetWebSettings");
const TCHAR c_szDefault[]           = TEXT("Check_If_Default");            // used to be Default
const TCHAR c_szRatings[]           = TEXT("Ratings");       
const TCHAR c_szCertif[]            = TEXT("Certificates");                // used to be Certif
const TCHAR c_szCertifPers[]        = TEXT("CertifPers");    
const TCHAR c_szCertifSite[]        = TEXT("CertifSite");    
const TCHAR c_szCertifPub[]         = TEXT("CertifPub");     
const TCHAR c_szCache[]             = TEXT("Cache");         
const TCHAR c_szAutoConfig[]        = TEXT("AutoConfig");
const TCHAR c_szAccessibility[]     = TEXT("Accessibility");
const TCHAR c_szSecChangeSettings[] = TEXT("SecChangeSettings");
const TCHAR c_szSecAddSites[]       = TEXT("SecAddSites");
const TCHAR c_szProfiles[]          = TEXT("Profiles");
const TCHAR c_szFormSuggest[]       = TEXT("FormSuggest");
const TCHAR c_szFormPasswords[]     = TEXT("FormSuggest Passwords");
#ifdef WALLET
const TCHAR c_szWallet[]            = TEXT("Wallet");
#endif
const TCHAR c_szConnectionWizard[]  = TEXT("Connwiz Admin Lock");
const TCHAR c_szCalContact[]        = TEXT("CalendarContact");             // used to be CalContact
const TCHAR c_szAdvanced[]          = TEXT("Advanced");
const TCHAR c_szSettings[]          = TEXT("Settings");
const TCHAR c_szPrivacySettings[]   = TEXT("Privacy Settings");

#if 0       // obsolete keys
const TCHAR c_szMultimedia[]     = TEXT("Multimedia");
const TCHAR c_szToolbar[]        = TEXT("Toolbar");       
const TCHAR c_szActiveX[]        = TEXT("ActiveX");       
const TCHAR c_szActiveDownload[] = TEXT("ActiveDownload");
const TCHAR c_szActiveControls[] = TEXT("ActiveControls");
const TCHAR c_szActiveScript[]   = TEXT("ActiveScript");  
const TCHAR c_szActiveJava[]     = TEXT("ActiveJava");    
const TCHAR c_szActiveSafety[]   = TEXT("ActiveSafety");  
const TCHAR c_szWarnings[]       = TEXT("Warnings");      
const TCHAR c_szOther[]          = TEXT("Other");         
const TCHAR c_szCrypto[]         = TEXT("Crypto");        
const TCHAR c_szFileTypes[]      = TEXT("FileTypes");     
#endif

// end ui restrictions stuff 

#ifdef REPLACE_PROPSHEET_TEMPLATE
// Used for modifying propsheet template
const TCHAR c_szComctl[] = TEXT("comctl32.dll");
#define DLG_PROPSHEET 1006 // Bad hack...assumes comctl's res id

typedef struct 
{
    int inumLang;
    WORD wLang;
} ENUMLANGDATA;

//
// EnumResLangProc
//
// purpose: a callback function for EnumResourceLanguages().
//          look into the type passed in and if it is RT_DIALOG
//          copy the lang of the first resource to our buffer 
//          this also counts # of lang if more than one of them 
//          are passed in
//
// IN:      lparam: ENUMLANGDATA - defined at the top of this file
//
BOOL CALLBACK EnumResLangProc(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName, WORD wIdLang, LPARAM lparam)
{
    ENUMLANGDATA *pel = (ENUMLANGDATA *)lparam;

    ASSERT(pel);

    if (lpszType == RT_DIALOG)
    {
        if (pel->inumLang == 0)
            pel->wLang = wIdLang;

        pel->inumLang++;
    }
    return TRUE;   // continue until we get all langs...
}

//
// GetDialogLang
//
// purpose: fill out the ENUMLANGDATA (see top of this file) with the
//          # of available langs in the module passed in, and the langid
//          of what system enumerates first. i.e, the langid eq. to what
//          the module localized if the module is localized in single 
//          language
//
// IN:      hinstCpl - this is supposed to be a instance handle of inetcpl.
//          pel - a pointer to the buffer we fill out
//
// RESULT:  TRUE  - everything cool, continue with adjusting property sheet
//          FALSE - somethings wrong, abort adjusting property sheet.
//
BOOL GetDialogLang(HMODULE hinstCpl, ENUMLANGDATA *pel)
{
    ASSERT(pel);
    OSVERSIONINFOA osvi;

    // Determine which version of NT or Windows we're running on
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA(&osvi);

    // Get the possible languages the template localized in.
    if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
        EnumResourceLanguages(hinstCpl, RT_DIALOG, MAKEINTRESOURCE(IDD_GENERAL), EnumResLangProc, (LPARAM)pel);
    else    
        EnumResourceLanguagesA(hinstCpl, (LPSTR)RT_DIALOG, MAKEINTRESOURCEA(IDD_GENERAL), (ENUMRESLANGPROCA)EnumResLangProc, (LPARAM)pel);

    return TRUE;
}
//
// PropSheetProc
//
// purpose: the callback function to modify resource template
//          in order to make DLG_PROPSHEET's lang mathed with ours.
//          there could be a general way but for now this is
//          an ugly hack from inetcpl.
//
//
int CALLBACK PropSheetProc (HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    LPVOID pTemplate = (LPVOID)lParam;
    LPVOID pTmpInLang = NULL;
    ENUMLANGDATA el = {0,0};
    HINSTANCE hComctl;
    HRSRC hrsrc;
    HGLOBAL hgmem;
    DWORD cbNewTmp;

    // Comm ctrl gives us a chance to recreate resource by this msg.
    if (uMsg==PSCB_PRECREATE && pTemplate)
    {
        // enumrate any possible language used in this cpl for dialogs
        if (!GetDialogLang(ghInstance, &el))
            return 0; // failed to get resouce name

        if (el.inumLang > 1)
        {
            // we've got multi-language templates
            // let comctl load the one that matches our thread langid.
            return 0;
        }
        if (GetSystemDefaultLangID() != el.wLang)
        {
            // Get comctl32's module handle
            hComctl = GetModuleHandle(c_szComctl);
            if (hComctl)
            {
                // this is a horrible hack because we assume DLG_PROPSHEET
                hrsrc = FindResourceExA(hComctl, (LPSTR)RT_DIALOG, MAKEINTRESOURCEA(DLG_PROPSHEET), el.wLang);
                if (hrsrc)
                {
                    if (hgmem = LoadResource(hComctl, hrsrc))
                    {
                        pTmpInLang = LockResource(hgmem);
                    } 
                    if (pTmpInLang)
                    {
                        cbNewTmp = SizeofResource(hComctl, hrsrc);
                        hmemcpy(pTemplate, pTmpInLang, cbNewTmp);
                    }    
                    if (hgmem && pTmpInLang)
                    {
                        UnlockResource(hgmem);
                        return 1; // everything went ok.
                    }
                }
            }
        }
    }
    return 0;
}
#endif // REPLACE_PROPSHEET_TEMPLATE

void ResWinHelp( HWND hwnd, int ids, int id2, DWORD_PTR dwp)
{
    TCHAR szSmallBuf[SMALL_BUF_LEN+1];
    SHWinHelpOnDemandWrap((HWND)hwnd, LoadSz(ids,szSmallBuf,sizeof(szSmallBuf)),
            id2, (DWORD_PTR)dwp);
}

/*******************************************************************

NAME:       _AddPropSheetPage

SYNOPSIS:   Adds a property sheet page to a property sheet
header's array of property sheet pages.

********************************************************************/
BOOL CALLBACK _AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    BOOL bResult;
    LPPROPSHEETHEADER ppsh = (LPPROPSHEETHEADER)lParam;

    bResult = (ppsh->nPages < MAX_NUM_OPTION_PAGES);

    if (bResult)
        ppsh->phpage[ppsh->nPages++] = hpage;

    return(bResult);
}

// hunts down all windows and notifies them that they should update themselves
// a-msadek; Use SendMessage instead of PostMessage to work around a syncronization problem causing the system to
// hang when changing security settings
void UpdateAllWindows()
{
    SendMessage(g_hwndUpdate, INM_UPDATE, 0, 0);
    // PostMessage(g_hwndUpdate, INM_UPDATE, 0, 0);
}



// walk the window list and post a message to it telling the windows to
// update (borrowed from MSHTML and slightly modified)
void WINAPI MSHTMLNotifyAllRefresh()
{
    TCHAR szClassName[32];
    TCHAR *Hidden_achClassName;
    HWND hwnd = GetTopWindow(GetDesktopWindow());

    //
    // FEATURE: These should be gotten from some place that is public
    //         to both MSHTML and INETCPL.
    //
    Hidden_achClassName = TEXT("Internet Explorer_Hidden");
#define WM_DO_UPDATEALL     WM_USER + 338

    while (hwnd) {
        GetClassName(hwnd, szClassName, ARRAYSIZE(szClassName));

        // is this our hidden window?
        if (!StrCmpI(szClassName, Hidden_achClassName))
        {
            // yes...  post it a message..
            PostMessage(hwnd, WM_DO_UPDATEALL, 0, g_fSecurityChanged );
        }

        hwnd = GetNextWindow(hwnd, GW_HWNDNEXT);
    }

    //
    // Notify top level windows that registry changed.
    // Defview monitors this message to update the listview
    // font underline settings on the fly.
    //
    SendBroadcastMessage(WM_WININICHANGE, SPI_GETICONTITLELOGFONT, (LPARAM)REGSTR_PATH_IEXPLORER);

    g_fSecurityChanged = FALSE;
}

// this window's sole purpose is to collect all the posted messages
// saying that we should update everything and collapse it down so that
// we only do it once
LRESULT WINAPI UpdateWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MSG msg;

    switch(uMsg) {
        case WM_DESTROY:
            g_hwndUpdate = NULL;
            // update everything as needed.. remove all messages
            if (PeekMessage(&msg, hwnd, 0, 0, PM_REMOVE)) {
                MSHTMLNotifyAllRefresh();
                SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)pfnStaticWndProc);
            }
            // since EXPLORER.EXE can hang on to us for a long while
            // we should bail as many of these as we possibly can.
            if (g_hinstWinInet)
            {
                FreeLibrary(g_hinstWinInet);
                g_hinstWinInet = NULL;
            }

            if (g_hinstRatings)
            {
                FreeLibrary(g_hinstRatings);
                g_hinstRatings = NULL;
            }

            if (g_hinstUrlMon)
            {
                FreeLibrary(g_hinstUrlMon);
                g_hinstUrlMon = NULL;
            }

            if (g_hinstMSHTML)
            {
                FreeLibrary(g_hinstMSHTML);
                g_hinstMSHTML = NULL;
            }
            if (hOLE32)
            {
                FreeLibrary(hOLE32);
                hOLE32 = NULL;
            }
            if (g_hinstShdocvw)
            {
                FreeLibrary(g_hinstShdocvw);
                g_hinstShdocvw = NULL;
            }
            if (g_hinstCrypt32)
            {
                FreeLibrary(g_hinstCrypt32);
                g_hinstCrypt32 = NULL;
            }
                        
                        
            break;

        case INM_UPDATE:
            // remove any other posted messages of this type
            while( PeekMessage(&msg, hwnd, INM_UPDATE, INM_UPDATE, PM_REMOVE))
            {
            }
            MSHTMLNotifyAllRefresh();
            break;

        default:
            return CallWindowProc(pfnStaticWndProc, hwnd, uMsg, wParam, lParam);
    }
    return 0L;
}

// this creates our private message window that we use to collapse notifies
// of updates
void CreatePrivateWindow(HWND hDlg)
{
    // Don't allow creation of more than one Private Window per Instance
    if(g_hwndUpdate) { 
        return;
    }

    g_hwndUpdate = CreateWindow(TEXT("static"), NULL, WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                NULL, NULL, ghInstance, NULL);
    if (g_hwndUpdate) {
        // subclass it
        pfnStaticWndProc = (WNDPROC) GetWindowLongPtr(g_hwndUpdate, GWLP_WNDPROC);
        SetWindowLongPtr(g_hwndUpdate, GWLP_WNDPROC, (LONG_PTR)UpdateWndProc);
    }
}


BOOL IsRestricted( HKEY hkey, const TCHAR * pszValue )
{
    LONG  lResult;
    DWORD lSize;
    DWORD  lValue;

    lValue = 0; // clear it
    lSize = sizeof(lValue);
    lResult = RegQueryValueEx( hkey, pszValue, NULL, NULL, (LPBYTE)&lValue, &lSize );
    if( ERROR_SUCCESS != lResult )
        return FALSE;

    return (0 != lValue);
}
void GetRestrictFlags( RESTRICT_FLAGS *pRestrict )
{
    LONG lResult;
    HKEY hkey;

    // key is wrong!
    lResult = RegOpenKeyEx( HKEY_CURRENT_USER, c_szKeyRestrict, (DWORD)0, KEY_READ, &hkey );
    if( ERROR_SUCCESS != lResult )
        return;

#if 0
    pRestrict->fMultimedia    = IsRestricted( hkey, c_szMultimedia     );
    pRestrict->fToolbar       = IsRestricted( hkey, c_szToolbar        );
    pRestrict->fFileTypes     = IsRestricted( hkey, c_szFileTypes      );
    pRestrict->fActiveX       = IsRestricted( hkey, c_szActiveX        );
    pRestrict->fActiveDownload= IsRestricted( hkey, c_szActiveDownload );
    pRestrict->fActiveControls= IsRestricted( hkey, c_szActiveControls );
    pRestrict->fActiveScript  = IsRestricted( hkey, c_szActiveScript   );
    pRestrict->fActiveJava    = IsRestricted( hkey, c_szActiveJava     );
    pRestrict->fActiveSafety  = IsRestricted( hkey, c_szActiveSafety   );
    pRestrict->fWarnings      = IsRestricted( hkey, c_szWarnings       );
    pRestrict->fOther         = IsRestricted( hkey, c_szOther          );
    pRestrict->fCrypto        = IsRestricted( hkey, c_szCrypto         );
#endif
    
    pRestrict->fGeneralTab    = IsRestricted( hkey, c_szGeneralTab     );
    pRestrict->fSecurityTab   = IsRestricted( hkey, c_szSecurityTab    );
    pRestrict->fContentTab    = IsRestricted( hkey, c_szContentTab     );
    pRestrict->fConnectionsTab= IsRestricted( hkey, c_szConnectionsTab );
    pRestrict->fProgramsTab   = IsRestricted( hkey, c_szProgramsTab    );
    pRestrict->fAdvancedTab   = IsRestricted( hkey, c_szAdvancedTab    );
    pRestrict->fPrivacyTab    = IsRestricted( hkey, c_szPrivacyTab     );
    pRestrict->fColors        = IsRestricted( hkey, c_szColors         );
    pRestrict->fLinks         = IsRestricted( hkey, c_szLinks          );
    pRestrict->fFonts         = IsRestricted( hkey, c_szFonts          );
    pRestrict->fInternational = IsRestricted( hkey, c_szInternational  );
    pRestrict->fDialing       = IsRestricted( hkey, c_szDialing        );
    pRestrict->fProxy         = IsRestricted( hkey, c_szProxy          );
    pRestrict->fPlaces        = IsRestricted( hkey, c_szPlaces         );
    pRestrict->fHistory       = IsRestricted( hkey, c_szHistory        );
    pRestrict->fMailNews      = IsRestricted( hkey, c_szMailNews       );
    pRestrict->fRatings       = IsRestricted( hkey, c_szRatings        );
    pRestrict->fCertif        = IsRestricted( hkey, c_szCertif         );
    pRestrict->fCertifPers    = IsRestricted( hkey, c_szCertifPers     );
    pRestrict->fCertifSite    = IsRestricted( hkey, c_szCertifSite     );
    pRestrict->fCertifPub     = IsRestricted( hkey, c_szCertifPub      );
    pRestrict->fCache         = IsRestricted( hkey, c_szCache          );
    pRestrict->fAutoConfig    = IsRestricted( hkey, c_szAutoConfig     );
    pRestrict->fAccessibility = IsRestricted( hkey, c_szAccessibility  );
    pRestrict->fSecChangeSettings = IsRestricted( hkey, c_szSecChangeSettings );
    pRestrict->fSecAddSites   = IsRestricted( hkey, c_szSecAddSites    );
    pRestrict->fProfiles      = IsRestricted( hkey, c_szProfiles       );
    pRestrict->fFormSuggest   = IsRestricted( hkey, c_szFormSuggest    );
    pRestrict->fFormPasswords = IsRestricted( hkey, c_szFormPasswords  );
#ifdef WALLET
    pRestrict->fWallet        = IsRestricted( hkey, c_szWallet         );
#endif
    pRestrict->fConnectionWizard = IsRestricted( hkey, c_szConnectionWizard );
    pRestrict->fCalContact    = IsRestricted( hkey, c_szCalContact     );
    pRestrict->fAdvanced      = IsRestricted( hkey, c_szAdvanced       );
    pRestrict->fCacheReadOnly = IsRestricted( hkey, c_szSettings       );
    pRestrict->fResetWebSettings = IsRestricted( hkey, c_szResetWebSettings );
    pRestrict->fDefault       = IsRestricted( hkey, c_szDefault        );
    pRestrict->fPrivacySettings = IsRestricted( hkey, c_szPrivacySettings );
    
    RegCloseKey( hkey );
}

// this sets up any globals that need to be init'ed before the prop sheets come up
void PreInitPropSheets(HWND hDlg)
{
    INITCOMMONCONTROLSEX icex;

    //
    // initialize the ieak restrictions data
    //
    GetRestrictFlags(&g_restrict);

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_USEREX_CLASSES|ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);
    CreatePrivateWindow(hDlg);
}


/*******************************************************************

NAME:       AddInternetPropertySheetsEx

SYNOPSIS:   Adds the Internet property sheets through a provided
callback function.  Allows caller to specify common
parent reference count pointer and common callback
function for those property sheets.

********************************************************************/
STDAPI AddInternetPropertySheetsEx(LPFNADDPROPSHEETPAGE pfnAddPage,
                                   LPARAM lparam, PUINT pucRefCount,
                                   LPFNPSPCALLBACK pfnCallback,
                                   LPIEPROPPAGEINFO piepi)
{
    HRESULT hr = S_OK;
    PROPSHEETPAGE* ppsPage;
    int nPageIndex;
    LPPROPSHEETHEADER ppsh = (LPPROPSHEETHEADER)lparam;

    PreInitPropSheets(NULL);

    // if REPLACE_PROPSHEET_TEMPLATE is defined, then this
    // callback will call another proc
    // this is to modify a resource template so we can use 
    // the resource in matched language for property sheet
    g_PropSheetCallback2 = NULL;
    if (ppsh)
    {
        if (!(ppsh->dwFlags & PSH_USECALLBACK))
        {
            ppsh->dwFlags |= PSH_USECALLBACK;
        }
        else
        {
            g_PropSheetCallback2 = ppsh->pfnCallback;
        }
        ppsh->pfnCallback = PropSheetCallback;
    }

    if (piepi->pszCurrentURL)
    {
#ifdef UNICODE
        SHAnsiToUnicode(piepi->pszCurrentURL, g_szCurrentURL, ARRAYSIZE(g_szCurrentURL));
#else
        StrCpyN(g_szCurrentURL, piepi->pszCurrentURL, ARRAYSIZE(g_szCurrentURL));
#endif
    }
    else
        g_szCurrentURL[0] = 0;

    // fill out common data property sheet page struct

    hr = E_OUTOFMEMORY;
    ppsPage = Whistler_CreatePropSheetPageStruct(MLGetHinst()); // Get the right version
    if (ppsPage)
    {
        if (pucRefCount)
        {
            ppsPage->pcRefParent = pucRefCount;
            ppsPage->dwFlags |= PSP_USEREFPARENT;
        }
        if (pfnCallback)
        {
            ppsPage->pfnCallback = pfnCallback;
            ppsPage->dwFlags |= PSP_USECALLBACK;
        }

        // if old IE30 users specify the old security page, then we'll show the new security page and the content page
        if (piepi->dwFlags & INET_PAGE_SECURITY_OLD)
            piepi->dwFlags |= INET_PAGE_SECURITY | INET_PAGE_CONTENT;

        // create a property sheet page for each page
        for (nPageIndex = 0; nPageIndex < ARRAYSIZE(c_PropInfo); nPageIndex++)
        {
            if (c_PropInfo[nPageIndex].dwPageFlag & piepi->dwFlags &&
                IsPropPageEnabled(nPageIndex))
            {
                HPROPSHEETPAGE hpage;

                ppsPage->pfnDlgProc  = c_PropInfo[nPageIndex].pfnDlgProc;
                ppsPage->pszTemplate = MAKEINTRESOURCE(c_PropInfo[nPageIndex].idRes);

                // set a pointer to the PAGEINFO struct as the private data for this page
                ppsPage->lParam = (LPARAM)nPageIndex;

                hpage = CreatePropertySheetPage((LPCPROPSHEETPAGE)ppsPage);

                if (hpage)
                {
                    if (pfnAddPage(hpage, lparam))
                        hr = S_OK;
                    else
                    {
                        DestroyPropertySheetPage(hpage);
                        hr = E_FAIL;
                    }
                }
                else
                    hr = E_OUTOFMEMORY;

                if (hr != S_OK)
                    break;
            }
        }

        LocalFree(ppsPage);
    }

    // this must be done after the pre-init prop sheet which has first
    // crack at initializing g_restrict
    if (piepi->cbSize == sizeof(IEPROPPAGEINFO))
    {
        //
        // blast in the new settings
        //
        if (piepi->dwRestrictMask & (R_MULTIMEDIA | R_WARNINGS | R_CRYPTOGRAPHY | R_ADVANCED))
            g_restrict.fAdvanced = (piepi->dwRestrictFlags & (R_MULTIMEDIA | R_WARNINGS | R_CRYPTOGRAPHY | R_ADVANCED));

        if (piepi->dwRestrictMask & R_DIALING)
            g_restrict.fDialing    = (piepi->dwRestrictFlags & R_DIALING);

        if (piepi->dwRestrictMask & R_PROXYSERVER)        
            g_restrict.fProxy      = (piepi->dwRestrictFlags & R_PROXYSERVER);

        if (piepi->dwRestrictMask & R_CUSTOMIZE)       
            g_restrict.fPlaces     = (piepi->dwRestrictFlags & R_CUSTOMIZE);

        if (piepi->dwRestrictMask & R_HISTORY)
            g_restrict.fHistory    = (piepi->dwRestrictFlags & R_HISTORY);

        if (piepi->dwRestrictMask & R_MAILANDNEWS)
            g_restrict.fMailNews   = (piepi->dwRestrictFlags & R_MAILANDNEWS);

        if (piepi->dwRestrictMask & R_CHECKBROWSER )
            g_restrict.fDefault = (piepi->dwRestrictFlags & R_CHECKBROWSER);

        if (piepi->dwRestrictMask & R_COLORS)
            g_restrict.fColors  = (piepi->dwRestrictFlags & R_COLORS);

        if (piepi->dwRestrictMask & R_LINKS)
            g_restrict.fLinks    = (piepi->dwRestrictFlags & R_LINKS);

        if (piepi->dwRestrictMask & R_FONTS)        
            g_restrict.fFonts      = (piepi->dwRestrictFlags & R_FONTS);

        if (piepi->dwRestrictMask & R_RATINGS)       
            g_restrict.fRatings     = (piepi->dwRestrictFlags & R_RATINGS);

        if (piepi->dwRestrictMask & R_CERTIFICATES) {
            g_restrict.fCertif    = (piepi->dwRestrictFlags & R_CERTIFICATES);
            g_restrict.fCertifPers = g_restrict.fCertif;
            g_restrict.fCertifSite = g_restrict.fCertif;
            g_restrict.fCertifPub  = g_restrict.fCertif;
        }
        
        if (piepi->dwRestrictMask & (R_ACTIVECONTENT | R_SECURITY_CHANGE_SETTINGS))
            g_restrict.fSecChangeSettings   = (piepi->dwRestrictFlags & (R_ACTIVECONTENT | R_SECURITY_CHANGE_SETTINGS ));

        if (piepi->dwRestrictMask & (R_ACTIVECONTENT | R_SECURITY_CHANGE_SITES))
            g_restrict.fSecAddSites = (piepi->dwRestrictFlags & (R_ACTIVECONTENT | R_SECURITY_CHANGE_SITES));

        if (piepi->dwRestrictMask & R_CACHE)
            g_restrict.fCache  = (piepi->dwRestrictFlags & R_CACHE);

        if (piepi->dwRestrictMask & R_LANGUAGES )
            g_restrict.fInternational  = (piepi->dwRestrictFlags & R_LANGUAGES );
        
        if (piepi->dwRestrictMask & R_ACCESSIBILITY )
            g_restrict.fAccessibility = (piepi->dwRestrictFlags & R_ACCESSIBILITY);
        
        if (piepi->dwRestrictMask & R_PROFILES)
        {
            g_restrict.fFormSuggest=    // piggyback on "profile assistant" restriction
            g_restrict.fProfiles   = (piepi->dwRestrictFlags & R_PROFILES);
        }
        
#ifdef WALLET
        if (piepi->dwRestrictMask & R_WALLET)
            g_restrict.fWallet  = (piepi->dwRestrictFlags & R_WALLET);
#endif
        
        if (piepi->dwRestrictMask & R_CONNECTION_WIZARD)
            g_restrict.fConnectionWizard  = (piepi->dwRestrictFlags & R_CONNECTION_WIZARD);
        
        if (piepi->dwRestrictMask & R_AUTOCONFIG)
            g_restrict.fAutoConfig  = (piepi->dwRestrictFlags & R_AUTOCONFIG);
        
        if (piepi->dwRestrictMask & R_CAL_CONTACT)
            g_restrict.fCalContact  = (piepi->dwRestrictFlags & R_CAL_CONTACT);
        
        if (piepi->dwRestrictMask & R_ADVANCED)
            g_restrict.fAdvanced  = (piepi->dwRestrictFlags & R_ADVANCED);

        }

    return(hr);
}

STDAPI AddInternetPropertySheets(LPFNADDPROPSHEETPAGE pfnAddPage,
                                 LPARAM lparam, PUINT pucRefCount,
                                 LPFNPSPCALLBACK pfnCallback)
{
    IEPROPPAGEINFO iepi;

    iepi.cbSize = sizeof(iepi);
    iepi.pszCurrentURL = NULL;

    // if not loaded, try to load
    if (!g_hinstMSHTML)
        g_hinstMSHTML = LoadLibrary(c_tszMSHTMLDLL);

    // if MSHTML found, then do the standard INETCPL
    if (g_hinstMSHTML)
    {
        iepi.dwFlags = (DWORD)-1;
        iepi.dwRestrictFlags = (DWORD)0;
        iepi.dwRestrictMask  = (DWORD)0;
    }
    else
    {
        // adjust these flags for the "special" inetcpl for the office guys.
        iepi.dwFlags = (DWORD) 
                       INET_PAGE_CONNECTION | INET_PAGE_PROGRAMS
                       | INET_PAGE_SECURITY | INET_PAGE_ADVANCED;
        iepi.dwRestrictFlags = (DWORD)
                               R_HISTORY | R_OTHER | R_CHECKBROWSER;
        iepi.dwRestrictMask  = (DWORD)
                               R_HISTORY | R_OTHER | R_CHECKBROWSER;
    }

    return AddInternetPropertySheetsEx(pfnAddPage, lparam, pucRefCount, pfnCallback, &iepi);
}

void DestroyPropertySheets(LPPROPSHEETHEADER ppsHeader)
{
    UINT nFreeIndex;

    for (nFreeIndex = 0; nFreeIndex < ppsHeader->nPages; nFreeIndex++)
        DestroyPropertySheetPage(ppsHeader->phpage[nFreeIndex]);

}




/*******************************************************************

NAME:       LaunchInternetControlPanel

SYNOPSIS:   Runs the Internet control panel.


WARNING:  This needs to be as bare bones as possible.
the pages are also added in from the internet (iShellFolder)
property page extension which means it doesn't come into this
code.  if you do any initialization/destruction here,
it won't get called on all cases.

********************************************************************/
STDAPI_(BOOL) LaunchInternetControlPanelAtPage(HWND hDlg, UINT nStartPage)
{
    HPROPSHEETPAGE hOptPage[ MAX_NUM_OPTION_PAGES ];  // array to hold handles to pages
    PROPSHEETHEADER     psHeader;
    BOOL fRet;
    HPSXA hpsxa;
    HRESULT hrOle = SHCoInitialize();
    // OLE Needs to be initialized for AutoComplete and the FTP URL association.

    // Don't need to test for nStartPage < 0 since UINTs are never negative
    if (nStartPage != DEFAULT_CPL_PAGE &&
       (nStartPage >= ARRAYSIZE(c_PropInfo)))
    {
        nStartPage = DEFAULT_CPL_PAGE;
    }
    
    //
    // initialize the ieak restrictions data
    //
    GetRestrictFlags(&g_restrict);

    //
    // The caller will pass DEFAULT_CPL_PAGE for nStartPage when it doesn't care
    // which tab should be displayed first.  In this case, we just
    // display the first tab that's not disabled via IEAK
    //
    if (DEFAULT_CPL_PAGE == nStartPage)
    {
        int iPage;

        for (iPage=0; iPage<ARRAYSIZE(c_PropInfo); iPage++)
        {
            if (IsPropPageEnabled(iPage))
                break;
        }

        //
        // If the ieak has disabled ALL the pages, then we don't
        // can't display the inetcpl.  Show a message.
        //
        if (iPage == ARRAYSIZE(c_PropInfo))
        {
            MLShellMessageBox(
                hDlg, 
                MAKEINTRESOURCEW(IDS_RESTRICTED_MESSAGE), 
                MAKEINTRESOURCEW(IDS_RESTRICTED_TITLE), 
                MB_OK);
            return FALSE;
        }
        else
        {
            nStartPage = 0;
        }

    }

    //
    // This means the caller has requested that a specific start
    // page for the propsheet
    //
    else
    {
        int iPage;

        //
        // If the caller has requested a specific page, and that 
        // page is disabled due to IEAK restrictions, then don't 
        // display the inetcpl at all.  Show a messagebox.
        //
        if (!IsPropPageEnabled(nStartPage))
        {
            MLShellMessageBox(
                hDlg, 
                MAKEINTRESOURCE(IDS_RESTRICTED_MESSAGE), 
                MAKEINTRESOURCE(IDS_RESTRICTED_TITLE),
                MB_OK);
            return FALSE;

        }

        //
        // Due to IEAK restrictions, there may be one or more pages
        // before nStartPage that are actually missing.  We need to
        // decrement nStartPage to take that into account.
        //
        for (iPage=nStartPage-1; iPage>=0; iPage--)
            if (!IsPropPageEnabled(iPage))
                nStartPage--;

    }


    memset(&psHeader,0,sizeof(psHeader));

    psHeader.dwSize = sizeof(psHeader);
    psHeader.dwFlags = PSH_PROPTITLE;
    psHeader.hwndParent = hDlg;
    psHeader.hInstance = MLGetHinst();
    psHeader.nPages = 0;
    psHeader.nStartPage = nStartPage;
    psHeader.phpage = hOptPage;
    psHeader.pszCaption = MAKEINTRESOURCE(IDS_INTERNET_LOC);

    if (AddInternetPropertySheets(&_AddPropSheetPage, (LPARAM)&psHeader, NULL,
                                  NULL) == S_OK)
    {
        // add any extra pages from hooks in the registry
        if( ( hpsxa = SHCreatePropSheetExtArray( HKEY_LOCAL_MACHINE, 
            REGSTR_PATH_INETCPL_PS_EXTENTIONS, MAX_NUM_OPTION_PAGES - NUM_OPTION_PAGES ) ) != NULL )
        {
            SHAddFromPropSheetExtArray( hpsxa, _AddPropSheetPage, (LPARAM)&psHeader );
        }

        // bring it up
        PropertySheet( &psHeader );

        // free the hooks if we loaded them 
        if ( hpsxa )
            SHDestroyPropSheetExtArray( hpsxa );

        fRet = TRUE;
    }
    else
    {
        DestroyPropertySheets(&psHeader);

        MsgBox(NULL, IDS_ERROutOfMemory, MB_ICONEXCLAMATION, MB_OK);
        fRet = FALSE;
    }

    SHCoUninitialize(hrOle);

    return fRet;
}

STDAPI_(BOOL) LaunchInternetControlPanel(HWND hDlg)
{
    return LaunchInternetControlPanelAtPage(hDlg, DEFAULT_CPL_PAGE);
}

STDAPI_(BOOL) LaunchConnectionDialog(HWND hDlg)
{
    ASSERT(INET_PAGE_CONNECTION == c_PropInfo[4].dwPageFlag);

    return LaunchInternetControlPanelAtPage(hDlg, 4);
}

STDAPI_(BOOL) LaunchPrivacyDialog(HWND hDlg)
{
    ASSERT(INET_PAGE_PRIVACY == c_PropInfo[2].dwPageFlag);
                                            
    return LaunchInternetControlPanelAtPage(hDlg, 2);
}


BOOL IsCompatModeProcess()
{
    if (GetModuleHandle(TEXT("IE4.EXE")) || GetModuleHandle(TEXT("IESQRL.EXE")))
    {
        // If we are running in compat mode, exit because we don't want users
        // mucking with control panel from here.
        WinExec("control.exe", SW_NORMAL);
        
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\process.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1998-                   **
//*********************************************************************
//
// created 8-19-1998
//
//

// class definition for the process information handler
// the class is to wrap NT/Win95 specific debugging aid APIs
#ifdef UNICODE
#undef Process32First 
#undef Process32Next 
#undef PROCESSENTRY32 
#undef PPROCESSENTRY32
#undef LPPROCESSENTRY32
#endif  // !UNICODE
class CProcessInfo
{
public:
    CProcessInfo(); 
    ~CProcessInfo();     
    HRESULT GetExeNameFromPID(DWORD dwPID, LPTSTR szFile, int cchFile);

    BOOL _fNT;
protected:
    HRESULT MakeRoomForInfoArray(int n);
    HRESULT EnsureProcessInfo();
    // 
    // win95 toolhelp stuff
    //
    HRESULT W95InitToolhelp32();
    HRESULT W95CreateProcessList();
    HRESULT W95FillProcessList();

    typedef BOOL (WINAPI* PROCESSWALK)(HANDLE, LPPROCESSENTRY32);
    typedef HANDLE (WINAPI* CREATESNAPSHOT)(DWORD, DWORD);
    CREATESNAPSHOT _lpfnCreateToolhelp32Snapshot;
    PROCESSWALK _lpfnProcess32First;
    PROCESSWALK _lpfnProcess32Next;
    //
    // NT PSAPI stuff
    //
    HRESULT NTInitPsapi();
    HRESULT NTCreateProcessList();
    HRESULT NTFillProcessList(DWORD dwProcessID, int iIndex);
    
    
    typedef BOOL  (CALLBACK* LPFNENUMPROCESSES)(DWORD *,DWORD,DWORD *);
    typedef BOOL  (CALLBACK* LPFNENUMPROCESSMODULES)(HANDLE,HMODULE *,DWORD,LPDWORD);
    typedef DWORD (CALLBACK* LPFNGETMODULEBASENAMEW)(HANDLE,HMODULE,LPWSTR,DWORD);
    HINSTANCE                 _hPsapiDLL; 
    LPFNENUMPROCESSES      _lpfnEnumProcesses; 
    LPFNENUMPROCESSMODULES _lpfnEnumProcessModules; 
    LPFNGETMODULEBASENAMEW  _lpfnGetModuleBaseName;
    //
    // place to hold processs information
    //
    struct PROCESSINFO {
        DWORD dwPID;
        TCHAR szExeName[MAX_PATH];
    } *_pProcInfoArray;
    int _iProcInfoCount;
    int _nAlloced;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\regutil.cpp ===
//////////////////////////////////////////////////////////////////////
//                      Microsoft Internet Explorer                 //
//                Copyright(c) Microsoft Corp., 1995-1996           //
//////////////////////////////////////////////////////////////////////
//
// REGUTIL.C - registry functions common between MSHTML and INETCPL.
//

// HISTORY:
//
// 8/7/96   t-gpease    created.
//

#include "inetcplp.h"

//
// Definintions
//

#define SMALLBUFFER 64

//
// Procedures
//
const TCHAR g_cszYes[] = TEXT("yes");
const TCHAR g_cszNo[]  = TEXT("no");


// Conveters and int into a string... ONLY BYTE VALUES!!
TCHAR *MyIntToStr(TCHAR *pBuf, BYTE iVal)
{
    int i, t;

    ASSERT(iVal < 1000);

    i=0;
    if (t = iVal/100)
    {
        pBuf[i] = L'0' + t;
        i++;
    }

    if ((t = (iVal % 100) / 10) || (i!=0))
    {
        pBuf[i] = L'0' + t;
        i++;
    }

    pBuf[i] = L'0' + iVal % 10;
    i++;

    pBuf[i] = L'\0';

    return pBuf;
}

// Read the registry for a string (REG_SZ) of comma separated RGB values
COLORREF RegGetColorRefString( HUSKEY huskey, LPTSTR RegValue, COLORREF Value)
{
    TCHAR SmallBuf[SMALLBUFFER];
    TCHAR *pBuf;
    DWORD cb;
	int iRed, iGreen, iBlue;

    cb = ARRAYSIZE(SmallBuf);
    if (SHRegQueryUSValue(huskey,
                          RegValue,
                          NULL,
                          (LPBYTE)&SmallBuf,
                          &cb,
                          FALSE,
                          NULL,
                          NULL) == ERROR_SUCCESS)
    {
        iRed = StrToInt(SmallBuf);
        pBuf = SmallBuf;

        // find the next comma
        while(pBuf && *pBuf && *pBuf!=L',')
            pBuf++;
        
        // if valid and not NULL...
        if (pBuf && *pBuf)
            pBuf++;         // increment

        iGreen = StrToInt(pBuf);

        // find the next comma
        while(pBuf && *pBuf && *pBuf!=L',')
            pBuf++;

        // if valid and not NULL...
        if (pBuf && *pBuf)
            pBuf++;         // increment

        iBlue = StrToInt(pBuf);

        // make sure all values are valid
		iRed    %= 256;
		iGreen  %= 256;
		iBlue   %= 256;

	    Value = RGB(iRed, iGreen, iBlue);
    }

    return Value;
}

// Writes the registry for a string (REG_SZ) of comma separated RGB values
COLORREF RegSetColorRefString( HUSKEY huskey, LPTSTR RegValue, COLORREF Value)
{
    TCHAR SmallBuf[SMALLBUFFER];
    TCHAR DigitBuf[4];  // that all we need for '255\0'
    int iRed, iGreen, iBlue;

    iRed   = GetRValue(Value);
    iGreen = GetGValue(Value);
    iBlue  = GetBValue(Value);

    ASSERT(ARRAYSIZE(SmallBuf) >= 3 + 3 + 3 + 2 + 1) // "255,255,255"

    MyIntToStr(SmallBuf, (BYTE)iRed);
    StrCat(SmallBuf, TEXT(","));
    StrCat(SmallBuf, MyIntToStr(DigitBuf, (BYTE)iGreen));
    StrCat(SmallBuf, TEXT(","));
    StrCat(SmallBuf, MyIntToStr(DigitBuf, (BYTE)iBlue));

    SHRegWriteUSValue(huskey,
                      RegValue,
                      REG_SZ,
                      (LPVOID)&SmallBuf,
                      (lstrlen(SmallBuf)+1) * sizeof(TCHAR),
                      SHREGSET_DEFAULT);

    //
    // FEATURE: Should we do something if this fails?
    //

    return Value;
}


// Read the registry for a string (REG_SZ = "yes" | "no") and return a BOOL value
BOOL RegGetBooleanString(HUSKEY huskey, LPTSTR pszRegValue, BOOL bValue)
{
    TCHAR   szBuf[SMALLBUFFER];
    LPCTSTR  pszDefault;
    DWORD   cb;
    DWORD   cbDef;

    // get the default setting
    if (bValue)
        pszDefault = g_cszYes;
    else
        pszDefault = g_cszNo;
    
    cb = ARRAYSIZE(szBuf);
    cbDef = (lstrlen(pszDefault)+1)*sizeof(TCHAR); // +1 for null term
    if (SHRegQueryUSValue(huskey,
                          pszRegValue,
                          NULL,
                          (LPVOID)&szBuf,
                          &cb,
                          FALSE,
                          (LPVOID)pszDefault,
                          cbDef) == ERROR_SUCCESS)
    {
        if (!StrCmpI(szBuf, g_cszYes))
            bValue = TRUE;
        else if (!StrCmpI(szBuf, g_cszNo))
            bValue = FALSE;

        // else fall thru and return the Default that was passed in
    }

    return bValue;
}

// Write the registry for a string (REG_SZ) TRUE = "yes", FALSE = "no"
BOOL RegSetBooleanString(HUSKEY huskey, LPTSTR pszRegValue, BOOL bValue)
{
    TCHAR szBuf[SMALLBUFFER];

    if (bValue)
        StrCpyN(szBuf, g_cszYes, ARRAYSIZE(szBuf));
    else
        StrCpyN(szBuf, g_cszNo, ARRAYSIZE(szBuf));

    SHRegWriteUSValue(huskey,
                      pszRegValue,
                      REG_SZ,
                      (LPVOID)&szBuf, 
                      (lstrlen(szBuf)+1) * sizeof(TCHAR),
                      SHREGSET_DEFAULT);

    //
    // FEATURE: Should we try to do something if this fails?
    //

    return bValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\proxysup.cpp ===
/*++


Copyright (c) 1996  Microsoft Corporation

Module Name:

    proxysup.c

Abstract:

    Contains implementation for proxy server and proxy bypass list
    dialog interface.

    WARNING: Changes in this code need to be syncronizated
    with changes in proxysup.cxx in the WININET project.

    Contents:

Author:

    Arthur L Bierer (arthurbi) 18-Apr-1996

Revision History:

    18-Apr-1996 arthurbi
    Created

--*/

#include "inetcplp.h"

#include <mluisupp.h>

// Disable warning for VC6 (ASSERT macro causing the problem)
#pragma warning(4:4509) // nonstandard extension used: 'ftn' uses SEH and 'object' has destructor

//
// Don't use CRTs so define our own isdigit
//

#undef isdigit
#define isdigit(ch) (ch >= '0' && ch <= '9')

//
// ARRAY_ELEMENTS - returns number of elements in array
//

#define ARRAY_ELEMENTS(array)   (sizeof(array)/sizeof(array[0]))

#define GET_TERMINATOR(string)  while(*string != '\0') string++

#define IS_BLANK(string)        (*string == '\0')


//
// private types
//
typedef enum {
    STATE_START,
    STATE_PROTOCOL,
    STATE_SCHEME,
    STATE_SERVER,
    STATE_PORT,
    STATE_END,
    STATE_ERROR
} PARSER_STATE;

typedef struct tagMY_URL_SCHEME
{
    LPSTR           SchemeName;
    DWORD           SchemeLength;
    INTERNET_SCHEME SchemeType;
    DWORD           dwControlId;
    DWORD           dwPortControlId;
} MY_URL_SCHEME;

const MY_URL_SCHEME UrlSchemeList[] =
{
    NULL,       0,  INTERNET_SCHEME_DEFAULT,IDC_NOTUSED,                  IDC_NOTUSED,
    "ftp",      3,  INTERNET_SCHEME_FTP,    IDC_PROXY_FTP_ADDRESS,        IDC_PROXY_FTP_PORT,
    "gopher",   6,  INTERNET_SCHEME_GOPHER, IDC_PROXY_GOPHER_ADDRESS,     IDC_PROXY_GOPHER_PORT,
    "http",     4,  INTERNET_SCHEME_HTTP,   IDC_PROXY_HTTP_ADDRESS,       IDC_PROXY_HTTP_PORT,
    "https",    5,  INTERNET_SCHEME_HTTPS,  IDC_PROXY_SECURITY_ADDRESS,   IDC_PROXY_SECURITY_PORT,
    "socks",    5,  INTERNET_SCHEME_SOCKS,  IDC_PROXY_SOCKS_ADDRESS,      IDC_PROXY_SOCKS_PORT,
};

#define INTERNET_MAX_PORT_LENGTH    sizeof("123456789")

typedef struct tagBEFOREUSESAME
{
    // addresses
    TCHAR szFTP      [ INTERNET_MAX_URL_LENGTH + 1 ];
    TCHAR szGOPHER   [ INTERNET_MAX_URL_LENGTH + 1 ];
    TCHAR szSECURE   [ INTERNET_MAX_URL_LENGTH + 1 ];
    TCHAR szSOCKS    [ INTERNET_MAX_URL_LENGTH + 1 ];

    // ports
    TCHAR szFTPport      [ INTERNET_MAX_PORT_LENGTH + 1 ];
    TCHAR szGOPHERport   [ INTERNET_MAX_PORT_LENGTH + 1 ];
    TCHAR szSECUREport   [ INTERNET_MAX_PORT_LENGTH + 1 ];
    TCHAR szSOCKSport    [ INTERNET_MAX_PORT_LENGTH + 1 ];

} BEFOREUSESAME, *LPBEFOREUSESAME;

static const int g_iProxies[] = {IDC_PROXY_HTTP_ADDRESS, IDC_PROXY_FTP_ADDRESS, IDC_PROXY_GOPHER_ADDRESS, IDC_PROXY_SECURITY_ADDRESS, IDC_PROXY_SOCKS_ADDRESS};


typedef struct tagPROXYPAGE
{
    LPBEFOREUSESAME lpOldSettings;
    BOOL            fNT;
    LPPROXYINFO     lpi;
    HINSTANCE       hinstUrlMon;    // runtime load URLMON.DLL
} PROXYPAGE, *LPPROXYPAGE;

extern const TCHAR cszLocalString[] = TEXT("<local>");

#define MAX_SCHEME_NAME_LENGTH  sizeof("gopher")

#define MAX_TITLE           80
#define MAX_DIALOG_MESSAGE  300


//
// private function prototypes
//


LPBEFOREUSESAME SaveCurrentSettings(HWND hDlg);
void RestorePreviousSettings(HWND hDlg, LPBEFOREUSESAME lpSave);

BOOL
ProxyDlgInitProxyServers(
    IN HWND hDlg
    );

BOOL
ProxyDlgOK(
    IN HWND hDlg
    );

BOOL
ProxyDlgInit(
    IN HWND hDlg, LPARAM lParam
    );

VOID
EnableProxyControls(
    IN HWND hDlg
    );

BOOL
IsProxyValid(
    IN HWND     hDlg
    );


BOOL
ParseEditCtlForPort(
    IN OUT LPSTR   lpszProxyName,
    IN HWND        hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId
    );

BOOL
FormatOutProxyEditCtl(
    IN HWND        hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId,
    OUT LPSTR     lpszOutputStr,
    IN OUT LPDWORD lpdwOutputStrSize,
    IN DWORD       dwOutputStrLength,
    IN BOOL        fDefaultProxy
    );

INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    );

DWORD
MapUrlSchemeTypeToCtlId(
    IN INTERNET_SCHEME SchemeType,
    IN BOOL        fIdForPortCtl
    );


BOOL
MapCtlIdUrlSchemeName(
    IN DWORD    dwEditCtlId,
    OUT LPSTR   lpszSchemeOut
    );


DWORD
MapAddrCtlIdToPortCtlId(
    IN DWORD    dwEditCtlId
    );

BOOL
RemoveLocalFromExceptionList(
    IN LPTSTR lpszExceptionList
    );



//
// functions
//


/*******************************************************************

    NAME:       ProxyDlgProc

    SYNOPSIS:   Proxy property sheet dialog proc.

********************************************************************/
INT_PTR CALLBACK ProxyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
    LPARAM lParam)
{
    LPPROXYPAGE pPxy= (LPPROXYPAGE) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        
        case WM_INITDIALOG:
        {
            BOOL fInited;
            
            fInited = ProxyDlgInit(hDlg, lParam);
            return fInited;
        }
        
        case WM_NOTIFY:
        {
            NMHDR * lpnm = (NMHDR *) lParam;
            switch (lpnm->code)
            {
                case PSN_APPLY:
                {
                    BOOL fRet = ProxyDlgOK(hDlg);
                    SetPropSheetResult(hDlg,!fRet);
                    return !fRet;
                    break;
                }
                
                case PSN_RESET:
                    SetPropSheetResult(hDlg,FALSE);
                    break;
            }
            break;
        }
        
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_PROXY_ENABLE:
                    EnableProxyControls(hDlg);
                    break;

                case IDC_PROXY_HTTP_ADDRESS:
                case IDC_PROXY_GOPHER_ADDRESS:
                case IDC_PROXY_SECURITY_ADDRESS:
                case IDC_PROXY_FTP_ADDRESS:
                case IDC_PROXY_SOCKS_ADDRESS:

                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS )
                    {
                        ParseEditCtlForPort(NULL, hDlg, (GET_WM_COMMAND_ID(wParam, lParam)), 0);
                        EnableProxyControls(hDlg);
                    }
                    break;

                case IDC_PROXY_HTTP_PORT:
                case IDC_PROXY_GOPHER_PORT:
                case IDC_PROXY_SECURITY_PORT:
                case IDC_PROXY_FTP_PORT:
                case IDC_PROXY_SOCKS_PORT:

                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS )
                    {
                        EnableProxyControls(hDlg);
                    }
                    break;


                case IDC_PROXY_USE_SAME_SERVER:

                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        if (IsDlgButtonChecked(hDlg, IDC_PROXY_USE_SAME_SERVER))
                            pPxy->lpOldSettings = SaveCurrentSettings(hDlg);
                        else if (pPxy->lpOldSettings !=NULL)
                        {
                            RestorePreviousSettings(hDlg, pPxy->lpOldSettings);
                            pPxy->lpOldSettings = NULL;
                        }

                        EnableProxyControls(hDlg);
                    }
                    break;

                case IDOK:

                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        BOOL fLeaveDialog = TRUE;

                        if (!IsProxyValid(hDlg))
                        {
                            // The proxy is invalid, so we need to ask the user if they want to turn it off.
                            TCHAR szTitle[MAX_TITLE];
                            TCHAR szMessage[MAX_DIALOG_MESSAGE];
                            int nUserResponce;

                            MLLoadShellLangString(IDS_INVALID_PROXY_TITLE, szTitle, ARRAYSIZE(szTitle));
                            MLLoadShellLangString(IDS_INVALID_PROXY, szMessage, ARRAYSIZE(szMessage));

                            // Ask the user if they want to turn off the proxy.
                            nUserResponce = MessageBox(hDlg, szMessage, szTitle, MB_YESNOCANCEL | MB_ICONERROR);
                            if (IDYES == nUserResponce)
                                pPxy->lpi->fEnable = FALSE;
                            else if (IDCANCEL == nUserResponce)
                                fLeaveDialog = FALSE;   // The user hit cancel, so let's not leave the dialog.
                        }

                        if (fLeaveDialog)
                        {
                            //
                            // Read the Ctls and Save out to the proxy..
                            //
                            ProxyDlgOK(hDlg);
                            EndDialog(hDlg, IDOK);
                        }
                    }
                    break;

                case IDCANCEL:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        EndDialog(hDlg, IDCANCEL);
                    }
                    break;

            }
            break;

        case WM_DESTROY:
            if (pPxy->lpOldSettings)
                LocalFree(pPxy->lpOldSettings);

            if (pPxy->hinstUrlMon)
                FreeLibrary(pPxy->hinstUrlMon);

            LocalFree(pPxy);
            return TRUE;

        case WM_HELP:      // F1
            ResWinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            ResWinHelp((HWND)wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


//
// Private Functions.
//

VOID
EnableProxyControls(HWND hDlg)

/*++

Routine Description:

    Enables controls appropriately depending on what
    checkboxes are checked.

Arguments:

    hDlg        - Page Dialog Box.

Return Value:

    VOID

--*/


{
    BOOL fNT = ((LPPROXYPAGE)GetWindowLongPtr(hDlg, DWLP_USER))->fNT;
    
    BOOL fEnable = !g_restrict.fProxy;
            
    BOOL fUseOneProxy = IsDlgButtonChecked(hDlg,IDC_PROXY_USE_SAME_SERVER);
    
    EnableDlgItem(hDlg,IDC_GRP_SETTINGS2, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_EXCEPTIONS_GROUPBOX, fEnable);

    EnableDlgItem(hDlg,IDC_TYPE_TEXT, fEnable);
    EnableDlgItem(hDlg,IDC_ADDR_TEXT, fEnable);
    EnableDlgItem(hDlg,IDC_PORT_TEXT, fEnable);
    EnableDlgItem(hDlg,IDC_EXCEPT_TEXT, fEnable);
    EnableDlgItem(hDlg,IDC_EXCEPT2_TEXT, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_ICON1, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_ICON2, fEnable);
    
    EnableDlgItem(hDlg,IDC_PROXY_HTTP_CAPTION, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_SECURITY_CAPTION, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_FTP_CAPTION, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_GOPHER_CAPTION, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_SOCKS_CAPTION, fEnable);

    EnableDlgItem(hDlg, IDC_PROXY_USE_SAME_SERVER, fEnable);

    EnableDlgItem(hDlg,IDC_PROXY_HTTP_ADDRESS,fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_HTTP_PORT,fEnable);
           
    EnableDlgItem(hDlg,IDC_PROXY_OVERRIDE,fEnable);

    //
    // If we only want one Proxy, then make all others use the same
    //  proxy.
    //

    EnableDlgItem(hDlg,IDC_PROXY_SECURITY_ADDRESS,!fUseOneProxy && fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_SECURITY_PORT,!fUseOneProxy && fEnable);

    EnableDlgItem(hDlg,IDC_PROXY_FTP_ADDRESS,!fUseOneProxy && fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_FTP_PORT,!fUseOneProxy && fEnable);

    EnableDlgItem(hDlg,IDC_PROXY_GOPHER_ADDRESS,!fUseOneProxy && fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_GOPHER_PORT,!fUseOneProxy && fEnable);

    EnableDlgItem(hDlg,IDC_PROXY_SOCKS_ADDRESS,!fUseOneProxy && fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_SOCKS_PORT,!fUseOneProxy && fEnable);

    //
    // If we only want one proxy, prepopulate the other fields
    //  so they use the the mirror of the first one.
    //

    if (fUseOneProxy)
    {
        TCHAR szProxyName[MAX_URL_STRING+1];
        TCHAR szProxyPort[INTERNET_MAX_PORT_LENGTH];

        GetDlgItemText(hDlg,
            IDC_PROXY_HTTP_ADDRESS,
            szProxyName,
            ARRAYSIZE(szProxyName));

        GetDlgItemText(hDlg,
            IDC_PROXY_HTTP_PORT,
            szProxyPort,
            ARRAYSIZE(szProxyPort));

        SetDlgItemText(hDlg,IDC_PROXY_SECURITY_ADDRESS,szProxyName);
        SetDlgItemText(hDlg,IDC_PROXY_SECURITY_PORT,szProxyPort);

        SetDlgItemText(hDlg,IDC_PROXY_FTP_ADDRESS,szProxyName);
        SetDlgItemText(hDlg,IDC_PROXY_FTP_PORT,szProxyPort);

        SetDlgItemText(hDlg,IDC_PROXY_GOPHER_ADDRESS,szProxyName);
        SetDlgItemText(hDlg,IDC_PROXY_GOPHER_PORT,szProxyPort);

        SetDlgItemText(hDlg,IDC_PROXY_SOCKS_ADDRESS,TEXT(""));
        SetDlgItemText(hDlg,IDC_PROXY_SOCKS_PORT,TEXT(""));
    }
}

//
// SaveCurrentSettings()
//
// Saves current settings... just in case user changes their mind.
//
// Returns a pointer to a structure filled with current settings.
//
LPBEFOREUSESAME SaveCurrentSettings(HWND hDlg)
{
    LPBEFOREUSESAME lpSave = (LPBEFOREUSESAME)LocalAlloc(LPTR, sizeof(*lpSave));

    if (!lpSave)
        return lpSave; // if NULL return NULL

    GetDlgItemText(hDlg, IDC_PROXY_FTP_ADDRESS,      lpSave->szFTP,    INTERNET_MAX_URL_LENGTH);
    GetDlgItemText(hDlg, IDC_PROXY_GOPHER_ADDRESS,   lpSave->szGOPHER, INTERNET_MAX_URL_LENGTH);
    GetDlgItemText(hDlg, IDC_PROXY_SECURITY_ADDRESS, lpSave->szSECURE, INTERNET_MAX_URL_LENGTH);
    GetDlgItemText(hDlg, IDC_PROXY_SOCKS_ADDRESS,    lpSave->szSOCKS,  INTERNET_MAX_URL_LENGTH);

    GetDlgItemText(hDlg, IDC_PROXY_FTP_PORT,      lpSave->szFTPport,    INTERNET_MAX_URL_LENGTH);
    GetDlgItemText(hDlg, IDC_PROXY_GOPHER_PORT,   lpSave->szGOPHERport, INTERNET_MAX_URL_LENGTH);
    GetDlgItemText(hDlg, IDC_PROXY_SECURITY_PORT, lpSave->szSECUREport, INTERNET_MAX_URL_LENGTH);
    GetDlgItemText(hDlg, IDC_PROXY_SOCKS_PORT,    lpSave->szSOCKSport,  INTERNET_MAX_URL_LENGTH);

    return lpSave;

} // SaveCurrentSettings()


//
// RestorePreviousSettings()
//
// Restores settings... just in case user changes their mind.
//
void RestorePreviousSettings(HWND hDlg, LPBEFOREUSESAME lpSave)
{

    if (!lpSave)
    return; // nothing to do

    SetDlgItemText(hDlg, IDC_PROXY_FTP_ADDRESS,      lpSave->szFTP    );
    SetDlgItemText(hDlg, IDC_PROXY_GOPHER_ADDRESS,   lpSave->szGOPHER );
    SetDlgItemText(hDlg, IDC_PROXY_SECURITY_ADDRESS, lpSave->szSECURE );
    SetDlgItemText(hDlg, IDC_PROXY_SOCKS_ADDRESS,    lpSave->szSOCKS  );

    SetDlgItemText(hDlg, IDC_PROXY_FTP_PORT,      lpSave->szFTPport    );
    SetDlgItemText(hDlg, IDC_PROXY_GOPHER_PORT,   lpSave->szGOPHERport );
    SetDlgItemText(hDlg, IDC_PROXY_SECURITY_PORT, lpSave->szSECUREport );
    SetDlgItemText(hDlg, IDC_PROXY_SOCKS_PORT,    lpSave->szSOCKSport  );

    LocalFree(lpSave);  // give back the memory

} // RestorePreviousSettings()


BOOL
ProxyDlgInit(
    IN HWND hDlg, LPARAM lParam
    )

/*++

Routine Description:

    Initialization proc for proxy prop page

Arguments:

    hDlg        - Page Dialog Box.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/


{
    BOOL fSuccess;
    LPPROXYPAGE pPxy;

    pPxy = (LPPROXYPAGE)LocalAlloc(LPTR, sizeof(*pPxy));
    // NOTE: this NULLS lpOldSettings

    if (!pPxy)
        return FALSE;   // no memory?

    OSVERSIONINFOA osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA(&osvi);
    
    pPxy->fNT = (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT);
    ASSERT(pPxy->lpOldSettings == NULL);
        
    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pPxy);

    pPxy->lpi = (LPPROXYINFO)lParam;
    //
    // Begin by reading and setting the list of proxy
    //  servers we have.
    //

    fSuccess = ProxyDlgInitProxyServers( hDlg );

    if (!fSuccess)
        return FALSE;

    //
    // read settings from registry, for the list of Exclusion Hosts.
    //

    RegEntry re(REGSTR_PATH_INTERNETSETTINGS,HKEY_CURRENT_USER);

    if (re.GetError() == ERROR_SUCCESS)
    {
        BUFFER bufProxyString(MAX_URL_STRING+1);
        
        if (!bufProxyString)
        {
            MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
            return FALSE;
        }

        //  
        // get proxy override settings from registry and stuff fields
        // Prevent entry of more than (MAX_URL_STRING - ("<local>" + safety))
        SendMessage(GetDlgItem(hDlg, IDC_PROXY_OVERRIDE), EM_SETLIMITTEXT, (WPARAM)ARRAYSIZE(pPxy->lpi->szOverride)-20, 0);
        SetDlgItemText(hDlg, IDC_PROXY_OVERRIDE, pPxy->lpi->szOverride);
    }

    //
    // initialize the UI appropriately
    //

    EnableProxyControls(hDlg);
    
    return TRUE;
}

BOOL
ProxyDlgOK(
    IN HWND hDlg
    )

/*++

Routine Description:

    OK button handler for proxy prop page

Arguments:

    hDlg        - Page Dialog Box.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/


{
    LPPROXYPAGE pPxy = (LPPROXYPAGE)GetWindowLongPtr(hDlg, DWLP_USER);       
    TCHAR szProxyListOutputBuffer[MAX_URL_STRING];
    CHAR  szProxyListOutputBufferA[MAX_URL_STRING];
    DWORD dwBufferOffset = 0;

    //
    // Get the state of our two check boxes.
    //

    BOOL fUseOneProxy =
        IsDlgButtonChecked(hDlg,IDC_PROXY_USE_SAME_SERVER);
    //
    // Open our Registry Key.
    //
    
    RegEntry re(REGSTR_PATH_INTERNETSETTINGS,HKEY_CURRENT_USER);
    if (re.GetError() == ERROR_SUCCESS)
    {       
        //
        //  Now Format, and write out the list of proxies to
        //  the registry.  We special case the case of
        //  only proxy.
        //

        szProxyListOutputBufferA[dwBufferOffset] = '\0';

        if ( fUseOneProxy )
        {
            FormatOutProxyEditCtl(
                                  hDlg,
                                  IDC_PROXY_HTTP_ADDRESS,
                                  IDC_PROXY_HTTP_PORT,
                                  szProxyListOutputBufferA,
                                  &dwBufferOffset,
                                  ARRAY_ELEMENTS(szProxyListOutputBufferA),
                                  TRUE
                                 );
        }
        else
        {
            for (int i = 1; i < ARRAY_ELEMENTS(UrlSchemeList); ++i)
            {
                FormatOutProxyEditCtl(
                                      hDlg,
                                      UrlSchemeList[i].dwControlId,
                                      UrlSchemeList[i].dwPortControlId,
                                      szProxyListOutputBufferA,
                                      &dwBufferOffset,
                                      ARRAY_ELEMENTS(szProxyListOutputBufferA),
                                      FALSE
                                     );

            }
        }

        szProxyListOutputBufferA[dwBufferOffset] = '\0';

#ifdef UNICODE
        SHAnsiToUnicode(szProxyListOutputBufferA, szProxyListOutputBuffer, MAX_URL_STRING);
#else
        lstrcpy(szProxyListOutputBuffer, szProxyListOutputBufferA);
#endif
        StrCpyN(pPxy->lpi->szProxy, szProxyListOutputBuffer, MAX_URL_STRING);

        //
        // Now Write out the Proxy Exception List
        //  (list of addresses to use for local connections)
        //

        szProxyListOutputBuffer[0] = '\0';
        
        GetDlgItemText(hDlg,
                       IDC_PROXY_OVERRIDE,
                       szProxyListOutputBuffer,
                       ARRAY_ELEMENTS(szProxyListOutputBuffer));
                
        StrCpyN(pPxy->lpi->szOverride, szProxyListOutputBuffer, MAX_URL_STRING);
    }
    
    else    
    {
        AssertMsg(0, TEXT("Couldn't save settings to registry!"));
    }


    // let any active (participating) wininet's get notified
    //
    InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

    return TRUE;
}


INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    )

/*++

Routine Description:

    Maps a scheme name/length to a scheme name type

Arguments:

    lpszSchemeName  - pointer to name of scheme to map

    dwSchemeNameLength  - length of scheme (if -1, lpszSchemeName is ASCIZ)

Return Value:

    INTERNET_SCHEME

--*/

{
    if (dwSchemeNameLength == (DWORD)-1)
    {
        dwSchemeNameLength = (DWORD)lstrlenA(lpszSchemeName);
    }
    
    for (int i = 0; i < ARRAY_ELEMENTS(UrlSchemeList); ++i)
    {
        if (UrlSchemeList[i].SchemeLength == dwSchemeNameLength)
        {   
            CHAR chBackup = lpszSchemeName[dwSchemeNameLength];
            lpszSchemeName[dwSchemeNameLength] = '\0';
            
            if(StrCmpIA(UrlSchemeList[i].SchemeName,lpszSchemeName) == 0)
            {
                lpszSchemeName[dwSchemeNameLength] = chBackup;
                return UrlSchemeList[i].SchemeType;
            }
            
            lpszSchemeName[dwSchemeNameLength] = chBackup;
        }
    }
    return INTERNET_SCHEME_UNKNOWN;
}



DWORD
MapUrlSchemeTypeToCtlId(
    IN INTERNET_SCHEME SchemeType,
    IN BOOL        fIdForPortCtl
    )

/*++

Routine Description:

    Maps a scheme to a dlg child control id.

Arguments:

    Scheme    - Scheme to Map

    fIdForPortCtl - If TRUE, means we really want the ID for a the PORT control
            not the ADDRESS control.

Return Value:

    DWORD

--*/

{
    for (int i = 0; i < ARRAY_ELEMENTS(UrlSchemeList); ++i)
    {
        if (SchemeType == UrlSchemeList[i].SchemeType)
        {
            return (fIdForPortCtl ? UrlSchemeList[i].dwPortControlId :
                    UrlSchemeList[i].dwControlId );
        }
    }
    return IDC_NOTUSED;
}

BOOL
MapCtlIdUrlSchemeName(
    IN DWORD    dwEditCtlId,
    OUT LPSTR   lpszSchemeOut
    )

/*++

Routine Description:

    Maps a dlg child control id to String represnting
    the name of the scheme.

Arguments:

    dwEditCtlId   - Edit Control to Map Out.

    lpszSchemeOut - Scheme to Map Out.
            WARNING: ASSUMED to be size of largest scheme type.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/

{
    ASSERT(lpszSchemeOut);

    for (int i = 0; i < ARRAY_ELEMENTS(UrlSchemeList); ++i)
    {
        if (dwEditCtlId == UrlSchemeList[i].dwControlId )
        {
            StrCpyA(lpszSchemeOut, UrlSchemeList[i].SchemeName);
            return TRUE;
        }
    }
    return FALSE;
}


DWORD
MapAddrCtlIdToPortCtlId(
    IN DWORD    dwEditCtlId
    )

/*++

Routine Description:

    Maps a dlg child control id for addresses to
    a dlg control id for ports.

Arguments:

    dwEditCtlId   - Edit Control to Map Out.

Return Value:

    DWORD
    Success - Correctly mapped ID.

    Failure - 0.

--*/

{

    for (int i = 0; i < ARRAY_ELEMENTS(UrlSchemeList); ++i)
    {
        if (dwEditCtlId == UrlSchemeList[i].dwControlId )
        {
            return UrlSchemeList[i].dwPortControlId ;
        }
    }
    return FALSE;
}


BOOL
ProxyDlgInitProxyServers(
    IN HWND hDlg
    )

/*++

Routine Description:

    Parses a list of proxy servers and sets them into the newly created
    Proxy Dialog.

    Ruthlessly stolen from RFirth's proxysup.cxx in WININET by
    ArthurBi.

Arguments:

    hDlg    -      HWin to add our stuff to.


Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

Comments:

    Designed to handle Proxy string entry of the Form:

      pointer to list of proxies of the form:

      [<protocol>=][<scheme>"://"]<server>[":"<port>][";"*]

      The list can is read from the registry.


--*/

{
    DWORD error = !ERROR_SUCCESS;
    DWORD entryLength;
    LPSTR protocolName;
    DWORD protocolLength;
    LPSTR schemeName;
    DWORD schemeLength;
    LPSTR serverName;
    DWORD serverLength;
    PARSER_STATE state;
    DWORD nSlashes;
    INTERNET_PORT port;
    BOOL done;
    LPSTR lpszList;

    entryLength = 0;
    protocolLength = 0;
    schemeName = NULL;
    schemeLength = 0;
    serverName = NULL;
    serverLength = 0;
    state = STATE_PROTOCOL;
    nSlashes = 0;
    port = 0;
    done = FALSE;


    //
    // Open the Reg Key.
    //

    RegEntry re(REGSTR_PATH_INTERNETSETTINGS,HKEY_CURRENT_USER);

    if (re.GetError() != ERROR_SUCCESS)
        return FALSE; // no REG values..


    //
    // Crack the Registry values, read the proxy list
    //


    BUFFER bufProxyString(MAX_URL_STRING+1);
    BOOL   fProxyEnabled;

    if (!bufProxyString)
    {
        MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
        return FALSE;
    }

    //
    // is proxy enabled?
    // It should if we got into this dialog.
    //

    fProxyEnabled = (BOOL)re.GetNumber(REGSTR_VAL_PROXYENABLE,0);

    //
    // get proxy server and override settings from registry and stuff fields
    //

    re.GetString(REGSTR_VAL_PROXYSERVER,bufProxyString.QueryPtr(),
        bufProxyString.QuerySize());


    LPPROXYPAGE pPxy = (LPPROXYPAGE)GetWindowLongPtr(hDlg, DWLP_USER);

    // if there's a proxy passed in from the main page, then use it; otherwise use the registry val
#ifndef UNICODE
    lpszList = pPxy->lpi->szProxy;
#else
    char*  szList = NULL;
    LPTSTR lpTmp = pPxy->lpi->szProxy;
    DWORD  cch = lstrlen(lpTmp) + 1;
    szList = new char[2 * cch];
    if (szList)
    {
        SHUnicodeToAnsi(lpTmp, szList, 2 * cch);
        lpszList = szList;
    }
    else
    {
        MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
        return FALSE;
    }
#endif

    protocolName = lpszList;

    //
    // walk the list, pulling out the various scheme parts
    //

    do
    {
        char ch = *lpszList++;

        if ((nSlashes == 1) && (ch != '/'))
        {
            state = STATE_ERROR;
            break;
        }
        
        switch (ch)
        {
            case '=':
                if ((state == STATE_PROTOCOL) && (entryLength != 0))
                {
                    protocolLength = entryLength;
                    entryLength = 0;
                    state = STATE_SCHEME;
                    schemeName = lpszList;
                }
                else
                {
                    //
                    // '=' can't legally appear anywhere else
                    //
                    state = STATE_ERROR;
                }
                break;
                
            case ':':
                switch (state)
                {
                    case STATE_PROTOCOL:
                        if (*lpszList == '/')
                        {
                            schemeName = protocolName;
                            protocolName = NULL;
                            schemeLength = entryLength;
                            protocolLength = 0;
                            state = STATE_SCHEME;
                        }
                        else if (*lpszList != '\0')
                        {
                            serverName = protocolName;
                            serverLength = entryLength;
                            state = STATE_PORT;
                        }
                        else
                        {
                            state = STATE_ERROR;
                        }
                        entryLength = 0;
                        break;
                        
                    case STATE_SCHEME:
                        if (*lpszList == '/')
                        {
                            schemeLength = entryLength;
                        }
                        else if (*lpszList != '\0')
                        {
                            serverName = schemeName;
                            serverLength = entryLength;
                            state = STATE_PORT;
                        }
                        else
                        {
                            state = STATE_ERROR;
                        }
                        entryLength = 0;
                        break;
                        
                    case STATE_SERVER:
                        serverLength = entryLength;
                        state = STATE_PORT;
                        entryLength = 0;
                        break;

                    default:
                        state = STATE_ERROR;
                        break;
                }
                break;

            case '/':
                if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0))
                {
                    if (++nSlashes == 2)
                    {
                        state = STATE_SERVER;
                        serverName = lpszList;
                    }
                }
                else
                {
                    state = STATE_ERROR;
                }
                break;

            case '\v':  // vertical tab, 0x0b
            case '\f':  // form feed, 0x0c
                if (!((state == STATE_PROTOCOL) && (entryLength == 0)))
                {
                    //
                    // can't have embedded whitespace
                    //

                    state = STATE_ERROR;
                }
                break;

            default:
                if (state != STATE_PORT)
                {
                    ++entryLength;
                }
                else if (isdigit(ch))
                {
                    //
                    // we will overflow if >65535
                    //
                    Assert(port < 65535);
                    port = port * 10 + (ch - '0');
                }
                else
                {                   
                    //
                    // STATE_PORT && non-digit character - error
                    //
                    state = STATE_ERROR;
                }
                break;

            case '\0':
                done = TRUE;

                //
                // fall through
                //
            case ' ':
            case '\t':
            case '\n':
            case '\r':
            case ';':
            case ',':
                if (serverLength == 0)
                {
                    serverLength = entryLength;
                }
                if (serverLength != 0)
                {
                    if (serverName == NULL)
                    {
                        serverName = (schemeName != NULL)
                            ? schemeName : protocolName;
                    }

                    ASSERT(serverName != NULL);

                    INTERNET_SCHEME protocol;

                    if (protocolLength != 0)
                    {
                        protocol = MapUrlSchemeName(protocolName, protocolLength);
                    }
                    else
                    {
                        protocol = INTERNET_SCHEME_DEFAULT;
                    }

                    INTERNET_SCHEME scheme;

                    if (schemeLength != 0)
                    {
                        scheme = MapUrlSchemeName(schemeName, schemeLength);
                    }
                    else
                    {
                        scheme = INTERNET_SCHEME_DEFAULT;
                    }

                    //
                    // add an entry if this is a protocol we handle and we don't
                    // already have an entry for it
                    //

                    if ((protocol != INTERNET_SCHEME_UNKNOWN)
                        && (scheme != INTERNET_SCHEME_UNKNOWN))
                    {
                        DWORD dwCtlId = IDC_NOTUSED;
                        DWORD dwPortCtlId = IDC_NOTUSED;
                        CHAR chBackup;

                        error = ERROR_SUCCESS;
                        //
                        // we can only currently handle CERN proxies (unsecure or
                        // secure) so kick out anything that wants to go via a different
                        // proxy scheme
                        //

                        if (protocol == INTERNET_SCHEME_DEFAULT)
                        {
                            CheckDlgButton( hDlg, IDC_PROXY_USE_SAME_SERVER, TRUE );
                            dwCtlId     = IDC_PROXY_HTTP_ADDRESS;
                            dwPortCtlId = IDC_PROXY_HTTP_PORT;
                        }
                        else
                        {
                            dwCtlId     = MapUrlSchemeTypeToCtlId(protocol,FALSE);
                            dwPortCtlId = MapUrlSchemeTypeToCtlId(protocol,TRUE);
                        }

                        //
                        // Set the Field Entry.
                        //

                        LPSTR lpszProxyNameText;

                        if (scheme != INTERNET_SCHEME_DEFAULT)
                        {
                            ASSERT(schemeLength != 0);
                            lpszProxyNameText = schemeName;
                        }
                        else
                            lpszProxyNameText = serverName;

                        chBackup = serverName[serverLength];
                        serverName[serverLength] = '\0';
                        
                        SetDlgItemTextA( hDlg, dwCtlId, lpszProxyNameText );
                        if ( port )
                            SetDlgItemInt( hDlg, dwPortCtlId, port, FALSE );

                        serverName[serverLength] = chBackup;
                        
                    }
                    
                    else
                    {                      
                        //
                        // bad/unrecognised protocol or scheme. Treat it as error
                        // for now
                        //
                        error = !ERROR_SUCCESS;
                    }
                }

                entryLength = 0;
                protocolName = lpszList;
                protocolLength = 0;
                schemeName = NULL;
                schemeLength = 0;
                serverName = NULL;
                serverLength = 0;
                nSlashes = 0;
                port = 0;
                if (error == ERROR_SUCCESS)
                {
                    state = STATE_PROTOCOL;
                }
                else
                {
                    state = STATE_ERROR;
                }
                break;
        }

        if (state == STATE_ERROR)
        {
            break;
        }
        
    } while (!done);

#ifdef UNICODE
    delete [] szList;
#endif

    if (state == STATE_ERROR)
    {
        error = ERROR_INVALID_PARAMETER;
    }

    if ( error == ERROR_SUCCESS )
        error = TRUE;
    else
        error = FALSE;

    return error;
}


BOOL
IsProxyValid(
    IN HWND     hDlg
    )

/*++

Routine Description:

    Determines if the Proxy is valid.  The proxy is invalid if
    all of the proxy entries are empty.

Arguments:

    hDlg      - HWIN of the dialog to play with.

Return Value:

    BOOL
    Success TRUE - Valid.

    FALSE - Invalid.


--*/

{
    BOOL  fProxyIsValid = FALSE;
    TCHAR szProxyUrl[MAX_URL_STRING+1];
    int   iCurrentProxy = 0;

    ASSERT(IsWindow(hDlg));

    for (int iIndex = 0; iIndex < ARRAYSIZE(g_iProxies); iIndex++)
    {
        szProxyUrl[0] = '\0';
        GetDlgItemText(hDlg,
                       g_iProxies[iIndex],
                       szProxyUrl,
                       sizeof(szProxyUrl));
        
        if (szProxyUrl[0])
        {
            fProxyIsValid = TRUE;
            break;
        }
    }

    return fProxyIsValid;
}



BOOL
ParseEditCtlForPort(
    IN OUT LPSTR   lpszProxyName,
    IN HWND        hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId
    )

/*++

Routine Description:

    Parses a Port Number off then end of a Proxy Server URL that is
    located either in the Proxy Name Edit Box, or passed in as
    a string pointer.

Arguments:

    lpszProxyName - (OPTIONAL) string pointer with Proxy Name to parse, and
            set into the Proxy Name edit ctl field.

    hDlg      - HWIN of the dialog to play with.

    dwProxyNameCtlId -  Res Ctl Id to play with.

    dwProxyPortCtlId -  Res Ctl Id of Port Number Edit Box.

Return Value:

    BOOL
    Success TRUE -

    Failure FALSE


--*/

{
    CHAR   szProxyUrl[MAX_URL_STRING+1];
    LPSTR  lpszPort;
    LPSTR  lpszProxyUrl;

    ASSERT(IsWindow(hDlg));

    if ( dwProxyPortCtlId == 0 )
    {
        dwProxyPortCtlId = MapAddrCtlIdToPortCtlId(dwProxyNameCtlId);
        ASSERT(dwProxyPortCtlId);
    }

    //
    // Get the Proxy String from the Edit Control
    //  (OR) from the Registry [passed in]
    //

    if ( lpszProxyName )
        lpszProxyUrl = lpszProxyName;
    else
    {
    //
    // Need to Grab it out of the edit control.
    //
        GetDlgItemTextA(hDlg,
            dwProxyNameCtlId,
            szProxyUrl,
            sizeof(szProxyUrl));

        lpszProxyUrl = szProxyUrl;
    }

    //
    // Now find the port.
    //

    lpszPort = lpszProxyUrl;

    GET_TERMINATOR(lpszPort);

    lpszPort--;

    //
    // Walk backwards from the end of url looking
    //  for a port number sitting on the end like this
    //  http://proxy:1234
    //

    while ( (lpszPort > lpszProxyUrl) &&
        (*lpszPort != ':')         &&
        (isdigit(*lpszPort))  )
    {
        lpszPort--;
    }

    //
    // If we found a match for our rules
    //  then set the port, otherwise
    //  we assume the user knows what he's
    //  doing.
    //

    if ( *lpszPort == ':'   &&   isdigit(*(lpszPort+1)) )
    {
        *lpszPort = '\0';

        SetDlgItemTextA(hDlg, dwProxyPortCtlId, (lpszPort+1));
    }

    SetDlgItemTextA(hDlg, dwProxyNameCtlId, lpszProxyUrl);
    return TRUE;
}


BOOL
FormatOutProxyEditCtl(
    IN HWND    hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId,
    OUT LPSTR      lpszOutputStr,
    IN OUT LPDWORD lpdwOutputStrSize,
    IN DWORD       dwOutputStrLength,
    IN BOOL    fDefaultProxy
    )

/*++

Routine Description:

    Combines Proxy URL components into a string that can be saved
    in the registry.  Can be called multiple times to build
    a list of proxy servers, or once to special case a "default"
    proxy.

Arguments:

    hDlg      - HWIN of the dialog to play with.

    dwProxyNameCtlId -  Res Ctl Id to play with.

    dwProxyPortCtlId -  Res Ctl Id of Port Number Edit Box.

    lpszOutputStr    -  The start of the output string to send
            the product of this function.

    lpdwOutputStrSize - The amount of used space in lpszOutputStr
            that is already used.  New output should
            start from (lpszOutputStr + *lpdwOutputStrSize)

    fDefaultProxy     - Default Proxy, don't add scheme= in front of the proxy
            just use plop one proxy into the registry.


Return Value:

    BOOL
    Success TRUE

    Failure FALSE


--*/

{
    LPSTR lpszOutput;
    LPSTR lpszEndOfOutputStr;

    ASSERT(IsWindow(hDlg));
    ASSERT(lpdwOutputStrSize);

    lpszOutput = lpszOutputStr + *lpdwOutputStrSize;
    lpszEndOfOutputStr = lpszOutputStr + dwOutputStrLength;

    ASSERT( lpszEndOfOutputStr > lpszOutput );

    if ( lpszEndOfOutputStr <= lpszOutput )
        return FALSE; // bail out, ran out of space

    //
    // Plop ';' if we're not the first in this string buffer.
    //

    if (*lpdwOutputStrSize != 0  )
    {
        *lpszOutput = ';';

        lpszOutput++;

        if ( lpszEndOfOutputStr <= lpszOutput )
            return FALSE; // bail out, ran out of space
    }

    //
    // Put the schemetype= into the string
    //  ex:  http=
    //

    if ( ! fDefaultProxy )
    {
        if ( lpszEndOfOutputStr <= (MAX_SCHEME_NAME_LENGTH + lpszOutput + 1) )
            return FALSE; // bail out, ran out of space
        
        if (!MapCtlIdUrlSchemeName(dwProxyNameCtlId,lpszOutput))
            return FALSE;
        
        lpszOutput += lstrlenA(lpszOutput);
    
        *lpszOutput = '=';
        lpszOutput++;
    }
    
    //
    // Need to Grab ProxyUrl out of the edit control.
    //
    
    GetDlgItemTextA(hDlg, dwProxyNameCtlId, lpszOutput, (int)(lpszEndOfOutputStr - lpszOutput));

    if ( IS_BLANK(lpszOutput) )
        return FALSE;

    //
    // Now seperate out the port so we can save them seperately.
    //   But go past the Proxy Url while we're at it.
    //      ex: http=http://netscape-proxy
    //

    if (!ParseEditCtlForPort(lpszOutput, hDlg, dwProxyNameCtlId, dwProxyPortCtlId))
        return FALSE;

    lpszOutput += lstrlenA(lpszOutput);

    //
    // Now, add in a ':" for the port number, if we don't
    //  have a port we'll remove it.
    //
    {
        *lpszOutput = ':';
        
        lpszOutput++;
        
        if ( lpszEndOfOutputStr <= lpszOutput )
            return FALSE; // bail out, ran out of space
    }

    //
    // Grab Proxy Port if its around.
    //  Back out the ':' if its not.
    //

    GetDlgItemTextA(hDlg, dwProxyPortCtlId,lpszOutput, (int)(lpszEndOfOutputStr - lpszOutput));

    if ( IS_BLANK(lpszOutput) )
    {
        lpszOutput--;
        
        ASSERT(*lpszOutput == ':');

        *lpszOutput = '\0';
    }
    
    lpszOutput += lstrlenA(lpszOutput);
    
    //
    // Now we're done return our final sizes.
    //
    
    *lpdwOutputStrSize = (DWORD)(lpszOutput - lpszOutputStr);

    return TRUE;
}

BOOL
RemoveLocalFromExceptionList(
    IN LPTSTR lpszExceptionList
    )

/*++

Routine Description:

    Scans a delimited list of entries, and removed "<local>
    if found.  If <local> is found we return TRUE.

Arguments:

    lpszExceptionList - String List of proxy excepion entries.


Return Value:

    BOOL
    TRUE - If found <local>

    FALSE - If local was not found.


--*/

{
    LPTSTR lpszLocalInstToRemove;
    BOOL   fFoundLocal;

    if ( !lpszExceptionList || ! *lpszExceptionList )
    return FALSE;

    fFoundLocal = FALSE;
    lpszLocalInstToRemove = lpszExceptionList;

    //
    // Loop looking "<local>" entries in the list.
    //

    do {

        lpszLocalInstToRemove =
                               StrStrI(lpszLocalInstToRemove,cszLocalString);
        
        
        if ( lpszLocalInstToRemove )
        {
            
            fFoundLocal = TRUE;
            
            //
            // Nuke <local> out of the string. <local>;otherstuff\0
            //  Dest is: '<'local>;otherstuff\0
            //     ??? (OR) ';'<local> if the ; is the first character.???
            //  Src  is: >'o'therstuff\0
            //  size is: sizeof(';otherstuff\0')
            //
            
            MoveMemory(
                       lpszLocalInstToRemove,
                       (lpszLocalInstToRemove+lstrlen(cszLocalString)),
                       lstrlen(lpszLocalInstToRemove+lstrlen(cszLocalString))*sizeof(TCHAR)+sizeof(TCHAR)
                      );
            
        }
        
    } while (lpszLocalInstToRemove && *lpszLocalInstToRemove);

    //
    // If we produced a ; on the end, nuke it.
    //

    lpszLocalInstToRemove = lpszExceptionList;

    GET_TERMINATOR(lpszLocalInstToRemove);

    if ( lpszLocalInstToRemove != lpszExceptionList &&
         *(lpszLocalInstToRemove-1) == ';' )
    {
        *(lpszLocalInstToRemove-1) = '\0';
    }
    
    return fFoundLocal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\privacy.cpp ===
//*********************************************************************
//*          Microsoft Windows                                       **
//*        Copyright(c) Microsoft Corp., 1995                        **
//*********************************************************************

//
// PRIVACY.cpp - "Privacy" Property Sheet and support dialogs
//

// HISTORY:
//
// 2/26/2001  darrenmi    new code
// 4/05/2001  jeffdav     did per-site cookie dialog ui stuff

#include "inetcplp.h"

#include <urlmon.h>
#include <mluisupp.h>

#include <htmlhelp.h>

BOOL DeleteCacheCookies();
INT_PTR CALLBACK EmptyCacheCookiesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

#define REGSTR_PATH_SETTINGS        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define REGSTR_VAL_PRIVADV          TEXT("PrivacyAdvanced")

#define REGSTR_PRIVACYPS_PATHEDIT   TEXT("Software\\Policies\\Microsoft\\Internet Explorer")
#define REGSTR_PRIVACYPS_VALUEDIT   TEXT("PrivacyAddRemoveSites")  //  this key is duplicated in shdocvw\privacyui.cpp

#define REGSTR_PRIVACYPS_PATHPANE   TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define REGSTR_PRIVACYPS_VALUPANE   TEXT("Privacy Settings")  //  this key is duplicated in shdocvw\privacyui.cpp

///////////////////////////////////////////////////////////////////////////////////////
//
// Per-site list dialog
//
///////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////
//
// Per-site list utility function to minimize the domain name
//

WCHAR *GetMinCookieDomainFromUrl(WCHAR *bstrFullUrl)
{
    WCHAR *pMinimizedDomain = NULL;

    if(bstrFullUrl == NULL)
        goto doneGetMinimizedCookieDomain;

    if(bstrFullUrl[0] == '\0')
        goto doneGetMinimizedCookieDomain;

    WCHAR *pBeginUrl = bstrFullUrl;

    WCHAR *pEndUrl = pBeginUrl;    // pEndUrl will find the '/path/path..' and clip it from pBeginUrl

    while(*pEndUrl != L'\0' && *pEndUrl != L'/')
        pEndUrl++;

    *pEndUrl = L'\0';
    pMinimizedDomain = pEndUrl;   

    do
    {
        pMinimizedDomain--;
        while(pBeginUrl < pMinimizedDomain
              && *(pMinimizedDomain-1) != L'.')
        {
            pMinimizedDomain--;
        }
    } while(!IsDomainLegalCookieDomain( pMinimizedDomain, pBeginUrl)
            && pBeginUrl < pMinimizedDomain);

doneGetMinimizedCookieDomain:

    return pMinimizedDomain;
}

///////////////////////////////////////////////////////////////////////////////////////
//
// Per-site list sorting function and data structure
//

struct LVCOMPAREINFO
{
    HWND    hwndLV;         //hwnd for listview
    int     iCol;           //column (0 based)
    BOOL    fAscending;     //true if ascending, false if descending
};

int CALLBACK CompareByAlpha(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    struct LVCOMPAREINFO   *plvci = (struct LVCOMPAREINFO *)lParamSort;
    WCHAR  wz1[INTERNET_MAX_URL_LENGTH];
    WCHAR  wz2[INTERNET_MAX_URL_LENGTH];

    ListView_GetItemText(plvci->hwndLV, lParam1, plvci->iCol, wz1, ARRAYSIZE(wz1));
    ListView_GetItemText(plvci->hwndLV, lParam2, plvci->iCol, wz2, ARRAYSIZE(wz2));

    int iVal = _wcsicmp(wz1, wz2);

    if (iVal < 0)
        return (plvci->fAscending ? -1 : 1);

    if (iVal == 0)
        return (0);

    // only thing left is if (iVal > 0)...
    return (plvci->fAscending ? 1 : -1);

}

///////////////////////////////////////////////////////////////////////////////////////
//
// Per-site list defines and prototypes
//

#define PRIVACYPS_ACTION_ACCEPT   0
#define PRIVACYPS_ACTION_REJECT   1
#define PRIVACYPS_ACTION_NOACTION 2

void OnContextMenu(HWND hDlg, LPARAM lParam);
void OnInvalidDomain(HWND hDlg);
void OnSiteSet(HWND hDlg);
void OnSiteDelete(HWND hDlg);
void OnSiteClear(HWND hDlg);
void PerSiteInit(HWND hDlg);

LRESULT CALLBACK PrivPerSiteEBProc(HWND hWnd, UINT uMsg, WPARAM wParam,LPARAM lParam);

///////////////////////////////////////////////////////////////////////////////////////
//
// Per-site list functions
//

void OnContextMenu(HWND hWnd, int iIndex, POINT pointClick)
{

    HMENU  hMenu0 = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(IDR_PERSITE_CONTEXT_MENU));
    HMENU  hMenu1 = GetSubMenu(hMenu0, 0);
    DWORD  dwAction = PRIVACYPS_ACTION_NOACTION;
    WCHAR  wzUrl[INTERNET_MAX_URL_LENGTH];
    WCHAR  wzAction[32];
    LVITEM lvi;

    if(!hMenu1)
        return;

    if(pointClick.x == -1 && pointClick.y == -1)
    {
        RECT rectListRect;
        RECT rectSelectionRect;
        if(   0 != GetWindowRect(hWnd, &rectListRect) &&
           TRUE == ListView_GetItemRect(hWnd, iIndex, &rectSelectionRect, LVIR_LABEL))
        {
            pointClick.x = rectListRect.left + (rectSelectionRect.left + rectSelectionRect.right) / 2;
            pointClick.y = rectListRect.top  + (rectSelectionRect.top + rectSelectionRect.bottom) / 2;
        }
        else
            return;
    }

    // display it, get choice (if any)
    int iPick = TrackPopupMenu(hMenu1, 
                               TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                               pointClick.x,
                               pointClick.y,
                               0,
                               hWnd,
                              (RECT *)NULL);

    DestroyMenu(hMenu0);
    DestroyMenu(hMenu1);

    if (iPick) 
    {
        switch(iPick) 
        {
            case IDM_PRIVACYPS_CTXM_ACCEPT:
                
                // set the action...
                dwAction = PRIVACYPS_ACTION_ACCEPT;
                MLLoadString(IDS_PRIVACYPS_ACCEPT, wzAction, ARRAYSIZE(wzAction));
                
                // then fall-through...

            case IDM_PRIVACYPS_CTXM_REJECT:
                
                // set the action IFF its reject
                if (PRIVACYPS_ACTION_NOACTION == dwAction)
                {
                    dwAction = PRIVACYPS_ACTION_REJECT;
                    MLLoadString(IDS_PRIVACYPS_REJECT, wzAction, ARRAYSIZE(wzAction));
                }

                // update the ui...
                lvi.iItem = iIndex;
                lvi.iSubItem = 1;
                lvi.mask = LVIF_TEXT;
                lvi.pszText = wzAction;
                ListView_SetItem(hWnd, &lvi);
            
                // get the text...
                ListView_GetItemText(hWnd, iIndex, 0, wzUrl, ARRAYSIZE(wzUrl));

                // update the internal list...
                InternetSetPerSiteCookieDecisionW(
                    wzUrl, 
                    ((PRIVACYPS_ACTION_ACCEPT == dwAction) ? COOKIE_STATE_ACCEPT : COOKIE_STATE_REJECT)
                );

                break;

            case IDM_PRIVACYPS_CTXM_DELETE:
                OnSiteDelete(GetParent(hWnd));
                break;

            default:
                break;
        }
    }
}

void OnInvalidDomain(HWND hDlg)
{

    WCHAR       szError[256];
    WCHAR       szTitle[64];

    // error message here
    MLLoadString(IDS_PRIVACYPS_ERRORTTL, szTitle, ARRAYSIZE(szTitle));
    MLLoadString(IDS_PRIVACYPS_ERRORTXT, szError, ARRAYSIZE(szError));
    MessageBox(hDlg, szError, szTitle, MB_ICONEXCLAMATION | MB_OK);

    // select the editbox text so the user can try again...
    SendMessage(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), EM_SETSEL, (WPARAM)0, (LPARAM)-1);
}

void AutosizeStatusColumnWidth(HWND hwndList)
{
    int  iColWidth = 0;
    RECT rc;

    if (0 == ListView_GetItemCount(hwndList))
    {
        // auto size it based on header text...
        ListView_SetColumnWidth(hwndList, 1, LVSCW_AUTOSIZE_USEHEADER);
    }
    else
    {
        // auto size it based on content...
        ListView_SetColumnWidth(hwndList, 1, LVSCW_AUTOSIZE);
    }

    // see how big that was...
    iColWidth = ListView_GetColumnWidth(hwndList, 1);

    // size the 1st col...
    GetClientRect(hwndList, &rc);
    ListView_SetColumnWidth(hwndList, 0, rc.right-rc.left-iColWidth-GetSystemMetrics(SM_CXVSCROLL));
    
}

void OnSiteSet(HWND hDlg, UINT uiChoice)
{
    WCHAR      wzUrl[INTERNET_MAX_URL_LENGTH];
    WCHAR      wzUrlDomain[INTERNET_MAX_URL_LENGTH];
    WCHAR      wzUrlMinimized[INTERNET_MAX_URL_LENGTH];
    WCHAR      wzSchema[INTERNET_MAX_URL_LENGTH];
    WCHAR      wzAction[32];
    LVFINDINFO lvfi;
    LVITEM     lvi;
    DWORD      dwAction = 0;
    DWORD      dwCount  = 0;
    int        iIndex;
    HWND       hwndList = GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX);

    // the enter key and dbl click should do the same thing, so if the listbox has focus
    // and we got called, then they hit enter in the listbox, so let the listbox process
    // a WM_KEYDOWN/VK_RETURN message.
    if (GetFocus() == hwndList)
    {
        INT_PTR iIndx = ListView_GetSelectionMark(GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX));
        if (-1 != iIndx)
        {
            SendMessage(hwndList, WM_KEYDOWN, VK_RETURN, NULL);
            return;
        }
    }

    // read url and setting from ui
    GetWindowText(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), wzUrl, INTERNET_MAX_URL_LENGTH);

    // if it came from AutoComplete it'll have an http:// or https:// in it...
    if(wcsstr(_wcslwr(wzUrl), TEXT("http://")) || 
       wcsstr(_wcslwr(wzUrl), TEXT("https://")))
    {
        // ...and we found it, so get just the domain name...
        if(S_OK != CoInternetParseUrl(wzUrl, PARSE_DOMAIN, NULL, wzUrlDomain, ARRAYSIZE(wzUrlDomain), &dwCount, 0))
        {
            OnInvalidDomain(hDlg);
            return;
        }
        else if(wcslen(wzUrlDomain) < 2)
        {
            OnInvalidDomain(hDlg);
            return;
        }
    }
    else if (wcslen(wzUrl) < 2)
    {
        // we don't want null strings.  in fact, the smallest a domain could theoretically be would be something like "f."
        // so, to avoid null strings and stuff we check...
        OnInvalidDomain(hDlg);
        return;
    }
    else
    {
        // ...otherwise just use it
        wcsncpy(wzUrlDomain, wzUrl, wcslen(wzUrl)+1);
    }

    // only http:// or https:// domains in the internet zone are valid, so if we still have a schema after asking for just
    // the domain (see above) then we must have something like file:/// or some junk like that.
    CoInternetParseUrl(wzUrlDomain, PARSE_SCHEMA, NULL, wzSchema, ARRAYSIZE(wzSchema), &dwCount, 0);
    if (wcslen(wzSchema) != 0)
    {
        OnInvalidDomain(hDlg);
        return;
    }

    // minimize the domain
    wcsncpy(wzUrlMinimized, GetMinCookieDomainFromUrl(wzUrlDomain), wcslen(wzUrlDomain)+1);

    for (unsigned int i=0;i<wcslen(wzUrlMinimized);i++)
    {
        if (iswalnum(wzUrlMinimized[i]))
        {
            continue;
        }
        else
        {
            switch(wzUrlMinimized[i])
            {
                case L'.':
                    if (i >= 1) 
                        if (L'.' == wzUrlMinimized[i-1]) //prevent duplicate periods like "www..net"
                            break;
                    // (fallthrough)

                case L'-':
                    if (i == 0) // first character cannot be a dash
                        break;
                    // (fallthrough)

                case L'/':
                    continue;

                default:
                    break;
            }
            
            OnInvalidDomain(hDlg);
            return;
        }
    }

    if (!wcschr(_wcslwr(wzUrlMinimized), L'.'))
    {
        OnInvalidDomain(hDlg);
        return;
    }

    // valid domain?
    if(FALSE == IsDomainLegalCookieDomainW(wzUrlMinimized, wzUrlMinimized))
    {
        OnInvalidDomain(hDlg);
        return;
    }

    // are we accepting or rejecting this site?
    if (IDC_PRIVACYPS_ACCEPTBTN == uiChoice)
    {
        dwAction = PRIVACYPS_ACTION_ACCEPT;
        MLLoadString(IDS_PRIVACYPS_ACCEPT, wzAction, ARRAYSIZE(wzAction));
    }
    else 
    if (IDC_PRIVACYPS_REJECTBTN == uiChoice)
    {
        dwAction = PRIVACYPS_ACTION_REJECT;
        MLLoadString(IDS_PRIVACYPS_REJECT, wzAction, ARRAYSIZE(wzAction));
    }
    else
    {
        return;
    }
   
    // update UI...
    lvfi.flags = LVFI_STRING;
    lvfi.psz = wzUrlMinimized;
    iIndex = ListView_FindItem(hwndList, -1, &lvfi);

    if(iIndex != -1)
    {
        // found it, ensure correct subitem...
        lvi.iItem = iIndex;
        lvi.iSubItem = 1;
        lvi.pszText = wzAction;
        lvi.mask = LVIF_TEXT;
        ListView_SetItem(hwndList, &lvi);

        AutosizeStatusColumnWidth(hwndList);
    }
    else 
    {
        // add a new item...
        lvi.iItem = 0;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_TEXT;
        lvi.pszText = wzUrlMinimized;
        iIndex = ListView_InsertItem(hwndList, &lvi);

        lvi.iItem = iIndex;
        lvi.iSubItem = 1;
        lvi.mask = LVIF_TEXT;
        lvi.pszText = wzAction;
        ListView_SetItem(hwndList, &lvi);

        AutosizeStatusColumnWidth(hwndList);

        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEALLBTN), TRUE);
    }

    // update internal list...
    InternetSetPerSiteCookieDecisionW(
        wzUrlMinimized, 
        ((PRIVACYPS_ACTION_ACCEPT == dwAction) ? COOKIE_STATE_ACCEPT : COOKIE_STATE_REJECT)
    );

    // clear the edit box...
    SetWindowText(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), TEXT(""));
    SetFocus(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET));
}

void OnSiteDelete(HWND hDlg)
{
    WCHAR       wzUrl[INTERNET_MAX_URL_LENGTH];
    HWND        hwndList = GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX);
    INT_PTR     iIndex;
    
    // get the current selection in the list view...
    iIndex = ListView_GetSelectionMark(hwndList);

    // if we got something get the URL and delete it...
    if(iIndex != -1)
    {
        // remove from listview...
        ListView_GetItemText(hwndList, iIndex, 0, wzUrl, ARRAYSIZE(wzUrl));
        ListView_DeleteItem(hwndList, iIndex);

        // disable buttons if the listbox is now empty...
        if(0 == ListView_GetItemCount(hwndList))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEALLBTN), FALSE);
        }

        InternetSetPerSiteCookieDecisionW(wzUrl, COOKIE_STATE_UNKNOWN);
        
        // clear selection
        SetFocus(GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX));
        iIndex = ListView_GetSelectionMark(hwndList);
        ListView_SetItemState(hwndList, iIndex, NULL, LVIS_FOCUSED | LVIS_SELECTED);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), FALSE);
    }
}

void OnSiteClear(HWND hDlg)
{
    // empty the list...
    ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX));
    InternetClearAllPerSiteCookieDecisions();
    
    // disable the remove buttons...
    EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEALLBTN), FALSE);

    // set focus back to the edit box so they can add more if they feel like it...
    SetFocus(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET));
}

void PerSiteInit(HWND hDlg)
{

    HWND          hwndList       = GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX);
    LVITEM        lviEntry;
    DWORD         dwSizeOfBuffer = 0; // in bytes
    DWORD         dwDecision     = 0;
    DWORD         dwIndex        = 0;
    WCHAR         wzSiteNameBuffer[INTERNET_MAX_URL_LENGTH];
    LONG_PTR      wndprocOld     = NULL;
    WCHAR         wzTitle[64];
    WCHAR         wzAccept[32];
    WCHAR         wzReject[32];
    int           iItem;
    DWORD         dwRet, dwType, dwValue, dwSize;

    // subclass the editbox
    wndprocOld = SetWindowLongPtr(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), GWLP_WNDPROC, (LONG_PTR)PrivPerSiteEBProc);

    // put a pointer to the old proc in GWLP_USERDATA so we can call it...
    SetWindowLongPtr(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), GWLP_USERDATA, wndprocOld);


    if (!hwndList)
        return;

    // empty the listview...
    ListView_DeleteAllItems(hwndList);

    // initialize domain column in the listview...
    LV_COLUMN   lvColumn;        
    RECT rc;

    // load the accept and reject strings...
    MLLoadString(IDS_PRIVACYPS_ACCEPT, wzAccept, ARRAYSIZE(wzAccept));
    MLLoadString(IDS_PRIVACYPS_REJECT, wzReject, ARRAYSIZE(wzReject));

    lvColumn.mask = LVCF_FMT | LVCF_TEXT;
    lvColumn.fmt = LVCFMT_LEFT;

    if( 0 != GetClientRect( hwndList, &rc))
    {
        lvColumn.cx = rc.right - rc.left - GetSystemMetrics(SM_CXVSCROLL) - 75;
        lvColumn.mask |= LVCF_WIDTH;
    }

    MLLoadString(IDS_PRIVACYPS_COLSITE, wzTitle, ARRAYSIZE(wzTitle));
    lvColumn.pszText = wzTitle;
    
    ListView_InsertColumn(hwndList, 0, &lvColumn);

    // initialize setting column
    lvColumn.mask = LVCF_FMT | LVCF_TEXT;
    lvColumn.fmt = LVCFMT_LEFT;

    if( 0 != GetClientRect( hwndList, &rc))
    {
        lvColumn.cx = 75;
        lvColumn.mask |= LVCF_WIDTH;
    }

    MLLoadString(IDS_PRIVACYPS_COLSET, wzTitle, ARRAYSIZE(wzTitle));
    lvColumn.pszText = wzTitle;
    
    ListView_InsertColumn(hwndList, 1, &lvColumn);

    // enumerate elements...
    while((dwSizeOfBuffer = ARRAYSIZE(wzSiteNameBuffer)) && 
          InternetEnumPerSiteCookieDecision(wzSiteNameBuffer,&dwSizeOfBuffer,&dwDecision,dwIndex))
    {

        lviEntry.iItem = dwIndex;
        lviEntry.iSubItem = 0;
        lviEntry.mask = LVIF_TEXT /*| LVIF_IMAGE*/;
        lviEntry.pszText = wzSiteNameBuffer;

        // don't display crap users may hack into the registry themselves, or hosed entries we may write :)
        if(FALSE == IsDomainLegalCookieDomainW(wzSiteNameBuffer, wzSiteNameBuffer))
        {
            dwIndex++;
            continue;
        }

        iItem = ListView_InsertItem(hwndList, &lviEntry);

        lviEntry.iItem = iItem;
        lviEntry.iSubItem = 1;
        lviEntry.mask = LVIF_TEXT;
        if (dwDecision == COOKIE_STATE_ACCEPT)
            lviEntry.pszText = wzAccept;
        else if (dwDecision == COOKIE_STATE_REJECT)
            lviEntry.pszText = wzReject;
        else
        {
            dwIndex++;
            continue;
        }

        ListView_SetItem(hwndList, &lviEntry);

        dwIndex++;
    }

    AutosizeStatusColumnWidth(hwndList);

    // enable the remove all button if we enumerated anything...
    if (dwIndex > 0)
    {
        ListView_SetItemState(hwndList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEALLBTN), TRUE);
    }

    // enable autocomplete for the editbox...
    SHAutoComplete(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), SHACF_DEFAULT);

    // check for policy to make this dialog read-only...
    dwSize = sizeof(dwValue);
    dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PRIVACYPS_PATHPANE, REGSTR_PRIVACYPS_VALUPANE, &dwType, &dwValue, &dwSize);

    if (ERROR_SUCCESS == dwRet && dwValue && REG_DWORD == dwType)
    {
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)TRUE);

        // disable all buttons and stuff...
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REJECTBTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_ACCEPTBTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEALLBTN), FALSE);
    }
}

void OnDoubleClick(HWND hWnd)
{
    
    int   iIndex = ListView_GetSelectionMark(hWnd);
    WCHAR wzUrl[INTERNET_MAX_URL_LENGTH];

    // on dbl clicks we want to enter the item in the edit box so the user can edit it, or cut & paste, or whatever
    // but only if we actually have a selected item...
    if (-1 == iIndex)
        return;

    // get the current selection...
    ListView_GetItemText(hWnd, iIndex, 0, wzUrl, ARRAYSIZE(wzUrl));
    
    // enter the text into the edit box...
    SetDlgItemText(GetParent(hWnd), IDC_PRIVACYPS_SITETOSET, wzUrl);

    // select it for the user...
    SendMessage(GetDlgItem(GetParent(hWnd), IDC_PRIVACYPS_SITETOSET), EM_SETSEL, (WPARAM)0, (LPARAM)-1);

    // set focus to the edit box...
    SetFocus(GetDlgItem(GetParent(hWnd), IDC_PRIVACYPS_SITETOSET));

    // unselect the listview item...
    ListView_SetItemState(hWnd, iIndex, NULL, LVIS_FOCUSED | LVIS_SELECTED);

}

///////////////////////////////////////////////////////////////////////////////////////
//
// Per-site list window proc's
//

LRESULT CALLBACK PrivPerSiteEBProc(HWND hWnd, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    HWND hDlg     = GetParent(hWnd);
    HWND hwndList = GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX);
    int  iIndex   = ListView_GetSelectionMark(hwndList);

    switch (uMsg)
    {
        case WM_SETFOCUS:
            // disable the remove button and unselect whatever in the listview...
            EnableWindow(GetDlgItem(GetParent(hWnd), IDC_PRIVACYPS_REMOVEBTN), FALSE);
            ListView_SetItemState(hwndList, iIndex, NULL, LVIS_FOCUSED | LVIS_SELECTED);
            break;

        default:
            break;
    }

    return (CallWindowProc((WNDPROC)GetWindowLongPtr(hWnd, GWLP_USERDATA), hWnd, uMsg, wParam, lParam));
}

INT_PTR CALLBACK PrivPerSiteDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{

    HWND hwndList = GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX);
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
            PerSiteInit(hDlg);

            if( IsOS(OS_WHISTLERORGREATER))
            {
                HICON hIcon = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_PRIVACY_XP));
                if( hIcon != NULL)
                    SendDlgItemMessage(hDlg, IDC_PRIVACY_ICON, STM_SETICON, (WPARAM)hIcon, 0);
                // icons loaded with LoadIcon never need to be released
            }
            
            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDCANCEL:
                case IDOK:
                    return EndDialog(hDlg, 0);

                case IDC_PRIVACYPS_REMOVEALLBTN:
                    OnSiteClear(hDlg);
                    return TRUE;

                case IDC_PRIVACYPS_REMOVEBTN:
                    OnSiteDelete(hDlg);
                    return TRUE;

                case IDC_PRIVACYPS_ACCEPTBTN:
                    OnSiteSet(hDlg, IDC_PRIVACYPS_ACCEPTBTN);
                    return TRUE;
                
                case IDC_PRIVACYPS_REJECTBTN:
                    OnSiteSet(hDlg, IDC_PRIVACYPS_REJECTBTN);
                    return TRUE;

            }
            break;
        
        case WM_NOTIFY:
            if (IDC_PRIVACYPS_LISTBOX == ((LPNMHDR)lParam)->idFrom)
            {
                switch (((LPNMHDR)lParam)->code)
                {
                    case NM_KILLFOCUS:

                        // lost focus, turn off remove button
                        if ((GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN) != GetFocus()) ||
                            (-1 == ListView_GetSelectionMark(hwndList)))
                        {
                            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), FALSE);
                        }

                        return TRUE;

                    case NM_SETFOCUS:
                        {
                            // if there is nothing in the list we have nothing to do
                            if (0 == ListView_GetItemCount(hwndList))
                                break;

                            // if this is true a policy has been set making per-site list read-only, so do nothing...
                            if ((BOOL)GetWindowLongPtr(hDlg, DWLP_USER))
                                break;

                            int iIndex = ListView_GetSelectionMark(hwndList);

                            if (-1 == iIndex)
                            {
                                iIndex = 0;
                            }

                            // select|focus the correct item...
                            ListView_SetItemState(hwndList, iIndex, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), TRUE);

                        }
                        return TRUE;

                    case NM_CLICK:
                        
                        if (-1 != ListView_GetSelectionMark(hwndList) &&
                            !((BOOL)GetWindowLongPtr(hDlg, DWLP_USER)))
                        {
                            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), TRUE);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), FALSE);
                        }
                        return TRUE;
                    
                    case NM_DBLCLK:
                        
                        OnDoubleClick(hwndList);
                        return TRUE;

                    case NM_RCLICK:
                        {
                            // if this is true a policy has been set making per-site list read-only, so don't show the context menu,
                            // since all it does is allow you to change or remove things...
                            if ((BOOL)GetWindowLongPtr(hDlg, DWLP_USER))
                                break;

                            int iItem = ((LPNMITEMACTIVATE)lParam)->iItem;

                            if (-1 != iItem)
                            {
                                POINT pointClick = ((LPNMITEMACTIVATE)lParam)->ptAction;
                                RECT  rc;

                                if(0 != GetWindowRect(hwndList, &rc))
                                {
                                    pointClick.x += rc.left;
                                    pointClick.y += rc.top;
                                }
                                else
                                {  
                                    pointClick.x = -1;
                                    pointClick.y = -1;
                                }
                                
                                OnContextMenu(hwndList, iItem, pointClick);
                            }

                            return TRUE;
                        }

                    case LVN_KEYDOWN:

                        switch (((LPNMLVKEYDOWN)lParam)->wVKey)
                        {
                            case VK_DELETE:

                                OnSiteDelete(hDlg);
                                return TRUE;

                            case VK_RETURN:
                                
                                OnDoubleClick(hwndList);
                                return TRUE;

                            default:
                                break;
                        }
                        break;

                    case LVN_COLUMNCLICK:
                        {
                            struct LVCOMPAREINFO lvci;
                            static BOOL fAscending = TRUE;

                            fAscending = !fAscending;

                            lvci.fAscending = fAscending;                            
                            lvci.hwndLV = hwndList;
                            lvci.iCol   = ((LPNMLISTVIEW)lParam)->iSubItem;
                            
                            return ListView_SortItemsEx(hwndList, CompareByAlpha, &lvci);
                        }
                        
                    default:
                        break;
                }
            }
            break;

        case WM_HELP:               // F1
            ResWinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                       HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            if ((HWND)wParam != hwndList)
            {
                ResWinHelp((HWND) wParam, IDS_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            }
            else if (-1 == GET_X_LPARAM(lParam) && -1 == GET_Y_LPARAM(lParam))
            {
                POINT pointClick;
                pointClick.x = -1; pointClick.y = -1;
                OnContextMenu(hwndList, ListView_GetSelectionMark(hwndList), pointClick);
            }
            break;

    }
    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////////////
//
// Advanced privacy settings dialog
//
///////////////////////////////////////////////////////////////////////////////////////

BOOL IsAdvancedMode(void)
{
    DWORD   dwTemplate, dwError;
    BOOL    fAdvanced = FALSE;

    dwError = PrivacyGetZonePreferenceW(
                URLZONE_INTERNET,
                PRIVACY_TYPE_FIRST_PARTY,
                &dwTemplate,
                NULL,
                NULL);

    if(ERROR_SUCCESS == dwError && PRIVACY_TEMPLATE_ADVANCED == dwTemplate)
    {
        fAdvanced = TRUE;
    }

    return fAdvanced;
}

DWORD MapPrefToIndex(WCHAR wcPref)
{
    switch(wcPref)
    {
    case 'r':   return 1;       // reject
    case 'p':   return 2;       // prompt
    default:    return 0;       // default is accept
    }
}

WCHAR MapRadioToPref(HWND hDlg, DWORD dwResource)
{
    if(IsDlgButtonChecked(hDlg, dwResource + 1))        // deny
    {
        return 'r';
    }

    if(IsDlgButtonChecked(hDlg, dwResource + 2))        // prompt
    {
        return 'p';
    }

    // deafult is accept
    return 'a';
}


void OnAdvancedInit(HWND hDlg)
{
    BOOL    fSession = FALSE;
    DWORD   dwFirst = IDC_FIRST_ACCEPT;
    DWORD   dwThird = IDC_THIRD_ACCEPT;

    if(IsAdvancedMode())
    {
        WCHAR   szBuffer[MAX_PATH];  
        // MAX_PATH is sufficent for advanced mode setting strings, MaxPrivacySettings is overkill.
        WCHAR   *pszAlways;
        DWORD   dwBufferSize, dwTemplate;
        DWORD   dwError;

        //
        // turn on advanced check box
        //
        CheckDlgButton(hDlg, IDC_USE_ADVANCED, TRUE);

        //
        // Figure out first party setting and session
        //
        dwBufferSize = ARRAYSIZE( szBuffer);
        dwError = PrivacyGetZonePreferenceW(
                    URLZONE_INTERNET,
                    PRIVACY_TYPE_FIRST_PARTY,
                    &dwTemplate,
                    szBuffer,
                    &dwBufferSize);

        if(ERROR_SUCCESS == dwError)
        {
            pszAlways = StrStrW(szBuffer, L"always=");
            if(pszAlways)
            {
                dwFirst = IDC_FIRST_ACCEPT + MapPrefToIndex(*(pszAlways + 7));
            }

            if(StrStrW(szBuffer, L"session"))
            {
                fSession = TRUE;
            }
        }

        //
        // Figure out third party setting
        //
        dwBufferSize = ARRAYSIZE( szBuffer);
        dwError = PrivacyGetZonePreferenceW(
                    URLZONE_INTERNET,
                    PRIVACY_TYPE_THIRD_PARTY,
                    &dwTemplate,
                    szBuffer,
                    &dwBufferSize);

        if(ERROR_SUCCESS == dwError)
        {
            WCHAR *pszAlways;

            pszAlways = StrStrW(szBuffer, L"always=");
            if(pszAlways)
            {
                dwThird = IDC_THIRD_ACCEPT + MapPrefToIndex(*(pszAlways + 7));
            }
        }
    }

    CheckRadioButton(hDlg, IDC_FIRST_ACCEPT, IDC_FIRST_PROMPT, dwFirst);
    CheckRadioButton(hDlg, IDC_THIRD_ACCEPT, IDC_THIRD_PROMPT, dwThird);
    CheckDlgButton( hDlg, IDC_SESSION_OVERRIDE, fSession);
}

void OnAdvancedOk(HWND hDlg)
{
    BOOL    fWasAdvanced = IsAdvancedMode();
    BOOL    fAdvanced = IsDlgButtonChecked(hDlg, IDC_USE_ADVANCED);

    // if advanced, build first and third party strings
    if(fAdvanced)
    {
        WCHAR   szBuffer[MAX_PATH];

        wnsprintf(szBuffer, ARRAYSIZE( szBuffer), L"IE6-P3PV1/settings: always=%c%s",
                        MapRadioToPref(hDlg, IDC_FIRST_ACCEPT),
                        IsDlgButtonChecked(hDlg, IDC_SESSION_OVERRIDE) ? L" session=a" : L""
                        );

        PrivacySetZonePreferenceW(
                    URLZONE_INTERNET,
                    PRIVACY_TYPE_FIRST_PARTY,
                    PRIVACY_TEMPLATE_ADVANCED,
                    szBuffer);

        wnsprintf(szBuffer, ARRAYSIZE( szBuffer), L"IE6-P3PV1/settings: always=%c%s",
                        MapRadioToPref(hDlg, IDC_THIRD_ACCEPT),
                        IsDlgButtonChecked(hDlg, IDC_SESSION_OVERRIDE) ? L" session=a" : L""
                        );

        PrivacySetZonePreferenceW(
                    URLZONE_INTERNET,
                    PRIVACY_TYPE_THIRD_PARTY,
                    PRIVACY_TEMPLATE_ADVANCED,
                    szBuffer);

        // tell wininet to refresh itself
        InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
    }
    else if ( fWasAdvanced && !fAdvanced)
    {
        PrivacySetZonePreferenceW(
            URLZONE_INTERNET,
            PRIVACY_TYPE_FIRST_PARTY,
            PRIVACY_TEMPLATE_MEDIUM, NULL);
        PrivacySetZonePreferenceW(
            URLZONE_INTERNET,
            PRIVACY_TYPE_THIRD_PARTY,
            PRIVACY_TEMPLATE_MEDIUM, NULL);

        // tell wininet to refresh itself
        InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
    }
}

void OnAdvancedEnable(HWND hDlg)
{
    BOOL fEnabled = IsDlgButtonChecked(hDlg, IDC_USE_ADVANCED);

    // if restricted, disable checkbox and force all others disabled
    if(g_restrict.fPrivacySettings)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_USE_ADVANCED), FALSE);
        fEnabled = FALSE;
    }

    EnableWindow(GetDlgItem(hDlg, IDC_FIRST_ACCEPT), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_FIRST_DENY), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_FIRST_PROMPT), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_THIRD_ACCEPT), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_THIRD_DENY), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_THIRD_PROMPT), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_SESSION_OVERRIDE), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_TX_FIRST), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_TX_THIRD), fEnabled);
}

INT_PTR CALLBACK PrivAdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            OnAdvancedInit(hDlg);
            OnAdvancedEnable(hDlg);
           
            if( IsOS(OS_WHISTLERORGREATER))
            {
                HICON hIcon = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_PRIVACY_XP));
                if( hIcon != NULL)
                    SendDlgItemMessage(hDlg, IDC_PRIVACY_ICON, STM_SETICON, (WPARAM)hIcon, 0);
                // icons loaded with LoadIcon never need to be released
            }
           
            return TRUE;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
         
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    if(FALSE == g_restrict.fPrivacySettings)
                    {
                        OnAdvancedOk(hDlg);
                    }
                    // fall through

                case IDCANCEL:
                    EndDialog(hDlg, IDOK == LOWORD(wParam));
                    return 0;

                case IDC_FIRST_ACCEPT:
                case IDC_FIRST_PROMPT:
                case IDC_FIRST_DENY:
                    CheckRadioButton(hDlg, IDC_FIRST_ACCEPT, IDC_FIRST_PROMPT, LOWORD(wParam));
                    return 0;

                case IDC_THIRD_ACCEPT:
                case IDC_THIRD_PROMPT:
                case IDC_THIRD_DENY:
                    CheckRadioButton(hDlg, IDC_THIRD_ACCEPT, IDC_THIRD_PROMPT, LOWORD(wParam));
                    return 0;

                case IDC_USE_ADVANCED:
                    OnAdvancedEnable(hDlg);
                    return 0;

                case IDC_PRIVACY_EDIT:
                    DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_PRIVACY_PERSITE),
                             hDlg, PrivPerSiteDlgProc);
                    return 0;
            }
            break;
    }
    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////////////
//
// Privacy pane
//
///////////////////////////////////////////////////////////////////////////////////////

#define PRIVACY_LEVELS          6
#define SLIDER_LEVEL_CUSTOM     6

TCHAR szPrivacyLevel[PRIVACY_LEVELS + 1][30];
TCHAR szPrivacyDescription[PRIVACY_LEVELS + 1][400];

typedef struct _privslider {

    DWORD_PTR   dwLevel;
    BOOL        fAdvanced;
    BOOL        fCustom;
    HFONT       hfontBolded;
    BOOL        fEditDisabled;

} PRIVSLIDER, *PPRIVSLIDER;

void EnablePrivacyControls(HWND hDlg, BOOL fCustom)
{
    WCHAR szBuffer[256];

    if( fCustom)
        MLLoadString( IDS_PRIVACY_SLIDERCOMMANDDEF, szBuffer, ARRAYSIZE( szBuffer));
    else
        MLLoadString( IDS_PRIVACY_SLIDERCOMMANDSLIDE, szBuffer, ARRAYSIZE( szBuffer));

    SendMessage(GetDlgItem(hDlg, IDC_PRIVACY_SLIDERCOMMAND), WM_SETTEXT, 
                0, (LPARAM)szBuffer);
     
    // slider disabled when custom
    EnableWindow(GetDlgItem(hDlg, IDC_LEVEL_SLIDER),       !fCustom);
    ShowWindow(GetDlgItem(hDlg, IDC_LEVEL_SLIDER),         !fCustom);

    // default button enabled with custom
    EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_DEFAULT),     fCustom);

    // if restricted, force slider and defaults disabled
    if(g_restrict.fPrivacySettings)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_DEFAULT), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LEVEL_SLIDER),    FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_IMPORT),  FALSE);
    }
}

PPRIVSLIDER OnPrivacyInit(HWND hDlg)
{
    DWORD   i;
    PPRIVSLIDER pData;
    DWORD dwRet, dwType, dwSize, dwValue;

    // allocate storage for the font and current level
    pData = new PRIVSLIDER;
    if(NULL == pData)
    {
        // doh
        return NULL;
    }
    pData->dwLevel = -1;
    pData->hfontBolded = NULL;
    pData->fAdvanced = IsAdvancedMode();
    pData->fCustom = FALSE;
    pData->fEditDisabled = FALSE;

    // 
    // Set the font of the name to the bold font
    //

    // find current font
    HFONT hfontOrig = (HFONT) SendDlgItemMessage(hDlg, IDC_LEVEL, WM_GETFONT, (WPARAM) 0, (LPARAM) 0);
    if(hfontOrig == NULL)
        hfontOrig = (HFONT) GetStockObject(SYSTEM_FONT);

    // build bold font
    if(hfontOrig)
    {
        LOGFONT lfData;
        if(GetObject(hfontOrig, SIZEOF(lfData), &lfData) != 0)
        {
            // The distance from 400 (normal) to 700 (bold)
            lfData.lfWeight += 300;
            if(lfData.lfWeight > 1000)
                lfData.lfWeight = 1000;
            pData->hfontBolded = CreateFontIndirect(&lfData);
            if(pData->hfontBolded)
            {
                // the zone level and zone name text boxes should have the same font, so this is okat
                SendDlgItemMessage(hDlg, IDC_LEVEL, WM_SETFONT, (WPARAM) pData->hfontBolded, (LPARAM) MAKELPARAM(FALSE, 0));
            }
        }
    }

    // initialize slider
    SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_SETRANGE, (WPARAM) (BOOL) FALSE, (LPARAM) MAKELONG(0, PRIVACY_LEVELS - 1));
    SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_SETTICFREQ, (WPARAM) 1, (LPARAM) 0);

    // initialize strings for levels and descriptions
    for(i=0; i<PRIVACY_LEVELS + 1; i++)
    {
        MLLoadString(IDS_PRIVACY_LEVEL_NO_COOKIE + i, szPrivacyLevel[i], ARRAYSIZE(szPrivacyLevel[i]));
        MLLoadString(IDS_PRIVACY_DESC_NO_COOKIE + i,  szPrivacyDescription[i], ARRAYSIZE(szPrivacyDescription[i]));
    }

    //
    // Get current internet privacy level
    //
    DWORD dwError, dwTemplateFirst, dwTemplateThird;


    // read first party setting
    dwError = PrivacyGetZonePreferenceW(
                    URLZONE_INTERNET,
                    PRIVACY_TYPE_FIRST_PARTY,
                    &dwTemplateFirst,
                    NULL,
                    NULL);

    if(dwError != ERROR_SUCCESS)
    {
        dwTemplateFirst = PRIVACY_TEMPLATE_CUSTOM;
    }

    // read third party setting
    dwError = PrivacyGetZonePreferenceW(
                    URLZONE_INTERNET,
                    PRIVACY_TYPE_THIRD_PARTY,
                    &dwTemplateThird,
                    NULL,
                    NULL);

    if(dwError != ERROR_SUCCESS)
    {
        dwTemplateThird = PRIVACY_TEMPLATE_CUSTOM;
    }

    if(dwTemplateFirst == dwTemplateThird && dwTemplateFirst != PRIVACY_TEMPLATE_CUSTOM)
    {
        // matched template values, set slider to template level
        pData->dwLevel = dwTemplateFirst;

        if(dwTemplateFirst == PRIVACY_TEMPLATE_ADVANCED)
        {
            pData->fAdvanced = TRUE;
            pData->dwLevel = SLIDER_LEVEL_CUSTOM;
        }
    }
    else
    {
        // make custom end of list
        pData->dwLevel = SLIDER_LEVEL_CUSTOM;
        pData->fCustom = TRUE;
    }

    // move slider to right spot
    SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)pData->dwLevel);

    // Enable stuff based on mode
    EnablePrivacyControls(hDlg, ((pData->fAdvanced) || (pData->fCustom)));

    // save off struct
    SetWindowLongPtr(hDlg, DWLP_USER, (DWORD_PTR)pData);

    dwSize = sizeof(dwValue);
    dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PRIVACYPS_PATHEDIT, REGSTR_PRIVACYPS_VALUEDIT, &dwType, &dwValue, &dwSize);

    if (ERROR_SUCCESS == dwRet && 1 == dwValue && REG_DWORD == dwType)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_EDIT), FALSE);
        pData->fEditDisabled = TRUE;
    }

    return pData;
}

void OnPrivacyApply(HWND hDlg, PPRIVSLIDER pData)
{
    if(pData->fCustom || pData->fAdvanced)
    {
        // nothing else to do
        return;
    }

    DWORD_PTR dwPos = SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_GETPOS, 0, 0);

    if(pData->dwLevel != dwPos)
    {
        DWORD   dwCookieAction = URLPOLICY_DISALLOW;

        // Set privacy settings
        PrivacySetZonePreferenceW(
                URLZONE_INTERNET,
                PRIVACY_TYPE_FIRST_PARTY,
                (DWORD)dwPos,
                NULL);

        PrivacySetZonePreferenceW(
                URLZONE_INTERNET,
                PRIVACY_TYPE_THIRD_PARTY,
                (DWORD)dwPos,
                NULL);

        // tell wininet to refresh itself
        InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

        // save new level as "current"
        pData->dwLevel = dwPos;
    }
}

void OnPrivacySlider(HWND hDlg, PPRIVSLIDER pData)
{
    DWORD dwPos;

    if(pData->fCustom || pData->fAdvanced)
    {
        dwPos = SLIDER_LEVEL_CUSTOM;
    }
    else
    {
        dwPos = (DWORD)SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_GETPOS, 0, 0);

        if(dwPos != pData->dwLevel)
        {
            ENABLEAPPLY(hDlg);
        }

        // enable default button if slider moved off medium
        BOOL fEnable = FALSE;

        if(dwPos != PRIVACY_TEMPLATE_MEDIUM && FALSE == g_restrict.fPrivacySettings)
        {
            fEnable = TRUE;
        }
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_DEFAULT), fEnable);
    }

    if (PRIVACY_TEMPLATE_NO_COOKIES == dwPos || PRIVACY_TEMPLATE_LOW == dwPos || pData->fEditDisabled)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_EDIT), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_EDIT), TRUE);
    }

    // on Mouse Move, change the level description only
    SetDlgItemText(hDlg, IDC_LEVEL_DESCRIPTION, szPrivacyDescription[dwPos]);
    SetDlgItemText(hDlg, IDC_LEVEL, szPrivacyLevel[dwPos]);
}

void OnPrivacyDefault( HWND hDlg, PPRIVSLIDER pData)
{
    // enable controls correctly
    pData->fAdvanced = FALSE;
    pData->fCustom = FALSE;
    EnablePrivacyControls(hDlg, FALSE);

    // set slider to medium
    SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)PRIVACY_TEMPLATE_MEDIUM);

    // update descriptions
    pData->dwLevel = SLIDER_LEVEL_CUSTOM;       // difference from medium so we get apply button
    OnPrivacySlider(hDlg, pData);

    //  Give slider focus (if default button has focus and gets disabled, 
    //    alt-key dialog control breaks)
    SendMessage( hDlg, WM_NEXTDLGCTL, 
                 (WPARAM)GetDlgItem( hDlg, IDC_LEVEL_SLIDER), 
                 MAKELPARAM( TRUE, 0)); 

}

INT_PTR CALLBACK PrivacyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PPRIVSLIDER pData = (PPRIVSLIDER)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // initialize slider
            pData = OnPrivacyInit(hDlg);
            if(pData)
            {
                OnPrivacySlider(hDlg, pData);
            }

            if( IsOS(OS_WHISTLERORGREATER))
            {
                HICON hIcon = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_PRIVACY_XP));
                if( hIcon != NULL)
                    SendDlgItemMessage(hDlg, IDC_PRIVACY_ICON, STM_SETICON, (WPARAM)hIcon, 0);
                // icons loaded with LoadIcon never need to be released
            }
            return TRUE;

        case WM_VSCROLL:
            // Slider Messages
            OnPrivacySlider(hDlg, pData);
            return TRUE;

        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            ASSERT(lpnm);

            switch (lpnm->code)
            {
                case PSN_QUERYCANCEL:
                case PSN_KILLACTIVE:
                case PSN_RESET:
                    return TRUE;

                case PSN_APPLY:
                    // Hitting the apply button runs this code
                    OnPrivacyApply(hDlg, pData);
                    break;
            }
            break;
        }
        case WM_DESTROY:
        {
            if(pData)
            {
                if(pData->hfontBolded)
                    DeleteObject(pData->hfontBolded);

                delete pData;
            }
            break;
        }
        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
         
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_PRIVACY_DEFAULT:
                    OnPrivacyDefault( hDlg, pData);
                    return 0;

                case IDC_PRIVACY_ADVANCED:
                {
                    BOOL fWasAdvanced = IsAdvancedMode();
                    
                    // show advanced
                    if( DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_PRIVACY_ADVANCED),
                                  hDlg, PrivAdvancedDlgProc))
                    {
                        // refresh advanced and reset slider/controls
                        pData->fAdvanced = IsAdvancedMode();
                        if(pData->fAdvanced)
                        {
                            // no longer have a slider template
                            pData->fCustom = FALSE;
                            pData->dwLevel = SLIDER_LEVEL_CUSTOM;

                            EnablePrivacyControls(hDlg, (pData->fCustom || pData->fAdvanced));
                            OnPrivacySlider(hDlg, pData);

                            //  Give advanced button focus (if slider has focus and gets disabled, 
                            //    alt-key dialog control breaks)
                            SendMessage( hDlg, WM_NEXTDLGCTL, 
                                         (WPARAM)GetDlgItem( hDlg, IDC_PRIVACY_ADVANCED), 
                                         MAKELPARAM( TRUE, 0)); 
                        }
                        else if (!pData->fAdvanced && fWasAdvanced)
                        {
                            OnPrivacyDefault( hDlg, pData);
                        }
                    }
                    return 0;
                }
                case IDC_PRIVACY_IMPORT:
                {
                    WCHAR szDialogTitle[MAX_PATH_URL];
                    WCHAR szFileExpr[MAX_PATH_URL];
                    MLLoadString( IDS_PRIVACYIMPORT_TITLE, szDialogTitle, ARRAYSIZE(szDialogTitle));
                    int iFileExprLength = MLLoadString( IDS_PRIVACYIMPORT_FILEEXPR, szFileExpr, ARRAYSIZE(szFileExpr));
                    szFileExpr[ iFileExprLength + 1] = L'\0';  // the extra \0 in the resource gets clipped.. replace it.
                    WCHAR szFile[MAX_PATH_URL];
                    szFile[0] = L'\0';
                    OPENFILENAME ofn;
                    memset((void*)&ofn, 0, sizeof(ofn));
                    ofn.lStructSize = sizeof( ofn);
                    ofn.hwndOwner = hDlg;
                    ofn.lpstrFilter = szFileExpr;
                    ofn.lpstrFile = szFile;
                    ofn.nMaxFile = ARRAYSIZE(szFile);
                    ofn.lpstrTitle = szDialogTitle;
                    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

                    if( 0 != GetOpenFileName(&ofn))
                    {
                        BOOL fParsePrivacyPreferences = TRUE;
                        BOOL fParsePerSiteRules = TRUE;
                        BOOL fResults;

                        fResults = ImportPrivacySettings( ofn.lpstrFile, 
                                     &fParsePrivacyPreferences, &fParsePerSiteRules);
                                     
                        if( fResults == FALSE
                            || (fParsePrivacyPreferences == FALSE 
                                && fParsePerSiteRules == FALSE))
                        {
                            MLShellMessageBox( hDlg, MAKEINTRESOURCE(IDS_PRIVACYIMPORT_FAILURE), 
                                    MAKEINTRESOURCE(IDS_PRIVACYIMPORT_TITLE),
                                    MB_OK | MB_APPLMODAL | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
                        }
                        else
                        {
                            if( fParsePrivacyPreferences)
                            {
                                pData->fCustom = TRUE;
                                pData->fAdvanced = FALSE;
                                EnablePrivacyControls( hDlg, pData->fCustom);
                                OnPrivacySlider(hDlg, pData);
                            }
                            MLShellMessageBox( hDlg, MAKEINTRESOURCE(IDS_PRIVACYIMPORT_SUCCESS), 
                                    MAKEINTRESOURCE(IDS_PRIVACYIMPORT_TITLE),
                                    MB_OK | MB_APPLMODAL | MB_SETFOREGROUND);
                        }
                    }
                    return 0;       
                }
                case IDC_PRIVACY_EDIT:
                    DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_PRIVACY_PERSITE),
                              hDlg, PrivPerSiteDlgProc);
                    return 0;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inetcpld.rc
//
#define IDD_GENERAL                     100
#define IDD_SECURITY_ADD_SITES          101
#define IDD_COLORS                      102
#define IDD_SECURITY_INTRANET           103
#define IDC_GENERAL_APPEARANCE_UNDERLINE_LINKS_CHECKBOX 104
#define IDC_GENERAL_APPEARANCE_GROUPBOX 105
#define IDC_GENERAL_MULTIMEDIA_PICTURES_CHECKBOX 106
#define IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX 107
#define IDC_GENERAL_APPEARANCE_COLOR_TEXT 108
#define IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND 109
#define IDC_GENERAL_APPEARANCE_COLOR_LINKS 110
#define IDC_GENERAL_APPEARANCE_COLOR_VISITED_LINKS 111
#define IDC_GENERAL_APPEARANCE_COLOR_HOVER 112
#define IDC_GENERAL_MULTIMEDIA_VIDEOS_CHECKBOX 113
#define IDC_GENERAL_SHOW_TEXT_ON_TOOLBAR 114
#define IDC_GENERAL_MULTIMEDIA_GROUPBOX 115
#define IDC_GENERAL_SHOW_BACKGROUNG_BITMAPS_CHECKBOX 116
#define IDC_GENERAL_SHOW_GROUPBOX       117
#define IDD_SECURITY_CUSTOM_SETTINGS    118
#define IDD_CONNECTION                  200
#define IDC_CONNECTION_DIALING_GROUPBOX 201
#define IDC_CONNECTION_PROXY_GROUPBOX   202
#define IDC_CONNECTION_PROXY_SETTINGS_BTN 203
#define IDC_CHOOSE_CONNECTOID           205
#define IDC_ENABLE_AUTODISCONNECT       206
#define IDC_IDLE_SPIN                   207
#define IDC_IDLE_TIMEOUT                208
#define IDC_ADD                         209
#define IDC_PROPERTIES                  210
#define IDC_INTERVAL                    211
#define IDC_TX_CHOOSE_CONNECTOID        212
#define IDC_GRP_SETTINGS2               213
#define IDC_TX_AUTODISCONNECT           214
#define IDC_CONNECT                     215
#define IDC_CONNECT_SPIN                216
#define IDC_INTERVAL_SPIN               217
#define IDC_PROXY_EXCEPTIONS_GROUPBOX   218
#define IDC_CONNECTION_AUTOCONFIG       219
#define IDD_PROGRAMS                    300
#ifndef UNIX
#define IDC_PROGRAMS_MAIL_COMBO         301
#define IDC_PROGRAMS_NEWS_COMBO         302
#define IDC_PROGRAMS_CALL_COMBO         313
#else
#define IDC_EDIT_PROGRAMS_MAIL          301
#define IDC_EDIT_PROGRAMS_NEWS          302
#define IDC_EDIT_PROGRAMS_VSOURCE       313
#endif
#define IDC_CHECK_ASSOCIATIONS_CHECKBOX 303
#define IDC_PROGRAMS_CALENDAR_COMBO     304
#define IDC_PROGRAMS_MAILANDNEWS_GROUPBOX 305
#define IDC_PROGRAMS_CONTACT_COMBO      306
#define IDC_PROGRAMS_WALLET_GROUPBOX    307
#define IDC_PROGRAMS_WALLET_PAYBUTTON   308
#define IDC_PROGRAMS_WALLET_ADDRBUTTON  309
#define IDC_PROGRAMS_IE_IS_FTPCLIENT    310
#define IDC_INTERNET_CALLS_GROUPBOX     311
#define IDC_PROGRAMS_MAIL_COMBO3        312
#ifdef UNIX
#define IDC_OE_MAIL                     320
#define IDC_MAIL_FIND                   314
#define IDC_MAIL_EDIT                   315
#define IDC_OE_NEWS                     321
#define IDC_NEWS_FIND                   316
#define IDC_NEWS_EDIT                   317
#define IDC_VSOURCE_FIND                318
#define IDC_VSOURCE_EDIT                319
#endif
#define IDC_PROGRAMS_WALLET_SETTINGS    320
#define IDC_AUTOSUGGEST_SETTINGS        321
#define IDD_PLACES                      400
#define IDC_PLACES_CUSTOMIZE_GROUPBOX   401
#define IDC_PLACES_CURRENT              402
#define IDC_USEBLANK                    404
#define IDC_PLACES_NAME                 405
#define IDC_PLACES_ADDRESS              406
#define IDC_PLACES_HISTORY_DAYS         407
#define IDC_PLACES_HISTORY_SPIN         408
#define IDC_PLACES_HISTORY_EMPTY        409
#define IDC_PLACES_HISTORY_GROUPBOX     410
#define IDC_PLACES_VIEW_HISTORY_BUTTON  411
#define IDD_SECURITY                    500
#define IDC_SECURITY_JAVA_CHECKBOX      501
#define IDC_SECURITY_ACTIVEX_SCRIPTING_CHECKBOX 503
#define IDC_SECURITY_ACTIVEX_CONTROLS_CHECKBOX 504
#define IDC_SECURITY_CODE_DOWNLOAD_BUTTON 505
#define IDC_SECURITY_SITES_BUTTON       511
//#define IDC_SECURITY_PERSONAL_BUTTON    512
#define IDC_SECURITY_WARNINGS_BUTTON    514
#define IDC_SECURITY_PUBLISHERS_BUTTON  515
#define IDC_SECURITY_ACTIVE_CONTENT_GROUPBOX 516
#define IDC_SECURITY_ACTIVE_CONTENT_GROUPBOX2 517
#define IDC_SECURITY_CLEAR_SSL_CACHE_BUTTON 518
#define IDD_ADVANCED                    600
#define IDC_RATINGS_TURN_ON             601
#define IDC_ADVANCED_MOVE_CACHE_LOCATION 605
#define IDC_ADVANCED_CACHE_MB           606
#define IDC_ADVANCED_RATINGS_GROUPBOX   607
#define IDC_ADVANCED_CACHE_LOCATION     608
#define IDC_ADVANCED_CACHE_BROWSE       609
#define IDC_ADVANCED_CACHE_PERCENT      610
#define IDC_ADVANCED_CACHE_TEXT_PERCENT 611
#define IDC_ADVANCED_CACHE_EMPTY        612
#define IDC_ADVANCED_CACHE_ONCEPERSESS  613
#define IDC_ADVANCED_CACHE_NEVER        614
#define IDC_ADVANCED_CACHE_AUTOMATIC    615
#define IDC_ADVANCED_CACHE_FILES_BUTTON 616
#define IDC_ADVANCED_CACHE_ALWAYS       618
#define IDC_ADVANCED_RATINGS_BUTTON     619
#define IDC_ADVANCED_TEMP_FILES_GROUPBOX 620
#define IDC_RATINGS_TEXT                621
#define IDC_RATINGS_ICON                622
#define IDC_CONNECTION_AUTO_CONFIG_BUTTON 623
#define IDC_CACHE_DELETE_FILES          624
#define IDC_ADVANCED_CACHE_STATUS       625
#define IDC_ADVANCED_CACHE_SIZE_SPIN    626
#define IDC_CACHE_DELETE_COOKIES        627
#define IDD_TEMP_FILES                  700
#define IDC_TEMPORARY_INTERNET_FILES_SETTINGS_GROUPBOX 701
#define IDD_AUTOSUGGEST_SETTINGS        750
#define IDD_WALLET_SETTINGS             751
#define IDC_AUTOSUGGEST_ENABLEADDR      756
#define IDC_AUTOSUGGEST_ENABLEFORM      757
#define IDC_AUTOSUGGEST_CLEARFORM       758
#define IDC_AUTOSUGGEST_SAVEPASSWORDS   759
#define IDC_AUTOSUGGEST_CLEARPASSWORDS  760
#define IDC_AUTOSUGGEST_PROMPTPASSWORDS 761
#define IDC_AUTOSUGGEST_CLEAR_TEXT      762
#define IDC_AUTOSUGGEST_FOR_GROUP       763
#define IDC_AUTOSUGGEST_HISTORY_GROUP   764
#define IDC_AUTOSUGGEST_STATIC_TEXT     765
#define IDD_SAFETY                      800
#define IDC_SAFETY_GROUPLABEL           801
#define IDC_SAFETY_LEVEL_HIGH           802
#define IDC_SAFETY_LEVEL_MEDIUM         803
#define IDC_SAFETY_LEVEL_LOW            804
#define IDD_FONTS                       1000
#define IDC_FONTS_SCRIPTS_GROUPBOX      1001
#define IDC_FONTS_CHAR_SET_COMBO        1002
#define IDC_BUTTON_REMOVE               1003
#define IDC_FONTS_PROP_FONT_LIST        1005
#define IDC_FONTS_FIXED_FONT_LIST       1007
#define IDC_CHECK_PROXY                 1008
#define IDC_EDIT_ADD_SITE               1010
#define IDC_CHECK_USEINTRANET           1011
#define IDC_CHECK_USE_MY_STYLESHEET     1012
#define IDC_COMBO_ZONE                  1013
#define IDC_RADIO_HIGH                  1014
#define IDC_RADIO_MEDIUM                1015
#define IDC_RADIO_LOW                   1016
#define IDC_RADIO_CUSTOM                1017
#define IDC_BUTTON_SETTINGS             1018
#define IDC_BUTTON_ADD_SITES            1019
#define IDC_BUTTON_APPLY                1020
#define IDC_COMBO_RESETLEVEL            1022
#define IDC_CHECK_REQUIRE_SERVER_VERIFICATION 1023
#define IDC_TREE_SECURITY_SETTINGS      1024
#define IDC_GROUP_CURRENT_SETTINGS      1025
#define IDC_LIST_WEBSITES               1026
#define IDC_CHECK_SOFTWARE_PUBLISHING   1027
#define IDC_BUTTON_ADD                  1028
#define IDC_LEVEL_GROUPBOX              1029
#define IDC_STATIC_SLIDERMOVETEXT       1030
#define IDC_SEC_STATIC_CURRENT_LEVEL    1031
#define IDD_PROXY_SETTINGS              1100
#define IDC_ENABLE_SECURITYCHECK        1101
#define IDC_PROXY_ENABLE                1102
#define IDC_PROXY_HTTP_ADDRESS          1103
#define IDC_PROXY_OVERRIDE              1104
#define IDC_PROXY_SECURITY_ADDRESS      1105
#define IDC_PROXY_FTP_ADDRESS           1106
#define IDC_PROXY_GOPHER_ADDRESS        1107
#define IDC_PROXY_HTTP_PORT             1108
#define IDC_PROXY_SECURITY_PORT         1109
#define IDC_PROXY_FTP_PORT              1110
#define IDC_PROXY_GOPHER_PORT           1111
#define IDC_PROXY_SOCKS_ADDRESS         1112
#define IDC_PROXY_SOCKS_PORT            1113
#define IDC_PROXY_HTTP_CAPTION          1114
#define IDC_PROXY_SECURITY_CAPTION      1115
#define IDC_PROXY_FTP_CAPTION           1116
#define IDC_PROXY_GOPHER_CAPTION        1117
#define IDC_PROXY_USE_SAME_SERVER       1118
#define IDC_PROXY_OMIT_LOCAL_ADDRESSES  1119
#define IDC_PROXY_SOCKS_CAPTION         1120
#define IDD_AUTOCNFG_SETTINGS           1140
#define IDC_CONFIGJS_ADDR               1141
#define IDC_CONFIGTIMER                 1142
#define IDC_CONFIGOPTIMIZE              1143
#define IDD_SITECERTS                   1200
#define IDC_CERTLIST                    1201
#define IDC_VIEWCERT                    1202
#define IDC_DELETECERT                  1203
#define IDC_INTL                        1300
#define IDI_HOME                        1301
#define IDI_TOOLBAR                     1302
#define IDI_HISTORY                     1303
#define IDI_FONTS                       1304
#define IDI_CRYPTOGRAPHY                1305
#define IDI_RATINGS                     1306
#define IDI_PRIVACY                     1307
#define IDI_MAILANDNEWS                 1308
#define IDI_VIEWERS                     1309
#define IDI_CERTIFICATES                1310
#define IDI_OTHER                       1311
#define IDI_MULTIMEDIA                  1312
#define IDI_ZONE_INTERNET               1313
#define IDI_DIALUP                      1314
#define IDI_PROXY                       1315
#define IDI_SAFETY                      1317
#define IDI_APPEARANCE                  1318
#define IDI_CACHE                       1319
#define IDI_SAFECONTENT                 1320
#define IDI_ACTIVECONTENT               1321
#define IDI_WALLET                      1322
#define IDI_USERS                       1323
#define IDI_ICON1_PLACEHOLDER           1324
#define IDI_PROGRAMS                    1325
#define IDC_GENERAL_APPEARANCE_COLOR_TEXT_LABEL 1400
#define IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND_LABEL 1401
#define IDC_ACCEPTENABLE                1405
#define IDC_ACCEPTDISABLE               1406
#define IDC_NOTACCEPT                   1407
#define IDC_TYPE_TEXT                   1408
#define IDC_ADDR_TEXT                   1409
#define IDC_PORT_TEXT                   1410
#define IDC_EXCEPT_TEXT                 1411
#define IDC_PROXY_ICON1                 1412
#define IDC_PROXY_ICON2                 1413
#define IDC_EXCEPT2_TEXT                1414
#define IDC_GENERAL_LINKS_GROUPBOX      1415
#define IDD_CRYPT                       1416
#define IDC_ALLOW_SSL2                  1417
#define IDC_ALLOW_SSL3                  1418
//#define IDC_ALLOW_PCT                   1419
#define IDC_DONT_WRITE_SSL_PAGES_TO_CACHE 1420
#define IDC_GROUP_PRINT                 1425
#define IDC_PRINT_BACKGROUND            1426
#define IDC_PRINT_BCKGRND_IMGS          1427
#define IDC_PRINT_SHORTCUT              1428
#define IDC_PRINT_TABLEHDFT             1429
#define IDC_PRINT_RECURSIVE             1432
#define IDC_FONTS_PROP_SAMPLE           1435
#define IDC_FONTS_FIXED_SAMPLE          1436
#define IDC_ADVANCEDTREE                1439
#define IDC_LANGUAGE                    1440
#define IDC_LANG_ACCEPT_LIST            1441
#define IDC_LANG_MOVE_UP_BUTTON         1442
#define IDC_LANG_MOVE_DOWN_BUTTON       1443
#define IDC_LANG_ADD_BUTTON             1444
#define IDC_LANG_REMOVE_BUTTON          1445
#define IDC_LANG_AVAILABLE_LIST         1446
#define IDC_LANG_USER_DEFINED_EDIT      1447
#define IDC_USE_IE40_SEARCH             1448
#define IDC_DELETE_SUB                  1449
#define IDC_PROXY_EXCEPTIONS            1450
#define IDC_PROXY_AUTO_URL              1451
#define IDC_PROXY_AUTO_RELOAD           1452
#define IDC_CONNECTION_WIZARD           1453
#define IDC_GRP_DIALUPSETTINGS          1454
#define IDC_GRP_LANSETTINGS             1455
#define IDC_OFFLINE                     1456
#define IDC_MODEM_SETTINGS              1457
#define IDC_NO_PROXY                    1458
#define IDC_PROXY_ADDR                  1460
#define IDC_PROXY_PORT                  1461
#define IDC_UNATTENDED                  1463
#define IDC_USER                        1464
#define IDC_PASSWORD                    1465
#define IDC_DOMAIN                      1466
#define IDC_FILENAME                    1466
#define IDC_PASSWORD2                   1467
#define IDC_ADDRESS_TEXT                1471
#define IDC_TX_USER                     1473
#define IDC_TX_PASSWORD                 1474
#define IDC_TX_DOMAIN                   1475
#define IDC_TX_CONNECT                  1476
#define IDC_TX2_CONNECT                 1477
#define IDC_TX_INTERVAL                 1478
#define IDC_TX2_INTERVAL                1479
//#define IDC_AUTOPROXY                   1481
#define IDC_COLORS                      1483
#define IDC_USEDEFAULT                  1485
#define IDC_USECURRENT                  1486
#define IDC_START_ADDRESS               1487
#define IDC_HISTORY_VIEW                1488
#define IDC_HISTORY_CLEAR               1489
#define IDC_CACHE_SETTINGS              1490
#define IDC_CACHE_VIEW_FILES            1491
#define IDC_HISTORY_DAYS                1492
#define IDC_HISTORY_SPIN                1493
#define IDC_FONTS                       1494
#define IDC_LANGUAGES                   1495
#define IDC_ACCESSIBILITY               1496
#define IDC_GROUP_FORMATTING            1497
#define IDC_CHECK_COLOR                 1498
#define IDC_CHECK_FONT_STYLE            1499
#define IDC_CHECK_FONT_SIZE             1500
#define IDC_AUTO_CONFIG_URL             1501
#define IDC_AUTO_REFRESH                1502
#define IDC_CUSTOM_TEXT                 1505
#define IDC_CHECK_NETWORK_CLIENT        1506
#define IDC_CHECK_NETWORK_SERVER        1507
#define IDC_CHECK_SECURE_EMAIL          1508
#define IDC_COMBO_SERVICE               1510
#define IDC_ADVANCED_STATIC             1512
#define IDC_ZONE_GROUPBOX               1513
#define IDC_DEFAULT_SETTINGS_GROUPBOX   1514
#define IDC_CONTACT_LIST_GROUPBOX       1515
#define IDC_ZONE_DESCRIPTION            1516
#define IDC_ADDSITES_GROUPBOX           1517
#define IDC_ZONE_ICON                   1518
#define IDC_UNDERLINE_LINKS_COMBO       1522
#define IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX 1524
#define IDC_STYLESHEET_BROWSE           1525
#define IDC_RESTORE_DEFAULT             1526
#define IDC_GROUP_STYLESHEET            1528
#define IDC_EDIT_STYLESHEET             1529
#define IDC_EDIT_PROFILE                1530
#define IDC_ZONE_RESET                  1531
#define IDC_INTRANET_ADVANCED           1532
#define IDC_ADVANCED_DOWNLOADED_CONTROLS 1533
#define IDC_JAVACUSTOM                  1534
#define IDC_CERT_BROWSE                 1535
#define IDC_USE_EXISTING                1536
#define IDC_USE_FILE                    1537
#define IDC_CHECK_UNC                   1540
#define IDC_CHECK_ENABLE_CERT           1541
#define IDC_RESET_SHARING               1542
#define IDC_AUTOCONFIG                  1544
#define IDC_AUTOCONFIG_TX               1545
#define IDC_USE_LAN                     1546
#define IDC_INTRANET                    1546
#define IDC_INTERNET                    1547
#define IDC_AUTOCNFG_ADVANCED           1548
#define IDC_DIALUP_REMOVE               1549
#define IDC_DIALUP_COMBO                1550
#define IDC_DIALUP_ADD                  1552
#define IDC_DIALUP_PROP                 1553
#define IDC_AUTODIAL                    1554
#define IDC_PROXY_ADVANCED              1555
#define IDC_EXIT_DISCONNECT             1556
#define IDC_TX_LOGON                    1557
#define IDC_CONN_LIST                   1559
#define IDC_RAS_SETTINGS                1560
#define IDC_GRP_DIAL                    1561
#define IDC_GRP_NET                     1562
#define IDC_TX_TIMES                    1563
#define IDC_TX_SECONDS                  1564
#define IDC_NO_AUTOCONFIG               1565
#define IDC_LIST_ZONE                   1566
#define IDC_SLIDER                      1567
#define IDC_LEVEL_DESCRIPTION           1568
#define IDC_NOPROXY                     1568
#define IDC_CONFIGSCRIPT                1569
#define IDC_MANUAL                      1570
#define IDC_CONFIG_ADDR                 1571
#define IDC_CONFIGADDR_TX               1572
#define IDC_AUTODISCOVER                1573
#define IDC_ENABLE_SECURITY             1574
#define IDC_STATIC_EMPTY                1575
#define IDC_ZONELABEL                   1576
#define IDC_LEVEL_NAME                  1578
#define IDC_LAN_SETTINGS                1580
#define IDS_DEFAULT_TEXT                1581
#define IDC_SET_DEFAULT                 1582
#define IDC_DIAL_DEF_ISP                1583
#define IDC_DIAL_ADVANCED               1584
#define IDC_DIAL_DEF_TXT                1585
#define IDC_GRP_PROXY                   1586
#define IDC_TX_PROPS                    1587
#define IDC_CON_SHARING                 1588
#define IDC_LANG_UI_PREF                1600
#define IDC_COMBO_UILANG                1601
#define IDC_LANG_CURSEL                 1602
#define IDC_LANG_DESCCURSEL             1603
#define IDC_LANG_ADDSPK                 1604
#define IDC_PROGRAMS_HTMLEDITOR_COMBO   1610
#define IDC_GRP_AUTO                    1611
#define IDC_DONT_USE_CONNECTION         1612
#define IDC_FONTS_PROP_FONT_COMBO       1613
#define IDC_FONTS_FIXED_FONT_COMBO      1614
#define IDC_FONTS_DEFAULT_LANG_TEXT     1615
#define IDC_FONTS_CODE_PAGES_LIST       1616
#define IDC_FONTS_SIZE_FONT_COMBO       1617
#define IDC_FONTS_MIME_FONT_COMBO       1618
#define IDC_FONTS_SETDEFAULT_BUTTON     1619
#define IDD_FONTS_IE4                   1620
#define IDC_DIALUP_NEVER                1621
#define IDC_DIALUP_ON_NONET             1622
#define IDC_DIALUP                      1623
#define IDC_ADVANCED_CACHE_PERCENT_ACC  1624
#define IDC_ERROR_USING_SYSTEM_DIR      4300
#define IDS_SELECT_CACHE                4301
// #define IDS_ERROR_SYSTEM_DIRECTORY      4302
#define IDS_REBOOTING_WARNING           4303
#define IDS_ERROR_REGISTRY_TITLE        4304
#define IDS_ERROR_WARNING_TITLE         4305
// #define IDS_ERROR_MUST_BE_ADMIN         4306
// #define IDS_ERROR_ADMIN_TITLE           4307
#define IDS_REBOOTING_TITLE             4308
// #define IDS_ERROR_REG_MISSING_SYSTEM_DIR 4309
#define IDS_ERROR_INVALID_PATH_MSG      4310
#define IDS_ERROR_INVALID_PATH_TITLE    4311
#define IDS_INTERNET                    4312
#define IDS_DESCRIPTION                 4313
#define IDS_APPNAME                     4314
#define IDS_RNADLL_FILENAME             4316
#define IDS_HELPFILE                    4317
#define IDS_RATINGS_TURN_OFF            4318
#define IDS_RATINGS_TURN_ON             4319
#define IDS_ERROutOfMemory              4320
// #define IDS_ConnectoidNotFound          4321
#define IDS_ConnectoidNotSpecified      4322
#define IDS_USERS                       4323
#define IDS_USERS_DESCRIPTION           4324
#define IDS_ERROR_INVALID_PATH          4325
// #define IDS_ClearCache                  4423
#define IDS_ClearHistory                4424
// #define IDS_SELECTHISTORYFOLDER         4425
#define IDD_NEWSITECERT                 4426
#define IDS_FILETYPES                   4427
#define IDS_FTDLL_FILENAME              4428
// #define IDS_RESTART_EXPLORER            4429
#define IDI_LINKS                       4432
#define IDD_PRINT                       4434
#define IDI_SECURITY                    4440
#define IDI_JAVA                        4441
#define IDI_WARNINGS                    4442
#define IDI_HTMLDOC                     4443
#define IDB_RADIOON                     4445
#define IDI_PRINTER                     4447
#define IDD_LANG                        4448
#define IDD_LANG_ADD                    4449
#define IDD_LANG_CHANGE                 4450
#define IDD_CACHE_EMPTY                 4451
#define IDD_DIALUP                      4452
#define IDD_CONTENT                     4454
#define IDS_DELETE_CERT                 4455
#define IDD_DIALUP_ADVANCED             4456
#define IDD_ACCESSIBILITY               4457
#define IDI_INTERNETCALL                4459
#define IDI_CONGEN                      4460
#define IDI_AUTOCFG                     4461
#define IDS_FONT_SIZE_SMALLEST          4474
#define IDB_BUTTONS                     4474
#define IDS_FONT_SIZE_SMALL             4475
#define IDS_FONT_SIZE_MEDIUM            4476
#define IDS_FONT_SIZE_LARGE             4477
#define IDS_FONT_SIZE_LARGEST           4478
#define IDI_ZONE                        4478
#define IDI_TRUSTED                     4480
#define IDI_UNTRUSTED                   4481
#define IDI_BROWSE                      4482
#define IDI_SEARCH                      4483
#define IDI_SCRIPT                      4485
#define IDI_DOWNLOAD                    4486
#define IDI_INTERNET                    4487
#define IDD_SECSTANDALONE               4488
#define IDI_MESSAGING                   4490
#define IDI_PERSINFO                    4491
#define IDD_PFX_EXPORT                  4493
#define IDD_PFX_IMPORT                  4495
#define IDI_YELLOW                      4496
#define IDI_ACCESS                      4497
#ifdef UNIX
#define IDI_OE                          4498
#define IDI_FONT                        4499
#endif
#define IDS_CLEAR_FORMSUGGEST           4500
#define IDS_CLEAR_FORMPASSWORDS         4501
#define IDS_USER_DEFINED_ERR            4602
#define IDS_LCID_ENG                    4603
#define IDS_USER_DEFINED                4604
#define IDS_MISSING_DLL                 4605
#define IDS_REOPEN_INETCPL              4606
#define IDS_INVALID_PROXY               4607
#define IDS_INVALID_PROXY_TITLE         4608
#define IDS_ICW_NAME                    4609
#define IDI_IMAGE                       4609
#define IDS_NONE                        4610
#define IDS_SIZE_FORMAT                 4612
// #define IDS_NO_AUTOPROXY                4613
#define IDS_SECURITY_WARNING            4614
#define IDS_WARNING                     4615
#define IDS_SECURITY_MINLEVEL           4616
#define IDS_SECURITY_HIGH               4617
#define IDS_SECURITY_MEDIUM             4618
#define IDS_SECURITY_LOW                4619
#define IDS_CERT_NETWORK_CLIENT         4620
#define IDS_CERT_NETWORK_SERVER         4621
#define IDS_CERT_SECURE_EMAIL           4622
#define IDS_CERT_SOFTWARE_PUBLISHING    4623
#define IDS_INVALIDURL                  4624
#define IDS_SECURITY                    4625
#define IDC_ISSUERS_GROUPBOX            4626
// #define IDS_ALWAYS                      4626
#define IDC_INTRANET_GROUPBOX           4627
// #define IDS_NEVER                       4627
// #define IDS_HOVER                       4628
#define IDS_HTTPSREQ                    4629
#define IDS_MAPPINGFAIL                 4630
#define IDS_STYLESHEET_EXT              4631
#define IDS_STYLESHEET_FILTER           4632
#define IDS_FILENOTFOUND                4633
#define IDS_ERROR                       4634
#define IDS_INTERNETOPTIONS             4635
#define IDS_PFX_EXT                     4636
#define IDS_PFX_FILTER                  4637
#define IDS_SITEEXISTS                  4638
#define IDS_INVALIDWILDCARD             4639
#define IDS_CERT_EXPORTOKTEXT           4640
#define IDS_CERT_EXPORTOKTITLE          4641
#define IDS_REVOKEPERMISSIONS           4642
#define IDS_CERT_FILE_INVALID           4643
#define IDC_ENABLE_AUTODIAL             4644
#define IDS_PASSWORDS_NOMATCH           4644
#define IDC_LAN                         4645
//#define IDS_TEMPMOVE                    4645
#define IDS_LAN                         4646
#define IDS_SETTINGS                    4648
#define IDS_LAN_SETTINGS                4649
#define IDS_LAN_SETTINGSPROXY         4650
#define IDI_PHONE                       4651
#define IDI_LAN                         4652
#define IDS_DELETECONNECTOID            4653
//#define IDS_CERT_MANAGER                4654
#define IDS_INVALID_REDIAL_ATTEMPTS     4655
#define IDS_INVALID_REDIAL_WAIT         4656
#define IDS_INVALID_AUTODISCONNECT_TIME 4657
#define IDS_STATIC_ADDSITE              4658
#define IDS_ERROR_MOVE_MSG              4659
#define IDS_ERROR_MOVE_TITLE            4660
#define IDS_ERROR_ARCHITECTURE          4661
#define IDS_ERROR_WRONG_PLACE           4662
//#define IDS_WARNING_USING_SYSTEM_DIR    4663
//#define IDS_ERROR_READONLY              4664
#define IDS_ERROR_STRANGENESS           4665
#define IDS_STATUS_FOLDER_CURRENT       4666
#define IDS_STATUS_FOLDER_NEW           4667
#define IDS_WRITE_WARNING               4668
#define IDS_TEMPLATE_DESC_HI            4669
#define IDS_TEMPLATE_DESC_MED           4670
#define IDS_TEMPLATE_DESC_MEDLOW        4671
#define IDS_TEMPLATE_DESC_LOW           4672
#define IDS_TEMPLATE_DESC_CUSTOM        4673
#define IDS_TEMPLATE_NAME_HI            4674
#define IDS_TEMPLATE_NAME_MED           4675
#define IDS_TEMPLATE_NAME_MEDLOW        4676
#define IDS_TEMPLATE_NAME_LOW           4677
#define IDS_TEMPLATE_NAME_CUSTOM        4678
#define IDS_ERROR_CANT_MOVE_TIF         4679
#define IDS_ERROR_CANT_CONNECT          4680
#define IDS_BRAND_NAME                  4681
#define IDS_RESTRICTED_MESSAGE          4682
#define IDS_RESTRICTED_TITLE            4683
#define IDS_TEMPLATE_NAME_UNDEFINED     4684
#define IDS_COOKIES_WARNING             4685
#define IDS_CLEAR_SSL_CACHE_TEXT        4686
#define IDS_CLEAR_SSL_CACHE_TITLE       4687
//  !!! do not change the order or distribution of IDS_ZONE* resources!
#define IDS_ZONENAME_LOCAL              4688
#define IDS_ZONENAME_INTRANET           4689
#define IDS_ZONENAME_TRUSTED            4690
#define IDS_ZONENAME_INTERNET           4691
#define IDS_ZONENAME_UNTRUSTED          4692
#define IDS_ZONEDESC_LOCAL              4693
#define IDS_ZONEDESC_INTRANET           4694
#define IDS_ZONEDESC_TRUSTED            4695
#define IDS_ZONEDESC_INTERNET           4696
#define IDS_ZONEDESC_UNTRUSTED          4697
//  !!! do not change the order or distribution of IDS_ZONE* resources!


#define IDS_LANG_EN                     4700
#define IDS_LANG_DE                     4701
#define IDS_LANG_JA                     4702
#define IDS_LANG_KO                     4703
#define IDS_LANG_TW                     4704
#define IDS_LANG_CN                     4705
#define IDS_LANG_FR                     4706
#define IDS_LANG_ES                     4707
#define IDS_LANG_BR                     4708
#define IDS_LANG_IT                     4709
#define IDS_LANG_NL                     4710
#define IDS_LANG_SV                     4711
#define IDS_LANG_DA                     4712
#define IDS_LANG_FI                     4713
#define IDS_LANG_HU                     4714
#define IDS_LANG_NO                     4715
#define IDS_LANG_EL                     4716
#define IDS_LANG_PL                     4717
#define IDS_LANG_RU                     4718
#define IDS_LANG_CZ                     4719
#define IDS_LANG_PT                     4720
#define IDS_LANG_TR                     4721
#define IDS_LANG_SK                     4722
#define IDS_LANG_SL                     4723
#define IDS_LANG_AR                     4724
#define IDS_LANG_HE                     4725
#define IDS_LANG_FUTUREUSE              4726
//#define IDS_NO_FONT                     4727
#define IDS_THE_INTERNET                4728
#define IDS_INTERNET_LOC                4729
#define IDC_STATIC_STYLESHEET           4730
#define IDC_UNUSED                      -1
#define IDC_STATIC                      -1
#define BETA1_FLAGS                     65535

//////////////////////////////////////////////
// strings which are referenced by id from  //
// the advanced options registry stuff      //
//////////////////////////////////////////////

#define IDS_ALTTEXT_TEXT                4731
#define IDS_MOVSYSCARET_TEXT            4732
#define IDS_BROWSE_PROCESS_TEXT         4733
#define IDS_FRIEND_URL_TEXT             4734
#define IDS_SMOOTH_SCROLL_TEXT          4735
#define IDS_ENABLE_SUB                  4736
#define IDS_ENABLE_FTPFOLDERS           4737
#define IDS_SM_IMAGE_DITH_TEXT          4738
#define IDS_PL_SOUNDS_TEXT              4739
#define IDS_PL_VID_TEXT                 4740
#define IDS_PL_ANI_TEXT                 4741
#define IDS_SH_PIC_TEXT                 4742
#define IDS_ENABLE_FTP_PASV             4743
#define IDS_MM_TEXT                     4744
#define IDS_BR_TEXT                     4745
#define IDS_ACC_TEXT                    4746
#define IDS_SEC_TEXT                    4747
#define IDS_IEONDESKTOP_TEXT            4748
#define IDS_CACHE_SEC_TEXT              4749
#define IDS_CACHE_FLUSH_TEXT            4750
//#define IDS_PCT1_TEXT                   4751
#define IDS_SSL2_TEXT                   4752
#define IDS_SSL3_TEXT                   4753
#define IDS_TLS1_TEXT                   4754
//#define IDS_FORTEZZA_TEXT               4755
#define IDS_P3_TEXT                     4756
#define IDS_ZONE_CROS_TEXT              4757
#define IDS_SUBMIT_REDIR_TEXT           4758
#define IDS_WARN_INV_CERT_TEXT          4759
#define IDS_SSL_REVOCATION_TEXT         4760
#define IDS_CERT_REV_TEXT               4761
#define IDS_SIG_CHECK_TEXT              4762
#define IDS_PRINT_TEXT                  4769
#define IDS_PR_BACK_TEXT                4770
#define IDS_SEARCH_TEXT                 4771
//#define IDS_AUTOSCAN_TEXT               4772
//#define IDS_URL_FAILS_TEXT              4773
#define IDS_ACTIVEX_TEXT                4774
#define IDS_RUN_ACTIVEX_TEXT            4775
#define IDS_DNLD_SIGN_ACTIVEX_TEXT      4776
#define IDS_DNLD_USIGN_ACTIVEX_TEXT     4777
#define IDS_JAVA_TEXT                   4778
#define IDS_JAVA_PER_TEXT               4779
#define IDS_SCRIPT_TEXT                 4782
#define IDS_SCRIPT_ACTIVEX_TEXT         4783
#define IDS_SCRIPT_SAFE_ACTIVEX_TEXT    4784
#define IDS_CROSS_DOMAIN_DATA_TEXT      4785
#define IDS_ACT_SCR_TEXT                4786
#define IDS_SCR_JAVA_TEXT               4787
#define IDS_AUTH_TEXT                   4788
#define IDS_LOGIN_TEXT                  4790
#define IDS_DNLD_TEXT                   4791
#define IDS_FILE_DNLD_TEXT              4792
#define IDS_FONT_DNLD_TEXT              4793
#define IDS_MISC_TEXT                   4794
#define IDS_DT_TEXT                     4795
#define IDS_DD_TEXT                     4796
#define IDS_SUB_FORM_TEXT               4797
#define IDS_LAUNCH_TEXT                 4798
#define IDS_ALWAYS_TEXT                 4799
#define IDS_AL_SEARCH_TEXT              4800
#define IDS_AL_ASK_TEXT                 4801
#define IDS_NEV_SEARCH_TEXT             4802
#define IDS_ENABLE_TEXT                 4803
#define IDS_PROMPT_TEXT                 4804
#define IDS_DISABLE_TEXT                4805
#define IDS_APPROVED_TEXT               4806
#define IDS_ANON_LOG_TEXT               4807
#define IDS_LOG_PROMPT_TEXT             4808
#define IDS_AUTO_LOG_TEXT               4809
#define IDS_COND_PROMPT_TEXT            4810
#define IDS_LOW_PER_TEXT                4814
#define IDS_MED_PER_TEXT                4815
#define IDS_HIGH_PER_TEXT               4816
#define IDS_CUS_PER_TEXT                4817
#define IDS_DIS_JAVA_TEXT               4818
#define IDS_HTTP_TEXT                   4822
#define IDS_HTTP11_TEXT                 4823
#define IDS_PXY_TEXT                    4824
#define IDS_ULINKS_ALWAYS_TEXT          4825
#define IDS_ULINKS_NEVER_TEXT           4826
#define IDS_ULINKS_HOVER_TEXT           4827
#define IDS_ULINKS_TEXT                 4828
#define IDS_PAGETRANS_TEXT              4829
#define IDS_SOFTDIST_TEXT               4830
#define IDS_SCRDBG_TEXT                 4831
#define IDS_SCRCACHE_TEXT               4832
#define IDS_FE_TEXT                     4833
#define IDS_CHANNELBAR_TEXT             4834
#define IDS_NOTIFYDOWNCOMPLETE_TEXT     4835
#define IDS_IOD_TEXT                    4836
#define IDS_IEUPDATECHECK_TEXT          4837
#define IDS_NSCSINGLEEXPAND_TEXT        4838
#define IDS_UTF8_TEXT                   4839
#define IDS_GOBUTTON_TEXT               4840
#define IDS_AUTOAPPEND_TEXT             4841
#define IDS_AUTOAPPEND_IE4_TEXT         4842
#define IDS_SH_PLACEHOLDERS_TEXT        4843
#define IDS_AUTOSEARCH_TEXT             4844
#define IDS_DISPLAY_AND_GO_TEXT         4845
#define IDS_JUST_GO_TEXT                4846
#define IDS_JUST_DISPLAY_TEXT           4847
#define IDS_NO_SEARCH_TEXT              4848
#define IDC_RESETWEBSETTINGS            4849
#define IDC_RESETWEBSETTINGS_TEXT       4850
#define IDS_LANG_CURRENTUSE             4851
#define IDS_AUTOAPPEND_NT5_TEXT         4852
#define IDS_USERDATA_TEXT               4853
#define IDS_SCRIPTPASTE_TEXT            4854
#define IDS_SUBFRAME_NAVIGATE           4855
#define IDS_FAVINTELLIMENUS             4856
#define IDS_LOGOFF_WARNING              4857
#define IDS_LOGOFF_TITLE                4858
#define IDD_LANG_WARNING                4859
#define IDD_LANG_INFO                   4860
#define IDS_REUSEWINDOWSTEXT            4861
#define IDS_CLIENT_CERT_PROMPT          4862
#define IDS_NEGOTIATE_TEXT              4863
// id 4864 was in use by xBar/PersonalBar
#define IDS_EN_MYPICS_TEXT              4865
#define IDS_FORCE_OFFSCREEN_TEXT        4866
#define IDD_CACHE_COOKIES_EMPTY         4869
#define IDS_METAREFRESH_TEXT            4870
#define IDS_AUTOIMAGERESIZE_TEXT        4871
#define IDS_MIXED_CONTENT_TEXT          4872
#define IDS_USE_THEMES_TEXT             4873
#define IDS_USE_BHO_TEXT                4874
#define IDS_WEBJIT_TEXT                 4875
#define IDS_NO_MB_ONLINE_TEXT           4876


// IDS range 5000 - 5299 is for script sample strings
// IDS_FONT_SAMPLE_SCRIPT = IDS_FONT_SAMPLE_DEFAULT + SidScript
//
#define IDS_FONT_SAMPLE_DEFAULT         5000
#define IDS_FONT_SAMPLE_MERGE           5001
#define IDS_FONT_SAMPLE_ASCIISYM        5002
#define IDS_FONT_SAMPLE_ASCIILATIN      5003
#define IDS_FONT_SAMPLE_LATIN           5004
#define IDS_FONT_SAMPLE_GREEK           5005
#define IDS_FONT_SAMPLE_CYRILLIC        5006
#define IDS_FONT_SAMPLE_ARMENIAN        5007
#define IDS_FONT_SAMPLE_HEBREW          5008
#define IDS_FONT_SAMPLE_ARABIC          5009
#define IDS_FONT_SAMPLE_DEVANAGARI      5010
#define IDS_FONT_SAMPLE_BENGALI         5011
#define IDS_FONT_SAMPLE_GURMUKHI        5012
#define IDS_FONT_SAMPLE_GUJARATI        5013
#define IDS_FONT_SAMPLE_ORIYA           5014
#define IDS_FONT_SAMPLE_TAMIL           5015
#define IDS_FONT_SAMPLE_TELUGU          5016
#define IDS_FONT_SAMPLE_KANNADA         5017
#define IDS_FONT_SAMPLE_MALAYALAM       5018
#define IDS_FONT_SAMPLE_THAI            5019
#define IDS_FONT_SAMPLE_LAO             5020
#define IDS_FONT_SAMPLE_TIBETAN         5021
#define IDS_FONT_SAMPLE_GEORGIAN        5022
#define IDS_FONT_SAMPLE_HANGUL          5023
#define IDS_FONT_SAMPLE_KANA            5024
#define IDS_FONT_SAMPLE_BOPOMOFO        5025
#define IDS_FONT_SAMPLE_HAN             5026
#define IDS_FONT_SAMPLE_ETHIOPIC        5027
#define IDS_FONT_SAMPLE_CANSYLLABIC     5028
#define IDS_FONT_SAMPLE_CHEROKEE        5029
#define IDS_FONT_SAMPLE_YI              5030
#define IDS_FONT_SAMPLE_BRAILLE         5031
#define IDS_FONT_SAMPLE_RUNIC           5032
#define IDS_FONT_SAMPLE_OGHAM           5033
#define IDS_FONT_SAMPLE_SINHALA         5034
#define IDS_FONT_SAMPLE_SYRIAC          5035
#define IDS_FONT_SAMPLE_BURMESE         5036
#define IDS_FONT_SAMPLE_KHMER           5037
#define IDS_FONT_SAMPLE_THAANA          5038
#define IDS_FONT_SAMPLE_MONGOLIAN       5039
#define IDS_FONT_SAMPLE_USERDEFINED     5040
// 5041 - 5299 is reserved for new language scripts
#define IDS_FONT_SAMPLE_MAX             5299

#define IDD_PRIVACY                     5300
#define IDC_PRIVACY_IMPORT              5301
#define IDI_PRIV                        5302
#define IDI_PRIV_IMPORT                 5303
#define IDS_PRIVACY_LEVEL_NO_COOKIE     5304
#define IDS_PRIVACY_LEVEL0              5305
#define IDS_PRIVACY_LEVEL1              5306
#define IDS_PRIVACY_LEVEL2              5307
#define IDS_PRIVACY_LEVEL3              5308
#define IDS_PRIVACY_LEVEL4              5309
#define IDS_PRIVACY_LEVEL5              5310
#define IDS_PRIVACY_DESC_NO_COOKIE      5311
#define IDS_PRIVACY_DESC0               5312
#define IDS_PRIVACY_DESC1               5313
#define IDS_PRIVACY_DESC2               5314
#define IDS_PRIVACY_DESC3               5315
#define IDS_PRIVACY_DESC4               5316
#define IDS_PRIVACY_DESC5               5317
#define IDC_PRIVACY_DEFAULT             5318
#define IDC_PRIVACY_ADVANCED            5319

#define IDD_PRIVACY_ADVANCED            5320
#define IDC_USE_ADVANCED                5321
#define IDC_FIRST_ACCEPT                5322
#define IDC_FIRST_DENY                  5323
#define IDC_FIRST_PROMPT                5324
#define IDC_THIRD_ACCEPT                5325
#define IDC_THIRD_DENY                  5326
#define IDC_THIRD_PROMPT                5327
#define IDC_SESSION_OVERRIDE            5328
#define IDC_PRIVACY_EDIT                5329
#define IDC_PRIVACY_CLEAR               5330
#define IDC_TX_FIRST                    5331
#define IDC_TX_THIRD                    5332
#define IDC_LEVEL                       5333
#define IDC_LEVEL_SLIDER                5334
#define IDC_PRIVACY_ICON                5335

#define IDD_PRIVACY_PERSITE             5371
//#define IDC_PRIVACYPS_SITEACCEPT        5372
//#define IDC_PRIVACYPS_SITEREJECT        5373
#define IDC_PRIVACYPS_SITETOSET         5374
#define IDC_PRIVACYPS_ACCEPTBTN         5375
#define IDC_PRIVACYPS_REJECTBTN         5376
#define IDC_PRIVACYPS_REMOVEBTN         5377
#define IDC_PRIVACYPS_LISTBOX           5378
#define IDC_PRIVACYPS_REMOVEALLBTN      5379
#define IDS_PRIVACYPS_ERRORTTL          5380
#define IDS_PRIVACYPS_ERRORTXT          5381
#define IDR_PERSITE_CONTEXT_MENU        5382
#define IDM_PRIVACYPS_CTXM_ACCEPT       5383
#define IDM_PRIVACYPS_CTXM_REJECT       5384
#define IDM_PRIVACYPS_CTXM_DELETE       5385
#define IDS_PRIVACYPS_COLSITE           5386
#define IDS_PRIVACYPS_COLSET            5387
#define IDS_PRIVACYPS_ACCEPT            5388
#define IDS_PRIVACYPS_REJECT            5389
#define IDI_PRIVACY_XP                  5390


#define IDS_PRIVACYIMPORT_TITLE                     5351
#define IDS_PRIVACYIMPORT_SUCCESS                   5352
#define IDS_PRIVACYIMPORT_FAILURE                   5355
#define IDS_PRIVACYIMPORT_FILEEXPR                  5356

#define IDS_PRIVACY_SLIDERCOMMANDSLIDE  5360
#define IDS_PRIVACY_SLIDERCOMMANDDEF    5361
#define IDC_PRIVACY_SLIDERCOMMAND       5362
                                           
// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        4500
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1567
#define _APS_NEXT_SYMED_VALUE           5000
#endif
#endif

// Following IDs are used by UNIX only
//
#ifdef UNIX

#define IDD_ASSOCIATIONS                0x4000
#define IDC_DOC_LIST                    0x4001
#define IDC_DOC_TYPE                    0x4002
#define IDC_DOC_EXTS                    0x4003
#define IDC_DOC_MIME                    0x4004
#define IDC_DOC_CMND                    0x4005
#define IDC_DOC_DESC                    0x4006
#define IDC_ASSOC_ADD                   0x4007
#define IDC_ASSOC_DEL                   0x4008
#define IDC_ASSOC_UPD                   0x4009
#define IDC_ASSOC_EDIT                  0x4010
#define IDC_BROWSE                      0x4011
#define IDS_ERROR_EXTS_ALREADY_EXISTS   0x4020
#define IDS_ERROR_DESC_ALREADY_EXISTS   0x4021
#define IDS_ERROR_NOT_AN_EXT            0x4022
#define IDS_ERROR_MISSING_EXTS          0x4023
#define IDS_ERROR_MISSING_DESC          0x4024
#define IDS_ERROR_MISSING_CMND          0x4025
#define IDS_ERROR_INVALID_MIME          0x4026
#define IDS_ERROR_ALIAS_ALREADY_EXISTS  0x4027
#define IDS_TITLE_ALIASEDIT             0x4028
#define IDS_TITLE_ALIASADD              0x4029

#define IDC_ALIAS_LIST                  0x4030
#define IDC_ALIAS_ADD                   0x4031
#define IDC_ALIAS_EDIT                  0x4032
#define IDC_ALIAS_DEL                   0x4033
#define IDD_ALIASDLG                    0x4034
#define IDS_FIRSTCOLUMN                 0x4050

#define IDD_ALIAS_EDIT                  0x4060
#define IDC_URL_EDIT                    0x4062

#define IDC_FONTS_PROP_GROUPBOX         0x4070
#define IDC_FONTS_FIXED_GROUPBOX        0x4071
#define IDC_FONTS_UPDATE_GROUPBOX       0x4072
#define IDC_FONTS_UPDATE_BUTTON         0x4073
#define IDC_FONTS_UPDATE_TEXT           0x4074

#define IDS_READONLY_CACHE_TEXT         0x4081
#define IDC_READONLY_CACHE_WARNING      0x4082
#define IDC_TEMP_INTERNET_TEXT          0x4083

#define IDD_ENTER_ASSOC                 0x4090

#define IDD_FONTUPD_PROG                0x40A0
#define IDC_FONTUPD_PROG                0x40A1
#define IDC_FONTUPD_CANCEL              0x40A2
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\programs.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************

//
// PROGRAMS.C - "Programs" property sheet UI handlers doe InetCpl
//
//

//
// History:
//
// 6/20/96  t-gpease    created
//

#include "inetcplp.h"

#include <mluisupp.h>
#include <advpub.h>

//
// Private Functions and Structures
//
BOOL ProgramsDlgInit( HWND hDlg);
void UpdateMailIconLabel();


typedef struct {
    HWND hDlg;          // dialog windows handle
    HWND hwndMail;      // Mail dropdown
    HWND hwndNews;      // News dropdown
    HWND hwndCalendar;  // Calendar dropdown
    HWND hwndContact;   // Contact dropdown
    HWND hwndCall;      // Internet call dropdown
    HWND hwndHtmlEdit;  // HTML Editors dropdown

    BOOL bAssociationCheck;     // Is IE the default browser?
#ifndef UNIX
    BOOL bIEIsFTPClient;  // Is IE the default FTP Client?
    IFtpInstaller * pfi;  // FTP Installer
#endif // UNIX

    int iHtmlEditor;
    int iMail;
    int iNews;
    int iCalendar;
    int iContact;
    int iCall;
    BOOL fChanged;

#ifdef UNIX
    HWND hwndVSource;   // View Source
    HWND hwndMailEdit;
    HWND hwndMailFind;
    HWND hwndNewsFind;
    HWND hwndNewsEdit;
    DWORD dwUseOEMail;
    DWORD dwUseOENews;
    HWND hwndEnableUseOEMail;
    HWND hwndEnableUseOENews;
    int  iVSource;
#endif

} PROGRAMSPAGE, *LPPROGRAMSPAGE;

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifdef WALLET
typedef int (*PFN_DISPLAYWALLETPAYDIALOG_PROC)(HWND, HINSTANCE, LPTSTR, int);
typedef int (*PFN_DISPLAYWALLETADDRDIALOG_PROC)(HWND, HINSTANCE, LPTSTR, int);
#endif

//
//
//
// "File Types" Dialog
//
//
//

// we only have to pull in one page.
#define NUM_FILETYPES_PAGES     1

static const char szAddFileTypesPS[] = "AddMIMEFileTypesPS";

#ifdef WALLET
// NOTE: This is dumb.  Wallet uses different GUIDs for Alpha and x86 versions
//
#ifdef _ALPHA_
static const TCHAR g_szWalletPaymentDirKey[] = TEXT("CLSID\\{B7FB4D5C-9FBE-11D0-8965-0000F822DEA9}\\InprocServer32");
static const TCHAR g_szWalletAddressDirKey[] = TEXT("CLSID\\{B7FB4D5C-9FBE-11D0-8965-0000F822DEA9}\\InprocServer32");
#else
static const TCHAR g_szWalletPaymentDirKey[] = TEXT("CLSID\\{87D3CB66-BA2E-11CF-B9D6-00A0C9083362}\\InprocServer32");
static const TCHAR g_szWalletAddressDirKey[] = TEXT("CLSID\\{87D3CB63-BA2E-11CF-B9D6-00A0C9083362}\\InprocServer32");
#endif

static const char g_szWalletPaymentFN[] = "DisplayWalletPaymentDialog";
static const char g_szWalletAddressFN[] = "DisplayWalletAddressDialog";
#endif


BOOL CALLBACK AddFileTypesPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    BOOL bResult;
    LPPROPSHEETHEADER ppsh = (LPPROPSHEETHEADER)lParam;

    bResult = (ppsh->nPages < NUM_FILETYPES_PAGES);

    if (bResult)
        ppsh->phpage[ppsh->nPages++] = hpage;

    return(bResult);
}

BOOL CreateFileTypesDialog(HWND hDlg)
{
    PROPSHEETPAGE       psp[NUM_FILETYPES_PAGES];  // only have "File Types" sheet
    PROPSHEETHEADER     psHeader;
    TCHAR               szFileTypes[MAX_PATH];

    typedef HRESULT (WINAPI *LPADDFILETYPESPS)(LPFNADDPROPSHEETPAGE pfnAddPage,
                                               LPARAM lparam);
    LPADDFILETYPESPS AddFileTypesPS;
    HINSTANCE hInstFTDll = NULL;

    // get the file name from resource
    TCHAR szDllFilename[SMALL_BUF_LEN+1];
    if (!MLLoadString(IDS_FTDLL_FILENAME,szDllFilename,ARRAYSIZE(szDllFilename)))
    {
        return FALSE;
    }

    // load the DLL
    hInstFTDll = LoadLibrary(szDllFilename);
    if (!hInstFTDll)
    {
        return FALSE;
    }

    // get Dialog Proc...
    if (!(AddFileTypesPS = (LPADDFILETYPESPS) GetProcAddress(hInstFTDll, szAddFileTypesPS)))
    {
        FreeLibrary(hInstFTDll);
        return FALSE;
    }

    memset(&psHeader,0,sizeof(psHeader));

    MLLoadString(IDS_FILETYPES, szFileTypes, ARRAYSIZE(szFileTypes));

    psHeader.dwSize = sizeof(psHeader);
    psHeader.dwFlags = PSH_NOAPPLYNOW | PSH_USECALLBACK ;
    psHeader.hwndParent = hDlg;
    psHeader.hInstance = MLGetHinst();
    psHeader.pszIcon = NULL;
    psHeader.nPages = 0;
    psHeader.ppsp = psp;
    psHeader.pszCaption = szFileTypes;

    // push the FileTypes page onto the sheet
    AddFileTypesPS(AddFileTypesPropSheetPage, (LPARAM)&psHeader);

    // don't care about the return value... wait for dialog to be done.
    PropertySheet(&psHeader);

    // all done... cleanup time...
    FreeLibrary(hInstFTDll);

    return TRUE;    // we succeeded
}


#ifdef WALLET
HINSTANCE GetWalletPaymentDProc(PFN_DISPLAYWALLETPAYDIALOG_PROC * ppfnDialogProc)
{
    TCHAR   szDLLFile[MAX_PATH];
    DWORD   dwType;
    DWORD   dwSize = SIZEOF(szDLLFile);
    HINSTANCE hInst = NULL;

    *ppfnDialogProc = NULL;
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, g_szWalletPaymentDirKey, NULL, &dwType, (LPVOID)szDLLFile, &dwSize))
    {
        hInst = LoadLibrary(szDLLFile);
        // Will Fail if OCX is not installed.
        if (hInst)
        {
            *ppfnDialogProc = (PFN_DISPLAYWALLETPAYDIALOG_PROC) GetProcAddress(hInst, g_szWalletPaymentFN);
        }
    }

    if (!*ppfnDialogProc && hInst)
    {
        FreeLibrary(hInst);
        hInst = NULL;
    }

    return hInst;
}


BOOL IsWalletPaymentAvailable(VOID)
{
    HINSTANCE hInst;
    PFN_DISPLAYWALLETPAYDIALOG_PROC pfnDialogProc;
    BOOL fIsAvailable = FALSE;

    hInst = GetWalletPaymentDProc(&pfnDialogProc);
    if (hInst)
    {
        fIsAvailable = TRUE;
        FreeLibrary(hInst);
    }

    return fIsAvailable;
}

VOID DisplayWalletPaymentDialog(HWND hWnd)
{
    HINSTANCE hInst;
    PFN_DISPLAYWALLETPAYDIALOG_PROC pfnDialogProc;

    hInst = GetWalletPaymentDProc(&pfnDialogProc);
    if (hInst)
    {
        (*pfnDialogProc)(hWnd, NULL, NULL, 0);
        FreeLibrary(hInst);
    }
}


HINSTANCE GetWalletAddressDProc(PFN_DISPLAYWALLETADDRDIALOG_PROC * ppfnDialogProc)
{
    TCHAR   szDLLFile[MAX_PATH];
    DWORD   dwType;
    DWORD   dwSize = SIZEOF(szDLLFile);
    HINSTANCE hInst = NULL;

    *ppfnDialogProc = NULL;
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, g_szWalletAddressDirKey, NULL, &dwType, (LPVOID)szDLLFile, &dwSize))
    {
        hInst = LoadLibrary(szDLLFile);
        // Will Fail if OCX is not installed.
        if (hInst)
        {
            *ppfnDialogProc = (PFN_DISPLAYWALLETADDRDIALOG_PROC) GetProcAddress(hInst, g_szWalletAddressFN);
        }
    }

    if (!*ppfnDialogProc && hInst)
    {
        FreeLibrary(hInst);
        hInst = NULL;
    }

    return hInst;
}

BOOL IsWallet3Installed()
{
    HINSTANCE hInst;
    PFN_DISPLAYWALLETADDRDIALOG_PROC pfnDialogProc;
    BOOL fWallet3 = FALSE;
    
    hInst = GetWalletAddressDProc(&pfnDialogProc);
    if (hInst)
    {
        CHAR chPath[MAX_PATH];
        
        if (GetModuleFileNameA(hInst, chPath, ARRAYSIZE(chPath)))
        {
            DWORD dwMSVer, dwLSVer;
            
            if (SUCCEEDED(GetVersionFromFile(chPath, &dwMSVer, &dwLSVer, TRUE)))
            {
                if (dwMSVer >= 3)
                {
                    fWallet3 = TRUE;
                }
            }
        }
        
        FreeLibrary(hInst);
    }

    return fWallet3;
}

BOOL IsWalletAddressAvailable(VOID)
{
    HINSTANCE hInst;
    PFN_DISPLAYWALLETADDRDIALOG_PROC pfnDialogProc;
    BOOL fIsAvailable = FALSE;

    hInst = GetWalletAddressDProc(&pfnDialogProc);
    if (hInst)
    {
        fIsAvailable = TRUE;
        FreeLibrary(hInst);
    }

    return fIsAvailable;
}

VOID DisplayWalletAddressDialog(HWND hWnd)
{
    HINSTANCE hInst;
    PFN_DISPLAYWALLETADDRDIALOG_PROC pfnDialogProc;

    hInst = GetWalletAddressDProc(&pfnDialogProc);
    if (hInst)
    {
        (*pfnDialogProc)(hWnd, NULL, NULL, 0);
        FreeLibrary(hInst);
    }
}
#endif

//
//
//
// "Programs" Tab
//
//
//


#ifndef UNIX
//
// RegPopulateComboBox()
//
// Takes an open HKEY (hkeyProtocol) and populates hwndCB with the friendly
// names of clients. The currently selected client is the "(default)" key of
// hkeyProtocol. The clients are sub-keys under the open key. The friendly
// names of the clients are in the "(default)" value of these sub-keys. This
// function also makes the currently selected client the selected item in
// hwndCB and returns the index number to the item.
//
// History:
//
// 7/ 8/96  t-gpease    created
//
UINT RegPopulateComboBox(HWND hwndCB, HKEY hkeyProtocol)
{
    TCHAR           szFriendlyName      [MAX_PATH];
    TCHAR           szKeyName           [MAX_PATH];
    TCHAR           szCurrent           [MAX_PATH];
    TCHAR           szFriendlyCurrent   [MAX_PATH];
    FILETIME        ftLastWriteTime;

    DWORD   i;              // Index counter

    HKEY    hkeyClient;
    DWORD   cb;

    // find the currently selected client
    cb = sizeof(szCurrent);
    if (RegQueryValueEx(hkeyProtocol, NULL, NULL, NULL, (LPBYTE)szCurrent, &cb)
        != ERROR_SUCCESS)
    {
        // if not found then blank the friendly name and keyname.
        szCurrent[0]=0;
        szFriendlyCurrent[0]=0;
    }

    // populate the dropdown
    for(i=0;                    // always start with 0
        cb=ARRAYSIZE(szKeyName),   // string size
        ERROR_SUCCESS==RegEnumKeyEx(hkeyProtocol, i, szKeyName, &cb, NULL, NULL, NULL, &ftLastWriteTime);
        i++)                    // get next entry
    {
        // get the friendly name of the client
        if (RegOpenKeyEx(hkeyProtocol, szKeyName, 0, KEY_READ, &hkeyClient)==ERROR_SUCCESS)
        {
            cb = sizeof(szFriendlyName);
            if (RegQueryValueEx(hkeyClient, NULL, NULL, NULL, (LPBYTE)szFriendlyName, &cb)
                == ERROR_SUCCESS)
            {
                // add name to dropdown
                SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)szFriendlyName);

                // check to see if it's the current default
                if (!StrCmp(szKeyName, szCurrent))
                {
                    // save its the friendly name which we'll use later to
                    // select the current client and what index it is.
                    StrCpyN(szFriendlyCurrent, szFriendlyName, ARRAYSIZE(szFriendlyCurrent));
                }
            }

            // close key
            RegCloseKey(hkeyClient);
        }

    }   // for

    // select current client and get index number... just in case listboxes are sorted we
    // are doing this last.
    return (unsigned int) SendMessage(hwndCB, CB_SELECTSTRING, (WPARAM) 0, (LPARAM) szFriendlyCurrent);
}   // RegPopulateComboBox()
#else
#define RegPopulateComboBox RegPopulateEditText
#endif /* UNIX */

//
// Adds the item and its associated HKEY in the combobox.  Stores the hkey
// as data associated with the item. Frees hkey if the item is already present
// or if an error occurs.
//
BOOL AddItemToEditorsCombobox
(
    HWND hwndCB, 
    LPTSTR pszFriendlyName, // friendly name of the app
    HKEY hkey               // location of assoc shell\edit verb
)
{
    ASSERT(pszFriendlyName);
    ASSERT(hkey);

    BOOL fRet = FALSE;

    // Only add if not already in combo
    if (SendMessage(hwndCB, CB_FINDSTRINGEXACT, -1, (LPARAM)pszFriendlyName) == CB_ERR)
    {
        // Add name to dropdown
        INT_PTR i = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)pszFriendlyName);
        if (i >= 0)
        {
            fRet = (SendMessage(hwndCB, CB_SETITEMDATA, i, (LPARAM)hkey) != CB_ERR);
        }
    }

    if (!fRet)
    {
        RegCloseKey(hkey);
    }
    return fRet;
}

//
// Adds the edit verb to the OpenWithList associated with .htm files.
//
void AddToOpenWithList(LPCTSTR pszFriendly, HKEY hkeyFrom, HKEY hkeyOpenWithList)
{
    ASSERT(pszFriendly);
    ASSERT(hkeyFrom);

    if (NULL == hkeyOpenWithList)
    {
        return;
    }

    TCHAR szBuf[MAX_PATH];
    StrCpyN(szBuf, pszFriendly, ARRAYSIZE(szBuf));
    StrCatBuff(szBuf, TEXT("\\shell\\edit"), ARRAYSIZE(szBuf));

    DWORD dwDisposition;
    HKEY hkeyDest;
    if (hkeyOpenWithList &&
        ERROR_SUCCESS == RegCreateKeyEx(hkeyOpenWithList, szBuf, 0,
                            NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyDest, &dwDisposition))
    {
        // Copy everything under shell if this item did not exist
        if (dwDisposition == REG_CREATED_NEW_KEY)
        {
            SHCopyKey(hkeyFrom, L"shell\\edit", hkeyDest, 0); 
        }
        RegCloseKey(hkeyDest);
    }
}

//
// Returns TRUE if the verb
//
BOOL IsHtmlStub
(
    HKEY hkeyVerb,  // reg location of the shell\verb\command
    LPCWSTR pszVerb // verb to check for ("edit" or "open")
)
{
    BOOL fRet = FALSE;

    // We don't display programs that are simple redirectors (such as Office's msohtmed.exe)
    TCHAR sz[MAX_PATH];
    if (SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, hkeyVerb, pszVerb, sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
    {
        // Get the MULTISZ list of known redirectors 
        TCHAR szRedir[MAX_PATH];
        ZeroInit(szRedir, ARRAYSIZE(szRedir)); // Protect against non-multisz strings in the reg
        DWORD dwType;
        DWORD cb = sizeof(szRedir) - 4;
        if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_DEFAULT_HTML_EDITOR, L"Stubs", &dwType, szRedir, &cb))
        {
            // Nothing in registry, so default to ignore the Office redirector
            StrCpyN(szRedir, L"msohtmed.exe\0", ARRAYSIZE(szRedir));
        }

        // Compare exe name with list of redirectors 
        LPCTSTR pszFile = PathFindFileName(sz);
        for (LPTSTR p = szRedir; *p != NULL; p += lstrlen(p) + 1)
        {
            if (StrCmpI(p, pszFile) == 0)
            {
                fRet = TRUE;
                break;
            }
        }
    }
    return fRet;
}


BOOL GetAppKey(LPCWSTR pszApp, HKEY *phkApp)
{
    ASSERT(pszApp && *pszApp);
    WCHAR szKey[MAX_PATH];
    StrCpy(szKey, L"Applications\\");
    StrCatBuff(szKey, pszApp, SIZECHARS(szKey));

    return (NOERROR == RegOpenKeyEx(
        HKEY_CLASSES_ROOT,
        szKey,
        0L,
        MAXIMUM_ALLOWED,
        phkApp));
}

//
// Adds the html editors to the combobox. Looks for edit verbs associated
// with the .htm extension, the .htm OpenWithList, and the current default
// editor.
//
void PopulateEditorsCombobox(HWND hwndCB)
{
    //
    // Add items from the OpenWithList for .htm
    //
    DWORD dw;
    HKEY hkeyOpenWithList = NULL;
    TCHAR szOpenWith[MAX_PATH];
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, L".htm\\OpenWithList", 0,
                            NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyOpenWithList, &dw))
    {
        //
        // First enumerate the entries in the OpenWithList
        //
        HKEY hkeyOpenWith = NULL;
        DWORD dwIndex = 0;
        DWORD dwSize = ARRAYSIZE(szOpenWith);
        while (ERROR_SUCCESS == RegEnumKeyEx(hkeyOpenWithList, dwIndex, szOpenWith, &dwSize, NULL, NULL, NULL, NULL))
        {
            if (GetAppKey(szOpenWith, &hkeyOpenWith))
            {
                // We only accept items that have an edit verb
                TCHAR sz[MAX_PATH];
                if (SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, hkeyOpenWith, L"edit", sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
                {
                    // Note that we store hkeyOpenWith in the combo so don't close it
                    AddItemToEditorsCombobox(hwndCB, sz, hkeyOpenWith);
                }
                else
                {
                    RegCloseKey(hkeyOpenWith);
                }
            }

            ++dwIndex;
            dwSize = ARRAYSIZE(szOpenWith);
        }

        // hkeyOpenWithList is closed below
    }

    //
    // Add the editor associated with .htm
    //
    HKEY hkeyHtm;

    //  FEATURE - should use AssocCreate(IQueryAssociations) here instead
    if (SUCCEEDED(AssocQueryKey(0, ASSOCKEY_SHELLEXECCLASS, L".htm", NULL, &hkeyHtm)))
    {
        TCHAR sz[MAX_PATH];
        if (!IsHtmlStub(hkeyHtm, L"edit") &&
             SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, hkeyHtm, L"edit", sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
        {
            AddItemToEditorsCombobox(hwndCB, sz, hkeyHtm);
            AddToOpenWithList(sz, hkeyHtm, hkeyOpenWithList);

            // Don't free the key we cached away
            hkeyHtm = NULL;
        }
        
        if (hkeyHtm)
        {
            RegCloseKey(hkeyHtm);
        }
    }

    //
    //  Get the default editor.  We check both hkcu & hklm.
    //
    HKEY hkeyDefault;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_HTML_EDITOR, 0, KEY_READ, &hkeyDefault) ||
        ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DEFAULT_HTML_EDITOR, 0, KEY_READ, &hkeyDefault))
    {
        TCHAR sz[MAX_PATH];
        if (SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, hkeyDefault, L"edit", sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
        {
            // Add name to dropdown and save hkeyDefault in the combobox (so don't close it)
            AddItemToEditorsCombobox(hwndCB, sz, hkeyDefault);

            // Select this item
            SendMessage(hwndCB, CB_SELECTSTRING, -1, (LPARAM)sz);

            //
            // Make sure the default editor is in the htm OpenWithList so it doesn't dissapear
            // if we change it
            //
            AddToOpenWithList(sz, hkeyDefault, hkeyOpenWithList);
        }
        else
        {
            RegCloseKey(hkeyDefault);
        }

    }

    if (hkeyOpenWithList)
    {
        RegCloseKey(hkeyOpenWithList);
    }
}
    

//
// ProgramsDlgInit()
//
// Does initalization for Programs Dlg.
//

// History:
//
// 6/17/96  t-gpease   created
// 7/ 8/96  t-gpease   added Mail and News initialization
//
BOOL ProgramsDlgInit( HWND hDlg)
{
    LPPROGRAMSPAGE  pPrg;
    DWORD           dw;
    HKEY            hkey;

    pPrg = (LPPROGRAMSPAGE)LocalAlloc(LPTR, sizeof(*pPrg));
    if (!pPrg)
    {
        EndDialog(hDlg, 0);
        return FALSE;   // no memory?
    }

    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pPrg);

    // save the handle to the page
    pPrg->hDlg = hDlg;

    //
    // Set default values.
    //

#ifndef UNIX
    pPrg->bAssociationCheck = TRUE;     // we want everybody to use IE!
    SUCCEEDED(CoCreateInstance(CLSID_FtpInstaller, NULL, CLSCTX_INPROC_SERVER, IID_IFtpInstaller, (void **) &pPrg->pfi));
    if (pPrg->pfi)
        pPrg->bIEIsFTPClient = ((S_OK == pPrg->pfi->IsIEDefautlFTPClient()) ? TRUE : FALSE);

#endif
    pPrg->iMail = -1;                   // nothing selected
    pPrg->iNews = -1;                   // nothing selected

#ifndef UNIX
    pPrg->bAssociationCheck = SHRegGetBoolUSValue(REGSTR_PATH_MAIN,REGSTR_VAL_CHECKASSOC,FALSE,TRUE);

    //
    // Get the html editors
    //
    pPrg->hwndHtmlEdit = GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_HTMLEDITOR_COMBO);
    PopulateEditorsCombobox(pPrg->hwndHtmlEdit);
    // Sundown: coercion to int because 32b is sufficient for cursor selection
    pPrg->iHtmlEditor = (int) SendMessage(pPrg->hwndHtmlEdit, CB_GETCURSEL, 0, 0);


    //
    // Get the Mail Clients
    //
    pPrg->hwndMail = GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_MAIL_COMBO);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_MAILCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
#else
    pPrg->hwndMail = GetDlgItem(pPrg->hDlg, IDC_EDIT_PROGRAMS_MAIL);
    if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_MAILCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
#endif
    {
        // populate the combobox
        pPrg->iMail = RegPopulateComboBox(pPrg->hwndMail, hkey);

        // close the keys
        RegCloseKey(hkey);
    }

    //
    // Get the News Clients
    //
#ifndef UNIX
    pPrg->hwndNews = GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_NEWS_COMBO);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_NEWSCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
#else
    pPrg->hwndNews = GetDlgItem(pPrg->hDlg, IDC_EDIT_PROGRAMS_NEWS);

    if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_NEWSCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
#endif
    {
        // populate the combobox
        pPrg->iNews = RegPopulateComboBox(pPrg->hwndNews, hkey);

        // close the keys
        RegCloseKey(hkey);
    }

    //
    // get the calendar clients
    //
#ifndef UNIX

    pPrg->hwndCalendar = GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_CALENDAR_COMBO);
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_CALENDARCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
    {
        // populate the combobox
        pPrg->iCalendar = RegPopulateComboBox(pPrg->hwndCalendar, hkey);

        // close the keys
        RegCloseKey(hkey);
    }

    //
    // get the contacts clients
    //
    pPrg->hwndContact = GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_CONTACT_COMBO);
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_CONTACTCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
    {
        // populate the combobox
        pPrg->iContact = RegPopulateComboBox(pPrg->hwndContact, hkey);

        // close the keys
        RegCloseKey(hkey);
    }

    //
    // get the internet call clients
    //
    pPrg->hwndCall = GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_CALL_COMBO);
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_CALLCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
    {
        // populate the combobox
        pPrg->iCall = RegPopulateComboBox(pPrg->hwndCall, hkey);

        // close the keys
        RegCloseKey(hkey);
    }

    // Set dialog items
    CheckDlgButton(hDlg, IDC_CHECK_ASSOCIATIONS_CHECKBOX, pPrg->bAssociationCheck);

    HRESULT hrIEDefaultFTPClient = E_FAIL;
    if (pPrg->pfi)
    {
        hrIEDefaultFTPClient = pPrg->pfi->IsIEDefautlFTPClient();
        // Is this option not applicable because only the IE FTP client is installed?
        if (SUCCEEDED(hrIEDefaultFTPClient))
            CheckDlgButton(hDlg, IDC_PROGRAMS_IE_IS_FTPCLIENT, pPrg->bIEIsFTPClient);
    }
    if (FAILED(hrIEDefaultFTPClient))
    {
        // Yes, so remove the option.
        ShowWindow(GetDlgItem(hDlg, IDC_PROGRAMS_IE_IS_FTPCLIENT), SW_HIDE);
    }


    if( g_restrict.fMailNews )
    {
        EnableWindow( GetDlgItem(hDlg, IDC_PROGRAMS_MAIL_COMBO), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_PROGRAMS_NEWS_COMBO), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_PROGRAMS_CALL_COMBO), FALSE);
    }

    if ( g_restrict.fCalContact )
    {
        EnableWindow( GetDlgItem(hDlg, IDC_PROGRAMS_CALENDAR_COMBO), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_PROGRAMS_CONTACT_COMBO), FALSE);
    }

    EnableWindow( GetDlgItem(hDlg, IDC_RESETWEBSETTINGS), !g_restrict.fResetWebSettings );
    EnableWindow( GetDlgItem(hDlg, IDC_CHECK_ASSOCIATIONS_CHECKBOX), !g_restrict.fDefault );

#else /* !UNIX */

    pPrg->hwndVSource = GetDlgItem(pPrg->hDlg, IDC_EDIT_PROGRAMS_VSOURCE);
    pPrg->hwndMailFind = GetDlgItem(pPrg->hDlg, IDC_MAIL_FIND);
    pPrg->hwndMailEdit = GetDlgItem(pPrg->hDlg, IDC_MAIL_EDIT);
    pPrg->hwndNewsFind = GetDlgItem(pPrg->hDlg, IDC_NEWS_FIND);
    pPrg->hwndNewsEdit = GetDlgItem(pPrg->hDlg, IDC_NEWS_EDIT);
    pPrg->hwndEnableUseOEMail = GetDlgItem(pPrg->hDlg, IDC_OE_MAIL);
    pPrg->hwndEnableUseOENews = GetDlgItem(pPrg->hDlg, IDC_OE_NEWS);
    if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_VSOURCECLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
    {
        // populate the combobox
        pPrg->iVSource = RegPopulateComboBox(pPrg->hwndVSource, hkey);

        // close the keys
        RegCloseKey(hkey);
    }

    // Set dialog items
    {
    // Look for the oexpress executable in the directory the
    // current process was executed from...  Use the value for the
    // excutable name as stored in the registry for msimn.exe
    DWORD dwType;
    TCHAR szPresentName[MAX_PATH];
    DWORD dwSize = sizeof(szPresentName)/sizeof(szPresentName[0]);
    if (SHGetValue(IE_USE_OE_PRESENT_HKEY, IE_USE_OE_PRESENT_KEY,
        IE_USE_OE_PRESENT_VALUE, &dwType, (void*)szPresentName, &dwSize) ||
        (dwType != REG_SZ) || LocalFileCheck(szPresentName))
    {
        // Disable user's access to OE settings
        EnableWindow(pPrg->hwndEnableUseOEMail, FALSE);
        EnableWindow(pPrg->hwndEnableUseOENews, FALSE);

        // Reset the internal state of the Use OE check buttons
        pPrg->dwUseOEMail = FALSE;
        pPrg->dwUseOENews = FALSE;
    }
    else
    {
        // Reset the values of the check button for use OE MAIL
        // Based on registry values
        dwSize = sizeof(pPrg->dwUseOEMail);
        if (SHGetValue(IE_USE_OE_MAIL_HKEY, IE_USE_OE_MAIL_KEY,
            IE_USE_OE_MAIL_VALUE, &dwType, (void*)&pPrg->dwUseOEMail,
            &dwSize) || (dwType != REG_DWORD))
        {
            // The default value for mail is FALSE
            pPrg->dwUseOEMail = FALSE;
        }
        // Reset the UI elements
        CheckDlgButton(hDlg, IDC_OE_MAIL, pPrg->dwUseOEMail ? BST_CHECKED :
            BST_UNCHECKED);
        EnableWindow(pPrg->hwndMail, pPrg->dwUseOEMail ? FALSE : TRUE);
        EnableWindow(pPrg->hwndMailEdit, pPrg->dwUseOEMail ? FALSE : TRUE);
        EnableWindow(pPrg->hwndMailFind, pPrg->dwUseOEMail ? FALSE : TRUE);

        // Repeat the above for the NEWS settings
        dwSize = sizeof(pPrg->dwUseOENews);
        if (SHGetValue(IE_USE_OE_NEWS_HKEY, IE_USE_OE_NEWS_KEY,
            IE_USE_OE_NEWS_VALUE, &dwType, (void*)&pPrg->dwUseOENews,
            &dwSize) || (dwType != REG_DWORD))
        {
            // The default value for News is FALSE
            pPrg->dwUseOENews = FALSE;
        }
        CheckDlgButton(hDlg, IDC_OE_NEWS, pPrg->dwUseOENews ? BST_CHECKED :
            BST_UNCHECKED);
        EnableWindow(pPrg->hwndNews, pPrg->dwUseOENews ? FALSE : TRUE);
        EnableWindow(pPrg->hwndNewsEdit, pPrg->dwUseOENews ? FALSE : TRUE);
        EnableWindow(pPrg->hwndNewsFind, pPrg->dwUseOENews ? FALSE : TRUE);
    }
    }

    if( g_restrict.fMailNews )
    {
        EnableWindow( GetDlgItem(hDlg, IDC_EDIT_PROGRAMS_MAIL), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_EDIT_PROGRAMS_NEWS), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_EDIT_PROGRAMS_VSOURCE), FALSE);

        EnableWindow( GetDlgItem(hDlg, IDC_OE_MAIL), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_OE_NEWS), FALSE);

        EnableWindow( GetDlgItem(hDlg, IDC_MAIL_FIND), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_NEWS_FIND), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_VSOURCE_FIND), FALSE);

        EnableWindow( GetDlgItem(hDlg, IDC_MAIL_EDIT), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_NEWS_EDIT), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_VSOURCE_EDIT), FALSE);
    }

    SendMessage( pPrg->hwndMail,    EM_LIMITTEXT, MAX_PATH, 0 );
    SendMessage( pPrg->hwndNews,    EM_LIMITTEXT, MAX_PATH, 0 );
    SendMessage( pPrg->hwndVSource, EM_LIMITTEXT, MAX_PATH, 0 );

#endif /* !UNIX */

    return TRUE;    // success

} // ProgramsDlgInit()

//
// RegCopyKey()
//
// Copies all the keys from hkeySrc down into hkeyRoot:pszDest.
//
// History:
//
// 7/ 8/96  t-gpease    created
//
void RegCopyKey(HKEY hkeyRoot, const TCHAR *pszDest, HKEY hkeySrc)
{
    HKEY    hkeyDest;
    HKEY    hkey;
    DWORD   dw;
    DWORD   i;
    DWORD   cb;
    DWORD   cbData;
    DWORD   Type;
    TCHAR   szName[MAX_PATH];
    TCHAR   szData[MAX_URL_STRING+1];

    // open/create the destination key
    if (RegCreateKeyEx(hkeyRoot, pszDest,
                       NULL, 0, NULL, KEY_READ|KEY_WRITE, NULL, &hkeyDest, &dw) == ERROR_SUCCESS)
    {
        i=0;
        // copy values of the key
        while(1)
        {
            // find next value
            cb=ARRAYSIZE(szName);
            cbData=sizeof(szData);
            if (RegEnumValue(hkeySrc, i, szName, &cb, NULL, &Type, (LPBYTE)&szData, &cbData)!=ERROR_SUCCESS)
                break;  // not found... exit loop

            // make a copy of the value in new location
            RegSetValueEx(hkeyDest, szName, NULL, Type, (CONST BYTE *)szData, cbData);

#ifdef UNIX
            RegFlushKey(hkeyDest);
#endif

            // increase index count
            i++;

        }   // while

        // look for more sub-keys in the source
        for(i=0;
            cb=ARRAYSIZE(szName),
            RegEnumKey(hkeySrc, i, szName, cb)==ERROR_SUCCESS;
            i++)
        {
            // open the sub-key
            if (RegCreateKeyEx(hkeySrc, szName,
                               NULL, 0, NULL, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
            {
                // copy the sub-key
                RegCopyKey(hkeyDest, szName, hkey);

                // close the key
                RegCloseKey(hkey);

            }   // if RegCreateKey()

        }   // for

        // close the key
        RegCloseKey(hkeyDest);

    }   // if RegCreateKey()

} // RegCopyKey()

//
// CopyInfoTo()
//
// Copies the information needed to run a mailto: or news: protocol
//
// History:
//
// 7/ 8/96  t-gpease    created
//
void CopyInfoTo(const TCHAR *pszKeyName, HKEY hkeyClient)
{
    HKEY    hkey;
    TCHAR   szName[MAX_PATH];

    // create the protocol sub-key path
    StrCpyN(szName, TSZPROTOCOLSPATH, ARRAYSIZE(szName));
    int len = lstrlen(szName);
    StrCpyN(szName + len, pszKeyName, ARRAYSIZE(szName) - len);

    // make sure it has the protocol we are looking for
    if (RegOpenKeyEx(hkeyClient, szName, NULL, KEY_READ|KEY_WRITE, &hkey)
        ==ERROR_SUCCESS)
    {
        // Netscape Messenger registry patch: they are missing "URL Protocol" in the HKLM mailto branch 
        // and we should set this value, otherwise we get the 68992 bug.  The source is changed rather 
        // than the destination to protect against other programs copying the tree without the value.
        // Might as well check this for all clients rather than look for Netscape, since we don't
        // change any data if it exists.

        if (lstrcmpi(pszKeyName, TSZMAILTOPROTOCOL) == 0 && 
            RegQueryValueEx(hkey, TEXT("URL Protocol"), NULL, NULL, NULL, NULL) != ERROR_SUCCESS) 
        {    
            RegSetValueEx(hkey, TEXT("URL Protocol"), 0, REG_SZ, (BYTE *) TEXT(""), sizeof(TCHAR));
        }

        // start by deleting all the old info
        if ( lstrcmpi(pszKeyName, TSZLDAPPROTOCOL) )
            SHDeleteKey(HKEY_CLASSES_ROOT, pszKeyName);

        // recreate key and copy the protocol info
        RegCopyKey(HKEY_CLASSES_ROOT, pszKeyName, hkey);

        // close the key
        RegCloseKey(hkey);

    }   // if RegOpenKey()

}   // CopyInfoTo()


//
// FindClient()
//
// Finds the currently selected item in hwndComboBox and locates it
// in the szPath's subkeys. If found it will then make a call to copy
// the information to szProtocol key under HKCR.
//
// History:
//
// 7/ 8/96  t-gpease    created
//
void FindClient(LPCTSTR szProtocol, HWND hwndComboBox, int iSelected, LPCTSTR szPath)
{
    TCHAR           szFriendlyName[MAX_PATH];
    TCHAR           szKeyName[MAX_PATH];
    TCHAR           szCurrent[MAX_PATH];
    FILETIME        ftLastWriteTime;

    DWORD   i;              // Index counter
    HKEY    hkeyClient;
    HKEY    hkey;
    DWORD   dw;

    // get the name of the new client
    if (CB_ERR!=SendMessage(hwndComboBox, CB_GETLBTEXT, (WPARAM)iSelected, (LPARAM)szCurrent))
    {
        // got the friendly name... now lets find the internal name
        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szPath,
                           0, NULL, 0, KEY_READ|KEY_WRITE, NULL, &hkey, &dw) == ERROR_SUCCESS)
        {
            DWORD   cb;

            // we must search all the sub-keys for the correct friendly name
            for(i=0;                    // always start with 0
                cb=ARRAYSIZE(szKeyName),   // string size
                ERROR_SUCCESS==RegEnumKeyEx(hkey, i, szKeyName, &cb, NULL, NULL, NULL, &ftLastWriteTime);
                i++)                    // get next entry
            {
                // get more info on the entry
                if (RegOpenKeyEx(hkey, szKeyName, 0, KEY_READ, &hkeyClient)==ERROR_SUCCESS)
                {
                    // get the friendly name of the client
                    cb = sizeof(szFriendlyName);
                    if (RegQueryValueEx(hkeyClient, NULL, NULL, NULL, (LPBYTE)szFriendlyName, &cb)
                        == ERROR_SUCCESS)
                    {
                        // is it the one we are looking for?
                        if (!StrCmp(szFriendlyName, szCurrent))
                        {
                            // yep... copy its info
                            CopyInfoTo(szProtocol, hkeyClient);

                            // make it the default handler
                            cb = (lstrlen(szKeyName) + 1)*sizeof(TCHAR);
                            RegSetValueEx(hkey, NULL, NULL, REG_SZ, (LPBYTE)szKeyName, cb);
                        }
                    }

                    // close key
                    RegCloseKey(hkeyClient);

                }   // if RegOpenKey()

            }   // for

            // close the keys
            RegCloseKey(hkey);

        }   // if RegCreateKeyEx()
    }
}   // FindClient()

//
// ProgramsDlgApplyNow()
//
// Enters "Programs" changes into registry.
//
// History:
//
// 6/20/96  t-gpease    created
// 7/ 8/96  t-gpease    added Mail and News
//
void ProgramsDlgApplyNow(LPPROGRAMSPAGE pPrg)
{
    int tmp;

    if (pPrg->fChanged)
    {
#ifndef UNIX
        // Did the user have a chance to change this option?
        if (pPrg->pfi)
        {
            HRESULT hrIEDefaultFTPClient = pPrg->pfi->IsIEDefautlFTPClient();
            if (IsWindowVisible(GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_IE_IS_FTPCLIENT)))
            {
                // Yes, so see if they changed it.
                pPrg->bIEIsFTPClient = IsDlgButtonChecked(pPrg->hDlg, IDC_PROGRAMS_IE_IS_FTPCLIENT);

                // Did they user want IE as default and currently someone else is?
                if (pPrg->bIEIsFTPClient && (S_FALSE == hrIEDefaultFTPClient))
                    pPrg->pfi->MakeIEDefautlFTPClient();

                // Did they user NOT want IE as default and it currently is?
                if (!pPrg->bIEIsFTPClient && (S_OK == hrIEDefaultFTPClient))
                    pPrg->pfi->RestoreFTPClient();
            }
        }

        pPrg->bAssociationCheck = IsDlgButtonChecked(pPrg->hDlg, IDC_CHECK_ASSOCIATIONS_CHECKBOX);
        TCHAR szYesNo[5];

        StrCpyN(szYesNo, (pPrg->bAssociationCheck ? TEXT("yes") : TEXT("no")), ARRAYSIZE(szYesNo));

        SHRegSetUSValue(REGSTR_PATH_MAIN,
                        REGSTR_VAL_CHECKASSOC,
                        REG_SZ,
                        (LPVOID)szYesNo,
                        (lstrlen(szYesNo)+1)*sizeof(TCHAR),
                        SHREGSET_DEFAULT);
#else
        // Set if OE in use
        SHSetValue(IE_USE_OE_MAIL_HKEY, IE_USE_OE_MAIL_KEY,
            IE_USE_OE_MAIL_VALUE, REG_DWORD, (void*)&pPrg->dwUseOEMail,
            sizeof(pPrg->dwUseOEMail));

        // Set if OE in use
        SHSetValue(IE_USE_OE_NEWS_HKEY, IE_USE_OE_NEWS_KEY,
            IE_USE_OE_NEWS_VALUE, REG_DWORD, (void*)&pPrg->dwUseOENews,
            sizeof(pPrg->dwUseOENews));
#endif
        //
        // Save the new default editor
        //
#ifndef UNIX
        // See if the selection was changed
        tmp = (int) SendMessage(pPrg->hwndHtmlEdit, CB_GETCURSEL, 0, 0);
        if (tmp != pPrg->iHtmlEditor)
        {
            pPrg->iHtmlEditor = tmp;

            // Get the text and hkey for the selected item
            WCHAR szDefault[MAX_PATH];
            SendMessage(pPrg->hwndHtmlEdit, CB_GETLBTEXT, tmp, (LPARAM)szDefault);
            HKEY hkeyFrom = (HKEY)SendMessage(pPrg->hwndHtmlEdit, CB_GETITEMDATA, tmp, 0);

            if (hkeyFrom && (INT_PTR)hkeyFrom != CB_ERR)
            {
                //
                // Save the selected item as the default editor
                //
                DWORD dw;
                HKEY hkeyDest;
                if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_HTML_EDITOR, 0,
                        NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyDest, &dw))
                {
                    // Update the name of the default editor
                    SHSetValue(hkeyDest, NULL, L"Description", REG_SZ, szDefault, CbFromCch(lstrlen(szDefault)+1));

                    // Delete the old shell command (and all subkeys).  This purges keys such as DDEEXEC.
                    SHDeleteKey(hkeyDest, L"shell");

                    // Update the verb of the default editor
                    HKEY hkeyEdit;
                    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyDest, L"shell\\edit", 0,
                            NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyEdit, &dw))
                    {
                        SHCopyKey(hkeyFrom, L"shell\\edit", hkeyEdit, 0);
                        RegCloseKey(hkeyEdit);
                    }
                    RegCloseKey(hkeyDest);
                }

                //
                // Also update Office's default editor
                //
                if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, L"Software\\Microsoft\\Shared\\HTML\\Default Editor", 0,
                        NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyDest, &dw))
                {
                    // Delete the old shell command (and all subkeys).  This purges keys such as DDEEXEC.
                    SHDeleteKey(hkeyDest, L"shell\\edit");

                    // Update the verb of the default editor
                    HKEY hkeyEdit;
                    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyDest, L"shell\\edit", 0,
                            NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyEdit, &dw))
                    {
                        SHCopyKey(hkeyFrom, L"shell\\edit", hkeyEdit, 0);
                        RegCloseKey(hkeyEdit);
                    }
                    RegCloseKey(hkeyDest);
                }

                //
                // Finally, update the edit verb for .htm files so that the shell honors the change.
                // But if .htm uses a stub like moshtmed, we leave it alone and assume that it
                // uses one of the above keys as the default editor.
                //
                HKEY hkeyHtm;
                if (SUCCEEDED(AssocQueryKey(0, ASSOCKEY_SHELLEXECCLASS, L".htm", NULL, &hkeyHtm)))
                {
                    if (!IsHtmlStub(hkeyHtm, L"edit"))
                    {
                        // Delete the old shell command (and all subkeys).  This purges keys such as DDEEXEC.
                        SHDeleteKey(hkeyHtm, L"shell\\edit");

                        // Copy the edit verb to the .htm
                        HKEY hkeyEdit;
                        if (ERROR_SUCCESS == RegCreateKeyEx(hkeyHtm, L"shell\\edit", 0,
                                NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyEdit, &dw))
                        {
                            SHCopyKey(hkeyFrom, L"shell\\edit", hkeyEdit, 0);
                            RegCloseKey(hkeyEdit);
                        }
                    }
    
                    RegCloseKey(hkeyHtm);
                }
            }
        }
#endif //!UNIX

        //
        // Save Mail Client Info
        //

        // is there a new client?
#ifndef UNIX
        tmp = (int) SendMessage(pPrg->hwndMail, CB_GETCURSEL, 0, 0);
        if (tmp!=pPrg->iMail)
        {
            pPrg->iMail = tmp;

            // find it and copy its info
            FindClient(TSZMAILTOPROTOCOL, pPrg->hwndMail, tmp, REGSTR_PATH_MAILCLIENTS);

            //Update the mail icon label
            UpdateMailIconLabel();
#else
        if (pPrg->iMail)
        {
            // copy its info
            FindEditClient(TSZMAILTOPROTOCOL, pPrg->hDlg, IDC_EDIT_PROGRAMS_MAIL,
               REGSTR_PATH_MAILCLIENTS);
#endif
            // tell the world that something has changed
            SendBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_MAILCLIENTS);
        }

        //
        // Save News Client Info
        //

        // is there a new client?
#ifndef UNIX
        tmp = (int) SendMessage(pPrg->hwndNews, CB_GETCURSEL, 0, 0);
        if (tmp!=pPrg->iNews)
        {
            pPrg->iNews = tmp;

            // find it and copy its info
            FindClient(TSZNEWSPROTOCOL, pPrg->hwndNews, tmp, REGSTR_PATH_NEWSCLIENTS);
            FindClient(TEXT("snews"), pPrg->hwndNews, tmp, REGSTR_PATH_NEWSCLIENTS);
            FindClient(TEXT("nntp"), pPrg->hwndNews, tmp, REGSTR_PATH_NEWSCLIENTS);
#else
        if (pPrg->iNews)
        {
            // copy its info
            FindEditClient(TSZNEWSPROTOCOL, pPrg->hDlg, IDC_EDIT_PROGRAMS_NEWS,
               REGSTR_PATH_NEWSCLIENTS);
            //FindEditClient(TEXT("snews"), pPrg->hwndNews, REGSTR_PATH_NEWSCLIENTS);
            //FindEditClient(TEXT("nntp"), pPrg->hwndNews, REGSTR_PATH_NEWSCLIENTS);
#endif

            // tell the world that something has changed
            SendBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_NEWSCLIENTS);
        }

        //
        // Save Internet Call Client info
        //

        // is there a new client?
#ifndef UNIX
        tmp = (int) SendMessage(pPrg->hwndCall, CB_GETCURSEL, 0, 0);
        if (tmp!=pPrg->iCall)
        {
            pPrg->iCall = tmp;

            // find it and copy its info
            FindClient(TSZCALLTOPROTOCOL, pPrg->hwndCall, tmp, REGSTR_PATH_CALLCLIENTS);

            // tell the world that something has changed
            SendBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_CALLCLIENTS);
        }
#else
        if (pPrg->iVSource)
        {
            // copy its info
            FindEditClient(TSZVSOURCEPROTOCOL, pPrg->hDlg, IDC_EDIT_PROGRAMS_VSOURCE,
               REGSTR_PATH_VSOURCECLIENTS);

            // tell the world that something has changed
            SendBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_VSOURCECLIENTS);
        }
#endif


#ifndef UNIX
        //
        // Save Contacts Client Info
        //

        // is there a new client?
        tmp = (int) SendMessage(pPrg->hwndContact, CB_GETCURSEL, 0, 0);
        if (tmp!=pPrg->iContact)
        {
            pPrg->iContact = tmp;

            // find it and copy its info
            FindClient(TSZLDAPPROTOCOL, pPrg->hwndContact, tmp, REGSTR_PATH_CONTACTCLIENTS);

            // tell the world that something has changed
            SendBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_CONTACTCLIENTS);
        }

        //
        // Save Calendar Client Info
        //

        // is there a new client?
        tmp = (int) SendMessage(pPrg->hwndCalendar, CB_GETCURSEL, 0, 0);
        if (tmp!=pPrg->iCalendar)
        {
            pPrg->iCalendar = tmp;

            // find it and copy its info
            FindClient(TSZCALENDARPROTOCOL, pPrg->hwndCalendar, tmp, REGSTR_PATH_CALENDARCLIENTS);

            // tell the world that something has changed
            SendBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_CALENDARCLIENTS);
        }
#endif
        UpdateAllWindows();
        pPrg->fChanged = FALSE;
    }
} // ProgramsDlgApplyNow()

    
extern HRESULT ResetWebSettings(HWND hwnd, BOOL *pfChangedHomePage);

#ifndef UNIX
//
// ProgramsOnCommand()
//
// Handles "Programs" property page's window commands
//
// History:
//
// 6/20/96  t-gpease    created
//
void ProgramsOnCommand(LPPROGRAMSPAGE pPrg, UINT id, UINT nCmd)
{

    switch (id) {

        case IDC_PROGRAMS_HTMLEDITOR_COMBO:
        {
            INT_PTR tmp;

            // Is there a new editor?
            tmp = SendMessage(pPrg->hwndHtmlEdit, CB_GETCURSEL, 0, 0);
            if (tmp != pPrg->iHtmlEditor)
            {
                ENABLEAPPLY(pPrg->hDlg);
                pPrg->fChanged = TRUE;
            }
        }
        break;

        case IDC_PROGRAMS_NEWS_COMBO:
        {
            INT_PTR tmp;
            // is there a new client?
            tmp = SendMessage(pPrg->hwndNews, CB_GETCURSEL, 0, 0);
            if (tmp != pPrg->iNews)
            {
                ENABLEAPPLY(pPrg->hDlg);
                pPrg->fChanged = TRUE;
            }
        }
        break;


        case IDC_PROGRAMS_MAIL_COMBO:
        {
            INT_PTR tmp;
            // is there a new client?
            tmp = SendMessage(pPrg->hwndMail, CB_GETCURSEL, 0, 0);
            if (tmp != pPrg->iMail)
            {
                ENABLEAPPLY(pPrg->hDlg);
                pPrg->fChanged = TRUE;
            }
        }
        break;

        case IDC_PROGRAMS_CALENDAR_COMBO:
        {
            INT_PTR tmp;
            // is there a new client?
            tmp = SendMessage(pPrg->hwndCalendar, CB_GETCURSEL, 0, 0);
            if (tmp != pPrg->iCalendar)
            {
                ENABLEAPPLY(pPrg->hDlg);
                pPrg->fChanged = TRUE;
            }
        }
        break;

        case IDC_PROGRAMS_CONTACT_COMBO:
        {
            INT_PTR tmp;
            // is there a new client?
            tmp = SendMessage(pPrg->hwndContact, CB_GETCURSEL, 0, 0);
            if (tmp != pPrg->iContact)
            {
                ENABLEAPPLY(pPrg->hDlg);
                pPrg->fChanged = TRUE;
            }
        }
        break;

        case IDC_PROGRAMS_CALL_COMBO:
        {
            INT_PTR tmp;
            // is there a new client?
            tmp = SendMessage(pPrg->hwndCall, CB_GETCURSEL, 0, 0);
            if (tmp != pPrg->iCall)
            {
                ENABLEAPPLY(pPrg->hDlg);
                pPrg->fChanged = TRUE;
            }
        }
        break;

        case IDC_RESETWEBSETTINGS:
            {
                BOOL fReloadHomePage;
                ResetWebSettings(pPrg->hDlg,&fReloadHomePage);
                if (fReloadHomePage)
                    g_fReloadHomePage = TRUE;
            }
            break;

        case IDC_PROGRAMS_IE_IS_FTPCLIENT:
        case IDC_CHECK_ASSOCIATIONS_CHECKBOX:
            ENABLEAPPLY(pPrg->hDlg);
            pPrg->fChanged = TRUE;
            break;
    } // switch

} // ProgramsOnCommand()

#else /* !UNIX */

//
// ProgramsOnCommand()
//
// Handles "Programs" property page's window commands
//
// History:
//
// 6/20/96  t-gpease    created
//
void ProgramsOnCommand(LPPROGRAMSPAGE pPrg, UINT id, UINT nCmd)
{

    switch (id) {

        case IDC_EDIT_PROGRAMS_MAIL:
        {
            if (nCmd == EN_CHANGE)
            {
                if (pPrg->iMail != -1)
                {
                    ENABLEAPPLY(pPrg->hDlg);
                    pPrg->iMail = 1;  //change has occoured
                    pPrg->fChanged = TRUE;
                }
            }
        }
        break;

        case IDC_OE_MAIL:
        {
            pPrg->dwUseOEMail = IsDlgButtonChecked(pPrg->hDlg,
                IDC_OE_MAIL) == BST_CHECKED;

            ENABLEAPPLY(pPrg->hDlg);
            pPrg->fChanged = TRUE;

            EnableWindow(pPrg->hwndMail, !pPrg->dwUseOEMail);
            EnableWindow(pPrg->hwndMailEdit, !pPrg->dwUseOEMail);
            EnableWindow(pPrg->hwndMailFind, !pPrg->dwUseOEMail);
        }
        break;

        case IDC_EDIT_PROGRAMS_NEWS:
        {
            if (nCmd == EN_CHANGE)
            {
                if (pPrg->iNews != -1)
                {
                    ENABLEAPPLY(pPrg->hDlg);
                    pPrg->iNews = 1;  //change has occoured
                    pPrg->fChanged = TRUE;
                }
            }
        }
        break;

        case IDC_OE_NEWS:
        {
            pPrg->dwUseOENews = IsDlgButtonChecked(pPrg->hDlg,
                IDC_OE_NEWS) == BST_CHECKED;

            ENABLEAPPLY(pPrg->hDlg);
            pPrg->fChanged = TRUE;

            EnableWindow(pPrg->hwndNews, !pPrg->dwUseOENews);
            EnableWindow(pPrg->hwndNewsEdit, !pPrg->dwUseOENews);
            EnableWindow(pPrg->hwndNewsFind, !pPrg->dwUseOENews);
        }
        break;

        case IDC_EDIT_PROGRAMS_VSOURCE:
        {
            if (nCmd == EN_CHANGE)
            {
                if (pPrg->iVSource != -1)
                {
                    ENABLEAPPLY(pPrg->hDlg);
                    pPrg->iVSource = 1;  //change has occoured
                    pPrg->fChanged = TRUE;
                }
            }
        }
        break;

        case IDC_MAIL_EDIT:
        {
            HKEY hkeyProtocol;
            DWORD dw;

            if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_MAILCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkeyProtocol, &dw) != ERROR_SUCCESS)
                break;
            EditScript(hkeyProtocol);
            RegCloseKey(hkeyProtocol);
        }
        break;

        case IDC_NEWS_EDIT:
        {
            HKEY hkeyProtocol;
            DWORD dw;

            if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_NEWSCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkeyProtocol, &dw) != ERROR_SUCCESS)
                break;
            EditScript(hkeyProtocol);
            RegCloseKey(hkeyProtocol);
        }
        break;

        case IDC_VSOURCE_EDIT:
        {
            HKEY hkeyProtocol;
            DWORD dw;

            if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_VSOURCECLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkeyProtocol, &dw) != ERROR_SUCCESS)
                break;
            EditScript(hkeyProtocol);
            RegCloseKey(hkeyProtocol);
        }
        break;

        case IDC_MAIL_FIND:
        {
            HKEY hkeyProtocol;
            DWORD dw;

                if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_MAILCLIENTS,
                           0, NULL, 0, KEY_READ, NULL, &hkeyProtocol, &dw) != ERROR_SUCCESS)
                    break;
            FindScript(pPrg->hwndMail, hkeyProtocol);
            RegCloseKey(hkeyProtocol);
        }
        break;

        case IDC_NEWS_FIND:
        {
            HKEY hkeyProtocol;
            DWORD dw;

            if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_NEWSCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkeyProtocol, &dw) != ERROR_SUCCESS)
                break;
            FindScript(pPrg->hwndNews, hkeyProtocol);
            RegCloseKey(hkeyProtocol);
        }
        break;

        case IDC_VSOURCE_FIND:
        {
            HKEY hkeyProtocol;
            DWORD dw;

            if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_VSOURCECLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkeyProtocol, &dw) != ERROR_SUCCESS)
                break;
            FindScript(pPrg->hwndVSource, hkeyProtocol);
            RegCloseKey(hkeyProtocol);
        }
        break;
    } // switch

} // ProgramsOnCommand()

#endif  /* !UNIX */

//
// ProgramsDlgProc()
//
// Handles window messages sent to the Programs Property Sheet.
//
// History:
//
// 6/20/96  t-gpease    created
//
INT_PTR CALLBACK ProgramsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                              LPARAM lParam)
{
    LPPROGRAMSPAGE pPrg;

    if (uMsg == WM_INITDIALOG)
        return ProgramsDlgInit( hDlg );
    else
        pPrg= (LPPROGRAMSPAGE) GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pPrg)
        return FALSE;

    switch (uMsg) {

        case WM_COMMAND:
            ProgramsOnCommand(pPrg, LOWORD(wParam), HIWORD(wParam));
            return TRUE;

        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            ASSERT(lpnm);
            switch (lpnm->code)
            {
                case PSN_KILLACTIVE:
#ifdef UNIX
                    if (!(FoundProgram(pPrg->hDlg, IDC_EDIT_PROGRAMS_MAIL) &&
                          FoundProgram(pPrg->hDlg, IDC_EDIT_PROGRAMS_NEWS) &&
                          FoundProgram(pPrg->hDlg, IDC_EDIT_PROGRAMS_VSOURCE)))
                    {
                        MessageBox(pPrg->hDlg, TEXT("One (or more) program is not found or not executable."), NULL, MB_OK);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        return TRUE;
                    }

                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return TRUE;

#endif //UNIX
                case PSN_QUERYCANCEL:
                case PSN_RESET:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return TRUE;

                case PSN_APPLY:
                    //
                    // Save Programs Dlg Stuff.
                    //
                    ProgramsDlgApplyNow(pPrg);
                    break;
            }
        }
        break;

        case WM_HELP:                   // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
        {
#ifndef UNIX
            // Free the data stored the HTML editor combo
            int iMax = (int) SendMessage(pPrg->hwndHtmlEdit, CB_GETCOUNT, 0, 0);
            HKEY hkey;
            for (int i = 0; i < iMax; ++i)
            {
                hkey = (HKEY) SendMessage(pPrg->hwndHtmlEdit, CB_GETITEMDATA, i, 0);
                if (hkey && (INT_PTR)hkey != CB_ERR)
                {
                    RegCloseKey(hkey);
                }
            }

            if (pPrg)
            {
                if (pPrg->pfi)
                    pPrg->pfi->Release();
                LocalFree(pPrg);
            }
#endif
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG)NULL);
            break;
        }
    }
    return FALSE;
}

static const TCHAR c_szMailIcon[] = TEXT("Software\\Microsoft\\MailIcon");
static const TCHAR c_szMailIconGuid[] = TEXT("CLSID\\{dacf95b0-0a3f-11d1-9389-006097d503d9}");
static const TCHAR c_szKeyMail[] = TEXT("Software\\Clients\\Mail");
static const TCHAR c_szRegFmt2[] = TEXT("%s\\%s");
static const TCHAR c_szFormatClient[] = TEXT("FormatClient");
static const TCHAR c_szFormatNoClient[] = TEXT("FormatNoClient");
static       WCHAR c_wszMailIconGuid[] = L"::{dacf95b0-0a3f-11d1-9389-006097d503d9}";

void UpdateMailIconLabel()
{
    TCHAR szOldLabel[MAX_PATH];
    TCHAR szNewLabel[MAX_PATH];
    TCHAR szDefClient[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    DWORD cbSize;
    HKEY  hKey;

    *szNewLabel = 0;
    *szOldLabel = 0;

    // check if the mail icon is even installed
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szMailIcon, 0, KEY_READ, &hKey))
    {
        cbSize = sizeof(szOldLabel);
        // get the current mail icon label
        if (ERROR_SUCCESS == RegQueryValue(HKEY_CLASSES_ROOT, c_szMailIconGuid, szOldLabel, (PLONG)&cbSize))
        {
            cbSize = sizeof(szDefClient);
            // get the default client's reg key
            if (ERROR_SUCCESS == RegQueryValue(HKEY_LOCAL_MACHINE, c_szKeyMail, szDefClient, (PLONG)&cbSize) && cbSize)
            {
                wnsprintf(szTemp, ARRAYSIZE(szTemp), c_szRegFmt2, c_szKeyMail, szDefClient);
                cbSize = sizeof(szDefClient);
                // get the default client's display name
                if (ERROR_SUCCESS == RegQueryValue(HKEY_LOCAL_MACHINE, szTemp, szDefClient, (PLONG)&cbSize) && cbSize)
                {
                    cbSize = sizeof(szTemp);
                    // get the mail icon label format string
                    if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_szFormatClient, 0, NULL, (LPBYTE)szTemp, &cbSize))
                    {
                        wnsprintf(szNewLabel, ARRAYSIZE(szNewLabel), szTemp, szDefClient);
                    }
                }
            }
            else
            {
                cbSize = sizeof(szNewLabel);
                // get the mail icon label format string
                RegQueryValueEx(hKey, c_szFormatNoClient, 0, NULL, (LPBYTE)szNewLabel, &cbSize);
            }
        }
        // if the above succeeded, and the label is different
        if (*szNewLabel && StrCmp(szNewLabel, szOldLabel))
        {
             IShellFolder *psf;

            // set the new label
            RegSetValue(HKEY_CLASSES_ROOT, c_szMailIconGuid, REG_SZ, szNewLabel, (lstrlen(szNewLabel)+1)*sizeof(TCHAR));

            // let the shell know that it changed
            if (SUCCEEDED(SHGetDesktopFolder(&psf)))
            {
                LPITEMIDLIST pidl;
                ULONG        chEaten;

                if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, c_wszMailIconGuid, &chEaten, &pidl, NULL)))
                {
                    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, pidl, NULL);
                    SHFree(pidl);
                }
                psf->Release();
            }
        }
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\security.cpp ===
//*********************************************************************
//*          Microsoft Windows                                       **
//*        Copyright(c) Microsoft Corp., 1995                        **
//*********************************************************************

//
// SECURITY.cpp - "Security" Property Sheet
//

// HISTORY:
//
// 6/22/96  t-gpease    moved to this file
// 5/14/97  t-ashlm     new dialog

#include "inetcplp.h"
#include "inetcpl.h"   // for LSDFLAGS
#include "intshcut.h"
#include "permdlg.h"   // java permissions
#include "pdlgguid.h"  // guids for Java VM permissions dlg
#include <cryptui.h>

#include <mluisupp.h>

void LaunchSecurityDialogEx(HWND hDlg, DWORD dwZone, BOOL bForceUI, BOOL bDisableAddSites);

//
// Private Functions and Structures
//
INT_PTR CALLBACK SecurityAddSitesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK SecurityCustomSettingsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK SecurityAddSitesIntranetDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
void SecurityChanged();

TCHAR *MyIntToStr(TCHAR *pBuf, BYTE iVal);
BOOL SecurityDlgInit(HWND hDlg);


#define WIDETEXT(x) L ## x
#define REGSTR_PATH_SECURITY_LOCKOUT  TEXT("Software\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define REGSTR_VAL_OPTIONS_EDIT       TEXT("Security_options_edit")
#define REGSTR_VAL_ZONES_MAP_EDIT     TEXT("Security_zones_map_edit")
#define REGSTR_VAL_HKLM_ONLY          TEXT("Security_HKLM_only")
#define REGSTR_PATH_SO                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SO")
#define REGSTR_PATH_SOIEAK            TEXT("Sofwtare\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SOIEAK")

///////////////////////////////////////////////////////////////////////////////////////
//
// Structures
//
///////////////////////////////////////////////////////////////////////////////////////

typedef struct tagSECURITYZONESETTINGS
{
    BOOL    dwFlags;            // from the ZONEATTRIBUTES struct
    DWORD   dwZoneIndex;        // as defined by ZoneManager
    DWORD   dwSecLevel;         // current level (High, Medium, Low, Custom)
    DWORD   dwPrevSecLevel;
    DWORD   dwMinSecLevel;      // current min level (High, Medium, Low, Custom)
    DWORD   dwRecSecLevel;      // current recommended level (High, Medium, Low, Custom)
    TCHAR   szDescription[MAX_ZONE_DESCRIPTION];
    TCHAR   szDisplayName[MAX_ZONE_PATH];
    HICON   hicon;
} SECURITYZONESETTINGS, *LPSECURITYZONESETTINGS;

// structure for main security page
typedef struct tagSECURITYPAGE
{
    HWND                    hDlg;                   // handle to window
    LPURLZONEMANAGER        pInternetZoneManager;   // pointer to InternetZoneManager
    IInternetSecurityManager *pInternetSecurityManager; // pointer to InternetSecurityMan