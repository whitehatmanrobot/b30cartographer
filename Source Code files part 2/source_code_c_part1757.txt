      1005
#define IDC_CI_LENGTH                   1006
#define IDC_CI_TYPE                     1007
#define IDC_CI_VERSION                  1008
#define IDC_CI_STATUS                   1009
#define IDC_CI_SCALE                    1010
#define IDC_CI_USER_DATA                1011
#define IDC_CI_COUNTER_NAME             1012
#define IDC_CI_FULL_NAME                1013
#define IDC_CI_EXPLAIN_TEXT             1014
#define IDC_RV_FIRST                    1015
#define IDC_RV_SECOND                   1016
#define IDC_RV_STATUS                   1017
#define IDC_RV_TYPE                     1018
#define IDC_FMT_LONG_VALUE              1019
#define IDC_FMT_DBL_VALUE               1020
#define IDC_BROWSE                      1020
#define IDC_FMT_LARGE_VALUE             1021
#define IDC_MACHINE_COMBO               1021
#define IDC_CI_MACHINE_NAME             1022
#define IDC_OBJECT_COMBO                1022
#define IDC_CI_OBJECT_NAME              1023
#define IDC_CI_INSTANCE_NAME            1024
#define IDC_INSTANCE_LIST               1024
#define IDC_CI_PARENT_NAME              1025
#define IDC_COUNTER_PATH                1025
#define IDC_SHOW_INDEX_NO               1026
#define IDC_TIME_STAMP                  1026
#define IDC_ALL_COUNTERS                1027
#define IDC_CI_DEFAULT_SCALE            1027
#define IDC_HELP_BTN                    1028
#define IDC_INCLUDE_MACHINE_NAME        1030
#define IDC_MACHINE_OBJECT_LIST         1031
#define IDC_USE_LOCAL_MACHINE           1032
#define IDC_SELECT_MACHINE              1033
#define IDC_NETWORK                     1034
#define IDC_ALL_INSTANCES               1036
#define IDC_USE_INSTANCE_LIST           1037
#define IDC_1SEC_BTN                    1038
#define IDC_CI_DATA_POINTS              1039
#define IDC_CI_AVERAGE_VALUE            1040
#define IDC_SELECT_DATA                 1040
#define IDC_CI_MIN_VALUE                1041
#define IDC_CI_MAX_VALUE                1042
#define IDC_LOG_FILE_NAME               1042
#define IDC_START_TIME                  1043
#define IDC_END_TIME                    1044
#define IDC_SAMPLE_COUNT                1045
#define IDC_CHECK_PATH_BTN              1046
#define IDC_MACHINE_NAME_EDIT           1047
#define IDC_MACHINE_NAME_CHK            1048
#define IDC_OBJECT_NAME_EDIT            1049
#define IDC_INSTANCE_NAME_CHK           1050
#define IDC_INSTANCE_NAME_EDIT          1051
#define IDC_COUNTER_NAME_EDIT           1052
#define IDC_WBEM_INPUT_CHK              1053
#define IDC_WBEM_OUTPUT_CHK             1054
#define IDC_FULL_PATH_STRING_EDIT       1055
#define IDC_ENTER_ELEM_BTN              1057
#define IDC_ENTER_PATH_BTN              1058
#define IDC_UNICODE_CHK                 1059
#define IDC_PROCESS_BTN                 1060
#define IDC_OBJ_NAME_LABEL              1061
#define IDC_COUNTER_NAME_LABEL          1062
#define IDC_PATH_STRING_LABEL           1063

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1064
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\countervaldlg.h ===
#if !defined(AFX_COUNTERVALDLG_H__8F3F6936_9221_11D3_B371_00105A1469B7__INCLUDED_)
#define AFX_COUNTERVALDLG_H__8F3F6936_9221_11D3_B371_00105A1469B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CounterValDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCounterValDlg dialog

class CCounterValDlg : public CDialog
{
// Construction
public:
	CCounterValDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCounterValDlg)
	enum { IDD = IDD_COUNTER_VAL };
	long	m_lCounter;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCounterValDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCounterValDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COUNTERVALDLG_H__8F3F6936_9221_11D3_B371_00105A1469B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\countervaldlg.cpp ===
// CounterValDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ShowPerfLib.h"
#include "CounterValDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCounterValDlg dialog


CCounterValDlg::CCounterValDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCounterValDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCounterValDlg)
	m_lCounter = 0;
	//}}AFX_DATA_INIT
}


void CCounterValDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCounterValDlg)
	DDX_Text(pDX, IDC_CTR_VAL, m_lCounter);
	DDV_MinMaxLong(pDX, m_lCounter, 0, 9999999);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCounterValDlg, CDialog)
	//{{AFX_MSG_MAP(CCounterValDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCounterValDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\listperf.cpp ===
// ListPerf.cpp : implementation file
//

#include "stdafx.h"
#include "ShowPerfLib.h"
#include "ListPerf.h"
#include "ntreg.h"
#include "Showperflibdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListPerfDlg dialog


CListPerfDlg::CListPerfDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CListPerfDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CListPerfDlg)
	m_bCheckRef = FALSE;
	//}}AFX_DATA_INIT
}


void CListPerfDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CListPerfDlg)
	DDX_Control(pDX, IDOK, m_wndOK);
	DDX_Control(pDX, IDC_PERFLIBS, m_wndPerfLibs);
	DDX_Check(pDX, IDC_CHECKREF, m_bCheckRef);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CListPerfDlg, CDialog)
	//{{AFX_MSG_MAP(CListPerfDlg)
	ON_BN_CLICKED(IDC_RESETSTATUS, OnResetstatus)
	ON_NOTIFY(NM_DBLCLK, IDC_PERFLIBS, OnDblclkPerflibs)
	ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
	ON_BN_CLICKED(IDC_HIDEPERFS, OnHideperfs)
	ON_BN_CLICKED(IDC_UNHIDEPERFS, OnUnhideperfs)
	ON_NOTIFY(NM_CLICK, IDC_PERFLIBS, OnClickPerflibs)
	ON_BN_CLICKED(IDC_CHECKREF, OnCheckref)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CListPerfDlg message handlers

BOOL CListPerfDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

	m_wndPerfLibs.InsertColumn( 0, "PerfLib", LVCFMT_LEFT, 100 );
	m_wndPerfLibs.InsertColumn( 1, "Status", LVCFMT_LEFT, 100 );	
	m_wndPerfLibs.InsertColumn( 2, "Active", LVCFMT_LEFT, 100 );	

	AddPerfLibs();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CListPerfDlg::GetCurrentSelection()
{
	POSITION pos = m_wndPerfLibs.GetFirstSelectedItemPosition();

	if ( NULL != pos )
	{
		int nItem = m_wndPerfLibs.GetNextSelectedItem( pos );
		m_strPerfName = m_wndPerfLibs.GetItemText( nItem, 0 );
	}
}

BOOL CListPerfDlg::AddPerfLibs()
{
	BOOL bRet = TRUE;

	CNTRegistry	reg;
	long lError;
	
	lError = reg.Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" );

	DWORD	dwIndex = 0;
	DWORD	dwBuffSize = 0;
	WCHAR*	wszServiceName = NULL;
	WCHAR	wszServiceKey[512];
	WCHAR	wszPerformanceKey[512];

	while ( CNTRegistry::no_error == lError )
	{

		// For each service name, we will check for a performance 
		// key and if it exists, we will process the library
		// ======================================================

		lError = reg.Enum( dwIndex, &wszServiceName , dwBuffSize );

		if ( CNTRegistry::no_error == lError )
		{
			// Create the perfomance key path
			// ==============================
			wcscpy( wszServiceKey, L"SYSTEM\\CurrentControlSet\\Services\\" );
			wcscat( wszServiceKey, wszServiceName );

			wcscpy( wszPerformanceKey, wszServiceKey );
			wcscat( wszPerformanceKey, L"\\Performance" );

			CNTRegistry	subreg;

			// Atempt to open the performance registry key for the service
			// ===========================================================

			if ( CNTRegistry::no_error == subreg.Open( HKEY_LOCAL_MACHINE, wszPerformanceKey ) )
			{
				DWORD dwVal = 0;
				subreg.GetDWORD(L"WbemAdapStatus", &dwVal );
				CHAR szStatus[64];
				sprintf(szStatus, "0x%0.4x", dwVal );

				int nNumItems = m_wndPerfLibs.GetItemCount();

				CHAR szServiceName[512];
				wcstombs( szServiceName, wszServiceName, 512 );

				m_wndPerfLibs.InsertItem( nNumItems, szServiceName );
				m_wndPerfLibs.SetItemText( nNumItems, 1, szStatus );
				m_wndPerfLibs.SetItemText( nNumItems, 2, "active" );
			}
			else
			{
				// Check the xPerfomance key path
				// ==============================

				wcscpy( wszPerformanceKey, wszServiceKey );
				wcscat( wszPerformanceKey, L"\\xPerformance" );

				CNTRegistry	subreg;

				// Atempt to open the performance registry key for the service
				// ===========================================================

				if ( CNTRegistry::no_error == subreg.Open( HKEY_LOCAL_MACHINE, wszPerformanceKey ) )
				{
					DWORD dwVal = 0;
					subreg.GetDWORD(L"WbemAdapStatus", &dwVal );
					CHAR szStatus[64];
					sprintf(szStatus, "0x%0.4x", dwVal );

					int nNumItems = m_wndPerfLibs.GetItemCount();

					CHAR szServiceName[512];
					wcstombs( szServiceName, wszServiceName, 512 );

					m_wndPerfLibs.InsertItem( nNumItems, szServiceName );
					m_wndPerfLibs.SetItemText( nNumItems, 1, szStatus );
					m_wndPerfLibs.SetItemText( nNumItems, 2, "inactive" );
				}
			}	
		}	
		dwIndex++;
	}

	return bRet;
}

void CListPerfDlg::OnResetstatus() 
{
	CNTRegistry	reg;
	long lError;
	
	lError = reg.Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" );

	DWORD	dwIndex = 0;
	DWORD	dwBuffSize = 0;
	WCHAR*	wszServiceName = NULL;
	WCHAR	wszServiceKey[512];
	WCHAR	wszPerformanceKey[512];

	while ( CNTRegistry::no_error == lError )
	{

		// For each service name, we will check for a performance 
		// key and if it exists, we will process the library
		// ======================================================

		lError = reg.Enum( dwIndex, &wszServiceName , dwBuffSize );

		if ( CNTRegistry::no_error == lError )
		{
			// Create the perfomance key path
			// ==============================
			wcscpy( wszServiceKey, L"SYSTEM\\CurrentControlSet\\Services\\" );
			wcscat( wszServiceKey, wszServiceName );

			wcscpy( wszPerformanceKey, wszServiceKey );
			wcscat( wszPerformanceKey, L"\\Performance" );

			CNTRegistry	subreg;

			// Atempt to open the performance registry key for the service
			// ===========================================================

			if ( CNTRegistry::no_error == subreg.Open( HKEY_LOCAL_MACHINE, wszPerformanceKey ) )
			{
				subreg.SetDWORD( L"WbemAdapStatus", 0 );
			}
		}	
		dwIndex++;
	}

	OnRefresh();
}

void CListPerfDlg::OnClickPerflibs(NMHDR* pNMHDR, LRESULT* pResult) 
{
	m_wndOK.EnableWindow();	

	*pResult = 0;
}

void CListPerfDlg::SelectPerfLib()
{
	GetCurrentSelection();

	CShowPerfLibDlg	dlg(m_strPerfName, m_bCheckRef);

	dlg.DoModal();
}

void CListPerfDlg::OnDblclkPerflibs(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SelectPerfLib();
	*pResult = 0;
}

void CListPerfDlg::OnOK() 
{
	SelectPerfLib();
	//CDialog::OnOK();
}


void CListPerfDlg::OnRefresh() 
{
	m_wndPerfLibs.DeleteAllItems();
	AddPerfLibs();	
}

void CListPerfDlg::OnHideperfs() 
{
	WCHAR	wszServiceName[512];
	char	szServiceName[512];
	WCHAR	wszServiceKey[512];
	WCHAR	wszPerformanceKey[512];

	UINT	uIndex = 0,
			uSelectedCount = m_wndPerfLibs.GetSelectedCount();

	int		nItem = -1;

	for ( uIndex = 0; uIndex < uSelectedCount; uIndex++ )
	{
		nItem = m_wndPerfLibs.GetNextItem( nItem, LVNI_SELECTED );
		m_wndPerfLibs.GetItemText( nItem, 0, szServiceName, 256 );
		mbstowcs( wszServiceName, szServiceName, 512 );

		// Create the perfomance key path
		// ==============================
		wcscpy( wszServiceKey, L"SYSTEM\\CurrentControlSet\\Services\\" );
		wcscat( wszServiceKey, wszServiceName );

		wcscpy( wszPerformanceKey, wszServiceKey );
		wcscat( wszPerformanceKey, L"\\Performance" );

		CNTRegistry	subreg;

		// Atempt to open the performance registry key for the service
		// ===========================================================

		if ( CNTRegistry::no_error == subreg.Open( HKEY_LOCAL_MACHINE, wszPerformanceKey ) )
		{
			Swap( wszServiceName, L"Performance", L"xPerformance" );
		}

	}

	OnRefresh();
}

void CListPerfDlg::OnUnhideperfs() 
{
	WCHAR	wszServiceName[512];
	char	szServiceName[512];
	WCHAR	wszServiceKey[512];
	WCHAR	wszPerformanceKey[512];

	UINT	uIndex = 0,
			uSelectedCount = m_wndPerfLibs.GetSelectedCount();

	int		nItem = -1;

	for ( uIndex = 0; uIndex < uSelectedCount; uIndex++ )
	{
		nItem = m_wndPerfLibs.GetNextItem( nItem, LVNI_SELECTED );
		m_wndPerfLibs.GetItemText( nItem, 0, szServiceName, 256 );
		mbstowcs( wszServiceName, szServiceName, 512 );

		// Create the perfomance key path
		// ==============================
		wcscpy( wszServiceKey, L"SYSTEM\\CurrentControlSet\\Services\\" );
		wcscat( wszServiceKey, wszServiceName );

		wcscpy( wszPerformanceKey, wszServiceKey );
		wcscat( wszPerformanceKey, L"\\xPerformance" );

		CNTRegistry	subreg;

		// Atempt to open the performance registry key for the service
		// ===========================================================

		if ( CNTRegistry::no_error == subreg.Open( HKEY_LOCAL_MACHINE, wszPerformanceKey ) )
		{
			Swap( wszServiceName, L"xPerformance", L"Performance" );
		}
	}

	OnRefresh();
}

void CListPerfDlg::Swap( WCHAR* wszPerformanceKey, WCHAR* wszFrom, WCHAR* wszTo )
{
	long	lRet = ERROR_SUCCESS;

	WCHAR	wszPath[512];
	DWORD	dwDisp = 0;
	HKEY	hSvcKey = NULL;
	HKEY	hFromKey = NULL;
	HKEY	hToKey = NULL;

	swprintf( wszPath, L"SYSTEM\\CurrentControlSet\\Services\\%s", wszPerformanceKey );
	lRet = RegOpenKeyExW( HKEY_LOCAL_MACHINE, wszPath, 0, KEY_ALL_ACCESS, &hSvcKey );

	if ( ERROR_SUCCESS == lRet )
	{
		lRet = RegOpenKeyExW( hSvcKey, wszFrom, 0, KEY_ALL_ACCESS, &hFromKey );
	}

	if ( ERROR_SUCCESS == lRet )
	{
		lRet = RegCreateKeyExW( hSvcKey, wszTo, 0, NULL, NULL, KEY_ALL_ACCESS, NULL, &hToKey, &dwDisp );
	}

	// Enumerate and copy
	
	DWORD	dwIndex = 0;
	WCHAR	wszName[256];
	DWORD	dwNameSize = 256;
	DWORD	dwType = 0;
	BYTE	pBuffer[2048];
	DWORD	dwBufferSize = 2048;

	while ( ERROR_SUCCESS == lRet )
	{
		dwBufferSize = 2048;
		dwNameSize = 256;

		lRet = RegEnumValueW( hFromKey, dwIndex, wszName, &dwNameSize, 0, &dwType, pBuffer, &dwBufferSize );
		if ( ERROR_SUCCESS == lRet )
		{
			RegSetValueExW( hToKey, wszName, 0, dwType, pBuffer, dwBufferSize );
		}

		dwIndex++;
	}

	lRet = RegCloseKey( hFromKey );
	lRet = RegCloseKey( hToKey );

	lRet = RegDeleteKeyW( hSvcKey, wszFrom );
	lRet = RegCloseKey( hSvcKey );
}

void CListPerfDlg::OnCheckref() 
{
	UpdateData();	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\ntreg.h ===
//***************************************************************************
//
//  REG.H
//
//  Utility registry classes.
//
//  a-raymcc    30-May-96   Created.
//
//***************************************************************************

#ifndef _NTREG_H_
#define _NTREG_H_
//#include "corepol.h"

class CNTRegistry
{
    HKEY	m_hPrimaryKey;
    HKEY	m_hSubkey;
    int		m_nStatus;
	LONG	m_nLastError;
   
public:
    enum { no_error, failed, out_of_memory, no_more_items };
    
    CNTRegistry();
   ~CNTRegistry();

    int Open(HKEY hStart, WCHAR *pszStartKey);

    int MoveToSubkey(WCHAR *pszNewSubkey);

    int GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue);
    int GetStr(WCHAR *pwszValueName, WCHAR **pwszValue);

	//Returns a pointer to a string buffer containing the null-terminated string.
	//The last entry is a double null terminator (i.e. the registry format for
	//a REG_MULTI_SZ).  Caller has do "delete []" the returned pointer.
	//dwSize is the size of the buffer returned.
	int GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize);

	// Allows key enumneration
	int Enum( DWORD dwIndex, WCHAR** pwszValue, DWORD& dwSize );

	int SetDWORD(WCHAR *pwszValueName, DWORD dwValue);
	int SetStr(WCHAR *pwszValueName, WCHAR *wszValue);

	LONG GetLastError() { return m_nLastError; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\ntreg.cpp ===
//***************************************************************************
//
//  REG.CPP
//
//  Utility CNTRegistry classes.
//
//  a-raymcc    30-May-96   Created.
//
//***************************************************************************

#include <windows.h>

#include <stdio.h>
#include "ntreg.h"
//#include <dbgalloc.h>

//#include "adaputil.h"

CNTRegistry::CNTRegistry() : m_hPrimaryKey(0), 
							 m_hSubkey(0),
							 m_nStatus(0),
							 m_nLastError(no_error)
{}

CNTRegistry::~CNTRegistry()
{
    if (m_hSubkey)
        RegCloseKey(m_hSubkey);
    if (m_hPrimaryKey != m_hSubkey)
        RegCloseKey(m_hPrimaryKey);
}

int CNTRegistry::Open(HKEY hStart, WCHAR *pszStartKey)
{
    int nStatus = no_error;

 	m_nLastError = RegOpenKeyExW(hStart, pszStartKey,
									0, KEY_ALL_ACCESS, &m_hPrimaryKey );

    if (m_nLastError != 0)
            nStatus = failed;

	m_hSubkey = m_hPrimaryKey;

    return nStatus;
}

int CNTRegistry::MoveToSubkey(WCHAR *pszNewSubkey)
{
    int nStatus = no_error;

	m_nLastError = RegOpenKeyExW(m_hPrimaryKey, pszNewSubkey, 0, KEY_ALL_ACCESS, &m_hSubkey );

    if (m_nLastError != 0)
            nStatus = failed;

    return nStatus;
}

int CNTRegistry::GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue)
{
	int nStatus = no_error;

    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
								LPBYTE(pdwValue), &dwSize);
    if (m_nLastError != 0)
		nStatus = failed;

    if (dwType != REG_DWORD)
        nStatus = failed;

    return nStatus;
}

int CNTRegistry::GetStr(WCHAR *pwszValueName, WCHAR **pwszValue)
{
    *pwszValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
									0, &dwSize);
    if (m_nLastError != 0)
		return failed;

    if ( ( dwType != REG_SZ ) && ( dwType != REG_EXPAND_SZ ) )
        return failed;

    WCHAR *p = new WCHAR[dwSize];

	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
									LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
		return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
		WCHAR* wszTemp = NULL;

		// Get the initial length

        DWORD nSize = ExpandEnvironmentStringsW( (WCHAR *)p, wszTemp, 0 ) + 10;
        wszTemp = new WCHAR[ nSize ];
        ExpandEnvironmentStringsW( (WCHAR *)p, wszTemp, nSize - 1 );
        delete [] p;
        *pwszValue = wszTemp;
    }
	else
		*pwszValue = p;

    return no_error;
}

int CNTRegistry::Enum( DWORD dwIndex, WCHAR **pwszValue, DWORD& dwSize )
{
	DWORD	dwBuffSize = dwSize;

	m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, *pwszValue, &dwBuffSize,
									NULL, NULL, NULL, NULL );

	while ( m_nLastError == ERROR_MORE_DATA )
	{
		// Grow in 256 byte chunks
		dwBuffSize += 256;

		try
		{
			// Reallocate the buffer and retry
			WCHAR*	p = new WCHAR[dwBuffSize];

			if ( NULL != *pwszValue )
			{
				delete *pwszValue;
			}

			*pwszValue = p;
			dwSize = dwBuffSize;

			m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, *pwszValue, &dwBuffSize,
											NULL, NULL, NULL, NULL );

		}
		catch (...)
		{
			return out_of_memory;
		}

	}

	if ( ERROR_SUCCESS != m_nLastError )
	{
		if ( ERROR_NO_MORE_ITEMS == m_nLastError )
			return no_more_items;
		else
			return failed;
	}

    return no_error;
}

int CNTRegistry::GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize)
{
	//Find out the size of the buffer required
	DWORD dwType;
	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, NULL, &dwSize);

	//If the error is an unexpected one bail out
	if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
	{
		dwSize = 0;
		return failed;
	}

	if (dwSize == 0)
	{
		dwSize = 0;
		return failed;
	}

	//allocate the buffer required
	WCHAR *pData = new WCHAR[dwSize];
	
	//get the values
	m_nLastError = RegQueryValueExW(m_hSubkey, 
								   pwszValueName, 
								   0, 
								   &dwType, 
								   LPBYTE(pData), 
								   &dwSize);

	//if an error bail out
	if (m_nLastError != 0)
	{
		delete [] pData;
		dwSize = 0;
		return failed;
	}

	*pwszValue = pData;

	return no_error;
}

int CNTRegistry::SetDWORD(WCHAR *pwszValueName, DWORD dwValue)
{
	int nStatus = no_error;

	m_nLastError = RegSetValueExW( m_hSubkey, 
								   pwszValueName,
								   0,
								   REG_DWORD,
								   (BYTE*)&dwValue,
								   sizeof( dwValue ) );

	if ( m_nLastError != ERROR_SUCCESS )
	{
		nStatus = failed;
	}

	return nStatus;
}

int CNTRegistry::SetStr(WCHAR *pwszValueName, WCHAR *wszValue)
{
	int nStatus = no_error;

	m_nLastError = RegSetValueExW( m_hSubkey, 
								   pwszValueName,
								   0,
								   REG_SZ,
								   (BYTE*)wszValue,
								   sizeof(WCHAR) * (wcslen(wszValue) + 1) );

	if ( m_nLastError != ERROR_SUCCESS )
	{
		nStatus = failed;
	}

	return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\perfselection.cpp ===
// PerfSelection.cpp : implementation file
//

#include "stdafx.h"
#include "ShowPerfLib.h"
#include "PerfSelection.h"
#include "ntreg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPerfSelection dialog


CPerfSelection::CPerfSelection(CWnd* pParent /*=NULL*/)
	: CDialog(CPerfSelection::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPerfSelection)
	m_strService = _T("");
	//}}AFX_DATA_INIT
}


void CPerfSelection::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPerfSelection)
	DDX_Control(pDX, IDC_SERVICE, m_wndService);
//	DDX_Control(pDX, IDC_PERFLIST, m_wndPerfList);
	DDX_Text(pDX, IDC_SERVICE, m_strService);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPerfSelection, CDialog)
	//{{AFX_MSG_MAP(CPerfSelection)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPerfSelection message handlers

BOOL CPerfSelection::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

	InitList();

	m_wndService.SetFocus();

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPerfSelection::InitList()
{
	CNTRegistry Reg;
	WCHAR	wszServiceKey[512], 
			wszPerformanceKey[512];

	if ( CNTRegistry::no_error == Reg.Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" ) )
	{
		DWORD	dwIndex = 0;

		// Iterate through the services list
		// =================================

		DWORD	dwBuffSize = 0;
		WCHAR*	wcsServiceName = NULL;
		long lError = CNTRegistry::no_error;

		while ( CNTRegistry::no_error == lError )
		{
			// For each service name, we will check for a performance 
			// key and if it exists, we will process the library
			// ======================================================

			lError = Reg.Enum( dwIndex, &wcsServiceName , dwBuffSize );
			if ( CNTRegistry::no_error ==  lError )
			{
				// Create the perfomance key path
				// ==============================

				swprintf(wszServiceKey, L"SYSTEM\\CurrentControlSet\\Services\\%s", wcsServiceName);
				swprintf(wszPerformanceKey, L"%s\\Performance", wszServiceKey);

				CNTRegistry	RegSubKey;

				// Atempt to open the performance registry key for the service
				// ===========================================================

				if ( CNTRegistry::no_error == RegSubKey.Open( HKEY_LOCAL_MACHINE, wszPerformanceKey ) )
				{
					CString str(wcsServiceName);
					m_wndPerfList.InsertItem( 1, str );
				}
				dwIndex++;
			}
		}
	}
}


void CPerfSelection::OnOK() 
{
	// TODO: Add extra validation here

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ShowPerfLib.rc
//
#define IDD_SHOWPERFLIB_DIALOG          102
#define IDR_MAINFRAME                   128
#define IDD_PERFSELECTION               129
#define IDD_LISTPERF                    130
#define IDC_PERFTREE                    1000
#define IDC_SERVICE                     1003
#define IDC_RESETSTATUS                 1005
#define IDC_PERFLIBS                    1006
#define IDC_REFRESH                     1007
#define IDC_HIDEPERFS                   1008
#define IDC_UNHIDEPERFS                 1009
#define IDC_ERRORS                      1011
#define IDC_CHECKREF                    1012
#define IDC_REQUEST                     1020
#define IDC_GET_COUNTER                 1022

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\perfselection.h ===
#if !defined(AFX_PERFSELECTION_H__5547DA35_0860_11D3_B35C_00105A1469B7__INCLUDED_)
#define AFX_PERFSELECTION_H__5547DA35_0860_11D3_B35C_00105A1469B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PerfSelection.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPerfSelection dialog

class CPerfSelection : public CDialog
{
// Construction
public:
	CPerfSelection(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPerfSelection)
	enum { IDD = IDD_PERFSELECTION };
	CEdit	m_wndService;
	CListCtrl	m_wndPerfList;
	CString	m_strService;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPerfSelection)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	CString GetServiceName() {return m_strService;}

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPerfSelection)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void InitList();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PERFSELECTION_H__5547DA35_0860_11D3_B35C_00105A1469B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\listperf.h ===
#if !defined(AFX_LISTPERF_H__B6F3F82D_2245_11D3_B360_00105A1469B7__INCLUDED_)
#define AFX_LISTPERF_H__B6F3F82D_2245_11D3_B360_00105A1469B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ListPerf.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CListPerfDlg dialog

class CListPerfDlg : public CDialog
{
// Construction
public:
	CListPerfDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CListPerfDlg)
	enum { IDD = IDD_LISTPERF };
	CButton	m_wndOK;
	CListCtrl	m_wndPerfLibs;
	BOOL	m_bCheckRef;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListPerfDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CListPerfDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnResetstatus();
	afx_msg void OnDblclkPerflibs(NMHDR* pNMHDR, LRESULT* pResult);
	virtual void OnOK();
	afx_msg void OnRefresh();
	afx_msg void OnHideperfs();
	afx_msg void OnUnhideperfs();
	afx_msg void OnClickPerflibs(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCheckref();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CString m_strPerfName;

	BOOL AddPerfLibs();
	void GetCurrentSelection();
	void Swap( WCHAR* wszPerformanceKey, WCHAR* wszFrom, WCHAR* wszTo );
	void SelectPerfLib();
public:
	CString GetPerfName(){ return m_strPerfName; }
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LISTPERF_H__B6F3F82D_2245_11D3_B360_00105A1469B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\showperflib.h ===
// ShowPerfLib.h : main header file for the SHOWPERFLIB application
//

#if !defined(AFX_SHOWPERFLIB_H__3FF01277_0700_11D3_B35B_00105A1469B7__INCLUDED_)
#define AFX_SHOWPERFLIB_H__3FF01277_0700_11D3_B35B_00105A1469B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CShowPerfLibApp:
// See ShowPerfLib.cpp for the implementation of this class
//

class CShowPerfLibApp : public CWinApp
{
public:
	CShowPerfLibApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CShowPerfLibApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CShowPerfLibApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHOWPERFLIB_H__3FF01277_0700_11D3_B35B_00105A1469B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\showperflib.cpp ===
// ShowPerfLib.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ShowPerfLib.h"
//#include "ShowPerfLibDlg.h"
#include "ListPerf.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CShowPerfLibApp

BEGIN_MESSAGE_MAP(CShowPerfLibApp, CWinApp)
	//{{AFX_MSG_MAP(CShowPerfLibApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CShowPerfLibApp construction

CShowPerfLibApp::CShowPerfLibApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CShowPerfLibApp object

CShowPerfLibApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CShowPerfLibApp initialization

BOOL CShowPerfLibApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CListPerfDlg	dlg;

	m_pMainWnd = &dlg;

	int nResponse = dlg.DoModal();

	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ShowPerfLib.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\showperflibdlg.h ===
// ShowPerfLibDlg.h : header file
//

#if !defined(AFX_SHOWPERFLIBDLG_H__3FF01279_0700_11D3_B35B_00105A1469B7__INCLUDED_)
#define AFX_SHOWPERFLIBDLG_H__3FF01279_0700_11D3_B35B_00105A1469B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <winperf.h>
#include "TitleDB.h"
#include "PerfSelection.h"

enum
{
	PERF_SUCCESS,
	PERF_INFO,
	PERF_MORE_DATA,
	PERF_WARNING,
	PERF_FAILURE
};

/////////////////////////////////////////////////////////////////////////////
// CShowPerfLibDlg dialog

class CShowPerfLibDlg : public CDialog
{
// Construction
public:
	CShowPerfLibDlg(CWnd* pParent = NULL);	// standard constructor
	CShowPerfLibDlg(CString strService, BOOL bRefCheck, CWnd* pParent =NULL );
	virtual ~CShowPerfLibDlg();

// Dialog Data
	//{{AFX_DATA(CShowPerfLibDlg)
	enum { IDD = IDD_SHOWPERFLIB_DIALOG };
	CButton	m_wndGetCounter;
	CListCtrl	m_wndErrorLog;
	CTreeCtrl	m_wndPerfTree;
	CString	m_strRequest;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CShowPerfLibDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CShowPerfLibDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnChangeRequest();
	afx_msg void OnGetCounter();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	HINSTANCE			m_hLib;				// The handle to the perflib
	PM_OPEN_PROC*		m_pfnOpenProc;		// The function pointer to the perflib's open function
	PM_COLLECT_PROC*	m_pfnCollectProc;	// The function pointer to the perflib's collect function
	PM_CLOSE_PROC*		m_pfnCloseProc;		// The function pointer to the perflib's close function

	CTitleLibrary		m_TitleLibrary;
	CPerfSelection		m_wndPerfSelection;

	CString				m_strPerfLib;
	CString				m_strOpen;
	CString				m_strCollect;
	CString				m_strClose;
	CString				m_strService;

	BOOL				m_bRefCheck;

	BOOL InitPerfLibTree();
	BOOL InitService();
	BOOL OpenLibrary();
	BOOL GetData();
	BOOL Collect( CString strSpace );
	BOOL BuildSubTree( CString strSpace, BYTE* pBlob, DWORD dwNumObjects);
	BOOL CloseLibrary();

	void Log( DWORD dwState, CString strDesc );
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHOWPERFLIBDLG_H__3FF01279_0700_11D3_B35B_00105A1469B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__3FF0127B_0700_11D3_B35B_00105A1469B7__INCLUDED_)
#define AFX_STDAFX_H__3FF0127B_0700_11D3_B35B_00105A1469B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3FF0127B_0700_11D3_B35B_00105A1469B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\showperflibdlg.cpp ===
// ShowPerfLibDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ShowPerfLib.h"
#include "ShowPerfLibDlg.h"
#include "PerfSelection.h"
#include "ntreg.h"
#include "listperf.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CShowPerfLibDlg dialog

CShowPerfLibDlg::CShowPerfLibDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CShowPerfLibDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CShowPerfLibDlg)
	m_strRequest = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_strService = _T("");
}

CShowPerfLibDlg::CShowPerfLibDlg(CString strService, BOOL bRefCheck, CWnd* pParent /*=NULL*/)
	: m_strService( strService ), m_bRefCheck(bRefCheck), CDialog(CShowPerfLibDlg::IDD, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

CShowPerfLibDlg::~CShowPerfLibDlg()
{
	CloseLibrary();
	FreeLibrary( m_hLib );
}

void CShowPerfLibDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CShowPerfLibDlg)
	DDX_Control(pDX, IDC_GET_COUNTER, m_wndGetCounter);
	DDX_Control(pDX, IDC_ERRORS, m_wndErrorLog);
	DDX_Control(pDX, IDC_PERFTREE, m_wndPerfTree);
	DDX_Text(pDX, IDC_REQUEST, m_strRequest);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CShowPerfLibDlg, CDialog)
	//{{AFX_MSG_MAP(CShowPerfLibDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_EN_CHANGE(IDC_REQUEST, OnChangeRequest)
	ON_BN_CLICKED(IDC_GET_COUNTER, OnGetCounter)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////	////////////////////////////////////////////////////////////////
// CShowPerfLibDlg message handlers

BOOL CShowPerfLibDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
//	SetIcon(m_hIcon, TRUE);			// Set big icon
//	SetIcon(m_hIcon, FALSE);		// Set small icon

	SetWindowText( m_strService );

	int nCol;
	nCol = m_wndErrorLog.InsertColumn(0, "Type", LVCFMT_LEFT, 75 );
	nCol = m_wndErrorLog.InsertColumn(1, "Description", LVCFMT_LEFT, 500 );

	InitPerfLibTree();

	return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CShowPerfLibDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CShowPerfLibDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


/////////////////////////////////////////////////////////////////////////////
//
//	Perf Lib methods
//
/////////////////////////////////////////////////////////////////////////////

BOOL CShowPerfLibDlg::InitPerfLibTree()
{				
	BOOL bRet = TRUE;

	CWaitCursor	wc;

	if (InitService())
	{
		if ( OpenLibrary() )
		{
			bRet = GetData();
		}
	}


	return bRet;
}

BOOL CShowPerfLibDlg::InitService()
{
	BOOL bRet = TRUE;

	CNTRegistry Reg;
	WCHAR	wszKey[128];

	char	szLog[256];

	swprintf(wszKey, L"SYSTEM\\CurrentControlSet\\Services\\%S\\Performance", m_strService);

	if ( CNTRegistry::no_error == Reg.Open( HKEY_LOCAL_MACHINE, wszKey ) )
	{
		WCHAR*	wszTemp;
		Reg.GetStr(L"Library", &wszTemp);
		m_strPerfLib = wszTemp;
		delete [] wszTemp;
		sprintf(szLog, "Library Name: %s", m_strPerfLib);
		Log( PERF_INFO, szLog );

		Reg.GetStr(L"Open", &wszTemp);
		m_strOpen = wszTemp;
		delete [] wszTemp;
		sprintf(szLog, "Open Function Name: %s", m_strOpen);
		Log( PERF_INFO, szLog );

		Reg.GetStr(L"Collect", &wszTemp);
		m_strCollect = wszTemp;
		delete [] wszTemp;
		sprintf(szLog, "Collect Function Name: %s", m_strCollect);
		Log( PERF_INFO, szLog );

		Reg.GetStr(L"Close", &wszTemp);
		m_strClose = wszTemp;
		delete [] wszTemp;
		sprintf(szLog, "Close Function Name: %s", m_strClose);
		Log( PERF_INFO, szLog );
	}
	else
	{
		sprintf(szLog, "Counld not open the %S registry key", wszKey);
		Log( PERF_FAILURE, szLog );

		bRet = FALSE;
	}

	return bRet;
}

BOOL CShowPerfLibDlg::OpenLibrary()
{
	BOOL bRet = TRUE;

	char szLog[256];

	m_hLib = LoadLibrary( (LPCSTR)m_strPerfLib );

	if ( NULL != m_hLib )
	{
		sprintf(szLog, "Loaded the %s Performance Library", m_strPerfLib);
		Log( PERF_SUCCESS, szLog );

		m_pfnOpenProc = (PM_OPEN_PROC*) GetProcAddress( m_hLib, m_strOpen );
		m_pfnCollectProc = (PM_COLLECT_PROC*) GetProcAddress( m_hLib, m_strCollect );
		m_pfnCloseProc = (PM_CLOSE_PROC*) GetProcAddress( m_hLib, m_strClose );

		bRet = ( ( NULL != m_pfnOpenProc ) &&
				 ( NULL != m_pfnCollectProc ) &&
				 ( NULL != m_pfnCloseProc ) );

		Log (( NULL != m_pfnOpenProc )?PERF_SUCCESS:PERF_FAILURE, "Get Open Procedure Address");
		Log (( NULL != m_pfnCollectProc )?PERF_SUCCESS:PERF_FAILURE, "Get Collect Procedure Address");
		Log (( NULL != m_pfnCloseProc )?PERF_SUCCESS:PERF_FAILURE, "Get Close Procedure Address");
	}
	else
	{
		sprintf(szLog, "Could not load the %s Performance Library", m_strPerfLib);
		Log( PERF_FAILURE, szLog );

		bRet = FALSE;
	}

	if ( bRet )
	{
		bRet = ( m_pfnOpenProc( NULL ) == ERROR_SUCCESS );
		Log( bRet?PERF_SUCCESS:PERF_FAILURE, "Opening Performance Library" );

		if ( bRet && m_bRefCheck )
		{
			bRet = ( m_pfnOpenProc( NULL ) == ERROR_SUCCESS );
			Log( bRet?PERF_SUCCESS:PERF_FAILURE, "Opening Performance Library" );

			if ( bRet )
			{
				bRet = ( m_pfnCloseProc() == ERROR_SUCCESS );
				Log( bRet?PERF_SUCCESS:PERF_FAILURE, "Closing Performance Library" );
			}
		}
	}

	return bRet;
}

BOOL CShowPerfLibDlg::Collect( CString strSpace )
{
	BOOL bRet = TRUE;

	int nRet = ERROR_MORE_DATA;
	char	szLog[256];

	DWORD	dwGuardSize  = 1024;
	DWORD	dwSize = 64000;

	BOOL bValid = HeapValidate( GetProcessHeap(), NULL, NULL );

	BYTE*	pSafeBuffer = new BYTE[dwSize + ( 2 * dwGuardSize )];

	memset( pSafeBuffer, 0xFFFFFFFF, dwSize + ( 2 * dwGuardSize ) );
	BYTE*	pBuffer = pSafeBuffer + dwGuardSize;
	BYTE*	pBufferPtr = NULL;

	DWORD	dwNumClasses = 0;
	DWORD	dwBufferSize = 0;

	WCHAR	wszSpace[256];

	mbstowcs( wszSpace, (LPCSTR)strSpace, 256 );

	while (ERROR_MORE_DATA == nRet)
	{
		pBufferPtr = pBuffer;
		dwBufferSize = dwSize;

		nRet = m_pfnCollectProc( wszSpace, (LPVOID*)(&pBufferPtr), &dwBufferSize, &dwNumClasses );
		sprintf(szLog, "Collect function called using %S counters", wszSpace);
		Log((nRet==ERROR_SUCCESS)?PERF_SUCCESS:((nRet==ERROR_MORE_DATA)?PERF_MORE_DATA:PERF_FAILURE), szLog );

		if (ERROR_SUCCESS == nRet)
		{
			sprintf(szLog, "Required buffer size: %d bytes", dwBufferSize);
			Log( PERF_INFO, szLog );
			sprintf(szLog, "Number of objects returned: %d", dwNumClasses);
			Log( PERF_INFO, szLog );

			try
			{
				BuildSubTree( strSpace, pBuffer, dwNumClasses );
			}
			catch(...)
			{
				AfxMessageBox("Exception thrown while processing blob");
			}
		}
		else if ( ERROR_MORE_DATA == nRet )
		{
			dwSize += 8000;

			if ( NULL != pSafeBuffer )
			{
				delete [] pSafeBuffer;
			}

			pSafeBuffer = new BYTE[dwSize + ( 2 * dwGuardSize )];
			memset( pSafeBuffer, 0xFFFFFFFF, dwSize + ( 2 * dwGuardSize ) );
		}
		else
		{
			bRet = FALSE;
		}
	}

	if ( NULL != pBuffer )
	{
		delete [] pSafeBuffer;
	}

	return bRet;
}

BOOL CShowPerfLibDlg::GetData()
{
	BOOL bRet = TRUE;
	char	szSpace[16];

	for ( int i = 0; (i < 2) && bRet; i++ )
	{
		if ( 0 == i )
		{
			strcpy (szSpace, "Global");
		}
		else
		{
			strcpy (szSpace, "Costly");
		}

		bRet = Collect( szSpace );
	}

	return bRet;
}

BOOL CShowPerfLibDlg::BuildSubTree( CString strSpace, BYTE* pBlob, DWORD dwNumObjects)
{
	BOOL bRet = TRUE;

	HTREEITEM hSpace = m_wndPerfTree.InsertItem( strSpace );

// Object

	PERF_OBJECT_TYPE* pObj = (PERF_OBJECT_TYPE*)pBlob;

	for ( DWORD dwObj = 0; dwObj < dwNumObjects; dwObj++ )
	{
		CString str;

		char* szName;
		m_TitleLibrary.GetName(pObj->ObjectNameTitleIndex, &szName);

		char szClassName[256];
		sprintf(szClassName, "%s Class", szName );
		HTREEITEM hClass = m_wndPerfTree.InsertItem( szClassName, hSpace );

		str.Format("TotalByteLength: %d", pObj->TotalByteLength);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("DefinitionLength: %d", pObj->DefinitionLength);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("HeaderLength: %d", pObj->HeaderLength);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("ObjectNameTitleIndex: %d", pObj->ObjectNameTitleIndex);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("ObjectHelpTitleIndex: %d", pObj->ObjectHelpTitleIndex);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("DetailLevel: %d", pObj->DetailLevel);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("NumCounters: %d", pObj->NumCounters);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("DefaultCounter: %d", pObj->DefaultCounter);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("NumInstances: %d", pObj->NumInstances);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("CodePage: %d", pObj->CodePage);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("PerfTime: %d", pObj->PerfTime);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("PerfFreq: %d", pObj->PerfFreq);
		m_wndPerfTree.InsertItem( str, hClass );

// Counters

		PERF_COUNTER_DEFINITION* pCtrDef = (PERF_COUNTER_DEFINITION*)((DWORD)pObj + pObj->HeaderLength);

		for ( DWORD dwCtr = 0; dwCtr < pObj->NumCounters; dwCtr++ )
		{
			char szCounterName[256];

			m_TitleLibrary.GetName( pCtrDef->CounterNameTitleIndex, &szName );
			sprintf(szCounterName, "%s Counter", szName);

			HTREEITEM hCtr = m_wndPerfTree.InsertItem( szCounterName, hClass );

			str.Format("ByteLength: %d", pCtrDef->ByteLength);
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("CounterNameTitleIndex: %d", pCtrDef->CounterNameTitleIndex);
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("CounterHelpTitleIndex: %d", pCtrDef->CounterHelpTitleIndex);
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("DefaultScale: %d", pCtrDef->DefaultScale);
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("DetailLevel: %d", pCtrDef->DetailLevel);
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("CounterType: 0x%X (%s Base)", pCtrDef->CounterType, ( PERF_COUNTER_BASE == (pCtrDef->CounterType & 0x00070000))?"Is a ":"Is not a ");
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("CounterSize: %d", pCtrDef->CounterSize);
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("CounterOffset: %d", pCtrDef->CounterOffset);
			m_wndPerfTree.InsertItem( str, hCtr );

			pCtrDef = (PERF_COUNTER_DEFINITION*)((DWORD)pCtrDef + pCtrDef->ByteLength);
		}

// Instances

		PERF_INSTANCE_DEFINITION* pInstDef = (PERF_INSTANCE_DEFINITION*)((DWORD)pObj + pObj->DefinitionLength);

		for ( LONG lInstance = 0; lInstance < pObj->NumInstances; lInstance++ )
		{
			char szInstanceName[256];
			sprintf(szInstanceName, "%S Instance", (WCHAR*)((DWORD)pInstDef + pInstDef->NameOffset));
			HTREEITEM hInst = m_wndPerfTree.InsertItem( szInstanceName, hClass );

			str.Format("ByteLength: %d", pInstDef->ByteLength);
			m_wndPerfTree.InsertItem( str, hInst );
			str.Format("ParentObjectTitleIndex: %d", pInstDef->ParentObjectTitleIndex);
			m_wndPerfTree.InsertItem( str, hInst );
			str.Format("ParentObjectInstance: %d", pInstDef->ParentObjectInstance);
			m_wndPerfTree.InsertItem( str, hInst );
			str.Format("UniqueID: %d", pInstDef->UniqueID);
			m_wndPerfTree.InsertItem( str, hInst );
			str.Format("NameOffset: %d", pInstDef->NameOffset);
			m_wndPerfTree.InsertItem( str, hInst );
			str.Format("NameLength: %d", pInstDef->NameLength);
			m_wndPerfTree.InsertItem( str, hInst );

// Instance Counter Data

			PERF_COUNTER_BLOCK* pCtrBlock = (PERF_COUNTER_BLOCK*)((DWORD)pInstDef + pInstDef->ByteLength);
			BYTE* pCurrCtr = (BYTE*)pCtrBlock;

			PERF_COUNTER_DEFINITION* pCtrDef = (PERF_COUNTER_DEFINITION*)((DWORD)pObj + pObj->HeaderLength);

			for ( DWORD dwCtr = 0; dwCtr < pObj->NumCounters; dwCtr++ )
			{
				char*	szName;
				m_TitleLibrary.GetName( pCtrDef->CounterNameTitleIndex, &szName );

				switch (pCtrDef->CounterSize)
				{
				case 0:
					{
						str.Format("%s data: <zero length>", szName );
						m_wndPerfTree.InsertItem( str, hInst );
					}break;
				case 4:
					{
						str.Format("%s data: %d", szName, (DWORD)(*(pCurrCtr + pCtrDef->CounterOffset)));
						m_wndPerfTree.InsertItem( str, hInst );
					}break;
				case 8:
					{
						str.Format("%s data: %I64d", szName, (__int64)(*(pCurrCtr + pCtrDef->CounterOffset)));
						m_wndPerfTree.InsertItem( str, hInst );
					}break;

				default:
					{
						str.Format("%s data: <unhandled>", szName );
						m_wndPerfTree.InsertItem( str, hInst );
					}break;
				}

				pCtrDef = (PERF_COUNTER_DEFINITION*)((DWORD)pCtrDef + pCtrDef->ByteLength);
			}


			pInstDef = (PERF_INSTANCE_DEFINITION*)((DWORD)pCtrBlock + pCtrBlock->ByteLength);
		}

		pObj = (PERF_OBJECT_TYPE*)((DWORD)pObj + pObj->TotalByteLength);
	}

	return bRet;
}

BOOL CShowPerfLibDlg::CloseLibrary()
{
	BOOL bRet = TRUE;

	DWORD dwRet = m_pfnCloseProc();

/*	if ( ERROR_SUCCESS != dwRet )
		bRet = FALSE;

	Log( bRet?PERF_SUCCESS:PERF_FAILURE, "Closing Performance Library" );
*/
	return bRet;
}

void CShowPerfLibDlg::Log( DWORD dwState, CString strDesc )
{
	CString strState;
	int nIndex = -1;
	BOOL bErr;

	switch( dwState )
	{
	case PERF_SUCCESS:
		{
			strState = "Success";
		}break;
	case PERF_INFO:
		{
			strState = "Information";
		}break;
	case PERF_MORE_DATA:
		{
			strState = "More Data";
		}break;
	case PERF_WARNING:
		{
			strState = "Warning";
		}break;
	case PERF_FAILURE:
		{
			strState = "Failure";
		}break;
	default:
		{
			strState = "Unknown";
		}break;
	};

	nIndex = m_wndErrorLog.InsertItem( m_wndErrorLog.GetItemCount() , strState );
	bErr = m_wndErrorLog.SetItemText( nIndex, 1, strDesc );

}

void CShowPerfLibDlg::OnChangeRequest() 
{

}

void CShowPerfLibDlg::OnGetCounter() 
{
	UpdateData();

	Collect( m_strRequest );

	m_strRequest.Empty();
	UpdateData( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\titledb.h ===
// TitleDB.h

#ifndef _TITLEDB_H_
#define _TITLEDB_H_

#include <windows.h>
#include <tchar.h>

class CTitleLibrary
{
protected:
	TCHAR*	m_tcsDataBlock;		// The title / index data block
	TCHAR**	m_atcsNames;		// The lookup table w/ pointers indexed into the data block
	long	m_lMaxIndex;		// The upper index limit

	HRESULT Initialize();

public:
	CTitleLibrary();
	~CTitleLibrary();

	HRESULT GetName (long lID, TCHAR** ptcsName);
};

#endif //_TITLEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\tests\showperflib\titledb.cpp ===
//TitleDB.cpp

#include "TitleDB.h"

#define PERFLIB	TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\PerfLib")

///////////////////////////////////////////////////////////////////////////////
//
//	CTitleLibrary
//
//	The CCtrLibrary object is an object that evaluates object and counter
//	titles based on their IDs.  The object uses a lookup table, where the 
//	elements reference strings in a block of ID / title pairs and the index
//	is the ID values of the object and counters.
//
///////////////////////////////////////////////////////////////////////////////

CTitleLibrary::CTitleLibrary()
///////////////////////////////////////////////////////////////////////////////
//
//	Constructor
//
///////////////////////////////////////////////////////////////////////////////
{
	Initialize();
}

CTitleLibrary::~CTitleLibrary()
///////////////////////////////////////////////////////////////////////////////
//
//	Destructor
//
///////////////////////////////////////////////////////////////////////////////
{
	if (m_tcsDataBlock)
		delete []m_tcsDataBlock;

	if (m_atcsNames)
		delete []m_atcsNames;
}

HRESULT CTitleLibrary::Initialize()
///////////////////////////////////////////////////////////////////////////////
//
//	Initialize
//
//	Sets up the lookup table for the library.  The titles are indexed by their
//	key ID values.
//
//	Determine the maximum index value of the titles.  Attempt to query the 
//	title/index pairs to determine how large of a block must be allocated to
//	accept the structure.  Create the block, and then query the title\index
//	pairs.  Create a lookup table the size of the maximum index, and populate 
//	it with the retrieved title data.
//
///////////////////////////////////////////////////////////////////////////////
{
	HKEY hKey = 0;

	// Get the upper index limit
	// =========================

	DWORD dwSize;

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, PERFLIB,
									  0, KEY_READ, &hKey))
	{
        return E_FAIL;
	}

	dwSize = 4;

    if (ERROR_SUCCESS != RegQueryValueEx(hKey, "Last Counter", 
										 0, 0, (PBYTE)&m_lMaxIndex, &dwSize))
    {
        RegCloseKey(hKey);
        return E_FAIL;
    }

    RegCloseKey(hKey);

	// Get the size of block required to retrieve the title / index pairs
	// ==================================================================

	if (ERROR_SUCCESS != RegQueryValueEx(HKEY_PERFORMANCE_DATA, TEXT("Counter009"), 
										 0, 0, 0, &dwSize))
		return E_FAIL;

	// Allocate the block, and retrieve the title / index pairs
	// ========================================================

	m_tcsDataBlock = new TCHAR[dwSize];

	if (ERROR_SUCCESS != RegQueryValueEx(HKEY_PERFORMANCE_DATA, TEXT("Counter009"), 
										 0, 0, (PBYTE)m_tcsDataBlock,	&dwSize))
	{
		delete []m_tcsDataBlock;
		return E_FAIL;
	}

	// Allocate and clear the memory for the lookup table
	// ==================================================

	m_atcsNames = new TCHAR*[m_lMaxIndex + 1];
    memset(m_atcsNames, 0, (sizeof(TCHAR*) * (m_lMaxIndex + 1)));

	// Populate the lookup table
	// =========================



    TCHAR* tcsTemp = m_tcsDataBlock;
    int nLen, nIndex;

    while ( 0 != (nLen = lstrlen(tcsTemp)))
    {
		// Get the index
		// =============

        nIndex = _ttoi(tcsTemp);
        tcsTemp += nLen + 1;

		// Set the table element at the index value to the string pointer 
		// ==============================================================

        m_atcsNames[nIndex] = tcsTemp;
        tcsTemp += lstrlen(tcsTemp) + 1;
    }

	return S_OK;
}

HRESULT CTitleLibrary::GetName(long lID, TCHAR** ptcsName)
///////////////////////////////////////////////////////////////////////////////
//
//	GetName
//
//	Evaluates the title given an object's or counter's ID.
//
//	Parameters:
//		lID			- the Index into the library
//		pstrName	- the Name
//
///////////////////////////////////////////////////////////////////////////////
{
	// Is it a valid index?
	// ====================

	if (lID > m_lMaxIndex)
		return E_INVALIDARG;
	
	// Assign the pointer
	// ==================

	*ptcsName = m_atcsNames[lID];

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\classmap.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    classmap.h

Abstract:

    the perfobject ID is combination of the perf counter ID and 
    the perf counter type. This is necessary to support counter
    definitions that use the counter ID for the numerator and denominator
    values (e.g. a counter and it's base value.)

--*/

//***************************************************************************
//
//  class CClassMapInfo
//
//***************************************************************************

#ifndef _CLASSMAP_H_
#define _CLASSMAP_H_

#include "utils.h"

typedef __int64 PerfObjectId;

#define CM_MAKE_PerfObjectId(ctr,type)  (PerfObjectId)(((__int64)(ctr)) | (((__int64)type << 32) & 0xFFFFFFFF00000000))

class CClassMapInfo
{
private:
    // friend clss declarations
    friend class CNt5PerfProvider;
    friend class CNt5Refresher;
    friend class PerfHelper;
    friend class CPerfObjectAccess; 

    // cached class definition object from CIMOM
    IWbemClassObject    *m_pClassDef;
    
    LPWSTR m_pszClassName;      // name of this class
    BOOL   m_bSingleton;        // true if this class has 1 and only 1 instance
    BOOL   m_bCostly;           // true when the costly qualifier is present in the obj def
    DWORD  m_dwObjectId;        // perf object ID corresponding to this class

    LONG   m_lRefCount;         // count of objects that are using this instance

    // saved handles to properties that are in every class of a 
    // performance class object
    LONG   m_dwNameHandle;
    LONG   m_dwPerfTimeStampHandle;
    LONG   m_dw100NsTimeStampHandle;
    LONG   m_dwObjectTimeStampHandle;
    LONG   m_dwPerfFrequencyHandle;
    LONG   m_dw100NsFrequencyHandle;
    LONG   m_dwObjectFrequencyHandle;

    // These entries make up the table of saved handles to the properties
    // belonging to this class.
    DWORD  m_dwNumProps;        // number of properties in the class
    PerfObjectId *m_pdwIDs;     // array of PerfCounterTitleIndex values 
    DWORD *m_pdwHandles;        // array of handles to each of the properties
    DWORD *m_pdwTypes;          // array of perf counter type values

    // internal sort function to arrange handles in order of the
    // perf counter ID so as to facilitate a binary table search 
    //
    // NOTE: Consider a better search routine base on table size
    void SortHandles();
            
public:
    CClassMapInfo();
   ~CClassMapInfo();
   
    // loads a new object and caches the necessary information
    BOOL Map( IWbemClassObject *pObj );
    // creates a new copy from an existing Class Map
    CClassMapInfo *CreateDuplicate();

    LONG    AddRef() {return ++m_lRefCount;}   // increment reference counter
    LONG    Release() {return --m_lRefCount;}   // decrement reference counter

    // looks up the ID in the table and returns the corresponding
    // handle to the property
    LONG GetPropHandle(PerfObjectId dwId);
    
    // returns information about the class
    DWORD GetObjectId() { return m_dwObjectId; }
    BOOL IsSingleton() { return m_bSingleton; }
    BOOL IsCostly() { return m_bCostly; }
};

#endif  // _CLASSMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\classmap.cpp ===
//***************************************************************************
//
//  (c) 1998-1999 by Microsoft Corp.
//
//  CLASSMAP.CPP
//  
//  Mapped NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97   Created.        
//  raymcc      20-Feb-98   Updated to use new initializer.
//  bobw         8-Jub-98   optimized for use with NT Perf counters
//
//***************************************************************************

#include <wpheader.h>
#include "oahelp.inl"

//***************************************************************************
//
//  CClassMapInfo::CClassMapInfo()
//
//  The objective of the map is to have one instance for each CIM class.
//  Internally, a map of perf object ids to CIM property handles is maintained
//  for the class.
//
//  Later, when instances are requested, the blob is retrieved from 
//  HKEY_PERFORMANCE_DATA, and the object IDs in the blob are used to
//  look up the property handles, which are then used to populate instances.
//
//  Property names are never really used except in the mapping phase.
//
//***************************************************************************
// ok
CClassMapInfo::CClassMapInfo()
{
    m_pClassDef = 0;            // The CIM class definition
    m_pszClassName = 0;         // The UNICODE class name

    m_dwObjectId = 0;           // Perf object Id
    m_bSingleton = FALSE;
    m_bCostly = FALSE;
    m_dwNumProps = 0;           // Number of props in class, size
                                // of the following arrays

    m_lRefCount = 0;            // nothing mapped yet
    // These are pointers to parallel arrays, all of the same
    // size (m_dwNumProps)
    // ============================================================
    
    m_pdwIDs = 0;               // IDs of properties
    m_pdwHandles = 0;           // Handles to properties
    m_pdwTypes = 0;             // Types of properties

    m_dwNameHandle = 0;             // The 'Name' property
    m_dwPerfTimeStampHandle = 0;    // the Perf time TimeStamp property
    m_dw100NsTimeStampHandle = 0;   // the 100 Ns Perf TimeStamp property
    m_dwObjectTimeStampHandle = 0;  // the Object TimeStamp property
    m_dwPerfFrequencyHandle = 0;    // the Perf time frequency property
    m_dw100NsFrequencyHandle = 0;   // the 100 Ns Perf frequency property
    m_dwObjectFrequencyHandle = 0;  // the Object frequency property
}

//***************************************************************************
//
//  CClassMapInfo::~CClassMapInfo
//
//***************************************************************************
// ok

CClassMapInfo::~CClassMapInfo()
{
    // this can be destructed only if it's the last item referencing it.
    // if there's another reference to this class, it should have been 
    // released before the destructor was called.
    assert (m_lRefCount <= 1);

    if (m_pClassDef)
        m_pClassDef->Release();

	if (m_pszClassName != NULL) { delete [] m_pszClassName; m_pszClassName = NULL;}
    if (m_pdwIDs != NULL)		{ delete [] m_pdwIDs;		m_pdwIDs = NULL; }
    if (m_pdwHandles != NULL)	{ delete [] m_pdwHandles;	m_pdwHandles = NULL; }
    if (m_pdwTypes != NULL)		{ delete [] m_pdwTypes;		m_pdwTypes = NULL; }
}

//***************************************************************************
//
//  CClassMapInfo::Copy(CClassMapInfo *pClassMap)
//
//  allocates an new Class Map entry and copies the data from the
//  class map passed into it and returns a pointer to the duplicate entry
//
//
//***************************************************************************
// ok
CClassMapInfo * CClassMapInfo::CreateDuplicate()
{
    CClassMapInfo *pOrigClassMap = this;
    CClassMapInfo *pNewClassMap = NULL;
    DWORD	i;

    pNewClassMap = new CClassMapInfo;

    if (pNewClassMap != NULL) {
        pNewClassMap->m_pClassDef = pOrigClassMap->m_pClassDef;
        pNewClassMap->m_pClassDef->AddRef();

        if (pOrigClassMap->m_pszClassName != NULL) {
            pNewClassMap->m_pszClassName = 
                new WCHAR[lstrlenW(pOrigClassMap->m_pszClassName)+1];
            if (pNewClassMap->m_pszClassName != NULL) {
                lstrcpyW (pNewClassMap->m_pszClassName, pOrigClassMap->m_pszClassName);

                pNewClassMap->m_bSingleton = pOrigClassMap->m_bSingleton;
                pNewClassMap->m_bCostly = pOrigClassMap->m_bCostly;

                pNewClassMap->m_dwObjectId = pOrigClassMap->m_dwObjectId;
                pNewClassMap->m_lRefCount = 1;

                pNewClassMap->m_dwNameHandle            = pOrigClassMap->m_dwNameHandle;
                pNewClassMap->m_dwPerfTimeStampHandle   = pOrigClassMap->m_dwPerfTimeStampHandle;
                pNewClassMap->m_dw100NsTimeStampHandle  = pOrigClassMap->m_dw100NsTimeStampHandle;
                pNewClassMap->m_dwObjectTimeStampHandle = pOrigClassMap->m_dwObjectTimeStampHandle;
                pNewClassMap->m_dwPerfFrequencyHandle   = pOrigClassMap->m_dwPerfFrequencyHandle;
                pNewClassMap->m_dw100NsFrequencyHandle  = pOrigClassMap->m_dw100NsFrequencyHandle;
                pNewClassMap->m_dwObjectFrequencyHandle = pOrigClassMap->m_dwObjectFrequencyHandle;

                pNewClassMap->m_dwNumProps = pOrigClassMap->m_dwNumProps;

                pNewClassMap->m_pdwIDs = new PerfObjectId[pNewClassMap->m_dwNumProps];
                pNewClassMap->m_pdwHandles = new DWORD[pNewClassMap->m_dwNumProps];
                pNewClassMap->m_pdwTypes = new DWORD[pNewClassMap->m_dwNumProps];

                if ((pNewClassMap->m_pdwIDs  != NULL) &&
                    (pNewClassMap->m_pdwHandles != NULL) &&
                    (pNewClassMap->m_pdwTypes  != NULL)) {
                    // copy each table to the new object
                    for (i = 0; i < pNewClassMap->m_dwNumProps; i++) {
                        pNewClassMap->m_pdwIDs[i]       = pOrigClassMap->m_pdwIDs[i];
                        pNewClassMap->m_pdwHandles[i]   = pOrigClassMap->m_pdwHandles[i];
                        pNewClassMap->m_pdwTypes[i]     = pOrigClassMap->m_pdwTypes[i];
                    }
                }
                else {
                    delete pNewClassMap;
                    pNewClassMap = NULL;
                }
            } else {
                delete pNewClassMap;
                pNewClassMap = NULL;
            }
        }
    }

    return pNewClassMap;
}

//***************************************************************************
//
//  CClassMapInfo::Map()
//
//  Maps the inbound class definition by:
//
//  (1) Retrieving the perf object id from the class definition.
//  (2) Retrieving the property handles, perf ids, and types for each 
//      property.
//
//
//***************************************************************************
// ok
BOOL CClassMapInfo::Map(IWbemClassObject *pObj)
{
    int                 nIndex = 0;
    IWbemObjectAccess   *pAlias = 0;
    IWbemQualifierSet   *pQSet = 0;
    HRESULT             hRes;
    VARIANT             vPropertyCount;
    VARIANT             vClsName;    
    VARIANT             vPerfObjType;
    VARIANT             vSingleton;
    VARIANT             vCostly;
    VARIANT             vCounter;
    VARIANT             vCounterType;
    CBSTR               cbPerfIndex(cszPerfIndex);
    CBSTR               cbCountertype(cszCountertype);
    BOOL                bReturn = TRUE;

    VariantInit(&vPropertyCount);
    VariantInit(&vClsName);    
    VariantInit(&vPerfObjType);
    VariantInit(&vSingleton);
    VariantInit(&vCostly);
    VariantInit(&vCounter);
    VariantInit(&vCounterType);

    // Copy the class definition.
    // ==========================
        
    m_pClassDef = pObj;
    //m_pClassDef->AddRef(); // this is unnecessary

    m_lRefCount++;  // bump our ref count
    
    // Get the alternate interface so that we can look up handles.
    // ===========================================================
    hRes = pObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pAlias);
    if (hRes) {
        bReturn = FALSE;
    }

    // Determine the number of properties and allocate
    // arrays to hold the handles, perf ids, and types.
    // ================================================
    if (bReturn) {
        hRes = pObj->Get(CBSTR(cszPropertyCount), 0, &vPropertyCount, 0, 0);
        if (hRes == NO_ERROR) {
            m_dwNumProps = DWORD(V_UI4(&vPropertyCount));
        } else {
            bReturn = FALSE;
        }
        VariantClear(&vPropertyCount);
    }

    // allocate the table of the handles and id's
    if (bReturn) {
        m_pdwHandles = new DWORD[m_dwNumProps];
        assert (m_pdwHandles != NULL);
        m_pdwIDs = new PerfObjectId[m_dwNumProps];
        assert (m_pdwIDs != NULL);
        m_pdwTypes = new DWORD[m_dwNumProps];
        assert (m_pdwTypes != NULL);

        // check the memory allocations
        if ((m_pdwHandles == NULL) ||
            (m_pdwIDs == NULL) ||
            (m_pdwTypes == NULL)) {
            bReturn = FALSE;
        }
    }    
    // Clone the class name.
    // =====================
    if (bReturn) {
        hRes = pObj->Get(CBSTR(cszClassName), 0, &vClsName, 0, 0);
        if ((hRes == NO_ERROR) && (vClsName.vt == VT_BSTR)) {
            m_pszClassName = Macro_CloneLPWSTR(V_BSTR(&vClsName));
            if (m_pszClassName == NULL) bReturn = FALSE;
        } else {
            bReturn = FALSE;
        }
        VariantClear (&vClsName);
    }

    // Get the perf object id for the class.
    // =====================================

    if (bReturn) {
        hRes = pObj->GetQualifierSet(&pQSet);
        if (hRes == NO_ERROR) {
            hRes = pQSet->Get(cbPerfIndex, 0, &vPerfObjType, 0);
            if (hRes == NO_ERROR) {
                m_dwObjectId = DWORD(V_UI4(&vPerfObjType));
            } else {
                bReturn = FALSE;
            }
            VariantClear(&vPerfObjType);

            hRes = pQSet->Get(CBSTR(cszSingleton), 0, &vSingleton, 0);
            if (hRes == 0) {
                m_bSingleton = TRUE;
            }
            VariantClear (&vSingleton);


            hRes = pQSet->Get(CBSTR(cszCostly), 0, &vCostly, 0);
            if ((hRes == 0) && (vCostly.vt == VT_BSTR)) {
                m_bCostly= TRUE;
            }
            VariantClear (&vCostly);

            pQSet->Release();
        } else {
            bReturn = FALSE;
        }
    }
    
    
    // Enumerate all the properties and get the object ids
    // and handles for each.
    // ===================================================
    
    hRes = pObj->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    if (hRes == NO_ERROR) {
        // enumeration handle obtained so 
        // continue and cache each property
    
        while (bReturn) {
            BSTR                Name = 0;
            DWORD               dwCtrId;
            DWORD               dwCtrType;
            IWbemQualifierSet   *pQSet = 0;
            LONG                lType = 0;
            LONG                lHandle = 0;
        
            hRes = pObj->Next(
                0,
                &Name,
                0,
                0,
                0
                );                

            if (hRes == WBEM_S_NO_MORE_DATA) {
                break;
            }

            // Next, get the qualifier set for this property.
            // ==============================================
        
            hRes = pObj->GetPropertyQualifierSet(Name, &pQSet);
            if (hRes == NO_ERROR) {
                hRes = pQSet->Get(cbPerfIndex, 0, &vCounter, 0);
                if (hRes == S_OK) {
                    dwCtrId = (DWORD)V_UI4(&vCounter);    
                } else {
                    // unable to read qualifier value
                    dwCtrId = 0;
                }
                VariantClear (&vCounter);

                hRes = pQSet->Get(cbCountertype, 0, &vCounterType, 0);
                if (hRes == S_OK) {
                    dwCtrType = (DWORD)V_UI4(&vCounterType);
                } else {
                    // unable to read qualifier value
                    dwCtrType = 0;
                }
                VariantClear (&vCounterType);

                // done with the qualifier set
                pQSet->Release();

                // Get the property handle and type.
                // =================================
                hRes = pAlias->GetPropertyHandle(Name, &lType, &lHandle);

                if (hRes == NO_ERROR) {
                    // We now know the counter id, the property handle and its
                    // type.  That is all we really need at runtime to map
                    // blobs into CIM object.
                    // =======================================================
                    m_pdwIDs[nIndex] = CM_MAKE_PerfObjectId (dwCtrId, dwCtrType);
                    m_pdwHandles[nIndex] = (DWORD) lHandle;
                    m_pdwTypes[nIndex] = (DWORD) lType;

                    // this property was loaded successfully so 
                    // advance to the next index 
                    nIndex++;
                } else {
                    // no property handle returned so skip it.
                }
            } else {
                // skip this object since it doesn't have
                // a qualifier set
            }

            // Free the name.
            // ==============        
            SysFreeString(Name);    

        }    

        pObj->EndEnumeration();
    } else {
        // unable to get enumeration handle
        bReturn = FALSE;
    }

    // Get the handle of the 'name' property.
    // ======================================
    if (bReturn) {
        if (!m_bSingleton) {
            // only non-singleton classes have this property
            pAlias->GetPropertyHandle((LPWSTR)cszName, 0, (LONG *) &m_dwNameHandle);
        } 

        // Get the handle of the "timestamp" properties
        pAlias->GetPropertyHandle((LPWSTR)cszTimestampPerfTime, 0, (LONG *) &m_dwPerfTimeStampHandle);
        pAlias->GetPropertyHandle((LPWSTR)cszFrequencyPerfTime, 0, (LONG *) &m_dwPerfFrequencyHandle);
        pAlias->GetPropertyHandle((LPWSTR)cszTimestampSys100Ns, 0, (LONG *) &m_dw100NsTimeStampHandle);
        pAlias->GetPropertyHandle((LPWSTR)cszFrequencySys100Ns, 0, (LONG *) &m_dw100NsFrequencyHandle);
        pAlias->GetPropertyHandle((LPWSTR)cszTimestampObject,   0, (LONG *) &m_dwObjectTimeStampHandle);
        pAlias->GetPropertyHandle((LPWSTR)cszFrequencyObject,   0, (LONG *) &m_dwObjectFrequencyHandle);

        // Cleanup.
        // ========

        SortHandles();
    }
    
    if (pAlias != NULL) pAlias->Release();
    
    return bReturn;
}

//***************************************************************************
//
//  CClassMapInfo::SortHandles
//
//  Sort the perf object ids for quick searching later in the GetPropHandle
//  method.
//
//***************************************************************************
// ok
void CClassMapInfo::SortHandles()
{
    DWORD           dwOuter;
    DWORD           dwInner;
    DWORD           dwTemp;
    PerfObjectId    poiTemp;


    // Simple selection sort.  The number of elements is so small
    // and this is only done once, so a quicksort / shellsort would be
    // overkill.
    // ===============================================================

    for (dwOuter = 0; dwOuter < m_dwNumProps - 1; dwOuter++)
    {
        for (dwInner = dwOuter + 1; dwInner < m_dwNumProps; dwInner++)
        {
            if (m_pdwIDs[dwInner] < m_pdwIDs[dwOuter])
            {
                poiTemp = m_pdwIDs[dwInner];
                m_pdwIDs[dwInner] = m_pdwIDs[dwOuter];
                m_pdwIDs[dwOuter] = poiTemp;

                dwTemp = m_pdwHandles[dwInner];
                m_pdwHandles[dwInner] = m_pdwHandles[dwOuter];
                m_pdwHandles[dwOuter] = dwTemp;

                dwTemp = m_pdwTypes[dwInner];
                m_pdwTypes[dwInner] = m_pdwTypes[dwOuter];
                m_pdwTypes[dwOuter] = dwTemp;
            }
        }
    }
}

//***************************************************************************
//
//  CClassMapInfo::GetPropHandle
//
//  Gets the property handle for a corresponding perf counter id.
//  Returns 0 if not found.
//
//***************************************************************************
// ok
LONG CClassMapInfo::GetPropHandle(PerfObjectId dwId)
{
    // Binary search.
    // ==============

    LONG    l;
    LONG    u;
    LONG    m;
    LONG    lReturn = 0;

    if (m_dwNumProps > 0) {
        l = 0;
        u = m_dwNumProps - 1;
        while (l <= u)
        {
            m = (l + u) / 2;

            if (dwId < m_pdwIDs[m]) {
                u = m - 1;
            } else if (dwId > m_pdwIDs[m]) {
                l = m + 1;
            } else {   // Hit!
                lReturn = m_pdwHandles[m];
                break;
            }
        }
    } else {
        // no entries so return 0;
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\flexarry.cpp ===
//***************************************************************************
//
//  (c) 1998-1999 by Microsoft Corp.
//
//  FLEXARRY.CPP
//
//  CFlexArray implementation (non-arena).
//
//  15-Jul-97  raymcc   Created.
//   8-Jun-98  bobw     cleaned up for WBEMPERF usage
//
//***************************************************************************

#include "wpheader.h"
#include <stdio.h>

//***************************************************************************
//
//  CFlexArray::CFlexArray
//
//  Constructs the array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************
// ok
CFlexArray::CFlexArray(
    int nSize,
    int nGrowBy
    )
{
    m_nExtent = nSize;
    m_nSize = 0;
    m_nGrowBy = nGrowBy;
    m_hHeap = GetProcessHeap(); // call this once and save heap handle locally

    m_pArray = (void **) ALLOCMEM(m_hHeap, HEAP_ZERO_MEMORY, sizeof(void *) * nSize);

	assert (m_pArray != NULL);
}

//***************************************************************************
//
//  CFlexArray::~CFlexArray
//
//***************************************************************************
// ok
CFlexArray::~CFlexArray()
{
    FREEMEM(m_hHeap, 0, m_pArray);
}

//***************************************************************************
//
//  Copy constructor.
//
//  Copies the pointers, not their contents.
//
//***************************************************************************
// ok
CFlexArray::CFlexArray(CFlexArray &Src)
{
    m_pArray = 0;
    m_nSize = 0;
    m_nExtent = 0;
    m_nGrowBy = 0;

    *this = Src;
}

//***************************************************************************
//
//  operator =
//
//  Assignment operator.
//
//  Arenas are not copied.  This allows transfer of arrays between arenas.
//  Arrays are copied by pointer only.
//
//***************************************************************************
// ok
CFlexArray& CFlexArray::operator=(CFlexArray &Src)
{
    m_nSize   = Src.m_nSize;
    m_nExtent = Src.m_nExtent;
    m_nGrowBy = Src.m_nGrowBy;

    FREEMEM (m_hHeap, 0, m_pArray);
    m_pArray = (void **) ALLOCMEM(m_hHeap, HEAP_ZERO_MEMORY, sizeof(void *) * m_nExtent);
    if (m_pArray) {
        memcpy(m_pArray, Src.m_pArray, sizeof(void *) * m_nExtent);
    }

    return *this;
}

//***************************************************************************
//
//  CFlexArray::RemoveAt
//
//  Removes the element at the specified location.  Does not
//  actually delete the pointer. Shrinks the array over the top of
//  the 'doomed' element.
//
//  Parameters:
//  <nIndex>    The location of the element.
//
//  Return value:
//  range_error     The index is not legal.
//  no_error        Success.
//
//***************************************************************************
// ok
int CFlexArray::RemoveAt(int nIndex)
{
    int i;

    if (nIndex >= m_nSize) {
        return range_error;
    }

    for (i = nIndex; i < m_nSize - 1; i++) {
        m_pArray[i] = m_pArray[i + 1];
    }

    m_nSize--;
    m_pArray[m_nSize] = 0;

    return no_error;
}

//***************************************************************************
//
//  CFlexArray::InsertAt
//
//  Inserts a new element at the specified location.  The pointer is copied.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to insert the new element.
//  <pSrc>          The pointer to copy. (contents are not copied).
//
//  Return value:
//  array_full
//  out_of_memory
//  no_error
//
//***************************************************************************
// ok
int CFlexArray::InsertAt(int nIndex, void *pSrc)
{
    void    **pTmp; // pointer to new array
    int     nReturn = no_error;
    LONG    lOldSize;
    LONG    lNewSize;

    // If the array is full, we need to expand it.
    // ===========================================

    if (m_nSize == m_nExtent) {
        if (m_nGrowBy == 0) {
            nReturn  = array_full;
        } else {
            // compute sizes
            lOldSize = sizeof(void *) * m_nExtent;
            m_nExtent += m_nGrowBy;
            lNewSize = sizeof(void *) * m_nExtent;

            // allocate new array
            pTmp = (void **) ALLOCMEM(m_hHeap, HEAP_ZERO_MEMORY, lNewSize);
            if (!pTmp) {
                nReturn = out_of_memory;
            } else {
                // move bits from old array to new array
                memcpy (pTmp, m_pArray, lOldSize);
                // toss old arrya
                FREEMEM (m_hHeap, 0, m_pArray);
                // save pointer to new array
                m_pArray = pTmp;
            }
        }
    }

    // Special case of appending.  This is so frequent
    // compared to true insertion that we want to optimize.
    // ====================================================

    if (nReturn == no_error) {
        if (nIndex == m_nSize)  {
            m_pArray[m_nSize++] = pSrc;
        } else {
            // If here, we are inserting at some random location.
            // We start at the end of the array and copy all the elements
            // one position farther to the end to make a 'hole' for
            // the new element.
            // ==========================================================

            for (int i = m_nSize; i > nIndex; i--) {
                m_pArray[i] = m_pArray[i - 1];
            }

            m_pArray[nIndex] = pSrc;
            m_nSize++;
        }
    }
    return nReturn;
}

//***************************************************************************
//
//  CFlexArray::DebugDump
//
//***************************************************************************
//
void CFlexArray::DebugDump()
{
    printf("----CFlexArray Debug Dump----\n");
    printf("m_pArray = 0x%p\n", m_pArray);
    printf("m_nSize = %d\n", m_nSize);
    printf("m_nExtent = %d\n", m_nExtent);
    printf("m_nGrowBy = %d\n", m_nGrowBy);

    for (int i = 0; i < m_nExtent; i++)
    {
        if (i < m_nSize) {
            printf("![%d] = %p\n", i, m_pArray[i]);
        } else {
            printf("?[%d] = %p\n", i, m_pArray[i]);
        }
    }
}

//***************************************************************************
//
//  CFlexArray::Compress
//
//  Removes NULL elements by moving all non-NULL pointers to the beginning
//  of the array.  The array "Size" changes, but the extent is untouched.
//
//***************************************************************************
// ok
void CFlexArray::Compress()
{
    int nLeftCursor = 0, nRightCursor = 0;

    while (nLeftCursor < m_nSize - 1) {
        if (m_pArray[nLeftCursor]) {
            nLeftCursor++;
            continue;
        }
        else {
            nRightCursor = nLeftCursor + 1;
            while (m_pArray[nRightCursor] == 0 && nRightCursor < m_nSize)
                nRightCursor++;
            if (nRightCursor == m_nSize)
                break;  // Short circuit, no more nonzero elements.
            m_pArray[nLeftCursor] = m_pArray[nRightCursor];
            m_pArray[nRightCursor] = 0;
        }
    }

    while (m_pArray[m_nSize - 1] == 0 && m_nSize > 0) m_nSize--;
}

//***************************************************************************
//
//  CFlexArray::Empty
//
//  Clears the array of all pointers (does not deallocate them) and sets
//  its apparent size to zero.
//
//***************************************************************************
// ok
void CFlexArray::Empty()
{
    FREEMEM(m_hHeap, 0, m_pArray);
    m_pArray = (void **) ALLOCMEM(m_hHeap, HEAP_ZERO_MEMORY, sizeof(void *) * m_nGrowBy);
    m_nSize = 0;
    m_nExtent = m_nGrowBy;
}

//***************************************************************************
//
//  CFlexArray::UnbindPtr
//
//  Empties the array and returns the pointer to the data it contained
//
//***************************************************************************

void** CFlexArray::UnbindPtr()
{
    void** pp = m_pArray;
    Empty();
    return pp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\ntperf.cpp ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    ntperf.cpp

Abstract:

    Mapped NT5 Perf counter provider

History:

    raymcc      02-Dec-97   Created.        
    raymcc      20-Feb-98   Updated to use new initializer.
    bobw         8-Jun-98   tuned up

--*/

#include "wpheader.h"
#include <stdio.h>
#include "oahelp.inl"

#define __WBEMSECURITY  1

//***************************************************************************
//
//  CNt5PerfProvider constructor
//
//***************************************************************************
// ok

CNt5PerfProvider::CNt5PerfProvider(enumCLSID OriginClsid)
{
    m_lRef = 0;
    m_OriginClsid = OriginClsid;
    m_hClassMapMutex = CreateMutex(NULL, FALSE, NULL);
}

//***************************************************************************
//
//  CNt5PerfProvider destructor
//
//***************************************************************************
// ok

CNt5PerfProvider::~CNt5PerfProvider()
{
    int i;
    CClassMapInfo *pClassElem;

    assert (m_lRef == 0);

    for (i = 0; i < m_aCache.Size(); i++) {
        pClassElem = (CClassMapInfo *) m_aCache[i];
        m_PerfObject.RemoveClass (pClassElem->m_pClassDef);
        delete pClassElem;
    }
    m_aCache.Empty(); // reset the buffer pointers

    if (m_hClassMapMutex != 0)
        CloseHandle(m_hClassMapMutex);

    // RegCloseKey(HKEY_PERFORMANCE_DATA); // causes more problems than it solves

}

//***************************************************************************
//
//  CNt5PerfProvider::AddRef
//
//  Standard COM AddRef().
//
//***************************************************************************
// ok

ULONG CNt5PerfProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CNt5PerfProvider::Release
//
//  Standard COM Release().
//
//***************************************************************************
// ok

ULONG CNt5PerfProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) {
        delete this;
    }
    return lRef;
}

//***************************************************************************
//
//  CNt5PerfProvider::QueryInterface
//
//  Standard COM QueryInterface().  We have to support two interfaces,
//  the IWbemHiPerfProvider interface itself to provide the objects and
//  the IWbemProviderInit interface to initialize the provider.
//
//***************************************************************************
// ok

HRESULT CNt5PerfProvider::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hReturn;

    if (riid == IID_IUnknown || riid == IID_IWbemHiPerfProvider) {
        *ppv = (IWbemHiPerfProvider*) this;
        AddRef();
        hReturn = S_OK;
    } else if (riid == IID_IWbemProviderInit) {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        hReturn = S_OK;
    } else {
        hReturn = E_NOINTERFACE;
    }
    return hReturn;
}

//***************************************************************************
//
//  CNt5PerfProvider::Initialize
//
//  Called once during startup.  Indicates to the provider which
//  namespace it is being invoked for and which User.  It also supplies
//  a back pointer to CIMOM so that class definitions can be retrieved.
//
//  We perform any one-time initialization in this routine. The
//  final call to Release() is for any cleanup.
//
//  <wszUser>           The current user.
//  <lFlags>            Reserved.
//  <wszNamespace>      The namespace for which we are being activated.
//  <wszLocale>         The locale under which we are to be running.
//  <pNamespace>        An active pointer back into the current namespace
//                      from which we can retrieve schema objects.
//  <pCtx>              The user's context object.  We simply reuse this
//                      during any reentrant operations into CIMOM.
//  <pInitSink>         The sink to which we indicate our readiness.
//
//***************************************************************************
// ok

HRESULT CNt5PerfProvider::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          LONG lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink
    )
{
    UNREFERENCED_PARAMETER(wszUser);
    UNREFERENCED_PARAMETER(lFlags);
    UNREFERENCED_PARAMETER(wszNamespace);
    UNREFERENCED_PARAMETER(wszLocale);
    UNREFERENCED_PARAMETER(pNamespace);
    UNREFERENCED_PARAMETER(pCtx);

    pInitSink->SetStatus(0, WBEM_S_INITIALIZED);

    return NO_ERROR;
}
    
//***************************************************************************
//
//  CNt5PerfProvider::QueryInstances
//
//  Called whenever a complete, fresh list of instances for a given
//  class is required.   The objects are constructed and sent back to the
//  caller through the sink.  The sink can be used in-line as here, or
//  the call can return and a separate thread could be used to deliver
//  the instances to the sink.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  This
//                      should not be AddRef'ed or retained past the
//                      execution of this method.
//  <wszClass>          The class name for which instances are required.
//  <lFlags>            Reserved.
//  <pCtx>              The user-supplied context (used during callbacks
//                      into CIMOM).
//  <pSink>             The sink to which to deliver the objects.  The objects
//                      can be delivered synchronously through the duration
//                      of this call or asynchronously (assuming we
//                      had a separate thread).  A IWbemObjectSink::SetStatus
//                      call is required at the end of the sequence.
//
//***************************************************************************
//  ok
HRESULT CNt5PerfProvider::QueryInstances( 
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *wszClass,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pSink
    )
{
    HRESULT hReturn;
    BOOL bRes ;
    CClassMapInfo *pClsMap = NULL;

    UNREFERENCED_PARAMETER(lFlags);

#ifdef __WBEMSECURITY
    hReturn = CoImpersonateClient(); // make sure we're legit.

    BOOL    fRevert = SUCCEEDED( hReturn );

    // The following error appears to occur when we are in-proc and there is no
    // proxy/stub, so we are effectively impersonating already

    if ( RPC_E_CALL_COMPLETE == hReturn ) {
        hReturn = S_OK;
    } 

    if (S_OK == hReturn) {
        hReturn = CheckImpersonationLevel();
    }
    // Check Registry security here.
    if ((hReturn != S_OK) || (!HasPermission())) {
        // if Impersonation level is incorrect or
        // the caller doesn't have permission to read
        // from the registry, then they cannot continue
        hReturn = WBEM_E_ACCESS_DENIED;
    }

#else
    hReturn = S_OK;
#endif

    if (hReturn == S_OK) {

        if (pNamespace == 0 || wszClass == 0 || pSink == 0) {
            hReturn = WBEM_E_INVALID_PARAMETER;
        } else {

            // Ensure the class is in our cache and mapped.
            // ============================================
            bRes = MapClass(pNamespace, wszClass, pCtx);

            if (bRes == FALSE)  {
                // Class is not one of ours.
                hReturn = WBEM_E_INVALID_CLASS;
            } else {
                pClsMap = FindClassMap(wszClass);
                if (pClsMap == NULL) {
                    hReturn = WBEM_E_INVALID_CLASS;
                }
            }

            if (hReturn == NO_ERROR) {
                // Refresh the instances.
                // ======================

                PerfHelper::QueryInstances(&m_PerfObject, pClsMap, pSink);

                // Tell CIMOM we are finished.
                // ===========================

                pSink->SetStatus(0, WBEM_NO_ERROR, 0, 0);
                hReturn = NO_ERROR;
            }
        }
    } else {
        // return error
    }

#ifdef __WBEMSECURITY
    // Revert if we successfuly impersonated the user
    if ( fRevert )
    {
        CoRevertToSelf();
    }
#endif

    return hReturn;
}    

//***************************************************************************
//
//  CNt5PerfProvider::CreateRefresher
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  Not used.
//  <lFlags>            Not used.
//  <ppRefresher>       Receives the requested refresher.
//
//***************************************************************************        
// ok
HRESULT CNt5PerfProvider::CreateRefresher( 
     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
     )
{
    HRESULT hReturn;
    CNt5Refresher *pNewRefresher;

    UNREFERENCED_PARAMETER(lFlags);

#ifdef __WBEMSECURITY
    hReturn = CoImpersonateClient(); // make sure we're legit.

    BOOL    fRevert = SUCCEEDED( hReturn );

    // The following error appears to occur when we are in-proc and there is no
    // proxy/stub, so we are effectively impersonating already

    if ( RPC_E_CALL_COMPLETE == hReturn ) {
        hReturn = S_OK;
    } 

    if (S_OK == hReturn) {
        hReturn = CheckImpersonationLevel();
    }
    // Check Registry security here.
    if ((hReturn != S_OK) || (!HasPermission())) {
        // if Impersonation level is incorrect or
        // the caller doesn't have permission to read
        // from the registry, then they cannot continue
        hReturn = WBEM_E_ACCESS_DENIED;
    }

#else
    hReturn = S_OK;
#endif

    if (hReturn == S_OK) {

        if (pNamespace == 0 || ppRefresher == 0) {
            hReturn = WBEM_E_INVALID_PARAMETER;
        } else {
            // Construct a new empty refresher.
            // ================================        
            pNewRefresher = new CNt5Refresher (this);

            if (pNewRefresher != NULL) {
                // Follow COM rules and AddRef() the thing before sending it back.
                // ===============================================================
                pNewRefresher->AddRef();
                *ppRefresher = pNewRefresher;
    
                hReturn = NO_ERROR;
            } else {
                hReturn = WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

#ifdef __WBEMSECURITY
    // Revert if we successfuly impersonated the user
    if ( fRevert )
    {
        CoRevertToSelf();
    }
#endif

    return hReturn;
}

//***************************************************************************
//
//  CNt5PerfProvider::CreateRefresherObject
//
//  Called whenever a user wants to include an object in a refresher.
//     
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace in CIMOM.
//  <pTemplate>         A pointer to a copy of the object which is to be
//                      added.  This object itself cannot be used, as
//                      it not owned locally.        
//  <pRefresher>        The refresher to which to add the object.
//  <lFlags>            Not used.
//  <pContext>          Not used here.
//  <ppRefreshable>     A pointer to the internal object which was added
//                      to the refresher.
//  <plId>              The Object Id (for identification during removal).        
//
//***************************************************************************        
// ok

HRESULT CNt5PerfProvider::CreateRefresherObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [string][in] */ LPCWSTR wszClass,
    /* [in] */ IWbemHiPerfEnum __RPC_FAR *pHiPerfEnum,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId
    )
{
    IWbemClassObject    *pOriginal = 0;
    IWbemClassObject    *pNewCopy = 0;    
    IWbemObjectAccess   *pNewAccess = 0;
    CNt5Refresher       *pRef = 0;
    CClassMapInfo       *pClsMap;
    VARIANT             v; 
    BOOL                bRes;
    HRESULT             hReturn = NO_ERROR;

    UNREFERENCED_PARAMETER(lFlags);

    if (ppRefreshable != NULL) {
        // Initialize the argument
        *ppRefreshable = 0;
    }

    // init the variant 
    VariantInit(&v);

    if (pTemplate != NULL) {
        // Make a copy of the template object.
        // ===================================
        hReturn = pTemplate->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pOriginal);
        if (hReturn == NO_ERROR) {
            hReturn = pOriginal->Clone(&pNewCopy);

            // Get the class name of the object.
            // =================================
            if (hReturn == NO_ERROR) {
                hReturn = pOriginal->Get(CBSTR(cszClassName), 0, &v, 0, 0);
                if ((hReturn == NO_ERROR) && (v.vt != VT_BSTR)) {
                    hReturn = WBEM_E_INVALID_CLASS;
                }
            }

            // We are now done with the original object
            // ========================================
            pOriginal->Release();   
        }

        if (hReturn == NO_ERROR) {
            // We now get the IWbemObjectAccess form of the cloned object
            // and release the unused interface.
            // ==========================================================
            hReturn = pNewCopy->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pNewAccess);
            if (hReturn == NO_ERROR) {
                pNewCopy->Release();    // We don't need the IWbemClassObject interface any more
                // We now have an IWbemObjectAccess pointer for the refreshable
                // object in <pNewAccess>.
                // ============================================================
            }
        }
    } else {
        // copy the class name passed in
        v.vt = VT_BSTR;
        v.bstrVal = SysAllocString(wszClass);
    }

    if (hReturn == NO_ERROR) {
        // cast refresher pointer to our refresher object
        pRef = (CNt5Refresher *) pRefresher;

        // Map the class info for this instance.
        // =====================================
        bRes = MapClass(pNamespace, V_BSTR(&v), pContext);
        if (bRes == FALSE) {
           // Class is not one of ours.
           if (pNewAccess != NULL) pNewAccess->Release();
           hReturn = WBEM_E_INVALID_CLASS;
        } else {
            pClsMap = FindClassMap(V_BSTR(&v));
            if (pClsMap == 0) {
                if (pNewAccess != NULL) pNewAccess->Release();
                hReturn = WBEM_E_INVALID_CLASS;
            } else {
                // Add the object to the refresher.
                if (pHiPerfEnum != NULL) {
                    // then this is an Enum object so add it
                    bRes = pRef->AddEnum (
                                pHiPerfEnum,
                                pClsMap,
                                plId);
                    if (bRes) {    
                        // Return new ID to caller
                        // ==========================
                        hReturn = NO_ERROR;
                    } else {
                        // unable to add enumerator
                        hReturn = GetLastError();
                    }
                } else {
                    // This method will AddRef() the object before returning.
                    // ======================================================
                    bRes = pRef->AddObject(
                                &pNewAccess, 
                                pClsMap,        
                                plId);
                    if (bRes) {    
                        // Return object to the user.
                        // ==========================
                        *ppRefreshable = pNewAccess;
                        hReturn = NO_ERROR;
                    } else {
                        // unable to add object
                        hReturn = GetLastError();
                    }
                }
            }
        }
    }

    VariantClear(&v);    

    return hReturn;
}

//***************************************************************************
//
//  CNt5PerfProvider::CreateRefreshableObject
//
//  Called whenever a user wants to include an object in a refresher.
//     
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace in CIMOM.
//  <pTemplate>         A pointer to a copy of the object which is to be
//                      added.  This object itself cannot be used, as
//                      it not owned locally.        
//  <pRefresher>        The refresher to which to add the object.
//  <lFlags>            Not used.
//  <pContext>          Not used here.
//  <ppRefreshable>     A pointer to the internal object which was added
//                      to the refresher.
//  <plId>              The Object Id (for identification during removal).        
//
//***************************************************************************        
// ok

HRESULT CNt5PerfProvider::CreateRefreshableObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId
    )
{


    HRESULT             hReturn = NO_ERROR;

#ifdef __WBEMSECURITY
    hReturn = CoImpersonateClient(); // make sure we're legit.

    BOOL    fRevert = SUCCEEDED( hReturn );

    // The following error appears to occur when we are in-proc and there is no
    // proxy/stub, so we are effectively impersonating already

    if ( RPC_E_CALL_COMPLETE == hReturn ) {
        hReturn = S_OK;
    } 

    if (S_OK == hReturn) {
        hReturn = CheckImpersonationLevel();
    }
    // Check Registry security here.
    if ((hReturn != S_OK) || (!HasPermission())) {
        // if Impersonation level is incorrect or
        // the caller doesn't have permission to read
        // from the registry, then they cannot continue
        hReturn = WBEM_E_ACCESS_DENIED;
    }

#else
    hReturn = S_OK;
#endif

    if (hReturn == S_OK) {
    
        hReturn = CreateRefresherObject( 
            pNamespace,
            pTemplate,
            pRefresher,
            lFlags,
            pContext,
            NULL,
            NULL,
            ppRefreshable,
            plId);
    }

#ifdef __WBEMSECURITY
    // Revert if we successfuly impersonated the user
    if ( fRevert )
    {
        CoRevertToSelf();
    }
#endif

    return hReturn;
}
    
//***************************************************************************
//
//  CNt5PerfProvider::StopRefreshing
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lId>                   The ID of the object.
//  <lFlags>                Not used.
//  
//***************************************************************************        
// ok
        
HRESULT CNt5PerfProvider::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags
    )
{
    CNt5Refresher *pRef;
    BOOL bRes ;
    HRESULT hReturn;

    UNREFERENCED_PARAMETER(lFlags);

#ifdef __WBEMSECURITY
    hReturn = CoImpersonateClient(); // make sure we're legit.

    BOOL    fRevert = SUCCEEDED( hReturn );

    // The following error appears to occur when we are in-proc and there is no
    // proxy/stub, so we are effectively impersonating already

    if ( RPC_E_CALL_COMPLETE == hReturn ) {
        hReturn = S_OK;
    } 

    if (S_OK == hReturn) {
        hReturn = CheckImpersonationLevel();
    }
    // Check Registry security here.
    if ((hReturn != S_OK) || (!HasPermission())) {
        // if Impersonation level is incorrect or
        // the caller doesn't have permission to read
        // from the registry, then they cannot continue
        hReturn = WBEM_E_ACCESS_DENIED;
    }

#else
    hReturn = S_OK;
#endif

    if (hReturn == S_OK) {

        pRef = (CNt5Refresher *) pRefresher;

        bRes = pRef->RemoveObject(lId);
        if (bRes == FALSE) {
            hReturn = WBEM_E_FAILED;
        } else {
            hReturn = WBEM_NO_ERROR;
        }
    }

#ifdef __WBEMSECURITY
    // Revert if we successfuly impersonated the user
    if ( fRevert )
    {
        CoRevertToSelf();
    }
#endif
    
    return hReturn;
}
 
HRESULT CNt5PerfProvider::CreateRefreshableEnum( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [string][in] */ LPCWSTR wszClass,
        /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pContext,
        /* [in] */ IWbemHiPerfEnum __RPC_FAR *pHiPerfEnum,
        /* [out] */ long __RPC_FAR *plId)
{
    HRESULT     hReturn;

#ifdef __WBEMSECURITY
    hReturn = CoImpersonateClient(); // make sure we're legit.

    BOOL    fRevert = SUCCEEDED( hReturn );

    // The following error appears to occur when we are in-proc and there is no
    // proxy/stub, so we are effectively impersonating already

    if ( RPC_E_CALL_COMPLETE == hReturn ) {
        hReturn = S_OK;
    } 

    if (S_OK == hReturn) {
        hReturn = CheckImpersonationLevel();
    }
    // Check Registry security here.
    if ((hReturn != S_OK) || (!HasPermission())) {
        // if Impersonation level is incorrect or
        // the caller doesn't have permission to read
        // from the registry, then they cannot continue
        hReturn = WBEM_E_ACCESS_DENIED;
    }

#else
    hReturn = S_OK;
#endif

    if (hReturn == S_OK) {

        hReturn = CreateRefresherObject( 
            pNamespace,
            NULL,
            pRefresher,
            lFlags,
            pContext,
            wszClass,
            pHiPerfEnum,
            NULL,
            plId);
    }

#ifdef __WBEMSECURITY
    // Revert if we successfuly impersonated the user
    if ( fRevert )
    {
        CoRevertToSelf();
    }
#endif
    
    return hReturn;
}
 
HRESULT CNt5PerfProvider::GetObjects( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [in] */ long lNumObjects,
        /* [size_is][in] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pContext)
{
    DBG_UNREFERENCED_PARAMETER(pNamespace);
    DBG_UNREFERENCED_PARAMETER(lNumObjects);
    DBG_UNREFERENCED_PARAMETER(apObj);
    DBG_UNREFERENCED_PARAMETER(lFlags);
    DBG_UNREFERENCED_PARAMETER(pContext);

    return WBEM_E_METHOD_NOT_IMPLEMENTED;
}  
 
//***************************************************************************
//
//  CNt5PerfProvider::MapClass
//
//  Adds the class map to an internal cache.
//
//  <pClsMap>           The pointer to the map info to add.  This pointer
//                      is acquired by this function and should not be
//                      deleted by the caller.
//
//***************************************************************************
// ok
BOOL CNt5PerfProvider::AddClassMap(
    IN CClassMapInfo *pClsMap
    )
{
    DWORD           dwResult = ERROR_SUCCESS;
    int             i;
    CClassMapInfo   *pTracer;
    int             nNumElements;

    if (m_hClassMapMutex != 0) {
        if (WAIT_OBJECT_0 == WaitForSingleObject(m_hClassMapMutex, cdwClassMapTimeout)) {
            nNumElements = m_aCache.Size();

			// Because of a problem in which perflibs seem to ignore supported methods of updating
			// the perflib names database (lodctr/unlodctr), do a quick initial traversal to ensure
			// that we don't have any duplicate object indices, since this can cause real problems
			// during adding and refreshing, since incorrect indexes can be returned.

            for (i = 0; i < nNumElements; i++) {
                pTracer = (CClassMapInfo *) m_aCache[i];

				// We've got a problem -- we cannot add this class
                if (pClsMap->m_dwObjectId == pTracer->m_dwObjectId )
				{
					ReleaseMutex( m_hClassMapMutex );
                    return FALSE;
                }
            }

            for (i = 0; i < nNumElements; i++) {
                pTracer = (CClassMapInfo *) m_aCache[i];
                if (_wcsicmp(pClsMap->m_pszClassName, pTracer->m_pszClassName) < 0) {
                    m_aCache.InsertAt(i, pClsMap);
                    break;
                }
            }
    
            if (i == nNumElements) {
                // If here, add it to the end.
                // ===========================
                m_aCache.Add(pClsMap);
            }

            // make sure the library is in the list
            dwResult = m_PerfObject.AddClass (pClsMap->m_pClassDef, TRUE);
            ReleaseMutex(m_hClassMapMutex);
        } else {
            dwResult = ERROR_LOCK_FAILED;
        }
    }
    return (dwResult == ERROR_SUCCESS);
}    

//***************************************************************************
//
//  CNt5PerfProvider::FindClassMap
//
//***************************************************************************
// ok
CClassMapInfo *CNt5PerfProvider::FindClassMap(
    LPWSTR pszClassName
    )
{
    int             l = 0;
    int             u;
    int             m;
    CClassMapInfo   *pClsMap;
    CClassMapInfo   *pClsMapReturn = NULL;

    // Binary search the cache.
    // ========================

    if (m_hClassMapMutex != 0) {
        if (WAIT_OBJECT_0 == WaitForSingleObject(m_hClassMapMutex, cdwClassMapTimeout)) {

            u = m_aCache.Size() - 1;

            while (l <= u) {
                m = (l + u) / 2;

                pClsMap = (CClassMapInfo *) m_aCache[m];

                if (pClsMap != NULL) {
                    if (_wcsicmp(pszClassName, pClsMap->m_pszClassName) < 0) {
                        u = m - 1;
                    } else if (_wcsicmp(pszClassName, pClsMap->m_pszClassName) > 0) {
                        l = m + 1;
                    } else {   // Hit!
                        pClsMapReturn = pClsMap;
                        break;
                    }
                } else {
                    break;
                }
            }
            ReleaseMutex(m_hClassMapMutex);
        }
    }
    return pClsMapReturn;
}

//***************************************************************************
//
//  CNt5PerfProvider::MapClass
//
//  Retrieves the requested class and places it in the cache.
//  
//  Parameters:
//      pNs         The namespace which contains the class definition.
//      wsClass     The class name.
//      pCtx        The inbound context object.  Only used for reentrant
//                  calls.
//
//***************************************************************************
// ok
BOOL CNt5PerfProvider::MapClass(
    IN IWbemServices *pNs,
    IN WCHAR *wszClass,
    IN IWbemContext *pCtx    
    )
{
    HRESULT             hRes = 0;
    BOOL                bReturn = FALSE; 
    IWbemClassObject    *pClsDef = 0;
    IWbemQualifierSet   *pQSet = 0;
    VARIANT             v;
    CClassMapInfo       *pMapInfo = 0;

    if (m_hClassMapMutex != 0) {
        if (WAIT_OBJECT_0 == WaitForSingleObject(m_hClassMapMutex, cdwClassMapTimeout)) {
            // See if the class is already in the cache.
            // =========================================
            if (FindClassMap(wszClass) != 0) {
                // already loaded so quit now
                bReturn = TRUE;
            } else {
                // Get the class definition from CIMOM.
                // ====================================
                hRes = pNs->GetObject(CBSTR(wszClass), 0, pCtx, &pClsDef, 0);
                if (hRes == NO_ERROR) {
                    // Verify the class is one of ours by checking
                    // the "provider" qualifier to ensure it matches
                    // the name that we we have for this component.
                    // =============================================
                    hRes = pClsDef->GetQualifierSet(&pQSet);
                    if (hRes == NO_ERROR) {
                        VariantInit(&v);
                        hRes = pQSet->Get(CBSTR(cszProvider), 0, &v, 0);
                        pQSet->Release();
                        
                        if ((hRes == NO_ERROR) && (v.vt == VT_BSTR)) {
                            if (_wcsicmp(V_BSTR(&v), cszProviderName) == 0) {
                                // Get the property handles and mappings to the perf counter ids
                                // by calling the Map() method of CClassMapInfo.
                                // ==============================================================
                                pMapInfo = new CClassMapInfo;
                                if (pMapInfo != NULL) {
                                    if (pMapInfo->Map(pClsDef)) {
                                        // Add it to the cache.
                                        // ====================
                                        bReturn = AddClassMap(pMapInfo);
                                    } else {
                                        // unable to add this to the cache
                                        delete pMapInfo;
                                        //pClsDef->Release(); // this was not AddRef'd so no need to Release
                                    }
                                } else {
                                    // inable to create new class
                                    bReturn = FALSE;
                                }
                            } else {
                                // unable to read provider qualifier so bail
                                // as this isn't a dynamic provider
                                pClsDef->Release(); 
                            }
                        } else {
                            SetLastError ((DWORD)WBEM_E_INVALID_PROVIDER_REGISTRATION);
                        }
                        VariantClear(&v);
                    } else {
                        // unable to get qualifiers
                        pClsDef->Release();
                    }
                } else {
                    // Unable to retrieve the class definition
                }
            } 
            ReleaseMutex(m_hClassMapMutex);
        }
    }
    return bReturn;
}    

//***************************************************************************
//
//  CNt5PerfProvider::HasPermission
//
//  tests to see if the caller has permission to access the functions
//  
//  Parameters:
//      void        N/A
//
//***************************************************************************
// ok
BOOL CNt5PerfProvider::HasPermission (void)
{
    DWORD   dwStatus;
    HKEY    hKeyTest;
    BOOL    bReturn;

    dwStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        (LPCWSTR)L"Software\\Microsoft\\Windows NT\\CurrentVersion\\WbemPerf",
        0, KEY_READ, &hKeyTest);

    if ((dwStatus == ERROR_SUCCESS) || (dwStatus == ERROR_FILE_NOT_FOUND)) {
        bReturn = TRUE;
        if (dwStatus == ERROR_SUCCESS) RegCloseKey (hKeyTest);
    } else  {
        bReturn = FALSE;
    }

    return bReturn;
}

//***************************************************************************
//
//  CNt5PerfProvider::CheckImpersonationLevel
//
//  tests caller's security impersonation level for correct access
//  
//  Only call here if CoImpersonate worked.
//
//  Parameters:
//      void        N/A
//
//***************************************************************************
// ok
HRESULT CNt5PerfProvider::CheckImpersonationLevel (void)
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;
    BOOL    bReturn;

    // Now, let's check the impersonation level.  First, get the thread token
    HANDLE hThreadTok;
    DWORD dwImp, dwBytesReturned;

    bReturn = OpenThreadToken(
        GetCurrentThread(),
        TOKEN_QUERY,
        TRUE,
        &hThreadTok);

    if (!bReturn) {

        // If the CoImpersonate works, but the OpenThreadToken fails, we are running under the
        // process token (either local system, or if we are running with /exe, the rights of
        // the logged in user).  In either case, impersonation rights don't apply.  We have the
        // full rights of that user.

        hr = WBEM_S_NO_ERROR;

    } else {
        // We really do have a thread token, so let's retrieve its level

        bReturn = GetTokenInformation(
            hThreadTok,
            TokenImpersonationLevel,
            &dwImp,
            sizeof(DWORD),
            &dwBytesReturned);

        if (bReturn) {
            // Is the impersonation level Impersonate?
            if ((dwImp == SecurityImpersonation) || (dwImp == SecurityDelegation)) {
                hr = WBEM_S_NO_ERROR;
            } else {
                hr = WBEM_E_ACCESS_DENIED;
            }
        } else {
            hr = WBEM_E_FAILED;
        }

        // Done with this handle
        CloseHandle(hThreadTok);
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\flexarry.h ===
//***************************************************************************
//
//  (c) 1998-1999 by Microsoft Corp.
//
//  FLEXARRY.H
//
//  CFlexArray and CWStringArray implementation.
//
//  This
//
//  15-Jul-97   raymcc    This implementation is not based on arenas.
//   8-Jun-98   bobw      cleaned up for use with WBEMPERF provider
//
//***************************************************************************

#ifndef _FLEXARRY_H_
#define _FLEXARRY_H_

#ifdef __cplusplus
//***************************************************************************
//
//  class CFlexArray
//
//  This class is a generic pointer array.
//
//***************************************************************************

class CFlexArray
{
private:
    int     m_nSize;            // apparent size
    int     m_nExtent;          // de facto size
    int     m_nGrowBy;          
    HANDLE  m_hHeap;            // heap to hold array
    void**  m_pArray;
            
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };

    // Constructs a flex array at an initial size and
    // specifies the initial size and growth-size chunk.
    // =================================================
    CFlexArray(
        IN int nInitialSize = 32, 
        IN int nGrowBy = 32
        );

   ~CFlexArray(); 
    CFlexArray(CFlexArray &);
    CFlexArray& operator=(CFlexArray &);

    // Gets an element at a particular location.
    // =========================================
    void *  GetAt(int nIndex) const { return m_pArray[nIndex]; }

    // Returns a ptr in the array; allows use on left-hand side of assignment.
    // =======================================================================
    void * operator[](int nIndex) const { return m_pArray[nIndex]; }
    void *& operator[](int nIndex) { return m_pArray[nIndex]; }

    // Sets the element at the requested location.
    // ===========================================
    void  SetAt(int nIndex, void *p) { m_pArray[nIndex] = p; }

    // Removes an element.
    // ====================
    int   RemoveAt(int nIndex);

    // Inserts an element.
    // ===================
    int   InsertAt(int nIndex, void *);

    // Removes all zero entries (null ptrs) and shrinks the array size.
    // ================================================================
    void  Compress();    

    // Adds a new element to the end of the array.
    // ===========================================
    int   Add(void *pSrc) { return InsertAt(m_nSize, pSrc); }    

    // Gets the apparent size of the array (number of used elements)
    // =============================================================
    int   Size() const { return m_nSize; }

    // Removes all entries and reduces array size to zero. The elements
    // are simply removed; not deallocated (this class doesn't know what
    // they are).
    // =================================================================
    void  Empty();

    // Gets a pointer to the internal array.
    // =====================================
    void** GetArrayPtr() { return m_pArray; }
    
    // Gets a pointer to the internal array and Resets the contents to none
    // ====================================================================

    void** UnbindPtr();

    // For debugging.
    // ==============
    void  DebugDump();
};

#endif  // __cplusplus
#endif  // not defined
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\oahelp.inl ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    oahelp.inl

Abstract:

    OLE Automation Helpers for client code

--*/

#ifndef _OAHELP_INL_
#define _OAHELP_INL_

#pragma warning (disable : 4310)	// typecasting in the following causes a warning
class CBSTR
{
    BSTR m_pStr;
public:
    CBSTR() { m_pStr = 0; }
    CBSTR(LPWSTR pSrc) { m_pStr = SysAllocString(pSrc); }
    CBSTR(LPCWSTR pSrc) { m_pStr = SysAllocString((LPWSTR)pSrc); }
   ~CBSTR() { if (m_pStr) SysFreeString(m_pStr); }
    operator BSTR() { return m_pStr; }

    void Unbind() { m_pStr = 0; }
};

class CVARIANT
{
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
   ~CVARIANT() { VariantClear(&v); }
    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }

    CVARIANT(LPWSTR pSrc)   { VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)     { VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(BOOL b)        { VariantInit(&v); SetBool(b); }
    CVARIANT(short i)       { VariantInit(&v); SetShort(i); }
    CVARIANT(double d)      { VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)        { VariantInit(&v); SetByte(b); }
    CVARIANT(IDispatch * pDisp) { VariantInit(&v); pDisp->AddRef(); SetDispatch(pDisp); }

    void   SetStr(LPWSTR pSrc)
    { Clear(); V_VT(&v) = (WORD)(pSrc != NULL ? VT_BSTR : VT_NULL); 
      V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDouble(double dSrc) { Clear(); V_VT(&v) = VT_R8; V_R8(&v) = dSrc; }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc; }
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) { V_VT(&v) = VT_BOOL; V_BOOL(&v) = (VARIANT_BOOL)(b ? VARIANT_TRUE : VARIANT_FALSE); }
    BOOL GetBool() { return (BOOL)(V_BOOL(&v) == VARIANT_TRUE); }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) { V_VT(&v) = VT_DISPATCH; V_DISPATCH(&v) = pDisp; }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) { V_VT(&v) = VT_UNKNOWN; V_UNKNOWN(&v) = pUnk; }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    void SetArray(SAFEARRAY *p, VARTYPE vt) { Clear(); V_VT(&v) = vt; V_ARRAY(&v) = p; }
        // This function acquires the SAFEARRAY pointer and it is no longer owned
        // by the caller.

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { VariantInit(&v); }
};

class CSAFEARRAY
{
    SAFEARRAY *p;
public:
    CSAFEARRAY(VARTYPE v, int nSize) 
    {
        SAFEARRAYBOUND rgsabound[1];
    	rgsabound[0].lLbound = 0;
    	rgsabound[0].cElements = nSize;
        p = SafeArrayCreate(v, 1, rgsabound);
    }
    
    ~CSAFEARRAY() { if (p) SafeArrayDestroy(p); }
    CSAFEARRAY(SAFEARRAY *pSrc) { p = pSrc; }

    HRESULT Put(long nLocation, LPVOID pData) {
        return SafeArrayPutElement(p, &nLocation, pData);                
    }

    HRESULT Get(long nLocation, LPVOID pData) { 
        return SafeArrayGetElement(p, &nLocation, pData);                
    }

    HRESULT Access(void **pData) { return SafeArrayAccessData(p, pData); }
    HRESULT Unaccess() { return SafeArrayUnaccessData(p); }

    operator SAFEARRAY *() { return p; }
    long GetNumElements() { long upper; SafeArrayGetUBound(p, 1, &upper); return upper + 1; }

    void Unbind() { p = 0; }
};
#pragma warning (default : 4310)	// restore


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\ntperf.h ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    ntperf.h

Abstract:

    NT5 Perf counter provider

    <abstract>

--*/

#ifndef _NTPERF_H_
#define _NTPERF_H_

#include "flexarry.h"
#include "classmap.h"
#include "perfacc.h"

const DWORD cdwClassMapTimeout = 10000;

//***************************************************************************
//
//  class CNt5PerfProvider
//
//***************************************************************************

class CNt5PerfProvider : public IWbemHiPerfProvider, public IWbemProviderInit
{
    friend class CNt5Refresher;

public:
    typedef enum {
        CLSID_SERVER,
        CLSID_CLIENT
    } enumCLSID;

private:
    LONG                m_lRef;
    enumCLSID           m_OriginClsid;
    CFlexArray          m_aCache;       // Array of CClassMapInfo pointers
	CPerfObjectAccess	m_PerfObject;	// class to interface

    HANDLE				m_hClassMapMutex;	// Lock the provider's Class Map Cache

protected:
    BOOL AddClassMap(CClassMapInfo *pCls);
    CClassMapInfo *FindClassMap(LPWSTR pszClassName);

    BOOL MapClass(
        IWbemServices *pNs,
        WCHAR *wszClass,
        IWbemContext *pCtx    
        );

public:
    static BOOL HasPermission (void);
    static HRESULT CheckImpersonationLevel (void);
    
    CNt5PerfProvider(enumCLSID OriginClsid);
   ~CNt5PerfProvider();

    // Interface members.
    // ==================

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);

	// helper functions
	HRESULT CNt5PerfProvider::CreateRefresherObject( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
		/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pContext,
		/* [string][in] */ LPCWSTR wszClass,
		/* [in] */ IWbemHiPerfEnum __RPC_FAR *pHiPerfEnum,
		/* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
		/* [out] */ long __RPC_FAR *plId
		);


    // IWbemHiPerfProvider methods.
    // ============================
        
    virtual HRESULT STDMETHODCALLTYPE QueryInstances( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [string][in] */ WCHAR __RPC_FAR *wszClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink
        );
    
    virtual HRESULT STDMETHODCALLTYPE CreateRefresher( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [in] */ long lFlags,
        /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
        );
    
    virtual HRESULT STDMETHODCALLTYPE CreateRefreshableObject( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
        /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pContext,
        /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
        /* [out] */ long __RPC_FAR *plId
        );
    
    virtual HRESULT STDMETHODCALLTYPE StopRefreshing( 
        /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
        /* [in] */ long lId,
        /* [in] */ long lFlags
        );

    virtual HRESULT STDMETHODCALLTYPE CreateRefreshableEnum( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [string][in] */ LPCWSTR wszClass,
        /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pContext,
        /* [in] */ IWbemHiPerfEnum __RPC_FAR *pHiPerfEnum,
        /* [out] */ long __RPC_FAR *plId);
    
    virtual HRESULT STDMETHODCALLTYPE GetObjects( 
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [in] */ long lNumObjects,
        /* [size_is][in] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pContext);
    

    // IWbemProviderInit method.
    // =========================
        
    virtual HRESULT STDMETHODCALLTYPE Initialize( 
        /* [unique][in] */ LPWSTR wszUser,
        /* [in] */ LONG lFlags,
        /* [in] */ LPWSTR wszNamespace,
        /* [unique][in] */ LPWSTR wszLocale,
        /* [in] */ IWbemServices __RPC_FAR *pNamespace,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
        );
        
};

// defined in server.cpp
extern void ObjectCreated();
extern void ObjectDestroyed();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\perfhelp.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    perfhelp.cpp

Abstract:

    Registry-based performance counter reading helper

--*/

#include "wpheader.h"
#include <stdio.h>

BOOL PerfHelper::IsMatchingInstance (
    PERF_INSTANCE_DEFINITION    *pInstanceDef,
    DWORD                       dwCodePage,
    LPWSTR                      szInstanceNameToMatch,
    DWORD                       dwInstanceNameLength
)
// compares pInstanceName to the name in the instance
{
    DWORD   dwThisInstanceNameLength;
    LPWSTR  szThisInstanceName;
    WCHAR   szBufferForANSINames[MAX_PATH];
    BOOL    bReturn = FALSE;

    if (dwInstanceNameLength == 0) {
        // get the length to compare
        dwInstanceNameLength = lstrlenW (szInstanceNameToMatch);
    }

    if (dwCodePage == 0) {
        // try to take a shortcut here if it's a unicode string
        // compare to the length of the shortest string
        // get the pointer to this string
        szThisInstanceName = GetInstanceName(pInstanceDef);

        // convert instance Name from bytes to chars
        dwThisInstanceNameLength = pInstanceDef->NameLength / sizeof(WCHAR);

        // see if this length includes the term. null. If so shorten it
        if (szThisInstanceName[dwThisInstanceNameLength-1] == 0) {
            dwThisInstanceNameLength--;
        }
    } else {
        // go the long way and read/translate/convert the string
        dwThisInstanceNameLength =GetInstanceNameStr (pInstanceDef,
                    szBufferForANSINames,
                    dwCodePage);
        if (dwThisInstanceNameLength > 0) {
            szThisInstanceName = &szBufferForANSINames[0];
        } else {
            szThisInstanceName = (LPWSTR)cszSpace;
        }
    }

    // if the lengths are not equal then the names can't be either
    if (dwInstanceNameLength == dwThisInstanceNameLength) {
        if (lstrcmpiW(szInstanceNameToMatch, szThisInstanceName) == 0) {
            // this is a match
            bReturn = TRUE;
        } else {
            // this is not a match
        }
    }
    return bReturn;
}

BOOL PerfHelper::ParseInstanceName (
    IN      LPCWSTR szInstanceString,
    IN      LPWSTR  szInstanceName,
    IN      LPWSTR  szParentName,
    IN      LPDWORD lpIndex
)
/*
    parses the instance name formatted as follows

        [parent/]instance[#index]

    parent is optional and if present, is delimited by a forward slash
    index is optional and if present, is delimited by a colon

    parent and instance may be any legal file name character except a
    delimeter character "/#\()" Index must be a string composed of
    decimal digit characters (0-9), less than 10 characters in length, and
    equate to a value between 0 and 2**32-1 (inclusive).

    This function assumes that the instance name and parent name buffers
    are of sufficient size.

    NOTE: szInstanceName and szInstanceString can be the same buffer

*/
{
    LPWSTR  szSrcChar, szDestChar;
    BOOL    bReturn = FALSE;
    WCHAR   szIndexBuffer[MAX_PATH];    // just to be safe
    DWORD   dwIndex = 0;

    szDestChar = (LPWSTR)szInstanceName;
    szSrcChar = (LPWSTR)szInstanceString;

    __try {
        do {
            *szDestChar++ = *szSrcChar++;
        } while ((*szSrcChar != 0) &&
                 (*szSrcChar != wcSlash) &&
                 (*szSrcChar != wcPoundSign));
        // see if that was really the parent or not
        if (*szSrcChar == wcSlash) {
            // terminate destination after test in case they are the same buffer
            *szDestChar = 0;
            szSrcChar++;    // and move source pointer past delimter
            // it was the parent name so copy it to the parent
            lstrcpyW (szParentName, szInstanceName);
            // and copy the rest of the string after the "/" to the
            //  instance name field
            szDestChar = szInstanceName;
            do {
                *szDestChar++ = *szSrcChar++;
            } while ((*szSrcChar != 0) && (*szSrcChar != wcPoundSign));
        } else {
            // that was the only element so load an empty string for the parent
            *szParentName = 0;
        }
        // *szSrcChar will either be pointing to the end of the input string
        // in which case the "0" index is assumed or it will be pointing
        // to the # delimiting the index argument in the string.
        if (*szSrcChar == wcPoundSign) {
            *szDestChar = 0;    // terminate the destination string
            szSrcChar++;    // move past delimter
            szDestChar = &szIndexBuffer[0];
            do {
                *szDestChar++ = *szSrcChar++;
            } while (*szSrcChar != 0);
            *szDestChar = 0;
            dwIndex = wcstoul (szIndexBuffer, NULL, 10);
        } else {
            *szDestChar = 0;    // terminate the destination string
            dwIndex = 0;
        }
        *lpIndex = dwIndex;
        bReturn = TRUE;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // unable to move strings
        bReturn = FALSE;
    }
    return bReturn;
}

#pragma warning ( disable : 4127)   // while (TRUE) error
PERF_OBJECT_TYPE *
PerfHelper::GetObjectDefByTitleIndex(
    IN  PERF_DATA_BLOCK *pDataBlock,
    IN  DWORD ObjectTypeTitleIndex
)
{
    DWORD NumTypeDef;

    PERF_OBJECT_TYPE *pObjectDef = NULL;
    PERF_OBJECT_TYPE *pReturnObject = NULL;
    PERF_OBJECT_TYPE *pEndOfBuffer = NULL;

    __try {
        pObjectDef = FirstObject(pDataBlock);
        pEndOfBuffer = (PPERF_OBJECT_TYPE)
                        ((DWORD_PTR)pDataBlock +
                            pDataBlock->TotalByteLength);

        if (pObjectDef != NULL) {
            NumTypeDef = 0;
            while (1) {
                if ( pObjectDef->ObjectNameTitleIndex == ObjectTypeTitleIndex ) {
                    pReturnObject = pObjectDef;
                    break;
                } else {
                    NumTypeDef++;
                    if (NumTypeDef < pDataBlock->NumObjectTypes) {
                        pObjectDef = NextObject(pObjectDef);
                        //make sure next object is legit
                        if (pObjectDef >= pEndOfBuffer) {
                            // looks like we ran off the end of the data buffer
                            assert (pObjectDef < pEndOfBuffer);
                            break;
                        } else {
                            if (pObjectDef != NULL) {
                                if (pObjectDef->TotalByteLength == 0) {
                                    // 0-length object buffer returned
                                    assert (pObjectDef->TotalByteLength > 0);
                                    break;
                                }
                            } else {
                                // and continue
                                assert (pObjectDef != NULL);
                                break;
                            }
                        }
                    } else {
                        // no more data objects in this data block
                        break;
                    }
                }
            }
        } // else no object found
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pReturnObject = NULL;
    }
    return pReturnObject;
}
#pragma warning ( default : 4127)   // while (TRUE) error

#pragma warning ( disable : 4127)   // while (TRUE) error
PERF_OBJECT_TYPE *
PerfHelper::GetObjectDefByName (
    IN      PERF_DATA_BLOCK *pDataBlock,
    IN      DWORD           dwLastNameIndex,
    IN      LPCWSTR         *NameArray,
    IN      LPCWSTR         szObjectName
)
{
    DWORD NumTypeDef;
    PERF_OBJECT_TYPE *pReturnObject = NULL;
    PERF_OBJECT_TYPE *pObjectDef = NULL;
    PERF_OBJECT_TYPE *pEndOfBuffer = NULL;

    __try {

        pObjectDef = FirstObject(pDataBlock);
        pEndOfBuffer = (PPERF_OBJECT_TYPE)
                        ((DWORD_PTR)pDataBlock +
                            pDataBlock->TotalByteLength);

        if (pObjectDef != NULL) {

            NumTypeDef = 0;
            while (1) {
                if ( pObjectDef->ObjectNameTitleIndex < dwLastNameIndex ) {
                    // look up name of object & compare
                    if (lstrcmpiW(NameArray[pObjectDef->ObjectNameTitleIndex],
                            szObjectName) == 0) {
                        pReturnObject = pObjectDef;
                        break;
                    }
                }
                NumTypeDef++;
                if (NumTypeDef < pDataBlock->NumObjectTypes) {
                    pObjectDef = NextObject(pObjectDef); // get next
                    //make sure next object is legit
                    if (pObjectDef != NULL) {
                        if (pObjectDef->TotalByteLength > 0) {
                            if (pObjectDef >= pEndOfBuffer) {
                                // looks like we ran off the end of the data buffer
                                assert (pObjectDef < pEndOfBuffer);
                                break;
                            }
                        } else {
                            // 0-length object buffer returned
                            assert (pObjectDef->TotalByteLength > 0);
                            break;
                        }
                    } else {
                        // null pointer
                        assert (pObjectDef != NULL);
                        break;
                    }
                } else {
                    // end of data block
                    break;
                }
            }
        } // else no object found
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pReturnObject = NULL;
    }
    return pReturnObject;
}
#pragma warning ( default : 4127)   // while (TRUE) error

PERF_INSTANCE_DEFINITION *
PerfHelper::GetInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceNumber
)
{

    PERF_INSTANCE_DEFINITION *pInstanceDef;
    PERF_INSTANCE_DEFINITION *pReturnDef = NULL;
    PERF_INSTANCE_DEFINITION *pEndOfBuffer = NULL;
    LONG NumInstance;


    if (pObjectDef != NULL) {
        pInstanceDef = FirstInstance(pObjectDef);
        if (pInstanceDef != NULL) {
            pEndOfBuffer = (PERF_INSTANCE_DEFINITION *)EndOfObject(pObjectDef);

            for ( NumInstance = 0;
                NumInstance < pObjectDef->NumInstances;
                NumInstance++ )  {
                if ( InstanceNumber == NumInstance ) {
                    pReturnDef = pInstanceDef;                    
                }
                pInstanceDef = NextInstance(pInstanceDef);
                // go to next instance in object and check for buffer overrun
                if (pInstanceDef >= pEndOfBuffer) {
                    // something doesn't add up so bail out and return NULL
                    break;
                }
            }
        }
    }

    return pReturnDef;
}

PERF_INSTANCE_DEFINITION *
PerfHelper::GetInstanceByUniqueId(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceUniqueId
)
{
    PERF_INSTANCE_DEFINITION *pInstanceDef;
    PERF_INSTANCE_DEFINITION *pReturnDef = NULL;
    PERF_INSTANCE_DEFINITION *pEndOfBuffer = NULL;
    LONG NumInstance;

    if (pObjectDef != NULL) {
        pInstanceDef = FirstInstance(pObjectDef);
        if (pInstanceDef != NULL) {
            pEndOfBuffer = (PERF_INSTANCE_DEFINITION *)EndOfObject(pObjectDef);

            for ( NumInstance = 0;
                NumInstance < pObjectDef->NumInstances;
                NumInstance++ )  {
                if ( InstanceUniqueId == pInstanceDef->UniqueID ) {
                    pReturnDef = pInstanceDef;
                }
                pInstanceDef = NextInstance(pInstanceDef);
                // go to next instance in object and check for buffer overrun
                if (pInstanceDef >= pEndOfBuffer) {
                    // something doesn't add up so bail out and return NULL
                    break;
                }
            }
        }
    }
    return pReturnDef;
}

DWORD
PerfHelper::GetAnsiInstanceName (PPERF_INSTANCE_DEFINITION pInstance,
                    LPWSTR lpszInstance,
                    DWORD dwCodePage)
{
    LPSTR   szSource;
    DWORD_PTR   dwLength;

    UNREFERENCED_PARAMETER(dwCodePage);

    szSource = (LPSTR)GetInstanceName(pInstance);

    // the locale should be set here

    // pInstance->NameLength == the number of bytes (chars) in the string
    dwLength = mbstowcs (lpszInstance, szSource, pInstance->NameLength);
    lpszInstance[dwLength] = 0; // null terminate string buffer

    return (DWORD)dwLength;
}

DWORD
PerfHelper::GetUnicodeInstanceName (PPERF_INSTANCE_DEFINITION pInstance,
                    LPWSTR lpszInstance)
{
   LPWSTR   wszSource;
   DWORD    dwLength;

   wszSource = GetInstanceName(pInstance) ;

   // pInstance->NameLength == length of string in BYTES so adjust to
   // number of wide characters here
   dwLength = pInstance->NameLength / sizeof(WCHAR);

   wcsncpy (lpszInstance,
        (LPWSTR)wszSource,
        dwLength);

   // add null termination if string length does not include  the null
   if ((dwLength > 0) && (lpszInstance[dwLength-1] != 0)) {    // i.e. it's the last character of the string
           lpszInstance[dwLength] = 0;    // then add a terminating null char to the string
   } else {
           // assume that the length value includes the terminating NULL
        // so adjust value to indicate chars only
           dwLength--;
   }

   return (dwLength); // just incase there's null's in the string
}

DWORD
PerfHelper::GetInstanceNameStr (PPERF_INSTANCE_DEFINITION pInstance,
                    LPWSTR lpszInstance,
                    DWORD dwCodePage)
{
    DWORD  dwCharSize;
    DWORD  dwLength = 0;

    if (pInstance != NULL) {
        if (lpszInstance != NULL) {
            if (dwCodePage > 0) {
                    dwCharSize = sizeof(CHAR);
                    dwLength = GetAnsiInstanceName (pInstance, lpszInstance, dwCodePage);
            } else { // it's a UNICODE name
                    dwCharSize = sizeof(WCHAR);
                    dwLength = GetUnicodeInstanceName (pInstance, lpszInstance);
            }
            // sanity check here...
            // the returned string length (in characters) plus the terminating NULL
            // should be the same as the specified length in bytes divided by the
            // character size. If not then the codepage and instance data type
            // don't line up so test that here

            if ((dwLength + 1) != (pInstance->NameLength / dwCharSize)) {
                // something isn't quite right so try the "other" type of string type
                if (dwCharSize == sizeof(CHAR)) {
                    // then we tried to read it as an ASCII string and that didn't work
                    // so try it as a UNICODE (if that doesn't work give up and return
                    // it any way.
                    dwLength = GetUnicodeInstanceName (pInstance, lpszInstance);
                } else if (dwCharSize == sizeof(WCHAR)) {
                    // then we tried to read it as a UNICODE string and that didn't work
                    // so try it as an ASCII string (if that doesn't work give up and return
                    // it any way.
                    dwLength = GetAnsiInstanceName (pInstance, lpszInstance, dwCodePage);
                }
            }
        } // else return buffer is null
    } else {
        // no instance def object is specified so return an empty string
        *lpszInstance = 0;
    }

    return dwLength;
}

PERF_INSTANCE_DEFINITION *
PerfHelper::GetInstanceByNameUsingParentTitleIndex(
    PERF_DATA_BLOCK *pDataBlock,
    PERF_OBJECT_TYPE *pObjectDef,
    LPWSTR pInstanceName,
    LPWSTR pParentName,
    DWORD  dwIndex
)
{
   PERF_OBJECT_TYPE *pParentObj;

   PERF_INSTANCE_DEFINITION  *pParentInst;
   PERF_INSTANCE_DEFINITION  *pInstanceDef;
   PERF_INSTANCE_DEFINITION  *pReturnDef = NULL;

   LONG     NumInstance;
   DWORD    dwLocalIndex;
   DWORD    dwInstanceNameLength;

   pInstanceDef = FirstInstance(pObjectDef);
   assert (pInstanceDef != NULL);
   dwLocalIndex = dwIndex;

    dwInstanceNameLength = lstrlenW(pInstanceName);

    for ( NumInstance = 0;
      NumInstance < pObjectDef->NumInstances;
      NumInstance++ ) {

        if (IsMatchingInstance (pInstanceDef, pObjectDef->CodePage,
             pInstanceName, dwInstanceNameLength )) {
            // this is the correct instance, so see if we need to find a parent instance
            if ( pParentName == NULL ) {
               // No parent, we're done if this is the right "copy"
                if (dwLocalIndex == 0) {
                    pReturnDef = pInstanceDef;
                    break;
                } else {
                    --dwLocalIndex;
                }
            } else {
                // Must match parent as well

                pParentObj = GetObjectDefByTitleIndex(
                   pDataBlock,
                   pInstanceDef->ParentObjectTitleIndex);

                if (!pParentObj) {
                   // can't locate the parent, forget it
                   break;
                }

                // Object type of parent found; now find parent
                // instance

                pParentInst = GetInstance(pParentObj,
                   pInstanceDef->ParentObjectInstance);

                if (!pParentInst) {
                   // can't locate the parent instance, forget it
                   break ;
                }

                if (IsMatchingInstance (pParentInst, pParentObj->CodePage,
                    pParentName, 0)) {
                   // Parent Instance Name matches that passed in
                    if (dwLocalIndex == 0) {
                        pReturnDef = pInstanceDef;
                        break;
                    } else {
                        --dwLocalIndex;
                    }
                }
            }
        }
        // get the next one
        pInstanceDef = NextInstance(pInstanceDef);
    }
    return pReturnDef;
}

PERF_INSTANCE_DEFINITION *
PerfHelper::GetInstanceByName(
    PERF_DATA_BLOCK *pDataBlock,
    PERF_OBJECT_TYPE *pObjectDef,
    LPWSTR pInstanceName,
    LPWSTR pParentName,
    DWORD   dwIndex
)
{
    PERF_OBJECT_TYPE *pParentObj;

    PERF_INSTANCE_DEFINITION *pParentInst;
    PERF_INSTANCE_DEFINITION *pInstanceDef;
    PERF_INSTANCE_DEFINITION *pReturnDef = NULL;
    PERF_INSTANCE_DEFINITION *pEndOfBuffer = NULL;

    LONG  NumInstance;
    DWORD  dwLocalIndex;
    DWORD   dwInstanceNameLength;

    pInstanceDef = FirstInstance(pObjectDef);
    if (pInstanceDef != NULL) {
        dwLocalIndex = dwIndex;
        dwInstanceNameLength = lstrlenW(pInstanceName);
        pEndOfBuffer = (PERF_INSTANCE_DEFINITION *)EndOfObject(pObjectDef);

        for ( NumInstance = 0;
            NumInstance < pObjectDef->NumInstances;
            NumInstance++ ) {
            if (IsMatchingInstance (pInstanceDef, pObjectDef->CodePage,
                pInstanceName, dwInstanceNameLength)) {

                // Instance name matches
                if ( !pInstanceDef->ParentObjectTitleIndex ) {
                    // No parent, we're done
                    if (dwLocalIndex == 0) {
                        pReturnDef = pInstanceDef;
                        break;
                    } else {
                        --dwLocalIndex;
                    }
                } else {
                    // Must match parent as well
                    pParentObj = GetObjectDefByTitleIndex(
                                    pDataBlock,
                                    pInstanceDef->ParentObjectTitleIndex);

                    if (pParentObj != NULL) {
                        // Object type of parent found; now find parent
                        // instance

                        pParentInst = GetInstance(pParentObj,
                                        pInstanceDef->ParentObjectInstance);

                        if (pParentInst != NULL) {
                            if (IsMatchingInstance (pParentInst,
                                    pParentObj->CodePage, pParentName, 0)) {
                            // Parent Instance Name matches that passed in

                                if (dwLocalIndex == 0) {
                                    pReturnDef = pInstanceDef;
                                    break;
                                } else {
                                    --dwLocalIndex;
                                }
                            }
                        }
                    } else {
                        // keep trying
                    }
                }
            }
            // go to next instance in object and check for buffer overrun
            pInstanceDef = NextInstance(pInstanceDef);
            if (pInstanceDef >= pEndOfBuffer) {
                // something doesn't add up so bail out and return NULL
                break;
            }
        }
    }
    return pReturnDef;
}  // GetInstanceByName

DWORD
PerfHelper::GetFullInstanceNameStr (
    PERF_DATA_BLOCK             *pPerfData,
    PERF_OBJECT_TYPE            *pObjectDef,
    PERF_INSTANCE_DEFINITION    *pInstanceDef,
    LPWSTR                      szInstanceName
)
// compile instance name.
// the instance name can either be just
// the instance name itself or it can be
// the concatenation of the parent instance,
// a delimiting char (backslash) followed by
// the instance name
{

    WCHAR               szInstanceNameString[1024];
    WCHAR               szParentNameString[1024];

    DWORD                       dwLength = 0;
    PERF_OBJECT_TYPE            *pParentObjectDef;
    PERF_INSTANCE_DEFINITION    *pParentInstanceDef;

    szInstanceNameString[0] = UNICODE_NULL;
    szParentNameString[0] = UNICODE_NULL;
    if (pInstanceDef->UniqueID == PERF_NO_UNIQUE_ID) {
        dwLength = GetInstanceNameStr (pInstanceDef,
            szInstanceNameString,
            pObjectDef->CodePage);
    } else {
        // make a string out of the unique ID
        _ltow (pInstanceDef->UniqueID, szInstanceNameString, 10);
        dwLength = lstrlenW (szInstanceNameString);
    }

    if (pInstanceDef->ParentObjectTitleIndex > 0) {
        // then add in parent instance name
        pParentObjectDef = GetObjectDefByTitleIndex (
            pPerfData,
            pInstanceDef->ParentObjectTitleIndex);

        if (pParentObjectDef != NULL) {
            pParentInstanceDef = GetInstance (
                pParentObjectDef,
                pInstanceDef->ParentObjectInstance);
            assert ((UINT_PTR)pParentObjectDef != (DWORD)0xFFFFFFFF);
            if (pParentInstanceDef != NULL) {
                if (pParentInstanceDef->UniqueID == PERF_NO_UNIQUE_ID) {
                    dwLength += GetInstanceNameStr (pParentInstanceDef,
                        szParentNameString,
                        pParentObjectDef->CodePage);
                } else {
                    // make a string out of the unique ID
                    _ltow (pParentInstanceDef->UniqueID, szParentNameString, 10);
                    dwLength += lstrlenW (szParentNameString);
                }

                lstrcatW (szParentNameString, cszSlash);
                dwLength += 1;
                lstrcatW (szParentNameString, szInstanceNameString);
                lstrcpyW (szInstanceName, szParentNameString);
            } else {
                lstrcpyW (szInstanceName, szInstanceNameString);
            }
        } else {
            lstrcpyW (szInstanceName, szInstanceNameString);
        }
    } else {
        lstrcpyW (szInstanceName, szInstanceNameString);
    }

    return dwLength;

}

//***************************************************************************
//
//  PerfHelper::GetInstances
//
//  This is called to retrieve all instances of a given class.
//
//  Parameters:
//  <pBuf>          The perf blob retrieved from HKEY_PERFORMANCE_DATA.
//  <pClassMap>     A map object of the class required.
//  <pSink>         The sink to which to deliver the objects.
//
//***************************************************************************
//
void PerfHelper::GetInstances(
    LPBYTE pBuf,
    CClassMapInfo *pClassMap,
    IWbemObjectSink *pSink
    )
{
    PPERF_OBJECT_TYPE           PerfObj = 0;
    PPERF_OBJECT_TYPE           pEndOfBuffer = 0;
    PPERF_INSTANCE_DEFINITION   PerfInst = 0;
    PPERF_INSTANCE_DEFINITION   pEndOfObject = 0;
    PPERF_COUNTER_DEFINITION    PerfCntr = 0, CurCntr = 0;
    PPERF_COUNTER_BLOCK         PtrToCntr = 0;
    PPERF_DATA_BLOCK            PerfData = (PPERF_DATA_BLOCK) pBuf;
    DWORD i, j, k;

    IWbemObjectAccess           *pNewInst = 0;
    IWbemClassObject            *pClsObj = 0;

    WCHAR                       pName[MAX_PATH];
    LONG                        lStatus = 0;
    LONG                        hPropHandle;
    LPDWORD                     pdwVal;
    ULONGLONG                   *pullVal;
    HRESULT                     hRes;
    LONG64                      llVal;

    // Get the first object type.
    // ==========================

    PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfData +
        PerfData->HeaderLength);

    if (PerfObj != NULL) {
        // get end of buffer
        pEndOfBuffer = (PPERF_OBJECT_TYPE)
                        ((DWORD_PTR)PerfData +
                            PerfData->TotalByteLength);

        // Process all objects.
        // ====================

        for (i = 0; i < PerfData->NumObjectTypes; i++ ) {
            // Within each PERF_OBJECT_TYPE is a series of
            // PERF_COUNTER_DEFINITION blocks.
            // ==========================================

            PerfCntr = (PPERF_COUNTER_DEFINITION) ((PBYTE)PerfObj +
                PerfObj->HeaderLength);

            // If the current object isn't of the class we requested,
            // simply skip over it.  I am not sure if this can really
            // happen or not in practice.
            // ======================================================

            if (PerfObj->ObjectNameTitleIndex != pClassMap->m_dwObjectId) {
                PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfObj +
                    PerfObj->TotalByteLength);
                continue;
            }

            if (PerfObj->NumInstances > 0) {
                // Get the first instance.
                // =======================

                PerfInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)PerfObj +
                    PerfObj->DefinitionLength);
                
                if (PerfInst < (PPERF_INSTANCE_DEFINITION)pEndOfBuffer) {
                        // make sure we are still within the caller's buffer
                        // then find the end of this object

                     pEndOfObject = (PERF_INSTANCE_DEFINITION *)EndOfObject(PerfObj);

                    // Retrieve all instances.
                    // =======================

                    for (k = 0; k < DWORD(PerfObj->NumInstances); k++ ) 
					{
                        CurCntr = PerfCntr;
						pClsObj  = NULL;
						pNewInst = NULL;
						HRESULT hr;
                        // Get the first counter.
                        // ======================

                        PtrToCntr = (PPERF_COUNTER_BLOCK)((PBYTE)PerfInst +
                            PerfInst->ByteLength);

                        // Quickly clone a new instance to send back to the user.
                        // Since SpawnInstance() returns an IWbemClassObject and
                        // we really need an IWbemObjectAccess,we have to QI
                        // after the spawn.  We need to fix this, as this number
                        // of calls is too time consuming.
                        // ======================================================

                        hr = pClassMap->m_pClassDef->SpawnInstance(0, &pClsObj);
						if (SUCCEEDED(hr))
						{
                            pClsObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pNewInst);
                            pClsObj->Release(); // We only need the IWbemObjectAccess pointer
						}
						else
						{
							break;
						}

                        // Locate the instance name.
                        // ==========================
                        lStatus = GetFullInstanceNameStr (
                            PerfData, PerfObj, PerfInst, pName);

                        // Retrieve all counters.
                        // ======================

                        for(j = 0; j < PerfObj->NumCounters; j++ ) {
                            // Find the WBEM property handle based on the counter title index.
                            // This function does a quick binary search of the class map object
                            // to find the handle that goes with this counter.
                            // ================================================================

                            hPropHandle = pClassMap->GetPropHandle(
                                CM_MAKE_PerfObjectId(CurCntr->CounterNameTitleIndex,
                                    CurCntr->CounterType));
                            if (hPropHandle == 0) {
                                continue;
                            }

                            // update value according to data type
                            if ((CurCntr->CounterType & 0x300) == 0) {
                                pdwVal = LPDWORD((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                                hRes = pNewInst->WriteDWORD(hPropHandle, *pdwVal);
                            } else if ((CurCntr->CounterType & 0x300) == 0x100){
                                pullVal = (ULONGLONG *)((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                                llVal = Assign64((PLARGE_INTEGER) pullVal);
                                hRes = pNewInst->WriteQWORD(hPropHandle, llVal);
                            } else {
                                //this shouldn't happen
                                assert (FALSE);
                            }

                            // Get next counter.
                            // =================
                            CurCntr =  (PPERF_COUNTER_DEFINITION)((PBYTE)CurCntr +
                                CurCntr->ByteLength);
                        }

                        // Write the instance 'name'
                        // =========================

                        if (pName && pClassMap->m_dwNameHandle) {
                            pNewInst->WritePropertyValue(
                                pClassMap->m_dwNameHandle,
                                (DWORD)(((DWORD)(wcslen(pName)) + 1) * 2),
                                LPBYTE(pName)
                                );
                        }

                        // update the timestamp
                        if (pClassMap->m_dwPerfTimeStampHandle) {
                            UpdateTimers(pClassMap, pNewInst, PerfData, PerfObj);
                        }

                        // Deliver the instance to the user.
                        // =================================
                        pSink->Indicate(1, (IWbemClassObject **) &pNewInst);
                        pNewInst->Release();

                        // Move to the next perf instance.
                        // ================================
                        PerfInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)PtrToCntr +
                            PtrToCntr->ByteLength);
                        if (PerfInst >= pEndOfObject) {
                            // something doesn't add up so bail out of this object
                            break;
                        }
                    }
                }
            } 
			else if (PerfObj->NumInstances == PERF_NO_INSTANCES) 
			{
				HRESULT hr;
				pClsObj = NULL;
				pNewInst = NULL;
                // Cases where the counters have one and only one instance.
                // ========================================================

                // Get the first counter.
                // ======================

                PtrToCntr = (PPERF_COUNTER_BLOCK) ((PBYTE)PerfObj +
                    PerfObj->DefinitionLength );

                // Quickly clone a new instance to send back to the user.
                // Since SpawnInstance() returns an IWbemClassObject and
                // we really need an IWbemObjectAccess,we have to QI
                // after the spawn.  We need to fix this, as this number
                // of calls is too time consuming.
                // ======================================================

                hr = pClassMap->m_pClassDef->SpawnInstance(0, &pClsObj);
				if (SUCCEEDED(hr))
				{
                    pClsObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pNewInst);
                    pClsObj->Release();

					// Retrieve all counters.
					// ======================

					for( j=0; j < PerfObj->NumCounters; j++ ) {
						// Find the WBEM property handle based on the counter title index.
						// This function does a quick binary search of the class map object
						// to find the handle that goes with this counter.
						// ================================================================

						hPropHandle = pClassMap->GetPropHandle(
								CM_MAKE_PerfObjectId(PerfCntr->CounterNameTitleIndex,
									PerfCntr->CounterType));
						if (hPropHandle == 0) {
							continue;
						}

						if ((PerfCntr->CounterType & 0x300) == 0) {
							pdwVal = LPDWORD((LPVOID)((PBYTE)PtrToCntr + PerfCntr->CounterOffset));
							hRes = pNewInst->WriteDWORD(hPropHandle, *pdwVal);
						} else if ((PerfCntr->CounterType & 0x300) == 0x100) {
							pullVal = (ULONGLONG *)((LPVOID)((PBYTE)PtrToCntr + PerfCntr->CounterOffset));
							llVal = Assign64((PLARGE_INTEGER) pullVal);
							hRes = pNewInst->WriteQWORD(hPropHandle, llVal);
						} else {
							// this shouldn't happen
							assert (FALSE);
						}

						PerfCntr = (PPERF_COUNTER_DEFINITION)((PBYTE)PerfCntr +
							   PerfCntr->ByteLength);
					}

                                        // update the timestamp
                                        if (pClassMap->m_dwPerfTimeStampHandle) {
                                            UpdateTimers(pClassMap, pNewInst, PerfData, PerfObj);
                                        }

					pSink->Indicate(1, (IWbemClassObject **) &pNewInst);
					pNewInst->Release();
				}

            } else {
                // this object can have instances, but currently doesn't
                // so there's nothing to report
            }

            // Get the next object type.
            // =========================

            PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfObj +
                PerfObj->TotalByteLength);

            if (PerfObj >= pEndOfBuffer) {
                // looks like we ran off the end of the data buffer
                break;
            } 
        }
    }
}

void PerfHelper::RefreshEnumeratorInstances (
    IN  RefresherCacheEl            *pThisCacheEl, 
    IN  PPERF_DATA_BLOCK            PerfData,
    IN  PPERF_OBJECT_TYPE           PerfObj
)
{
    LONG    lNumObjInstances;
    LONG    lStatus;
    HRESULT hRes;

    PPERF_INSTANCE_DEFINITION   PerfInst = 0;
    PPERF_INSTANCE_DEFINITION   pEndOfObject = 0;
    PPERF_COUNTER_DEFINITION    PerfCntr = 0, CurCntr = 0;
    PPERF_COUNTER_BLOCK         PtrToCntr = 0;
    WCHAR                       pName[MAX_PATH];

    LONG                        hPropHandle;
    LPDWORD                     pdwVal;
    ULONGLONG                   *pullVal;
    LONG64                      llVal;

    IWbemObjectAccess           *pNewInst = 0;

    assert (PerfObj != NULL);
    assert (pThisCacheEl != NULL);

    if (pThisCacheEl == NULL)
        return;

    // make sure we have enough pointers 
    // handle the singleton object case
    if (PerfObj->NumInstances == PERF_NO_INSTANCES) {
        lNumObjInstances = 1;
    } else {
        lNumObjInstances = PerfObj->NumInstances;
    }

    if (pThisCacheEl->m_aEnumInstances.Size() < lNumObjInstances) {
        LONG    i;
        // alloc and init the ID array
        if (pThisCacheEl->m_plIds != NULL) {
            delete (pThisCacheEl->m_plIds);
        }
    
        pThisCacheEl->m_lEnumArraySize = lNumObjInstances;
        pThisCacheEl->m_plIds = new LONG[lNumObjInstances];
        
        if (pThisCacheEl->m_plIds == NULL)
            return;

        for (i = 0; i < lNumObjInstances; i++) pThisCacheEl->m_plIds[i] = i;
        
        // add the new IWbemObjectAccess pointers
        for (i = pThisCacheEl->m_aEnumInstances.Size(); 
            i < PerfObj->NumInstances;
            i++) 
		{
            IWbemClassObject *  pClsObj  = NULL;
            IWbemObjectAccess * pNewInst = NULL;
			HRESULT hr;
            
            hr = pThisCacheEl->m_pClassMap->m_pClassDef->SpawnInstance(0, &pClsObj);
			if (SUCCEEDED(hr))
			{
				pClsObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pNewInst);
				pClsObj->Release(); // We only need the IWbemObjectAccess pointer
            
				pThisCacheEl->m_aEnumInstances.Add (pNewInst);
			}
        }
    }
    assert (pThisCacheEl->m_aEnumInstances.Size() >= lNumObjInstances);

    // release enumerator items to prepare a new batch

    hRes = pThisCacheEl->m_pHiPerfEnum->RemoveAll(0);
    assert (hRes == S_OK);

    // update new instance list

    if (PerfObj->NumInstances == PERF_NO_INSTANCES) {
        //handle the singleton case

    } else if (PerfObj->NumInstances > 0) {
        // Get the first instance.
        // =======================

        PerfInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)PerfObj +
            PerfObj->DefinitionLength);

        // get pointer to the end of this object buffer
        pEndOfObject = (PERF_INSTANCE_DEFINITION *)EndOfObject(PerfObj);

        // point to the first counter definition in the object
        PerfCntr = (PPERF_COUNTER_DEFINITION) ((PBYTE)PerfObj +
            PerfObj->HeaderLength);

        // Retrieve all instances.
        // =======================

        for (LONG k = 0; k < PerfObj->NumInstances; k++ ) {
            CurCntr = PerfCntr;
            // Get the first counter.
            // ======================

            PtrToCntr = (PPERF_COUNTER_BLOCK)((PBYTE)PerfInst +
                PerfInst->ByteLength);

            // get the IWbemObjectAccess pointer from our 
            // cached array of pointers

            pNewInst = (IWbemObjectAccess *)(pThisCacheEl->m_aEnumInstances.GetAt(k));

            // Locate the instance name.
            // ==========================
            lStatus = GetFullInstanceNameStr (
                PerfData, PerfObj, PerfInst, pName);

            // Retrieve all counters.
            // ======================

            for(DWORD j = 0; j < PerfObj->NumCounters; j++ ) {
                // Find the WBEM property handle based on the counter title index.
                // This function does a quick binary search of the class map object
                // to find the handle that goes with this counter.
                // ================================================================

                hPropHandle = pThisCacheEl->m_pClassMap->GetPropHandle(
                    CM_MAKE_PerfObjectId(CurCntr->CounterNameTitleIndex,
                        CurCntr->CounterType));
                if (hPropHandle == 0) {
                    continue;
                }

                // update value according to data type
                if ((CurCntr->CounterType & 0x300) == 0) {
                    pdwVal = LPDWORD((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                    hRes = pNewInst->WriteDWORD(hPropHandle, *pdwVal);
                } else if ((CurCntr->CounterType & 0x300) == 0x100){
                    pullVal = (ULONGLONG *)((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                    llVal = Assign64((PLARGE_INTEGER) pullVal);
                    hRes = pNewInst->WriteQWORD(hPropHandle, llVal);
                } else {
                    //this shouldn't happen
                    assert (FALSE);
                }

                // Get next counter.
                // =================
                CurCntr =  (PPERF_COUNTER_DEFINITION)((PBYTE)CurCntr +
                    CurCntr->ByteLength);
            }

            // Write the instance 'name'
            // =========================

            if (pName && pThisCacheEl->m_pClassMap->m_dwNameHandle) {
                pNewInst->WritePropertyValue(
                    pThisCacheEl->m_pClassMap->m_dwNameHandle,
                    (DWORD)(((DWORD)(wcslen(pName)) + 1) * 2),
                    LPBYTE(pName)
                    );
            }

            // update the timestamp
            if (pThisCacheEl->m_pClassMap->m_dwPerfTimeStampHandle) {
                UpdateTimers(pThisCacheEl->m_pClassMap, pNewInst, PerfData, PerfObj);
            }

            // Move to the next perf instance.
            // ================================
            PerfInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)PtrToCntr +
                PtrToCntr->ByteLength);

            if (PerfInst >= pEndOfObject) {
                // something doesn't add up so bail out of this object
                break;
            }

        }
    } else {
        // no instances so there's nothing to do
    }

    if (lNumObjInstances > 0) {
        // update the hiperf enumerator object
        hRes = pThisCacheEl->m_pHiPerfEnum->AddObjects( 
                0,
                lNumObjInstances,
                pThisCacheEl->m_plIds,
                (IWbemObjectAccess __RPC_FAR *__RPC_FAR *)pThisCacheEl->m_aEnumInstances.GetArrayPtr());
    } else {
        // nothing to do since we've already cleared the enumerator above
    }

    return;
}

//***************************************************************************
//
//  PerfHelper::RefreshInstances
//
//  searches the refresher's list first then
//  looks up the corresponding items in the perf data structure
//
//***************************************************************************
//
void PerfHelper::RefreshInstances(
    LPBYTE pBuf,
    CNt5Refresher *pRef
)
{
    PPERF_OBJECT_TYPE           PerfObj = 0;
    PPERF_INSTANCE_DEFINITION   PerfInst = 0;
    PPERF_COUNTER_DEFINITION    PerfCntr = 0, CurCntr = 0;
    PPERF_COUNTER_BLOCK         PtrToCntr = 0;
    PPERF_DATA_BLOCK            PerfData = (PPERF_DATA_BLOCK) pBuf;

    // for each refreshable object
    PRefresherCacheEl           pThisCacheEl;
    DWORD                       dwNumCacheEntries = pRef->m_aCache.Size();
    DWORD                       dwThisCacheEntryIndex = 0;
    DWORD                       dwThisCounter;
    DWORD                       dwThisInstanceIndex = 0;
    DWORD                       dwNumInstancesInCache = 0;
    IWbemObjectAccess           *pInst = 0;
    LONG                        hPropHandle;
    LPDWORD                     pdwVal;
    HRESULT                     hRes;
    ULONGLONG                   *pullVal;
    LONG64                      llVal;


    while (dwThisCacheEntryIndex < dwNumCacheEntries) {
        // get this entry from the cache
        pThisCacheEl = (PRefresherCacheEl) pRef->m_aCache[dwThisCacheEntryIndex];
        // get class map from this entry
        CClassMapInfo *pClassMap = pThisCacheEl->m_pClassMap;
        // get perf object pointer from the perf data block
        PerfObj = GetObjectDefByTitleIndex (
            PerfData, pThisCacheEl->m_dwPerfObjIx);
        if (PerfObj != NULL) {
            // found the object so do each of the instances
            // loaded in this refresher
            PerfCntr = (PPERF_COUNTER_DEFINITION)
                ((PBYTE)PerfObj +
                  PerfObj->HeaderLength);

            // found so update the properties
            if (PerfObj->NumInstances > 0) {
                // see if they have an enumerator interface and refresh it if they do
                if (pThisCacheEl->m_pHiPerfEnum != NULL) {
                    // refresh enum
                    RefreshEnumeratorInstances (pThisCacheEl, PerfData, PerfObj);
                }
                //do each instance in this class
                dwThisInstanceIndex = 0;
                dwNumInstancesInCache = pThisCacheEl->m_aInstances.Size();
                while (dwThisInstanceIndex < dwNumInstancesInCache ) {
                    pInst = 0;
                    // get the pointer to this instance in the refresher
                    CachedInst *pInstInfo = PCachedInst(pThisCacheEl->m_aInstances[dwThisInstanceIndex]);
                    // get the pointer to the instance block in the current object
                    PerfInst = GetInstanceByName(
                        PerfData,
                        PerfObj,
                        pInstInfo->m_szInstanceName,
                        pInstInfo->m_szParentName,
                        pInstInfo->m_dwIndex);

                    IWbemObjectAccess *pInst = pInstInfo->m_pInst;
                    // Get the first counter.
                    // ======================
                    CurCntr = PerfCntr;

                    if (PerfInst != NULL) {
                        PtrToCntr = (PPERF_COUNTER_BLOCK)((PBYTE)PerfInst +
                            PerfInst->ByteLength);

                        // Retrieve all counters for the instance if it was one of the instances
                        // we are supposed to be refreshing.
                        // =====================================================================

                        for (dwThisCounter = 0; dwThisCounter < PerfObj->NumCounters; dwThisCounter++ ) {
                            hPropHandle = pClassMap->GetPropHandle(
                                CM_MAKE_PerfObjectId(CurCntr->CounterNameTitleIndex,
                                    CurCntr->CounterType));
                            if (hPropHandle == 0) {
                                continue;
                            }
                            // Data is (LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset);

                            if ((CurCntr->CounterType & 0x300) == 0) {
                                pdwVal = LPDWORD((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                                hRes = pInst->WriteDWORD(hPropHandle, *pdwVal);
                            } else if ((CurCntr->CounterType & 0x300) == 0x100) {
                                pullVal = (ULONGLONG *)((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                                llVal = Assign64((PLARGE_INTEGER) pullVal);
                                hRes = pInst->WriteQWORD(hPropHandle, llVal);
                            } else {
                                // This shouldn't happen
                                assert (FALSE);
                            }

                            // Get next counter.
                            // =================
                            CurCntr =  (PPERF_COUNTER_DEFINITION)((PBYTE)CurCntr +
                                CurCntr->ByteLength);
                        }
                        // update the timestamp
                        if (pClassMap->m_dwPerfTimeStampHandle) {
                            UpdateTimers(pClassMap, pInst, PerfData, PerfObj);
                        } // else no timestamp handle present
                    } else {
                        // then there's no data for this
                        // instance anymore so zero out the values and continue
                        for (dwThisCounter = 0; dwThisCounter < PerfObj->NumCounters; dwThisCounter++ ) {
                            hPropHandle = pClassMap->GetPropHandle(
                                CM_MAKE_PerfObjectId(CurCntr->CounterNameTitleIndex,
                                    CurCntr->CounterType));
                            if (hPropHandle == 0) {
                                continue;
                            }
                            
                            if ((CurCntr->CounterType & 0x300) == 0) {
                                hRes = pInst->WriteDWORD(hPropHandle, 0);
                            } else if ((CurCntr->CounterType & 0x300) == 0x100) {
                                hRes = pInst->WriteQWORD(hPropHandle, 0);
                            } else {
                                // This shouldn't happen
                                assert (FALSE);
                            }

                            // Get next counter.
                            // =================
                            CurCntr =  (PPERF_COUNTER_DEFINITION)((PBYTE)CurCntr +
                                CurCntr->ByteLength);
                        }

                        // update the timestamp
                        if (pClassMap->m_dwPerfTimeStampHandle) {
                            // save system timer tick
                            pInst->WriteQWORD(pClassMap->m_dwPerfTimeStampHandle , 0);
                            // use system 100 NS timer
                            pInst->WriteQWORD(pClassMap->m_dw100NsTimeStampHandle, 0);
                            // use timer from object
                            pInst->WriteQWORD(pClassMap->m_dwObjectTimeStampHandle, 0);
                        }
                    }       
                    // Get the next instance.
                    // =====================
                    dwThisInstanceIndex++;
                }
            } else if (PerfObj->NumInstances == PERF_NO_INSTANCES
                        && NULL != pThisCacheEl->m_pSingleton ) {

                // Check that the singleton instance did not get cleared
                // due to no references.

                // only a single instance so get the properties and
                // update them
                // Get the first counter.

                // Find the singleton WBEM instance which correponds to the singleton perf instance
                // along with its class def so that we have the property handles.
                //
                // Note that since the perf object index translates to a WBEM class and there
                // can only be one instance, all that is required to find the instance in the
                // refresher is the perf object title index.
                // =================================================================================

                pInst = pThisCacheEl->m_pSingleton;

                // ======================

                PtrToCntr = (PPERF_COUNTER_BLOCK) ((PBYTE)PerfObj +
                    PerfObj->DefinitionLength );

                // Retrieve all counters if the instance is one we are supposed to be refreshing.
                // ==============================================================================
                for( dwThisCounter=0;
                     dwThisCounter < PerfObj->NumCounters;
                     dwThisCounter++ ) {
                    // Get the property handle for the counter.
                    // ========================================

                    hPropHandle = pClassMap->GetPropHandle(
                        CM_MAKE_PerfObjectId(PerfCntr->CounterNameTitleIndex,
                            PerfCntr->CounterType));
                    if (hPropHandle == 0) {
                        continue;
                    }

                    // update the data values based on the datatype
                    if ((PerfCntr->CounterType & 0x300) == 0) {
                        pdwVal = LPDWORD((LPVOID)((PBYTE)PtrToCntr + PerfCntr->CounterOffset));
                        hRes = pInst->WriteDWORD(hPropHandle, *pdwVal);
                    } else if ((PerfCntr->CounterType & 0x300) == 0x100){
                        pullVal = (ULONGLONG *)((LPVOID)((PBYTE)PtrToCntr + PerfCntr->CounterOffset));
                        llVal = Assign64((PLARGE_INTEGER) pullVal);
                        hRes = pInst->WriteQWORD(hPropHandle, llVal);
                    } else {
                        // this shouldn't happen
                        assert (FALSE);
                    }

                    // get next counter definition
                    PerfCntr = (PPERF_COUNTER_DEFINITION)((PBYTE)PerfCntr +
                           PerfCntr->ByteLength);
                }
                // update the timestamp
                if (pClassMap->m_dwPerfTimeStampHandle) {
                    UpdateTimers(pClassMap, pInst, PerfData, PerfObj);
                }
            } else {
                // this object could have instances but doesn't so
                // skip
            }
        } else {
            // desired object not found in data
        }

        // Get the next refresher object
        // =========================
        dwThisCacheEntryIndex++;
    }
}

//***************************************************************************
//
//  QueryInstances
//
//  Used to send back all instances of a perf counter.  The counter
//  is specified by the <pClassMap> object, which is tightly bound to
//  a particular counter.
//
//***************************************************************************
//
BOOL PerfHelper::QueryInstances(
    CPerfObjectAccess *pPerfObj,
    CClassMapInfo *pClassMap,
    IWbemObjectSink *pSink
)
{
    DWORD   dwBufSize = 0;
    LPBYTE  pBuf = NULL;
    LONG    lStatus;
    BOOL    bReturn = FALSE;
    WCHAR   szValueNum[MAX_PATH];
    
    for (;;) {
        dwBufSize += 0x10000;   // 64K
        assert (dwBufSize< 0x100000);   // make sure we don't do this forever

        pBuf = new BYTE[dwBufSize];
        assert (pBuf != NULL);

        if (pBuf != NULL) {
            // either do a global or a costly query depending on the
            // object being queried
            if (pClassMap->GetObjectId() > 0) {
                _ultow (pClassMap->GetObjectId(), (LPWSTR)szValueNum, 10);
            } else if (pClassMap->IsCostly()) {
                lstrcpyW (szValueNum, cszCostly);
            } else {
                lstrcpyW (szValueNum, cszGlobal);
            }
            lStatus = pPerfObj->CollectData (pBuf, &dwBufSize, szValueNum);
            if (lStatus == ERROR_MORE_DATA) {
                // toss the old buffer as it's not useful
                delete pBuf;
                continue;
            } else if (lStatus == ERROR_SUCCESS) {
                bReturn = TRUE;
            }
            break;
        } else {
            // memory allocation failure
            break;
        }
    }

    if (bReturn && (pBuf != NULL)) {
        // a good buffer was returned so
        // Decode the instances and send them back.
        // ========================================

        GetInstances(pBuf, pClassMap, pSink);
    }

    // Cleanup.
    // ========
    if (pBuf != NULL) delete pBuf;

    return bReturn;
}

//***************************************************************************
//
//  RefreshInstances
//
//  Used to refresh a set of instances.
//
//***************************************************************************
//
BOOL PerfHelper::RefreshInstances(
    CNt5Refresher *pRef
)
{
    DWORD   dwBufSize = 0;
    LPBYTE  pBuf = NULL;
    LONG    lStatus;
    BOOL    bReturn = FALSE;

    for (;;) {
        dwBufSize += 0x10000;   // 64K
        assert (dwBufSize< 0x100000);   // make sure we don't do this forever

        pBuf = new BYTE[dwBufSize];
        assert (pBuf != NULL);

        if (pBuf != NULL) {
            lStatus = pRef->m_PerfObj.CollectData (pBuf, &dwBufSize);
            if (lStatus == ERROR_MORE_DATA) {
                // toss the old buffer as it's not useful
                delete pBuf;
                continue;
            } else if (lStatus == ERROR_SUCCESS) {
                bReturn = TRUE;
            }
            break;
        } else {
            // memory allocation failure
            break;
        }
    }

    if (bReturn && (pBuf != NULL)) {
        // update the instances and send them back.
        // ========================================
        RefreshInstances(pBuf, pRef);
    }
    // Cleanup.
    // ========

    if (pBuf != NULL) delete pBuf;

    return bReturn;
}

VOID
PerfHelper::UpdateTimers(
    CClassMapInfo     *pClassMap,
    IWbemObjectAccess *pInst,
    PPERF_DATA_BLOCK  PerfData,
	PPERF_OBJECT_TYPE PerfObj
    )
{
    LONG64 llVal;

    // save system timer tick
    llVal = Assign64(&PerfData->PerfTime);
    pInst->WriteQWORD(
       pClassMap->m_dwPerfTimeStampHandle ,
       llVal
       );
   // use timer from object
    llVal = Assign64(&PerfObj->PerfTime);
   pInst->WriteQWORD(
       pClassMap->m_dwObjectTimeStampHandle,
       llVal
       );
   // use system 100 NS timer
   llVal = Assign64(&PerfData->PerfTime100nSec);
   pInst->WriteQWORD(
       pClassMap->m_dw100NsTimeStampHandle,
       llVal
       );
   // save system timer freq
   llVal = Assign64(&PerfData->PerfFreq);
   pInst->WriteQWORD(
       pClassMap->m_dwPerfFrequencyHandle ,
       llVal
       );
   // use timer from object
    llVal = Assign64(&PerfObj->PerfFreq);
   pInst->WriteQWORD(
       pClassMap->m_dwObjectFrequencyHandle,
       llVal
       );
   // use system 100 NS Freq
   pInst->WriteQWORD(
       pClassMap->m_dw100NsFrequencyHandle,
       (LONGLONG)10000000);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\perfacc.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    PerfAcc.h

Abstract:

    Windows NT Perf Object Access Class Definition

--*/

#ifndef _NT_PERF_OBJECT_ACCESS_H
#define _NT_PERF_OBJECT_ACCESS_H

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <wbemidl.h>
#include <assert.h>
#include "flexarry.h"
#include "utils.h"

#if (DBG && _OUTPUT_DEBUG_STRINGS)
#define DebugPrint(x)   OutputDebugString (x)
#else
#define DebugPrint(x)
#endif

//
//      constants used by guard page testing
//
#define GUARD_PAGE_SIZE 1024
#define GUARD_PAGE_CHAR 0xA5
#define GUARD_PAGE_DWORD 0xA5A5A5A5

#define  LOG_UNDEFINED  ((LONG)-1)
#define  LOG_NONE       0
#define  LOG_USER       1
#define  LOG_DEBUG      2
#define  LOG_VERBOSE    3

#define     EXT_TEST_UNDEFINED  0
#define     EXT_TEST_ALL        1
#define     EXT_TEST_BASIC      2
#define     EXT_TEST_NONE       3
#define     EXT_TEST_NOMEMALLOC 4

// structure for passing to extensible counter open procedure wait thread

typedef struct _OPEN_PROC_WAIT_INFO {
    struct _OPEN_PROC_WAIT_INFO *pNext;
    LPWSTR  szLibraryName;
    LPWSTR  szServiceName;
    DWORD   dwWaitTime;
} OPEN_PROC_WAIT_INFO, FAR * LPOPEN_PROC_WAIT_INFO;

//#define PERFLIB_TIMING_THREAD_TIMEOUT  120000  // 2 min (in milliseconds)
#define PERFLIB_TIMING_THREAD_TIMEOUT   30000  // 30 sec (for debugging)

// timing thread handles
#define PL_TIMER_START_EVENT    0
#define PL_TIMER_EXIT_EVENT     1
#define PL_TIMER_NUM_OBJECTS    2

#define PERFLIB_TIMER_INTERVAL  500     // 500 ms Timer

__inline
LONGLONG
GetTimeAsLongLong ()
/*++
    Returns time performance timer converted to ms.

-*/
{
    LARGE_INTEGER liCount, liFreq;
    LONGLONG        llReturn;

    if (QueryPerformanceCounter (&liCount) && 
        QueryPerformanceFrequency (&liFreq)) {
        llReturn = liCount.QuadPart * 1000 / liFreq.QuadPart;
    } else {
        llReturn = 0;
    }
    return llReturn;
}

//
//  Definition of handle table for extensible objects
//
typedef PM_OPEN_PROC    *OPENPROC;
typedef PM_COLLECT_PROC *COLLECTPROC;
typedef PM_QUERY_PROC   *QUERYPROC;
typedef PM_CLOSE_PROC   *CLOSEPROC;

#define EXT_OBJ_INFO_NAME_LENGTH    32

typedef struct _ExtObject {
        LPVOID      pNext;   // not used
        HANDLE      hMutex;         // sync mutex for this function
        OPENPROC    OpenProc;       // address of the open routine
        LPSTR       szOpenProcName; // open procedure name
        LPWSTR      szLinkageString; // param for open proc
        DWORD       dwOpenTimeout;  // wait time in MS for open proc
        COLLECTPROC CollectProc;    // address of the collect routine
        QUERYPROC   QueryProc;      // address of query proc
        LPSTR       szCollectProcName;  // collect procedure name
        DWORD       dwCollectTimeout;   // wait time in MS for collect proc
        CLOSEPROC   CloseProc;     // address of the close routine
        LPSTR       szCloseProcName;    // close procedure name
        HMODULE     hLibrary ;     // handle returned by LoadLibraryW
        LPWSTR      szLibraryName;  // full path of library
        HKEY        hPerfKey;       // handle to performance sub key fo this service
        DWORD       dwNumObjects;  // number of supported objects
        DWORD       dwObjList[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];    // address of array of supported objects
        DWORD       dwFlags;        // flags
        LPWSTR      szServiceName;  // service name
        LONGLONG    llLastUsedTime; // FILETIME of last access
// Performance statistics
        LONGLONG    llElapsedTime;  // time spent in call
        DWORD       dwCollectCount; // number of times Collect successfully called
        DWORD       dwOpenCount;    // number of Loads & opens
        DWORD       dwCloseCount;   // number of Unloads & closes
        DWORD       dwLockoutCount; // count of lock timeouts
        DWORD       dwErrorCount;   // count of errors (other than timeouts)
} ExtObject, *pExtObject;

const DWORD dwExtCtrOpenProcWaitMs = 10000;

// ext object flags
#define PERF_EO_QUERY_FUNC  ((DWORD)0x00000001)     // use query proc
#define PERF_EO_BAD_DLL     ((DWORD)0x00000002)     // true when DLL ret. error
#define PERF_EO_KEEP_RESIDENT ((DWORD)0x00000004)    // true if lib should not be trimmed
#define PERF_EO_OBJ_IN_QUERY ((DWORD)0x80000000)    // true when in query list

#ifdef __cplusplus

class CPerfDataLibrary {
public:
    pExtObject  pLibInfo;
    WCHAR       szQueryString[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION * 10]; // string of objects to query
    DWORD       dwRefCount;     // number of classes referencing this object

    CPerfDataLibrary (void);
    ~CPerfDataLibrary (void);
};

class CPerfObjectAccess {
private:
    HANDLE  m_hObjectHeap;
    // list of libraries referenced
    CFlexArray  m_aLibraries;
    LONG    lEventLogLevel;
    HANDLE  hEventLog;

    DWORD   AddLibrary  (IWbemClassObject *pClass, 
                        IWbemQualifierSet *pClassQualifiers,
                        LPCWSTR szRegistryKey,
                        DWORD   dwPerfIndex);
    DWORD   OpenExtObjectLibrary (pExtObject  pObj);

    DWORD CloseLibrary (CPerfDataLibrary *pLib);

    //
    // Timer functions
    //
    HANDLE StartPerflibFunctionTimer (LPOPEN_PROC_WAIT_INFO pInfo);

    DWORD KillPerflibFunctionTimer (HANDLE  hPerflibTimer);

    DWORD DestroyPerflibFunctionTimer (void);

public:
    CPerfObjectAccess (void);
    ~CPerfObjectAccess (void);

    // used by timing thread
    HANDLE   hTimerHandles[PL_TIMER_NUM_OBJECTS];

    HANDLE  hTimerDataMutex;
    HANDLE  hPerflibTimingThread;
    LPOPEN_PROC_WAIT_INFO   pTimerItemListHead;

    DWORD   AddClass (IWbemClassObject *pClass, BOOL bCatalogQuery);
    DWORD   CollectData(LPBYTE pBuffer, LPDWORD pdwBufferSize, LPWSTR pszItemList=NULL);
    DWORD   RemoveClass(IWbemClassObject *pClass);
};

#endif // _cplusplus

#endif // _NT_PERF_OBJECT_ACCESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\perfhelp.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    perfhelp.h

Abstract:

    <abstract>

--*/

#ifndef _PERFHELP_H_
#define _PERFHELP_H_

#include <winperf.h>

__inline 
PERF_OBJECT_TYPE *
FirstObject(IN PERF_DATA_BLOCK * pPerfData)
{
    PERF_OBJECT_TYPE *  pReturn;
    LPBYTE              pEndOfBuffer;

    pReturn = (PPERF_OBJECT_TYPE)((PBYTE)(pPerfData) + (pPerfData)->HeaderLength);
    pEndOfBuffer = (LPBYTE)((LPBYTE)pPerfData + pPerfData->TotalByteLength);

    if ((LPBYTE)pReturn >= pEndOfBuffer) pReturn = NULL;

    return (pReturn);
}

#define NextObject(pObject) \
    (PPERF_OBJECT_TYPE)((pObject)->TotalByteLength != 0 ? (PPERF_OBJECT_TYPE)((PBYTE)(pObject) + (pObject)->TotalByteLength) : NULL)

#define FirstInstance(pObjectDef) \
    (PERF_INSTANCE_DEFINITION *)((PCHAR) pObjectDef + pObjectDef->DefinitionLength)

// the return of this macro must be cast to the correct type of pointer by the caller
#define EndOfObject(pObjectDef) \
    ((PCHAR) pObjectDef + pObjectDef->TotalByteLength)

__inline
PERF_INSTANCE_DEFINITION *
NextInstance(
    IN  PERF_INSTANCE_DEFINITION *pInstDef
)
{
    PERF_COUNTER_BLOCK *pCounterBlock;
    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstDef + pInstDef->ByteLength);
    return (PERF_INSTANCE_DEFINITION *)
               ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}

#define PERF_TIMER_TYPE_FIELD	\
	(PERF_TIMER_TICK | PERF_TIMER_100NS | PERF_OBJECT_TIMER)

class PerfHelper
{
    static void GetInstances(
        LPBYTE pBuf,
        CClassMapInfo *pClassMap,
        IWbemObjectSink *pSink
        );

    static void RefreshInstances(
        LPBYTE pBuf,
        CNt5Refresher *pRef
        );

	static PERF_INSTANCE_DEFINITION * GetInstanceByName(
		PERF_DATA_BLOCK *pDataBlock,
		PERF_OBJECT_TYPE *pObjectDef,
		LPWSTR pInstanceName,
		LPWSTR pParentName,
		DWORD   dwIndex);

	static PERF_INSTANCE_DEFINITION * GetInstanceByNameUsingParentTitleIndex(
		PERF_DATA_BLOCK *pDataBlock,
		PERF_OBJECT_TYPE *pObjectDef,
		LPWSTR pInstanceName,
		LPWSTR pParentName,
		DWORD  dwIndex);

	static DWORD GetInstanceNameStr (
		PPERF_INSTANCE_DEFINITION pInstance,
        LPWSTR lpszInstance,
        DWORD dwCodePage);

	static DWORD GetUnicodeInstanceName (
		PPERF_INSTANCE_DEFINITION pInstance,
        LPWSTR lpszInstance);

	static 	LPWSTR GetInstanceName(PPERF_INSTANCE_DEFINITION  pInstDef)
		{
			return (LPWSTR) ((PCHAR) pInstDef + pInstDef->NameOffset);
		}

	static DWORD GetAnsiInstanceName (
		PPERF_INSTANCE_DEFINITION pInstance,
        LPWSTR lpszInstance,
        DWORD dwCodePage);

	static PERF_INSTANCE_DEFINITION * GetInstanceByUniqueId (
		PERF_OBJECT_TYPE *pObjectDef,
		LONG InstanceUniqueId);

	static PERF_INSTANCE_DEFINITION * GetInstance(
		PERF_OBJECT_TYPE *pObjectDef,
		LONG InstanceNumber);

	static PERF_OBJECT_TYPE * GetObjectDefByName (
		PERF_DATA_BLOCK *pDataBlock,
		DWORD           dwLastNameIndex,
		LPCWSTR         *NameArray,
		LPCWSTR         szObjectName);

	static PERF_OBJECT_TYPE * GetObjectDefByTitleIndex (
		PERF_DATA_BLOCK *pDataBlock,
		DWORD ObjectTypeTitleIndex);

	static BOOL PerfHelper::IsMatchingInstance (
			PERF_INSTANCE_DEFINITION	*pInstanceDef, 
			DWORD						dwCodePage,
			LPWSTR						szInstanceNameToMatch,
			DWORD						dwInstanceNameLength);

	static void RefreshEnumeratorInstances (
		IN	RefresherCacheEl            *pThisCacheEl, 
		IN	PERF_DATA_BLOCK				*PerfData,
		IN  PERF_OBJECT_TYPE			*PerfObj);
public:
	static BOOL ParseInstanceName (
		LPCWSTR szInstanceString,
		LPWSTR  szInstanceName,
		LPWSTR  szParentName,
		LPDWORD lpIndex);

	static DWORD GetFullInstanceNameStr (
		PERF_DATA_BLOCK             *pPerfData,
		PERF_OBJECT_TYPE            *pObjectDef,
		PERF_INSTANCE_DEFINITION    *pInstanceDef,
		LPWSTR                      szInstanceName);

    static BOOL QueryInstances(
		CPerfObjectAccess *pPerfObj,
        CClassMapInfo *pClassMap,
        IWbemObjectSink *pSink
        );

    static BOOL RefreshInstances(
        CNt5Refresher *pRef
        );

    static VOID UpdateTimers(
        CClassMapInfo     *pClassMap,
        IWbemObjectAccess *pInst,
        PPERF_DATA_BLOCK  PerfData,
		PPERF_OBJECT_TYPE  PerfObj
        );
};

__inline
LONG64
Assign64(
    IN PLARGE_INTEGER Unaligned
    )
{
    PLARGE_INTEGER pAligned;
    LONG64 llVal;

    pAligned = (PLARGE_INTEGER) &llVal;
    pAligned->LowPart = Unaligned->LowPart;
    pAligned->HighPart = Unaligned->HighPart;
    return llVal;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\refreshr.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    refreshr.h

Abstract:

    <abstract>

--*/

#ifndef _REFRESHR_H_
#define _REFRESHR_H_

#include "ntperf.h"
#include "perfacc.h"
#include "utils.h"

//***************************************************************************
//
//***************************************************************************

struct CachedInst
{
    LPWSTR              m_pName;         // Full Instance name
    IWbemObjectAccess   *m_pInst;         // Pointer to WBEM object
    LONG                m_lId;           // ID for this object
    LPWSTR              m_szParentName; // parsed parent name from full name
    LPWSTR              m_szInstanceName; // parsed instance name from full name
    DWORD               m_dwIndex;      // index parsed from full instance name
                
    CachedInst() {  m_pName = 0; 
                    m_pInst = 0; 
                    m_lId = 0;  
                    m_szParentName = 0; 
                    m_szInstanceName = 0; 
                    m_dwIndex = 0;
                }
    ~CachedInst() { if (m_pInst) m_pInst->Release(); 
                    if (m_pName) delete (m_pName);
                    if (m_szParentName) delete (m_szParentName);
                    if (m_szInstanceName) delete (m_szInstanceName);
                    }
};
  
typedef CachedInst *PCachedInst;

//***************************************************************************
//
//  RefresherCacheEl
//
//  Each CNt5Refresher has a cache of <RefresherCacheEl> elements.  There
//  is one RefresherCacheEl struct for each class of object in the refresher.
//
//  As each object is added to the refresher, we locate the corresponding
//  <RefresherCacheEl> for the class of the object.  We then add the
//  instance into the instance cache of the <RefresherCacheEl>. If there
//  is no RefresherCacheEl, we create one.
//
//  For singleton instances, we simply special case by having a dedicated
//  pointer.
//
//  For multi-instance counters, we use a binary search lookup.
//  
//***************************************************************************
// ok
struct RefresherCacheEl
{
    DWORD              m_dwPerfObjIx;       // Perf object index for Class Def
    CClassMapInfo     *m_pClassMap;         // WBEM Class def stuff
    IWbemObjectAccess *m_pSingleton;        // Optional Singleton instance
    LONG               m_lSingletonId;
    CFlexArray         m_aInstances;        // Instance list for non-singleton
                                            // of CachedInst pointers.
    CFlexArray         m_aEnumInstances;    // array of IWbemObjectAccess pointers
    LONG               *m_plIds;            // array of ID's
    LONG               m_lEnumArraySize;    // size of enum item array in elements
    IWbemHiPerfEnum    *m_pHiPerfEnum;      // interface for hi perf enumerator
    LONG               m_lEnumId;           // id of the enumerator

    RefresherCacheEl();
   ~RefresherCacheEl(); 
   
    IWbemObjectAccess *FindInst(LPWSTR pszName);  // Already scoped by class
    BOOL RemoveInst(LONG lId);
    BOOL InsertInst(IWbemObjectAccess **pp, LONG lNewId);
    // support for enumerator objects
    BOOL CreateEnum(IWbemHiPerfEnum *p, LONG lNewId);
    BOOL DeleteEnum(LONG lId);   
};

typedef RefresherCacheEl *PRefresherCacheEl;


// used by flags arg of AddObject Method
#define REFRESHER_ADD_OBJECT_ADD_ITEM   ((DWORD)0)
#define REFRESHER_ADD_OBJECT_ADD_ENUM   ((DWORD)0x00000001)

class CNt5Refresher : public IWbemRefresher
{
    HANDLE              m_hAccessMutex;
    LONG                m_lRef;
    LONG                m_lProbableId;
    CFlexArray          m_aCache;   
    CNt5PerfProvider    *m_pPerfProvider; // back pointer to provider if used

    DWORD       m_dwGetGetNextClassIndex;

    CNt5PerfProvider::enumCLSID m_ClsidType;

    friend  PerfHelper;
public:
    CNt5Refresher(CNt5PerfProvider *pPerfProvider = NULL);
   ~CNt5Refresher();

    CPerfObjectAccess   m_PerfObj;

    // Interface members.
    // ==================

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);

    // Primary WBEM method for updating.
    // =================================
    virtual HRESULT STDMETHODCALLTYPE Refresh(/* [in] */ long lFlags);

    // Private members used by NTPERF.CPP
    // ==================================
    
    BOOL AddObject(
        IN  IWbemObjectAccess **ppObj,    // Object to add
        IN  CClassMapInfo *pClsMap,     // Class of object
        OUT LONG *plId                  // The id of the object added
        );

    BOOL RemoveObject(LONG lId);

    BOOL AddEnum (
        IN  IWbemHiPerfEnum *pEnum,     // enum interface pointer
        IN  CClassMapInfo *pClsMap,     // Class of object
        OUT LONG    *plId               // id for new enum
        );

    CClassMapInfo * FindClassMap(
        DWORD dwObjectTitleIx
        );

    BOOL FindSingletonInst(
        IN  DWORD dwPerfObjIx,
        OUT IWbemObjectAccess **pInst,
        OUT CClassMapInfo **pClsMap
        );

    BOOL FindInst(
        IN  DWORD dwObjectClassIx,
        IN  LPWSTR pszInstName,
        OUT IWbemObjectAccess **pInst,
        OUT CClassMapInfo **pClsMap
        );

    BOOL GetObjectIds(DWORD *pdwNumIds, DWORD **pdwIdList); 
        // Use operator delete on returned <pdwIdList>

    LONG FindUnusedId();
        // Returns -1 on error or an unused id.

    PRefresherCacheEl GetCacheEl(CClassMapInfo *pClsMap);


    BOOL AddNewCacheEl(
        IN CClassMapInfo *pClsMap, 
        PRefresherCacheEl *pOutput
        );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\perfacc.cpp ===
//***************************************************************************
//
//  (c) 1998-1999 by Microsoft Corp.
//
//  PerfAcc.CPP
//  
//  Windows NT Performance Data Access helper functions
//
//  bobw         8-Jub-98   Created for use with NT Perf counters
//
//***************************************************************************
//
#include "wpheader.h"
#include <stdlib.h>
#include "oahelp.inl"
#include <malloc.h>

// NOTE: Consider reading this from the registry
LONG    lExtCounterTestLevel = EXT_TEST_ALL;



//
//
// precompiled security descriptor
// System and NetworkService has full access
//
// since this is RELATIVE, it will work on both IA32 and IA64
//
DWORD g_PrecSD[] = {
  0x80040001 , 0x00000044 , 0x00000050 , 0x00000000  ,
  0x00000014 , 0x00300002 , 0x00000002 , 0x00140000  ,
  0x001f0001 , 0x00000101 , 0x05000000 , 0x00000012  ,
  0x00140000 , 0x001f0001 , 0x00000101 , 0x05000000  ,
  0x00000014 , 0x00000101 , 0x05000000 , 0x00000014  ,
  0x00000101 , 0x05000000 , 0x00000014 
};

DWORD g_SizeSD = 0;

DWORD g_RuntimeSD[(sizeof(ACL)+sizeof(ACCESS_ALLOWED_ACE)+sizeof(SECURITY_DESCRIPTOR_RELATIVE)+4*(sizeof(SID)+SID_MAX_SUB_AUTHORITIES*sizeof(DWORD)))/sizeof(DWORD)];

typedef 
BOOLEAN ( * fnRtlValidRelativeSecurityDescriptor)(
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );

fnRtlValidRelativeSecurityDescriptor RtlValidRelativeSecurityDescriptor;

//
//  Build a SD with owner == This
//                  group == This
//                  DACL
//                  ACE[0]  MUTEX_ALL_ACCESS Owner
//                  ACE[1]  MUTEX_ALL_ACCESS System
///////////////////////////////////////////////////////////////////

BOOL
CreateSD( )
{

	if (!RtlValidRelativeSecurityDescriptor)
	{
		HMODULE hModule = GetModuleHandleW(L"ntdll.dll");
		if (hModule)
		{
            RtlValidRelativeSecurityDescriptor = (fnRtlValidRelativeSecurityDescriptor)GetProcAddress(hModule,"RtlValidRelativeSecurityDescriptor");
			if (!RtlValidRelativeSecurityDescriptor)
			{
				return FALSE;
			}
		}
	}

    HANDLE hToken;
    BOOL bRet;
    
    bRet = OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&hToken);
    if (bRet)
    {
        TOKEN_USER * pToken_User;
        DWORD dwSize = sizeof(TOKEN_USER)+sizeof(SID)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD));
        pToken_User = (TOKEN_USER *)_alloca(dwSize);
        bRet = GetTokenInformation(hToken,TokenUser,pToken_User,dwSize,&dwSize);
        if (bRet)
        {
            SID SystemSid = { SID_REVISION,
                              1,
                              SECURITY_NT_AUTHORITY,
                              SECURITY_LOCAL_SYSTEM_RID 
                            };
        
            PSID pSIDUser = pToken_User->User.Sid;
            dwSize = GetLengthSid(pSIDUser);
            DWORD dwSids = 2; // Owner and System
            DWORD ACLLength = (ULONG) sizeof(ACL) +
                              (dwSids * ((ULONG) sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) + dwSize + sizeof(SystemSid);

            DWORD dwSizeSD = sizeof(SECURITY_DESCRIPTOR_RELATIVE) + dwSize + dwSize + ACLLength;
            SECURITY_DESCRIPTOR_RELATIVE * pLocalSD = (SECURITY_DESCRIPTOR_RELATIVE *)_alloca(dwSizeSD); 
            
            memset(pLocalSD,0,sizeof(SECURITY_DESCRIPTOR_RELATIVE));
            pLocalSD->Revision = SECURITY_DESCRIPTOR_REVISION;
            pLocalSD->Control = SE_DACL_PRESENT|SE_SELF_RELATIVE;
            
            //SetSecurityDescriptorOwner(pLocalSD,pSIDUser,FALSE);
            memcpy((BYTE*)pLocalSD+sizeof(SECURITY_DESCRIPTOR_RELATIVE),pSIDUser,dwSize);
            pLocalSD->Owner = (DWORD)sizeof(SECURITY_DESCRIPTOR_RELATIVE);
            
            //SetSecurityDescriptorGroup(pLocalSD,pSIDUser,FALSE);
            memcpy((BYTE*)pLocalSD+sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize,pSIDUser,dwSize);
            pLocalSD->Group = (DWORD)(sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize);


            PACL pDacl = (PACL)_alloca(ACLLength);

            bRet = InitializeAcl( pDacl,
                                  ACLLength,
                                  ACL_REVISION);
            if (bRet)
            {
                bRet = AddAccessAllowedAceEx (pDacl,ACL_REVISION,0,MUTEX_ALL_ACCESS,&SystemSid);
                if (bRet)
                {
                    bRet = AddAccessAllowedAceEx (pDacl,ACL_REVISION,0,MUTEX_ALL_ACCESS,pSIDUser);
	                
	                if (bRet)
	                {
	                    //bRet = SetSecurityDescriptorDacl(pLocalSD,TRUE,pDacl,FALSE);
		                memcpy((BYTE*)pLocalSD+sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize+dwSize,pDacl,ACLLength);	                
		                pLocalSD->Dacl = (DWORD)(sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize+dwSize);

						if (RtlValidRelativeSecurityDescriptor(pLocalSD,
							                               dwSizeSD,
							                               OWNER_SECURITY_INFORMATION|
														   GROUP_SECURITY_INFORMATION|
														   DACL_SECURITY_INFORMATION))
						{
		                    g_SizeSD = dwSizeSD;
		                    memcpy(g_RuntimeSD,pLocalSD,dwSizeSD);
						}
						else
						{
							bRet = FALSE;
						}
	                }
                }
            }
        }
        
        CloseHandle(hToken);
    }

    return bRet;
};

//***************************************************************************
//
//  HANDLE CreateMutexAsProcess(LPCWSTR pwszName)
//
//  This function will create a mutex using the process' security context
//
//***************************************************************************
//
HANDLE CreateMutexAsProcess(LPCWSTR pwszName)
{
	BOOL bImpersonating = FALSE;

	HANDLE hThreadToken = NULL;

	// Determine if we are impersonating

	bImpersonating = OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE, TRUE,
		&hThreadToken);
    
	if(bImpersonating)
	{
		// Determine if we are impersonating
		
		bImpersonating = RevertToSelf();
	}

    // Create the mutex as using the process token.



	HANDLE hRet = OpenMutexW(MUTEX_ALL_ACCESS,FALSE,pwszName);
	if (NULL == hRet)
	{
		SECURITY_ATTRIBUTES sa;
	
	    if (0 == g_SizeSD)
	    {
	        if (CreateSD())
	        {
	    		sa.nLength = g_SizeSD; 
		    	sa.lpSecurityDescriptor = (LPVOID)g_RuntimeSD; 
			    sa.bInheritHandle = FALSE;	        
	        }
	        else
	        {
	    		sa.nLength = sizeof(g_PrecSD);
		    	sa.lpSecurityDescriptor = (LPVOID)g_PrecSD;
			    sa.bInheritHandle = FALSE;	        
	        
	        }	         
	    }
	    else
	    {
	   		sa.nLength = g_SizeSD; 
	    	sa.lpSecurityDescriptor = (LPVOID)g_RuntimeSD; 
		    sa.bInheritHandle = FALSE;	        	    
	    }

		hRet = CreateMutexW(&sa, FALSE, pwszName);
	}

    // If code was oringinally impersonating, resume impersonation

	if(bImpersonating)
		SetThreadToken(NULL, hThreadToken);

	if(hThreadToken)
		CloseHandle(hThreadToken);

	return hRet;
}


//***************************************************************************
//
//  CPerfDataLibrary ::CPerfDataLibrary 
//
//  This object is used to abstract the perf data library
//
//***************************************************************************
//
CPerfDataLibrary::CPerfDataLibrary (void)
{
    pLibInfo = NULL;
    memset ((LPVOID)szQueryString, 0, sizeof(szQueryString));
    dwRefCount = 0;     // number of classes referencing this object
}

CPerfDataLibrary::~CPerfDataLibrary (void)
{
    // all libraries should be closed before this is
    // destructed
    assert (dwRefCount == 0);
    assert (pLibInfo == NULL);
}

//***************************************************************************
//
//  CPerfObjectAccess::CPerfObjectAccess
//
//  This object is used to abstract a data object within a perf library
//
//***************************************************************************
//
CPerfObjectAccess::CPerfObjectAccess ()
{
    m_hObjectHeap = HeapCreate(HEAP_GENERATE_EXCEPTIONS, 0x10000, 0);
    if (m_hObjectHeap == NULL) {
        // then just use the process heap
        m_hObjectHeap = GetProcessHeap();
    }

    for (DWORD n=0; n < PL_TIMER_NUM_OBJECTS; n++) {
        hTimerHandles[n] = NULL;
    }

    hTimerDataMutex = NULL;
    hPerflibTimingThread   = NULL;
    pTimerItemListHead = NULL;

    m_aLibraries.Empty();
    lEventLogLevel = LOG_UNDEFINED;
    hEventLog = NULL;
}

CPerfObjectAccess::~CPerfObjectAccess ()
{
	int	nNumLibraries;
	int	nIdx;

	CPerfDataLibrary *pThisLibrary;

    if (pTimerItemListHead != NULL) {
        DestroyPerflibFunctionTimer();
        pTimerItemListHead = NULL;
    }

    // the DestroyPerflibFunctionTimer should take care of these
    // but just in case....
    if (hTimerDataMutex != NULL) {
        CloseHandle (hTimerDataMutex);
        hTimerDataMutex = NULL;
    }

    if (hPerflibTimingThread != NULL) {
        CloseHandle (hPerflibTimingThread);
        hPerflibTimingThread = NULL;
    }

    for (DWORD n=0; n < PL_TIMER_NUM_OBJECTS; n++) {
        if (hTimerHandles[n] != NULL) {
            CloseHandle (hTimerHandles[n]);
            hTimerHandles[n] = NULL;
        }
    }

	// close any lingering libraries
	nNumLibraries = m_aLibraries.Size();
	for (nIdx = 0; nIdx < nNumLibraries; nIdx++) {
		pThisLibrary = (CPerfDataLibrary *)m_aLibraries[nIdx];
		CloseLibrary (pThisLibrary);
        FREEMEM(m_hObjectHeap, 0, pThisLibrary->pLibInfo);
		pThisLibrary->pLibInfo = NULL;
        delete pThisLibrary;
	}
    m_aLibraries.Empty();

    if ((m_hObjectHeap != NULL) && (m_hObjectHeap != GetProcessHeap())) {
        HeapDestroy (m_hObjectHeap);
    }
}

//
// Timer functions
//
DWORD
__stdcall
PerflibTimerFunction (
    LPVOID pArg
)
/*++

 PerflibTimerFunction

    Timing thread used to write an event log message if the timer expires.

    This thread runs until the Exit event is set or the wait for the
    Exit event times out.

    While the start event is set, then the timer checks the current events
    to be timed and reports on any that have expired. It then sleeps for
    the duration of the timing interval after which it checks the status
    of the start & exit events to begin the next cycle.

    The timing events are added and deleted from the list only by the
    StartPerflibFunctionTimer and KillPerflibFunctionTimer functions.

 Arguments

    pArg -- parent class object

--*/
{
    CPerfObjectAccess       *pObj = (CPerfObjectAccess *)pArg;

    LONG                    lStatus = ERROR_SUCCESS;
    BOOL                    bKeepTiming = TRUE;
    LPOPEN_PROC_WAIT_INFO   pLocalInfo;
    LPWSTR                  szMessageArray[2];
    DWORD                   dwData;

    if (lStatus == ERROR_SUCCESS) {
        while (bKeepTiming) {
            // wait for either the start or exit event flags to be set
            lStatus = WaitForMultipleObjects (
                PL_TIMER_NUM_OBJECTS,
                &pObj->hTimerHandles[0],
                FALSE,          //wait for either one to be set
                PERFLIB_TIMING_THREAD_TIMEOUT);

            if (lStatus != WAIT_TIMEOUT) {
                if ((lStatus - WAIT_OBJECT_0) == PL_TIMER_EXIT_EVENT ) {
                    // then that's all
                    bKeepTiming = FALSE;
                    break;
                } else if ((lStatus - WAIT_OBJECT_0) == PL_TIMER_START_EVENT) {
                    // then the timer is running so wait the interval period
                    // wait on exit event here to prevent hanging
                    lStatus = WaitForSingleObject (
                        pObj->hTimerHandles[PL_TIMER_EXIT_EVENT],
                        PERFLIB_TIMING_THREAD_TIMEOUT);

                    if (lStatus == WAIT_TIMEOUT) {
                        // then the wait time expired without being told
                        // to terminate the thread so
                        // now evaluate the list of timed events
                        // lock the data mutex
                        lStatus = WaitForSingleObject (
                            pObj->hTimerDataMutex,
                            (PERFLIB_TIMER_INTERVAL * 2));

                        for (pLocalInfo = pObj->pTimerItemListHead;
                            pLocalInfo != NULL;
                            pLocalInfo = pLocalInfo->pNext) {

                            if (pLocalInfo->dwWaitTime != 0) {
                                if (pLocalInfo->dwWaitTime == 1) {
                                    // then this is the last interval so log error

                                    szMessageArray[0] = pLocalInfo->szServiceName;
                                    szMessageArray[1] = pLocalInfo->szLibraryName;
                                    dwData = pLocalInfo->dwWaitTime * 1000;

                                    ReportEventW (hEventLog,
                                        EVENTLOG_WARNING_TYPE,      // error type
                                        0,                          // category (not used)
                                        (DWORD)WBEMPERF_OPEN_PROC_TIMEOUT, // event,
                                        NULL,                       // SID (not used),
                                        2,                          // number of strings
                                        sizeof(DWORD),              // sizeof raw data
                                        (LPCWSTR *)szMessageArray,  // message text array
                                        (LPBYTE)&dwData);           // raw data
                                }
                                pLocalInfo->dwWaitTime--;
                            }
                        }
                        ReleaseMutex (pObj->hTimerDataMutex);
                    } else {
                        // we've been told to exit so
                        lStatus = ERROR_SUCCESS;
                        bKeepTiming = FALSE;
                        break;
                    }
                } else {
                    // some unexpected error was returned
                    assert (FALSE);
                }
            } else {
                // the wait timed out so it's time to go
                lStatus = ERROR_SUCCESS;
                bKeepTiming = FALSE;
                break;
            }
        }
    }

    return lStatus;
}

HANDLE
CPerfObjectAccess::StartPerflibFunctionTimer (
    IN  LPOPEN_PROC_WAIT_INFO pInfo
)
/*++

    Starts a timing event by adding it to the list of timing events.
    If the timer thread is not running, then the is started as well.

    If this is the first event in the list then the Start Event is
    set indicating that the timing thread can begin processing timing
    event(s).

--*/
{
    LONG    Status = ERROR_SUCCESS;
    LPOPEN_PROC_WAIT_INFO   pLocalInfo;
    DWORD   dwLibNameLen;
    DWORD   dwBufferLength = sizeof (OPEN_PROC_WAIT_INFO);
    HANDLE  hReturn = NULL;

    if (pInfo == NULL) {
        // no required argument
        Status = ERROR_INVALID_PARAMETER;
    } else {
        // check on or create sync objects

        // allocate timing events for the timing thread
        if (hTimerHandles[PL_TIMER_START_EVENT] == NULL) {
            // create the event as NOT signaled since we're not ready to start
            hTimerHandles[PL_TIMER_START_EVENT] = CreateEvent (NULL, TRUE, FALSE, NULL);
            if (hTimerHandles[PL_TIMER_START_EVENT] == NULL) {
                Status = GetLastError();
            }
        }

        if (hTimerHandles[PL_TIMER_EXIT_EVENT] == NULL) {
            hTimerHandles[PL_TIMER_EXIT_EVENT] = CreateEvent (NULL, TRUE, FALSE, NULL);
            if (hTimerHandles[PL_TIMER_EXIT_EVENT] == NULL) {
            Status = GetLastError();
            }
        }

        // create data sync mutex if it hasn't already been created
        if (hTimerDataMutex  == NULL) {
            hTimerDataMutex = CreateMutex (NULL, FALSE, NULL);
            if (hTimerDataMutex == NULL) {
                Status = GetLastError();
            }
        }
    }

    if (Status == ERROR_SUCCESS) {
        // continue creating timer entry
        if (hPerflibTimingThread != NULL) {
            // see if the handle is valid (i.e the thread is alive)
            Status = WaitForSingleObject (hPerflibTimingThread, 0);
            if (Status == WAIT_OBJECT_0) {
                // the thread has terminated so close the handle
                CloseHandle (hPerflibTimingThread);
                hPerflibTimingThread = NULL;
                Status = ERROR_SUCCESS;
            } else if (Status == WAIT_TIMEOUT) {
                // the thread is still running so continue
                Status = ERROR_SUCCESS;
            } else {
                // some other, probably serious, error
                // so pass it on through
            }
        } else {
            // the thread has never been created yet so continue
        }

        if (hPerflibTimingThread == NULL) {
            DWORD   hThreadID;
            // create the timing thread

            assert (pTimerItemListHead == NULL);    // there should be no entries, yet

            // everything is ready for the timer thread

            hPerflibTimingThread = CreateThread (
                NULL, 0,
                (LPTHREAD_START_ROUTINE)PerflibTimerFunction,
                (LPVOID)this, 0, &hThreadID);

            assert (hPerflibTimingThread != NULL);
            if (hPerflibTimingThread == NULL) {
                Status = GetLastError();
            }
        }

        if (Status == ERROR_SUCCESS) {

            // compute the length of the required buffer;

            dwLibNameLen = (lstrlenW (pInfo->szLibraryName) + 1) * sizeof(WCHAR);
            dwBufferLength += dwLibNameLen;
            dwBufferLength += (lstrlenW (pInfo->szServiceName) + 1) * sizeof(WCHAR);
            dwBufferLength = DWORD_MULTIPLE (dwBufferLength);

            pLocalInfo = (LPOPEN_PROC_WAIT_INFO)ALLOCMEM (
                    m_hObjectHeap, HEAP_ZERO_MEMORY, dwBufferLength);

            if (pLocalInfo) {
                // copy the arg buffer to the local list

                pLocalInfo->szLibraryName = (LPWSTR)&pLocalInfo[1];
                lstrcpyW (pLocalInfo->szLibraryName, pInfo->szLibraryName);
                pLocalInfo->szServiceName = (LPWSTR)
                ((LPBYTE)pLocalInfo->szLibraryName + dwLibNameLen);
                lstrcpyW (pLocalInfo->szServiceName, pInfo->szServiceName);
                // convert wait time in milliseconds to the number of "loops"
                pLocalInfo->dwWaitTime = pInfo->dwWaitTime / PERFLIB_TIMER_INTERVAL;

                // wait for access to the data
                if (hTimerDataMutex != NULL) {
                    Status = WaitForSingleObject (
                        hTimerDataMutex,
                        (PERFLIB_TIMER_INTERVAL * 2));
                } else {
                    Status = ERROR_NOT_READY;
                }

                if (Status == WAIT_OBJECT_0) {
                    // we have access to the data so add this item to the front of the list
                    pLocalInfo->pNext = pTimerItemListHead;
                    pTimerItemListHead = pLocalInfo;
                    ReleaseMutex (hTimerDataMutex);

                    if (pLocalInfo->pNext == NULL) {
                        // then the list was empty before this call so start the timer
                        // going
                        SetEvent (hTimerHandles[PL_TIMER_START_EVENT]);
                    }

                    hReturn = (HANDLE)pLocalInfo;
                } else {
                    SetLastError (Status);
                }
            }
            else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                SetLastError (Status);
            }
        } else {
            // unable to create thread
            SetLastError (Status);
        }
    } else {
        // unable to start timer
        SetLastError (Status);
    }

    return hReturn;
}

DWORD
CPerfObjectAccess::KillPerflibFunctionTimer (
    IN  HANDLE  hPerflibTimer
)
/*++

    Terminates a timing event by removing it from the list. When the last
    item is removed from the list the Start event is reset so the timing
    thread will wait for either the next start event, exit event or it's
    timeout to expire.

--*/
{
    DWORD   Status;
    LPOPEN_PROC_WAIT_INFO   pArg = (LPOPEN_PROC_WAIT_INFO)hPerflibTimer;
    LPOPEN_PROC_WAIT_INFO   pLocalInfo;
    BOOL                    bFound = FALSE;
    DWORD   dwReturn = ERROR_SUCCESS;

    if (hTimerDataMutex == NULL) {
        dwReturn = ERROR_NOT_READY;
    } else if (pArg == NULL) {
    dwReturn = ERROR_INVALID_HANDLE;
    } else {
    // so far so good
        // wait for access to the data
        Status = WaitForSingleObject (
            hTimerDataMutex,
            (PERFLIB_TIMER_INTERVAL * 2));

        if (Status == WAIT_OBJECT_0) {
            // we have access to the list so walk down the list and remove the
            // specified item
            // see if it's the first one in the list

            if (pArg == pTimerItemListHead) {
                // then remove it
                pTimerItemListHead = pArg->pNext;
                bFound = TRUE;
            } else {
                for (pLocalInfo = pTimerItemListHead;
                    pLocalInfo != NULL;
                    pLocalInfo = pLocalInfo->pNext) {
                    if (pLocalInfo->pNext == pArg) {
                        pLocalInfo->pNext = pArg->pNext;
                        bFound = TRUE;
                        break;
                    }
                }
            }
            assert (bFound);

            if (bFound) {
                // it's out of the list so release the lock
                ReleaseMutex (hTimerDataMutex);

                if (pTimerItemListHead == NULL) {
                    // then the list is empty now so stop timing
                    // going
                    ResetEvent (hTimerHandles[PL_TIMER_START_EVENT]);
                }

                // free memory

                FREEMEM (m_hObjectHeap, 0, pArg);
                dwReturn = ERROR_SUCCESS;
            } else {
                dwReturn = ERROR_NOT_FOUND;
            }
        } else {
            dwReturn = ERROR_TIMEOUT;
        }
    }
    return dwReturn;
}

DWORD
CPerfObjectAccess::DestroyPerflibFunctionTimer (
)
/*++

    Terminates the timing thread and cancels any current timer events.

--*/
{
    LONG    Status;
    LPOPEN_PROC_WAIT_INFO   pThisItem;
    LPOPEN_PROC_WAIT_INFO   pNextItem;

    // wait for data mutex
    Status = WaitForSingleObject (
        hTimerDataMutex,
        (PERFLIB_TIMER_INTERVAL * 2));

    assert (Status != WAIT_TIMEOUT);

    // free all entries in the list

    for (pNextItem = pTimerItemListHead;
        pNextItem != NULL;) {
        pThisItem = pNextItem;
        pNextItem = pThisItem->pNext;
        FREEMEM (m_hObjectHeap, 0, pThisItem);
    }

    // set exit event
    SetEvent (hTimerHandles[PL_TIMER_EXIT_EVENT]);

    // wait for thread to terminate
    Status = WaitForSingleObject (
        hPerflibTimingThread,
        (PERFLIB_TIMER_INTERVAL * 5));

    assert (Status != WAIT_TIMEOUT);

    if (hPerflibTimingThread != NULL) {
        CloseHandle (hPerflibTimingThread);
        hPerflibTimingThread = NULL;
    }

    if (hTimerDataMutex != NULL) {
        // cloes handles and leave
        ReleaseMutex (hTimerDataMutex);
        CloseHandle (hTimerDataMutex);
        hTimerDataMutex = NULL;
    }

    if (hTimerHandles[PL_TIMER_START_EVENT] != NULL) {
        CloseHandle (hTimerHandles[PL_TIMER_START_EVENT]);
        hTimerHandles[PL_TIMER_START_EVENT] = NULL;
    }

    if (hTimerHandles[PL_TIMER_EXIT_EVENT] != NULL) {
        CloseHandle (hTimerHandles[PL_TIMER_EXIT_EVENT]);
        hTimerHandles[PL_TIMER_EXIT_EVENT] = NULL;
    }

    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  CPerfObjectAccess::CloseLibrary (CPerfDataLibrary *pLib)
//
//  removes a reference to the library that contains this object and closes
//  the library when the last reference is removed
//
//***************************************************************************
//
DWORD
CPerfObjectAccess::CloseLibrary (CPerfDataLibrary *pLib)
{
    pExtObject  pInfo;
	LONG		lStatus;

    assert (pLib != NULL);
    assert (pLib->pLibInfo != NULL);
    pInfo = pLib->pLibInfo;

    assert (pLib->dwRefCount > 0); 
    if (pLib->dwRefCount > 0)   {
        pLib->dwRefCount--;

        if (pLib->dwRefCount == 0) {
			// if there's a close proc to call, then 
			// call close procedure to close anything that may have
			// been allocated by the library
			if (pInfo->hMutex != NULL){
				lStatus = WaitForSingleObject (
					pInfo->hMutex, 
					pInfo->dwOpenTimeout);
				// BUG!!A-DCREWS: If CloseProc is uninitialized, then the condition will 
				// result in the lockoutcount being incremented
				if ((lStatus != WAIT_TIMEOUT) && 
					(pInfo->CloseProc != NULL)) {
					lStatus = (*pInfo->CloseProc) ();
					ReleaseMutex(pInfo->hMutex);
				} else {
					pInfo->dwLockoutCount++;
				}
			} else {
				lStatus = ERROR_LOCK_FAILED;
			}

            // then close everything
            if (pInfo->hMutex != NULL) {
                CloseHandle (pInfo->hMutex);
                pInfo->hMutex = NULL;
            }
            
            if (pInfo->hLibrary != NULL) {
                FreeLibrary (pInfo->hLibrary);
                pInfo->hLibrary = NULL;
            }
 
            if (pInfo->hPerfKey != NULL) {
                RegCloseKey (pInfo->hPerfKey);
                pInfo->hPerfKey = NULL;
            }
        }
    }
    return pLib->dwRefCount; // returns remaining references
}

//***************************************************************************
//
//  CPerfObjectAccess::OpenExtObjectLibrary (pExtObject  pObj)
//
//  OpenExtObjectLibrary
//
//    Opens the specified library and looks up the functions used by
//    the performance library. If the library is successfully
//    loaded and opened then the open procedure is called to initialize
//    the object.
//
//    This function expects locked and exclusive access to the object while
//    it is opening. This must be provided by the calling function.
//
//  Arguments:
//
//    pObj    -- pointer to the object information structure of the
//                perf object to close
//
//***************************************************************************
//
DWORD
CPerfObjectAccess::OpenExtObjectLibrary (pExtObject  pObj)
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwOpenEvent = 0;
    DWORD   dwType;
    DWORD   dwSize;
    DWORD   dwValue;

    // variables used for event logging
    DWORD   dwDataIndex;
    WORD    wStringIndex;
    DWORD   dwRawDataDwords[8];
    LPWSTR  szMessageArray[8];

    HANDLE  hPerflibFuncTimer = NULL;

    OPEN_PROC_WAIT_INFO opwInfo;
    UINT    nErrorMode;

    // check to see if the library has already been opened

    if (pObj->hLibrary == NULL) {
        // library isn't loaded yet, so
        // check to see if this function is enabled

        dwType = 0;
        dwSize = sizeof (dwValue);
        dwValue = 0;
        Status = RegQueryValueExW (
            pObj->hPerfKey,
            cszDisablePerformanceCounters,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);

        if ((Status == ERROR_SUCCESS) &&
            (dwType == REG_DWORD) &&
            (dwValue == 1)) {
            // then DON'T Load this library
            Status = ERROR_SERVICE_DISABLED;
        } else {
            Status = ERROR_SUCCESS;
            //  go ahead and load it
            nErrorMode = SetErrorMode (SEM_FAILCRITICALERRORS);
            // then load library & look up functions
            pObj->hLibrary = LoadLibraryExW (pObj->szLibraryName,
                NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

            if (pObj->hLibrary != NULL) {
                // lookup function names
                pObj->OpenProc = (OPENPROC)GetProcAddress(
                    pObj->hLibrary, pObj->szOpenProcName);
                if (pObj->OpenProc == NULL) {
                    if (lEventLogLevel >= LOG_USER) {
                        Status = GetLastError();
                        // load data for eventlog message
                        dwDataIndex = wStringIndex = 0;
                        dwRawDataDwords[dwDataIndex++] =
                            (DWORD)Status;
                        szMessageArray[wStringIndex++] =
                            ConvertProcName(pObj->szOpenProcName);
                        szMessageArray[wStringIndex++] =
                            pObj->szLibraryName;
                        szMessageArray[wStringIndex++] =
                            pObj->szServiceName;

                        ReportEventW (hEventLog,
                            EVENTLOG_ERROR_TYPE,        // error type
                            0,                          // category (not used)
                            (DWORD)WBEMPERF_OPEN_PROC_NOT_FOUND,              // event,
                            NULL,                       // SID (not used),
                            wStringIndex,               // number of strings
                            dwDataIndex*sizeof(DWORD),  // sizeof raw data
                            (LPCWSTR *)szMessageArray,             // message text array
                            (LPVOID)&dwRawDataDwords[0]);           // raw data
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    if (pObj->dwFlags & PERF_EO_QUERY_FUNC) {
                        pObj->QueryProc = (QUERYPROC)GetProcAddress (
                            pObj->hLibrary, pObj->szCollectProcName);
                        pObj->CollectProc = (COLLECTPROC)pObj->QueryProc;
                    } else {
                        pObj->CollectProc = (COLLECTPROC)GetProcAddress (
                            pObj->hLibrary, pObj->szCollectProcName);
                        pObj->QueryProc = (QUERYPROC)pObj->CollectProc;
                    }

                    if (pObj->CollectProc == NULL) {
                        if (lEventLogLevel >= LOG_USER) {
                            Status = GetLastError();
                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            dwRawDataDwords[dwDataIndex++] =
                                (DWORD)Status;
                            szMessageArray[wStringIndex++] =
                                ConvertProcName(pObj->szCollectProcName);
                            szMessageArray[wStringIndex++] =
                                pObj->szLibraryName;
                            szMessageArray[wStringIndex++] =
                                pObj->szServiceName;

                            ReportEventW (hEventLog,
                                EVENTLOG_ERROR_TYPE,        // error type
                                0,                          // category (not used)
                                (DWORD)WBEMPERF_COLLECT_PROC_NOT_FOUND,              // event,
                                NULL,                       // SID (not used),
                                wStringIndex,               // number of strings
                                dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                (LPCWSTR *)szMessageArray,             // message text array
                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                        }
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    pObj->CloseProc = (CLOSEPROC)GetProcAddress (
                        pObj->hLibrary, pObj->szCloseProcName);

                    if (pObj->CloseProc == NULL) {
                        if (lEventLogLevel >= LOG_USER) {
                            Status = GetLastError();
                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            dwRawDataDwords[dwDataIndex++] =
                                (DWORD)Status;
                            szMessageArray[wStringIndex++] =
                                ConvertProcName(pObj->szCloseProcName);
                            szMessageArray[wStringIndex++] =
                                pObj->szLibraryName;
                            szMessageArray[wStringIndex++] =
                                pObj->szServiceName;

                            ReportEventW (hEventLog,
                                EVENTLOG_ERROR_TYPE,        // error type
                                0,                          // category (not used)
                                (DWORD)WBEMPERF_CLOSE_PROC_NOT_FOUND,              // event,
                                NULL,                       // SID (not used),
                                wStringIndex,               // number of strings
                                dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                (LPCWSTR *)szMessageArray,             // message text array
                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                        }
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    __try {
                        // start timer
                        opwInfo.pNext = NULL;
                        opwInfo.szLibraryName = pObj->szLibraryName;
                        opwInfo.szServiceName = pObj->szServiceName;
                        opwInfo.dwWaitTime = pObj->dwOpenTimeout;
#if 0 // disabled for testing
                        hPerflibFuncTimer = StartPerflibFunctionTimer(&opwInfo);
                        // if no timer, continue anyway, even though things may
                        // hang, it's better than not loading the DLL since they
                        // usually load OK
                        //
                        if (hPerflibFuncTimer == NULL) {
                            // unable to get a timer entry
                            DebugPrint (("\nPERFLIB: Unable to acquire timer for Open Proc"));
                        }
#endif //test section
                        // call open procedure to initialize DLL
						if (pObj->hMutex != NULL) {
							Status = WaitForSingleObject (
								pObj->hMutex, 
								pObj->dwOpenTimeout);
							// BUG!!A-DCREWS: If OpenProc is uninitialized, then the condition will 
							// result in the lockoutcount being incremented
							if ((Status != WAIT_TIMEOUT) &&
								(pObj->OpenProc != NULL)) {
								Status = (*pObj->OpenProc)(pObj->szLinkageString);
								ReleaseMutex(pObj->hMutex);
							}
							else {
								pObj->dwLockoutCount++;
							}
						} else {
							Status = ERROR_LOCK_FAILED;
						}

						// check the result.
						if (Status != ERROR_SUCCESS) {
							dwOpenEvent = WBEMPERF_OPEN_PROC_FAILURE;
                        } else {
	                        InterlockedIncrement((LONG *)&pObj->dwOpenCount);
		                }
			            if (hPerflibFuncTimer != NULL) {
				            // kill timer
					        Status = KillPerflibFunctionTimer (hPerflibFuncTimer);
						}
						else 
							dwOpenEvent = WBEMPERF_OPEN_PROC_FAILURE;
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = GetExceptionCode();
                        dwOpenEvent = WBEMPERF_OPEN_PROC_EXCEPTION;
                    }

                    if (Status != ERROR_SUCCESS) {
                        // load data for eventlog message
                        dwDataIndex = wStringIndex = 0;
                        dwRawDataDwords[dwDataIndex++] =
                            (DWORD)Status;
                        szMessageArray[wStringIndex++] =
                            pObj->szServiceName;
                        szMessageArray[wStringIndex++] =
                            pObj->szLibraryName;

                        ReportEventW (hEventLog,
                            (WORD)EVENTLOG_ERROR_TYPE, // error type
                            0,                          // category (not used)
                            dwOpenEvent,                // event,
                            NULL,                       // SID (not used),
                            wStringIndex,               // number of strings
                            dwDataIndex*sizeof(DWORD),  // sizeof raw data
                            (LPCWSTR *)szMessageArray,                // message text array
                            (LPVOID)&dwRawDataDwords[0]);           // raw data
                    }
                }

                if (Status != ERROR_SUCCESS) {
                    // clear fields
                    pObj->OpenProc = NULL;
                    pObj->CollectProc = NULL;
                    pObj->QueryProc = NULL;
                    pObj->CloseProc = NULL;
                    if (pObj->hLibrary != NULL) {
                        FreeLibrary (pObj->hLibrary);
                        pObj->hLibrary = NULL;
                    }
                } else {
                    pObj->llLastUsedTime = GetTimeAsLongLong();
                }
            } else {
                Status = GetLastError();
            }
            SetErrorMode (nErrorMode);
        }
    } else {
        // else already open so bump the ref count
        pObj->llLastUsedTime = GetTimeAsLongLong();
    }

    return Status;
}

//***************************************************************************
//
//  CPerfObjectAccess::AddLibrary   (
//          IWbemClassObject *pClass, 
//          IWbemQualifierSet *pClassQualifiers,
//          LPCWSTR szRegistryKey,
//          DWORD   dwPerfIndex)
//
//  Adds the library referenced by the class object to the list of 
//  libraries to call 
//
//***************************************************************************
//
DWORD
CPerfObjectAccess::AddLibrary   (
            IWbemClassObject *pClass, 
            IWbemQualifierSet *pClassQualifiers,
            LPCWSTR szRegistryKey,
            DWORD   dwPerfIndex)
{
    CPerfDataLibrary *pLibEntry = NULL;
    LONG    Status = ERROR_SUCCESS;
    HKEY    hServicesKey = NULL;
    HKEY    hPerfKey = NULL;
    LPWSTR  szServiceName = NULL;

    HKEY    hKeyLinkage;

    BOOL    bUseQueryFn = FALSE;

    pExtObject  pReturnObject = NULL;

    DWORD   dwType = 0;
    DWORD   dwSize = 0;
    DWORD   dwFlags = 0;
    DWORD   dwKeep;
    DWORD   dwObjectArray[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];
    DWORD   dwObjIndex = 0;
    DWORD   dwMemBlockSize = sizeof(ExtObject);
    DWORD   dwLinkageStringLen = 0;

    CHAR    szOpenProcName[MAX_PATH];
    CHAR    szCollectProcName[MAX_PATH];
    CHAR    szCloseProcName[MAX_PATH];
    WCHAR   szLibraryString[MAX_PATH];
    WCHAR   szLibraryExpPath[MAX_PATH];
    WCHAR   mszObjectList[MAX_PATH];
    WCHAR   szLinkageKeyPath[MAX_PATH];
    WCHAR   szLinkageString[MAX_PATH];

    DWORD   dwOpenTimeout = 0;
    DWORD   dwCollectTimeout = 0;

    LPWSTR  szThisObject;
    LPWSTR  szThisChar;

    LPSTR   pNextStringA;
    LPWSTR  pNextStringW;

    WCHAR   szServicePath[MAX_PATH];
	WCHAR	szMutexName[MAX_PATH];
	WCHAR	szPID[32];

    assert(pClass != NULL);
    assert(pClassQualifiers != NULL);

    UNREFERENCED_PARAMETER(pClassQualifiers);
    UNREFERENCED_PARAMETER(pClass);

    pLibEntry = new CPerfDataLibrary;
    
    if ((pLibEntry != NULL) && (szRegistryKey != NULL)) {

        lstrcpyW (szServicePath, cszHklmServicesKey);

        Status = RegOpenKeyExW (HKEY_LOCAL_MACHINE, szServicePath, 
            0, KEY_READ, &hServicesKey);

        if (Status == ERROR_SUCCESS) {
            lstrcpyW (szServicePath, szRegistryKey);
            lstrcatW (szServicePath, cszPerformance);
            Status = RegOpenKeyExW (hServicesKey, szServicePath, 
                0, KEY_READ, &hPerfKey);

            if (Status == ERROR_SUCCESS) {
                szServiceName = (LPWSTR)szRegistryKey;

                // read the performance DLL name

                dwType = 0;
                dwSize = sizeof(szLibraryString);
                memset (szLibraryString, 0, sizeof(szLibraryString));
                memset (szLibraryString, 0, sizeof(szLibraryExpPath));

                Status = RegQueryValueExW (hPerfKey,
                                        cszDLLValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szLibraryString,
                                        &dwSize);
            }
        }

        if (Status == ERROR_SUCCESS) {
            if (dwType == REG_EXPAND_SZ) {
                // expand any environment vars
                dwSize = ExpandEnvironmentStringsW(
                    szLibraryString,
                    szLibraryExpPath,
                    MAX_PATH);

                if ((dwSize > MAX_PATH) || (dwSize == 0)) {
                    Status = ERROR_INVALID_DLL;
                } else {
                    dwSize += 1;
                    dwSize *= sizeof(WCHAR);
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }
            } else if (dwType == REG_SZ) {
                // look for dll and save full file Path
                dwSize = SearchPathW (
                    NULL,   // use standard system search path
                    szLibraryString,
                    NULL,
                    MAX_PATH,
                    szLibraryExpPath,
                    NULL);

                if ((dwSize > MAX_PATH) || (dwSize == 0)) {
                    Status = ERROR_INVALID_DLL;
                } else {
                    dwSize += 1;
                    dwSize *= sizeof(WCHAR);
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }
            } else {
                Status = ERROR_INVALID_DLL;
            }

            if (Status == ERROR_SUCCESS) {
                // we have the DLL name so get the procedure names
                dwType = 0;
                dwSize = sizeof(szOpenProcName);
                memset (szOpenProcName, 0, sizeof(szOpenProcName));
                Status = RegQueryValueExA (hPerfKey,
                                        caszOpenValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szOpenProcName,
                                        &dwSize);
            }

            if (Status == ERROR_SUCCESS) {
                // add in size of previous string
                // the size value includes the Term. NULL
                dwMemBlockSize += DWORD_MULTIPLE(dwSize);

                // we have the procedure name so get the timeout value
                dwType = 0;
                dwSize = sizeof(dwOpenTimeout);
                Status = RegQueryValueExW (hPerfKey,
                                        cszOpenTimeout,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)&dwOpenTimeout,
                                        &dwSize);

                // if error, then apply default
                if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                    dwOpenTimeout = dwExtCtrOpenProcWaitMs;
                    Status = ERROR_SUCCESS;
                }

            }

            if (Status == ERROR_SUCCESS) {
                // get next string

                dwType = 0;
                dwSize = sizeof(szCloseProcName);
                memset (szCloseProcName, 0, sizeof(szCloseProcName));
                Status = RegQueryValueExA (hPerfKey,
                                        caszCloseValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szCloseProcName,
                                        &dwSize);
            }

            if (Status == ERROR_SUCCESS) {
                // add in size of previous string
                // the size value includes the Term. NULL
                dwMemBlockSize += DWORD_MULTIPLE(dwSize);

                // try to look up the query function which is the
                // preferred interface if it's not found, then
                // try the collect function name. If that's not found,
                // then bail
                dwType = 0;
                dwSize = sizeof(szCollectProcName);
                memset (szCollectProcName, 0, sizeof(szCollectProcName));
                Status = RegQueryValueExA (hPerfKey,
                                        caszQueryValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szCollectProcName,
                                        &dwSize);

                if (Status == ERROR_SUCCESS) {
                    // add in size of the Query Function Name
                    // the size value includes the Term. NULL
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                    // get next string

                    bUseQueryFn = TRUE;
                    // the query function can support a static object list
                    // so look it up

                } else {
                    // the QueryFunction wasn't found so look up the
                    // Collect Function name instead
                    dwType = 0;
                    dwSize = sizeof(szCollectProcName);
                    memset (szCollectProcName, 0, sizeof(szCollectProcName));
                    Status = RegQueryValueExA (hPerfKey,
                                            caszCollectValue,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)szCollectProcName,
                                            &dwSize);

                    if (Status == ERROR_SUCCESS) {
                        // add in size of Collect Function Name
                        // the size value includes the Term. NULL
                        dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    // we have the procedure name so get the timeout value
                    dwType = 0;
                    dwSize = sizeof(dwCollectTimeout);
                    Status = RegQueryValueExW (hPerfKey,
                                            cszCollectTimeout,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)&dwCollectTimeout,
                                            &dwSize);

                    // if error, then apply default
                    if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                        dwCollectTimeout = dwExtCtrOpenProcWaitMs;
                        Status = ERROR_SUCCESS;
                    }

                }
                // get the list of supported objects if provided by the registry

                dwType = 0;
                dwSize = sizeof(mszObjectList);
                memset (mszObjectList, 0, sizeof(mszObjectList));
                Status = RegQueryValueExW (hPerfKey,
                                        cszObjListValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)mszObjectList,
                                        &dwSize);

                if (Status == ERROR_SUCCESS) {
                    if (dwType != REG_MULTI_SZ) {
                        // convert space delimited list to msz
                        for (szThisChar = mszObjectList; *szThisChar != 0; szThisChar++) {
                            if (*szThisChar == L' ') *szThisChar = L'\0';
                        }
                        ++szThisChar;
                        *szThisChar = 0; // add MSZ term Null
                    }
                    for (szThisObject = mszObjectList, dwObjIndex = 0;
                        (*szThisObject != 0) && (dwObjIndex < MAX_PERF_OBJECTS_IN_QUERY_FUNCTION);
                        szThisObject += lstrlenW(szThisObject) + 1) {
                        dwObjectArray[dwObjIndex] = wcstoul(szThisObject, NULL, 10);
                        dwObjIndex++;
                    }
                    if (*szThisObject != 0) {
                        DWORD  dwDataIndex  = 0;
                        WORD   wStringIndex = 0;
                        DWORD  dwRawDataDwords[8];
                        LPWSTR szMessageArray[8];
                        dwRawDataDwords[dwDataIndex++] = (DWORD) ERROR_SUCCESS;
                        szMessageArray[wStringIndex++] = (LPWSTR) cszObjListValue;
                        szMessageArray[wStringIndex++] = szLibraryString;
                        szMessageArray[wStringIndex++] = szServicePath;

                        ReportEventW(hEventLog,
                                     EVENTLOG_WARNING_TYPE,
                                     0,
                                     (DWORD) WBEMPERF_TOO_MANY_OBJECT_IDS,
                                     NULL,
                                     wStringIndex,
                                     dwDataIndex * sizeof(DWORD),
                                     (LPCWSTR *) szMessageArray,
                                     (LPVOID) & dwRawDataDwords[0]);
                    }
                } else {
                    // reset status since not having this is
                    //  not a showstopper
                    Status = ERROR_SUCCESS;
                }

                if (Status == ERROR_SUCCESS) {
                    dwType = 0;
                    dwKeep = 0;
                    dwSize = sizeof(dwKeep);
                    Status = RegQueryValueExW (hPerfKey,
                                            cszKeepResident,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)&dwKeep,
                                            &dwSize);

                    if ((Status == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
                        if (dwKeep == 1) {
                            dwFlags |= PERF_EO_KEEP_RESIDENT;
                        } else {
                            // no change.
                        }
                    } else {
                        // not fatal, just use the defaults.
                        Status = ERROR_SUCCESS;
                    }

                }
            }
        }

        if (Status == ERROR_SUCCESS) {
            memset (szLinkageString, 0, sizeof(szLinkageString));

            lstrcpyW (szLinkageKeyPath, szServiceName);
            lstrcatW (szLinkageKeyPath, cszLinkageKey);

            Status = RegOpenKeyExW (
                hServicesKey,
                szLinkageKeyPath,
                0L,
                KEY_READ,
                &hKeyLinkage);

            if (Status == ERROR_SUCCESS) {
                // look up export value string
                dwSize = sizeof(szLinkageString);
                dwType = 0;
                Status = RegQueryValueExW (
                    hKeyLinkage,
                    cszExportValue,
                    NULL,
                    &dwType,
                    (LPBYTE)&szLinkageString,
                    &dwSize);

                if ((Status != ERROR_SUCCESS) ||
                    ((dwType != REG_SZ) && (dwType != REG_MULTI_SZ))) {
                    // clear buffer
                    memset (szLinkageString, 0, sizeof(szLinkageString));
                    dwLinkageStringLen = 0;

                    // not finding a linkage key is not fatal so correct
                    // status
                    Status = ERROR_SUCCESS;
                } else {
                    // add size of linkage string to buffer
                    // the size value includes the Term. NULL
                    dwLinkageStringLen = dwSize;
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }

                RegCloseKey (hKeyLinkage);
            } else {
                // not finding a linkage key is not fatal so correct
                // status
                Status = ERROR_SUCCESS;
            }
        }

        if (Status == ERROR_SUCCESS) {
            // add in size of service name
            dwSize = lstrlenW (szServiceName);
            dwSize += 1;
            dwSize *= sizeof(WCHAR);
            dwMemBlockSize += DWORD_MULTIPLE(dwSize);

            // allocate and initialize a new ext. object block
            pReturnObject = (pExtObject)ALLOCMEM(m_hObjectHeap,
                HEAP_ZERO_MEMORY, dwMemBlockSize);

            if (pReturnObject != NULL) {
                // copy values to new buffer (all others are NULL)
                pNextStringA = (LPSTR)&pReturnObject[1];

                // copy Open Procedure Name
                pReturnObject->szOpenProcName = pNextStringA;
                lstrcpyA (pNextStringA, szOpenProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);

                pReturnObject->dwOpenTimeout = dwOpenTimeout;

                // copy collect function or query function, depending
                pReturnObject->szCollectProcName = pNextStringA;
                lstrcpyA (pNextStringA, szCollectProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);

                pReturnObject->dwCollectTimeout = dwCollectTimeout;

                // copy Close Procedure Name
                pReturnObject->szCloseProcName = pNextStringA;
                lstrcpyA (pNextStringA, szCloseProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);

                // copy Library path
                pNextStringW = (LPWSTR)pNextStringA;
                pReturnObject->szLibraryName = pNextStringW;
                lstrcpyW (pNextStringW, szLibraryExpPath);

                pNextStringW += lstrlenW (pNextStringW) + 1;
                pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);

                // copy Linkage String if there is one
                if (*szLinkageString != 0) {
                    pReturnObject->szLinkageString = pNextStringW;
                    memcpy (pNextStringW, szLinkageString, dwLinkageStringLen);

                    // length includes extra NULL char and is in BYTES
                    pNextStringW += (dwLinkageStringLen / sizeof (WCHAR));
                    pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);
                }

                // copy Service name
                pReturnObject->szServiceName = pNextStringW;
                lstrcpyW (pNextStringW, szServiceName);

                pNextStringW += lstrlenW (pNextStringW) + 1;
                pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);

                // load flags
                if (bUseQueryFn) {
                    dwFlags |= PERF_EO_QUERY_FUNC;
                }
                pReturnObject->dwFlags =  dwFlags;

                pReturnObject->hPerfKey = hPerfKey;

                // load Object array
                if (dwObjIndex > 0) {
                    pReturnObject->dwNumObjects = dwObjIndex;
                    memcpy (pReturnObject->dwObjList,
                        dwObjectArray, (dwObjIndex * sizeof(dwObjectArray[0])));
                }

                pReturnObject->llLastUsedTime = 0;

				// create Mutex name
				lstrcpyW (szMutexName, szRegistryKey);
				lstrcatW (szMutexName, (LPCWSTR)L"_Perf_Library_Lock_PID_");
				_ultow ((ULONG)GetCurrentProcessId(), szPID, 16);
				lstrcatW (szMutexName, szPID);

                // pReturnObject->hMutex = CreateMutexW (NULL, FALSE, szMutexName);
				pReturnObject->hMutex = CreateMutexAsProcess(szMutexName);
            } else {
                Status = ERROR_OUTOFMEMORY;
            }
        }

        if (Status != ERROR_SUCCESS) {
            SetLastError (Status);
            if (pReturnObject != NULL) {
                // release the new block
                FREEMEM (m_hObjectHeap, 0, pReturnObject);
            }
        } else {
            if (pReturnObject != NULL) {
                Status = OpenExtObjectLibrary (pReturnObject);
                if (Status == ERROR_SUCCESS) {
                    if (dwPerfIndex != 0) {
                        // initialize the perf index string
                        _ultow (dwPerfIndex, pLibEntry->szQueryString, 10);
                    } else {
                        lstrcpyW (pLibEntry->szQueryString, cszGlobal);
                    }
                    // save the pointer to the initialize structure
                    pLibEntry->pLibInfo = pReturnObject;
                    m_aLibraries.Add(pLibEntry);
                    pLibEntry->dwRefCount++;
                    assert(pLibEntry->dwRefCount == 1);
                } else {
                    // release the new block
                    FREEMEM (m_hObjectHeap, 0, pReturnObject);
                }
            }
        }

        if (hServicesKey != NULL) RegCloseKey (hServicesKey);
    } else {    // gets here if pLibEntry == NULL and/or szRegistryKey == NULL
        if (pLibEntry == NULL) {
            Status = ERROR_OUTOFMEMORY;
        }
        if (szRegistryKey == NULL) {
            Status = ERROR_INVALID_PARAMETER;
        }
    }
    if ((Status != ERROR_SUCCESS) && (pLibEntry != NULL))
        delete pLibEntry;

    return Status;
}

//***************************************************************************
//
//  CPerfObjectAccess::AddClass (IWbemClassObject *pClass, BOOL bCatalogQuery)
//
//  Adds the specified WBEM performance object class and any required library 
//  entries to the access object.
//
//***************************************************************************
//
DWORD   
CPerfObjectAccess::AddClass (IWbemClassObject *pClass, BOOL bCatalogQuery)
{
    CPerfDataLibrary *pLibEntry = NULL;
    CPerfDataLibrary *pThisLibEntry = NULL;
    DWORD           dwIndex, dwEnd;
    LPWSTR          szRegistryKey = NULL;
    IWbemQualifierSet   *pClassQualifiers = NULL;
    VARIANT         vRegistryKey;
    HRESULT         hRes;
    DWORD           dwReturn = ERROR_SUCCESS;
    DWORD           dwPerfIndex = 0;

    VariantInit (&vRegistryKey);
    // get the Qualifier Set for this class
    hRes = pClass->GetQualifierSet(&pClassQualifiers);
    assert (hRes == 0);
    // now get the library and procedure names
    hRes = pClassQualifiers->Get(CBSTR(cszRegistryKey), 0, &vRegistryKey, 0);
    if ((hRes == 0) && (vRegistryKey.vt == VT_BSTR)) {
        szRegistryKey = Macro_CloneLPWSTR(V_BSTR(&vRegistryKey));
        if (szRegistryKey == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            // now also get the perf index
            if (bCatalogQuery) {
                // then insert 0 for the perf index to indicate a "GLOBAL"
                // query
                dwPerfIndex = 0;
            } else {
                VariantClear (&vRegistryKey);
                hRes = pClassQualifiers->Get(CBSTR(cszPerfIndex), 0, &vRegistryKey, 0);
                if (hRes == 0) {
                    dwPerfIndex = (DWORD)V_UI4(&vRegistryKey);
                } else {
                    // unable to find NtPerfLibrary entry
                    dwReturn = ERROR_FILE_NOT_FOUND;
                }
            }
        }
    } else {
        // unable to find NtPerfLibrary entry
        dwReturn = ERROR_FILE_NOT_FOUND;
    }

	if (pClassQualifiers != NULL) pClassQualifiers->Release();

    if (dwReturn == ERROR_SUCCESS) {
        // find matching library in the array
        dwEnd = m_aLibraries.Size();
        if (dwEnd > 0) {
            // walk down the list of libraries
            for (dwIndex = 0; dwIndex < dwEnd; dwIndex++) {
                // see if this library entry is good enough to keep
                // The library is assumed to be a match if the 
                // lib. name and all proc's are the same.
                pThisLibEntry = (CPerfDataLibrary *)m_aLibraries[dwIndex];
                assert (pThisLibEntry != NULL); // it should have been removed!
                // make sure it's complete
                assert (pThisLibEntry->pLibInfo->szServiceName != NULL);

                if (lstrcmpiW (szRegistryKey, pThisLibEntry->pLibInfo->szServiceName) == 0) {
                    pLibEntry = pThisLibEntry;
                    break;
                } else {
                    // wrong library
                    // so continue
                }
            }
        }

        if (pLibEntry == NULL) {
            // add this class & it's library to the list
            dwReturn = AddLibrary   (pClass, pClassQualifiers, szRegistryKey, dwPerfIndex);
        } else {
            WCHAR   wszNewIndex[MAX_PATH];
            pLibEntry->dwRefCount++;
            _ultow (dwPerfIndex, wszNewIndex, 10);
            if (!IsNumberInUnicodeList (dwPerfIndex, pLibEntry->szQueryString)) {
                // then add it to the list
                lstrcatW (pLibEntry->szQueryString, cszSpace);
                lstrcatW (pLibEntry->szQueryString, wszNewIndex);
            }
        }
    }

	if (szRegistryKey != NULL) delete szRegistryKey;
    VariantClear(&vRegistryKey);

    return dwReturn;
}

//***************************************************************************
//
//  CPerfObjectAccess::CollectData (LPBYTE pBuffer, 
//              LPDWORD pdwBufferSize, LPWSTR pszItemList)
//
//  Collects data from the perf objects and libraries added to the access 
//  object
//
//      Inputs:
//
//          pBuffer              -   pointer to start of data block
//                                  where data is being collected
//
//          pdwBufferSize        -   pointer to size of data buffer
//
//          pszItemList        -    string to pass to ext DLL
//
//      Outputs:
//
//          *lppDataDefinition  -   set to location for next Type
//                                  Definition if successful
//
//      Returns:
//
//          0 if successful, else Win 32 error code of failure
//
//
//***************************************************************************
//
DWORD   
CPerfObjectAccess::CollectData (LPBYTE pBuffer, LPDWORD pdwBufferSize, LPWSTR pszItemList)
{
    LPWSTR  lpValueName = NULL;
    LPBYTE  lpData = pBuffer;
    LPDWORD lpcbData = pdwBufferSize;
    LPVOID  lpDataDefinition = NULL;

    DWORD Win32Error=ERROR_SUCCESS;          //  Failure code
    DWORD BytesLeft;
    DWORD NumObjectTypes;

    LPVOID  lpExtDataBuffer = NULL;
    LPVOID  lpCallBuffer = NULL;
    LPVOID  lpLowGuardPage = NULL;
    LPVOID  lpHiGuardPage = NULL;
    LPVOID  lpEndPointer = NULL;
    LPVOID  lpBufferBefore = NULL;
    LPVOID  lpBufferAfter = NULL;
    LPDWORD lpCheckPointer;
    LARGE_INTEGER   liStartTime, liEndTime, liWaitTime;

    pExtObject  pThisExtObj = NULL;

    BOOL    bGuardPageOK;
    BOOL    bBufferOK;
    BOOL    bException;
    BOOL    bUseSafeBuffer;
    BOOL    bUnlockObjData = FALSE;

    LPWSTR  szMessageArray[8];
    DWORD   dwRawDataDwords[8];     // raw data buffer
    DWORD   dwDataIndex;
    WORD    wStringIndex;
    LONG    lReturnValue = ERROR_SUCCESS;

    LONG                lInstIndex;
    PERF_OBJECT_TYPE    *pObject, *pNextObject;
    PERF_INSTANCE_DEFINITION    *pInstance;
    PERF_DATA_BLOCK     *pPerfData;
    BOOL                bForeignDataBuffer;

    DWORD           dwItemsInList = 0;

    DWORD           dwIndex, dwEntry;

    CPerfDataLibrary    *pThisLib;

    liStartTime.QuadPart = 0;
    liEndTime.QuadPart = 0;

    if (lExtCounterTestLevel < EXT_TEST_NOMEMALLOC) {
        bUseSafeBuffer = TRUE;
    } else {
        bUseSafeBuffer = FALSE;
    }

    lReturnValue = RegisterExtObjListAccess();

    if (lReturnValue == ERROR_SUCCESS) {

        if (*pdwBufferSize > (sizeof(PERF_DATA_BLOCK) *2)) {
            MonBuildPerfDataBlock(
                (PERF_DATA_BLOCK *)pBuffer,
                &lpDataDefinition,
                0,0);
            dwItemsInList = m_aLibraries.Size();
        } else {
            lReturnValue = ERROR_MORE_DATA;
            dwItemsInList = 0;
        }


        if (dwItemsInList > 0) {
            for (dwEntry = 0; dwEntry < dwItemsInList; dwEntry++) {
                pThisLib = (CPerfDataLibrary *)m_aLibraries[dwEntry];
                assert (pThisLib != NULL);

                pThisExtObj = pThisLib->pLibInfo;
                if (pszItemList == NULL) {
                    // use the one for this library
                    lpValueName = pThisLib->szQueryString;
                } else {
                    // use the one passed by the caller
                    lpValueName = pszItemList;
                }

                // convert timeout value
                liWaitTime.QuadPart = MakeTimeOutValue (pThisExtObj->dwCollectTimeout);

                // initialize values to pass to the extensible counter function
                NumObjectTypes = 0;
                BytesLeft = (DWORD) (*lpcbData - ((LPBYTE)lpDataDefinition - lpData));
                bException = FALSE;

                if (pThisExtObj->hLibrary == NULL) {
                    // lock library object
                    if (pThisExtObj->hMutex != NULL) {
                        Win32Error =  WaitForSingleObject (
                            pThisExtObj->hMutex,
                            pThisExtObj->dwCollectTimeout);
                        if (Win32Error != WAIT_TIMEOUT) {
                            // if necessary, open the library
                            if (pThisExtObj->hLibrary == NULL) {
                                // make sure the library is open
                                Win32Error = OpenExtObjectLibrary(pThisExtObj);
                                if (Win32Error != ERROR_SUCCESS) {
                                    // assume error has been posted
                                    ReleaseMutex (pThisExtObj->hMutex);
                                    continue; // to next entry
                                }
                            }
                            ReleaseMutex (pThisExtObj->hMutex);
                        } else {
                            pThisExtObj->dwLockoutCount++;
                        }
                    } else {
                        Win32Error = ERROR_LOCK_FAILED;
                    }
                } else {
                    // library should be ready to use
                }

                // allocate a local block of memory to pass to the
                // extensible counter function.

                if (bUseSafeBuffer) {
                    lpExtDataBuffer = ALLOCMEM (m_hObjectHeap,
                        HEAP_ZERO_MEMORY, BytesLeft + (2*GUARD_PAGE_SIZE));
                } else {
                    lpExtDataBuffer =
                        lpCallBuffer = lpDataDefinition;
                }

                if (lpExtDataBuffer != NULL) {

                    if (bUseSafeBuffer) {
                        // set buffer pointers
                        lpLowGuardPage = lpExtDataBuffer;
                        lpCallBuffer = (LPBYTE)lpExtDataBuffer + GUARD_PAGE_SIZE;
                        lpHiGuardPage = (LPBYTE)lpCallBuffer + BytesLeft;
                        lpEndPointer = (LPBYTE)lpHiGuardPage + GUARD_PAGE_SIZE;
                        lpBufferBefore = lpCallBuffer;
                        lpBufferAfter = NULL;

                        // initialize GuardPage Data

                        memset (lpLowGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
                        memset (lpHiGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
                    }

                    __try {
                        //
                        //  Collect data from extesible objects
                        //

                        bUnlockObjData = FALSE;
                        if (pThisExtObj->hMutex != NULL) {
                            Win32Error =  WaitForSingleObject (
                                pThisExtObj->hMutex,
                                pThisExtObj->dwCollectTimeout);
							// BUG!!A-DCREWS: If CollectProc is uninitialized, then the condition will 
							// result in the lockoutcount being incremented
                            if ((Win32Error != WAIT_TIMEOUT)  &&
                                (pThisExtObj->CollectProc != NULL)) {

                                bUnlockObjData = TRUE;

                                QueryPerformanceCounter (&liStartTime);

									Win32Error =  (*pThisExtObj->CollectProc) (
                                        lpValueName,
										&lpCallBuffer,
                                        &BytesLeft,
                                        &NumObjectTypes);

                                QueryPerformanceCounter (&liEndTime);

                                pThisExtObj->llLastUsedTime = GetTimeAsLongLong();

                                ReleaseMutex (pThisExtObj->hMutex);
                                bUnlockObjData = FALSE;
                            } else {
                                pThisExtObj->dwLockoutCount++;
                            }
                        } else {
                            Win32Error = ERROR_LOCK_FAILED;
                        }

                        if ((Win32Error == ERROR_SUCCESS) && (BytesLeft > 0)) {
                            // increment perf counters
                            InterlockedIncrement ((LONG *)&pThisExtObj->dwCollectCount);
                            pThisExtObj->llElapsedTime +=
                                liEndTime.QuadPart - liStartTime.QuadPart;

                            if (bUseSafeBuffer) {
                                // a data buffer was returned and
                                // the function returned OK so see how things
                                // turned out...
                                //
                                lpBufferAfter = lpCallBuffer;
                                //
                                // check for buffer corruption here
                                //
                                bBufferOK = TRUE; // assume it's ok until a check fails
                                //
                                if (lExtCounterTestLevel <= EXT_TEST_BASIC) {
                                    //
                                    //  check 1: bytes left should be the same as
                                    //      new data buffer ptr - orig data buffer ptr
                                    //
                                    if (BytesLeft != (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore)) {
                                        if (lEventLogLevel >= LOG_DEBUG) {
                                            // issue WARNING, that bytes left param is incorrect
                                            // load data for eventlog message
                                            // since this error is correctable (though with
                                            // some risk) this won't be reported at LOG_USER
                                            // level
                                            dwDataIndex = wStringIndex = 0;
                                            dwRawDataDwords[dwDataIndex++] = BytesLeft;
                                            dwRawDataDwords[dwDataIndex++] =
                                                (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore);
                                            szMessageArray[wStringIndex++] =
                                                pThisExtObj->szServiceName;
                                            szMessageArray[wStringIndex++] =
                                                pThisExtObj->szLibraryName;
                                            ReportEventW (hEventLog,
                                                EVENTLOG_WARNING_TYPE,      // error type
                                                0,                          // category (not used)
                                                (DWORD)WBEMPERF_BUFFER_POINTER_MISMATCH,   // event,
                                                NULL,                       // SID (not used),
                                                wStringIndex,              // number of strings
                                                dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                (LPCWSTR *)szMessageArray,                // message text array
                                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                                        }
                                        // we'll keep the buffer, since the returned bytes left
                                        // value is ignored anyway, in order to make the
                                        // rest of this function work, we'll fix it here
                                        BytesLeft = (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore);
                                    }
                                    //
                                    //  check 2: buffer after ptr should be < hi Guard page ptr
                                    //
                                    if (((LPBYTE)lpBufferAfter >= (LPBYTE)lpHiGuardPage) && bBufferOK) {
                                        // see if they exceeded the allocated memory
                                        if ((LPBYTE)lpBufferAfter >= (LPBYTE)lpEndPointer) {
                                            // this is very serious since they've probably trashed
                                            // the heap by overwriting the heap sig. block
                                            // issue ERROR, buffer overrun
                                            if (lEventLogLevel >= LOG_USER) {
                                                // load data for eventlog message
                                                dwDataIndex = wStringIndex = 0;
                                                dwRawDataDwords[dwDataIndex++] =
                                                    (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpHiGuardPage);
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szLibraryName;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szServiceName;
                                                ReportEventW (hEventLog,
                                                    EVENTLOG_ERROR_TYPE,        // error type
                                                    0,                          // category (not used)
                                                    (DWORD)WBEMPERF_HEAP_ERROR,  // event,
                                                    NULL,                       // SID (not used),
                                                    wStringIndex,               // number of strings
                                                    dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                    (LPCWSTR *)szMessageArray,             // message text array
                                                    (LPVOID)&dwRawDataDwords[0]);           // raw data
                                            }
                                        } else {
                                            // issue ERROR, buffer overrun
                                            if (lEventLogLevel >= LOG_USER) {
                                                // load data for eventlog message
                                                dwDataIndex = wStringIndex = 0;
                                                dwRawDataDwords[dwDataIndex++] =
                                                    (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpHiGuardPage);
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szLibraryName;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szServiceName;
                                                ReportEventW (hEventLog,
                                                    EVENTLOG_ERROR_TYPE,        // error type
                                                    0,                          // category (not used)
                                                    (DWORD)WBEMPERF_BUFFER_OVERFLOW,     // event,
                                                    NULL,                       // SID (not used),
                                                    wStringIndex,              // number of strings
                                                    dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                    (LPCWSTR *)szMessageArray,                // message text array
                                                    (LPVOID)&dwRawDataDwords[0]);           // raw data
                                            }
                                        }
                                        bBufferOK = FALSE;
                                        // since the DLL overran the buffer, the buffer
                                        // must be too small (no comments about the DLL
                                        // will be made here) so the status will be
                                        // changed to ERROR_MORE_DATA and the function
                                        // will return.
                                        Win32Error = ERROR_MORE_DATA;
                                    }
                                    //
                                    //  check 3: check lo guard page for corruption
                                    //
                                    if (bBufferOK) {
                                        bGuardPageOK = TRUE;
                                        for (lpCheckPointer = (LPDWORD)lpLowGuardPage;
                                                lpCheckPointer < (LPDWORD)lpBufferBefore;
                                            lpCheckPointer++) {
                                            if (*lpCheckPointer != GUARD_PAGE_DWORD) {
                                                bGuardPageOK = FALSE;
                                                    break;
                                            }
                                        }
                                        if (!bGuardPageOK) {
                                            // issue ERROR, Lo Guard Page corrupted
                                            if (lEventLogLevel >= LOG_USER) {
                                                // load data for eventlog message
                                                dwDataIndex = wStringIndex = 0;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szLibraryName;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szServiceName;
                                                ReportEventW (hEventLog,
                                                    EVENTLOG_ERROR_TYPE,        // error type
                                                    0,                          // category (not used)
                                                    (DWORD)WBEMPERF_GUARD_PAGE_VIOLATION, // event
                                                    NULL,                       // SID (not used),
                                                    wStringIndex,              // number of strings
                                                    dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                    (LPCWSTR *)szMessageArray,                // message text array
                                                    (LPVOID)&dwRawDataDwords[0]);           // raw data
                                            }
                                            bBufferOK = FALSE;
                                        }
                                    }
                                    //
                                    //  check 4: check hi guard page for corruption
                                    //
                                    if (bBufferOK) {
                                        bGuardPageOK = TRUE;
                                        for (lpCheckPointer = (LPDWORD)lpHiGuardPage;
                                            lpCheckPointer < (LPDWORD)lpEndPointer;
                                            lpCheckPointer++) {
                                                if (*lpCheckPointer != GUARD_PAGE_DWORD) {
                                                    bGuardPageOK = FALSE;
                                                break;
                                            }
                                        }
                                        if (!bGuardPageOK) {
                                            // issue ERROR, Hi Guard Page corrupted
                                            if (lEventLogLevel >= LOG_USER) {
                                                // load data for eventlog message
                                                dwDataIndex = wStringIndex = 0;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szLibraryName;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szServiceName;
                                                ReportEventW (hEventLog,
                                                    EVENTLOG_ERROR_TYPE,        // error type
                                                    0,                          // category (not used)
                                                    (DWORD)WBEMPERF_GUARD_PAGE_VIOLATION, // event,
                                                    NULL,                       // SID (not used),
                                                    wStringIndex,              // number of strings
                                                    dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                    (LPCWSTR *)szMessageArray,                // message text array
                                                    (LPVOID)&dwRawDataDwords[0]);           // raw data
                                            }

                                            bBufferOK = FALSE;
                                        }
                                    }
                                    //
                                    if ((lExtCounterTestLevel <= EXT_TEST_ALL) && bBufferOK) {
                                        //
                                        //  Internal consistency checks
                                        //
                                        //
                                        //  Check 5: Check object length field values
                                        //
                                        // first test to see if this is a foreign
                                        // computer data block or not
                                        //
                                        pPerfData = (PERF_DATA_BLOCK *)lpBufferBefore;
                                        if ((pPerfData->Signature[0] == (WCHAR)'P') &&
                                            (pPerfData->Signature[1] == (WCHAR)'E') &&
                                            (pPerfData->Signature[2] == (WCHAR)'R') &&
                                            (pPerfData->Signature[3] == (WCHAR)'F')) {
                                            // if this is a foreign computer data block, then the
                                            // first object is after the header
                                            pObject = (PERF_OBJECT_TYPE *) (
                                                (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                            bForeignDataBuffer = TRUE;
                                        } else {
                                            // otherwise, if this is just a buffer from
                                            // an extensible counter, the object starts
                                            // at the beginning of the buffer
                                            pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                            bForeignDataBuffer = FALSE;
                                        }
                                        // go to where the pointers say the end of the
                                        // buffer is and then see if it's where it
                                        // should be
                                        for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                            pObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                                pObject->TotalByteLength);
                                        }
                                        if ((LPBYTE)pObject != (LPBYTE)lpCallBuffer) {
                                            // then a length field is incorrect. This is FATAL
                                            // since it can corrupt the rest of the buffer
                                            // and render the buffer unusable.
                                            if (lEventLogLevel >= LOG_USER) {
                                                // load data for eventlog message
                                                dwDataIndex = wStringIndex = 0;
                                                dwRawDataDwords[dwDataIndex++] = NumObjectTypes;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szLibraryName;
                                                szMessageArray[wStringIndex++] =
                                                    pThisExtObj->szServiceName;
                                                ReportEventW (hEventLog,
                                                    EVENTLOG_ERROR_TYPE,        // error type
                                                    0,                          // category (not used)
                                                    (DWORD)WBEMPERF_INCORRECT_OBJECT_LENGTH, // event,
                                                    NULL,                       // SID (not used),
                                                    wStringIndex,               // number of strings
                                                    dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                    (LPCWSTR *)szMessageArray,             // message text array
                                                    (LPVOID)&dwRawDataDwords[0]); // raw data
                                            }
                                            bBufferOK = FALSE;
                                        }
                                        //
                                        //  Test 6: Test instance field size values
                                        //
                                        if (bBufferOK) {
                                            // set object pointer
                                            if (bForeignDataBuffer) {
                                                pObject = (PERF_OBJECT_TYPE *) (
                                                    (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                            } else {
                                                // otherwise, if this is just a buffer from
                                                // an extensible counter, the object starts
                                                // at the beginning of the buffer
                                                pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                            }

                                            for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                                pNextObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                                    pObject->TotalByteLength);

                                                if (pObject->NumInstances != PERF_NO_INSTANCES) {
                                                    pInstance = (PERF_INSTANCE_DEFINITION *)
                                                        ((LPBYTE)pObject + pObject->DefinitionLength);
                                                    lInstIndex = 0;
                                                    while (lInstIndex < pObject->NumInstances) {
                                                        PERF_COUNTER_BLOCK *pCounterBlock;

                                                        pCounterBlock = (PERF_COUNTER_BLOCK *)
                                                            ((PCHAR) pInstance + pInstance->ByteLength);

                                                        pInstance = (PERF_INSTANCE_DEFINITION *)
                                                            ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);

                                                        lInstIndex++;
                                                    }
                                                    if ((LPBYTE)pInstance > (LPBYTE)pNextObject) {
                                                        bBufferOK = FALSE;
                                                    }
                                                }

                                                if (!bBufferOK) {
                                                    break;
                                                } else {
                                                    pObject = pNextObject;
                                                }
                                            }

                                            if (!bBufferOK) {
                                                if (lEventLogLevel >= LOG_USER) {
                                                    // load data for eventlog message
                                                    dwDataIndex = wStringIndex = 0;
                                                    dwRawDataDwords[dwDataIndex++] = pObject->ObjectNameTitleIndex;
                                                    szMessageArray[wStringIndex++] =
                                                        pThisExtObj->szLibraryName;
                                                    szMessageArray[wStringIndex++] =
                                                        pThisExtObj->szServiceName;
                                                    ReportEventW (hEventLog,
                                                        EVENTLOG_ERROR_TYPE,        // error type
                                                        0,                          // category (not used)
                                                        (DWORD)WBEMPERF_INCORRECT_INSTANCE_LENGTH, // event,
                                                        NULL,                       // SID (not used),
                                                        wStringIndex,              // number of strings
                                                        dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                                        (LPCWSTR *)szMessageArray,                // message text array
                                                        (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                }
                                            }
                                        }
                                    }
                                }
                                //
                                // if all the tests pass,then copy the data to the
                                // original buffer and update the pointers
                                if (bBufferOK) {
                                    RtlMoveMemory (lpDataDefinition,
                                        lpBufferBefore,
                                        BytesLeft); // returned buffer size
                                } else {
                                    NumObjectTypes = 0; // since this buffer was tossed
                                    BytesLeft = 0; // reset the size value since the buffer wasn't used
                                }
                            } else {
                                // function already copied data to caller's buffer
                                // so no further action is necessary
                            }
                            lpDataDefinition = (LPVOID)((LPBYTE)(lpDataDefinition) + BytesLeft);    // update data pointer
                        } else {
                            if (Win32Error != ERROR_SUCCESS) {
                                InterlockedIncrement ((LONG *)&pThisExtObj->dwErrorCount);
                            }
                            if (bUnlockObjData) {
                                ReleaseMutex (pThisExtObj->hMutex);
                            }

                            NumObjectTypes = 0; // clear counter
                        }// end if function returned successfully

                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        Win32Error = GetExceptionCode();
                        InterlockedIncrement ((LONG *)&pThisExtObj->dwErrorCount);
                        bException = TRUE;
                        if (bUnlockObjData) {
                            ReleaseMutex (pThisExtObj->hMutex);
                            bUnlockObjData = FALSE;
                        }
                    }
                    if (bUseSafeBuffer) {
                        FREEMEM (m_hObjectHeap, 0, lpExtDataBuffer);
                    }
                } else {
                    // unable to allocate memory so set error value
                    Win32Error = ERROR_OUTOFMEMORY;
                } // end if temp buffer allocated successfully
                //
                //  Update the count of the number of object types
                //
                ((PPERF_DATA_BLOCK) lpData)->NumObjectTypes += NumObjectTypes;

                if ( Win32Error != ERROR_SUCCESS) {
                    if (bException ||
                        !((Win32Error == ERROR_MORE_DATA) ||
                          (Win32Error == WAIT_TIMEOUT))) {
                        // inform on exceptions & illegal error status only
                        if (lEventLogLevel >= LOG_USER) {
                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            dwRawDataDwords[dwDataIndex++] = Win32Error;
                            szMessageArray[wStringIndex++] =
                                pThisExtObj->szServiceName;
                            szMessageArray[wStringIndex++] =
                                pThisExtObj->szLibraryName;
                            ReportEventW (hEventLog,
                                EVENTLOG_ERROR_TYPE,        // error type
                                0,                          // category (not used)
                                (DWORD)WBEMPERF_COLLECT_PROC_EXCEPTION,   // event,
                                NULL,                       // SID (not used),
                                wStringIndex,              // number of strings
                                dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                (LPCWSTR *)szMessageArray,                // message text array
                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                        } else {
                            // don't report
                        }
                    }
                    // the ext. dll is only supposed to return:
                    //  ERROR_SUCCESS even if it encountered a problem, OR
                    //  ERROR_MODE_DATA if the buffer was too small.
                    // if it's ERROR_MORE_DATA, then break and return the
                    // error now, since it'll just be returned again and again.
                    if (Win32Error == ERROR_MORE_DATA) {
                        lReturnValue = Win32Error;
                        break;
                    }
                }
            } // end for each object
        } // else an error occurred so unable to call functions
        Win32Error = DeRegisterExtObjListAccess();
        ((PPERF_DATA_BLOCK) lpData)->TotalByteLength = (DWORD)
            ((LPBYTE)lpDataDefinition - (LPBYTE)lpData);    
    }

    return lReturnValue;
}

//***************************************************************************
//
//  CPerfObjectAccess::RemoveClass(IWbemClassObject *pClass)
//
//  removes the class from the access object
//
//***************************************************************************
//
DWORD   
CPerfObjectAccess::RemoveClass(IWbemClassObject *pClass)
{
    CPerfDataLibrary *pLibEntry = NULL;
    CPerfDataLibrary *pThisLibEntry = NULL;
    DWORD           dwIndex = 0;
	DWORD			dwEnd;
    LPWSTR          szRegistryKey = NULL;
    IWbemQualifierSet   *pClassQualifiers = NULL;
    VARIANT         vRegistryKey;
    HRESULT         hRes;
    DWORD           dwReturn = ERROR_SUCCESS;
    DWORD           dwPerfIndex;

    VariantInit (&vRegistryKey);
    // get the Qualifier Set for this class
    hRes = pClass->GetQualifierSet(&pClassQualifiers);
    assert (hRes == 0);
    // now get the library and procedure names
    hRes = pClassQualifiers->Get(CBSTR(cszRegistryKey), 0, &vRegistryKey, 0);
    if ((hRes == 0) && (vRegistryKey.vt == VT_BSTR)) {
        szRegistryKey = Macro_CloneLPWSTR(V_BSTR(&vRegistryKey));
        if (szRegistryKey == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            // now also get the perf index
            VariantClear (&vRegistryKey);
            hRes = pClassQualifiers->Get(CBSTR(cszPerfIndex), 0, &vRegistryKey, 0);
            if (hRes == 0) {
                dwPerfIndex = (DWORD)V_UI4(&vRegistryKey);
            } else {
                // unable to find NtPerfLibrary entry
                dwReturn = ERROR_FILE_NOT_FOUND;
            }
        }
    } else {
        // unable to find NtPerfLibrary entry
        dwReturn = ERROR_FILE_NOT_FOUND;
    }

	if (pClassQualifiers != NULL) pClassQualifiers->Release();

    if (dwReturn == ERROR_SUCCESS) {
        // find matching library in the array
        dwEnd = m_aLibraries.Size();
        if (dwEnd > 0) {
            // walk down the list of libraries
            for (dwIndex = 0; dwIndex < dwEnd; dwIndex++) {
                // see if this library entry is good enough to keep
                // The library is assumed to be a match if the 
                // lib. name and all proc's are the same.
                pThisLibEntry = (CPerfDataLibrary *)m_aLibraries[dwIndex];
                assert (pThisLibEntry != NULL); // it should have been removed!
                // make sure it's complete
                assert (pThisLibEntry->pLibInfo->szServiceName != NULL);

                if (lstrcmpiW (szRegistryKey, pThisLibEntry->pLibInfo->szServiceName) == 0) {
                    pLibEntry = pThisLibEntry;
                    break;
                } else {
                    // wrong library
                    // so continue
                }
            }
        }

        if (pLibEntry != NULL) {
            // close this class & it's library 
            dwReturn = CloseLibrary(pLibEntry);
            if (dwReturn == 0) {
                // then no one wants it
                FREEMEM(m_hObjectHeap, 0, pLibEntry->pLibInfo);
				pLibEntry->pLibInfo = NULL;
                m_aLibraries.RemoveAt(dwIndex);
                m_aLibraries.Compress();
                delete pLibEntry;
            }
            dwReturn = ERROR_SUCCESS;
        } else {
            dwReturn = ERROR_FILE_NOT_FOUND;
        }
    }

	if (szRegistryKey != NULL) delete szRegistryKey;
    VariantClear(&vRegistryKey);

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\refreshr.cpp ===
//***************************************************************************
//
//  (c) 1997-1999 by Microsoft Corp.
//
//  REFRESHR.CPP
//  
//  Mapped NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97   Created.        
//  raymcc      20-Feb-98   Updated to use new initializer.
//  bobw         8-Jub-98   optimized for use with NT Perf counters
//
//***************************************************************************

#include "wpheader.h"
#include <stdio.h>
#include "oahelp.inl"

#define __WBEMSECURITY 1

// HRESULT CNt5PerfProvider::CheckImpersonationLevel (void);
// BOOL CNt5PerfProvider::HasPermission (void);

// Timeout for our wait calls
#define REFRESHER_MUTEX_WAIT_TIMEOUT	10000

class CMutexReleaseMe
{
private:
	HANDLE	m_hMutex;

public:
	CMutexReleaseMe( HANDLE hMutex ) : m_hMutex( hMutex ) {};
	~CMutexReleaseMe()	{ if ( NULL != m_hMutex ) ReleaseMutex( m_hMutex ); };
};

//***************************************************************************
//
//  RefresherCacheEl::RefresherCacheEl
//
//  Constructor
//
//***************************************************************************
// ok
RefresherCacheEl::RefresherCacheEl()
{
    m_dwPerfObjIx = 0;
    m_pClassMap = NULL;
    m_pSingleton = NULL;    
    m_lSingletonId = 0;
    m_plIds = NULL;         // array of ID's
    m_lEnumArraySize = 0;   // size of ID array in elements
    m_pHiPerfEnum = NULL;
    m_lEnumId = 0;
}

//***************************************************************************
//
//  RefresherCacheEl::~RefresherCacheEl()
//
//  Destructor
//
//***************************************************************************
//  ok 
RefresherCacheEl::~RefresherCacheEl()
{
    LONG    nNumInstances;
    int i;

    delete m_pClassMap;

    if (m_pSingleton != NULL) {
        m_pSingleton->Release();
        m_pSingleton = NULL;
        m_lSingletonId = 0;
    }
        
    nNumInstances = m_aInstances.Size();
    for (i = 0; i < nNumInstances; i++) {
        delete (CachedInst *) m_aInstances[i];
    }

    nNumInstances = m_aEnumInstances.Size();
    if (nNumInstances> 0) {
        IWbemObjectAccess   *pAccess;
        for (i = 0;  i < nNumInstances ; i++) {
            pAccess = (IWbemObjectAccess *)(m_aEnumInstances.GetAt(i));
            if (pAccess != NULL) {
                pAccess->Release();
            }
        }
        m_aEnumInstances.Empty();
    }

    if (m_plIds != NULL) {
        delete (m_plIds);
        m_plIds = NULL;
        m_lEnumArraySize = 0;
    }

    if (m_pHiPerfEnum != NULL) {
        m_pHiPerfEnum->Release();
        m_pHiPerfEnum = NULL;
    }
}

//***************************************************************************
//
//  CNt5Refresher constructor
//
//***************************************************************************
// ok
CNt5Refresher::CNt5Refresher(CNt5PerfProvider *pPerfProviderArg)
{
    assert (pPerfProviderArg != NULL);

    m_ClsidType = pPerfProviderArg->m_OriginClsid;
    m_pPerfProvider = pPerfProviderArg;

    m_pPerfProvider = NULL; // for testing of local class map

    if (m_pPerfProvider != NULL) {
        m_pPerfProvider->AddRef();
    }
    m_hAccessMutex = CreateMutex (NULL, TRUE, NULL);
    m_dwGetGetNextClassIndex = 0;
    m_lRef = 0;             // COM Ref Count
    m_lProbableId = 1;      // Used for new IDs
    m_aCache.Empty();       // clear and reset the array
    RELEASE_MUTEX (m_hAccessMutex);
}

//***************************************************************************
//
//  CNt5Refresher destructor
//
//***************************************************************************
// ok
CNt5Refresher::~CNt5Refresher()
{
    int         nNumElements;
    int         i;

    PRefresherCacheEl pCacheEl;

    assert (m_lRef == 0);

	// Make sure we get access to the mutex before we try and clean things up.
	// If we don't get it in a reasonable time, something's up.  Since we're
	// destructing, we'll just quietly let stuff go.

	if ( WaitForSingleObject( m_hAccessMutex, REFRESHER_MUTEX_WAIT_TIMEOUT ) == WAIT_OBJECT_0 )
	{
		// This will auto-release the mutex in case something bad happens
		CMutexReleaseMe	mrm( m_hAccessMutex );

		nNumElements = m_aCache.Size();
		for (i = 0; i < nNumElements; i++) {
			pCacheEl = (PRefresherCacheEl)m_aCache[i];

			// We want to call this once for each instance
			for ( int n = 0; n < pCacheEl->m_aInstances.Size(); n++ )
			{
				m_PerfObj.RemoveClass (pCacheEl->m_pClassMap->m_pClassDef);
			}

			// If we have a Singleton value, RemoveClass should be
			// called once more
			if ( NULL != pCacheEl->m_pSingleton )
			{
				m_PerfObj.RemoveClass (pCacheEl->m_pClassMap->m_pClassDef);
			}

			// And finally if we have an enumerator, remove the class
			// once more.
			if ( NULL != pCacheEl->m_pHiPerfEnum )
			{
				m_PerfObj.RemoveClass (pCacheEl->m_pClassMap->m_pClassDef);
			}

			delete pCacheEl;
		}

		if (m_pPerfProvider != NULL) {
			m_pPerfProvider->Release();
			m_pPerfProvider = NULL;
		}
	}

    CloseHandle (m_hAccessMutex);
}

//***************************************************************************
//
//  CNt5Refresher::Refresh
//
//  Executed to refresh a set of instances bound to the particular 
//  refresher.
//
//***************************************************************************
// ok
HRESULT CNt5Refresher::Refresh(/* [in] */ long lFlags)
{
    HRESULT     hrReturn = WBEM_S_NO_ERROR;
    HRESULT     hReturn = S_OK;    
    BOOL        bRes;

    UNREFERENCED_PARAMETER(lFlags);

    BOOL bNeedCoImpersonate = FALSE;
    
    //
    // this is ugly
    // wmicookr is not impersonating, because
    // it relys on other provider to do that
    // but, it calls the IWbemRefresher::Refresh when it's inside winmgmt or wmiprvse
    // and it calls it from an UN-Impersonated thread
    // so, we need that the provider calls CoImpersonateClient
    // on a Refresh invocation, that is expensive in general,
    // only if the provider has been invoked through the Server CLSID
    //
    BOOL    fRevert;
    if (CNt5PerfProvider::CLSID_SERVER == m_ClsidType)
    {
#ifdef __WBEMSECURITY
	    hReturn = CoImpersonateClient(); // make sure we're legit.

	    fRevert = SUCCEEDED( hReturn );

	    // The following error appears to occur when we are in-proc and there is no
	    // proxy/stub, so we are effectively impersonating already

	    if ( RPC_E_CALL_COMPLETE == hReturn ) {
	        hReturn = S_OK;
	    } 

	    if (S_OK == hReturn) {
	        hReturn = CNt5PerfProvider::CheckImpersonationLevel();
	    }
	    // Check Registry security here.
	    if ((hReturn != S_OK) || (!CNt5PerfProvider::HasPermission())) {
	        // if Impersonation level is incorrect or
	        // the caller doesn't have permission to read
	        // from the registry, then they cannot continue
	        hReturn = WBEM_E_ACCESS_DENIED;
	    }

#else
	    hReturn = S_OK;
#endif
    
    }

    if (hReturn == S_OK)
    {
		// Make sure we get access to the mutex before we continue.  If we can't
		// get to it, something's wrong, so we'll just assume we are busy.

		if ( WaitForSingleObject( m_hAccessMutex, REFRESHER_MUTEX_WAIT_TIMEOUT ) == WAIT_OBJECT_0 )
		{
			// This will auto-release the mutex in case something bad happens
			CMutexReleaseMe	mrm( m_hAccessMutex );

			bRes = PerfHelper::RefreshInstances(this);
			if (!bRes) {
				hrReturn = WBEM_E_FAILED;
			}
		}
		else
		{
			hrReturn = WBEM_E_REFRESHER_BUSY;
		}
	}

    if (CNt5PerfProvider::CLSID_SERVER == m_ClsidType)
    {
#ifdef __WBEMSECURITY
	    // Revert if we successfuly impersonated the user
	    if ( fRevert )
	    {
	        CoRevertToSelf();
	    }
#endif
    }

    
    return hrReturn;
}

//***************************************************************************
//
//  CNt5Refresher::AddRef
//
//  Standard COM AddRef().
//
//***************************************************************************
// ok

ULONG CNt5Refresher::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CNt5Refresher::Release
//
//  Standard COM Release().
//
//***************************************************************************
// ok

ULONG CNt5Refresher::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CNt5Refresher::QueryInterface
//
//  Standard COM QueryInterface().
//
//***************************************************************************
// ok

HRESULT CNt5Refresher::QueryInterface(REFIID riid, void** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IWbemRefresher)
    {
        *ppv = (IWbemRefresher *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

//***************************************************************************
//
//  CNt5Refresher::RemoveObject
//
//  Removes an object from the refresher.   Since we don't know
//  by ID alone which class it is, we loop through all the ones we 
//  have until somebody claims it and returns TRUE for a removal.(
//
//***************************************************************************
// ok
BOOL CNt5Refresher::RemoveObject(LONG lId)
{
    BOOL    bReturn = FALSE;
    BOOL    bRes;
    PRefresherCacheEl pCacheEl;
    int     nNumElements;

	// Make sure we get access to the mutex before we continue.  If we can't
	// get to it, something's wrong, so we'll just assume we are busy.

	if ( WaitForSingleObject( m_hAccessMutex, REFRESHER_MUTEX_WAIT_TIMEOUT ) == WAIT_OBJECT_0 )
	{
		// This will auto-release the mutex in case something bad happens
		CMutexReleaseMe	mrm( m_hAccessMutex );
    
		nNumElements = m_aCache.Size();
		for (int i = 0; i < nNumElements; i++)
		{
			pCacheEl = PRefresherCacheEl(m_aCache[i]);
			assert (pCacheEl != NULL);

			bRes = pCacheEl->RemoveInst(lId);
			if (bRes == TRUE) {
				// found the matching instance so 
				// de register this with the perf library
				m_PerfObj.RemoveClass (pCacheEl->m_pClassMap->m_pClassDef);
				bReturn = TRUE;
				break;
			}
		}
	}
	else
	{
		SetLastError( (ULONG) WBEM_E_REFRESHER_BUSY );
		bReturn = FALSE;
	}
    
    return bReturn;
}

//***************************************************************************
//
//  CNt5Refresher::FindSingletonInst
//
//  Based on a perf object identification, locates a singleton WBEM
//  instance of that class within this refresher and returns the pointer
//  to it and its WBEM class info.
//
//  Note that the <dwPerfObjIx> maps directly to a WBEM Class entry.
//
//  To save execution time, we don't AddRef() the return value and the 
//  caller doesn't Release().
//
//***************************************************************************
// ok
BOOL CNt5Refresher::FindSingletonInst(
    IN  DWORD dwPerfObjIx,
    OUT IWbemObjectAccess **pInst,
    OUT CClassMapInfo **pClsMap
)
{
    BOOL    bReturn = FALSE;
    PRefresherCacheEl pCacheEl;

    int l = 0;
    int u = m_aCache.Size() - 1;
    int m;

    // Binary search the cache.
    // ========================

    while (l <= u) {

        m = (l + u) / 2;

        pCacheEl = PRefresherCacheEl(m_aCache[m]);

        if (dwPerfObjIx < pCacheEl->m_dwPerfObjIx) {
            u = m - 1;
        } else if (dwPerfObjIx > pCacheEl->m_dwPerfObjIx) {
            l = m + 1;
        } else {
            *pClsMap = pCacheEl->m_pClassMap;    
            *pInst = pCacheEl->m_pSingleton; // No AddRef() caller doesn't 
                                             // change ref count
            bReturn = TRUE;
            break;
        }            
    }

    // Not found
    // =========
        
    return bReturn;
}

//***************************************************************************
//
//  CNt5Refresher::FindInst
//
//  Based on a perf object identification, locates a WBEM instance of 
//  that class within this refresher and returns the pointer to it. 
//
//  Note that the <dwPerfObjIx> maps directly to a WBEM Class entry.
//
//  To save execution time, we don't AddRef() the return value and the 
//  caller doesn't Release().
//
//***************************************************************************
// ok

BOOL CNt5Refresher::FindInst(
    IN  DWORD dwPerfObjIx,
    IN  LPWSTR pszInstName,
    OUT IWbemObjectAccess **pInst,
    OUT CClassMapInfo **pClsMap
    )
{
    BOOL    bReturn = FALSE;
    IWbemObjectAccess *pTmp;
    PRefresherCacheEl pCacheEl;

    int l = 0; 
    int u = m_aCache.Size() - 1;
    int m;

    // Binary search the cache.
    // ========================

    while (l <= u) {
        m = (l + u) / 2;

        pCacheEl = PRefresherCacheEl(m_aCache[m]);

        if (dwPerfObjIx < pCacheEl->m_dwPerfObjIx) {
            u = m - 1;
        } else if (dwPerfObjIx > pCacheEl->m_dwPerfObjIx) {
            l = m + 1;
        } else {
            // We found the class.  Now do we have the instance?
            // =================================================
            pTmp = pCacheEl->FindInst(pszInstName);
            if (pTmp == 0) {
                bReturn  = FALSE;   // Didn't have it.
            } else {
                *pInst = pTmp;                
                *pClsMap = pCacheEl->m_pClassMap;    
                bReturn = TRUE;
            }
            break;
        }            
    }

    // Not found
    // =========
        
    return bReturn;
}

//***************************************************************************
//
//  CNt5Refresher::GetObjectIds
//
//  Gets a list of all the perf object Ids corresponding to the instances
//  in the refresher.
//
//  Caller uses operator delete to deallocate the returned array.
//
//***************************************************************************
// ok
BOOL CNt5Refresher::GetObjectIds(
    DWORD *pdwNumIds, 
    DWORD **pdwIdList
)
{
    DWORD *pdwIds;
    int     nNumElements;
    BOOL    bReturn;
 
    nNumElements = m_aCache.Size();

    pdwIds = new DWORD[nNumElements ];

    if (pdwIds != NULL) {
        for (int i = 0; i < nNumElements; i++) {
            pdwIds[i] = PRefresherCacheEl(m_aCache[i])->m_dwPerfObjIx;
        }

        *pdwIdList = pdwIds;
        *pdwNumIds = nNumElements;
        bReturn = TRUE;
    } else {
        // unable to create buffer
        bReturn = FALSE;
    }

    return bReturn;    
}

//***************************************************************************
//
//  CNt5Refresher::FindUnusedId
//
//  Finds an ID not in use for new objects to be added to the refresher.
//
//***************************************************************************
// ok
LONG CNt5Refresher::FindUnusedId()
{
    PRefresherCacheEl pEl;
    PCachedInst pInst;
    int         nRetries = 0x100000;    // A hundred thousand retries
    LONG        lReturn = -1;
    int         i;
    int         i2;
    int         nNumElements;
    int         nNumInstances;
    // assume the object is locked for access
    
    Restart: 
    while (nRetries--) {
        i = 0;
        nNumElements = m_aCache.Size();
        while(i < nNumElements) {
            pEl = PRefresherCacheEl(m_aCache[i]);
            // test enum Id first
            if (pEl->m_lEnumId == m_lProbableId) {
                m_lProbableId++;
                goto Restart;
            }
            i2 = 0;
            nNumInstances = pEl->m_aInstances.Size();
            while (i2 < nNumInstances) {
                pInst = (PCachedInst) pEl->m_aInstances[i2];
                if (pInst->m_lId == m_lProbableId) {
                    m_lProbableId++;
                    goto Restart;
                }
                i2++;
            }           
            i++;
        }            
        
        lReturn = m_lProbableId;
        break;
    }
    
    return lReturn;
}

//***************************************************************************
//
//  RefresherCacheEl::RemoveInst
//
//  Removes the requested instances from the cache element for a particular
//  class.
//
//***************************************************************************
// ok

BOOL RefresherCacheEl::RemoveInst(LONG lId)
{
    BOOL    bReturn = FALSE;
    int i;
    PCachedInst pInst;
    int nNumInstances;

    if (lId == m_lEnumId) {
        // then clean out the enumerator for this object
        nNumInstances = m_aEnumInstances.Size();
        if (nNumInstances> 0) {
            IWbemObjectAccess   *pAccess;
            for (i = 0;  i < nNumInstances ; i++) {
                pAccess = (IWbemObjectAccess *)(m_aEnumInstances.GetAt(i));
                if (pAccess != NULL) {
                    pAccess->Release();
                }
            }
            m_aEnumInstances.Empty();
        }

        if (m_plIds != NULL) {
            delete (m_plIds);
            m_plIds = NULL;
            m_lEnumArraySize = 0;
        }

        if (m_pHiPerfEnum != NULL) {
            m_pHiPerfEnum->Release();
            m_pHiPerfEnum = NULL;
        }

        // Now, if this is a singleton (m_pSingleton != NULL),
        // then check if m_aInstances is empty.  If so, then
        // no instances are referencing the singleton object
        // so we can free up its resources.

        if ( NULL != m_pSingleton && 0 == m_aInstances.Size() )
        {
            m_pSingleton->Release();
            m_pSingleton = NULL;
        }

        return TRUE;
    } else {
        // walk the instances to find a match
        nNumInstances = m_aInstances.Size();
        for (i = 0; i < nNumInstances; i++) {
            pInst = (PCachedInst) m_aInstances[i];        
            if (lId == pInst->m_lId) {
                delete pInst;
                m_aInstances.RemoveAt(i);
                bReturn = TRUE;
                break;
            }
        }

        // Now, if we removed an instance, m_aInstances is empty
        // and this is a singleton (m_pSingleton != NULL), then
        // check if m_pHiPerfEnum is NULL, meaning no Enumerator
        // exists, so none of its instances will be referencing
        // the singleton object, so we can free up its resources.

        if (    NULL != m_pSingleton
            &&  bReturn
            &&  0 == m_aInstances.Size()
            &&  NULL == m_pHiPerfEnum )
        {
            m_pSingleton->Release();
            m_pSingleton = NULL;
        }

        if ( bReturn )
        {
        }
    }
    return bReturn;
}

//***************************************************************************
//
//  CNt5Refresher::AddEnum
//
//  Creates an enumerator for the specified class
//  to it.
//  
//***************************************************************************
// ?
BOOL CNt5Refresher::AddEnum (
        IN  IWbemHiPerfEnum *pEnum,     // enum interface pointer
        IN  CClassMapInfo *pClsMap,     // Class of object
        OUT LONG    *plId               // id for new enum
)
{
    BOOL bRes = FALSE;
    LONG lStatus;
    LONG lNewId;
    PRefresherCacheEl pWorkEl;
    int  iReturn;

	// Make sure we get access to the mutex before we continue.  If we can't
	// get to it, something's wrong, so we'll just assume we are busy.

	if ( WaitForSingleObject( m_hAccessMutex, REFRESHER_MUTEX_WAIT_TIMEOUT ) == WAIT_OBJECT_0 )
	{
		// This will auto-release the mutex in case something bad happens
		CMutexReleaseMe	mrm( m_hAccessMutex );

		lNewId = FindUnusedId();
    
		if (lNewId != -1) {
			// First, find the cache element corresponding to this object.
			// ===========================================================
			pWorkEl = GetCacheEl(pClsMap);
    
			// If <pWorkEl> is NULL, we didn't have anything in the cache
			// and have to add a new one.
			// ==========================================================

			if (pWorkEl == NULL) {
				bRes = AddNewCacheEl(pClsMap, &pWorkEl);
			}    

			if (pWorkEl != NULL) {
				if (pWorkEl->m_pHiPerfEnum == NULL) {
					// then we can init it as it hasn't been opened
					pEnum->AddRef();
					pWorkEl->m_pHiPerfEnum = pEnum;
					pWorkEl->m_lEnumId = lNewId;

					assert (pWorkEl->m_aEnumInstances.Size() == 0L);
					bRes = TRUE;

					if (pClsMap->IsSingleton()) {
						LONG    lNumObjInstances;
						// then create the singleton IWbemObjectAccess entry here

						lNumObjInstances = 1;

						// If we do NOT have a singleton pointer, make it so.
						if ( NULL == pWorkEl->m_pSingleton )
						{
							// add the new IWbemObjectAccess pointers
							IWbemClassObject    *pClsObj;
        
							pWorkEl->m_pClassMap->m_pClassDef->SpawnInstance(0, &pClsObj);
							pClsObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pWorkEl->m_pSingleton);
							pClsObj->Release(); // We only need the IWbemObjectAccess pointer

							// We don't really care about the singleton id anymore
							// pWorkEl->m_lSingletonId = pWorkEl->m_plIds[0];

						}

						if (pWorkEl->m_aEnumInstances.Size() < lNumObjInstances) {
							// alloc and init the ID array
							if (pWorkEl->m_plIds != NULL) {
								delete (pWorkEl->m_plIds);
							}
                    
							pWorkEl->m_lEnumArraySize = lNumObjInstances;
							pWorkEl->m_plIds = new LONG[lNumObjInstances];

                            if (pWorkEl->m_plIds != NULL) {
							    pWorkEl->m_plIds[0] = 0;
                        
							    // AddRef the singleton class and place it in the enuminstances array
							    pWorkEl->m_pSingleton->AddRef();
							    iReturn = pWorkEl->m_aEnumInstances.Add (pWorkEl->m_pSingleton);
                                if (iReturn == CFlexArray::no_error) {
					    		    // Add the singleton object to the enumerator.  Then, all we have to
						    	    // do is update this object and we will, by default update the
							        // enumerator, since the number of objects in it will always
							        // be one.

							        pWorkEl->m_pHiPerfEnum->AddObjects( 
									        0,
									        1,
									        pWorkEl->m_plIds,
									        (IWbemObjectAccess __RPC_FAR *__RPC_FAR *)pWorkEl->m_aEnumInstances.GetArrayPtr());
                                }
                                else {
                                    SetLastError((ULONG) WBEM_E_OUT_OF_MEMORY);
                                    bRes = FALSE;
                                }

                            } else {
                                SetLastError ((ULONG)WBEM_E_OUT_OF_MEMORY);
                                bRes = FALSE;
                            }
						}
						assert (pWorkEl->m_aEnumInstances.Size() >= lNumObjInstances);

					}

					// load provider library since all went OK so far
					lStatus = m_PerfObj.AddClass (pClsMap->m_pClassDef, FALSE);
					if (lStatus == ERROR_SUCCESS) {
						// return new ID & successful status 
						*plId = lNewId;
						bRes = TRUE;
					} else {
						// set error: Class or library failed to load
						SetLastError ((ULONG)WBEM_E_PROVIDER_FAILURE);
						bRes = FALSE;
					}
				} else {
					// this class already has an enumerator
					// what to do here? 
					// for now we'll return the id of the existing one
					SetLastError ((ULONG)WBEM_E_ILLEGAL_OPERATION);
					bRes = FALSE;
				}
			}
		}

	}	// IF WaitForSingleObject
	else
	{
		bRes = FALSE;
		// We're locked out of the mutex
		SetLastError ((ULONG)WBEM_E_REFRESHER_BUSY);
	}

    return bRes;
}

//***************************************************************************
//
//  CNt5Refresher::AddObject
//
//  Adds the requested object to the refresher and assigns an ID
//  to it.
//  
//***************************************************************************
// ?
BOOL CNt5Refresher::AddObject(
    IN  IWbemObjectAccess **ppObj,    // Object to add
    IN  CClassMapInfo   *pClsMap,   // Class of object
    OUT LONG            *plId       // The id of the object added
)
{
    BOOL bRes = FALSE;
    LONG lStatus;
    LONG lNewId;
    PRefresherCacheEl pWorkEl;

	// Make sure we get access to the mutex before we continue.  If we can't
	// get to it, something's wrong, so we'll just assume we are busy.

	if ( WaitForSingleObject( m_hAccessMutex, REFRESHER_MUTEX_WAIT_TIMEOUT ) == WAIT_OBJECT_0 )
	{
		// This will auto-release the mutex in case something bad happens
		CMutexReleaseMe	mrm( m_hAccessMutex );

		lNewId = FindUnusedId();
    
		if (lNewId != -1) {
			// First, find the cache element corresponding to this object.
			// ===========================================================
			pWorkEl = GetCacheEl(pClsMap);
    
			// If <pWorkEl> is NULL, we didn't have anything in the cache
			// and have to add a new one.
			// ==========================================================

			if (pWorkEl == NULL) {
				bRes = AddNewCacheEl(pClsMap, &pWorkEl);
			}    

			if (pWorkEl != NULL) {
				// If here, we have successfully added a new cache element.
				// ========================================================
				bRes = pWorkEl->InsertInst(ppObj, lNewId);

				if (bRes) {
					// load provider library since all went OK so far
					lStatus = m_PerfObj.AddClass (pClsMap->m_pClassDef, FALSE);

					if (lStatus == ERROR_SUCCESS) {
						// return new ID & successful status 
						*plId = lNewId;
						bRes = TRUE;
					} else {
						// set error: Class or library failed to load
						SetLastError ((ULONG)WBEM_E_PROVIDER_FAILURE);
						bRes = FALSE;
					}
				}
			}
		}

	}	// IF acquired mutex
	else
	{
		bRes = FALSE;
		// Return a busy error
		SetLastError ((ULONG)WBEM_E_REFRESHER_BUSY);
	}

    return bRes;
}

//***************************************************************************
//
//  CNt5Refresher::AddNewCacheEl
//
//  Adds a new cache element in the proper position so that a binary
//  search on perf object id can occur later.
//
//***************************************************************************
// ok
BOOL CNt5Refresher::AddNewCacheEl(
    IN CClassMapInfo *pClsMap, 
    PRefresherCacheEl *pOutput
    )
{
    // assumes the object is locked for access

    PRefresherCacheEl pWorkEl;
    PRefresherCacheEl pNew = 0;

    int i;
    int nNumElements;
    BOOL bReturn = FALSE;

    * pOutput = NULL;
    pNew = new RefresherCacheEl;

    if (pNew != NULL) {
        pNew->m_dwPerfObjIx = pClsMap->GetObjectId();
        pNew->m_pClassMap = pClsMap->CreateDuplicate();

        if (pNew->m_pClassMap != NULL) {
            nNumElements = m_aCache.Size();
            for (i = 0; i < nNumElements; i++) {
                // walk through the list of cache elements
                // and find the first entry that has a 
                // larger index then the one we are adding
                pWorkEl = PRefresherCacheEl(m_aCache[i]);
                if (pNew->m_dwPerfObjIx < pWorkEl->m_dwPerfObjIx) {
                    m_aCache.InsertAt(i, pNew);
                    *pOutput = pNew;
                    bReturn = TRUE;
                    break;
                }
            }

            if (i == nNumElements) {
                // this entry is larger than anyone in the list
                // so Add it to the end.
                // =====-===============
                m_aCache.Add(pNew);    
                *pOutput = pNew;
                bReturn = TRUE;
            }
        }
        else {
            // cannot duplicate ClassMap,
            // delte allocated object and return false
            delete pNew;
        }

    } else {
        // return false
    } 

    return bReturn;
}    

//***************************************************************************
//
//  CNt5Refresher::GetCacheEl
//
//***************************************************************************
// ok
PRefresherCacheEl CNt5Refresher::GetCacheEl(
    CClassMapInfo *pClsMap
)
{
    // assumes the structure is locked for access
    PRefresherCacheEl pReturn = NULL;
    PRefresherCacheEl pWorkEl;
    int i;
    int nNumElements;
    DWORD   dwObjectIdToFind;

    if (pClsMap != NULL) {
        dwObjectIdToFind = pClsMap->GetObjectId();
        nNumElements = m_aCache.Size();
        for (i = 0; i < nNumElements; i++) {
            pWorkEl = PRefresherCacheEl(m_aCache[i]);
            if (pWorkEl->m_pClassMap->GetObjectId() == dwObjectIdToFind) {
                pReturn = pWorkEl;
                break;
            }
        }        
    }

    return pReturn;
}    

//***************************************************************************
//
//  RefresherCacheEl::FindInstance
//
//  Finds an instance in the current cache element for a particular instance.
//  For this to work, the instances have to be sorted by name.
//  
//***************************************************************************
// ok
IWbemObjectAccess *RefresherCacheEl::FindInst(
    LPWSTR pszInstName
    )
{
    // Binary search the cache.
    // ========================

    int l = 0;
    int u = m_aInstances.Size() - 1;
    int m;
    CachedInst *pInst;

    while (l <= u) {
        m = (l + u) / 2;

        pInst = PCachedInst(m_aInstances[m]);

        if (_wcsicmp(pszInstName, pInst->m_pName) < 0) {
            u = m - 1;
        } else if (_wcsicmp(pszInstName, pInst->m_pName) > 0) {
            l = m + 1;
        } else  {
            // We found the instance. 
            // ======================
            return pInst->m_pInst;            
        }            
    }

    // Not found
    // =========
        
    return NULL;
}    

//***************************************************************************
//
//  Inserts a new instance.
//
//***************************************************************************
//
BOOL RefresherCacheEl::InsertInst(IWbemObjectAccess **ppNew, LONG lNewId)
{
    // Save the value passed in
    IWbemObjectAccess*  pNew = *ppNew;

    IWbemClassObject *pObj;
    VARIANT         v;
    PCachedInst     pNewInst;
    DWORD           dwInstanceNameLength;
    PCachedInst     pTest;
    BOOL            bReturn = FALSE;
    HRESULT         hRes;
    int             nNumInstances;

    // Check for singleton.
    // ====================
    if (m_pClassMap->IsSingleton()) {

        // If we don't already have an object, use the one passed in.  Otherwise
        // we will replace it.

        if ( NULL == m_pSingleton )
        {
            m_pSingleton = pNew;
            m_pSingleton->AddRef();
            // We don't really need the id anymore
            // m_lSingletonId = lNewId;
        }
        else
        {
            // Now we're sneaking around by replacing *ppNew with the
            // singleton we already have.  We must release *ppNew in
            // order to get away with this.

            (*ppNew)->Release();

            // We need to AddRef() this because *ppNew is now referencing it
            m_pSingleton->AddRef();
            *ppNew = m_pSingleton;
            pNew = m_pSingleton;
        }

        // Now we will Add this instance just like any other

        pNewInst = new CachedInst;
//        assert (pNewInst != NULL);

        if ( pNewInst != NULL )
        {
            // For singletons, none of the other pointers
            // should matter.

            pNewInst->m_lId = lNewId;
            pNewInst->m_pInst = pNew;
            pNewInst->m_pInst->AddRef();

            // We are saving the name just to be safe (It will
            // really only be an "@", and I don't believe it
            // will be accessed anywhere else.  I hope...)
            pNewInst->m_pName = Macro_CloneLPWSTR(L"@");
//            assert (pNewInst->m_pName != NULL);

            if ( NULL != pNewInst->m_pName )
            {
                // We can just add this in, since any entries will all be the
                // same anyway.

                m_aInstances.Add(pNewInst);    
                bReturn = TRUE;
            }
            else    // Memory Allocation failed
            {
                bReturn = FALSE;
                SetLastError ((DWORD)WBEM_E_OUT_OF_MEMORY);
                delete(pNewInst);
            }

        }
        else    // Memory allocation failed
        {
            bReturn = FALSE;
            SetLastError ((DWORD)WBEM_E_OUT_OF_MEMORY);
        }

    } else {
        VariantInit(&v);
   
        // For multi-instance, get the instance name.
        // ==========================================
        hRes = pNew->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
        assert (hRes == NO_ERROR);

        if (hRes == NO_ERROR) {
            hRes = pObj->Get(CBSTR(cszName), 0, &v, 0, 0);
            assert (hRes == NO_ERROR);
            if (hRes == NO_ERROR) {
                if (v.vt == VT_BSTR) {
                    bReturn = TRUE;
                } else {
                    bReturn = FALSE;
                    // the object passed in should have an instance name
                    SetLastError ((DWORD)WBEM_E_INVALID_OBJECT_PATH);
                }
            }

            pObj->Release();
    
            if (bReturn) {
                // Construct the new instance.
                // ===========================
                pNewInst = new CachedInst;
//                assert (pNewInst != NULL);

                if (pNewInst != NULL) {
                    pNewInst->m_lId = lNewId;
                    pNewInst->m_pInst = pNew;
                    pNewInst->m_pInst->AddRef();
                    pNewInst->m_pName = Macro_CloneLPWSTR(V_BSTR(&v));
//                    assert (pNewInst->m_pName != NULL);

                    if (pNewInst->m_pName != NULL) {
                        dwInstanceNameLength = lstrlenW (pNewInst->m_pName) + 1;

                        // parse the instance string now to save processing time later
                        pNewInst->m_szParentName = new WCHAR[dwInstanceNameLength]; 
//                        assert (pNewInst->m_szParentName != NULL);

                        pNewInst->m_szInstanceName = new WCHAR[dwInstanceNameLength];
//                        assert (pNewInst->m_szInstanceName != NULL);

                        if ((pNewInst->m_szParentName != NULL) &&
                            (pNewInst->m_szInstanceName != NULL)) {

                            // break the instance name into components
                            bReturn = PerfHelper::ParseInstanceName (pNewInst->m_pName,
                                pNewInst->m_szInstanceName,
                                pNewInst->m_szParentName ,
                                &pNewInst->m_dwIndex);
    
                            if (bReturn) {
                                bReturn = FALSE;    // to prime it.
                                // Now place the name in the instance cache element.
                                // =================================================
                                nNumInstances = m_aInstances.Size();
                                for (int i = 0; i < nNumInstances; i++) {
                                    // see if it belongs in the list
                                    pTest = PCachedInst(m_aInstances[i]);        
                                    if (_wcsicmp(V_BSTR(&v), pTest->m_pName) < 0) {
                                        m_aInstances.InsertAt(i, pNewInst);
                                        bReturn = TRUE;
                                        // once it's been added, 
                                        // there's no point in continuing
                                        break; 
                                    }
                                }

                                if (!bReturn) {
                                    // this goes at the end of the list
                                    m_aInstances.Add(pNewInst);    
                                    bReturn = TRUE;
                                } else {
                                    // unable to create instance
                                    SetLastError ((DWORD)WBEM_E_INVALID_OBJECT_PATH);
                                }
                            }
                        }
                        // clean up if there's an error
                        if (!bReturn) {
                            if (pNewInst->m_szParentName != NULL) {
                                delete (pNewInst->m_szParentName);
                            }
                            if (pNewInst->m_szInstanceName != NULL) {
                                delete pNewInst->m_szInstanceName;
                            }
                            delete (pNewInst->m_pName);
                            bReturn = FALSE;
                            delete (pNewInst);
                        }
                    } else {
                        // unable to alloc memory
                        bReturn = FALSE;
                        SetLastError ((DWORD)WBEM_E_OUT_OF_MEMORY);
                        delete (pNewInst);
                    }
                } else {
                    // unable to alloc memory
                    bReturn = FALSE;
                    SetLastError ((DWORD)WBEM_E_OUT_OF_MEMORY);
                }
            } else {
                // return FALSE
            }
        } else {
            // return FALSE
        }
        VariantClear(&v);
    }
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\server.cpp ===
//***************************************************************************
//
//  Copyright (c) 1997-1999, Microsoft Corporation, All rights reserved
//
//  SERVER.CPP
//
//  Generic COM server framework, adapted for the NT perf counter sample
//
//  This module contains nothing specific to the NT perf counter provider
//  except what is defined in the section bracketed by the CLSID SPECIFIC
//  comments below.
//
//  History:
//  raymcc        25-Nov-97     Created.
//  raymcc        18-Feb-98     Updated for NT5 Beta 2 version.
//
//***************************************************************************
#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <objbase.h>
#include <initguid.h>
/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//
#pragma warning ( disable : 4268)
#include <wbemidl.h>
#pragma warning ( default : 4268)
#include <wbemint.h>
#include "ntperf.h"
#include "strings.h"

//
//  this is going to be the ClientLoadable one
//

// {FF37A93C-C28E-11d1-AEB6-00C04FB68820}
DEFINE_GUID(CLSID_NT5PerfProvider_V1,
0xff37a93c, 0xc28e, 0x11d1, 0xae, 0xb6, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);

//
// this is going to be the Server Loadable
//

// {76A94DE3-7C26-44f5-8E98-C5AEA48186CB}
DEFINE_GUID(CLSID_NT5PerfProvider_V1_Srv, 
0x76a94de3, 0x7c26, 0x44f5, 0x8e, 0x98, 0xc5, 0xae, 0xa4, 0x81, 0x86, 0xcb);


#define IMPLEMENTED_CLSID_1         CLSID_NT5PerfProvider_V1
#define IMPLEMENTED_CLSID_2         CLSID_NT5PerfProvider_V1_Srv 
#define SERVER_REGISTRY_COMMENT     cszOleRegistryComment
#define CPP_CLASS_NAME              CNt5PerfProvider
#define INTERFACE_CAST              (IWbemHiPerfProvider *)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////




HINSTANCE g_hInstance;
static ULONG g_cLock = 0;

void ObjectCreated()    { g_cLock++; }
void ObjectDestroyed() { g_cLock--; }

//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//***************************************************************************

class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};

//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    UNREFERENCED_PARAMETER(lpReserved);

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************
extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (IMPLEMENTED_CLSID_1 != rclsid &&
        IMPLEMENTED_CLSID_2 != rclsid) 
            return ResultFromScode(E_FAIL);

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    //
    // Get a new class factory.
    //
    pFactory = new CFactory(rclsid);

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    //
    // Verify we can get an instance.
    //
    HRESULT hRes = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hRes))
        delete pFactory;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cLock)
        sc = S_FALSE;

    return sc;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];
    HKEY hKey;
    LONG lRes;
    wchar_t *pName;
    HKEY hSubkey;
    
    // Where are we?
    // =============
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    StringFromCLSID(IMPLEMENTED_CLSID_1, &pGuidStr);
    swprintf(KeyPath, cszClsidFormatString, pGuidStr);

    lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    pName = (LPWSTR)SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, (DWORD)(((DWORD)(wcslen(pName)) + 1) * 2));


    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, (DWORD)(((DWORD)(wcslen(Path)) + 1) * 2));
    RegSetValueExW(hSubkey, cszThreadingModel, 0, REG_SZ, (const BYTE *) cszBoth, (DWORD)(((DWORD)(wcslen(cszBoth)) + 1) * 2));

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1_Srv : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1_Srv\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================    

    StringFromCLSID(IMPLEMENTED_CLSID_2, &pGuidStr);
    swprintf(KeyPath, cszClsidFormatString, pGuidStr);

    lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    pName = (LPWSTR)SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, (DWORD)(((DWORD)(wcslen(pName)) + 1) * 2));

    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, (DWORD)(((DWORD)(wcslen(Path)) + 1) * 2));
    RegSetValueExW(hSubkey, cszThreadingModel, 0, REG_SZ, (const BYTE *) cszBoth, (DWORD)(((DWORD)(wcslen(cszBoth)) + 1) * 2));

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];
    LONG lRes;

    // Delete InProcServer32 subkey.
    // =============================
    // Delete CLSID GUID key.
    // ======================
    
    StringFromCLSID(IMPLEMENTED_CLSID_1, &pGuidStr);
    swprintf(KeyPath, cszClsidFormatString, pGuidStr);

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, cszInprocServer);
    RegCloseKey(hKey);

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, cszClsidKey, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    StringFromCLSID(IMPLEMENTED_CLSID_2, &pGuidStr);
    swprintf(KeyPath, cszClsidFormatString, pGuidStr);

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, cszInprocServer);
    RegCloseKey(hKey);

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, cszClsidKey, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//  PARAMETERS:
//
//      const CLSID & ClsId     The CLSID. 
//
//***************************************************************************
CFactory::CFactory(const CLSID & ClsId)
{
    m_cRef = 0;
    ObjectCreated();
    m_ClsId = ClsId;
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
CFactory::~CFactory()
{
    ObjectDestroyed();
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


ULONG CFactory::AddRef()
{
    return ++m_cRef;
}


ULONG CFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CFactory::CreateInstance
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//      
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    if (m_ClsId == IMPLEMENTED_CLSID_1) {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME(CPP_CLASS_NAME::CLSID_CLIENT);
    } else if (m_ClsId == IMPLEMENTED_CLSID_2) {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME(CPP_CLASS_NAME::CLSID_SERVER);
    } else {
		pObj = NULL;
	}

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\strings.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    central definition file of common static strings
    these strings SHOULD NOT be localized as they are internal
    to the program and not intended for any display to the user

--*/

#include "windows.h"

#ifdef __cplusplus
extern "C" {
#endif

// single character constants
#define wcSpace     L' '
#define wcSlash     L'/'
#define wcPoundSign L'#'
#define wc_0        L'0'
#define wc_a        L'a'
#define wc_A        L'A'
#define wc_E        L'E'
#define wc_F        L'F'
#define wc_P        L'P'
#define wc_R        L'R'
#define wc_z        L'z'
   
// OLE and  Registry strings
extern LPCWSTR cszOleRegistryComment;
extern LPCWSTR cszClsidFormatString;
extern LPCWSTR cszThreadingModel;
extern LPCWSTR cszInprocServer;
extern LPCWSTR cszClsidKey;
extern LPCWSTR cszPerflibKey;
extern LPCWSTR cszDLLValue;
extern LPCWSTR cszObjListValue;
extern LPCWSTR cszLinkageKey;
extern LPCWSTR cszExportValue;
extern LPCWSTR cszOpenTimeout;
extern LPCWSTR cszCollectTimeout;
extern LPCWSTR cszExtCounterTestLevel;
extern LPCWSTR cszOpenProcedureWaitTime;
extern LPCWSTR cszLibraryUnloadTime;
extern LPCWSTR cszKeepResident;
extern LPCWSTR cszDisablePerformanceCounters;
extern LPCWSTR cszProviderName;
extern LPCWSTR cszHklmServicesKey;
extern LPCWSTR cszPerformance;
extern LPCWSTR cszGlobal;
extern LPCWSTR cszForeign;
extern LPCWSTR cszCostly;
extern LPCWSTR cszCounter;
extern LPCWSTR cszExplain;
extern LPCWSTR cszHelp;
extern LPCWSTR cszAddCounter;
extern LPCWSTR cszAddHelp;
extern LPCWSTR cszOnly;
extern LPCWSTR cszBoth;

extern LPCSTR  caszOpenValue;
extern LPCSTR  caszCloseValue;
extern LPCSTR  caszCollectValue;
extern LPCSTR  caszQueryValue;

// "well known" property names
extern LPCWSTR cszPropertyCount;
extern LPCWSTR cszClassName;
extern LPCWSTR cszName;
extern LPCWSTR cszTimestampPerfTime;
extern LPCWSTR cszFrequencyPerfTime;
extern LPCWSTR cszTimestampSys100Ns;
extern LPCWSTR cszFrequencySys100Ns;
extern LPCWSTR cszTimestampObject;
extern LPCWSTR cszFrequencyObject;

// "well known" qualifier names
extern LPCWSTR cszPerfIndex;
extern LPCWSTR cszSingleton;
extern LPCWSTR cszCountertype;
extern LPCWSTR cszProvider;
extern LPCWSTR cszRegistryKey;

// other random strings
extern LPCWSTR cszSpace;
extern LPCWSTR cszSlash;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\strings.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    strings.cpp

Abstract:

    central definition file of common static strings
    these strings SHOULD NOT be localized as they are internal
    to the program and not intended for any display to the user

--*/

#include "strings.h"

// OLE and  Registry strings
LPCWSTR cszOleRegistryComment   = L"WBEM NT5 Base Perf Provider";
LPCWSTR cszClsidFormatString    = L"Software\\Classes\\CLSID\\\\%s";
LPCWSTR cszThreadingModel       = L"ThreadingModel";
LPCWSTR cszInprocServer         = L"InprocServer32";
LPCWSTR cszClsidKey             = L"Software\\Classes\\CLSID";
LPCWSTR cszPerflibKey           = L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR cszDLLValue             = L"Library";
LPCWSTR cszObjListValue         = L"Object List";
LPCWSTR cszLinkageKey           = L"\\Linkage";
LPCWSTR cszExportValue          = L"Export";
LPCWSTR cszOpenTimeout          = L"Open Timeout";
LPCWSTR cszCollectTimeout       = L"Collect Timeout";
LPCWSTR cszExtCounterTestLevel  = L"ExtCounterTestLevel";
LPCWSTR cszOpenProcedureWaitTime = L"OpenProcedureWaitTime";
LPCWSTR cszLibraryUnloadTime    = L"Library Unload Time";
LPCWSTR cszKeepResident         = L"Keep Library Resident";
LPCWSTR cszDisablePerformanceCounters = L"Disable Performance Counters";
LPCWSTR cszProviderName         = L"NT5_GenericPerfProvider_V1";
LPCWSTR cszHklmServicesKey      = L"SYSTEM\\CurrentControlSet\\Services";
LPCWSTR cszPerformance          = L"\\Performance";
LPCWSTR cszGlobal               = L"Global";
LPCWSTR cszForeign              = L"FOREIGN";
LPCWSTR cszCostly               = L"COSTLY";
LPCWSTR cszCounter              = L"COUNTER";
LPCWSTR cszExplain              = L"EXPLAIN";
LPCWSTR cszHelp                 = L"HELP";
LPCWSTR cszAddCounter           = L"ADDCOUNTER";
LPCWSTR cszAddHelp              = L"ADDEXPLAIN";
LPCWSTR cszOnly                 = L"ONLY";
LPCWSTR cszBoth                 = L"Both";

LPCSTR  caszOpenValue           = "Open";
LPCSTR  caszCloseValue          = "Close";
LPCSTR  caszCollectValue        = "Collect";
LPCSTR  caszQueryValue          = "Query";

// "well known" property names
LPCWSTR cszPropertyCount        = L"__PROPERTY_COUNT";
LPCWSTR cszClassName            = L"__CLASS";
LPCWSTR cszName                 = L"Name";
LPCWSTR cszTimestampPerfTime    = L"Timestamp_PerfTime";
LPCWSTR cszFrequencyPerfTime    = L"Frequency_PerfTime";
LPCWSTR cszTimestampSys100Ns    = L"Timestamp_Sys100NS";
LPCWSTR cszFrequencySys100Ns    = L"Frequency_Sys100NS";
LPCWSTR cszTimestampObject      = L"Timestamp_Object";
LPCWSTR cszFrequencyObject      = L"Frequency_Object";

// "well known" qualifier names
LPCWSTR cszPerfIndex            = L"PerfIndex";
LPCWSTR cszSingleton            = L"Singleton";
LPCWSTR cszCountertype          = L"countertype";
LPCWSTR cszProvider             = L"Provider";
LPCWSTR cszRegistryKey          = L"registrykey";

// other random strings
LPCWSTR cszSpace                = L" ";
LPCWSTR cszSlash                = L"/";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\utils.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1998-1999   Microsoft Corporation

Module Name:

    utils.c

Abstract:

        Utility functions used by the performance library functions

Author:

    Russ Blake  11/15/91

Revision History:
    8-Jun-98    bobw    revised for use with WBEM functions

--*/
#define UNICODE
//
//  Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
//#include <prflbmsg.h>
//#include <regrpc.h>
#include "PerfAcc.h"
#include "strings.h"
#include "utils.h"
#include "wbprfmsg.h"
// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < '0') ? INVALID : \
     (c > '9') ? INVALID : \
     DIGIT)

// the length of "ADDEXPLAIN" in chars
#define MAX_KEYWORD_LEN     10

// minimum length to hold a value name understood by Perflib
// "foreign" is the longest "string" value understood

const   DWORD VALUE_NAME_LENGTH = ((7 + 1) * sizeof(WCHAR));

HANDLE hEventLog = NULL;

static WCHAR    LocalComputerName[MAX_PATH];
static LPWSTR   pComputerName = &LocalComputerName[0];
static DWORD    ComputerNameLength = 0;

BOOL
MonBuildPerfDataBlock(
    PERF_DATA_BLOCK *pBuffer,
    PVOID *pBufferNext,
    DWORD NumObjectTypes,
    DWORD DefaultObject
)
/*++

    MonBuildPerfDataBlock -     build the PERF_DATA_BLOCK structure

        Inputs:

            pBuffer         -   where the data block should be placed

            pBufferNext     -   where pointer to next byte of data block
                                is to begin; DWORD aligned

            NumObjectTypes  -   number of types of objects being reported

            DefaultObject   -   object to display by default when
                                this system is selected; this is the
                                object type title index
--*/

{

    LARGE_INTEGER Time, TimeX10000;

    // Initialize Signature and version ID for this data structure

    pBuffer->Signature[0] = wc_P;
    pBuffer->Signature[1] = wc_E;
    pBuffer->Signature[2] = wc_R;
    pBuffer->Signature[3] = wc_F;

    pBuffer->LittleEndian = 1;

    pBuffer->Version = PERF_DATA_VERSION;
    pBuffer->Revision = PERF_DATA_REVISION;

    //
    //  The next field will be filled in at the end when the length
    //  of the return data is known
    //

    pBuffer->TotalByteLength = 0;

    pBuffer->NumObjectTypes = NumObjectTypes;
    pBuffer->DefaultObject = DefaultObject;
    GetSystemTime(&pBuffer->SystemTime);
    NtQueryPerformanceCounter(&pBuffer->PerfTime,&pBuffer->PerfFreq);

    TimeX10000.QuadPart = pBuffer->PerfTime.QuadPart * 10000L;
    Time.QuadPart = TimeX10000.QuadPart / pBuffer->PerfFreq.LowPart;
    pBuffer->PerfTime100nSec.QuadPart = Time.QuadPart * 1000L;

    if ( ComputerNameLength == 0) {
        // load the name
        ComputerNameLength = sizeof (LocalComputerName) / sizeof(LocalComputerName[0]);
        if (!GetComputerNameW(pComputerName, &ComputerNameLength)) {
            // name look up failed so reset length
            ComputerNameLength = 0;
        }
        assert (ComputerNameLength > 0);
    }

    //  There is a Computer name: i.e., the network is installed

    pBuffer->SystemNameLength = ComputerNameLength;
    pBuffer->SystemNameOffset = sizeof(PERF_DATA_BLOCK);
    RtlMoveMemory(&pBuffer[1],
           pComputerName,
           ComputerNameLength);
    *pBufferNext = (PVOID) ((PCHAR) &pBuffer[1] +
                            QWORD_MULTIPLE(ComputerNameLength));
    pBuffer->HeaderLength = (DWORD)((PCHAR) *pBufferNext - (PCHAR) pBuffer);

    return 0;
}

//
//  Perflib functions:
//
LONG
GetPerflibKeyValue (
    LPCWSTR szItem,
    DWORD   dwRegType,
    DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    LPVOID  pReturnBuffer,
    DWORD   dwDefaultSize,  // ... of pDefault in bytes
    LPVOID  pDefault
)
/*++

    read and return the current value of the specified value
    under the Perflib registry key. If unable to read the value
    return the default value from the argument list.

    the value is returned in the pReturnBuffer.

--*/
{

    HKEY                    hPerflibKey;
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    UNICODE_STRING          PerflibSubKeyString;
    UNICODE_STRING          ValueNameString;
    LONG                    lReturn = STATUS_SUCCESS;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInformation;
    ULONG                   ValueBufferLength;
    ULONG                   ResultLength;
    BOOL                    bUseDefault = TRUE;

    // initialize UNICODE_STRING structures used in this function

    RtlInitUnicodeString (
        &PerflibSubKeyString,
        cszPerflibKey);

    RtlInitUnicodeString (
        &ValueNameString,
        (LPWSTR)szItem);

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //
    InitializeObjectAttributes(
            &Obja,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerflibKey,
                KEY_READ,
                &Obja
                );

    if (NT_SUCCESS( Status )) {
        // read value of desired entry

        ValueBufferLength = ResultLength = 1024;
        pValueInformation = ALLOCMEM(RtlProcessHeap(), 0, ResultLength);

        if (pValueInformation != NULL) {
            while ( (Status = NtQueryValueKey(hPerflibKey,
                                            &ValueNameString,
                                            KeyValuePartialInformation,
                                            pValueInformation,
                                            ValueBufferLength,
                                            &ResultLength))
                    == STATUS_BUFFER_OVERFLOW ) {

                pValueInformation = REALLOCMEM(RtlProcessHeap(), 0,
                                                        pValueInformation,
                                                        ResultLength);
                if ( pValueInformation == NULL) {
                    break;
                } else {
                    ValueBufferLength = ResultLength;
                }
            }

            if (NT_SUCCESS(Status)) {
                // check to see if it's the desired type
                if (pValueInformation->Type == dwRegType) {
                    // see if it will fit
                    if (pValueInformation->DataLength <= dwMaxSize) {
                        memcpy (pReturnBuffer, &pValueInformation->Data[0],
                            pValueInformation->DataLength);
                        bUseDefault = FALSE;
                        lReturn = STATUS_SUCCESS;
                    }
                }
            } else {
                // return the default value
                lReturn = Status;
            }
            // release temp buffer
            if (pValueInformation) {
                FREEMEM (RtlProcessHeap(), 0, pValueInformation);
            }
        } else {
            // unable to allocate memory for this operation so
            // just return the default value
        }
        // close the registry key
        NtClose(hPerflibKey);
    } else {
        // return default value
    }

    if (bUseDefault) {
        memcpy (pReturnBuffer, pDefault, dwDefaultSize);
        lReturn = STATUS_SUCCESS;
    }

    return lReturn;
}

#pragma warning ( disable : 4127)   // while (TRUE) error
BOOL
MatchString (
    IN LPCWSTR lpValueArg,
    IN LPCWSTR lpNameArg
)
/*++

MatchString

    return TRUE if lpName is in lpValue.  Otherwise return FALSE

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

    IN lpName
        string for one of the keyword names

Return TRUE | FALSE

--*/
{
    BOOL    bFound      = TRUE; // assume found until contradicted
    LPWSTR  lpValue     = (LPWSTR)lpValueArg;
    LPWSTR  lpName      = (LPWSTR)lpNameArg;

    // check to the length of the shortest string

    while (1) {
        if (*lpValue != 0) {
            if (*lpName != 0) {
                if (*lpValue++ != *lpName++) {
                    bFound = FALSE; // no match
                    break;          // bail out now
                }
            } else {
                // the value still has characters, but the name is out
                // so this is no match
                bFound = FALSE;
                break;
            }
        } else {
            if (*lpName != 0) {
                // then the value is out of characters, but the name
                // is out so no match
                bFound = FALSE;
                break;
            } else {
                // both strings are at the end so it must be a match
            }
        }
    }

    return (bFound);
}
#pragma warning ( default : 4127)   // while (TRUE) error

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    QUERY_COUNTER
        if lpValue == pointer to "Counter" string

    QUERY_HELP
        if lpValue == pointer to "Explain" string

    QUERY_ADDCOUNTER
        if lpValue == pointer to "Addcounter" string

    QUERY_ADDHELP
        if lpValue == pointer to "Addexplain" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   LocalBuff[MAX_KEYWORD_LEN+1];
    int     i;

    if ((lpValue == 0 || *lpValue == 0))
        return QUERY_GLOBAL;

    // convert the input string to Upper case before matching
    for (i=0; i < MAX_KEYWORD_LEN; i++) {
        if ((*lpValue == wcSpace) || (*lpValue == 0)) {
            break;
        }
        LocalBuff[i] = *lpValue ;
        if (*lpValue >= wc_a && *lpValue <= wc_z) {
            LocalBuff[i]  = (WCHAR)(LocalBuff[i] - (WCHAR)wc_a + (WCHAR)wc_A);
        }
        lpValue++ ;
    }
    LocalBuff[i] = 0;

    // check for "Global" request
    if (MatchString (LocalBuff, cszGlobal))
        return QUERY_GLOBAL ;

    // check for "Foreign" request
    if (MatchString (LocalBuff, cszForeign))
        return QUERY_FOREIGN ;

    // check for "Costly" request
    if (MatchString (LocalBuff, cszCostly))
        return QUERY_COSTLY;

    // check for "Counter" request
    if (MatchString (LocalBuff, cszCounter))
        return QUERY_COUNTER;

    // check for "Help" request
    if (MatchString (LocalBuff, cszHelp))
        return QUERY_HELP;

    if (MatchString (LocalBuff, cszExplain))
        return QUERY_HELP;

    // check for "AddCounter" request
    if (MatchString (LocalBuff, cszAddCounter))
        return QUERY_ADDCOUNTER;

    // check for "AddHelp" request
    if (MatchString (LocalBuff, cszAddHelp))
        return QUERY_ADDHELP;

    // None of the above, then it must be an item list
    return QUERY_ITEMS;

}

#pragma warning ( disable : 4127)   // while (TRUE) error
DWORD
GetNextNumberFromList (
    IN LPWSTR   szStartChar,
    IN LPWSTR   *szNextChar
)
/*++

 Reads a character string from the szStartChar to the next
 delimiting space character or the end of the string and returns
 the value of the decimal number found. If no valid number is found
 then 0 is returned. The pointer to the next character in the
 string is returned in the szNextChar parameter. If the character
 referenced by this pointer is 0, then the end of the string has
 been reached.

--*/
{
    DWORD   dwThisNumber    = 0;
    WCHAR   *pwcThisChar    = szStartChar;
    WCHAR   wcDelimiter     = wcSpace;
    BOOL    bValidNumber    = FALSE;

    if (szStartChar != 0) {
        while (TRUE) {
            switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
                case DIGIT:
                    // if this is the first digit after a delimiter, then
                    // set flags to start computing the new number
                    bValidNumber = TRUE;
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - wc_0);
                    break;

                case DELIMITER:
                    // a delimter is either the delimiter character or the
                    // end of the string ('\0') if when the delimiter has been
                    // reached a valid number was found, then return it
                    //
                    if (bValidNumber || (*pwcThisChar == 0)) {
                        *szNextChar = pwcThisChar;
                        return dwThisNumber;
                    } else {
                        // continue until a non-delimiter char or the
                        // end of the file is found
                    }
                    break;

                case INVALID:
                    // if an invalid character was encountered, ignore all
                    // characters up to the next delimiter and then start fresh.
                    // the invalid number is not compared.
                    bValidNumber = FALSE;
                    break;

                default:
                    break;

            }
            pwcThisChar++;
        }
    } else {
        *szNextChar = szStartChar;
        return 0;
    }
}
#pragma warning ( default : 4127)   // while (TRUE) error

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;

    while (*pwcThisChar != 0) {
        dwThisNumber = GetNextNumberFromList (
            pwcThisChar, &pwcThisChar);
        if (dwNumber == dwThisNumber) return TRUE;
    }
    // if here, then the number wasn't found
    return FALSE;

}   // IsNumberInUnicodeList

LPWSTR
ConvertProcName(LPSTR strProcName)
{
    static WCHAR  wstrProcName[MAX_PATH];
    ULONG  lenProcName = (strProcName == NULL) ? (0) : (lstrlenA(strProcName));
    ULONG  i;
    PUCHAR AnsiChar;

    if ((lenProcName == 0) || (lenProcName >= MAX_PATH)) {
        return (LPWSTR) cszSpace;
    }

    for (i = 0; i < lenProcName; i ++) {
        AnsiChar = (PUCHAR) & strProcName[i];
        wstrProcName[i] = (WCHAR) RtlAnsiCharToUnicodeChar(& AnsiChar);
    }
    wstrProcName[lenProcName] = L'\0';
    return wstrProcName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\wpheader.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    wpheader.h

Abstract:

    <abstract>

--*/

#include    <windows.h>
#include    <wbemidl.h>
#include    <wbemint.h>
#include    "classmap.h"
#include    "flexarry.h"
#include    "ntperf.h"
#include    "PerfAcc.h"
#include    "refreshr.h"
#include    "perfhelp.h"
#include    "strings.h"
#include    "utils.h"
#include    "wbprfmsg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\utils.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    <abstract>

--*/

#ifndef _WBEMPERF_UTILS_H_
#define _WBEMPERF_UTILS_H_

#ifdef __cplusplus

/*
#define Macro_CloneLPWSTR(x) \
    (x ? wcscpy(new wchar_t[wcslen(x) + 1], x) : 0)
*/
__inline wchar_t* Macro_CloneLPWSTR(wchar_t *x)
{
    wchar_t *s;
    if (!x) return NULL;
    s = new wchar_t[wcslen(x) + 1];
    if (!s) return NULL;
    return wcscpy(s, x);
}

extern "C" {
#endif

#include <windows.h>
#include <winperf.h>

#ifndef _OUTPUT_DEBUG_STRINGS
#define _OUTPUT_DEBUG_STRINGS 0
#endif

#ifndef _DEBUG_MUTEXES
#define _DEBUG_MUTEXES 0	// for debugging locks
#endif // _DEBUG_MUTEXES undefined

extern HANDLE hEventLog;

#define ALLOCMEM(heap, flags, size)     HeapAlloc (heap, flags, size)
#define REALLOCMEM(heap, flags, pointer, newsize) \
                                    HeapReAlloc(heap, flags, pointer, newsize)
#define FREEMEM(heap, flags, pointer)   HeapFree (heap, flags, pointer)

// convert mS to relative time
#define MakeTimeOutValue(ms) ((LONGLONG)((LONG)(ms) * -10000L))

#define CLOSE_WAIT_TIME     5000L   // wait time for query mutex (in ms)
#define QUERY_WAIT_TIME     2000L    // wait time for query mutex (in ms)
#define OPEN_PROC_WAIT_TIME 10000L  // default wait time for open proc to finish (in ms)

// query types

#define QUERY_GLOBAL       1
#define QUERY_ITEMS        2
#define QUERY_FOREIGN      3
#define QUERY_COSTLY       4
#define QUERY_COUNTER      5
#define QUERY_HELP         6
#define QUERY_ADDCOUNTER   7
#define QUERY_ADDHELP      8

extern const   WCHAR GLOBAL_STRING[];
extern const   WCHAR COSTLY_STRING[];

extern const   DWORD VALUE_NAME_LENGTH;

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes)
#define ALIGN_ON_DWORD(x) ((VOID *)(((DWORD_PTR)x & 3) ? (((DWORD_PTR)x & ~3) + 4) : ((DWORD_PTR)x)))

#define QWORD_MULTIPLE(x) (((x+sizeof(LONGLONG)-1)/sizeof(LONGLONG))*sizeof(LONGLONG))

//    (assumes quadword is 8 bytes)
#define ALIGN_ON_QWORD(x) ((VOID *)(((DWORD_PTR)x & 7) ? (((DWORD_PTR)x & ~7) + 8) : ((DWORD_PTR)x)))

//
// function prototypes
//
BOOL
MonBuildPerfDataBlock(
    PERF_DATA_BLOCK *pBuffer,
    PVOID *pBufferNext,
    DWORD NumObjectTypes,
    DWORD DefaultObject
);


LONG
GetPerflibKeyValue (
    LPCWSTR szItem,
    DWORD   dwRegType,
    DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    LPVOID  pReturnBuffer,
    DWORD   dwDefaultSize,  // ... of pDefault in bytes
    LPVOID  pDefault
);

BOOL
MatchString (
    IN LPCWSTR lpValueArg,
    IN LPCWSTR lpNameArg
);


DWORD
GetQueryType (
    IN LPWSTR lpValue
);

DWORD
GetNextNumberFromList (
    IN LPWSTR   szStartChar,
    IN LPWSTR   *szNextChar
);

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
);

LPWSTR
ConvertProcName(
    IN LPSTR strProcName
);

#if _DEBUG_MUTEXES
#include <stdio.h>
__inline
void
PdhiLocalWaitForMutex (
	LPCSTR	szSourceFileName,
	DWORD	dwLineNo,
	HANDLE	hMutex
)
{
	DWORD	dwReturnValue;
    CHAR    szOutputString[MAX_PATH];
	FILETIME	ft;
	
	if (hMutex != NULL) {
		GetSystemTimeAsFileTime (&ft);
		dwReturnValue = WaitForSingleObject (hMutex, 10000);
		sprintf (szOutputString, "\n[%8.8x] Mutex [%8.8x] %s by (%d) at: %s (%d)",
			ft.dwLowDateTime,
			(DWORD)hMutex,
			(dwReturnValue == 0 ? "Locked" : "Lock Failed"),
			GetCurrentThreadId(),
			szSourceFileName, dwLineNo);
	} else {
		sprintf (szOutputString, "\nLock of NULL Mutex attmpted at: %s (%d)",
			szSourceFileName, dwLineNo);
	}
	OutputDebugStringA (szOutputString);
}

#define WAIT_FOR_AND_LOCK_MUTEX(h) PdhiLocalWaitForMutex (__FILE__, __LINE__, h);

__inline
void
PdhiLocalReleaseMutex (
	LPCSTR	szSourceFileName,
	DWORD	dwLineNo,
	HANDLE	hMutex
)
{
	BOOL	bSuccess;
    CHAR    szOutputString[MAX_PATH];
	LONG	lPrevCount = 0;
	FILETIME	ft;

	if (hMutex != NULL) {
		GetSystemTimeAsFileTime (&ft);
		bSuccess = ReleaseMutex (hMutex);
		sprintf (szOutputString, "\n[%8.8x] Mutex [%8.8x] %s by (%d) at: %s (%d)",
			ft.dwLowDateTime,
			(DWORD)hMutex,
			(bSuccess ? "Released" : "Release Failed"),
			GetCurrentThreadId(),
			szSourceFileName, dwLineNo);
	} else {
		sprintf (szOutputString, "\nRelease of NULL Mutex attempted at: %s (%d)",
			szSourceFileName, dwLineNo);
	}
    OutputDebugStringA (szOutputString);
}

#define RELEASE_MUTEX(h)  PdhiLocalReleaseMutex (__FILE__, __LINE__, h);
#else
// 10 second wait timeout
#define WAIT_FOR_AND_LOCK_MUTEX(h) (h != NULL ? WaitForSingleObject(h, 10000) : WAIT_TIMEOUT)
#define RELEASE_MUTEX(h)  (h != NULL ? ReleaseMutex(h) : FALSE)
#endif

__inline
DWORD
RegisterExtObjListAccess ()
{
#if 0
    LONG    Status;

    if (hGlobalDataMutex != NULL) {
        // wait for access to the list of ext objects
        Status = WaitForSingleObject (
            hGlobalDataMutex,
			QUERY_WAIT_TIME);
        if (Status != WAIT_TIMEOUT) {
            if (hExtObjListIsNotInUse != NULL) {
                // indicate that we are going to use the list
                InterlockedIncrement (&dwExtObjListRefCount);
                if (dwExtObjListRefCount > 0) {
                    ResetEvent (hExtObjListIsNotInUse); // indicate list is busy
                } else {
                    SetEvent (hExtObjListIsNotInUse); // indicate list is not busy
                }
                Status = ERROR_SUCCESS;
            } else {
                Status = ERROR_NOT_READY;
            }
            ReleaseMutex (hGlobalDataMutex);
        }  // else return status;
    } else {
        Status = ERROR_LOCK_FAILED;
    }
    return Status;
#else
	return ERROR_SUCCESS;
#endif
}


__inline
DWORD
DeRegisterExtObjListAccess ()
{
#if 0
    LONG    Status;

    if (hGlobalDataMutex != NULL) {
        // wait for access to the list of ext objects
        Status = WaitForSingleObject (
            hGlobalDataMutex, QUERY_WAIT_TIME);
        if (Status != WAIT_TIMEOUT) {
            if (hExtObjListIsNotInUse != NULL) {
                assert (dwExtObjListRefCount > 0);
                // indicate that we are going to use the list
                InterlockedDecrement (&dwExtObjListRefCount);
                if (dwExtObjListRefCount > 0) {
                    ResetEvent (hExtObjListIsNotInUse); // indicate list is busy
                } else {
                    SetEvent (hExtObjListIsNotInUse); // indicate list is not busy
                }
                Status = ERROR_SUCCESS;
            } else {
                Status = ERROR_NOT_READY;
            }
            ReleaseMutex (hGlobalDataMutex);
        }  // else return status;
    } else {
        Status = ERROR_LOCK_FAILED;
    }
    return Status;
#else
	return ERROR_SUCCESS;
#endif
}


#ifdef __cplusplus
}
#endif

#endif //_PERFLIB_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\wbemperf\wpheader.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    wpheader.cpp

Abstract:

    <abstract>

--*/

#include "wpheader.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlcnfig\makefile.inc ===
pdlcnfig.hlp: hlp\pdlcnfig.hlp
    copy hlp\pdlcnfig.hlp .
    binplace pdlcnfig.hlp

pdlcnfig.cnt: hlp\pdlcnfig.cnt
    copy hlp\pdlcnfig.cnt .
    binplace pdlcnfig.cnt



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlcnfig\common.h ===
/*
    Performance Logging Service common definitions file
*/

#ifndef _PERFLOG_COMMON_H_
#define _PERFLOG_COMMON_H_

// common definitions

#if UNICODE
#define     _ultot      _ultow
#define     _ltot       _ltow
#else // not UNICODE
#define     _ultot      _ultoa
#define     _ltot       _ltoa
#endif

// PSM_QUERYSIBLING message parameters

// WPARAM arguments
#define PDLCNFIG_PSM_QS_LISTBOX_STARS	1
#define PDLCNFIG_PSM_QS_WILDCARD_LOG	2
#define PDLCNFIG_PSM_QS_ARE_YOU_READY	3

// return values for ...LISTBOX_STARS
#define	PDLCNFIG_LISTBOX_STARS_DONT_KNOW	0
#define PDLCNFIG_LISTBOX_STARS_YES			1
#define PDLCNFIG_LISTBOX_STARS_NO			2

// return values for ...WILDCARD_LOG
#define PDLCNFIG_WILDCARD_LOG_DONT_KNOW		0
#define PDLCNFIG_WILDCARD_LOG_YES			1
#define PDLCNFIG_WILDCARD_LOG_NO			2


// output file configuration definitions

#define OPD_CSV_FILE        0
#define OPD_TSV_FILE        1
#define OPD_BIN_FILE        2
#define OPD_NUM_FILE_TYPES  3

#define OPD_NAME_MMDDHH     0
#define OPD_NAME_NNNNNN     1
#define OPD_NAME_YYDDD      2
#define OPD_NAME_YYMM       3
#define OPD_NAME_YYMMDD     4
#define OPD_NAME_YYMMDDHH   5

#define OPD_RENAME_HOURS    0
#define OPD_RENAME_DAYS     1
#define OPD_RENAME_MONTHS   2
#define OPD_RENAME_KBYTES   3
#define OPD_RENAME_MBYTES   4

// settings page

// sample interval units combo box settings
#define    SIU_SECONDS      0
#define    SIU_MINUTES      1
#define    SIU_HOURS        2
#define    SIU_DAYS         3

#define SECONDS_IN_DAY      86400
#define SECONDS_IN_HOUR      3600
#define SECONDS_IN_MINUTE      60

#define LOG_SERV_START      1
#define LOG_SERV_STOP       2
#define LOG_SERV_PAUSE      4
#define LOG_SERV_RESUME     8

// alarm configuration and setting information

// alarm configuration flags

#define ALERT_FLAGS_OVER_THRESHOLD      (DWORD)0x00000001
#define ALERT_FLAGS_UNDER_THRESHOLD     (DWORD)0x00000002
#define ALERT_FLAGS_THRESHOLD_MASK      (DWORD)0x00000003

#define ALERT_FLAGS_EXECUTE_PROGRAM     (DWORD)0x00000010
#define ALERT_FLAGS_TEXT_LOG            (DWORD)0x00000020
#define ALERT_FLAGS_EVENT_LOG           (DWORD)0x00000040
#define ALERT_FLAGS_NET_MESSAGE         (DWORD)0x00000080

#define ALERT_FLAGS_FIRST_TIME          (DWORD)0x00000100
#define ALERT_FLAGS_EVERY_TIME          (DWORD)0x00000200

#define ALERT_FLAGS_NAME_PARAM          (DWORD)0x00001000
#define ALERT_FLAGS_VALUE_PARAM         (DWORD)0x00002000
#define ALERT_FLAGS_THRESHOLD_PARAM     (DWORD)0x00004000
#define ALERT_FLAGS_TIME_PARAM          (DWORD)0x00008000

#define ALERT_FLAGS_INFO                (DWORD)0x00010000
#define ALERT_FLAGS_WARNING             (DWORD)0x00020000
#define ALERT_FLAGS_ERROR               (DWORD)0x00030000
#define ALERT_FLAGS_SEVERITY_SHIFT      (DWORD)16L
#define ALERT_FLAGS_SEVERITY_MASK       (DWORD)0x00030000

#define ALERT_FLAGS_DELETE              (DWORD)0x40000000
#define ALERT_FLAGS_ALERTED             (DWORD)0x80000000

typedef struct _ALERT_CONFIG_INFO_W {
    DWORD   dwTotalSize;
    HKEY    hKeyCounter;
    LONG    lEditIndex;
    LPWSTR  szCounterPath;
    LPWSTR  szCommandLine;
    LPWSTR  szNetName;
    DWORD   dwAlertFlags;
    DWORD   dwThresholdValue;
} ALERT_CONFIG_INFO_W, FAR * LPALERT_CONFIG_INFO_W;

typedef struct _ALERT_CONFIG_INFO_A {
    DWORD   dwTotalSize;
    HKEY    hKeyCounter;
    LONG    lEditIndex;
    LPSTR   szCounterPath;
    LPSTR   szCommandLine;
    LPSTR   szNetName;
    DWORD   dwAlertFlags;
    DWORD   dwThresholdValue;
} ALERT_CONFIG_INFO_A, FAR * LPALERT_CONFIG_INFO_A;

#ifdef UNICODE 
#define ALERT_CONFIG_INFO   ALERT_CONFIG_INFO_W
#define LPALERT_CONFIG_INFO LPALERT_CONFIG_INFO_W
#else
#define ALERT_CONFIG_INFO   ALERT_CONFIG_INFO_A
#define LPALERT_CONFIG_INFO LPALERT_CONFIG_INFO_A
#endif

#define KEY_BS_CHAR TEXT('|')
#define BS_CHAR     TEXT('\\')
#define KEY_GT_CHAR TEXT('>')
#define KEY_LT_CHAR TEXT('<')

#endif //_PERFLOG_COMMON_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlcnfig\outpage.h ===
// OutPage.h : header file
//
#include "common.h"
/////////////////////////////////////////////////////////////////////////////
// COutputPropPage dialog

class COutputPropPage : public CPropertyPage
{
    DECLARE_DYNCREATE(COutputPropPage)

// Construction
public:
    COutputPropPage();
    ~COutputPropPage();

// Dialog Data
    //{{AFX_DATA(COutputPropPage)
	enum { IDD = IDD_OUTPUT_PAGE };
    CString     m_OutputFileName;
    DWORD       m_RenameInterval;
    CString     m_BaseFileName;
    int         m_AutoNameIndex;
    int         m_LogFileTypeIndex;
    int         m_RenameUnitsIndex;
    CString     m_szLogDirectory;
	CString		m_szCmdFilename;
	int			m_ExecuteCmd;
	//}}AFX_DATA


	BOOL		IsWildcardLogFileType (void);
// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(COutputPropPage)
	public:
    virtual void OnCancel();
    virtual void OnOK();
    virtual BOOL OnQueryCancel();
	virtual BOOL OnKillActive();
	protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(COutputPropPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnAutomaticName();
    afx_msg void OnManualName();
    afx_msg void OnSelchangeAutoNameCombo();
    afx_msg void OnChangeBaseFilenameEdit();
    afx_msg void OnBrowseOutputFile();
    afx_msg void OnSelchangeLogFiletype();
    afx_msg void OnSelchangeRenameUnits();
    afx_msg void OnDeltaposSpinRenameInterval(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChangeOutputFileEdit();
    afx_msg void OnChangeRenameInterval();
    afx_msg void OnUpdateBaseFilenameEdit();
	afx_msg void OnBrowseFolder();
	afx_msg void OnExecuteCheck();
	afx_msg void OnBrowseCmdFile();
	afx_msg void OnChangeCmdFilename();
	//}}AFX_MSG
	afx_msg LRESULT OnQuerySiblings (WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()

	void InitDialogData(void);
    void AutoManualEnable (BOOL bAutomatic);
    void UpdateSampleFilename();
    BOOL IsDirPathValid (LPCTSTR szPath, 
                         BOOL bLastNameIsDirectory, 
                         BOOL bCreateMissingDirs);


    HKEY m_hKeyLogSettingsDefault;
    HKEY m_hKeyLogSettings;
    HKEY m_hKeyLogService;
    BOOL m_bFileNameChanged;
	BOOL m_bInitialized;
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlcnfig\outpage.cpp ===
// OutPage.cpp : implementation file
//

#include "stdafx.h"
#include "pdlcnfig.h"
#include "common.h"
#include "OutPage.h"

#ifndef _tsplitpath
#if _MBCS
#define _tsplitpath        _splitpath
#else
#define _tsplitpath        _wsplitpath
#endif
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COutputPropPage property page

IMPLEMENT_DYNCREATE(COutputPropPage, CPropertyPage)

COutputPropPage::COutputPropPage() : CPropertyPage(COutputPropPage::IDD)
{
    //{{AFX_DATA_INIT(COutputPropPage)
    m_OutputFileName = _T("");
    m_RenameInterval = 0;
    m_BaseFileName = _T("");
    m_AutoNameIndex = -1;
    m_LogFileTypeIndex = -1;
    m_RenameUnitsIndex = -1;
    m_szLogDirectory = _T("");
	m_szCmdFilename = _T("");
	m_ExecuteCmd = 0;
	//}}AFX_DATA_INIT
    m_hKeyLogSettingsDefault = NULL;
    m_hKeyLogSettings = NULL;
    m_hKeyLogService = NULL;
    m_bFileNameChanged = NULL;
	m_bInitialized = FALSE;
}

COutputPropPage::~COutputPropPage()
{
    if (m_hKeyLogSettingsDefault != NULL) RegCloseKey(m_hKeyLogSettingsDefault);
    if (m_hKeyLogSettings != NULL) RegCloseKey(m_hKeyLogSettings);
    if (m_hKeyLogService != NULL) RegCloseKey(m_hKeyLogService);
}

void COutputPropPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(COutputPropPage)
    DDX_Text(pDX, IDC_OUTPUT_FILE_EDIT, m_OutputFileName);
    DDV_MaxChars(pDX, m_OutputFileName, 260);
    DDX_Text(pDX, IDC_RENAME_INTERVAL, m_RenameInterval);
    DDV_MinMaxDWord(pDX, m_RenameInterval, 0, 99999);
    DDX_Text(pDX, IDC_BASE_FILENAME_EDIT, m_BaseFileName);
    DDV_MaxChars(pDX, m_BaseFileName, 260);
    DDX_CBIndex(pDX, IDC_AUTO_NAME_COMBO, m_AutoNameIndex);
    DDX_CBIndex(pDX, IDC_LOG_FILETYPE, m_LogFileTypeIndex);
    DDX_CBIndex(pDX, IDC_RENAME_UNITS, m_RenameUnitsIndex);
    DDX_Text(pDX, IDC_LOG_DIRECTORY, m_szLogDirectory);
    DDV_MaxChars(pDX, m_szLogDirectory, 260);
	DDX_Text(pDX, IDC_CMD_FILENAME, m_szCmdFilename);
	DDV_MaxChars(pDX, m_szCmdFilename, 260);
	DDX_Check(pDX, IDC_EXECUTE_CHECK, m_ExecuteCmd);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(COutputPropPage, CPropertyPage)
    //{{AFX_MSG_MAP(COutputPropPage)
    ON_BN_CLICKED(IDC_AUTOMATIC_NAME, OnAutomaticName)
    ON_BN_CLICKED(IDC_MANUAL_NAME, OnManualName)
    ON_CBN_SELCHANGE(IDC_AUTO_NAME_COMBO, OnSelchangeAutoNameCombo)
    ON_EN_CHANGE(IDC_BASE_FILENAME_EDIT, OnChangeBaseFilenameEdit)
    ON_BN_CLICKED(IDC_BROWSE_OUTPUT_FILE, OnBrowseOutputFile)
    ON_CBN_SELCHANGE(IDC_LOG_FILETYPE, OnSelchangeLogFiletype)
    ON_CBN_SELCHANGE(IDC_RENAME_UNITS, OnSelchangeRenameUnits)
    ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_RENAME_INTERVAL, OnDeltaposSpinRenameInterval)
    ON_EN_CHANGE(IDC_OUTPUT_FILE_EDIT, OnChangeOutputFileEdit)
    ON_EN_CHANGE(IDC_RENAME_INTERVAL, OnChangeRenameInterval)
    ON_EN_UPDATE(IDC_BASE_FILENAME_EDIT, OnUpdateBaseFilenameEdit)
	ON_BN_CLICKED(IDC_BROWSE_FOLDER, OnBrowseFolder)
	ON_BN_CLICKED(IDC_EXECUTE_CHECK, OnExecuteCheck)
	ON_BN_CLICKED(IDC_BROWSE_CMD_FILE, OnBrowseCmdFile)
	ON_EN_CHANGE(IDC_CMD_FILENAME, OnChangeCmdFilename)
	//}}AFX_MSG_MAP
	ON_MESSAGE (PSM_QUERYSIBLINGS, OnQuerySiblings)
END_MESSAGE_MAP()

void COutputPropPage::InitDialogData (void)
{
    LONG    lStatus = ERROR_INVALID_FUNCTION;

    DWORD   dwRegValType;
    DWORD   dwRegValue;
    DWORD   dwRegValueSize;

    CString csTempFilePath;

    TCHAR   szRegString[MAX_PATH];
    TCHAR   szDriveName[MAX_PATH];

    BOOL    bAutoMode = FALSE;

	if (m_bInitialized) return;

	if (m_hKeyLogService == NULL) {
	    // open registry key to service
		lStatus = RegOpenKeyEx (
			HKEY_LOCAL_MACHINE,
			TEXT("SYSTEM\\CurrentControlSet\\Services\\PerfDataLog"),
			0,
			KEY_READ | KEY_WRITE,
			&m_hKeyLogService);
	}

	if ((m_hKeyLogSettings == NULL) &&
        (m_hKeyLogService != NULL)) {
		// open registry to log query info
		lStatus = RegOpenKeyEx (
			m_hKeyLogService,
			TEXT("Log Queries"),
			0,
			KEY_READ | KEY_WRITE,
			&m_hKeyLogSettings);
	}

	if ((m_hKeyLogSettingsDefault == NULL) &&
        (m_hKeyLogSettings != NULL)) {
		// open registry to default log query
		lStatus = RegOpenKeyEx (
			m_hKeyLogSettings,
			TEXT("Default"),
			0,
			KEY_READ | KEY_WRITE,
			&m_hKeyLogSettingsDefault);
	}

    if (lStatus != ERROR_SUCCESS) {
        return;
        // display error, close dialog and exit
    }
    // continue

  	if (m_LogFileTypeIndex == -1) {
		// read log file format
		dwRegValType = 0;
		dwRegValue = 0;
		dwRegValueSize = sizeof(DWORD);
		lStatus = RegQueryValueEx (
			m_hKeyLogSettingsDefault,
			TEXT("Log File Type"),
			NULL,
			&dwRegValType,
			(LPBYTE)&dwRegValue,
			&dwRegValueSize);
		if (lStatus != ERROR_SUCCESS) {
			// then apply default value
			dwRegValue = OPD_CSV_FILE;
		}

		m_LogFileTypeIndex = dwRegValue;
	}

	if (m_RenameInterval == 0) {
		// set default mode
		dwRegValType = 0;
		dwRegValue = 0;
		dwRegValueSize = sizeof(DWORD);
		lStatus = RegQueryValueEx (
			m_hKeyLogSettingsDefault,
			TEXT("Auto Name Interval"),
			NULL,
			&dwRegValType,
			(LPBYTE)&dwRegValue,
			&dwRegValueSize);

		if (lStatus != ERROR_SUCCESS) {
			// then apply default value
			dwRegValue = 0; // manual naming is the default
		} else if (dwRegValType != REG_DWORD) {
			// then apply default value
			dwRegValue = 0; // manual naming is the default
		} // else assume it was OK

		if (dwRegValue == 0) {
			// initialize the rest of the manual name field(s)
			dwRegValType = 0;
			dwRegValueSize = MAX_PATH * sizeof(TCHAR);
			memset (szRegString, 0, dwRegValueSize);
			lStatus = RegQueryValueEx (
				m_hKeyLogSettingsDefault,
				TEXT("Log Filename"),
				NULL,
				&dwRegValType,
				(LPBYTE)&szRegString[0],
				&dwRegValueSize);

			if (lStatus != ERROR_SUCCESS) {
				// apply default name
				lstrcpy (szRegString, TEXT("perfdata."));
				switch (m_LogFileTypeIndex) {
				case OPD_TSV_FILE:
					lstrcat (szRegString, TEXT("tsv"));
					break;

				case OPD_BIN_FILE:
					lstrcat (szRegString, TEXT("blg"));
					break;

				case (OPD_CSV_FILE):
				default:
					lstrcat (szRegString, TEXT("csv"));
					break;
				}
			}
			// if the filename doesn't specify a directory, then use the
			csTempFilePath = szRegString;

			_tsplitpath ((LPCTSTR)csTempFilePath, szDriveName, szRegString,
				NULL, NULL);
			if ((lstrlen(szDriveName) == 0) && (lstrlen(szRegString) == 0)) {
				// default log file directory
				dwRegValType = 0;
				dwRegValueSize = MAX_PATH * sizeof(TCHAR);
				memset (szRegString, 0, dwRegValueSize);
				lStatus = RegQueryValueEx (
					m_hKeyLogSettingsDefault,
					TEXT("Log Default Directory"),
					NULL,
					&dwRegValType,
					(LPBYTE)&szRegString[0],
					&dwRegValueSize);

				if (lStatus != ERROR_SUCCESS) {
					// try to use the general default
					dwRegValType = 0;
					dwRegValueSize = MAX_PATH * sizeof(TCHAR);
					memset (szRegString, 0, dwRegValueSize);
					lStatus = RegQueryValueEx (
						m_hKeyLogSettings,
						TEXT("Log Default Directory"),
						NULL,
						&dwRegValType,
						(LPBYTE)&szRegString[0],
						&dwRegValueSize);

					if (lStatus != ERROR_SUCCESS) {
						// apply the default then since we can't find it
						// in the registry anywhere
						lstrcpy (szRegString, TEXT("c:\\perflogs"));
					}
				}
				// szRegString should have a valid path here
				m_szLogDirectory = szRegString;    // load default dir for auto section
				m_OutputFileName = szRegString;
				m_OutputFileName += TEXT ("\\");
			} else {
				m_szLogDirectory = szDriveName;
				// the file parsing function leaves the trailing backslash
				// so remove it before concatenating it.
				if (szRegString[lstrlen(szRegString)-1] == TEXT('\\')) {
					szRegString[lstrlen(szRegString)-1] = 0;
				}
				m_szLogDirectory += szRegString;
				m_OutputFileName.Empty();
			}
			m_OutputFileName += csTempFilePath;

			// set auto combo boxes to default values

			m_BaseFileName = TEXT("perfdata");
			m_AutoNameIndex = OPD_NAME_YYMMDD;
			m_RenameUnitsIndex = OPD_RENAME_DAYS;
			m_RenameInterval = 1;

			bAutoMode = FALSE;
		} else {
			m_RenameInterval = dwRegValue;
			// get values for controls
			dwRegValType = 0;
			dwRegValueSize = MAX_PATH * sizeof(TCHAR);
			memset (szRegString, 0, dwRegValueSize);
			lStatus = RegQueryValueEx (
				m_hKeyLogSettingsDefault,
				TEXT("Log Default Directory"),
				NULL,
				&dwRegValType,
				(LPBYTE)&szRegString[0],
				&dwRegValueSize);

			if (lStatus != ERROR_SUCCESS) {
				// try to use the general default
				dwRegValType = 0;
				dwRegValueSize = MAX_PATH * sizeof(TCHAR);
				memset (szRegString, 0, dwRegValueSize);
				lStatus = RegQueryValueEx (
					m_hKeyLogSettings,
					TEXT("Log Default Directory"),
					NULL,
					&dwRegValType,
					(LPBYTE)&szRegString[0],
					&dwRegValueSize);

				if (lStatus != ERROR_SUCCESS) {
					// apply the default then since we can't find it
					// in the registry anywhere
					lstrcpy (szRegString, TEXT("c:\\perflogs"));
				}
			}
			// szRegString should have a valid path here
			m_szLogDirectory = szRegString;

			// base filename
			dwRegValType = 0;
			dwRegValueSize = MAX_PATH * sizeof(TCHAR);
			memset (szRegString, 0, dwRegValueSize);
			lStatus = RegQueryValueEx (
				m_hKeyLogSettingsDefault,
				TEXT("Base Filename"),
				NULL,
				&dwRegValType,
				(LPBYTE)&szRegString[0],
				&dwRegValueSize);

			if (lStatus != ERROR_SUCCESS) {
				// apply default name
				lstrcpy (szRegString, TEXT("perfdata"));
			}
			m_BaseFileName = szRegString;

			// get auto name format
			dwRegValType = 0;
			dwRegValue = 0;
			dwRegValueSize = sizeof(DWORD);
			lStatus = RegQueryValueEx (
				m_hKeyLogSettingsDefault,
				TEXT("Log File Auto Format"),
				NULL,
				&dwRegValType,
				(LPBYTE)&dwRegValue,
				&dwRegValueSize);

			if (lStatus != ERROR_SUCCESS) {
				// then apply default value
				dwRegValue = OPD_NAME_YYMMDD; // manual naming is the default
			}
			// set update interval information
			m_AutoNameIndex = dwRegValue;

			dwRegValType = 0;
			dwRegValue = 0;
			dwRegValueSize = sizeof(DWORD);
			lStatus = RegQueryValueEx (
				m_hKeyLogSettingsDefault,
				TEXT("Auto Rename Units"),
				NULL,
				&dwRegValType,
				(LPBYTE)&dwRegValue,
				&dwRegValueSize);

			if (lStatus != ERROR_SUCCESS) {
				// then apply default value
				dwRegValue = OPD_RENAME_DAYS; // manual naming is the default
			}
			m_RenameUnitsIndex = dwRegValue;

			dwRegValType = 0;
			dwRegValueSize = MAX_PATH * sizeof(TCHAR);
			memset (szRegString, 0, dwRegValueSize);
			lStatus = RegQueryValueEx (
				m_hKeyLogSettingsDefault,
				TEXT("Command File"),
				NULL,
				&dwRegValType,
				(LPBYTE)&szRegString[0],
				&dwRegValueSize);

			if (lStatus != ERROR_SUCCESS) {
				// then apply default value
				m_ExecuteCmd = 0;
				m_szCmdFilename = _T("");
			} else {
				// else use the one from the registry
				m_ExecuteCmd = 1;
				m_szCmdFilename = szRegString;
			}
		}
	}
	m_bInitialized = TRUE;
	return;
}

afx_msg LRESULT COutputPropPage::OnQuerySiblings (WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
		case PDLCNFIG_PSM_QS_WILDCARD_LOG:
			switch (m_LogFileTypeIndex) {
				case -1:
					return PDLCNFIG_WILDCARD_LOG_DONT_KNOW;

				case OPD_BIN_FILE:
					return PDLCNFIG_WILDCARD_LOG_YES;

				case OPD_CSV_FILE:
				case OPD_TSV_FILE:
				default:
					return PDLCNFIG_WILDCARD_LOG_NO;

			}

		case PDLCNFIG_PSM_QS_ARE_YOU_READY:
			InitDialogData();
			return 0;


		default:
			return 0; // to pass to the next property page
	}
}

BOOL COutputPropPage::IsDirPathValid (LPCTSTR szPath,
                                      BOOL bLastNameIsDirectory,
                                      BOOL bCreateMissingDirs)
/*++

Routine Description:

    Creates the directory specified in szPath and any other "higher"
        directories in the specified path that don't exist.

Arguments:

    IN  LPCTSTR szPath
        directory path to create (assumed to be a DOS path, not a UNC)

    IN  BOOL bLastNameIsDirectory
        TRUE when the last name in the path is a Directory and not a File
        FALSE if the last name is a file

    IN  BOOL bCreateMissingDirs
        TRUE will create any dirs in the path that are not found
        FALSE will only test for existence and not create any
            missing dirs.


Return Value:

    TRUE    if the directory path now exists
    FALSE   if error (GetLastError to find out why)

--*/
{
    LPTSTR   szLocalPath;
    LPTSTR   szEnd;
    LONG     lReturn = 0L;
    LPSECURITY_ATTRIBUTES   lpSA = NULL;
    DWORD       dwAttr;
    TCHAR    cBackslash = TEXT('\\');

    szLocalPath = (LPTSTR)HeapAlloc (GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        MAX_PATH * sizeof(TCHAR));

    if (szLocalPath == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    } else {
        // so far so good...
        SetLastError (ERROR_SUCCESS); // initialize error value to SUCCESS
    }

    if (GetFullPathName (szPath,
        MAX_PATH,
        szLocalPath,
        NULL) > 0) {

        szEnd = &szLocalPath[3];

        if (*szEnd != 0) {
            // then there are sub dirs to create
            while (*szEnd != 0) {
                // go to next backslash
                while ((*szEnd != cBackslash) && (*szEnd != 0)) szEnd++;
                if (*szEnd == cBackslash) {
                    // terminate path here and create directory
                    *szEnd = 0;
                    if (bCreateMissingDirs) {
                        if (!CreateDirectory (szLocalPath, lpSA)) {
                            // see what the error was and "adjust" it if necessary
                            if (GetLastError() == ERROR_ALREADY_EXISTS) {
                                // this is OK
                                SetLastError (ERROR_SUCCESS);
                            } else {
                                lReturn = 0;
                            }
                        } else {
                            // directory created successfully so update count
                            lReturn++;
                        }
                    } else {
                        if ((dwAttr = GetFileAttributes(szLocalPath)) != 0xFFFFFFFF) {
                            // make sure it's a dir
                            if ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) ==
                                FILE_ATTRIBUTE_DIRECTORY) {
                                lReturn++;
                            } else {
                                // if any dirs fail, then clear the return value
                                lReturn = 0;
                            }
                        } else {
                            // if any dirs fail, then clear the return value
                            lReturn = 0;
                        }
                    }
                    // replace backslash and go to next dir
                    *szEnd++ = cBackslash;
                }
            }
            // create last dir in path now if it's a dir name and not a filename
            if (bLastNameIsDirectory) {
                if (bCreateMissingDirs) {
                    if (!CreateDirectory (szLocalPath, lpSA)) {
                        // see what the error was and "adjust" it if necessary
                        if (GetLastError() == ERROR_ALREADY_EXISTS) {
                            // this is OK
                            SetLastError (ERROR_SUCCESS);
                            lReturn++;
                        } else {
                            lReturn = 0;
                        }
                    } else {
                        // directory created successfully
                        lReturn++;
                    }
                } else {
                    if ((dwAttr = GetFileAttributes(szLocalPath)) != 0xFFFFFFFF) {
                        // make sure it's a dir
                        if ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) ==
                            FILE_ATTRIBUTE_DIRECTORY) {
                            lReturn++;
                        } else {
                            // if any dirs fail, then clear the return value
                            lReturn = 0;
                        }
                    } else {
                        // if any dirs fail, then clear the return value
                        lReturn = 0;
                    }
                }
            }
        } else {
            // else this is a root dir only so return success.
            lReturn = 1;
        }
    }
    if (szLocalPath !=  NULL) HeapFree (GetProcessHeap(), 0, szLocalPath);
    return lReturn;

}

void COutputPropPage::AutoManualEnable (BOOL bAutomatic)
{
	BOOL	bShowCmdFile;

    GetDlgItem(IDC_MANUAL_NAME_GROUP)->EnableWindow(!bAutomatic);
    GetDlgItem(IDC_OUTPUT_FILE_EDIT)->EnableWindow(!bAutomatic);
    GetDlgItem(IDC_BROWSE_OUTPUT_FILE)->EnableWindow(!bAutomatic);

    GetDlgItem(IDC_AUTO_NAME_GROUP)->EnableWindow(bAutomatic);
    GetDlgItem(IDC_RENAME_INTERVAL)->EnableWindow(bAutomatic);
    GetDlgItem(IDC_SPIN_RENAME_INTERVAL)->EnableWindow(bAutomatic);
    GetDlgItem(IDC_RENAME_UNITS)->EnableWindow(bAutomatic);
    GetDlgItem(IDC_BROWSE_FOLDER)->EnableWindow(bAutomatic);
    GetDlgItem(IDC_LOG_DIRECTORY)->EnableWindow(bAutomatic);
    GetDlgItem(IDC_BASE_NAME_CAPTION)->EnableWindow(bAutomatic);
    GetDlgItem(IDC_BASE_FILENAME_EDIT)->EnableWindow(bAutomatic);
    GetDlgItem(IDC_AUTO_NAME_CAPTION)->EnableWindow(bAutomatic);
    GetDlgItem(IDC_AUTO_NAME_COMBO)->EnableWindow(bAutomatic);
    GetDlgItem(IDC_SAMPLE_NAME)->EnableWindow(bAutomatic);
    GetDlgItem(IDC_SAMPLE_NAME_TEXT)->EnableWindow(bAutomatic);
    GetDlgItem(IDC_EXECUTE_CHECK)->EnableWindow(bAutomatic);

	bShowCmdFile = bAutomatic && m_ExecuteCmd;
    GetDlgItem(IDC_CMD_FILENAME)->EnableWindow(bShowCmdFile);
    GetDlgItem(IDC_BROWSE_CMD_FILE)->EnableWindow(bShowCmdFile);
}

void COutputPropPage::UpdateSampleFilename()
{
    CString     cCompositeName;
    CString     cBaseName;
    CString     cDateString;
    CString     cFileTypeString;
    CTime       cCurrentTime = CTime::GetCurrentTime();
    LONG        lAutoNameFormat;
    LONG        lFileTypeIndex;
	BOOL		bAutoName;

	bAutoName = IsDlgButtonChecked (IDC_AUTOMATIC_NAME);

    if (bAutoName) {
        // only update if the automatic button is checked
        // get base name text
        GetDlgItemText (IDC_BASE_FILENAME_EDIT, cBaseName);
        cBaseName += TEXT("_");

        // get date/time/serial integer format
        cCurrentTime.GetCurrentTime();
        lAutoNameFormat = ((CComboBox *)GetDlgItem(IDC_AUTO_NAME_COMBO))->GetCurSel();
        switch (lAutoNameFormat) {
        case OPD_NAME_NNNNNN:
            cDateString = TEXT("000001");
            break;

        case OPD_NAME_YYDDD:
            cDateString = cCurrentTime.Format (TEXT("%y%j"));
            break;

        case OPD_NAME_YYMM:
            cDateString = cCurrentTime.Format (TEXT("%y%m"));
            break;

        case OPD_NAME_YYMMDDHH:
            cDateString = cCurrentTime.Format (TEXT("%y%m%d%H"));
            break;

        case OPD_NAME_MMDDHH:
            cDateString = cCurrentTime.Format (TEXT("%m%d%H"));
            break;

        case OPD_NAME_YYMMDD:
        default:
            cDateString = cCurrentTime.Format (TEXT("%y%m%d"));
            break;
        }

		cCompositeName = cBaseName;
		cCompositeName += cDateString;
    } else {
		int	nExtLoc;
		int	nNameLen;
		// with a manual name, just update the extension
		// get the current filename
        if (GetDlgItemText (IDC_OUTPUT_FILE_EDIT, cBaseName) == 0) {
			// no name in the edit control, so make one up to use
			// as a default
			cCompositeName = TEXT("c:\\perflogs");
			cCompositeName += TEXT("\\perfdata");

		} else {
			//find last "." in string
			nExtLoc = cBaseName.ReverseFind (_T('.'));
			if (nExtLoc > 0) {
				// don't copy the "."
				cCompositeName = cBaseName.Left(nExtLoc);
			}
		}
	}

    // get file type
    lFileTypeIndex = ((CComboBox *)GetDlgItem(IDC_LOG_FILETYPE))->GetCurSel();
    switch (lFileTypeIndex) {
    case OPD_TSV_FILE:
        cFileTypeString = TEXT(".TSV");
        break;

    case OPD_BIN_FILE:
        cFileTypeString = TEXT(".BLG");
        break;

    case OPD_CSV_FILE:
    default:
        cFileTypeString = TEXT(".CSV");
        break;
    }
    cCompositeName += cFileTypeString;

    if (bAutoName) {
	    SetDlgItemText (IDC_SAMPLE_NAME_TEXT, cCompositeName);
	} else {
	    SetDlgItemText (IDC_OUTPUT_FILE_EDIT, cCompositeName);
	}
}

BOOL	COutputPropPage::IsWildcardLogFileType (void)
{
	switch (m_LogFileTypeIndex) {
		case OPD_BIN_FILE:
			return TRUE;

		case OPD_CSV_FILE:
		case OPD_TSV_FILE:
		default:
			return FALSE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// COutputPropPage message handlers

BOOL COutputPropPage::OnInitDialog()
{
    BOOL bAutoMode;

	InitDialogData();

 	// now init other pages
	QuerySiblings (PDLCNFIG_PSM_QS_ARE_YOU_READY, 0);

   if (m_RenameInterval == 0) {
        // then manual naming has been selected:
        CheckRadioButton (IDC_MANUAL_NAME, IDC_AUTOMATIC_NAME, IDC_MANUAL_NAME);
        bAutoMode = FALSE;
    } else {
        CheckRadioButton (IDC_MANUAL_NAME, IDC_AUTOMATIC_NAME, IDC_AUTOMATIC_NAME);
        bAutoMode = TRUE;
   }

    CPropertyPage::OnInitDialog();

    // now finish updating the controls in the property page
    UpdateSampleFilename();

    // update control state to match selection
    AutoManualEnable (bAutoMode);

    SetModified(FALSE);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void COutputPropPage::OnAutomaticName()
{
    AutoManualEnable(TRUE);
    UpdateSampleFilename();
    SetModified(TRUE);
}

void COutputPropPage::OnManualName()
{
    AutoManualEnable(FALSE);
    UpdateSampleFilename();
    SetModified(TRUE);
}

void COutputPropPage::OnSelchangeAutoNameCombo()
{
    // TODO: Add your control notification handler code here
    UpdateSampleFilename();
    m_bFileNameChanged = TRUE;
    SetModified(TRUE);
}

void COutputPropPage::OnChangeBaseFilenameEdit()
{
    // TODO: Add your control notification handler code here
    SetModified(TRUE);
    m_bFileNameChanged = TRUE;
}

void COutputPropPage::OnBrowseOutputFile()
{
    OPENFILENAME    ofn;
    CComboBox        *cFileTypeCombo;
    CString            csInitialDir;
    LONG            lLogFileType;
    TCHAR            szFileName[MAX_PATH];
    CString            csBaseFilename;
    TCHAR            szDrive[MAX_PATH];
    TCHAR            szDir[MAX_PATH];
    TCHAR            szExt[MAX_PATH];
    LPTSTR            szDefExt = NULL;

    cFileTypeCombo = (CComboBox *)GetDlgItem(IDC_LOG_FILETYPE);
    lLogFileType = cFileTypeCombo->GetCurSel();
    if (lLogFileType == CB_ERR) lLogFileType = OPD_NUM_FILE_TYPES;

    GetDlgItemText (IDC_OUTPUT_FILE_EDIT, csBaseFilename);
    _tsplitpath((LPCTSTR)csBaseFilename,
        szDrive, szDir, szFileName, szExt);

    csInitialDir = szDrive;
    csInitialDir += szDir;

    lstrcat (szFileName, szExt);

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.hInstance = GetModuleHandle(NULL);
    ofn.lpstrFilter = TEXT("CSV Files (*.csv)\0*.csv\0TSV Files (*.tsv)\0*.tsv\0BLG Files (*.blg)\0*.blg\0All Files (*.*)\0*.*\0");
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = lLogFileType + 1; // nFilterIndex is 1-based
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = (LPCTSTR)csInitialDir;
    ofn.lpstrTitle = TEXT("Select Log Filename");
    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    if (GetOpenFileName (&ofn) == IDOK) {
        // Update the fields with the new information
        cFileTypeCombo->SetCurSel(ofn.nFilterIndex-1);
        // see if an file name extension needs to be added...
        if (ofn.nFileExtension == 0) {
            // then add the one that matches the current file type
            switch (ofn.nFilterIndex-1) {
            case OPD_CSV_FILE:
                szDefExt = TEXT(".csv");
                break;

            case OPD_TSV_FILE:
                szDefExt = TEXT(".tsv");
                break;

            case OPD_BIN_FILE:
                szDefExt = TEXT(".blg");
                break;

            default:
                szDefExt = NULL;
                break;
            }
        }
        if (szDefExt != NULL) {
            lstrcat (szFileName, szDefExt);
        }

        SetDlgItemText (IDC_OUTPUT_FILE_EDIT, szFileName);
    } // else ignore if they canceled out
}

void COutputPropPage::OnSelchangeLogFiletype()
{
    UpdateData(TRUE);
    UpdateSampleFilename();
	if ((m_LogFileTypeIndex != OPD_BIN_FILE) &&
		(QuerySiblings (PDLCNFIG_PSM_QS_LISTBOX_STARS, 0) ==
		PDLCNFIG_LISTBOX_STARS_YES)) {
		AfxMessageBox	(IDS_NOT_WILDCARD_FMT, MB_OK, 0);
	}
    m_bFileNameChanged = TRUE;
    SetModified(TRUE);
}

void COutputPropPage::OnSelchangeRenameUnits()
{
    LONG    lIndex;
    LONG    lNewDefault;
    // Get new sample and update default extension based on rename
    // interval units
    lIndex = ((CComboBox *)GetDlgItem(IDC_RENAME_UNITS))->GetCurSel();
    switch (lIndex) {
    case OPD_RENAME_HOURS:
        lNewDefault = OPD_NAME_YYMMDDHH;
        break;

    case OPD_RENAME_DAYS:
        lNewDefault = OPD_NAME_YYMMDD;
        break;

    case OPD_RENAME_MONTHS:
        lNewDefault = OPD_NAME_YYMM;
        break;

    case OPD_RENAME_KBYTES:
    case OPD_RENAME_MBYTES:
    default:
        lNewDefault = OPD_NAME_NNNNNN;
        break;
    }
    // update new default selection
    ((CComboBox *)GetDlgItem(IDC_AUTO_NAME_COMBO))->SetCurSel(lNewDefault);

    UpdateSampleFilename();
    SetModified(TRUE);
}

void COutputPropPage::OnDeltaposSpinRenameInterval(NMHDR* pNMHDR, LRESULT* pResult)
{
    TCHAR    szStringValue[MAX_PATH];
    DWORD    dwNumValue;
    int        nChange;

    NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

    // get current value from edit window
    GetDlgItemText (IDC_RENAME_INTERVAL, szStringValue, MAX_PATH);

    // convert to integer
    dwNumValue = _tcstoul (szStringValue, NULL, 10);
    // delta is opposite of arrow direction
    nChange = -pNMUpDown->iDelta;

    // apply value from spin control
    if (nChange < 0) { // 1 is the minimum
        // make sure we haven't hit bottom already
        if (dwNumValue > 1) {
            dwNumValue += nChange;
        }
    } else {
        dwNumValue += nChange;
    }

    // update edit window
    _ultot (dwNumValue, szStringValue, 10);

    SetDlgItemText(IDC_RENAME_INTERVAL, szStringValue);

    SetModified(TRUE);

    *pResult = 0;
}

void COutputPropPage::OnCancel()
{
    // TODO: Add your specialized code here and/or call the base class

    CPropertyPage::OnCancel();
}

void COutputPropPage::OnOK()
{
    LONG    lIndex;
    LONG    lStatus;
    CString    csFilename;

    DWORD   dwAutoNameFormat;
    DWORD   dwAutoChangeInterval;
    BOOL    bManual;
    BOOL    bBogus = FALSE;

    bManual = IsDlgButtonChecked (IDC_MANUAL_NAME);
    if (!bManual) {
        dwAutoNameFormat = ((CComboBox *)GetDlgItem(IDC_AUTO_NAME_COMBO))->GetCurSel();
        dwAutoChangeInterval = ((CComboBox *)GetDlgItem(IDC_RENAME_UNITS))->GetCurSel();
    }
    // save Log File Type
    lIndex = ((CComboBox *)GetDlgItem(IDC_LOG_FILETYPE))->GetCurSel();

    lStatus = RegSetValueEx (
        m_hKeyLogSettingsDefault,
        TEXT("Log File Type"),
        0L,
        REG_DWORD,
        (LPBYTE)&lIndex,
        sizeof(lIndex));

    ASSERT (lStatus == ERROR_SUCCESS);

    // is manual filename button pushed?
    if (bManual) {
        // YES:
        csFilename.Empty();
        // write output filename frome edit box
        GetDlgItemText(IDC_OUTPUT_FILE_EDIT, csFilename);

        lStatus = RegSetValueEx (
            m_hKeyLogSettingsDefault,
            TEXT("Log Filename"),
            0L,
            REG_SZ,
            (LPBYTE)(LPCTSTR)csFilename,
            (csFilename.GetLength()+1)*sizeof(TCHAR));

        ASSERT (lStatus == ERROR_SUCCESS);

        // write rename interval == 0
        lIndex = 0;
        lStatus = RegSetValueEx (
            m_hKeyLogSettingsDefault,
            TEXT("Auto Name Interval"),
            0L,
            REG_DWORD,
            (LPBYTE)&lIndex,
            sizeof(lIndex));

        ASSERT (lStatus == ERROR_SUCCESS);

        // clear auto rename entries:
        //    Log File Auto Format
        RegDeleteValue (m_hKeyLogSettingsDefault, TEXT("Log File Auto Format"));
        //  Log Auto Name Units
        RegDeleteValue (m_hKeyLogSettingsDefault, TEXT("Auto Rename Units"));
        //  Log Base Filename
        RegDeleteValue (m_hKeyLogSettingsDefault, TEXT("Base Log Filename"));
		// Command File name
		RegDeleteValue (m_hKeyLogSettingsDefault, TEXT("Command File"));
    } else {
        // auto is pressed so:
        csFilename.Empty();
        //  save Log Default Directory
        GetDlgItemText (IDC_LOG_DIRECTORY, csFilename);
        lStatus = RegSetValueEx (
            m_hKeyLogSettingsDefault,
            TEXT("Log Default Directory"),
            0L,
            REG_SZ,
            (LPBYTE)(LPCTSTR)csFilename,
            (csFilename.GetLength()+1)*sizeof(TCHAR));

        ASSERT (lStatus == ERROR_SUCCESS);

        //    save Log Base Filename
        csFilename.Empty();
        GetDlgItemText (IDC_BASE_FILENAME_EDIT, csFilename);
        lStatus = RegSetValueEx (
            m_hKeyLogSettingsDefault,
            TEXT("Base Filename"),
            0L,
            REG_SZ,
            (LPBYTE)(LPCTSTR)csFilename,
            (csFilename.GetLength()+1)*sizeof(TCHAR));

        ASSERT (lStatus == ERROR_SUCCESS);

        //  save Log Auto Name Format
        lStatus = RegSetValueEx (
            m_hKeyLogSettingsDefault,
            TEXT("Log File Auto Format"),
            0L,
            REG_DWORD,
            (LPBYTE)&dwAutoNameFormat,
            sizeof(DWORD));

        ASSERT (lStatus == ERROR_SUCCESS);

        if (lIndex == OPD_NAME_NNNNNN) {
            if (m_bFileNameChanged) {
                // reset serial number counter to 1
                lIndex = 1;
                lStatus = RegSetValueEx (
                    m_hKeyLogSettingsDefault,
                    TEXT("Log File Serial Number"),
                    0L,
                    REG_DWORD,
                    (LPBYTE)&lIndex,
                    sizeof(DWORD));
                ASSERT (lStatus == ERROR_SUCCESS);
            }
        } else {
            // delete serial number entry
            lStatus = RegDeleteValue (
                m_hKeyLogSettingsDefault,
                TEXT("Log File Serial Number"));
            // this may fail if the key is already
            // deleted. That's ok.
        }
        //    save Log Rename Interval
        csFilename.Empty();
        GetDlgItemText (IDC_RENAME_INTERVAL, csFilename);
        lIndex = _tcstol((LPCTSTR)csFilename, NULL, 10);
        lStatus = RegSetValueEx (
            m_hKeyLogSettingsDefault,
            TEXT("Auto Name Interval"),
            0L,
            REG_DWORD,
            (LPBYTE)&lIndex,
            sizeof(DWORD));

        ASSERT (lStatus == ERROR_SUCCESS);

        //    save Log Rename Units
        lStatus = RegSetValueEx (
            m_hKeyLogSettingsDefault,
            TEXT("Auto Rename Units"),
            0L,
            REG_DWORD,
            (LPBYTE)&dwAutoChangeInterval,
            sizeof(DWORD));

        ASSERT (lStatus == ERROR_SUCCESS);

		if (m_ExecuteCmd != 0) {
			csFilename.Empty();
			GetDlgItemText (IDC_CMD_FILENAME, csFilename);
			lStatus = RegSetValueEx (
				m_hKeyLogSettingsDefault,
				TEXT("Command File"),
				0L,
				REG_SZ,
				(LPBYTE)(LPCTSTR)csFilename,
				(csFilename.GetLength()+1)*sizeof(TCHAR));

			ASSERT (lStatus == ERROR_SUCCESS);
		} else {
			// no command file to be executed
			RegDeleteValue (m_hKeyLogSettingsDefault, TEXT("Command File"));
		}
        //    clear Manual entries
        //     Log Filename
        RegDeleteValue (m_hKeyLogSettingsDefault, TEXT("Log Filename"));
    }
    CancelToClose();
}

BOOL COutputPropPage::OnQueryCancel()
{
    // TODO: Add your specialized code here and/or call the base class

    return CPropertyPage::OnQueryCancel();
}

void COutputPropPage::OnChangeOutputFileEdit()
{
    // TODO: Add your control notification handler code here
    SetModified(TRUE);
}

void COutputPropPage::OnChangeRenameInterval()
{
    // TODO: Add your control notification handler code here
    SetModified(TRUE);
}

void COutputPropPage::OnUpdateBaseFilenameEdit()
{
    // TODO: Add your control notification handler code here
    UpdateSampleFilename();
    m_bFileNameChanged = TRUE;
}

void COutputPropPage::OnBrowseFolder()
{
    OPENFILENAME    ofn;
    CComboBox        *cFileTypeCombo;
    CString            csInitialDir;
    LONG            lLogFileType;
    TCHAR            szFileName[MAX_PATH];
    CString            csBaseFilename;
    LONG            lFileNameLength;

    cFileTypeCombo = (CComboBox *)GetDlgItem(IDC_LOG_FILETYPE);
    lLogFileType = cFileTypeCombo->GetCurSel();
    if (lLogFileType == CB_ERR) lLogFileType = OPD_NUM_FILE_TYPES;

    // should the default filename be the base or the synthesized one?
    GetDlgItemText (IDC_BASE_FILENAME_EDIT, szFileName, MAX_PATH);
    GetDlgItemText (IDC_LOG_DIRECTORY, csInitialDir);

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.hInstance = GetModuleHandle(NULL);
    ofn.lpstrFilter = TEXT("CSV Files (*.csv)\0*.csv\0TSV Files (*.tsv)\0*.tsv\0BLG Files (*.blg)\0*.blg\0All Files (*.*)\0*.*\0");
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = lLogFileType + 1; // nFilterIndex is 1 based
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = csInitialDir;
    ofn.lpstrTitle = TEXT("Select Log Folder and Base Filename");
    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    if (GetOpenFileName (&ofn) == IDOK) {
        // Update the fields with the new information
        cFileTypeCombo->SetCurSel(ofn.nFilterIndex -1);

        lFileNameLength = lstrlen(szFileName);
        // truncate extension
        if ((ofn.nFileExtension < lFileNameLength) && (ofn.nFileExtension > 0)) {
            szFileName[ofn.nFileExtension-1] = 0;
        }
        if ((ofn.nFileOffset < lFileNameLength) && (ofn.nFileOffset >= 0)){
            csBaseFilename = &szFileName[ofn.nFileOffset];
            if (ofn.nFileOffset > 0) {
                szFileName[ofn.nFileOffset-1] = 0;
            }
            SetDlgItemText (IDC_BASE_FILENAME_EDIT, csBaseFilename);
            SetDlgItemText (IDC_LOG_DIRECTORY, szFileName);
        }
        UpdateSampleFilename();
    } // else ignore if they canceled out
}

BOOL COutputPropPage::OnKillActive()
{
    CString    csFilename;
    int     nMbReturn;

    DWORD   dwAutoNameFormat;
    DWORD   dwAutoChangeInterval;
    BOOL    bManual;
    BOOL    bBogus = FALSE;
    BOOL    bPathHasFileName;

    BOOL    bReturn = TRUE; // assume all is OK

    UpdateData(TRUE);

    bManual = IsDlgButtonChecked (IDC_MANUAL_NAME);
    if (!bManual) {
        dwAutoNameFormat = ((CComboBox *)GetDlgItem(IDC_AUTO_NAME_COMBO))->GetCurSel();
        dwAutoChangeInterval = ((CComboBox *)GetDlgItem(IDC_RENAME_UNITS))->GetCurSel();
        // check for valid interval/name combinations
        switch (dwAutoChangeInterval) {
        case OPD_RENAME_HOURS:
            if ((dwAutoNameFormat == OPD_NAME_YYDDD) ||
                (dwAutoNameFormat == OPD_NAME_YYMM) ||
                (dwAutoNameFormat == OPD_NAME_YYMMDD)) bBogus = TRUE;
            break;

        case OPD_RENAME_DAYS:
            if (dwAutoNameFormat == OPD_NAME_YYMM) bBogus = TRUE;
            break;

        case OPD_RENAME_MONTHS:
            break;

        case OPD_RENAME_KBYTES:
        case OPD_RENAME_MBYTES:
        default:
            if (dwAutoNameFormat != OPD_NAME_NNNNNN) bBogus = TRUE;
            break;
        }
    }

    if (bBogus) {
        // display warning
        if (AfxMessageBox (IDS_NAME_FORMAT_NOT_COMPATIBLE,
            MB_OKCANCEL, 0) == IDCANCEL) {
            // the user has selected to change it so this is not valid
            bReturn = FALSE;
        }
    }

    // is manual filename button pushed?
    if (bManual) {
        // YES:
        csFilename.Empty();
        // write output filename frome edit box
        csFilename = m_OutputFileName;
        bPathHasFileName = TRUE;
    } else {
        // auto is pressed so:
        csFilename.Empty();
        //  save Log Default Directory
        csFilename = m_szLogDirectory;
        bPathHasFileName = FALSE;
    }
    // check to see if the dir path is valid
    if (!IsDirPathValid (csFilename, !bPathHasFileName, FALSE)) {
        nMbReturn = AfxMessageBox (IDS_DIR_NOT_FOUND,
            MB_YESNOCANCEL, 0);
        if (nMbReturn == IDYES) {
            // create the dir(s)
            if (!IsDirPathValid (csFilename, !bPathHasFileName, TRUE)) {
                // unable to create the dir, display message
                nMbReturn = AfxMessageBox (IDS_DIR_NOT_MADE,
                    MB_OK, 0);
                bReturn = FALSE;
            }
        } else if (nMbReturn == IDCANCEL) {
            // then abort and return to the dialog
            bReturn = FALSE;
        }
    } // else the path is OK

    return bReturn;
}

void COutputPropPage::OnExecuteCheck() 
{
	BOOL	bExecuteCmd;
    m_ExecuteCmd = IsDlgButtonChecked (IDC_EXECUTE_CHECK);

	bExecuteCmd = (m_ExecuteCmd != 0 ? TRUE : FALSE);
    GetDlgItem(IDC_CMD_FILENAME)->EnableWindow(bExecuteCmd);
    GetDlgItem(IDC_BROWSE_CMD_FILE)->EnableWindow(bExecuteCmd);
    SetModified(TRUE);

}

void COutputPropPage::OnBrowseCmdFile() 
{
    OPENFILENAME     ofn;
    CComboBox        *cFileTypeCombo;
    CString          csInitialDir;
    LONG             lLogFileType;
    TCHAR            szFileName[MAX_PATH];
    CString          csBaseFilename;
    TCHAR            szDrive[MAX_PATH];
    TCHAR            szDir[MAX_PATH];
    TCHAR            szExt[MAX_PATH];
    LPTSTR           szDefExt = NULL;

    GetDlgItemText (IDC_CMD_FILENAME, csBaseFilename);
    _tsplitpath((LPCTSTR)csBaseFilename,
        szDrive, szDir, szFileName, szExt);

    csInitialDir = szDrive;
    csInitialDir += szDir;

    lstrcat (szFileName, szExt);

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.hInstance = GetModuleHandle(NULL);
    ofn.lpstrFilter = TEXT("Command Files (*.bat, *.cmd)\0*.cmd;*.bat\0Executable Files (*.exe)\0*.exe\0All Files (*.*)\0*.*\0");
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1; // nFilterIndex is 1-based
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = (LPCTSTR)csInitialDir;
    ofn.lpstrTitle = TEXT("Select Command Filename");
    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    if (GetOpenFileName (&ofn) == IDOK) {
        SetDlgItemText (IDC_CMD_FILENAME, szFileName);
	    SetModified(TRUE);
    } // else ignore if they canceled out
	
}

void COutputPropPage::OnChangeCmdFilename() 
{
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlcnfig\pdlcnfig.h ===
// pdlcnfig.h : main header file for the pdlcnfig application
//
#ifndef _PDLCNFIG_H_
#define _PDLCNFIG_H_
#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include <tchar.h>
#include "resource.h"        // main symbols


/////////////////////////////////////////////////////////////////////////////
// CPdlConfigApp:
// See PDLCNFIG.cpp for the implementation of this class
//

class CPdlConfigApp : public CWinApp
{
public:
    CPdlConfigApp();

    LONG    PerfLogServiceStatus();
    LONG    ServiceFilesCopied();
    LONG    CreatePerfDataLogService ();
    LONG    InitPerfDataLogRegistry ();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPdlConfigApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(CPdlConfigApp)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
#endif // _PDLCNFIG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlcnfig\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pdlcnfig.RC
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDD_PDLCNFIG_DIALOG             101
#define IDS_ABOUTBOX                    101
#define IDD_SETTINGS_PAGE               102
#define IDS_SERVICE_NOT_INSTALLED       102
#define IDD_OUTPUT_PAGE                 103
#define IDS_PROPERTY_SHEET_CAPTION      103
#define IDS_ACCESS_DENIED               104
#define IDS_REGISTRY_ERROR              105
#define IDS_MESSAGE_BOX_CAPTION         106
#define IDS_NAME_FORMAT_NOT_COMPATIBLE  107
#define IDS_WARNING                     108
#define IDS_SC_ACCESS_ERROR             109
#define IDS_SC_CREATE_ERROR             110
#define IDS_SC_INSTALL_ERROR_PERMS      111
#define IDS_ERROR                       112
#define IDS_STOP_AND_START              113
#define IDS_NOTICE                      114
#define IDS_REMOVE_SERVICE_WARNING      115
#define IDS_QUERY_INSTALL               116
#define IDR_MAINFRAME                   1000
#define IDC_INTERVAL_TIME               1005
#define IDC_INTERVAL_SPIN               1006
#define IDC_BROWSE_COUNTERS             1007
#define IDC_REMOVE                      1008
#define IDC_SERVICE_AUTO                1009
#define IDC_SERVICE_MAN                 1010
#define IDC_REMOVE_SERVICE              1011
#define IDC_EDIT                        1012
#define IDC_EDIT_BUTTON                 1013
#define IDC_MANUAL_NAME                 1018
#define IDC_OUTPUT_FILE_EDIT            1019
#define IDC_BROWSE_OUTPUT_FILE          1020
#define IDC_AUTOMATIC_NAME              1021
#define IDC_BASE_FILENAME_EDIT          1022
#define IDC_AUTO_NAME_COMBO             1023
#define IDC_SAMPLE_NAME                 1024
#define IDC_RENAME_INTERVAL             1025
#define IDC_RENAME_UNITS                1026
#define IDC_SPIN_RENAME_INTERVAL        1027
#define IDC_BROWSE_BASE_NAME            1028
#define IDC_BROWSE_CMD_FILE             1028
#define IDC_BROWSE_FOLDER               1029
#define IDC_SAMPLE_NAME_TEXT            1030
#define IDC_COUNTER_LIST                1031
#define IDC_MAN_START                   1033
#define IDC_MAN_STOP                    1034
#define IDC_MAN_PAUSE                   1035
#define IDC_SERVICE_START_GROUP         1036
#define IDC_MANUAL_CONTROL_GROUP        1037
#define IDC_MAN_RESUME                  1038
#define IDC_SAMPLE_INTERVAL_CAPTION     1040
#define IDC_COUNTER_LIST_CAPTION        1042
#define IDC_RENAME_INTERVAL_CAPTION     1044
#define IDC_BASE_NAME_CAPTION           1046
#define IDC_MAN_FILENAME                1047
#define IDC_PROGRESS_BAR                1048
#define IDC_STATUS_TEXT                 1049
#define IDC_MANUAL_NAME_GROUP           1052
#define IDC_FILE_TYPE_CAPTION           1053
#define IDC_LOG_FILETYPE                1054
#define IDC_INTERVAL_UNITS              1055
#define IDC_AUTO_NAME_GROUP             1056
#define IDC_AUTO_NAME_CAPTION           1057
#define IDC_LOG_DIRECTORY               1064
#define IDC_LOG_ALARM_TO_FILE           1065
#define IDC_ALARM_LOG_FILE_EDIT         1066
#define IDC_BROWSE_ALARM_LOG            1067
#define IDC_LOG_TO_EVENTLOG             1068
#define IDC_ALARM_LOG_FILE_CAPTION      1069
#define IDC_RUN_PROGRAM                 1070
#define IDC_PROGRAM_COMMAND_LINE        1071
#define IDC_COMMAND_LINE_CAPTION        1072
#define IDC_COMMAND_LINE_OPTIONS        1073
#define IDC_RUN_PROGRAM_GROUP           1074
#define IDC_CMD_FIRST_TIME              1075
#define IDC_CMD_EVERY_TIME              1076
#define IDC_CMD_ARG_NAME                1077
#define IDC_CMD_ARG_VALUE               1078
#define IDC_CMD_ARG_LIMIT               1079
#define IDC_CMD_ARG_TIME                1080
#define IDC_LOG_DIRECTORY_CAPTION       1081
#define IDC_DIRECTORY_PATH_EDIT         1082
#define IDC_BROWSE_DIRS                 1083
#define IDC_EDIT1                       1084
#define IDC_COUNTER_PATH_EDIT           1084
#define IDC_CMD_FILENAME                1084
#define IDC_BUTTON1                     1085
#define IDC_OVER                        1086
#define IDC_UNDER                       1087
#define IDC_THRESHOLD                   1088
#define IDC_INFO_ALERT                  1089
#define IDC_WARNING_ALERT               1090
#define IDC_ERROR_ALERT                 1091
#define IDC_EXECUTE_CHECK               1092
#define IDS_DIR_NOT_FOUND               57345
#define IDS_DIR_NOT_MADE                57346
#define IDS_SERVICE_INSTALLED           57347
#define IDS_NOT_WILDCARD_FMT            57348

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        142
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1093
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlcnfig\setpage.cpp ===
// SettingsPage.cpp : implementation file
//

#include "stdafx.h"
#include "pdlcnfig.h"
#include "SetPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSettingsPropPage property page

IMPLEMENT_DYNCREATE(CSettingsPropPage, CPropertyPage)

CSettingsPropPage::CSettingsPropPage() : CPropertyPage(CSettingsPropPage::IDD)
{
    //{{AFX_DATA_INIT(CSettingsPropPage)
    m_IntervalTime = 0;
    m_SettingsFile = _T("");
    m_IntervalUnitsIndex = -1;
    //}}AFX_DATA_INIT

    m_hKeyLogSettingsDefault = NULL;
    m_hKeyLogService = NULL;
    // counter buffer
    m_szCounterListBuffer = NULL;
    m_dwCounterListBufferSize = 0;
    // list box information
    m_dwMaxHorizListExtent = 0;
	m_lCounterListHasStars = PDLCNFIG_LISTBOX_STARS_DONT_KNOW;
    // prototype use only
    bServiceStopped = TRUE;
    bServicePaused = FALSE;
	m_bInitialized = FALSE;
}

CSettingsPropPage::~CSettingsPropPage()
{
    if (m_hKeyLogSettingsDefault != NULL) RegCloseKey(m_hKeyLogSettingsDefault);
    if (m_hKeyLogService != NULL) RegCloseKey(m_hKeyLogService);
}

void CSettingsPropPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSettingsPropPage)
    DDX_Text(pDX, IDC_INTERVAL_TIME, m_IntervalTime);
    DDX_CBIndex(pDX, IDC_INTERVAL_UNITS, m_IntervalUnitsIndex);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSettingsPropPage, CPropertyPage)
    //{{AFX_MSG_MAP(CSettingsPropPage)
    ON_BN_CLICKED(IDC_BROWSE_COUNTERS, OnBrowseCounters)
    ON_BN_CLICKED(IDC_MAN_START, OnManStart)
    ON_BN_CLICKED(IDC_MAN_STOP, OnManStop)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
    ON_BN_CLICKED(IDC_SERVICE_AUTO, OnServiceAuto)
    ON_BN_CLICKED(IDC_SERVICE_MAN, OnServiceMan)
    ON_NOTIFY(UDN_DELTAPOS, IDC_INTERVAL_SPIN, OnDeltaposIntervalSpin)
    ON_CBN_SELCHANGE(IDC_INTERVAL_UNITS, OnSelchangeIntervalUnits)
    ON_BN_CLICKED(IDC_REMOVE_SERVICE, OnRemoveService)
	ON_EN_CHANGE(IDC_INTERVAL_TIME, OnChangeIntervalTime)
	//}}AFX_MSG_MAP
	ON_MESSAGE (PSM_QUERYSIBLINGS, OnQuerySiblings)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSettingsPropPage Helper Functions
void CSettingsPropPage::InitDialogData (void)
{
    LONG     lStatus = ERROR_INVALID_FUNCTION;
    DWORD    dwRegValType;
    DWORD    dwRegValue;
    DWORD    dwRegValueSize;
    DWORD    dwIndex;

	if (m_bInitialized) return;

	if (m_hKeyLogService == NULL) {
		// open registry key to service
		lStatus = RegOpenKeyEx (
			HKEY_LOCAL_MACHINE,
			TEXT("SYSTEM\\CurrentControlSet\\Services\\PerfDataLog"),
			0,
			KEY_READ | KEY_WRITE,
			&m_hKeyLogService);
	}

	if ((m_hKeyLogSettingsDefault == NULL) &&
        (m_hKeyLogService != NULL)) {
		// open registry to default log query
		lStatus = RegOpenKeyEx (
			m_hKeyLogService,
			TEXT("Log Queries\\Default"),
			0,
			KEY_READ | KEY_WRITE,
			&m_hKeyLogSettingsDefault);
	}

    if (lStatus != ERROR_SUCCESS) {
        return;
        // display error, close dialog and exit
    }
    // continue

	// set sample time
	if (m_IntervalTime == 0) {
		dwRegValType = 0;
		dwRegValue = 0;
		dwRegValueSize = sizeof(DWORD);
		lStatus = RegQueryValueEx (
			m_hKeyLogSettingsDefault,
			TEXT("Sample Interval"),
			NULL,
			&dwRegValType,
			(LPBYTE)&dwRegValue,
			&dwRegValueSize);

		if ((lStatus == ERROR_SUCCESS) &&
			(dwRegValType == REG_DWORD)) {
			if ((dwRegValue % SECONDS_IN_DAY) == 0) {
				// then this is in days so scale
				dwRegValue /= SECONDS_IN_DAY;
				dwIndex = SIU_DAYS;
			} else if ((dwRegValue % SECONDS_IN_HOUR) == 0) {
				// scale to hours
				dwRegValue /= SECONDS_IN_HOUR;
				dwIndex = SIU_HOURS;
			} else if ((dwRegValue % SECONDS_IN_MINUTE) == 0) {
				// scale to minutes
				dwRegValue /= SECONDS_IN_MINUTE;
				dwIndex = SIU_MINUTES;
			} else {
				// use as seconds
				dwIndex = SIU_SECONDS;
			}
			// check for zero values & apply default if found
			if (dwRegValue == 0) {
				dwRegValue = 15;    // default is 15 sec.
				dwIndex = SIU_SECONDS;
			}
		} else {
			// load default values
			dwRegValue = 15;
			dwIndex = SIU_SECONDS;
		}
		m_IntervalTime = dwRegValue;
		m_IntervalUnitsIndex = dwIndex;
	}

	return;
}

afx_msg LRESULT CSettingsPropPage::OnQuerySiblings (WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
		case PDLCNFIG_PSM_QS_LISTBOX_STARS:
			return m_lCounterListHasStars;

		case PDLCNFIG_PSM_QS_ARE_YOU_READY:
			if (!m_bInitialized) {
				InitDialogData();
			}
			return 0;

		default:
			return 0; // to pass to the next property page
	}
}

LONG CSettingsPropPage::GetCounterListStarInfo (void)
{
	return	m_lCounterListHasStars;
}

LONG CSettingsPropPage::SetCurrentServiceState (DWORD dwNewState)
{
    SC_HANDLE   hSC = NULL;
    SC_HANDLE   hService = NULL;
    SERVICE_STATUS  ssData;
    DWORD           dwTimeout = 20;
    BOOL            bStopped, bPaused;
    LONG            lStatus;
    HCURSOR     hOrigCursor;

    hOrigCursor = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

    // open SC database
    hSC = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSC == NULL) {
        lStatus = GetLastError();
        ASSERT (lStatus != ERROR_SUCCESS);
    }
    // open service
    hService = OpenService (hSC, TEXT("PerfDataLog"),
        SERVICE_START | SERVICE_STOP | SERVICE_PAUSE_CONTINUE);

    if (hService != NULL) {
        switch (dwNewState) {
        case LOG_SERV_START:
            StartService (hService, 0, NULL);
            // wait for the service to start before returning
            while (--dwTimeout) {
                GetCurrentServiceState (&bStopped, &bPaused);
                if (bStopped) {
                    Sleep(500);
                } else {
                    break;
                }
            }
            break;

        case LOG_SERV_STOP:
            ControlService (hService, SERVICE_CONTROL_STOP, &ssData);
            // wait for the service to stop before returning
            while (--dwTimeout) {
                GetCurrentServiceState (&bStopped, &bPaused);
                if (!bStopped) {
                    Sleep(500);
                } else {
                    break;
                }
            }
            break;

        case LOG_SERV_PAUSE:
            ControlService (hService, SERVICE_CONTROL_PAUSE, &ssData);
            // wait for the service to start pause returning
            while (--dwTimeout) {
                GetCurrentServiceState (&bStopped, &bPaused);
                if (!bPaused) {
                    Sleep(500);
                } else {
                    break;
                }
            }
            break;

        case LOG_SERV_RESUME:
            ControlService (hService, SERVICE_CONTROL_CONTINUE, &ssData);
            // wait for the service to start before returning
            while (--dwTimeout) {
                GetCurrentServiceState (&bStopped, &bPaused);
                if (bPaused) {
                    Sleep(500);
                } else {
                    break;
                }
            }
            break;

        default:
            // no change if not recognized
            break;
        }
        CloseServiceHandle (hService);
    } else {
        lStatus = GetLastError();
        ASSERT (lStatus != 0);
    }
    // close handles
    if (hSC != NULL) CloseServiceHandle (hSC);

    ::SetCursor (hOrigCursor);

    return ERROR_SUCCESS;
}

LONG CSettingsPropPage::GetCurrentServiceState (BOOL * bStopped, BOOL * bPaused)
{
    SC_HANDLE   hSC = NULL;
    SC_HANDLE   hService = NULL;
    SERVICE_STATUS  ssData;
    LONG        lStatus;
    HCURSOR     hOrigCursor;

    BOOL    bServiceStopped, bServicePaused;

    hOrigCursor = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

    bServiceStopped = TRUE;
    bServicePaused = TRUE;

    // open SC database
    hSC = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSC == NULL) {
        lStatus = GetLastError();
        ASSERT (lStatus != ERROR_SUCCESS);
    }
    // open service
    hService = OpenService (hSC, TEXT("PerfDataLog"), SERVICE_INTERROGATE);
    // get service status

    if (hService != NULL) {
        if (ControlService (
            hService, SERVICE_CONTROL_INTERROGATE,
            &ssData)) {
            switch (ssData.dwCurrentState) {
            case SERVICE_STOPPED:
                bServiceStopped = TRUE;
                bServicePaused = FALSE;
                break;

            case SERVICE_START_PENDING:
                bServiceStopped = TRUE;
                bServicePaused = FALSE;
                break;

            case SERVICE_STOP_PENDING:
                bServiceStopped = FALSE;
                bServicePaused = FALSE;
                break;

            case SERVICE_RUNNING:
                bServiceStopped = FALSE;
                bServicePaused = FALSE;
                break;

            case SERVICE_CONTINUE_PENDING:
                bServiceStopped = FALSE;
                bServicePaused = FALSE;
                break;

            case SERVICE_PAUSE_PENDING:
                bServiceStopped = FALSE;
                bServicePaused = FALSE;
                break;

            case SERVICE_PAUSED:
                bServiceStopped = FALSE;
                bServicePaused = TRUE;
                break;

            default:
                bServiceStopped = TRUE;
                bServicePaused = TRUE;
                ;// no op
            }
        } else {
            bServiceStopped = TRUE;
            bServicePaused = TRUE;
        }
        CloseServiceHandle (hService);
    } else {
        lStatus = GetLastError();
        ASSERT (lStatus != 0);
    }

    *bStopped = bServiceStopped;
    *bPaused = bServicePaused;

    // close handles
    if (hSC != NULL) CloseServiceHandle (hSC);

    ::SetCursor (hOrigCursor);

    return ERROR_SUCCESS;
}

UINT
ConnectMachineThreadProc (LPVOID lpArg)
{
    return PdhConnectMachine (NULL);
}

LONG CSettingsPropPage::SyncServiceStartWithButtons(void)
{
    SC_HANDLE   hSC = NULL;
    SC_HANDLE   hService = NULL;
    DWORD       dwMoreBytes = 0;
    BOOL        bManualEnabled = FALSE;
    BOOL        bUpdate = FALSE;
    LONG        lStatus;

    QUERY_SERVICE_CONFIG    qsConfig;
    HCURSOR     hOrigCursor;

    hOrigCursor = ::SetCursor(LoadCursor(NULL, IDC_WAIT));

    // get button state
    if (IsDlgButtonChecked(IDC_SERVICE_MAN)) {
        bManualEnabled = TRUE;
    }

    // open SC database
    hSC = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSC == NULL) {
        lStatus = GetLastError();
        ASSERT (lStatus != ERROR_SUCCESS);
    }
    // open service
    hService = OpenService (hSC, TEXT("PerfDataLog"),
        SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG);

    if (hService != NULL) {
        // get current config
        memset (&qsConfig, 0, sizeof(qsConfig));
        if (QueryServiceConfig (hService, &qsConfig,
            sizeof(qsConfig), &dwMoreBytes)) {
            // see if the current status is different
            // from the selection. if it is, then change
            // the current mode.
            if (bManualEnabled) {
                if (qsConfig.dwStartType == SERVICE_AUTO_START) {
                    bUpdate = TRUE;
                }
            } else {
                // auto start selected
                if (qsConfig.dwStartType == SERVICE_DEMAND_START) {
                    bUpdate = TRUE;
                }
            }
        } else {
            // else unable to read the current status so update anyway
            bUpdate = TRUE;
        }

        if (bUpdate) {
            ChangeServiceConfig (
                hService,
                SERVICE_NO_CHANGE,
                (bManualEnabled ? SERVICE_DEMAND_START : SERVICE_AUTO_START),
                SERVICE_NO_CHANGE,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL);
        }
        CloseServiceHandle (hService);
    } else {
        lStatus = GetLastError();
        ASSERT (lStatus != 0);
    }

    // close handles
    if (hSC != NULL) CloseServiceHandle (hSC);

    ::SetCursor (hOrigCursor);

    return ERROR_SUCCESS;
}


void CSettingsPropPage::UpdateManualButtonsState()
{
    BOOL    bServiceIsStopped;
    BOOL    bServiceIsPaused;

    LONG    lStatus;
    BOOL    bManualEnabled;
    if (IsDlgButtonChecked(IDC_SERVICE_AUTO)) {
        bManualEnabled = FALSE;
    } else if (IsDlgButtonChecked(IDC_SERVICE_MAN)) {
        bManualEnabled = TRUE;
    } else {
        // if no button is checked, then check the auto
        // button and continue
        CheckRadioButton (IDC_SERVICE_AUTO, IDC_SERVICE_MAN, IDC_SERVICE_AUTO);
        bManualEnabled = FALSE;
    }

    GetDlgItem(IDC_MAN_START)->EnableWindow(bManualEnabled);
    GetDlgItem(IDC_MAN_STOP)->EnableWindow(bManualEnabled);

    if (bManualEnabled) {
        // check with service controller to get the current state of the service

        lStatus = GetCurrentServiceState (&bServiceIsStopped, &bServiceIsPaused);
        GetDlgItem(IDC_MAN_START)->EnableWindow(bServiceIsStopped);
        GetDlgItem(IDC_MAN_STOP)->EnableWindow(!bServiceIsStopped);
    }
}

static void DialogCallBack(CSettingsPropPage *pDlg)
{
    // add strings in buffer to list box
    LPTSTR         NewCounterName;
    LRESULT        lIndex;
    PDH_STATUS    pdhStatus;
    CListBox    *cCounterList;
    DWORD       dwItemExtent;

    cCounterList = (CListBox *)pDlg->GetDlgItem(IDC_COUNTER_LIST);

    for (NewCounterName = pDlg->m_szCounterListBuffer;
        *NewCounterName != 0;
        NewCounterName += (lstrlen(NewCounterName) + 1)) {
        pdhStatus = PdhValidatePath(NewCounterName);
        if (pdhStatus == ERROR_SUCCESS) {
            // this is a valid counter so add it to the list
            lIndex = cCounterList->AddString(NewCounterName);
            // select the current entry in the list box
            if (lIndex != LB_ERR) {
				if (pDlg->m_lCounterListHasStars != PDLCNFIG_LISTBOX_STARS_YES) {
					// save a string compare if this value is already set
					if (_tcsstr (NewCounterName, TEXT("*")) == NULL) {
						pDlg->m_lCounterListHasStars = PDLCNFIG_LISTBOX_STARS_YES;
					}
				}
                // update list box extent
                dwItemExtent = (DWORD)((cCounterList->GetDC())->GetTextExtent (NewCounterName)).cx;
                if (dwItemExtent > pDlg->m_dwMaxHorizListExtent) {\
                    pDlg->m_dwMaxHorizListExtent = dwItemExtent;
                    cCounterList->SetHorizontalExtent(dwItemExtent);
                }
                cCounterList->SetSel (-1, FALSE);    // cancel existing selections
                cCounterList->SetSel ((int)lIndex);
                cCounterList->SetCaretIndex ((int)lIndex);
            }
        } else {
            MessageBeep (MB_ICONEXCLAMATION);
        }
    }
    // clear buffer
    memset (pDlg->m_szCounterListBuffer, 0, pDlg->m_dwCounterListBufferSize);
}

/////////////////////////////////////////////////////////////////////////////
// CSettingsPropPage message handlers

BOOL CSettingsPropPage::OnInitDialog()
{
    LONG    lStatus;
    DWORD    dwRegValType;
    DWORD    dwRegValue;
    DWORD    dwRegValueSize;
    DWORD    dwIndex;
    LPTSTR    mszCounterPathList;
    LPTSTR    szThisCounterPath;
    CListBox *cCounterList;
    DWORD   dwItemExtent;

	InitDialogData();

	// now init other pages
	QuerySiblings (PDLCNFIG_PSM_QS_ARE_YOU_READY, 0);

    // start machine connection thread to make initial "ADD" dialog
    // "snappier"

//    AfxBeginThread ((AFX_THREADPROC)ConnectMachineThreadProc, NULL);

    // initialize the service state

    dwRegValType = 0;
    dwRegValue = 0;
    dwRegValueSize = sizeof(DWORD);
    lStatus = RegQueryValueEx (
        m_hKeyLogService,
        TEXT("Start"),
        NULL,
        &dwRegValType,
        (LPBYTE)&dwRegValue,
        &dwRegValueSize);

    if ((lStatus == ERROR_SUCCESS) &&
        (dwRegValType == REG_DWORD) &&
        (dwRegValue == SERVICE_DEMAND_START)) {
        // then set manual control
        CheckRadioButton (IDC_SERVICE_AUTO,
            IDC_SERVICE_MAN, IDC_SERVICE_MAN);
    } else {
        // set automatic control (default)
        CheckRadioButton (IDC_SERVICE_AUTO,
            IDC_SERVICE_MAN, IDC_SERVICE_AUTO);
    }

    // set manual buttons to reflect current state of control
    UpdateManualButtonsState();

    // load counter list box
    GetDlgItem(IDC_COUNTER_LIST)->SendMessage(LB_RESETCONTENT, 0, 0);
    // read path string from registry

    // find out buffer size required
    dwRegValType = 0;
    dwRegValue = 0;
    dwRegValueSize = 0;
    lStatus = RegQueryValueEx (
        m_hKeyLogSettingsDefault,
        TEXT("Counter List"),
        NULL,
        &dwRegValType,
        NULL,
        &dwRegValueSize);

    cCounterList = (CListBox *)GetDlgItem(IDC_COUNTER_LIST);
    if (dwRegValueSize > 0) {
        // allocate buffer
        mszCounterPathList = new TCHAR[dwRegValueSize/sizeof(TCHAR)];
        ASSERT (mszCounterPathList != NULL);

        *mszCounterPathList = 0;
        dwRegValType = 0;
        dwRegValue = 0;
        lStatus = RegQueryValueEx (
            m_hKeyLogSettingsDefault,
            TEXT("Counter List"),
            NULL,
            &dwRegValType,
            (LPBYTE)mszCounterPathList,
            &dwRegValueSize);

        if (lStatus != ERROR_SUCCESS) {
            // assign a MSZ termination
            mszCounterPathList[0] = 0;
            mszCounterPathList[1] = 0;
        }

        // load list box.
        dwIndex = 0;
        cCounterList->ResetContent();
        for (szThisCounterPath = mszCounterPathList;
             *szThisCounterPath != 0;
             szThisCounterPath += lstrlen(szThisCounterPath)+1) {
            lStatus = cCounterList->AddString (szThisCounterPath);
            if (lStatus != LB_ERR) {
				if (m_lCounterListHasStars != PDLCNFIG_LISTBOX_STARS_YES) {
					// save a string compare if this value is already set
					if (_tcsstr (szThisCounterPath, TEXT("*")) == NULL) {
						m_lCounterListHasStars = PDLCNFIG_LISTBOX_STARS_YES;
					}
				}
                dwItemExtent = (DWORD)((cCounterList->GetDC())->GetTextExtent (szThisCounterPath)).cx;
                if (dwItemExtent > m_dwMaxHorizListExtent) {
                    m_dwMaxHorizListExtent = dwItemExtent;
                    cCounterList->SetHorizontalExtent(dwItemExtent);
                }
                dwIndex++;
            }
        }
        cCounterList->SetSel(dwIndex-1);
        cCounterList->SetCaretIndex(dwIndex-1);

        delete mszCounterPathList;
    } else {
        // no counters presently in the list so just initialize everything
        cCounterList->ResetContent();
    }

    // select first counter in list (if present)
    if (GetDlgItem(IDC_COUNTER_LIST)->SendMessage(LB_GETCOUNT) > 0) {
        GetDlgItem(IDC_COUNTER_LIST)->SendMessage(LB_SETCURSEL, 0, 0);
        // highlight remove button if an item is selected
        GetDlgItem(IDC_REMOVE)->EnableWindow (TRUE);
    } else {
        GetDlgItem(IDC_REMOVE)->EnableWindow (FALSE);
    }

	if (m_lCounterListHasStars == PDLCNFIG_LISTBOX_STARS_DONT_KNOW) {
		// if here and the value hasn't been changed, then that means
		// there are no wild card entries in the list box
		m_lCounterListHasStars = PDLCNFIG_LISTBOX_STARS_NO;
	}

    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CSettingsPropPage::OnBrowseCounters()
{
    PDH_BROWSE_DLG_CONFIG    dlgConfig;
    CListBox                *cCounterList;
    LONG                    lBeforeCount;
    LONG                    lAfterCount;
	LRESULT					lWildCardOk;

	DWORD					dwRegValType;
	DWORD					dwRegValue;
	DWORD					dwRegValueSize;
	LONG					lStatus;

    if (m_szCounterListBuffer == NULL) {
        m_dwCounterListBufferSize = 16384;
        m_szCounterListBuffer = new TCHAR[m_dwCounterListBufferSize];
    }

    dlgConfig.bIncludeInstanceIndex = 0;
    dlgConfig.bSingleCounterPerAdd = 0;
    dlgConfig.bSingleCounterPerDialog = 0;
    dlgConfig.bLocalCountersOnly = 0;

	lWildCardOk = QuerySiblings (PDLCNFIG_PSM_QS_WILDCARD_LOG, 0);

	if ( lWildCardOk == PDLCNFIG_WILDCARD_LOG_YES) {
	    dlgConfig.bWildCardInstances = 1;
	} else  if (lWildCardOk == PDLCNFIG_WILDCARD_LOG_DONT_KNOW ){
		// the property page doesn't know so ask the registry
		// read log file format
		dwRegValType = 0;
		dwRegValue = 0;
		dwRegValueSize = sizeof(DWORD);
		lStatus = RegQueryValueEx (
			m_hKeyLogSettingsDefault,
			TEXT("Log File Type"),
			NULL,
			&dwRegValType,
			(LPBYTE)&dwRegValue,
			&dwRegValueSize);
		if (lStatus != ERROR_SUCCESS) {
			// then apply default value
			dwRegValue = OPD_CSV_FILE;
		}
		switch (dwRegValue) {
			case OPD_BIN_FILE:
				// the current log file does support wildcards
				dlgConfig.bWildCardInstances = 1;
                                break;

			case OPD_CSV_FILE:
			case OPD_TSV_FILE:
			default:
				// the current log file doesn't support wildcards
				dlgConfig.bWildCardInstances = 0;
				break;
		}
	} else {
		// the current log file doesn't support wildcards
	    dlgConfig.bWildCardInstances = 0;
	}

    dlgConfig.bHideDetailBox = 0;
    dlgConfig.bInitializePath = 0;
    dlgConfig.bDisableMachineSelection = 0;
	dlgConfig.bIncludeCostlyObjects = 0;
    dlgConfig.bReserved = 0;

    dlgConfig.hWndOwner = this->m_hWnd;
    dlgConfig.szDataSource = NULL;

    dlgConfig.szReturnPathBuffer = m_szCounterListBuffer;
    dlgConfig.cchReturnPathLength = m_dwCounterListBufferSize;
    dlgConfig.pCallBack = (CounterPathCallBack)DialogCallBack;
    dlgConfig.dwDefaultDetailLevel = PERF_DETAIL_WIZARD;
    dlgConfig.dwCallBackArg = (DWORD_PTR)this;
    dlgConfig.szDialogBoxCaption = TEXT("Select Counters To Log");

    cCounterList = (CListBox *)GetDlgItem(IDC_COUNTER_LIST);
    // get count of items in the list box before calling the browser
    lBeforeCount = cCounterList->GetCount();

    PdhBrowseCounters (&dlgConfig);

    // get count of items in the list box After calling the browser
    // to see if the Apply button should enabled
    lAfterCount = cCounterList->GetCount();

    if (lAfterCount > lBeforeCount) SetModified(TRUE);

    // see if the remove button should be enabled
    GetDlgItem (IDC_REMOVE)->EnableWindow(
        lAfterCount > 0 ? TRUE : FALSE);

    delete m_szCounterListBuffer;
    m_szCounterListBuffer = NULL;
    m_dwCounterListBufferSize = 0;
}

void CSettingsPropPage::OnManStart()
{
    SetCurrentServiceState (LOG_SERV_START);
    UpdateManualButtonsState();
    // set focus to stop button
    GetDlgItem(IDC_MAN_STOP)->SetFocus();
}

void CSettingsPropPage::OnManStop()
{
    SetCurrentServiceState (LOG_SERV_STOP);
    UpdateManualButtonsState();
    // set focus to start button
    GetDlgItem(IDC_MAN_START)->SetFocus();
}

void CSettingsPropPage::OnRemove()
{
    CListBox    *cCounterList;
    LONG        lThisItem;
    BOOL        bDone;
    LONG        lOrigCaret;
    LONG        lItemStatus;
    LONG        lItemCount;
    BOOL        bChanged = FALSE;
    DWORD       dwItemExtent;
    CString     csItemText;

    cCounterList = (CListBox *)GetDlgItem(IDC_COUNTER_LIST);
    // delete all selected items in the list box and
    // set the cursor to the item above the original caret position
    // or the first or last if that is out of the new range
    lOrigCaret = cCounterList->GetCaretIndex();
    lThisItem = 0;
    bDone = FALSE;
    // clear the max extent
    m_dwMaxHorizListExtent = 0;
	// clear the value and see if any non deleted items have a star, if so
	// then set the flag back
    do {
        lItemStatus = cCounterList->GetSel(lThisItem);
        if (lItemStatus > 0) {
            // then it's selected so delete it
            cCounterList->DeleteString(lThisItem);
            bChanged = TRUE;
        } else if (lItemStatus == 0) {
            // get the text length of this item since it will stay
            cCounterList->GetText(lThisItem, csItemText);
			if (m_lCounterListHasStars != PDLCNFIG_LISTBOX_STARS_YES) {
				// save a string compare if this value is already set
				if (_tcsstr (csItemText, TEXT("*")) == NULL) {
					m_lCounterListHasStars = PDLCNFIG_LISTBOX_STARS_YES;
				}
			}
            dwItemExtent = (DWORD)((cCounterList->GetDC())->GetTextExtent(csItemText)).cx;
            if (dwItemExtent > m_dwMaxHorizListExtent) {
                m_dwMaxHorizListExtent = dwItemExtent;
            }
            // then it's not selected so go to the next one
            lThisItem++;
        } else {
            // we've run out so exit
            bDone = TRUE;
        }
    } while (!bDone);

    // update the text extent of the list box
    cCounterList->SetHorizontalExtent(m_dwMaxHorizListExtent);

    // see how many entries are left and update the
    // caret position and the remove button state
    lItemCount = cCounterList->GetCount();
    if (lItemCount > 0) {
        // the update the caret
        if (lOrigCaret >= lItemCount) {
            lOrigCaret = lItemCount-1;
        } else {
            // caret should be within the list
        }
        cCounterList->SetSel(lOrigCaret);
        cCounterList->SetCaretIndex(lOrigCaret);
    } else {
        // the list is empty so remove caret, selection
        // disable the remove button and activate the
        // add button
        cCounterList->SetSel(-1);
        GetDlgItem(IDC_BROWSE_COUNTERS)->SetFocus();
        GetDlgItem(IDC_REMOVE)->EnableWindow(FALSE);
    }
    SetModified(bChanged);
}

void CSettingsPropPage::OnServiceAuto()
{
    // set service to AutoStart
    UpdateManualButtonsState();
    SetModified(TRUE);
}

void CSettingsPropPage::OnServiceMan()
{
    // set service to manual Start
    UpdateManualButtonsState();
    SetModified(TRUE);
}

void CSettingsPropPage::OnDeltaposIntervalSpin(NMHDR* pNMHDR, LRESULT* pResult)
{
    TCHAR    szStringValue[MAX_PATH];
    DWORD    dwNumValue;
    int        nChange;

    NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

    // get current value from edit window
    GetDlgItemText (IDC_INTERVAL_TIME, szStringValue, MAX_PATH);

    // convert to integer
    dwNumValue = _tcstoul (szStringValue, NULL, 10);
    // delta is opposite of arrow direction
    nChange = -pNMUpDown->iDelta;

    // apply value from spin control
    if (nChange < 0) {
        // make sure we haven't hit bottom already
        // we can't allow a 0 to be "spin-ed" in
        if (dwNumValue > 1) {
            dwNumValue += nChange;
        }
    } else {
        dwNumValue += nChange;
    }

    // update edit window
    _ultot (dwNumValue, szStringValue, 10);

    SetDlgItemText(IDC_INTERVAL_TIME, szStringValue);

    SetModified(TRUE);

    *pResult = 0;
}

void CSettingsPropPage::OnCancel()
{

    CPropertyPage::OnCancel();
}

void CSettingsPropPage::OnOK()
{
    CListBox    *cCounterList;
    CString        cIntervalString;
    CString        cCounterListString;
    CString        cThisCounterName;
    DWORD        dwSampleInterval;
    LONG        lIntervalUnits;
    DWORD        dwNumCounters;
    DWORD        dwThisCounter;
    DWORD        dwBufferLength;
    LONG        lStatus;
    LPTSTR        mszCounterPathList = NULL;
    LPTSTR        szNextItemInList;

    BOOL        bStopped, bPaused;

    cCounterList = (CListBox *)GetDlgItem(IDC_COUNTER_LIST);
    // get service state
    GetCurrentServiceState (&bStopped, &bPaused);

    if (!bStopped) {
        AfxMessageBox (IDS_STOP_AND_START);
    }

    // write changes to registry
    //*********************************

    // update service start mode if necessary
    SyncServiceStartWithButtons();

    // sample interval
    //    read value
    GetDlgItemText (IDC_INTERVAL_TIME, cIntervalString);
    dwSampleInterval = _tcstoul((LPCTSTR)cIntervalString, NULL, 10);

    //    read units
    lIntervalUnits = ((CComboBox *)GetDlgItem(IDC_INTERVAL_UNITS))->GetCurSel();

    //    convert value to seconds based on units
    switch (lIntervalUnits) {
    case    SIU_MINUTES:
        dwSampleInterval *= SECONDS_IN_MINUTE;
        break;

    case    SIU_HOURS:
        dwSampleInterval *= SECONDS_IN_HOUR;
        break;

    case    SIU_DAYS:
        dwSampleInterval *= SECONDS_IN_DAY;
        break;

    case    SIU_SECONDS:
    default:
        // already in second so leave it
        break;
    }

    //    write value to registry
    lStatus = RegSetValueEx (
        m_hKeyLogSettingsDefault,
        TEXT("Sample Interval"),
        0L,
        REG_DWORD,
        (LPBYTE)&dwSampleInterval,
        sizeof(DWORD));

    if (lStatus != ERROR_SUCCESS) {
        // unable to update value
    }

    //*********************************
    // counter list
    //  retrieve items from list box
    dwNumCounters = cCounterList->GetCount();
    dwBufferLength = 0;
    // determine required buffer size
    for (dwThisCounter = 0; dwThisCounter < dwNumCounters; dwThisCounter++) {
        dwBufferLength += cCounterList->GetTextLen (dwThisCounter) + 1;
    }
    //  add terminating NULL char
    dwBufferLength++;
    //  allocate string buffer and copy list box entries to MSZ
    mszCounterPathList = new TCHAR[dwBufferLength];
    ASSERT (mszCounterPathList != NULL);

    //  load listbox entries into MSZ
    szNextItemInList = mszCounterPathList;
    *szNextItemInList = 0;
    for (dwThisCounter = 0; dwThisCounter < dwNumCounters; dwThisCounter++) {
        lStatus = cCounterList->GetText(dwThisCounter, szNextItemInList);
        lStatus /= sizeof(TCHAR);
        szNextItemInList += lStatus;
        *szNextItemInList++ = 0;
    }
    *szNextItemInList++ = 0;
    dwBufferLength = (DWORD)((LPBYTE)szNextItemInList - (LPBYTE)mszCounterPathList);

    //    write MSZ to registry

    lStatus = RegSetValueEx (
        m_hKeyLogSettingsDefault,
        TEXT("Counter List"),
        0L,
        REG_MULTI_SZ,
        (LPBYTE)mszCounterPathList,
        dwBufferLength);

    if (lStatus != ERROR_SUCCESS) {
        // unable to update value
    }

    delete mszCounterPathList;

    CancelToClose();
}

BOOL CSettingsPropPage::OnQueryCancel()
{
    return CPropertyPage::OnQueryCancel();
}


void CSettingsPropPage::OnSelchangeIntervalUnits()
{
    SetModified(TRUE);
}

void CSettingsPropPage::OnRemoveService()
{
    SC_HANDLE   hSC = NULL;
    SC_HANDLE   hService = NULL;
    DWORD       dwMoreBytes = 0;
    LONG        lStatus;

    if (AfxMessageBox (IDS_REMOVE_SERVICE_WARNING,
        MB_OKCANCEL | MB_DEFBUTTON2) == IDCANCEL) {
        return;
    }

    // open SC database
    hSC = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSC == NULL) {
        lStatus = GetLastError();
        ASSERT (lStatus != ERROR_SUCCESS);
    }
    // open service
    hService = OpenService (hSC, TEXT("PerfDataLog"),
        SERVICE_CHANGE_CONFIG | DELETE);

    if (hService != NULL) {
        // Delete the service
        if (DeleteService (hService)) {
            EndDialog (IDCANCEL);
        }
        CloseServiceHandle (hService);
    } else {
        lStatus = GetLastError();
        ASSERT (lStatus != 0);
    }

    // close handles
    if (hSC != NULL) CloseServiceHandle (hSC);

    return;
}



void CSettingsPropPage::OnChangeIntervalTime()
{
	// TODO: Add your control notification handler code here
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlcnfig\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

//#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>            // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <stdlib.h>
#include <winperf.h>        // windows NT Performance definitions
#include <pdh.h>            // PDH function definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlcnfig\setpage.h ===
// SetPage.h : header file
//
#include "resource.h"        // main symbols
#include "common.h"
#include "pdlcnfig.h"

/////////////////////////////////////////////////////////////////////////////
// CSettingsPropPage dialog

class CSettingsPropPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CSettingsPropPage)

// Construction
public:
    CSettingsPropPage();
    ~CSettingsPropPage();

// Dialog Data
    //{{AFX_DATA(CSettingsPropPage)
    enum { IDD = IDD_SETTINGS_PAGE };
    DWORD    m_IntervalTime;
    CString    m_SettingsFile;
    int        m_IntervalUnitsIndex;
    //}}AFX_DATA

    LPTSTR              m_szCounterListBuffer;
    DWORD               m_dwCounterListBufferSize;
						
    DWORD               m_dwMaxHorizListExtent;

	BOOL				m_lCounterListHasStars;
	LONG				GetCounterListStarInfo (void);

// TEMPORARY Variables until service is completed
    BOOL                bServiceStopped;
    BOOL                bServicePaused;

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSettingsPropPage)
    public:
    virtual void OnCancel();
    virtual void OnOK();
    virtual BOOL OnQueryCancel();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);
    //}}AFX_VIRTUAL
	
// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CSettingsPropPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnBrowseCounters();
    afx_msg void OnManPause();
    afx_msg void OnManResume();
    afx_msg void OnManStart();
    afx_msg void OnManStop();
    afx_msg void OnRemove();
    afx_msg void OnServiceAuto();
    afx_msg void OnServiceMan();
    afx_msg void OnDeltaposIntervalSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelchangeIntervalUnits();
    afx_msg void OnRemoveService();
	afx_msg void OnChangeIntervalTime();
	//}}AFX_MSG
	afx_msg LRESULT OnQuerySiblings (WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()

	void	InitDialogData(void);
    LONG    SyncServiceStartWithButtons(void);
    void    UpdateManualButtonsState(void);

    HKEY    m_hKeyLogService;
    HKEY    m_hKeyLogSettingsDefault;
	BOOL	m_bInitialized;
    LONG    GetCurrentServiceState (BOOL *, BOOL *);
    LONG    SetCurrentServiceState (DWORD);
};


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlcnfig\pdlcnfig.cpp ===
// pdlcnfig.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "pdlcnfig.h"
#include "OutPage.h"
#include "SetPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPdlConfigApp

BEGIN_MESSAGE_MAP(CPdlConfigApp, CWinApp)
    //{{AFX_MSG_MAP(CPdlConfigApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPdlConfigApp construction

CPdlConfigApp::CPdlConfigApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CPdlConfigApp object

CPdlConfigApp theApp;

/////////////////////////////////////////////////////////////////////////////
// Test for installation of the service.

LONG CPdlConfigApp::PerfLogServiceStatus()
{
    HKEY    hKeyLogService;
    LONG    lStatus;

    // try opening the key to the service
    lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\PerfDataLog"),
        0,
        KEY_READ | KEY_WRITE,
        &hKeyLogService);

    if (lStatus == ERROR_SUCCESS) {
        // don't keep the key open
        RegCloseKey (hKeyLogService);
    }

    return lStatus;
}

LONG CPdlConfigApp::ServiceFilesCopied()
{
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    LONG    lStatus = ERROR_SUCCESS;
    TCHAR   szFullPathName[MAX_PATH];

    ExpandEnvironmentStrings (
    	TEXT("%windir%\\system32\\pdlsvc.exe"),
    	szFullPathName, MAX_PATH);

    hFile = CreateFile (
        szFullPathName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        lStatus = GetLastError();
    } else {
        CloseHandle (hFile);
        lStatus = ERROR_SUCCESS;
    }

    return lStatus;
}

/////////////////////////////////////////////////////////////////////////////
// CPdlConfigApp initialization

LONG    CPdlConfigApp::CreatePerfDataLogService ()
{
	LONG	lStatus = ERROR_SUCCESS;
	HKEY	hKeyServices = NULL;
	HKEY	hKeyPerfLog = NULL;
	HKEY	hKeyPerfAlert = NULL;
    DWORD   dwWaitLimit = 20;
    SC_HANDLE   hSC;
    SC_HANDLE   hLogService;

	// create service

    hSC = OpenSCManager (NULL, NULL, SC_MANAGER_CREATE_SERVICE);

    if (hSC == NULL) {
		// display error message
        lStatus = GetLastError();
    }

    if (lStatus == ERROR_SUCCESS) {
        hLogService = CreateService (hSC,
            TEXT("PerfDataLog"),
            TEXT("Performance Data Log"),
            SERVICE_ALL_ACCESS,
            SERVICE_WIN32_OWN_PROCESS,
            SERVICE_DEMAND_START,
            SERVICE_ERROR_NORMAL,
            TEXT("%systemroot%\\system32\\pdlsvc.exe"),
            NULL,
            NULL,
            NULL,
            NULL,
            NULL);

        if (hLogService == NULL) {
            lStatus = GetLastError();
        } else {
            lStatus = ERROR_SUCCESS;
            CloseServiceHandle (hLogService);
        }

        if (lStatus == ERROR_SUCCESS) {
            // wait until the registry is updated before continuing
            while (lStatus = RegOpenKeyEx (
		        HKEY_LOCAL_MACHINE,
		        TEXT("System\\CurrentControlSet\\Services\\PerfDataLog"),
		        0,
		        KEY_READ | KEY_WRITE,
		        &hKeyPerfLog) != ERROR_SUCCESS) {
                Sleep (500);    // wait .5 seconds and try again
                if (--dwWaitLimit == 0) {
                    AfxMessageBox (IDS_SC_CREATE_ERROR);
                    break;
                }
            }

            if (lStatus == ERROR_SUCCESS) {
                RegCloseKey (hKeyPerfLog);
            }
        }

        CloseServiceHandle (hSC);
    }

	return lStatus;
}

LONG CPdlConfigApp::InitPerfDataLogRegistry ()
{
	LONG	lStatus = ERROR_SUCCESS;

	HKEY	hKeyPerfLog = NULL;
	HKEY	hKeyLogQueries = NULL;
	HKEY	hKeyLogQueriesDefault = NULL;

	HKEY	hKeyPerfAlert = NULL;
	HKEY	hKeyAlertQueries = NULL;
	HKEY	hKeyAlertQueriesDefault = NULL;

    HKEY    hKeyEventLogApplication = NULL;
    HKEY    hKeyEventLogPerfDataLog = NULL;
    HKEY    hKeyEventLogPerfDataAlert = NULL;

	DWORD	dwValue;
	DWORD	dwDisposition;

	// open registry key

	lStatus = RegOpenKeyEx (
		HKEY_LOCAL_MACHINE,
		TEXT("System\\CurrentControlSet\\Services\\PerfDataLog"),
		0,
		KEY_READ | KEY_WRITE,
		&hKeyPerfLog);
    ASSERT (lStatus == ERROR_SUCCESS);
    if (lStatus != ERROR_SUCCESS) goto Close_And_Exit;

	// add registry subkeys for Log Queries
	lStatus = RegCreateKeyEx (
		hKeyPerfLog,
		TEXT("Log Queries"),
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_READ | KEY_WRITE,
		NULL,
		&hKeyLogQueries,
		&dwDisposition);
    ASSERT (lStatus == ERROR_SUCCESS);
    if (lStatus != ERROR_SUCCESS) goto Close_And_Exit;

	lStatus = RegCreateKeyEx (
		hKeyLogQueries,
		TEXT("Default"),
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_READ | KEY_WRITE,
		NULL,
		&hKeyLogQueriesDefault,
		&dwDisposition);
    ASSERT (lStatus == ERROR_SUCCESS);
    if (lStatus != ERROR_SUCCESS) goto Close_And_Exit;

	// open registry key
	lStatus = RegOpenKeyEx (
		HKEY_LOCAL_MACHINE,
		TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application"),
		0,
		KEY_READ | KEY_WRITE,
		&hKeyEventLogApplication);
    ASSERT (lStatus == ERROR_SUCCESS);
    if (lStatus != ERROR_SUCCESS) goto Close_And_Exit;

	// add registry subkeys for event log

	lStatus = RegCreateKeyEx (
		hKeyEventLogApplication,
		TEXT("PerfDataLog"),
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_READ | KEY_WRITE,
		NULL,
		&hKeyEventLogPerfDataLog,
		&dwDisposition);
    ASSERT (lStatus == ERROR_SUCCESS);
    if (lStatus != ERROR_SUCCESS) goto Close_And_Exit;

	lStatus = RegSetValueEx (hKeyEventLogPerfDataLog,
		TEXT("EventMessageFile"),
		0,
		REG_SZ,
		(BYTE *)TEXT("%systemroot%\\system32\\pdlsvc.exe"),
		(lstrlen(TEXT("%systemroot%\\system32\\pdlsvc.exe"))+1) * sizeof (TCHAR));
    ASSERT (lStatus == ERROR_SUCCESS);
    if (lStatus != ERROR_SUCCESS) goto Close_And_Exit;

	dwValue = 7;
    lStatus = RegSetValueEx (hKeyEventLogPerfDataLog,
		TEXT("TypesSupported"),
		0,
		REG_DWORD,
		(BYTE *)&dwValue,
		sizeof (DWORD));
    ASSERT (lStatus == ERROR_SUCCESS);
    if (lStatus != ERROR_SUCCESS) goto Close_And_Exit;

Close_And_Exit:

	if (hKeyPerfLog != NULL) RegCloseKey (hKeyPerfLog);
	if (hKeyLogQueries != NULL) RegCloseKey (hKeyLogQueries);
	if (hKeyLogQueriesDefault != NULL) RegCloseKey (hKeyLogQueriesDefault);

    if (hKeyEventLogApplication != NULL) RegCloseKey (hKeyEventLogApplication);
  	if (hKeyEventLogPerfDataLog != NULL) RegCloseKey (hKeyEventLogPerfDataLog);

	return lStatus;
}

/////////////////////////////////////////////////////////////////////////////
// CPdlConfigApp initialization

BOOL CPdlConfigApp::InitInstance()
{
    LONG    lServiceStatus;
    CString csMessage;
    BOOL    bReturn = TRUE;

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();            // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();    // Call this when linking to MFC statically
#endif

    lServiceStatus = PerfLogServiceStatus();

    if (lServiceStatus == ERROR_FILE_NOT_FOUND) {
        lServiceStatus = ServiceFilesCopied();
        if (lServiceStatus == ERROR_SUCCESS) {
            if (AfxMessageBox (IDS_QUERY_INSTALL,
                MB_OKCANCEL | MB_ICONQUESTION) == IDOK) {
                lServiceStatus = CreatePerfDataLogService();
                if (lServiceStatus == ERROR_SUCCESS) {
                    lServiceStatus = InitPerfDataLogRegistry();
                }
                if (lServiceStatus != ERROR_SUCCESS) {
                    csMessage.FormatMessage (lServiceStatus);
                    AfxMessageBox (csMessage);
                    bReturn = FALSE;
                } else {
                    // the service was successfully installed so display
                    // message
                    AfxMessageBox (IDS_SERVICE_INSTALLED);
                }
            } else {
                // the service is not installed and the user doesn't
                // want it installed so exit
                bReturn = FALSE;
            }
        } else {
            // then the service has not yet been installed so bail
            AfxMessageBox (IDS_SERVICE_NOT_INSTALLED);
            bReturn = FALSE;
        }
    } else if (lServiceStatus == ERROR_ACCESS_DENIED) {
        AfxMessageBox (IDS_ACCESS_DENIED, MB_OK | MB_ICONEXCLAMATION);
        bReturn = FALSE;
    } else if (lServiceStatus != ERROR_SUCCESS) {
        AfxMessageBox (IDS_REGISTRY_ERROR, MB_OK | MB_ICONEXCLAMATION);
        bReturn = FALSE;
    } else {
        bReturn = TRUE;
    }

    if (bReturn) {
        CPropertySheet      PSheet;
        COutputPropPage     POutput;
        CSettingsPropPage   PSettings;

        m_pMainWnd = &PSheet;

        csMessage.LoadString (IDS_PROPERTY_SHEET_CAPTION);
        PSheet.SetTitle(csMessage);
        PSheet.AddPage(&PSettings);
        PSheet.AddPage(&POutput);

        INT_PTR nResponse = PSheet.DoModal();
        if (nResponse == IDOK)
        {
            // TODO: Place code here to handle when the dialog is
            //  dismissed with OK
        }
        else if (nResponse == IDCANCEL)
        {
            // TODO: Place code here to handle when the dialog is
            //  dismissed with Cancel
        }
        bReturn = FALSE;
    }

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlcnfig\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//    pdlcnfig.pch will be the pre-compiled header
//    stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlsvc\logutils.h ===
#ifndef _LOG_UTILS_H_
#define _LOG_UTILS_H_

#define LOG_READ_ACCESS     0x00010000
#define LOG_WRITE_ACCESS    0x00020000
#define LOG_ACCESS_MASK     0x000F0000
#define LOG_CREATE_NEW      0x00000001
#define LOG_CREATE_ALWAYS   0x00000002
#define LOG_OPEN_ALWAYS     0x00000003
#define LOG_OPEN_EXISTING   0x00000004
#define LOG_CREATE_MASK     0x0000000F

#define FLAGS_CLOSE_QUERY   0x00000001

#define DWORD_MULTIPLE(x) ((((x)+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define CLEAR_FIRST_FOUR_BYTES(x)     *(DWORD *)(x) = 0L


LONG __stdcall
OpenLogW (
    IN      LPCWSTR szLogFileName,
    IN      DWORD   dwAccessFlags,
    IN      LPDWORD lpdwLogType,
    IN      HQUERY  hQuery,
    IN      DWORD   dwMaxRecords
);

LONG __stdcall UpdateLog (
    IN  LPDWORD pdwSampleTime);

LONG __stdcall CloseLog(IN  DWORD dwFlags);

LONG __stdcall GetLogFileSize (IN  LONGLONG    *llSize);

#endif   // _LOG_UTILS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlsvc\logthred.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    LogThred.c

Abstract:

    module containing logging thread functions

Author:

    Bob Watson (a-robw) 10 Apr 96

Revision History:

--*/
#ifndef UNICODE
#define UNICODE     1
#endif
#ifndef _UNICODE
#define _UNICODE    1
#endif
//
//  Windows Include files
//
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <pdh.h>
#include <pdhmsg.h>
#include "pdlsvc.h"
//#include "logutils.h"
#include "pdlmsg.h"

static
long
JulianDateFromSystemTime(
    SYSTEMTIME *pST
)
{
    static WORD wDaysInRegularMonth[] = {
    	31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };

    static WORD wDaysInLeapYearMonth[] = {
    	31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366
    };

    long JDate = 0;

    // Check for leap year.
    if (pST->wMonth > 1) {
        if( pST->wYear % 100 != 0 && pST->wYear % 4 == 0 ) {
	    // this is a leap year
	    JDate += wDaysInLeapYearMonth[pST->wMonth - 1];
	} else {
	    // this is not a leap year
            JDate += wDaysInRegularMonth[pST->wMonth - 1];
        }
    }
    // Add in days for this month.
    JDate += pST->wDay;

    // Add in year.
    JDate += (pST->wYear % 100) * 10000;

    return JDate;
}

static
BOOL
GetLocalFileTime (
    SYSTEMTIME  *pST,
    LONGLONG    *pFileTime
)
{
    BOOL    bResult;
    GetLocalTime (pST);
    if (pFileTime != NULL) {
        bResult = SystemTimeToFileTime (pST, (LPFILETIME)pFileTime);
    } else {
        bResult = TRUE;
    }
    return bResult;
}

static
DWORD
GetSamplesInRenameInterval(
    IN DWORD    dwSampleInterval,           // in seconds
    IN DWORD    dwRenameIntervalCount,      // in units
    IN DWORD    dwRenameIntervalUnits)      // for "count" arg
{
    DWORD    dwRenameIntervalSeconds;
    // convert rename interval to seconds and account for the
    // first (or zero-th) sample in the log

    dwRenameIntervalSeconds = dwRenameIntervalCount;

    switch (dwRenameIntervalUnits) {
        case OPD_RENAME_HOURS:
            dwRenameIntervalSeconds *= SECONDS_IN_HOUR;
            break;

        case OPD_RENAME_DAYS:
        default:
            dwRenameIntervalSeconds *= SECONDS_IN_DAY;
            break;

        case OPD_RENAME_MONTHS:
            dwRenameIntervalSeconds *= SECONDS_IN_DAY * 30;
            break;

        case OPD_RENAME_KBYTES:
        case OPD_RENAME_MBYTES:
            // these don't use a rename counter
            return (DWORD)0;
            break;
    }

    dwRenameIntervalSeconds /= dwSampleInterval;

    dwRenameIntervalSeconds += 1;   // add in the "zero-th" sample

    return (dwRenameIntervalSeconds);
}

static
LONG
BuildCurrentLogFileName (
    IN  LPCTSTR     szBaseFileName,
    IN  LPCTSTR     szDefaultDir,
    IN  LPTSTR      szOutFileBuffer,
    IN  LPDWORD     lpdwSerialNumber,
    IN  DWORD       dwDateFormat,
    IN  DWORD       dwLogFormat
)
// presumes OutFileBuffer is large enough (i.e. >= MAX_PATH)
{
    SYSTEMTIME  st;
    BOOL        bUseCurrentDir = FALSE;
    TCHAR       szAuto[MAX_PATH];
    LPTSTR      szExt;

    if (szDefaultDir != NULL) {
        if (*szDefaultDir == 0) {
            bUseCurrentDir = TRUE;
        }
    } else {
        bUseCurrentDir = TRUE;
    }

    if (bUseCurrentDir) {
        GetCurrentDirectory (MAX_PATH, szOutFileBuffer);
    } else {
        lstrcpy (szOutFileBuffer, szDefaultDir);
    }

    // add a backslash to the path name if it doesn't have one already

    if (szOutFileBuffer[lstrlen(szOutFileBuffer)-1] != TEXT('\\')) {
        lstrcat (szOutFileBuffer, TEXT("\\"));
    }

    // add the base filename

    lstrcat (szOutFileBuffer, szBaseFileName);

    // add the auto name part

    // get date/time/serial integer format
    GetLocalTime(&st);

    switch (dwDateFormat) {
    case OPD_NAME_NNNNNN:
        _stprintf (szAuto, TEXT("_%6.6d"), *lpdwSerialNumber);
        (*lpdwSerialNumber)++; // increment
        if (*lpdwSerialNumber >= 1000000) {
            // roll over to 0
            *lpdwSerialNumber = 0;
        }
        break;

    case OPD_NAME_YYDDD:
        _stprintf (szAuto, TEXT("_%5.5d"),
            JulianDateFromSystemTime(&st));
        break;

    case OPD_NAME_YYMM:
        _stprintf (szAuto, TEXT("_%2.2d%2.2d"),
            st.wYear % 100, st.wMonth);
        break;

    case OPD_NAME_YYMMDDHH:
        _stprintf (szAuto, TEXT("_%2.2d%2.2d%2.2d%2.2d"),
            (st.wYear % 100), st.wMonth, st.wDay, st.wHour);
        break;

    case OPD_NAME_MMDDHH:
        _stprintf (szAuto, TEXT("_%2.2d%2.2d%2.2d"),
            st.wMonth, st.wDay, st.wHour);
        break;

    case OPD_NAME_YYMMDD:
    default:
        _stprintf (szAuto, TEXT("_%2.2d%2.2d%2.2d"),
            st.wYear % 100, st.wMonth, st.wDay);
        break;
    }

    lstrcat (szOutFileBuffer, szAuto);

    // get file type
    switch (dwLogFormat) {
    case PDH_LOG_TYPE_TSV:
        szExt = TEXT(".tsv");
        break;

    case PDH_LOG_TYPE_BINARY:
        szExt = TEXT(".blg");
        break;

    case PDH_LOG_TYPE_CSV:
    default:
        szExt = TEXT(".csv");
        break;
    }

    lstrcat (szOutFileBuffer, szExt);

    return ERROR_SUCCESS;
}

static
BOOL
LoadDataFromRegistry (
    IN  LPLOG_THREAD_DATA   pArg,
    IN  LPTSTR              szDefaultDir,
    IN  LPTSTR              szBaseName,
    IN  LPTSTR              szCurrentLogFile
)
{
    LONG            lStatus;
    DWORD           dwType;
    DWORD           dwSize;
    DWORD           dwData;
    LPTSTR          szStringArray[2];

    // get size of buffer required by counter list,
    // then allocate the buffer and retrieve the counter list

    dwType = 0;
    dwData = 0;
    dwSize = 0;
    lStatus = RegQueryValueEx (
        pArg->hKeyQuery,
        TEXT("Counter List"),
        NULL,
        &dwType,
        (LPBYTE)NULL,
        &dwSize);

    pArg->mszCounterList = (LPTSTR)G_ALLOC(dwSize);

    if (pArg->mszCounterList != NULL) {
        dwType = 0;
        lStatus = RegQueryValueEx (
            pArg->hKeyQuery,
            TEXT("Counter List"),
            NULL,
            &dwType,
            (LPBYTE)pArg->mszCounterList,
            &dwSize);

        if ((lStatus != ERROR_SUCCESS) || (dwSize == 0)) {
            // no counter list retrieved so there's not much
            // point in continuing
            szStringArray[0] = pArg->szQueryName;
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFLOG_UNABLE_READ_COUNTER_LIST,
                NULL,
                1,
                sizeof(DWORD),
                szStringArray,
                (LPVOID)&lStatus);
            return FALSE;
        }
    } else {
        szStringArray[0] = pArg->szQueryName;
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFLOG_UNABLE_ALLOC_COUNTER_LIST,
            NULL,
            1,
            sizeof(DWORD),
            szStringArray,
            (LPVOID)&lStatus);
        return FALSE;
    }

    dwType = 0;
    dwData = 0;
    dwSize = sizeof(DWORD);
    lStatus = RegQueryValueEx (
        pArg->hKeyQuery,
        TEXT("Auto Name Interval"),
        NULL,
        &dwType,
        (LPBYTE)&dwData,
        &dwSize);
    if (lStatus != ERROR_SUCCESS) {
        dwData = 0; // default is no autonaming
    } else if (dwType != REG_DWORD) {
        dwData = 0; // default is no autonaming
    } // else assume success

    pArg->dwRenameIntervalCount = dwData;

    dwType = 0;
    dwData = 0;
    dwSize = sizeof(DWORD);
    lStatus = RegQueryValueEx (
        pArg->hKeyQuery,
        TEXT("Auto Rename Units"),
        NULL,
        &dwType,
        (LPBYTE)&dwData,
        &dwSize);
    if (lStatus != ERROR_SUCCESS) {
        dwData = OPD_RENAME_DAYS; // default is days
    } else if (dwType != REG_DWORD) {
        dwData = OPD_RENAME_DAYS; // default is days
    } // else assume success

    pArg->dwRenameIntervalUnits = dwData;

    dwType = 0;
    dwData = 0;
    dwSize = sizeof(DWORD);
    lStatus = RegQueryValueEx (
        pArg->hKeyQuery,
        TEXT("Log File Auto Format"),
        NULL,
        &dwType,
        (LPBYTE)&dwData,
        &dwSize);
    if (lStatus != ERROR_SUCCESS) {
        dwData = OPD_NAME_NNNNNN; // default is a serial number
    } else if (dwType != REG_DWORD) {
        dwData = OPD_NAME_NNNNNN; // default is a serial number
    } // else assume success

    pArg->dwAutoNameFormat = dwData;

    dwType = 0;
    dwData = 0;
    dwSize = sizeof(DWORD);
    lStatus = RegQueryValueEx (
        pArg->hKeyQuery,
        TEXT("Log File Type"),
        NULL,
        &dwType,
        (LPBYTE)&dwData,
        &dwSize);
    if (lStatus != ERROR_SUCCESS) {
        dwData = OPD_CSV_FILE; // default is a CSV file
    } else if (dwType != REG_DWORD) {
        dwData = OPD_CSV_FILE; // default is a CSV file
    } // else assume success

    // convert from OPD to PDH constant
    switch (dwData) {
        case OPD_TSV_FILE:
            pArg->dwLogType = PDH_LOG_TYPE_TSV;
            break;

        case OPD_BIN_FILE:
            pArg->dwLogType = PDH_LOG_TYPE_BINARY;
            break;

        case OPD_CSV_FILE:
        default:
            pArg->dwLogType = PDH_LOG_TYPE_CSV;
            break;
    }

    dwType = 0;
    dwData = 0;
    dwSize = sizeof(DWORD);
    lStatus = RegQueryValueEx (
        pArg->hKeyQuery,
        TEXT("Sample Interval"),
        NULL,
        &dwType,
        (LPBYTE)&dwData,
        &dwSize);
    if (lStatus != ERROR_SUCCESS) {
        dwData = SECONDS_IN_MINUTE; // default is 1 Minute samples
    } else if (dwType != REG_DWORD) {
        dwData = SECONDS_IN_MINUTE; // default is 1 Minute samples
    } // else assume success

    pArg->dwTimeInterval = dwData;

    // get filename or components if auto name

    if (pArg->dwRenameIntervalCount > 0) {
        // this is an autoname file so get components
        dwType = 0;
        *szDefaultDir = 0;
        dwSize = MAX_PATH * sizeof(TCHAR);
        lStatus = RegQueryValueEx (
            pArg->hKeyQuery,
            TEXT("Log Default Directory"),
            NULL,
            &dwType,
            (LPBYTE)&szDefaultDir[0],
            &dwSize);
        if (lStatus != ERROR_SUCCESS) {
            *szDefaultDir = 0;
        } // else assume success

        dwType = 0;
        *szBaseName = 0;
        dwSize = MAX_PATH * sizeof(TCHAR);
        lStatus = RegQueryValueEx (
            pArg->hKeyQuery,
            TEXT("Base Filename"),
            NULL,
            &dwType,
            (LPBYTE)&szBaseName[0],
            &dwSize);
        if (lStatus != ERROR_SUCCESS) {
            // apply default
            lstrcpy (szBaseName, TEXT("perfdata"));
        } // else assume success

        dwType = 0;
        dwSize = 0;
        lStatus = RegQueryValueEx (
            pArg->hKeyQuery,
            TEXT("Command File"),
            NULL,
            &dwType,
            NULL,
            &dwSize);
        if (lStatus != ERROR_SUCCESS) {
            // assume no command filname
            pArg->szCmdFileName = NULL;
        } else {
            // allocate a buffer for this field and collect data
            pArg->szCmdFileName = (LPTSTR)G_ALLOC(dwSize);
            if (pArg->szCmdFileName != NULL) {
                // get command filename
                dwType = 0;
                lStatus = RegQueryValueEx (
                    pArg->hKeyQuery,
                    TEXT("Command File"),
                    NULL,
                    &dwType,
                    (LPBYTE)pArg->szCmdFileName,
                    &dwSize);
                if (lStatus != ERROR_SUCCESS) {
                    // apply default
                    pArg->szCmdFileName = NULL;
                } // else assume success
            }
            if (pArg->szCmdFileName == NULL) {
                // log error message
                // no command file could be read so issue
                // warning and continue
                szStringArray[0] = pArg->szQueryName;
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    PERFLOG_ALLOC_CMDFILE_BUFFER,
                    NULL,
                    1,
                    sizeof(DWORD),
                    szStringArray,
                    (LPVOID)&lStatus);
            }
        }

    } else {
        // this is a manual name file so read name
        dwType = 0;
        *szCurrentLogFile = 0;
        dwSize = MAX_PATH * sizeof(TCHAR);
        lStatus = RegQueryValueEx (
            pArg->hKeyQuery,
            TEXT("Log Filename"),
            NULL,
            &dwType,
            (LPBYTE)&szCurrentLogFile[0],
            &dwSize);
        if (lStatus != ERROR_SUCCESS) {
            // apply default
            lstrcpy (szCurrentLogFile, TEXT("c:\\perfdata.log"));
        } // else assume success
    }

    dwType = 0;
    dwData = 0;
    dwSize = sizeof(DWORD);
    lStatus = RegQueryValueEx (
        pArg->hKeyQuery,
        TEXT("Log File Serial Number"),
        NULL,
        &dwType,
        (LPBYTE)&dwData,
        &dwSize);
    if (lStatus != ERROR_SUCCESS) {
        dwData = 1; // default is to start at 1
    } else if (dwType != REG_DWORD) {
        dwData = 1; // default is to start at 1
    } // else assume success

    pArg->dwCurrentSerialNumber = dwData;
    return TRUE;
}

static
LONG
DoCommandFile (
    IN  LPLOG_THREAD_DATA   pArg,
    IN  LPTSTR              szLogFileName,
    IN  BOOL                bStillRunning
)
{
    LONG    lStatus;
    BOOL    bStatus;
    LPTSTR  szCommandString;
    LONG    nErrorMode;
    TCHAR   TempBuffer [ 5 * MAX_PATH] ;
    DWORD   StringLen;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD          dwCreationFlags = NORMAL_PRIORITY_CLASS;

    szCommandString = (LPTSTR)G_ALLOC(4096 * sizeof(TCHAR));

    if (szCommandString != NULL) {
        // build command line arguments
        szCommandString[0] = _T('\"');
        lstrcpy (&szCommandString[1], szLogFileName);
        lstrcat (szCommandString, TEXT("\" "));
        lstrcat (szCommandString,
            (bStillRunning ? TEXT("1") : TEXT("0")));

        // initialize Startup Info block
        memset (&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.dwFlags = STARTF_USESHOWWINDOW ;
        si.wShowWindow = SW_SHOWNOACTIVATE ;

        memset (&pi, 0, sizeof(pi));

        // supress pop-ups inf the detached process
        nErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

        lstrcpy (TempBuffer, pArg->szCmdFileName) ;

        // see if this is a CMD or a BAT file
        // if it is then create a process with a console window, otherwise
        // assume it's an executable file that will create it's own window
        // or console if necessary
        //
        _tcslwr (TempBuffer);
        if ((_tcsstr(TempBuffer, TEXT(".bat")) != NULL) ||
            (_tcsstr(TempBuffer, TEXT(".cmd")) != NULL)){
                dwCreationFlags |= CREATE_NEW_CONSOLE;
        } else {
                dwCreationFlags |= DETACHED_PROCESS;
        }
        // recopy the image name to the temp buffer since it was modified
        // (i.e. lowercased) for the previous comparison.

        lstrcpy (TempBuffer, pArg->szCmdFileName) ;
        StringLen = lstrlen (TempBuffer) ;

        // now add on the alert text preceded with a space char
        TempBuffer [StringLen] = TEXT(' ') ;
        StringLen++ ;
        lstrcpy (&TempBuffer[StringLen], szCommandString) ;

        bStatus = CreateProcess (
            NULL,
            TempBuffer,
            NULL, NULL, FALSE,
            dwCreationFlags,
            NULL,
            NULL,
            &si,
            &pi);

        SetErrorMode(nErrorMode);

        if (bStatus) {
            lStatus = ERROR_SUCCESS;
        } else {
            lStatus = GetLastError();
        }

    } else {
        lStatus = ERROR_OUTOFMEMORY;
    }

    return lStatus;
}

BOOL
LoggingProc (
    IN    LPLOG_THREAD_DATA pArg
)
{
    HQUERY          hQuery;
    HCOUNTER        hThisCounter;
    HLOG            hLog;
    DWORD           dwDelay;
    DWORD           dwSampleInterval, dwSampleTime=-1;
    PDH_STATUS      pdhStatus;
    DWORD           dwNumCounters;
    LONG            lStatus;
    TCHAR           szDefaultDir[MAX_PATH];
    TCHAR           szBaseName[MAX_PATH];

    LPTSTR          szThisPath;
    DWORD           dwLogType = PDH_LOG_TYPE_CSV;
    BOOL            bRun = FALSE;
    DWORD           dwSamplesUntilNewFile;
    TCHAR           szCurrentLogFile[MAX_PATH];
    LONG            lWaitStatus;
    LPTSTR          szStringArray[4];
    DWORD           dwFileSizeLimit;
    LONGLONG        llFileSizeLimit;
    LONGLONG        llFileSize;
    PLOG_COUNTER_INFO   pCtrInfo;

	SYSTEMTIME	    st;
    LONGLONG        llStartTime = 0;
    LONGLONG        llFinishTime = 0;

    // read registry values

    if (!LoadDataFromRegistry (pArg, szDefaultDir, szBaseName, szCurrentLogFile)) {
        // unable to initialize the query from the registry
        return FALSE;
    }

    // convert to milliseconds for use in timeouts
    dwSampleInterval = pArg->dwTimeInterval * 1000L;

    // open query and add counters from info file

    pdhStatus = PdhOpenQuery (NULL, 0, &hQuery); // from current activity
    if (pdhStatus == ERROR_SUCCESS) {
        dwNumCounters = 0;
        for (szThisPath = pArg->mszCounterList;
            *szThisPath != 0;
            szThisPath += lstrlen(szThisPath) + 1) {
            pdhStatus = PdhAddCounter (hQuery,
                (LPTSTR)szThisPath, dwNumCounters++, &hThisCounter);

            if (pdhStatus == ERROR_SUCCESS) {
                // then add this handle to the list
                pCtrInfo = G_ALLOC (sizeof (LOG_COUNTER_INFO));
                if (pCtrInfo != NULL) {
                    // insert at front of list since the order isn't
                    // important and this is simpler than walking the
                    // list each time.
                    pCtrInfo->hCounter = hThisCounter;
                    pCtrInfo->next = pFirstCounter;
                    pFirstCounter = pCtrInfo;
                }
            }
        }

        // to make sure we get to log the data
        SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

        bRun = TRUE;
        while (bRun) {
            // Get the current Log filename
            if (pArg->dwRenameIntervalCount != 0) {
                // then this is an autonamed file
                // so make current name
                BuildCurrentLogFileName (
                    szBaseName,
                    szDefaultDir,
                    szCurrentLogFile,
                    &pArg->dwCurrentSerialNumber,
                    pArg->dwAutoNameFormat,
                    pArg->dwLogType);
                // reset loop counter
                switch (pArg->dwRenameIntervalUnits) {
                case OPD_RENAME_KBYTES:
                    dwFileSizeLimit = pArg->dwRenameIntervalCount * 1024;
                    dwSamplesUntilNewFile = 0;
                    break;

                case OPD_RENAME_MBYTES:
                    dwFileSizeLimit = pArg->dwRenameIntervalCount * 1024 * 1024;
                    dwSamplesUntilNewFile = 0;
                    break;

                case OPD_RENAME_HOURS:
                case OPD_RENAME_DAYS:
                case OPD_RENAME_MONTHS:
                default:
                    dwSamplesUntilNewFile = GetSamplesInRenameInterval(
                        pArg->dwTimeInterval,
                        pArg->dwRenameIntervalCount,
                        pArg->dwRenameIntervalUnits);
                    dwFileSizeLimit = 0;
                    break;
                }
            } else {
                // filename is left as read from the registry
                dwSamplesUntilNewFile = 0;
                dwFileSizeLimit = 0;
            }
            llFileSizeLimit = dwFileSizeLimit;
            // open log file using this query
            dwLogType = pArg->dwLogType;
            pdhStatus = PdhOpenLog (
                szCurrentLogFile,
                PDH_LOG_WRITE_ACCESS |
                    PDH_LOG_CREATE_ALWAYS,
                &dwLogType,
                hQuery,
                0,
                NULL,
                &hLog);

            if (pdhStatus == ERROR_SUCCESS) {
                szStringArray[0] = pArg->szQueryName;
                szStringArray[1] = szCurrentLogFile;
                ReportEvent (hEventLog,
                    EVENTLOG_INFORMATION_TYPE,
                    0,
                    PERFLOG_LOGGING_QUERY,
                    NULL,
                    2,
                    0,
                    szStringArray,
                    NULL);
                // start sampling immediately
                dwDelay = 0;
                while ((lWaitStatus = WaitForSingleObject (pArg->hExitEvent, dwDelay)) == WAIT_TIMEOUT) {
                    // the event flag will be set when the sampling should exit. if
                    // the wait times out, then that means it's time to collect and
                    // log another sample of data.
                    // time the call to adjust the wait time

                    GetLocalFileTime (&st, &llStartTime);

                    pdhStatus = PdhUpdateLog (hLog, NULL);

                    if (pdhStatus == ERROR_SUCCESS) {
                        // see if it's time to rename the file
                        if (dwSamplesUntilNewFile) {
                            if (!--dwSamplesUntilNewFile) break;
                        } else if (llFileSizeLimit) {
                            // see if the file is too big
                            pdhStatus = PdhGetLogFileSize (hLog, &llFileSize);
                            if (pdhStatus == ERROR_SUCCESS) {
                                if (llFileSizeLimit <= llFileSize) break;
                            }
                        }
                        // compute new timeout value
                        if (dwSampleTime < dwSampleInterval) {
                            dwDelay = dwSampleInterval - dwSampleTime;
                        } else {
                            dwDelay = 0;
                        }
                    } else {
                        // unable to update the log so log event and exit
                        ReportEvent (hEventLog,
                            EVENTLOG_ERROR_TYPE,
                            0,
                            PERFLOG_UNABLE_UPDATE_LOG,
                            NULL,
                            0,
                            sizeof(DWORD),
                            NULL,
                            (LPVOID)&pdhStatus);

                        bRun = FALSE;
                        break;
                    }
                    GetLocalFileTime (&st, &llFinishTime);
                    // compute difference and convert to milliseconds
                    dwSampleTime = (DWORD)((llFinishTime - llStartTime) / 10000L);
                } // end while wait keeps timing out
                if (lWaitStatus == WAIT_OBJECT_0) {
                    // then the loop was terminated by the Exit event
                    // so clear the "run" flag to exit the loop & thread
                    bRun = FALSE;
                }

                // close log file, but keep query open
                PdhCloseLog (hLog, 0);

                if (pArg->szCmdFileName != NULL) {
                    DoCommandFile (pArg, szCurrentLogFile, bRun);
                }
            } else {
                // unable to open log file so log event log message
                szStringArray[0] = szCurrentLogFile;
                ReportEvent (hEventLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    PERFLOG_UNABLE_OPEN_LOG_FILE,
                    NULL,
                    1,
                    sizeof(DWORD),
                    szStringArray,
                    (LPVOID)&pdhStatus);

                bRun = FALSE; // exit now
            }
        } // end while (bRun)
        PdhCloseQuery (hQuery);

        // update log serial number if necssary
        if (pArg->dwAutoNameFormat == OPD_NAME_NNNNNN) {
            lStatus = RegSetValueEx (
                pArg->hKeyQuery,
                TEXT("Log File Serial Number"),
                0L,
                REG_DWORD,
                (LPBYTE)&pArg->dwCurrentSerialNumber,
                sizeof(DWORD));
        }
    } else {
        // unable to open query so write event log message
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFLOG_UNABLE_OPEN_LOG_QUERY,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&pdhStatus);

    }

    // free allocated buffers
    if (pArg->mszCounterList != NULL) {
        G_FREE(pArg->mszCounterList);
        pArg->mszCounterList = NULL;
    }

    if (pArg->szCmdFileName != NULL) {
        G_FREE(pArg->szCmdFileName);
        pArg->szCmdFileName = NULL;
    }

    return bRun;
}

DWORD
LoggingThreadProc (
    IN    LPVOID    lpThreadArg
)
{
    LPLOG_THREAD_DATA   pThreadData = (LPLOG_THREAD_DATA)lpThreadArg;
    DWORD               dwStatus = ERROR_SUCCESS;
    BOOL                bContinue = TRUE;

    if (pThreadData != NULL) {
        // read config from registry

        do {
            // read config from registry
            // expand counter paths as necessary
            // call Logging function
            bContinue = LoggingProc (pThreadData);
            // see if this thread was paused for reloading
            // or stopped to terminate
            if (pThreadData->bReloadNewConfig) {
                bContinue = TRUE;
            } // else  bContinue is always returned as FALSE
            // so that will terminate this loop
        } while (bContinue);
        dwStatus = ERROR_SUCCESS;
    } else {
        // unable to find data block so return
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlsvc\pdlsvc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pdlsvc.c

Abstract:

    service to log performance data

Author:

    Bob Watson (a-robw) 10 Apr 96

Revision History:

--*/
#ifndef UNICODE
#define UNICODE     1
#endif

#ifndef _UNICODE
#define _UNICODE    1
#endif

//
//  Windows Include files
//
#include <windows.h>
#include <tchar.h>

#include "pdlsvc.h"
#include "pdlmsg.h"

// Global variables used by all modules
HANDLE    hEventLog = NULL;
PLOG_COUNTER_INFO pFirstCounter = NULL;

SERVICE_STATUS_HANDLE    hPerfLogStatus;
SERVICE_STATUS    ssPerfLogStatus;

// Static variables used by this module only
static LPLOG_THREAD_DATA    pFirstThread = NULL;
static HANDLE               *pThreadHandleArray = NULL;
static DWORD                dwHandleCount = 0;
static DWORD                dwMaxHandleCount = 0;

// this is for the time being, until full multiple log query
// support is added
#define LOCAL_HANDLE_COUNT  1
static HANDLE               LocalThreadArray[LOCAL_HANDLE_COUNT];

// functions

void FreeThreadData (
    IN  LPLOG_THREAD_DATA    pThisThread
)
{
    if (pThisThread->next != NULL) {
        // free the "downstream" entries
        FreeThreadData (pThisThread->next);
        pThisThread->next = NULL;
    }
    // now free this entry
    if (pThisThread->mszCounterList != NULL) {
        G_FREE (pThisThread->mszCounterList);
        pThisThread->mszCounterList = NULL;
    }

    if (pThisThread->hExitEvent != NULL) {
        CloseHandle (pThisThread->hExitEvent);
        pThisThread->hExitEvent = NULL;
    }

    if (pThisThread->hKeyQuery != NULL) {
        RegCloseKey (pThisThread->hKeyQuery);
        pThisThread->hKeyQuery = NULL;
    }

    G_FREE (pThisThread);
}

void PerfDataLogServiceControlHandler(
    IN  DWORD dwControl
)
{
    LPLOG_THREAD_DATA    pThisThread;

    switch (dwControl) {
    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:
        // stop logging & close queries and files
        // set stop event for all running threads
        pThisThread = pFirstThread;
        while (pThisThread != NULL) {
            SetEvent (pThisThread->hExitEvent);
            pThisThread = pThisThread->next;
        }
        break;
    case SERVICE_CONTROL_PAUSE:
        // stop logging, close queries and files
        // not supported, yet
        break;
    case SERVICE_CONTROL_CONTINUE:
        // reload configuration and restart logging
        // not supported, yet
        break;
    case SERVICE_CONTROL_INTERROGATE:
        // update current status
    default:
        // report to event log that an unrecognized control
        // request was received.
        ;
    }
}

void
PerfDataLogServiceStart (
    IN  DWORD   argc,
    IN  LPTSTR  *argv
)
{
    LONG                lStatus;
    HKEY                hKeyLogQueries;
    HKEY                hKeyThisLogQuery;
    DWORD               dwQueryIndex;
    TCHAR               szQueryNameBuffer[MAX_PATH];
    DWORD               dwQueryNameBufferSize;
    TCHAR               szQueryClassBuffer[MAX_PATH];
    DWORD               dwQueryClassBufferSize;
    LPLOG_THREAD_DATA   lpThreadData;
    HANDLE              hThread;
    LPTSTR              szStringArray[2];
    DWORD               dwThreadId;

    ssPerfLogStatus.dwServiceType       = SERVICE_WIN32_OWN_PROCESS;
    ssPerfLogStatus.dwCurrentState      = SERVICE_START_PENDING;
    ssPerfLogStatus.dwControlsAccepted  = SERVICE_ACCEPT_STOP |
//        SERVICE_ACCEPT_PAUSE_CONTINUE |
        SERVICE_ACCEPT_SHUTDOWN;
    ssPerfLogStatus.dwWin32ExitCode = 0;
    ssPerfLogStatus.dwServiceSpecificExitCode = 0;
    ssPerfLogStatus.dwCheckPoint = 0;
    ssPerfLogStatus.dwWaitHint = 0;

    hPerfLogStatus = RegisterServiceCtrlHandler (
        TEXT("PerfDataLog"), PerfDataLogServiceControlHandler);

    if (hPerfLogStatus == (SERVICE_STATUS_HANDLE)0) {
        lStatus = GetLastError();
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFLOG_UNABLE_REGISTER_HANDLER,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&lStatus);
        // this is fatal so bail out
        return;
    }

    // registered the service successfully, so load the log queries
    // assign the handle buffer
    pThreadHandleArray = &LocalThreadArray[0];
    dwMaxHandleCount = LOCAL_HANDLE_COUNT;
    // open (each) query
    lStatus = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\PerfDataLog\\Log Queries"),
        0L,
        KEY_READ,
        &hKeyLogQueries);

    if (lStatus != ERROR_SUCCESS) {
        // unable to read the log query information from the registry
        lStatus = GetLastError();
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFLOG_UNABLE_OPEN_LOG_QUERY,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&lStatus);

        // we can't start the service with out the evnt log.
        ssPerfLogStatus.dwCurrentState    = SERVICE_STOPPED;
        SetServiceStatus (hPerfLogStatus, &ssPerfLogStatus);

        return;
    }

    // enumerate and start the queries in the registry
    dwQueryIndex = 0;
    *szQueryNameBuffer = 0;
    dwQueryNameBufferSize = MAX_PATH;
    *szQueryClassBuffer;
    dwQueryClassBufferSize = MAX_PATH;
    while ((lStatus = RegEnumKeyEx (
        hKeyLogQueries,
        dwQueryIndex,
        szQueryNameBuffer,
        &dwQueryNameBufferSize,
        NULL,
        szQueryClassBuffer,
        &dwQueryClassBufferSize,
        NULL)) != ERROR_NO_MORE_ITEMS) {

        // open this key
        lStatus = RegOpenKeyEx (
            hKeyLogQueries,
            szQueryNameBuffer,
            0L,
            KEY_READ | KEY_WRITE,
            &hKeyThisLogQuery);

        if (lStatus != ERROR_SUCCESS) {
            szStringArray[0] = szQueryNameBuffer;
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFLOG_UNABLE_READ_LOG_QUERY,
                NULL,
                1,
                sizeof(DWORD),
                szStringArray,
                   (LPVOID)&lStatus);
            // skip to next item
            goto CONTINUE_ENUM_LOOP;
        }

        // update the service status
        ssPerfLogStatus.dwCheckPoint++;
        SetServiceStatus (hPerfLogStatus, &ssPerfLogStatus);

        // allocate a thread info block.
        lpThreadData = G_ALLOC (sizeof(LOG_THREAD_DATA));
        if (lpThreadData == NULL) {
            lStatus = GetLastError();
            szStringArray[0] = szQueryNameBuffer;
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFLOG_UNABLE_ALLOCATE_DATABLOCK,
                NULL,
                1,
                sizeof(DWORD),
                szStringArray,
                (LPVOID)&lStatus);
            goto CONTINUE_ENUM_LOOP;
        }

        // initialize the thread data block
        lpThreadData->hKeyQuery = hKeyThisLogQuery;
        lpThreadData->hExitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        lpThreadData->bReloadNewConfig = FALSE;
        lstrcpy (lpThreadData->szQueryName, szQueryNameBuffer);

        // start logging thread
        hThread = CreateThread (
            NULL, 0, LoggingThreadProc,
            (LPVOID)lpThreadData, 0, &dwThreadId);

        if (hThread != NULL) {
            // add it to the list and continue
            if (pFirstThread == NULL) {
                // then this is the first thread so add it
                lpThreadData->next = NULL;
                pFirstThread = lpThreadData;
            } else {
                // insert this at the head of the list since
                // that's the easiest and the order isn't
                // really important
                lpThreadData->next = pFirstThread;
                pFirstThread = lpThreadData;
            }
            // add thread to array for termination wait
            if (dwHandleCount < dwMaxHandleCount) {
                pThreadHandleArray[dwHandleCount++] = hThread;
            } else {
                // realloc buffer and try again
                // this will be added when multi-query
                // support is added. for now we'll ignore
                // ones that don't fit.
            }
            lpThreadData = NULL; //clear for next lap
        } else {
            // unable to start thread
            lStatus = GetLastError();
            szStringArray[0] = szQueryNameBuffer;
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFLOG_UNABLE_START_THREAD,
                NULL,
                1,
                sizeof(DWORD),
                szStringArray,
                (LPVOID)&lStatus);
        }
CONTINUE_ENUM_LOOP:
        // prepare for next loop
        dwQueryIndex++;
        // for now we just do the first item in the list
        // the full multiple log query feature will be
        // added later.
        if (dwQueryIndex > 0) break;
        // otherwise we would continue here
        *szQueryNameBuffer = 0;
        dwQueryNameBufferSize = MAX_PATH;
        *szQueryClassBuffer;
        dwQueryClassBufferSize = MAX_PATH;
    } // end enumeration of log queries

    // service is now started
    ssPerfLogStatus.dwCurrentState    = SERVICE_RUNNING;
    ssPerfLogStatus.dwCheckPoint++;
    SetServiceStatus (hPerfLogStatus, &ssPerfLogStatus);

    // wait for (all) timing and logging threads to complete
    lStatus = WaitForMultipleObjects (dwHandleCount,
        pThreadHandleArray, TRUE, INFINITE);

    ssPerfLogStatus.dwCurrentState    = SERVICE_STOP_PENDING;
    SetServiceStatus (hPerfLogStatus, &ssPerfLogStatus);

    // when here, all logging threads have terminated so the
    // memory can be released and the service can exit and shutdown.
    for (dwQueryIndex = 0; dwQueryIndex < dwHandleCount; dwQueryIndex++) {
        CloseHandle (pThreadHandleArray[dwQueryIndex]);
    }

    // release the dynamic memory
    FreeThreadData (pFirstThread);

    // and update the service status
    ssPerfLogStatus.dwCurrentState    = SERVICE_STOPPED;
    SetServiceStatus (hPerfLogStatus, &ssPerfLogStatus);

    if (hEventLog != NULL) CloseHandle (hEventLog);

    return;
}

void
__cdecl main(void)
/*++

main



Arguments


ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LONG    lStatus;

    SERVICE_TABLE_ENTRY    DispatchTable[] = {
        {TEXT("PerfDataLog"),    PerfDataLogServiceStart    },
        {NULL,                    NULL                    }
    };

    hEventLog = RegisterEventSource (NULL, TEXT("PerfDataLog"));

    if (!StartServiceCtrlDispatcher (DispatchTable)) {
        lStatus = GetLastError();
        // log failure to event log
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFLOG_UNABLE_START_DISPATCHER,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&lStatus);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perflog\pdlsvc\pdlsvc.h ===
/*
    pdlsvc.h

*/
#include <pdh.h>
#include <common.h>

#ifndef _PDLSVC_H_
#define _PDLSVC_H_

#define     G_ALLOC(size)   HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, size)
#define     G_FREE(ptr)     HeapFree (GetProcessHeap(), 0, ptr)

// definitionsdwAutoNameFormat
typedef struct _LOG_THREAD_DATA {
	// These fields are written by the main thread
	// and read by the logging thread
	struct _LOG_THREAD_DATA *next;	
	HKEY		hKeyQuery;
	HANDLE		hExitEvent;
    BOOL        bReloadNewConfig;
    TCHAR       szQueryName[MAX_PATH];
	// these fields are written and read by the logging thread
	DWORD		dwTimeInterval;	// in seconds
	LPTSTR		mszCounterList;
    LPTSTR      szCmdFileName;
	DWORD		dwLogType;
	DWORD		dwAutoNameFormat;
	DWORD		dwRenameIntervalCount;
	DWORD		dwRenameIntervalUnits;
    DWORD       dwCurrentSerialNumber;
} LOG_THREAD_DATA, FAR * LPLOG_THREAD_DATA;

typedef struct _LOG_COUNTER_INFO {
    struct _LOG_COUNTER_INFO *next;
    HCOUNTER    hCounter;
} LOG_COUNTER_INFO, * PLOG_COUNTER_INFO;

extern PLOG_COUNTER_INFO pFirstCounter;

// global variables
extern HANDLE	hEventLog;

extern SERVICE_STATUS_HANDLE	hPerfLogStatus;
extern SERVICE_STATUS			ssPerfLogStatus;

// pdlsvc.c
void PerfDataLogServiceControlHandler(
	IN	DWORD dwControl
);

void 
PerfDataLogServiceStart (
	IN	DWORD	argc,
	IN	LPTSTR	*argv
);

void
__cdecl main(void);

// logthred.c

DWORD
LoggingThreadProc (
	IN  LPVOID	lpThreadArg
);


#endif //_PDLSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\addline.h ===
void /*static*/ OnComputerChanged (HDLG hDlg) ;


BOOL AddLine (HWND hWndParent, 
              PPERFSYSTEM *ppSystemFirstView,
              PLINEVISUAL pLineVisual,
              LPTSTR pCurrentLine,
              int iLineTypeToAdd) ;


BOOL EditLine (HWND hWndParent,
               PPERFSYSTEM *ppSystemFirstView,
               PLINE pLineToEdit,
               int iLineTypeToEdit) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\addlog.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include "perfmon.h"
#include "utils.h"
#include "log.h"
#include "pmemory.h"    // for MemoryXXX (malloc-like) routines
#include "perfdata.h"
#include "perfmops.h"
#include "system.h"     // for SystemGet
#include "playback.h"   // for PlayingBackLog & DataFromIndexPosition
#include "pmhelpid.h"   // Help IDs

//==========================================================================//
//                               External Data                              //
//==========================================================================//

extern HWND          hWndLogEntries ;

BOOL                 ComputerChange ;
static   PPERFDATA   pPerfData ;


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


BOOL
/* static */
LogComputerChanged (
                    HDLG hDlg
                    )
{
    PLOG           pLog ;
    HWND           hWndObjects ;
    PPERFSYSTEM    pSysInfo;
    DWORD          iObjectType ;
    DWORD          iObjectNum ;

    pLog = LogData (hDlg) ;
    hWndObjects = DialogControl (hDlg, IDD_ADDLOGOBJECT) ;

    if (!pPerfData) {
        LBReset (hWndObjects) ;
        return FALSE ;
    }

    SetHourglassCursor() ;

    pSysInfo = GetComputer (hDlg,
                            IDD_ADDLOGCOMPUTER,
                            TRUE,
                            &pPerfData,
                            &pLog->pSystemFirst) ;

    if (!pPerfData || !pSysInfo) {
        LBReset (hWndObjects) ;
        SetArrowCursor() ;
        return FALSE ;
    } else {
        LBLoadObjects (hWndObjects,
                       pPerfData,
                       pSysInfo,
                       pLog->dwDetailLevel,
                       NULL,
                       FALSE) ;

        iObjectNum = (DWORD) LBNumItems (hWndObjects) ;
        for (iObjectType = 0 ;
            iObjectType < iObjectNum ;
            iObjectType++) {  // for
            LBSetSelection (hWndObjects, iObjectType) ;
        }  // for

    }

    ComputerChange = FALSE ;

    SetArrowCursor() ;

    return TRUE ;
}


void
/*static*/
OnLogDestroy (
              HDLG hDlg
              )
{

    dwCurrentDlgID = 0 ;

    if (!PlayingBackLog ())
        MemoryFree ((LPMEMORY)pPerfData) ;

    bAddLineInProgress = FALSE ;
}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void
/* static */
OnInitAddLogDialog (
                    HDLG hDlg
                    )
{
    TCHAR          szRemoteComputerName[MAX_PATH + 3] ;
    INT_PTR        iIndex ;
    PLOGENTRY      pLogEntry ;
    LPTSTR         pComputerName ;

    bAddLineInProgress = TRUE ;
    if (PlayingBackLog()) {
        pPerfData = DataFromIndexPosition (&(PlaybackLog.StartIndexPos), NULL) ;
        GetPerfComputerName(pPerfData, szRemoteComputerName);
        DialogSetString (hDlg, IDD_ADDLOGCOMPUTER, szRemoteComputerName);
    } else {
        pPerfData = MemoryAllocate (STARTING_SYSINFO_SIZE) ;

        //Try to use computer specified on command line (if any), otherwise local computer
        pComputerName = CmdLineComputerName[0] ?
                        CmdLineComputerName :
                        LocalComputerName ;

        iIndex = LBSelection (hWndLogEntries) ;
        if (iIndex != LB_ERR) {
            pLogEntry = (PLOGENTRY) LBData(hWndLogEntries, iIndex) ;

            if (pLogEntry && pLogEntry != (PLOGENTRY)LB_ERR) {
                pComputerName = pLogEntry->szComputer ;
            }
        }

        DialogSetString (hDlg, IDD_ADDLOGCOMPUTER, pComputerName) ;
    }

    LogComputerChanged (hDlg) ;

    DialogEnable (hDlg, IDD_ADDLOGOBJECTTEXT, TRUE) ;
    DialogEnable (hDlg, IDD_ADDLOGOBJECT, TRUE) ;

    WindowCenter (hDlg) ;

    dwCurrentDlgID = HC_PM_idDlgEditAddToLog ;

}


void
/* static */
OnLogComputer (
               HDLG hDlg
               )
/*
   Effect:        Put up the select Domain/Computer dialog. Allow the user
                  to select the computer. Check for user entering a domain
                  instead. Place the selected computer in the readonly
                  edit box.
*/
{
    TCHAR          szComputer [MAX_SYSTEM_NAME_LENGTH + 1] ;

    if (ChooseComputer (hDlg, szComputer)) {
        DialogSetString (hDlg, IDD_ADDLOGCOMPUTER, szComputer) ;
        LogComputerChanged (hDlg) ;
    }
}



void
/* static */
OnAddToLog (
            HDLG hDlg
            )
/*
   Effect:        Perform all actions needed when the user clicks on
                  the add button. In particular, determine if the required
                  fields of the dialog have valid values. If so, go ahead
                  and add a LOGENTRY record in the log. If the computer
                  being logged is not already logged, add a LOGSYSTEMENTRY
                  as well.

   Assert:        We have valid values for computer and object, since we
                  always control these fields.
*/
{
    TCHAR          szComputer [MAX_SYSTEM_NAME_LENGTH + 1] ;
    TCHAR          szObjectType [PerfObjectLen + 1] ;
    DWORD          iObjectType ;
    DWORD          iObjectNum ;
    HWND           hWndObjectTypes ;
    PPERFOBJECT    pObject ;
    PLOG           pLog ;

    pLog = LogData (hWndLog) ;

    DialogText (hDlg, IDD_ADDLOGCOMPUTER, szComputer) ;

    hWndObjectTypes = DialogControl(hDlg, IDD_ADDLOGOBJECT) ;

    iObjectNum = (DWORD) LBNumItems (hWndObjectTypes) ;

    LBSetRedraw (hWndLogEntries, FALSE) ;

    for (iObjectType = 0; iObjectType < iObjectNum; iObjectType++) {
        // NOTE: for now, we don't check for duplicate lines
        if (LBSelected (hWndObjectTypes, iObjectType)) {  // if
            LBString (hWndObjectTypes, iObjectType, szObjectType) ;
            pObject = (PPERFOBJECT) LBData (hWndObjectTypes, iObjectType) ;

            // eliminate duplicates here
            if (LogFindEntry(szComputer, pObject->ObjectNameTitleIndex) ==
                LOG_ENTRY_NOT_FOUND) {
                LogAddEntry (hWndLogEntries,
                             szComputer,
                             szObjectType,
                             pObject->ObjectNameTitleIndex,
                             FALSE) ;
            }
        }
    }

    LBSetRedraw (hWndLogEntries, TRUE) ;

    DialogSetText (hDlg, IDD_ADDLOGDONE, IDS_DONE) ;

    if (pLog->iStatus == iPMStatusCollecting) {
        LogWriteSystemCounterNames (hWndLog, pLog) ;
    }
}



INT_PTR
FAR
WINAPI
AddLogDlgProc (
               HWND hDlg,
               UINT msg,
               WPARAM wParam,
               LPARAM lParam
               )
{
    switch (msg) {
        case WM_INITDIALOG:
            OnInitAddLogDialog (hDlg) ;
            SetFocus (DialogControl (hDlg, IDD_ADDLOGADD)) ;
            return(FALSE);

        case WM_COMMAND:

            switch (LOWORD(wParam)) {
                case IDD_CANCEL:
                    EndDialog(hDlg,0);
                    return(TRUE);

                case IDD_OK:
                case IDD_ADDLOGADD:

                    if (ComputerChange) {
                        TCHAR    szComputer [MAX_SYSTEM_NAME_LENGTH + 3] ;

                        DialogText (hDlg, IDD_ADDLOGCOMPUTER, szComputer) ;
                        LogComputerChanged (hDlg) ;
                    } else {
                        SetHourglassCursor() ;
                        OnAddToLog (hDlg) ;
                        SetArrowCursor() ;
                    }
                    break ;

                case IDD_ADDLOGDONE:
                    EndDialog (hDlg, 0) ;
                    break ;

                case IDD_ADDLOGELLIPSES:
                    SetHourglassCursor() ;
                    OnLogComputer (hDlg) ;
                    SetArrowCursor() ;
                    break ;


                case IDD_ADDLOGCOMPUTER:
                    if (HIWORD (wParam) == EN_UPDATE) {
                        ComputerChange = TRUE ;
                    }
                    break ;

                case IDD_ADDLOGHELP:
                    CallWinHelp (dwCurrentDlgID, hDlg) ;
                    break ;

                case IDD_ADDLOGOBJECT:
                    if (ComputerChange) {
                        TCHAR    szComputer [MAX_SYSTEM_NAME_LENGTH + 3] ;

                        DialogText (hDlg, IDD_ADDLOGCOMPUTER, szComputer) ;
                        LogComputerChanged (hDlg) ;
                    }
                    break ;

                default:
                    break ;
            }
            break;

        case WM_DESTROY:
            OnLogDestroy (hDlg) ;
            break ;

        default:
            break;
    }

    return (FALSE);
}



BOOL AddLog (HWND hWndParent)
{
    if (DialogBox (hInstance, idDlgAddLog, hWndParent, AddLogDlgProc)) {
        return (TRUE) ;
    }
    return (FALSE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\addlog.h ===
BOOL AddLog (HWND hWndParent) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\addline.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//



#include <stdio.h>
#include <math.h>

#include "perfmon.h"
#include "addline.h"

#include "alert.h"      // for AlertInsertLine, AlertDeleteLine
#include "grafdata.h"   // for ChartInsertLine, ChartDeleteLine
#include "graph.h"      // for SizeGraphComponents
#include "legend.h"     // for LegendAddItem
#include "line.h"       // for LineAllocate, LineFree.
#include "pmemory.h"    // for MemoryXXX (mallloc-type) routines
#include "perfdata.h"   // for QueryPerformanceData
#include "perfmops.h"   // for dlg_error_box
#include "playback.h"   // for PlaybackLines
#include "report.h"     // for ReportInsertLine, ReportDeleteLine
#include "system.h"     // for SystemGet
#include "utils.h"
#include "playback.h"   // for PlayingBackLog
#include "counters.h"
#include "pmhelpid.h"   // Help IDs

//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#ifdef ADVANCED_PERFMON
#define ADDLINEDETAILLEVEL    PERF_DETAIL_WIZARD
#else
#define ADDLINEDETAILLEVEL    PERF_DETAIL_NOVICE
#endif

#define iInitialExplainLen    256

// defines used in owner-drawn items
#define OWNER_DRAWN_ITEM      2
#define OWNER_DRAW_FOCUS      1

//==========================================================================//
//                                Local Data                                //
//==========================================================================//

// defined in PerfData.c
extern WCHAR   NULL_NAME[] ;


COLORREF argbColors[] =
   {
   RGB (0xff, 0x00, 0x00),
   RGB (0x00, 0x80, 0x00),
   RGB (0x00, 0x00, 0xff),
   RGB (0xff, 0xff, 0x00),
   RGB (0xff, 0x00, 0xff),
   RGB (0x00, 0xff, 0xff),
   RGB (0x80, 0x00, 0x00),
   RGB (0x40, 0x40, 0x40),
   RGB (0x00, 0x00, 0x80),
   RGB (0x80, 0x80, 0x00),
   RGB (0x80, 0x00, 0x80),
   RGB (0x00, 0x80, 0x80),
   RGB (0x40, 0x00, 0x00),
   RGB (0x00, 0x40, 0x00),
   RGB (0x00, 0x00, 0x40),
   RGB (0x00, 0x00, 0x00)
   } ;


TCHAR *apszScaleFmt[] =
   {
   TEXT("%7.7f"),
   TEXT("%6.6f"),
   TEXT("%5.5f"),
   TEXT("%4.4f"),
   TEXT("%3.3f"),
   TEXT("%2.2f"),
   TEXT("%1.1f"),
   TEXT("%2.1f"),
   TEXT("%3.1f"),
   TEXT("%4.1f"),
   TEXT("%5.1f"),
   TEXT("%6.1f"),
   TEXT("%7.1f")
   } ;
#define DEFAULT_SCALE 0
#define NUMBER_OF_SCALE sizeof(apszScaleFmt)/sizeof(apszScaleFmt[0])

int               iLineType ;
static PPERFDATA  pPerfData ;
PPERFSYSTEM       pSystem ;
PLINESTRUCT       pLineEdit ;
PPERFSYSTEM       *ppSystemFirst ;
PLINEVISUAL       pVisual ;

#define bEditLine (pLineEdit != NULL)


BOOL              ComputerChange ;
LPTSTR            pCurrentSystem ;

//=============================//
// Alert-related locals        //
//=============================//


BOOL           bAlertOver ;         // over or under?
FLOAT          eAlertValue ;        // value to compare
BOOL           bEveryTime ;         // run every time or once?

// program to run;
LPTSTR          pszAlertProgram ;


//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define InChartAdd()             \
   (iLineType == LineTypeChart)


#define InAlertAdd()             \
   (iLineType == LineTypeAlert)

#define InReportAdd()            \
   (iLineType == LineTypeReport)




#define NumColorIndexes()     \
   (sizeof (argbColors) / sizeof (argbColors[0]))

#define NumWidthIndexes()  5

#define NumStyleIndexes()  4


//==========================================================================//
//                              Forward Declarations                        //
//==========================================================================//

BOOL /*static*/ OnObjectChanged (HDLG hDlg) ;


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


PPERFINSTANCEDEF
ParentInstance (
                PPERFINSTANCEDEF pInstance
                )
   {
   PPERFOBJECT          parent_obj ;
   PPERFINSTANCEDEF     parent_instance ;
   PERF_COUNTER_BLOCK   *counter_blk;
   LONG                 i ;

   parent_obj =
      GetObjectDefByTitleIndex (pPerfData,
                                pInstance->ParentObjectTitleIndex) ;
   if (!parent_obj)
      return (NULL) ;


   // Then get the parent instance.
   // NOTE: can use unique ID field to match here instead
   // of name compare.
   for (i = 0,
        parent_instance = (PPERFINSTANCEDEF ) ( (PBYTE)parent_obj
        + parent_obj->DefinitionLength);
        i < parent_obj->NumInstances;
        i++, parent_instance = (PPERFINSTANCEDEF ) ( (PBYTE)counter_blk
        + counter_blk->ByteLength))
      {  // for
      counter_blk = (PERF_COUNTER_BLOCK *) ( (PBYTE)parent_instance
                   + parent_instance->ByteLength);
     if ((DWORD)i == pInstance->ParentObjectInstance)
        return (parent_instance) ;
     }

   return (NULL) ;
   }


PPERFOBJECT
SelectedObject (
                HWND hWndObjects,
                LPTSTR lpszObjectName
                )
/*
   Effect:        Return the pObject associated with the currently selected
                  combo-box item of hWndObjects. Set lpszObjectName to
                  the object's name.

                  If no item is selected in the combobox, return NULL.

   Assert:        The pObject for each CB item was added when the string
                  was added to the CB, by CBLoadObjects.

   See Also:      LoadObjects.
*/
   {
   INT_PTR  iIndex ;

   iIndex = CBSelection (hWndObjects) ;
   if (iIndex == CB_ERR)
      return (NULL) ;

   if (lpszObjectName)
      CBString (hWndObjects, iIndex, lpszObjectName) ;

   return ((PPERFOBJECT) CBData (hWndObjects, iIndex)) ;
   }



PPERFCOUNTERDEF
SelectedCounter (
                 HWND hWndCounters,
                 LPTSTR lpszCounterName
                 )
/*
   Effect:        Return the pCounter associated with the currently selected
                  LB item of hWndCounters. Set lpszCounterName to
                  the Counter's name.

                  If no item is selected in the listbox, return NULL.

   Assert:        The pCounter for each LB item was added when the string
                  was added to the LB, by LoadCounters.

   See Also:      LoadCounters.
*/
   {
   INT_PTR            iIndex ;

   iIndex = LBSelection (hWndCounters) ;
   if (iIndex == LB_ERR)
      return (NULL) ;

   if (lpszCounterName)
      LBString (hWndCounters, iIndex, lpszCounterName) ;
   return ((PPERFCOUNTERDEF) LBData (hWndCounters, iIndex)) ;
   }



void
VisualIncrement (
                 PLINEVISUAL pVisual
                 )
/*
   Effect:        Cycle through the combinations of color, width, and
                  style to distinguish between lines.  The color attributes
                  are like a number:
                        <style> <width> <color>

                  Since color is the LSB, it is always incremented. The
                  others are incremented whenever the color rolls over.

                  If a current index is -1, that means don't increment
                  that visual attribute.
*/
   {
   pVisual->iColorIndex =
      (pVisual->iColorIndex + 1) % NumColorIndexes () ;

   if (pVisual->iColorIndex)
      return ;


   if (pVisual->iWidthIndex == -1)
      return ;


   pVisual->iWidthIndex =
      (pVisual->iWidthIndex + 1) % NumWidthIndexes () ;

   if (pVisual->iWidthIndex)
       return ;


   if (pVisual->iStyleIndex == -1)
      return ;


   pVisual->iStyleIndex =
      (pVisual->iStyleIndex + 1) % NumStyleIndexes () ;
   }


COLORREF
LineColor (
           int iColorIndex
           )
   {
   return (argbColors [iColorIndex]) ;
   }


int
LineWidth (
           int iWidthIndex
           )
   {
   switch (iWidthIndex)
      {  // switch
      case 0:
          return (1) ;
          break ;

      case 1:
          return (3) ;
          break ;

      case 2:
          return (5) ;
          break ;

      case 3:
          return (7) ;
          break ;

      case 4:
          return (9) ;
          break ;

      default:
          return (1) ;
          break ;
      }  // switch
   }



int
LineStyle (
           int iStyleIndex
           )
   {
   return (iStyleIndex) ;
   }


BOOL
/*static*/
LoadInstances (
               HDLG hDlg
               )
   {
   PPERFOBJECT       pObject ;
   PPERFINSTANCEDEF  pInstance, pInstanceParent ;
   TCHAR             szInstance [256], szInstanceParent [256] ;
   TCHAR             szCompositeName [256 * 2] ;
   TCHAR             szInstCompositeName [256 * 2] ;

   LONG              iInstance ;
   INT_PTR           iIndex ;

   int               xTextExtent = 0 ;
   int               currentTextExtent ;
   HFONT             hFont ;
   HDC               hDC = 0 ;
   HWND              hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);
   HWND              hWndInstances = DialogControl (hDlg, IDD_ADDLINEINSTANCE);

   // turn off horiz. scrollbar
   LBSetHorzExtent (hWndInstances, 0) ;
   LBReset (hWndInstances) ;

   pObject = SelectedObject (hWndObjects, NULL) ;
   if (!pObject)
      return (FALSE) ;

   if (pObject->NumInstances <= 0)
      {
      MLBSetSelection (hWndInstances, 0, TRUE) ;
      return (FALSE) ;
      }

   // turn off Listbox redraw
   LBSetRedraw (hWndInstances, FALSE) ;

   memset(szInstance, 0, sizeof(TCHAR) * 256);
   memset(szInstanceParent, 0, sizeof(TCHAR) * 256);
   szCompositeName[0] = szInstCompositeName[0] = 0;

   if (bEditLine)
      {
      if (pLineEdit->lnObject.NumInstances > 0)
         {
         if (pLineEdit->lnInstanceDef.ParentObjectTitleIndex)
            {
            // Get the Parent Object Instance Name.
            // and prefix it to the Instance Name, to make
            // the string we want to display.
            TSPRINTF (szInstCompositeName,
                     TEXT("%s ==> %s"),
                     pLineEdit->lnPINName,
                     pLineEdit->lnInstanceName) ;
            }
         else
            {
            lstrcpy (szInstCompositeName, pLineEdit->lnInstanceName) ;
            }
         }
      else
         {
         szInstCompositeName[0] = TEXT('\0');
         }
      }

   if (!bEditLine && (hDC = GetDC (hWndInstances)))
      {
      hFont = (HFONT)SendMessage(hWndInstances, WM_GETFONT, 0, 0L);
      if (hFont)
         SelectObject(hDC, hFont);
      }


   for (iInstance = 0, pInstance = FirstInstance (pObject) ;
        iInstance < pObject->NumInstances;
        iInstance++, pInstance = NextInstance (pInstance))
      {  // for
      strclr(szInstance);
      GetInstanceNameStr (pInstance, szInstance, pObject->CodePage) ;
      pInstanceParent = ParentInstance (pInstance) ;

      if (pInstanceParent)
         {
         strclr(szInstanceParent);
         GetInstanceNameStr (pInstanceParent, szInstanceParent, pObject->CodePage);
         TSPRINTF (szCompositeName, TEXT("%s ==> %s"),
                   szInstanceParent, szInstance) ;
         }
     else
        lstrcpy (szCompositeName, szInstance) ;

  	iIndex = LBAdd (hWndInstances, szCompositeName) ;
   if (iIndex != LB_ERR)
      {
      LBSetData (hWndInstances, iIndex, (LPARAM) pInstance) ;
      }

   // get the biggest text width
   if (hDC)
      {
      currentTextExtent = TextWidth (hDC, szCompositeName) + xScrollWidth / 2  ;
      if (currentTextExtent > xTextExtent)
         {
         xTextExtent = currentTextExtent ;
         }
      }
   }  // for

   if (hDC)
      {
      // turn on horiz. scrollbar if necessary...
      LBSetHorzExtent (hWndInstances, xTextExtent) ;
      ReleaseDC (hWndInstances, hDC) ;
      }


   if (!bEditLine || szInstCompositeName[0] == TEXT('\0'))
      {
      MLBSetSelection (hWndInstances, 0, TRUE) ;
      }
   else
      {
      BOOL bSetSelection = TRUE ;

      iIndex = LBFind (hWndInstances, szInstCompositeName) ;
      if (iIndex == LB_ERR)
         {
         if (bEditLine)
            {
            bSetSelection = FALSE ;
            }
         iIndex = 0 ;
         }

      if (bSetSelection)
         {
         MLBSetSelection (hWndInstances, iIndex, TRUE) ;
         }

      LBSetVisible (hWndInstances, iIndex) ;
      }

   // turn on Listbox redraw
   LBSetRedraw (hWndInstances, TRUE) ;

   return TRUE;

   }


BOOL
OnCounterChanged (
                  HDLG hDlg
                  )
/*
   Effect:        Perform any actions necessary when the counter has changed.
                  In particular, display the explanation for the counter
                  that has the focus rectangle.
*/
   {
   LPTSTR         lpszText ;
   PPERFCOUNTERDEF pCounter ;
   int            iStatus ;
   INT_PTR        iFocusIndex ;
   HWND           hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER);
   HWND           hWndScales = DialogControl (hDlg, IDD_ADDLINESCALE) ;

   iFocusIndex = LBFocus (hWndCounters) ;
   if  (iFocusIndex == LB_ERR)
      return (FALSE) ;

   if (PlayingBackLog())
      {
      DialogEnable (hDlg, IDD_ADDLINEEXPANDEXPLAIN, FALSE) ;
      return (TRUE) ;
      }

   pCounter = (PPERFCOUNTERDEF) LBData (hWndCounters, iFocusIndex) ;
   if ((!pCounter) || (pCounter == (PPERFCOUNTERDEF)LB_ERR))
      return (FALSE) ;

   // no need to get help text before the button is clicked
   if (!bExplainTextButtonHit)
      return (FALSE) ;

   // Create initial string
   lpszText = MemoryAllocate (iInitialExplainLen * sizeof (TCHAR)) ;

   if (!lpszText)
      return (FALSE) ;

   while (TRUE)
      {
      lpszText[0] = TEXT('\0') ;

      #ifdef UNICODE
      iStatus = QueryPerformanceName  (pSystem,
                                       pCounter->CounterHelpTitleIndex,
                                       iLanguage,
                                       MemorySize (lpszText) / sizeof(TCHAR),
                                       lpszText,
                                       TRUE) ;
      #else
      iStatus = QueryPerformanceNameW (pSystem,
                                       pCounter->CounterHelpTitleIndex,
                                       iLanguage,
                                       MemorySize (lpszText),
                                       lpszText,
                                       TRUE) ;
      #endif

      if (iStatus == ERROR_SUCCESS)
         break ;

      if (iStatus == ERROR_MORE_DATA)
         lpszText =
            MemoryResize (lpszText,
                          MemorySize (lpszText) + iInitialExplainLen) ;
      else
         break ;
      }  // while

   // Don't use my DialogSetString, it won't handle such large strings.
   SetDlgItemText (hDlg, IDD_ADDLINEEXPLAIN, lpszText) ;
   MemoryFree (lpszText) ;

   return (TRUE) ;
   }



BOOL
LoadCounters (
              HDLG hDlg,
              UINT iSelectCounterDefn
              )
   {
   PPERFOBJECT       pObject ;

   TCHAR             szCounterName [256] ;
   TCHAR             szDefaultCounterName [256] ;
   PPERFCOUNTERDEF   pCounter ;
   UINT              i ;
   INT_PTR           iIndex ;
   int               xTextExtent = 0 ;
   int               currentTextExtent ;
   HFONT             hFont ;
   HDC               hDC = 0 ;
   BOOL              bSetSelection = TRUE ;
   HWND              hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);
   HWND              hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER);


   strclr (szDefaultCounterName) ;

   // turn off horiz. scrollbar
   LBSetHorzExtent (hWndCounters, 0) ;
   LBReset (hWndCounters) ;

   pObject = SelectedObject (hWndObjects, NULL) ;
   if (!pObject)
      return (FALSE) ;

   if (!bEditLine && (hDC = GetDC (hWndCounters)))
      {
      hFont = (HFONT)SendMessage(hWndCounters, WM_GETFONT, 0, 0L);
      if (hFont)
         SelectObject(hDC, hFont);
      }

   memset(szCounterName, 0, sizeof(TCHAR) * 256);
   memset(szDefaultCounterName, 0, sizeof(TCHAR) * 256);
   // turn off Listbox redraw
   LBSetRedraw (hWndCounters, FALSE) ;

   for (i = 0, pCounter = FirstCounter (pObject) ;
        i < pObject->NumCounters ;
        i++, pCounter = NextCounter (pCounter))
      {  // for
      if (IsCounterSupported(pCounter->CounterType))
         {   // if
         szCounterName[0] = TEXT('\0') ;
         QueryPerformanceName (pSystem,
                                 pCounter->CounterNameTitleIndex,
                                 0, sizeof (szCounterName) / sizeof(TCHAR),
                                 szCounterName,
                                 FALSE) ;

         // if szCounterName is not empty, add it to the listbox
         if (!strsame(szCounterName, NULL_NAME))
            {
            iIndex = LBAdd (hWndCounters, szCounterName) ;
            LBSetData (hWndCounters, iIndex, (DWORD_PTR) pCounter) ;

            // get the biggest text width
            if (hDC)
               {
               currentTextExtent = TextWidth (hDC, szCounterName) + xScrollWidth / 2 ;
               if (currentTextExtent > xTextExtent)
                  {
                  xTextExtent = currentTextExtent ;
                  }
               }

            if (iSelectCounterDefn == i)
               lstrcpy (szDefaultCounterName, szCounterName) ;
            } // if szCounterName is not empty
         }   // if
      }  // for

   if (bEditLine)
      lstrcpy (szDefaultCounterName, pLineEdit->lnCounterName) ;

   iIndex = LBFind (hWndCounters, szDefaultCounterName) ;
   if (iIndex == LB_ERR)
      {
      if (bEditLine)
         {
         bSetSelection = FALSE ;
         }
      iIndex = 0 ;
      }

   if (bSetSelection)
      {
      MLBSetSelection (hWndCounters, iIndex, TRUE) ;
      }
   LBSetVisible (hWndCounters, iIndex) ;

   if (hDC)
      {
      // turn on horiz. scrollbar if necessary...
      LBSetHorzExtent (hWndCounters, xTextExtent) ;
      ReleaseDC (hWndCounters, hDC) ;
      }

   // turn on Listbox redraw
   LBSetRedraw (hWndCounters, TRUE) ;

   OnCounterChanged (hDlg) ;

   return TRUE;
   }  // LoadCounters




void
LoadObjects (
             HDLG hDlg,
             PPERFDATA pPerfData
             )
/*
   Effect:        Load into the object CB the objects for the current
                  pPerfData.
*/
   {
   LPTSTR         lpszObject ;
   HWND           hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);


   lpszObject = bEditLine ? pLineEdit->lnObjectName : NULL ;

   CBLoadObjects (hWndObjects,
                  pPerfData,
                  pSystem,
                  ADDLINEDETAILLEVEL,
                  lpszObject,
                  FALSE) ;
   OnObjectChanged (hDlg) ;
//   UpdateWindow (hDlg) ;
   }

void
OnComputerChanged (
                   HDLG hDlg
                   )
   {

   PPERFSYSTEM pLocalSystem;
   PPERFDATA   pLocalPerfData;

   pLocalPerfData = pPerfData;
   pLocalSystem = GetComputer (hDlg,
                          IDD_ADDLINECOMPUTER,
                          TRUE,
                          &pLocalPerfData,
                          ppSystemFirst) ;
   if (pLocalSystem && pLocalPerfData)
      {
      pSystem = pLocalSystem;
      pPerfData = pLocalPerfData;
      LoadObjects (hDlg, pPerfData) ;
      ComputerChange = FALSE ;
      }
   SetArrowCursor();
   }


BOOL
AddOneChartLine (
                 HWND hDlg,
                 PPERFCOUNTERDEF pCounter,
                 LPTSTR lpszCounter,
                 PPERFINSTANCEDEF pInstance,
                 BOOL bInsertObject
                 )
   {
   TCHAR             szComputer [MAX_SYSTEM_NAME_LENGTH] ;

   PPERFOBJECT       pObject ;
   TCHAR             szObject [PerfObjectLen] ;

   TCHAR             szInstance [256] ;

   PLINE             pLine ;
//   int               i ;
   int               iCounterIndex ;
   int               j ;

   PPERFINSTANCEDEF  pInstanceParent ;
   PERF_COUNTER_BLOCK *pCounterBlock ;
   TCHAR          szInstanceParent [256] ;
   TCHAR          szObjectParent [256] ;
   HWND           hWndColors = DialogControl (hDlg, IDD_ADDLINECOLOR) ;
   HWND           hWndWidths = DialogControl (hDlg, IDD_ADDLINEWIDTH) ;
   HWND           hWndStyles = DialogControl (hDlg, IDD_ADDLINESTYLE) ;
   HWND           hWndScales = DialogControl (hDlg, IDD_ADDLINESCALE) ;
   HWND           hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);
   BOOL           bFail;

   //=============================//
   // Get selected data values    //
   //=============================//

   memset(szInstance, 0, sizeof(TCHAR) * 256);

   DialogText (hDlg, IDD_ADDLINECOMPUTER, szComputer) ;

   pObject = SelectedObject (hWndObjects, szObject) ;
   if (!pObject)
      return (FALSE) ;

   if (pInstance)
      GetInstanceNameStr (pInstance, szInstance, pObject->CodePage);

   //=============================//
   // Allocate the line           //
   //=============================//

   bFail = FALSE;
   pLine = LineAllocate () ;
   if (pLine) {

       //=============================//
       // Set line's data values      //
       //=============================//

       pLine->iLineType = iLineType ;
       pLine->lnSystemName = StringAllocate (szComputer) ;
       if (pLine->lnSystemName == NULL)
          bFail = TRUE;

       pLine->lnObject = *pObject ;
       pLine->lnObjectName = StringAllocate (szObject) ;
       if (pLine->lnObjectName == NULL) {
          bFail = TRUE;
          MemoryFree(pLine->lnSystemName);
       }

       pLine->lnCounterDef = *pCounter ;
       pLine->lnCounterName = StringAllocate (lpszCounter) ;
       if (pLine->lnCounterName == NULL) {
          bFail = TRUE;
          MemoryFree(pLine->lnSystemName);
          MemoryFree(pLine->lnObjectName);
       }
   }
   if (!pLine || bFail)
      {
      DlgErrorBox (hDlg, ERR_NO_MEMORY);
      return (FALSE) ;
      }

   if (pObject->NumInstances > 0 && pInstance)
      {
      pLine->lnInstanceDef = *pInstance ;
      pLine->lnInstanceName = StringAllocate (szInstance) ;

      pLine->lnUniqueID = pInstance->UniqueID ;

      pLine->dwInstanceIndex = 0;

      if (pInstance->ParentObjectTitleIndex)
         {
         szObjectParent[0] = (TCHAR)'\0';
         QueryPerformanceName (pSystem,
                               pInstance->ParentObjectTitleIndex,
                               0,  PerfObjectLen, szObjectParent, FALSE) ;
         pLine->lnParentObjName = StringAllocate (szObjectParent) ;
         }

      pInstanceParent = ParentInstance (pInstance) ;
      if (pInstanceParent)
         {
         GetInstanceNameStr (pInstanceParent, szInstanceParent,
            pObject->CodePage);
         if (pInstance->ParentObjectTitleIndex)
            {
            pLine->lnPINName = StringAllocate (szInstanceParent) ;
            }
         }
      }  // if

   pLine->lnCounterType = pCounter->CounterType;
   pLine->lnCounterLength = pCounter->CounterSize;

   pLine->lnOldTime = pPerfData->PerfTime ;
   pLine->lnNewTime = pPerfData->PerfTime ;

   for (j = 0 ; j < 2 ; j++)
      {
      pLine->lnaCounterValue[j].LowPart = 0 ;
      pLine->lnaCounterValue[j].HighPart = 0 ;
      }


   //=============================//
   // Chart-related Values        //
   //=============================//

   pLine->iScaleIndex = (int)CBSelection (hWndScales) ;
   if (pLine->iScaleIndex == 0)
      {
      // use the default scale
      pLine->eScale = (FLOAT) pow ((double)10.0,
          (double)pCounter->DefaultScale) ;
      }
   else
      {
      pLine->eScale = DialogFloat (hDlg, IDD_ADDLINESCALE, NULL) ;
      }

   if (pObject->NumInstances > 0 && pInstance)
      {
      pCounterBlock = (PERF_COUNTER_BLOCK *) ( (PBYTE) pInstance +
                       pInstance->ByteLength);
      }
   else
      {
      pCounterBlock = (PERF_COUNTER_BLOCK *) ( (PBYTE) pObject +
                       pObject->DefinitionLength);
      }

   if (pLine->lnCounterLength <= 4)
       pLine->lnaOldCounterValue[0].LowPart =
               * ( (DWORD FAR *) ( (PBYTE)pCounterBlock +
               pCounter[0].CounterOffset));
   else
      {
      pLine->lnaOldCounterValue[0] =
              * ( (LARGE_INTEGER UNALIGNED *) ( (PBYTE)pCounterBlock +
              pCounter[0].CounterOffset));
      }

   // Get second counter, only if we are not at
   // the end of the counters; some computations
   // require a second counter

   iCounterIndex = CounterIndex (pCounter, (PPERFOBJECT) pObject) ;
   if ((UINT) iCounterIndex < pObject->NumCounters - 1 &&
       iCounterIndex != -1)
      {
      if (pLine->lnCounterLength <= 4)
          pLine->lnaOldCounterValue[1].LowPart =
                  * ( (DWORD FAR *) ( (PBYTE)pCounterBlock +
                  pCounter[1].CounterOffset));
      else
         pLine->lnaOldCounterValue[1] =
                 * ( (LARGE_INTEGER UNALIGNED *) ( (PBYTE)pCounterBlock +
                 pCounter[1].CounterOffset));
      }


   pLine->lnaOldCounterValue[0] = pLine->lnaCounterValue[0];
   pLine->lnaOldCounterValue[1] = pLine->lnaCounterValue[1];

   //=============================//
   // Visual Values               //
   //=============================//

   pLine->Visual.iColorIndex = (int)CBSelection (hWndColors) ;
   pLine->Visual.crColor = LineColor (pLine->Visual.iColorIndex) ;

   pLine->Visual.iWidthIndex = (int)CBSelection (hWndWidths) ;
   pLine->Visual.iWidth = LineWidth (pLine->Visual.iWidthIndex) ;

   pLine->Visual.iStyleIndex = (int)CBSelection (hWndStyles) ;
   pLine->Visual.iStyle = LineStyle (pLine->Visual.iStyleIndex) ;

   *pVisual = pLine->Visual ;
   if (!bEditLine)
      VisualIncrement (pVisual) ;

   CBSetSelection (hWndColors, pVisual->iColorIndex) ;
   CBSetSelection (hWndWidths, pVisual->iWidthIndex) ;
   CBSetSelection (hWndStyles, pVisual->iStyleIndex) ;

   if (iLineType == LineTypeChart)
      {
      pLine->hPen = LineCreatePen (NULL, &(pLine->Visual), FALSE) ;
      }

   //=============================//
   // Alert Related Values        //
   //=============================//

   if (iLineType == LineTypeAlert)
      {
      pLine->bAlertOver = bAlertOver ;
      pLine->eAlertValue = eAlertValue ;
      pLine->bEveryTime =
         IsDlgButtonChecked (hDlg, IDD_ADDLINEPROGRAMEVERYTIME) ;
      pLine->bAlerted = FALSE ;
      pLine->hBrush = CreateSolidBrush (pLine->Visual.crColor) ;
      if (!PlayingBackLog ())
         {
         pLine->lpszAlertProgram = StringAllocate (pszAlertProgram) ;
         }
      else
         {
         pLine->lpszAlertProgram = NULL ;
         }
      }
   //=============================//
   // Insert the line!            //
   //=============================//

   if (InsertLine (pLine) == FALSE)
      {
      // no inert occurred due to either line already existed
      // or error detected.
      LineFree (pLine) ;
      }
   else
      {
      if (pSystem->lpszValue && pSystem->FailureTime == 0)
         {
         if (bInsertObject) {
            if (strsame(pSystem->lpszValue, TEXT("Global")))
                {
                // take out the "Global" string
                *(pSystem->lpszValue) = 0 ;
                }
            AppendObjectToValueList (
                pLine->lnObject.ObjectNameTitleIndex,
                pSystem->lpszValue) ;
            }
         }
      }
      return TRUE;
   }


BOOL AddCounter (HWND hDlg,
                      PPERFCOUNTERDEF pCounter,
                      LPTSTR lpszCounter)
   {
   int               iInstanceIndex ;
   int               iInstanceNum ;
   PPERFINSTANCEDEF  pInstance ;
   PPERFOBJECT       pObject;
   HWND              hWndInstances = DialogControl (hDlg, IDD_ADDLINEINSTANCE);
   HWND              hWndObjects;
   BOOL              bInsertObject = TRUE;
   int               nResult;

   // NOTE: for now, we don't check for duplicate lines
   if (!IsCounterSupported (pCounter->CounterType))
      {
      DlgErrorBox (hDlg, ERR_COUNTER_NOT_IMP);
      return (FALSE) ;
      }


   if ((iInstanceNum = LBNumItems (hWndInstances)) && iInstanceNum != LB_ERR)
      {

      if (iInstanceNum > 1)
         {
         // delay some of the insert actions for performacne improvement
         bDelayAddAction = TRUE ;

         if (InChartAdd())
            {
            LegendSetRedraw (hWndGraphLegend, FALSE) ;
            }
         else if (InAlertAdd())
            {
            LegendSetRedraw (hWndAlertLegend, FALSE) ;
            }
         }

      for (iInstanceIndex = 0 ;
           iInstanceIndex < iInstanceNum ;
           iInstanceIndex++)
         {  // for
         nResult = LBSelected (hWndInstances, iInstanceIndex);
         if ((nResult != LB_ERR) && (nResult != 0))
            {  // if
            pInstance = (PPERFINSTANCEDEF) LBData (hWndInstances, iInstanceIndex) ;
            if (pInstance == (PPERFINSTANCEDEF) LB_ERR)
               {
               pInstance = NULL;
               }
            AddOneChartLine (hDlg, pCounter, lpszCounter, pInstance, bInsertObject) ;
            bInsertObject = FALSE; // for all subsequent calls
            }  // if
         }  // for

      if (bDelayAddAction)
         {
         // now do the post add-line actions
         bDelayAddAction = FALSE ;
         if (InReportAdd())
            {
            PREPORT pReport ;

            pReport = ReportData (hWndReport) ;
            ReportAddAction (pReport);
            }
         else if (InChartAdd())
            {
            GraphAddAction () ;
            LegendSetRedraw (hWndGraphLegend, TRUE) ;
            }
         else if (InAlertAdd())
            {
            AlertAddAction () ;
            LegendSetRedraw (hWndAlertLegend, TRUE) ;
            }
         }
      }
   else
      {
      // the list box could be empty for 2 reasons:
      // there are no instances and could be or
      // there is one and only one instance. Find out which
      hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);

      pObject = SelectedObject (hWndObjects, NULL) ;
      if (!pObject)
        return (FALSE) ;

      if (pObject->NumInstances == PERF_NO_INSTANCES)
        {
        // then there is one and only one, so add it
        pInstance = NULL;
        AddOneChartLine (hDlg, pCounter, lpszCounter, pInstance, bInsertObject) ;
        }
      else
        {
        // there are no instances of this object so don't add anything
        return (FALSE);
        }
      }

   return (TRUE) ;
   }


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


BOOL
/*static*/
OnInitDialog (
              HWND hDlg
              )
   {
   int            i ;
   FLOAT          ScaleFactor ;
   TCHAR          tempBuff[ShortTextLen] ;
   TCHAR          szCaption [WindowCaptionLen] ;
   TCHAR          szRemoteComputerName[MAX_PATH + 3] ;
   HWND           hWndComputer = DialogControl (hDlg, IDD_ADDLINECOMPUTER);
   HWND           hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);
   HWND           hWndInstances = DialogControl (hDlg, IDD_ADDLINEINSTANCE);
   HWND           hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER);
   HWND           hWndColors = DialogControl (hDlg, IDD_ADDLINECOLOR) ;
   HWND           hWndWidths = DialogControl (hDlg, IDD_ADDLINEWIDTH) ;
   HWND           hWndStyles = DialogControl (hDlg, IDD_ADDLINESTYLE) ;
   HWND           hWndScales = DialogControl (hDlg, IDD_ADDLINESCALE) ;

   // this is used to tell UPdateLines not to mark any
   // system as not used
   bAddLineInProgress = TRUE ;

   // turn this off until the Explain text button is clicked
   bExplainTextButtonHit = FALSE ;

   if (InAlertAdd())
      {
      pszAlertProgram = (LPTSTR) MemoryAllocate (FilePathLen * sizeof (TCHAR)) ;
      }

   if (!PlayingBackLog ())
      pPerfData = MemoryAllocate (STARTING_SYSINFO_SIZE) ;

   pSystem = NULL ;

   if (!bEditLine && PlayingBackLog())
      {
      pPerfData = DataFromIndexPosition (&(PlaybackLog.StartIndexPos), NULL) ;
      GetPerfComputerName(pPerfData, szRemoteComputerName);
      DialogSetString (hDlg, IDD_ADDLINECOMPUTER, szRemoteComputerName);
      }
   else
      {
      if (bEditLine)
         {
         DialogSetString (hDlg, IDD_ADDLINECOMPUTER,
            pLineEdit->lnSystemName) ;
         }
      else
         {
			//Try to use current system (if any), otherwise computer specified on commandline (if any),
			//otherwise local computer
         DialogSetString (hDlg, IDD_ADDLINECOMPUTER,
            pCurrentSystem ?
                pCurrentSystem :
                (( CmdLineComputerName[0] ) ?
                   CmdLineComputerName :
                   LocalComputerName )) ;
         }
      }

   OnComputerChanged (hDlg) ;

   //=============================//
   // Set default line values     //
   //=============================//

   bAlertOver = bEditLine ? pLineEdit->bAlertOver : TRUE ;
   bEveryTime = bEditLine ? pLineEdit->bEveryTime : TRUE ;

   //=============================//
   // Fill line attribute CBs     //
   //=============================//

   // Load the colors combobox, select the default color.
   for (i = 0 ; i < NumColorIndexes () ; i++)
       CBAdd (hWndColors, IntToPtr(i)) ;
   CBSetSelection (hWndColors, pVisual->iColorIndex) ;

   // Load the widths combobox, select the default width.
   for (i = 0 ; i < NumWidthIndexes () ; i++)
      CBAdd (hWndWidths, IntToPtr(i)) ;
   CBSetSelection (hWndWidths, pVisual->iWidthIndex) ;

   // Load the styles combobox, select the default style.
   for (i = 0 ; i < NumStyleIndexes () ; i++)
      CBAdd (hWndStyles, IntToPtr(i)) ;
   CBSetSelection (hWndStyles, pVisual->iStyleIndex) ;

#if (!WIDESTYLES)
   DialogEnable (hDlg, IDD_ADDLINESTYLE, pVisual->iWidthIndex == 0) ;
   DialogEnable (hDlg, IDD_ADDLINESTYLETEXT, pVisual->iWidthIndex == 0) ;

   if (pVisual->iWidthIndex == 0 && pVisual->iStyleIndex > 0)
      {
      DialogEnable (hDlg, IDD_ADDLINEWIDTHTEXT, FALSE) ;
      DialogEnable (hDlg, IDD_ADDLINEWIDTH, FALSE) ;
      }
#endif

   // Init the scale combo box.

   StringLoad (IDS_DEFAULT, tempBuff) ;
   CBAdd (hWndScales, tempBuff) ;

   // we are formatting the scale factors during run-time so
   // the c-runtime library will pick up the default locale
   // decimal "charatcer".
   ScaleFactor = (FLOAT)0.0000001 ;
   for (i = 0 ; i < NUMBER_OF_SCALE ; i++)
      {
      TSPRINTF(tempBuff, apszScaleFmt[i], ScaleFactor) ;
      ConvertDecimalPoint (tempBuff) ;
      ScaleFactor *= (FLOAT) 10.0 ;
      CBAdd (hWndScales, tempBuff) ;
      }

   CBSetSelection (hWndScales, bEditLine ? pLineEdit->iScaleIndex : DEFAULT_SCALE) ;


   CheckRadioButton (hDlg, IDD_ADDLINEIFOVER, IDD_ADDLINEIFUNDER,
                     bAlertOver ? IDD_ADDLINEIFOVER: IDD_ADDLINEIFUNDER) ;
   CheckRadioButton (hDlg, IDD_ADDLINEPROGRAMFIRSTTIME, IDD_ADDLINEPROGRAMEVERYTIME,
                     bEveryTime ? IDD_ADDLINEPROGRAMEVERYTIME: IDD_ADDLINEPROGRAMFIRSTTIME) ;

   if (bEditLine)
      {
      DialogSetText (hDlg, IDD_ADDLINEADD, IDS_OK) ;
      DialogSetFloat (hDlg, IDD_ADDLINEIFVALUE, pLineEdit->eAlertValue) ;
      if (pLineEdit->lpszAlertProgram)
         DialogSetString (hDlg, IDD_ADDLINEPROGRAM,
                          pLineEdit->lpszAlertProgram) ;

      DialogEnable (hDlg, IDD_ADDLINECOMPUTERTEXT, FALSE) ;
      DialogEnable (hDlg, IDD_ADDLINECOMPUTER, FALSE) ;
      DialogEnable (hDlg, IDD_ADDLINEELLIPSES, FALSE) ;
      DialogEnable (hDlg, IDD_ADDLINEOBJECTTEXT, FALSE) ;
      DialogEnable (hDlg, IDD_ADDLINEOBJECT, FALSE) ;
      DialogEnable (hDlg, IDD_ADDLINECOUNTERTEXT, FALSE) ;
      DialogEnable (hDlg, IDD_ADDLINECOUNTER, FALSE) ;
      DialogEnable (hDlg, IDD_ADDLINEINSTANCE, FALSE) ;
      DialogEnable (hDlg, IDD_ADDLINEINSTANCETEXT, FALSE) ;
      }
   else
      {
      // set the scroll limit on the edit box
      EditSetLimit (GetDlgItem(hDlg, IDD_CHOOSECOMPUTERNAME),
         MAX_SYSTEM_NAME_LENGTH-1) ;

      }

   if (PlayingBackLog())
      {
      DialogEnable (hDlg, IDD_ADDLINEEXPANDEXPLAIN, FALSE) ;
      }

   //=============================//
   // LineType specific init      //
   //=============================//

   switch (iLineType)
      {
      case LineTypeChart:
         dwCurrentDlgID = bEditLine ?
                  HC_PM_idDlgEditChartLine : HC_PM_idDlgEditAddToChart ;

         StringLoad (bEditLine ?
                     IDS_EDITCHART : IDS_ADDTOCHART, szCaption) ;

         DialogShow (hDlg, IDD_ADDLINEIFGROUP, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEIFVALUE, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEIFUNDER, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEIFOVER, FALSE) ;

         DialogShow (hDlg, IDD_ADDLINEPROGRAMGROUP, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEPROGRAM, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEPROGRAMFIRSTTIME, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEPROGRAMEVERYTIME, FALSE) ;
         break ;

      case LineTypeAlert:
         dwCurrentDlgID = bEditLine ?
                  HC_PM_idDlgEditAlertEntry : HC_PM_idDlgEditAddToAlert ;

         StringLoad (bEditLine ?
                     IDS_EDITALERT : IDS_ADDTOALERT, szCaption) ;

         DialogShow (hDlg, IDD_ADDLINESCALE, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINESCALETEXT, FALSE) ;

         DialogShow (hDlg, IDD_ADDLINEWIDTH, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEWIDTHTEXT, FALSE) ;

         DialogShow (hDlg, IDD_ADDLINESTYLE, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINESTYLETEXT, FALSE) ;

         if (PlayingBackLog ())
            {
            DialogEnable (hDlg, IDD_ADDLINEPROGRAM, FALSE) ;
            DialogEnable (hDlg, IDD_ADDLINEPROGRAMGROUP, FALSE) ;
            DialogEnable (hDlg, IDD_ADDLINEPROGRAMEVERYTIME, FALSE) ;
            DialogEnable (hDlg, IDD_ADDLINEPROGRAMFIRSTTIME, FALSE) ;
            }

         // set the scroll limit on the edit boxes

         EditSetLimit (GetDlgItem(hDlg, IDD_ADDLINEIFVALUE), ShortTextLen) ;
         EditSetLimit (GetDlgItem(hDlg, IDD_ADDLINEPROGRAM), FilePathLen-1) ;

         break ;

      case LineTypeReport:

         dwCurrentDlgID = HC_PM_idDlgEditAddToReport ;

         StringLoad (bEditLine ?
                     IDS_EDITREPORT : IDS_ADDTOREPORT, szCaption) ;

         DialogShow (hDlg, IDD_ADDLINEIFGROUP, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEIFVALUE, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEIFUNDER, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEIFOVER, FALSE) ;

         DialogShow (hDlg, IDD_ADDLINEPROGRAMGROUP, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEPROGRAM, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEPROGRAMFIRSTTIME, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEPROGRAMEVERYTIME, FALSE) ;

         DialogShow (hDlg, IDD_ADDLINECOLOR, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINECOLORTEXT, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINESCALE, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINESCALETEXT, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEWIDTH, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINEWIDTHTEXT, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINESTYLE, FALSE) ;
         DialogShow (hDlg, IDD_ADDLINESTYLETEXT, FALSE) ;
         break ;
      }  // switch

   SetWindowText (hDlg, szCaption) ;
   SendDlgItemMessage (hDlg,
                       IDD_ADDLINEEXPLAIN, WM_SETFONT,
                       (WPARAM) hFontScales, (LPARAM) FALSE) ;
   WindowCenter (hDlg) ;
   return (TRUE) ;
   }


BOOL
/*static*/
OnObjectChanged (
                 HDLG hDlg
                 )
/*
   Effect:        Perform any actions necessary when the user has selected
                  a new object category from the object CB, or when a default
                  object is first selected into the dialog. In particular,
                  find and load the counters, instances, etc., for this
                  object.

   Called by:     OnInitDialog, AddLineDlgProc (in response to an
                  IDM_ADDLINEOBJECT notification).
*/
   {
   PPERFOBJECT    pObject ;
   HWND           hWndInstances = DialogControl (hDlg, IDD_ADDLINEINSTANCE);
   HWND           hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER);
   HWND           hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);

   LBReset (hWndInstances) ;
   LBReset (hWndCounters) ;

   pObject = SelectedObject (hWndObjects, NULL) ;
   if (!pObject)
      return (FALSE) ;

   LoadCounters (hDlg, (UINT)pObject->DefaultCounter) ;
   LoadInstances (hDlg) ;

   return TRUE;

   }



void
/*static*/
OnEllipses (
            HWND hDlg
            )
   {
   TCHAR          szComputer [256] ;

   memset(szComputer, 0, sizeof(TCHAR) * 256);
   DialogText (hDlg, IDD_ADDLINECOMPUTER, szComputer) ;
   if (ChooseComputer (hDlg, szComputer))
      {
      SetHourglassCursor() ;
      DialogSetString (hDlg, IDD_ADDLINECOMPUTER, szComputer) ;
      OnComputerChanged (hDlg) ;
      }
   }

BOOL
LineModifyAttributes (
                      HWND hDlg,
                      PLINE pLineToModify
                      )
{
   LINEVISUAL  LineVisual ;
   HPEN        hLinePen ;
   int         iScaleIndex = 0 ;        // chart attribute
   FLOAT	   eScale = 1.0f;           // chart attribute

   BOOL        bLocalAlertOver = FALSE;  // alert attribute - over or under?
   FLOAT       eLocalAlertValue = 0.0f;  // alert attribute - value to compare
   LPTSTR      lpLocalszAlertProgram = NULL;   // alert attribute - program to run
   BOOL        bLocalEveryTime = FALSE;  // alert attribute - run every time or once?
   BOOL        bLocalAlerted ;           // alert attribute - alert happened on line?

   HPEN        hTempPen ;
   LPTSTR      lpTempAlertProgram ;
   HWND        hWndColors = DialogControl (hDlg, IDD_ADDLINECOLOR) ;
   HWND        hWndWidths = DialogControl (hDlg, IDD_ADDLINEWIDTH) ;
   HWND        hWndStyles = DialogControl (hDlg, IDD_ADDLINESTYLE) ;
   HWND        hWndScales = DialogControl (hDlg, IDD_ADDLINESCALE) ;

   //=============================//
   // Visual Values               //
   //=============================//

   LineVisual.iColorIndex = (int)CBSelection (hWndColors) ;
   LineVisual.crColor = LineColor (LineVisual.iColorIndex) ;

   LineVisual.iWidthIndex = (int)CBSelection (hWndWidths) ;
   LineVisual.iWidth = LineWidth (LineVisual.iWidthIndex) ;

   LineVisual.iStyleIndex = (int)CBSelection (hWndStyles) ;
   LineVisual.iStyle = LineStyle (LineVisual.iStyleIndex) ;

   hLinePen = LineCreatePen (NULL, &(LineVisual), FALSE) ;

   //=============================//
   // Chart-related Values        //
   //=============================//

   if (InChartAdd())
      {
      iScaleIndex = (int)CBSelection (hWndScales) ;
      if (iScaleIndex == 0)
          {
          // use the default scale
          eScale = (FLOAT) pow ((double)10.0,
              (double)pLineToModify->lnCounterDef.DefaultScale) ;
          }
      else
          {
          eScale = DialogFloat (hDlg, IDD_ADDLINESCALE, NULL) ;
          }
      }

   //=============================//
   // Alert Related Values        //
   //=============================//

   if (InAlertAdd())
      {
      bLocalAlertOver = bAlertOver ;
      eLocalAlertValue = eAlertValue ;
      bLocalEveryTime =
         IsDlgButtonChecked (hDlg, IDD_ADDLINEPROGRAMEVERYTIME) ;
      bLocalAlerted = FALSE ;
      lpLocalszAlertProgram = StringAllocate (pszAlertProgram) ;
      }

   // Just do it..
   pLineToModify->Visual = LineVisual ;
   if (pLineToModify->hPen)
      {
      hTempPen = pLineToModify->hPen ;
      pLineToModify->hPen = hLinePen ;
      DeletePen (hTempPen) ;
      }

   if (InChartAdd())
      {
      pLineToModify->iScaleIndex = iScaleIndex ;
      pLineToModify->eScale = eScale ;

      }

   if (InAlertAdd())
      {
      HBRUSH   hOldBrush;
      pLineToModify->bAlertOver = bLocalAlertOver ;
      pLineToModify->eAlertValue = eLocalAlertValue ;
      pLineToModify->bEveryTime = bLocalEveryTime ;
      pLineToModify->bAlerted = FALSE ;

      hOldBrush = pLineToModify->hBrush ;
      pLineToModify->hBrush = CreateSolidBrush (pLineToModify->Visual.crColor) ;
      DeleteBrush (hOldBrush);

      lpTempAlertProgram = pLineToModify->lpszAlertProgram ;
      pLineToModify->lpszAlertProgram = lpLocalszAlertProgram ;

      if (lpTempAlertProgram)
         {
         MemoryFree (lpTempAlertProgram) ;
         }
      }

   return (TRUE) ;

}

BOOL OnAddLines (HWND hDlg)
   {
   PPERFCOUNTERDEF   pCounter ;
   TCHAR             szCounter [256] ;
   BOOL              bOK ;
   int               iCounter ;
   int               iCounterNum ;
   HWND              hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER);

   memset(szCounter, 0, sizeof(TCHAR) * 256);

   if (ComputerChange)
      {
      // if computer has changed, don't want to continue
      // because the perfdata may have changed
      OnComputerChanged (hDlg) ;
      return (TRUE) ;
      }

   //=============================//
   // Dialog Values Acceptable?   //
   //=============================//

   if (InAlertAdd ())
      {
      eAlertValue = DialogFloat (hDlg, IDD_ADDLINEIFVALUE, &bOK) ;
      if (!bOK)
         {
         DlgErrorBox (hDlg, ERR_NEEDALERTVALUE);
         SetFocus (DialogControl (hDlg, IDD_ADDLINEIFVALUE)) ;
         return (FALSE) ;
         }  // if
      }  // if

   if (bEditLine)
      {
      LineModifyAttributes (hDlg, pLineEdit) ;
      EndDialog (hDlg, TRUE) ;
      }

      // If the user changed the textbox for computer name and pressed enter,
      // the OnAddLines function would be called without a check of the
      // computer name. This solves that problem.
   else
      {

      iCounterNum = LBNumItems (hWndCounters) ;
      for (iCounter = 0 ;
           iCounter < iCounterNum ;
           iCounter++)
         {  // for
         // NOTE: for now, we don't check for duplicate lines
         if (LBSelected (hWndCounters, iCounter))
            {
            pCounter = (PPERFCOUNTERDEF) LBData (hWndCounters, iCounter) ;
            LBString (hWndCounters, iCounter, szCounter) ;

            if (!IsCounterSupported (pCounter->CounterType))
               {
               DlgErrorBox (hDlg, ERR_COUNTER_NOT_IMP);
               }
            else
               {
               AddCounter (hDlg, pCounter, szCounter);
               }
            }
         }  // for
      DialogSetText (hDlg, IDCANCEL, IDS_DONE) ;
      } // else (not bEditLine)

   if (InChartAdd ())
      SizeGraphComponents (hWndGraph) ;
   if (InAlertAdd ())
      SizeAlertComponents (hWndAlert) ;
   if (InReportAdd())
      UpdateReportData (hWndReport);

   WindowInvalidate (PerfmonViewWindow ()) ;

   return TRUE;

   }


void OnExpandExplain (HWND hDlg)
/*
   Effect:        Perform actions needed when user clicks on the Explain...
                  button. In particular, expand the dialog size to
                  uncover the explain edit box, and gray out the button.
*/
   {
   RECT           rectWindow ;

   // Disable button first
   DialogEnable (hDlg, IDD_ADDLINEEXPANDEXPLAIN, FALSE) ;

   // go get the help text
   bExplainTextButtonHit = TRUE ;
   OnCounterChanged (hDlg) ;

   GetWindowRect (hDlg, &rectWindow) ;
   MoveWindow (hDlg,
               rectWindow.left,
               rectWindow.top,
               rectWindow.right - rectWindow.left,
               rectWindow.bottom - rectWindow.top +
               DialogHeight (hDlg, IDD_ADDLINEEXPLAINGROUP) +
               yScrollHeight,
               TRUE) ;
   }

BOOL
/*static*/
OnCommand (
           HWND hDlg,
           WPARAM wParam,
           LPARAM lParam
           )
{
   int            iWidthIndex ;
   int            iStyleIndex ;
   HWND           hWndWidths = DialogControl (hDlg, IDD_ADDLINEWIDTH) ;
   HWND           hWndStyles = DialogControl (hDlg, IDD_ADDLINESTYLE) ;

   switch (LOWORD (wParam))
      {
      case IDD_ADDLINEIFVALUE:
         // We don't get the value when the user types it. We get it when
         // the user attempts to add the line.
         break ;

      case IDD_ADDLINEPROGRAM:
         GetDlgItemText (hDlg,
            IDD_ADDLINEPROGRAM,
            pszAlertProgram,
            FilePathLen - 1) ;
         break ;

      case IDD_ADDLINEIFOVER:
      case IDD_ADDLINEIFUNDER:
         bAlertOver = (LOWORD (wParam) == IDD_ADDLINEIFOVER) ;
         CheckRadioButton (hDlg, IDD_ADDLINEIFOVER, IDD_ADDLINEIFUNDER,
                           bAlertOver ? IDD_ADDLINEIFOVER: IDD_ADDLINEIFUNDER) ;
         break ;

      case IDD_ADDLINEPROGRAMFIRSTTIME:
      case IDD_ADDLINEPROGRAMEVERYTIME:
         bEveryTime = (LOWORD (wParam) == IDD_ADDLINEPROGRAMEVERYTIME) ;
         CheckRadioButton (hDlg, IDD_ADDLINEPROGRAMFIRSTTIME, IDD_ADDLINEPROGRAMEVERYTIME,
                           bEveryTime ? IDD_ADDLINEPROGRAMEVERYTIME: IDD_ADDLINEPROGRAMFIRSTTIME) ;
         break ;

      case IDD_ADDLINEWIDTH:
         iWidthIndex = (int)CBSelection (hWndWidths) ;
#if (!WIDESTYLES)
         DialogEnable (hDlg, IDD_ADDLINESTYLETEXT,
                       iWidthIndex == 0  || iWidthIndex == CB_ERR) ;
         DialogEnable (hDlg, IDD_ADDLINESTYLE,
                       iWidthIndex == 0  || iWidthIndex == CB_ERR) ;
#endif
         break ;

      case IDD_ADDLINESTYLE:
         iStyleIndex = (int)CBSelection (hWndStyles) ;
#if (!WIDESTYLES)
         DialogEnable (hDlg, IDD_ADDLINEWIDTHTEXT,
                       iStyleIndex == 0  || iStyleIndex == CB_ERR) ;
         DialogEnable (hDlg, IDD_ADDLINEWIDTH,
                       iStyleIndex == 0  || iStyleIndex == CB_ERR) ;
#endif
         break ;

      case IDCANCEL:
         EndDialog (hDlg, 0);
         return (TRUE);
         break ;

      case IDD_ADDLINEADD :

         if (ComputerChange)
            {
            SetHourglassCursor() ;
            OnComputerChanged (hDlg) ;
            }
         else
            {
            SetHourglassCursor() ;
            OnAddLines (hDlg) ;
            SetArrowCursor() ;
            }
         break;

      case IDD_ADDLINEEXPANDEXPLAIN :
         if (ComputerChange)
            {
            SetHourglassCursor() ;
            OnComputerChanged (hDlg) ;
            }
         else
            {
            OnExpandExplain (hDlg) ;
            }
         break;

      case IDD_ADDLINEELLIPSES:
         SetHourglassCursor() ;
         OnEllipses (hDlg) ;
         SetArrowCursor() ;
         break ;


      case IDD_ADDLINECOUNTER:
         if (ComputerChange)
            {
            SetHourglassCursor() ;
            OnComputerChanged (hDlg) ;
            }
         else if (HIWORD (wParam) == LBN_SELCHANGE)
            OnCounterChanged (hDlg) ;
         break ;


      case IDD_ADDLINEOBJECT:
         if (ComputerChange)
            {
            SetHourglassCursor() ;
            OnComputerChanged (hDlg) ;
            }
         else if (HIWORD (wParam) == CBN_SELCHANGE)
            OnObjectChanged (hDlg) ;
         break ;

      case IDD_ADDLINEINSTANCE:
         if (ComputerChange)
            {
            SetHourglassCursor() ;
            OnComputerChanged (hDlg) ;
            }
         break ;

      case IDD_ADDLINECOMPUTER:
         if (HIWORD (wParam) == EN_UPDATE)
            {
            ComputerChange = TRUE ;
            }
         break ;

      case IDD_ADDLINEHELP:
         CallWinHelp (dwCurrentDlgID, hDlg) ;
         break ;

		default:
		    break;
	    } // switch

   return (FALSE) ;
   } // OnCommand


void
/*static*/
OnMeasureItem (
               HWND hDlg,
               PMEASUREITEMSTRUCT pMI
               )
   {
   pMI->CtlType    = ODT_COMBOBOX ;
   pMI->CtlID      = IDD_ADDLINECOLOR ;
   pMI->itemData   = 0 ;
   pMI->itemWidth  = 0 ;

   // need 14 in order to draw the thickest line width
   pMI->itemHeight = 14 ;
//   pMI->itemHeight = 12 ;
   }

//***************************************************************************
//                                                                          *
//  FUNCTION   : HandleSelectionState(LPDRAWITEMSTRUCT)                     *
//                                                                          *
//  PURPOSE    : Handles a change in an item selection state. If an item is *
//               selected, a black rectangular frame is drawn around that   *
//               item; if an item is de-selected, the frame is removed.     *
//                                                                          *
//  COMMENT    : The black selection frame is slightly larger than the gray *
//               focus frame so they won't paint over each other.           *
//                                                                          *
//***************************************************************************
void
static
HandleSelectionState (
                      LPDRAWITEMSTRUCT	lpdis
                      )
{
	HBRUSH	hbr ;

	if (lpdis->itemState & ODS_SELECTED)
	{
		// selecting item -- paint a black frame
		hbr = GetStockObject(BLACK_BRUSH) ;
	}
	else
	{
		// de-selecting item -- remove frame
		hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)) ;
	}
    if (hbr) {
        FrameRect(lpdis->hDC, (LPRECT)&lpdis->rcItem, hbr) ;
        DeleteObject (hbr) ;
    }
}

//***************************************************************************
//                                                                          *
//  FUNCTION   : HandleFocusState(LPDRAWITEMSTRUCT)                         *
//                                                                          *
//  PURPOSE    : Handle a change in item focus state. If an item gains the  *
//               input focus, a gray rectangular frame is drawn around that *
//               item; if an item loses the input focus, the gray frame is  *
//               removed.                                                   *
//                                                                          *
//  COMMENT    : The gray focus frame is slightly smaller than the black    *
//               selection frame so they won't paint over each other.       *
//                                                                          *
//***************************************************************************
void
static
HandleFocusState (
                  LPDRAWITEMSTRUCT	lpdis
                  )
{
	RECT	   rc ;
	HBRUSH	hbr ;

	// Resize rectangle to place focus frame between the selection
	// frame and the item.
	CopyRect ((LPRECT)&rc, (LPRECT)&lpdis->rcItem) ;
	InflateRect ((LPRECT)&rc, -OWNER_DRAW_FOCUS, -OWNER_DRAW_FOCUS) ;

	if (lpdis->itemState & ODS_FOCUS)
	{
		// gaining input focus -- paint a gray frame
		hbr = GetStockObject(GRAY_BRUSH) ;
	}
	else
	{
		// losing input focus -- remove (paint over) frame
		hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)) ;
	}
    if (hbr) {
        FrameRect(lpdis->hDC, (LPRECT)&rc, hbr) ;
        DeleteObject (hbr) ;
    }
}


void
/*static*/
OnDrawItem (
            HWND hDlg,
            PDRAWITEMSTRUCT pDI
            )
{
   HDC            hDC ;
   PRECT          prect ;
   INT            itemID,
                  CtlID,
                  itemAction ;
   LOGBRUSH       logBrush ;
   HANDLE         hBrush,
                  hOldBrush,
                  hPen,
                  hOldPen ;
   INT            x1, y1, x2, y2, cy ;
   POINT          point ;
   INT            iPenWidth ;
   COLORREF       BackgroundColor ;

   hDC        = pDI-> hDC ;
   CtlID      = pDI->CtlID ;
   prect      = &pDI->rcItem ;
   itemID     = pDI->itemID ;
   itemAction = pDI->itemAction ;


   if (itemID == -1)
      {
      // invalid ID, can't go on
      HandleFocusState (pDI) ;
      }
   else if (itemAction == ODA_SELECT)
      {
      HandleSelectionState(pDI);
      }
   else if (itemAction == ODA_FOCUS)
      {
      HandleFocusState (pDI) ;
      }
   else
      {

      // draw the entire item

      InflateRect (prect, -OWNER_DRAWN_ITEM, -OWNER_DRAWN_ITEM) ;

      switch (CtlID)
         {  // switch
         case IDD_ADDLINECOLOR:

            // Draw a color rectangle into the control area

            logBrush.lbStyle = BS_SOLID ;
            logBrush.lbColor = (COLORREF) argbColors[itemID] ;
            logBrush.lbHatch = 0 ;

            hBrush = CreateBrushIndirect (&logBrush) ;
            if (!hBrush)
                break;
            hOldBrush = SelectObject (hDC, hBrush) ;

            hPen = GetStockObject (NULL_PEN) ;
            hOldPen = SelectObject (hDC, hPen) ;

            x1 = prect->left ;
            y1 = prect->top ;
            x2 = prect->right ;
            y2 = prect->bottom ;

            Rectangle (hDC, x1, y1, x2, y2) ;

            SelectObject (hDC, hOldBrush) ;
            DeleteObject (hBrush) ;

            InflateRect (prect, OWNER_DRAWN_ITEM, OWNER_DRAWN_ITEM) ;

            HandleSelectionState (pDI) ;
            HandleFocusState (pDI) ;

            break ;

         case IDD_ADDLINEWIDTH:
         case IDD_ADDLINESTYLE:

            // First draw a rectangle, white interior, null border
            hBrush = GetStockObject (WHITE_BRUSH) ;
            hOldBrush = SelectObject (hDC, hBrush) ;

            // we need to set the bk color in order to draw
            // the dash lines coorectly during focus.  Otherwise,
            // the COLOR_WINDOW background will make all dash lines
            // look like solid line...
            BackgroundColor = SetBkColor (hDC, crWhite) ;

            hPen = GetStockObject (NULL_PEN) ;
            hOldPen = SelectObject (hDC, hPen) ;

            x1 = prect->left ;
            y1 = prect->top ;
            x2 = prect->right ;
            y2 = prect->bottom ;

            Rectangle (hDC, x1, y1, x2, y2) ;

            SelectObject (hDC, hOldPen) ;

            // Draw a line of the itemID width in the middle
            // of the control area.

            if (CtlID == IDD_ADDLINEWIDTH)
               {
               iPenWidth = LineWidth (itemID) ;
               hPen = CreatePen (PS_SOLID, iPenWidth, RGB (0, 0, 0)) ;
               }
            else
               {
               hPen = CreatePen (itemID, 1, RGB (0, 0, 0)) ;
               }

            if (!hPen)
                break;
            hOldPen = SelectObject (hDC, hPen) ;

            x1 = prect->left + 8 ;
            cy = prect->bottom - prect->top ;
            y1 = prect->top + (cy / 2) - 1 ;
            x2 = prect->right - 8 ;
            MoveToEx (hDC, x1, y1, &point) ;
            LineTo (hDC, x2, y1) ;

            SelectObject (hDC, hOldPen) ;
            DeleteObject (hPen) ;
            SelectObject (hDC, hOldBrush) ;
            BackgroundColor = SetBkColor (hDC, BackgroundColor) ;

            InflateRect (prect, OWNER_DRAWN_ITEM, OWNER_DRAWN_ITEM) ;

            HandleSelectionState (pDI) ;
            HandleFocusState (pDI) ;

            break ;
         }   // switch
      }  // draw entire item
   }


void
/*static*/
OnDestroy (HDLG hDlg)
   {
   if (!PlayingBackLog ())
      MemoryFree ((LPMEMORY)pPerfData) ;

   if (pszAlertProgram)
      {
      MemoryFree (pszAlertProgram) ;
      pszAlertProgram = NULL ;
      }

   pLineEdit = NULL ;
   bAddLineInProgress = FALSE ;
   dwCurrentDlgID = 0 ;
   bExplainTextButtonHit = FALSE ;
   }



//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//



INT_PTR
FAR
PASCAL
AddLineDlgProc (
                HWND hDlg,
                UINT msg,
                WPARAM wParam,
                LPARAM lParam
                )
{
   BOOL Status;

   switch (msg) {
      case WM_COMMAND:
         OnCommand (hDlg, wParam, lParam) ;
         return (FALSE) ;
         break ;

   	case WM_INITDIALOG:
         SetHourglassCursor() ;
         Status = OnInitDialog (hDlg) ;
         SetArrowCursor() ;

         // set focus on the "Add" button instead of the "Computer"
         SetFocus (DialogControl (hDlg, IDD_ADDLINEADD)) ;
         return FALSE ;
         break ;

      case WM_MEASUREITEM:
         OnMeasureItem (hDlg, (PMEASUREITEMSTRUCT) lParam) ;
         return (TRUE) ;
         break ;

      case WM_DRAWITEM:
         OnDrawItem (hDlg, (PDRAWITEMSTRUCT) lParam) ;
         return (TRUE) ;
         break ;

      case WM_DESTROY:
         OnDestroy (hDlg) ;
         break ;

   	default:
	      break;
      }

   return (FALSE) ;
}




BOOL
AddLine (
         HWND hWndParent,
         PPERFSYSTEM *ppSystemFirstView,
         PLINEVISUAL pLineVisual,
         LPTSTR pInCurrentSystem,
         int iLineTypeToAdd
         )
/*
   Effect:        Display the add line dialog box, allowing the user
                  to specify the computer, object, counter, instance,
                  and scale for a line.  The user can also select the
                  visual aspects of color, width and line style.

*/
{
    pLineEdit = NULL ;

    ppSystemFirst = ppSystemFirstView ;
    iLineType = iLineTypeToAdd ;
    pVisual = pLineVisual ;
    pCurrentSystem = pInCurrentSystem ;

    return (DialogBox (hInstance, idDlgAddLine, hWndParent, AddLineDlgProc) ? TRUE : FALSE) ;
}


BOOL
EditLine (
          HWND hWndParent,
          PPERFSYSTEM *ppSystemFirstView,
          PLINE pLineToEdit,
          int iLineTypeToEdit
          )
{
    if (!pLineToEdit)
        {
        return (FALSE) ;
        }

    pLineEdit = pLineToEdit ;

    ppSystemFirst = ppSystemFirstView ;
    iLineType = iLineTypeToEdit ;
    pVisual = &(pLineToEdit->Visual) ;

    return (DialogBox (hInstance, idDlgAddLine, hWndParent, AddLineDlgProc) ? TRUE : FALSE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\alert.h ===
#define iDefaultAlertIntervalSecs  5


#if 0
PALERT AlertData (HWND hWndAlert) ;
#endif
#define AlertData(hWndAlert)        \
   (&Alert)

BOOL AlertInitializeApplication (void) ;

void ClearAlertDisplay (HWND hWnd) ;


HWND CreateAlertWindow (HWND hWndParent) ;


void UpdateAlertDisplay (HWND hWnd) ;


BOOL AlertInsertLine (HWND hWnd, PLINE pLine) ;


BOOL AlertDeleteLine (HWND hWnd, PLINE pLine) ;


void SizeAlertComponents (HWND hDlg) ;


INT PlaybackAlert (HWND hWndAlert, HANDLE hExportFile) ;

#if 0
PLINESTRUCT CurrentAlertLine (HWND hWndAlert) ;
#endif
#define CurrentAlertLine(hWndAlert)       \
   (LegendCurrentLine (hWndAlertLegend))


BOOL AddAlert (HWND hWndParent) ;


BOOL EditAlert (HWND hWndParent) ;


BOOL AlertRefresh (HWND hWnd) ;
BOOL ToggleAlertRefresh (HWND hWnd) ;


void AlertTimer (HWND hWnd, BOOL bForce) ;


BOOL SetAlertTimer (PALERT pAlert) ;



BOOL OpenAlert (HWND hWndAlert, 
                HANDLE hFile, 
                DWORD dwMajorVersion,
                DWORD dwMinorVersion,
                BOOL bAlertFile) ;


void ResetAlert (HWND hWndAlert) ;
void ResetAlertView (HWND hWndAlert) ;

BOOL SaveAlert (HWND hWndAlert, HANDLE hInputFile, BOOL bGetFileName) ;

void ExportAlert (void) ;

void AlertAddAction (void) ;

void AlertCreateThread (PALERT pAlert) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\alert.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <stdio.h>
#include "perfmon.h"
#include "alert.h"         // External declarations for this file

#include "addline.h"       // for AddLine
#include "fileutil.h"      // for FileRead
#include "legend.h"
#include "line.h"
#include "pmemory.h"       // for MemoryXXX (mallloc-type) routines
#include "owndraw.h"       // for OwnerDraw macros
#include "perfdata.h"      // for UpdateLines
#include "perfmops.h"      // for SystemAdd
#include "playback.h"      // for PlaybackLines
#include "status.h"        // for StatusUpdateAlerts
#include "system.h"        // for SystemGet
#include "utils.h"
#include "menuids.h"       // for IDM_VIEWALERT
#include "fileopen.h"      // for FileGetName
#include "counters.h"      // for CounterEntry

#include <lmcons.h>
#include <lmmsg.h>
#include <lmerr.h>

#include "perfmsg.h"       // Alert eventlog message id

#define WM_SEND_NETWORK_ALERT (WM_USER + 101)

//==========================================================================//
//                                  Typedefs                                //
//==========================================================================//

typedef NET_API_STATUS
(*pNetMessageBufferSend) (
                         IN  LPTSTR  servername,
                         IN  LPTSTR  msgname,
                         IN  LPTSTR  fromname,
                         IN  LPBYTE  buf,
                         IN  DWORD   buflen
                         );

typedef struct ALERTENTRYSTRUCT {
    SYSTEMTIME     SystemTime ;
    PLINE          pLine ;
    FLOAT          eValue ;
    BOOL           bOver ;
    FLOAT          eAlertValue ;
    LPTSTR         lpszInstance ;
    LPTSTR         lpszParent ;
    INT            StringWidth ;
} ALERTENTRY ;

typedef ALERTENTRY *PALERTENTRY ;

static HBRUSH  hRedBrush ;

//====
//====

//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define szNumberFormat         TEXT("%12.3f")
#define szMediumnNumberFormat  TEXT("%12.0f")
#define szLargeNumberFormat    TEXT("%12.4e")
#define eNumber                ((FLOAT) 99999999.999)
#define eLargeNumber           ((FLOAT) 999999999999.0)

#define szNumberPrototype        TEXT("99999999.999")


#define szConditionFormat        TEXT("  %c  ")
#define szConditionPrototype     TEXT("  >  ")

#define szDatePrototype          TEXT("12/31/1999   ")
#define szTimePrototype          TEXT("12:34:56.9 pm  ")

#define ALERTLOGMAXITEMS         1000
// enclose alert within double quotes to make it a single command line
// argument rather then 10 args.
#define szAlertFormat TEXT("\"%s %s %s %c %s %s,  %s,  %s,  %s,  %s\"")


//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define AlertItemTopMargin()     (yBorderHeight)



//==========================================================================//
//                              Local Functions                             //
//==========================================================================//
INT ExportAlertLine (PLINE pLine, FLOAT eValue, SYSTEMTIME *pSystemTime, HANDLE hExportFile) ;

void
AlertFormatFloat (
                 LPTSTR lpValueBuf,
                 FLOAT eValue
                 )
{
    if (eValue <= eNumber) {
        TSPRINTF (lpValueBuf, szNumberFormat, eValue) ;
    } else if (eValue <= eLargeNumber) {
        TSPRINTF (lpValueBuf, szMediumnNumberFormat, eValue) ;
    } else {
        TSPRINTF (lpValueBuf, szLargeNumberFormat, eValue) ;
    }
    ConvertDecimalPoint (lpValueBuf) ;

}


PALERT
AllocateAlertData (
                  HWND hWndAlert
                  )
{
    PALERT           pAlert ;

    pAlert = AlertData (hWndAlert) ;

    pAlert->hWnd = hWndAlert ;
    pAlert->hAlertListBox = DialogControl (hWndAlert, IDD_ALERTLOG) ;
    pAlert->iStatus = iPMStatusClosed ;
    pAlert->bManualRefresh = FALSE ;
    pAlert->bModified = FALSE ;

    pAlert->Visual.iColorIndex = 0 ;
    pAlert->Visual.iWidthIndex = -1 ;
    pAlert->Visual.iStyleIndex = -1 ;

    pAlert->iIntervalMSecs = iDefaultAlertIntervalSecs * 1000 ;
    pAlert->pSystemFirst = NULL ;
    pAlert->pLineFirst = NULL ;

    pAlert->MessageName[0] = TEXT('\0') ;

    pAlert->bLegendOn = TRUE ;

    return (pAlert) ;
}


void FreeAlertData (PALERT pAlert) {}


BOOL
SetAlertTimer (
              PALERT pAlert
              )
{
    if (pAlert->iStatus == iPMStatusCollecting)
        KillTimer (pAlert->hWnd, AlertTimerID) ;

    pAlert->iStatus = iPMStatusCollecting ;
    SetTimer (pAlert->hWnd, AlertTimerID, pAlert->iIntervalMSecs, NULL) ;
    return (TRUE) ;
}


BOOL
ClearAlertTimer (
                PALERT pAlert
                )
{
    if (!PlayingBackLog()) {
        KillTimer (pAlert->hWnd, AlertTimerID) ;
    }
    pAlert->iStatus = iPMStatusClosed ;

    return (TRUE) ;
}


BOOL
AlertExec (
          LPTSTR lpszImageName,
          LPTSTR lpszCommandLine
          )
/*
   Effect:        WinExec is considered obsolete. We're supposed to use
                  CreateProcess, which allows considerably more control.
                  For perfmon, we only execute a program when an alert
                  occurs, and we really don't know anything about the
                  program, so can't really do much.  We just set some
                  defaults and go.

   Called By:     SignalAlert only.
*/
{
    STARTUPINFO    si ;
    PROCESS_INFORMATION  pi ;
    int            StringLen ;
    TCHAR          TempBuffer [ 5 * FilePathLen ] ;
    BOOL           RetCode;
    DWORD          dwCreationFlags = NORMAL_PRIORITY_CLASS;

    memset (&si, 0, sizeof (STARTUPINFO)) ;
    si.cb = sizeof (STARTUPINFO) ;
    si.dwFlags = STARTF_USESHOWWINDOW ;
    si.wShowWindow = SW_SHOWNOACTIVATE ;
    memset (&pi, 0, sizeof (PROCESS_INFORMATION)) ;

    lstrcpy (TempBuffer, lpszImageName) ;
    StringLen = lstrlen (TempBuffer) ;

    // see if this is a CMD or a BAT file
    // if it is then create a process with a console window, otherwise
    // assume it's an executable file that will create it's own window
    // or console if necessary
    //
    _tcslwr (TempBuffer);
    if ((_tcsstr(TempBuffer, TEXT(".bat")) != NULL) ||
        (_tcsstr(TempBuffer, TEXT(".cmd")) != NULL)) {
        dwCreationFlags |= CREATE_NEW_CONSOLE;
    } else {
        dwCreationFlags |= DETACHED_PROCESS;
    }
    // recopy the image name to the temp buffer since it was modified
    // (i.e. lowercased) for the previous comparison.

    lstrcpy (TempBuffer, lpszImageName) ;
    StringLen = lstrlen (TempBuffer) ;

    // now add on the alert text preceded with a space char
    TempBuffer [StringLen] = TEXT(' ') ;
    StringLen++ ;
    lstrcpy (&TempBuffer[StringLen], lpszCommandLine) ;

    // DETACHED_PROCESS is needed to get rid of the ugly console window
    // that SQL guys have been bitching..
    RetCode = CreateProcess (NULL, TempBuffer,
                             NULL, NULL, FALSE,
                             dwCreationFlags,
                             //                          (DWORD) NORMAL_PRIORITY_CLASS | DETACHED_PROCESS,
                             //                          (DWORD) NORMAL_PRIORITY_CLASS,
                             NULL, NULL,
                             &si, &pi) ;
    if (RetCode) {
        if (pi.hProcess && pi.hProcess != INVALID_HANDLE_VALUE) {
            CloseHandle (pi.hProcess) ;
        }
        if (pi.hThread && pi.hThread != INVALID_HANDLE_VALUE) {
            CloseHandle (pi.hThread) ;
        }
    }

    return RetCode ;
}


BOOL
SendNetworkMessage (
                   LPTSTR pText,
                   DWORD TextLen,
                   LPTSTR pMessageName
                   )
{
    NET_API_STATUS NetStatus;
    HANDLE dllHandle ;
    pNetMessageBufferSend SendFunction ;

    //
    // Dynamically link to netapi32.dll.  If it's not there just return.  Return
    // TRUE so we won't try to send this alert again.
    //

    dllHandle = LoadLibrary(TEXT("NetApi32.Dll")) ;
    if ( !dllHandle || dllHandle == INVALID_HANDLE_VALUE ) {
        return(TRUE) ;
    }

    //
    // Get the address of the service's main entry point.  This
    // entry point has a well-known name.
    //

    SendFunction = (pNetMessageBufferSend)GetProcAddress(
                                                        dllHandle, "NetMessageBufferSend") ;

    if (SendFunction == NULL) {
        FreeLibrary (dllHandle) ;
        return(TRUE) ;
    }

    NetStatus = (*SendFunction) (NULL, pMessageName,
                                 NULL, (LPBYTE)pText, TextLen * sizeof(TCHAR)) ;
    if (NetStatus != NERR_Success) {
        FreeLibrary (dllHandle) ;
        return (FALSE) ;
    }

    FreeLibrary (dllHandle) ;

    return (TRUE) ;
}


// this is the child thread used to send out network alert message.
// This thread is created at init time and is destroyed at close time
void
NetAlertHandler (
                LPVOID *pDummy
                )
{
    MSG      msg;

    while (GetMessage (&msg, NULL, 0, 0)) {
        // we are only interested in this message
        if (LOWORD(msg.message) == WM_SEND_NETWORK_ALERT) {
            SendNetworkMessage ((LPTSTR)(msg.wParam),
                                lstrlen ((LPTSTR)(msg.wParam)),
                                (LPTSTR)(msg.lParam)) ;
            MemoryFree ((LPTSTR)(msg.wParam)) ;
        }
    }
}


void
SignalAlert (
            HWND hWnd,
            HWND hWndAlerts,
            PLINE pLine,
            FLOAT eValue,
            SYSTEMTIME *pSystemTime,
            LPTSTR pSystemName,
            DWORD dwSystemState
            )
/*
   Effect:        Perform any actions necessary when a given alert line's
                  condition is true. In particular, add the alert to the
                  alert log. Also, depending on the user's wishes, signal
                  a network alert or beep or run a program.

                  If we are not viewing the alert screen, add one alert to
                  the unviewed list.
*/
{
    INT_PTR        iIndex ;
    PALERT         pAlert ;
    PALERTENTRY    pAlertEntry ;
    TCHAR          szTime [20] ;
    TCHAR          szDate [20] ;
    TCHAR          szInstance [256] ;
    TCHAR          szParent [256] ;
    TCHAR          szText [256 * 4] ;
    TCHAR          eValueBuf [40] ;
    TCHAR          eAlertValueBuf [40] ;
    TCHAR          eAlertValueBuf1 [42] ;
    FLOAT          eLocalValue ;
    DWORD          TextSize = 0;
    LPTSTR         lpAlertMsg ;
    LPTSTR         lpEventLog[7] ;
    TCHAR          NullBuff [2] ;

    NullBuff [0] = NullBuff [1] = TEXT('\0') ;

    pAlert = AlertData (hWnd) ;

    pAlertEntry = MemoryAllocate (sizeof (ALERTENTRY)) ;
    if (!pAlertEntry) {
        return ;
    }
    pAlertEntry->SystemTime = *pSystemTime ;
    pAlertEntry->pLine= pLine ;
    pAlertEntry->eValue = eValue ;
    if (pLine) {
        pAlertEntry->bOver = pLine->bAlertOver ;
        pAlertEntry->eAlertValue = pLine->eAlertValue ;
    }


    //=============================//
    // Determine Instance, Parent  //
    //=============================//

    // It's possible that there will be no instance, therefore
    // the lnInstanceName would be NULL.

    if (pLine && pLine->lnObject.NumInstances > 0) {
        // Test for the parent object instance name title index.
        // If there is one, it implies that there will be a valid
        // Parent Object Name and a valid Parent Object Instance Name.

        // If the Parent Object title index is 0 then
        // just display the instance name.

        lstrcpy (szInstance, pLine->lnInstanceName) ;
        if (pLine->lnInstanceDef.ParentObjectTitleIndex && pLine->lnPINName) {
            // Get the Parent Object Name.
            lstrcpy (szParent, pLine->lnPINName) ;
        } else {
            szParent[0] = TEXT(' ') ;
            szParent[1] = TEXT('\0') ;
        }
    } else {
        if (pLine) {
            szInstance[0] = TEXT(' ') ;
            szInstance[1] = TEXT('\0') ;
            szParent[0] = TEXT(' ') ;
            szParent[1] = TEXT('\0') ;
        } else {
            // this is a system down/reconnect alert
            StringLoad (
                       dwSystemState == SYSTEM_DOWN ?
                       IDS_SYSTEM_DOWN : IDS_SYSTEM_UP,
                       szInstance) ;
            lstrcpy (szParent, pSystemName) ;
        }
    }


    pAlertEntry->lpszInstance = StringAllocate (szInstance) ;
    pAlertEntry->lpszParent = StringAllocate (szParent) ;

    //=============================//
    // Add alert to Alert Log      //
    //=============================//

    if (LBNumItems (hWndAlerts) >= ALERTLOGMAXITEMS)
        LBDelete (hWndAlerts, 0) ;

    iIndex = LBAdd (hWndAlerts, (LPARAM) pAlertEntry) ;
    LBSetSelection (hWndAlerts, iIndex) ;

    // no need to check other things if we
    // are playing back log
    if (PlayingBackLog()) {
        return ;
    }

    //=============================//
    // Update Status Line          //
    //=============================//

    if (iPerfmonView != IDM_VIEWALERT) {
        if (pAlert->bSwitchToAlert) {
            SendMessage (hWndMain, WM_COMMAND, (LONG)IDM_VIEWALERT, 0L) ;
        } else {
            // if iUnviewedAlerts is over 100, we will display "++"
            // so, no need to keep updating the icon...
            if (iUnviewedAlerts < 100) {
                iUnviewedAlerts ++ ;
                if (pLine) {
                    crLastUnviewedAlert = pLine->Visual.crColor ;
                }
                StatusUpdateIcons (hWndStatus) ;
            }
        }
    }

    //===================================//
    //  Check if we need to do anything  //
    //===================================//
    szText[0] = TEXT('\0') ;
    if ((pAlert->bNetworkAlert && pAlert->MessageName[0])
        ||
        (pLine) &&
        (pLine->lpszAlertProgram &&
         (pLine->bEveryTime || !pLine->bAlerted))
        ||
        (pAlert->bEventLog)) {
        // format the alert line to be exported
        SystemTimeDateString (pSystemTime, szDate) ;
        SystemTimeTimeString (pSystemTime, szTime, TRUE) ;

        if (pLine) {
            AlertFormatFloat (eValueBuf, pAlertEntry->eValue) ;

            eLocalValue = pAlertEntry->eAlertValue ;
            if (eLocalValue < (FLOAT) 0.0) {
                eLocalValue = -eLocalValue ;
            }
            AlertFormatFloat (eAlertValueBuf, pAlertEntry->eAlertValue) ;

            TSPRINTF (szText,
                      szAlertFormat,
                      szDate,
                      szTime,
                      eValueBuf,
                      (pLine->bAlertOver ? TEXT('>') : TEXT('<')),
                      eAlertValueBuf,
                      pLine->lnCounterName,
                      szInstance,
                      szParent,
                      pLine->lnObjectName,
                      pLine->lnSystemName) ;
        } else {
            lstrcpy (eValueBuf, DashLine) ;
            lstrcpy (eAlertValueBuf, eValueBuf) ;
            TSPRINTF (szText,
                      szAlertFormat,
                      szDate,
                      szTime,
                      eValueBuf,
                      TEXT(' '),
                      eAlertValueBuf,
                      szInstance,             // system up/down message
                      NullBuff,
                      NullBuff,
                      NullBuff,
                      szParent) ;
        }

        TextSize = sizeof(TCHAR) * (lstrlen(szText)+1) ;
    }

    if (szText[0] == TEXT('\0')) {
        // nothing to do
        return ;
    }

    //=============================//
    // Network Alert?              //
    //=============================//

    SetHourglassCursor() ;

    if (pAlert->bNetworkAlert && pAlert->MessageName[0]) {

        if (pAlert->dwNetAlertThreadID) {
            // use thread to send the network alert.
            // the memory will be released by the child thread when done
            lpAlertMsg =
            (LPTSTR) MemoryAllocate (TextSize) ;
            if (lpAlertMsg) {
                lstrcpy (lpAlertMsg, szText) ;
                PostThreadMessage (pAlert->dwNetAlertThreadID,
                                   WM_SEND_NETWORK_ALERT,
                                   (WPARAM)lpAlertMsg,
                                   (LPARAM)pAlert->MessageName) ;
            }
        } else {
            // no thread available, use the slow way to send the network alert
            SendNetworkMessage (szText,
                                (DWORD) lstrlen(szText),
                                pAlert->MessageName) ;
        }
    }


    //=============================//
    // Run Program?                //
    //=============================//

    if (pLine &&
        pLine->lpszAlertProgram &&
        (pLine->bEveryTime || !pLine->bAlerted)) {
        AlertExec (pLine->lpszAlertProgram, szText) ;
        pLine->bAlerted = TRUE ;
    }

    //===================================//
    // Log event to Application Log?     //
    //===================================//
    if (pAlert->bEventLog) {
        if (hEventLog) {
            if (pLine) {
                lpEventLog[0] = pLine->lnSystemName ;
                lpEventLog[1] = pLine->lnObjectName ;
                lpEventLog[2] = pLine->lnCounterName ;
                lpEventLog[3] = szInstance ;
                lpEventLog[4] = szParent ;
                lpEventLog[5] = eValueBuf ;
                eAlertValueBuf1[0] = pLine->bAlertOver ? TEXT('>') : TEXT('<') ;
                eAlertValueBuf1[1] = TEXT(' ') ;
                lstrcpy (&eAlertValueBuf1[2], eAlertValueBuf) ;
                lpEventLog[6] = eAlertValueBuf1 ;
            } else {
                lpEventLog[0] = szParent ;
                lpEventLog[1] = szInstance ;
            }

            ReportEvent (hEventLog,
                         (WORD)EVENTLOG_INFORMATION_TYPE,
                         (WORD)0,
                         (DWORD)(pLine ? MSG_ALERT_OCCURRED : MSG_ALERT_SYSTEM),
                         (PSID)NULL,
                         (WORD)(pLine ? 7 : 2),
                         (DWORD)TextSize,
                         (LPCTSTR *)lpEventLog,
                         (LPVOID)(szText)) ;
        }
    }
    SetArrowCursor() ;
}


BOOL
AlertCondition (
               PLINE pLine,
               FLOAT eValue
               )
/*
   Effect:        Return whether the alert test passed for line pLine,
                  with current data value eValue.

   Internals:     Don't *ever* say (bFoo == bBar), as non-FALSE values
                  could be represented by any nonzero number.  Use
                  BoolEqual or equivalent.
*/
{
    BOOL           bOver ;

    bOver = eValue > pLine->eAlertValue ;

    return (BoolEqual (bOver, pLine->bAlertOver)) ;
}


INT
static
CheckAlerts (
            HWND hWnd,
            HWND hWndAlerts,
            SYSTEMTIME *pSystemTime,
            PLINE pLineFirst,
            HANDLE hExportFile,
            PPERFSYSTEM pSystemFirst
            )
{
    FLOAT          eValue ;
    PLINE          pLine ;
    BOOL           bAnyAlerts ;
    INT            ErrCode = 0 ;
    PPERFSYSTEM    pSystem ;

    bAnyAlerts = FALSE ;
    if (!PlayingBackLog()) {
        LBSetRedraw (hWndAlerts, FALSE) ;

        // check for system up/down
        for (pSystem = pSystemFirst ;
            pSystem ;
            pSystem = pSystem->pSystemNext) {
            if (pSystem->dwSystemState == SYSTEM_DOWN) {
                pSystem->dwSystemState = SYSTEM_DOWN_RPT ;
                SignalAlert (hWnd,
                             hWndAlerts,
                             NULL,
                             (FLOAT) 0.0,
                             pSystemTime,
                             pSystem->sysName,
                             SYSTEM_DOWN) ;
            } else if (pSystem->dwSystemState == SYSTEM_RECONNECT) {
                pSystem->dwSystemState = SYSTEM_RECONNECT_RPT ;
                SignalAlert (hWnd,
                             hWndAlerts,
                             NULL,
                             (FLOAT) 0.0,
                             pSystemTime,
                             pSystem->sysName,
                             SYSTEM_RECONNECT) ;
            }
        }
    }


    for (pLine = pLineFirst ;
        pLine ;
        pLine = pLine->pLineNext) {
        if (pLine->bFirstTime) {
            // skip until we have collect enough samples for the first data
            continue ;
        }

        // Get the new value for this line.
        eValue = CounterEntry (pLine) ;
        if (AlertCondition (pLine, eValue)) {
            bAnyAlerts = TRUE ;

            // the case that hExportFile is !NULL is when playingback log and that the
            // listbox is overflowed with alert.  In this case, we have to
            // walk the log file again to re-generate all the alerts.
            if (hExportFile) {
                ErrCode = ExportAlertLine (pLine, eValue, pSystemTime, hExportFile) ;
                if (ErrCode) {
                    break ;
                }
            } else {
                SignalAlert (hWnd,
                             hWndAlerts,
                             pLine,
                             eValue,
                             pSystemTime,
                             NULL,
                             0) ;
            }
        }
    }

    if (!PlayingBackLog()) {
        LBSetRedraw (hWndAlerts, TRUE) ;
    }

    return (ErrCode) ;
}


void
DrawAlertEntry (
               HWND hWnd,
               PALERT pAlert,
               PALERTENTRY pAlertEntry,
               LPDRAWITEMSTRUCT lpDI,
               HDC hDC
               )
{
    PLINE          pLine ;
    RECT           rectUpdate ;

    TCHAR          szTime [20] ;
    TCHAR          szDate [20] ;
    TCHAR          szText [256] ;

    HBRUSH         hBrushPrevious ;
    FLOAT          eLocalValue ;
    COLORREF       preBkColor = 0;
    COLORREF       preTextColor = 0;

    pLine = pAlertEntry->pLine ;

    SystemTimeDateString (&(pAlertEntry->SystemTime), szDate) ;
    SystemTimeTimeString (&(pAlertEntry->SystemTime), szTime, TRUE) ;

    if (DISelected (lpDI)) {
        preTextColor = SetTextColor (hDC, GetSysColor (COLOR_HIGHLIGHTTEXT)) ;
        preBkColor = SetBkColor (hDC, GetSysColor (COLOR_HIGHLIGHT)) ;
    }

    //=============================//
    // Draw Color Dot              //
    //=============================//

    rectUpdate.left = 0 ;
    rectUpdate.top = lpDI->rcItem.top ;
    rectUpdate.right = pAlert->xColorWidth ;
    rectUpdate.bottom = lpDI->rcItem.bottom ;

    ExtTextOut (hDC, rectUpdate.left, rectUpdate.top,
                ETO_CLIPPED | ETO_OPAQUE,
                &rectUpdate,
                NULL, 0,
                NULL) ;

    if (pLine) {
        hBrushPrevious = SelectBrush (hDC, pLine->hBrush) ;
    } else {
        if (hRedBrush == NULL) {
            hRedBrush = CreateSolidBrush (RGB (0xff, 0x00, 0x00)) ;
        }
        hBrushPrevious = SelectBrush (hDC, hRedBrush) ;
    }

    Ellipse (hDC,
             rectUpdate.left + 2,
             rectUpdate.top + 2,
             rectUpdate.right - 2,
             rectUpdate.bottom - 2) ;

    SelectBrush (hDC, hBrushPrevious) ;

    //=============================//
    // Draw Date                   //
    //=============================//

    rectUpdate.left = rectUpdate.right ;
    rectUpdate.right = rectUpdate.left + pAlert->xDateWidth ;

    ExtTextOut (hDC, rectUpdate.left, rectUpdate.top,
                ETO_CLIPPED | ETO_OPAQUE,
                &rectUpdate,
                szDate, lstrlen (szDate),
                NULL) ;

    //=============================//
    // Draw Time                   //
    //=============================//

    rectUpdate.left = rectUpdate.right ;
    rectUpdate.right = rectUpdate.left + pAlert->xTimeWidth ;

    ExtTextOut (hDC, rectUpdate.left, rectUpdate.top,
                ETO_CLIPPED | ETO_OPAQUE,
                &rectUpdate,
                szTime, lstrlen (szTime),
                NULL) ;

    //=============================//
    // Draw Alert Value            //
    //=============================//

    SetTextAlign (hDC, TA_RIGHT) ;

    rectUpdate.left = rectUpdate.right ;
    rectUpdate.right = rectUpdate.left + pAlert->xNumberWidth ;

    if (pLine) {
        AlertFormatFloat (szText, pAlertEntry->eValue) ;
    } else {
        lstrcpy (szText, DashLine) ;
    }

    ExtTextOut (hDC, rectUpdate.right, rectUpdate.top,
                ETO_CLIPPED | ETO_OPAQUE,
                &rectUpdate,
                szText, lstrlen (szText),
                NULL) ;

    //=============================//
    // Draw Alert Condition        //
    //=============================//

    rectUpdate.left = rectUpdate.right ;
    rectUpdate.right = rectUpdate.left + pAlert->xConditionWidth ;

    TSPRINTF (szText, szConditionFormat,
              pLine ?
              (pAlertEntry->bOver ? TEXT('>') : TEXT('<')) :
              TEXT(' ')
             ) ;

    ExtTextOut (hDC, rectUpdate.right, rectUpdate.top,
                ETO_CLIPPED | ETO_OPAQUE,
                &rectUpdate,
                szText, lstrlen (szText),
                NULL) ;

    //=============================//
    // Draw Trigger Value          //
    //=============================//

    rectUpdate.left = rectUpdate.right ;
    rectUpdate.right = rectUpdate.left + pAlert->xNumberWidth ;

    if (pLine) {
        eLocalValue = pAlertEntry->eAlertValue ;
        if (eLocalValue < (FLOAT) 0.0) {
            eLocalValue = -eLocalValue ;
        }
        AlertFormatFloat (szText, pAlertEntry->eAlertValue) ;
    } else {
        lstrcpy (szText, DashLine) ;
    }

    ExtTextOut (hDC, rectUpdate.right, rectUpdate.top,
                ETO_CLIPPED | ETO_OPAQUE,
                &rectUpdate,
                szText, lstrlen (szText),
                NULL) ;

    //=============================//
    // Draw Rest                   //
    //=============================//

    SetTextAlign (hDC, TA_LEFT) ;

    rectUpdate.left = rectUpdate.right ;
    rectUpdate.right = 10000 ;

    if (pLine) {
        TSPRINTF (szText,
                  TEXT("    %s,  %s,  %s,  %s,  %s"),
                  pLine->lnCounterName,
                  pAlertEntry->lpszInstance,
                  pAlertEntry->lpszParent,
                  pLine->lnObjectName,
                  pLine->lnSystemName) ;
    } else {
        TSPRINTF (szText,
                  TEXT("    %s, , , ,  %s"),
                  pAlertEntry->lpszInstance,
                  pAlertEntry->lpszParent) ;
    }

    ExtTextOut (hDC, rectUpdate.left, rectUpdate.top,
                ETO_OPAQUE,
                &rectUpdate,
                szText, lstrlen (szText),
                NULL) ;

    // check if we need to bring-up or resize the horiz scrollbar
    if (pAlertEntry->StringWidth == 0) {
        pAlertEntry->StringWidth = TextWidth (hDC, szText) + xScrollWidth +
                                   rectUpdate.left ;
    }

    if (pAlertEntry->StringWidth > pAlert->xTextExtent) {
        pAlert->xTextExtent = pAlertEntry->StringWidth ;
        LBSetHorzExtent (pAlert->hAlertListBox, pAlertEntry->StringWidth) ;
    }

    if (DISelected (lpDI)) {
        preTextColor = SetTextColor (hDC, preTextColor) ;
        preBkColor = SetBkColor (hDC, preBkColor) ;
    }
}



//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void
static
OnDrawItem (
           HWND hWnd,
           LPDRAWITEMSTRUCT lpDI
           )
{
    HFONT          hFontPrevious ;
    HDC            hDC ;
    PALERT         pAlert ;
    PALERTENTRY    pAlertEntry ;
    //   PLINESTRUCT    pLine ;
    int            iLBIndex ;

    hDC = lpDI->hDC ;
    iLBIndex = DIIndex (lpDI) ;

    pAlert = AlertData (hWnd) ;

    if (iLBIndex == -1) {
        pAlertEntry = NULL ;
    } else {
        pAlertEntry = (PALERTENTRY) LBData (pAlert->hAlertListBox, iLBIndex) ;
        if (pAlertEntry == (PALERTENTRY) LB_ERR) {
            pAlertEntry = NULL ;
        }
    }

    //=============================//
    // Draw Legend Item            //
    //=============================//

    if (pAlertEntry) {
        hFontPrevious = SelectFont (hDC, pAlert->hFontItems) ;
        DrawAlertEntry (hWnd, pAlert, pAlertEntry, lpDI, hDC) ;
        SelectFont (hDC, hFontPrevious) ;
    }

    //=============================//
    // Draw Focus                  //
    //=============================//

    if (DIFocus (lpDI))
        DrawFocusRect (hDC, &(lpDI->rcItem)) ;

}



INT_PTR
static
OnCtlColor (
           HWND hDlg,
           HDC hDC
           )
{
    SetTextColor (hDC, crBlack) ;
    //   SetBkColor (hDC, crLightGray) ;
    //   return ((int) hbLightGray) ;
    SetBkColor (hDC, ColorBtnFace) ;
    return ((INT_PTR) hBrushFace) ;
}

void
AlertCreateThread (
                  PALERT pAlert
                  )
{
    pAlert->hNetAlertThread = CreateThread(NULL, (DWORD)1024L,
                                           (LPTHREAD_START_ROUTINE)NetAlertHandler,
                                           NULL, (DWORD)0, &(pAlert->dwNetAlertThreadID)) ;

    if (!(pAlert->hNetAlertThread)) {
        // CreateThread failure, set its ID to zero
        // so we will not use the thread
        pAlert->dwNetAlertThreadID = 0 ;
    } else {
        SetThreadPriority (pAlert->hNetAlertThread, THREAD_PRIORITY_HIGHEST) ;
    }
}

void
static
OnInitDialog (
             HWND hDlg
             )
{
    HDC            hDC ;
    PALERT         pAlert ;

    iUnviewedAlerts = 0 ;

    pAlert = AllocateAlertData (hDlg) ;
    if (!pAlert)
        return ;

    pAlert->iStatus = iPMStatusClosed ;
    pAlert->hFontItems = hFontScales ;

    hDC = GetDC (hDlg) ;
    SelectFont (hDC, pAlert->hFontItems) ;

    pAlert->yItemHeight = FontHeight (hDC, TRUE) + 2 * AlertItemTopMargin () ;

    pAlert->xColorWidth = pAlert->yItemHeight ;
    pAlert->xDateWidth = TextWidth (hDC, szDatePrototype) ;
    pAlert->xTimeWidth = TextWidth (hDC, szTimePrototype) ;
    pAlert->xNumberWidth = TextWidth (hDC, szNumberPrototype) ;
    pAlert->xConditionWidth = TextWidth (hDC, szConditionPrototype) ;

    // no Horz. scroll bar to begin with
    pAlert->xTextExtent = 0 ;
    pAlert->hNetAlertThread = 0;
#if 0
    pAlert->hNetAlertThread = CreateThread(NULL, (DWORD)1024L,
                                           (LPTHREAD_START_ROUTINE)NetAlertHandler,
                                           NULL, (DWORD)0, &(pAlert->dwNetAlertThreadID)) ;

    if (!(pAlert->hNetAlertThread)) {
        // CreateThread failure, set its ID to zero
        // so we will not use the thread
        pAlert->dwNetAlertThreadID = 0 ;
    } else {
        SetThreadPriority (pAlert->hNetAlertThread, THREAD_PRIORITY_HIGHEST) ;
    }
#endif
    ReleaseDC (hDlg, hDC) ;

    hWndAlertLegend = DialogControl (hDlg, IDD_ALERTLEGEND) ;
    UpdateAlertDisplay (hDlg) ;
}



void
static
OnMeasureItem (
              HWND hWnd,
              LPMEASUREITEMSTRUCT lpMI
              )
/*
   Note:          Since we have an LB_OWNERDRAWFIXED item in the alert
                  dialog, we get this message *before* the WM_INITDIALOG
                  message.  Therefore we can't rely on any of the values
                  set in that message handler.
*/
{
    HDC            hDC ;

    hDC = GetDC (hWnd) ;
    SelectFont (hDC, hFontScales) ;

    lpMI->itemHeight = FontHeight (hDC, TRUE) + 2 * AlertItemTopMargin () ;

    ReleaseDC (hWnd, hDC) ;
}


void
static
OnDeleteItem (
             HDLG hDlg,
             WPARAM wControlID,
             LPDELETEITEMSTRUCT lpDI
             )
{
    PALERTENTRY    pAlertEntry ;

    pAlertEntry = (PALERTENTRY) lpDI->itemData ;

    MemoryFree (pAlertEntry->lpszParent) ;
    MemoryFree (pAlertEntry->lpszInstance) ;

    MemoryFree (pAlertEntry) ;
}



void
static
OnSize (
       HWND hDlg,
       int xWidth,
       int yHeight
       )
{
    SizeAlertComponents (hDlg) ;
}


void
static
OnDestroy (
          HWND hWnd
          )
/*
   Effect:        Perform any actions necessary when an AlertDisplay window
                  is being destroyed. In particular, free the instance
                  data for the log.

                  Since we really only have one log window and one global
                  log data structure, we don't free the structure. We do,
                  however, delete the objects allocated within the structure.
*/
{
    PALERT           pAlert ;

    pAlert = AlertData (hWnd) ;
    FreeAlertData (pAlert) ;

    if (pAlert->dwNetAlertThreadID) {
        CloseHandle (pAlert->hNetAlertThread) ;
    }
}



//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


BOOL
AlertInitializeApplication (void)
{
    return (TRUE) ;
}


INT_PTR
APIENTRY
AlertDisplayDlgProc (
                    HWND hDlg,
                    UINT iMessage,
                    WPARAM wParam,
                    LPARAM lParam
                    )
/*
   Note:          This function must be exported in the application's
                  linker-definition file, perfmon.def.
*/
{
    switch (iMessage) {
        case WM_CTLCOLORDLG:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSTATIC:
            return (OnCtlColor (hDlg, (HDC) wParam)) ;
            break ;

        case WM_DELETEITEM:
            OnDeleteItem (hDlg, wParam, (LPDELETEITEMSTRUCT) lParam) ;
            break ;

        case WM_DRAWITEM:
            OnDrawItem (hDlg, (LPDRAWITEMSTRUCT) lParam) ;
            break ;

        case WM_INITDIALOG:
            OnInitDialog (hDlg) ;
            break ;

        case WM_LBUTTONDOWN:
            DoWindowDrag (hDlg, lParam) ;
            break ;

        case WM_LBUTTONDBLCLK:
            SendMessage (hWndMain, WM_LBUTTONDBLCLK, wParam, lParam) ;
            break ;

        case WM_MEASUREITEM:
            OnMeasureItem (hDlg, (LPMEASUREITEMSTRUCT) lParam) ;
            break ;

        case WM_SIZE:
            OnSize (hDlg, LOWORD (lParam), HIWORD (lParam)) ;
            break ;

        case WM_TIMER:
            AlertTimer (hDlg, FALSE) ;
            break ;

        case WM_DESTROY:
            OnDestroy (hDlg) ;
            return (FALSE) ;
            break ;

        default:
            return (FALSE) ;
    } // switch

    return (TRUE) ;
}


HWND
CreateAlertWindow (
                  HWND hWndParent
                  )
/*
   Effect:        Create the Alert window. This window is a child of
                  hWndMain.

   Note:          We dont worry about the size here, as this window
                  will be resized whenever the main window is resized.

*/
{
    HWND           hWnd ;
    hWnd = CreateDialog (hInstance,
                         MAKEINTRESOURCE (idDlgAlertDisplay),
                         hWndParent,
                         AlertDisplayDlgProc) ;

    return (hWnd) ;
}



void
UpdateAlertDisplay (
                   HWND hWnd
                   )
/*
   Effect:        Set the values for the various controls in the Alert
                  display.

   Called By:     OnInitDialog, any other routines that change these
                  values.
*/
{
    PALERT         pAlert ;

    pAlert = AlertData (hWnd) ;

    DialogSetInterval (hWnd, IDD_ALERTINTERVAL, pAlert->iIntervalMSecs) ;
}


BOOL
AlertInsertLine (
                HWND hWnd,
                PLINE pLine
                )
{
    PALERT         pAlert ;
    PLINE          pLineEquivalent ;

    pAlert = AlertData (hWnd) ;
    pAlert->bModified = TRUE ;

    pLineEquivalent = FindEquivalentLine (pLine, pAlert->pLineFirst) ;
    // alert view is not permitted to have duplicate entries
    if (pLineEquivalent) {
        LINESTRUCT  tempLine ;

        tempLine = *pLineEquivalent ;

        // copy the new alert line attributes
        pLineEquivalent->Visual = pLine->Visual ;
        pLineEquivalent->bAlertOver = pLine->bAlertOver ;
        pLineEquivalent->eAlertValue = pLine->eAlertValue ;
        pLineEquivalent->bEveryTime = pLine->bEveryTime ;

        pLineEquivalent->lpszAlertProgram = pLine->lpszAlertProgram ;
        pLine->lpszAlertProgram = tempLine.lpszAlertProgram ;

        pLineEquivalent->hBrush = pLine->hBrush ;
        pLine->hBrush = tempLine.hBrush ;

        if (PlayingBackLog ()) {
            PlaybackAlert (hWnd, 0) ;
            WindowInvalidate (hWnd) ;
        }

        return (FALSE) ;
    }
    SystemAdd (&pAlert->pSystemFirst, pLine->lnSystemName, hWnd) ;

    LineAppend (&pAlert->pLineFirst, pLine) ;

    LegendAddItem (hWndAlertLegend, pLine) ;

    if (!bDelayAddAction) {
        SizeAlertComponents (hWndAlert) ;
        LegendSetSelection (hWndAlertLegend,
                            LegendNumItems (hWndAlertLegend) - 1) ;
    }

    if (!bDelayAddAction) {
        if (PlayingBackLog ()) {
            PlaybackAlert (hWnd, 0) ;
            WindowInvalidate (hWnd) ;
        }

        else if (pAlert->iStatus == iPMStatusClosed)
            SetAlertTimer (pAlert) ;
    }

    return (TRUE) ;
}


void
AlertAddAction ()
{
    PALERT           pAlert ;

    pAlert = AlertData (hWndAlert) ;

    SizeAlertComponents (hWndAlert) ;
    LegendSetSelection (hWndAlertLegend,
                        LegendNumItems (hWndAlertLegend) - 1) ;

    if (PlayingBackLog ()) {
        PlaybackAlert (hWndAlert, 0) ;
        WindowInvalidate (hWndAlert) ;
    } else if (pAlert->iStatus == iPMStatusClosed)
        SetAlertTimer (pAlert) ;
}

void
SizeAlertComponents (
                    HWND hDlg
                    )
{
    RECT           rectClient ;
    int            xWidth, yHeight ;
    int            yLegendHeight ;
    int            yLegendTextHeight ;
    int            yLogHeight ;
    int            yLogTextHeight ;
    int            yIntervalHeight ;
    int            xIntervalTextWidth ;
    int            StartYPos ;
    PALERT         pAlert = AlertData(hDlg) ;

    GetClientRect (hDlg, &rectClient) ;
    xWidth = rectClient.right ;
    yHeight = rectClient.bottom ;

    if (pAlert->bLegendOn) {
        yLegendHeight = LegendHeight (hWndAlertLegend, yHeight) ;
    } else {
        yLegendHeight = 0 ;
    }

    if (yHeight < 7 * xScrollWidth) {
        // too small, just display the alert logs and hide all other
        // items
        DialogShow (hDlg, IDD_ALERTLEGEND, FALSE) ;
        DialogShow (hDlg, IDD_ALERTLEGENDTEXT, FALSE) ;

        DialogShow (hDlg, IDD_ALERTINTERVAL, FALSE) ;
        DialogShow (hDlg, IDD_ALERTINTERVALTEXT, FALSE) ;

        yLogTextHeight = DialogHeight (hDlg, IDD_ALERTLOGTEXT) ;

        if (yHeight - yLogTextHeight > 3 * xScrollWidth) {
            DialogMove (hDlg, IDD_ALERTLOGTEXT,
                        xScrollWidth,
                        xScrollWidth / 2,
                        NOCHANGE, NOCHANGE) ;
            yLogTextHeight += xScrollWidth / 2 ;
            DialogShow (hDlg, IDD_ALERTLOGTEXT, TRUE) ;
        } else {
            yLogTextHeight = 0 ;
            DialogShow (hDlg, IDD_ALERTLOGTEXT, FALSE) ;
        }
        DialogMove (hDlg, IDD_ALERTLOG,
                    xScrollWidth,
                    xScrollWidth / 2 + yLogTextHeight,
                    xWidth - 2 * xScrollWidth,
                    yHeight - xScrollWidth) ;
    } else if (yHeight <= 2 * yLegendHeight + 5 * xScrollWidth) {
        if (pAlert->bLegendOn) {
            yLegendHeight = min (yLegendHeight,
                                 (yHeight - xScrollWidth) / 2) ;
        } else {
            yLegendHeight = 0 ;
        }


        yLogHeight = yHeight - yLegendHeight - xScrollWidth - 2 ;

        DialogShow (hDlg, IDD_ALERTLEGENDTEXT, FALSE) ;
        DialogShow (hDlg, IDD_ALERTINTERVAL, FALSE) ;
        DialogShow (hDlg, IDD_ALERTINTERVALTEXT, FALSE) ;

        yLogTextHeight = DialogHeight (hDlg, IDD_ALERTLOGTEXT) ;
        if (yLogHeight - yLogTextHeight > 3 * xScrollWidth) {
            DialogMove (hDlg, IDD_ALERTLOGTEXT,
                        xScrollWidth,
                        xScrollWidth / 2,
                        NOCHANGE, NOCHANGE) ;
            yLogTextHeight += xScrollWidth / 2 ;
            DialogShow (hDlg, IDD_ALERTLOGTEXT, TRUE) ;
        } else {
            yLogTextHeight = 0 ;
            DialogShow (hDlg, IDD_ALERTLOGTEXT, FALSE) ;
        }

        DialogMove (hDlg, IDD_ALERTLOG,
                    xScrollWidth,
                    xScrollWidth / 2 + yLogTextHeight,
                    xWidth - 2 * xScrollWidth,
                    yLogHeight - yLogTextHeight) ;

        DialogMove (hDlg, IDD_ALERTLEGEND,
                    xScrollWidth,
                    yLogHeight + xScrollWidth - 2,
                    xWidth - 2 * xScrollWidth,
                    yLegendHeight) ;

        DialogShow (hDlg, IDD_ALERTLEGEND, pAlert->bLegendOn ? TRUE : FALSE) ;
    } else {
        if (pAlert->bLegendOn) {
            DialogMove (hDlg, IDD_ALERTLEGEND,
                        xScrollWidth, yHeight - xScrollWidth / 2 - yLegendHeight,
                        xWidth - 2  * xScrollWidth,
                        yLegendHeight) ;
            DialogMove (hDlg, IDD_ALERTLEGENDTEXT,
                        xScrollWidth,
                        DialogYPos (hDlg, IDD_ALERTLEGEND) - xScrollWidth,
                        NOCHANGE, NOCHANGE) ;

            yLegendTextHeight = DialogYPos (hDlg, IDD_ALERTLEGENDTEXT) ;
        } else {
            yLegendTextHeight = yHeight - xScrollWidth / 2 - yLegendHeight ;
        }

        yLogTextHeight = DialogHeight (hDlg, IDD_ALERTLOGTEXT) ;
        yIntervalHeight = DialogHeight (hDlg, IDD_ALERTINTERVAL) ;
        yLogHeight = yLegendTextHeight - 4 * xScrollWidth ;

        if (yLogHeight < 2 * xScrollWidth) {
            yLogHeight = yLegendTextHeight - yLogTextHeight - xScrollWidth ;
        }
        DialogMove (hDlg, IDD_ALERTLOG,
                    xScrollWidth,
                    yLegendTextHeight - yLogHeight - xScrollWidth / 2,
                    xWidth - 2 * xScrollWidth,
                    yLogHeight) ;
        DialogMove (hDlg, IDD_ALERTLOGTEXT,
                    xScrollWidth,
                    yLogTextHeight = DialogYPos (hDlg, IDD_ALERTLOG) - xScrollWidth,
                    xWidth - 2 * xScrollWidth, NOCHANGE) ;

        DialogShow (hDlg, IDD_ALERTLEGEND, pAlert->bLegendOn ? TRUE : FALSE) ;
        DialogShow (hDlg, IDD_ALERTLEGENDTEXT, pAlert->bLegendOn ? TRUE : FALSE) ;
        DialogShow (hDlg, IDD_ALERTLOGTEXT, TRUE) ;


        if (yLogTextHeight >= yIntervalHeight + xScrollWidth) {
            StartYPos = (yLogTextHeight - yIntervalHeight) / 2 ;
            xIntervalTextWidth = DialogWidth (hDlg, IDD_ALERTINTERVALTEXT) ;
            DialogMove (hDlg, IDD_ALERTINTERVALTEXT,
                        xScrollWidth,
                        StartYPos + 1,
                        NOCHANGE, NOCHANGE) ;
            DialogMove (hDlg, IDD_ALERTINTERVAL,
                        xScrollWidth + xIntervalTextWidth + 4,
                        StartYPos,
                        NOCHANGE, NOCHANGE) ;

            DialogShow (hDlg, IDD_ALERTINTERVAL, TRUE) ;
            DialogShow (hDlg, IDD_ALERTINTERVALTEXT, TRUE) ;
        } else {
            DialogShow (hDlg, IDD_ALERTINTERVAL, FALSE) ;
            DialogShow (hDlg, IDD_ALERTINTERVALTEXT, FALSE) ;
        }
    }

    WindowInvalidate (hDlg) ;
}


INT
PlaybackAlert (
              HWND hWndAlert,
              HANDLE hExportFile
              )
{
    PALERT         pAlert ;
    LOGPOSITION    lp ;
    PLOGINDEX      pLogIndex ;
    SYSTEMTIME     SystemTime ;
    SYSTEMTIME     PreviousSystemTime ;
    BOOL           bFirstTime = TRUE ;
    INT            ErrCode = 0 ;
    int            iDisplayTics ;
    DWORD          TimeDiff ;

    pAlert = AlertData (hWndAlert) ;

    if (!pAlert->pLineFirst) {
        // nothing to check
        return ErrCode;
    }

    lp = PlaybackLog.StartIndexPos ;
    iDisplayTics = PlaybackLog.iSelectedTics;

    if (!hExportFile) {
        LBReset (pAlert->hAlertListBox) ;
        LBSetRedraw (pAlert->hAlertListBox, FALSE) ;
    }

    while (iDisplayTics) {

        pLogIndex = IndexFromPosition (&lp) ;
        if (pLogIndex)
            SystemTime = pLogIndex->SystemTime ;
        else
            GetLocalTime (&SystemTime) ;

        if (!bFirstTime) {
            // check if it is time to do the alert checking
            TimeDiff = (DWORD) SystemTimeDifference (&PreviousSystemTime,
                                                     &SystemTime, TRUE) ;
            if (TimeDiff * 1000 >= pAlert->iIntervalMSecs) {
                PlaybackLines (pAlert->pSystemFirst,
                               pAlert->pLineFirst,
                               lp.iPosition) ;
                ErrCode = CheckAlerts (hWndAlert,
                                       pAlert->hAlertListBox,
                                       &SystemTime,
                                       pAlert->pLineFirst,
                                       hExportFile,
                                       NULL) ;
                if (ErrCode) {
                    break ;
                }

                PreviousSystemTime = SystemTime ;
            }
        } else {
            // setup the data for the first time
            bFirstTime = FALSE ;
            PreviousSystemTime = SystemTime ;
            PlaybackLines (pAlert->pSystemFirst,
                           pAlert->pLineFirst,
                           lp.iPosition) ;
        }

        if (!NextIndexPosition (&lp, FALSE))
            break;

        iDisplayTics-- ;
    }

    if (!hExportFile) {
        LBSetRedraw (pAlert->hAlertListBox, TRUE) ;
    }

    return (ErrCode) ;
}


BOOL
AddAlert (
         HWND hWndParent
         )
{
    PALERT         pAlert ;
    PLINE          pCurrentLine ;

    pAlert = AlertData (hWndAlert) ;
    pCurrentLine = CurrentAlertLine (hWndAlert) ;

    return (AddLine (hWndParent,
                     &(pAlert->pSystemFirst),
                     &(pAlert->Visual),
                     pCurrentLine ? pCurrentLine->lnSystemName : NULL,
                     LineTypeAlert)) ;
}



BOOL
EditAlert (
          HWND hWndParent
          )
{
    PALERT        pAlert ;
    BOOL          bOK ;

    pAlert = AlertData (hWndAlert) ;

    bOK = EditLine (hWndParent,
                    &(pAlert->pSystemFirst),
                    CurrentAlertLine (hWndAlert),
                    LineTypeAlert) ;

    if (bOK && PlayingBackLog()) {
        //re-do the alert using the new condition
        PlaybackAlert (hWndAlert, 0) ;
        WindowInvalidate (hWndAlert) ;
    }

    return (bOK) ;
}

// RemoveLineFromAlertListBox is called when we are deleting a line
// while monitoring current activity.  We have to clear all the alert
// entries of this line because we are already doing this when
// playing back from log.  Moreover, we are using the line structure
// while drawing the item.
//
void
RemoveLineFromAlertListBox (
                           PALERT pAlert,
                           PLINE pLine
                           )
{
    int            iIndex ;
    int            iNumOfAlerts ;
    PALERTENTRY    pAlertEntry ;

    iNumOfAlerts = LBNumItems (pAlert->hAlertListBox) ;

    if (iNumOfAlerts == 0 || iNumOfAlerts == (int) LB_ERR) {
        return ;
    }

    LBSetRedraw (pAlert->hAlertListBox, FALSE) ;

    // go thru the listbox from bottom to top
    for (iIndex = iNumOfAlerts - 1; iIndex >= 0; iIndex-- ) {
        pAlertEntry = (PALERTENTRY) LBData (pAlert->hAlertListBox, iIndex) ;
        if (pAlertEntry != (PALERTENTRY) NULL && pAlertEntry) {
            if (pAlertEntry->pLine == pLine) {
                // remove it from the alert listbox.
                LBDelete (pAlert->hAlertListBox, iIndex) ;
            }
        }
    }
    LBSetRedraw (pAlert->hAlertListBox, TRUE) ;
}

BOOL
AlertDeleteLine (
                HWND hWndAlert,
                PLINE pLine
                )
/*
   Effect:        Delete the line pLine from the alerts associated with
                  window hWnd.  Return whether the line could be deleted.
*/
{
    PALERT         pAlert ;

    pAlert = AlertData (hWndAlert) ;
    pAlert->bModified = TRUE ;

    LineRemove (&pAlert->pLineFirst, pLine) ;
    LegendDeleteItem (hWndAlertLegend, pLine) ;

    if (!pAlert->pLineFirst) {
        // no need to collect data
        ClearAlertTimer (pAlert) ;

        // clear legend
        ClearLegend (hWndAlertLegend) ;

        // reset visual data
        pAlert->Visual.iColorIndex = 0 ;
        pAlert->Visual.iWidthIndex = 0 ;
        pAlert->Visual.iStyleIndex = 0 ;
    } else {
        BuildValueListForSystems (
                                 pAlert->pSystemFirst,
                                 pAlert->pLineFirst) ;
    }

    if (!PlayingBackLog()) {
        // delete any alert entry for this line
        RemoveLineFromAlertListBox (pAlert, pLine) ;
    }

    SizeAlertComponents (hWndAlert) ;

    if (PlayingBackLog ()) {
        if (pAlert->pLineFirst)
            PlaybackAlert (hWndAlert, 0) ;
        else {
            LBReset (pAlert->hAlertListBox) ;
        }

        WindowInvalidate (hWndAlert) ;
    }

    return (TRUE) ;
}


BOOL
ToggleAlertRefresh (
                   HWND hWnd
                   )
{
    PALERT        pAlert ;

    pAlert = AlertData (hWnd) ;

    if (pAlert->bManualRefresh)
        SetAlertTimer (pAlert) ;
    else
        ClearAlertTimer (pAlert) ;

    pAlert->bManualRefresh = !pAlert->bManualRefresh ;
    return (pAlert->bManualRefresh) ;
}

BOOL
AlertRefresh (
             HWND hWnd
             )
{
    PALERT        pAlert ;

    pAlert = AlertData (hWnd) ;

    return (pAlert->bManualRefresh) ;
}


void
AlertTimer (
           HWND hWnd,
           BOOL bForce
           )
/*
   Effect:        Perform all actions neccesary when an alert timer tick
                  or manual refresh occurs. In particular, get the current
                  values for each line in the alert window, and compare
                  the value against the alert conditions. For each alert
                  that may have occured, call SignalAlert.

   Called By:     AlertWndProc, in response to a WM_TIMER message.
                  OnCommand, in response to a IDM_REFRESHALERT notification.
*/
{
    PALERT         pAlert ;
    SYSTEMTIME     SystemTime ;

    pAlert = AlertData (hWnd) ;

    if (PlayingBackLog ())
        return ;

    if (bForce || !pAlert->bManualRefresh) {
        UpdateLines (&(pAlert->pSystemFirst), pAlert->pLineFirst) ;
        GetLocalTime (&SystemTime) ;
        CheckAlerts (hWnd,
                     pAlert->hAlertListBox,
                     &SystemTime,
                     pAlert->pLineFirst,
                     FALSE,
                     pAlert->pSystemFirst) ;
    }
}



BOOL
OpenAlertVer1 (
              HANDLE hFile,
              DISKALERT *pDiskAlert,
              PALERT pAlert,
              DWORD dwMinorVersion
              )
{
    bDelayAddAction = TRUE ;
    pAlert->Visual = pDiskAlert->Visual ;
    pAlert->iIntervalMSecs = pDiskAlert->dwIntervalSecs ;
    if (dwMinorVersion < 3) {
        pAlert->iIntervalMSecs *= 1000 ;
    }

    pAlert->bNetworkAlert = pDiskAlert->bNetworkAlert ;
    pAlert->bManualRefresh = pDiskAlert->bManualRefresh ;
    pAlert->bSwitchToAlert = pDiskAlert->bSwitchToAlert ;

    if (dwMinorVersion >= 2) {
        lstrcpy (pAlert->MessageName, pDiskAlert->MessageName) ;
    }

    pAlert->bLegendOn = TRUE ;

    if (dwMinorVersion >= 4) {
        if (dwMinorVersion == 4)
            pAlert->bEventLog = pDiskAlert->MiscOptions ;
        else {
            pAlert->bEventLog = pDiskAlert->MiscOptions & 0x01 ;
            pAlert->bLegendOn = pDiskAlert->MiscOptions & 0x02 ;
        }
    } else {
        pAlert->bEventLog = FALSE ;

        // have to move the file pointer back for old pma file
        FileSeekCurrent (hFile, -((int) (sizeof (pDiskAlert->MiscOptions)))) ;
    }

    if (pAlert->bNetworkAlert && pAlert->hNetAlertThread == 0) {
        AlertCreateThread (pAlert) ;
    }

    ReadLines (hFile, pDiskAlert->dwNumLines,
               &(pAlert->pSystemFirst), &(pAlert->pLineFirst), IDM_VIEWALERT) ;

    bDelayAddAction = FALSE ;

    AlertAddAction () ;

    return (TRUE) ;
}



BOOL
OpenAlert (
          HWND hWndAlert,
          HANDLE hFile,
          DWORD dwMajorVersion,
          DWORD dwMinorVersion,
          BOOL bAlertFile
          )
{
    PALERT         pAlert ;
    DISKALERT      DiskAlert ;
    BOOL           bSuccess = TRUE ;

    pAlert = AlertData (hWndAlert) ;
    if (!pAlert) {
        bSuccess = FALSE ;
        goto Exit0 ;
    }

    if (!FileRead (hFile, &DiskAlert, sizeof (DISKALERT))) {
        bSuccess = FALSE ;
        goto Exit0 ;
    }


    switch (dwMajorVersion) {
        case (1):

            SetHourglassCursor() ;

            ResetAlertView (hWndAlert) ;

            OpenAlertVer1 (hFile, &DiskAlert, pAlert, dwMinorVersion) ;

            // change to alert view if we are opening a
            // alert file
            if (bAlertFile && iPerfmonView != IDM_VIEWALERT) {
                SendMessage (hWndMain, WM_COMMAND, (LONG)IDM_VIEWALERT, 0L) ;
            }

            if (iPerfmonView == IDM_VIEWALERT) {
                SetPerfmonOptions (&DiskAlert.perfmonOptions) ;
            }
            UpdateAlertDisplay (hWndAlert) ;

            SetArrowCursor() ;

            break ;
    }

    Exit0:

    if (bAlertFile) {
        CloseHandle (hFile) ;
    }

    return (bSuccess) ;
}


void
ResetAlertView (
               HWND hWndAlert
               )
{
    PALERT         pAlert ;

    pAlert = AlertData (hWndAlert) ;
    if (!pAlert)
        return ;

    ChangeSaveFileName (NULL, IDM_VIEWALERT) ;

    if (pAlert->pSystemFirst) {
        ResetAlert (hWndAlert) ;
    }
}

void
ResetAlert (
           HWND hWndAlert
           )
{
    PALERT         pAlert ;


    pAlert = AlertData (hWndAlert) ;
    if (!pAlert)
        return ;

    ClearAlertTimer (pAlert) ;

    ClearLegend (hWndAlertLegend) ;
    if (pAlert->pLineFirst) {
        FreeLines (pAlert->pLineFirst) ;
        pAlert->pLineFirst = NULL ;
    }

    if (pAlert->pSystemFirst) {
        FreeSystems (pAlert->pSystemFirst) ;
        pAlert->pSystemFirst = NULL ;
    }

    pAlert->bModified = FALSE ;

    // reset visual data
    pAlert->Visual.iColorIndex = 0 ;
    pAlert->Visual.iWidthIndex = 0 ;
    pAlert->Visual.iStyleIndex = 0 ;

    iUnviewedAlerts = 0 ;
    if (iPerfmonView != IDM_VIEWALERT) {
        StatusUpdateIcons (hWndStatus) ;
    }

    // remove the horiz. scrollbar
    pAlert->xTextExtent = 0 ;
    LBSetHorzExtent (pAlert->hAlertListBox, pAlert->xTextExtent) ;

    LBReset (pAlert->hAlertListBox) ;
    SizeAlertComponents (hWndAlert) ;

    //   WindowInvalidate (hWndAlert) ;
}


void
ClearAlertDisplay (
                  HWND hWnd
                  )
{
    PALERT         pAlert ;

    pAlert = AlertData (hWnd) ;

    // remove the horiz. scrollbar
    pAlert->xTextExtent = 0 ;
    LBSetHorzExtent (pAlert->hAlertListBox, pAlert->xTextExtent) ;

    LBReset (pAlert->hAlertListBox) ;
}

BOOL
SaveAlert (
          HWND hWndAlert,
          HANDLE hInputFile,
          BOOL bGetFileName
          )
{
    PALERT         pAlert ;
    PLINE          pLine ;
    HANDLE         hFile = NULL;
    DISKALERT      DiskAlert ;
    PERFFILEHEADER FileHeader ;
    TCHAR          szFileName [256] ;
    BOOL           newFileName = FALSE ;

    if (hInputFile) {
        // use the input file handle if it is available
        // this is the case for saving workspace data
        hFile = hInputFile ;
    } else {
        if (pAlertFullFileName) {
            lstrcpy (szFileName, pAlertFullFileName) ;
        }
        if (bGetFileName || pAlertFullFileName == NULL) {
            if (!FileGetName (hWndAlert, IDS_ALERTFILE, szFileName)) {
                return (FALSE) ;
            }
            newFileName = TRUE ;
        }

        hFile = FileHandleCreate (szFileName) ;

        if (hFile && newFileName) {
            ChangeSaveFileName (szFileName, IDM_VIEWALERT) ;
        } else if (!hFile) {
            DlgErrorBox (hWndAlert, ERR_CANT_OPEN, szFileName) ;
        }
    }

    if (!hFile || hFile == INVALID_HANDLE_VALUE)
        return (FALSE) ;

    pAlert = AlertData (hWndAlert) ;
    if (!pAlert) {
        if (!hInputFile) {
            CloseHandle (hFile) ;
        }
        return (FALSE) ;
    }

    if (!hInputFile) {
        memset (&FileHeader, 0, sizeof (FileHeader)) ;
        lstrcpy (FileHeader.szSignature, szPerfAlertSignature) ;
        FileHeader.dwMajorVersion = AlertMajorVersion ;
        FileHeader.dwMinorVersion = AlertMinorVersion ;

        if (!FileWrite (hFile, &FileHeader, sizeof (PERFFILEHEADER))) {
            goto Exit0 ;
        }
    }

    DiskAlert.Visual = pAlert->Visual ;
    DiskAlert.dwIntervalSecs = pAlert->iIntervalMSecs ;
    DiskAlert.dwNumLines = NumLines (pAlert->pLineFirst) ;

    // fill in misc alert options
    DiskAlert.MiscOptions = 0 ;
    if (pAlert->bEventLog)
        DiskAlert.MiscOptions = 0x01 ;
    if (pAlert->bLegendOn)
        DiskAlert.MiscOptions += 0x02 ;

    //   DiskAlert.bEventLog = pAlert->bEventLog ;
    DiskAlert.bNetworkAlert = pAlert->bNetworkAlert ;
    DiskAlert.bSwitchToAlert = pAlert->bSwitchToAlert ;
    DiskAlert.bManualRefresh = pAlert->bManualRefresh ;
    DiskAlert.perfmonOptions = Options ;
    lstrcpy (DiskAlert.MessageName, pAlert->MessageName) ;
    if (!FileWrite (hFile, &DiskAlert, sizeof (DISKALERT))) {
        goto Exit0 ;
    }

    for (pLine = pAlert->pLineFirst; pLine; pLine = pLine->pLineNext) {
        if (!WriteLine (pLine, hFile)) {
            goto Exit0 ;
        }
    }

    if (!hInputFile) {
        CloseHandle (hFile) ;
    }

    return (TRUE) ;

    Exit0:
    if (!hInputFile) {
        CloseHandle (hFile) ;

        // only need to report error if not workspace
        DlgErrorBox (hWndAlert, ERR_SETTING_FILE, szFileName) ;
    }
    return (FALSE) ;
}


BOOL
ExportAlertEntry (
                 HANDLE hFile,
                 PALERTENTRY pAlertEntry
                 )
{
    TCHAR          UnicodeBuff [LongTextLen] ;
    CHAR           TempBuff [LongTextLen * 2] ;
    int            StringLen ;
    PLINE          pLine ;

    pLine = pAlertEntry->pLine ;

    // export the alert date-time

    strcpy (TempBuff, LineEndStr) ;
    StringLen = strlen (TempBuff) ;
    SystemTimeDateString (&(pAlertEntry->SystemTime), UnicodeBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;

    strcat (TempBuff, pDelimiter) ;
    SystemTimeTimeString (&(pAlertEntry->SystemTime), UnicodeBuff, FALSE) ;
    StringLen = strlen (TempBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
    strcat (TempBuff, pDelimiter) ;
    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        goto Exit0 ;
    }

    // export alert value and trigger condition

    if (pLine) {
        TSPRINTF (UnicodeBuff, szNumberFormat, pAlertEntry->eValue) ;
        ConvertDecimalPoint (UnicodeBuff) ;
        ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
        strcat (TempBuff, pDelimiter) ;
        StringLen = strlen (TempBuff) ;
        TempBuff[StringLen] = pAlertEntry->bOver ? '>' : '<' ;
        StringLen++ ;
        TSPRINTF (UnicodeBuff, szNumberFormat, pAlertEntry->eAlertValue) ;
        ConvertDecimalPoint (UnicodeBuff) ;
        ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
        strcat (TempBuff, pDelimiter) ;
    } else {
        strcpy (TempBuff, pDelimiter) ;
        strcat (TempBuff, pDelimiter) ;
    }
    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        goto Exit0 ;
    }

    // export Counter, Instance, & Parent names

    if (pLine) {
        ConvertUnicodeStr (TempBuff, pLine->lnCounterName) ;
    } else {
        // system up/down message is stored in lpszInstance.
        ConvertUnicodeStr (TempBuff, pAlertEntry->lpszInstance) ;
    }

    strcat (TempBuff, pDelimiter) ;
    StringLen = strlen (TempBuff) ;

    if (pLine && !(strempty(pAlertEntry->lpszInstance))) {
        ConvertUnicodeStr (&TempBuff[StringLen], pAlertEntry->lpszInstance) ;
    }

    strcat (TempBuff, pDelimiter) ;
    StringLen = strlen (TempBuff) ;

    if (pLine && !(strempty(pAlertEntry->lpszParent))) {
        ConvertUnicodeStr (&TempBuff[StringLen], pAlertEntry->lpszParent) ;
    }
    strcat (TempBuff, pDelimiter) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        goto Exit0 ;
    }

    // export object, & computer names
    TempBuff[0] = '\0' ;
    if (pLine) {
        ConvertUnicodeStr (TempBuff, pLine->lnObjectName) ;
    }
    strcat (TempBuff, pDelimiter) ;
    StringLen = strlen (TempBuff) ;

    if (pLine) {
        ConvertUnicodeStr (&TempBuff[StringLen], pLine->lnSystemName) ;
    } else {
        // system name for the system that is up or down is in
        // lpszParent.
        ConvertUnicodeStr (&TempBuff[StringLen], pAlertEntry->lpszParent) ;
    }

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        goto Exit0 ;
    }

    return (TRUE) ;

    Exit0:
    return (FALSE) ;
}

INT
ExportAlertLine (
                PLINE pLine,
                FLOAT eValue,
                SYSTEMTIME *pSystemTime,
                HANDLE hExportFile
                )
{
    ALERTENTRY     AlertEntry ;
    TCHAR          szInstance [256] ;
    TCHAR          szParent [256] ;
    INT            ErrCode = 0 ;

    AlertEntry.SystemTime = *pSystemTime ;
    AlertEntry.pLine= pLine ;
    AlertEntry.eValue = eValue ;
    AlertEntry.bOver = pLine->bAlertOver ;
    AlertEntry.eAlertValue = pLine->eAlertValue ;


    //=============================//
    // Determine Instance, Parent  //
    //=============================//

    // It's possible that there will be no instance, therefore
    // the lnInstanceName would be NULL.

    if (pLine->lnObject.NumInstances > 0) {
        // Test for the parent object instance name title index.
        // If there is one, it implies that there will be a valid
        // Parent Object Name and a valid Parent Object Instance Name.

        // If the Parent Object title index is 0 then
        // just display the instance name.

        lstrcpy (szInstance, pLine->lnInstanceName) ;
        if (pLine->lnInstanceDef.ParentObjectTitleIndex && pLine->lnPINName) {
            // Get the Parent Object Name.
            lstrcpy (szParent, pLine->lnPINName) ;
        } else {
            szParent[0] = TEXT(' ') ;
            szParent[1] = TEXT('\0') ;
        }
    } else {
        szInstance[0] = TEXT(' ') ;
        szInstance[1] = TEXT('\0') ;
        szParent[0] = TEXT(' ') ;
        szParent[1] = TEXT('\0') ;
    }

    AlertEntry.lpszInstance = szInstance ;
    AlertEntry.lpszParent = szParent ;

    if (!ExportAlertEntry (hExportFile, &AlertEntry)) {
        ErrCode = ERR_EXPORT_FILE ;
    }

    return ErrCode ;
}


BOOL
ExportAlertLabels (
                  HANDLE hFile
                  )
{
    TCHAR          UnicodeBuff [LongTextLen] ;
    CHAR           TempBuff [LongTextLen * 2] ;
    int            StringLen ;

    strcpy (TempBuff, LineEndStr) ;
    StringLen = strlen (TempBuff) ;
    StringLoad (IDS_EXPORT_DATE, UnicodeBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
    strcat (TempBuff, pDelimiter) ;
    StringLen = strlen (TempBuff) ;

    StringLoad (IDS_EXPORT_TIME, UnicodeBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
    strcat (TempBuff, pDelimiter) ;
    StringLen = strlen (TempBuff) ;

    StringLoad (IDS_LABELVALUE, UnicodeBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
    strcat (TempBuff, pDelimiter) ;
    StringLen = strlen (TempBuff) ;

    StringLoad (IDS_ALERT_TRIGGER, UnicodeBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
    strcat (TempBuff, pDelimiter) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        goto Exit0 ;
    }

    StringLoad (IDS_COUNTERNAME, UnicodeBuff) ;
    ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
    strcat (TempBuff, pDelimiter) ;
    StringLen = strlen (TempBuff) ;

    StringLoad (IDS_INSTNAME, UnicodeBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
    strcat (TempBuff, pDelimiter) ;
    StringLen = strlen (TempBuff) ;

    StringLoad (IDS_PARENT, UnicodeBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
    strcat (TempBuff, pDelimiter) ;
    StringLen = strlen (TempBuff) ;

    StringLoad (IDS_OBJNAME, UnicodeBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
    strcat (TempBuff, pDelimiter) ;
    StringLen = strlen (TempBuff) ;

    StringLoad (IDS_LABELSYSTEM, UnicodeBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        goto Exit0 ;
    }

    return (TRUE) ;

    Exit0:
    return (FALSE) ;
}


void
ExportAlert (void)
{
    PALERT         pAlert ;
    HANDLE         hFile = 0 ;
    HWND           hWndAlerts ;
    PALERTENTRY    pAlertEntry ;
    int            AlertTotal ;
    int            iIndex ;
    LPTSTR         pFileName = NULL ;
    INT            ErrCode = 0 ;

    if (!(pAlert = AlertData (hWndAlert))) {
        return ;
    }

    // see if there is anything to export..
    if (!(pAlert->pLineFirst)) {
        return ;
    }

    if (!(hWndAlerts = pAlert->hAlertListBox)) {
        return ;
    }

    AlertTotal = LBNumItems (hWndAlerts) ;
    if (AlertTotal == LB_ERR || AlertTotal == 0) {
        return ;
    }

    SetHourglassCursor() ;

    if (ErrCode = ExportFileOpen (hWndAlert, &hFile, pAlert->iIntervalMSecs, &pFileName)) {
        goto Exit0 ;
    }

    if (!pFileName) {
        // the case when user cancel.
        goto Exit0 ;
    }

    // export the column labels
    if (!ExportAlertLabels (hFile)) {
        ErrCode = ERR_EXPORT_FILE ;
        goto Exit0 ;
    }
    if (AlertTotal < ALERTLOGMAXITEMS || !PlayingBackLog()) {
        for (iIndex = 0 ; iIndex < AlertTotal ; iIndex++) {
            // get the alert data
            pAlertEntry = (PALERTENTRY) LBData (hWndAlerts, iIndex) ;

            if (!pAlertEntry || pAlertEntry == (PALERTENTRY)LB_ERR) {
                // skip this entry if we hit an error
                continue ;
            }

            // export the alert line
            if (!ExportAlertEntry (hFile, pAlertEntry)) {
                ErrCode = ERR_EXPORT_FILE ;
                break ;
            }
        }
    } else {
        // we are playingback log and that the listbox does not
        // contain all the alerts.  In this case, have to walk the
        // log file to re-generate all the alerts.
        ErrCode = PlaybackAlert (hWndAlert, hFile) ;
    }

    Exit0:

    SetArrowCursor() ;

    if (hFile) {
        CloseHandle (hFile) ;
    }

    if (pFileName) {
        if (ErrCode) {
            DlgErrorBox (hWndAlert, ErrCode, pFileName) ;
        }

        MemoryFree (pFileName) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\bookmark.c ===
#include "perfmon.h"
#include "bookmark.h"   // External declarations for this file

#include "log.h"        // for LogWriteBookmark
#include "utils.h"      // for WindowCenter

#include "pmhelpid.h"   // Help IDs



void static OnInitDialog (HDLG hDlg)
   {
   dwCurrentDlgID = HC_PM_idDlgOptionBookMark ;
   EditSetLimit (DialogControl (hDlg, IDD_BOOKMARKCOMMENT),
                 BookmarkCommentLen-1) ;
   WindowCenter (hDlg) ;
   }


void static OnOK (HDLG hDlg)
   {
   TCHAR          szComment [BookmarkCommentLen + 1] ;

   DialogText (hDlg, IDD_BOOKMARKCOMMENT, szComment) ;
   LogWriteBookmark (hWndLog, szComment) ;
   EndDialog (hDlg, 1) ;
   }


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


INT_PTR
FAR
WINAPI
BookmarkDlgProc (
                 HWND hDlg,
                 unsigned iMessage,
                 WPARAM wParam,
                 LPARAM lParam
                 )
{
   BOOL           bHandled ;

   bHandled = TRUE ;
   switch (iMessage)
      {
      case WM_INITDIALOG:
         OnInitDialog (hDlg) ;
         return  (TRUE) ;

      case WM_CLOSE:
         dwCurrentDlgID = 0 ;
         EndDialog (hDlg, 0) ;
         break ;

      case WM_COMMAND:
         switch(wParam)
            {
            case IDD_OK:
               dwCurrentDlgID = 0 ;
               OnOK (hDlg) ;
               break ;

            case IDD_CANCEL:
               dwCurrentDlgID = 0 ;
               EndDialog (hDlg, 0) ;
               break ;

            case IDD_BOOKMARKHELP:
               CallWinHelp (dwCurrentDlgID, hDlg) ;
               break ;

            default:
               bHandled = FALSE ;
               break;
            }
         break;


      default:
            bHandled = FALSE ;
         break ;
      }  // switch

   return (bHandled) ;
   }  // BookmarkDlgProc




BOOL
AddBookmark (
             HWND hWndParent
             )
{  // AddBookmark
   return (DialogBox (hInstance, idDlgAddBookmark, hWndParent, BookmarkDlgProc) ? TRUE : FALSE) ;
}  // AddBookmark


void
BookmarkAppend (
                PPBOOKMARK ppBookmarkFirst,
                PBOOKMARK pBookmarkNew
                )
{  // BookmarkAppend
   PBOOKMARK      pBookmark ;

   if (!*ppBookmarkFirst)
      *ppBookmarkFirst = pBookmarkNew ;
   else
      {  // else
      for (pBookmark = *ppBookmarkFirst ;
           pBookmark->pBookmarkNext ;
           pBookmark = pBookmark->pBookmarkNext)
         /* nothing */ ;
      pBookmark->pBookmarkNext = pBookmarkNew ;
      }  // else
}  // BookmarkAppend
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\bookmark.h ===
BOOL AddBookmark (HWND hWndParent) ;

void BookmarkAppend (PPBOOKMARK ppBookmarkFirst, 
                     PBOOKMARK pBookmarkNew) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\chosecom.c ===
/*****************************************************************************
 *
 *  ChoseCom.c - This module handles the Dialog user interactions for the
 *    choose computers within a log file
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 ****************************************************************************/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "perfmon.h"       // basic defns, windows.h

#include "dlgs.h"          // common dialog control IDs
#include "playback.h"      // for PlayingBackLog
#include "pmhelpid.h"      // Help IDs
#include "utils.h"         // for CallWinHelp

static LPTSTR  lpChooseComputerText ;
static DWORD   TextLength ;

//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void
static
OnInitDialog (
              HDLG hDlg
              )
{
    // build the listbox of computers wintin the log file
    BuildLogComputerList (hDlg, IDD_CHOOSECOMPUTERLISTBOX) ;

    // set the scroll limit on the edit box
    EditSetLimit (GetDlgItem(hDlg, IDD_CHOOSECOMPUTERNAME), TextLength-1) ;

    dwCurrentDlgID = HC_PM_idDlgLogComputerList ;

    WindowCenter (hDlg) ;
}

void
static
OnOK (
      HDLG hDlg
      )
{
    GetDlgItemText (hDlg,
                    IDD_CHOOSECOMPUTERNAME,
                    lpChooseComputerText,
                    TextLength-1) ;

}

void
OnComputerSelectionChanged (
                            HWND hDlg
                            )
{
    TCHAR localComputerName [MAX_PATH + 3] ;
    INT_PTR SelectedIndex ;
    HWND  hWndLB = GetDlgItem (hDlg, IDD_CHOOSECOMPUTERLISTBOX) ;

    // get the listbox selection and put it in the editbox
    SelectedIndex = LBSelection (hWndLB) ;
    if (SelectedIndex != LB_ERR) {
        localComputerName[0] = TEXT('\0') ;
        if (LBString (hWndLB, SelectedIndex, localComputerName) != LB_ERR &&
            localComputerName[0]) {
            SetDlgItemText (hDlg, IDD_CHOOSECOMPUTERNAME, localComputerName) ;
        }
    }
}

INT_PTR
ChooseLogComputerDlgProc(
                         HWND hDlg,
                         UINT msg,
                         WPARAM wParam,
                         LPARAM lParam
                         )
{
    switch (msg) {
        case WM_INITDIALOG:
            OnInitDialog (hDlg) ;
            break ;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    OnOK (hDlg) ;
                    dwCurrentDlgID = 0 ;
                    EndDialog (hDlg, TRUE) ;
                    return (TRUE) ;
                    break ;

                case IDCANCEL:
                    dwCurrentDlgID = 0 ;
                    EndDialog (hDlg, FALSE) ;
                    return (TRUE) ;

                case ID_HELP:
                    CallWinHelp (dwCurrentDlgID, hDlg) ;
                    break ;

                case IDD_CHOOSECOMPUTERLISTBOX:
                    if (HIWORD (wParam) == LBN_SELCHANGE)
                        OnComputerSelectionChanged (hDlg) ;
                    break ;

                default:
                    break;
            }
            break ;

        default:
            break ;
    }

    return (FALSE) ;
}


BOOL
GetLogFileComputer (
                    HWND hWndParent,
                    LPTSTR lpComputerName,
                    DWORD BufferSize
                    )
{
    BOOL  bSuccess ;
    DWORD LocalDlgID = dwCurrentDlgID ;

    // initialize some globals
    *lpComputerName = TEXT('\0') ;
    lpChooseComputerText = lpComputerName ;
    TextLength = BufferSize ;

    bSuccess = DialogBox (hInstance, idDlgChooseComputer, hWndParent, ChooseLogComputerDlgProc) ? TRUE : FALSE;

    dwCurrentDlgID = LocalDlgID ;

    if (*lpComputerName == '\0') {
        bSuccess = FALSE ;
    }

    return (bSuccess) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\command.c ===
/*
==============================================================================

  Application:

            Microsoft Windows NT (TM) Performance Monitor

  File:
            Command.c -- PerfmonCommand routine and helpers.

            This file contains the PerfmonCommand routine, which handles
            all of the user's menu selections.

  Copyright 1992-1993, Microsoft Corporation. All Rights Reserved.
            Microsoft Confidential.
==============================================================================
*/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "stdio.h"
#include "perfmon.h"
#include "command.h"    // External declarations for this file
#include <shellapi.h>   // for ShellAbout

#include "addlog.h"     // for AddLog
#include "alert.h"      // for CurrentAlertLine
#include "bookmark.h"   // for AddBookmark
#include "cderr.h"
#include "datasrc.h"    // for DisplayDataSourceOptions
#include "dialogs.h"
#include "dispoptn.h"   // for DisplayDisplayOptions
#include "fileopen.h"   // for FileOpen
#include "grafdata.h"   // for ChartDeleteLine ClearGraphDisplay
#include "grafdisp.h"   // for ToggleGraphRefresh
#include "graph.h"      // for SizeGraphComponents
#include "init.h"       // for PerfmonClose
#include "legend.h"
#include "log.h"        // for LogTimer
#include "logoptns.h"
#include "playback.h"
#include "report.h"     // for CurrentReportItem
#include "rptoptns.h"   // for DisplayReportOptions
#include "status.h"     // for StatusUpdateIcons
#include "timefrm.h"    // for SetTimeframe
#include "toolbar.h"    // for ToolbarDepressButton
#include "utils.h"
#include "perfmops.h"   // for SaveWorkspace

int static deltax ;
int static deltay ;

#define ABOUT_TIMER_ID 10

INT_PTR
FAR
WINAPI
AboutDlgProc (
             HWND hDlg,
             UINT iMessage,
             WPARAM wParam,
             LPARAM lParam
             )
{
    BOOL           bHandled ;

    bHandled = TRUE ;
    switch (iMessage) {
        case WM_INITDIALOG:
            deltax = 0 ;
            deltay = 0 ;
            dwCurrentDlgID = 0 ;
            SetTimer(hDlg, ABOUT_TIMER_ID, 1000, NULL) ;
            WindowCenter (hDlg) ;
            return (TRUE) ;

        case WM_TIMER:
            deltax += 2 ;
            if (deltax > 60)
                deltax = 0 ;

            deltay += 5 ;
            if (deltay > 60)
                deltay = 0 ;

            WindowInvalidate (DialogControl (hDlg, 524)) ;
            break ;

        case WM_DRAWITEM:
            {
                int xPos, yPos ;
                LPDRAWITEMSTRUCT lpItem ;

                lpItem = (LPDRAWITEMSTRUCT) lParam ;
                xPos = lpItem->rcItem.left + deltax ;
                yPos = lpItem->rcItem.top + deltay ;
                DrawIcon (lpItem->hDC, xPos, yPos, hIcon) ;
            }
            break ;

        case WM_CLOSE:
            dwCurrentDlgID = 0 ;
            KillTimer (hDlg, ABOUT_TIMER_ID) ;
            EndDialog (hDlg, 1) ;
            break ;

        case WM_COMMAND:
            switch (wParam) {
                case IDD_OK:
                    dwCurrentDlgID = 0 ;
                    EndDialog (hDlg, 1) ;
                    break ;

                default:
                    bHandled = FALSE ;
                    break;
            }
            break;

        default:
            bHandled = FALSE ;
            break ;
    }

    return (bHandled) ;
}


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


void
ChangeView (
           HWND hWnd,
           int iNewView
           )
{
    HMENU hMenu = GetMenu (hWnd) ;
    BOOL  bViewChart, bViewAlert, bViewLog, bViewReport ;

#ifdef ADVANCED_PERFMON
    iPerfmonView = iNewView ;
    bViewChart = bViewAlert = bViewLog = bViewReport = FALSE;

    switch (iNewView) {
        case IDM_VIEWCHART:
            bViewChart = TRUE ;
            break ;

        case IDM_VIEWALERT:
            bViewAlert = TRUE ;
            break ;

        case IDM_VIEWLOG:
            bViewLog = TRUE ;
            break ;

        case IDM_VIEWREPORT:
            bViewReport = TRUE ;
            break ;
    }

    WindowShow (hWndGraph, bViewChart) ;
    WindowShow (hWndAlert, bViewAlert) ;
    WindowShow (hWndLog, bViewLog) ;
    WindowShow (hWndReport, bViewReport) ;

    // set focus on the Legend window
    if (iPerfmonView == IDM_VIEWCHART) {
        SetFocus (hWndGraphLegend) ;
    } else if (iPerfmonView == IDM_VIEWALERT) {
        SetFocus (hWndAlertLegend) ;
    } else if (iPerfmonView == IDM_VIEWLOG) {
        SetFocus (hWndLogEntries) ;
    } else if (iPerfmonView == IDM_VIEWREPORT) {
        SetFocus (hWndReport) ;
    }

    if (hMenu) {
        MenuCheck (hMenu, IDM_VIEWCHART, bViewChart) ;
        MenuCheck (hMenu, IDM_VIEWALERT, bViewAlert) ;
        MenuCheck (hMenu, IDM_VIEWLOG, bViewLog) ;
        MenuCheck (hMenu, IDM_VIEWREPORT, bViewReport) ;

        // show the Title bar
        ShowPerfmonWindowText () ;
    }

    ToolbarDepressButton (hWndToolbar, ChartTool, bViewChart) ;
    ToolbarDepressButton (hWndToolbar, AlertTool, bViewAlert) ;
    ToolbarDepressButton (hWndToolbar, LogTool, bViewLog) ;
    ToolbarDepressButton (hWndToolbar, ReportTool, bViewReport) ;
#else
    // only Chart view in Perfmon Lite
    iPerfmonView = IDM_VIEWCHART ;
    WindowShow (hWndGraph, TRUE) ;
#endif

    DrawMenuBar(hWnd) ;
    StatusLineReady (hWndStatus) ;
}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void
ViewChart (
          HWND hWnd
          )
{
    if (Options.bMenubar)
        SetMenu (hWnd, hMenuChart) ;
    ChangeView (hWnd, IDM_VIEWCHART) ;
}


void
ViewAlert (
          HWND hWnd
          )
{
    iUnviewedAlerts = 0 ;
    StatusUpdateIcons (hWndStatus) ;
    if (Options.bMenubar)
        SetMenu (hWnd, hMenuAlert) ;
    ChangeView (hWnd, IDM_VIEWALERT) ;
}


void
ViewLog (
         HWND hWnd
         )
{
    if (Options.bMenubar)
        SetMenu (hWnd, hMenuLog) ;
    ChangeView (hWnd, IDM_VIEWLOG) ;
}


void
ViewReport (
            HWND hWnd
            )
{
    if (Options.bMenubar)
        SetMenu (hWnd, hMenuReport) ;
    ChangeView (hWnd, IDM_VIEWREPORT) ;
}


#ifdef KEEP_MANUALREFRESH
void
ToggleRefresh (
               HWND hWnd
               )
{
    BOOL           bRefresh ;

    switch (iPerfmonView) {
        case IDM_VIEWCHART:
            bRefresh = ToggleGraphRefresh (hWndGraph) ;
            break ;

        case IDM_VIEWALERT:
            bRefresh = ToggleAlertRefresh (hWndAlert) ;
            break ;

        case IDM_VIEWLOG:
            bRefresh = ToggleLogRefresh (hWndLog) ;
            break ;

        case IDM_VIEWREPORT:
            bRefresh = ToggleReportRefresh (hWndReport) ;
            break ;
    }

    MenuCheck (GetMenu (hWnd), IDM_OPTIONSMANUALREFRESH, bRefresh) ;
}
#endif


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


BOOL
PerfmonCommand (
                HWND hWnd,
                     WPARAM wParam,
                     LPARAM lParam
                     )
/*
   Effect:        Respond to the user's menu selection, found in wParam.
                  In particular, branch to the appropriate OnXXX function
                  to perform the action associated with each command.

   Called By:     MainWndProc (perfmon.c), in response to a WM_COMMAND
                  message.
*/
{
    PLINESTRUCT    pLine ;
    BOOL           bPrepareMenu = TRUE ;

    switch (LOWORD (wParam)) {

        //=============================//
        // Toolbar Commands            //
        //=============================//

        case IDM_TOOLBARADD:
            bPrepareMenu = FALSE ;

            switch (iPerfmonView) {
                case IDM_VIEWCHART:
                    SendMessage (hWnd, WM_COMMAND, IDM_EDITADDCHART, lParam) ;
                    break ;

                case IDM_VIEWALERT:
                    SendMessage (hWnd, WM_COMMAND, IDM_EDITADDALERT, lParam) ;
                    break ;

                case IDM_VIEWLOG:
                    SendMessage (hWnd, WM_COMMAND, IDM_EDITADDLOG, lParam) ;
                    break ;

                case IDM_VIEWREPORT:
                    SendMessage (hWnd, WM_COMMAND, IDM_EDITADDREPORT, lParam) ;
                    break ;
            }
            break ;


        case IDM_TOOLBARMODIFY:
            bPrepareMenu = FALSE ;

            switch (iPerfmonView) {
                case IDM_VIEWCHART:
                    SendMessage (hWnd, WM_COMMAND, IDM_EDITMODIFYCHART, lParam) ;
                    break ;

                case IDM_VIEWALERT:
                    SendMessage (hWnd, WM_COMMAND, IDM_EDITMODIFYALERT, lParam) ;
                    break ;

                case IDM_VIEWREPORT:
                    SendMessage (hWnd, WM_COMMAND, IDM_EDITMODIFYREPORT, lParam) ;
                    break ;
            }
            break ;


        case IDM_TOOLBARDELETE:
            bPrepareMenu = FALSE ;

            switch (iPerfmonView) {
                case IDM_VIEWCHART:
                    SendMessage (hWnd, WM_COMMAND, IDM_EDITDELETECHART, lParam) ;
                    break ;

                case IDM_VIEWALERT:
                    SendMessage (hWnd, WM_COMMAND, IDM_EDITDELETEALERT, lParam) ;
                    break ;

                case IDM_VIEWLOG:
                    SendMessage (hWnd, WM_COMMAND, IDM_EDITDELETELOG, lParam) ;
                    break ;

                case IDM_VIEWREPORT:
                    SendMessage (hWnd, WM_COMMAND, IDM_EDITDELETEREPORT, lParam) ;
                    break ;
            }
            break ;


        case IDM_TOOLBARREFRESH:
            bPrepareMenu = FALSE ;

            switch (iPerfmonView) {
                case IDM_VIEWCHART:
                    SendMessage (hWnd, WM_COMMAND, IDM_OPTIONSREFRESHNOWCHART, lParam) ;
                    break ;

                case IDM_VIEWALERT:
                    SendMessage (hWnd, WM_COMMAND, IDM_OPTIONSREFRESHNOWALERT, lParam) ;
                    break ;

                case IDM_VIEWLOG:
                    SendMessage (hWnd, WM_COMMAND, IDM_OPTIONSREFRESHNOWLOG, lParam) ;
                    break ;

                case IDM_VIEWREPORT:
                    SendMessage (hWnd, WM_COMMAND, IDM_OPTIONSREFRESHNOWREPORT, lParam) ;
                    break ;
            }
            break ;


        case IDM_TOOLBAROPTIONS:
            bPrepareMenu = FALSE ;

            switch (iPerfmonView) {
                case IDM_VIEWCHART:
                    SendMessage (hWnd, WM_COMMAND, IDM_OPTIONSCHART, lParam) ;
                    break ;

                case IDM_VIEWALERT:
                    SendMessage (hWnd, WM_COMMAND, IDM_OPTIONSALERT, lParam) ;
                    break ;

                case IDM_VIEWLOG:
                    SendMessage (hWnd, WM_COMMAND, IDM_OPTIONSLOG, lParam) ;
                    break ;

                case IDM_VIEWREPORT:
                    SendMessage (hWnd, WM_COMMAND, IDM_OPTIONSREPORT, lParam) ;
                    break ;
            }
            break ;


            //=============================//
            // "File" Commands             //
            //=============================//


        case IDM_FILENEWCHART:
            //         if (QuerySaveChart (hWnd, pGraphs))
            ResetGraphView (hWndGraph) ;
            break ;


        case IDM_FILENEWALERT:
            //         if (QuerySaveAlert (hWnd, hWndAlert))
            ResetAlertView (hWndAlert) ;
            break ;

        case IDM_FILENEWLOG:
            ResetLogView (hWndLog) ;
            break ;

        case IDM_FILENEWREPORT:
            ResetReportView (hWndReport) ;
            break ;

        case IDM_FILEOPENCHART:
            FileOpen (hWndGraph, IDS_CHARTFILE, NULL) ;
            break ;

        case IDM_FILEOPENALERT:
            FileOpen (hWndAlert, IDS_ALERTFILE, NULL) ;
            break ;

        case IDM_FILEOPENLOG:
            FileOpen (hWndLog, IDS_LOGFILE, NULL) ;
            break ;

        case IDM_FILEOPENREPORT:
            FileOpen (hWndReport, IDS_REPORTFILE, NULL) ;
            break ;

        case IDM_FILESAVECHART:
        case IDM_FILESAVEASCHART:
            bPrepareMenu = FALSE ;
            SaveChart (hWndGraph, 0,
                       (LOWORD (wParam) == IDM_FILESAVEASCHART) ? TRUE : FALSE) ;
            break;

        case IDM_FILESAVEALERT:
        case IDM_FILESAVEASALERT:
            bPrepareMenu = FALSE ;
            SaveAlert (hWndAlert, 0,
                       (LOWORD (wParam) == IDM_FILESAVEASALERT) ? TRUE : FALSE) ;
            break ;

        case IDM_FILESAVELOG:
        case IDM_FILESAVEASLOG:
            bPrepareMenu = FALSE ;
            SaveLog (hWndLog, 0,
                     (LOWORD (wParam) == IDM_FILESAVEASLOG) ? TRUE : FALSE) ;
            break ;

        case IDM_FILESAVEREPORT:
        case IDM_FILESAVEASREPORT:
            bPrepareMenu = FALSE ;
            SaveReport (hWndReport, 0,
                        (LOWORD (wParam) == IDM_FILESAVEASREPORT) ? TRUE : FALSE) ;
            break ;


        case IDM_FILESAVEWORKSPACE:
            bPrepareMenu = FALSE ;
            SaveWorkspace () ;
            break ;

        case IDM_FILEEXPORTCHART:
            bPrepareMenu = FALSE ;
            ExportChart () ;
            break ;

        case IDM_FILEEXPORTALERT:
            bPrepareMenu = FALSE ;
            ExportAlert () ;
            break ;

        case IDM_FILEEXPORTLOG:
            bPrepareMenu = FALSE ;
            ExportLog () ;
            break ;

        case IDM_FILEEXPORTREPORT:
            bPrepareMenu = FALSE ;
            ExportReport () ;
            break ;


#ifdef KEEP_PRINT
        case IDM_FILEPRINTCHART:
            PrintChart (hWnd, pGraphs) ;
            break ;


        case IDM_FILEPRINTREPORT:
            PrintReport (hWnd, hWndReport) ;
            break ;
#endif

        case IDM_FILEEXIT:
            PerfmonClose (hWnd) ;
            bPrepareMenu = FALSE ;
            break ;


            //=============================//
            // "Edit" Commands             //
            //=============================//


        case IDM_EDITADDCHART:
            AddChart (hWnd) ;
            break;

        case IDM_EDITADDALERT:
            AddAlert (hWnd) ;
            break;

        case IDM_EDITADDLOG:
            AddLog (hWnd) ;
            break ;

        case IDM_EDITADDREPORT:
            AddReport (hWnd) ;
            break ;

        case IDM_EDITCLEARCHART :
            ClearGraphDisplay (pGraphs) ;
            break ;

        case IDM_EDITCLEARALERT:
            ClearAlertDisplay (hWndAlert) ;
            break ;

        case IDM_EDITCLEARREPORT:
            ClearReportDisplay (hWndReport) ;
            break ;

        case IDM_EDITDELETECHART:
            pLine = CurrentGraphLine (hWndGraph) ;
            if (pLine)
                ChartDeleteLine(pGraphs, pLine) ;
            break ;

        case IDM_EDITDELETEALERT:
            pLine = CurrentAlertLine (hWndAlert) ;
            if (pLine)
                AlertDeleteLine (hWndAlert, pLine) ;
            break ;

        case IDM_EDITDELETELOG:
            LogDeleteEntry (hWndLog) ;
            break ;

        case IDM_EDITDELETEREPORT:
            if (CurrentReportItem (hWndReport))
                ReportDeleteItem (hWndReport) ;
            break ;

        case IDM_EDITMODIFYCHART:
            EditChart (hWnd) ;
            break ;

        case IDM_EDITMODIFYALERT:
            EditAlert (hWnd) ;
            break ;

        case IDM_EDITTIMEWINDOW:
            if (PlayingBackLog()) {
                SetTimeframe (hWnd) ;
            }
            break ;


            //=============================//
            // "View" Commands             //
            //=============================//


        case IDM_VIEWCHART:
            if (iPerfmonView != IDM_VIEWCHART) {
                ViewChart (hWnd) ;
            } else {
                bPrepareMenu = FALSE ;
                ToolbarDepressButton (hWndToolbar, ChartTool, TRUE) ;
            }
            break ;

        case IDM_VIEWALERT:
            if (iPerfmonView != IDM_VIEWALERT) {
                ViewAlert (hWnd) ;
            } else {
                bPrepareMenu = FALSE ;
                ToolbarDepressButton (hWndToolbar, AlertTool, TRUE) ;
            }
            break ;

        case IDM_VIEWLOG:
            if (iPerfmonView != IDM_VIEWLOG) {
                ViewLog (hWnd) ;
            } else {
                bPrepareMenu = FALSE ;
                ToolbarDepressButton (hWndToolbar, LogTool, TRUE) ;
            }
            break ;

        case IDM_VIEWREPORT:
            if (iPerfmonView != IDM_VIEWREPORT) {
                ViewReport (hWnd) ;
            } else {
                bPrepareMenu = FALSE ;
                ToolbarDepressButton (hWndToolbar, ReportTool, TRUE) ;
            }
            break ;


            //=============================//
            // "Options" Commands          //
            //=============================//


        case IDM_OPTIONSCHART:
            DialogBox(hInstance, idDlgChartOptions, hWnd, GraphOptionDlg);
            break;

        case IDM_OPTIONSALERT:
            DisplayAlertOptions (hWnd, hWndAlert) ;
            break;

        case IDM_OPTIONSLOG:
            DisplayLogOptions (hWnd, hWndLog) ;
            break ;

        case IDM_OPTIONSREPORT:
            if (!PlayingBackLog())
                DisplayReportOptions (hWnd, hWndReport) ;
            break ;

        case IDM_OPTIONSBOOKMARK:
            bPrepareMenu = FALSE ;
            AddBookmark (hWnd) ;
            break;

#ifdef KEEP_DISPLAY_OPTION
        case IDM_OPTIONSDISPLAY:
            DisplayDisplayOptions (hWnd) ;
            break ;
#endif

        case IDM_OPTIONSDISPLAYMENU:
            // ShowPerfmonMenu will update Options.bMenubar..
            ShowPerfmonMenu (!Options.bMenubar) ;
            break ;

        case IDM_OPTIONSDISPLAYTOOL:
            Options.bToolbar = !Options.bToolbar ;
            SizePerfmonComponents () ;
            break ;

        case IDM_OPTIONSDISPLAYSTATUS:
            Options.bStatusbar = !Options.bStatusbar ;
            SizePerfmonComponents () ;
            break ;

        case IDM_OPTIONSDISPLAYONTOP:
            Options.bAlwaysOnTop = !Options.bAlwaysOnTop ;
            WindowSetTopmost (hWndMain, Options.bAlwaysOnTop) ;
            break ;

        case IDM_OPTIONSDATASOURCE:
            DisplayDataSourceOptions (hWnd) ;
            break ;

#ifdef KEEP_MANUALREFRESH
        case IDM_OPTIONSMANUALREFRESH:
            bPrepareMenu = FALSE ;
            if (!PlayingBackLog())
                ToggleRefresh (hWnd) ;
            break ;
#endif

        case IDM_OPTIONSREFRESHNOWCHART:
            bPrepareMenu = FALSE ;
            if (!PlayingBackLog())
                GraphTimer (hWndGraph, TRUE) ;
            break ;

        case IDM_OPTIONSREFRESHNOWALERT:
            bPrepareMenu = FALSE ;
            if (!PlayingBackLog())
                AlertTimer (hWndAlert, TRUE) ;
            break ;

        case IDM_OPTIONSREFRESHNOWLOG:
            bPrepareMenu = FALSE ;
            if (!PlayingBackLog())
                LogTimer (hWndLog, TRUE) ;
            break ;

        case IDM_OPTIONSREFRESHNOWREPORT:
            bPrepareMenu = FALSE ;
            if (!PlayingBackLog())
                ReportTimer (hWndReport, TRUE) ;
            break ;

        case IDM_OPTIONSLEGENDONOFF:
            bPrepareMenu = FALSE ;
            if (iPerfmonView == IDM_VIEWCHART) {
                pGraphs->gOptions.bLegendChecked =
                !pGraphs->gOptions.bLegendChecked ;
                SizeGraphComponents (hWndGraph) ;
                WindowInvalidate (hWndGraph) ;
            } else if (iPerfmonView == IDM_VIEWALERT) {
                PALERT pAlert = AlertData (hWnd) ;

                pAlert->bLegendOn = !pAlert->bLegendOn ;

                SizeAlertComponents (hWndAlert) ;
                WindowInvalidate (hWndAlert) ;
            }
            break ;

            //=============================//
            // "Help" Commands             //
            //=============================//


        case IDM_HELPABOUT:
            {
                TCHAR          szApplication [WindowCaptionLen] ;

                bPrepareMenu = FALSE ;

                if (GetKeyState(VK_SHIFT) < 0 && GetKeyState(VK_CONTROL) < 0) {
                    DialogBox (hInstance, idDlgAbout, hWndMain, AboutDlgProc) ;
                } else {
                    StringLoad (IDS_APPNAME, szApplication) ;
                    ShellAbout (hWnd, szApplication, NULL, hIcon) ;
                }
            }
            break ;

            //======================================//
            //  Generic messages from ACCELERATORS  //
            //======================================//
        case IDM_FILEOPENFILE:
            bPrepareMenu = FALSE ;
            switch (iPerfmonView) {
                case IDM_VIEWCHART:
                    SendMessage (hWnd, WM_COMMAND, IDM_FILEOPENCHART, lParam) ;
                    break ;

                case IDM_VIEWALERT:
                    SendMessage (hWnd, WM_COMMAND, IDM_FILEOPENALERT, lParam) ;
                    break ;

                case IDM_VIEWLOG:
                    SendMessage (hWnd, WM_COMMAND, IDM_FILEOPENLOG, lParam) ;
                    break ;

                case IDM_VIEWREPORT:
                    SendMessage (hWnd, WM_COMMAND, IDM_FILEOPENREPORT, lParam) ;
                    break ;
            }
            break ;

        case IDM_FILESAVEFILE:
            bPrepareMenu = FALSE ;
            switch (iPerfmonView) {
                case IDM_VIEWCHART:
                    SendMessage (hWnd, WM_COMMAND, IDM_FILESAVECHART, lParam) ;
                    break ;

                case IDM_VIEWALERT:
                    SendMessage (hWnd, WM_COMMAND, IDM_FILESAVEALERT, lParam) ;
                    break ;

                case IDM_VIEWLOG:
                    SendMessage (hWnd, WM_COMMAND, IDM_FILESAVELOG, lParam) ;
                    break ;

                case IDM_VIEWREPORT:
                    SendMessage (hWnd, WM_COMMAND, IDM_FILESAVEREPORT, lParam) ;
                    break ;
            }
            break ;

        case IDM_FILESAVEASFILE:
            bPrepareMenu = FALSE ;
            switch (iPerfmonView) {
                case IDM_VIEWCHART:
                    SendMessage (hWnd, WM_COMMAND, IDM_FILESAVEASCHART, lParam) ;
                    break ;

                case IDM_VIEWALERT:
                    SendMessage (hWnd, WM_COMMAND, IDM_FILESAVEASALERT, lParam) ;
                    break ;

                case IDM_VIEWLOG:
                    SendMessage (hWnd, WM_COMMAND, IDM_FILESAVEASLOG, lParam) ;
                    break ;

                case IDM_VIEWREPORT:
                    SendMessage (hWnd, WM_COMMAND, IDM_FILESAVEASREPORT, lParam) ;
                    break ;
            }
            break ;

        case IDM_CHARTHIGHLIGHTON:
            bPrepareMenu = FALSE ;
            if (iPerfmonView == IDM_VIEWCHART) {
                ChartHighlight () ;
            }
            break ;

        case IDM_TOOLBARID:
            // msg from the toolbar control
            bPrepareMenu = FALSE ;
            OnToolbarHit (wParam, lParam) ;
            break ;

        case IDM_HELPCONTENTS:
            {
                TCHAR NullStr [2] ;

                NullStr[0] = TEXT('\0') ;
                bPrepareMenu = FALSE ;
                if (*pszHelpFile != 0) {
                    WinHelp (hWndMain, pszHelpFile, HELP_FINDER, (DWORD_PTR)(NullStr)) ;
                } else {
                    DlgErrorBox (hWnd, ERR_HELP_NOT_AVAILABLE);
                }
            }
            break ;

        case IDM_HELPSEARCH:
            {
                TCHAR NullStr [2] ;

                NullStr[0] = TEXT('\0') ;
                bPrepareMenu = FALSE ;
                if (*pszHelpFile != 0) {
                    WinHelp (hWndMain, pszHelpFile, HELP_PARTIALKEY, (DWORD_PTR)(NullStr)) ;
                } else {
                    DlgErrorBox (hWnd, ERR_HELP_NOT_AVAILABLE);
                }
            }
            break ;

        case IDM_HELPHELP:
            {
                TCHAR NullStr [2] ;

                NullStr[0] = TEXT('\0') ;
                bPrepareMenu = FALSE ;
                if (*pszHelpFile != 0) {
                    WinHelp (hWndMain, pszHelpFile, HELP_HELPONHELP, (DWORD_PTR)(NullStr)) ;
                } else {
                    DlgErrorBox (hWnd, ERR_HELP_NOT_AVAILABLE);
                }
            }
            break ;

        default:
            return (FALSE) ;
    }

    if (bPrepareMenu) {
        PrepareMenu (GetMenu (hWnd)) ;
    }

    return (TRUE) ;
}



void
PrepareMenu (
             HMENU hMenu
             )
{
    BOOL           bPlayingLog ;
    BOOL           bCurrentLine = FALSE;
    BOOL           bManualRefresh = FALSE;
    BOOL           bLogCollecting ;
    BOOL           bRefresh ;

    // hMenu is NULL when the menu bar display option is off.
    // In that case, we still have to enable/disable all tool buttons
    // So, I have commented out the next 2 lines...
    //   if (!hMenu)
    //      return ;

    bLogCollecting = LogCollecting (hWndLog) ;
    bPlayingLog = PlayingBackLog () ;

    switch (iPerfmonView) {
        case IDM_VIEWCHART:
            bCurrentLine = (CurrentGraphLine (hWndGraph) != NULL) ;
            bRefresh = GraphRefresh (hWndGraph) ;
            bManualRefresh = !bPlayingLog && bCurrentLine ;
            if (hMenu) {
                MenuCheck (hMenu, IDM_VIEWCHART, TRUE) ;
                MenuEnableItem (hMenu, IDM_FILEEXPORTCHART, bCurrentLine) ;
                MenuEnableItem (hMenu, IDM_EDITMODIFYCHART, bCurrentLine) ;
                MenuEnableItem (hMenu, IDM_EDITDELETECHART, bCurrentLine) ;
                MenuEnableItem (hMenu, IDM_OPTIONSREFRESHNOWCHART, bManualRefresh) ;
                MenuEnableItem (hMenu, IDM_EDITCLEARCHART, !bPlayingLog && bCurrentLine) ;
            }
            break ;

        case IDM_VIEWALERT:
            bCurrentLine = (CurrentAlertLine (hWndAlert) != NULL) ;
            bRefresh = AlertRefresh (hWndAlert) ;
            bManualRefresh = !bPlayingLog && bCurrentLine ;
            if (hMenu) {
                MenuCheck (hMenu, IDM_VIEWALERT, TRUE) ;
                MenuEnableItem (hMenu, IDM_FILEEXPORTALERT, bCurrentLine) ;
                MenuEnableItem (hMenu, IDM_EDITMODIFYALERT, bCurrentLine) ;
                MenuEnableItem (hMenu, IDM_EDITDELETEALERT, bCurrentLine) ;
                MenuEnableItem (hMenu, IDM_EDITCLEARALERT, !bPlayingLog && bCurrentLine) ;
                MenuEnableItem (hMenu, IDM_OPTIONSREFRESHNOWALERT, bManualRefresh) ;
            }
            break ;

        case IDM_VIEWLOG:
            bCurrentLine = AnyLogLine() ;
            bRefresh = LogRefresh (hWndLog) ;
            bManualRefresh = !bPlayingLog && bLogCollecting ;
            if (hMenu) {
                MenuCheck (hMenu, IDM_VIEWLOG, TRUE) ;
                MenuEnableItem (hMenu, IDM_FILEEXPORTLOG, bCurrentLine) ;
                MenuEnableItem (hMenu, IDM_EDITDELETELOG, bCurrentLine) ;
                MenuEnableItem (hMenu, IDM_OPTIONSREFRESHNOWLOG , bManualRefresh) ;
            }
            break ;

        case IDM_VIEWREPORT:
            bCurrentLine = CurrentReportItem (hWndReport) ;
            bRefresh = ReportRefresh (hWndReport) ;
            bManualRefresh = !bPlayingLog && bCurrentLine ;
            if (hMenu) {
                MenuCheck (hMenu, IDM_VIEWREPORT, TRUE) ;
                MenuEnableItem (hMenu, IDM_FILEEXPORTREPORT, bCurrentLine) ;
                MenuEnableItem (hMenu, IDM_EDITMODIFYREPORT, FALSE) ;
                MenuEnableItem (hMenu, IDM_EDITDELETEREPORT, bCurrentLine) ;
                MenuEnableItem (hMenu, IDM_EDITCLEARREPORT, !bPlayingLog && bCurrentLine) ;
                MenuEnableItem (hMenu, IDM_OPTIONSREFRESHNOWREPORT, bManualRefresh) ;
            }
            break ;
    }

    ToolbarEnableButton (hWndToolbar, EditTool,
                         bCurrentLine &&
                         (iPerfmonView != IDM_VIEWREPORT &&
                          iPerfmonView != IDM_VIEWLOG)) ;

    ToolbarEnableButton (hWndToolbar, DeleteTool, bCurrentLine) ;

    ToolbarEnableButton (hWndToolbar, RefreshTool, bManualRefresh) ;

    // None of the alert or report options make sense when playing back a log.
#if 0
    ToolbarEnableButton (hWndToolbar,
                         OptionsTool,
                         !bPlayingLog ||
                         (iPerfmonView != IDM_VIEWREPORT &&
                          iPerfmonView != IDM_VIEWALERT)) ;
#endif
    ToolbarEnableButton (hWndToolbar,
                         OptionsTool,
                         !bPlayingLog ||
                         iPerfmonView != IDM_VIEWREPORT) ;

    ToolbarEnableButton (hWndToolbar, BookmarkTool, bLogCollecting) ;


    if (hMenu) {
        //      MenuEnableItem (hMenu, IDM_OPTIONSMANUALREFRESH, !bPlayingLog) ;
        //      MenuCheck (hMenu, IDM_OPTIONSMANUALREFRESH, bRefresh) ;
        MenuEnableItem (hMenu, IDM_EDITTIMEWINDOW, bPlayingLog) ;
        //      MenuEnableItem (hMenu, IDM_OPTIONSALERT, !bPlayingLog) ;
        MenuEnableItem (hMenu, IDM_OPTIONSREPORT, !bPlayingLog) ;
        MenuEnableItem (hMenu, IDM_OPTIONSBOOKMARK, bLogCollecting) ;

        // check/uncheck all the display options
        MenuCheck (hMenu, IDM_OPTIONSDISPLAYMENU, Options.bMenubar) ;
        MenuCheck (hMenu, IDM_OPTIONSDISPLAYTOOL, Options.bToolbar) ;
        MenuCheck (hMenu, IDM_OPTIONSDISPLAYSTATUS, Options.bStatusbar) ;
        MenuCheck (hMenu, IDM_OPTIONSDISPLAYONTOP, Options.bAlwaysOnTop) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\command.h ===
//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


BOOL PerfmonCommand (HWND hwnd, 
                     WPARAM wParam, 
                     LPARAM lParam) ;


void PrepareMenu (HMENU hMenu) ;

void ViewChart (HWND hWnd) ;

void ViewLog (HWND hWnd) ;

void ViewAlert (HWND hWnd) ;

void ViewReport (HWND hWnd) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\counters.h ===
FLOAT CounterEntry (PLINESTRUCT pLine);
BOOL IsCounterSupported ( DWORD dwCounterType );

FLOAT Counter_Counter(PLINESTRUCT pline);
FLOAT Counter_Bulk(PLINESTRUCT pline);
FLOAT Counter_Timer(PLINESTRUCT pline);
FLOAT Counter_Queuelen(PLINESTRUCT pLineStruct, DWORD dwFlags);
FLOAT Counter_Text(PLINESTRUCT pline);
FLOAT Counter_Rawcount(PLINESTRUCT pline);
FLOAT Sample_Fraction(PLINESTRUCT pline);
FLOAT Sample_Counter(PLINESTRUCT pline);
FLOAT Counter_Timer_Inv(PLINESTRUCT pline);
FLOAT Counter_Timer100Ns(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Timer100Ns_Inv(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Timer_Multi(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Timer_Multi_Inv(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Timer100Ns_Multi(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Timer100Ns_Multi_Inv(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Average_Timer(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Average_Bulk(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Raw_Fraction(PLINESTRUCT pLineStruct, BOOL bLargeValue) ;
FLOAT Counter_Elapsed_Time (PLINESTRUCT pLineStruct);
FLOAT Counter_Delta(PLINESTRUCT pLineStruct, BOOL bLargeData);

FLOAT Counter_Null(PLINESTRUCT pline);



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\datasrc.h ===
BOOL DisplayDataSourceOptions (HWND hWndParent) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\counters.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1993   Microsoft Corporation

Module Name:

    counters.c

Abstract:

    This module contains the routines to calculate "DataPoint" values from
    the registry data.

    The algoritms were lifted from RussBls's "Data.C" in winmeter.

    All the math is done in floating point to get the correct results, at
    the sacrifice of efficiency on a 386 with not 387. We can always
    revisit these routines later.

Revision History:

    Bob Watson  11/04/92
        -- modified calculations to use more integer math and "early
            exits" to improve efficiency on slower & non-coprocessor
            machines
--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//
#include "perfmon.h"       // perfmon include files
#include "counters.h"      // Exported declarations for this file
#include "perfmsg.h"       // message file definitions

//==========================================================================//
//                                  Constants                               //
//==========================================================================//

#ifdef DBG_COUNTER_DATA
#undef DBG_COUNTER_DATA
#endif
//#define DBG_COUNTER_DATA

#define INVERT             PERF_COUNTER_TIMER_INV
#define NS100_INVERT       PERF_100NSEC_TIMER_INV
#define NS100              PERF_100NSEC_TIMER
#define TIMER_MULTI        PERF_COUNTER_MULTI_TIMER
#define TIMER_MULTI_INVERT PERF_COUNTER_MULTI_TIMER_INV
#define NS100_MULTI        PERF_100NSEC_MULTI_TIMER
#define NS100_MULTI_INVERT PERF_100NSEC_MULTI_TIMER_INV


#define FRACTION 1
#define BULK     1

#define TOO_BIG   (FLOAT)1500000000

//==========================================================================//
//                              Local Functions                             //
//==========================================================================//
#define eLIntToFloat(LI)    (FLOAT)( ((LARGE_INTEGER *)(LI))->QuadPart )

static LPTSTR  cszSpace = TEXT(" ");


FLOAT
eGetTimeInterval(
    IN PLARGE_INTEGER pliCurrentTime,
    IN PLARGE_INTEGER pliPreviousTime,
    IN PLARGE_INTEGER pliFreq
)
/*++

Routine Description:

    Get the difference between the current and previous time counts,
        then divide by the frequency.

Arguments:

    IN pCurrentTime
    IN pPreviousTime
        used to compute the duration of this sample (the time between
        samples

    IN pliFreq
        # of  counts (clock ticks) per second

Return Value:

    Floating point representation of Time Interval (seconds)
--*/
{
    FLOAT   eTimeDifference;
    FLOAT   eFreq;
    FLOAT   eTimeInterval ;

    LARGE_INTEGER liDifference;

    // Get the number of counts that have occured since the last sample

    liDifference.QuadPart = pliCurrentTime->QuadPart -
            pliPreviousTime->QuadPart;

    if (liDifference.QuadPart <= 0) {
        return (FLOAT) 0.0f;
    } else {
        eTimeDifference = eLIntToFloat(&liDifference);

        // Get the counts per second

        eFreq = eLIntToFloat(pliFreq) ;
        if (eFreq <= 0.0f)
           return (FLOAT) 0.0f;

        // Get the time since the last sample.

        eTimeInterval = eTimeDifference / eFreq ;

        return (eTimeInterval) ;
    }
} // eGetTimeInterval

FLOAT
Counter_Counter_Common(
    IN PLINESTRUCT pLineStruct,
    IN INT iType
)
/*++

Routine Description:

    Take the difference between the current and previous counts
        then divide by the time interval

Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

    IN iType
        Counter Type


Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eTimeInterval;
    FLOAT   eDifference;
    FLOAT   eCount ;
    BOOL    bValueDrop = FALSE ;

    LARGE_INTEGER   liDifference;

    if (iType != BULK) {
        pLineStruct->lnaCounterValue[0].HighPart = 0;
    }

    liDifference.QuadPart = pLineStruct->lnaCounterValue[0].QuadPart -
                        pLineStruct->lnaOldCounterValue[0].QuadPart;

    if (liDifference.QuadPart <= 0) {
        if (bReportEvents && (liDifference.QuadPart < 0)) {
            wMessageIndex = 0;
            dwMessageDataBytes = 0;
            szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
            if (pLineStruct->lnInstanceName != NULL){
                if (pLineStruct->lnPINName != NULL) {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                } else {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
            } else {
                szMessageArray[wMessageIndex++] = cszSpace;
                szMessageArray[wMessageIndex++] = cszSpace;
            }
            if (iType != BULK) {
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[0].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[0].LowPart;
            } else {  // 8 byte counter values
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[0].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[0].HighPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[0].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[0].HighPart;
            }
            dwMessageDataBytes *= sizeof(DWORD); // convert index to size
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,      // error type
                0,                          // category (not used)
                (DWORD)PERFMON_ERROR_NEGATIVE_VALUE, // event,
                NULL,                       // SID (not used),
                wMessageIndex,              // number of strings
                dwMessageDataBytes,         // sizeof raw data
                szMessageArray,             // message text array
                (LPVOID)&dwMessageData[0]); // raw data
        }
        return (FLOAT) 0.0f;
    } else {
        eTimeInterval = eGetTimeInterval(&pLineStruct->lnNewTime,
                                        &pLineStruct->lnOldTime,
                                        &pLineStruct->lnPerfFreq) ;
        if (eTimeInterval <= 0.0f) {
            if ((eTimeInterval < 0.0f) && bReportEvents) {
                wMessageIndex = 0;
                dwMessageDataBytes = 0;
                szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
                if (pLineStruct->lnInstanceName != NULL){
                    if (pLineStruct->lnPINName != NULL) {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    } else {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                        szMessageArray[wMessageIndex++] = cszSpace;
                    }
                } else {
                    szMessageArray[wMessageIndex++] = cszSpace;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnNewTime.LowPart;
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnNewTime.HighPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnOldTime.LowPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnOldTime.HighPart;
                dwMessageDataBytes *= sizeof(DWORD); // convert index to size
                ReportEvent (hEventLog,
                    EVENTLOG_ERROR_TYPE,        // error type
                    0,                          // category (not used)
                    (DWORD)PERFMON_ERROR_NEGATIVE_TIME, // event,
                    NULL,                       // SID (not used),
                    wMessageIndex,             // number of strings
                    dwMessageDataBytes,         // sizeof raw data
                    szMessageArray,             // message text array
                    (LPVOID)&dwMessageData[0]); // raw data
                return (FLOAT) 0.0f;
            }
        } else {
            eDifference = eLIntToFloat (&liDifference);

            eCount         = eDifference / eTimeInterval ;

            if (bValueDrop && (eCount > ((FLOAT)TOO_BIG))) {
                // ignore this bogus data since it is too big for
                // the wrap-around case
                wMessageIndex = 0;
                dwMessageDataBytes = 0;
                szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
                if (pLineStruct->lnInstanceName != NULL){
                    if (pLineStruct->lnPINName != NULL) {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    } else {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                        szMessageArray[wMessageIndex++] = cszSpace;
                    }
                } else {
                    szMessageArray[wMessageIndex++] = cszSpace;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    liDifference.LowPart;
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    liDifference.HighPart;
                dwMessageDataBytes *= sizeof(DWORD); // convert index to size
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,        // error type
                    0,                          // category (not used)
                    (DWORD)PERFMON_ERROR_VALUE_OUT_OF_BOUNDS, // event
                    NULL,                       // SID (not used),
                    wMessageIndex,             // number of strings
                    dwMessageDataBytes,         // sizeof raw data
                    szMessageArray,             // message text array
                    (LPVOID)&dwMessageData[0]); // raw data
                eCount = (FLOAT) 0.0f ;
            }
            return(eCount) ;
        }
    }
    return (FLOAT) 0.0f;
} // Counter_Counter_Common


FLOAT
Counter_Average_Timer(
    IN PLINESTRUCT pLineStruct
)
/*++

Routine Description:

    Take the differences between the current and previous times and counts
    divide the time interval by the counts multiply by 10,000,000 (convert
    from 100 nsec to sec)

Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eTimeInterval;
    FLOAT   eCount;

    LARGE_INTEGER    liDifference;

    // Get the current and previous counts.

    pLineStruct->lnaCounterValue[1].HighPart = 0;
    liDifference.QuadPart = pLineStruct->lnaCounterValue[1].QuadPart -
            pLineStruct->lnaOldCounterValue[1].QuadPart;

    if ( liDifference.QuadPart <= 0) {
        if ((liDifference.QuadPart < 0) && bReportEvents) {
            wMessageIndex = 0;
            dwMessageDataBytes = 0;
            szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
            if (pLineStruct->lnInstanceName != NULL){
                if (pLineStruct->lnPINName != NULL) {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                } else {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
            } else {
                szMessageArray[wMessageIndex++] = cszSpace;
                szMessageArray[wMessageIndex++] = cszSpace;
            }
            dwMessageData[dwMessageDataBytes++] =       // recent data
                pLineStruct->lnaCounterValue[1].LowPart;
            dwMessageData[dwMessageDataBytes++] =       // previous data
                pLineStruct->lnaOldCounterValue[1].LowPart;
            dwMessageDataBytes *= sizeof(DWORD); // convert index to size
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,        // error type
                0,                          // category (not used)
                (DWORD)PERFMON_ERROR_NEGATIVE_VALUE, // event,
                NULL,                       // SID (not used),
                wMessageIndex,             // number of strings
                dwMessageDataBytes,         // sizeof raw data
                szMessageArray,             // message text array
                (LPVOID)&dwMessageData[0]); // raw data
        }
        return (FLOAT) 0.0f;
    } else {
        // Get the amount of time that has passed since the last sample
        eTimeInterval = eGetTimeInterval(&pLineStruct->lnaCounterValue[0],
                                            &pLineStruct->lnaOldCounterValue[0],
                                            &pLineStruct->lnPerfFreq) ;

        if (eTimeInterval <= 0.0f) { // return 0 if negative time has passed
            if ((eTimeInterval < 0.0f) & bReportEvents) {
                wMessageIndex = 0;
                dwMessageDataBytes = 0;
                szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
                if (pLineStruct->lnInstanceName != NULL){
                    if (pLineStruct->lnPINName != NULL) {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    } else {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                        szMessageArray[wMessageIndex++] = cszSpace;
                    }
                } else {
                    szMessageArray[wMessageIndex++] = cszSpace;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[0].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[0].HighPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[0].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[0].HighPart;
                dwMessageDataBytes *= sizeof(DWORD); // convert index to size
                ReportEvent (hEventLog,
                    EVENTLOG_ERROR_TYPE,        // error type
                    0,                          // category (not used)
                    (DWORD)PERFMON_ERROR_NEGATIVE_TIME, // event,
                    NULL,                       // SID (not used),
                    wMessageIndex,              // number of strings
                    dwMessageDataBytes,         // sizeof raw data
                    szMessageArray,             // message text array
                    (LPVOID)&dwMessageData[0]); // raw data
            }
            return (0.0f);
        } else {
            // Get the number of counts in this time interval.
            eCount = eTimeInterval / eLIntToFloat (&liDifference);
            return(eCount) ;
        }
    }
} //Counter_Average_Timer



FLOAT
Counter_Average_Bulk(
    IN PLINESTRUCT pLineStruct
)
/*++

Routine Description:

    Take the differences between the current and previous byte counts and
    operation counts divide the bulk count by the operation counts

Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eBulkDelta;
    FLOAT   eDifference;
    FLOAT   eCount;

    LARGE_INTEGER liDifference;
    LARGE_INTEGER liBulkDelta;

    // Get the bulk count increment since the last sample

    liBulkDelta.QuadPart = pLineStruct->lnaCounterValue[0].QuadPart -
            pLineStruct->lnaOldCounterValue[0].QuadPart;

    if (liBulkDelta.QuadPart <= 0) {
        if ((liBulkDelta.QuadPart < 0) && bReportEvents) {
            wMessageIndex = 0;
            dwMessageDataBytes = 0;
            szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
            if (pLineStruct->lnInstanceName != NULL){
                if (pLineStruct->lnPINName != NULL) {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                } else {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
            } else {
                szMessageArray[wMessageIndex++] = cszSpace;
                szMessageArray[wMessageIndex++] = cszSpace;
            }
            dwMessageData[dwMessageDataBytes++] =       // recent data
                pLineStruct->lnaCounterValue[0].LowPart;
            dwMessageData[dwMessageDataBytes++] =       // recent data
                pLineStruct->lnaCounterValue[0].HighPart;
            dwMessageData[dwMessageDataBytes++] =       // previous data
                pLineStruct->lnaOldCounterValue[0].LowPart;
            dwMessageData[dwMessageDataBytes++] =       // previous data
                pLineStruct->lnaOldCounterValue[0].HighPart;
            dwMessageDataBytes *= sizeof(DWORD); // convert index to size
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,        // error type
                0,                          // category (not used)
                (DWORD)PERFMON_ERROR_NEGATIVE_VALUE, // event,
                NULL,                       // SID (not used),
                wMessageIndex,             // number of strings
                dwMessageDataBytes,         // sizeof raw data
                szMessageArray,             // message text array
                (LPVOID)&dwMessageData[0]); // raw data
        }
        return (FLOAT) 0.0f;
    } else {
        // Get the current and previous counts.
        pLineStruct->lnaCounterValue[1].HighPart = 0;
        liDifference.QuadPart = pLineStruct->lnaCounterValue[1].QuadPart -
                pLineStruct->lnaOldCounterValue[1].QuadPart;

        // Get the number of counts in this time interval.

        if ( liDifference.QuadPart <= 0) {
            if ((liDifference.QuadPart < 0) && bReportEvents) {
                // Counter value invalid
                wMessageIndex = 0;
                dwMessageDataBytes = 0;
                szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
                if (pLineStruct->lnInstanceName != NULL){
                    if (pLineStruct->lnPINName != NULL) {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    } else {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                        szMessageArray[wMessageIndex++] = cszSpace;
                    }
                } else {
                    szMessageArray[wMessageIndex++] = cszSpace;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[1].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[1].HighPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[1].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[1].HighPart;
                dwMessageDataBytes *= sizeof(DWORD); // convert index to size
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,        // error type
                    0,                          // category (not used)
                    (DWORD)PERFMON_ERROR_NEGATIVE_VALUE, // event,
                    NULL,                       // SID (not used),
                    wMessageIndex,             // number of strings
                    dwMessageDataBytes,         // sizeof raw data
                    szMessageArray,             // message text array
                    (LPVOID)&dwMessageData[0]); // raw data
            }
            return (FLOAT) 0.0f;
        } else {
            eBulkDelta = eLIntToFloat (&liBulkDelta);
            eDifference = eLIntToFloat (&liDifference);
            eCount = eBulkDelta / eDifference ;

            // Scale the value to up to 1 second

            return(eCount) ;
        }
    }
} // Counter_Average_Bulk



FLOAT
Counter_Timer_Common(
    IN  PLINESTRUCT pLineStruct,
    IN  INT iType
)
/*++

Routine Description:

    Take the difference between the current and previous counts,
        Normalize the count (counts per interval)
        divide by the time interval (count = % of interval)
        if (invert)
            subtract from 1 (the normalized size of an interval)
        multiply by 100 (convert to a percentage)
        this value from 100.

Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

    IN iType
        Counter Type

Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eTimeInterval;
    FLOAT   eDifference;
    FLOAT   eFreq;
    FLOAT   eFraction;
    FLOAT   eMultiBase;
    FLOAT   eCount ;

    LARGE_INTEGER   liTimeInterval;
    LARGE_INTEGER   liDifference;
    LARGE_INTEGER   liFreq;

    // test to see if the previous sample was 0, if so, return 0 since
    // the difference between a "valid" value and 0 will likely exceed
    // 100%. It's better to keep the value at 0 until a valid one can
    // be displayed, rather than display a 100% spike, then a valid value.

    if (pLineStruct->lnaOldCounterValue[0].QuadPart == 0) {
        return (FLOAT)0.0f;
    }

    // Get the amount of time that has passed since the last sample

    if (iType == NS100 ||
        iType == NS100_INVERT ||
        iType == NS100_MULTI ||
        iType == NS100_MULTI_INVERT) {
            liTimeInterval.QuadPart = pLineStruct->lnNewTime100Ns.QuadPart -
                pLineStruct->lnOldTime100Ns.QuadPart;
            eTimeInterval = eLIntToFloat (&liTimeInterval);
    } else {
            liTimeInterval.QuadPart = pLineStruct->lnNewTime.QuadPart -
                             pLineStruct->lnOldTime.QuadPart;
            eTimeInterval = eGetTimeInterval(&pLineStruct->lnNewTime,
                                            &pLineStruct->lnOldTime,
                                            &pLineStruct->lnPerfFreq) ;
    }

    if (liTimeInterval.QuadPart <= 0) {
        if ((liTimeInterval.QuadPart < 0) && bReportEvents) {
            wMessageIndex = 0;
            dwMessageDataBytes = 0;
            szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
            if (pLineStruct->lnInstanceName != NULL){
                if (pLineStruct->lnPINName != NULL) {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                } else {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
            } else {
                szMessageArray[wMessageIndex++] = cszSpace;
                szMessageArray[wMessageIndex++] = cszSpace;
            }
            dwMessageData[dwMessageDataBytes++] =       // recent data
                pLineStruct->lnNewTime.LowPart;
            dwMessageData[dwMessageDataBytes++] =       // recent data
                pLineStruct->lnNewTime.HighPart;
            dwMessageData[dwMessageDataBytes++] =       // previous data
                pLineStruct->lnOldTime.LowPart;
            dwMessageData[dwMessageDataBytes++] =       // previous data
                pLineStruct->lnOldTime.HighPart;
            dwMessageDataBytes *= sizeof(DWORD); // convert index to size
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,        // error type
                0,                          // category (not used)
                (DWORD)PERFMON_ERROR_NEGATIVE_TIME, // event,
                NULL,                       // SID (not used),
                wMessageIndex,             // number of strings
                dwMessageDataBytes,         // sizeof raw data
                szMessageArray,             // message text array
                (LPVOID)&dwMessageData[0]); // raw data
        }
       return (FLOAT) 0.0f;
    }
    // Get the current and previous counts.

    liDifference.QuadPart = pLineStruct->lnaCounterValue[0].QuadPart -
            pLineStruct->lnaOldCounterValue[0].QuadPart;

    // Get the number of counts in this time interval.
    // (1, 2, 3 or any number of seconds could have gone by since
    // the last sample)

    eDifference = eLIntToFloat (&liDifference) ;

    if (iType == 0 || iType == INVERT)
    {
        // Get the counts per interval (second)
        liFreq.QuadPart = pLineStruct->lnPerfFreq.QuadPart;

        if ((liFreq.QuadPart <= 0) && bReportEvents) {
            wMessageIndex = 0;
            dwMessageDataBytes = 0;
            szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
            if (pLineStruct->lnInstanceName != NULL){
                if (pLineStruct->lnPINName != NULL) {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                } else {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
            } else {
                szMessageArray[wMessageIndex++] = cszSpace;
                szMessageArray[wMessageIndex++] = cszSpace;
            }
            dwMessageData[dwMessageDataBytes++] = liFreq.LowPart;
            dwMessageData[dwMessageDataBytes++] = liFreq.HighPart;
            dwMessageDataBytes *= sizeof(DWORD); // convert index to size
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,        // error type
                0,                          // category (not used)
                (DWORD)PERFMON_ERROR_BAD_FREQUENCY, // event,
                NULL,                       // SID (not used),
                wMessageIndex,             // number of strings
                dwMessageDataBytes,         // sizeof raw data
                szMessageArray,             // message text array
                (LPVOID)&dwMessageData[0]); // raw data
           return (FLOAT) 0.0f;
        } else {
            eFreq = eLIntToFloat(&pLineStruct->lnPerfFreq) ;
        }
        // Calculate the fraction of the counts that are used by whatever
        // we are measuring to convert to units per second

        eFraction = eDifference / eFreq ;
    }
    else
    {
        // for 100 NS counters, the frequency is not included since it
        // would cancel out since both numerator & denominator are returned
        // in 100 NS units.  Non "100 NS" counter types are normalized to
        // seconds.
        eFraction = eDifference ;
        liFreq.QuadPart = 10000000;
    }

    // Calculate the fraction of time used by what were measuring.

    if (eTimeInterval > 0.0)
        eCount = eFraction / eTimeInterval ;
    else
        eCount = 0.0;

    // If this is  an inverted count take care of the inversion.

    if (iType == INVERT || iType == NS100_INVERT)
        eCount = (FLOAT) 1.0 - eCount ;

    if (eCount <= (FLOAT)0.0f) {
        // the threshold for reporting an error is -.1 since some timers
        // have a small margin of error that should never exceed this value
        // but can fall below 0 at times. Typically this error is no more
        // than -0.01
        if ((eCount < (FLOAT)-0.1f) && bReportEvents) {
            wMessageIndex = 0;
            dwMessageDataBytes = 0;
            szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
            if (pLineStruct->lnInstanceName != NULL){
                if (pLineStruct->lnPINName != NULL) {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                } else {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
            } else {
                szMessageArray[wMessageIndex++] = cszSpace;
                szMessageArray[wMessageIndex++] = cszSpace;
            }
            dwMessageData[dwMessageDataBytes++] =       // recent data
                pLineStruct->lnaCounterValue[0].LowPart;
            dwMessageData[dwMessageDataBytes++] =       // recent data
                pLineStruct->lnaCounterValue[0].HighPart;
            dwMessageData[dwMessageDataBytes++] =       // previous data
                pLineStruct->lnaOldCounterValue[0].LowPart;
            dwMessageData[dwMessageDataBytes++] =       // previous data
                pLineStruct->lnaOldCounterValue[0].HighPart;
            dwMessageDataBytes *= sizeof(DWORD); // convert index to size
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,        // error type
                0,                          // category (not used)
                (DWORD)PERFMON_ERROR_NEGATIVE_VALUE, // event,
                NULL,                       // SID (not used),
                wMessageIndex,             // number of strings
                dwMessageDataBytes,         // sizeof raw data
                szMessageArray,             // message text array
                (LPVOID)&dwMessageData[0]); // raw data
        }
        // don't just return here, since 0 is possibly a valid value
        eCount = (FLOAT)0.0f;
    }

    // If this is a multi count take care of the base
    if (iType == TIMER_MULTI || iType == NS100_MULTI ||
        iType == TIMER_MULTI_INVERT || iType == NS100_MULTI_INVERT) {

        if (pLineStruct->lnaCounterValue[1].LowPart <= 0) {
#if 0
            if ((pLineStruct->lnaCounterValue[1].LowPart < 0) &&
                 bReportEvents) {
                wMessageIndex = 0;
                dwMessageDataBytes = 0;
                szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
                if (pLineStruct->lnInstanceName != NULL){
                    if (pLineStruct->lnPINName != NULL) {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    } else {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                        szMessageArray[wMessageIndex++] = cszSpace;
                    }
                } else {
                    szMessageArray[wMessageIndex++] = cszSpace;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[1].LowPart;
                dwMessageDataBytes *= sizeof (DWORD);
                ReportEvent (hEventLog,
                    EVENTLOG_ERROR_TYPE,        // error type
                    0,                          // category (not used)
                    (DWORD)PERFMON_ERROR_INVALID_BASE, // event,
                    NULL,                       // SID (not used),
                    wMessageIndex,             // number of strings
                    dwMessageDataBytes,         // sizeof raw data
                    szMessageArray,             // message text array
                    (LPVOID)&dwMessageData[0]); // raw data
            }
#endif
            return (FLOAT) 0.0f;
        } else {
            eMultiBase  = (FLOAT)pLineStruct->lnaCounterValue[1].LowPart ;
        }

        // If this is an inverted multi count take care of the inversion.
        if (iType == TIMER_MULTI_INVERT || iType == NS100_MULTI_INVERT) {
            eCount = (FLOAT) eMultiBase - eCount ;
        }
        eCount /= eMultiBase;
    }

    // Scale the value to up to 100.

    eCount *= 100.0f ;

    if (((eCount > 100.0f) && (bCapPercentsAt100)) &&
        iType != NS100_MULTI &&
        iType != NS100_MULTI_INVERT &&
        iType != TIMER_MULTI &&
        iType != TIMER_MULTI_INVERT) {
        if (bReportEvents) {
            wMessageIndex = 0;
			dwMessageDataBytes = 0;
            szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
            if (pLineStruct->lnInstanceName != NULL){
                if (pLineStruct->lnPINName != NULL) {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                } else {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
            } else {
                szMessageArray[wMessageIndex++] = cszSpace;
                szMessageArray[wMessageIndex++] = cszSpace;
            }
            dwMessageData[dwMessageDataBytes++] =
                pLineStruct->lnaCounterValue[0].LowPart;
            dwMessageData[dwMessageDataBytes++] =
                pLineStruct->lnaCounterValue[0].HighPart;
            dwMessageData[dwMessageDataBytes++] =
                pLineStruct->lnaOldCounterValue[0].LowPart;
            dwMessageData[dwMessageDataBytes++] =
                pLineStruct->lnaOldCounterValue[0].HighPart;
            dwMessageData[dwMessageDataBytes++] = liTimeInterval.LowPart;
            dwMessageData[dwMessageDataBytes++] = liTimeInterval.HighPart;
            dwMessageData[dwMessageDataBytes++] = liFreq.LowPart;
            dwMessageData[dwMessageDataBytes++] = liFreq.HighPart;
            dwMessageDataBytes *= sizeof(DWORD);
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,      // error type
                0,                          // category (not used)
                (DWORD)PERFMON_ERROR_VALUE_OUT_OF_RANGE, // event,
                NULL,                       // SID (not used),
                wMessageIndex,              // number of strings
                dwMessageDataBytes,         // sizeof raw data
                szMessageArray,             // message text array
                (LPVOID)&dwMessageData[0]); // raw data
        }
        eCount = 100.0f; // limit value to 100.0%
    }
    return(eCount) ;
} // Counter_Timer_Common


FLOAT
Counter_Raw_Fraction(
    IN PLINESTRUCT pLineStruct,
    IN BOOL        bLargeValue
)
/*++

Routine Description:

    Evaluate a raw fraction (no time, just two values: Numerator and
        Denominator) and multiply by 100 (to make a percentage;

Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eCount ;

    LARGE_INTEGER   liNumerator;

    if (pLineStruct->lnaCounterValue[0].LowPart == 0) {
        // numerator is 0 so just bail here
        return (FLOAT)0.0f;
    } else {
        if (!bLargeValue) {
            liNumerator.QuadPart =
                pLineStruct->lnaCounterValue[0].LowPart * 100L;
        } else {
            liNumerator.QuadPart =
                pLineStruct->lnaCounterValue[0].QuadPart * 100L;
        }
    }

    // now test and compute base (denominator)
    if (pLineStruct->lnaCounterValue[1].QuadPart == 0 ) {
        // invalid value for denominator
        if (bReportEvents) {
            wMessageIndex = 0;
            dwMessageDataBytes = 0;
            szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
            if (pLineStruct->lnInstanceName != NULL){
                if (pLineStruct->lnPINName != NULL) {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                } else {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
            } else {
                szMessageArray[wMessageIndex++] = cszSpace;
                szMessageArray[wMessageIndex++] = cszSpace;
            }
            dwMessageData[dwMessageDataBytes++] =       // recent data
                pLineStruct->lnaCounterValue[0].LowPart;
            dwMessageData[dwMessageDataBytes++] =       // recent data
                pLineStruct->lnaCounterValue[1].LowPart;
                dwMessageDataBytes *= sizeof (DWORD);
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,        // error type
                0,                          // category (not used)
                (DWORD)PERFMON_ERROR_INVALID_BASE, // event,
                NULL,                       // SID (not used),
                wMessageIndex,              // number of strings
                dwMessageDataBytes,         // sizeof raw data
                szMessageArray,             // message text array
                (LPVOID)&dwMessageData[0]); // raw data
        }
        return (0.0f);
    } else {
        // if base is OK, then get fraction
        eCount = eLIntToFloat(&liNumerator)  /
                 (FLOAT) pLineStruct->lnaCounterValue[1].QuadPart;
        return(eCount) ;
    }
} // Counter_Raw_Fraction


FLOAT
eElapsedTime(
    PLINESTRUCT pLineStruct,
    INT iType
)
/*++

Routine Description:

    Converts 100NS elapsed time to fractional seconds

Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

    IN iType
        Unused.

Return Value:

    Floating point representation of elapsed time in seconds
--*/
{
    FLOAT   eSeconds ;

    LARGE_INTEGER   liDifference;

    if (pLineStruct->lnaCounterValue[0].QuadPart <= 0) {
        // no data [start time = 0] so return 0
        // this really doesn't warrant an error message
        return (FLOAT) 0.0f;
    } else {
        // otherwise compute difference between current time and start time
        liDifference.QuadPart =
            pLineStruct->lnNewTime.QuadPart -   // sample time in obj. units
            pLineStruct->lnaCounterValue[0].QuadPart;   // start time in obj. units

        if ((liDifference.QuadPart <= 0)  ||
            (pLineStruct->lnObject.PerfFreq.QuadPart <= 0)) {

            if ((bReportEvents) && ((liDifference.QuadPart < 0)  ||
                (pLineStruct->lnObject.PerfFreq.QuadPart < 0))) {
                wMessageIndex = 0;
                dwMessageDataBytes = 0;
                szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
                if (pLineStruct->lnInstanceName != NULL){
                    if (pLineStruct->lnPINName != NULL) {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    } else {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                        szMessageArray[wMessageIndex++] = cszSpace;
                    }
                } else {
                    szMessageArray[wMessageIndex++] = cszSpace;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
                if (liDifference.QuadPart < 0) {
                    dwMessageData[dwMessageDataBytes++] =
                        pLineStruct->lnNewTime.LowPart;
                    dwMessageData[dwMessageDataBytes++] =
                        pLineStruct->lnNewTime.HighPart;
                    dwMessageData[dwMessageDataBytes++] =
                        pLineStruct->lnaCounterValue[0].LowPart;
                    dwMessageData[dwMessageDataBytes++] =
                        pLineStruct->lnaCounterValue[0].HighPart;
                    dwMessageDataBytes *= sizeof(DWORD); // convert index to size
                    ReportEvent (hEventLog,
                        EVENTLOG_ERROR_TYPE,        // error type
                        0,                          // category (not used)
                        (DWORD)PERFMON_ERROR_NEGATIVE_TIME, // event,
                        NULL,                       // SID (not used),
                        wMessageIndex,             // number of strings
                        dwMessageDataBytes,         // sizeof raw data
                        szMessageArray,             // message text array
                        (LPVOID)&dwMessageData[0]); // raw data
                } else {
                    dwMessageData[dwMessageDataBytes++] =
                        pLineStruct->lnObject.PerfFreq.LowPart;
                    dwMessageData[dwMessageDataBytes++] =
                        pLineStruct->lnObject.PerfFreq.HighPart;
                    dwMessageDataBytes *= sizeof(DWORD); // convert index to size
                    ReportEvent (hEventLog,
                        EVENTLOG_ERROR_TYPE,        // error type
                        0,                          // category (not used)
                        (DWORD)PERFMON_ERROR_BAD_FREQUENCY, // event,
                        NULL,                       // SID (not used),
                        wMessageIndex,             // number of strings
                        dwMessageDataBytes,         // sizeof raw data
                        szMessageArray,             // message text array
                        (LPVOID)&dwMessageData[0]); // raw data
                }
            }
            return (FLOAT) 0.0f;
        } else {
            // convert to fractional seconds using object counter
            eSeconds = eLIntToFloat (&liDifference);
            eSeconds /= eLIntToFloat (&pLineStruct->lnObject.PerfFreq);

            return (eSeconds);
        }
    }

} // eElapsedTime


FLOAT
Sample_Common(
    PLINESTRUCT pLineStruct,
    INT iType
)
/*++

Routine Description:

    Divites "Top" differenced by Base Difference

Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

    IN iType
        Counter Type

Return Value:

    Floating point representation of outcome
--*/
{
    double  eCount ;

    LONG    lDifference;
    LONG    lBaseDifference;

    double  dReturn;

    lDifference = pLineStruct->lnaCounterValue[0].LowPart -
        pLineStruct->lnaOldCounterValue[0].LowPart ;

    if (lDifference <= 0) {
        if ((lDifference < 0) && bReportEvents) {
            wMessageIndex = 0;
            dwMessageDataBytes = 0;
            szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
            if (pLineStruct->lnInstanceName != NULL){
                if (pLineStruct->lnPINName != NULL) {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                } else {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
            } else {
                szMessageArray[wMessageIndex++] = cszSpace;
                szMessageArray[wMessageIndex++] = cszSpace;
            }
            dwMessageData[dwMessageDataBytes++] =       // recent data
                pLineStruct->lnaCounterValue[0].LowPart;
            dwMessageData[dwMessageDataBytes++] =       // previous data
                pLineStruct->lnaOldCounterValue[0].LowPart;
            dwMessageDataBytes *= sizeof(DWORD); // convert index to size
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,      // error type
                0,                          // category (not used)
                (DWORD)PERFMON_ERROR_NEGATIVE_VALUE, // event,
                NULL,                       // SID (not used),
                wMessageIndex,              // number of strings
                dwMessageDataBytes,         // sizeof raw data
                szMessageArray,             // message text array
                (LPVOID)&dwMessageData[0]); // raw data
        }
        dReturn = (double) 0.0f;
    } else {
        lBaseDifference = pLineStruct->lnaCounterValue[1].LowPart -
            pLineStruct->lnaOldCounterValue[1].LowPart ;

        if ( lBaseDifference <= 0 ) {
            // invalid value
            if ((lBaseDifference < 0 ) && bReportEvents) {
                wMessageIndex = 0;
                dwMessageDataBytes = 0;
                szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
                szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
                if (pLineStruct->lnInstanceName != NULL){
                    if (pLineStruct->lnPINName != NULL) {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    } else {
                        szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                        szMessageArray[wMessageIndex++] = cszSpace;
                    }
                } else {
                    szMessageArray[wMessageIndex++] = cszSpace;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[1].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[1].LowPart;
                dwMessageDataBytes *= sizeof(DWORD); // convert index to size
                ReportEvent (hEventLog,
                    EVENTLOG_ERROR_TYPE,        // error type
                    0,                          // category (not used)
                    (DWORD)PERFMON_ERROR_INVALID_BASE, // event,
                    NULL,                       // SID (not used),
                    wMessageIndex,              // number of strings
                    dwMessageDataBytes,         // sizeof raw data
                    szMessageArray,             // message text array
                    (LPVOID)&dwMessageData[0]); // raw data
            }
            dReturn = (0.0f);
        } else {
            eCount = lDifference / lBaseDifference ;

            if (iType == FRACTION) {
                eCount *= 100.0f ;
            }
            dReturn = eCount;
        }
    }

    return (FLOAT)dReturn;
} // Sample_Common


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


/*****************************************************************************
 * Counter_Counter - Take the difference between the current and previous
 *                   counts then divide by the time interval
 ****************************************************************************/
#define Counter_Counter(pLineStruct)      \
        Counter_Counter_Common(pLineStruct, 0)

/*****************************************************************************
 * Counter_Bulk    - Take the difference between the current and previous
 *                   counts then divide by the time interval
 *                   Same as a Counter_counter except it uses large_ints
 ****************************************************************************/
#define Counter_Bulk(pLineStruct)         \
        Counter_Counter_Common(pLineStruct, BULK)


/*****************************************************************************
 * Counter_Timer100Ns -
 *
 *      Need to review with RussBl exactly what he is doing here.
 ****************************************************************************/
#define Counter_Timer100Ns(pLineStruct)     \
        Counter_Timer_Common(pLineStruct, NS100)

/*****************************************************************************
 * Counter_Timer100Ns_Inv -
 *
 *      Need to review with RussBl exactly what he is doing here.
 ****************************************************************************/
#define Counter_Timer100Ns_Inv(pLineStruct)     \
        Counter_Timer_Common(pLineStruct, NS100_INVERT)

/*****************************************************************************
 * Counter_Timer_Multi -
 *
 *      Need to review with RussBl exactly what he is doing here.
 ****************************************************************************/
#define Counter_Timer_Multi(pLineStruct)     \
        Counter_Timer_Common(pLineStruct, TIMER_MULTI)

/*****************************************************************************
 * Counter_Timer_Multi_Inv -
 *
 *      Need to review with RussBl exactly what he is doing here.
 ****************************************************************************/
#define Counter_Timer_Multi_Inv(pLineStruct)       \
        Counter_Timer_Common(pLineStruct, TIMER_MULTI_INVERT)

/*****************************************************************************
 * Counter_Timer100Ns_Multi -
 *
 *      Need to review with RussBl exactly what he is doing here.
 ****************************************************************************/
#define Counter_Timer100Ns_Multi(pLineStruct)     \
        Counter_Timer_Common(pLineStruct, NS100_MULTI)

/*****************************************************************************
 * Counter_Timer100Ns_Multi_Inv -
 *
 *      Need to review with RussBl exactly what he is doing here.
 ****************************************************************************/
#define Counter_Timer100Ns_Multi_Inv(pLineStruct)    \
        Counter_Timer_Common(pLineStruct, NS100_MULTI_INVERT)

/*****************************************************************************
 * Counter_Timer - Take the difference between the current and previous
 *                 counts,
 *                 Normalize the count (counts per interval)
 *                 divide by the time interval (count = % of interval)
 *                 multiply by 100 (convert to a percentage)
 *                 this value from 100.
 ****************************************************************************/
#define Counter_Timer(pLineStruct)       \
        Counter_Timer_Common(pLineStruct, 0)

/*****************************************************************************
 * Counter_Timer_Inv - Take the difference between the current and previous
 *                     counts,
 *                     Normalize the count (counts per interval)
 *                     divide by the time interval (count = % of interval)
 *                     subtract from 1 (the normalized size of an interval)
 *                     multiply by 100 (convert to a percentage)
 *                     this value from 100.
 ****************************************************************************/
#define Counter_Timer_Inv(pLineStruct)         \
      Counter_Timer_Common(pLineStruct, INVERT)

/*****************************************************************************
 * Sample_Counter -
 ****************************************************************************/
#define Sample_Counter(pLineStruct)      \
      Sample_Common(pLineStruct, 0)

/*****************************************************************************
 * Sample_Fraction -
 ****************************************************************************/
#define Sample_Fraction(pLineStruct)     \
     Sample_Common(pLineStruct, FRACTION)

/*****************************************************************************
 * Counter_Rawcount - This is just a raw count.
 ****************************************************************************/
#define Counter_Rawcount(pLineStruct)     \
   ((FLOAT) (pLineStruct->lnaCounterValue[0].LowPart))

/*****************************************************************************
 * Counter_Large_Rawcount - This is just a raw count.
 ****************************************************************************/
#define Counter_Large_Rawcount(pLineStruct)     \
   ((FLOAT) eLIntToFloat(&(pLineStruct->lnaCounterValue[0])))

/*****************************************************************************
 * Counter_Elapsed_Time -
 ****************************************************************************/
#define Counter_Elapsed_Time(pLineStruct)         \
    eElapsedTime (pLineStruct, 0)

#define CQLFLAGS_LARGE   ((DWORD)0x00000001)
#define CQLFLAGS_100NS   ((DWORD)0x00000002)

FLOAT Counter_Queuelen(PLINESTRUCT pLineStruct, DWORD dwFlags)
/*++

Routine Description:

    Take the difference between the current and previous counts,
        divide by the time interval (count = decimal fraction of interval)
        Value can exceed 1.00.

Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

    IN iType
        Counter Type

Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eTimeDiff;
    FLOAT   eDifference;
    FLOAT   eCount;

    LONGLONG    llDifference;
    LONGLONG    llTimeDiff;

    // Get the amount of time that has passed since the last sample

    if (dwFlags & CQLFLAGS_100NS) {
        llTimeDiff = pLineStruct->lnNewTime100Ns.QuadPart -
                 pLineStruct->lnOldTime100Ns.QuadPart;
    } else {
        llTimeDiff = pLineStruct->lnNewTime.QuadPart -
                 pLineStruct->lnOldTime.QuadPart;
    }

    if (llTimeDiff <= 0) {
        if ((llTimeDiff < 0 )  && bReportEvents) {
            wMessageIndex = 0;
            dwMessageDataBytes = 0;
            szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
            if (pLineStruct->lnInstanceName != NULL){
                if (pLineStruct->lnPINName != NULL) {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                } else {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
            } else {
                szMessageArray[wMessageIndex++] = cszSpace;
                szMessageArray[wMessageIndex++] = cszSpace;
            }
            dwMessageData[dwMessageDataBytes++] =       // recent data
                pLineStruct->lnNewTime.LowPart;
            dwMessageData[dwMessageDataBytes++] =       // recent data
                pLineStruct->lnNewTime.HighPart;
            dwMessageData[dwMessageDataBytes++] =       // previous data
                pLineStruct->lnOldTime.LowPart;
            dwMessageData[dwMessageDataBytes++] =       // previous data
                pLineStruct->lnOldTime.HighPart;
            dwMessageDataBytes *= sizeof(DWORD); // convert index to size
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,        // error type
                0,                          // category (not used)
                (DWORD)PERFMON_ERROR_NEGATIVE_TIME, // event,
                NULL,                       // SID (not used),
                wMessageIndex,             // number of strings
                dwMessageDataBytes,         // sizeof raw data
                szMessageArray,             // message text array
                (LPVOID)&dwMessageData[0]); // raw data
        }
        return (FLOAT)0.0f;
    } else {
        eTimeDiff = (FLOAT)llTimeDiff;
    }

    // Get the current and previous counts.

    if (dwFlags & CQLFLAGS_LARGE) {
        llDifference = pLineStruct->lnaCounterValue[0].QuadPart -
                pLineStruct->lnaOldCounterValue[0].QuadPart;
    } else {
        llDifference = (LONGLONG)(pLineStruct->lnaCounterValue[0].LowPart -
                pLineStruct->lnaOldCounterValue[0].LowPart);
    }

    eDifference = (FLOAT)llDifference;

    if (eDifference < 0.0f) {
        if (bReportEvents) {
            wMessageIndex = 0;
            dwMessageDataBytes = 0;
            szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
            if (pLineStruct->lnInstanceName != NULL){
                if (pLineStruct->lnPINName != NULL) {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                } else {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
            } else {
                szMessageArray[wMessageIndex++] = cszSpace;
                szMessageArray[wMessageIndex++] = cszSpace;
            }
            if (!(dwFlags & CQLFLAGS_LARGE)) {
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[0].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[0].LowPart;
            } else {  // 8 byte counter values
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[0].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[0].HighPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[0].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[0].HighPart;
            }
            dwMessageDataBytes *= sizeof(DWORD); // convert index to size
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,      // error type
                0,                          // category (not used)
                (DWORD)PERFMON_ERROR_NEGATIVE_VALUE, // event,
                NULL,                       // SID (not used),
                wMessageIndex,              // number of strings
                dwMessageDataBytes,         // sizeof raw data
                szMessageArray,             // message text array
                (LPVOID)&dwMessageData[0]); // raw data
        }
        eCount = 0.0f ;
    } else {
        eCount = eDifference / eTimeDiff;
    }

    return(eCount) ;

}

FLOAT Counter_Delta(PLINESTRUCT pLineStruct, BOOL bLargeData)
/*++

Routine Description:

    Take the difference between the current and previous counts,

Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eDifference;
    LONGLONG    llDifference;
    ULONGLONG   ullThisValue, ullPrevValue;

    // Get the current and previous counts.

    if (!bLargeData) {
        // then clear the high part of the word
        ullThisValue = (ULONGLONG)pLineStruct->lnaCounterValue[0].LowPart;
        ullPrevValue = (ULONGLONG)pLineStruct->lnaOldCounterValue[0].LowPart;
    } else {
        ullThisValue = (ULONGLONG)pLineStruct->lnaCounterValue[0].QuadPart;
        ullPrevValue = (ULONGLONG)pLineStruct->lnaOldCounterValue[0].QuadPart;
    }

    if (ullThisValue > ullPrevValue) {
        llDifference = (LONGLONG)(ullThisValue - ullPrevValue);
        eDifference = (FLOAT)llDifference;
    } else {
        // the new value is smaller than or equal to the old value
        // and negative numbers are not allowed.
        if ((ullThisValue < ullPrevValue) && bReportEvents) {
            wMessageIndex = 0;
            dwMessageDataBytes = 0;
            szMessageArray[wMessageIndex++] = pLineStruct->lnSystemName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnObjectName;
            szMessageArray[wMessageIndex++] = pLineStruct->lnCounterName;
            if (pLineStruct->lnInstanceName != NULL){
                if (pLineStruct->lnPINName != NULL) {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnPINName;
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                } else {
                    szMessageArray[wMessageIndex++] = pLineStruct->lnInstanceName;
                    szMessageArray[wMessageIndex++] = cszSpace;
                }
            } else {
                szMessageArray[wMessageIndex++] = cszSpace;
                szMessageArray[wMessageIndex++] = cszSpace;
            }
            if (!bLargeData) {
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[0].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[0].LowPart;
            } else {  // 8 byte counter values
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[0].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // recent data
                    pLineStruct->lnaCounterValue[0].HighPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[0].LowPart;
                dwMessageData[dwMessageDataBytes++] =       // previous data
                    pLineStruct->lnaOldCounterValue[0].HighPart;
            }
            dwMessageDataBytes *= sizeof(DWORD); // convert index to size
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,      // error type
                0,                          // category (not used)
                (DWORD)PERFMON_ERROR_NEGATIVE_VALUE, // event,
                NULL,                       // SID (not used),
                wMessageIndex,              // number of strings
                dwMessageDataBytes,         // sizeof raw data
                szMessageArray,             // message text array
                (LPVOID)&dwMessageData[0]); // raw data
        }
        eDifference = 0.0f;
    }

    return(eDifference) ;

}

/*****************************************************************************
 * Counter_Null - The counters that return nothing go here.
 ****************************************************************************/
#define Counter_Null(pline)        \
        ((FLOAT) 0.0)


FLOAT
CounterEntry (
    PLINESTRUCT pLine
)
{
    FLOAT fReturn;

#ifdef DBG_COUNTER_DATA
    PLINESTRUCT	pLineStruct = pLine;
    WCHAR    szBuffer[512];
    WCHAR    szBuffer2[512];

    swprintf (szBuffer2, L"\nPERFMON:CALC\t%s\\%s",
	pLineStruct->lnSystemName,
	pLineStruct->lnObjectName);
    lstrcpyW (szBuffer, szBuffer2);

    if (pLineStruct->lnInstanceName != NULL){
        if (pLineStruct->lnPINName != NULL) {
	   swprintf (szBuffer2, L"\\(%s/%s)",
		pLineStruct->lnPINName,
		pLineStruct->lnInstanceName);
        } else {
	   swprintf (szBuffer2, L"\\(%s)",
		pLineStruct->lnInstanceName);
        }
        lstrcatW (szBuffer, szBuffer2);
    }

    swprintf (szBuffer2, L"\\%s\t%u\t%I64u\t%I64u\t%I64u",
	pLineStruct->lnCounterName,
	pLineStruct->lnCounterType,
	pLineStruct->lnNewTime100Ns,
	pLineStruct->lnaCounterValue[0].QuadPart,
	pLineStruct->lnaCounterValue[1].QuadPart);
    lstrcatW (szBuffer, szBuffer2);
	
#endif

    switch (pLine->lnCounterType) {
        case  PERF_COUNTER_COUNTER:
            fReturn = Counter_Counter (pLine);
	    break;

        case  PERF_COUNTER_TIMER:
        case  PERF_PRECISION_SYSTEM_TIMER:  // precision value is not used
            fReturn = Counter_Timer (pLine);
	    break;

        case  PERF_COUNTER_QUEUELEN_TYPE:
            fReturn = Counter_Queuelen(pLine, 0);
	    break;

        case  PERF_COUNTER_LARGE_QUEUELEN_TYPE:
            fReturn = Counter_Queuelen(pLine, CQLFLAGS_LARGE);
	    break;

        case  PERF_COUNTER_100NS_QUEUELEN_TYPE:
            fReturn = Counter_Queuelen(pLine, CQLFLAGS_LARGE | CQLFLAGS_100NS);
	    break;

        case  PERF_COUNTER_BULK_COUNT:
            fReturn = Counter_Bulk (pLine);
	    break;

        case  PERF_COUNTER_RAWCOUNT:
        case  PERF_COUNTER_RAWCOUNT_HEX:
            fReturn = Counter_Rawcount(pLine);
	    break;

        case  PERF_COUNTER_LARGE_RAWCOUNT:
        case  PERF_COUNTER_LARGE_RAWCOUNT_HEX:
            fReturn = Counter_Large_Rawcount(pLine);
	    break;

        case  PERF_SAMPLE_FRACTION:
            fReturn = Sample_Fraction(pLine);
	    break;

        case  PERF_SAMPLE_COUNTER:
            fReturn = Sample_Counter (pLine);
	    break;

        case  PERF_COUNTER_TIMER_INV:
            fReturn = Counter_Timer_Inv (pLine);
	    break;

        case  PERF_AVERAGE_TIMER:
            fReturn = Counter_Average_Timer (pLine);
	    break;

        case  PERF_AVERAGE_BULK:
            fReturn = Counter_Average_Bulk (pLine);
	    break;

        case  PERF_100NSEC_TIMER:
        case  PERF_PRECISION_100NS_TIMER:   // precision value is not used
            fReturn = Counter_Timer100Ns (pLine);
	    break;

        case  PERF_100NSEC_TIMER_INV:
            fReturn = Counter_Timer100Ns_Inv (pLine);
	    break;

        case  PERF_COUNTER_MULTI_TIMER:
            fReturn = Counter_Timer_Multi (pLine);
	    break;

        case  PERF_COUNTER_MULTI_TIMER_INV:
            fReturn = Counter_Timer_Multi_Inv (pLine);
	    break;

        case  PERF_100NSEC_MULTI_TIMER:
            fReturn = Counter_Timer100Ns_Multi (pLine);
	    break;

        case  PERF_100NSEC_MULTI_TIMER_INV:
            fReturn = Counter_Timer100Ns_Multi_Inv (pLine);
	    break;

        case  PERF_RAW_FRACTION:
            fReturn = Counter_Raw_Fraction (pLine, FALSE);
	    break;

        case  PERF_LARGE_RAW_FRACTION:
            fReturn = Counter_Raw_Fraction (pLine, TRUE);
	    break;

        case  PERF_ELAPSED_TIME:
            fReturn = Counter_Elapsed_Time (pLine);
	    break;

        case  PERF_COUNTER_DELTA:
            fReturn = Counter_Delta(pLine, FALSE);
	    break;

        case  PERF_COUNTER_LARGE_DELTA:
            fReturn = Counter_Delta(pLine, TRUE);
	    break;

        case  PERF_COUNTER_TEXT:
        case  PERF_COUNTER_NODATA:
        case  PERF_RAW_BASE:
        case  PERF_LARGE_RAW_BASE:
        case  PERF_COUNTER_MULTI_BASE:
//      case  PERF_SAMPLE_BASE:
//      case  PERF_AVERAGE_BASE:
        default:
            fReturn = Counter_Null (pLine);
	    break;
    }

#ifdef DBG_COUNTER_DATA
    swprintf (szBuffer2, L"\t%g", fReturn);
    lstrcatW (szBuffer, szBuffer2);
    OutputDebugStringW(szBuffer);
#endif
	
    return fReturn;
}


BOOL
IsCounterSupported (
    DWORD dwCounterType
)
{
    switch (dwCounterType) {
// supported counters
        case  PERF_COUNTER_COUNTER:
        case  PERF_COUNTER_TIMER:
        case  PERF_COUNTER_QUEUELEN_TYPE:
        case  PERF_COUNTER_LARGE_QUEUELEN_TYPE:
        case  PERF_COUNTER_100NS_QUEUELEN_TYPE:
        case  PERF_COUNTER_BULK_COUNT:
        case  PERF_COUNTER_RAWCOUNT:
        case  PERF_COUNTER_RAWCOUNT_HEX:
        case  PERF_COUNTER_LARGE_RAWCOUNT:
        case  PERF_COUNTER_LARGE_RAWCOUNT_HEX:
        case  PERF_SAMPLE_FRACTION:
        case  PERF_SAMPLE_COUNTER:
        case  PERF_COUNTER_TIMER_INV:
        case  PERF_AVERAGE_TIMER:
        case  PERF_AVERAGE_BULK:
        case  PERF_100NSEC_TIMER:
        case  PERF_100NSEC_TIMER_INV:
        case  PERF_COUNTER_MULTI_TIMER:
        case  PERF_COUNTER_MULTI_TIMER_INV:
        case  PERF_100NSEC_MULTI_TIMER:
        case  PERF_100NSEC_MULTI_TIMER_INV:
        case  PERF_RAW_FRACTION:
        case  PERF_ELAPSED_TIME:
        case  PERF_COUNTER_DELTA:
        case  PERF_COUNTER_LARGE_DELTA:
        case  PERF_PRECISION_100NS_TIMER:
        case  PERF_PRECISION_SYSTEM_TIMER:
        case  PERF_LARGE_RAW_FRACTION:
            return TRUE;

// unsupported counters
        case  PERF_COUNTER_TEXT:
        case  PERF_COUNTER_NODATA:
        case  PERF_RAW_BASE:
        case  PERF_LARGE_RAW_BASE:
//      case  PERF_SAMPLE_BASE:
//      case  PERF_AVERAGE_BASE:
        case  PERF_COUNTER_MULTI_BASE:
//        case  PERF_PRECISION_TIMESTAMP:
        default:
            return FALSE;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\datasrc.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include "perfmon.h"
#include "datasrc.h"       // External declarations for this file

#include "fileutil.h"      // for FileErrorMessageBox (whatever)
#include "grafdata.h"      // for ResetGraph
#include "alert.h"         // for ResetAlert
#include "log.h"           // for ResetLog
#include "report.h"        // for ResetReport
#include "playback.h"
#include "status.h"
#include "utils.h"
#include "pmhelpid.h"      // Help IDs
#include "fileopen.h"      // FileOpneHookProc
#include "pmemory.h"       // for MemoryAllocate & MemoryFree
#include "perfmops.h"      // for ShowPerfmonWindowText

//==========================================================================//
//                                Local Data                                //
//==========================================================================//


BOOL           bIgnoreFirstChange ;
BOOL           bDataSourceNow ;
BOOL           bDataSourcePrevious ;
BOOL           bLogFileNameChanged ;

LPTSTR           pszLogFilePath ;
LPTSTR           pszLogFileTitle ;
//TCHAR          szLogFilePath [FilePathLen + 1] ;
//TCHAR          szLogFileTitle [FilePathLen + 1] ;


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//



void static UpdateLogName (HDLG hDlg)
   {
   DialogSetString (hDlg, IDD_DATASOURCEFILENAME, pszLogFilePath) ;
//   DialogSetString (hDlg, IDD_DATASOURCEFILENAME, pszLogFileTitle) ;
   }



void OnChangeLog (HWND hWndParent)
   {  // OnChangeLog
   OPENFILENAME   ofn ;
   TCHAR          szOpenLog [WindowCaptionLen + 1] ;
   TCHAR          aszOpenFilter[LongTextLen] ;
   TCHAR          szMyLogFilePath [FilePathLen + 1] ;
   int            StringLength ;
   DWORD          SaveCurrentDlgID = dwCurrentDlgID ;

   //=============================//
   // Get Log File                //
   //=============================//

   aszOpenFilter[0] = 0;
   StringLoad (IDS_OPENLOG, szOpenLog) ;
   StringLoad (IDS_SAVELOGFILEEXT, szMyLogFilePath) ;

   // load the log file extension
   LoadString (hInstance, IDS_SAVELOGFILE, aszOpenFilter,
      sizeof(aszOpenFilter) / sizeof(TCHAR)) ;
   StringLength = lstrlen (aszOpenFilter) + 1 ;
   LoadString (hInstance, IDS_SAVELOGFILEEXT,
      &aszOpenFilter[StringLength],
      sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
   StringLength += lstrlen (&aszOpenFilter[StringLength]) ;

   // setup the end strings
   aszOpenFilter[StringLength+1] = aszOpenFilter[StringLength+2] = TEXT('\0') ;


   ofn.lStructSize = sizeof (OPENFILENAME) ;
   ofn.hwndOwner = hWndParent ;
   ofn.hInstance = hInstance ;
   ofn.lpstrFilter = aszOpenFilter ;
   ofn.lpstrCustomFilter = NULL ;
   ofn.nMaxCustFilter = 0 ;
   ofn.nFilterIndex = 1;
   ofn.lpstrFile = szMyLogFilePath ;
   ofn.nMaxFile = FilePathLen * sizeof (TCHAR) ;
   ofn.lpstrFileTitle = pszLogFileTitle ;
   ofn.nMaxFileTitle = FilePathLen * sizeof (TCHAR) ;
   ofn.lpstrInitialDir = NULL ;
   ofn.lpstrTitle = szOpenLog ;
   ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
//               OFN_PATHMUSTEXIST | OFN_SHOWHELP  | OFN_ENABLEHOOK ;
               OFN_PATHMUSTEXIST | OFN_ENABLEHOOK | OFN_EXPLORER;
   ofn.lCustData = 0L ;
   ofn.lpfnHook = (LPOFNHOOKPROC) FileOpenHookProc ;
   ofn.lpstrDefExt = (LPTSTR)NULL;

   dwCurrentDlgID  = HC_PM_idDlgOptionOpenLogFile ;
   if (GetOpenFileName (&ofn))
      {
      if (!strsame(pszLogFilePath, szMyLogFilePath))
         {
         INT_PTR FileNameOffset ;
         LPTSTR pFileName ;

         bLogFileNameChanged |= TRUE ;
         lstrcpy (pszLogFilePath, szMyLogFilePath) ;
         lstrcpy (pszLogFileTitle, ofn.lpstrFileTitle) ;

         pFileName = ExtractFileName (szMyLogFilePath) ;
         if (pFileName != szMyLogFilePath)
            {
            FileNameOffset = pFileName - szMyLogFilePath ;
            szMyLogFilePath[FileNameOffset] = TEXT('\0') ;
            SetCurrentDirectory (szMyLogFilePath) ;
            }
         UpdateLogName (hWndParent) ;
         }
      }

   // restore the global before exit
   dwCurrentDlgID  = SaveCurrentDlgID ;
   }  // OnChangeLog


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void static OnInitDialog (HDLG hDlg)
   {
   bLogFileNameChanged = FALSE ;

   bIgnoreFirstChange = TRUE ;

   bDataSourcePrevious = bDataSourceNow = !PlayingBackLog () ;

   CheckRadioButton (hDlg, IDD_DATASOURCENOW, IDD_DATASOURCEFILE,
                     bDataSourceNow ? IDD_DATASOURCENOW : IDD_DATASOURCEFILE) ;
   UpdateLogName (hDlg) ;

   EditSetLimit (GetDlgItem(hDlg, IDD_DATASOURCEFILENAME),
      FilePathLen - 1) ;

   WindowCenter (hDlg) ;

   dwCurrentDlgID = HC_PM_idDlgOptionDataFrom ;
   }


void /*static*/ OnDataSourceOK (HDLG hDlg)
   {  // OnOK
   BOOL     bHaveResetPerfmon ;
   INT      RetCode = 0 ;

   bHaveResetPerfmon = FALSE;
   if (!BoolEqual (bDataSourceNow, bDataSourcePrevious) ||
       (bLogFileNameChanged && !bDataSourceNow) )
      {
      if (PlayingBackLog () && bDataSourceNow | bLogFileNameChanged)
         {
         CloseInputLog (hWndMain) ;
         bHaveResetPerfmon = TRUE ;
         }

      if (!bDataSourceNow)
         {
         if (!bHaveResetPerfmon)
            {
            ResetGraphView (hWndGraph) ;
            ResetAlertView (hWndAlert) ;
            ResetLogView (hWndLog) ;
            ResetReportView (hWndReport) ;

            if (pWorkSpaceFullFileName)
               {
               MemoryFree (pWorkSpaceFullFileName) ;
               pWorkSpaceFileName = NULL ;
               pWorkSpaceFullFileName = NULL ;
               }
            ShowPerfmonWindowText () ;
            }

         GetDlgItemText (hDlg, IDD_DATASOURCEFILENAME,
            pszLogFilePath, FilePathLen - 1) ;
         lstrcpy (pszLogFileTitle, pszLogFilePath);

         if (RetCode = OpenPlayback (pszLogFilePath, pszLogFileTitle))
            {
            DlgErrorBox (hDlg, RetCode, pszLogFileTitle) ;
            }
         }

      StatusLineReady (hWndStatus) ;
      }

   if (!BoolEqual (bDataSourceNow, bDataSourcePrevious))
      {
      if (bDataSourceNow)
         {
         // Set Priority high
         SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS) ;
         SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST) ;
         }
      else
         {
         // Use a lower priority for Playing back log
         SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS) ;
         SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL) ;
         }
      }

   if (RetCode == 0)
      {
      EndDialog (hDlg, 1) ;
      }
   }  // OnOK



//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


INT_PTR
FAR
WINAPI
DataSourceDlgProc (
                   HWND hDlg,
                   unsigned iMessage,
                   WPARAM wParam,
                   LPARAM lParam
                   )
{
   BOOL           bHandled ;

   bHandled = TRUE ;
   switch (iMessage)
      {
      case WM_INITDIALOG:
         OnInitDialog (hDlg) ;
         return  (TRUE) ;

      case WM_CLOSE:
         EndDialog (hDlg, 0) ;
         break ;

      case WM_DESTROY:
         dwCurrentDlgID = 0 ;
         break;

      case WM_COMMAND:
         switch(LOWORD(wParam))
            {
            case IDD_DATASOURCEFILENAME:
               if (bIgnoreFirstChange)
                  {
                  bIgnoreFirstChange = FALSE;
                  }

               else if (HIWORD(wParam) == EN_UPDATE && !bLogFileNameChanged)
                  {
                  bLogFileNameChanged = TRUE;
                  CheckRadioButton (hDlg,
                                  IDD_DATASOURCENOW,
                                  IDD_DATASOURCEFILE,
                                  IDD_DATASOURCEFILE) ;
                  bDataSourceNow = FALSE ;
                  }
               break ;

            case IDD_DATASOURCECHANGEFILE:
               OnChangeLog (hDlg) ;
               if (bLogFileNameChanged)
                  {
                  CheckRadioButton (hDlg,
                                    IDD_DATASOURCENOW,
                                    IDD_DATASOURCEFILE,
                                    IDD_DATASOURCEFILE) ;
                  bDataSourceNow = FALSE ;
                  }
               break ;

            case IDD_DATASOURCEFILE:
               bDataSourceNow = FALSE ;
               break ;

            case IDD_DATASOURCENOW:
               bDataSourceNow = TRUE ;
               break ;

            case IDD_OK:
               OnDataSourceOK (hDlg) ;
               break ;

            case IDD_CANCEL:
               EndDialog (hDlg, 0) ;
               break ;

            case IDD_DATASOURCEHELP:
               CallWinHelp (dwCurrentDlgID, hDlg) ;
               break ;

            default:
               bHandled = FALSE ;
               break;
            }
         break;


      default:
            bHandled = FALSE ;
         break ;
      }  // switch

   return (bHandled) ;
   }  // DataSourceDlgProc



BOOL
DisplayDataSourceOptions (
                          HWND hWndParent
                          )
/*
   Effect:        Put up Perfmon's Data Source Options Display dialog,
                  which allows
                  the user to select the source of data input: real
                  time or log file.
*/
{  // DisplayDisplayOptions
   BOOL     retCode ;

   pszLogFilePath  = (LPTSTR) MemoryAllocate (FilePathLen * sizeof(TCHAR)) ;
   if (pszLogFilePath == NULL)
      return FALSE;
   pszLogFileTitle = (LPTSTR) MemoryAllocate (FilePathLen * sizeof(TCHAR)) ;
   if (pszLogFileTitle == NULL) {
      MemoryFree(pszLogFilePath);
      return FALSE;
   }

   lstrcpy (pszLogFilePath, PlaybackLog.szFilePath) ;
   lstrcpy (pszLogFileTitle, PlaybackLog.szFileTitle) ;

   retCode = DialogBox (hInstance, idDlgDataSource, hWndParent, DataSourceDlgProc) ? TRUE : FALSE;

   MemoryFree (pszLogFilePath) ;
   MemoryFree (pszLogFileTitle) ;

   return (retCode) ;

}  // DisplayDisplayOptions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\dialogs.c ===
/*****************************************************************************
 *
 *  Dialogs.c - This module handles the Menu and Dialog user interactions.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 ****************************************************************************/

#include <stdio.h>
#include <wchar.h>   // for swscanf

#include "perfmon.h"
#include "perfmops.h"      // for ConvertDecimalPoint

#include "alert.h"     // for SetAlertTimer, AlertData
#include "graph.h"
#include "cderr.h"
#include "utils.h"
#include "playback.h"  // for PlayingBackLog
#include "grafdisp.h"  // for ToggleGraphRefresh
#include "pmhelpid.h"  // Help IDs

BOOL          LocalManualRefresh ;

INT_PTR
GraphOptionDlg(
              HWND hDlg,
              UINT msg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    static GRAPH_OPTIONS goLocalCopy ;

    INT            iTimeMilliseconds ;
    TCHAR          szBuff[MiscTextLen] ;
    PGRAPHSTRUCT   lgraph;

    lParam ;
    lgraph = pGraphs;

    switch (msg) {

        case WM_INITDIALOG:

            dwCurrentDlgID = HC_PM_idDlgOptionChart ;

            // Init the Radio button, Check boxes and text fields.

            goLocalCopy.iGraphOrHistogram =
            lgraph->gOptions.iGraphOrHistogram ;
            if (lgraph->gOptions.iGraphOrHistogram == LINE_GRAPH)
                CheckRadioButton(hDlg, ID_GRAPH, ID_HISTOGRAM, ID_GRAPH) ;
            else
                CheckRadioButton(hDlg, ID_GRAPH, ID_HISTOGRAM, ID_HISTOGRAM) ;

            CheckDlgButton(hDlg, ID_LEGEND, lgraph->gOptions.bLegendChecked) ;
            if (!(lgraph->gOptions.bLegendChecked)) {
                // can't display valuebar w/o legend
                DialogEnable (hDlg, IDD_CHARTOPTIONSVALUEBAR, FALSE) ;
            }

            CheckDlgButton(hDlg, ID_LABELS, lgraph->gOptions.bLabelsChecked) ;
            CheckDlgButton(hDlg, ID_VERT_GRID, lgraph->gOptions.bVertGridChecked) ;
            CheckDlgButton(hDlg, ID_HORZ_GRID, lgraph->gOptions.bHorzGridChecked) ;
            CheckDlgButton(hDlg, IDD_CHARTOPTIONSVALUEBAR,
                           lgraph->gOptions.bStatusBarChecked) ;

            TSPRINTF(szBuff, TEXT("%d"), lgraph->gOptions.iVertMax) ;
            SendDlgItemMessage(hDlg, ID_VERT_MAX, WM_SETTEXT, 0, (LONG_PTR) szBuff) ;

            TSPRINTF(szBuff, TEXT("%3.3f"), lgraph->gOptions.eTimeInterval) ;
            ConvertDecimalPoint (szBuff) ;
            SendDlgItemMessage(hDlg, IDD_CHARTOPTIONSINTERVAL, WM_SETTEXT, 0, (LONG_PTR) szBuff) ;

            // Pickup a local copy of the Graph Options.

            goLocalCopy = lgraph->gOptions ;
            LocalManualRefresh = lgraph->bManualRefresh ;

            if (PlayingBackLog()) {
                DialogEnable (hDlg, IDD_CHARTOPTIONSPERIODIC, FALSE) ;
                DialogEnable (hDlg, IDD_CHARTOPTIONSUPDATETEXT, FALSE) ;
                DialogEnable (hDlg, IDD_CHARTOPTIONSMANUALREFRESH, FALSE) ;
            } else {
                CheckRadioButton (hDlg,
                                  IDD_CHARTOPTIONSMANUALREFRESH,
                                  IDD_CHARTOPTIONSPERIODIC,
                                  LocalManualRefresh ? IDD_CHARTOPTIONSMANUALREFRESH :
                                  IDD_CHARTOPTIONSPERIODIC) ;
            }

            if (lgraph->bManualRefresh || PlayingBackLog()) {
                DialogEnable (hDlg, IDD_CHARTOPTIONSINTERVALTEXT, FALSE) ;
                DialogEnable (hDlg, IDD_CHARTOPTIONSINTERVAL, FALSE) ;
            } else {
                DialogEnable (hDlg, IDD_CHARTOPTIONSINTERVALTEXT, TRUE) ;
                DialogEnable (hDlg, IDD_CHARTOPTIONSINTERVAL, TRUE) ;
            }

            EditSetLimit (GetDlgItem(hDlg, ID_VERT_MAX),
                          sizeof(szBuff) / sizeof(TCHAR) - 1) ;

            EditSetLimit (GetDlgItem(hDlg, IDD_CHARTOPTIONSINTERVAL),
                          ShortTextLen) ;

            WindowCenter (hDlg) ;
            return(TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case ID_VERT_MAX:
                    if (HIWORD(wParam) == EN_CHANGE) {
                        DialogText(hDlg, ID_VERT_MAX, szBuff) ;
                        swscanf(szBuff, TEXT("%d"), &goLocalCopy.iVertMax) ;
                    }
                    break ;


                case IDD_CHARTOPTIONSINTERVAL:
                    if (HIWORD(wParam) == EN_CHANGE) {
                        goLocalCopy.eTimeInterval =
                        DialogFloat (hDlg, IDD_CHARTOPTIONSINTERVAL, NULL) ;
                    }
                    break ;

                case IDD_CHARTOPTIONSPERIODIC:
                case IDD_CHARTOPTIONSMANUALREFRESH:
                    // check if the Manual refresh is currently checked.
                    // Then toggle the ManualRefresh button
                    LocalManualRefresh =
                    (LOWORD(wParam) == IDD_CHARTOPTIONSMANUALREFRESH) ;

                    CheckRadioButton (hDlg,
                                      IDD_CHARTOPTIONSMANUALREFRESH,
                                      IDD_CHARTOPTIONSPERIODIC,
                                      LocalManualRefresh ? IDD_CHARTOPTIONSMANUALREFRESH :
                                      IDD_CHARTOPTIONSPERIODIC) ;

                    // gray out time interval if necessary...
                    DialogEnable (hDlg, IDD_CHARTOPTIONSINTERVALTEXT,
                                  !LocalManualRefresh) ;
                    DialogEnable (hDlg, IDD_CHARTOPTIONSINTERVAL,
                                  !LocalManualRefresh) ;
                    break ;

                case IDD_CHARTOPTIONSVALUEBAR:
                    if (goLocalCopy.bStatusBarChecked == TRUE)
                        goLocalCopy.bStatusBarChecked = FALSE ;
                    else
                        goLocalCopy.bStatusBarChecked = TRUE ;
                    break ;


                case ID_LEGEND:
                    if (goLocalCopy.bLegendChecked == TRUE)
                        goLocalCopy.bLegendChecked = FALSE ;
                    else
                        goLocalCopy.bLegendChecked = TRUE ;

                    DialogEnable (hDlg, IDD_CHARTOPTIONSVALUEBAR,
                                  goLocalCopy.bLegendChecked) ;

                    break ;


                case ID_LABELS:
                    if (goLocalCopy.bLabelsChecked == TRUE)
                        goLocalCopy.bLabelsChecked = FALSE ;
                    else
                        goLocalCopy.bLabelsChecked = TRUE ;
                    break ;


                case ID_VERT_GRID:
                    if (goLocalCopy.bVertGridChecked == TRUE)
                        goLocalCopy.bVertGridChecked = FALSE ;
                    else
                        goLocalCopy.bVertGridChecked = TRUE ;
                    break ;


                case ID_HORZ_GRID:
                    if (goLocalCopy.bHorzGridChecked == TRUE)
                        goLocalCopy.bHorzGridChecked = FALSE ;
                    else
                        goLocalCopy.bHorzGridChecked = TRUE ;
                    break ;


                case ID_GRAPH:
                case ID_HISTOGRAM:
                    if (LOWORD(wParam) == ID_GRAPH) {
                        goLocalCopy.iGraphOrHistogram = LINE_GRAPH ;
                    } else {
                        goLocalCopy.iGraphOrHistogram = BAR_GRAPH ;
                    }
                    CheckRadioButton(hDlg, ID_GRAPH, ID_HISTOGRAM,
                                     goLocalCopy.iGraphOrHistogram == LINE_GRAPH ?
                                     ID_GRAPH : ID_HISTOGRAM) ;

                    break ;

                case IDOK:
                    //  verify some numeric entries first
                    if (goLocalCopy.iVertMax > MAX_VERTICAL ||
                        goLocalCopy.iVertMax < MIN_VERTICAL) {
                        DlgErrorBox (hDlg, ERR_BADVERTMAX) ;
                        SetFocus (DialogControl (hDlg, ID_VERT_MAX)) ;
                        EditSetTextEndPos (hDlg, ID_VERT_MAX) ;
                        return (FALSE) ;
                        break ;
                    }
                    if (goLocalCopy.eTimeInterval > MAX_INTERVALSEC ||
                        goLocalCopy.eTimeInterval < MIN_INTERVALSEC) {
                        DlgErrorBox (hDlg, ERR_BADTIMEINTERVAL) ;
                        SetFocus (DialogControl (hDlg, IDD_CHARTOPTIONSINTERVAL)) ;
                        EditSetTextEndPos (hDlg, IDD_CHARTOPTIONSINTERVAL) ;
                        return (FALSE) ;
                        break ;
                    }

                    // We need to send a size message to the main window
                    // so it can setup the redraw of the graph and legend.

                    lgraph->gOptions.bLegendChecked    = goLocalCopy.bLegendChecked ;
                    lgraph->gOptions.bStatusBarChecked = goLocalCopy.bStatusBarChecked ;

                    if (lgraph->gOptions.eTimeInterval != goLocalCopy.eTimeInterval
                        && !LocalManualRefresh) {
                        iTimeMilliseconds = (INT) (goLocalCopy.eTimeInterval * (FLOAT) 1000.0) ;
                        pGraphs->gInterval = iTimeMilliseconds ;
                        if (!PlayingBackLog()) {
                            SetGraphTimer(pGraphs) ;
                        }
                        lgraph->bManualRefresh = LocalManualRefresh ;

                    } else if (LocalManualRefresh != lgraph->bManualRefresh) {
                        ToggleGraphRefresh (hWndGraph) ;
                    }
                    // Assign the local copy of the graph options to the
                    // global copy.

                    lgraph->gOptions = goLocalCopy ;

                    SizeGraphComponents (hWndGraph) ;
                    WindowInvalidate (hWndGraph) ;
                    dwCurrentDlgID = 0 ;
                    EndDialog (hDlg, 1) ;
                    return (TRUE) ;
                    break ;


                case IDCANCEL:
                    dwCurrentDlgID = 0 ;
                    EndDialog(hDlg,0);
                    return(TRUE);

                case ID_HELP:
                    CallWinHelp (dwCurrentDlgID, hDlg) ;
                    break ;

                default:
                    break;
            }
            break;

        default:
            break;

    }
    return(FALSE);
}


DWORD          iIntervalMSecs ;

void
static
OnAlertOptionDlgInit (
                     HWND hDlg,
                     PALERT pAlert
                     )
{
    BOOL           EnableFlag ;

    iIntervalMSecs = pAlert->iIntervalMSecs ;

    LocalManualRefresh = pAlert->bManualRefresh ;

    if (PlayingBackLog()) {
        // When playingback log, disable all controls except
        // the alert interval
        //
        EnableFlag = TRUE ;
        DialogEnable (hDlg, IDD_ALERTOPTIONSMANUALREFRESH, FALSE) ;
        DialogEnable (hDlg, IDD_ALERTOPTIONSPOPUP, FALSE) ;
        DialogEnable (hDlg, IDD_ALERTOPTIONSNETWORKALERT, FALSE) ;
        DialogEnable (hDlg, IDD_ALERTOPTIONSNETGROUPTEXT, FALSE) ;
        DialogEnable (hDlg, IDD_ALERTOPTIONSMSGNAME, FALSE) ;
        DialogEnable (hDlg, IDD_ALERTOPTIONSMSGNAMETEXT, FALSE) ;
    } else {
        EnableFlag = !LocalManualRefresh ;
        DialogEnable (hDlg, IDD_ALERTOPTIONSMSGNAME, pAlert->bNetworkAlert) ;
        DialogEnable (hDlg, IDD_ALERTOPTIONSMSGNAMETEXT, pAlert->bNetworkAlert) ;
    }

    // setup the Update time interval group items
    DialogSetInterval (hDlg, IDD_ALERTOPTIONSINTERVAL, iIntervalMSecs) ;
    DialogEnable (hDlg, IDD_ALERTOPTIONSINTERVAL, EnableFlag) ;
    DialogEnable (hDlg, IDD_ALERTOPTIONSINTERVALTEXT, EnableFlag) ;
    CheckRadioButton(hDlg, IDD_ALERTOPTIONSMANUALREFRESH,
                     IDD_ALERTOPTIONSPERIODIC,
                     !EnableFlag ? IDD_ALERTOPTIONSMANUALREFRESH : IDD_ALERTOPTIONSPERIODIC) ;

    CheckDlgButton (hDlg, IDD_ALERTOPTIONSEVENTLOG, pAlert->bEventLog) ;
    CheckDlgButton (hDlg, IDD_ALERTOPTIONSPOPUP, pAlert->bSwitchToAlert) ;
    CheckDlgButton (hDlg, IDD_ALERTOPTIONSNETWORKALERT, pAlert->bNetworkAlert) ;

    if (pAlert->MessageName[0]) {
        DialogSetString (hDlg, IDD_ALERTOPTIONSMSGNAME, pAlert->MessageName) ;
    }

    EditSetLimit (GetDlgItem(hDlg, IDD_ALERTOPTIONSMSGNAME),
                  sizeof(pAlert->MessageName)/sizeof(TCHAR) - 1) ;

    dwCurrentDlgID = HC_PM_idDlgOptionAlert ;

    WindowCenter (hDlg) ;

}

INT_PTR
AlertOptionDlg (
               HWND hDlg,
               UINT msg,
               WPARAM wParam,
               LPARAM lParam
               )
{
    PALERT         pAlert ;

    switch (msg) {

        case WM_INITDIALOG:
            pAlert = (PALERT) lParam ;
            OnAlertOptionDlgInit (hDlg, pAlert) ;
            return(TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    {
                        FLOAT eTimeInterval ;

                        pAlert = AlertData (hWndAlert) ;

                        eTimeInterval = DialogFloat (hDlg, IDD_ALERTOPTIONSINTERVAL, NULL) ;

                        if (eTimeInterval > MAX_INTERVALSEC ||
                            eTimeInterval < MIN_INTERVALSEC) {
                            DlgErrorBox (hDlg, ERR_BADTIMEINTERVAL) ;
                            SetFocus (DialogControl (hDlg, IDD_ALERTOPTIONSINTERVAL)) ;
                            EditSetTextEndPos (hDlg, IDD_ALERTOPTIONSINTERVAL) ;
                            return (FALSE) ;
                            break ;
                        }

                        eTimeInterval = eTimeInterval * (FLOAT) 1000.0 +
                                        (FLOAT) 0.5 ;

                        iIntervalMSecs = (DWORD) eTimeInterval ;

                        pAlert->bNetworkAlert =
                        IsDlgButtonChecked (hDlg, IDD_ALERTOPTIONSNETWORKALERT) ;

                        pAlert->bSwitchToAlert =
                        IsDlgButtonChecked (hDlg, IDD_ALERTOPTIONSPOPUP) ;

                        pAlert->bEventLog =
                        IsDlgButtonChecked (hDlg, IDD_ALERTOPTIONSEVENTLOG) ;



                        if (!PlayingBackLog()) {
                            DialogText (hDlg,
                                        IDD_ALERTOPTIONSMSGNAME,
                                        pAlert->MessageName) ;
                        }

                        dwCurrentDlgID = 0 ;
                        EndDialog (hDlg, 1) ;
                    }
                    break ;

                case IDCANCEL:
                    dwCurrentDlgID = 0 ;
                    EndDialog(hDlg,0);
                    return(TRUE);

                case IDD_ALERTOPTIONSPERIODIC:
                case IDD_ALERTOPTIONSMANUALREFRESH:

                    if (!PlayingBackLog()) {
                        // check if the Manual refresh is currently checked.
                        // Then toggle the ManualRefresh button
                        LocalManualRefresh =
                        (LOWORD(wParam) == IDD_ALERTOPTIONSMANUALREFRESH) ;

                        CheckRadioButton(hDlg,
                                         IDD_ALERTOPTIONSMANUALREFRESH,
                                         IDD_ALERTOPTIONSPERIODIC,
                                         LocalManualRefresh ? IDD_ALERTOPTIONSMANUALREFRESH :
                                         IDD_ALERTOPTIONSPERIODIC) ;

                        DialogEnable (hDlg,
                                      IDD_ALERTOPTIONSINTERVAL,
                                      !LocalManualRefresh) ;

                        DialogEnable (hDlg,
                                      IDD_ALERTOPTIONSINTERVALTEXT,
                                      !LocalManualRefresh) ;
                    }

                    break ;
#if 0
                case IDD_ALERTOPTIONSPOPUP:
                    bSwitchToAlert = !bSwitchToAlert ;
                    CheckDlgButton (hDlg, IDD_ALERTOPTIONSPOPUP, bSwitchToAlert) ;
                    break;
#endif

                case IDD_ALERTOPTIONSNETWORKALERT:
                    {
                        BOOL  bNetworkAlert ;

                        bNetworkAlert =
                        IsDlgButtonChecked (hDlg, IDD_ALERTOPTIONSNETWORKALERT) ;

                        DialogEnable (hDlg, IDD_ALERTOPTIONSMSGNAME, bNetworkAlert) ;
                        DialogEnable (hDlg, IDD_ALERTOPTIONSMSGNAMETEXT, bNetworkAlert) ;

                        if (bNetworkAlert) {
                            SetFocus (GetDlgItem(hDlg, IDD_ALERTOPTIONSMSGNAME)) ;
                            SendDlgItemMessage(hDlg, IDD_ALERTOPTIONSMSGNAME,
                                               EM_SETSEL, 0, 16) ;
                        }
                    }
                    break;

                case IDD_DISPLAYHELP:
                    CallWinHelp (dwCurrentDlgID, hDlg) ;
                    break ;

                default:
                    break;
            }
            break;


        default:
            break;

    }

    return (FALSE);
}


BOOL
DisplayAlertOptions (
                    HWND hWndParent,
                    HWND hWndAlert
                    )
{
    PALERT        pAlert ;

    pAlert = AlertData (hWndParent) ;

    if (DialogBoxParam (hInstance, idDlgAlertOptions, hWndParent, AlertOptionDlg, (LPARAM) pAlert)) {
        if (pAlert->bNetworkAlert && pAlert->hNetAlertThread == 0) {
            AlertCreateThread (pAlert) ;
        }

        if (PlayingBackLog()) {
            if (pAlert->iIntervalMSecs != iIntervalMSecs) {
                // a new time interval, re-do the backing back log
                // using the new value...
                pAlert->iIntervalMSecs = iIntervalMSecs ;
                DialogSetInterval (hWndAlert, IDD_ALERTINTERVAL, iIntervalMSecs) ;
                if (pAlert->pLineFirst) {
                    PlaybackAlert (hWndAlert, 0) ;
                    WindowInvalidate (hWndAlert) ;
                }
            }
        } else if (LocalManualRefresh != pAlert->bManualRefresh) {
            if (!LocalManualRefresh) {
                pAlert->iIntervalMSecs = iIntervalMSecs ;
                DialogSetInterval (hWndAlert, IDD_ALERTINTERVAL, iIntervalMSecs) ;
            }
            ToggleAlertRefresh (hWndAlert) ;
        } else if (!LocalManualRefresh) {
            pAlert->iIntervalMSecs = iIntervalMSecs ;
            SetAlertTimer (pAlert) ;
            DialogSetInterval (hWndAlert, IDD_ALERTINTERVAL, iIntervalMSecs) ;
        }
    }

    return (TRUE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\export.c ===
#include "perfmon.h"
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmwksta.h>
// #include <uiexport.h>
#include <stdio.h>         // for sprintf
#include "utils.h"

#include "perfmops.h"      // for SystemTimeDateString
#include "fileopen.h"      // for FileGetName
#include "fileutil.h"      // for FileRead etc
#include "playback.h"      // for PlayingBackLog & LogPositionSystemTime
#include "dlgs.h"          // common dialog control IDs
#include "pmhelpid.h"      // Help IDs


// This routine opens the export file and put in the header info.
// It is used by ExportChart, ExportAlert, & ExportReport.
INT
ExportFileOpen (
               HWND hWnd,
               HANDLE *phFile,
               int IntervalMSecs,
               LPTSTR *ppFileName
               )
{
    CHAR           TempBuff [LongTextLen*2] ;        // The maximum number of bytes that can be stored in the multibyte output string  is twice as the number of wide-charcter string.
    TCHAR          UnicodeBuff [LongTextLen] ;
    TCHAR          UnicodeBuff1 [MiscTextLen] ;
    SYSTEMTIME     SystemTime ;
    int            StringLen ;
    INT            ErrCode = 0 ;
    FLOAT          eIntervalSecs ;
    HANDLE         hFile;

    // defined and setup in status.c
    extern TCHAR   szCurrentActivity [] ;
    extern TCHAR   szStatusFormat [] ;

    if (phFile == NULL)
        ErrCode = ERR_EXPORT_FILE;
    *phFile = 0 ;

    if (!FileGetName (hWnd, IDS_EXPORTFILE, UnicodeBuff)) {
        // user cancel
        goto Exit0 ;
    }

    *ppFileName = StringAllocate (UnicodeBuff) ;

    // open the file..
    hFile = FileHandleCreate (UnicodeBuff);
    if (!hFile || hFile == INVALID_HANDLE_VALUE) {
        // can't open the file
        ErrCode = ERR_CANT_OPEN ;
        goto Exit0 ;
    }

    *phFile = hFile;
    // export header
    StringLoad (IDS_REPORT_HEADER, UnicodeBuff) ;
    ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
    StringLen = strlen (TempBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], LocalComputerName) ;
    strcat (TempBuff, LineEndStr) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        ErrCode = ERR_EXPORT_FILE ;
        goto Exit0 ;
    }

    // export today's date time
    GetLocalTime (&SystemTime) ;

    StringLoad (IDS_EXPORT_DATE, UnicodeBuff) ;
    StringLen = lstrlen (UnicodeBuff) ;
    UnicodeBuff[StringLen] = TEXT(':') ;
    UnicodeBuff[StringLen+1] = TEXT(' ') ;
    SystemTimeDateString (&SystemTime, &UnicodeBuff[StringLen+2]) ;
    ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
    strcat (TempBuff, LineEndStr) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        ErrCode = ERR_EXPORT_FILE ;
        goto Exit0 ;
    }

    StringLoad (IDS_EXPORT_TIME, UnicodeBuff) ;
    StringLen = lstrlen (UnicodeBuff) ;
    UnicodeBuff[StringLen] = TEXT(':') ;
    UnicodeBuff[StringLen+1] = TEXT(' ') ;
    SystemTimeTimeString (&SystemTime, &UnicodeBuff[StringLen+2], FALSE) ;
    ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
    strcat (TempBuff, LineEndStr) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        ErrCode = ERR_EXPORT_FILE ;
        goto Exit0 ;
    }

    // export data source
    TSPRINTF (UnicodeBuff, szStatusFormat,
              PlayingBackLog () ?
              PlaybackLog.szFileTitle : szCurrentActivity) ;
    ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
    strcat (TempBuff, LineEndStr) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        ErrCode = ERR_EXPORT_FILE ;
        goto Exit0 ;
    }

    if (!PlayingBackLog()) {

        eIntervalSecs = (FLOAT)IntervalMSecs / (FLOAT) 1000.0 ;
        StringLoad (IDS_CHARTINT_FORMAT, UnicodeBuff1) ;
        TSPRINTF (UnicodeBuff, UnicodeBuff1, eIntervalSecs) ;
        ConvertDecimalPoint (UnicodeBuff) ;
        ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
        strcat (TempBuff, LineEndStr) ;

        if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {

            ErrCode = ERR_EXPORT_FILE ;
            goto Exit0 ;
        }
    } else {
        // export the log start and stop date/time
        StringLoad (IDS_START_TEXT, UnicodeBuff) ;
        StringLen = lstrlen (UnicodeBuff) ;
        LogPositionSystemTime (&(PlaybackLog.StartIndexPos), &SystemTime) ;
        SystemTimeDateString (&SystemTime, &UnicodeBuff[StringLen]) ;
        StringLen = lstrlen (UnicodeBuff) ;
        UnicodeBuff[StringLen] = TEXT(' ') ;
        StringLen++ ;
        SystemTimeTimeString (&SystemTime, &UnicodeBuff[StringLen], FALSE) ;
        ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
        strcat (TempBuff, LineEndStr) ;

        if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {

            ErrCode = ERR_EXPORT_FILE ;
            goto Exit0 ;
        }

        StringLoad (IDS_STOP_TEXT, UnicodeBuff) ;
        StringLen = lstrlen (UnicodeBuff) ;
        LogPositionSystemTime (&(PlaybackLog.StopIndexPos), &SystemTime) ;
        SystemTimeDateString (&SystemTime, &UnicodeBuff[StringLen]) ;
        StringLen = lstrlen (UnicodeBuff) ;
        UnicodeBuff[StringLen] = TEXT(' ') ;
        StringLen++ ;
        SystemTimeTimeString (&SystemTime, &UnicodeBuff[StringLen], FALSE) ;
        ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
        strcat (TempBuff, LineEndStr) ;

        if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
            ErrCode = ERR_EXPORT_FILE ;
            goto Exit0 ;
        }

        if (hWnd == hWndAlert) {
            eIntervalSecs = (FLOAT)IntervalMSecs / (FLOAT) 1000.0 ;
            StringLoad (IDS_CHARTINT_FORMAT, UnicodeBuff1) ;
            TSPRINTF (UnicodeBuff, UnicodeBuff1, eIntervalSecs) ;
            ConvertDecimalPoint (UnicodeBuff) ;
            ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
            strcat (TempBuff, LineEndStr) ;

            if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
                ErrCode = ERR_EXPORT_FILE ;
                goto Exit0 ;
            }
        }

    }

    return (0) ;

    Exit0:

    return (ErrCode) ;

}  // ExportFileOpen



BOOL
APIENTRY
ExportOptionsHookProc (
                      HWND hDlg,
                      UINT iMessage,
                      WPARAM wParam,
                      LPARAM lParam
                      )

{
    BOOL           bHandled ;

    bHandled = TRUE ;
    switch (iMessage) {
        case WM_INITDIALOG:
            CheckRadioButton (hDlg, IDD_EXPORTCOMMAS, IDD_EXPORTTAB,
                              pDelimiter == TabStr ? IDD_EXPORTTAB : IDD_EXPORTCOMMAS ) ;

            WindowCenter (hDlg) ;
            break ;

#if WINVER >= 0x0400
        case WM_NOTIFY:
            {
                LPOFNOTIFY  pOfn;
                pOfn = (LPOFNOTIFY)lParam;

                switch (pOfn->hdr.code) {
                    case CDN_INITDONE:
                        WindowCenter (pOfn->hdr.hwndFrom) ;
                        break;

                    case CDN_FILEOK:
                        {
                            INT_PTR iFileIndex ;
                            HWND  hWndCBox;

                            hWndCBox = GetDlgItem (pOfn->hdr.hwndFrom, cmb1); // Type combo box
                            iFileIndex = CBSelection (hWndCBox) ;
                            // the order of the entries in the combo box depends on
                            // the current delimiter character
                            if (pDelimiter == TabStr) {
                                pDelimiter = iFileIndex == 0 ? // 0 = TSV, 1=CSV
                                             TabStr : CommasStr;
                            } else {
                                pDelimiter = iFileIndex == 0 ? // 0 = TSV, 1=CSV
                                             CommasStr : TabStr;
                            }
                        }
                        break;

                    default:
                        break;
                }

            }
            break;

#endif

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDD_EXPORTCOMMAS:
                case IDD_EXPORTTAB:
                    // toggle between the 2 radio buttons..
                    CheckRadioButton (hDlg, IDD_EXPORTCOMMAS, IDD_EXPORTTAB,
                                      LOWORD(wParam) == IDD_EXPORTTAB ?
                                      IDD_EXPORTTAB : IDD_EXPORTCOMMAS ) ;
                    break ;

                case IDD_OK:
                    pDelimiter = IsDlgButtonChecked (hDlg, IDD_EXPORTCOMMAS) ?
                                 CommasStr : TabStr ;
                    bHandled = FALSE ;

                    break ;

                case IDD_EXPORTHELP:
                    CallWinHelp (dwCurrentDlgID, hDlg) ;
                    break ;

                case cmb1:
                    if (HIWORD (wParam) == CBN_SELCHANGE) {
                        INT_PTR  iFileIndex ;
                        HWND  hWndCBox = (HWND) lParam ;

                        // a diff. selection from the file type, change
                        // the delimiter accordingly.
                        iFileIndex = CBSelection (hWndCBox) ;
                        CheckRadioButton (hDlg, IDD_EXPORTCOMMAS, IDD_EXPORTTAB,
                                          iFileIndex == 0 ?
                                          IDD_EXPORTTAB : IDD_EXPORTCOMMAS ) ;

                    } else {
                        bHandled = FALSE ;
                    }
                    break ;

                default:
                    bHandled = FALSE ;
            }
            break;

        default:
            bHandled = FALSE ;
            break;
    }

    return (bHandled) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\dispoptn.h ===
//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//



BOOL DisplayDisplayOptions (HWND hWndParent) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\dialogs.h ===
//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


INT_PTR
GraphOptionDlg(
               HWND hDlg,
               UINT msg,
               WPARAM wParam,
               LPARAM lParam
               );

INT_PTR
BookmarkDlg(
            HWND hDlg,
            UINT msg,
            WPARAM wParam,
            LPARAM lParam
            );

INT_PTR
AboutDlg(
         HWND hDlg,
         UINT msg,
         WPARAM wParam,
         LPARAM lParam
         ) ;

BOOL
DisplayAlertOptions (
                     HWND hWndParent,
                     HWND hWndAlert
                     ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\dlgids.h ===
#define IDD_OK             IDOK
#define IDD_CANCEL         IDCANCEL


/*	BUTTON ID'S                */


#define ID_ADD			    10
#define ID_START		    11
#define ID_STOP 		    12

#define ID_COMPUTER		 14
#define ID_OBJECT		    15
#define ID_INSTANCE		 16
#define ID_COUNTER		 17
#define ID_FILE 		    21

#define ID_TIME 		    26



#define ID_MAX_ENTRIES	 32

#define ID_THRESHOLD		 35
#define ID_FOREGR		    36
#define ID_BACKGR		    37
#define ID_TIME_LINE		 38

#define ID_POPUP		    40
#define ID_ELLIPSIS		 42
#define ID_TIME_SCROLL	 43
#define ID_BOOKMARK_IN	 45


#define ID_TIME_IN		 49
#define ID_FILE_IN		 50
#define ID_MAX_IN		    51
#define ID_NUM_IN		    52

#define ID_VERTICAL		 54
#define ID_CCOLOR		    55
#define ID_ENTER_SCALE	 56
#define ID_ENTER_VERT	 57
#define ID_ENTER_INTR	 58
#define ID_LOGTIME       62


#define ID_HELP          112
#define ID_LEGEND        201
#define ID_MENU          202
#define ID_LABELS        203
#define ID_VERT_GRID     204
#define ID_HORZ_GRID     205
#define ID_VERT_MAX      208
#define ID_GRAPH         211
#define ID_HISTOGRAM     212
#define ID_COMPUTER_EDIT_FIELD      301

#define ID_INTERVAL                 402


//=============================//
// Log Display Dialog          //
//=============================//


#define IDD_LOGFILETEXT          3001
#define IDD_LOGFILE              3002
#define IDD_LOGSTATUSTEXT        3003
#define IDD_LOGSTATUS            3004
#define IDD_LOGINTERVALTEXT      3005
#define IDD_LOGINTERVAL          3006
#define IDD_LOGSIZETEXT          3007
#define IDD_LOGSIZE              3008
#define IDD_LOGENTRIESTEXT       3009
#define IDD_LOGENTRIES           3010


//=============================//
// Log Options Dialog          //
//=============================//


#define IDD_LOGOPTSTART             3101
#define IDD_LOGOPTPAUSE             3102
#define IDD_LOGOPTINTERVALTEXT      3103
#define IDD_LOGOPTINTERVAL          3104
#define IDD_LOGOPTIONSMANUALREFRESH 3105
#define IDD_LOGOPTIONSPERIODIC      3106


//=============================//
// Add Log Dialog              //
//=============================//


#define IDD_ADDLOGCOMPUTER       3201
#define IDD_ADDLOGOBJECTTEXT     3202
#define IDD_ADDLOGOBJECT         3203
#define IDD_ADDLOGELLIPSES       3204
#define IDD_ADDLOGADD            3205
#define IDD_ADDLOGDONE           3206
#define IDD_ADDLOGHELP           3207


//=============================//
// Timeframe Dialog            //
//=============================//


#define IDD_TIMEFRAMETIMELINE    3301
#define IDD_TIMEFRAMEHELP        3302
#define IDD_TIMEFRAMESTOPTIME    3303
#define IDD_TIMEFRAMESTOPDATE    3304
#define IDD_TIMEFRAMESTARTDATE   3305
#define IDD_TIMEFRAMESTARTTIME   3306
#define IDD_TIMEFRAMESETSTART    3307
#define IDD_TIMEFRAMESTOP        3308
#define IDD_TIMEFRAMEBOOKMARKS   3309
#define IDD_TIMEFRAMESETSTOP     3310
#define IDD_TIMEFRAMEBOOKMARKGRP 3311



//=============================//
// Alert Display Dialog        //
//=============================//

#define IDD_ALERTLOGTEXT         3401
#define IDD_ALERTLOG             3402
#define IDD_ALERTLEGENDTEXT      3403
#define IDD_ALERTLEGEND          3404
#define IDD_ALERTINTERVALTEXT    3405
#define IDD_ALERTINTERVAL        3406


//=============================//
// Add Line Dialog             //
//=============================//


#define IDD_ADDLINECOMPUTERTEXT        3501
#define IDD_ADDLINECOMPUTER            3502
#define IDD_ADDLINEELLIPSES            3503
#define IDD_ADDLINEOBJECTTEXT          3504
#define IDD_ADDLINEOBJECT              3505
#define IDD_ADDLINECOUNTERTEXT         3506
#define IDD_ADDLINECOUNTER             3507
#define IDD_ADDLINEINSTANCETEXT        3508
#define IDD_ADDLINEINSTANCE            3509

#define IDD_ADDLINECOLORTEXT           3510
#define IDD_ADDLINECOLOR               3511
#define IDD_ADDLINESCALETEXT           3512
#define IDD_ADDLINESCALE               3513
#define IDD_ADDLINEWIDTHTEXT           3514
#define IDD_ADDLINEWIDTH               3515
#define IDD_ADDLINESTYLETEXT           3516
#define IDD_ADDLINESTYLE               3517

#define IDD_ADDLINEADD                 3521
#define IDD_ADDLINEHELP                3523

#define IDD_ADDLINEIFGROUP             3531
#define IDD_ADDLINEIFOVER              3532
#define IDD_ADDLINEIFUNDER             3533
#define IDD_ADDLINEIFVALUE             3534

#define IDD_ADDLINEPROGRAMGROUP        3535
#define IDD_ADDLINEPROGRAM             3536
#define IDD_ADDLINEPROGRAMFIRSTTIME    3537
#define IDD_ADDLINEPROGRAMEVERYTIME    3538

#define IDD_ADDLINEEXPANDEXPLAIN       3541
#define IDD_ADDLINEEXPLAINGROUP        3542
#define IDD_ADDLINEEXPLAIN             3543


//=============================//
// Report Options Dialog       //
//=============================//


#define IDD_REPORTOPTIONSINTERVALTEXT  3601
#define IDD_REPORTOPTIONSINTERVAL      3602
#define IDD_REPORTOPTIONSMANUALREFRESH 3603
#define IDD_REPORTOPTIONSPERIODIC      3604


//=============================//
// Display Options Dialog      //
//=============================//


#define IDD_DISPLAYMENU                3701
#define IDD_DISPLAYTOOLBAR             3702
#define IDD_DISPLAYSTATUS              3703
#define IDD_DISPLAYONTOP               3704
#define IDD_DISPLAYHELP                3705


//=============================//
// Data Source Dialog          //
//=============================//


#define IDD_DATASOURCENOW              3801
#define IDD_DATASOURCEFILE             3802
#define IDD_DATASOURCECHANGEFILE       3803
#define IDD_DATASOURCEHELP             3804
#define IDD_DATASOURCEFILENAME         3805



//=============================//
// Alert Options Dialog        //
//=============================//


#define IDD_ALERTOPTIONSINTERVAL       3901
#define IDD_ALERTOPTIONSBEEP           3902
#define IDD_ALERTOPTIONSNUMBEEPS       3903
#define IDD_ALERTOPTIONSPOPUP          3904
#define IDD_ALERTOPTIONSEVENTLOG       3905
#define IDD_ALERTOPTIONSNETWORKALERT   3906
#define IDD_ALERTOPTIONSMSGNAME        3907
#define IDD_ALERTOPTIONSMSGNAMETEXT    3908
#define IDD_ALERTOPTIONSMANUALREFRESH  3909
#define IDD_ALERTOPTIONSPERIODIC       3911
#define IDD_ALERTOPTIONSINTERVALTEXT   3912
#define IDD_ALERTOPTIONSNETGROUPTEXT   3913

//=============================//
// Chart Options Dialog        //
//=============================//


#define IDD_CHARTOPTIONSINTERVAL       4001
#define IDD_CHARTOPTIONSINTERVALTEXT   4002
#define IDD_CHARTOPTIONSVALUEBAR       4003
#define IDD_CHARTOPTIONSMANUALREFRESH  4004
#define IDD_CHARTOPTIONSPERIODIC       4005
#define IDD_CHARTOPTIONSUPDATETEXT     4006

//=============================//
// Bookmark Options Dialog     //
//=============================//


#define IDD_BOOKMARKCOMMENT            4101
#define IDD_BOOKMARKLIST               4102
#define IDD_BOOKMARKHELP               4103

//=========================//
// Export Options Dialog   //
//=========================//

#define IDD_EXPORTCOMMAS               4201
#define IDD_EXPORTTAB                  4202
#define IDD_EXPORTDELIMITERTEXT        4203
#define IDD_EXPORTHELP                 4204

//==========================//
//   Generic Menu items     //
// (used by ACCELERATORS)   //
//==========================//
#define IDM_FILEOPENFILE               4701
#define IDM_FILESAVEFILE               4702
#define IDM_FILESAVEASFILE             4703
#define IDM_CHARTHIGHLIGHTON           4704

//=============//
// Toolbar ID  //
//=============//
#define IDM_TOOLBARID                  4801
#define WM_F1DOWN                      WM_USER+100

//===============================//
// Select Computer from log file //
//===============================//
#define IDD_CHOOSECOMPUTERTEXT         4901
#define IDD_CHOOSECOMPUTERTEXT1        4902
#define IDD_CHOOSECOMPUTERNAME         4903
#define IDD_CHOOSECOMPUTERLISTBOX      4904


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\fileopen.h ===
BOOL FileOpen (HWND hWndParent, int nStringResourceID, LPTSTR lpInputFileName) ;
BOOL FileGetName (HWND hWndParent, int nStringResourceID, LPTSTR lpFileName) ;

BOOL APIENTRY FileOpenHookProc (HWND hDlg, UINT iMessage, 
                                WPARAM wParam, LPARAM lParam) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\filesave.c ===
#include "perfmon.h"



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\fileopen.c ===
#include "perfmon.h"
#include "cderr.h"

#include "alert.h"      // for OpenAlert
#include "fileutil.h"   // for FileOpen, FileRead
#include "grafdata.h"   // for OpenChart
#include "log.h"        // for OpenLog
#include "report.h"     // for OpenReport
#include "utils.h"      // for strempty
#include "perfmops.h"   // for OpenWorkspace
#include "pmhelpid.h"   // Help IDs
#include <dlgs.h>       // for pshHelp

#define OptionsOFNStyle \
   (OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ENABLEHOOK | OFN_EXPLORER)
//   (OFN_HIDEREADONLY | OFN_SHOWHELP | OFN_OVERWRITEPROMPT | OFN_ENABLEHOOK)

#define ExportOptionsOFNStyle                   \
   (OFN_ENABLETEMPLATE | OFN_HIDEREADONLY |     \
    OFN_ENABLEHOOK | OFN_OVERWRITEPROMPT | OFN_EXPLORER)
//    OFN_SHOWHELP | OFN_ENABLEHOOK | OFN_OVERWRITEPROMPT)

extern BOOL APIENTRY ExportOptionsHookProc (HWND hDlg, UINT iMessage, 
                                            WPARAM wParam, LPARAM lParam) ;

BOOL APIENTRY FileOpenHookProc (HWND hDlg, 
                                UINT iMessage, 
                                WPARAM wParam, 
                                LPARAM lParam)
{
   BOOL     bHandled = FALSE ;
   
   // only intercept the Help button and bring up our WinHelp data
   if (iMessage == WM_COMMAND && wParam == pshHelp)
      {
      CallWinHelp (dwCurrentDlgID, hDlg) ;
      bHandled = TRUE ;
      }
   else if (iMessage == WM_INITDIALOG)
      {
      WindowCenter (hDlg) ;
      bHandled = TRUE ;
      }

#if WINVER >= 0x0400
    else if (iMessage == WM_NOTIFY)
      {
      LPOFNOTIFY  pOfn;
      pOfn = (LPOFNOTIFY)lParam;

      switch (pOfn->hdr.code) {
        case CDN_INITDONE:
            WindowCenter (pOfn->hdr.hwndFrom) ;
            break;

        default:
            break;
        }
      }
#endif

   return (bHandled) ;
}



BOOL FileOpen (HWND hWndParent, int nStringResourceID, LPTSTR lpInputFileName)
   {
   OPENFILENAME   ofn ;
   TCHAR          szFileSpec [FilePathLen] ;
   TCHAR          szFileTitle [FilePathLen] ;
   TCHAR          szDialogTitle [FilePathLen] ;
   HANDLE         hFile ;
   PERFFILEHEADER FileHeader ;
   
   TCHAR          aszOpenFilter[LongTextLen] ;
   int            StringLength ;
   BOOL           retCode ;
   LPTSTR         pFileName = NULL ;
   BOOL           bNoFile = FALSE;

   if (lpInputFileName == NULL) {
      bNoFile = TRUE;
   }
   else if (strempty(lpInputFileName)) {
      bNoFile = TRUE;
   }

   aszOpenFilter[0] = 0;
   if (bNoFile)
      {

      dwCurrentDlgID = HC_PM_idDlgFileOpen ;

      // get the file extension strings
      LoadString (hInstance, nStringResourceID, aszOpenFilter,
         sizeof(aszOpenFilter) / sizeof(TCHAR)) ;
      StringLength = lstrlen (aszOpenFilter) + 1 ;
      LoadString (hInstance, nStringResourceID+1,
         &aszOpenFilter[StringLength],
         sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
      StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1 ;

#ifdef ADVANCED_PERFMON
      // get workspace file extension strings
      LoadString (hInstance, IDS_WORKSPACEFILE, 
         &aszOpenFilter[StringLength],
         sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
      StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1 ;
      LoadString (hInstance, IDS_WORKSPACEFILEEXT,
         &aszOpenFilter[StringLength],
         sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
      StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1;
#endif

      // get all file extension strings
      LoadString (hInstance, IDS_ALLFILES, 
         &aszOpenFilter[StringLength],
         sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
      StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1 ;
      LoadString (hInstance, IDS_ALLFILESEXT,
         &aszOpenFilter[StringLength],
         sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
      StringLength += lstrlen (&aszOpenFilter[StringLength]) ;

      // setup the end strings
      aszOpenFilter[StringLength+1] = aszOpenFilter[StringLength+2] = TEXT('\0') ;

      strclr (szFileSpec) ;
      strclr (szFileTitle) ;

      StringLoad (IDS_FILEOPEN_TITLE, szDialogTitle) ;
      memset (&ofn, 0, sizeof(OPENFILENAME)) ;
      ofn.lStructSize = sizeof(OPENFILENAME) ;
      ofn.hwndOwner = hWndParent ;
      ofn.hInstance = hInstance;
      ofn.lpstrTitle = szDialogTitle ;
      ofn.lpstrFilter = aszOpenFilter ;
      ofn.nFilterIndex = 1L ;

      ofn.lpstrFile = szFileSpec;
      ofn.nMaxFile = sizeof(szFileSpec);
      ofn.lpstrFileTitle = szFileTitle;
      ofn.nMaxFileTitle = sizeof(szFileTitle);
//      ofn.Flags = OFN_HIDEREADONLY | OFN_SHOWHELP | OFN_FILEMUSTEXIST | OFN_ENABLEHOOK ;
      ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ENABLEHOOK | OFN_EXPLORER;
      ofn.lpfnHook = (LPOFNHOOKPROC) FileOpenHookProc ;

      if (!GetOpenFileName(&ofn))
         {
         dwCurrentDlgID = 0 ;
         return (FALSE) ;
         }

      dwCurrentDlgID = 0 ;

      hFile = FileHandleOpen (szFileSpec) ;
      pFileName = szFileSpec ;

      }  // NULL lpFileName

   else
      {
      // open the input file
      hFile = FileHandleOpen (lpInputFileName) ;
      if (hFile && hFile != INVALID_HANDLE_VALUE &&
          SearchPath (NULL, lpInputFileName, NULL,
            sizeof(szFileSpec)/sizeof(TCHAR) - 1,
            szFileSpec, &pFileName))
         {
         pFileName = szFileSpec ;
         }
      else
         {
         pFileName = NULL ;
         }
      }

   if (!hFile || hFile == INVALID_HANDLE_VALUE)
      {
      return (FALSE) ;
      }

   if (!FileRead (hFile, &FileHeader, sizeof (FileHeader)))
      {
      CloseHandle (hFile) ;
      if (bNoFile)
         {
         DlgErrorBox (hWndParent, ERR_BAD_SETTING_FILE, pFileName) ;
         }
      return (FALSE) ;
      }


   //=============================//
   // Chart File?                 //
   //=============================//

   if (strsame (FileHeader.szSignature, szPerfChartSignature))
      {
      retCode = OpenChart (hWndGraph,
                           hFile,
                           FileHeader.dwMajorVersion,
                           FileHeader.dwMinorVersion,
                           TRUE) ;
      if (retCode)
         {
         ChangeSaveFileName (pFileName, IDM_VIEWCHART) ;
         }
      else
         {
         goto ErrExit ;
         }
      return (retCode) ;
      }

#ifdef ADVANCED_PERFMON
   //=============================//
   // Alert File?                 //
   //=============================//

   if (strsame (FileHeader.szSignature, szPerfAlertSignature))
      {
      retCode = OpenAlert (hWndAlert,
                           hFile,
                           FileHeader.dwMajorVersion,
                           FileHeader.dwMinorVersion,
                           TRUE) ;
      if (retCode)
         {
         ChangeSaveFileName (pFileName, IDM_VIEWALERT) ;
         }
      else
         {
         goto ErrExit ;
         }

      return (retCode) ;
      }


   //=============================//
   // Log File?                   //
   //=============================//

   if (strsame (FileHeader.szSignature, szPerfLogSignature))
      {
      retCode = OpenLog (hWndLog,
                         hFile,
                         FileHeader.dwMajorVersion,
                         FileHeader.dwMinorVersion,
                         TRUE) ;
      if (retCode)
         {
         ChangeSaveFileName (pFileName, IDM_VIEWLOG) ;
         }
      else
         {
         goto ErrExit ;
         }

      return (retCode) ;
      }

   //=============================//
   // Report File?                //
   //=============================//

   if (strsame (FileHeader.szSignature, szPerfReportSignature))
      {
      retCode = OpenReport (hWndReport,
                            hFile,
                            FileHeader.dwMajorVersion,
                            FileHeader.dwMinorVersion,
                            TRUE) ;
      if (retCode)
         {
         ChangeSaveFileName (pFileName, IDM_VIEWREPORT) ;
         }
      else
         {
         goto ErrExit ;
         }

      return (retCode) ;
      }

   //=============================//
   // Workspace File?             //
   //=============================//

   if (strsame (FileHeader.szSignature, szPerfWorkspaceSignature))
      {
      retCode = OpenWorkspace (hFile,
                               FileHeader.dwMajorVersion,
                               FileHeader.dwMinorVersion) ;
      if (retCode)
         {
         ChangeSaveFileName (pFileName, IDM_WORKSPACE) ;
         return (TRUE) ;
         }
      else
         {
         goto ErrExit ;
         }
      }
#endif

   //=============================//
   // Unknown file type           //
   //=============================//
   CloseHandle (hFile) ;

ErrExit:

   DlgErrorBox (hWndParent, ERR_BAD_SETTING_FILE, pFileName) ;
   return (FALSE) ;
   }  // FileOpen


BOOL FileGetName (HWND hWndParent, int nStringResourceID, LPTSTR lpFileName)
   {
   OPENFILENAME   ofn ;
   TCHAR          szFileSpec [FilePathLen] ;
   TCHAR          szFileTitle [FilePathLen] ;
   TCHAR          szDialogTitle [FilePathLen] ;
   TCHAR          aszOpenFilter[LongTextLen] ;
   TCHAR          aszDefaultExt[FileExtLen];
   int            StringLength ;
   int            nExportExtId = 0;

   aszOpenFilter[0] = 0;
   if (lpFileName)
      {

      if (nStringResourceID != IDS_EXPORTFILE)
         {
         // get the file extension strings
         LoadString (hInstance, nStringResourceID,
            aszOpenFilter,
            sizeof(aszOpenFilter) / sizeof(TCHAR) ) ;
         StringLength = lstrlen (aszOpenFilter) + 1 ;
         LoadString (hInstance, nStringResourceID+1,
            &aszOpenFilter[StringLength],
            sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;

         StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1 ;
         // get all file extension strings
         LoadString (hInstance, IDS_ALLFILES, 
            &aszOpenFilter[StringLength],
            sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
         StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1 ;
         LoadString (hInstance, IDS_ALLFILESEXT,
            &aszOpenFilter[StringLength],
            sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
         }
      else
         {
         // get the Export file extension based on the current delimiter
         int   FirstExtensionID, SecondExtensionID ;

         if (pDelimiter == TabStr)
            {
            FirstExtensionID = IDS_EXPORTFILETSV ;
            SecondExtensionID = IDS_EXPORTFILE ;
            nExportExtId = IDS_DEF_EXPORT_TSV;
            }
         else
            {
            FirstExtensionID = IDS_EXPORTFILE ;
            SecondExtensionID = IDS_EXPORTFILETSV ;
            nExportExtId = IDS_DEF_EXPORT_CSV;
            }

         LoadString (hInstance, FirstExtensionID,
            aszOpenFilter,
            sizeof(aszOpenFilter) / sizeof(TCHAR) ) ;
         StringLength = lstrlen (aszOpenFilter) + 1 ;
         LoadString (hInstance, FirstExtensionID+1,
            &aszOpenFilter[StringLength],
            sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;

         StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1 ;
         // get all file extension strings
         LoadString (hInstance, SecondExtensionID, 
            &aszOpenFilter[StringLength],
            sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
         StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1 ;
         LoadString (hInstance, SecondExtensionID+1,
            &aszOpenFilter[StringLength],
            sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;

         }

      // setup the end strings
      StringLength += lstrlen (&aszOpenFilter[StringLength]) ;
      aszOpenFilter[StringLength+1] = aszOpenFilter[StringLength+2] = TEXT('\0') ;

      strclr (szFileSpec) ;
      strclr (szFileTitle) ;

      if (nStringResourceID == IDS_EXPORTFILE)
         {
         dwCurrentDlgID = HC_PM_idDlgFileExport ;
         StringLoad (IDS_EXPORTAS_TITLE, szDialogTitle) ;
         }
      else if (nStringResourceID == IDS_WORKSPACEFILE)
         {
         dwCurrentDlgID = HC_PM_idDlgFileSaveWorkSpace ;
         StringLoad (IDS_SAVEASW_TITLE, szDialogTitle) ;
         }
      else
         {
         dwCurrentDlgID = HC_PM_idDlgFileSaveAs ;
         StringLoad (IDS_SAVEAS_TITLE, szDialogTitle) ;
         }

      memset (&ofn, 0, sizeof(OPENFILENAME)) ;
      ofn.lStructSize = sizeof(OPENFILENAME) ;
      ofn.hwndOwner = hWndParent ;
      ofn.hInstance = hInstance;
      ofn.lpstrTitle = szDialogTitle ;
      ofn.lpstrFilter = aszOpenFilter ;
      ofn.nFilterIndex = 1L ;

      ofn.lpstrFile = szFileSpec;
      ofn.nMaxFile = sizeof(szFileSpec);
      ofn.lpstrFileTitle = szFileTitle;
      ofn.nMaxFileTitle = sizeof(szFileTitle);

      if (nStringResourceID == IDS_EXPORTFILE)
         {
         // get default file extension 
         if (LoadString (hInstance, nExportExtId,
            aszDefaultExt,
            sizeof(aszDefaultExt) / sizeof(TCHAR)) > 0) {
            ofn.lpstrDefExt = aszDefaultExt;
         } else {
            ofn.lpstrDefExt = NULL; // no default extenstion
         }
         ofn.Flags = ExportOptionsOFNStyle ;
         ofn.lpfnHook = (LPOFNHOOKPROC) ExportOptionsHookProc ;
         ofn.lpTemplateName = idDlgExportOptions ;
         }
      else
         {
         // get default file extension 
         if (LoadString (hInstance, nStringResourceID+2,
            aszDefaultExt,
            sizeof(aszDefaultExt) / sizeof(TCHAR)) > 0) {
            ofn.lpstrDefExt = aszDefaultExt;
         } else {
            ofn.lpstrDefExt = NULL; // no default extenstion
         }
         ofn.Flags = OptionsOFNStyle ;
         ofn.lpfnHook = (LPOFNHOOKPROC) FileOpenHookProc ;
         }

      if (!GetSaveFileName(&ofn))
         {
         dwCurrentDlgID = 0 ;
         return (FALSE) ;
         }
      dwCurrentDlgID = 0 ;
      }
   else
      {
      return (FALSE) ;
      }

   lstrcpy (lpFileName, ofn.lpstrFile) ;

   return (TRUE) ;
   } // FileGetName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\grafdata.h ===
//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//
#if 0
PGRAPHSTRUCT GraphData (HWND hWndGraphDisplay) ;
#endif
#define GraphData(hWndGraphDisplay)       \
      (pGraphs)

FLOAT eUpdateAve(FLOAT eValue, PLINESTRUCT pLineStruct, INT iValidValues,
                 INT iDataPoint, INT iTotalValidPoints) ;

FLOAT eUpdateMin(FLOAT eValue, PLINESTRUCT pLineStruct, INT iValidValues, 
                 INT iTotalValidPoints, INT iDataPoint, INT gMaxPoints) ;


FLOAT eUpdateMax(FLOAT eValue, PLINESTRUCT pLineStruct, INT iValidValues,
                 INT iTotalValidPoints) ;


PPERFSYSTEM InsertSystem(LPTSTR SysName) ;


BOOL ChartInsertLine (PGRAPHSTRUCT pGraph,
                      PLINE pLineNew) ;

VOID ChartDeleteLine (PGRAPHSTRUCT lgraph,
                      PLINESTRUCT pline) ;


void ResetGraph (PGRAPHSTRUCT pGraph) ;
void ResetGraphView (HWND hWndGraph) ;

void ClearGraphDisplay (PGRAPHSTRUCT pGraph) ;



BOOL InsertGraph(HWND hwnd) ;


void PlaybackChart (HWND hWndChart) ;

#if 0
PLINESTRUCT CurrentGraphLine (HWND hWndGraph) ;
#endif
#define CurrentGraphLine(hWndGraph)       \
   (LegendCurrentLine (hWndGraphLegend))


BOOL AddChart (HWND hWndParent) ;


BOOL EditChart (HWND hWndParent) ;


BOOL HandleGraphTimer (void) ;


VOID ClearGraphTimer(PGRAPHSTRUCT pGraph) ;


BOOL SaveChart (HWND hWndGraph, HANDLE hInputFile, BOOL bGetFileName) ;
BOOL OpenChart (HWND hWndGraph, HANDLE hFile, 
         DWORD dwMajorVersion, DWORD dwMinorVersion, BOOL bChartFile) ;

void ExportChart (void) ;

VOID UpdateValueBarData (PGRAPHSTRUCT pGraph) ;

void GraphAddAction (void) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\globals.h ===
#ifdef DEFINE_GLOBALS

#define GLOBAL   

// #include "counters.h"

// initialize some of the globals
// only perfmon.c will define DEFINE_GLOBALS

int     aiIntervals [] = { 1, 5, 15, 30, 60, 120, 300, 600, 3600 } ;


// setup CVS delimiter and line ending used by Export routines
CHAR           CommasStr[] = "," ;
CHAR           TabStr[] = "\t" ;
CHAR           *pDelimiter = TabStr ;
CHAR           LineEndStr[] = "\n" ;
TCHAR          DashLine[] = TEXT("- - - -") ;

// PDFN           CounterFuncEntry = CounterEntry ;


#else
// only perfmon.c define DEFINE_GLOBALS,
// all other references to them as extern
#define GLOBAL extern

#define  NumIntervals   9
GLOBAL   int            aiIntervals [] ;

// setup CVS delimiter and line ending used by Export routines
GLOBAL   CHAR           CommasStr[] ;
GLOBAL   CHAR           TabStr[] ;
GLOBAL   CHAR           *pDelimiter ;
GLOBAL   CHAR           LineEndStr[] ;
GLOBAL   TCHAR          DashLine[] ;
#endif



//=============================//
// Graph Data Information      //
//=============================//


// GLOBAL   PPERFSYSTEM    pSysInfo ;
GLOBAL   PGRAPHSTRUCT   pGraphs;


//=============================//
// Font Information            //
//=============================//


GLOBAL   HFONT          hFontScales ;
GLOBAL   HFONT          hFontScalesBold ;
GLOBAL   LONG           HalfTextHeight;

#ifdef KEEP_PRINT
GLOBAL   HFONT          hFontPrinterScales ;
GLOBAL   HFONT          hFontPrinterScalesBold ;
#endif

//=============================//
// Control Information         //
//=============================//


GLOBAL   INT            iPerfmonView ;
GLOBAL   LANGID         iLanguage ;
GLOBAL   LANGID         iEnglishLanguage ;
GLOBAL   OPTIONS        Options ;

GLOBAL   HICON          hIcon ;
GLOBAL   HANDLE         hInstance;
GLOBAL   HANDLE         hAccelerators ;

GLOBAL   HANDLE         hEventLog ;

GLOBAL   LPTSTR         szMessageArray[8]; // used for reporting events
GLOBAL   WORD           wMessageIndex;
GLOBAL   DWORD          dwMessageData[8]; // used to report data in event msg
GLOBAL   DWORD          dwMessageDataBytes;

GLOBAL   HMENU          hMenuChart ;
GLOBAL   HMENU          hMenuAlert ;
GLOBAL   HMENU          hMenuLog ;
GLOBAL   HMENU          hMenuReport ;


//=============================//
// Windows                     //
//=============================//


GLOBAL   HWND    hWndMain ;
GLOBAL   HWND    hWndGraph ;
GLOBAL   HWND    hWndLog ;
GLOBAL   HWND    hWndAlert ;
GLOBAL   HWND    hWndReport ;

GLOBAL   HWND    hWndGraphDisplay ;
GLOBAL   HWND    hWndGraphLegend ;
GLOBAL   HWND    hWndGraphStatus ;

GLOBAL   HWND    hWndAlertLegend ;
GLOBAL   HWND    hWndLogEntries ;

GLOBAL   HWND    hWndToolbar ;
GLOBAL   HWND    hWndStatus ;


//=============================//
// System Metrics              //
//=============================//


GLOBAL   int     xScreenWidth ;
GLOBAL   int     yScreenHeight ;

GLOBAL   int     xBorderWidth ;
GLOBAL   int     yBorderHeight ;

GLOBAL   int     xScrollWidth ;
GLOBAL   int     yScrollHeight ;

GLOBAL   int     xScrollThumbWidth ;
GLOBAL   int     yScrollThumbHeight ;


GLOBAL   int     xDlgBorderWidth ;
GLOBAL   int     yDlgBorderHeight ;

GLOBAL   int     MinimumSize ;

//=============================//
// Miscellaneous               //
//=============================//

GLOBAL   int            iUnviewedAlerts ;
GLOBAL   COLORREF       crLastUnviewedAlert ;

GLOBAL   LPTSTR         pChartFileName ;
GLOBAL   LPTSTR         pChartFullFileName ;
GLOBAL   LPTSTR         pAlertFileName ;
GLOBAL   LPTSTR         pAlertFullFileName ;
GLOBAL   LPTSTR         pLogFileName ;
GLOBAL   LPTSTR         pLogFullFileName ;
GLOBAL   LPTSTR         pReportFileName ;
GLOBAL   LPTSTR         pReportFullFileName ;
GLOBAL   LPTSTR         pWorkSpaceFileName ;
GLOBAL   LPTSTR         pWorkSpaceFullFileName ;


// globals for perfmornance improvements

// frequently used GDI objects 
GLOBAL   UINT     ColorBtnFace ;  // for concave/convex button painting
GLOBAL   HBRUSH   hBrushFace ;    // for concave/convex button painting
GLOBAL   HPEN     hPenHighlight ; // for concave/convex button painting
GLOBAL   HPEN     hPenShadow ;    // for concave/convex button painting
GLOBAL   HPEN     hWhitePen ;     // for chart highlighting
GLOBAL   HANDLE   hbLightGray ;   // for painting the background

// bPerfmonIconic is TRUE when perfmon is minimized.
// Thus, we don't need to update chart or report view until
// it is not iconized
GLOBAL   BOOL     bPerfmonIconic ;

// bAddLineInPorgress is TRUE when Addline dialog is up.  It is used
// in freeing unused system during data collecting. (But not while
// addline dialog is still up)
GLOBAL   BOOL     bAddLineInProgress ;

// bDelayAddAction is TRUE when reading setting files or adding more
// than 1 counter.  This is to delay some of the costly screen adjustments
// until we have added all the lines.
GLOBAL   BOOL     bDelayAddAction ;


// bExplainTxtButtonHit is TRUE when the ExplainText button in addline 
// dialog is clicked.  This is to save time and memory for fetching the
// help text, during BuildNameTable(), unless it is needed.
GLOBAL   BOOL     bExplainTextButtonHit ;

// globals used for WinHelp
GLOBAL   DWORD          dwCurrentDlgID ;
GLOBAL   DWORD          dwCurrentMenuID ;
GLOBAL   LPTSTR         pszHelpFile ;

// Following includes space for trailing NULL and preceeding \\'s
GLOBAL   TCHAR  LocalComputerName[MAX_COMPUTERNAME_LENGTH + 3];
GLOBAL	TCHAR	 CmdLineComputerName[MAX_COMPUTERNAME_LENGTH + 3];

// Flag to indicate if we need to close local machine
GLOBAL   BOOL           bCloseLocalMachine ;

// Timeout for data collection thread in msec
GLOBAL   DWORD          DataTimeOut ;

// flag to indicate duplicate instance names should be allowed
GLOBAL  BOOL            bMonitorDuplicateInstances;

// flag to indicate that events should be reported to the event log
GLOBAL  BOOL            bReportEvents;

// flag to indicate that percentages should/shouldn't be limited to 100
GLOBAL  BOOL            bCapPercentsAt100;

// 20 sec for the data thread timeout
#define  DEFAULT_DATA_TIMEOUT    20000L

//=============================//
// Log Playback Information    //
//=============================//

GLOBAL   PLAYBACKLOG    PlaybackLog ;

GLOBAL   REPORT         Report ;
GLOBAL   ALERT          Alert ;
GLOBAL   LOG            Log ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\grafdisp.h ===
BOOL GraphDisplayInitializeApplication (void) ;


HWND CreateGraphDisplayWindow (HWND hWndGraph) ;


void SizeGraphDisplayComponentsRect (HDC hDC,
                                     PGRAPHSTRUCT pGraph,
                                     RECT rectDisplay) ;


void SizeGraphDisplayComponents (HWND hWnd) ;


BOOL GraphRefresh (HWND hWnd) ;
BOOL ToggleGraphRefresh (HWND hWnd) ;


void GraphTimer (HWND hWnd, 
                 BOOL bForce) ;


void DrawGraphDisplay (HDC hDC,
                       RECT rectDraw,
                       PGRAPHSTRUCT pGraph) ;


void PrintGraphDisplay (HDC hDC,
                        PGRAPHSTRUCT pGraph) ;

void ChartHighlight (void) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\grafdata.c ===
/*****************************************************************************
 *
 *  Grafdata.c - This module handles the non-drawing functions of the graph,
 *      such as allocating linked structures and their memory, freeing it,
 *      unlinking, starting and stopping the timer,
 *      setting up the first graph (CPU), and all the numeric functions for
 *      the different counter types.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *
 ****************************************************************************/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <stdio.h>      // for sprintf

#include "perfmon.h"       // main perfmon declarations
#include "grafdata.h"      // external declarations for this file
#include <float.h>         // for FLT_MAX constant

#include "addline.h"       // for AddLine, EditLine
#include "counters.h"      // for CounterEntry
#include "graph.h"         // for SizeGraphComponents
#include "pmemory.h"       // for MemoryXXX (mallloc-type) routines
#include "perfdata.h"      // for UpdateLines
#include "playback.h"      // for PlayingBackLog, PlaybackLines
#include "legend.h"
#include "system.h"        // for SystemGet
#include "utils.h"
#include "line.h"          // for LineFree
#include "valuebar.h"      // for StatusTimer

#include "fileopen.h"      // for FileGetName
#include "fileutil.h"      // for FileRead...
#include "menuids.h"       // for IDM_VIEWCHART
#include "perfmops.h"      // for ExportFileHeader
#include "status.h"        // for StatusLineReady

extern BOOL SaveFileHandler(HWND hWnd,DWORD type) ;

// this macro is used in doing a simple DDA (Digital Differential Analyzer)
// * 10 + 5 is to make the result round up with .5
#define DDA_DISTRIBUTE(TotalTics, numOfData) \
   ((TotalTics * 10 / numOfData) + 5) / 10

#define szSmallValueFormat         TEXT("%10.3f")
#define szLargeValueFormat         TEXT("%10.0f")

//==========================================================================//
//                                Local Data                                //
//==========================================================================//




//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


/****************************************************************************
 * eUpdateMinMaxAve -
 ****************************************************************************/
void eUpdateMinMaxAve (FLOAT eValue, PLINESTRUCT pLineStruct, INT iValidValues,
   INT iTotalValidPoints, INT iDataPoint, INT gMaxPoints)
{
INT     i ;
INT     iDataNum = iTotalValidPoints ;
FLOAT   eMin,
        eMax,
        eSum,
        eNewValue ;


   eMax = eMin = eValue ;

   if (PlayingBackLog())
      {
      eSum = (FLOAT) 0.0 ;
      }
   else
      {
      eSum = eValue ;
      }

   if (iValidValues == iTotalValidPoints)
      {
      for (i=0 ; i < iValidValues ; i++)
         {
         if (i == iDataPoint)
            {
            // skip the data point we are going to replace
            continue ;
            }

         eNewValue = pLineStruct->lnValues[i] ;
         
         eSum += eNewValue ;

         if (eNewValue > eMax)
            {
            eMax = eNewValue ;
            }

         if (eNewValue < eMin)
            {
            eMin = eNewValue ;
            }
         }
      }
   else
      {
      // special case when we start the new line in the middle of the chart
      for (i = iDataPoint, iTotalValidPoints-- ;
          iTotalValidPoints > 0 ;
          iTotalValidPoints-- )
         {
         i-- ;
         if (i < 0)
            {
            // for the wrap-around case..
            i = gMaxPoints - 1 ;
            }

         if (i == iDataPoint)
            {
            // skip the data point we are going to replace
            continue ;
            }
         eNewValue = pLineStruct->lnValues[i] ;

         eSum += eNewValue ;

         if (eNewValue > eMax)
            {
            eMax = eNewValue ;
            }

         if (eNewValue < eMin)
            {
            eMin = eNewValue ;
            }
         }
      }

   pLineStruct->lnMinValue = eMin ;
   pLineStruct->lnMaxValue = eMax ;

   if (iDataNum)
      {
      pLineStruct->lnAveValue = eSum / (FLOAT) iDataNum ;
      }
   else
      {
      pLineStruct->lnAveValue = (FLOAT) 0.0 ;
      }

   //clean up bogus (negative)values
   if (pLineStruct->lnMinValue < (FLOAT)0.0) {
      pLineStruct->lnMinValue = (FLOAT)0.0;
   }
   if (pLineStruct->lnMaxValue < (FLOAT)0.0) {
      pLineStruct->lnMaxValue = (FLOAT)0.0;
   }
   if (pLineStruct->lnAveValue < (FLOAT) 0.0) {
      pLineStruct->lnAveValue = (FLOAT) 0.0 ;
   }
    
}


// UpdateValueBarData is used to update the value bar data
// It is called when the user switches to a diff. line from
// the legned window.
VOID UpdateValueBarData (PGRAPHSTRUCT pGraph)
   {
   PLINESTRUCT    pCurrentGraphLine ;   
   INT            KnownValue,
                  MaxValues,
                  iValidValues,
                  iDataPoint ;
   FLOAT          eValue ;
   pCurrentGraphLine = CurrentGraphLine (hWndGraph) ;

   if (!pCurrentGraphLine || pCurrentGraphLine->bFirstTime)
      {
      // we have not collect enough samples
      return ;
      }

   KnownValue = pGraph->gKnownValue ;
   MaxValues = pGraph->gMaxValues ;

   // The valid values is the number of valid entries in the
   // data buffer.  After we wrap the buffer, all the values are
   // valid.
   iValidValues = pGraph->gTimeLine.iValidValues ;

   // Get the index to the data point we are updating.

   iDataPoint = KnownValue % MaxValues ;
   eValue = pCurrentGraphLine->lnValues[iDataPoint] ;

   // get the statistical data for this line
   eUpdateMinMaxAve(eValue, pCurrentGraphLine,
      iValidValues, pCurrentGraphLine->lnValidValues,
      iDataPoint, MaxValues) ;
   }  // UpdateValueBarData


VOID UpdateLGData (PGRAPHSTRUCT pGraph)
   {
   PLINESTRUCT    pLine ;               
   PLINESTRUCT    pCurrentGraphLine ;   
   INT            KnownValue,
                  MaxValues,
                  iValidValues,
                  iDataPoint ;
   FLOAT          eValue ;
   // Known Value is the where data is placed in the buffer.
   pGraph->gKnownValue++;

   KnownValue = pGraph->gKnownValue ;

   // Update the high water mark for valid data in the lnValues
   // (aka DataPoint) buffer.


   MaxValues = pGraph->gMaxValues ;

   // The valid values is the number of valid entries in the
   // data buffer.  After we wrap the buffer, all the values are
   // valid.
   iValidValues = pGraph->gTimeLine.iValidValues ;

   if (iValidValues < MaxValues)
       iValidValues = (KnownValue % MaxValues) + 1 ;

   pGraph->gTimeLine.iValidValues = iValidValues ;

   // Get the index to the data point we are updating.

   iDataPoint = KnownValue % MaxValues ;

   // loop through lines,
   // If one of the lines is highlighted then do the calculations
   // for average, min, & max on that line.

   pCurrentGraphLine = CurrentGraphLine (hWndGraph) ;

   for (pLine=pGraph->pLineFirst; pLine; pLine=pLine->pLineNext)
     { // for

     if (pLine->bFirstTime)
         {
         // skip until we have collect enough samples to plot the first data
         continue ;
         }

     if (pLine->lnValidValues < MaxValues)
         {   
         (pLine->lnValidValues)++ ;
         }
   
     // Get the new value for this line.
     eValue = CounterEntry (pLine) ;

     if (pLine == pCurrentGraphLine)
        {  // if
        // get the statistical data for this line
        eUpdateMinMaxAve (eValue, pLine, 
                                 iValidValues, pLine->lnValidValues,
                                 iDataPoint, MaxValues) ;
        }  // if
      
     // Now put the new value into the data array
     pLine->lnValues[iDataPoint] = eValue ;
     }
   
   GetLocalTime (&(pGraph->pDataTime[iDataPoint])) ; 
   }  // UpdateLGData



BOOL HandleGraphTimer (void)
   {
   PGRAPHSTRUCT pGraph;

   //NOTE: get a strategy for these "no-go" states
   if (!(pGraph = pGraphs) || !pGraphs->pSystemFirst)
       return(FALSE);


   if (!UpdateLines(&(pGraphs->pSystemFirst), pGraphs->pLineFirst))
        return (TRUE) ;

   UpdateLGData(pGraph);

   return(TRUE);
   }


VOID ClearGraphTimer(PGRAPHSTRUCT pGraph)
   {
   KillTimer(pGraph->hWnd, GRAPH_TIMER_ID);
   }


VOID SetGraphTimer(PGRAPHSTRUCT pGraph)
   {
   SetTimer(pGraph->hWnd, GRAPH_TIMER_ID, pGraph->gInterval, NULL) ;
   }

VOID ResetGraphTimer(PGRAPHSTRUCT pGraph)
{
    KillTimer(pGraph->hWnd, GRAPH_TIMER_ID);
    SetGraphTimer(pGraph);
}


VOID GetGraphConfig(PGRAPHSTRUCT pGraph)
{

    LoadRefreshSettings(pGraph);
    LoadLineGraphSettings(pGraph);


    // Init the structure
    pGraph->pLineFirst = NULL;

    //NOTE: put the rest of this in Config

    pGraph->gOptions.bLegendChecked    = TRUE;
    pGraph->gOptions.bMenuChecked      = TRUE;
    pGraph->gOptions.bLabelsChecked    = TRUE;
    pGraph->gOptions.bVertGridChecked  = FALSE;
    pGraph->gOptions.bHorzGridChecked  = FALSE;
    pGraph->gOptions.bStatusBarChecked = TRUE;
    pGraph->gOptions.GraphVGrid        = TRUE;
    pGraph->gOptions.GraphHGrid        = TRUE;
    pGraph->gOptions.HistVGrid         = TRUE;
    pGraph->gOptions.HistHGrid         = TRUE;

    pGraph->gOptions.iGraphOrHistogram = LINE_GRAPH;       // vs. BAR_GRAPH
    pGraph->gOptions.iVertMax = DEF_GRAPH_VMAX;

    return;
}


BOOL InsertGraph (HWND hWnd)
   {
   PGRAPHSTRUCT    pGraph;

   pGraph = MemoryAllocate (sizeof (GRAPHSTRUCT)) ;
   if (!pGraph)
      return (FALSE) ;


   pGraphs = pGraph;

   
   GetGraphConfig(pGraph);
   pGraph->bManualRefresh = FALSE ;

// there's at least one place where the [DEFAULT_MAX_VALUES] entry is 
// accessed when the index should stop at [DEFAULT_MAX_VALUES -1]. 
// rather than try to find all the places this index is used it's easier
// and safer just to make the array large enough to accomodate this 
// "oversight"

   pGraph->gMaxValues = DEFAULT_MAX_VALUES;
   pGraph->pptDataPoints = 
      (PPOINT) MemoryAllocate (sizeof (POINT) * (pGraph->gMaxValues + 1)) ;

   pGraph->pDataTime =
      (SYSTEMTIME *) MemoryAllocate (sizeof(SYSTEMTIME) * (pGraph->gMaxValues + 1)) ;

   pGraph->hWnd = hWnd ;
   pGraph->bModified = FALSE ;

   pGraph->Visual.iColorIndex = 0 ;
   pGraph->Visual.iWidthIndex = 0 ;
   pGraph->Visual.iStyleIndex = 0 ;

   return(TRUE) ;
   }



void PlaybackSetGraphLines (HWND hWndChart, 
                            PLINE pLineFirst, 
                            int iDisplayTic,
                            int iLogTic,
                            BOOL CalcData)
   {
   PLINE          pLine ;
   FLOAT          eValue ;

   for (pLine = pLineFirst ;
        pLine ;
        pLine = pLine->pLineNext)
      {  // for
      eValue = CounterEntry (pLine) ;
      pLine->lnValues[iDisplayTic] = eValue ;
      pLine->aiLogIndexes[iDisplayTic] = iLogTic ;

      // only need to do this on request.
      if (CalcData)
         {
         eUpdateMinMaxAve (eValue, pLine, iDisplayTic, iDisplayTic,
            iDisplayTic, iDisplayTic) ;
         }  // if
      }  // for
   }  // PlaybackSetGraphLines



BOOL ChartInsertLine (PGRAPHSTRUCT pGraph, 
                      PLINE pLine)
/*
   Effect:        Insert the line pLine into the graph pGraph and 
                  allocate space for the graph's number of values.

   Returns:       Whether the line could be added and space allocated.

   See Also:      LineAllocate (line.c), ChartDeleteLine.
*/
   {  // ChartInsertLine
   PLINE          pLineEquivalent ;
   INT            i ;
   FLOAT          *pTempPts;
   HPEN           tempPen ;

   pGraph->bModified = TRUE ;

   pLineEquivalent = FindEquivalentLine (pLine, pGraph->pLineFirst) ;
   if (pLineEquivalent)
    {
      if (bMonitorDuplicateInstances) {
          pLine->dwInstanceIndex = pLineEquivalent->dwInstanceIndex + 1;
      } else {
        pLineEquivalent->Visual = pLine->Visual ;
        pLineEquivalent->iScaleIndex = pLine->iScaleIndex ;
        pLineEquivalent->eScale = pLine->eScale ;

        tempPen = pLineEquivalent->hPen ;
        pLineEquivalent->hPen =  pLine->hPen ;
        pLine->hPen = tempPen ;
        return FALSE ;
      }  
    }

    if (!pGraph->pLineFirst && !PlayingBackLog())
        {
        SetGraphTimer (pGraph) ;
        }

    if (!SystemAdd (&pGraph->pSystemFirst, pLine->lnSystemName,pGraph->hWnd))
    return FALSE;

    LineAppend (&pGraph->pLineFirst, pLine) ;

    pLine->lnMinValue = FLT_MAX ;
    pLine->lnMaxValue = - FLT_MAX ;
    pLine->lnAveValue = 0.0F ;
    pLine->lnValidValues = 0 ;

    pLine->lnValues = 
        (FLOAT *) MemoryAllocate (sizeof (FLOAT) * (pGraph->gMaxValues + 1)) ;
    
    for (i = pGraph->gMaxValues, pTempPts = pLine->lnValues ;
        (i > 0) && (pTempPts != NULL) ;
        i-- )
        {
        *pTempPts++ = (FLOAT) 0.0 ;
        }

    if (PlayingBackLog ())
        {
        pLine->aiLogIndexes =
        (int *) MemoryAllocate (sizeof (LONG) * (pGraph->gMaxValues + 1)) ;
        }

    // Add the line to the legend, resize the legend window, and then
    // select the new line as the current legend item. Do it in this 
    // sequence to avoid the legend scroll bar momentarily appearing and
    // then disappearing, since the resize will obviate the scroll bar.

    LegendAddItem (hWndGraphLegend, pLine) ;

    if (!bDelayAddAction)
        {
        SizeGraphComponents (hWndGraph) ;
        LegendSetSelection (hWndGraphLegend, 
                        LegendNumItems (hWndGraphLegend) - 1) ;

        if (PlayingBackLog ()) PlaybackChart (pGraph->hWnd) ;
        }

   return (TRUE) ;
   }  // ChartInsertLine


VOID ChartDeleteLine (PGRAPHSTRUCT pGraph, 
                      PLINESTRUCT pLine)
   {
   PLINESTRUCT npLine;


   pGraph->bModified = TRUE ;

   if (pGraph->pLineFirst == pLine)
       pGraph->pLineFirst = pLine->pLineNext;
   else
   {
       for (npLine = pGraph->pLineFirst; npLine; npLine = npLine->pLineNext)
       {
           if (npLine->pLineNext == pLine)
               npLine->pLineNext = pLine->pLineNext;
       }
   }

   if (!pGraph->pLineFirst)
      {
      ResetGraph (pGraph) ;
      }
   else
      {
      BuildValueListForSystems (
         pGraph->pSystemFirst,
         pGraph->pLineFirst) ;
      }

   // Delete the legend entry for this line.
   // If the line was highlighted then this will undo the highlight.

   LegendDeleteItem (hWndGraphLegend, pLine) ;

   LineFree (pLine) ;

   SizeGraphComponents (hWndGraph) ;


   }

void ClearGraphDisplay (PGRAPHSTRUCT pGraph)
   {
   PLINESTRUCT    pLine;

   // reset the timeline data
//   pGraph->gKnownValue = -1 ;
   pGraph->gKnownValue = 0 ;
   pGraph->gTimeLine.iValidValues = 0 ;
   pGraph->gTimeLine.xLastTime = 0 ;
   memset (pGraph->pDataTime, 0, sizeof(SYSTEMTIME) * (pGraph->gMaxValues + 1)) ;

   // loop through lines,
   // If one of the lines is highlighted then do the calculations
   // for average, min, & max on that line.

   for (pLine=pGraph->pLineFirst; pLine; pLine=pLine->pLineNext)
      { // for

      pLine->bFirstTime = 2 ;
      pLine->lnMinValue = FLT_MAX ;
      pLine->lnMaxValue = - FLT_MAX ;
      pLine->lnAveValue = 0.0F ;
      pLine->lnValidValues = 0 ;
      memset (pLine->lnValues, 0, sizeof(FLOAT) * (pGraph->gMaxValues + 1)) ;
      }

   StatusTimer (hWndGraphStatus, TRUE) ;
   WindowInvalidate (hWndGraphDisplay) ;
   }

void ResetGraphView (HWND hWndGraph)
   {
   PGRAPHSTRUCT      pGraph ;

   pGraph = GraphData (hWndGraph) ;


   if (!pGraph)
      {
      return ;
      }

   ChangeSaveFileName (NULL, IDM_VIEWCHART) ;

   if (pGraph->pSystemFirst)
      {
      ResetGraph (pGraph) ;
      }
   }  // ResetGraphView

void ResetGraph (PGRAPHSTRUCT pGraph)
   {
   ClearGraphTimer (pGraph) ;
   ClearLegend (hWndGraphLegend) ;
   if (pGraph->pLineFirst)
      {
      FreeLines (pGraph->pLineFirst) ;
      pGraph->pLineFirst = NULL ;
      }

   if (pGraph->pSystemFirst)
      {
      FreeSystems (pGraph->pSystemFirst) ;
      pGraph->pSystemFirst = NULL ;
      }
//   pGraph->gKnownValue = -1 ;
   pGraph->gKnownValue = 0 ;
   pGraph->gTimeLine.iValidValues = 0 ;
   pGraph->gTimeLine.xLastTime = 0 ;

   // reset visual data
   pGraph->Visual.iColorIndex = 0 ;
   pGraph->Visual.iWidthIndex = 0 ;
   pGraph->Visual.iStyleIndex = 0 ;

   memset (pGraph->pDataTime, 0, sizeof(SYSTEMTIME) * (pGraph->gMaxValues + 1)) ;

   SizeGraphComponents (hWndGraph) ;
   InvalidateRect(hWndGraph, NULL, TRUE) ;
   }



void PlaybackChart (HWND hWndChart)
   {  // PlaybackChart
   int            iDisplayTics ;       // num visual points to display
   int            iDisplayTic ;
   int            iLogTic ;
   int            iLogTicsMove ;
   BOOL           bFirstTime = TRUE;
   int            iLogTicsRemaining ;

   if (!pGraphs->pLineFirst)
      {
      // no line to playback
      return ;
      }

   iLogTicsRemaining = PlaybackLog.iSelectedTics ;


   // we only have iDisplayTics-1 points since
   // we have to use the first two sample points to
   // get the first data points.
   if (iLogTicsRemaining <= pGraphs->gMaxValues)
      {
      iDisplayTics = iLogTicsRemaining ;
      pGraphs->gTimeLine.iValidValues = iDisplayTics - 1 ;
      }
   else
      {
      iDisplayTics = pGraphs->gMaxValues ;
      pGraphs->gTimeLine.iValidValues = iDisplayTics ;
      }

   iDisplayTic = -1 ;
   iLogTic = PlaybackLog.StartIndexPos.iPosition ;

   while (iDisplayTics)
      {

      PlaybackLines (pGraphs->pSystemFirst, 
                     pGraphs->pLineFirst, 
                     iLogTic) ;

      if (bFirstTime)
         {
         bFirstTime = FALSE ;

         // get the second sample data to form the first data point
         iLogTic++ ;
         iLogTicsRemaining-- ;
         PlaybackLines (pGraphs->pSystemFirst, 
                        pGraphs->pLineFirst, 
                        iLogTic) ;
         }
      iDisplayTic++ ;
      PlaybackSetGraphLines (hWndChart, pGraphs->pLineFirst, 
         iDisplayTic, iLogTic, (iDisplayTics == 1)) ;

      // setup DDA to get the index of the next sample point
      iLogTicsMove = DDA_DISTRIBUTE (iLogTicsRemaining, iDisplayTics) ;
      iLogTicsRemaining -= iLogTicsMove ;
      iLogTic += iLogTicsMove ;

      iDisplayTics-- ;

      }  // while

   // point to the last value for valuebar display
   pGraphs->gKnownValue = iDisplayTic ;

   }  // PlaybackChart



#if 0
PLINESTRUCT CurrentGraphLine (HWND hWndGraph)
   {  // CurrentGraphLine
   UNREFERENCED_PARAMETER (hWndGraph) ;

   return (LegendCurrentLine (hWndGraphLegend)) ;
   }
#endif


BOOL AddChart (HWND hWndParent)
   {
   PLINE pCurrentLine = CurrentGraphLine (hWndGraph) ;

   return (AddLine (hWndParent, 
                    &(pGraphs->pSystemFirst), 
                    &(pGraphs->Visual), 
                    pCurrentLine ? pCurrentLine->lnSystemName : NULL,
                    LineTypeChart)) ;
   }


BOOL EditChart (HWND hWndParent)
   {  // EditChart
   return (EditLine (hWndParent, 
                     &(pGraphs->pSystemFirst), 
                     CurrentGraphLine (hWndGraph),
                     LineTypeChart)) ;
   }

void GraphAddAction ()
   {
   PGRAPHSTRUCT      pGraph ;

   pGraph = GraphData (hWndGraph) ;

   SizeGraphComponents (hWndGraph) ;
   
   LegendSetSelection (hWndGraphLegend,
      LegendNumItems (hWndGraphLegend) - 1) ;

   if (PlayingBackLog ())
      PlaybackChart (pGraph->hWnd) ;
   }

BOOL OpenChartVer1 (HANDLE hFile,
                    DISKCHART *pDiskChart,
                    PGRAPHSTRUCT pGraph)
   {  // OpenChartVer1
   bDelayAddAction = TRUE ;
   pGraph->Visual = pDiskChart->Visual ;
   pGraph->gOptions = pDiskChart->gOptions ;
   pGraph->gMaxValues = pDiskChart->gMaxValues ;
   pGraph->bManualRefresh = pDiskChart->bManualRefresh ;
   pGraphs->gInterval = (INT) (pGraph->gOptions.eTimeInterval * (FLOAT) 1000.0) ;
   ReadLines (hFile, pDiskChart->dwNumLines,
               &(pGraph->pSystemFirst), &(pGraph->pLineFirst), IDM_VIEWCHART) ;
   
   bDelayAddAction = FALSE ;

   GraphAddAction () ;

   return (TRUE) ;
   }  // OpenChartVer1



BOOL OpenChart (HWND hWndGraph,
                HANDLE hFile,
                DWORD dwMajorVersion,
                DWORD dwMinorVersion,
                BOOL bChartFile)
   {  // OpenChart
   PGRAPHSTRUCT   pGraph ;
   DISKCHART      DiskChart ;
   BOOL           bSuccess = TRUE ;

   pGraph = pGraphs ;
   if (!pGraph)
      {
      bSuccess = FALSE ;
      goto Exit0 ;
      }

   if (!FileRead (hFile, &DiskChart, sizeof (DISKCHART)))
      {
      bSuccess = FALSE ;
      goto Exit0 ;
      }


   switch (dwMajorVersion)
      {
      case (1):

         SetHourglassCursor() ;
         
         ResetGraphView (hWndGraph) ;

         OpenChartVer1 (hFile, &DiskChart, pGraph) ;

         // change to chart view if we are opening a 
         // chart file
         if (bChartFile && iPerfmonView != IDM_VIEWCHART)
            {
            SendMessage (hWndMain, WM_COMMAND, (LONG)IDM_VIEWCHART, 0L) ;
            }

         if (iPerfmonView == IDM_VIEWCHART)
            {
            SetPerfmonOptions (&DiskChart.perfmonOptions) ;
            }
         
         SetArrowCursor() ;

         break ;
      }  // switch

Exit0:

   if (bChartFile)
      {
      CloseHandle (hFile) ;
      }

   return (bSuccess) ;
   }  // OpenChart

BOOL SaveChart (HWND hWndGraph, HANDLE hInputFile, BOOL bGetFileName)
   {
   PGRAPHSTRUCT   pGraph ;
   PLINE          pLine ;
   HANDLE         hFile ;
   DISKCHART      DiskChart ;
   PERFFILEHEADER FileHeader ;
   TCHAR          szFileName [256] ;
   BOOL           newFileName = FALSE ;

   if (hInputFile)
      {
      // use the input file handle if it is available
      // this is the case for saving workspace data
      hFile = hInputFile ;
      }
   else
      {
      if (pChartFullFileName)
         {
         lstrcpy (szFileName, pChartFullFileName) ;
         }
      if (bGetFileName || pChartFullFileName == NULL)
         {
//         if (!pChartFullFileName)
//            {
//            StringLoad (IDS_GRAPH_FNAME, szFileName) ;
//            }

         if (!FileGetName (hWndGraph, IDS_CHARTFILE, szFileName))
            {
            return (FALSE) ;
            }
         newFileName = TRUE ;
         }

      hFile = FileHandleCreate (szFileName) ;

      if (hFile && hFile != INVALID_HANDLE_VALUE && newFileName)
         {
         ChangeSaveFileName (szFileName, IDM_VIEWCHART) ;
         }
      else if (!hFile || hFile == INVALID_HANDLE_VALUE)
         {
         DlgErrorBox (hWndGraph, ERR_CANT_OPEN, szFileName) ;
         }
      }

   if (!hFile || hFile == INVALID_HANDLE_VALUE)
      return (FALSE) ;

   pGraph = pGraphs ;
   if (!pGraph)
      {
      if (!hInputFile || hInputFile == INVALID_HANDLE_VALUE)
         {
         CloseHandle (hFile) ;
         }
      return (FALSE) ;
      }

   if (!hInputFile || hInputFile == INVALID_HANDLE_VALUE)
      {
      // only need to write file header if not workspace 
      memset (&FileHeader, 0, sizeof (FileHeader)) ;
      lstrcpy (FileHeader.szSignature, szPerfChartSignature) ;
      FileHeader.dwMajorVersion = ChartMajorVersion ;
      FileHeader.dwMinorVersion = ChartMinorVersion ;
   
      if (!FileWrite (hFile, &FileHeader, sizeof (PERFFILEHEADER)))
         {
         goto Exit0 ;
         }
      }

   DiskChart.Visual = pGraph->Visual ;
   DiskChart.gOptions = pGraph->gOptions ;
   DiskChart.gMaxValues = pGraph->gMaxValues ;
   DiskChart.dwNumLines = NumLines (pGraph->pLineFirst) ;
   DiskChart.bManualRefresh = pGraph->bManualRefresh ;
   DiskChart.perfmonOptions = Options ;

   if (!FileWrite (hFile, &DiskChart, sizeof (DISKCHART)))
      {
      goto Exit0 ;
      }

   for (pLine = pGraph->pLineFirst ;
        pLine ;
        pLine = pLine->pLineNext)
      {  // for
      if (!WriteLine (pLine, hFile))
         {
         goto Exit0 ;
         }
      }  // for

   if (!hInputFile || hInputFile == INVALID_HANDLE_VALUE)
      {
      CloseHandle (hFile) ;
      }

   return (TRUE) ;

Exit0:
   if (!hInputFile || hInputFile == INVALID_HANDLE_VALUE)
      {
      CloseHandle (hFile) ;

      // only need to report error if not workspace 
      DlgErrorBox (hWndGraph, ERR_SETTING_FILE, szFileName) ;
      }
   return (FALSE) ;

   }  // SaveChart

#define TIME_TO_WRITE 2
BOOL ExportChartLabels (HANDLE hFile, PGRAPHSTRUCT pGraph)
{
   TCHAR          UnicodeBuff [LongTextLen] ;
   CHAR           TempBuff [LongTextLen * 2] ;
   int            StringLen ;
   PLINESTRUCT    pLine;
   int            TimeToWriteFile ;
   int            iIndex ;
   LPTSTR         lpItem = NULL;

   for (iIndex = 0 ; iIndex < 5 ; iIndex++)
      {
      // for iIndex == 0, get counter name 
      // for iIndex == 1, get instance name
      // for iIndex == 2, get parent name
      // for iIndex == 3, get object name 
      // for iIndex == 4, get computer name
      if (iIndex == 4)
         {
         // the last label field, write date/time labels
         strcpy (TempBuff, LineEndStr) ;
         StringLen = strlen (TempBuff) ;
         StringLoad (IDS_EXPORT_DATE, UnicodeBuff) ;
         ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
         strcat (TempBuff, pDelimiter) ;
         StringLen = strlen (TempBuff) ;
      
         StringLoad (IDS_EXPORT_TIME, UnicodeBuff) ;
         ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
         strcat (TempBuff, pDelimiter) ;
         StringLen = strlen (TempBuff) ;
         }
      else
         {
         strcpy (TempBuff, LineEndStr) ;
         strcat (TempBuff, pDelimiter) ;
         strcat (TempBuff, pDelimiter) ;
         StringLen = strlen (TempBuff) ;
         }

      TimeToWriteFile = 0 ;

      for (pLine=pGraph->pLineFirst; pLine; pLine=pLine->pLineNext)
         {
         switch (iIndex)
            {
            case 0:
               lpItem = (LPTSTR) pLine->lnCounterName ;
               break ;

            case 1:
               lpItem = (LPTSTR) pLine->lnInstanceName ;
               break ;

            case 2:
               lpItem = (LPTSTR) pLine->lnPINName ;
               break ;

            case 3:
               lpItem = (LPTSTR) pLine->lnObjectName ;
               break ;

            case 4:
               lpItem = (LPTSTR) pLine->lnSystemName ;
               break ;
            }

         if (lpItem)
            {
            ConvertUnicodeStr (&TempBuff[StringLen], lpItem) ;
            }
         else
            {
            TempBuff[StringLen] = '\0' ;
            }
         strcat (TempBuff, pDelimiter);
         StringLen = strlen (TempBuff) ;
   
         if (++TimeToWriteFile > TIME_TO_WRITE)
            {
            // better write the buffers before they overflow.
            // there are better ways to check for overflow 
            // but this is good enough
   
            if (!FileWrite (hFile, TempBuff, StringLen))
               {
               goto Exit0 ;
               }
            StringLen = TimeToWriteFile = 0 ;
            }
         }     // for each line

      if (StringLen)
         {
         // write the last block of data
         if (!FileWrite (hFile, TempBuff, StringLen))
            {
            goto Exit0 ;
            }
         }
      }     // for iIndex

   return (TRUE) ;

Exit0:
   return (FALSE) ;

}  // ExportChartLabels

BOOL ExportLogChart (HANDLE hFile, PGRAPHSTRUCT pGraph)
{
   TCHAR          UnicodeBuff [LongTextLen] ;
   CHAR           TempBuff [LongTextLen * 2] ;
   int            StringLen ;
   PLINESTRUCT    pLine;
   int            TimeToWriteFile ;
   FLOAT          eValue ;
   int            iLogTic ;
   BOOL           bFirstTime = TRUE ;
   SYSTEMTIME     LogSystemTime ;
   LOGPOSITION    LogPosition ;

   iLogTic = PlaybackLog.StartIndexPos.iPosition ;

   // we have to export every point from the log file 

   for ( ; iLogTic <= PlaybackLog.StopIndexPos.iPosition ; iLogTic++)
      {

      PlaybackLines (pGraphs->pSystemFirst, 
                     pGraphs->pLineFirst, 
                     iLogTic) ;

      if (!bFirstTime)
         {
         // export the values
         TimeToWriteFile = 0 ;

         
         if (!LogPositionN (iLogTic, &LogPosition))
            {
            goto Exit0 ;
            }

         LogPositionSystemTime (&LogPosition, &LogSystemTime) ;

         strcpy (TempBuff, LineEndStr) ;
         StringLen = strlen (TempBuff) ;

         SystemTimeDateString (&LogSystemTime, UnicodeBuff) ;
         ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
         strcat (TempBuff, pDelimiter) ;
         StringLen = strlen (TempBuff) ;

         SystemTimeTimeString (&LogSystemTime, UnicodeBuff, FALSE) ;
         ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
         strcat (TempBuff, pDelimiter) ;
         StringLen = strlen (TempBuff) ;

         for (pLine=pGraph->pLineFirst; pLine; pLine=pLine->pLineNext)
            {
      
            eValue = CounterEntry (pLine) ;

            TSPRINTF (UnicodeBuff,
                      eValue > (FLOAT)999999.0 ?
                           szLargeValueFormat : szSmallValueFormat,
                      eValue) ;
            ConvertDecimalPoint (UnicodeBuff) ;
            ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
            strcat (TempBuff, pDelimiter) ;
            StringLen = strlen (TempBuff) ;

            if (++TimeToWriteFile > TIME_TO_WRITE)
               {
               if (!FileWrite (hFile, TempBuff, StringLen))
                  {
                  goto Exit0 ;
                  }
               StringLen = TimeToWriteFile = 0 ;
               TempBuff[0] = '\0' ;
               }
            }

         if (StringLen)
            {
            if (!FileWrite (hFile, TempBuff, StringLen))
               {
               goto Exit0 ;
               }
            }
         }
      else
         {
         // skip the first data point since we
         // need 2 points to form the first value
         bFirstTime = FALSE ;
         }
      }

   return (TRUE) ;

Exit0:
   return (FALSE) ;

}  // ExportLogChart

BOOL ExportLineValue (HANDLE hFile, PGRAPHSTRUCT pGraph,
   int CurrentIndex, int iDataPoint)
{
   TCHAR          UnicodeBuff [MiscTextLen] ;
   CHAR           TempBuff [LongTextLen] ;
   int            StringLen ;
   PLINESTRUCT    pLine;
   int            MaxValues ;
   int            TimeToWriteFile ;
   SYSTEMTIME     *pSystemTime ;
   BOOL           ValidValue ;

   pSystemTime = pGraph->pDataTime ;
   pSystemTime += CurrentIndex ;

   if (pSystemTime->wYear == 0 && pSystemTime->wYear == 0)
      {
      // ignore value that has 0 system time
      return (TRUE) ;
      }

   MaxValues = pGraph->gMaxValues ;
   strcpy (TempBuff, LineEndStr) ;
   StringLen = strlen (TempBuff) ;

   SystemTimeDateString (pSystemTime, UnicodeBuff) ;
   ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
   strcat (TempBuff, pDelimiter) ;
   StringLen = strlen (TempBuff) ;

   SystemTimeTimeString (pSystemTime, UnicodeBuff, FALSE) ;
   ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
   strcat (TempBuff, pDelimiter) ;
   StringLen = strlen (TempBuff) ;

   TimeToWriteFile = 0 ;
   for (pLine=pGraph->pLineFirst; pLine; pLine=pLine->pLineNext)
      {
      if (!pLine->bFirstTime)
         {
         ValidValue = FALSE ;
         // check if this is a valid value
         if (pLine->lnValidValues == MaxValues)
            {
            // this is the simple case where we have filled up 
            // the whole buffer
            ValidValue = TRUE ;
            }
         else if (pLine->lnValidValues <= iDataPoint)
            {
            if (CurrentIndex <= iDataPoint &&
               CurrentIndex > iDataPoint - pLine->lnValidValues)
               {
               ValidValue = TRUE ;
               }
            }
         else
            {
            if (CurrentIndex <= iDataPoint ||
               CurrentIndex > (MaxValues - pLine->lnValidValues + iDataPoint))
               {
               // this is the case when we start the new line in the middle
               // and data buffer has been wrap-around.
               ValidValue = TRUE ;
               }
            }

         // only export the data when we determine it is valid
         if (ValidValue)
            {
            TSPRINTF (UnicodeBuff,
               pLine->lnValues[CurrentIndex] > (FLOAT)999999.0 ?
               szLargeValueFormat : szSmallValueFormat,
               pLine->lnValues[CurrentIndex]) ;
            ConvertDecimalPoint (UnicodeBuff) ;
            ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
            }
         }
      strcat (TempBuff, pDelimiter) ;
      StringLen = strlen (TempBuff) ;

      if (++TimeToWriteFile > TIME_TO_WRITE)
         {
         // better write the buffers before they overflow.
         // there are better ways to check for overflow 
         // but this is good enough
   
         if (!FileWrite (hFile, TempBuff, StringLen))
            {
            goto Exit0 ;
            }
         StringLen = TimeToWriteFile = 0 ;
         TempBuff[0] = '\0' ;
         }
      }

   if (StringLen)
      {
      // write the last block of data
      if (!FileWrite (hFile, TempBuff, StringLen))
         {
         goto Exit0 ;
         }
      }

   return (TRUE) ;

Exit0:
   return (FALSE) ;

}     // ExportLineValue

BOOL ExportCurrentChart (HANDLE hFile, PGRAPHSTRUCT pGraph)
{
   int            KnownValue,
                  MaxValues,
                  iValidValues,
                  iDataPoint ;
   BOOL           SimpleCase = FALSE ;
   int            iIndex ;

   MaxValues = pGraph->gMaxValues ;
   KnownValue = pGraph->gKnownValue ;
   iValidValues = pGraph->gTimeLine.iValidValues ;

   if (iValidValues < MaxValues)
      {
      // data have not wrapped around, so the oldest time
      // is started at 0.
      SimpleCase = TRUE ;
      iValidValues = (KnownValue % MaxValues) + 1 ;
      }

   iDataPoint = KnownValue % MaxValues ;

   if (!SimpleCase)
      {
      for (iIndex = iDataPoint+1 ; iIndex < MaxValues ; iIndex++)
         {
         if (!ExportLineValue (hFile, pGraph, iIndex, iDataPoint))
            {
            goto Exit0 ;
            }
         }
      }

   for (iIndex = 0 ; iIndex <= iDataPoint ; iIndex++)
      {
      if (!ExportLineValue (hFile, pGraph, iIndex, iDataPoint))
         {
         goto Exit0 ;
         }
      }

   return (TRUE) ;

Exit0:
   return (FALSE) ;

}  // ExportCurrentChart


void ExportChart (void)
{

   PGRAPHSTRUCT   pGraph ;
   HANDLE         hFile = 0 ;
   LPTSTR         pFileName = NULL ;
   INT            ErrCode = 0 ;

   if (!(pGraph = pGraphs))
      {
      return ;
      }

   // see if there is anything to export..
   if (!(pGraph->pLineFirst))
      {
      return ;
      }

   SetHourglassCursor() ;
   
   if (ErrCode = ExportFileOpen (hWndGraph, &hFile, pGraph->gInterval, &pFileName))
      {
      goto Exit0 ;
      }

   if (!pFileName)
      {
      // this is the case when user cancel.
      goto Exit0 ;
      }

   // export the column labels
   if (!ExportChartLabels (hFile, pGraph))
      {
   
      ErrCode = ERR_EXPORT_FILE ;
      goto Exit0 ;
      }

   // export the lines
   if (PlayingBackLog())
      {
      if (!ExportLogChart (hFile, pGraph))
         {
         ErrCode = ERR_EXPORT_FILE ;
         goto Exit0 ;
         }
      }
   else
      {
      if (!ExportCurrentChart (hFile, pGraph))
         {
         ErrCode = ERR_EXPORT_FILE ;
         goto Exit0 ;
         }
      }
Exit0:

   SetArrowCursor() ;

   if (hFile)
      {
      CloseHandle (hFile) ;
      }

   if (pFileName)
      {
      if (ErrCode)
         {
         DlgErrorBox (hWndGraph, ErrCode, pFileName) ;
         }

      MemoryFree (pFileName) ;
      }

}     // ExportChart


typedef struct CHARTDATAPOINTSTRUCT
   {
   int         iLogIndex ;
   int         xDispDataPoint ;
   } CHARTDATAPOINT, *PCHARTDATAPOINT ;

void PlaybackChartDataPoint (PCHARTDATAPOINT pChartDataPoint)
   {  // PlaybackChartDataPoint
   int            iDisplayTics ;       // num visual points to display
   int            iDisplayTic ;
   int            iLogTic ;
   int            iLogTicsMove ;
   BOOL           bFirstTime = TRUE;
   int            iLogTicsRemaining ;
   int            numOfData, xDispDataPoint, rectWidth, xPos ;
   PGRAPHSTRUCT   pGraph ;

   pGraph = GraphData (hWndGraph) ;

   iLogTicsRemaining = PlaybackLog.iSelectedTics ;


   // we only have iDisplayTics-1 points since
   // we have to use the first two sample points to
   // get the first data points.
   if (iLogTicsRemaining <= pGraphs->gMaxValues)
      {
      iDisplayTics = iLogTicsRemaining ;
      }
   else
      {
      iDisplayTics = pGraphs->gMaxValues ;
      }

   iDisplayTic = -1 ;
   iLogTic = PlaybackLog.StartIndexPos.iPosition ;

   numOfData      = pGraph->gMaxValues - 1 ;
   rectWidth      = pGraph->rectData.right - pGraph->rectData.left ;
   xDispDataPoint = pGraph->rectData.left ;

   while (iDisplayTics && numOfData)
      {

      if (!bFirstTime)
         {
         iDisplayTic++ ;
         }
      else
         {
         bFirstTime = FALSE ;

         // get the second sample data to form the first data point
         iLogTic++ ;
         iLogTicsRemaining-- ;

         iDisplayTic++ ;
         }

      pChartDataPoint[iDisplayTic].iLogIndex = iLogTic ;
      pChartDataPoint[iDisplayTic].xDispDataPoint = xDispDataPoint ;

      // setup DDA to get the index of the next sample point
      iLogTicsMove = DDA_DISTRIBUTE (iLogTicsRemaining, iDisplayTics) ;
      iLogTicsRemaining -= iLogTicsMove ;
      iLogTic += iLogTicsMove ;


      xPos = DDA_DISTRIBUTE (rectWidth, numOfData) ;
      xDispDataPoint += xPos ;
      numOfData-- ;
      rectWidth -= xPos ;

      iDisplayTics-- ;

      }  // while

   }  // PlaybackChartDataPoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\grafdisp.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include <stdio.h>
#include "perfmon.h"
#include "grafdisp.h"      // external declarations for this file

#include "grafdata.h"      // for InsertGraph, et al.
#include "graph.h"
#include "legend.h"
#include "line.h"          // for LineCreatePen
#include "perfmops.h"      // for DoWindowDrag
#include "playback.h"      // for PlayingBackLog
#include "valuebar.h"
#include "utils.h"
#include "timeline.h"      // for IsTLineWindowUp & TLineRedraw
#include "counters.h"      // for CounterEntry

//==========================================================================//
//                                  Constants                               //
//==========================================================================//

// this macro is used in doing a simple DDA (Digital Differential Analyzer)
// * 10 + 5 is to make the result round up with .5
#define DDA_DISTRIBUTE(TotalTics, numOfData) \
   ((TotalTics * 10 / numOfData) + 5) / 10

HDC   hGraphDisplayDC ;
//=============================//
// GraphDisplay Class          //
//=============================//


TCHAR   szGraphDisplayWindowClass[] = TEXT("PerfChart") ;
#define dwGraphDisplayClassStyle    (CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS | CS_OWNDC)
#define iGraphDisplayClassExtra     (0)
#define iGraphDisplayWindowExtra    (0)
#define dwGraphDisplayWindowStyle   (WS_CHILD | WS_VISIBLE)



//==========================================================================//
//                              Local Functions                             //
//==========================================================================//
BOOL UpdateTimeLine (HDC hDC, PGRAPHSTRUCT pGraph, BOOL getLastTimeLocation) ;

INT
ScaleAndInvertY (
                FLOAT ey,
                PLINESTRUCT pLineStruct,
                PGRAPHSTRUCT pGraph
                )
/*
   Effect:        Given data value ey, scale and fit the value to fit
                  within the graph data area of the window, considering
                  the scale set for the line and the current size of the
                  data rectangle.
*/
{
    INT     yGraphDataHeight,               // Height of graph area
    yInverted ;                     // Scaled & Inverted Y.
    FLOAT   eppd,
    eyScaled ;

    // Take care of any scaling now, at output time.
    ey *= pLineStruct->eScale ;

    // Calculate the Cy of the graph area.
    yGraphDataHeight = pGraph->rectData.bottom - pGraph->rectData.top ;

    // Calculate the pixels per data point.
    eppd = (FLOAT) ((FLOAT) yGraphDataHeight / (FLOAT) pGraph->gOptions.iVertMax) ;
    eyScaled = eppd * ey ;
    yInverted = (INT) (((FLOAT) yGraphDataHeight) - eyScaled) ;

    yInverted += pGraph->rectData.top ;

    // Clamp the range to fit with in the graph portion of the windows
    yInverted = PinInclusive (yInverted,
                              pGraph->rectData.top, pGraph->rectData.bottom) ;
    return (yInverted) ;
}


BOOL
DrawGrid (
         HDC hDC,
         PGRAPHSTRUCT pGraph,
         LPRECT lpRect,
         BOOL bForPaint
         )
/*
   Effect:        Draw the grid lines in the graph display window.
                  These grid lines are in the graph data area only,
                  which is indicated by pGraph->rectData.

   Called By:     OnPaint only.
*/
{
    int            iGrid, iLines ;
    int            xGrid, yGrid ;
    POINT          aPoints [4 * iGraphMaxTics] ;
    DWORD          aCounts [2 * iGraphMaxTics] ;
    HPEN           hPenPrevious ;
    int            bottomAdjust ;

    if (!pGraph->gOptions.bHorzGridChecked &&
        !pGraph->gOptions.bVertGridChecked)
        return (FALSE) ;


    hPenPrevious = SelectPen (hDC, IsPrinterDC (hDC) ?
                              GetStockObject (BLACK_PEN) : pGraph->hGridPen) ;

    iLines = 0 ;

    if (pGraph->gOptions.bHorzGridChecked) {
        for (iGrid = 1 ;
            iGrid < pGraph->yNumTics ;
            iGrid++) {
            yGrid = pGraph->ayTics[iGrid] + pGraph->rectData.top ;
            if (yGrid >= lpRect->top &&
                yGrid <= lpRect->bottom) {
                aPoints[2 * iLines].x = lpRect->left ;
                aPoints[2 * iLines].y = yGrid ;
                aPoints[2 * iLines + 1].x = lpRect->right ;
                aPoints[2 * iLines + 1].y = yGrid ;

                aCounts[iLines] = 2 ;
                iLines++ ;
            }
        }
    }

    if (pGraph->gOptions.bVertGridChecked) {
        bottomAdjust = lpRect->bottom + (bForPaint ? 1 : 0) ;
        for (iGrid = 1 ;
            iGrid < pGraph->xNumTics ;
            iGrid++) {
            xGrid = pGraph->axTics[iGrid] + pGraph->rectData.left ;
            if (xGrid >= lpRect->left &&
                xGrid <= lpRect->right) {
                aPoints[2 * iLines].x = xGrid ;
                aPoints[2 * iLines].y = lpRect->top ;
                aPoints[2 * iLines + 1].x = xGrid ;
                aPoints[2 * iLines + 1].y = bottomAdjust ;

                aCounts[iLines] = 2 ;
                iLines++ ;
            }
        }
    }

    if (iLines)
        PolyPolyline (hDC, aPoints, aCounts, iLines) ;

    SelectPen (hDC, hPenPrevious) ;

    return (TRUE) ;
}



BOOL
DrawBarChartData (
                 HDC hDC,
                 PGRAPHSTRUCT pGraph
                 )
{
    PLINESTRUCT pLineStruct ;
    PFLOAT      pDataPoints ;
    INT         nLegendItems,
    cx,
    cxBar,
    xDataPoint = 0,
                 y  = 0;
    RECT        rectBar ;
    RECT        rectBkgrnd ;
    HBRUSH      hOldBrush ;
    FLOAT       eValue ;
    PLINESTRUCT pCurrentLine ;

    // Determine how many items are in the legend.

    nLegendItems = 0 ;

    for (pLineStruct = pGraph->pLineFirst ;
        pLineStruct ;
        pLineStruct = pLineStruct->pLineNext) {
        nLegendItems++ ;
    }

    if (nLegendItems == 0)
        return(FALSE) ;

    // get current select line for highlighting
    if (pGraph->HighLightOnOff) {
        pCurrentLine = CurrentGraphLine (hWndGraph) ;
    } else {
        pCurrentLine = NULL ;
    }

    // Determine the width of each bar.
    cx = pGraph->rectData.right - pGraph->rectData.left ;


    if (PlayingBackLog()) {
        // get the average using the start and stop data point
        // from the log file
        PlaybackLines (pGraph->pSystemFirst,
                       pGraph->pLineFirst,
                       PlaybackLog.StartIndexPos.iPosition) ;
        PlaybackLines (pGraph->pSystemFirst,
                       pGraph->pLineFirst,
                       PlaybackLog.StopIndexPos.iPosition) ;
    } else {
        // Loop through all the DataLines and draw a bar for
        // it's last value.
        xDataPoint = pGraph->gKnownValue % pGraph->gMaxValues ;
    }

    rectBar.bottom = pGraph->rectData.bottom + 1 ;

    rectBkgrnd = pGraph->rectData ;

    hOldBrush = SelectBrush (hDC, hBrushFace) ;

    PatBlt (hDC,
            rectBkgrnd.left, rectBkgrnd.top,
            rectBkgrnd.right - rectBkgrnd.left,
            rectBkgrnd.bottom - rectBkgrnd.top + 1,
            PATCOPY) ;
    DrawGrid(hDC, pGraph, &(rectBkgrnd), FALSE) ;

    rectBar.right = pGraph->rectData.left ;
    for (pLineStruct = pGraph->pLineFirst ;
        pLineStruct ;
        pLineStruct = pLineStruct->pLineNext) {
        pDataPoints = pLineStruct->lnValues ;

        if (PlayingBackLog()) {
            eValue = CounterEntry (pLineStruct) ;
        } else {
            eValue = pDataPoints[xDataPoint] ;
        }


        y = ScaleAndInvertY (eValue,
                             pLineStruct,
                             pGraph) ;

        rectBar.left   = rectBar.right ;
        rectBar.top    = y ;

        // nomore line to draw
        if (nLegendItems == 0 ) {
            break ;
        }

        cxBar = DDA_DISTRIBUTE (cx, nLegendItems) ;
        rectBar.right  = rectBar.left + cxBar ;

        // setup for next DDA
        nLegendItems-- ;
        cx -= cxBar ;

        // NOTE: this handle creation should be moved to line
        //       create time.

        if (pCurrentLine == pLineStruct) {
            SetBkColor (hDC, crWhite) ;
        } else {
            SetBkColor (hDC, pLineStruct->Visual.crColor) ;
        }
        ExtTextOut (hDC, rectBar.right, rectBar.top, ETO_OPAQUE,
                    &rectBar, NULL, 0, NULL) ;
    }

    return (TRUE) ;
}


/***************************************************************************
 * DrawTLGraphData - Draw Time Line Graph Data.
 *
 *  Some notes about drawing the DataPoint graphs.
 *
 *      1]  It's real expensive to make a GDI call. So, we do not
 *          make a MoveToEx and LineTo call for each point.  Instead
 *          we create a polyline and send it down to GDI.
 *
 *      2]  The X coordinates for each point in the polyline is generated
 *          from our favorite xDataPoint to xWindows DDA.
 *
 *      3]  The Y coordinate is generated from the pLineStruct->lnValues[x]
 *          data associated with each line.
 ***************************************************************************/
BOOL
DrawTLGraphData (
                HDC hDC,
                BOOL bForPaint,
                PRECT prctPaint,
                PGRAPHSTRUCT pGraph
                )
/*
   Called By:     UpdateGraphDisplay only.
*/
{
    PLINESTRUCT pLineStruct ;
    HPEN        hPen = 0 ;
    HPEN        hOldPen ;
    PFLOAT      pDataPoints ;
    INT         i, j,
    iValidValues,
    xDispDataPoint,
    xLeftLimit,
    xRightLimit ;
    PPOINT      pptDataPoints ;
    INT         numOfData, rectWidth, xPos ;
    PLINESTRUCT pCurrentLine ;
    INT         DrawZeroPoint = 0 ;

    //   SetBkColor (hDC, crLightGray) ;

    if (!IsPrinterDC (hDC)) {
        if (bForPaint) {
            IntersectClipRect (hDC,
                               pGraph->rectData.left,
                               pGraph->rectData.top,
                               pGraph->rectData.right,
                               pGraph->rectData.bottom + 1) ;
        } else {
            IntersectClipRect (hDC,
                               pGraph->rectData.left,
                               pGraph->rectData.top,
                               PlayingBackLog () ?
                               pGraph->rectData.right :
                               min (pGraph->rectData.right,
                                    pGraph->gTimeLine.xLastTime + 2),
                               pGraph->rectData.bottom + 1) ;
        }
    }

    xLeftLimit  = prctPaint->left  - pGraph->gTimeLine.ppd - 1 ;

    if (bForPaint)
        xRightLimit = prctPaint->right + pGraph->gTimeLine.ppd ;
    else
        xRightLimit = prctPaint->right ;

    pptDataPoints  = pGraph->pptDataPoints ;

    iValidValues   = pGraph->gTimeLine.iValidValues ;

    if (!PlayingBackLog() &&
        pGraph->gOptions.iGraphOrHistogram == LINE_GRAPH) {
        // drawing the 0th at the end of the chart.
        DrawZeroPoint = 1 ;
        if (iValidValues == pGraph->gMaxValues) {
            iValidValues++ ;
        }
    }

    // get current select line for highlighting
    if (pGraph->HighLightOnOff) {
        pCurrentLine = CurrentGraphLine (hWndGraph) ;
    } else {
        pCurrentLine = NULL ;
    }

    // loop through lines to plot
    for (pLineStruct = pGraph->pLineFirst ;
        pLineStruct || pCurrentLine;
        pLineStruct = pLineStruct->pLineNext) {

        if (pLineStruct == NULL) {
            // now draw the current line
            pLineStruct = pCurrentLine ;
        } else if (pLineStruct == pCurrentLine) {
            // skip this line and draw it later
            continue ;
        }

        // "Localize" some variables from the line data structure.
        pDataPoints    = pLineStruct->lnValues ;


        rectWidth      = pGraph->rectData.right - pGraph->rectData.left ;
        numOfData      = pGraph->gMaxValues - 1 + DrawZeroPoint ;

        // Generate the polyline data.
        xDispDataPoint = pGraph->rectData.left ;

        // Only process points that lie within the update region.
        // Also only process points that have valid data.
        j = 0 ;

        for (i = 0 ; i < iValidValues ; i++) {
            if (xDispDataPoint > xRightLimit) {
                // we are done!
                break ;
            }
            if (xDispDataPoint >= xLeftLimit) {
                // It is within the limits, plot the point
                pptDataPoints[j].x = xDispDataPoint ;
                pptDataPoints[j].y = ScaleAndInvertY (
                                                     (i == pGraph->gMaxValues) ? pDataPoints[0] : pDataPoints[i],
                                                     pLineStruct,
                                                     pGraph) ;
                j++ ;
            }

            // setup for the next point
            if (!numOfData) {
                // no more points to go
                break ;
            }

            xPos = DDA_DISTRIBUTE (rectWidth, numOfData) ;
            xDispDataPoint += xPos ;
            numOfData-- ;
            rectWidth -= xPos ;
        }

        // only need to draw the line if there is point to draw.
        if (j > 0) {
            // Set the pen color and draw the polyline.
            if (IsPrinterDC (hDC)) {
                hPen = LineCreatePen (hDC, &(pLineStruct->Visual), TRUE) ;
                hOldPen = SelectObject (hDC, hPen) ;
            } else {
                if (pCurrentLine == pLineStruct) {
                    // highlight this line by turning it into White color
                    hOldPen = SelectObject (hDC, hWhitePen) ;
                } else {
                    SelectObject (hDC, pLineStruct->hPen) ;
                }
            }

            Polyline(hDC, pptDataPoints, j) ;

            if (hPen) {
                SelectObject (hDC, hOldPen) ;

                if (hPen != hWhitePen) {
                    DeletePen (hPen) ;
                }
                hPen = 0 ;
            }
        }

        if (pCurrentLine == pLineStruct) {
            // We are done...
            break ;
        }
    }

    if (IsTLineWindowUp()) {
        // re-draw the timelines if need
        TLineRedraw (hDC, pGraph) ;
    }

    // reset the clipping region
    SelectClipRgn (hDC, pGraph->hGraphRgn) ;

    return (TRUE) ;
}



/***************************************************************************
 * bInitTimeLine - Initialize the fields of the time line structure.
 ***************************************************************************/
BOOL
bInitTimeLine(
             PGRAPHSTRUCT pGraph
             )
{
    pGraph->gTimeLine.xLastTime      = 0 ;
    pGraph->gTimeLine.ppd            = 0 ;
    pGraph->gTimeLine.rppd           = 0 ;
    pGraph->gTimeLine.iValidValues   = 1 ;

    return (TRUE) ;
}


/***************************************************************************
 * Scale Time Line
 *
 *  This routine should be called from the WM_SIZE message.
 *  It does the scaling from the number of data points to the
 *  size of the window.
 ***************************************************************************/
void
ScaleTimeLine (
              PGRAPHSTRUCT pGraph
              )
{
    INT     nDataPoints,
    cxClient ;

    // Calculate the pels per data point.
    nDataPoints = pGraph->gMaxValues - 1 ;
    cxClient    = pGraph->rectData.right - pGraph->rectData.left ;

    // ppd  = Pixels per DataPoint.
    // rppd = Remaining Pixels per DataPoint.
    pGraph->gTimeLine.ppd  = cxClient / nDataPoints ;
    pGraph->gTimeLine.rppd = cxClient % nDataPoints ;
}


void
DisplayTimeLine(
               HDC hDC,
               PGRAPHSTRUCT pGraph
               )
/*
   Called By:     OnPaint only.

   Assert:        xDisplayPoint has been set by UpdateTimeLine on this
                  same timer tick.
*/
{
    INT     xDisplayPoint ;
    RECT    rect ;

    if (pGraph->gTimeLine.xLastTime == -1) {
        UpdateTimeLine (hGraphDisplayDC, pGraph, TRUE) ;
    }

    // xDisplayPoint is X coordinate to display the time line at.
    if ((xDisplayPoint = pGraph->gTimeLine.xLastTime) == 0)
        return ;

    SelectBrush (hDC, pGraph->hbRed) ;

    if (xDisplayPoint >= pGraph->rectData.right) {
        rect.left   = pGraph->rectData.left ;
    } else {
        //      rect.left   = xDisplayPoint++ ;
        rect.left   = xDisplayPoint ;
    }
    rect.top    = pGraph->rectData.top ;
    rect.right  = rect.left + 2 ;
    rect.bottom = pGraph->rectData.bottom ;

    //   IntersectRect (&rect, &rect, &pGraph->rectData) ;
    if (rect.right > pGraph->rectData.right) {
        rect.right = pGraph->rectData.right ;
    }
    PatBlt (hDC,
            rect.left, rect.top,
            rect.right - rect.left,
            rect.bottom - rect.top + 1 ,
            PATCOPY) ;

}

int
SuggestedNumTics (
                 int iRange
                 )
/*
   Effect:        Return an appropriate number of tic marks to display
                  within iRange pixels.

                  These numbers are empirically chosen for pleasing
                  results.
*/
{
    if (iRange < 20)
        return (0) ;

    if (iRange < 50)
        return (2) ;

    if (iRange < 100)
        return (4) ;

    if (iRange < 150)
        return (5) ;

    if (iRange < 300)
        return (10) ;

    if (iRange < 500)
        return (20) ;

    return (25) ;
}



void
SetGridPositions (
                 PGRAPHSTRUCT pGraph
                 )
{
    int            xDataWidth ;
    int            yDataHeight ;

    int            iCurrentTicPixels ;
    int            iNumTics ;

    int            i ;


    //=============================//
    // Set number of Tics          //
    //=============================//

    xDataWidth = pGraph->rectData.right - pGraph->rectData.left ;
    yDataHeight = pGraph->rectData.bottom - pGraph->rectData.top ;

    pGraph->xNumTics = PinInclusive (SuggestedNumTics (xDataWidth),
                                     0, iGraphMaxTics) ;
    pGraph->yNumTics = PinInclusive (SuggestedNumTics (yDataHeight),
                                     0, iGraphMaxTics) ;

    // if we have more tics than possible integral values, reduce the number
    // of tics.
    if (pGraph->gOptions.iVertMax < pGraph->yNumTics)
        pGraph->yNumTics = pGraph->gOptions.iVertMax ;


    //=============================//
    // Set X Tic Positions         //
    //=============================//

    if (pGraph->xNumTics) {
        iNumTics = pGraph->xNumTics ;

        pGraph->axTics[0] = 0 ;
        for (i = 1; i < pGraph->xNumTics; i++) {
            if (iNumTics == 0) {
                break ;
            }
            iCurrentTicPixels = DDA_DISTRIBUTE (xDataWidth, iNumTics) ;
            pGraph->axTics [i] = pGraph->axTics [i - 1] + iCurrentTicPixels ;

            xDataWidth -= iCurrentTicPixels ;
            iNumTics-- ;
        }
    }


    //=============================//
    // Set Y Tic Positions         //
    //=============================//

    if (pGraph->yNumTics) {
        iNumTics = pGraph->yNumTics ;

        pGraph->ayTics[0] = 0 ;
        for (i = 1; i < pGraph->yNumTics; i++) {
            if (iNumTics == 0) {
                break ;
            }
            iCurrentTicPixels = DDA_DISTRIBUTE (yDataHeight, iNumTics) ;
            pGraph->ayTics [i] = pGraph->ayTics [i- 1] + iCurrentTicPixels ;

            yDataHeight -= iCurrentTicPixels ;
            iNumTics-- ;
        }
    }
}

int
GraphVerticalScaleWidth (
                        HDC hDC,
                        PGRAPHSTRUCT pGraph
                        )
{
    TCHAR          szMaxValue [20] ;
    int            xWidth ;

    if (!pGraph->gOptions.bLabelsChecked)
        return (0) ;

    //   SelectFont (hDC, IsPrinterDC (hDC) ? hFontPrinterScales : hFontScales) ;

    TSPRINTF (szMaxValue, TEXT(" %1d "),
              pGraph->gOptions.iVertMax * 10 ) ;

    xWidth = TextWidth (hDC, szMaxValue) ;

    return (xWidth) ;
}


void
DrawGraphScale (
               HDC hDC,
               PGRAPHSTRUCT pGraph
               )
{
    TCHAR   szScale [20] ;

    INT     len,
    i,
    nLines,
    iUnitsPerLine = 0;
    FLOAT   ePercentOfTotal  = 0.0f;
    FLOAT   eDiff ;
    BOOL    bUseFloatingPt = FALSE ;

    //=============================//
    // Draw Vertical Scale?        //
    //=============================//

    if (!pGraph->gOptions.bLabelsChecked)
        return ;

    // Get the number of lines.
    nLines = pGraph->yNumTics ;

    // nLines may be zero if the screen size if getting too small
    if (nLines > 0) {
        // Calculate what percentage of the total each line represents.
        ePercentOfTotal = ((FLOAT) 1.0) / ((FLOAT) nLines)  ;

        // Calculate the amount (number of units) of the Vertical max each
        // each line in the graph represents.
        iUnitsPerLine = (INT) ((FLOAT) pGraph->gOptions.iVertMax * ePercentOfTotal) ;
        ePercentOfTotal *= (FLOAT) pGraph->gOptions.iVertMax ;
        eDiff = (FLOAT)iUnitsPerLine - ePercentOfTotal ;
        if (eDiff < (FLOAT) 0.0)
            eDiff = -eDiff ;

        if (eDiff > (FLOAT) 0.1)
            bUseFloatingPt = TRUE ;
    }

    //=============================//
    // Set Drawing Attributes      //
    //=============================//

    //   SelectFont (hDC, IsPrinterDC (hDC) ? hFontPrinterScales : hFontScales) ;
    SetBkMode(hDC, TRANSPARENT) ;
    SetTextAlign (hDC, TA_TOP | TA_RIGHT) ;
    SelectObject(hDC, GetStockObject (BLACK_PEN)) ;

    // Set the background color to gray
    if (!IsPrinterDC (hDC))
        //      FillRect (hDC, &(pGraph->rectVertScale), hbLightGray) ;
        FillRect (hDC, &(pGraph->rectVertScale), hBrushFace) ;

    // TESTING TESTING
#ifdef   PERFMON_DEBUG
    GdiSetBatchLimit(1) ;   // disable Batching
#endif

    // Now Output each string.
    for (i = 0; i < nLines; i++) {
        if (bUseFloatingPt) {
            len = TSPRINTF (szScale, TEXT("%1.1f"),
                            (FLOAT)pGraph->gOptions.iVertMax - ((FLOAT)i *
                                                                ePercentOfTotal)) ;
            ConvertDecimalPoint (szScale) ;
        } else {
            len = TSPRINTF (szScale, TEXT("%d"),
                            pGraph->gOptions.iVertMax - (i * iUnitsPerLine)) ;
        }
        TextOut (hDC,
                 pGraph->rectVertScale.right,
                 pGraph->ayTics[i] +
                 pGraph->rectData.top - HalfTextHeight,
                 szScale,
                 len) ;
    }

    // Output the "min value" separately.
    TextOut (hDC,
             pGraph->rectVertScale.right,
             pGraph->rectData.bottom - HalfTextHeight,
             TEXT("0"),
             1) ;

#ifdef   PERFMON_DEBUG
    // TESTING TESTING
    GdiSetBatchLimit(0) ;   // enable default Batching
#endif
}

void
SizeGraphDisplayComponentsRect (
                               HDC hDC,
                               PGRAPHSTRUCT pGraph,
                               RECT rectDisplay
                               )
{
    int            xScaleWidth ;

    if (!rectDisplay.right || !rectDisplay.bottom)
        return ;

    //=============================//
    // Size the Vertical Scale     //
    //=============================//

    xScaleWidth = GraphVerticalScaleWidth (hDC, pGraph) ;
    pGraph->rectVertScale.left = rectDisplay.left ;
    pGraph->rectVertScale.top = rectDisplay.top ;
    pGraph->rectVertScale.right = rectDisplay.left + xScaleWidth ;
    pGraph->rectVertScale.bottom = rectDisplay.bottom ;

    //=============================//
    // Size the Horizontal Scale   //
    //=============================//

    pGraph->rectHorzScale.left = 0 ;
    pGraph->rectHorzScale.top = 0 ;
    pGraph->rectHorzScale.right = 0 ;
    pGraph->rectHorzScale.bottom = 0 ;

    //=============================//
    // Size the Data Area          //
    //=============================//

    pGraph->rectData.left = pGraph->rectVertScale.right + 3 + ThreeDPad ;
    pGraph->rectData.right = rectDisplay.right - 5 - ThreeDPad ;
    pGraph->rectData.top = rectDisplay.top + 5 + ThreeDPad ;
    pGraph->rectData.bottom = rectDisplay.bottom - 5 - ThreeDPad ;

    SetGridPositions (pGraph) ;
    ScaleTimeLine (pGraph) ;

    //==========================================//
    // Invalidate the last time line poisition  //
    //==========================================//
    pGraph->gTimeLine.xLastTime = -1 ;

    if (pGraph->hGraphRgn) {
        DeleteObject (pGraph->hGraphRgn) ;
    }

    pGraph->hGraphRgn = CreateRectRgn (rectDisplay.left,
                                       rectDisplay.top,
                                       rectDisplay.right,
                                       rectDisplay.bottom) ;

    SelectClipRgn (hDC, pGraph->hGraphRgn) ;

}


void
SizeGraphDisplayComponents (
                           HWND hWnd
                           )
/*
   Effect:        Given the graph display window hWnd, of size
                  (xWidth x yHeight), determine the size and position
                  of the various graph display components: the vertical
                  scale, the horizontal scale, and the data area.

   Called By:     OnSize, any other routine that changes the visibility
                  of a vertical or horizontal scale.

   Note:          This function has multiple return points.
*/
{  // SizeGraphDisplayComponents
    PGRAPHSTRUCT   pGraph ;
    RECT           rectClient ;

    pGraph = GraphData (hWnd) ;
    GetClientRect (hWnd, &rectClient) ;

    SizeGraphDisplayComponentsRect (hGraphDisplayDC, pGraph, rectClient) ;
}


void
UpdateGraphDisplay (
                   HDC hDC,
                   BOOL bForPaint,
                   LPRECT lpRect,
                   PGRAPHSTRUCT pGraph
                   )
/*
   Effect:        Draw the portions of the graph that change as the
                  graph's values change. This includes the background,
                  the grid, the lines, and the timeline.
*/
{
    RECT           rectUpdate ;

    if (!bForPaint && !IsPrinterDC (hDC) &&
        pGraph->gOptions.iGraphOrHistogram == LINE_GRAPH) {
        HBRUSH         hOldBrush ;

        rectUpdate = pGraph->rectData ;
        rectUpdate.bottom += 1 ;

        IntersectRect (&rectUpdate, lpRect, &rectUpdate) ;
        hOldBrush = SelectBrush (hDC, hBrushFace) ;

        PatBlt (hDC,
                rectUpdate.left, rectUpdate.top,
                rectUpdate.right - rectUpdate.left,
                rectUpdate.bottom - rectUpdate.top,
                PATCOPY) ;
    } else {
        IntersectRect (&rectUpdate, lpRect, &pGraph->rectData) ;
    }

    if (pGraph->gOptions.iGraphOrHistogram == LINE_GRAPH) {
        DrawGrid(hDC, pGraph, &rectUpdate, bForPaint) ;
        if (pGraph->pLineFirst != NULL) {
            DrawTLGraphData(hDC, bForPaint, &rectUpdate, pGraph) ;
            if (!PlayingBackLog ())
                DisplayTimeLine(hDC, pGraph) ;
        }
    } else {
        DrawBarChartData (hDC, pGraph) ;
    }
}


BOOL
UpdateTimeLine (
               HDC hDC,
               PGRAPHSTRUCT pGraph,
               BOOL getLastTimeLocation
               )
/*
   Called By:     GraphTimer only.

   See Also:      UpdateGraphDisplay.
*/
{
    INT     i,
    xDisplayPoint,
    xDataPoint ;
    RECT    rctUpdate ;
    INT     xLastTime ;
    INT     rectWidth,
    xPos,
    numOfPoints ;


    if ((xLastTime = pGraph->gTimeLine.xLastTime) != 0) {
        if ((pGraph->gKnownValue % pGraph->gMaxValues) == 1) {
            // Data wrap around case
            rctUpdate.left   = pGraph->rectData.left ;
            rctUpdate.right  = pGraph->rectData.left +
                               pGraph->gTimeLine.ppd + 1 ;
        } else {
            rctUpdate.left   = xLastTime - pGraph->gTimeLine.ppd ;
            rctUpdate.right  = xLastTime +
                               pGraph->gTimeLine.ppd + 1 ;
        }
        rctUpdate.top    = pGraph->rectData.top ;
        rctUpdate.bottom = pGraph->rectData.bottom + 1 ;
    }

    // Calculate where to draw the time line.
    // This is done by running a simple DDA (Digital Differential Analyzer)
    // We have to position the time depending upon the size of the
    // graph window.  In essence we need to calculate the x display
    // coordinate.

    // Note we should wrap Known Value in UpdateGLData.
    // We should also use a data buffer of 256 bytes so we can
    // wrap with and AND.

    // xDataPoint =  pGraph->gKnownValue ;
    xDataPoint =  pGraph->gKnownValue % pGraph->gMaxValues ;

    xDisplayPoint = pGraph->rectData.left ;

    numOfPoints = pGraph->gMaxValues - 1 ;

    if (!PlayingBackLog() &&
        pGraph->gOptions.iGraphOrHistogram == LINE_GRAPH) {
        // drawing the 0th at the end of the chart.
        // So, we do have gMaxValues points
        numOfPoints++ ;
        if ((pGraph->gKnownValue % pGraph->gMaxValues) == 0) {
            xDataPoint = pGraph->gMaxValues ;
        }
    }

    rectWidth = pGraph->rectData.right - pGraph->rectData.left ;

    for (i = 0 ; i < xDataPoint ; i++) {
        if (numOfPoints == 0) {
            break ;
        }
        xPos = DDA_DISTRIBUTE (rectWidth, numOfPoints) ;
        xDisplayPoint += xPos ;
        rectWidth -= xPos ;
        numOfPoints-- ;
    }

    pGraph->gTimeLine.xLastTime = xDisplayPoint ;

    if (!getLastTimeLocation && iPerfmonView == IDM_VIEWCHART && !bPerfmonIconic) {
        UpdateGraphDisplay (hDC, FALSE, &rctUpdate, pGraph) ;
    }

    return(TRUE) ;
}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void
/*static*/
OnCreate (
         HWND hWnd
         )
/*
   Effect:        Perform all actions needed when a GraphDisplay window is
                  created.
                  In particular, initialize the graph instance data and
                  create the child windows.

   Called By:     GraphDisplayWndProc, in response to a WM_CREATE message.
*/
{
    LOGBRUSH       LogBrush ;
    TEXTMETRIC     tmScales ;

    hGraphDisplayDC = GetDC(hWnd) ;
    if (!hGraphDisplayDC)
        return;

    SelectFont(hGraphDisplayDC, hFontScales) ;
    GetTextMetrics(hGraphDisplayDC, &tmScales) ;
    HalfTextHeight = tmScales.tmHeight / 2 ;

    //   SetBkColor (hGraphDisplayDC, crLightGray) ;
    SetBkColor (hGraphDisplayDC, ColorBtnFace) ;


    InsertGraph(hWnd) ;
    bInitTimeLine(pGraphs) ;

    pGraphs->hWnd = hWnd ;

    // Create the brush and pen used by the time line.
    // We don't want to create these on every timer tick.

    LogBrush.lbStyle = BS_SOLID ;
    LogBrush.lbColor = RGB(0xff, 0, 0) ;
    LogBrush.lbHatch = 0 ;

    // Now get the system resources we use "all the time"
    pGraphs->hbRed = CreateBrushIndirect(&LogBrush) ;
    pGraphs->hGridPen = CreatePen (PS_SOLID, 1, crGray) ;

    pGraphs->xNumTics = 0 ;
    pGraphs->yNumTics = 0 ;
}


void
/*static*/
OnSize (
       HWND hWnd,
       WORD xWidth,
       WORD yHeight
       )
{
    PGRAPHSTRUCT   pGraph ;

    pGraph = GraphData (hWnd) ;

    SizeGraphDisplayComponents (hWnd) ;
}


void
/*static*/
OnPaint (
        HWND hWnd
        )
{
    HDC            hDC ;
    PAINTSTRUCT    ps ;
    PGRAPHSTRUCT   pGraph ;

    pGraph = GraphData (hWnd) ;
    hDC = BeginPaint(hWnd, &ps) ;

    DrawGraphDisplay (hDC, ps.rcPaint, pGraph) ;

    EndPaint(hWnd, &ps) ;
}


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

#ifdef KEEP_PRINT
void PrintGraphDisplay (HDC hDC,
                        PGRAPHSTRUCT pGraph)
{
    DrawGraphScale (hDC, pGraph) ;


    //!!   UpdateGraphDisplay (hDC, TRUE, &(pGraph->rectData), pGraph) ;

    IntersectClipRect (hDC, 0, 0, 10000, 10000) ;
    SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ;
    SelectPen (hDC, GetStockObject (BLACK_PEN)) ;
    Rectangle (hDC,
               pGraph->rectData.left,
               pGraph->rectData.top,
               pGraph->rectData.right,
               pGraph->rectData.bottom) ;
}
#endif



void
DrawGraphDisplay (
                 HDC hDC,
                 RECT rectDraw,
                 PGRAPHSTRUCT pGraph
                 )
{
    BOOL        bPaintScale ;
    INT         LocalThreeDPad = ThreeDPad - 1 ;

    // Only draw the vertical labels if the paint rectangle
    // any portion of the window to the left of the graph area.

    bPaintScale = (rectDraw.left <= pGraph->rectVertScale.right) ;
    if (bPaintScale)
        DrawGraphScale (hDC, pGraph) ;
    if (IsPrinterDC (hDC))
        Rectangle (hDC,
                   pGraph->rectData.left,
                   pGraph->rectData.top,
                   pGraph->rectData.right,
                   pGraph->rectData.bottom) ;
    else
        ThreeDConcave1 (hDC,
                        pGraph->rectData.left - LocalThreeDPad,
                        pGraph->rectData.top - LocalThreeDPad,
                        pGraph->rectData.right + LocalThreeDPad,
                        pGraph->rectData.bottom + LocalThreeDPad + 1) ;

    UpdateGraphDisplay (hDC, TRUE, &(rectDraw), pGraph) ;
}


LRESULT
APIENTRY
GraphDisplayWndProc (
                    HWND hWnd,
                    UINT uMsg,
                    WPARAM wParam,
                    LPARAM lParam
                    )
{
    LRESULT     lret = 0L ;
    BOOL        bCallDefProc = FALSE ;

    switch (LOWORD (uMsg)) {
        case WM_LBUTTONDOWN:
            DoWindowDrag (hWnd, lParam) ;
            break ;

        case WM_LBUTTONDBLCLK:
            SendMessage (hWndMain, uMsg, wParam, lParam) ;
            break ;

        case WM_CREATE:
            OnCreate (hWnd) ;
            break ;

        case WM_SIZE:
            OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ;
            break ;

        case WM_DESTROY:
            KillTimer(hWndMain, GRAPH_TIMER_ID) ;
            break ;

        case WM_PAINT:
            OnPaint (hWnd) ;
            break ;

        case WM_TIMER:
            GraphTimer (hWnd, FALSE) ;
            break ;

        default:
            bCallDefProc = TRUE ;
            break ;
    }  // switch


    if (bCallDefProc) {
        lret = DefWindowProc(hWnd, uMsg, wParam, lParam) ;
    }
    return (lret) ;
}


BOOL
GraphDisplayInitializeApplication (void)
{
    WNDCLASS       wc ;

    wc.style         = dwGraphDisplayClassStyle ;
    wc.lpfnWndProc   = GraphDisplayWndProc ;
    wc.hInstance     = hInstance ;
    wc.cbClsExtra    = iGraphDisplayWindowExtra ;
    wc.cbWndExtra    = iGraphDisplayClassExtra ;
    wc.hIcon         = NULL ;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
    //   wc.hbrBackground = hbLightGray ;
    wc.hbrBackground = hBrushFace ;
    wc.lpszMenuName  = NULL ;
    wc.lpszClassName = (LPTSTR) szGraphDisplayWindowClass ;

    return (RegisterClass (&wc)) ;
}



HWND
CreateGraphDisplayWindow (
                         HWND hWndGraph
                         )
{
    return (CreateWindow (szGraphDisplayWindowClass,   // class
                          NULL,                        // caption
                          dwGraphDisplayWindowStyle,   // window style
                          0, 0,                        // position
                          0, 0,                        // size
                          hWndGraph,                   // parent window
                          NULL,                        // menu
                          hInstance,                  // program instance
                          NULL)) ;                     // user-supplied data
}

BOOL
ToggleGraphRefresh (
                   HWND hWnd
                   )
{
    PGRAPHSTRUCT   pGraph ;

    pGraph = GraphData (hWnd) ;

    if (pGraph->bManualRefresh)
        SetGraphTimer (pGraph) ;
    else
        ClearGraphTimer (pGraph) ;

    pGraph->bManualRefresh = !pGraph->bManualRefresh ;
    return (pGraph->bManualRefresh) ;
}

BOOL
GraphRefresh (
             HWND hWnd
             )
{
    PGRAPHSTRUCT   pGraph ;

    pGraph = GraphData (hWnd) ;

    return (pGraph->bManualRefresh) ;
}


void
GraphTimer (
           HWND hWnd,
           BOOL bForce
           )
/*
   Effect:        Handle any actions necessary when the graph display
                  window hWnd receives a timer tick. In particular,
                  update the graph display and update the status bar
                  if it is showing.

   Called By:     GraphDisplayWndProc, in response to a WM_TIMER message.
*/
{
    PGRAPHSTRUCT         pGraph ;

    pGraph = GraphData (hWnd) ;

    if (!pGraph->pLineFirst)
        return ;

    if (bForce || !pGraph->bManualRefresh) {

        HandleGraphTimer () ;

        // If we are displaying a time-line graph then do the
        // calculations for the minimal update region.
        // If were doing a bar graph, then draw the
        // whole graph area.

        if (pGraph->gOptions.iGraphOrHistogram == LINE_GRAPH)
            UpdateTimeLine (hGraphDisplayDC, pGraph, FALSE) ;
        else
            DrawBarChartData (hGraphDisplayDC, pGraph) ;

        // Take care of the status bar window
        StatusTimer (hWndGraphStatus, FALSE) ;

    }  // if
}

// this routine set/reset the line highlight mode
void
ChartHighlight (void)
{
    PGRAPHSTRUCT         pGraph ;


    if (pGraph = GraphData (hWndGraph)) {
        if (pGraph->pLineFirst) {
            // toggle the HightlightOnOff mode
            pGraph->HighLightOnOff = !pGraph->HighLightOnOff ;
            WindowInvalidate (hWndGraphDisplay) ;
        } else {
            // no line availble, just turn it off
            pGraph->HighLightOnOff = FALSE ;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\fileutil.h ===
//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

#define FILE_ERROR_MESSAGE_SIZE 256


VOID FileErrorMessageBox(HWND hWnd,
                         LPTSTR lpszFileName,
                         DWORD ErrorCode) ;


BOOL FileRead (HANDLE hFile,
               LPMEMORY lpMemory,
               DWORD nAmtToRead) ;

BOOL FileWrite (HANDLE hFile,
                LPMEMORY lpMemory,
                DWORD nAmtToWrite) ;


#define FileSeekBegin(hFile, lAmtToMove) \
   SetFilePointer (hFile, lAmtToMove, NULL, FILE_BEGIN)

#define FileSeekEnd(hFile, lAmtToMove) \
   SetFilePointer (hFile, lAmtToMove, NULL, FILE_END)

#define FileSeekCurrent(hFile, lAmtToMove) \
   SetFilePointer (hFile, lAmtToMove, NULL, FILE_CURRENT)

#define FileTell(hFile) \
   SetFilePointer (hFile, 0, NULL, FILE_CURRENT)

#define FileHandleOpen(lpszFilePath)         \
   (HANDLE) CreateFile (lpszFilePath,        \
      GENERIC_READ | GENERIC_WRITE,          \
      FILE_SHARE_READ,                       \
      NULL, OPEN_EXISTING,                   \
      FILE_ATTRIBUTE_NORMAL, NULL)

#define FileHandleReadOnly(lpszFilePath)     \
   (HANDLE) CreateFile (lpszFilePath,        \
      GENERIC_READ ,                         \
      FILE_SHARE_READ | FILE_SHARE_WRITE,    \
      NULL, OPEN_EXISTING,                   \
      FILE_ATTRIBUTE_NORMAL, NULL)

#define FileHandleCreate(lpszFilePath)       \
   (HANDLE) CreateFile (lpszFilePath,        \
      GENERIC_READ | GENERIC_WRITE,          \
      FILE_SHARE_READ,                       \
      NULL, CREATE_ALWAYS,                   \
      FILE_ATTRIBUTE_NORMAL, NULL)

int FileHandleSeekCurrent (HANDLE hFile,
                           int iAmtToMove,
                           LPTSTR lpszFilePath) ;


int FileHandleSeekStart (HANDLE hFile,
                         int iAmtToMove,
                         LPTSTR lpszFilePath) ;


BOOL FileHandleWrite (HANDLE hFile, 
                      LPMEMORY lpBuffer,
                      int cbWrite,
                      LPTSTR lpszFilePath) ;


LPMEMORY FileMap (HANDLE hFile, HANDLE *phMapHandle) ;


BOOL FileUnMap (LPVOID pBase, HANDLE hMapHandle) ;


void FileDriveDirectory (LPTSTR lpszFileSpec,
                         LPTSTR lpszDirectory) ;


void FileNameExtension (LPTSTR lpszSpec,
                        LPTSTR lpszFileNameExtension) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\fileutil.c ===
//#include <string.h>
//#include <tchar.h>

#include <stdio.h>
#include "perfmon.h"
#include "fileutil.h"
#include "utils.h"

#include <string.h>     // for strncpy
#ifdef UNICODE
#define _tcsrchr	wcsrchr
#else
#define _tcsrchr	strrchr
#endif

#define DRIVE_DELIMITER          TEXT(':')
#define DIRECTORY_DELIMITER      TEXT('\\')
#define EXTENSION_DELIMITER      TEXT('.')


#if 0
VOID FileErrorMessageBox(HWND hWnd, LPTSTR lpszFileName, DWORD ErrorCode)
   {
   TCHAR szErrorMessage[FILE_ERROR_MESSAGE_SIZE] ;
   TCHAR szErrorMessageTemplate[FILE_ERROR_MESSAGE_SIZE] ;

   StringLoad (IDS_FILE_ERROR, szErrorMessageTemplate) ;
   TSPRINTF((LPTSTR)szErrorMessage,
            (LPTSTR)szErrorMessageTemplate,
            lpszFileName,
            ErrorCode) ;

   MessageBox (hWnd, (LPTSTR)szErrorMessage, NULL,
              MB_OK | MB_ICONSTOP | MB_TASKMODAL);
   return ;
   }
#endif


BOOL FileRead (HANDLE hFile,
               LPMEMORY lpMemory,
               DWORD nAmtToRead)
   {  // FileRead
   BOOL           bSuccess ;
   DWORD          nAmtRead ;

   bSuccess = ReadFile (hFile, lpMemory, nAmtToRead, &nAmtRead, NULL) ;
   return (bSuccess && (nAmtRead == nAmtToRead)) ;
   }  // FileRead



BOOL FileWrite (HANDLE hFile,
                LPMEMORY lpMemory,
                DWORD nAmtToWrite)
   {  // FileWrite
   BOOL           bSuccess = FALSE;
   DWORD          nAmtWritten  = 0;
   DWORD          dwFileSizeLow, dwFileSizeHigh;
   LONGLONG       llResultSize;
    
   dwFileSizeLow = GetFileSize (hFile, &dwFileSizeHigh);
   // limit file size to 2GB

   if (dwFileSizeHigh > 0) {
      SetLastError (ERROR_WRITE_FAULT);
      bSuccess = FALSE;
   } else {
      // note that the error return of this function is 0xFFFFFFFF
      // since that is > the file size limit, this will be interpreted
      // as an error (a size error) so it's accounted for in the following
      // test.
      llResultSize = dwFileSizeLow + nAmtToWrite;
      if (llResultSize >= 0x80000000) {
          SetLastError (ERROR_WRITE_FAULT);
          bSuccess = FALSE;
      } else {
          // write buffer to file
          bSuccess = WriteFile (hFile, lpMemory, nAmtToWrite, &nAmtWritten, NULL) ;
          if (bSuccess) bSuccess = (nAmtWritten == nAmtToWrite ? TRUE : FALSE);
      }
   }

   return (bSuccess) ;
   }  // FileWrite

                
#if 0
HANDLE FileHandleOpen (LPTSTR lpszFilePath)
   {  // FileHandleOpen
   return ((HANDLE) CreateFile (lpszFilePath,
                                GENERIC_READ |
                                GENERIC_WRITE,
                                FILE_SHARE_READ |
                                FILE_SHARE_WRITE,
                                NULL, 
                                OPEN_EXISTING,
                                0,
                                NULL)) ;
   }  // FileHandleOpen


HANDLE FileHandleCreate (LPTSTR lpszFilePath)
   {  // FileHandleCreate
   return ((HANDLE) CreateFile (lpszFilePath, 
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL)) ;
   }  // FileHandleCreate



long FileSeekEnd (HANDLE hFile,
                  long lAmtToMove)
   {  // FileSeekEnd
   return (SetFilePointer (hFile, lAmtToMove, NULL, FILE_END)) ;
   }  // FileSeekEnd


long FileSeekBegin (HANDLE hFile,
                    long lAmtToMove)
   {  // FileSeekBegin
   return (SetFilePointer (hFile, lAmtToMove, NULL, FILE_BEGIN)) ;
   }  // FileSeekBegin


long FileSeekCurrent (HANDLE hFile,
                      long lAmtToMove)
   {  // FileSeekCurrent
   return  (SetFilePointer (hFile, lAmtToMove, NULL, FILE_CURRENT)) ;
   }  // FileSeekCurrent
   


long FileTell (HANDLE hFile)
   {  // FileTell
   return (SetFilePointer (hFile, 0, NULL, FILE_CURRENT)) ;
   }  // FileTell
#endif



LPMEMORY FileMap (HANDLE hFile, HANDLE *phMapHandle)
/*
   To Do:         Error reporting!!
*/
   {  // FileMap
   HANDLE         hMapping ;


   *phMapHandle = 0 ;
   hMapping = CreateFileMapping (hFile, NULL, PAGE_READONLY,
                                 0, 0, NULL) ;
   if (!hMapping)
      return (NULL) ;

   *phMapHandle = hMapping ;
   return (MapViewOfFile (hMapping, FILE_MAP_READ, 0, 0, 0)) ;
   }  // FileMap



BOOL FileUnMap (LPVOID pBase, HANDLE hMapping)
/*
   To Do:         Error reporting!!
*/
   {  // FileUnMap
   UnmapViewOfFile(pBase) ;
   CloseHandle (hMapping) ;
   return (TRUE) ;
   }  // FileUnMap



void FileNameExtension (LPTSTR lpszSpec,
                        LPTSTR lpszFileNameExtension)
/*
   Effect:        Return the name and extension portion only of lpszSpec
                  int lpszFileNameExtension.

   Assert:        lpszFileNameExtension is large enough to hold a name,
                  delimiter, extension, and terminating null character.
*/
   {  // FileNameExtension
   LPTSTR          lpszDelimiter ;

   lpszDelimiter = _tcsrchr ((LPCTSTR)lpszSpec, (TCHAR)DIRECTORY_DELIMITER) ;
   if (!lpszDelimiter)
      lpszDelimiter = _tcsrchr ((LPCTSTR)lpszSpec, (TCHAR)DRIVE_DELIMITER) ;

   lstrcpy (lpszFileNameExtension, 
           lpszDelimiter ? ++lpszDelimiter : lpszSpec) ;
   }  // FileNameExtension



void FileDriveDirectory (LPTSTR lpszFileSpec,
                         LPTSTR lpszDirectory)
/*
   Effect:        Extract the drive and directory from the file 
                  specification lpszFileSpec, and return the it in
                  lpszDirectory.

   Internals:     Copy the the whole spec to lpszDirectory. Use lstrrchr
                  to find the *last* directory delimiter ('\') and 
                  truncate the string right after that. 

   Note:          This function assumes that the specification lpszFileSpec
                  is fairly complete, in that it contains both a directory
                  and a file name.
*/
   {  // FileDriveDirectory
   LPTSTR          lpszDelimiter ;

   lstrcpy (lpszDirectory, lpszFileSpec) ;
   lpszDelimiter = _tcsrchr ((LPCTSTR)lpszDirectory, (TCHAR)DIRECTORY_DELIMITER) ;
   if (lpszDelimiter)
      *(++lpszDelimiter) = TEXT('\0') ;
   }  // FileDriveDirectory





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\graph.c ===
/*****************************************************************************
 *
 *  Graph.c - This module handles the graphing window.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *
 ****************************************************************************/

/*
   File Contents:

      This file contains the code for creating and manipulating the graph
      window. This window is a child of hWndMain and represents one of the
      three "views" of the program. The other views are log and alert.

      The graph window is actually just a container window, whose surface
      is completely filled by its children: hWndGraphDisplay, ,
      hWndGraphLegend, and hWndGraphStatus. Therefore much of this file is
      merely calls to the appropriate functions for these children.

      The graph window is responsible for the graph structure itself,
      however. Conceptually this should be instance data for the graph
      window. Right now, however, there is only one window and only one
      graph structure. Nevertheless, we go through the GraphData(hWnd)
      function to get a pointer to the graph structure for the graph window.

*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include "perfmon.h"
#include "graph.h"
#include "grafdisp.h"
#include "legend.h"
#include "valuebar.h"
#include "utils.h"   // for WindowShow


//==========================================================================//
//                                  Constants                               //
//==========================================================================//


//=============================//
// Graph Class                 //
//=============================//


TCHAR   szGraphWindowClass[] = TEXT("PerfGraph") ;
#define dwGraphClassStyle           (CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS)
#define iGraphClassExtra            (0)
#define iGraphWindowExtra           (0)
#define dwGraphWindowStyle          (WS_CHILD)



//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


void
static
OnCreate (
          HWND hWnd
          )
{
    hWndGraphDisplay = CreateGraphDisplayWindow (hWnd) ;
    hWndGraphLegend = CreateGraphLegendWindow (hWnd) ;
    hWndGraphStatus = CreateGraphStatusWindow (hWnd) ;
}


void
static
OnPaint (
         HWND hWnd
         )
{
    HDC            hDC ;
    PAINTSTRUCT    ps ;

    hDC = BeginPaint (hWnd, &ps) ;
    EndPaint (hWnd, &ps) ;
}


void
static
OnSize (
        HWND hWnd,
        int xWidth,
        int yHeight
        )
{
    SizeGraphComponents (hWnd) ;
}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//



LRESULT
APIENTRY
GraphWndProc (
             HWND hWnd,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    BOOL           bCallDefProc ;
    LRESULT        lReturnValue ;

    bCallDefProc = FALSE ;
    lReturnValue = 0L ;

    switch (wMsg) {
        case WM_CREATE:
            OnCreate (hWnd) ;
            break ;

        case WM_LBUTTONDBLCLK:
            SendMessage (hWndMain, WM_LBUTTONDBLCLK, wParam, lParam) ;
            break ;

        case WM_PAINT:
            OnPaint (hWnd) ;
            break ;

        case WM_SIZE:
            OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ;
            break ;

        default:
            bCallDefProc = TRUE ;
    }

    if (bCallDefProc)
        lReturnValue = DefWindowProc (hWnd, wMsg, wParam, lParam) ;

    return (lReturnValue);
}



BOOL
GraphInitializeApplication (void)
/*
   Note:          There is no background brush set for the MainWindow
                  class so that the main window is never erased. The
                  client area of MainWindow is always covered by one
                  of the view windows. If we erase it, it would just
                  flicker needlessly.
*/
{
    BOOL           bSuccess ;
    WNDCLASS       wc ;

    //=============================//
    // Register GraphWindow class  //
    //=============================//


    wc.style         = dwGraphClassStyle ;
    wc.lpfnWndProc   = GraphWndProc ;
    wc.hInstance     = hInstance ;
    wc.cbClsExtra    = iGraphWindowExtra ;
    wc.cbWndExtra    = iGraphClassExtra ;
    wc.hIcon         = NULL ;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
    wc.hbrBackground = NULL ;                          // see note above
    wc.lpszMenuName  = NULL ;
    wc.lpszClassName = szGraphWindowClass ;

    bSuccess = RegisterClass (&wc) ;


    //=============================//
    // Register Child classes      //
    //=============================//

    if (bSuccess)
        bSuccess = GraphDisplayInitializeApplication () ;

    if (bSuccess)
        bSuccess = GraphLegendInitializeApplication () ;

    if (bSuccess)
        bSuccess = GraphStatusInitializeApplication () ;

    return (bSuccess) ;
}


HWND
CreateGraphWindow (
                   HWND hWndParent
                   )
/*
   Effect:        Create the graph window. This window is a child of
                  hWndMain and is a container for the graph data,
                  graph label, graph legend, and graph status windows.

   Note:          We dont worry about the size here, as this window
                  will be resized whenever the main window is resized.

*/
{
    return (CreateWindow (szGraphWindowClass,       // window class
                          NULL,                     // caption
                          dwGraphWindowStyle,       // style for window
                          0, 0,                     // initial position
                          0, 0,                     // initial size
                          hWndParent,               // parent
                          NULL,                     // menu
                          hInstance,               // program instance
                          NULL)) ;                  // user-supplied data
}


void
SizeGraphComponents (
                     HWND hWnd
                     )
/*
   Effect:        Move and show the various components of the graph to
                  fill the size (xWidth x yHeight). Take into account
                  whether the user wants to show the legend or status
                  bars. Also take into account if we have room for these
                  items.

   Internals:     If the user doesn't want the status or legend windows,
                  they aren't shown. Also, if the user wanted the status
                  window but not the legend window, the status window is
                  not shown.

                  We may disregard the user's desire for the legend or
                  status bar if there is not room. In particular, a legend
                  window has a minimum width (LegendMinWidth ()) and a
                  minimum height (LegendMinHeight ()). These values are
                  fixed for a given session of perfmon. It also has a
                  preferred height, which takes into consideration the
                  size of the graph window and the number of items in
                  the legend. This value is returned by LegendHeight().

                  We don't show the legend if its minimum height would
                  take up more than half the graph height.

                  If we feel we don't have room for the legend, we don't
                  show the status window either.

   See Also:      LegendMinWidth, LegendMinHeight, LegendHeight,
                  ValuebarHeight.

   Called By:     OnSize, any other function that may remove or add one
                  of the graph components.
*/
{
    RECT           rectClient ;
    BOOL           bShowLegend ;
    BOOL           bShowStatus ;
    int            yStatusHeight ;
    int            yLegendHeight ;
    int            xWidth ;
    int            yHeight ;

    GetClientRect (hWnd, &rectClient) ;
    xWidth = rectClient.right - rectClient.left ;
    yHeight = rectClient.bottom - rectClient.top ;

    // if the graph window has no size, neither will its children.
    if (!xWidth || !yHeight)
        return ;

    //=============================//
    // Show the Legend Window?     //
    //=============================//

    if (!pGraphs->gOptions.bLegendChecked)
        bShowLegend = FALSE ;
    else if (xWidth < LegendMinWidth (hWndGraphLegend))
        bShowLegend = FALSE ;
    else if (yHeight < 5 * LegendMinHeight (hWndGraphLegend))
        bShowLegend = FALSE ;
    else
        bShowLegend = TRUE ;

    //=============================//
    // Show the Status Window?     //
    //=============================//

    if (!pGraphs->gOptions.bStatusBarChecked)
        bShowStatus = FALSE ;
    else if (!bShowLegend)
        bShowStatus = FALSE ;
    else
        bShowStatus = TRUE ;


    yStatusHeight = bShowStatus ?
                    ValuebarHeight (hWndGraphStatus) : 0 ;
    yLegendHeight = bShowLegend ?
                    LegendHeight (hWndGraphLegend, yHeight) : 0 ;


    //=============================//
    // Update the status window    //
    //=============================//

    if (bShowStatus)
        MoveWindow (hWndGraphStatus,
                    0, yHeight - yStatusHeight - yLegendHeight,
                    xWidth, yStatusHeight,
                    TRUE) ;
    WindowShow (hWndGraphStatus, bShowStatus) ;


    //=============================//
    // Update the legend window    //
    //=============================//

    if (bShowLegend)
        MoveWindow (hWndGraphLegend,
                    0, yHeight - yLegendHeight,
                    xWidth, yLegendHeight,
                    TRUE) ;
    WindowShow (hWndGraphLegend, bShowLegend) ;


    //=============================//
    // Update the display window   //
    //=============================//

    MoveWindow (hWndGraphDisplay,
                0, 0,
                xWidth, yHeight - yStatusHeight - yLegendHeight,
                TRUE) ;
    SizeGraphDisplayComponents (hWndGraphDisplay) ;
    WindowInvalidate (hWndGraphDisplay) ;
    WindowShow (hWndGraphDisplay, TRUE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\graph.h ===
/*****************************************************************************
 *
 *  Graph.h - Header for graphing window.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *
 ****************************************************************************/


#define GRAPH_BORDER 4


BOOL GraphInitializeApplication (void) ;


HWND CreateGraphWindow (HWND hWndParent) ;


void SizeGraphComponents (HWND hWnd) ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\init.h ===
BOOL PerfmonInitialize (HINSTANCE hCurrentInstance,
                        HINSTANCE hPrevInstance,
                        LPCSTR lpszCmdLine,
                        int nCmdShow) ;


void PerfmonClose (HWND hWndMain) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\init.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//
#include <string.h>     // strupr
#include <stdio.h>      // for sprintf.


#include "perfmon.h"
#include "init.h"       // external declarations for this file

#include "alert.h"      // for AlertIitializeApplication
#include "command.h"    // for ViewChart
#include "grafdata.h"   // for QuerySaveChart
#include "graph.h"      // for GraphInitializeApplication
#include "legend.h"     // for LegendInitializeApplication
#include "log.h"        // for LogInitializeApplication
#include "intrline.h"   // for ILineInitializeApplication
#include "perfdata.h"   // for PerfDataInitializeInstance
#include "perfmops.h"   // for OpenFileHandler, for now
#include "status.h"     // for StatusInitializeApplication
#include "timeline.h"   // for TLineInitializeApplication
#include "playback.h"   // for PlaybackInitializeInstance
#include "registry.h"   // for Load/SaveMainWindowPlacement
#include "report.h"     // for ReportInitializeApplication
#include "toolbar.h"    // for ToolbarInitializeApplication
#include "utils.h"
#include "fileopen.h"   // for FileOpen
#include "pmemory.h"    // for MemoryFree

extern   TCHAR          DefaultLangId[] ;
extern   TCHAR          EnglishLangId[] ;

static   LPSTR           lpszCommandLine ;

//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define szPerfmonMainClass TEXT("PerfmonMainClass")

HHOOK   lpMsgFilterProc ;
DWORD FAR PASCAL MessageFilterProc (int nCode, WPARAM wParam,
                                    LPARAM lParam) ;


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//

static
LONG
EnablePrivilege (
                IN  LPTSTR  szPrivName
                )
{
    LUID SePrivNameValue;
    TOKEN_PRIVILEGES tkp;

    HANDLE hToken = NULL;

    /* Retrieve a handle of the access token. */

    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken)) {
        goto Exit_Point;
    }

    /*
     * Enable the privilege by name and get the ID
     */

    if (!LookupPrivilegeValue((LPTSTR) NULL,
                              szPrivName,
                              &SePrivNameValue)) {
        goto Exit_Point;
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = SePrivNameValue;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(hToken,
                          FALSE,
                          &tkp,
                          sizeof(TOKEN_PRIVILEGES),
                          (PTOKEN_PRIVILEGES) NULL,
                          (PDWORD) NULL);

    /* The return value of AdjustTokenPrivileges be texted. */

    Exit_Point:

    if (hToken != NULL) CloseHandle (hToken);
    return GetLastError();
}

void
GetScalesFonts (void)
{
    LOGFONT      lf ;
    CHARSETINFO  csi;
    DWORD        dw = GetACP();

    if (!TranslateCharsetInfo(UlongToPtr(dw), &csi, TCI_SRCCODEPAGE))
        csi.ciCharset = ANSI_CHARSET;

    memset (&lf, 0, sizeof (lf)) ;

    lstrcpy (lf.lfFaceName, szScalesFontFace) ;
    /*
       if (csi.ciCharset == ANSI_CHARSET)
           lf.lfHeight = iScalesFontHeightAnsi ;
       else
           lf.lfHeight = iScalesFontHeightNonAnsi ;
    */
    // make the text the same size as a menu text
    lf.lfHeight = GetSystemMetrics (SM_CYMENUCHECK);
    lf.lfWeight = FW_REGULAR ;
    lf.lfCharSet = (BYTE)csi.ciCharset;

    hFontScales = CreateFontIndirect (&lf) ;

    if (csi.ciCharset == ANSI_CHARSET)
        lf.lfWeight = FW_BOLD ;
    hFontScalesBold = CreateFontIndirect (&lf) ;
}


BOOL
InitializeSystemValues (void)
/*
   Effect:        Read and store in variables the various system values,
                  such as the width and height of the screen and icons,
                  the width of scroll bars, etc.

   Called By:     PerfmonInitialize only.

   Returns:       Whether this function was successful in getting all
                  needed system values.
*/
{
    xScreenWidth =  GetSystemMetrics (SM_CXSCREEN) ;
    yScreenHeight = GetSystemMetrics (SM_CYSCREEN) ;

    xBorderWidth = GetSystemMetrics (SM_CXBORDER) ;
    yBorderHeight = GetSystemMetrics (SM_CYBORDER) ;

    xScrollWidth = GetSystemMetrics (SM_CXVSCROLL) ;
    yScrollHeight = GetSystemMetrics (SM_CYHSCROLL) ;

    xScrollThumbWidth = GetSystemMetrics (SM_CXHTHUMB) ;
    yScrollThumbHeight = GetSystemMetrics (SM_CYVTHUMB) ;

    xDlgBorderWidth = GetSystemMetrics (SM_CXDLGFRAME) ;
    yDlgBorderHeight = GetSystemMetrics (SM_CYDLGFRAME) ;

    MinimumSize = yScrollHeight +
                  GetSystemMetrics (SM_CYMENU) +
                  GetSystemMetrics (SM_CYCAPTION) ;

    //================================================================//
    // create all the brushes and pens for performance improvement    //
    //================================================================//
    CreatePerfmonSystemObjects () ;
    hWhitePen = CreatePen (PS_SOLID, 3, crWhite) ;

    return (TRUE) ;
}


BOOL
InitializeApplication (void)
/*
   Effect:        Perform all initializations required for the FIRST
                  instance of the Perfmon application. In particular,
                  register all of Perfmon's window classes.

   Note:          There is no background brush set for the MainWindow
                  class so that the main window is never erased. The
                  client area of MainWindow is always covered by one
                  of the view windows. If we erase it, it would just
                  flicker needlessly.

   Called By:     PerfmonInitialize only.

   Returns:       Whether this function was successful in initializing.
*/
{
    BOOL           bSuccess ;
    WNDCLASS       wc ;
    TCHAR          LocalHelpFileName [ShortTextLen] ;
    LPTSTR         pFileName ;

    hIcon = LoadIcon (hInstance, idIcon) ;

    //=============================//
    // Register Main window class  //
    //=============================//

    wc.style         = CS_DBLCLKS | CS_BYTEALIGNCLIENT;
    wc.lpfnWndProc   = MainWndProc;
    wc.hInstance     = hInstance;
    wc.cbClsExtra    = 0 ;
    wc.cbWndExtra    = 0;
    wc.hIcon         = hIcon ;
    wc.hCursor       = LoadCursor(NULL, IDI_APPLICATION);
    wc.hbrBackground = NULL ;                             // see note above
    wc.lpszMenuName  = idMenuChart ;
    wc.lpszClassName = szPerfmonMainClass ;

    bSuccess = RegisterClass (&wc) ;

    //=============================//
    // Register Abstract "Systems" //
    //=============================//
    hbLightGray = GetStockObject (LTGRAY_BRUSH) ;

    if (bSuccess)
        bSuccess = StatusInitializeApplication () ;

    if (bSuccess)
        bSuccess = GraphInitializeApplication () ;

#ifdef ADVANCED_PERFMON
    if (bSuccess)
        bSuccess = LogInitializeApplication () ;

    if (bSuccess)
        bSuccess = AlertInitializeApplication () ;

    if (bSuccess)
        bSuccess = ReportInitializeApplication () ;

    if (bSuccess)
        bSuccess = ILineInitializeApplication () ;

    if (bSuccess)
        bSuccess = TLineInitializeApplication () ;
#endif

    // setup messagehook to handle F1 as help
    lpMsgFilterProc = SetWindowsHookEx (WH_MSGFILTER,
                                        (HOOKPROC) MessageFilterProc,
                                        hInstance,
                                        GetCurrentThreadId()) ;

    // get the help file full path name
    LoadString (hInstance, IDS_HELPFILE_NAME,
                (LPTSTR)LocalHelpFileName, ShortTextLen-1);


    if (LocalHelpFileName[0]) {
        DWORD dwLength;
        pszHelpFile = (LPTSTR) MemoryAllocate (FilePathLen * sizeof (TCHAR)) ;
        dwLength = SearchPath (NULL, LocalHelpFileName, NULL,
                               FilePathLen - 1, pszHelpFile, &pFileName) ;
        if (dwLength == 0) {
            // not found in the path so check the help dir
            TCHAR szSearchPath[MAX_PATH];
            ExpandEnvironmentStrings (TEXT("%windir%\\help"),
                                      szSearchPath, ((sizeof (szSearchPath)/sizeof (TCHAR)) -1));
            SearchPath (szSearchPath, LocalHelpFileName, NULL,
                        FilePathLen - 1, pszHelpFile, &pFileName) ;
        }
    } else {
        // no help file
        pszHelpFile = (LPTSTR) MemoryAllocate (sizeof (TCHAR)) ;
        if (pszHelpFile) {
            *pszHelpFile = TEXT('\0') ;
        }
    }

    return (bSuccess) ;
}


BOOL
InitializeInstance (
                    int nCmdShow,
                    LPCSTR lpszCmdLine
                    )
/*
   Effect:        Perform all initializations required for EACH instance
                  of the Perfmon application. In particular, create all
                  of Perfmon's initial windows, and perform any other
                  initializations except registering classes (done in
                  InitializeApplication).

   Called By:     PerfmonInitialize only.

   Note:          This function has multiple return points.

   Returns:       Whether this function was successful in initalizing.
*/
{
    DWORD          ComputerNameLength;
    TCHAR          szApplication [WindowCaptionLen] ;

    bCloseLocalMachine = FALSE;

    // enable privileges needed to profile system
    // if this fails, that's ok for now.

    EnablePrivilege (SE_SYSTEM_PROFILE_NAME);    // to access perfdata
    EnablePrivilege (SE_INC_BASE_PRIORITY_NAME); // to raise priority

    //=============================//
    // Set Priority high           //
    //=============================//

    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS) ;
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST) ;

    //=============================//
    // Load Resources              //
    //=============================//

    GetScalesFonts () ;

    hMenuChart = LoadMenu (hInstance, idMenuChart) ;

#ifdef ADVANCED_PERFMON
    hMenuAlert = LoadMenu (hInstance, idMenuAlert) ;
    hMenuLog = LoadMenu (hInstance, idMenuLog) ;
    hMenuReport = LoadMenu (hInstance, idMenuReport) ;
#endif

    hAccelerators = LoadAccelerators (hInstance, idAccelerators) ;


    //=============================//
    // Initialize Systems          //
    //=============================//

    iLanguage = GetUserDefaultLangID() ;
    iEnglishLanguage = MAKELANGID (LANG_ENGLISH, LANG_NEUTRAL) ;
    //   iEnglishLanguage = MAKELANGID (iLanguage & 0x0ff, LANG_NEUTRAL) ;
    TSPRINTF (DefaultLangId, TEXT("%03x"), iLanguage) ;
    TSPRINTF (EnglishLangId, TEXT("%03x"), iEnglishLanguage) ;

    // GetComputerName returns the name without the "\\" prefix. We add
    // the prefix before even calling the routine. This is so that all our
    // computer names have the prefix and are therefore compatible with
    // I_SetSystemFocus (see perfmops.c).

    ComputerNameLength = MAX_PATH + 1;
    lstrcpy (LocalComputerName, szComputerPrefix) ;
    GetComputerName (LocalComputerName + lstrlen (szComputerPrefix),
                     &ComputerNameLength);

    PlaybackInitializeInstance () ;
    PerfDataInitializeInstance () ;

    //Copy command line into buffer for modification
    lpszCommandLine = (LPSTR)MemoryAllocate (strlen (lpszCmdLine) + sizeof(CHAR)) ;
    if (lpszCommandLine)
        strcpy(lpszCommandLine, lpszCmdLine) ;
    else
        return (FALSE) ;


    StringLoad (IDS_APPNAME, szApplication) ;

    //Insure CmdLineComputerName starts out NULL
    CmdLineComputerName[0] = TEXT('\0') ;

    //Check to see if there is a computer name specified on the command
    //line (indicated by /c, or /C).  If there is, get it and
    //null out the command line string so that it is not mistaken for
    //startup file.  This assumes that specifying a computer and a startup
    //file on the command line are mutually exclusive.  If the /c option
    //is on the command line, anything else on the command line is discarded.
    if (!strempty (lpszCommandLine)) {
        LPSTR               lpszNewCL ;

        //Preserve initial command line pointer position
        lpszNewCL = (LPSTR)lpszCommandLine ;
        while (*lpszNewCL != '\0' && *lpszCommandLine) {
            if (*lpszNewCL  == '/' || *lpszNewCL    == '-') {
                lpszNewCL++ ;
                if (*lpszNewCL == 'c' || *lpszNewCL == 'C') {
                    int i = 0;

                    lpszNewCL++ ;
                    //ignore leading backslashes * spaces
                    while (*lpszNewCL == '\\' || *lpszNewCL == ' ')
                        lpszNewCL++ ;

                    //Terminate at first blank space if there is one.
                    //We don't allow anything else on the command line
                    //if a computer name is specified.
                    while (lpszNewCL[i] != ' ' && lpszNewCL[i] != '\0')
                        i++ ;
                    lpszNewCL[i] = '\0' ;

                    if ((*lpszNewCL != '\0') && (strlen(lpszNewCL) <= MAX_PATH)) {
                        int nSizePrefix ;

                        nSizePrefix = lstrlen (szComputerPrefix) ;
                        lstrcpy( CmdLineComputerName, szComputerPrefix ) ;
                        MultiByteToWideChar (CP_ACP,
                                             MB_PRECOMPOSED,
                                             lpszNewCL,
                                             -1,
                                             CmdLineComputerName + nSizePrefix,
                                             sizeof(CmdLineComputerName) - nSizePrefix) ;
                        //prevent lpszCommandLine from being used as input file & stop while loop
                        *lpszCommandLine = '\0' ;
                    } else {
                        LPTSTR  lpszErrMsg ;
                        TCHAR       lpszFormat[80] ;

                        LoadString(hInstance, ERR_BADCOMPUTERNAME, lpszFormat, sizeof(lpszFormat)/sizeof(TCHAR)) ;
                        lpszErrMsg = (LPTSTR)MemoryAllocate ((strlen (lpszNewCL) + 1)*sizeof(TCHAR) + sizeof(lpszFormat)) ;
                        //If memory allocation failed, don't display error message
                        if (lpszErrMsg) {
                            //lpszFormat uses %S specifier so lpszNewCL can be ansi string
                            wsprintf (lpszErrMsg, lpszFormat, lpszNewCL) ;
                            MessageBox (NULL, lpszErrMsg, szApplication, MB_OK | MB_ICONSTOP | MB_TASKMODAL) ;
                        }

                        //prevent lpszCommandLine from being used as input file & stop while loop
                        *lpszCommandLine = '\0' ;
                    }
                }
            }
            lpszNewCL++ ;
        }
    }

    //=============================//
    // Create Window               //
    //=============================//


    hWndMain = CreateWindow (szPerfmonMainClass,
                             szApplication,
                             WS_OVERLAPPEDWINDOW | WS_BORDER,
                             CW_USEDEFAULT, CW_USEDEFAULT,
                             CW_USEDEFAULT, CW_USEDEFAULT,
                             NULL,
                             NULL,
                             NULL,
                             NULL);

    if (!hWndMain)
        return (FALSE) ;

    ViewChart (hWndMain) ;

    LoadMainWindowPlacement (hWndMain) ;

    //=============================//
    // Setup for event logging     //
    //=============================//
    hEventLog = RegisterEventSource (
                                    (LPTSTR)NULL,            // Use Local Machine
                                    TEXT("PerfMon"));        // event log app name to find in registry

    return (TRUE) ;
}


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


BOOL
PerfmonInitialize (
                   HINSTANCE hCurrentInstance,
                   HINSTANCE hPrevInstance,
                   LPCSTR lpszCmdLine,
                   int nCmdShow
                   )
/*
   Effect:        Performa all initializations required when Perfmon is
                  started. In particular, initialize all "systems", register
                  all window classes, create needed windows, read in and
                  process font and Perfmon lists.

   Called By:     WinMain only, at the start of the application.

   Assert:        There are no other instances of Perfmon currently
                  executing.

   Returns:       Whether initialization was successful. If this function
                  returns FALSE, Perfmon should exit immediately.

   Internals:     The bSuccess variable is used to conditionalize each
                  successive initialization step.
*/
{
    BOOL           bSuccess ;
    TCHAR          szFilePath [FilePathLen + 1] ;
    LPTSTR         pFileNameStart ;
    HANDLE         hFindFile ;
    WIN32_FIND_DATA FindFileInfo ;
    CHAR           QuoteChar ;
    LPSTR          pCmdLine ;
    LPSTR          lpszCmdLineStart = NULL ;
    SIZE_T         NameOffset ;
    int            StringLen ;

    hInstance = hCurrentInstance ;
    bSuccess = InitializeSystemValues () ;

    if (bSuccess && !hPrevInstance)
        bSuccess = InitializeApplication () ;

    if (bSuccess)
        bSuccess = InitializeInstance (nCmdShow, lpszCmdLine) ;

    GetDateTimeFormats() ;

    lpszCmdLineStart = lpszCommandLine ;


    if (bSuccess) {

        if (strempty (lpszCommandLine))
            StringLoad (IDS_DEFAULTPATH, szFilePath) ;
        else {
            // check for single or double quote
            QuoteChar = *lpszCommandLine ;
            if (QuoteChar == '\'' || QuoteChar == '\"') {
                lpszCommandLine++ ;

                // remove the matching QuoteChar if found
                pCmdLine = (LPSTR) lpszCommandLine ;
                while (*pCmdLine != '\0') {
                    if (*pCmdLine == QuoteChar) {
                        *pCmdLine = '\0' ;
                        break ;
                    } else {
                        pCmdLine++ ;
                    }
                }
            }

            // convert the LPSTR to LPTSTR

            StringLen = strlen(lpszCommandLine) + 1 ;
            if (StringLen > sizeof(szFilePath)) {
                StringLen = sizeof (szFilePath) - sizeof (TEXT('\0')) ;
            }
            szFilePath[FilePathLen] = TEXT('\0') ;

            mbstowcs (szFilePath, lpszCommandLine, StringLen) ;

            if (!(QuoteChar == '\'' || QuoteChar == '\"')) {
                // if there is no quote, then looking for trailing space
                LPTSTR  pThisChar = szFilePath ;
                LPTSTR  pLastChar = NULL;
                LPTSTR  pSpaceChar = NULL;
                BOOL    bWord = FALSE;

                while (*pThisChar != TEXT('\0')) {
                    if (*pThisChar > TEXT(' ')) {
                        // this is a printable char
                        bWord = TRUE;
                        pLastChar = pThisChar;
                    } else if (bWord) {
                        bWord = FALSE;
                        pSpaceChar = pThisChar;
                    }
                    pThisChar++ ;
                }
                // terminate string after last printable character.
                if (pSpaceChar > pLastChar) *pSpaceChar = TEXT('\0');
            }

            pFileNameStart = ExtractFileName (szFilePath) ;
            NameOffset = pFileNameStart - szFilePath ;

            // convert short filename to long NTFS filename if necessary
            hFindFile = FindFirstFile (szFilePath, &FindFileInfo) ;
            if (hFindFile && hFindFile != INVALID_HANDLE_VALUE) {
                // append the file name back to the path name
                lstrcpy (&szFilePath[NameOffset], FindFileInfo.cFileName) ;
                FindClose (hFindFile) ;
            }
        }

        //      OpenFileHandler (hWndMain, szFilePath) ;
        FileOpen (hWndMain, (int)0, (LPTSTR)szFilePath) ;
        PrepareMenu (GetMenu (hWndMain));
    }

    if (lpszCmdLineStart) {
        MemoryFree (lpszCmdLineStart) ;
        lpszCommandLine = NULL ;
    }

    return (bSuccess) ;
}


void
PerfmonClose (
              HWND hWndMain
              )
{
    DWORD          dwException;
    // close the log file for now.
    // need to query the user later..!!
#if 0
    if (LogCollecting (hWndLog)) {
        PLOG pLog = LogData (hWndLog) ;

        if (pLog) {
            CloseLog (hWndLog, pLog) ;
        }
    }
#endif


    // reset all views - will free all systems as well
    ResetGraphView (hWndGraph) ;
    ResetAlertView (hWndAlert) ;
    ResetLogView (hWndLog) ;
    ResetReportView (hWndReport) ;

    try {
        // if the key has already been closed, this will
        // generate an exception so we'll catch that here
        // and continue...
        //
        // close the local machine
        if (bCloseLocalMachine) {
            RegCloseKey (HKEY_PERFORMANCE_DATA) ;
        }
    }except (EXCEPTION_EXECUTE_HANDLER) {
        // get the exception for the debugger user, that's all
        dwException = GetExceptionCode();
    }


    // free all the filenames
    if (pChartFullFileName) {
        MemoryFree (pChartFullFileName) ;
        pChartFullFileName = NULL ;
    }
    if (pAlertFullFileName) {
        MemoryFree (pAlertFullFileName) ;
        pAlertFullFileName = NULL ;
    }
    if (pLogFullFileName) {
        MemoryFree (pLogFullFileName) ;
        pLogFullFileName = NULL ;
    }
    if (pReportFullFileName) {
        MemoryFree (pReportFullFileName) ;
        pReportFullFileName = NULL ;
    }

    // free all the GDI resources
    DeletePen (hWhitePen) ;
    DeletePerfmonSystemObjects () ;

    // close event log
    DeregisterEventSource (hEventLog);

    SaveMainWindowPlacement (hWndMain) ;
    DestroyWindow (hWndMain) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\intrline.c ===
/*
==============================================================================

  Application:

            Microsoft Windows NT (TM) Performance Monitor

  File:
            intrline.c -- IntervalLine custom control.

  Copyright 1992, Microsoft Corporation. All Rights Reserved.
==============================================================================
*/


/*


Basic Information
-----------------

An ILine (Interval Line) control is a horizontally-sliding device; the user
can slide the start position and end position independently by dragging
either "grab" bar, or move them simultaneously by dragging the center grab
bar. An ILine control is used in the Input Log dialog of Perfmon, but could
be used anywhere. The control allows the user to specify the start, end and
duration of playback within the range of previously-logged data.


ILine Parts
-----------

     iBeginValue                                            iEndValue
     |      iStartValue                        iStopValue           |
     |      |                                           |           |
     v      v                                           v           v
     +------+-+---------------------------------------+-+-----------+
     |      |X|                                       |X|           |
     |      |X|                                       |X|           |
     +------+-+---------------------------------------+-+-----------+
             ^                    ^                    ^
             Start grab bar       Center grab bar      Stop grab bar


ILine Terminology
-----------------

All external routines are designated by the prefix ILine-.
Internal routines are designated by the prefix IL-.

The suffix -Value represents an integer in the user-supplied domain.
The suffix -Pixel represents an integer location on the screen.

Note that the range of the IntervalLine is represented by "Begin" and
"End", while the the currently selected interval is represented by
"Start" and "Stop".


Implementation Notes
--------------------

ILine is a custom control, but does not have all the messages
normally associated with a full-fledged control type like "button".
In particular, it doesn't have a keyboard interface or ask it's parent
for color choices. It also doesn't have the functions needed for interfacing
with the dialog editor custom control menu.

An ILine control is designed to work with an integer range of values
specified by the user of the control. These values should have meaning to
the caller. The caller can specify the minimum value of the range
(iBeginValue), the maximum value of the range (iEndValue), and the current
starting and stopping values (iStartValue and iStopValue).

These values are set with a function-based interface. (ILSetXXX).

The code distinguishes between the *values* for the begin, end, start, and
stop, and the *pixels* which represent locations on the control for these
values.

Various bits of the control style allow for changing the control's
behavior.

To allow for multiple ILine controls, all data used by each ILine
instance is allocated from the heap and associated with the control.
The allocation is done in OnCreate and the freeing in OnDestroy. The
instance data is contained in the ILINE structure. Each message handler
retrieves this instance data with the ILData function.

*/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "perfmon.h"
#include "utils.h"
#include "intrline.h"
#include "pmemory.h"        // for MemoryXXX (mallloc-type) routines

BOOL  IntrLineFocus ;

//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define dwILineClassStyle     (CS_HREDRAW | CS_VREDRAW)
#define iILineClassExtra      (0)
#define iILineWindowExtra     (sizeof (PILINE))
#define dwILineWindowStyle    (WS_CHILD | WS_VISIBLE)


#define ILModeNone            0
#define ILModeLeft            1
#define ILModeCenter          2
#define ILModeRight           3

#define TO_THE_END            0x7FFFFFFFL

//==========================================================================//
//                                  Typedefs                                //
//==========================================================================//


// The instance data for each IL window.  One of these is allocated for each
// window in the window's OnCreate processing and free'd in OnDestroy.
typedef struct ILINESTRUCT
   {  // ILINE
   int            iBeginValue ;        // user-supplied lowest range
   int            iEndValue ;          // user-supplied highest range
   int            iStartValue ;        // current start of selected interval
   int            iStopValue ;         // current end of selected interval
   int            iGranularityValue ;
   int            iMinimumRangeValue ;

   RECT           rectBorder ;
   RECT           rectLeftBk ;
   RECT           rectLeftGrab ;
   RECT           rectCenterGrab ;
   RECT           rectRightGrab ;
   RECT           rectRightBk ;

   HBRUSH         hBrushBk ;

   POINTS         ptsMouse ;
   int            iMode ;              // who is being tracked?
   } ILINE ;

typedef ILINE *PILINE ;


//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


// Width of the start and stob grab bars
#define ILGrabWidth()      \
   (xScrollThumbWidth)


// A rectangle is "drawable" if it has both nonzero width and height
#define RectDrawable(lpRect)           \
   ((lpRect->right - lpRect->left) &&  \
    (lpRect->bottom - lpRect->top))


//======================================//
// ILine Accessor Macros                //
//======================================//

// These macros reference fields in the ILine structure and should be
// used in place of direct reference to the fields. This makes the code
// easier to read and allows modification of the underlying structure.

// You can use these macros to both get and set the fields.

#define ILBegin(pILine)    \
   (pILine->iBeginValue)

#define ILEnd(pILine)      \
   (pILine->iEndValue)

#define ILStart(pILine)    \
   (pILine->iStartValue)

#define ILStop(pILine)     \
   (pILine->iStopValue)

#define ILMode(pILine)     \
   (pILine->iMode)


//======================================//
// ILine Pseudo-Accessor Macros         //
//======================================//

// These macros are used to get values which don't correspond to a single
// field. You can get the value with these macros but can't set it.

#define ILWidth(pILine)    \
   (pILine->rectBorder.right)

#define ILRange(pILine)    \
   (ILEnd (pILine) - ILBegin (pILine))

#define ILStartPixel(pILine) \
   (pILine->rectLeftGrab.left)

#define ILStopPixel(pILine)   \
   (pILine->rectRightGrab.right)


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


void static ILNotifyChange (HWND hWnd,
                            PILINE pILine)
   {  // ILNotifyChange
   HWND           hWndParent ;

   hWndParent = WindowParent (hWnd) ;

   if (hWndParent)
      SendMessage (hWndParent, WM_COMMAND,
                   (WPARAM) WindowID (hWnd),
                   (LPARAM) hWnd) ;
   }  // ILNotifyChange


BOOL ILGrabRect (IN PILINE pILine,
                 OUT LPRECT lpRect)
/*
   Effect:        Return in lpRect the rectangle representing the position
                  of the grab bar currently being tracked.
*/
   {  // ILGrabRect
   switch (ILMode (pILine))
      {  // switch
      case ILModeLeft:
         *lpRect = pILine->rectLeftGrab ;
         return (TRUE) ;
         break ;

      case ILModeRight:
         *lpRect = pILine->rectRightGrab ;
         return (TRUE) ;
         break ;

      case ILModeCenter:
         *lpRect = pILine->rectCenterGrab ;
         return (TRUE) ;
         break ;

      case ILModeNone:
         lpRect->left = 0 ;
         lpRect->top = 0 ;
         lpRect->right = 0 ;
         lpRect->bottom = 0 ;
         return (FALSE) ;
         break ;
      }  // switch

    // return FALSE if it falls through to here
    return FALSE;
   }  // ILGrabRect


PILINE ILData (HWND hWndIL)
   {
   return ((PILINE) GetWindowLongPtr (hWndIL, 0)) ;
   }


PILINE AllocateILData (HWND hWndIL)
   {
   PILINE         pILine ;

   pILine = MemoryAllocate (sizeof (ILINE)) ;
   SetWindowLongPtr (hWndIL, 0, (LONG_PTR) pILine) ;

   return (pILine) ;
   }


void static DrawGrab (HDC hDC,
                      LPRECT lpRectGrab,
                      BOOL bDown)
   {  // DrawGrab
   if (!RectDrawable (lpRectGrab))
      return ;

   if (bDown)
      ThreeDConcave1 (hDC,
                     lpRectGrab->left,
                     lpRectGrab->top,
                     lpRectGrab->right,
                     lpRectGrab->bottom) ;
   else
      ThreeDConvex1 (hDC,
                    lpRectGrab->left,
                    lpRectGrab->top,
                    lpRectGrab->right,
                    lpRectGrab->bottom) ;
   }  // DrawGrab


int ILValueToPixel (PILINE pILine,
                    int iValue)
   {
   int            xPixel ;

   if (ILRange (pILine))
      xPixel = MulDiv (iValue, ILWidth (pILine), ILRange (pILine)) ;
   else
      xPixel = 0 ;

   return (PinExclusive (xPixel, 0, pILine->rectBorder.right)) ;
   }


int ILPixelToValue (PILINE pILine,
                    int xPixel)
   {
   int            iValue ;

   if (ILWidth (pILine))
      iValue = MulDiv (xPixel, ILRange (pILine), ILWidth (pILine)) ;
   else
      iValue = 0 ;

   return (PinInclusive (iValue, ILBegin (pILine), ILEnd (pILine))) ;
   }


void static ILCalcPositions (HWND hWnd,
                             PILINE pILine)
/*
   Effect:        Determine and set all of the physical rectangles of ILine,
                  based on the current size of the ILine window and the
                  current logical Start, Stop, Begin, and End values.
*/
   {  // ILCalcPositions
   int            xStart, xStop ;
   int            yHeight ;

   GetClientRect (hWnd, &pILine->rectBorder) ;
   yHeight = pILine->rectBorder.bottom ;

   xStart = ILValueToPixel (pILine, ILStart (pILine)) ;
   xStop = ILValueToPixel (pILine, ILStop (pILine)) ;

   pILine->rectLeftBk.left = 1 ;
   pILine->rectLeftBk.top = 1 ;
   pILine->rectLeftBk.right = xStart ;
   pILine->rectLeftBk.bottom = yHeight - 1 ;

   pILine->rectLeftGrab.left = xStart ;
   pILine->rectLeftGrab.top = 1 ;
   pILine->rectLeftGrab.right = xStart + ILGrabWidth () ;
   pILine->rectLeftGrab.bottom = yHeight - 1 ;

   pILine->rectRightBk.left = xStop ;
   pILine->rectRightBk.top = 1 ;
   pILine->rectRightBk.right = pILine->rectBorder.right - 1 ;
   pILine->rectRightBk.bottom = yHeight - 1 ;

   pILine->rectRightGrab.left = xStop - ILGrabWidth () ;
   pILine->rectRightGrab.top = 1 ;
   pILine->rectRightGrab.right = xStop ;
   pILine->rectRightGrab.bottom = yHeight - 1 ;

   pILine->rectCenterGrab.left = pILine->rectLeftGrab.right ;
   pILine->rectCenterGrab.top = 1 ;
   pILine->rectCenterGrab.right = pILine->rectRightGrab.left ;
   pILine->rectCenterGrab.bottom = yHeight - 1 ;

   if (pILine->rectLeftGrab.right > pILine->rectRightGrab.left)
      {
      pILine->rectLeftGrab.right = pILine->rectLeftGrab.left +
                                   (xStop - xStart) / 2 ;
      pILine->rectRightGrab.left = pILine->rectLeftGrab.right ;
      pILine->rectCenterGrab.left = 0 ;
      pILine->rectCenterGrab.right = 0 ;
      }
   }  // ILCalcPositions


void static ILDraw (HDC hDC,
                    PILINE pILine,
                    LPRECT lpRectUpdate)
/*
   Effect:        Draw the image of pILine on hDC.  Draw at least the
                  portions within rectUpdate.

   Called By:     OnPaint, OnMouseMove.
*/
   {  // ILDraw
   HBRUSH hBrush = GetStockObject (BLACK_BRUSH);

   if (!hBrush)
        return;
   //=============================//
   // Draw Border                 //
   //=============================//

   FrameRect (hDC, &pILine->rectBorder, hBrush);

   //=============================//
   // Draw Background             //
   //=============================//

   FillRect (hDC, &pILine->rectLeftBk, pILine->hBrushBk) ;
   FillRect (hDC, &pILine->rectRightBk, pILine->hBrushBk) ;

   //=============================//
   // Draw Range Grabs            //
   //=============================//

   DrawGrab (hDC, &pILine->rectLeftGrab,
             ILMode (pILine) == ILModeLeft) ;
   DrawGrab (hDC, &pILine->rectRightGrab,
             ILMode (pILine) == ILModeRight) ;

   //=============================//
   // Draw Center Grab            //
   //=============================//

   DrawGrab (hDC, &pILine->rectCenterGrab,
             ILMode (pILine) == ILModeCenter) ;
   }  // ILDraw

#if 0
void ILPageLeftRight (HWND hWnd,
                      PILINE pILine,
                      BOOL bLeft)
   {  // ILPageLeftRight
   int            iStart, iStop, iMove ;
   HDC            hDC ;

   iStart = ILStart (pILine) ;
   iStop = ILStop (pILine) ;

   if (ILRange (pILine) >= 10)
      iMove = ILRange (pILine) / 10 ;
   else
      iMove = 1 ;

   if (bLeft)
      iMove = -iMove ;

   iStart += iMove ;
   iStop += iMove ;

   ILineSetStart (hWnd, iStart) ;
   ILineSetStop (hWnd, iStop) ;

   hDC = GetDC (hWnd) ;
   ILDraw (hDC, pILine, &pILine->rectBorder) ;
   ReleaseDC (hWnd, hDC) ;

   ILNotifyChange (hWnd, pILine) ;
   }  // ILPageLeftRight
#endif

void ILMoveLeftRight (HWND hWnd,
                      BOOL bStart,
                      BOOL bLeft,
                      int  MoveAmt)
   {  // ILPageLeftRight
   int            iStart, iStop, iMove ;
   int            iBegin, iEnd ;
   HDC            hDC ;
   PILINE         pILine ;

   pILine = ILData (hWnd) ;
   iStart = ILStart (pILine) ;
   iStop = ILStop (pILine) ;
   iBegin = ILBegin (pILine) ;
   iEnd = ILEnd (pILine) ;

   iMove = MoveAmt ;
   if (bLeft)
      iMove = -iMove ;

   if (bStart)
      {
      if (MoveAmt == TO_THE_END)
         {
         iStart = iBegin ;
         }
      else
         {
         iStart += iMove ;
         if (iStart >= iStop)
            {
            return;
            }
         }

      ILineSetStart (hWnd, iStart) ;
      }
   else
      {
      if (MoveAmt == TO_THE_END)
         {
         iStop = iEnd ;
         }
      else
         {
         iStop += iMove ;
         if (iStart >= iStop)
            {
            return;
            }
         }

      ILineSetStop (hWnd, iStop) ;
      }

   hDC = GetDC (hWnd) ;
   if (hDC) {
       ILDraw (hDC, pILine, &pILine->rectBorder) ;
       ReleaseDC (hWnd, hDC) ;
   }

   ILNotifyChange (hWnd, pILine) ;
   }  // ILMoveLeftRight

static BOOL OnKeyDown (HWND hWnd,
                       WPARAM wParam)
   {
   BOOL bHandle = TRUE ;
   BOOL bStart ;
   BOOL bLeftDirection ;
   BOOL bShiftKeyDown ;

   if (wParam == VK_LEFT || wParam == VK_RIGHT)
      {
      bShiftKeyDown = (GetKeyState (VK_SHIFT) < 0) ;

      if (!bShiftKeyDown)
         {
         if (wParam == VK_LEFT)
            {
            // Left Arrow --> move Start Edge Left
            bStart = TRUE ;
            bLeftDirection = TRUE ;
            }
         else
            {
            // Right Arrow --> move Stop Edge Right
            bStart = FALSE ;
            bLeftDirection = FALSE ;
            }
         }
      else
         {
         if (wParam == VK_LEFT)
            {
            // Shift Left Arrow --> move Stop Edge Left
            bStart = FALSE ;
            bLeftDirection = TRUE ;
            }
         else
            {
            // Shift Right Arrow --> move Start Edge Right
            bStart = TRUE ;
            bLeftDirection = FALSE ;
            }
         }
      ILMoveLeftRight (hWnd, bStart, bLeftDirection, 1) ;
      }
   else if (wParam == VK_HOME)
      {
      // move iStart all the way the Left
      ILMoveLeftRight (hWnd, TRUE, TRUE, TO_THE_END) ;
      }
   else if (wParam == VK_END)
      {
      // move iStop all the way the right
      ILMoveLeftRight (hWnd, FALSE, FALSE, TO_THE_END) ;
      }
   else
      {
      bHandle = FALSE ;
      }
   return (bHandle) ;

   }  // OnKeyDown

void StartGrab (HWND hWnd,
                PILINE pILine)
   {  // StartGrab
   RECT           rectUpdate ;
   HDC            hDC ;

   SetCapture (hWnd) ;
   ILGrabRect (pILine, &rectUpdate) ;

   hDC = GetDC (hWnd) ;
   if (hDC) {
       ILDraw (hDC, pILine, &rectUpdate) ;
       ReleaseDC (hWnd, hDC) ;
   }  // StartGrab
}

void EndGrab (HWND hWnd,
              PILINE pILine)
/*
   Internals:     Set the mode to null after getting the grab rectangle
                  so ILGrabRect knows which grab bar to get.
*/
   {
   RECT           rectUpdate ;
   HDC            hDC ;

   ReleaseCapture () ;

   ILGrabRect (pILine, &rectUpdate) ;
   ILMode (pILine) = ILModeNone ;

   hDC = GetDC (hWnd) ;
   if (hDC) {
       ILDraw (hDC, pILine, &rectUpdate) ;
       ReleaseDC  (hWnd, hDC) ;
   }
}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void static OnPaint (HWND hWnd)
   {
   PAINTSTRUCT    ps ;
   HDC            hDC ;
   PILINE         pILine ;

   pILine = ILData (hWnd) ;
   hDC = BeginPaint (hWnd, &ps) ;

   ILDraw (hDC, pILine, &ps.rcPaint) ;

   EndPaint (hWnd, &ps) ;
   }


void static OnCreate (HWND hWnd)
   {
   PILINE         pILine ;

   pILine = AllocateILData (hWnd) ;
   ILBegin (pILine) =  0 ;
   ILEnd (pILine) =  100 ;
   ILStart (pILine) =  0 ;
   ILStop (pILine) = 100 ;
   ILMode (pILine) = ILModeNone ;

   pILine->hBrushBk = CreateSolidBrush (crBlue) ;
   ILCalcPositions (hWnd, pILine) ;
   }


void static OnDestroy (HWND hWnd)
   {
   PILINE         pILine ;

   pILine = ILData (hWnd) ;

   IntrLineFocus = FALSE ;
   DeleteBrush (pILine->hBrushBk) ;
   MemoryFree (pILine) ;
   }


void static OnLButtonUp (HWND hWnd)
   {  // OnLButtonUp
   PILINE         pILine ;

   pILine = ILData (hWnd) ;

   if (ILMode (pILine) == ILModeNone)
      return ;

   EndGrab (hWnd, pILine) ;
   }  // OnLButtonUp


void static OnMouseMove (HWND hWnd,
                         POINTS ptsMouse)
/*
   Effect:        Handle any actions needed when the mouse moves in the
                  ILine hWnd's client area or while the mouse is captured.
                  In particular, if we are tracking one of the grab bars,
                  determine if the mouse movement represents a logical value
                  change and move the grab bar accordingly.

   Called By:     ILineWndProc, in response to a WM_MOUSEMOVE message.

   See Also:      OnLButtonDown, OnLButtonUp.

   Note:          This function has multiple return points.

   Note:          Since we have captured the mouse, we receive mouse msgs
                  even when the mouse is outside our client area, but still
                  in client coordinates. Thus we can have negative mouse
                  coordinates. That is why we convert the lParam of the
                  mouse msg into a POINTS structure rather than 2 WORDS.


   Internals:     Remember that an IntervalLine can only take on integral
                  values in the user-supplied range. Therefore we do our
                  movement calculation in user values, not pixels. We
                  determine what the logical value would be for the previous
                  (last mouse move) and current mouse position. If these
                  LOGICAL values differ, we attempt an adjustment of the
                  grab bar by that logical amount.  This way the grab
                  values assume on integral positions and the calculations
                  are simplified.

                  If we calculated by pixel movement, and then shifted the
                  bar into the nearest integal position, we would encounter
                  rounding problems. In particular, when tracking the center
                  grab bar, if we moved both start and stop by the same
                  amount of PIXELS, then converted to LOGICAL values, we
                  might find our center bar shrinking and growing while
                  the bar moves.
*/
   {
   int            iMousePrevious, iMouseCurrent ;
   int            iMouseMove ;
   PILINE         pILine ;
   HDC            hDC ;

   //=============================//
   // Are we tracking?            //
   //=============================//

   pILine = ILData (hWnd) ;
   if (ILMode (pILine) == ILModeNone)
      return ;

   //=============================//
   // Calc LOGICAL mouse movement //
   //=============================//

   ptsMouse.x = PinInclusive ((INT)ptsMouse.x,
                              (INT)pILine->rectBorder.left,
                              (INT)pILine->rectBorder.right) ;

   iMousePrevious = ILPixelToValue (pILine, pILine->ptsMouse.x) ;
   iMouseCurrent = ILPixelToValue (pILine, ptsMouse.x) ;

   iMouseMove = iMouseCurrent - iMousePrevious ;
   if (!iMouseMove)
      return ;

   //=============================//
   // Move grab bar positions     //
   //=============================//

   switch (ILMode (pILine))
      {  // switch
      case ILModeLeft:
         ILStart (pILine) += iMouseMove ;
         ILStart (pILine) = min (ILStart (pILine), ILStop (pILine) - 1) ;
         break ;

      case ILModeCenter:
         // Before we slide the center grab bar we need to see if the
         // desired movement amount would send either end out of bounds,
         // and reduce the movement accordingly.

         if (ILStart (pILine) + iMouseMove < ILBegin (pILine))
            iMouseMove = ILBegin (pILine) - ILStart (pILine) ;
         if (ILStop (pILine) + iMouseMove > ILEnd (pILine))
            iMouseMove = ILEnd (pILine) - ILStop (pILine) ;

         ILStart (pILine) += iMouseMove ;
         ILStop (pILine) += iMouseMove ;
         break ;

      case ILModeRight:
         ILStop (pILine) += iMouseMove ;
         ILStop (pILine) = max (ILStart (pILine) + 1, ILStop (pILine)) ;
         break ;
      }  // switch


   //=============================//
   // Keep grab bars in range     //
   //=============================//


   ILStart (pILine) = PinInclusive (ILStart (pILine),
                                    ILBegin (pILine), ILEnd (pILine)) ;
   ILStop (pILine) = PinInclusive (ILStop (pILine),
                                   ILBegin (pILine), ILEnd (pILine)) ;

   //=============================//
   // Determine pixel pos, draw   //
   //=============================//

   ILCalcPositions (hWnd, pILine) ;

   hDC = GetDC (hWnd) ;
   if (hDC) {
       ILDraw (hDC, pILine, &pILine->rectBorder) ;
       ReleaseDC (hWnd, hDC) ;
   }

   pILine->ptsMouse = ptsMouse ;
   ILNotifyChange (hWnd, pILine) ;
   }  // OnMouseMove


void static OnLButtonDown (HWND hWnd,
                           POINTS ptsMouse)
   {
   PILINE         pILine ;
   POINT          ptMouse ;

   pILine = ILData (hWnd) ;

   pILine->ptsMouse = ptsMouse ;
   ptMouse.x = ptsMouse.x ;
   ptMouse.y = ptsMouse.y ;

#if 0
   // Russ said this is bad, so don't do it
   if (PtInRect (&pILine->rectLeftBk, ptMouse))
      ILPageLeftRight (hWnd, pILine, TRUE) ;

   else if (PtInRect (&pILine->rectRightBk, ptMouse))
      ILPageLeftRight (hWnd, pILine, FALSE) ;

   else if (PtInRect (&pILine->rectLeftGrab, ptMouse))
#endif
   if (PtInRect (&pILine->rectLeftGrab, ptMouse) ||
       PtInRect (&pILine->rectLeftBk, ptMouse))
      {
      ILMode (pILine) = ILModeLeft ;
      StartGrab (hWnd, pILine) ;
      }

   else if (PtInRect (&pILine->rectRightGrab, ptMouse) ||
            PtInRect (&pILine->rectRightBk, ptMouse))
      {
      ILMode (pILine) = ILModeRight ;
      StartGrab (hWnd, pILine) ;
      }

   else if (PtInRect (&pILine->rectCenterGrab, ptMouse))
      {
      ILMode (pILine) = ILModeCenter ;
      StartGrab (hWnd, pILine) ;
      }
   }


void static OnSize (HWND hWnd, WORD xWidth, WORD yHeight)
   {  // OnSize
   PILINE         pILine ;

   pILine = ILData (hWnd) ;

   ILCalcPositions (hWnd, pILine) ;
   }  // OnSize


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


LRESULT
FAR
PASCAL
ILineWndProc (
              HWND hWnd,
              unsigned msg,
              WPARAM wParam,
              LPARAM lParam
              )
/*
   Note:          This function must be declared in the application's
                  linker-definition file, perfmon.def file.
*/
   {  // ILineWndProc
   BOOL           bCallDefWindowProc ;
   POINTS         ptsMouse ;
   LRESULT        lReturnValue ;

   bCallDefWindowProc = FALSE ;
   lReturnValue = 0L ;

   switch (msg)
      {  // switch
      case WM_CREATE:
         OnCreate (hWnd) ;
         break ;

      case WM_DESTROY:
         OnDestroy (hWnd) ;
         break ;

      case WM_LBUTTONDOWN:
         // See the note in OnMouseMove for why we are using POINTS
         SetFocus (hWnd) ;
         ptsMouse = MAKEPOINTS (lParam) ;
         OnLButtonDown (hWnd, ptsMouse) ;
         break ;

      case WM_LBUTTONUP:
         OnLButtonUp (hWnd) ;
         break ;

      case WM_SETFOCUS:
      case WM_KILLFOCUS:
         {
         PILINE         pILine ;

         IntrLineFocus = (msg == WM_SETFOCUS) ;

         pILine = ILData (hWnd) ;
         ILNotifyChange (hWnd, pILine) ;
         }
         return 0 ;


      case WM_MOUSEMOVE:
         // See the note in OnMouseMove for why we are using POINTS
         ptsMouse = MAKEPOINTS (lParam) ;
         OnMouseMove (hWnd, ptsMouse) ;
         break ;

      case WM_KEYDOWN:
         if (!OnKeyDown (hWnd, wParam))
            {
            bCallDefWindowProc = TRUE ;
            }
         break ;

      case WM_GETDLGCODE:
         // We want to handle Arrow keys input.  If we don't specify this
         // the dialog will not pass arrow keys to us.
         return (DLGC_WANTARROWS) ;
         break ;

      case WM_PAINT:
         OnPaint (hWnd) ;
         break ;

      case WM_SIZE:
         OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ;

      default:
         bCallDefWindowProc = TRUE ;
      }  // switch

   if (bCallDefWindowProc)
      lReturnValue = DefWindowProc (hWnd, msg, wParam, lParam) ;

   return (lReturnValue) ;
   }  // ILineWndProc



BOOL ILineInitializeApplication (void)
/*
   Effect:        Perform all initializations required before an application
                  can create an IntervalLine. In particular, register the
                  IntervalLine window class.

   Called By:     The application, in its InitializeApplication routine.

   Returns:       Whether the class could be registered.
*/
   {  // ILineInitializeApplication
   WNDCLASS       wc ;

   wc.style =           dwILineClassStyle ;
   wc.lpfnWndProc =     ILineWndProc ;
   wc.cbClsExtra =      iILineClassExtra ;
   wc.cbWndExtra =      iILineWindowExtra ;
   wc.hInstance =       hInstance ;
   wc.hIcon =           NULL ;
   wc.hCursor =         LoadCursor (NULL, IDC_ARROW) ;
   wc.hbrBackground =   NULL ;
   wc.lpszMenuName =    NULL ;
   wc.lpszClassName =   szILineClass ;

   return (RegisterClass (&wc)) ;
   }  // ILineInitializeApplication


void ILineSetRange (HWND hWnd, int iBegin, int iEnd)
   {  // ILineSetRange
   PILINE         pILine ;

   pILine = ILData (hWnd) ;

   ILBegin (pILine) = iBegin ;
   ILEnd (pILine) = iEnd ;

   ILCalcPositions (hWnd, pILine) ;
   }  // ILineSetRange


void ILineSetStart (HWND hWnd, int iStart)
   {  // ILineSetStart
   PILINE         pILine ;

   pILine = ILData (hWnd) ;

   iStart = PinInclusive (iStart, ILBegin (pILine), ILEnd (pILine)) ;
   ILStart (pILine) = iStart ;

   ILCalcPositions (hWnd, pILine) ;
   }  // ILineSetStart



void ILineSetStop (HWND hWnd, int iStop)
   {  // ILineSetStop
   PILINE         pILine ;

   pILine = ILData (hWnd) ;

   iStop = PinInclusive (iStop, ILBegin (pILine), ILEnd (pILine)) ;
   ILStop (pILine) = iStop ;

   ILCalcPositions (hWnd, pILine) ;
   }  // ILineSetStop


int ILineXStart (HWND hWnd)
   {
   PILINE         pILine ;

   pILine = ILData (hWnd) ;

   return (pILine->rectLeftGrab.left) ;
   }


int ILineXStop (HWND hWnd)
   {
   PILINE         pILine ;

   pILine = ILData (hWnd) ;

   return (pILine->rectRightGrab.right) ;
   }


int ILineStart (HWND hWnd)
   {
   PILINE         pILine ;

   pILine = ILData (hWnd) ;

   return  (ILStart (pILine)) ;
   }


int ILineStop (HWND hWnd)
   {
   PILINE         pILine ;

   pILine = ILData (hWnd) ;

   return  (ILStop (pILine)) ;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\legend.h ===
//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define szGraphLegendClass          TEXT("PerfLegend")
#define szGraphLegendClassA         "PerfLegend"


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//



void ClearLegend (HWND hWndLegend) ;

BOOL GraphLegendInitializeApplication (void) ;

HWND CreateGraphLegendWindow (HWND hWndGraph) ;

int LegendMinHeight (HWND hWnd) ;

int LegendMinWidth (HWND hWnd) ;


void LegendDeleteItem (HWND hWndLegend, 
                       PLINE pLine) ;


int LegendHeight (HWND hWnd, int yGraphHeight) ;


BOOL LegendAddItem (HWND hWndGraph,
                    PLINESTRUCT pLine) ;


PLINE LegendCurrentLine (HWND hWndLegend) ;


int LegendNumItems (HWND hWndLegend) ;


void LegendSetSelection (HWND hWndLegend, int iIndex) ;


int LegendFullHeight (HWND hWnd, HDC hDC) ;


void PrintLegend (HDC hDC, PGRAPHSTRUCT pGraph, HWND hWndLegend,
                  RECT rectLegend) ;

void LegendSetRedraw (HWND hWndLegend, BOOL bRedraw) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\intrline.h ===
/*
==============================================================================

  Application:

            Microsoft Windows NT (TM) Performance Monitor

  File:
            intrline.h -- IntervalLine custom control.

  Written by:

            Mike Moskowitz 24 Mar 92.

  Copyright 1992, Microsoft Corporation. All Rights Reserved.
==============================================================================
*/

//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define szILineClass          TEXT("PerfILine")


#define ILN_SELCHANGED        (WM_USER + 0x200)


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


BOOL ILineInitializeApplication (void) ;


void ILineSetRange (HWND hWnd, int iBegin, int iEnd) ;


void ILineSetStart (HWND hWnd, int iStart) ;


void ILineSetStop (HWND hWnd, int iStop) ;


int ILineStart (HWND hWnd) ;


int ILineStop (HWND hWnd) ;


int ILineXStart (HWND hWnd) ;


int ILineXStop (HWND hWnd) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\legend.c ===
/*
==============================================================================

  Application:

            Microsoft Windows NT (TM) Performance Monitor

  File:
            legend.c - legend window routines.

            This file contains code creating the legend window, which is
            a child of the graph windows. The legend window displays a
            legend line for each line in the associated graph. It also
            includes an area called the label, which are headers for those
            lines.


  Copyright 1992, Microsoft Corporation. All Rights Reserved.
==============================================================================
*/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include <stdio.h>      // for sprintf
#include "perfmon.h"
#include "legend.h"     // external declarations for this file

#include "owndraw.h"

#include "alert.h"      // for EditAlert
#include "grafdata.h"   // for EditChart
#include "pmemory.h"    // for MemoryXXX (mallloc-type) routines
#include "utils.h"
#include "valuebar.h"   // for StatusTimer
#include "playback.h"   // for PlayingBackLog()
#include "perfmops.h"   // for COnvertDecimalPoint

#define eScaleValueSpace       TEXT(">9999999999.0")

//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define dwGraphLegendClassStyle     (CS_HREDRAW | CS_VREDRAW)
#define iGraphLegendClassExtra      (0)
#define iGraphLegendWindowExtra     (sizeof (PLEGEND))
#define dwGraphLegendWindowStyle    (WS_CHILD | WS_VISIBLE)

#define xLegendBorderWidth          (xDlgBorderWidth)
#define yLegendBorderHeight         (yDlgBorderHeight)

#define iLabelLen                   30
#define iLegendColMax               1000

#define LEFTORIENTATION             1
#define CENTERORIENTATION           2
#define RIGHTORIENTATION            3

#define LegendColorCol              0
#define LegendScaleCol              1
#define LegendCounterCol            2
#define LegendInstanceCol           3
#define LegendParentCol             4
#define LegendObjectCol             5
#define LegendSystemCol             6

#define iLegendNumCols              7

#define iLegendMaxVisibleItems      8

#define dwGraphLegendItemsWindowClass  TEXT("ListBox")
#define dwGraphLegendItemsWindowStyle           \
   (LBS_NOTIFY | LBS_NOINTEGRALHEIGHT | LBS_OWNERDRAWFIXED | \
    WS_VISIBLE | WS_CHILD | WS_VSCROLL)


//==========================================================================//
//                                  Typedefs                                //
//==========================================================================//


typedef struct LEGENDCOLSTRUCT {
    TCHAR          szLabel [iLabelLen] ;
    int            xMinWidth ;
    int            xMaxWidth ;
    int            xWidth ;
    int            xPos ;
    int            iOrientation ;
} LEGENDCOL ;

typedef LEGENDCOL *PLEGENDCOL ;


typedef struct LEGENDTRUCT {
    HWND           hWndItems ;
    HFONT          hFontItems ;
    HFONT          hFontLabels ;
    int            xMinWidth ;
    int            yLabelHeight ;
    int            yItemHeight ;
    int            iNumItemsVisible ;
    LEGENDCOL      aCols [iLegendNumCols] ;
    int            iLineType ;
    PLINE          pCurrentLine ;    // current selected line
}  LEGEND ;

typedef LEGEND *PLEGEND ;


//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define LabelTopMargin()      (2)
#define LegendLeftMargin()    (3 + ThreeDPad)

#define LegendItemTopMargin() (yBorderHeight)


#define IsLegendLabelVisible()  (TRUE)

#define ColCanGrow(pCol)                     \
   (pCol->xMaxWidth > pCol->xWidth)


#define LegendHorzMargin()    (3)



//==========================================================================//
//                                Local Data                                //
//==========================================================================//


PLEGEND     pGraphLegendData ;
PLEGEND     pAlertLegendData ;

#define  LegendData(hWnd)     \
   ((hWnd == hWndGraphLegend) ? pGraphLegendData : pAlertLegendData )

//==========================================================================//
//                              Local Functions                             //
//==========================================================================//
void
LegendSetCurrentLine (
                     PLEGEND pLegend,
                     int iIndex
                     )
{
    pLegend->pCurrentLine =
    (PLINESTRUCT) LBData (pLegend->hWndItems, iIndex) ;

    if (pLegend->pCurrentLine == (PLINESTRUCT) LB_ERR) {
        pLegend->pCurrentLine = NULL ;
    }
}


PLEGEND
AllocateLegendData (
                   HWND hWnd,
                   BOOL bChartLegend
                   )
{
    PLEGEND        pLegend ;

    pLegend = MemoryAllocate (sizeof (LEGEND)) ;

    if (bChartLegend) {
        hWndGraphLegend = hWnd ;
        pGraphLegendData = pLegend ;
    } else {
        hWndAlertLegend = hWnd ;
        pAlertLegendData = pLegend ;
    }

    return (pLegend) ;
}


void
DrawLegendLabel (
                PLEGEND pLegend,
                HDC hDC,
                HWND hWnd
                )
{
    int            i ;
    int            xPos ;
    RECT           rect ;
    RECT           rectLB ;
    INT            LocalThreeDPad = ThreeDPad - 1 ;

    //   SetBkColor (hDC, crLightGray) ;
    SetBkColor (hDC, ColorBtnFace) ;

    SelectFont (hDC, pLegend->hFontLabels) ;

    GetClientRect (hWnd, &rect) ;
    //   Fill (hDC, crLightGray, &rect) ;
    ExtTextOut (hDC, rect.left, rect.top,
                ETO_OPAQUE, &(rect), NULL, 0, NULL ) ;

    GetWindowRect (pLegend->hWndItems, &rectLB) ;
    ScreenRectToClient (hWnd, &rectLB) ;
    ThreeDConcave1 (hDC,
                    rectLB.left - LocalThreeDPad,
                    rectLB.top - LocalThreeDPad,
                    rectLB.right + LocalThreeDPad,
                    rectLB.bottom + LocalThreeDPad) ;

    for (i = 0; i < iLegendNumCols; i++) {
        rect.left = pLegend->aCols[i].xPos ;
        rect.top = yBorderHeight ;
        rect.right = rect.left + pLegend->aCols[i].xWidth - LegendHorzMargin () ;
        rect.bottom = pLegend->yLabelHeight ;

        switch (pLegend->aCols[i].iOrientation) {
            case LEFTORIENTATION:
                SetTextAlign (hDC, TA_LEFT) ;
                xPos = rect.left ;
                break ;

            case CENTERORIENTATION:
                SetTextAlign (hDC, TA_CENTER) ;
                xPos = (rect.left + rect.right) / 2 ;
                break ;

            case RIGHTORIENTATION:
                SetTextAlign (hDC, TA_RIGHT) ;
                xPos = rect.right ;
                break ;

            default:
                xPos = rect.left ;
                break ;
        }

        ExtTextOut (hDC,
                    xPos, rect.top,
                    ETO_OPAQUE,
                    &rect,
                    pLegend->aCols[i].szLabel,
                    lstrlen (pLegend->aCols[i].szLabel),
                    NULL) ;
    }
}


void
DrawColorCol (
             PLEGEND pLegend,
             PLINE pLine,
             int iCol,
             HDC hDC,
             int yPos
             )
/*
   Effect:        Draw the "color" column of a legend entry. The color
                  column displays a small sample of the line drawing.

                  For charts, the sample is a line of the correct style,
                  color, and width.  Since we are using wide lines,
                  the round endcaps of the lines will breach the column.
                  Therefore we need to set the clip region. We could
                  remove this clipping if we find a way to change the
                  end cap design.

                  For alerts, the sample is a small circle which echos
                  the design in the alert log itself.
*/
{
    HBRUSH         hBrush, hBrushPrevious ;
    RECT           rect ;
    int            yMiddle ;
    int            iCircle ;

    rect.left = pLegend->aCols[iCol].xPos - LegendLeftMargin () + 2 ;
    rect.top = yPos + 1 ;
    rect.right = rect.left + pLegend->aCols[iCol].xWidth - LegendHorzMargin () ;
    rect.bottom = yPos + pLegend->yItemHeight - 1 ;

    yMiddle = rect.top + (rect.bottom - rect.top) / 2 ;
    iCircle = rect.bottom - rect.top - 2 ;

    switch (pLegend->iLineType) {
        case LineTypeChart:

            if (pLine->Visual.iWidth == 1) {
                // simple case with thin pen
                //            hBrush = SelectBrush (hDC, hbLightGray) ;
                hBrush = SelectBrush (hDC, hBrushFace) ;
                Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom) ;

                HLine (hDC, pLine->hPen,
                       rect.left + 1, rect.right - 1, yMiddle) ;
                SelectBrush (hDC, hBrush) ;
            } else {
                // thicker pen width, have to set ClipRect so
                // it will not draw otherside the rect.
                SaveDC (hDC) ;
                //            hBrush = SelectBrush (hDC, hbLightGray) ;
                hBrush = SelectBrush (hDC, hBrushFace) ;
                Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom) ;

                IntersectClipRect (hDC,
                                   rect.left + 1,
                                   rect.top + 1,
                                   rect.right - 1,
                                   rect.bottom - 1) ;
                HLine (hDC, pLine->hPen,
                       rect.left + 1, rect.right - 1, yMiddle) ;
                SelectBrush (hDC, hBrush) ;
                RestoreDC (hDC, -1) ;
            }
            break ;


        case LineTypeAlert:
            hBrushPrevious = SelectBrush (hDC, pLine->hBrush) ;

            Ellipse (hDC,
                     rect.left + 2,
                     rect.top + 2,
                     rect.left + 2 + iCircle,
                     rect.top + 2 + iCircle) ;

            SelectBrush (hDC, hBrushPrevious) ;
            break ;
    }
}


void
DrawLegendCol (
              PLEGEND pLegend,
              int iCol,
              HDC hDC,
              int yPos,
              LPTSTR lpszValue
              )
/*
   Effect:        Draw the value lpszValue for the column iCol on hDC.

   Assert:        The foreground and background text colors of hDC are
                  properly set.
*/
{
    RECT           rect ;
    int            xPos ;

    rect.left = pLegend->aCols[iCol].xPos - LegendLeftMargin () ;
    rect.top = yPos ;
    rect.right = rect.left + pLegend->aCols[iCol].xWidth - LegendHorzMargin () ;
    rect.bottom = yPos + pLegend->yItemHeight ;

    //   SetTextAlign (hDC, TA_TOP) ;
    switch (pLegend->aCols[iCol].iOrientation) {
        case LEFTORIENTATION:
            SetTextAlign (hDC, TA_LEFT) ;
            xPos = rect.left ;
            break ;

        case CENTERORIENTATION:
            SetTextAlign (hDC, TA_CENTER) ;
            xPos = (rect.left + rect.right) / 2 ;
            break ;

        case RIGHTORIENTATION:
            SetTextAlign (hDC, TA_RIGHT) ;
            xPos = rect.right ;
            break ;

        default:
            xPos = rect.left ;
            break ;
    }

    ExtTextOut (hDC,
                xPos, rect.top + LegendItemTopMargin (),
                ETO_OPAQUE | ETO_CLIPPED,
                &rect,
                lpszValue,
                lstrlen (lpszValue),
                NULL) ;
}


void
DrawLegendItem (
               PLEGEND pLegend,
               PLINESTRUCT pLine,
               int yPos,
               HDC hDC
               )
{
    TCHAR          szValue [256] ;
    TCHAR          szInstance [256] ;
    TCHAR          szParent [256] ;
    TCHAR          szNoName[4] ;

    szNoName[0] = szNoName[1] = szNoName[2] = TEXT('-') ;
    szNoName[3] = TEXT('\0') ;

    //=============================//
    // Determine Instance, Parent  //
    //=============================//

    // It's possible that there will be no instance, therefore
    // the lnInstanceName would be NULL.

    if (pLine->lnObject.NumInstances > 0) {
        // Test for the parent object instance name title index.
        // If there is one, it implies that there will be a valid
        // Parent Object Name and a valid Parent Object Instance Name.

        // If the Parent Object title index is 0 then
        // just display the instance name.

        lstrcpy (szInstance, pLine->lnInstanceName) ;
        if (pLine->lnInstanceDef.ParentObjectTitleIndex &&
            pLine->lnPINName) {
            // Get the Parent Object Name.
            lstrcpy (szParent, pLine->lnPINName) ;
        } else {
            lstrcpy (szParent, szNoName) ;
        }
    } else {
        lstrcpy (szInstance, szNoName) ;
        lstrcpy (szParent, szNoName) ;
    }

    //=============================//
    // Draw Color                  //
    //=============================//

    DrawColorCol (pLegend, pLine, LegendColorCol, hDC, yPos) ;

    //=============================//
    // Draw Scale/Value            //
    //=============================//

    if (pLegend->iLineType == LineTypeChart) {
        if (pLine->eScale < (FLOAT) 1.0) {
            TSPRINTF (szValue, TEXT("%7.7f"), pLine->eScale) ;
        } else {
            TSPRINTF (szValue, TEXT("%10.3f"), pLine->eScale) ;
        }
        ConvertDecimalPoint (szValue) ;
    } else {
        FLOAT tempAlertValue ;

        tempAlertValue = pLine->eAlertValue ;
        if (tempAlertValue < (FLOAT) 0.0) {
            tempAlertValue = -tempAlertValue ;
        }

        if (tempAlertValue >= (FLOAT) 10000.0) {
            if (tempAlertValue < (FLOAT) 1.0E+8) {
                TSPRINTF (szValue, TEXT("%c%10.0f"),
                          pLine->bAlertOver ? TEXT('>') : TEXT('<'),
                          pLine->eAlertValue) ;
            } else {
                TSPRINTF (szValue, TEXT("%c%10.3e"),
                          pLine->bAlertOver ? TEXT('>') : TEXT('<'),
                          pLine->eAlertValue) ;
            }
            ConvertDecimalPoint (szValue) ;
        } else {
            TSPRINTF (szValue, TEXT("%c%10.4f"),
                      pLine->bAlertOver ? TEXT('>') : TEXT('<'),
                      pLine->eAlertValue) ;
            ConvertDecimalPoint (szValue) ;
        }
    }

    SetTextAlign (hDC, TA_TOP) ;

    DrawLegendCol (pLegend, LegendScaleCol,
                   hDC, yPos, szValue) ;

    //=============================//
    // Draw Counter                //
    //=============================//

    DrawLegendCol (pLegend, LegendCounterCol,
                   hDC, yPos, pLine->lnCounterName) ;


    //=============================//
    // Draw Instance               //
    //=============================//

    DrawLegendCol (pLegend, LegendInstanceCol,
                   hDC, yPos, szInstance) ;

    //=============================//
    // Draw Parent                 //
    //=============================//

    DrawLegendCol (pLegend, LegendParentCol,
                   hDC, yPos, szParent) ;

    //=============================//
    // Draw Object                 //
    //=============================//

    DrawLegendCol (pLegend, LegendObjectCol,
                   hDC, yPos, pLine->lnObjectName) ;

    //=============================//
    // Draw System                 //
    //=============================//

    DrawLegendCol (pLegend, LegendSystemCol,
                   hDC, yPos, pLine->lnSystemName) ;
}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


BOOL
OnLegendCreate (
               HWND hWnd,
               LPCREATESTRUCT lpCS
               )
{
    PLEGEND        pLegend ;
    HDC            hDC ;
    int            iCol ;
    BOOL           bChartLegend ;

    bChartLegend = (lpCS->lpCreateParams) == (LPVOID) TRUE ;

    pLegend = AllocateLegendData (hWnd, bChartLegend) ;

    if (!pLegend)
        return (FALSE) ;

    if (bChartLegend) {
        pLegend->iLineType = LineTypeChart ;
    } else {
        pLegend->iLineType = LineTypeAlert ;
    }

    pLegend->hFontItems = hFontScales ;
    pLegend->hFontLabels = hFontScalesBold ;
    hDC = GetDC (hWnd) ;
    if (!hDC)
        return (FALSE);

    //=============================//
    // Load Labels                 //
    //=============================//

    StringLoad (IDS_LABELCOLOR, pLegend->aCols[LegendColorCol].szLabel) ;
    if (pLegend->iLineType == LineTypeChart)
        StringLoad (IDS_LABELSCALE,
                    pLegend->aCols[LegendScaleCol].szLabel) ;
    else
        StringLoad (IDS_LABELVALUE,
                    pLegend->aCols[LegendScaleCol].szLabel) ;
    StringLoad (IDS_LABELCOUNTER, pLegend->aCols[LegendCounterCol].szLabel) ;
    StringLoad (IDS_LABELINSTANCE, pLegend->aCols[LegendInstanceCol].szLabel) ;
    StringLoad (IDS_LABELPARENT, pLegend->aCols[LegendParentCol].szLabel) ;
    StringLoad (IDS_LABELOBJECT, pLegend->aCols[LegendObjectCol].szLabel) ;
    StringLoad (IDS_LABELSYSTEM, pLegend->aCols[LegendSystemCol].szLabel) ;


    //=============================//
    // Label dimensions            //
    //=============================//

    SelectFont (hDC, pLegend->hFontLabels) ;
    pLegend->yLabelHeight = FontHeight (hDC, TRUE) + 2 * LabelTopMargin () ;

    //=============================//
    // Column dimensions           //
    //=============================//

    for (iCol = 0; iCol < iLegendNumCols; iCol++) {
        pLegend->aCols[iCol].iOrientation = LEFTORIENTATION ;
        pLegend->aCols[iCol].xMinWidth =
        TextWidth (hDC, pLegend->aCols[iCol].szLabel) + LegendHorzMargin () ;
    }

    SelectFont (hDC, pLegend->hFontItems) ;
    pLegend->yItemHeight = FontHeight (hDC, TRUE) + 2 * LegendItemTopMargin () ;

    pLegend->aCols[LegendColorCol].xMaxWidth = max (3 * xScrollWidth,
                                                    pLegend->aCols[LegendColorCol].xMinWidth) ;

    pLegend->aCols[LegendScaleCol].xMaxWidth = TextWidth (hDC, eScaleValueSpace) ;
    pLegend->aCols[LegendCounterCol].xMaxWidth = iLegendColMax ;
    pLegend->aCols[LegendInstanceCol].xMaxWidth = iLegendColMax ;
    pLegend->aCols[LegendParentCol].xMaxWidth = iLegendColMax ;
    pLegend->aCols[LegendObjectCol].xMaxWidth = iLegendColMax ;
    pLegend->aCols[LegendSystemCol].xMaxWidth = iLegendColMax ;

    pLegend->aCols[LegendColorCol].iOrientation = LEFTORIENTATION ;
    pLegend->aCols[LegendScaleCol].iOrientation = RIGHTORIENTATION ;

    ReleaseDC (hWnd, hDC) ;

    //=============================//
    // Create Legend Items Listbox //
    //=============================//

    pLegend->hWndItems =
    CreateWindow (TEXT("ListBox"),               // window class
                  NULL,                          // window caption
                  dwGraphLegendItemsWindowStyle, // window style
                  0, 0, 0, 0,                    // window size and pos
                  hWnd,                          // parent window
                  NULL,                          // menu
                  hInstance,                     // program instance
                  (LPVOID) TRUE) ;               // user-supplied data

    return TRUE;
}


void
static
OnSize (
       HWND hWnd,
       int xWidth,
       int yHeight
       )
/*
   Effect:        Perform all actions necessary when the legend window is
                  being resized. In particular, set the width and starting
                  position for each column of the legend list and labels.

   Internals:     What we do is determine the amount of space in the
                  width that is greater than the minimum, and allocate
                  that space among each of the columns that is willing to
                  be larger than minimum. If there is not enough room for
                  the minimum, don't bother with calculations.
*/

{
    PLEGEND        pLegend ;
    PLEGENDCOL     pCol ;
    int            xMin ;
    int            xSlack ;
    int            iColsToGrow ;
    int            iCol ;

    pLegend = LegendData (hWnd) ;

    //=============================//
    // Resize Legend Items         //
    //=============================//

    if (IsLegendLabelVisible ())
        MoveWindow (pLegend->hWndItems,
                    LegendLeftMargin (), pLegend->yLabelHeight + ThreeDPad,
                    xWidth - 2 * LegendLeftMargin (),
                    yHeight - pLegend->yLabelHeight - yLegendBorderHeight,
                    TRUE) ;
    else
        MoveWindow (pLegend->hWndItems,
                    0, 0,
                    xWidth, yHeight,
                    TRUE) ;

    //=============================//
    // Allocate width to Columns   //
    //=============================//

    xMin = LegendMinWidth (hWnd) ;
    xSlack = max (xWidth - xMin, 0) ;
    iColsToGrow = 0 ;

    for (iCol = 0; iCol < iLegendNumCols; iCol++) {
        pCol = &(pLegend->aCols[iCol]) ;

        pCol->xWidth = pCol->xMinWidth ;
        if (ColCanGrow (pCol))
            iColsToGrow++ ;
    }

    for (iCol = 0; iCol < iLegendNumCols; iCol++) {
        pCol = &(pLegend->aCols[iCol]) ;

        if (ColCanGrow (pCol)) {
            if ((pCol->xWidth + xSlack / iColsToGrow) > pCol->xMaxWidth) {
                pCol->xWidth = pCol->xMaxWidth ;
                xSlack -= (pCol->xMaxWidth - pCol->xMinWidth) ;
                iColsToGrow-- ;
            }
        }
    }

    for (iCol = 0; iCol < iLegendNumCols; iCol++) {
        pCol = &(pLegend->aCols[iCol]) ;

        if (ColCanGrow (pCol))
            pCol->xWidth += xSlack / iColsToGrow ;
    }

    if (pLegend->aCols[LegendCounterCol].xWidth <
        pLegend->aCols[LegendCounterCol].xMaxWidth) {
        // cut some from the other columns and give them to CounterCol
        if (pLegend->aCols[LegendColorCol].xWidth - xScrollWidth >=
            pLegend->aCols[LegendColorCol].xMinWidth) {
            pLegend->aCols[LegendColorCol].xWidth -= xScrollWidth ;
            pLegend->aCols[LegendCounterCol].xWidth += xScrollWidth ;
        }
        if (pLegend->aCols[LegendInstanceCol].xWidth - xScrollWidth >=
            pLegend->aCols[LegendInstanceCol].xMinWidth) {
            pLegend->aCols[LegendInstanceCol].xWidth -= xScrollWidth ;
            pLegend->aCols[LegendCounterCol].xWidth += xScrollWidth ;
        }
        if (pLegend->aCols[LegendParentCol].xWidth - xScrollWidth >=
            pLegend->aCols[LegendParentCol].xMinWidth) {
            pLegend->aCols[LegendParentCol].xWidth -= xScrollWidth ;
            pLegend->aCols[LegendCounterCol].xWidth += xScrollWidth ;
        }
    }

    //=============================//
    // Set Column positions        //
    //=============================//

    pLegend->aCols[0].xPos = LegendLeftMargin () ;
    for (iCol = 1; iCol < iLegendNumCols; iCol++) {
        pLegend->aCols[iCol].xPos =
        pLegend->aCols[iCol - 1].xPos + pLegend->aCols[iCol - 1].xWidth ;

        if (iCol == LegendCounterCol) {
            // add some space between Scale/Value col & Counter col
            pLegend->aCols[LegendCounterCol].xPos += LegendLeftMargin () ;
        }
    }
}


void
static
OnPaint (
        HWND hWnd
        )
{
    PLEGEND        pLegend ;
    HDC            hDC ;
    PAINTSTRUCT    ps ;

    hDC = BeginPaint (hWnd, &ps) ;

    if (IsLegendLabelVisible ()) {
        pLegend = LegendData (hWnd) ;
        DrawLegendLabel (pLegend, hDC, hWnd) ;
    }

    if (LBNumItems (pLegend->hWndItems) == 0) {
        WindowInvalidate(pLegend->hWndItems) ;
    }

    EndPaint (hWnd, &ps) ;
}


void
OnDrawLegendItem (
                 HWND hWnd,
                 LPDRAWITEMSTRUCT lpDI
                 )
{
    HFONT          hFontPrevious ;
    HDC            hDC ;
    PLEGEND        pLegend ;
    PLINESTRUCT    pLine ;
    int            iLBIndex ;
    COLORREF       preBkColor = 0;
    COLORREF       preTextColor = 0;
    BOOL           ResetColor = FALSE ;


    hDC = lpDI->hDC ;
    iLBIndex = DIIndex (lpDI) ;

    pLegend = LegendData (hWnd) ;

    if (iLBIndex == -1)
        pLine = NULL ;
    else
        pLine = (PLINESTRUCT) LBData (pLegend->hWndItems, iLBIndex) ;

    //=============================//
    // Set DC attributes           //
    //=============================//


    if (DISelected (lpDI) || pLine == NULL) {
        preTextColor = SetTextColor (hDC, GetSysColor (COLOR_HIGHLIGHTTEXT)) ;
        preBkColor = SetBkColor (hDC, GetSysColor (COLOR_HIGHLIGHT)) ;
        ResetColor = TRUE ;
    }
    ExtTextOut (hDC, lpDI->rcItem.left, lpDI->rcItem.top,
                ETO_OPAQUE, &(lpDI->rcItem), NULL, 0, NULL ) ;

    //=============================//
    // Draw Legend Item            //
    //=============================//

    hFontPrevious = SelectFont (hDC, pLegend->hFontItems) ;
    if (pLine)
        DrawLegendItem (pLegend, pLine, lpDI->rcItem.top, hDC) ;
    SelectFont (hDC, hFontPrevious) ;

    //=============================//
    // Draw Focus                  //
    //=============================//

    if (DIFocus (lpDI))
        DrawFocusRect (hDC, &(lpDI->rcItem)) ;

    if (ResetColor == TRUE) {
        preTextColor = SetTextColor (hDC, preTextColor) ;
        preBkColor = SetBkColor (hDC, preBkColor) ;
    }
}

void
static
OnMeasureItem (
              HWND hWnd,
              LPMEASUREITEMSTRUCT lpMI
              )
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWnd) ;
    lpMI->itemHeight = pLegend->yItemHeight ;
}


void
static
OnDestroy (
          HWND hWnd
          )
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWnd) ;
    MemoryFree (pLegend) ;
}


void
static
OnDoubleClick (
              HWND hWnd
              )
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWnd) ;
    if (!pLegend)
        return ;

    switch (pLegend->iLineType) {
        case LineTypeChart:
            EditChart (hWndMain) ;
            break ;

        case LineTypeAlert:
            EditAlert (hWndAlert) ;
            break ;
    }
}


void
static
OnSetFocus (
           HWND hWnd
           )
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWnd) ;

    SetFocus (pLegend->hWndItems) ;
}


void
static
OnSelectionChanged (
                   HWND hWnd
                   )
{
    PLEGEND        pLegend ;
    PGRAPHSTRUCT         pGraph ;
    int            iIndex ;


    pLegend = LegendData (hWnd) ;

    // set the new selected line
    iIndex = (int)LBSelection (pLegend->hWndItems) ;

    if (iIndex == LB_ERR)
        return ;

    LegendSetCurrentLine (pLegend, iIndex) ;

    if (pLegend->iLineType == LineTypeChart) {
        pGraph = GraphData (hWndGraph) ;

        if (!PlayingBackLog()) {
            // update the min, max, & avg of the current line
            UpdateValueBarData (pGraph) ;
        }

        // update the valuebar display
        StatusTimer (hWndGraphStatus, TRUE) ;

        // change the Current highlighted line if necessary
        if (pGraph && pGraph->HighLightOnOff) {
            WindowInvalidate (hWndGraphDisplay) ;
        }
    }
}


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//
LRESULT
APIENTRY
GraphLegendWndProc (
                   HWND hWnd,
                   UINT wMsg,
                   WPARAM wParam,
                   LPARAM lParam
                   )
{
    BOOL           bCallDefProc ;
    LRESULT        lReturnValue ;

    bCallDefProc = FALSE ;
    lReturnValue = 0L ;

    switch (wMsg) {
        case WM_DELETEITEM:
            break ;

        case WM_COMMAND:
            switch (HIWORD (wParam)) {  // switch
                case LBN_DBLCLK:
                    OnDoubleClick (hWnd) ;
                    break ;

                case LBN_SELCHANGE:
                    OnSelectionChanged (hWnd) ;
                    break ;

                default:
                    break ;
            }  // switch
            break ;

        case WM_CREATE:
            OnLegendCreate (hWnd, (LPCREATESTRUCT) lParam) ;
            break ;

        case WM_DESTROY:
            OnDestroy (hWnd) ;
            break ;

        case WM_DRAWITEM:
            OnDrawLegendItem (hWnd, (LPDRAWITEMSTRUCT) lParam) ;
            break ;

        case WM_MEASUREITEM:
            OnMeasureItem (hWnd, (LPMEASUREITEMSTRUCT) lParam) ;
            break ;

        case WM_PAINT:
            OnPaint (hWnd) ;
            break ;

        case WM_SIZE:
            OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ;
            break ;

        case WM_SETFOCUS:
            OnSetFocus (hWnd) ;
            break ;

        default:
            bCallDefProc = TRUE ;
    }

    if (bCallDefProc)
        lReturnValue = DefWindowProc (hWnd, wMsg, wParam, lParam) ;

    return (lReturnValue);
}


int
LegendMinWidth (
               HWND hWnd
               )
{
    PLEGEND        pLegend ;
    int            iCol ;
    int            xMinWidth ;

    pLegend = LegendData (hWnd) ;
    xMinWidth = 0 ;

    for (iCol = 0; iCol < iLegendNumCols; iCol++) {
        xMinWidth += pLegend->aCols[iCol].xMinWidth ;
    }

    return (xMinWidth) ;
}


int
LegendMinHeight (
                HWND hWnd
                )
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWnd) ;

    if (IsLegendLabelVisible ())
        return (pLegend->yLabelHeight + pLegend->yItemHeight) ;
    else
        return (pLegend->yItemHeight) ;
}


int
LegendHeight (
             HWND hWnd,
             int yGraphHeight
             )
/*
   Effect:        Return the best height for the Legend window given the
                  number of items and label visibility of the legend, as
                  well as the overall height of the graph.
*/
{
    PLEGEND        pLegend ;
    int            yPreferredHeight ;

    pLegend = LegendData (hWnd) ;

    yPreferredHeight = yLegendBorderHeight +
                       pLegend->yItemHeight *
                       PinInclusive (LBNumItems (pLegend->hWndItems),
                                     1, iLegendMaxVisibleItems) ;
    if (IsLegendLabelVisible ())
        yPreferredHeight += pLegend->yLabelHeight ;

    return (min (yPreferredHeight, yGraphHeight / 2)) ;
}


int
LegendFullHeight (
                 HWND hWnd,
                 HDC hDC
                 )
/*
   Effect:        Return the best height for the Legend window given the
                  number of items and label visibility of the legend, as
                  well as the overall height of the graph.
*/
{
    PLEGEND        pLegend ;
    int            yPreferredHeight ;

    pLegend = LegendData (hWnd) ;

    yPreferredHeight = yLegendBorderHeight +
                       pLegend->yItemHeight *
                       LBNumItems (pLegend->hWndItems) ;
    if (IsLegendLabelVisible ())
        yPreferredHeight += pLegend->yLabelHeight ;

    return (yPreferredHeight) ;
}


HWND
CreateGraphLegendWindow (
                        HWND hWndGraph
                        )
{
    return (CreateWindow (szGraphLegendClass,       // class
                          NULL,                     // caption
                          dwGraphLegendWindowStyle, // window style
                          0, 0,                     // position
                          0, 0,                     // size
                          hWndGraph,                // parent window
                          NULL,                     // menu
                          hInstance,                // program instance
                          (LPVOID) TRUE)) ;         // user-supplied data
}


BOOL
GraphLegendInitializeApplication (void)
/*
   Called By:     GraphInitializeApplication only
*/
{
    WNDCLASS       wc ;

    wc.style          = dwGraphLegendClassStyle ;
    wc.lpfnWndProc    = GraphLegendWndProc ;
    wc.hInstance      = hInstance ;
    wc.cbClsExtra     = iGraphLegendClassExtra ;
    wc.cbWndExtra     = iGraphLegendWindowExtra ;
    wc.hIcon          = NULL ;
    wc.hCursor        = LoadCursor (NULL, IDC_ARROW) ;
    //   wc.hbrBackground  = hbLightGray ;
    wc.hbrBackground  = hBrushFace ;
    wc.lpszMenuName   = NULL ;
    wc.lpszClassName  = szGraphLegendClass ;

    return (RegisterClass (&wc)) ;
}


BOOL
LegendAddItem (
              HWND hWnd,
              PLINESTRUCT pLine
              )
/*
   Effect:        Add a legend entry for the line pLine. Don't select
                  the line as current entry here, because this will cause
                  the scroll bar to unneccesarily appear for a moment.
                  If you want this line to be the current line, resize
                  the legend first, then set as current line.

   See Also:      ChartInsertLine, AlertInsertLine.
*/
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWnd) ;
    LBAdd (pLegend->hWndItems, pLine) ;

    return (TRUE) ;
}


void
LegendDeleteItem (
                 HWND hWndLegend,
                 PLINE pLine
                 )
{
    PLEGEND        pLegend ;
    int            iIndex ;
    int            iNextIndex ;
    int            iNumItems ;
    PGRAPHSTRUCT   pGraph ;

    pLegend = LegendData (hWndLegend) ;
    if (!pLegend)
        return ;

    iNumItems = LBNumItems (pLegend->hWndItems) ;

    iIndex = (int)LBFind (pLegend->hWndItems, pLine) ;

    if (iIndex != LB_ERR) {
        LBDelete (pLegend->hWndItems, iIndex) ;
    }

    // no need to do anything if iNumItems is 1 to begin with
    if (iNumItems != LB_ERR && iNumItems > 1) {
        if (iIndex == iNumItems - 1) {
            // deleting the last line, then set selection
            // to the previous legend line
            iNextIndex = iIndex - 1 ;
        } else {
            // set the selection to the next legend line
            iNextIndex = iIndex ;
        }

        LBSetSelection (pLegend->hWndItems, iNextIndex) ;
        LegendSetCurrentLine (pLegend, iNextIndex) ;

        if (pLegend->iLineType == LineTypeChart) {
            // update the min, max, & avg of the current line
            pGraph = GraphData (hWndGraph) ;

            if (!PlayingBackLog()) {
                // update the min, max, & avg of the current line
                UpdateValueBarData (pGraph) ;
            }

            // update the valuebar display
            StatusTimer (hWndGraphStatus, TRUE) ;
        }
    }
}


PLINE
LegendCurrentLine (
                  HWND hWndLegend
                  )
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWndLegend) ;

    if (!pLegend)
        return (NULL) ;

    return (pLegend->pCurrentLine) ;
}


int
LegendNumItems (
               HWND hWndLegend
               )
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWndLegend) ;

    return (LBNumItems (pLegend->hWndItems)) ;
}


void
LegendSetSelection (
                   HWND hWndLegend,
                   int iIndex
                   )
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWndLegend) ;
    LBSetSelection (pLegend->hWndItems, iIndex) ;
    LegendSetCurrentLine (pLegend, iIndex) ;
}


#ifdef KEEP_PRINT

void
PrintLegend (
            HDC hDC,
            PGRAPHSTRUCT pGraph,
            HWND hWndLegend,
            RECT rectLegend
            )
{
    PLEGEND        pLegend ;
    int            yItemHeight ;
    HFONT          hFontItems ;
    PLINE          pLine ;
    int            iIndex ;
    int            iIndexNum ;


    pLegend = LegendData (hWndLegend) ;

    yItemHeight = pLegend->yItemHeight ;
    hFontItems = pLegend->hFontItems ;

    pLegend->hFontItems = hFontPrinterScales ;
    SelectFont (hDC, pLegend->hFontItems) ;

    pLegend->yItemHeight = FontHeight (hDC, TRUE) ;

    iIndexNum = LBNumItems (pLegend->hWndItems) ;
    for (iIndex = 0; iIndex < iIndexNum; iIndex++) {
        pLine = (PLINE) LBData (pLegend->hWndItems, iIndex) ;
        DrawLegendItem (pLegend, pLine, iIndex * pLegend->yItemHeight, hDC) ;
    }

    pLegend->hFontItems = hFontItems ;
    pLegend->yItemHeight = yItemHeight ;


    SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ;
    SelectPen (hDC, GetStockObject (BLACK_PEN)) ;
    Rectangle (hDC, 0, 0,
               rectLegend.right - rectLegend.left,
               rectLegend.bottom - rectLegend.top) ;
}
#endif


void
ClearLegend (
            HWND hWndLegend
            )
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWndLegend) ;
    if (!pLegend)
        return ;

    LBReset (pLegend->hWndItems) ;
    pLegend->pCurrentLine = NULL ;
}

void
LegendSetRedraw (
                HWND hWndLegend,
                BOOL bRedraw
                )
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWndLegend) ;
    if (!pLegend)
        return ;

    LBSetRedraw (pLegend->hWndItems, bRedraw) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\line.h ===
VOID FreeLines (PLINESTRUCT pLineFirst) ;


PLINE LineAllocate (void) ;


void LineFree (PLINE pLine) ;



void LineAppend (PPLINE ppLineFirst, 
                 PLINE pLineNew) ;



BOOL LineRemove (PPLINE ppLineFirst,
                 PLINE pLineRemove) ;


int NumLines (PLINE pLineFirst) ;


LPTSTR LineInstanceName (PLINE pLine) ;


LPTSTR LineParentName (PLINE pLine) ;


void LineCounterAppend (PCOUNTERGROUP pCGroup,
                        PLINE pLineNew) ;


BOOL EquivalentLine (PLINE pLine1,
                     PLINE pLine2) ;


PLINE FindEquivalentLine (PLINE pLineToFind,
                          PLINE pLineFirst) ;


BOOL WriteLine (PLINE pLine,
                HANDLE hFile) ;




void ReadLines (HANDLE hFile,
                DWORD dwNumLines,
                PPPERFSYSTEM ppSystemFirst,
                PPLINE ppLineFirst,
                int LineType) ;


HPEN LineCreatePen (HDC hDC,
                    PLINEVISUAL pVisual,
                    BOOL bForPrint) ;

PPERFOBJECT LineFindObject (PPERFSYSTEM pSystem,
                            PPERFDATA pPerfData,
                            PLINE pLine) ;

PPERFCOUNTERDEF LineFindCounter (PPERFSYSTEM pSystem,
                                 PPERFOBJECT pObject,
                                 PPERFDATA pPerfData,
                                 PLINE pLine) ;

PPERFINSTANCEDEF LineFindInstance (PPERFDATA pPerfData,
                                   PPERFOBJECT pObject,
                                   PLINE pLine) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\line.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "perfmon.h"    // included by all source files
#include "line.h"       // external declarations for this file
//#include <tchar.h>      // for _tcsncpy

#include "fileutil.h"   // for FileRead, FileWrite
#include "pmemory.h"     // for MemoryXXX (mallloc-type) routines
#include "perfdata.h"   // for UpdateSystemData, et al
#include "perfmops.h"   // for InsertLine
#include "system.h"     // for SystemAdd
#include "utils.h"
#include "playback.h"   // for PlayingBackLog
#include "counters.h"   // CounterEntry

#include <string.h>     // for strncpy
#ifdef UNICODE
#define _tcsncpy	wcsncpy
#else
#define _tcsncpy	strncpy
#endif

TCHAR LOCAL_SYS_CODE_NAME[] = TEXT("....") ;
#define  sizeofCodeName sizeof(LOCAL_SYS_CODE_NAME) / sizeof(TCHAR) - 1

// Local Function prototype
PLINE ReadLine (PPERFSYSTEM *ppSystem,
                PPPERFSYSTEM ppSystemFirst,
                PPERFDATA *ppPerfData,
                HANDLE hFile,
                int LineType,
                PDISKLINE  *ppDiskLine,
                DWORD *pSizeofDiskLine) ;



//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


PLINE
LineAllocate (void)
/*
   Effect:        Allocate and initialize a Line data structure. Lines
                  are used as the primary elements of both charts and
                  alerts.

                  Establish any representation invariants for the Line
                  type.

                  Also alllocate another structure, an array of data
                  elements, iNumDataValues long.
*/
{
    PLINE          pLine ;

    pLine = MemoryAllocate (sizeof (LINESTRUCT)) ;

    if (pLine) {
        //  don't need to zero these again since MemoryAllocate is using
        //  GMEM_ZEROPOINT
        //      pLine->pLineNext = NULL ;
        //      pLine->pLineCounterNext = NULL ;

        // do want to do this since (FLOAT)0.0 is not 0
        pLine->lnMinValue =
        pLine->lnMaxValue =
        pLine->lnAveValue = (FLOAT) 0.0 ;

        if (PlayingBackLog()) {
            pLine->bFirstTime = FALSE ;
        } else {
            //         pLine->bFirstTime = TRUE ;
            // we want to take 2 samples before plotting the first data
            pLine->bFirstTime = 2 ;
        }
    }

    return (pLine) ;
}


void
LineFree (
         PLINE pLine
         )
{
   // free any memory allocated by this line
    if (pLine->lnSystemName)
        MemoryFree (pLine->lnSystemName) ;

    if (pLine->lnObjectName)
        MemoryFree (pLine->lnObjectName) ;

    if (pLine->lnCounterName)
        MemoryFree (pLine->lnCounterName) ;

    if (pLine->lnInstanceName)
        MemoryFree (pLine->lnInstanceName) ;

    if (pLine->lnParentObjName)
        MemoryFree (pLine->lnParentObjName) ;

    if (pLine->lnPINName)
        MemoryFree (pLine->lnPINName) ;

    if (pLine->lpszAlertProgram)
        MemoryFree (pLine->lpszAlertProgram) ;

    if (pLine->hPen)
        DeletePen(pLine->hPen);

    if (pLine->hBrush)
        DeletePen(pLine->hBrush);

    if (pLine->lnValues)
        MemoryFree (pLine->lnValues) ;

    if (pLine->aiLogIndexes)
        MemoryFree (pLine->aiLogIndexes) ;

    MemoryFree (pLine) ;
}


void
LineAppend (
           PPLINE ppLineFirst,
           PLINE pLineNew
           )
{
    PLINE          pLine ;

    if (!*ppLineFirst) {
        *ppLineFirst = pLineNew ;
    } else {
        for (pLine = *ppLineFirst ;
            pLine->pLineNext ;
            pLine = pLine->pLineNext)
            /* nothing */ ;
        pLine->pLineNext = pLineNew ;
    }
}



BOOL
LineRemove (
           PPLINE ppLineFirst,
           PLINE pLineRemove
           )
{
    PLINE          pLine ;

    if (*ppLineFirst == pLineRemove) {
        *ppLineFirst = (*ppLineFirst)->pLineNext ;
        return (TRUE) ;
    }

    for (pLine = *ppLineFirst; pLine->pLineNext; pLine = pLine->pLineNext) {
        if (pLine->pLineNext == pLineRemove) {
            pLine->pLineNext = pLineRemove->pLineNext ;
            return (TRUE) ;
        }
    }

    return (FALSE) ;
}



int
NumLines (
         PLINE pLineFirst
         )
{
    PLINE          pLine ;
    int            iNumLines ;

    if (!pLineFirst)
        return (0) ;

    iNumLines = 0 ;
    for (pLine = pLineFirst; pLine; pLine = pLine->pLineNext) {
        iNumLines++ ;
    }

    return (iNumLines) ;
}


LPTSTR
LineInstanceName (
                 PLINE pLine
                 )
{
    if (pLine->lnObject.NumInstances <= 0)
        return (NULL) ;
    else
        return (pLine->lnInstanceName) ;
}


LPTSTR
LineParentName (
               PLINE pLine
               )
{
    if (pLine->lnObject.NumInstances <= 0)
        return (NULL) ;
    else if (pLine->lnInstanceDef.ParentObjectTitleIndex)
        return (pLine->lnPINName) ;
    else
        return (NULL) ;
}


void
LineCounterAppend (
                  PCOUNTERGROUP pCGroup,
                  PLINE pLineNew
                  )
{
    if (!pCGroup->pLineFirst) {
        pCGroup->pLineFirst = pLineNew ;
        pCGroup->pLineLast = pLineNew;
    } else {
        pCGroup->pLineLast->pLineCounterNext = pLineNew;
        pCGroup->pLineLast = pLineNew;
    }
}


BOOL
EquivalentLine (
               PLINE pLine1,
               PLINE pLine2
               )
{
    return (pstrsame (pLine1->lnCounterName, pLine2->lnCounterName) &&
            pstrsame (pLine1->lnInstanceName, pLine2->lnInstanceName) &&
            pstrsame (pLine1->lnPINName, pLine2->lnPINName) &&
            pstrsame (pLine1->lnObjectName, pLine2->lnObjectName) &&
            pstrsamei (pLine1->lnSystemName, pLine2->lnSystemName)) ;
}


PLINE
FindEquivalentLine (
                   PLINE pLineToFind,
                   PLINE pLineFirst
                   )
{
    PLINE          pLine = NULL;
    PLINE          pLastEquivLine = NULL;

    for (pLine = pLineFirst ;
        pLine ;
        pLine = pLine->pLineNext) {

        if (EquivalentLine (pLine, pLineToFind)) {
            if (pLastEquivLine == NULL) {
                pLastEquivLine = pLine;
            } else {
                if (pLine->dwInstanceIndex > pLastEquivLine->dwInstanceIndex) {
                    pLastEquivLine = pLine;
                }
            }
        }
    }

    return (pLastEquivLine) ;
}

// This routine is used only to read the system name from a disk string
// It is mainly for performance improvement.
LPTSTR
DiskStringReadSys (
                  PDISKSTRING pDS
                  )
{
    LPTSTR         lpszText ;
    LPTSTR         pDiskSysName ;
    int            iIndex ;
    BOOL           bLocalSysName = FALSE ;

    if (pDS->dwLength == 0) {
        return (NULL) ;
    }

    if (pDS->dwLength == sizeofCodeName) {
        // check for LOCAL_SYS_CODE_NAME
        bLocalSysName = TRUE ;
        pDiskSysName = (LPTSTR)((PBYTE) pDS + pDS->dwOffset) ;
        for (iIndex = 0 ; iIndex < sizeofCodeName; iIndex++, pDiskSysName++) {
            if (*pDiskSysName != LOCAL_SYS_CODE_NAME[iIndex]) {
                bLocalSysName = FALSE ;
                break ;
            }
        }
    }

    if (bLocalSysName) {
        lpszText =
        MemoryAllocate ((lstrlen(LocalComputerName)+1) * sizeof(TCHAR)) ;
        if (lpszText) {
            lstrcpy (lpszText, LocalComputerName) ;
        }
    } else {
        lpszText = MemoryAllocate (sizeof (TCHAR) * (pDS->dwLength + 1)) ;
        if (lpszText) {
            _tcsncpy ((WCHAR *)lpszText, (WCHAR *)((PBYTE) pDS + pDS->dwOffset),
                      pDS->dwLength) ;
        }
    }

    return (lpszText) ;
}


LPTSTR
DiskStringRead (
               PDISKSTRING pDS
               )
{
    LPTSTR         lpszText ;

    if (pDS->dwLength == 0) {
        return (NULL) ;
    }

    lpszText = MemoryAllocate (sizeof (TCHAR) * (pDS->dwLength + 1)) ;
    if (!lpszText) {
        return (NULL) ;
    }

    _tcsncpy ((WCHAR *)lpszText, (WCHAR *)((PBYTE) pDS + pDS->dwOffset),
              pDS->dwLength) ;

    return (lpszText) ;
}


int
DiskStringLength (
                 LPTSTR lpszText
                 )
{
    if (!lpszText)
        return (0) ;
    else
        return (lstrlen (lpszText)) ;
}

PBYTE
DiskStringCopy (
               PDISKSTRING pDS,
               LPTSTR lpszText,
               PBYTE pNextFree
               )
{
    if (!lpszText) {
        pDS->dwOffset = 0 ;
        pDS->dwLength = 0 ;
        return (pNextFree) ;
    } else {
        pDS->dwOffset = (DWORD)(pNextFree - (PBYTE) pDS) ;
        pDS->dwLength = DiskStringLength (lpszText) ;
        _tcsncpy ((WCHAR *)pNextFree, (WCHAR *)lpszText, pDS->dwLength) ;
        return (pNextFree + pDS->dwLength * sizeof(TCHAR)) ;
    }
}


void
CounterName (
            PPERFSYSTEM pSystem,
            PPERFCOUNTERDEF pCounter,
            LPTSTR lpszCounter
            )
{
    //!!   strclr (lpszCounter) ;
    lpszCounter [0] = TEXT('\0') ;
    QueryPerformanceName (pSystem,
                          pCounter->CounterNameTitleIndex,
                          0, 256,
                          lpszCounter,
                          FALSE) ;
}


PPERFOBJECT
LineFindObject (
               PPERFSYSTEM pSystem,
               PPERFDATA pPerfData,
               PLINE pLine
               )
/*
   Effect:        Set the lnObject field of pLine to the object with the
                  name of lnObjectName, and return TRUE. Return FALSE if
                  there is no such object.
*/
{
    PPERFOBJECT    pObject ;

    pObject = GetObjectDefByName (pSystem, pPerfData, pLine->lnObjectName) ;

    if (pObject) {
        pLine->lnObject = *pObject ;
        return (pObject) ;
    } else
        return (NULL) ;
}


PPERFCOUNTERDEF
LineFindCounter (
                PPERFSYSTEM pSystem,
                PPERFOBJECT pObject,
                PPERFDATA pPerfData,
                PLINE pLine
                )
{
    UINT               i ;
    PPERFCOUNTERDEF   pCounter ;
    TCHAR             szCounter [256] ;

    for (i = 0, pCounter = FirstCounter (pObject) ;
        i < pObject->NumCounters ;
        i++, pCounter = NextCounter (pCounter))
    {
        CounterName (pSystem, pCounter, szCounter) ;
        if (strsame (szCounter, pLine->lnCounterName)) {
            pLine->lnCounterDef = *pCounter ;
            return (pCounter) ;
        }
    }

    return (NULL) ;
}


PPERFINSTANCEDEF
LineFindInstance (
                 PPERFDATA pPerfData,
                 PPERFOBJECT pObject,
                 PLINE pLine
                 )
{

    PPERFINSTANCEDEF  pInstance = NULL ;

    if ((pObject->NumInstances > 0) && pLine->lnInstanceName) {
        // instances exist, find the right one

        if (pLine->lnUniqueID != PERF_NO_UNIQUE_ID) {
            pInstance = GetInstanceByUniqueID(pObject, pLine->lnUniqueID,
                                              pLine->dwInstanceIndex) ;
        } else {
            pInstance = GetInstanceByName(pPerfData, pObject,
                                          pLine->lnInstanceName, pLine->lnPINName,
                                          pLine->dwInstanceIndex) ;
        }
    }

    if (pInstance) {
        pLine->lnInstanceDef = *pInstance ;
    }

    return (pInstance) ;
}


void
ReadLines (
          HANDLE hFile,
          DWORD dwNumLines,
          PPPERFSYSTEM ppSystemFirst,
          PPLINE ppLineFirst,
          int LineType
          )
{
    DWORD          i ;
    PPERFDATA      pPerfData ;
    PLINE          pLine ;
    PPERFSYSTEM    pSystem ;
    PDISKLINE      pDiskLine = NULL ;
    DWORD          SizeofDiskLine = 0 ;  // bytes in pDiskLine


    pPerfData = AllocatePerfData () ;
    pSystem = *ppSystemFirst ;

    pDiskLine = MemoryAllocate (FilePathLen) ;
    if (!pDiskLine) {
        // no memory to begin with, forget it
        DlgErrorBox (hWndMain, ERR_NO_MEMORY) ;
        return ;
    }
    SizeofDiskLine = FilePathLen ;

    for (i = 0 ;
        i < dwNumLines ;
        i++) {
        pLine = ReadLine (&pSystem, ppSystemFirst, &pPerfData, hFile,
                          LineType, &pDiskLine, &SizeofDiskLine) ;
        if (pLine) {
            if (InsertLine (pLine) == FALSE) {
                // no inert occurred due to either line already existed
                // or error detected.
                LineFree (pLine) ;
            }
        }
    }

    if (pDiskLine) {
        MemoryFree (pDiskLine);
    }

    BuildValueListForSystems (*ppSystemFirst, *ppLineFirst) ;


    MemoryFree ((LPMEMORY)pPerfData) ;
}


PLINE
ReadLine (
         PPERFSYSTEM *ppSystem,
         PPPERFSYSTEM ppSystemFirst,
         PPERFDATA *ppPerfData,
         HANDLE hFile,
         int LineType,
         PDISKLINE  *ppDiskLine,
         DWORD *pSizeofDiskLine
         )
/*
   Effect:        Read in a line from the file hFile, at the current file
                  position.

   Internals:     The very first characters are a line signature, then a
                  length integer. If the signature is correct, then allocate
                  the length amount, and work with that.
*/
{
    PLINE             pLine ;

    struct {
        DWORD             dwSignature ;
        DWORD             dwLength ;
    } LineHeader ;

    PPERFOBJECT       pObject ;
    PPERFCOUNTERDEF   pCounter ;
    PDISKLINE         pDiskLine ;    // Local copy of the pointer
    PPERFINSTANCEDEF  pInstance ;

    pLine = NULL ;

    //=============================//
    // read and compare signature  //
    //=============================//

    if (!FileRead (hFile, &LineHeader, sizeof (LineHeader)))
        return (NULL) ;


    if (LineHeader.dwSignature != dwLineSignature ||
        LineHeader.dwLength == 0) {
        SetLastError (ERROR_BAD_FORMAT) ;
        return (NULL) ;
    }

    //=============================//
    // read and allocate length    //
    //=============================//

    //   if (!FileRead (hFile, &dwLength, sizeof (dwLength)) || dwLength == 0)
    //      return (NULL) ;

    // check if we need a bigger buffer,
    // normally, it should be the same except the first time...
    if (LineHeader.dwLength > *pSizeofDiskLine) {
        if (*ppDiskLine) {
            // free the previous buffer
            MemoryFree (*ppDiskLine);
            *pSizeofDiskLine = 0 ;
        }

        // re-allocate a new buffer
        *ppDiskLine = (PDISKLINE) MemoryAllocate (LineHeader.dwLength) ;
        if (!(*ppDiskLine)) {
            // no memory, should flag an error...
            return (NULL) ;
        }
        *pSizeofDiskLine = LineHeader.dwLength ;
    }

    pDiskLine = *ppDiskLine ;


    //=============================//
    // copy diskline, alloc line   //
    //=============================//

    if (!FileRead (hFile, pDiskLine, LineHeader.dwLength))
        return (NULL) ;


    pLine = LineAllocate () ;
    if (!pLine) {
        return (NULL) ;
    }

    pLine->iLineType = pDiskLine->iLineType ;


    //=============================//
    // convert system information  //
    //=============================//

    pLine->lnSystemName = DiskStringReadSys (&(pDiskLine->dsSystemName)) ;
    if (!pLine->lnSystemName)
        goto ErrorBadLine ;

    if (!*ppSystem || !strsamei (pLine->lnSystemName, (*ppSystem)->sysName)) {
        *ppSystem = SystemAdd (ppSystemFirst, pLine->lnSystemName, NULL) ;
        if (!*ppSystem) {
            SetLastError (ERROR_BAD_FORMAT) ;
            goto ErrorBadLine ;
        }
        UpdateSystemData (*ppSystem, ppPerfData) ;
    }

    //=============================//
    // convert object information  //
    //=============================//

    pLine->lnObjectName = DiskStringRead (&(pDiskLine->dsObjectName)) ;
    if (!pLine->lnObjectName)
        goto ErrorBadLine ;

    pObject = LineFindObject (*ppSystem, *ppPerfData, pLine) ;

    //=============================//
    // convert counter information //
    //=============================//

    pLine->lnCounterName = DiskStringRead (&(pDiskLine->dsCounterName)) ;
    if (!pLine->lnCounterName)
        goto ErrorBadLine ;

    if (pObject) {
        pCounter = LineFindCounter (*ppSystem, pObject, *ppPerfData, pLine) ;
        if (!pCounter) {
            SetLastError (ERROR_BAD_FORMAT) ;
            goto ErrorBadLine ;
        }
    }

    //=============================//
    // convert instance info       //
    //=============================//

    pLine->lnUniqueID = pDiskLine->dwUniqueID ;
    pLine->lnInstanceName = DiskStringRead (&(pDiskLine->dsInstanceName)) ;
    pLine->lnPINName = DiskStringRead (&(pDiskLine->dsPINName)) ;

    if (pObject &&
        pLine->lnObject.NumInstances > 0 &&
        pLine->lnInstanceName == NULL) {
        goto ErrorBadLine ;
    }

    if (pObject) {
        pInstance = LineFindInstance (*ppPerfData, pObject, pLine) ;

        if (pInstance) {
            pLine->lnParentObjName = DiskStringRead (&(pDiskLine->dsParentObjName)) ;
        }
    } else {
        pLine->lnParentObjName = DiskStringRead (&(pDiskLine->dsParentObjName)) ;
    }


    //=============================//
    // convert chart information   //
    //=============================//

    if (LineType == IDM_VIEWCHART) {
        pLine->Visual = pDiskLine->Visual ;
        pLine->hPen = CreatePen (pLine->Visual.iStyle,
                                 pLine->Visual.iWidth,
                                 pLine->Visual.crColor) ;
        pLine->iScaleIndex = pDiskLine->iScaleIndex ;
        pLine->eScale = pDiskLine->eScale ;
    }


    //=============================//
    // convert alert information   //
    //=============================//

    if (LineType == IDM_VIEWALERT) {
        pLine->Visual = pDiskLine->Visual ;
        pLine->hBrush = CreateSolidBrush (pLine->Visual.crColor) ;
        pLine->bAlertOver = pDiskLine->bAlertOver ;
        pLine->eAlertValue = pDiskLine->eAlertValue ;
        pLine->lpszAlertProgram = DiskStringRead (&(pDiskLine->dsAlertProgram)) ;
        pLine->bEveryTime = pDiskLine->bEveryTime ;
        pLine->bAlerted = FALSE ;
    }


    //=============================//
    // Convert the nasty stuff     //
    //=============================//


    if (pObject) {
        pLine->lnCounterType = pCounter->CounterType;
        pLine->lnCounterLength = pCounter->CounterSize;
    }

    return (pLine) ;


    ErrorBadLine:
    if (!pLine) {
        LineFree (pLine) ;
    }
    return (NULL) ;
}


BOOL
WriteLine (
          PLINE pLine,
          HANDLE hFile
          )
{
    PDISKLINE      pDiskLine ;
    DWORD          dwSignature ;
    DWORD          dwLength ;
    PBYTE          pNextFree ;
    BOOL           bConvertName ;

    //=============================//
    // write signature             //
    //=============================//

    dwSignature = dwLineSignature ;
    if (!FileWrite (hFile, &dwSignature, sizeof (dwSignature)))
        return (FALSE) ;

    if (IsLocalComputer(pLine->lnSystemName)) {
        bConvertName = TRUE ;
    } else {
        bConvertName = FALSE ;
    }

    //=============================//
    // compute and allocate length //
    //=============================//


    dwLength = sizeof (DISKLINE) ;
    if (bConvertName) {
        dwLength += DiskStringLength (LOCAL_SYS_CODE_NAME) * sizeof (TCHAR) ;
    } else {
        dwLength += DiskStringLength (pLine->lnSystemName) * sizeof (TCHAR) ;
    }
    dwLength += DiskStringLength (pLine->lnObjectName) * sizeof (TCHAR) ;
    dwLength += DiskStringLength (pLine->lnCounterName) * sizeof (TCHAR) ;
    dwLength += DiskStringLength (pLine->lnInstanceName) * sizeof (TCHAR) ;
    dwLength += DiskStringLength (pLine->lnPINName) * sizeof (TCHAR) ;
    dwLength += DiskStringLength (pLine->lnParentObjName) * sizeof (TCHAR) ;
    dwLength += DiskStringLength (pLine->lpszAlertProgram) * sizeof (TCHAR) ;


    if (!FileWrite (hFile, &dwLength, sizeof (dwLength)))
        return (FALSE) ;

    pDiskLine = (PDISKLINE) MemoryAllocate (dwLength) ;
    if (!pDiskLine)
        return (FALSE) ;

    pNextFree = (PBYTE) pDiskLine + sizeof (DISKLINE) ;


    //=============================//
    // convert fixed size fields   //
    //=============================//

    pDiskLine->iLineType = pLine->iLineType ;
    pDiskLine->dwUniqueID = pLine->lnUniqueID ;
    pDiskLine->Visual = pLine->Visual ;
    pDiskLine->iScaleIndex = pLine->iScaleIndex ;
    pDiskLine->eScale = pLine->eScale ;
    pDiskLine->bAlertOver = pLine->bAlertOver ;
    pDiskLine->eAlertValue = pLine->eAlertValue ;
    pDiskLine->bEveryTime = pLine->bEveryTime ;


    //=============================//
    // copy disk string fields     //
    //=============================//

    if (bConvertName) {
        pNextFree = DiskStringCopy (&pDiskLine->dsSystemName,
                                    LOCAL_SYS_CODE_NAME,
                                    pNextFree) ;
    } else {
        pNextFree = DiskStringCopy (&pDiskLine->dsSystemName,
                                    pLine->lnSystemName,
                                    pNextFree) ;
    }

    pNextFree = DiskStringCopy (&pDiskLine->dsObjectName,
                                pLine->lnObjectName,
                                pNextFree) ;

    pNextFree = DiskStringCopy (&pDiskLine->dsCounterName,
                                pLine->lnCounterName,
                                pNextFree) ;

    pNextFree = DiskStringCopy (&pDiskLine->dsParentObjName,
                                pLine->lnParentObjName,
                                pNextFree) ;

    pNextFree = DiskStringCopy (&pDiskLine->dsInstanceName,
                                pLine->lnInstanceName,
                                pNextFree) ;

    pNextFree = DiskStringCopy (&pDiskLine->dsPINName,
                                pLine->lnPINName,
                                pNextFree) ;

    pNextFree = DiskStringCopy (&pDiskLine->dsAlertProgram,
                                pLine->lpszAlertProgram,
                                pNextFree) ;

    FileWrite (hFile, pDiskLine, dwLength) ;
    MemoryFree (pDiskLine) ;
    return (TRUE) ;
}


// we are not doing printing.  In case we need this
// later, then define DO_PRINTING
#ifdef DO_PRINTING
int aiPrinterLineStyles [] =
{
    PS_SOLID,
    PS_DASH,
    PS_DOT,
    PS_DASHDOT,
    PS_DASHDOTDOT
} ;
#define NumPrinterLineStyles()   \
   (sizeof (aiPrinterLineStyles) / sizeof (aiPrinterLineStyles [0]))


COLORREF acrPrinterLineColors [] =
{
    RGB (192, 192, 192),
    RGB (128, 128, 128),
    RGB (64, 64, 64),
    RGB (0, 0, 0)
}  ;


#define NumPrinterLineColors()   \
   (sizeof (acrPrinterLineColors) / sizeof (acrPrinterLineColors [0]))
#endif      // DO_PRINTING


HPEN
LineCreatePen (
              HDC hDC,
              PLINEVISUAL pVisual,
              BOOL bForPrint
              )
{
    HPEN        hPen ;
#ifdef DO_PRINTING
    LOGBRUSH    logBrush ;

    if (bForPrint) {
        logBrush.lbStyle = PS_SOLID ;
        //!!         aiPrinterLineStyles [pVisual->iColorIndex % NumPrinterLineStyles ()] ;
        logBrush.lbColor =
        acrPrinterLineColors [pVisual->iColorIndex % NumPrinterLineColors ()] ;
        logBrush.lbHatch = 0 ;

        hPen = ExtCreatePen (logBrush.lbStyle |
                             PS_GEOMETRIC |
                             PS_ENDCAP_SQUARE |
                             PS_JOIN_BEVEL,
                             VertInchPixels (hDC, pVisual->iWidth, 20),
                             &logBrush,
                             0, NULL) ;
    } else
#endif
        hPen = CreatePen (pVisual->iStyle,
                          pVisual->iWidth,
                          pVisual->crColor) ;

    return (hPen) ;
}



VOID
FreeLines (
          PLINESTRUCT pLineFirst
          )
{
    PLINESTRUCT    pLine,next_line;


    for (pLine = pLineFirst; pLine; pLine = next_line) {
        next_line = pLine->pLineNext;
        LineFree (pLine) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\logoptns.h ===
BOOL DisplayLogOptions (HWND hWndParent,
                        HWND hWndLog) ;



BOOL APIENTRY LogOptionsHookProc (HWND hDlg, 
                                  UINT iMessage, 
                                  WPARAM wParam, 
                                  LPARAM lParam) ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\log.c ===
/*****************************************************************************
 *
 *  Log.c - This module handles the Logging.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *
 ****************************************************************************/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <stdio.h>

#include "perfmon.h"
#include "log.h"

#include "fileutil.h"
#include "owndraw.h"
#include "pmemory.h"       // for MemoryXXX (mallloc-type) routines
#include "perfmops.h"      // for SystemAdd
#include "perfdata.h"
#include "playback.h"      // for PlayingBackLog
#include "status.h"        // for StatusUpdateIcons
#include "system.h"        // for SystemAdd
#include "utils.h"
#include "fileopen.h"      // for FileGetName
#include "command.h"

extern TCHAR LOCAL_SYS_CODE_NAME[] ;

//==========================================================================//
//                              Funtion Prototypes                          //
//==========================================================================//


BOOL LogWriteStartBookmark (HWND hWnd, SYSTEMTIME *pSystemTime) ;
BOOL LogWriteBookmarkData (HWND hWnd, PBOOKMARK pBookMark) ;
BOOL LogWriteSystemBookmark (HWND hWnd, LPTSTR SysName, BOOL DisConnect, SYSTEMTIME *pSystemTime) ;


//==========================================================================//
//                                  Constants                               //
//==========================================================================//



#define LogNameMinLen             15
#define LogObjectMinLen           20

// This is set to 1 min
#define LARGE_INTERVAL            60

//=============================//
// Log Class                   //
//=============================//


#define dwLogClassStyle           (CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS)
#define iLogClassExtra            (0)
#define iLogWindowExtra           (0)
#define dwLogWindowStyle          (WS_CHILD)


//==========================================================================//
//                                Local Data                                //
//==========================================================================//



int            xStatusWidth ;
int            xNameMinWidth ;

TCHAR          szClosed [ShortTextLen] ;
TCHAR          szCollecting [ShortTextLen] ;
// TCHAR          szPaused [ControlStringLen + 1] ;



LOGINDEXBLOCK  *pLogIndexBlock ;

#define WM_START_LOGGING  WM_USER+2

//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define LogEntryN(hWndLogEntries, iIndex)        \
   ((PLOGENTRY) LBData (hWndLogEntries, iIndex))


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//

void LogAddEntryToList (PLOGENTRY *ppLogEntryFirst, PLOGENTRY pLogNewEntry)
{
    // insert the new entry at the beginning
    pLogNewEntry->pNextLogEntry = *ppLogEntryFirst ;
    *ppLogEntryFirst = pLogNewEntry ;
}

void LogDeleteEntryFromList (PLOGENTRY *ppLogEntryFirst, PLOGENTRY pLogEntryDel)
{
    PLOGENTRY   pLogEntry ;

    if (*ppLogEntryFirst == pLogEntryDel) {
        *ppLogEntryFirst = pLogEntryDel->pNextLogEntry ;
    } else {
        for (pLogEntry = *ppLogEntryFirst ;
            pLogEntry ;
            pLogEntry = pLogEntry->pNextLogEntry) {
            if (pLogEntry->pNextLogEntry == pLogEntryDel) {
                // found, remove this entry from the list
                pLogEntry->pNextLogEntry =
                pLogEntryDel->pNextLogEntry ;
                break ;
            }
        }
    }
}


// LogDeleteIndex - delete the log entry specified by iIndex
// and do memory clean-up
void static LogDeleteIndex (HWND hWndLogEntries, INT_PTR iIndex)
{
    PLOGENTRY   pLogEntry ;
    PLOG        pLog ;

    pLogEntry = (PLOGENTRY) LBData(hWndLogEntries, iIndex) ;


    if (pLogEntry && pLogEntry != (PLOGENTRY)LB_ERR) {
        pLog = LogData (hWndLog) ;

        if (pLog->pLogEntryFirst) {
            LogDeleteEntryFromList (&(pLog->pLogEntryFirst), pLogEntry) ;
        }

        MemoryFree (pLogEntry) ;
    }

    LBDelete (hWndLogEntries, iIndex) ;
}


void LogEntriesChanged (HWND hWndLogEntries)
/*
   Effect:        Perform any actions needed when an entry has been added or
                  removed from the log. In particular, determine if a new
                  "Object" column width is appropriate. If it is, then
                  change the width and redraw the log entries list.
*/
{
    int         iIndex ;
    int         iIndexNum ;
    int         xCol1Width ;
    HDC         hDC ;
    PLOG        pLog ;
    PLOGENTRY   pLogEntry ;
    PPERFSYSTEM pSystem;

    pLog = LogData (hWndLog) ;
    xCol1Width = 0 ;

    hDC = GetDC (hWndLog) ;
    iIndexNum = LBNumItems (hWndLogEntries) ;

    // clear value Strings for all systems

    for (pSystem = pLog->pSystemFirst;
        pSystem;
        pSystem = pSystem->pSystemNext) {
        if (pSystem && pSystem->FailureTime == 0) {
            RemoveObjectsFromSystem (pSystem);
        }
    }

    for (iIndex = 0; iIndex < iIndexNum; iIndex++) {
        pLogEntry = LogEntryN (hWndLogEntries, iIndex) ;
        xCol1Width = max (TextWidth (hDC, pLogEntry->szObject),
                          xCol1Width) ;

        pSystem = SystemGet (pLog->pSystemFirst, pLogEntry->szComputer);
        if (pSystem && pSystem->FailureTime == 0) {
            AppendObjectToValueList (
                                    pLogEntry->ObjectTitleIndex,
                                    pSystem->lpszValue);
        }
    }

    xCol1Width += 2 * xScrollWidth ;
    xCol1Width = max (xCol1Width,
                      TextAvgWidth (hDC, LogObjectMinLen)) ;
    if (xCol1Width != pLog->xCol1Width) {
        pLog->xCol1Width = xCol1Width ;
        WindowInvalidate (hWndLogEntries) ;
    }
    ReleaseDC (hWndLog, hDC) ;
}


LPTSTR StatusText (int iPMStatus)
/*
   Effect:        Return a string representation of the log status
                  iPMStatus.

   Note:          Since these are globals, we can just return a pointer
                  to them. The user of this routine should not free
                  these pointers or modify the string.
*/
{
    switch (iPMStatus) {
        case iPMStatusClosed:
            return (szClosed) ;

        case iPMStatusCollecting:
            return (szCollecting) ;

            //      case iPMStatusPaused:
            //         return (szPaused) ;

        default:
            return (szClosed) ;
    }
}


PLOG AllocateLogData (HWND hWndLog)
{
    PLOG           pLog ;

    pLog = LogData (hWndLog) ;

    pLog->iStatus = iPMStatusClosed ;
    pLog->bManualRefresh = FALSE ;

    // let's not give it a filename

    /*!!
       FileCombine (pLog->szFilePath,
                    szDefaultLogDirectory, szDefaultLogFileName) ;
    !!*/
    strclr (pLog->szFilePath) ;

    pLog->pSystemFirst = NULL;
    pLog->lFileSize = 0L ;
    pLog->iIntervalMSecs = iDefaultLogIntervalSecs * 1000 ;

    pLog->pLogData = (PPERFDATA) MemoryAllocate (STARTING_SYSINFO_SIZE) ;
    pLog->dwDetailLevel = PERF_DETAIL_WIZARD ;
    LogEntriesChanged (hWndLogEntries) ;

    return (pLog) ;
}


void FreeLogData (PLOG pLog)
{
    MemoryFree ((LPMEMORY)pLog->pLogData) ;
}


void UpdateLogSize (HWND hWnd)
/*
   Effect:        Set the size value to the current size.  Also change the
                  size entry in the status line.
*/
{
    PLOG           pLog ;
    TCHAR          szSize [ShortTextLen + 1] ;

    pLog = LogData (hWnd) ;

    LongToCommaString (pLog->lFileSize, szSize) ;
    SetDlgItemText (hWnd, IDD_LOGSIZE, szSize) ;

    if (!PlayingBackLog()) {
        StatusUpdateIcons (hWndStatus) ;
    }
}


HANDLE LogAppendSetup(PLOG pLog, PLOGHEADER pLogFileHeader)
{
    PLOGHEADER     pHeader ;
    LOGPOSITION    LP ;
    DWORD          lPreviousIndexBlock ;
    DWORD          lNextIndexBlock ;
    PLOGHEADER     pPlaybackLogHeader ;
    HANDLE         hMapHandle ;

    pHeader = (PLOGHEADER) FileMap(pLog->hFile, &hMapHandle) ;
    if (!pHeader ||
        !strsame(pHeader->szSignature, LogFileSignature) ||
        pHeader->wVersion != LogFileVersion ||
        pHeader->wRevision != LogFileRevision) {
        if (pHeader) {
            FileUnMap((LPVOID)pHeader, hMapHandle) ;
        }
        return 0 ;
    }

    *pLogFileHeader = *pHeader ;


    LP.pIndexBlock = FirstIndexBlock(pHeader) ;
    LP.iIndex = 0 ;
    LP.iPosition = 0 ;
    lPreviousIndexBlock = pHeader->iLength ;
    lNextIndexBlock = LP.pIndexBlock->lNextBlockOffset ;

    // since inside NextReLogIndexPosition would eventually call
    // PlaybackSeek for large log file, we have to temporarily
    // setup PlaybackLog.pHeader.   Not a good fix but it works...
    pPlaybackLogHeader = PlaybackLog.pHeader ;
    PlaybackLog.pHeader = pHeader ;
    while (NextReLogIndexPosition(&LP)) {
        if (LP.pIndexBlock->lNextBlockOffset != lNextIndexBlock) {
            lPreviousIndexBlock = lNextIndexBlock ;
            lNextIndexBlock = LP.pIndexBlock->lNextBlockOffset ;
        }
    }

    // get the last system time from this log file
    if (LP.iIndex > 0) {
        SYSTEMTIME localSystemTime ;

        if (LogPositionSystemTime (&LP, &localSystemTime)) {
            pLog->LastLogTime = localSystemTime ;
        }
    }

    PlaybackLog.pHeader = pPlaybackLogHeader ;
    if (!pLogIndexBlock) {
        pLogIndexBlock = (LOGINDEXBLOCK *) MemoryAllocate (sizeof(LOGINDEXBLOCK)) ;
    }
    if (pLogIndexBlock) {
        *pLogIndexBlock = *LP.pIndexBlock ;
    }
    pLog->lIndexBlockOffset = lPreviousIndexBlock ;
    pLog->iIndex = ++LP.iIndex ;
    pLog->lFileSize = FileSeekEnd(pLog->hFile, 0) ;

    FileUnMap((LPVOID)pHeader, hMapHandle) ;
    return pLog->hFile ;
}

void LogRemoveCounterName (PLOG pLog)
{
    PPERFSYSTEM    pSystem ;

    if (pLog->pBaseCounterName) {
        MemoryFree (pLog->pBaseCounterName) ;
    }
    pLog->pBaseCounterName = 0 ;
    pLog->lBaseCounterNameSize = 0 ;
    pLog->lBaseCounterNameOffset = 0 ;

    // clear all the system marker to indicate they have not been
    // saved
    for (pSystem = pLog->pSystemFirst ;
        pSystem ;
        pSystem = pSystem->pSystemNext) {
        pSystem->bSystemCounterNameSaved = FALSE ;
    }
}

int CreateLogFile (PLOG pLog, BOOL bCreateFile, BOOL bSameFile)
{
    HANDLE               returnHandle ;
    LOGHEADER            LogFileHeader ;
    long                 lCurPosition ;
    LOGFILECOUNTERNAME   CounterNameRecord ;

    pLog->lFileSize = 0 ;
    memset (&(pLog->LastLogTime), 0, sizeof(SYSTEMTIME)) ;

    if (!pLogIndexBlock) {
        pLogIndexBlock = (LOGINDEXBLOCK *) MemoryAllocate (sizeof(LOGINDEXBLOCK)) ;
    }
    if (pLogIndexBlock) {
        lstrcpy (pLogIndexBlock->szSignature, LogIndexSignature) ;
    }
    else
        return ERROR_NOT_ENOUGH_MEMORY;

    pLog->hFile = FileHandleOpen (pLog->szFilePath) ;
    if (pLog->hFile != INVALID_HANDLE_VALUE) {
        // if this is a pre-existing log file, set up to append to it
        returnHandle = LogAppendSetup(pLog, &LogFileHeader) ;
        if (!returnHandle) {
            // this is not a log file...
            CloseHandle (pLog->hFile) ;
            return (ERR_BAD_LOG_FILE) ;
        }

        pLog->hFile = returnHandle ;
    }

    if (bCreateFile && (!pLog->hFile || pLog->hFile == INVALID_HANDLE_VALUE)) {
        // Create a new log file if needed.
        pLog->hFile = FileHandleCreate (pLog->szFilePath) ;
        if (!pLog->hFile || pLog->hFile == INVALID_HANDLE_VALUE)
            return (ERR_LOG_FILE) ;
        lstrcpy (LogFileHeader.szSignature, LogFileSignature) ;
        LogFileHeader.wVersion = LogFileVersion ;
        LogFileHeader.wRevision = LogFileRevision ;
        LogFileHeader.iLength = sizeof (LOGHEADER) ;
        LogFileHeader.lBaseCounterNameOffset = 0 ;
        if (!FileWrite (pLog->hFile, &LogFileHeader, sizeof (LogFileHeader))) {
            CloseHandle (pLog->hFile) ;
            return (ERR_LOG_FILE) ;
        }

        pLog->iIndex = 0 ;
        pLog->lIndexBlockOffset = FileTell (pLog->hFile) ;
        FileSeekCurrent (pLog->hFile, sizeof (LOGINDEXBLOCK)) ;
        pLog->lFileSize = sizeof(LOGHEADER) + sizeof (LOGINDEXBLOCK) ;
        pLogIndexBlock->iNumIndexes = 0 ;
        pLogIndexBlock->lNextBlockOffset = 0 ;

        // get rid of any previous counter names and get ready for start
        //      if (!bSameFile)
        //         {
        //         LogRemoveCounterName (pLog) ;
        //         }
        LogRemoveCounterName (pLog) ;
    } else if (bCreateFile) {
        // this is an existing log file, setup the counter names
        // LogFileHeader already has the header info filled in
        // by LogAppendSetup
        if (!bSameFile || !pLog->pBaseCounterName) {
            // get rid of any previous counter names
            LogRemoveCounterName (pLog) ;

            // read the new names and get ready for start
            lCurPosition = FileTell (pLog->hFile) ;

            FileSeekBegin (pLog->hFile,
                           LogFileHeader.lBaseCounterNameOffset) ;

            if (!(FileRead (pLog->hFile,
                            &CounterNameRecord,
                            sizeof (CounterNameRecord)))) {
                FileSeekBegin (pLog->hFile,
                               lCurPosition) ;
                goto EXIT ;
            }

            FileSeekBegin (pLog->hFile,
                           CounterNameRecord.lCurrentCounterNameOffset) ;

            if (!(pLog->pBaseCounterName = MemoryAllocate (
                                                          CounterNameRecord.lUnmatchCounterNames))) {
                FileSeekBegin (pLog->hFile,
                               lCurPosition) ;
                goto EXIT ;
            }
            if (!(FileRead (pLog->hFile,
                            pLog->pBaseCounterName,
                            CounterNameRecord.lUnmatchCounterNames))) {
                MemoryFree (pLog->pBaseCounterName) ;
                pLog->pBaseCounterName = NULL ;
                FileSeekBegin (pLog->hFile,
                               lCurPosition) ;
                goto EXIT ;
            }
            // we got the data, fill in other info
            pLog->lBaseCounterNameSize =
            CounterNameRecord.lUnmatchCounterNames ;
            pLog->lBaseCounterNameOffset =
            LogFileHeader.lBaseCounterNameOffset ;

            FileSeekBegin (pLog->hFile,
                           lCurPosition) ;
        }
    }

    EXIT:

    return (0) ;

}

void LogWriteIndexBlock (PLOG pLog)
{
    FileSeekBegin (pLog->hFile,
                   pLog->lIndexBlockOffset) ;
    pLogIndexBlock->lNextBlockOffset = 0 ;
    FileWrite (pLog->hFile,
               (LPSTR) pLogIndexBlock,
               sizeof (LOGINDEXBLOCK)) ;
}


BOOL LogWriteIndex (PLOG pLog,
                    UINT uFlags,
                    SYSTEMTIME *pSystemTime,
                    LONG lDataOffset,
                    int iSystemsLogged)
{
    LOGINDEX       Index ;
    long           lNextBlockOffset ;
    BOOL           WriteOK ;
    //=============================//
    // Add Index Block Entry       //
    //=============================//
    //=============================//
    // Index Block Full?           //
    //=============================//

    WriteOK = TRUE ;

    if (pLog->iIndex == LogFileBlockMaxIndexes - 1) {
        lNextBlockOffset = FileTell (pLog->hFile) ;
        pLogIndexBlock->lNextBlockOffset = lNextBlockOffset ;
        FileSeekBegin (pLog->hFile,
                       pLog->lIndexBlockOffset) ;
        WriteOK = FileWrite (pLog->hFile,
                             (LPSTR) pLogIndexBlock,
                             sizeof (LOGINDEXBLOCK)) ;
        if (WriteOK) {
            FileSeekBegin (pLog->hFile,
                           lNextBlockOffset) ;
            // Fake file end until we really write the block
            pLogIndexBlock->iNumIndexes = 0 ;
            pLogIndexBlock->lNextBlockOffset = 0 ;
            WriteOK = FileWrite (pLog->hFile,
                                 (LPSTR) pLogIndexBlock,
                                 sizeof (LOGINDEXBLOCK)) ;
            if (WriteOK) {
                pLog->lIndexBlockOffset = lNextBlockOffset ;
                pLog->iIndex = 0 ;
                pLog->lFileSize += sizeof (LOGINDEXBLOCK) ;
            }
        }
    }

    //=============================//
    // Add Index Block Entry       //
    //=============================//

    Index.uFlags = uFlags ;
    Index.SystemTime = *pSystemTime ;
    Index.lDataOffset = lDataOffset ;
    Index.iSystemsLogged = iSystemsLogged ;

    pLogIndexBlock->aIndexes [pLog->iIndex] = Index ;
    pLog->iIndex++ ;
    pLogIndexBlock->iNumIndexes++ ;

    // write out the index block if the log interval if too large
    if (pLog->iIntervalMSecs >= LARGE_INTERVAL * 1000 ) {
        LONG           lCurPosition ;

        // save the current file position
        lCurPosition = FileTell (pLog->hFile) ;

        // flush the index block to the file
        LogWriteIndexBlock (pLog) ;

        // restore previous file position since
        // LogWriteIndexBlock has messed it up
        FileSeekBegin (pLog->hFile, lCurPosition) ;
    }
    return (WriteOK) ;
}



BOOL LogWritePerfData (HWND hWnd,
                       PLOG pLog,
                       PPERFDATA pPerfData,
                       SYSTEMTIME *pSystemTime,
                       DWORD iNumSystems,
                       BOOL bWriteIndex)
{
    LONG           lSize ;
    BOOL           WriteOK ;
    LONG           lCurPosition ;

    lSize = pPerfData->TotalByteLength ;

    lCurPosition = FileTell (pLog->hFile) ;

    //=============================//
    // Write Perf Data             //
    //=============================//

    WriteOK = FileWrite (pLog->hFile, (LPSTR) pPerfData, lSize) ;
    if (WriteOK) {
        pLog->lFileSize += lSize ;

        if (bWriteIndex) {
            WriteOK = LogWriteIndex (pLog,
                                     LogFileIndexData,
                                     pSystemTime,
                                     lCurPosition,
                                     iNumSystems) ;
        }
    }
    if ( !WriteOK ) {
        CloseLog (hWnd, pLog) ;
        PrepareMenu (GetMenu (hWndMain)) ;
        UpdateLogDisplay (hWnd) ;
        DlgErrorBox (hWnd, ERR_LOG_FILE, pLog->szFilePath) ;
    }
    return (WriteOK) ;
}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void static OnSize (HWND hDlg,
                    int xWidth,
                    int yHeight)
/*
   Effect:        Perform any actions necessary when the log window (dialog)
                  is resized. In particular, move and resize some of the
                  dialogs controls.

   Internals:     The rightmost control, the log status, contains one of
                  only several values. These values are all within
                  xStatusWidth, computed at init time. Put this control
                  one scroll width away from the right edge at fixed
                  width. Move its associated text prompt with it. Then
                  use the remaining space for the filename control, which
                  can probably use it.

   To Do:         Need to consider minimum first.
*/
{
    int            xStatusPos ;
    int            xStatusTextPos ;
    int            xNameWidth ;
    int            xMinWidth ;

    //=============================//
    // Enough space for minimums?  //
    //=============================//

    xMinWidth =
    xScrollWidth +                         // margin before prompt
    DialogWidth (hDlg, IDD_LOGFILETEXT) +  // width of prompt
    xNameMinWidth +                        // width of name
    xScrollWidth +
    DialogWidth (hDlg, IDD_LOGSTATUSTEXT) +
    DialogWidth (hDlg, IDD_LOGSTATUS) +
    xScrollWidth ;


    xStatusPos = xWidth - xStatusWidth - xScrollWidth ;
    DialogMove (hDlg, IDD_LOGSTATUS,
                xStatusPos, NOCHANGE,
                xStatusWidth, NOCHANGE) ;

    xStatusTextPos = xStatusPos -
                     DialogWidth (hDlg, IDD_LOGSTATUSTEXT) -
                     xScrollWidth ;
    DialogMove (hDlg, IDD_LOGSTATUSTEXT,
                xStatusTextPos, NOCHANGE,
                NOCHANGE, NOCHANGE) ;

    xNameWidth = xStatusTextPos -
                 DialogWidth (hDlg, IDD_LOGFILETEXT) -
                 2 * xScrollWidth ;
    DialogMove (hDlg, IDD_LOGFILE,
                NOCHANGE, NOCHANGE,
                xNameWidth, NOCHANGE) ;

    DialogMove (hDlg, IDD_LOGSIZE,
                DialogXPos (hDlg, IDD_LOGFILE), NOCHANGE,
                DialogWidth (hDlg, IDD_LOGFILE), NOCHANGE) ;

    DialogMove (hDlg, IDD_LOGINTERVALTEXT,
                DialogXPos (hDlg, IDD_LOGSTATUSTEXT), NOCHANGE,
                DialogWidth (hDlg, IDD_LOGSTATUSTEXT), NOCHANGE) ;

    DialogMove (hDlg, IDD_LOGINTERVAL,
                DialogXPos (hDlg, IDD_LOGSTATUS), NOCHANGE,
                DialogWidth (hDlg, IDD_LOGSTATUS), NOCHANGE) ;

    DialogMove (hDlg, IDD_LOGENTRIESTEXT,
                xScrollWidth, NOCHANGE, NOCHANGE, NOCHANGE) ;

    DialogMove (hDlg, IDD_LOGENTRIES,
                xScrollWidth, NOCHANGE,
                xWidth - 2 * xScrollWidth,
                yHeight - DialogYPos (hDlg, IDD_LOGENTRIES) - yScrollHeight) ;
    WindowInvalidate (hDlg) ;
}


INT_PTR
OnCtlColor (
           HWND hDlg,
           HDC hDC
           )
{
    SetTextColor (hDC, crBlack) ;
    //   SetBkColor (hDC, crLightGray) ;
    //   return ((int) hbLightGray) ;
    SetBkColor (hDC, ColorBtnFace) ;
    return ((INT_PTR) hBrushFace) ;
}


void static OnInitDialog (HWND hDlg)
{
    HDC            hDC ;
    PLOG           pLog ;

    hWndLogEntries = DialogControl (hDlg, IDD_LOGENTRIES) ;

    pLog = AllocateLogData (hDlg) ;
    if (!pLog)
        return ;

    StringLoad (IDS_CLOSED, szClosed) ;
    //   StringLoad (IDS_PAUSED, szPaused) ;
    StringLoad (IDS_COLLECTING, szCollecting) ;
    UpdateLogDisplay (hDlg) ;

    hDC = GetDC (hDlg) ;
    xStatusWidth = max (TextWidth (hDC, szClosed),
                        TextWidth (hDC, szCollecting)) ;
    //                       max (TextWidth (hDC, szPaused),
    //                            TextWidth (hDC, szCollecting))) ;
    xStatusWidth += xScrollWidth ;

    xNameMinWidth = TextAvgWidth (hDC, LogNameMinLen) ;
    ReleaseDC (hDlg, hDC) ;
}



void static OnDestroy (HWND hWnd)
/*
   Effect:        Perform any actions necessary when a LogDisplay window
                  is being destroyed. In particular, free the instance
                  data for the log.

                  Since we really only have one log window and one global
                  log data structure, we don't free the structure. We do,
                  however, delete the objects allocated within the structure.
*/
{
    PLOG           pLog ;

    pLog = LogData (hWnd) ;
    FreeLogData (pLog) ;
}


void static OnDrawItem (HWND hWnd, LPDRAWITEMSTRUCT lpDI)
{
    HDC            hDC ;
    RECT           rectComputer, rectObject ;
    PLOGENTRY      pLogEntry ;
    PLOG           pLog ;
    COLORREF       preBkColor = 0;
    COLORREF       preTextColor = 0;

    pLog = LogData (hWnd) ;

    pLogEntry = LogEntryN (hWndLogEntries, DIIndex (lpDI)) ;

    // LogEntryN (SendMessage) will return LB_ERR for error, have to
    // check for that case
    if (!pLogEntry || pLogEntry == (PLOGENTRY)LB_ERR) {
        return ;
    }

    hDC = lpDI->hDC ;

    SelectFont (hDC, hFontScales) ;

    if (DISelected (lpDI)) {
        preTextColor = SetTextColor (hDC, GetSysColor (COLOR_HIGHLIGHTTEXT)) ;
        preBkColor = SetBkColor (hDC, GetSysColor (COLOR_HIGHLIGHT)) ;
    }

    rectObject.left = lpDI->rcItem.left ;
    rectObject.top = lpDI->rcItem.top ;
    rectObject.right = rectObject.left + pLog->xCol1Width ;
    rectObject.bottom = lpDI->rcItem.bottom ;

    ExtTextOut (hDC,
                rectObject.left + xScrollWidth, rectObject.top,
                ETO_OPAQUE,
                &rectObject,
                pLogEntry->szObject,
                lstrlen (pLogEntry->szObject),
                NULL) ;


    rectComputer.left = rectObject.right ;
    rectComputer.top = lpDI->rcItem.top ;
    rectComputer.right = lpDI->rcItem.right ;
    rectComputer.bottom = lpDI->rcItem.bottom ;

    ExtTextOut (hDC,
                rectComputer.left, rectComputer.top,
                ETO_OPAQUE,
                &rectComputer,
                pLogEntry->szComputer,
                lstrlen (pLogEntry->szComputer),
                NULL) ;

    if (DIFocus (lpDI))
        DrawFocusRect (hDC, &(lpDI->rcItem)) ;

    if (DISelected (lpDI)) {
        preTextColor = SetTextColor (hDC, preTextColor) ;
        preBkColor = SetBkColor (hDC, preBkColor) ;
    }
    //   RestoreDC (hDC, -1) ;
}



//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


INT_PTR
APIENTRY
LogDisplayDlgProc (
                   HWND hDlg,
                   UINT iMessage,
                   WPARAM wParam,
                   LPARAM lParam)
/*
   Note:          This function must be exported in the application's
                  linker-definition file, perfmon.def.
*/
{
    switch (iMessage) {
        case WM_INITDIALOG:
            OnInitDialog (hDlg) ;
            break ;

        case WM_CTLCOLORDLG:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSTATIC:
            return (OnCtlColor (hDlg, (HDC) wParam)) ;
            break ;

        case WM_DRAWITEM:
            OnDrawItem (hDlg, (LPDRAWITEMSTRUCT) lParam) ;
            break ;

        case WM_LBUTTONDBLCLK:
            SendMessage (hWndMain, WM_LBUTTONDBLCLK, wParam, lParam) ;
            break ;

        case WM_LBUTTONDOWN:
            DoWindowDrag (hDlg, lParam) ;
            break ;

        case WM_SIZE:
            OnSize (hDlg, LOWORD (lParam), HIWORD (lParam)) ;
            break ;

        case WM_TIMER:
            LogTimer (hDlg, FALSE) ;
            break ;

        case WM_SETFOCUS:
            SetFocus (hWndLogEntries) ;
            break ;

        case WM_START_LOGGING:
            {
                PLOG        pLog ;

                pLog = LogData (hDlg) ;
                if (StartLog (hDlg, pLog, FALSE)) {
                    UpdateLogDisplay (hDlg) ;
                    PrepareMenu (GetMenu (hWndMain)) ;
                }
            }
            break ;

        case WM_DESTROY:
            OnDestroy (hDlg) ;
            return (FALSE) ;
            break ;

        default:
            return (FALSE) ;
    }

    return (TRUE) ;
}


HWND CreateLogWindow (HWND hWndParent)
/*
   Effect:        Create the Log window. This window is a child of
                  hWndMain.

   Note:          We dont worry about the size here, as this window
                  will be resized whenever the main window is resized.

*/
{
    HWND           hWnd ;
    hWnd = CreateDialog (hInstance,
                         MAKEINTRESOURCE (idDlgLogDisplay),
                         hWndParent,
                         LogDisplayDlgProc) ;

    return (hWnd) ;
}



void UpdateLogDisplay (HWND hWnd)
/*
   Effect:        Set the values for the various controls in the log
                  display.

   Called By:     OnInitDialog, any other routines that change these
                  values.
*/
{
    PLOG           pLog ;
    WCHAR          szSize [MiscTextLen + 1] ;

    pLog = LogData (hWnd) ;

    DialogSetString (hWnd, IDD_LOGFILE, pLog->szFilePath) ;

    // position the cursor at the end of the text
    EditSetTextEndPos (hWnd, IDD_LOGFILE) ;


    DialogSetString (hWnd, IDD_LOGSTATUS, StatusText (pLog->iStatus)) ;

    LongToCommaString (pLog->lFileSize, szSize) ;
    DialogSetString (hWnd, IDD_LOGSIZE, szSize) ;

    DialogSetInterval (hWnd, IDD_LOGINTERVAL, pLog->iIntervalMSecs) ;
}


BOOL LogInitializeApplication (void)
{
    return (TRUE) ;
}


void SetLogTimer (HWND hWnd,
                  int iIntervalMSecs)
{
    PLOG           pLog ;

    pLog = LogData (hWnd) ;
    pLog->iIntervalMSecs = iIntervalMSecs ;

    KillTimer (hWnd, LogTimerID) ;
    SetTimer (hWnd, LogTimerID, pLog->iIntervalMSecs, NULL) ;
}


void ClearLogTimer (HWND hWnd)
{
    KillTimer (hWnd, LogTimerID) ;
}



BOOL CloseLogStopTimer (HWND hWnd, PLOG pLog)
{
    CloseHandle (pLog->hFile) ;

    pLog->hFile = 0 ;
    pLog->iStatus = iPMStatusClosed ;

    ClearLogTimer (hWnd) ;

    return (TRUE) ;
}


BOOL CloseLog (HWND hWnd, PLOG pLog)
{
    LogWriteIndexBlock (pLog) ;
    CloseLogStopTimer (hWnd, pLog) ;
    WindowInvalidate (hWndStatus) ;
    return (TRUE) ;
}

BOOL StartLog (HWND hWnd, PLOG pLog, BOOL bSameFile)
{
    int            RetCode ;
    SYSTEMTIME     SystemTime ;

    if ((RetCode = CreateLogFile (pLog, TRUE, bSameFile)) == 0) {
        pLog->iStatus = iPMStatusCollecting ;

        GetLocalTime (&SystemTime) ;

        // write a dummy record.
        // this is needed because when playingback log
        // it will skip the first index from the first
        // index block.
        LogWriteIndex (pLog, 0, &SystemTime, 0, 0) ;

        if (!PlayingBackLog()) {
            // write out a bookmark to indicate start of new data
            if (!LogWriteStartBookmark (hWnd, &SystemTime)) {
                RetCode = 0 ;
                goto ErrorExit ;
            }

            if (!(pLog->bManualRefresh)) {
                SetLogTimer (hWnd, pLog->iIntervalMSecs) ;
                WindowInvalidate (hWndStatus) ;
            }
        } else {
            // check if time if OK
            LOGPOSITION    LP ;
            SYSTEMTIME     FirstSystemTime ;
            int            TimeDiff ;

            LP = PlaybackLog.StartIndexPos ;

            if (LogPositionSystemTime (&LP, &FirstSystemTime)) {
                // we don't want to append data to the log file if
                // the time is not in order.  So, forget it if the
                // last log time in the Log file is greater than the First
                // log time of the playback log file.
                TimeDiff = SystemTimeDifference (&(pLog->LastLogTime),
                                                 &(FirstSystemTime), FALSE) ;
                if (TimeDiff < 0) {
                    // error , time not in order
                    CloseHandle (pLog->hFile) ;
                    RetCode = ERR_CANT_RELOG_DATA ;
                }
            }
        }

        if (RetCode == 0) {
            // write counter names if needed
            LogWriteSystemCounterNames (hWnd, pLog) ;
            return (TRUE) ;
        }
    }

    ErrorExit:
    pLog->hFile = 0 ;
    CloseLogStopTimer(hWnd, pLog);
    PrepareMenu (GetMenu (hWndMain)) ;
    UpdateLogDisplay (hWnd) ;
    if (RetCode) {
        DlgErrorBox (hWnd, RetCode, pLog->szFilePath);
    }
    return (FALSE) ;
}



DWORD LogFindEntry(LPTSTR lpszComputer, DWORD ObjectTitleIndex)
/*
   Effect:         Returns the index of the specified Computer/Object
                   if it already exists in the Entries List Box,
                   otherwise returns LOG_ENTRY_NOT_FOUND
*/
{
    DWORD          iLogEntry ;
    DWORD          iLogNum ;
    PLOGENTRY      pLogEntry ;

    iLogNum = (DWORD) LBNumItems(hWndLogEntries) ;
    for (iLogEntry = 0;
        iLogEntry < iLogNum ;
        iLogEntry++) {
        pLogEntry = (PLOGENTRY) LBData(hWndLogEntries, iLogEntry) ;
        if (pLogEntry->ObjectTitleIndex == ObjectTitleIndex &&
            strsamei(pLogEntry->szComputer, lpszComputer)) {
            return iLogEntry ;
        }
    }
    return (DWORD) LOG_ENTRY_NOT_FOUND;
}



BOOL LogAddEntry (HWND hWndLog,
                  LPTSTR lpszComputer,
                  LPTSTR lpszObject,
                  DWORD ObjectTitleIndex,
                  BOOL  bGetObjectTitleIndex)
/*
   Effect:        Add an entry in the log structure for the computer and
                  object to be logged.

   Returns:       Whether the operation could be performed.
*/
{
    PLOG           pLog ;
    PLOGENTRY      pLogEntry ;
    SIZE_T         iIndex ;
    PPERFSYSTEM    pCurrentSystem = NULL ;
    DWORD          CurrentObjectTitleIndex ;


    pLog = LogData (hWndLog) ;

    pCurrentSystem = SystemAdd (&(pLog->pSystemFirst), lpszComputer, hWndLog) ;

    pLogEntry = MemoryAllocate (sizeof (LOGENTRY)) ;
    if (!pLogEntry)
        return (FALSE) ;

    lstrcpy (pLogEntry->szComputer, lpszComputer) ;
    lstrcpy (pLogEntry->szObject, lpszObject) ;

    pLogEntry->ObjectTitleIndex = ObjectTitleIndex ;

    // if reading from a log setting file, get the
    // latest Object index by the perfdata itself.
    // There may be case that the id has been changed
    if (bGetObjectTitleIndex &&
        pCurrentSystem &&
        pCurrentSystem->pSystemPerfData) {
        if (pCurrentSystem->pSystemPerfData->Signature[0] == TEXT('\0')) {
            UpdateSystemData (
                             pCurrentSystem,
                             &(pCurrentSystem->pSystemPerfData)) ;
        }

        if (CurrentObjectTitleIndex = GetObjectIdByName(
                                                       pCurrentSystem,
                                                       pCurrentSystem->pSystemPerfData,
                                                       lpszObject)) {
            pLogEntry->ObjectTitleIndex = CurrentObjectTitleIndex ;
        }
    }

    iIndex = LBAdd (hWndLogEntries, pLogEntry) ;

    if (!bDelayAddAction) {
        if (iIndex == LB_ERR) {
            iIndex = 0 ;
        }

        LBSetSelection (hWndLogEntries, iIndex) ;
        LBSetVisible (hWndLogEntries, iIndex) ;

        LogEntriesChanged (hWndLogEntries) ;
    }

    LogAddEntryToList (&(pLog->pLogEntryFirst), pLogEntry) ;

    return TRUE;
}




BOOL ToggleLogRefresh (HWND hWnd)
{
    PLOG        pLog ;

    pLog = LogData (hWnd) ;

    if (pLog->bManualRefresh)
        SetLogTimer (hWnd, pLog->iIntervalMSecs) ;
    else
        ClearLogTimer (hWnd) ;

    pLog->bManualRefresh = !pLog->bManualRefresh ;
    return (pLog->bManualRefresh) ;
}

BOOL LogRefresh (HWND hWnd)
{
    PLOG        pLog ;

    pLog = LogData (hWnd) ;

    return (pLog->bManualRefresh) ;
}

BOOL  CheckUnusedSystem (LPTSTR      lpszComputer)
{
    BOOL  bStillUse = FALSE ;
    PLOGENTRY      pLogEntry ;
    PLOG           pLog ;

    pLog = LogData (hWndLog) ;

    for (pLogEntry = pLog->pLogEntryFirst; pLogEntry; pLogEntry = pLogEntry->pNextLogEntry)
    {
        if (strsamei(pLogEntry->szComputer, lpszComputer)) {
            bStillUse = TRUE ;
            break ;
        }
    }
    return (bStillUse) ;
}

int SelectLogObjects(LPTSTR      lpszComputer,
                     PPERFDATA   pPerfData,
                     PPERFDATA   *ppLogData)
/*
   Effect:        This routine copies the header from pPerfData
                  to pLogData and initializes the byte length and the
                  number of objects.  It then copies the previously
                  selected objects from pPerfData to pLogData.  If
                  pLogData must be enlarged to accomodate the new data,
                  this routine will enlarge it.

   Returns:       An updated pLogData, and TRUE if at least one object
                  was copied.

*/

{
    PLOGENTRY      pLogEntry ;
    PPERFOBJECT    pObject ;
    DWORD          TotalBytes ;
    DWORD          NumObjects ;
    PBYTE          pNextObject ;
    DWORD          MaxLogDataSize ;
    PLOG           pLog ;

    if (!*ppLogData || !pPerfData)
        return -1 ;

    memcpy ((LPVOID)*ppLogData, (LPVOID)pPerfData, pPerfData->HeaderLength) ;
    TotalBytes = pPerfData->HeaderLength ;
    MaxLogDataSize = MemorySize((LPMEMORY)*ppLogData) ;
    NumObjects = 0;


    pLog = LogData (hWndLog) ;

    for (pLogEntry = pLog->pLogEntryFirst ;
        pLogEntry ;
        pLogEntry = pLogEntry->pNextLogEntry)
    {
        if (strsamei(pLogEntry->szComputer, lpszComputer)) {
            pObject = GetObjectDefByTitleIndex(pPerfData,
                                               pLogEntry->ObjectTitleIndex) ;

            if (pObject) {
                if (MaxLogDataSize < TotalBytes + pObject->TotalByteLength) {
                    *ppLogData = MemoryResize((LPMEMORY)*ppLogData,
                                              TotalBytes + pObject->TotalByteLength) ;
                    if (!*ppLogData)
                        return -1 ;

                }

                pNextObject = (PBYTE) *ppLogData + TotalBytes ;
                memcpy ((LPVOID)pNextObject, (LPVOID)pObject, pObject->TotalByteLength);
                TotalBytes += pObject->TotalByteLength ;
                NumObjects++;
            } else {
            }
        }
    }

    if (!NumObjects)
        return 1 ;

    (*ppLogData)->TotalByteLength = TotalBytes ;
    (*ppLogData)->NumObjectTypes = NumObjects ;

    return 0 ;
}


void LogTimer (HWND hWnd, BOOL bForce)
/*
   Effect:        Perform all actions necessary when the log window
                  receives a timer tic. In particular, if we are
                  collecting data, get a new perf_data_block and add a
                  header entry. If the header block is full, write the
                  data to disk.

   Called By:     LogDisplayDlgProc, in response to a WM_TIMER message.
*/
{
    PLOG           pLog ;
    PPERFSYSTEM       pSystem ;
    BOOL           bWriteIndex ;
    DWORD          iNumSystems ;
    SYSTEMTIME     SystemTime ;
    int            iNoUseSystemDetected = 0 ;

    int               NumberOfSystems = 0 ;
    DWORD             WaitStatus ;
    BOOL              bNeedToStoreName = FALSE ;
    HANDLE            *lpPacketHandles ;


    pLog = LogData (hWnd) ;

    if (pLog->iStatus != iPMStatusCollecting)
        return ;

    if (bForce || !pLog->bManualRefresh) {
        if (pLog->NumberOfHandles == 0) {
            pLog->NumberOfHandles = MAXIMUM_WAIT_OBJECTS ;
            pLog->lpHandles = (HANDLE *) MemoryAllocate (pLog->NumberOfHandles * sizeof (HANDLE)) ;
            if (!pLog->lpHandles) {
                // out of memory, can't go on
                pLog->NumberOfHandles = 0 ;
                return ;
            }
        }

        iNumSystems = SystemCount(pLog->pSystemFirst) ;
        bWriteIndex = TRUE ;

        for (pSystem = pLog->pSystemFirst; pSystem; pSystem = pSystem->pSystemNext) {

            if (pSystem->hStateDataMutex == 0)
                continue ;

            // lock the state data mutex
            WaitStatus = WaitForSingleObject(pSystem->hStateDataMutex, 100L);
            if (WaitStatus == WAIT_OBJECT_0) {
                ResetEvent (pSystem->hPerfDataEvent) ;
                pSystem->StateData = WAIT_FOR_PERF_DATA ;

                if (NumberOfSystems >= pLog->NumberOfHandles) {
                    pLog->NumberOfHandles += MAXIMUM_WAIT_OBJECTS ;
                    pLog->lpHandles = (HANDLE *) MemoryResize (
                                                              pLog->lpHandles,
                                                              pLog->NumberOfHandles * sizeof (HANDLE)) ;
                    if (!pLog->lpHandles) {
                        // out of memory, can't go on
                        pLog->NumberOfHandles = 0 ;
                        return ;
                    }
                }

                // add this to the wait
                pLog->lpHandles [NumberOfSystems] = pSystem->hPerfDataEvent ;
                NumberOfSystems++ ;
            }

            // Send Message to thread to take a data sample
            PostThreadMessage (
                              pSystem->dwThreadID,
                              WM_GET_PERF_DATA,
                              (WPARAM)0,
                              (LPARAM)0) ;

            ReleaseMutex(pSystem->hStateDataMutex);
        }

	Sleep (50);

        // wait for all the data
        if (NumberOfSystems) {
            // increase timeout if we are monitoring lots of systems
            // For every additional 5 systems, add five more seconds
            lpPacketHandles = pLog->lpHandles ;
            do {
                WaitStatus = WaitForMultipleObjects (
                                                    min (NumberOfSystems, MAXIMUM_WAIT_OBJECTS),
                                                    lpPacketHandles,
                                                    TRUE,       // wait for all objects
                                                    DataTimeOut + (NumberOfSystems / 5) * DEFAULT_DATA_TIMEOUT);

                if (WaitStatus == WAIT_TIMEOUT ||
                    NumberOfSystems <= MAXIMUM_WAIT_OBJECTS) {
                    //if (WaitStatus == WAIT_TIMEOUT)
                    //mike2(TEXT("WaitTimeOut for %ld systems\n"), NumberOfSystems) ;
                    break ;
                }

                // more systems --> more to wait
                NumberOfSystems -= MAXIMUM_WAIT_OBJECTS ;
                lpPacketHandles += MAXIMUM_WAIT_OBJECTS ;
            } while (TRUE) ;


            for (pSystem = pLog->pSystemFirst ;
                pSystem ;
                pSystem = pSystem->pSystemNext)
            {
                if (pSystem->hStateDataMutex == 0)
                    continue ;

                // lock the state data mutex
                WaitStatus = WaitForSingleObject(pSystem->hStateDataMutex, 100L);
                if (WaitStatus == WAIT_OBJECT_0) {
                    // check for system disconnect/reconnect
                    if (pSystem->dwSystemState == SYSTEM_DOWN ||
                        pSystem->dwSystemState == SYSTEM_RECONNECT) {
                        BOOL  bDisconnected ;

                        GetLocalTime (&SystemTime) ;
                        if (bDisconnected = (pSystem->dwSystemState == SYSTEM_DOWN)) {
                            pSystem->dwSystemState = SYSTEM_DOWN_RPT ;
                        } else {
                            pSystem->dwSystemState = SYSTEM_RECONNECT_RPT ;
                        }
                        if (!LogWriteSystemBookmark (
                                                    hWnd,
                                                    pSystem->sysName,
                                                    bDisconnected,
                                                    &SystemTime)) {
                            pSystem->StateData = IDLE_STATE ;
                            ReleaseMutex(pSystem->hStateDataMutex);
                            return ;
                        }
                    }

                    if (pSystem->StateData == PERF_DATA_READY) {
                        if (pSystem->bSystemCounterNameSaved == FALSE) {
                            // we have not written the system name to log file.  This
                            // is the case when this system is down when we first
                            // start logging data...
                            bNeedToStoreName = TRUE ;
                        }

                        if (bWriteIndex) {
                            GetLocalTime (&SystemTime) ;
                        }

                        if (SelectLogObjects(pSystem->sysName,
                                             pSystem->pSystemPerfData,
                                             &pLog->pLogData) == 0) {
                            if ( !LogWritePerfData (hWnd, pLog, pLog->pLogData, &SystemTime,
                                                    iNumSystems, bWriteIndex) ) {
                                CloseLogStopTimer(hWnd, pLog) ;

                                pSystem->StateData = IDLE_STATE ;
                                ReleaseMutex(pSystem->hStateDataMutex);

                                return ;
                            }
                            // write an index for only the first system
                            bWriteIndex = FALSE ;
                        } else {
                            if (!bAddLineInProgress) {
                                pSystem->bSystemNoLongerNeeded = TRUE ;
                                iNoUseSystemDetected ++ ;
                            }
                        }
                    }  // if PERF_DATA_READY
                    else if (!bAddLineInProgress &&
                             CheckUnusedSystem (pSystem->sysName) == FALSE) {
                        // we don't need this system any more
                        pSystem->bSystemNoLongerNeeded = TRUE ;
                        iNoUseSystemDetected ++ ;
                    }

                    pSystem->StateData = IDLE_STATE ;
                    ReleaseMutex(pSystem->hStateDataMutex);
                }  // wait for StateDataMutex
            }  // For each system
        }  // if NumberOfSystems

        if (!bWriteIndex) {
            UpdateLogSize (hWnd) ;
        }
    }

    if (iNoUseSystemDetected) {
        DeleteUnusedSystems (&(pLog->pSystemFirst), iNoUseSystemDetected) ;
    }

    if (bNeedToStoreName == TRUE) {
        LogWriteSystemCounterNames (hWnd, pLog) ;
    }
}



BOOL NextIntervalIndexPosition (PLOG pLog, PLOGPOSITION pLP, int *pNumTics)
{
    SYSTEMTIME     SystemTime1 ;
    SYSTEMTIME     SystemTime2 ;
    LOGPOSITION    LP ;
    PLOGINDEX      pIndex ;
    DWORD          TimeDiff ;

    LogPositionSystemTime (pLP, &SystemTime1) ;

    LP = *pLP ;

    while (NextReLogIndexPosition (&LP)) {

        *pNumTics = *pNumTics - 1 ;

        pIndex = IndexFromPosition (&LP) ;
        if (pIndex && IsBookmarkIndex (pIndex)) {
            *pLP = LP ;
            return TRUE ;
        }
        LogPositionSystemTime (&LP, &SystemTime2) ;
        TimeDiff = (DWORD) SystemTimeDifference (&SystemTime1,
                                                 &SystemTime2, TRUE) ;
        if (TimeDiff * 1000 >= pLog->iIntervalMSecs) {
            *pLP = LP ;
            return (TRUE) ;
        }
    }

    return (FALSE) ;
}



BOOL ReLogTimer (HWND hWnd,
                 PLOG pLog,
                 LOGPOSITION lp,
                 BOOL *pWriteBookmark)
{
    PPERFSYSTEM    pSystem ;
    BOOL           bWriteIndex ;
    DWORD          iNumSystems ;
    SYSTEMTIME     SystemTime ;
    PPERFDATA      pPerfData ;

    bWriteIndex = TRUE ;

    // First count number of systems to be logged

    iNumSystems = 0;

    for (pSystem = pLog->pSystemFirst; pSystem; pSystem = pSystem->pSystemNext) {
        pPerfData = LogDataFromPosition (pSystem, &lp) ;
        if (pPerfData) {
            if (SelectLogObjects(pSystem->sysName,
                                 pPerfData,
                                 &pLog->pLogData) == 0) {
                iNumSystems++;
            }
        }
    }

    // Now we can log the data

    for (pSystem = pLog->pSystemFirst ;
        pSystem ;
        pSystem = pSystem->pSystemNext) {  // for
        pPerfData = LogDataFromPosition (pSystem, &lp) ;
        if (pPerfData) {
            // write an index for only the first system
            LogPositionSystemTime (&lp, &SystemTime) ;
            if (SelectLogObjects(pSystem->sysName,
                                 pPerfData,
                                 &pLog->pLogData) == 0) {
                if (*pWriteBookmark) {
                    // only need to write the start bookmark once.
                    *pWriteBookmark = FALSE ;
                    LogWriteStartBookmark (hWnd, &SystemTime) ;
                }
                if ( !LogWritePerfData (hWnd, pLog, pLog->pLogData, &SystemTime,
                                        iNumSystems, bWriteIndex) ) {
                    CloseLogStopTimer(hWnd, pLog) ;
                    return FALSE ;
                } else {
                    // write the index for only the first system logged
                    bWriteIndex = FALSE ;
                }
            }
        }
    }

    return TRUE ;
}


void ReLog (HWND hWndLog, BOOL bSameFile)
{
    PLOG           pLog ;
    LOGPOSITION    lp ;
    //   SYSTEMTIME     SystemTime ;
    PLOGINDEX      pIndex ;
    PBOOKMARK      pBookmark;
    int            iDisplayTics ;

    // bWriteBookmark tell relogtimer to write start bookmark
    BOOL           bWriteBookmark = TRUE ;

    pLog = LogData (hWndLog) ;
    if (StartLog (hWndLog, pLog, bSameFile) == FALSE) {
        return ;
    }

    lp = PlaybackLog.StartIndexPos ;
    iDisplayTics = PlaybackLog.iSelectedTics;

    while (iDisplayTics > 0) {
        pIndex = IndexFromPosition (&lp) ;
        if (pIndex) {
            if (IsBookmarkIndex (pIndex)) {
                pBookmark = (PBOOKMARK) PlaybackSeek (pIndex->lDataOffset) ;
                if (!LogWriteBookmarkData (hWndLog, pBookmark))
                    break;
            } else if (!ReLogTimer (hWndLog, pLog, lp, &bWriteBookmark))
                break ;
        }

        if (!NextIntervalIndexPosition (pLog, &lp, &iDisplayTics))
            break ;

    }
    UpdateLogSize (hWndLog) ;
    CloseLog (hWndLog, pLog) ;
}

// SaveLog is diff than other because we are not saving a "Line"
// We are actually saving an entry in the hWndLogEntries listbox.
// It only contains the system & object name.
BOOL SaveLog (HWND hWndLog, HANDLE hInputFile, BOOL bGetFileName)
{
    int         iIndex, iIndexNum ;
    PLOG        pLog ;
    PLOGENTRY   pLogEntry ;
    LOGENTRY       tempLogEntry ;
    HANDLE         hFile ;
    DISKLOG        DiskLog ;
    PERFFILEHEADER FileHeader ;
    TCHAR          szFileName [256] ;
    BOOL           newFileName = FALSE ;

    pLog = LogData (hWndLog) ;
    if (!pLog) {
        return (FALSE) ;
    }

    if (hInputFile) {
        // use the input file handle if it is available
        // this is the case for saving workspace data
        hFile = hInputFile ;
    } else {
        if (pLogFullFileName) {
            lstrcpy (szFileName, pLogFullFileName) ;
        }
        if (bGetFileName || pLogFullFileName == NULL) {
            //         if (pLogFullFileName == NULL)
            //            {
            //            StringLoad (IDS_LOG_FNAME, szFileName) ;
            //            }

            if (!FileGetName (hWndLog, IDS_LOGFILE, szFileName)) {
                return (FALSE) ;
            }
            newFileName = TRUE ;
        }

        hFile = FileHandleCreate (szFileName) ;

        if (hFile && hFile != INVALID_HANDLE_VALUE && newFileName) {
            ChangeSaveFileName (szFileName, IDM_VIEWLOG) ;
        } else if (!hFile) {
            DlgErrorBox (hWndLog, ERR_CANT_OPEN, szFileName) ;
        }
    }

    if (!hFile || hFile == INVALID_HANDLE_VALUE)
        return (FALSE) ;

    iIndexNum = LBNumItems (hWndLogEntries) ;

    if (!hInputFile) {
        memset (&FileHeader, 0, sizeof (FileHeader)) ;
        lstrcpy (FileHeader.szSignature, szPerfLogSignature) ;
        FileHeader.dwMajorVersion = LogMajorVersion ;
        FileHeader.dwMinorVersion = LogMinorVersion ;

        if (!FileWrite (hFile, &FileHeader, sizeof (PERFFILEHEADER))) {
            goto Exit0 ;
        }
    }

    DiskLog.dwIntervalSecs = pLog->iIntervalMSecs ;
    DiskLog.dwNumLines = iIndexNum ;
    DiskLog.bManualRefresh = pLog->bManualRefresh ;
    DiskLog.perfmonOptions = Options ;
    lstrcpy(DiskLog.LogFileName, pLog->szFilePath) ;

    if (!FileWrite (hFile, &DiskLog, sizeof (DISKLOG))) {
        goto Exit0 ;
    }

    for (iIndex = 0; iIndex < iIndexNum; iIndex++) {
        pLogEntry = LogEntryN (hWndLogEntries, iIndex) ;
        if (pstrsamei (pLogEntry->szComputer, LocalComputerName)) {
            tempLogEntry = *pLogEntry ;
            lstrcpy (tempLogEntry.szComputer, LOCAL_SYS_CODE_NAME) ;
            if (!FileWrite (hFile,
                            &tempLogEntry,
                            sizeof(LOGENTRY)-sizeof(pLogEntry->pNextLogEntry))) {
                goto Exit0 ;
            }
        } else {
            if (!FileWrite (hFile,
                            pLogEntry,
                            sizeof(LOGENTRY)-sizeof(pLogEntry->pNextLogEntry))) {
                goto Exit0 ;
            }
        }
    }

    if (!hInputFile) {
        CloseHandle (hFile) ;
    }

    return (TRUE) ;

    Exit0:
    if (!hInputFile) {
        CloseHandle (hFile) ;

        // only need to report error if not workspace
        DlgErrorBox (hWndLog, ERR_SETTING_FILE, szFileName) ;
    }
    return (FALSE) ;
}

BOOL OpenLogVer1 (HWND hWndLog, HANDLE hFile, DISKLOG *pDiskLog, PLOG
                  pLog, DWORD dwMinorVersion)
{
    int            iIndex, iIndexNum ;
    PLOGENTRY      pLogEntry ;
    LOGENTRY       LogEntry ;
    PPERFSYSTEM    pSystem;

    pLog->iIntervalMSecs = pDiskLog->dwIntervalSecs ;
    if (dwMinorVersion < 3) {
        pLog->iIntervalMSecs *= 1000 ;
    }

    pLog->lFileSize = 0L ;
    if (dwMinorVersion >= 5) {
        lstrcpy (pLog->szFilePath, pDiskLog->LogFileName) ;
    } else {
        strclr (pLog->szFilePath) ;

        // fixed the file pointer for backward compatible with older version.
        //      FileSeekCurrent (hFile, -((int) (sizeof (pDiskLog->LogFileName)))) ;
    }

    pLog->bManualRefresh = pDiskLog->bManualRefresh ;
    iIndexNum = pDiskLog->dwNumLines ;

    LBSetRedraw (hWndLogEntries, FALSE) ;

    bDelayAddAction = TRUE ;

    for (iIndex = 0 ; iIndex < iIndexNum ; iIndex++) {
        if (!FileRead (hFile,
                       &LogEntry,
                       sizeof(LOGENTRY)-sizeof(LogEntry.pNextLogEntry))) {
            break ;
        }

        if (pstrsame (LogEntry.szComputer, LOCAL_SYS_CODE_NAME)) {
            // convert it back to the local name
            lstrcpy (LogEntry.szComputer, LocalComputerName) ;
        }

        LogAddEntry (hWndLog,
                     LogEntry.szComputer,
                     LogEntry.szObject,
                     LogEntry.ObjectTitleIndex,
                     TRUE) ;
    }

    bDelayAddAction = FALSE ;

    LBSetSelection (hWndLogEntries, 0) ;
    LBSetVisible (hWndLogEntries, 0) ;

    LogEntriesChanged (hWndLogEntries) ;

    LBSetRedraw (hWndLogEntries, TRUE) ;

    for (pSystem = pLog->pSystemFirst ;
        pSystem ;
        pSystem = pSystem->pSystemNext) {
        if (pSystem) {
            RemoveObjectsFromSystem (pSystem);
        }
    }


    for (iIndex = 0 ;
        iIndex < iIndexNum ;
        iIndex++)
    {
        pLogEntry = LogEntryN (hWndLogEntries, iIndex) ;

        pSystem = SystemGet (pLog->pSystemFirst, pLogEntry->szComputer);
        if (pSystem) {
            AppendObjectToValueList (
                                    pLogEntry->ObjectTitleIndex,
                                    pSystem->lpszValue);
        }
    }

    if (!strempty(pLog->szFilePath)) {
        if (pLog->pLogEntryFirst &&
            pLog->pSystemFirst) {
            // PostMessage so it will start logging
            PostMessage (
                        hWndLog,
                        WM_START_LOGGING,
                        0,
                        0) ;
        } else {
            HANDLE   hLogFile ;

            // get the file size.
            hLogFile = FileHandleOpen (pLog->szFilePath) ;

            if (hLogFile && hLogFile != INVALID_HANDLE_VALUE) {
                pLog->lFileSize = GetFileSize (hLogFile, NULL);
                CloseHandle (hLogFile) ;
            }
        }
    }

    return (TRUE) ;
}

BOOL OpenLog (HWND hWndLog,
              HANDLE hFile,
              DWORD dwMajorVersion,
              DWORD dwMinorVersion,
              BOOL bLogFile)
{
    PLOG        pLog ;
    DISKLOG     DiskLog ;
    BOOL        bSuccess = TRUE ;

    pLog = LogData (hWndLog) ;
    if (!pLog) {
        bSuccess = FALSE ;
        goto Exit0 ;
    }

    if (!FileRead (hFile, &DiskLog, sizeof (DISKLOG) - sizeof(DiskLog.LogFileName))) {
        bSuccess = FALSE ;
        goto Exit0 ;
    }

    if (dwMajorVersion == 1 && dwMinorVersion >= 5 ||
        dwMajorVersion > 1) {
        // read LogFileName
        if (!FileRead (hFile, DiskLog.LogFileName, sizeof (DiskLog.LogFileName))) {
            bSuccess = FALSE ;
            goto Exit0 ;
        }
    }

    switch (dwMajorVersion) {
        case (1):

            SetHourglassCursor() ;

            ResetLogView (hWndLog) ;

            OpenLogVer1 (hWndLog, hFile, &DiskLog, pLog, dwMinorVersion) ;

            // change to log view if we are opening a
            // log file
            if (bLogFile && iPerfmonView != IDM_VIEWLOG) {
                SendMessage (hWndMain, WM_COMMAND, (LONG)IDM_VIEWLOG, 0L) ;
            }

            if (iPerfmonView == IDM_VIEWLOG) {
                SetPerfmonOptions (&DiskLog.perfmonOptions) ;
            }

            UpdateLogDisplay (hWndLog) ;

            SetArrowCursor() ;

            break ;
    }

    Exit0:

    if (bLogFile) {
        CloseHandle (hFile) ;
    }

    return (bSuccess) ;
}


BOOL LogCollecting (HWND hWndLog)
/*
   Effect:        Return whether the log associated with hWndLog is currently
                  collecting data (writing performance values to disk).
*/
{
    PLOG           pLog ;

    pLog = LogData (hWndLog) ;

    return (pLog->iStatus == iPMStatusCollecting) ;
}


int LogFileSize (HWND hWndLog)
{
    PLOG           pLog ;

    pLog = LogData (hWndLog) ;

    return (pLog->lFileSize) ;
}

BOOL LogWriteSystemBookmark (
                            HWND     hWnd,
                            LPTSTR   lpSystemName,
                            BOOL     bDisconnected,
                            SYSTEMTIME *pSystemTime)
{
    BOOKMARK       Bookmark ;
    TCHAR    NewSystemBookmark [MiscTextLen * 2] ;

    memset (&Bookmark, 0, sizeof (BOOKMARK)) ;

    NewSystemBookmark [0] = TEXT('\0') ;
    StringLoad (
               bDisconnected ?
               IDS_SYSTEM_DOWN :
               IDS_SYSTEM_UP,
               NewSystemBookmark) ;

    lstrcat (NewSystemBookmark, TEXT(" - ")) ;
    lstrcat (NewSystemBookmark, lpSystemName) ;
    Bookmark.SystemTime = *pSystemTime ;
    lstrcpy (Bookmark.szComment, NewSystemBookmark) ;

    return (LogWriteBookmarkData (hWndLog, &Bookmark)) ;
}

BOOL LogWriteStartBookmark (HWND hWnd, SYSTEMTIME *pSystemTime)
{
    BOOKMARK       Bookmark ;
    TCHAR    NewDataBookmark [MiscTextLen] ;

    memset (&Bookmark, 0, sizeof (BOOKMARK)) ;

    NewDataBookmark [0] = TEXT('\0') ;
    StringLoad (IDS_NEWDATA_BOOKMARK, NewDataBookmark) ;
    Bookmark.SystemTime = *pSystemTime ;
    lstrcpy (Bookmark.szComment, NewDataBookmark) ;

    return (LogWriteBookmarkData (hWndLog, &Bookmark)) ;
}

BOOL LogWriteBookmarkData (HWND hWnd, PBOOKMARK pBookmark)
{
    PLOG           pLog ;
    LONG           lDataOffset ;
    BOOL           WriteOK ;

    pLog = LogData (hWndLog) ;
    if (!pLog)
        return (FALSE) ;

    lDataOffset = FileTell (pLog->hFile) ;
    WriteOK = FileWrite (pLog->hFile, pBookmark, sizeof (BOOKMARK)) ;
    if ( WriteOK ) {
        pLog->lFileSize += sizeof (BOOKMARK) ;
        UpdateLogSize (hWndLog) ;

        WriteOK = LogWriteIndex (pLog, LogFileIndexBookmark,
                                 &(pBookmark->SystemTime),
                                 lDataOffset,
                                 0) ;
    }
    if ( !WriteOK ) {
        CloseLog (hWndLog, pLog) ;
        PrepareMenu (GetMenu (hWndMain)) ;
        UpdateLogDisplay (hWndLog) ;
        DlgErrorBox (hWndLog, ERR_LOG_FILE, pLog->szFilePath);
    }
    return WriteOK ;
}



BOOL LogWriteBookmark (HWND hWndLog,
                       LPCTSTR lpszComment)
{
    BOOKMARK       Bookmark ;

    memset (&Bookmark, 0, sizeof (BOOKMARK)) ;

    GetLocalTime (&Bookmark.SystemTime) ;
    lstrcpy (Bookmark.szComment, lpszComment) ;

    return (LogWriteBookmarkData (hWndLog, &Bookmark)) ;
}


BOOL AnyLogLine (void)
{
    if (LBSelection (hWndLogEntries) == LB_ERR) {
        return (FALSE) ;
    } else {
        return (TRUE) ;
    }
}

void ResetLogView (HWND hWndLog)
{
    PLOG        pLog ;

    pLog = LogData (hWndLog) ;

    ChangeSaveFileName (NULL, IDM_VIEWLOG) ;

    if (pLog && pLog->pSystemFirst) {
        ResetLog (hWndLog) ;
    }
}

BOOL ResetLog (HWND hWndLog)
{
    INT_PTR     iIndex ;
    PLOG        pLog ;
    INT_PTR     iEntriesNum ;

    pLog = LogData (hWndLog) ;

    if (LogCollecting (hWndLog)) {
        CloseLog (hWndLog, pLog) ;
    }

    LBSetRedraw (hWndLogEntries, FALSE) ;
    iEntriesNum = LBNumItems (hWndLogEntries) ;

    // only need to zero out the list head
    // each item will be deleted by LogDeleteIndex via the listbox
    pLog->pLogEntryFirst = NULL ;

    // delete each line
    for (iIndex = iEntriesNum - 1; iIndex >= 0; iIndex-- )
    {
        LogDeleteIndex (hWndLogEntries, iIndex) ;
    }

    LBSetRedraw (hWndLogEntries, TRUE) ;

    if (pLog->pSystemFirst) {
        FreeSystems (pLog->pSystemFirst) ;
        pLog->pSystemFirst = NULL ;
    }

    MemoryFree ((LPMEMORY)pLog->pLogData) ;

    pLog->pLogData = (PPERFDATA) MemoryAllocate (STARTING_SYSINFO_SIZE) ;

    LogEntriesChanged (hWndLogEntries) ;

    pLog->iStatus = iPMStatusClosed ;
    UpdateLogDisplay (hWndLog) ;

    return (TRUE) ;
}

BOOL LogDeleteEntry (HWND hWndLog)
{
    INT_PTR     iIndex ;
    PLOG        pLog ;
    BOOL        retCode ;
    int         iEntriesNum ;

    pLog = LogData (hWndLog) ;

    iIndex = LBSelection (hWndLogEntries) ;

    if (iIndex == LB_ERR) {
        retCode = FALSE ;
    } else {
        // remove the current selection
        LogDeleteIndex (hWndLogEntries, iIndex) ;

        iEntriesNum = LBNumItems (hWndLogEntries) ;

        if (iEntriesNum == 0 || iEntriesNum == LB_ERR) {
            // delete the last line or something bad happened,
            // then reset the window.
            ResetLog (hWndLog) ;
        } else {
            // set selection on the item above the deleted item.
            iIndex-- ;
            if (iIndex < 0) {
                iIndex = 0 ;
            }
            LBSetSelection (hWndLogEntries, iIndex) ;
            LBSetVisible (hWndLogEntries, iIndex) ;
        }

        LogEntriesChanged (hWndLogEntries) ;
        retCode = TRUE ;
    }
    return (retCode) ;
}


void ExportLog (void)
{
    HANDLE      hFile ;
    PLOG        pLog ;
    PLOGENTRY   pLogEntry ;
    int         iIndex ;
    int         iIndexNum ;
    CHAR        TempBuff [LongTextLen * 2] ;
    TCHAR       UnicodeBuff [LongTextLen] ;
    TCHAR       UnicodeBuff1 [MiscTextLen] ;
    int         StringLen ;
    LPTSTR      pFileName = NULL ;
    INT         ErrCode = 0 ;

    if (!(pLog = LogData (hWndLog))) {
        return ;
    }

    // see if there is anything to export..
    iIndexNum = LBNumItems (hWndLogEntries) ;
    if (iIndexNum == 0 || iIndexNum == LB_ERR) {
        return ;
    }

    if (!FileGetName (hWndLog, IDS_EXPORTFILE, UnicodeBuff)) {
        // user cancel
        return ;
    }

    pFileName = StringAllocate (UnicodeBuff) ;

    // open the file..
    hFile = FileHandleCreate (UnicodeBuff);

    if (hFile == INVALID_HANDLE_VALUE) {
        // can't open the file
        ErrCode = ERR_CANT_OPEN ;
        return ;
    }

    SetHourglassCursor() ;

    // get header
    StringLoad (IDS_REPORT_HEADER, UnicodeBuff) ;
    ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
    StringLen = strlen (TempBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], LocalComputerName) ;
    strcat (TempBuff, LineEndStr) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        ErrCode = ERR_EXPORT_FILE ;
        goto Exit0 ;
    }

    if (!(strempty(pLog->szFilePath))) {
        // export filename is there is one
        StringLoad (IDS_REPORT_LOGFILE, UnicodeBuff) ;
        ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
        StringLen = strlen (TempBuff) ;
        ConvertUnicodeStr (&TempBuff[StringLen], pLog->szFilePath) ;
        strcat (TempBuff, LineEndStr) ;

        if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
            ErrCode = ERR_EXPORT_FILE ;
            goto Exit0 ;
        }
    }

    // export interval
    StringLoad (IDS_CHARTINT_FORMAT, UnicodeBuff1) ;
    TSPRINTF (UnicodeBuff, UnicodeBuff1,
              (FLOAT) pLog->iIntervalMSecs / (FLOAT) 1000.0) ;
    ConvertDecimalPoint (UnicodeBuff) ;
    ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
    strcat (TempBuff, LineEndStr) ;
    strcat (TempBuff, LineEndStr) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        ErrCode = ERR_EXPORT_FILE ;
        goto Exit0 ;
    }

    // export Labels
    StringLoad (IDS_LABELOBJECT, UnicodeBuff) ;
    ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
    strcat (TempBuff, pDelimiter) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        ErrCode = ERR_EXPORT_FILE ;
        goto Exit0 ;
    }

    StringLoad (IDS_LABELSYSTEM, UnicodeBuff) ;
    ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
    strcat (TempBuff, LineEndStr) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        ErrCode = ERR_EXPORT_FILE ;
        goto Exit0 ;
    }


    // export each counter
    for (iIndex = 0 ; iIndex < iIndexNum ; iIndex++) {  // for

        pLogEntry = LogEntryN (hWndLogEntries, iIndex) ;

        if (!pLogEntry || pLogEntry == (PLOGENTRY)LB_ERR) {
            continue ;
        }

        ConvertUnicodeStr (TempBuff, pLogEntry->szObject) ;
        strcat (TempBuff, pDelimiter) ;

        if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
            ErrCode = ERR_EXPORT_FILE ;
            break ;
        }

        ConvertUnicodeStr (TempBuff, pLogEntry->szComputer) ;
        strcat (TempBuff, LineEndStr) ;

        if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
            ErrCode = ERR_EXPORT_FILE ;
            break ;
        }
    }

    Exit0:

    SetArrowCursor() ;
    CloseHandle (hFile) ;

    if (pFileName) {
        if (ErrCode) {
            DlgErrorBox (hWndGraph, ErrCode, pFileName) ;
        }
        MemoryFree (pFileName) ;
    }
}


LPTSTR   MatchSystemCounters (LPTSTR pBaseSysCounter,
                              long   lBaseSysSize,
                              LPTSTR pSysCounter,
                              long   lSysSize,
                              long   *pMatchPortion)
{
    LPTSTR   pNotMatch = NULL ;
    long     i, lSizeToCompare ;

    *pMatchPortion = 0 ;
    lSizeToCompare = min (lBaseSysSize, lSysSize) / sizeof (TCHAR) ;

    for (i = 0 ; i < lSizeToCompare ; i++, pBaseSysCounter++, pSysCounter++) {
        if (*pBaseSysCounter != *pSysCounter) {
            pNotMatch = pSysCounter ;
            break ;
        }
    }

    if (pNotMatch == NULL) {
        if (lBaseSysSize < lSysSize) {
            // the new system has longer counter names than base system
            // setup the extra portion.
            pNotMatch = pSysCounter ;
        } else {
            // new system counter name is shorter than or equal to
            // the base system counter names
            *pMatchPortion = lSysSize ;
        }
    }

    return (pNotMatch) ;

}

void LogWriteSystemCounterNames (HWND hWnd, PLOG pLog)
{
    long           dwArraySize ;
    PPERFSYSTEM    pSystem = pLog->pSystemFirst ;
    LPTSTR         pMatchLen ;
    LPTSTR         pCounterName ;
    long           lMatchLen, lMatchPortion ;

    for (pSystem = pLog->pSystemFirst ;
        pSystem ;
        pSystem = pSystem->pSystemNext) {
        if (pSystem->bSystemCounterNameSaved == TRUE ||
            pSystem->CounterInfo.dwLastId == 0) {
            // we have either wrote out the counter name for
            // this system, or this system is not connect when
            // reading in the setting file,  skip it then.
            continue ;
        }

        dwArraySize = (pSystem->CounterInfo.dwLastId + 1 ) ;

        if (!pLog->lBaseCounterNameOffset) {
            LogWriteCounterName (hWnd, pSystem, pLog,
                                 (LPTSTR)(pSystem->CounterInfo.TextString + dwArraySize),
                                 0,
                                 pSystem->CounterInfo.dwCounterSize,
                                 0 ) ;
        } else {
            // check for matched characters between this system and the
            // base system
            pCounterName = (LPTSTR)(pSystem->CounterInfo.TextString + dwArraySize) ;
            pMatchLen = MatchSystemCounters (pLog->pBaseCounterName,
                                             pLog->lBaseCounterNameSize,
                                             pCounterName,
                                             pSystem->CounterInfo.dwCounterSize,
                                             &lMatchPortion) ;

            if (pMatchLen) {
                // This system matches part of the base system
                // (all if it has more names)
                lMatchLen = (long) (pMatchLen - pCounterName) * sizeof (TCHAR) ;
                LogWriteCounterName (hWnd, pSystem, pLog,
                                     pMatchLen,
                                     lMatchLen,
                                     pSystem->CounterInfo.dwCounterSize - lMatchLen,
                                     0 ) ;
            } else {
                // This system matches the based system
                LogWriteCounterName (hWnd, pSystem, pLog,
                                     NULL,
                                     lMatchPortion,
                                     0,
                                     0 ) ;
            }
        }
    }
}


BOOL LogWriteCounterName (HWND hWnd,
                          PPERFSYSTEM pSystem,
                          PLOG   pLog,
                          LPTSTR pCounterName,
                          long sizeMatched,
                          long sizeOfData,
                          BOOL bBaseCounterName)
{
    BOOL                 ReadOK ;
    BOOL                 WriteOK ;
    SYSTEMTIME           SystemTime ;
    LOGFILECOUNTERNAME   CounterNameRecord ;
    LOGHEADER            LogFileHeader ;
    long                 lDataOffset, lCurPosition ;
    TCHAR                Dummy [sizeof(DWORD)] ;
    int                  PatchBytes = 0;

    if (pSystem->bSystemCounterNameSaved == TRUE)
        return FALSE ;

    GetLocalTime (&SystemTime) ;

    lCurPosition = FileTell (pLog->hFile) ;

    lstrcpy (CounterNameRecord.szComputer, pSystem->sysName) ;
    CounterNameRecord.lBaseCounterNameOffset = pLog->lBaseCounterNameOffset ;
    CounterNameRecord.lCurrentCounterNameOffset =
    lCurPosition + sizeof (LOGFILECOUNTERNAME) ;
    CounterNameRecord.lMatchLength = sizeMatched ;
    CounterNameRecord.lUnmatchCounterNames = sizeOfData ;
    CounterNameRecord.dwLastCounterId = pSystem->CounterInfo.dwLastId ;
    CounterNameRecord.dwLangId = pSystem->CounterInfo.dwLangId ;
    WriteOK = FileWrite (pLog->hFile, &CounterNameRecord,
                         sizeof (CounterNameRecord)) ;

    if (WriteOK) {
        pLog->lFileSize += sizeof (LOGFILECOUNTERNAME) ;

        if (sizeOfData) {

            WriteOK = FileWrite (pLog->hFile, pCounterName, sizeOfData) ;

            if (WriteOK && (PatchBytes = sizeOfData % sizeof(DWORD)) > 0) {
                // ensure the file is in DWORD boundary.
                WriteOK = FileWrite (pLog->hFile, Dummy, PatchBytes) ;
            }

            if (WriteOK) {
                pLog->lFileSize += sizeOfData + PatchBytes ;

                if (!pLog->lBaseCounterNameOffset) {
                    // this is the first counter name data block
                    // then update the log file header
                    lDataOffset = FileTell (pLog->hFile) ;

                    FileSeekBegin (pLog->hFile, 0L) ;

                    ReadOK = FileRead (pLog->hFile,
                                       &LogFileHeader,
                                       sizeof (LogFileHeader)) ;

                    if (ReadOK) {
                        LogFileHeader.lBaseCounterNameOffset = lCurPosition ;
                        FileSeekBegin (pLog->hFile, 0L) ;
                        WriteOK = FileWrite (pLog->hFile,
                                             &LogFileHeader,
                                             sizeof (LogFileHeader)) ;
                    } else {
                        // flag an error
                        WriteOK = FALSE ;
                    }

                    // retore back to current file position
                    FileSeekBegin (pLog->hFile, lDataOffset) ;

                    if (ReadOK && WriteOK) {
                        // allocate memory to save the base system counter names
                        if (pLog->pBaseCounterName) {
                            MemoryFree (pLog->pBaseCounterName) ;
                        }
                        if (pLog->pBaseCounterName = MemoryAllocate (sizeOfData)) {
                            memcpy (pLog->pBaseCounterName,
                                    pCounterName,
                                    sizeOfData) ;
                            pLog->lBaseCounterNameOffset = lCurPosition ;
                            pLog->lBaseCounterNameSize = sizeOfData ;
                        }
                    }
                }
            }
        }
    }

    if ( WriteOK ) {
        WriteOK = LogWriteIndex (pLog, LogFileIndexCounterName,
                                 &SystemTime,
                                 lCurPosition,
                                 0) ;
    }

    if ( !WriteOK ) {
        CloseLog (hWndLog, pLog) ;
        PrepareMenu (GetMenu (hWndMain)) ;
        UpdateLogDisplay (hWndLog) ;
        DlgErrorBox (hWndLog, ERR_LOG_FILE, pLog->szFilePath);
    } else {
        UpdateLogSize (hWnd) ;
        pSystem->bSystemCounterNameSaved = TRUE ;
    }

    return (TRUE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\logoptns.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "perfmon.h"       // basic defns, windows.h
#include "logoptns.h"      // external declarations for this file

#include "dlgs.h"          // common dialog control IDs
#include "log.h"           // for StartLog, SetLogTimer, CloseLog
#include "fileutil.h"      // file utilities
#include "utils.h"         // various utilities
#include "playback.h"      // for PlayingBackLog
#include "pmhelpid.h"      // Help IDs

//==========================================================================//
//                                Local Data                                //
//==========================================================================//

DWORD          iIntervalMSecs ;
BOOL           bNeedToRelogData ;
BOOL           bNeedToStartLog ;
BOOL           bNeedToSetTimer ;

extern BOOL    LocalManualRefresh ;
static BOOL    bStopButtonClicked ;
extern HWND    hWndLogEntries ;

#if WINVER >= 0x0400
// the win4.0 common dialogs are organized a little differently
// the hDlg passed in not the Master dialog, but only the window
// with the extended controls. This buffer is to save the extended
// controls in.
static  HDLG    hWndDlg = NULL;
#endif

// This is a counter that is init. to 0.  It is incremened by 1
// when the user click the cancel button.
// It is set to -1 when we sent the cancell msg internally.
int            bCancelled ;
TCHAR          szmsgFILEOK[] = FILEOKSTRING ;
DWORD          msgFILEOK ;

//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define LogOptionsOFNStyle                      \
   (OFN_ENABLETEMPLATE | OFN_HIDEREADONLY |     \
    OFN_ENABLEHOOK | OFN_EXPLORER)
//    OFN_SHOWHELP | OFN_ENABLEHOOK)



//==========================================================================//
//                              Local Functions                             //
//==========================================================================//

void
EnableFileControls (
                    HDLG hDlg,
                    BOOL bEnable
                    )
{
    DialogEnable (hDlg, stc3, bEnable) ;
    DialogEnable (hDlg, lst1, bEnable) ;
    DialogEnable (hDlg, stc1, bEnable) ;
    DialogEnable (hDlg, lst2, bEnable) ;
    DialogEnable (hDlg, stc2, bEnable) ;
    DialogEnable (hDlg, cmb1, bEnable) ;
    DialogEnable (hDlg, stc4, bEnable) ;
    DialogEnable (hDlg, cmb2, bEnable) ;
    DialogEnable (hDlg, edt1, bEnable) ;
}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void
static
OnInitDialog (
              HDLG hDlg
              )
{
    PLOG           pLog ;
    int            i ;
    BOOL           DisplayManualRefresh ;
    pLog = LogData (hWndLog) ;

    if (msgFILEOK == 0) {
        msgFILEOK = RegisterWindowMessage(szmsgFILEOK);
    }

    bCancelled = 0 ;

    switch (pLog->iStatus) {
        case iPMStatusClosed:
            //         DialogEnable (hDlg, IDD_LOGOPTPAUSE, FALSE) ;
            break ;

        case iPMStatusPaused:
            EnableFileControls (hDlg, FALSE) ;
            DialogSetText (hDlg, IDD_LOGOPTSTART, IDS_STOP) ;
            //         DialogSetText (hDlg, IDD_LOGOPTPAUSE, IDS_RESUME) ;
            break ;

        case iPMStatusCollecting:
            EnableFileControls (hDlg, FALSE) ;
            DialogSetText (hDlg, IDD_LOGOPTSTART, IDS_STOP) ;
            break ;
    }

    for (i = 0 ;
        i < NumIntervals ;
        i++)
        CBAddInt (DialogControl (hDlg, IDD_LOGOPTINTERVAL), aiIntervals [i]) ;
    DialogSetInterval (hDlg, IDD_LOGOPTINTERVAL, pLog->iIntervalMSecs) ;
    iIntervalMSecs = pLog->iIntervalMSecs ;

    LocalManualRefresh = pLog->bManualRefresh ;
    DisplayManualRefresh = TRUE ;

    if (PlayingBackLog ()) {
        DialogSetText (hDlg, IDD_LOGOPTSTART, IDS_CREATELOGFILE) ;
        DisplayManualRefresh = FALSE ;
    }

    if (LBNumItems (hWndLogEntries) == 0) {
        DialogEnable (hDlg, IDD_LOGOPTSTART, FALSE) ;
        //      DialogEnable (hDlg, IDD_LOGOPTPAUSE, FALSE) ;
    }

    if (DisplayManualRefresh) {
        if (LocalManualRefresh) {
            DialogEnable (hDlg, IDD_LOGOPTINTERVAL, FALSE) ;
            DialogEnable (hDlg, IDD_LOGOPTINTERVALTEXT, FALSE) ;
        }

        CheckRadioButton (hDlg,
                          IDD_LOGOPTIONSMANUALREFRESH,
                          IDD_LOGOPTIONSPERIODIC,
                          LocalManualRefresh ? IDD_LOGOPTIONSMANUALREFRESH :
                          IDD_LOGOPTIONSPERIODIC) ;
    } else {
        DialogEnable (hDlg, IDD_LOGOPTIONSMANUALREFRESH, FALSE) ;
        CheckRadioButton (hDlg,
                          IDD_LOGOPTIONSMANUALREFRESH,
                          IDD_LOGOPTIONSPERIODIC,
                          IDD_LOGOPTIONSPERIODIC) ;
    }


    dwCurrentDlgID = HC_PM_idDlgOptionLog ;

    WindowCenter (hDlg) ;
}


void
OnStart (
         HDLG hDlg
         )
/*
   Effect:        Handle any actions necessary when the user clicks on
                  the "Start/Stop" button.

   Note:          This button could be displaying start or stop, depending
                  on the situation.
*/
{
    PLOG           pLog ;

    pLog = LogData (hDlg) ;

    bStopButtonClicked = FALSE ;
    switch (pLog->iStatus) {
        case iPMStatusClosed:
            if (PlayingBackLog ()) {
                bNeedToRelogData = TRUE ;
            } else {
                FLOAT eTimeInterval ;

                eTimeInterval = DialogFloat (hDlg, IDD_LOGOPTINTERVAL, NULL) ;
                if (eTimeInterval > MAX_INTERVALSEC ||
                    eTimeInterval < MIN_INTERVALSEC) {
                    DlgErrorBox (hDlg, ERR_BADTIMEINTERVAL) ;
                    SetFocus (DialogControl (hDlg, IDD_LOGOPTINTERVAL)) ;
                    EditSetTextEndPos (hDlg, IDD_LOGOPTINTERVAL) ;
                    return ;
                    break ;
                }

                eTimeInterval = eTimeInterval * (FLOAT) 1000.0 + (FLOAT) 0.5 ;
                pLog->iIntervalMSecs = (DWORD) eTimeInterval ;

                iIntervalMSecs = pLog->iIntervalMSecs ;
                bNeedToStartLog = TRUE ;
            }
            break ;

        case iPMStatusCollecting:
        case iPMStatusPaused:
            CloseLog (hWndLog, pLog) ;
            bStopButtonClicked = TRUE ;
            break ;
    }

#if WINVER < 0x0400
    SimulateButtonPush (hDlg, IDD_OK) ;
#else
    SimulateButtonPush (hWndDlg, IDOK) ;
#endif
}


BOOL
static
OnOK (
      HDLG hDlg
      )
/*
   Effect:        Perform any hooked actions needed when the user selects
                  OK in the log options dialog. In particular, if we are
                  currently logging, record the need to relog and CANCEL
                  the dialog, never letting the real dialog proc get the
                  OK. Remember, this is actually a file open dialog that
                  we have perverted. If we let the OK through, the common
                  dialog manager will try to open it and it will inform
                  the user that the file is locked. This way, we let the
                  user click OK, but the dialog thinks we cancelled.

   Called By:     LogOptionsHookProc only.

   Returns:       Whether the message was handled by this function or not.
*/
{
    PLOG           pLog ;


    pLog = LogData (hWndLog) ;
    if (pLog->iStatus == iPMStatusCollecting ||
        pLog->iStatus == iPMStatusPaused) {
        if (LocalManualRefresh != pLog->bManualRefresh) {
            if (!LocalManualRefresh) {
                FLOAT eTimeInterval ;

                eTimeInterval = DialogFloat (hDlg, IDD_LOGOPTINTERVAL, NULL) ;

                if (eTimeInterval > MAX_INTERVALSEC ||
                    eTimeInterval < MIN_INTERVALSEC) {
                    DlgErrorBox (hDlg, ERR_BADTIMEINTERVAL) ;
                    SetFocus (DialogControl (hDlg, IDD_LOGOPTINTERVAL)) ;
                    EditSetTextEndPos (hDlg, IDD_LOGOPTINTERVAL) ;
                    return (FALSE) ;
                }

                eTimeInterval = eTimeInterval * (FLOAT) 1000.0 + (FLOAT) 0.5 ;
                pLog->iIntervalMSecs = (DWORD) eTimeInterval ;
                iIntervalMSecs = pLog->iIntervalMSecs ;
                UpdateLogDisplay (hWndLog) ;
            }
            ToggleLogRefresh (hWndLog) ;
        } else {
            bNeedToSetTimer = TRUE ;
            bCancelled = -1 ;
        }
#if WINVER < 0x0400
        SimulateButtonPush (hDlg, IDD_CANCEL) ;
#else
        SimulateButtonPush (hWndDlg, IDCANCEL) ;
#endif
        return TRUE ;
    } else {
        if (!LocalManualRefresh) {
            FLOAT eTimeInterval ;

            eTimeInterval = DialogFloat (hDlg, IDD_LOGOPTINTERVAL, NULL) ;

            if (eTimeInterval > MAX_INTERVALSEC ||
                eTimeInterval < MIN_INTERVALSEC) {
                DlgErrorBox (hDlg, ERR_BADTIMEINTERVAL) ;
                SetFocus (DialogControl (hDlg, IDD_LOGOPTINTERVAL)) ;
                EditSetTextEndPos (hDlg, IDD_LOGOPTINTERVAL) ;
                return (TRUE) ;
            }
        }
    }
    return FALSE ;
}

void OnPause (HDLG hDlg) { }

BOOL
APIENTRY
LogOptionsHookProc (
                    HWND hDlg,
                                  UINT iMessage,
                                  WPARAM wParam,
                                  LPARAM lParam
                                  )
{
    BOOL           bHandled ;

    bHandled = TRUE ;

    if (iMessage == msgFILEOK) {
        bHandled = OnOK (hDlg) ;
        return (bHandled) ;
    }

    switch (iMessage) {
        case WM_INITDIALOG:
            OnInitDialog (hDlg) ;
            break ;

#if WINVER >= 0x0400
        case WM_NOTIFY:
            {
                LPOFNOTIFY  pOfn;
                pOfn = (LPOFNOTIFY)lParam;

                switch (pOfn->hdr.code) {
                    case CDN_INITDONE:
                        hWndDlg = pOfn->hdr.hwndFrom;
                        OnInitDialog (hWndDlg);
                        break;

                    case CDN_FILEOK:
                        {
                            INT_PTR  iFileIndex ;
                            HWND  hWndCBox;

                            hWndCBox = GetDlgItem (pOfn->hdr.hwndFrom, cmb1); // Type combo box
                            iFileIndex = CBSelection (hWndCBox) ;
                            // the order of the entries in the combo box depends on
                            // the current delimiter character
                            if (pDelimiter == TabStr) {
                                pDelimiter = iFileIndex == 0 ? // 0 = TSV, 1=CSV
                                             TabStr : CommasStr;
                            } else {
                                pDelimiter = iFileIndex == 0 ? // 0 = TSV, 1=CSV
                                             CommasStr : TabStr;
                            }
                        }
                        break;

                    default:
                        break;
                }

            }
            break;

        case WM_HELP:
            {
                LPHELPINFO  pInfo;
                PLOG        pLog ;
                int         iHelpId;

                pInfo = (LPHELPINFO)lParam;
                pLog = LogData (hDlg) ;

                if (pInfo->iContextType == HELPINFO_WINDOW) {
                    // display perfmon help if a "perfmon" control is selected
                    switch (pInfo->iCtrlId) {
                        case IDD_LOGOPTSTART:
                        case IDD_LOGOPTPAUSE:
                            // call winhelp to display text
                            // decide if start or stop button is pressed
                            switch (pLog->iStatus) {
                                case iPMStatusCollecting:
                                case iPMStatusPaused:
                                    // then it's a stop button
                                    iHelpId = IDD_LOGOPTPAUSE;
                                    break;

                                case iPMStatusClosed:
                                    default:
                                    // then it's a start button
                                    iHelpId = IDD_LOGOPTSTART;
                                    break;
                            }
                            if (*pszHelpFile != 0) {
                                bHandled = WinHelp (
                                                   hDlg,
                                                   pszHelpFile,
                                                   HELP_CONTEXTPOPUP,
                                                   iHelpId);
                            } else {
                                DlgErrorBox (hDlg, ERR_HELP_NOT_AVAILABLE);
                            }
                            break;

                        case IDD_LOGOPTINTERVAL:
                        case IDD_LOGOPTIONSPERIODIC:
                        case IDD_LOGOPTIONSMANUALREFRESH:
                            // call winhelp to display text
                            if (*pszHelpFile != 0) {
                                bHandled = WinHelp (
                                                   hDlg,
                                                   pszHelpFile,
                                                   HELP_CONTEXTPOPUP,
                                                   pInfo->iCtrlId);
                            } else {
                                DlgErrorBox (hDlg, ERR_HELP_NOT_AVAILABLE);
                            }
                            break;

                        default:
                            bHandled = FALSE;
                            break;
                    }
                } else {
                    bHandled = FALSE;
                }
            }
            break;
#endif
        case WM_DESTROY:

            {
                FLOAT eTimeInterval ;

                if (!bCancelled) {
                    eTimeInterval = DialogFloat (hDlg, IDD_LOGOPTINTERVAL, NULL) ;
                    if (eTimeInterval > MAX_INTERVALSEC ||
                        eTimeInterval < MIN_INTERVALSEC) {
                        DlgErrorBox (hDlg, ERR_BADTIMEINTERVAL) ;
                    } else {
                        eTimeInterval = eTimeInterval * (FLOAT) 1000.0 + (FLOAT) 0.5 ;
                        iIntervalMSecs = (DWORD) eTimeInterval ;
                    }
                }
#if WINVER >= 0x0400
                hWndDlg = NULL;
#endif

                dwCurrentDlgID = 0 ;
                bHandled = FALSE ;
            }
            break ;

        case WM_COMMAND:
            switch (wParam) {
                case IDD_LOGOPTSTART:
                    OnStart (hDlg) ;
                    break ;

                case IDD_LOGOPTPAUSE:
                    OnPause (hDlg) ;
                    break ;

                case IDD_OK:
                    bHandled = OnOK (hDlg) ;
                    break ;

                case IDD_CANCEL:
                    bCancelled += 1 ;
                    bHandled = FALSE ;
                    break ;

                case IDD_LOGOPTIONSPERIODIC:
                    if (PlayingBackLog()) {
                        break ;
                    }
                    // else fall thru to the following case...
                case IDD_LOGOPTIONSMANUALREFRESH:
                    // check if the Manual refresh is currently checked.
                    // Then toggle the ManualRefresh button
                    LocalManualRefresh =
                    (wParam == IDD_LOGOPTIONSMANUALREFRESH) ;

                    CheckRadioButton (hDlg,
                                      IDD_LOGOPTIONSMANUALREFRESH,
                                      IDD_LOGOPTIONSPERIODIC,
                                      LocalManualRefresh ? IDD_LOGOPTIONSMANUALREFRESH :
                                      IDD_LOGOPTIONSPERIODIC) ;

                    DialogEnable (hDlg, IDD_LOGOPTINTERVAL, !LocalManualRefresh) ;
                    DialogEnable (hDlg, IDD_LOGOPTINTERVALTEXT, !LocalManualRefresh) ;
                    break ;

                case ID_HELP:
                    CallWinHelp (dwCurrentDlgID, hDlg) ;
                    break ;

                default:
                    bHandled = FALSE ;
                    break ;
            }
            break;

        default:
            bHandled = FALSE ;
            break;
    }

    return (bHandled) ;
}


BOOL
DisplayLogOptions (
                   HWND hWndParent,
                        HWND hWndLog
                        )
{
    TCHAR          szFilePath [FilePathLen + 1] ;
    TCHAR          szFileTitle [FilePathLen + 1] ;
    TCHAR          szFileDirectory [FilePathLen + 1] ;
    TCHAR          szCaption [WindowCaptionLen + 1] ;
    OPENFILENAME   ofn ;
    PLOG           pLog ;
    int            RetCode ;
    int            PrevLogSize ;
    BOOL           bSameFile ;

    TCHAR szFilter[LongTextLen] ;
    int   StringLength ;

    szFilter[0] = 0;
    StringLoad (IDS_SAVELOGFILE, szFilter) ;
    StringLength = lstrlen (szFilter) + 1 ;
    LoadString (hInstance, IDS_SAVELOGFILEEXT,
                &szFilter[StringLength],
                (sizeof(szFilter)/sizeof(TCHAR))-StringLength) ;
    StringLength += lstrlen (&szFilter[StringLength]) ;
    szFilter[StringLength+1] = szFilter[StringLength+2] = TEXT('\0') ;

    // This dialog is used to change attributes for an existing log file,
    // and to select the name of a log file to open. Therefore we have
    // different options in these cases.

    pLog = LogData (hWndLog) ;
    if (!strempty (pLog->szFilePath)) {
        FileNameExtension (pLog->szFilePath, szFileTitle) ;
        FileDriveDirectory (pLog->szFilePath, szFileDirectory) ;
        lstrcpy (szFilePath, szFileTitle) ;
    } else {
        szFileTitle[0] = szFileDirectory[0] = TEXT('\0') ;
        StringLoad (IDS_SAVELOGFILEEXT, szFilePath) ;
    }

    StringLoad (IDS_LOGOPTIONS, szCaption) ;

    ofn.lStructSize = sizeof(OPENFILENAME) ;
    ofn.hwndOwner = hWndParent ;
    ofn.hInstance = hInstance ;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = (LPTSTR) NULL;
    ofn.nMaxCustFilter = 0L;
    ofn.nFilterIndex = 1L;
    ofn.lpstrFile = szFilePath ;
    ofn.nMaxFile = FilePathLen ;
    ofn.lpstrFileTitle = szFileTitle ;
    ofn.nMaxFileTitle = FilePathLen ;
    ofn.lpstrInitialDir = szFileDirectory ;
    ofn.lpstrTitle = (LPTSTR) szCaption ;
    ofn.Flags = LogOptionsOFNStyle  ;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = (LPTSTR) NULL;
    ofn.lpfnHook = (LPOFNHOOKPROC) LogOptionsHookProc ;
    ofn.lpTemplateName = idDlgLogOptions ;

    bNeedToRelogData = FALSE;
    bNeedToStartLog = FALSE ;
    bNeedToSetTimer = FALSE ;
    bStopButtonClicked = FALSE ;

    if (GetSaveFileName(&ofn) && !bStopButtonClicked) {
        pLog = LogData (hWndLog) ;

        // save previous log file name & size
        // so we can reset if error
        PrevLogSize = pLog->lFileSize ;

        lstrcpy (szFileTitle, pLog->szFilePath) ;

        bSameFile = pstrsamei (pLog->szFilePath, ofn.lpstrFile) ;

        if (!bSameFile) {
            lstrcpy (pLog->szFilePath, ofn.lpstrFile) ;
        }

        pLog->iIntervalMSecs = iIntervalMSecs ;

        if (bNeedToStartLog) {
            pLog->bManualRefresh = LocalManualRefresh ;
            StartLog (hWndLog, pLog, bSameFile) ;
        } else if (bNeedToRelogData) {
            bNeedToRelogData = FALSE ;
            SetHourglassCursor() ;
            ReLog (hWndLog, bSameFile) ;
            SetArrowCursor() ;
        } else if (LocalManualRefresh != pLog->bManualRefresh) {
            ToggleLogRefresh (hWndLog) ;
        }

        if (!pLog->hFile) {
            if (bNeedToStartLog) {
                // if we get here, that means StartLog has detected
                // problem, just restore the old stuff..
                pLog->lFileSize = PrevLogSize ;
                lstrcpy (pLog->szFilePath, szFileTitle) ;
            }
            // verify if this is a good log file and setup the file size
            else if ((RetCode = CreateLogFile (pLog, FALSE, bSameFile)) != 0) {
                DlgErrorBox (hWndLog, RetCode, pLog->szFilePath);
                pLog->lFileSize = PrevLogSize ;
                lstrcpy (pLog->szFilePath, szFileTitle) ;
            } else {
                // unfortunately, we have to close this file.
                // Otherwise, when we do StartLog, the common dialog
                // will complain that this file is already in-used.
                CloseHandle (pLog->hFile) ;
            }
            pLog->hFile = 0 ;
        }

        //      UpdateLogDisplay (hWndLog) ;
    }


    // Remember, we faked out GetSaveFileName to return FALSE. See OnOK doc.
    if (bNeedToSetTimer) {
        SetLogTimer (hWndLog, iIntervalMSecs) ;
        //      UpdateLogDisplay (hWndLog) ;
    }

    UpdateLogDisplay (hWndLog) ;

    return (TRUE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\owndraw.h ===
#define DIWindow(lpDI)              \
   (lpDI->hwndItem)

#define DIIndex(lpDI)               \
   (lpDI->itemID)

#define DIEntire(lpDI)              \
   (lpDI->itemAction & ODA_DRAWENTIRE)

#define DIFocusChanged(lpDI)        \
   (lpDI->itemAction & ODA_FOCUS)

#define DISelectionChanged(lpDI)    \
   (lpDI->itemAction & ODA_SELECT)

#define DISelected(lpDI)            \
   (lpDI->itemState & ODS_SELECTED)

#define DIDisabled(lpDI)            \
   (lpDI->itemState & ODS_DISABLED)

#define DIFocus(lpDI)               \
   (lpDI->itemState & ODS_FOCUS)




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\menuids.h ===
#define MENUIDTOHELPID        4000


#define FILEMENUPOSITION      0
#define EDITMENUPOSITION      1
#define VIEWMENUPOSITION      2
#define OPTIONSMENUPOSITION   3



// Special "view-independent" menu IDs for the toolbar
#define IDM_TOOLBARADD                 4291
#define IDM_TOOLBARMODIFY              4292
#define IDM_TOOLBARDELETE              4294
#define IDM_TOOLBAROPTIONS             4295
#define IDM_TOOLBARREFRESH             4296
#define IDM_TOOLBARBOOKMARK            4297


//=============================//
// "File" Menu IDs             //
//=============================//

#define IDM_FILENEWCHART            4101
#define IDM_FILEOPENCHART           4102
#define IDM_FILESAVECHART           4103
#define IDM_FILESAVEASCHART         4104
#define IDM_FILEEXPORTCHART         4105

#define IDM_FILENEWALERT            4106
#define IDM_FILEOPENALERT           4107
#define IDM_FILESAVEALERT           4108
#define IDM_FILESAVEASALERT         4109
#define IDM_FILEEXPORTALERT         4110

#define IDM_FILENEWLOG              4111
#define IDM_FILEOPENLOG             4112
#define IDM_FILESAVELOG             4113
#define IDM_FILESAVEASLOG           4114
#define IDM_FILEEXPORTLOG           4115

#define IDM_FILENEWREPORT           4116
#define IDM_FILEOPENREPORT          4117
#define IDM_FILESAVEREPORT          4118
#define IDM_FILESAVEASREPORT        4119
#define IDM_FILEEXPORTREPORT        4120

#define IDM_FILESAVEWORKSPACE       4121
#define IDM_FILEPRINTERSETUP        4125
#define IDM_FILEEXIT                4127


//=============================//
// "Edit" Menu IDs             //
//=============================//


#define IDM_EDITADDCHART            4201
#define IDM_EDITMODIFYCHART         4202
#define IDM_EDITCLEARCHART          4203
#define IDM_EDITDELETECHART         4204

#define IDM_EDITADDALERT            4205
#define IDM_EDITMODIFYALERT         4206
#define IDM_EDITCLEARALERT          4207
#define IDM_EDITDELETEALERT         4208

#define IDM_EDITADDLOG              4209
#define IDM_EDITMODIFYLOG           4210
#define IDM_EDITCLEARLOG            4211
#define IDM_EDITDELETELOG           4212

#define IDM_EDITADDREPORT           4213
#define IDM_EDITMODIFYREPORT        4214
#define IDM_EDITCLEARREPORT         4215
#define IDM_EDITDELETEREPORT        4216

#define IDM_EDITTIMEWINDOW          4217


//=============================//
// "View" Menu IDs             //
//=============================//

#define IDM_VIEWCHART               4301
#define IDM_VIEWALERT               4302
#define IDM_VIEWLOG                 4303
#define IDM_VIEWREPORT              4304

// IDM_WORKSPACE is not a view nor menu, just a define
#define IDM_WORKSPACE               4305  


//=============================//
// "Options" Menu IDs          //
//=============================//


#define IDM_OPTIONSCHART            4401

#define IDM_OPTIONSALERT            4403

#define IDM_OPTIONSLOG              4405

#define IDM_OPTIONSREPORT           4407

#define IDM_OPTIONSMANUALREFRESH    4409

#define IDM_OPTIONSDISPLAYMENU      4408
#define IDM_OPTIONSDISPLAYTOOL      4409
#define IDM_OPTIONSDISPLAYSTATUS    4410
#define IDM_OPTIONSDISPLAYONTOP     4411

#define IDM_OPTIONSBOOKMARK         4413
#define IDM_OPTIONSDATASOURCE       4415

#define IDM_OPTIONSREFRESHNOWCHART  4416
#define IDM_OPTIONSREFRESHNOWALERT  4417
#define IDM_OPTIONSREFRESHNOWLOG    4418
#define IDM_OPTIONSREFRESHNOWREPORT 4419

// no really a menu item.  This is sent from the ^G for now
// to turn the legend on/off.
#define IDM_OPTIONSLEGENDONOFF      4420

//=============================//
// "Help" Menu IDs             //
//=============================//


#define IDM_HELPCONTENTS            4501
#define IDM_HELPSEARCH              4502
#define IDM_HELPHELP                4503
#define IDM_HELPABOUT               4504


//=============================//
// "System" Menu IDs           //
//=============================//

#define IDM_SYSTEMRESTORE           4910
#define IDM_SYSTEMMOVE              4911
#define IDM_SYSTEMSIZE              4912
#define IDM_SYSTEMMINIMIZE          4913
#define IDM_SYSTEMMAXIMIZE          4914
#define IDM_SYSTEMCLOSE             4915
#define IDM_SYSTEMSWITCHTO          4916

#define IDM_FIRSTMENUID             IDM_FILENEWCHART
#define IDM_LASTMENUID              IDM_SYSTEMSWITCHTO


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\log.h ===
#define LOG_ENTRY_NOT_FOUND (-1)

#define szDefaultLogDirectory    TEXT("")
#define szDefaultLogFileName     TEXT("perfmon.log")

#define iDefaultLogIntervalSecs  15


#define IsDataIndex(pIndex)      \
   (pIndex->uFlags & LogFileIndexData)


#define IsBookmarkIndex(pIndex)  \
   (pIndex->uFlags & LogFileIndexBookmark)

#define IsCounterNameIndex(pIndex)  \
   (pIndex->uFlags & LogFileIndexCounterName)


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

#if 0
PLOG LogData (HWND hWndLog) ;
#endif
#define LogData(hWndLog)      \
   (&Log)

HWND CreateLogWindow (HWND hWndParent) ;

LRESULT APIENTRY LogWndProc (HWND hWnd,
                               WORD wMsg,
                               DWORD wParam,
                               LONG lParam) ;

BOOL LogInitializeApplication  (void) ;


void UpdateLogDisplay (HWND hWnd) ;


BOOL StartLog (HWND hWnd, PLOG pLog, BOOL bSameFile) ;

BOOL CloseLog (HWND hWnd, PLOG pLog) ;


BOOL LogAddEntry (HWND hWndLog, 
                  LPTSTR lpszComputer,
                  LPTSTR lpszObject,
                  DWORD ObjectTitleIndex,
                  BOOL  bGetObjectTitleIndex) ;


void SetLogTimer (HWND hWnd,
                  int iIntervalSecs) ;



BOOL LogRefresh (HWND hWnd) ;
BOOL ToggleLogRefresh (HWND hWnd) ;


void LogTimer (HWND hWnd, BOOL bForce) ;


void ReLog (HWND hWndLog, BOOL bSameFile) ;


BOOL OpenLog (HWND hWndLog,
              HANDLE hFile,
              DWORD dwMajorVersion,
              DWORD dwMinorVersion,
              BOOL bLogFile) ;


BOOL LogCollecting (HWND hWndLog) ;


int LogFileSize (HWND hWndLog) ;



BOOL LogWriteBookmark (HWND hWndLog,
                       LPCTSTR lpszComment) ;


DWORD LogFindEntry (LPTSTR lpszComputer, DWORD ObjectTitleIndex) ;

BOOL ResetLog  (HWND hWndLog) ;
void ResetLogView  (HWND hWndLog) ;
BOOL LogDeleteEntry  (HWND hWndLog) ;
BOOL AnyLogLine (void) ;

BOOL SaveLog (HWND hWndLog, HANDLE hInputFile, BOOL bGetFileName) ;

void ExportLog (void) ;

int CreateLogFile (PLOG pLog, BOOL bCreateFile, BOOL bSameFile) ;

BOOL LogWriteCounterName (HWND hWnd,
                          PPERFSYSTEM pSystem,
                          PLOG   pLog,
                          LPTSTR pCounterName,
                          long sizeMatched,
                          long sizeOfData,
                          BOOL bBaseCounterName) ;

void LogWriteSystemCounterNames (HWND hWnd, PLOG pLog) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\perfdata.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include <string.h>     // strupr
#include <stdio.h>   // for sprintf.
#include "perfmon.h"
#include "utils.h"

#include "pmemory.h"        // for MemoryXXX (mallloc-type) routines
#include "playback.h"   // for PlayingBackLog
#include "perfdata.h"   // external declarations for this file
#include "system.h"     // for DeleteUnusedSystems
#include "line.h"       // for LineFind???()
#include "perfmops.h"   // for AppendObjectToValueList()
#include "perfmsg.h"    // for event log messages

//==========================================================================//
//                                  Constants                               //
//==========================================================================//

TCHAR NamesKey[] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
TCHAR Counters[] = L"Counters";
TCHAR Help[] = L"Help";
TCHAR LastHelp[] = L"Last Help";
TCHAR LastCounter[] = L"Last Counter";
TCHAR SysVersion[] = L"Version";
TCHAR CounterNameStr[] = L"Counter ";
TCHAR ExplainNameStr[] = L"Explain ";

#define szPerfSubkey      (NULL)
TCHAR   NULL_NAME[] = L" ";
#define RESERVED    0L

TCHAR          DefaultLangId[4] ;
TCHAR          EnglishLangId[4] ;

static   HANDLE            *lpHandles ;
static   int               NumberOfHandles = 0 ;

//==========================================================================//
//                                   Macros                                 //
//==========================================================================//



//==========================================================================//
//                                Local Data                                //
//==========================================================================//


// When the conversion of this code is complete, this will be the *only*
// allocated copy of the performance data.  It will monotonically grow
// to hold the largest of the system's performance data.

// PPERFDATA      pGlobalPerfData ;

//==========================================================================//
//                              Local Functions                             //
//==========================================================================//

NTSTATUS
AddNamesToArray (
                LPTSTR pNames,
                DWORD    dwLastID,
                LPWSTR   *lpCounterId
                ) ;

//======================================//
// Object Accessors                     //
//======================================//


void
ObjectName (
           PPERFSYSTEM pSystem,
           PPERFOBJECT pObject,
           LPTSTR lpszName,
           int iLen
           )
{
    strclr (lpszName) ;
    QueryPerformanceName (pSystem,
                          pObject->ObjectNameTitleIndex,
                          0, iLen, lpszName, FALSE) ;
}



//======================================//
// Counter Accessors                    //
//======================================//


PPERFINSTANCEDEF
FirstInstance(
             PPERFOBJECT pObjectDef
             )
{
    return (PPERFINSTANCEDEF )
    ((PCHAR) pObjectDef + pObjectDef->DefinitionLength);
}


PPERFINSTANCEDEF
NextInstance(
            PPERFINSTANCEDEF pInstDef
            )
{
    PERF_COUNTER_BLOCK *pCounterBlock;

    pCounterBlock = (PERF_COUNTER_BLOCK *)
                    ((PCHAR) pInstDef + pInstDef->ByteLength);

    return (PPERFINSTANCEDEF )
    ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}




LPWSTR
GetInstanceName(
               PPERFINSTANCEDEF  pInstDef
               )
{
    return (LPWSTR) ((PCHAR) pInstDef + pInstDef->NameOffset);
}

DWORD
GetAnsiInstanceName (
                    PPERFINSTANCEDEF pInstance,
                    LPWSTR lpszInstance,
                    DWORD dwCodePage
                    )
{
    LPSTR   szSource;
    DWORD   dwLength;

    szSource = (LPSTR)GetInstanceName(pInstance);

    // the locale should be set here

    // pInstance->NameLength == the number of bytes (chars) in the string
    dwLength = mbstowcs (lpszInstance, szSource, pInstance->NameLength);
    lpszInstance[dwLength] = 0; // null terminate string buffer

    return dwLength;
}

DWORD
GetUnicodeInstanceName (
                       PPERFINSTANCEDEF pInstance,
                       LPWSTR lpszInstance
                       )
{
    LPWSTR   wszSource;
    DWORD    dwLength;

    wszSource = GetInstanceName(pInstance) ;

    // pInstance->NameLength == length of string in BYTES so adjust to
    // number of wide characters here
    dwLength = pInstance->NameLength / sizeof(WCHAR);

    wcsncpy (lpszInstance,
             (LPWSTR)wszSource,
             dwLength);

    lpszInstance[dwLength] = 0;

    return (DWORD)(wcslen(lpszInstance)); // just incase there's null's in the string

}

void
GetInstanceNameStr (
                   PPERFINSTANCEDEF pInstance,
                   LPWSTR lpszInstance,
                   DWORD dwCodePage
                   )
{
    DWORD  dwCharSize;
    DWORD  dwLength;

    if (dwCodePage > 0) {
        dwCharSize = sizeof(CHAR);
        dwLength = GetAnsiInstanceName (pInstance, lpszInstance, dwCodePage);
    } else { // it's a UNICODE name
        dwCharSize = sizeof(WCHAR);
        dwLength = GetUnicodeInstanceName (pInstance, lpszInstance);
    }
    // sanity check here...
    // the returned string length (in characters) plus the terminating NULL
    // should be the same as the specified length in bytes divided by the
    // character size. If not then the codepage and instance data type
    // don't line up so test that here

    if ((dwLength + 1) != (pInstance->NameLength / dwCharSize)) {
        // something isn't quite right so try the "other" type of string type
        if (dwCharSize == sizeof(CHAR)) {
            // then we tried to read it as an ASCII string and that didn't work
            // so try it as a UNICODE (if that doesn't work give up and return
            // it any way.
            dwLength = GetUnicodeInstanceName (pInstance, lpszInstance);
        } else if (dwCharSize == sizeof(WCHAR)) {
            // then we tried to read it as a UNICODE string and that didn't work
            // so try it as an ASCII string (if that doesn't work give up and return
            // it any way.
            dwLength = GetAnsiInstanceName (pInstance, lpszInstance, dwCodePage);
        }
    }
}

void
GetPerfComputerName(
                   PPERFDATA pPerfData,
                   LPTSTR lpszComputerName
                   )
{
    lstrcpy(lpszComputerName, szComputerPrefix) ;
    if (pPerfData) {
        wcsncpy (&lpszComputerName[2],
                 (LPWSTR)((PBYTE) pPerfData + pPerfData->SystemNameOffset),
                 pPerfData->SystemNameLength/sizeof(WCHAR)) ;
    } else {
        lpszComputerName[0] = TEXT('\0') ;
    }
}


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


int
CounterIndex (
             PPERFCOUNTERDEF pCounterToFind,
             PPERFOBJECT pObject
             )
/*
   Effect:        Return the index ("counter number") of pCounterToFind
                  within pObject. If the counter doesnt belong to pObject,
                  return -1.
*/
{
    PPERFCOUNTERDEF   pCounter ;
    UINT              iCounter ;

    for (iCounter = 0, pCounter = FirstCounter (pObject) ;
        iCounter < pObject->NumCounters ;
        iCounter++, pCounter = NextCounter (pCounter)) {
        if (pCounter->CounterNameTitleIndex ==
            pCounterToFind->CounterNameTitleIndex)
            return (iCounter) ;
    }

    return (-1) ;
}


HKEY
OpenSystemPerfData (
                   IN LPCTSTR lpszSystem
                   )
{
    HKEY    hKey = NULL;
    LONG    lStatus;


    lStatus = ERROR_CANTOPEN;   // default error if none is returned

    if (IsLocalComputer(lpszSystem) || PlayingBackLog()) {
        bCloseLocalMachine = TRUE ;
        SetLastError (ERROR_SUCCESS);
        return HKEY_PERFORMANCE_DATA;
    } else {
        // Must be a remote system
        try {
            lStatus = RegConnectRegistry (
                                         (LPTSTR)lpszSystem,
                                         HKEY_PERFORMANCE_DATA,
                                         &hKey);
        }finally {
            if (lStatus != ERROR_SUCCESS) {
                SetLastError (lStatus);
                hKey = NULL;
            }
        }
    }
    return (hKey);

}

LPWSTR
*AddNewName(
           HKEY    hKeyNames,
           PCOUNTERTEXT  pCounterInfo,
           LPWSTR  CounterBuffer,
           LPWSTR  HelpBuffer,
           DWORD   dwLastId,
           DWORD   dwCounterSize,
           DWORD   dwHelpSize,
           LANGID  LangIdUsed
           )
{
    LPWSTR  *lpReturnValue;
    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwValueType;
    LONG    lWin32Status = ERROR_SUCCESS;
    NTSTATUS    Status;
    DWORD   dwLastError;

    dwArraySize = (dwLastId + 1 ) * sizeof(LPWSTR);
    lpReturnValue = MemoryAllocate (dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue)
        goto ERROR_EXIT;

    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueEx (
                                   hKeyNames,
                                   CounterBuffer,
                                   RESERVED,
                                   &dwValueType,
                                   (LPVOID)lpCounterNames,
                                   &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto ERROR_EXIT;

    if (bExplainTextButtonHit) {
        dwBufferSize = dwHelpSize;
        lWin32Status = RegQueryValueEx (
                                       hKeyNames,
                                       HelpBuffer,
                                       RESERVED,
                                       &dwValueType,
                                       (LPVOID)lpHelpText,
                                       &dwBufferSize);

        if (lWin32Status != ERROR_SUCCESS) goto ERROR_EXIT;
    }

    // load counter array items
    Status = AddNamesToArray (lpCounterNames, dwLastId, lpCounterId);
    if (Status != ERROR_SUCCESS) goto ERROR_EXIT;

    if (bExplainTextButtonHit) {
        Status = AddNamesToArray (lpHelpText, dwLastId, lpCounterId);
    }

    if (Status != ERROR_SUCCESS) goto ERROR_EXIT;

    if (pCounterInfo) {
        pCounterInfo->dwLastId = dwLastId;
        pCounterInfo->dwLangId = LangIdUsed;
        pCounterInfo->dwHelpSize = dwHelpSize;
        pCounterInfo->dwCounterSize = dwCounterSize;
    }

    return lpReturnValue;

    ERROR_EXIT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
    }

    if (lpReturnValue) {
        MemoryFree ((LPVOID)lpReturnValue);
    }

    return NULL;
}


LPWSTR
*BuildNewNameTable(
                  PPERFSYSTEM   pSystem,
                  LPWSTR        lpszLangId,     // unicode value of Language subkey
                  PCOUNTERTEXT  pCounterInfo,
                  LANGID        iLangId,         // lang ID of the lpszLangId
                  DWORD         dwLastId
                  )
/*++

BuildNewNameTable

Arguments:

    lpszLangId
            The unicode id of the language to look up. (English is 0x409)

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{
    LONG    lWin32Status;
    DWORD   dwValueType;
    DWORD   dwLastError;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    HKEY    hKeyNames;
    TCHAR   CounterBuffer [MiscTextLen] ;
    TCHAR   ExplainBuffer [MiscTextLen] ;
    TCHAR   subLangId [ShortTextLen] ;
    LANGID  LangIdUsed = iLangId;


    //initialize local variables
    hKeyNames = pSystem->sysDataKey;


    // check for null arguments and insert defaults if necessary
    if (!lpszLangId) {
        lpszLangId = DefaultLangId;
        LangIdUsed = iLanguage ;
    }

    // get size of counter names and add that to the arrays
    lstrcpy (CounterBuffer, CounterNameStr);
    lstrcat (CounterBuffer, lpszLangId);

    lstrcpy (ExplainBuffer, ExplainNameStr);
    lstrcat (ExplainBuffer, lpszLangId);

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
                                   hKeyNames,
                                   CounterBuffer,
                                   RESERVED,
                                   &dwValueType,
                                   NULL,
                                   &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        // check for ACCESS_DENIED error first since if it's here
        // it will be returned on all subsequent calls, we might as well
        // bail out now.

        if (lWin32Status == ERROR_ACCESS_DENIED) {
            goto BNT_BAILOUT;
        }

        // try take out the country ID
        LangIdUsed = MAKELANGID (LangIdUsed & 0x0ff, LANG_NEUTRAL);
        TSPRINTF (subLangId, TEXT("%03x"), LangIdUsed);
        lstrcpy (CounterBuffer, CounterNameStr);
        lstrcat (CounterBuffer, subLangId);

        lstrcpy (ExplainBuffer, ExplainNameStr);
        lstrcat (ExplainBuffer, subLangId);

        dwBufferSize = 0;
        lWin32Status = RegQueryValueEx (
                                       hKeyNames,
                                       CounterBuffer,
                                       RESERVED,
                                       &dwValueType,
                                       NULL,
                                       &dwBufferSize);
    }

    if (lWin32Status != ERROR_SUCCESS) {
        // try the EnglishLangId
        if (!strsame(EnglishLangId, subLangId)) {

            lstrcpy (CounterBuffer, CounterNameStr);
            lstrcat (CounterBuffer, EnglishLangId);

            lstrcpy (ExplainBuffer, ExplainNameStr);
            lstrcat (ExplainBuffer, EnglishLangId);

            LangIdUsed = iEnglishLanguage ;

            dwBufferSize = 0;
            lWin32Status = RegQueryValueEx (
                                           hKeyNames,
                                           CounterBuffer,
                                           RESERVED,
                                           &dwValueType,
                                           NULL,
                                           &dwBufferSize);
        }
    }

    // Fail, too bad...
    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    dwCounterSize = dwBufferSize;

    // If ExplainText is needed, then
    // get size of help text and add that to the arrays

    if (bExplainTextButtonHit) {
        dwBufferSize = 0;
        lWin32Status = RegQueryValueEx (
                                       hKeyNames,
                                       ExplainBuffer,
                                       RESERVED,
                                       &dwValueType,
                                       NULL,
                                       &dwBufferSize);

        if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

        dwHelpSize = dwBufferSize;
    } else {
        dwHelpSize = 0;
    }

    return (AddNewName(
                      hKeyNames,
                      pCounterInfo,
                      CounterBuffer,
                      ExplainBuffer,
                      dwLastId,
                      dwCounterSize,
                      dwHelpSize,
                      LangIdUsed));


    BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
        // set the LastError value since a null pointer will
        // be returned which doesn't tell much to the caller
        SetLastError (lWin32Status);
    }

    return NULL;
}


LPWSTR *
BuildOldNameTable(
                 HKEY          hKeyRegistry,   // handle to registry db with counter names
                 LPWSTR        lpszLangId,     // unicode value of Language subkey
                 PCOUNTERTEXT  pCounterInfo,
                 LANGID        iLangId,         // lang ID of the lpszLangId
                 DWORD         dwLastId
                 )
/*++

BuildOldNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (English is 0x409)

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{
    LPWSTR  *lpReturnValue = NULL;

    LONG    lWin32Status;
    DWORD   dwValueType;
    DWORD   dwLastError;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    HKEY    hKeyNames;
    TCHAR   tempBuffer [MiscTextLen] ;
    TCHAR   subLangId [ShortTextLen] ;
    LPWSTR  lpValueNameString;
    LANGID  LangIdUsed = iLangId;
    TCHAR   Slash[2];

    //initialize local variables
    hKeyNames = NULL;
    Slash[0] = L'\\';
    Slash[1] = L'\0';

    // check for null arguments and insert defaults if necessary
    if (!lpszLangId) {
        lpszLangId = DefaultLangId;
        LangIdUsed = iLanguage ;
    }

    // get size of string buffer
    lpValueNameString = tempBuffer ;

    lstrcpy (lpValueNameString, NamesKey);
    lstrcat (lpValueNameString, Slash);
    lstrcat (lpValueNameString, lpszLangId);

    lWin32Status = RegOpenKeyEx (
                                hKeyRegistry,
                                lpValueNameString,
                                RESERVED,
                                KEY_READ,
                                &hKeyNames);

    if (lWin32Status != ERROR_SUCCESS) {
        // check for ACCESS_DENIED error first since if it's here
        // it will be returned on all subsequent calls, we might as well
        // bail out now.

        if (lWin32Status == ERROR_ACCESS_DENIED) {
            goto BNT_BAILOUT;
        }

        // try take out the country ID
        LangIdUsed = MAKELANGID (LangIdUsed & 0x0ff, LANG_NEUTRAL);
        TSPRINTF (subLangId, TEXT("%03x"), LangIdUsed);
        lstrcpy (lpValueNameString, NamesKey);
        lstrcat (lpValueNameString, Slash);
        lstrcat (lpValueNameString, subLangId);

        lWin32Status = RegOpenKeyEx (
                                    hKeyRegistry,
                                    lpValueNameString,
                                    RESERVED,
                                    KEY_READ,
                                    &hKeyNames);
    }

    if (lWin32Status != ERROR_SUCCESS) {
        // try the EnglishLangId
        if (!strsame(EnglishLangId, subLangId)) {

            lstrcpy (lpValueNameString, NamesKey);
            lstrcat (lpValueNameString, Slash);
            lstrcat (lpValueNameString, EnglishLangId);

            LangIdUsed = iEnglishLanguage ;

            lWin32Status = RegOpenKeyEx (
                                        hKeyRegistry,
                                        lpValueNameString,
                                        RESERVED,
                                        KEY_READ,
                                        &hKeyNames);
        }
    }

    // Fail, too bad...
    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get size of counter names and add that to the arrays


    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
                                   hKeyNames,
                                   Counters,
                                   RESERVED,
                                   &dwValueType,
                                   NULL,
                                   &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwCounterSize = dwBufferSize;

    // If ExplainText is needed, then
    // get size of help text and add that to the arrays

    if (bExplainTextButtonHit) {
        dwBufferSize = 0;
        lWin32Status = RegQueryValueEx (
                                       hKeyNames,
                                       Help,
                                       RESERVED,
                                       &dwValueType,
                                       NULL,
                                       &dwBufferSize);

        if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

        dwHelpSize = dwBufferSize;
    } else {
        dwHelpSize = 0;
    }

    lpReturnValue = AddNewName(
                              hKeyNames,
                              pCounterInfo,
                              Counters,
                              Help,
                              dwLastId,
                              dwCounterSize,
                              dwHelpSize,
                              LangIdUsed);

    RegCloseKey (hKeyNames);

    return lpReturnValue;

    BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
        // set the LastError value since a null pointer will
        // be returned which doesn't tell much to the caller
        SetLastError (lWin32Status);
    }

    if (lpReturnValue) {
        MemoryFree ((LPVOID)lpReturnValue);
    }

    if (hKeyNames) RegCloseKey (hKeyNames);

    return NULL;
}


LPWSTR *
BuildNameTable(
              PPERFSYSTEM   pSysInfo,
              HKEY          hKeyRegistry,   // handle to registry db with counter names
              LPWSTR        lpszLangId,     // unicode value of Language subkey
              PCOUNTERTEXT  pCounterInfo,
              LANGID        iLangId         // lang ID of the lpszLangId
              )
/*++

BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (English is 0x409)

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{

    LPWSTR  *lpReturnValue;
    LONG    lWin32Status;
    DWORD   dwLastError;
    DWORD   dwValueType;
    DWORD   dwLastHelp;
    DWORD   dwLastCounter;
    DWORD   dwLastId;
    DWORD   dwBufferSize;
    HKEY    hKeyValue;
    DWORD   dwSystemVersion;


    //initialize local variables
    lpReturnValue = NULL;
    hKeyValue = NULL;


    // open registry to get number of items for computing array size

    lWin32Status = RegOpenKeyEx (
                                hKeyRegistry,
                                NamesKey,
                                RESERVED,
                                KEY_READ,
                                &hKeyValue);

    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof (dwLastHelp);
    lWin32Status = RegQueryValueEx (
                                   hKeyValue,
                                   LastHelp,
                                   RESERVED,
                                   &dwValueType,
                                   (LPBYTE)&dwLastHelp,
                                   &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    dwBufferSize = sizeof (dwLastCounter);
    lWin32Status = RegQueryValueEx (
                                   hKeyValue,
                                   LastCounter,
                                   RESERVED,
                                   &dwValueType,
                                   (LPBYTE)&dwLastCounter,
                                   &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    if (dwLastCounter >= dwLastHelp) {
        dwLastId = dwLastCounter;
    } else {
        dwLastId = dwLastHelp;
    }

    // get system version
    dwBufferSize = sizeof (dwSystemVersion);
    lWin32Status = RegQueryValueEx (
                                   hKeyValue,
                                   SysVersion,
                                   RESERVED,
                                   &dwValueType,
                                   (LPBYTE)&dwSystemVersion,
                                   &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        pSysInfo->SysVersion = 0x10000;
    } else {
        pSysInfo->SysVersion = dwSystemVersion;
    }

    if (pSysInfo->SysVersion <= 0x10000) {
        lpReturnValue = BuildOldNameTable (
                                          hKeyRegistry,
                                          lpszLangId,
                                          pCounterInfo,
                                          iLangId,
                                          dwLastId) ;
    } else {
        lpReturnValue = BuildNewNameTable (
                                          pSysInfo,
                                          lpszLangId,
                                          pCounterInfo,
                                          iLangId,
                                          dwLastId) ;
    }

    RegCloseKey (hKeyValue);
    return lpReturnValue;

    BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
        // set the LastError value since a null pointer will
        // be returned which doesn't tell much to the caller
        SetLastError (lWin32Status);
    }
    if (hKeyValue) RegCloseKey (hKeyValue);
    return NULL;
}

DWORD
GetSystemKey (
             PPERFSYSTEM pSysInfo,
             HKEY *phKeyMachine
             )
{
    DWORD   dwStatus;

    // connect to system registry

    if (IsLocalComputer(pSysInfo->sysName) ||
        (PlayingBackLog() && PlaybackLog.pBaseCounterNames)) {
        *phKeyMachine = HKEY_LOCAL_MACHINE;
    } else {
        try {
            dwStatus = RegConnectRegistry (
                                          pSysInfo->sysName,
                                          HKEY_LOCAL_MACHINE,
                                          phKeyMachine);

            if (dwStatus != ERROR_SUCCESS) {
                if (PlayingBackLog()) {
                    // If remote machine is not on and we are
                    // playing back log, then, use the counters from
                    // local machine.
                    *phKeyMachine = HKEY_LOCAL_MACHINE;
                } else {
                    return dwStatus;
                }
            }
        }finally {
            ; // nothing
        }
    }
    return 0;
}


DWORD
GetSystemNames(
              PPERFSYSTEM pSysInfo
              )
{
    HKEY    hKeyMachine = 0;
    DWORD   dwStatus;

    if (dwStatus = GetSystemKey (pSysInfo, &hKeyMachine)) {
        return dwStatus;
    }

    // if here, then hKeyMachine is an open key to the system's
    //  HKEY_LOCAL_MACHINE registry database

    // only one language is supported by this approach.
    // multiple language support would:
    //  1.  enumerate language keys
    //       and for each key:
    //  2.  allocate memory for structures
    //  3.  call BuildNameTable for each lang key.

    pSysInfo->CounterInfo.pNextTable = NULL;
    pSysInfo->CounterInfo.dwLangId = iLanguage ;   // default Lang ID

    if (PlayingBackLog() && PlaybackLog.pBaseCounterNames) {
        pSysInfo->CounterInfo.TextString = LogBuildNameTable (pSysInfo) ;
    } else {
        pSysInfo->CounterInfo.TextString = BuildNameTable (
                                                          pSysInfo,
                                                          hKeyMachine,
                                                          NULL,                               // use default
                                                          &pSysInfo->CounterInfo,
                                                          0);
    }

    if (hKeyMachine && hKeyMachine != HKEY_LOCAL_MACHINE) {
        RegCloseKey (hKeyMachine) ;
    }

    if (pSysInfo->CounterInfo.TextString == NULL) {
        return GetLastError();
    } else {
        return ERROR_SUCCESS;
    }
}

BOOL
GetHelpText(
           PPERFSYSTEM pSysInfo
           )
{
    LPWSTR  *lpCounterId;
    LPWSTR  lpHelpText;
    LONG    lWin32Status;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    NTSTATUS    Status;
    DWORD   dwLastId;
    TCHAR   Slash[2];

    HKEY    hKeyNames;

    TCHAR   SysLangId [ShortTextLen] ;
    TCHAR   ValueNameString [MiscTextLen] ;
    HKEY    hKeyMachine = 0;
    DWORD   dwStatus;

    SetHourglassCursor() ;

    //initialize local variables
    lpHelpText = NULL;
    hKeyNames = hKeyMachine = NULL;
    Slash[0] = L'\\';
    Slash[1] = L'\0';

    dwBufferSize = 0;

    TSPRINTF (SysLangId, TEXT("%03x"), pSysInfo->CounterInfo.dwLangId) ;

    if (pSysInfo->SysVersion <= 0x10000) {
        // old version, get help from registry
        if (dwStatus = GetSystemKey (pSysInfo, &hKeyMachine)) {
            goto ERROR_EXIT;
        }

        lstrcpy (ValueNameString, NamesKey);
        lstrcat (ValueNameString, Slash);
        lstrcat (ValueNameString, SysLangId);

        lWin32Status = RegOpenKeyEx (
                                    hKeyMachine,
                                    ValueNameString,
                                    RESERVED,
                                    KEY_READ,
                                    &hKeyNames);

        if (lWin32Status != ERROR_SUCCESS) goto ERROR_EXIT;
    } else {
        // new system version, get it from the HKEY_PERFORMANCE
        hKeyNames = pSysInfo->sysDataKey;
        lstrcpy (ValueNameString, ExplainNameStr);
        lstrcat (ValueNameString, SysLangId);
    }

    dwHelpSize = 0;
    lWin32Status = RegQueryValueEx (
                                   hKeyNames,
                                   pSysInfo->SysVersion <= 0x010000 ? Help : ValueNameString,
                                   RESERVED,
                                   &dwValueType,
                                   NULL,
                                   &dwHelpSize);

    if (lWin32Status != ERROR_SUCCESS || dwHelpSize == 0) goto ERROR_EXIT;

    dwLastId = pSysInfo->CounterInfo.dwLastId;
    dwArraySize = (dwLastId + 1) * sizeof (LPWSTR);
    dwCounterSize = pSysInfo->CounterInfo.dwCounterSize;

    // allocate another memory to get the help text
    lpHelpText = MemoryAllocate (dwHelpSize);
    if (!lpHelpText) goto ERROR_EXIT;

    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueEx (
                                   hKeyNames,
                                   pSysInfo->SysVersion <= 0x010000 ? Help : ValueNameString,
                                   RESERVED,
                                   &dwValueType,
                                   (LPVOID)lpHelpText,
                                   &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto ERROR_EXIT;

    // setup the help text pointers
    lpCounterId = pSysInfo->CounterInfo.TextString;
    Status = AddNamesToArray (lpHelpText, dwLastId, lpCounterId) ;
    if (Status != ERROR_SUCCESS) goto ERROR_EXIT;

    pSysInfo->CounterInfo.dwHelpSize = dwHelpSize;

    if (pSysInfo->SysVersion <= 0x010000)
        RegCloseKey (hKeyNames);

    if (hKeyMachine && hKeyMachine != HKEY_LOCAL_MACHINE) {
        RegCloseKey (hKeyMachine) ;
    }

    pSysInfo->CounterInfo.HelpTextString = lpHelpText;

    SetArrowCursor() ;

    return TRUE;

    ERROR_EXIT:

    SetArrowCursor() ;

    if (lpHelpText) {
        MemoryFree ((LPVOID)lpHelpText);
    }

    if (hKeyNames) {
        RegCloseKey (hKeyNames);
    }
    if (hKeyMachine && hKeyMachine != HKEY_LOCAL_MACHINE) {
        RegCloseKey (hKeyMachine) ;
    }

    return FALSE;
}

//
//  QueryPerformanceName -	Get a title, given an index
//
//	Inputs:
//
//          pSysInfo        -   Pointer to sysinfo struct for the
//                              system in question
//
//	    dwTitleIndex    -	Index of Title entry
//
//          LangID          -   language in which title should be displayed
//
//	    cbTitle	    -	# of char in the lpTitle buffer
//
//	    lpTitle	    -	pointer to a buffer to receive the
//                              Title
//
//          Help            -   TRUE is help is desired, else counter or
//                              object is assumed
DWORD
QueryPerformanceName(
                    PPERFSYSTEM pSysInfo,
                    DWORD dwTitleIndex,
                    LANGID LangID,
                    DWORD cbTitle,
                    LPTSTR lpTitle,
                    BOOL Help
                    )
{
    LPWSTR  lpTitleFound;
    NTSTATUS    Status;
    BOOL    bGetTextSuccess = TRUE ;

    DBG_UNREFERENCED_PARAMETER(LangID);

    if (Help && pSysInfo->CounterInfo.dwHelpSize == 0) {
        // we have not get the help text yet, go get it
        bGetTextSuccess = GetHelpText (pSysInfo);
    }

    if (!bGetTextSuccess) {
        Status = ERROR_INVALID_NAME;
        goto ErrorExit;
    }

    if ((dwTitleIndex > 0) && (dwTitleIndex <= pSysInfo->CounterInfo.dwLastId)) {
        // then title should be found in the array
        lpTitleFound = pSysInfo->CounterInfo.TextString[dwTitleIndex];
        if (!lpTitleFound) {
            // no entry for this index
            Status = ERROR_INVALID_NAME;
        } else if ((DWORD)lstrlen(lpTitleFound) < cbTitle) {
            lstrcpy (lpTitle, lpTitleFound);
            return (ERROR_SUCCESS);
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {

        Status = ERROR_INVALID_NAME;
    }

    ErrorExit:
    // if here, then an error occured, so return a blank

    if ((DWORD)lstrlen (NULL_NAME) < cbTitle) {
        lstrcpy (lpTitle, NULL_NAME);
    }

    return Status;   // title not returned

}


LONG
GetSystemPerfData (
                  IN HKEY hKeySystem,
                  IN LPTSTR lpszValue,
                  OUT PPERFDATA pPerfData,
                  OUT PDWORD pdwPerfDataLen
                  )
{
    LONG     lError ;
    DWORD    Type ;

    // have to pass in a Type to RegQueryValueEx(W) or else it
    // will crash
    lError = RegQueryValueEx (hKeySystem, lpszValue, NULL, &Type,
                              (LPSTR) pPerfData, pdwPerfDataLen) ;
    return (lError) ;
}


BOOL
CloseSystemPerfData (
                    HKEY hKeySystem
                    )
{
    return (TRUE) ;
}


int
CBLoadObjects (
              HWND hWndCB,
              PPERFDATA pPerfData,
              PPERFSYSTEM pSysInfo,
              DWORD dwDetailLevel,
              LPTSTR lpszDefaultObject,
              BOOL bIncludeAll
              )
/*
   Effect:        Load into the combo box CB one item for each Object in
                  pPerfData. For each item, look up the object's name in
                  the registry strings associated with pSysInfo, and
                  attach the object to the data field of the CB item.

                  Dont add those objects that are more detailed than
                  dwDetailLevel.

                  Set the current selected CB item to the object named
                  lpszDefaultObject, or to the default object specified in
                  pPerfData if lpszDefaultObject is NULL.
*/
{
    UINT           i ;
    INT_PTR        iIndex ;
    PPERFOBJECT    pObject ;
    TCHAR          szObject [PerfObjectLen + 1] ;
    TCHAR          szDefaultObject [PerfObjectLen + 1] ;

    CBReset (hWndCB) ;
    strclr (szDefaultObject) ;

    pObject = FirstObject (pPerfData) ;

    for (i = 0, pObject = FirstObject (pPerfData) ;
        i < pPerfData->NumObjectTypes ;
        i++, pObject = NextObject (pObject)) {  // for
        if (pObject->DetailLevel <= dwDetailLevel) {  // if
            strclr (szObject) ;
            QueryPerformanceName (pSysInfo, pObject->ObjectNameTitleIndex,
                                  0, PerfObjectLen, szObject, FALSE) ;

            // if szObject not empty, add it to the Combo-box
            if (!strsame(szObject, NULL_NAME)) {
                iIndex = CBAdd (hWndCB, szObject) ;
                CBSetData (hWndCB, iIndex, (DWORD_PTR) pObject) ;

                if ((LONG)pObject->ObjectNameTitleIndex == pPerfData->DefaultObject)
                    lstrcpy (szDefaultObject, szObject) ;
            }
        }
    }


    if (bIncludeAll) {
        StringLoad (IDS_ALLOBJECTS, szObject) ;
        CBInsert (hWndCB, 0, szObject) ;
        // assume "ALL" is default unless overridden
        lstrcpy (szDefaultObject, szObject) ;
    }

    if (lpszDefaultObject)
        lstrcpy (szDefaultObject, lpszDefaultObject) ;

    iIndex = CBFind (hWndCB, szDefaultObject) ;
    CBSetSelection (hWndCB, (iIndex != CB_ERR) ? iIndex : 0) ;

    return (i) ;
}


int
LBLoadObjects (
              HWND hWndLB,
              PPERFDATA pPerfData,
              PPERFSYSTEM pSysInfo,
              DWORD dwDetailLevel,
              LPTSTR lpszDefaultObject,
              BOOL bIncludeAll
              )
/*
   Effect:        Load into the list box LB one item for each Object in
                  pPerfData. For each item, look up the object's name in
                  the registry strings associated with pSysInfo, and
                  attach the object to the data field of the LB item.

                  Dont add those objects that are more detailed than
                  dwDetailLevel.

                  Set the current selected LB item to the object named
                  lpszDefaultObject, or to the default object specified in
                  pPerfData if lpszDefaultObject is NULL.
*/
{
    UINT           i ;
    INT_PTR        iIndex = 0;
    PPERFOBJECT    pObject ;
    TCHAR          szObject [PerfObjectLen + 1] ;
    TCHAR          szDefaultObject [PerfObjectLen + 1] ;

    LBReset (hWndLB) ;
    strclr (szDefaultObject) ;

    pObject = FirstObject (pPerfData) ;

    for (i = 0, pObject = FirstObject (pPerfData) ;
        i < pPerfData->NumObjectTypes ;
        i++, pObject = NextObject (pObject)) {
        if (pObject->DetailLevel <= dwDetailLevel) {
            strclr (szObject) ;
            QueryPerformanceName (pSysInfo, pObject->ObjectNameTitleIndex,
                                  0, PerfObjectLen, szObject, FALSE) ;

            // if szObject is not empty, add it to the listbox
            if (!strsame(szObject, NULL_NAME)) {
                iIndex = LBAdd (hWndLB, szObject) ;
                LBSetData (hWndLB, iIndex, (DWORD_PTR) pObject) ;

                if ((LONG)pObject->ObjectNameTitleIndex == pPerfData->DefaultObject)
                    lstrcpy (szDefaultObject, szObject) ;
            }
        }
    }


    if (bIncludeAll) {
        StringLoad (IDS_ALLOBJECTS, szObject) ;
        LBInsert (hWndLB, 0, szObject) ;
        LBSetData (hWndLB, iIndex, 0) ;
        // assume "ALL" is default unless overridden
        lstrcpy (szDefaultObject, szObject) ;
    }

    if (lpszDefaultObject)
        lstrcpy (szDefaultObject, lpszDefaultObject) ;

    iIndex = LBFind (hWndLB, szDefaultObject) ;
    LBSetSelection (hWndLB, (iIndex != LB_ERR) ? iIndex : 0) ;

    return (i) ;
}


/***************************************************************************\
* GetObjectDef()
*
* Entry: pointer to data block and the number of the object type
* Exit:  returns a pointer to the specified object type definition
*
\***************************************************************************/

PPERFOBJECT
GetObjectDef(
            PPERFDATA pDataBlock,
            DWORD NumObjectType
            )
{
    DWORD NumTypeDef;

    PPERFOBJECT pObjectDef;

    pObjectDef = FirstObject(pDataBlock);

    for ( NumTypeDef = 0;
        NumTypeDef < pDataBlock->NumObjectTypes;
        NumTypeDef++ ) {

        if ( NumTypeDef == NumObjectType ) {

            return pObjectDef;
        }
        pObjectDef = NextObject(pObjectDef);
    }
    return 0;
}

/***************************************************************************\
* GetObjectDefByTitleIndex()
*
* Entry: pointer to data block and the title index of the object type
* Exit:  returns a pointer to the specified object type definition
*
\***************************************************************************/

PPERFOBJECT
GetObjectDefByTitleIndex(
                        PPERFDATA pDataBlock,
                        DWORD ObjectTypeTitleIndex
                        )
{
    DWORD NumTypeDef;

    PPERFOBJECT pObjectDef;

    pObjectDef = FirstObject(pDataBlock);

    for ( NumTypeDef = 0;
        NumTypeDef < pDataBlock->NumObjectTypes;
        NumTypeDef++ ) {

        if ( pObjectDef->ObjectNameTitleIndex == ObjectTypeTitleIndex ) {

            return pObjectDef;
        }
        pObjectDef = NextObject(pObjectDef);
    }
    return 0;
}

/***************************************************************************\
* GetObjectDefByName()
*
* Entry: pointer to data block and the name of the object type
* Exit:  returns a pointer to the specified object type definition
*
\***************************************************************************/

PPERFOBJECT
GetObjectDefByName(
                  PPERFSYSTEM pSystem,
                  PPERFDATA pDataBlock,
                  LPTSTR pObjectName
                  )
{
    DWORD NumTypeDef;
    TCHAR szObjectName [PerfObjectLen + 1] ;

    PPERFOBJECT pObjectDef;

    pObjectDef = FirstObject(pDataBlock);
    for ( NumTypeDef = 0;
        NumTypeDef < pDataBlock->NumObjectTypes;
        NumTypeDef++ ) {

        ObjectName (pSystem, pObjectDef, szObjectName, PerfObjectLen) ;
        if (strsame (szObjectName, pObjectName) ) {

            return pObjectDef;
        }
        pObjectDef = NextObject(pObjectDef);
    }
    return 0;
}

/***************************************************************************\
* GetObjectIdByName()
*
* Entry: pointer to data block and the name of the object type
* Exit:  returns the Object title index for the specified Object Name
*
\***************************************************************************/

DWORD
GetObjectIdByName(
                 PPERFSYSTEM pSystem,
                 PPERFDATA pDataBlock,
                 LPTSTR pObjectName
                 )
{
    DWORD NumTypeDef;
    TCHAR szObjectName [PerfObjectLen + 1] ;

    PPERFOBJECT pObjectDef;

    pObjectDef = FirstObject(pDataBlock);
    for ( NumTypeDef = 0;
        NumTypeDef < pDataBlock->NumObjectTypes;
        NumTypeDef++ ) {

        ObjectName (pSystem, pObjectDef, szObjectName, PerfObjectLen) ;
        if (strsame (szObjectName, pObjectName) ) {

            return pObjectDef->ObjectNameTitleIndex;
        }
        pObjectDef = NextObject(pObjectDef);
    }
    return 0;
}


/***************************************************************************\
* GetCounterDef()
*
* Entry: pointer to object type definition the number of the Counter
*	 definition
* Exit:  returns a pointer to the specified Counter definition
*
\***************************************************************************/

PPERFCOUNTERDEF
GetCounterDef(
             PPERFOBJECT pObjectDef,
             DWORD NumCounter
             )
{
    DWORD NumCtrDef;

    PPERFCOUNTERDEF pCounterDef;

    pCounterDef = FirstCounter(pObjectDef);

    for ( NumCtrDef = 0;
        NumCtrDef < pObjectDef->NumCounters;
        NumCtrDef++ ) {

        if ( NumCtrDef == NumCounter ) {

            return pCounterDef;
        }
        pCounterDef = NextCounter(pCounterDef);
    }
    return 0;
}

/***************************************************************************\
* GetCounterNumByTitleIndex()
*
* Entry: pointer to object type definition and the title index of
*        the name of the Counter definition
* Exit:  returns the number of the specified Counter definition
*
\***************************************************************************/

LONG
GetCounterNumByTitleIndex(
                         PPERFOBJECT pObjectDef,
                         DWORD CounterTitleIndex
                         )
{
    DWORD NumCtrDef;

    PPERFCOUNTERDEF pCounterDef;

    pCounterDef = FirstCounter(pObjectDef);

    for ( NumCtrDef = 0;
        NumCtrDef < pObjectDef->NumCounters;
        NumCtrDef++ ) {

        if ( pCounterDef->CounterNameTitleIndex == CounterTitleIndex ) {

            return NumCtrDef;
        }
        pCounterDef = NextCounter(pCounterDef);
    }
    return 0;
}

/***************************************************************************\
* GetCounterData()
*
* Entry: pointer to object definition and number of counter, must be
*	 an object with no instances
* Exit:  returns a pointer to the data
*
\***************************************************************************/

PVOID
GetCounterData(
              PPERFOBJECT pObjectDef,
              PPERFCOUNTERDEF pCounterDef
              )
{

    PERF_COUNTER_BLOCK *pCtrBlock;

    pCtrBlock = (PERF_COUNTER_BLOCK *)((PCHAR)pObjectDef +
                                       pObjectDef->DefinitionLength);

    return (PVOID)((PCHAR)pCtrBlock + pCounterDef->CounterOffset);
}

/***************************************************************************\
* GetInstanceCounterData()
*
* Entry: pointer to object definition and number of counter, and a pointer
*        to the instance for which the data is to be retrieved
* Exit:  returns a pointer to the data
*
\***************************************************************************/

PVOID
GetInstanceCounterData(
                      PPERFOBJECT pObjectDef,
                      PPERFINSTANCEDEF pInstanceDef,
                      PPERFCOUNTERDEF pCounterDef
                      )
{

    PERF_COUNTER_BLOCK *pCtrBlock;

    pCtrBlock = (PERF_COUNTER_BLOCK *)((PCHAR)pInstanceDef +
                                       pInstanceDef->ByteLength);

    return (PVOID)((PCHAR)pCtrBlock + pCounterDef->CounterOffset);
}

/***************************************************************************\
* GetNextInstance()
*
* Entry: pointer to instance definition
* Exit:  returns a pointer to the next instance definition.  If none,
*        points to byte past this instance
*
\***************************************************************************/

PPERFINSTANCEDEF
GetNextInstance(
               PPERFINSTANCEDEF pInstDef
               )
{
    PERF_COUNTER_BLOCK *pCtrBlock;

    pCtrBlock = (PERF_COUNTER_BLOCK *)
                ((PCHAR) pInstDef + pInstDef->ByteLength);

    return (PPERFINSTANCEDEF )
    ((PCHAR) pCtrBlock + pCtrBlock->ByteLength);
}

/***************************************************************************\
* GetInstance()
*
* Entry: pointer to object type definition, the name of the instance,
*	 the name of the parent object type, and the parent instance index.
*	 The name of the parent object type is NULL if no parent.
* Exit:  returns a pointer to the specified instance definition
*
\***************************************************************************/

PPERFINSTANCEDEF
GetInstance(
           PPERFOBJECT pObjectDef,
           LONG InstanceNumber
           )
{

    PPERFINSTANCEDEF pInstanceDef;
    LONG NumInstance;

    if (!pObjectDef) {
        return 0;
    }

    pInstanceDef = FirstInstance(pObjectDef);

    for ( NumInstance = 0;
        NumInstance < pObjectDef->NumInstances;
        NumInstance++ ) {
        if ( InstanceNumber == NumInstance ) {
            return pInstanceDef;
        }
        pInstanceDef = GetNextInstance(pInstanceDef);
    }

    return 0;
}

/***************************************************************************\
* GetInstanceByUniqueID()
*
* Entry: pointer to object type definition, and
*        the unique ID of the instance.
* Exit:  returns a pointer to the specified instance definition
*
\***************************************************************************/

PPERFINSTANCEDEF
GetInstanceByUniqueID(
                     PPERFOBJECT pObjectDef,
                     LONG UniqueID,
                     DWORD   dwIndex
                     )
{

    PPERFINSTANCEDEF pInstanceDef;
    DWORD   dwLocalIndex;

    LONG NumInstance;

    pInstanceDef = FirstInstance(pObjectDef);
    dwLocalIndex = dwIndex;

    for ( NumInstance = 0;
        NumInstance < pObjectDef->NumInstances;
        NumInstance++ ) {

        if ( pInstanceDef->UniqueID == UniqueID ) {
            if (dwLocalIndex == 0) {
                return pInstanceDef;
            } else {
                --dwLocalIndex;
            }
        }
        pInstanceDef = GetNextInstance(pInstanceDef);
    }
    return 0;
}


/***************************************************************************\
* GetInstanceByNameUsingParentTitleIndex()
*
* Entry: pointer to object type definition, the name of the instance,
*	 and the name of the parent instance.
*	 The name of the parent instance is NULL if no parent.
* Exit:  returns a pointer to the specified instance definition
*
\***************************************************************************/

PPERFINSTANCEDEF
GetInstanceByNameUsingParentTitleIndex(
                                      PPERFDATA pDataBlock,
                                      PPERFOBJECT pObjectDef,
                                      LPTSTR pInstanceName,
                                      LPTSTR pParentName,
                                      DWORD  dwIndex
                                      )
{
    BOOL fHaveParent;
    PPERFOBJECT pParentObj;

    PPERFINSTANCEDEF pParentInst,
    pInstanceDef;

    LONG   NumInstance;
    TCHAR  InstanceName[256];
    DWORD    dwLocalIndex;


    fHaveParent = FALSE;
    pInstanceDef = FirstInstance(pObjectDef);
    dwLocalIndex = dwIndex;

    memset(InstanceName, 0, sizeof(TCHAR) * 256);
    for ( NumInstance = 0;
        NumInstance < pObjectDef->NumInstances;
        NumInstance++ ) {

        GetInstanceNameStr(pInstanceDef, InstanceName, pObjectDef->CodePage);
        if ( lstrcmpi(InstanceName, pInstanceName) == 0 ) {

            // Instance name matches

            if ( pParentName == NULL ) {

                // No parent, we're done if this is the right "copy"

                if (dwLocalIndex == 0) {
                    return pInstanceDef;
                } else {
                    --dwLocalIndex;
                }

            } else {

                // Must match parent as well

                pParentObj = GetObjectDefByTitleIndex(
                                                     pDataBlock,
                                                     pInstanceDef->ParentObjectTitleIndex);

                if (!pParentObj) {
                    // can't locate the parent, forget it
                    break ;
                }

                // Object type of parent found; now find parent
                // instance

                pParentInst = GetInstance(pParentObj,
                                          pInstanceDef->ParentObjectInstance);

                if (!pParentInst) {
                    // can't locate the parent instance, forget it
                    break ;
                }

                GetInstanceNameStr(pParentInst,InstanceName, pParentObj->CodePage);
                if ( lstrcmpi(InstanceName, pParentName) == 0 ) {

                    // Parent Instance Name matches that passed in
                    if (dwLocalIndex == 0) {
                        return pInstanceDef;
                    } else {
                        --dwLocalIndex;
                    }
                }
            }
        }
        pInstanceDef = GetNextInstance(pInstanceDef);
    }
    return 0;
}

/***************************************************************************\
* GetInstanceByName()
*
* Entry: pointer to object type definition, the name of the instance,
*	 and the name of the parent instance.
*	 The name of the parent instance is NULL if no parent.
* Exit:  returns a pointer to the specified instance definition
*
\***************************************************************************/

PPERFINSTANCEDEF
GetInstanceByName(
                 PPERFDATA pDataBlock,
                 PPERFOBJECT pObjectDef,
                 LPTSTR pInstanceName,
                 LPTSTR pParentName,
                 DWORD   dwIndex
                 )
{
    BOOL fHaveParent;

    PPERFOBJECT pParentObj;

    PPERFINSTANCEDEF pParentInst,
    pInstanceDef;

    LONG  NumInstance;
    TCHAR  InstanceName[256];
    DWORD  dwLocalIndex;

    fHaveParent = FALSE;
    pInstanceDef = FirstInstance(pObjectDef);
    dwLocalIndex = dwIndex;

    memset(InstanceName, 0, sizeof(TCHAR) * 256);
    for ( NumInstance = 0;
        NumInstance < pObjectDef->NumInstances;
        NumInstance++ ) {

        GetInstanceNameStr(pInstanceDef,InstanceName, pObjectDef->CodePage);
        if ( lstrcmpi(InstanceName, pInstanceName) == 0 ) {

            // Instance name matches

            if ( !pInstanceDef->ParentObjectTitleIndex ) {

                // No parent, we're done

                if (dwLocalIndex == 0) {
                    return pInstanceDef;
                } else {
                    --dwLocalIndex;
                }

            } else {

                // Must match parent as well

                pParentObj = GetObjectDefByTitleIndex(
                                                     pDataBlock,
                                                     pInstanceDef->ParentObjectTitleIndex);

                // Object type of parent found; now find parent
                // instance

                if (pParentObj == NULL)
                    continue;
                pParentInst = GetInstance(pParentObj,
                                          pInstanceDef->ParentObjectInstance);

                GetInstanceNameStr(pParentInst,InstanceName, pParentObj->CodePage);
                if ( lstrcmpi(InstanceName, pParentName) == 0 ) {
                    // Parent Instance Name matches that passed in

                    if (dwLocalIndex == 0) {
                        return pInstanceDef;
                    } else {
                        --dwLocalIndex;
                    }
                }
            }
        }
        pInstanceDef = GetNextInstance(pInstanceDef);
    }
    return 0;
}  // GetInstanceByName


BOOL
FailedLineData (
               PPERFDATA pPerfData,
               PLINE pLine
               )
/*
        This routine handles the case where there is no data for a
        system.
*/
{
    LARGE_INTEGER     liDummy ;

    // System no longer exists.
    liDummy.LowPart = liDummy.HighPart = 0;
    if (pLine->lnCounterType == PERF_COUNTER_TIMER_INV) {
        // Timer inverse with Performance Counter as timer
        pLine->lnaOldCounterValue[0] = pLine->lnOldTime ;
        pLine->lnaCounterValue[0] = pLine->lnNewTime ;
    } else if (pLine->lnCounterType == PERF_100NSEC_TIMER_INV ||
               pLine->lnCounterType == PERF_100NSEC_MULTI_TIMER_INV) {
        // Timer inverse with System Time as timer
        pLine->lnaOldCounterValue[0] = pLine->lnOldTime100Ns ;
        pLine->lnaCounterValue[0] = pLine->lnNewTime100Ns ;
    } else {
        // Normal timer
        pLine->lnaOldCounterValue[0] =
        pLine->lnaCounterValue[0] =
        pLine->lnaOldCounterValue[1] =
        pLine->lnaCounterValue[1] = liDummy ;
    }
    return TRUE ;

}


BOOL
UpdateLineData (
               PPERFDATA pPerfData,
               PLINE pLine,
               PPERFSYSTEM pSystem
               )
/*
   Assert:        pPerfData holds the performance data for the same
                  system as pLine.
*/
{
    PPERFOBJECT       pObject ;
    PPERFINSTANCEDEF  pInstanceDef ;
    PPERFCOUNTERDEF   pCounterDef ;
    PPERFCOUNTERDEF   pCounterDef2 ;
    PDWORD            pCounterValue ;
    PDWORD            pCounterValue2 = NULL;
    UINT              iCounterIndex ;
    LARGE_INTEGER     liDummy[2] ;

    // Use Object time units if available, otherwise use system
    // performance timer

    pLine->lnOldTime = pLine->lnNewTime;

    pLine->lnOldTime100Ns = pLine->lnNewTime100Ns;
    pLine->lnNewTime100Ns = pPerfData->PerfTime100nSec;

    pLine->lnPerfFreq = pPerfData->PerfFreq ;

    if ((pLine->lnObject.TotalByteLength == 0) && !(PlayingBackLog())) {
        // this is the case when openning a setting file and the remote
        // system is not up at that time.  We have all the names but no
        // pObject, pCounter, etc.  So, we have to re-built the linedata.
        PPERFOBJECT       pObject ;
        PPERFCOUNTERDEF   pCounter ;
        PPERFINSTANCEDEF  pInstance ;

        pObject = LineFindObject (pSystem, pPerfData, pLine) ;
        if (!pObject) {
            //Something wrong, this object is still not there...
            return FALSE ;
        }
        pCounter = LineFindCounter (pSystem, pObject, pPerfData, pLine) ;
        if (!pCounter) {
            return FALSE ;
        }
        if (pObject &&
            pLine->lnObject.NumInstances > 0 &&
            pLine->lnInstanceName == NULL) {
            return FALSE ;
        }
        pInstance = LineFindInstance (pPerfData, pObject, pLine) ;
        if (!pInstance) {
            if (pLine->lnParentObjName) {
                MemoryFree (pLine->lnParentObjName) ;
                pLine->lnParentObjName = NULL ;
            }
        }

        pLine->lnCounterType = pCounter->CounterType;
        pLine->lnCounterLength = pCounter->CounterSize;

        if (pSystem->lpszValue && strsame (pSystem->lpszValue, L"Global")) {
            DWORD dwBufferSize = MemorySize (pSystem->lpszValue) ;
            memset (pSystem->lpszValue, 0, dwBufferSize) ;
        }

        AppendObjectToValueList (
                                pLine->lnObject.ObjectNameTitleIndex,
                                pSystem->lpszValue);


    }

    pObject = GetObjectDefByTitleIndex(
                                      pPerfData,
                                      pLine->lnObject.ObjectNameTitleIndex);

    if (!pObject) {
        // Object Type no longer exists.  This is possible if we are
        // looking at a log file which has not always collected all
        // the same data, such as appending measurements of different
        // object types.

        pCounterValue =
        pCounterValue2 = (PDWORD) liDummy;
        liDummy[0].QuadPart = 0;


        pLine->lnNewTime = pPerfData->PerfTime;

        if (pLine->lnCounterType == PERF_COUNTER_TIMER_INV) {
            // Timer inverse with Performance Counter as timer
            pLine->lnaOldCounterValue[0] = pLine->lnOldTime ;
            pLine->lnaCounterValue[0] = pLine->lnNewTime ;
        } else if (pLine->lnCounterType == PERF_100NSEC_TIMER_INV ||
                   pLine->lnCounterType == PERF_100NSEC_MULTI_TIMER_INV) {
            // Timer inverse with System Time as timer
            pLine->lnaOldCounterValue[0] = pLine->lnOldTime100Ns ;
            pLine->lnaCounterValue[0] = pLine->lnNewTime100Ns ;
        } else {
            // Normal timer or counter
            pLine->lnaOldCounterValue[0] =
            pLine->lnaCounterValue[0] =
            pLine->lnaOldCounterValue[1] =
            pLine->lnaCounterValue[1] = liDummy[0] ;
        }
        return TRUE ;
    } else {
        pCounterDef = &pLine->lnCounterDef ;

        //      if (pObject->PerfFreq.QuadPart > 0) {
        if (pCounterDef->CounterType & PERF_OBJECT_TIMER) {
            pLine->lnNewTime = pObject->PerfTime;
        } else {
            pLine->lnNewTime = pPerfData->PerfTime;
        }

        iCounterIndex = CounterIndex (pCounterDef, pObject) ;

        // Get second counter, only if we are not at
        // the end of the counters; some computations
        // require a second counter

        if (iCounterIndex < pObject->NumCounters-1 && iCounterIndex != -1) {
            pCounterDef2 = GetCounterDef(pObject, iCounterIndex+1);
        } else {
            pCounterDef2 = NULL;
        }

        if (pObject->NumInstances > 0) {

            if ( pLine->lnUniqueID != PERF_NO_UNIQUE_ID ) {
                pInstanceDef = GetInstanceByUniqueID(pObject,
                                                     pLine->lnUniqueID,
                                                     pLine->dwInstanceIndex);
            } else {

                pInstanceDef =
                GetInstanceByNameUsingParentTitleIndex(
                                                      pPerfData,
                                                      pObject,
                                                      pLine->lnInstanceName,
                                                      pLine->lnPINName,
                                                      pLine->dwInstanceIndex);
            }

            if (pInstanceDef) {
                pLine->lnInstanceDef = *pInstanceDef;
                pCounterValue = GetInstanceCounterData(pObject,
                                                       pInstanceDef,
                                                       pCounterDef);
                if ( pCounterDef2 ) {
                    pCounterValue2 = GetInstanceCounterData(pObject,
                                                            pInstanceDef,
                                                            pCounterDef2);
                }
            } else {
                pCounterValue =
                pCounterValue2 = (PDWORD) liDummy;
                liDummy[0].QuadPart = 0;
                liDummy[1].QuadPart = 0;
            }

            // Got everything...

        } // instances exist, look at them for counter blocks

        else {
            pCounterValue = GetCounterData(pObject, pCounterDef);
            if (pCounterDef2) {
                pCounterValue2 = GetCounterData(pObject, pCounterDef2);
            }

        } // counter def search when no instances
    }

    pLine->lnaOldCounterValue[0] = pLine->lnaCounterValue[0] ;

    if (pLine->lnCounterLength <= 4) {
        // HighPart was initialize to 0
        pLine->lnaCounterValue[0].HighPart = 0;
        pLine->lnaCounterValue[0].LowPart = *pCounterValue;
    } else {
        pLine->lnaCounterValue[0] = *(LARGE_INTEGER UNALIGNED *) pCounterValue;
    }

    // Get second counter, only if we are not at
    // the end of the counters; some computations
    // require a second counter

    if ( pCounterDef2 ) {
        pLine->lnaOldCounterValue[1] =
        pLine->lnaCounterValue[1] ;
        if (pCounterDef2->CounterSize <= 4) {
            // HighPart was initialize to 0
            pLine->lnaCounterValue[1].HighPart = 0;
            pLine->lnaCounterValue[1].LowPart = *pCounterValue2;
        } else
            pLine->lnaCounterValue[1] =
            *((LARGE_INTEGER UNALIGNED *) pCounterValue2);
    }
    return (TRUE) ;
}  // UpdateLineData



BOOL
UpdateSystemData (
                 PPERFSYSTEM pSystem,
                 PPERFDATA *ppPerfData
                 )
{
   #define        PERF_SYSTEM_TIMEOUT (60L * 1000L)
    long           lError ;
    DWORD          Status ;
    DWORD          Size;
    BOOL           TimeToCheck = FALSE ;
    LONGLONG       llLastTimeStamp;

    if (!ppPerfData)
        return (FALSE) ;

    while (TRUE) {
        if (pSystem->FailureTime) {
            DWORD    CurrentTickCount = GetTickCount() ;

            if (CurrentTickCount < pSystem->FailureTime) {
                // wrap-around case
                if (CurrentTickCount >= PERF_SYSTEM_TIMEOUT)
                    TimeToCheck = TRUE ;
                else if ( ~pSystem->FailureTime >= PERF_SYSTEM_TIMEOUT)
                    TimeToCheck = TRUE ;
                else if (CurrentTickCount + (~pSystem->FailureTime) >= PERF_SYSTEM_TIMEOUT)
                    TimeToCheck = TRUE ;
            } else {
                if (CurrentTickCount - pSystem->FailureTime >= PERF_SYSTEM_TIMEOUT)
                    TimeToCheck = TRUE ;
            }

            if (TimeToCheck) {
                // free any memory hanging off this system
                SystemFree (pSystem, FALSE) ;

                // get the registry info
                pSystem->sysDataKey = OpenSystemPerfData(pSystem->sysName) ;

                Status = !ERROR_SUCCESS ;
                if (pSystem->sysDataKey) {
                    Status = GetSystemNames(pSystem);
                }

                if (Status != ERROR_SUCCESS) {
                    // something wrong in getting the registry info,
                    // remote system must be still down (??)
                    pSystem->FailureTime = GetTickCount();

                    // Free any memory that may have created
                    SystemFree (pSystem, FALSE) ;

                    return (FALSE) ;
                }

                // time to check again
                pSystem->FailureTime = 0 ;
            } else {
                // not time to check again
                return (FALSE) ;
            }
        }

        if (pSystem->FailureTime == 0 ) {
            Size = MemorySize ((LPMEMORY)*ppPerfData);

            // save the last sample timestamp for this system

            if (pSystem->pSystemPerfData != NULL) {
                llLastTimeStamp =
                pSystem->pSystemPerfData->PerfTime.QuadPart;
            }

            lError = GetSystemPerfData (pSystem->sysDataKey,
                                        pSystem->lpszValue,
                                        *ppPerfData,
                                        &Size) ;
            if ((!lError) &&
                (Size > 0) &&
                (*ppPerfData)->Signature[0] == (WCHAR)'P' &&
                (*ppPerfData)->Signature[1] == (WCHAR)'E' &&
                (*ppPerfData)->Signature[2] == (WCHAR)'R' &&
                (*ppPerfData)->Signature[3] == (WCHAR)'F' ) {
                if (pSystem->dwSystemState == SYSTEM_OK) {
                    if (pSystem->pSystemPerfData != NULL) {
                        if (pSystem->pSystemPerfData->PerfTime.QuadPart <
                            llLastTimeStamp) {
                            if (bReportEvents) {
                                // then a system error occured, so log it
                                dwMessageDataBytes = 0;
                                szMessageArray[wMessageIndex++] = pSystem->sysName;
                                ReportEvent (hEventLog,
                                             EVENTLOG_ERROR_TYPE,        // error type
                                             0,                          // category (not used)
                                             (DWORD)PERFMON_ERROR_TIMESTAMP, // event,
                                             NULL,                       // SID (not used),
                                             wMessageIndex,              // number of strings
                                             0,                          // sizeof raw data
                                             szMessageArray,             // message text array
                                             NULL);                       // raw data
                            }
                        }
                    }
                    return (TRUE) ;
                } else if (pSystem->dwSystemState == SYSTEM_DOWN ||
                           pSystem->dwSystemState == SYSTEM_DOWN_RPT ) {
                    if (TimeToCheck && bReportEvents) {
                        // then the system just came back so display the message
                        wMessageIndex = 0;
                        szMessageArray[wMessageIndex++] = pSystem->sysName;
                        ReportEvent (hEventLog,
                                     EVENTLOG_INFORMATION_TYPE,        // error type
                                     0,                          // category (not used)
                                     (DWORD)PERFMON_INFO_SYSTEM_RESTORED, // event,
                                     NULL,                       // SID (not used),
                                     wMessageIndex,             // number of strings
                                     0,                          // sizeof raw data
                                     szMessageArray,             // message text array
                                     NULL);                      // raw data
                    }
                    pSystem->dwSystemState = SYSTEM_RECONNECT ;
                } else if (pSystem->dwSystemState == SYSTEM_RECONNECT_RPT) {
                    pSystem->dwSystemState = SYSTEM_OK ;
                }
                // for SYSTEM_RECONNECT case, we want to wait for Alert
                // view to report the re-connection first
                return (TRUE) ;
            }

            if (lError == ERROR_MORE_DATA) {
                Size = MemorySize ((LPMEMORY)*ppPerfData) + dwPerfDataIncrease;
                *ppPerfData = MemoryResize ((LPMEMORY)*ppPerfData, Size);

                if (!*ppPerfData) {
                    if (pSystem->dwSystemState != SYSTEM_DOWN_RPT) {
                        if (bReportEvents) {
                            // then the system just came back so display the message
                            wMessageIndex = 0;
                            dwMessageDataBytes = 0;
                            szMessageArray[wMessageIndex++] = pSystem->sysName;
                            dwMessageData[dwMessageDataBytes++] = Size;
                            dwMessageData[dwMessageDataBytes++] = GetLastError();
                            dwMessageDataBytes *= sizeof(DWORD);
                            ReportEvent (hEventLog,
                                         EVENTLOG_ERROR_TYPE,        // error type
                                         0,                          // category (not used)
                                         (DWORD)PERFMON_ERROR_PERF_DATA_ALLOC, // event,
                                         NULL,                       // SID (not used),
                                         wMessageIndex,              // number of strings
                                         dwMessageDataBytes,         // sizeof raw data
                                         szMessageArray,             // message text array
                                         (LPVOID)&dwMessageData[0]);  // raw data
                        }
                        pSystem->dwSystemState = SYSTEM_DOWN ;
                    }
                    pSystem->FailureTime = GetTickCount();
                    return (FALSE) ;
                }
            } else {
                if (pSystem->dwSystemState != SYSTEM_DOWN_RPT) {
                    if (bReportEvents) {
                        // then the system just came back so display the message
                        wMessageIndex = 0;
                        dwMessageDataBytes = 0;
                        szMessageArray[wMessageIndex++] = pSystem->sysName;
                        dwMessageData[dwMessageDataBytes++] = lError;
                        dwMessageDataBytes *= sizeof(DWORD);
                        ReportEvent (hEventLog,
                                     EVENTLOG_WARNING_TYPE,      // error type
                                     0,                          // category (not used)
                                     (DWORD)PERFMON_ERROR_SYSTEM_OFFLINE, // event,
                                     NULL,                       // SID (not used),
                                     wMessageIndex,              // number of strings
                                     dwMessageDataBytes,         // sizeof raw data
                                     szMessageArray,             // message text array
                                     (LPVOID)&dwMessageData[0]); // raw data
                    }
                    pSystem->dwSystemState = SYSTEM_DOWN ;
                }
                pSystem->FailureTime = GetTickCount();
                return (FALSE) ;
            }  // else
        } // if
    }  // while
}



BOOL
FailedLinesForSystem (
                     LPTSTR lpszSystem,
                     PPERFDATA pPerfData,
                     PLINE pLineFirst
                     )
{
    PLINE          pLine ;
    BOOL           bMatchFound = FALSE ;   // no line from this system

    for (pLine = pLineFirst; pLine; pLine = pLine->pLineNext) {
        if (strsamei (lpszSystem, pLine->lnSystemName)) {
            FailedLineData (pPerfData, pLine) ;
            if (pLine->bFirstTime) {
                pLine->bFirstTime-- ;
            }
            bMatchFound = TRUE ; // one or more lines from this system
        }
    }

    return (bMatchFound) ;
}


BOOL UpdateLinesForSystem (LPTSTR lpszSystem,
                           PPERFDATA pPerfData,
                           PLINE pLineFirst,
                           PPERFSYSTEM pSystem)
{
    PLINE          pLine ;
    BOOL           bMatchFound = FALSE ;   // no line from this system

    for (pLine = pLineFirst; pLine; pLine = pLine->pLineNext) {
        if (strsamei (lpszSystem, pLine->lnSystemName)) {
            UpdateLineData (pPerfData, pLine, pSystem) ;
            if (pLine->bFirstTime) {
                pLine->bFirstTime-- ;
            }
            bMatchFound = TRUE ; // one or more lines from this system
        }
    }

    return (bMatchFound) ;
}


BOOL
PerfDataInitializeInstance (void)
{
    //   pGlobalPerfData = MemoryAllocate (STARTING_SYSINFO_SIZE) ;
    //   return (pGlobalPerfData != NULL) ;
    return (TRUE) ;
}

NTSTATUS
AddNamesToArray (
                LPTSTR lpNames,
                DWORD    dwLastId,
                LPWSTR   *lpCounterId
                )
{
    LPWSTR      lpThisName;
    LPWSTR      lpStopString;
    DWORD       dwThisCounter;
    NTSTATUS    Status = ERROR_SUCCESS;

    for (lpThisName = lpNames; *lpThisName; ) {

        // first string should be an integer (in decimal unicode digits)
        dwThisCounter = wcstoul(lpThisName, &lpStopString, 10);

        if ((dwThisCounter == 0) || (dwThisCounter == ULONG_MAX)) {
            Status += 1;
            goto ADD_BAILOUT;  // bad entry
        }

        // point to corresponding counter name

        while (*lpThisName++);

        if (dwThisCounter <= dwLastId) {

            // and load array element;

            lpCounterId[dwThisCounter] = lpThisName;

        }

        while (*lpThisName++);

    }

    ADD_BAILOUT:
    return (Status) ;
}

// try the new way of getting data...

BOOL
UpdateLines (
            PPPERFSYSTEM ppSystemFirst,
            PLINE pLineFirst
            )
{
    PPERFSYSTEM       pSystem ;
    int               iNoUseSystemDetected = 0 ;
    int               NumberOfSystems = 0 ;
    DWORD             WaitStatus ;
    HANDLE            *lpPacketHandles ;

    // allocate the handle array for multiple wait
    if (NumberOfHandles == 0) {
        NumberOfHandles = MAXIMUM_WAIT_OBJECTS ;
        lpHandles = (HANDLE *) MemoryAllocate (NumberOfHandles * sizeof (HANDLE)) ;
        if (!lpHandles) {
            // out of memory, can't go on
            NumberOfHandles = 0 ;
            return FALSE ;
        }
    }

    for (pSystem = *ppSystemFirst; pSystem; pSystem = pSystem->pSystemNext) {

        // lock the state data mutex, should be quick unless this thread
        // is still getting data from last time
        if (pSystem->hStateDataMutex == 0)
            continue ;

        WaitStatus = WaitForSingleObject(pSystem->hStateDataMutex, 100L);
        if (WaitStatus == WAIT_OBJECT_0) {
            ResetEvent (pSystem->hPerfDataEvent) ;
            pSystem->StateData = WAIT_FOR_PERF_DATA ;

            // add this to the wait
            if (NumberOfSystems >= NumberOfHandles) {
                NumberOfHandles += MAXIMUM_WAIT_OBJECTS ;
                lpHandles = (HANDLE *) MemoryResize (
                                                    lpHandles,
                                                    NumberOfHandles * sizeof (HANDLE)) ;
                if (!lpHandles) {
                    // out of memory, can't go on
                    NumberOfHandles = 0 ;
                    return FALSE ;
                }
            }

            lpHandles [NumberOfSystems] = pSystem->hPerfDataEvent ;
            NumberOfSystems++ ;

            // Send Message to thread to take a data sample
            PostThreadMessage (
                              pSystem->dwThreadID,
                              WM_GET_PERF_DATA,
                              (WPARAM)0,
                              (LPARAM)0) ;

            ReleaseMutex(pSystem->hStateDataMutex);
        } else {
            // wait timed out, report error
            if (bReportEvents) {
                wMessageIndex = 0;
                dwMessageDataBytes = 0;
                szMessageArray[wMessageIndex++] = pSystem->sysName;
                ReportEvent (hEventLog,
                             EVENTLOG_ERROR_TYPE,        // error type
                             0,                          // category (not used)
                             (DWORD)PERFMON_ERROR_LOCK_TIMEOUT, // event,
                             NULL,                       // SID (not used),
                             wMessageIndex,              // number of strings
                             0,                          // sizeof raw data
                             szMessageArray,             // message text array
                             NULL); // raw data
            }
        }
    }

    Sleep (10); // give the data collection thread a chance to get going

    // wait for all the data
    if (NumberOfSystems) {
        // increase timeout if we are monitoring lots of systems
        // For every additional 5 systems, add 5 more seconds
        lpPacketHandles = lpHandles ;
        do {
            WaitStatus = WaitForMultipleObjects (
                                                min (NumberOfSystems, MAXIMUM_WAIT_OBJECTS),
                                                lpPacketHandles,
                                                TRUE,       // wait for all objects
                                                DataTimeOut + (NumberOfSystems / 5) * DEFAULT_DATA_TIMEOUT);

            if (WaitStatus == WAIT_TIMEOUT ||
                NumberOfSystems <= MAXIMUM_WAIT_OBJECTS) {
                //if (WaitStatus == WAIT_TIMEOUT)
                //   mike2(TEXT("WaitTimeOut for %ld systems\n"), NumberOfSystems) ;

                break ;
            }

            // more systems --> more to wait
            NumberOfSystems -= MAXIMUM_WAIT_OBJECTS ;
            lpPacketHandles += MAXIMUM_WAIT_OBJECTS ;
        } while (TRUE) ;

        for (pSystem = *ppSystemFirst; pSystem; pSystem = pSystem->pSystemNext) {

            if (pSystem->hStateDataMutex == 0)
                continue ;

            // lock the state data mutex
            WaitStatus = WaitForSingleObject(pSystem->hStateDataMutex, 100L);
            if (WaitStatus == WAIT_OBJECT_0) {
                if (pSystem->StateData != PERF_DATA_READY) {
                    if (!FailedLinesForSystem (pSystem->sysName,
                                               pSystem->pSystemPerfData,
                                               pLineFirst)) {
                        if (!bAddLineInProgress) {
                            // mark this system as no-longer-needed
                            iNoUseSystemDetected++ ;
                            pSystem->bSystemNoLongerNeeded = TRUE ;
                        }
                    }
                } else {
                    if (!UpdateLinesForSystem (pSystem->sysName,
                                               pSystem->pSystemPerfData,
                                               pLineFirst,
                                               pSystem)) {
                        if (!bAddLineInProgress) {
                            // mark this system as no-longer-needed
                            iNoUseSystemDetected++ ;
                            pSystem->bSystemNoLongerNeeded = TRUE ;
                        }
                    }
                }
                pSystem->StateData = IDLE_STATE ;
                ReleaseMutex(pSystem->hStateDataMutex);
            } else {
                if (!FailedLinesForSystem (pSystem->sysName,
                                           pSystem->pSystemPerfData,
                                           pLineFirst)) {
                    if (!bAddLineInProgress) {
                        // mark this system as no-longer-needed
                        iNoUseSystemDetected++ ;
                        pSystem->bSystemNoLongerNeeded = TRUE ;
                    }
                }
            }
        }

        // check for un-used systems
        if (iNoUseSystemDetected) {
            // some unused system(s) detected.
            DeleteUnusedSystems (ppSystemFirst, iNoUseSystemDetected) ;
        }
    }

    return (TRUE) ;
}

void
PerfDataThread (
               PPERFSYSTEM pSystem
               )
{
    MSG      msg ;
    BOOL     bGetPerfData ;
    DWORD    WaitStatus ;

    while (GetMessage (&msg, NULL, 0, 0)) {
        if (LOWORD(msg.message) == WM_GET_PERF_DATA) {

            // this system has been marked as no long used,
            // forget about getting data and continue until
            // we get to the WM_FREE_SYSTEM msg
            if (pSystem->bSystemNoLongerNeeded)
                continue ;

            bGetPerfData = FALSE ;

            if (!bAddLineInProgress ||
                (pSystem->lpszValue &&
                 !strsame (pSystem->lpszValue, L"Global"))) {
                bGetPerfData = UpdateSystemData (pSystem, &(pSystem->pSystemPerfData)) ;
            }

            WaitStatus = WaitForSingleObject(pSystem->hStateDataMutex, 1000L);
            if (WaitStatus == WAIT_OBJECT_0) {
                if (pSystem->StateData == WAIT_FOR_PERF_DATA) {
                    pSystem->StateData = bGetPerfData ?
                                         PERF_DATA_READY : PERF_DATA_FAIL ;
                } else {
                    //mike2(TEXT("Thread - System = %s, WaitStatus = %d\n"),
                    //pSystem->sysName, WaitStatus) ;
                }
                ReleaseMutex(pSystem->hStateDataMutex);
                SetEvent (pSystem->hPerfDataEvent) ;
            }
        }  // WM_GET_PERF_DATA MSG

        else if (LOWORD(msg.message) == WM_FREE_SYSTEM) {
            //mike2(TEXT("Thread - System = %s closing\n"),
            //pSystem->sysName) ;
            // do the memory cleanup during SystemFree stage
            // cleanup all the data collection variables
            if (pSystem->hPerfDataEvent)
                CloseHandle (pSystem->hPerfDataEvent) ;

            if (pSystem->hStateDataMutex)
                CloseHandle (pSystem->hStateDataMutex) ;

            if (pSystem->pSystemPerfData)
                MemoryFree ((LPMEMORY)pSystem->pSystemPerfData);

            if (pSystem->lpszValue) {
                MemoryFree (pSystem->lpszValue);
                pSystem->lpszValue = NULL ;
            }

            CloseHandle (pSystem->hThread);

            MemoryFree (pSystem) ;
            break ;  // get out of message loop
        }  // WM_FREE_SYSTEM MSG
    }

    ExitThread (TRUE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\perferr.h ===
#define PostError()     

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\perfdata.h ===
#define dwPerfDataIncrease       0x1000

#define AllocatePerfData()      (MemoryAllocate (STARTING_SYSINFO_SIZE))

// Messages for the perf data collection thread
#define WM_GET_PERF_DATA (WM_USER + 102)
#define WM_FREE_SYSTEM   (WM_USER + 103)

// State for perf data collection
#define WAIT_FOR_PERF_DATA    0x0010
#define PERF_DATA_READY       0x0011
#define PERF_DATA_FAIL        0x0012
#define IDLE_STATE            0x0013


//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define IsLocalComputer(a) (!lstrcmp(a,LocalComputerName))
#define IsRemoteComputer(a) (!IsLocalComputer(a))


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

#if 0
PPERFOBJECT FirstObject (PPERFDATA pPerfData) ;

PPERFOBJECT NextObject (PPERFOBJECT pObject) ;

PPERFCOUNTERDEF 
FirstCounter(
    PPERFOBJECT pObjectDef) ;

PPERFCOUNTERDEF 
NextCounter(
    PPERFCOUNTERDEF pCounterDef) ;
#endif

#define FirstObject(pPerfData)         \
   ((PPERFOBJECT) ((PBYTE) pPerfData + pPerfData->HeaderLength))

#define NextObject(pObject)            \
   ((PPERFOBJECT) ((PBYTE) pObject + pObject->TotalByteLength))

#define FirstCounter(pObjectDef)       \
   ((PPERFCOUNTERDEF ) ((PCHAR)pObjectDef + pObjectDef->HeaderLength))

#define NextCounter(pCounterDef)       \
   ((PPERFCOUNTERDEF ) ((PCHAR)pCounterDef + pCounterDef->ByteLength))

void
GetInstanceNameStr (PPERFINSTANCEDEF pInstance,
                    LPTSTR lpszInstance,
                    DWORD   dwCodePage);

LPTSTR   
GetInstanceName (PPERFINSTANCEDEF pInstance) ;

void
GetPerfComputerName(PPERFDATA pPerfData,
                    LPTSTR szComputerName) ;

PPERFINSTANCEDEF GetInstanceByName(
    PPERFDATA pDataBlock,
    PPERFOBJECT pObjectDef,
    LPTSTR pInstanceName,
    LPTSTR pParentName,
    DWORD   dwIndex) ;


PPERFINSTANCEDEF GetInstanceByUniqueID(
    PPERFOBJECT pObjectDef,
    LONG UniqueID,
    DWORD   dwIndex) ;



HKEY OpenSystemPerfData (IN LPCTSTR lpszSystem) ;



LONG GetSystemPerfData (
    IN HKEY hKeySystem,
    IN LPTSTR lpszValue,
    OUT PPERFDATA pPerfData, 
    OUT PDWORD pdwPerfDataLen
);


BOOL CloseSystemPerfData (HKEY hKeySystem) ;



int CBLoadObjects (HWND hWndCB,
                   PPERFDATA pPerfData,
                   PPERFSYSTEM pSysInfo,
                   DWORD dwDetailLevel,
                   LPTSTR lpszDefaultObject,
                   BOOL bIncludeAll) ;

int LBLoadObjects (HWND hWndCB,
                   PPERFDATA pPerfData,
                   PPERFSYSTEM pSysInfo,
                   DWORD dwDetailLevel,
                   LPTSTR lpszDefaultObject,
                   BOOL bIncludeAll) ;


BOOL UpdateSystemData (PPERFSYSTEM pSystem, 
                       PPERFDATA *ppPerfData) ;


BOOL UpdateLinesForSystem (LPTSTR lpszSystem, 
                           PPERFDATA pPerfData, 
                           PLINE pLineFirst,
                           PPERFSYSTEM pSystem) ;

BOOL FailedLinesForSystem (LPTSTR lpszSystem, 
                           PPERFDATA pPerfData, 
                           PLINE pLineFirst) ;


BOOL UpdateLines (PPPERFSYSTEM ppSystemFirst,
                  PLINE pLineFirst) ;


BOOL PerfDataInitializeInstance (void) ;


DWORD
QueryPerformanceName(
    PPERFSYSTEM pSysInfo,
    DWORD dwTitleIndex,
    LANGID LangID,
    DWORD cbTitle,
    LPTSTR lpTitle,
    BOOL Help
    );

PPERFINSTANCEDEF 
FirstInstance(
    PPERFOBJECT pObjectDef) ;



PPERFINSTANCEDEF 
NextInstance(
    PPERFINSTANCEDEF pInstDef) ;



int CounterIndex (PPERFCOUNTERDEF pCounterToFind,
                  PPERFOBJECT pObject) ;


DWORD GetSystemNames(PPERFSYSTEM pSysInfo) ;



PPERFOBJECT GetObjectDefByTitleIndex(
    PPERFDATA pDataBlock,
    DWORD ObjectTypeTitleIndex) ;


PPERFOBJECT GetObjectDefByName(
    PPERFSYSTEM pSystem,
    PPERFDATA pDataBlock,
    LPTSTR pObjectName) ;

DWORD GetObjectIdByName(
    PPERFSYSTEM pSystem,
    PPERFDATA pDataBlock,
    LPTSTR pObjectName) ;

LPTSTR
InstanceName(
PPERFINSTANCEDEF pInstDef) ;

void PerfDataThread (PPERFSYSTEM pSystem) ;




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\perfmon.h ===
/*****************************************************************************
 *
 *  Perfmon.h - This is the main include file. It contains all major data
 *              structures and general defines.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *  Author: Mike Moskowicz
 *
 *          [1-May-1992]
 *
 ****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <limits.h>
#include <windows.h>
#include <commdlg.h>
#include <shellapi.h>
#include <stdlib.h>
#include <string.h>
#include <winperf.h>
#include <tchar.h>

#include "perfmrc.h"
#include "strids.h"
#include "menuids.h"
#include "dlgids.h"

#include "sizes.h"
#include "typedefs.h"
#include "winhelpr.h"

extern VOID LoadLineGraphSettings(PGRAPHSTRUCT);
extern VOID LoadRefreshSettings(PGRAPHSTRUCT);
extern VOID SetGraphTimer(PGRAPHSTRUCT lgraph) ;
extern BOOL QueryTitleEntry(HKEY,DWORD,DWORD,DWORD,LPTSTR);
extern VOID ResetGraphTimer(PGRAPHSTRUCT lgraph);

//==========================================================================//
//                                  Constants                               //
//==========================================================================//

#define VERSION_NUMBER      1
#define SAVED_LOG           4
#define SAVED_ALERT         2
#define SAVED_GRAPH         1
#define SAVED_WORKSPACE     (SAVED_GRAPH | SAVED_ALERT | SAVED_LOG)
#define FNAMLEN             128

#define szScalesFontFace         TEXT("MS Shell Dlg")
#define iScalesFontHeightAnsi    8
#define iScalesFontHeightNonAnsi 12
#define szScalesPrinterFontFace  TEXT("MS Shell Dlg")
#define iScalesPrinterFontHeight 12
#define iTitlePrinterFontHeight  18

#define crLightGray              RGB (0xC0, 0xC0, 0xC0)
#define crDarkGray               RGB (0x40, 0x40, 0x40)
#define crGray                   RGB (0x80, 0x80, 0x80)
#define crRed                    RGB (0xFF, 0x00, 0x00)
#define crGreen                  RGB (0x00, 0xFF, 0x00)
#define crBlue                   RGB (0x00, 0x00, 0xFF)
#define crBlack                  RGB (0x00, 0x00, 0x00)
#define crWhite                  RGB (0xFF, 0xFF, 0xFF)

#define LogTimerID               100
#define AlertTimerID             200
#define ChartTimerID             300
#define ReportTimerID            400

#define ChartTool                IDM_VIEWCHART
#define AlertTool                IDM_VIEWALERT
#define LogTool                  IDM_VIEWLOG
#define ReportTool               IDM_VIEWREPORT
#define AddTool                  IDM_TOOLBARADD
#define EditTool                 IDM_TOOLBARMODIFY
#define DeleteTool               IDM_TOOLBARDELETE
#define RefreshTool              IDM_TOOLBARREFRESH
#define BookmarkTool             IDM_OPTIONSBOOKMARK
#define OptionsTool              IDM_TOOLBAROPTIONS

#define szComputerPrefix         TEXT("\\\\")      // two backslashes

#define WIDESTYLES               FALSE       // Don't allow wide styled lines

//==========================================================================//
//                                Global Data                               //
//==========================================================================//

#include "globals.h"

//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

LRESULT
APIENTRY
MainWndProc (
             HWND hwnd,
             UINT message,
             WPARAM wParam,
             LPARAM lParam) ;

void SizePerfmonComponents (void) ;

#define TSPRINTF _stprintf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\perfmops.h ===
HWND PerfmonViewWindow (void) ;

BOOL ChooseComputer (HWND hWndParent, LPTSTR lpszComputer) ;


BOOL CurrentComputerName (LPTSTR lpszComputer) ;

void GetDateTimeFormats (void) ;

void SystemTimeDateString (SYSTEMTIME *pSystemTime,
                           LPTSTR lpszDate) ;


void SystemTimeTimeString (SYSTEMTIME *pSystemTime,
                           LPTSTR lpszTime,
                           BOOL bOutputMsec) ;


VOID dlg_error_box (HANDLE hDlg, UINT id) ;


void ShowPerfmonMenu (BOOL bMenu) ;


void SmallFileSizeString (int iFileSize,
                          LPTSTR lpszFileText) ;


BOOL DoWindowDrag (HWND hWnd, LPARAM lParam) ;


int SystemTimeDifference (SYSTEMTIME *pst1, SYSTEMTIME *pst2, BOOL bAbs) ;


BOOL OpenFileHandler(HWND hWnd, LPTSTR lpszFilePath) ;


BOOL InsertLine (PLINE pLine)  ;

BOOL OpenWorkspace (HANDLE hFile, DWORD dwMajorVersion, DWORD dwMinorVersion) ;

BOOL SaveWorkspace (void) ;

INT ExportFileOpen (HWND hWnd, HANDLE *phFile, int IntervalSecs, LPTSTR *ppFileName) ;

void SetPerfmonOptions (OPTIONS *pOptions) ;

void ChangeSaveFileName (LPTSTR szFileName, int iPMView) ;

BOOL AppendObjectToValueList ( DWORD   dwObjectId, LPTSTR   pwszValueList );

BOOL RemoveObjectsFromSystem (PPERFSYSTEM pSystem);

BOOL BuildValueListForSystems (PPERFSYSTEM, PLINE);

BOOL SetSystemValueNameToGlobal (PPERFSYSTEM);

void CreatePerfmonSystemObjects () ;

void DeletePerfmonSystemObjects () ;

void ConvertDecimalPoint (LPTSTR lpFloatPointStr) ;

void ReconvertDecimalPoint (LPTSTR lpFloatPointStr) ;

void ShowPerfmonWindowText (void) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\perfmrc.h ===
//=============================//
// ID Macro Definition         //
//=============================//


#ifdef RC_INVOKED
   #define ID(id) id
#else
   #define ID(id) MAKEINTRESOURCE (id)
#endif


//=============================//
// Resource IDs                //
//=============================//


#define idMenuChart                 ID (2001)
#define idMenuAlert                 ID (2002)
#define idMenuLog                   ID (2003)
#define idMenuReport                ID (2004)


#define idAccelerators              ID (4001)


#define idDlgLogDisplay             ID (4002)
#define idDlgLogOptions             ID (4003)
#define idDlgAddLog                 ID (4004)
#define idDlgAbort                  ID (4005)
#define idDlgTimeframe              ID (4006)
#define idDlgAlertDisplay           ID (4007)
#define idDlgAddLine                ID (4008)
#define idDlgChartOptions           ID (4009)
#define idDlgAlertOptions           ID (4010)
#define idDlgAddBookmark            ID (4011)
#define idDlgReportOptions          ID (4012)
#define idDlgDisplayOptions         ID (4013)
#define idDlgDataSource             ID (4014)
#define idDlgAbout                  ID (4015)
#define idDlgExportOptions          ID (4016)
#define idDlgChooseComputer         ID (4017)


#define idIcon                      ID (5001)

#define idBitmapToolbar             101
#define idBitmapAlertStatus         ID (6002)
#define idBitmapLogStatus           ID (6003)


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\perfmops.c ===
#include "perfmon.h"
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmwksta.h>
#include <uiexport.h>
#include <stdio.h>         // for sprintf
#include <locale.h>        // for setlocale
#include "utils.h"

#include "perfdata.h"      // for OpenSystemPerfData
#include "alert.h"         // for AlertInsertLine
#include "report.h"        // for ReportInsertLine
#include "grafdata.h"      // for GraphInsertLine
#include "log.h"           // for OpenLog
#include "fileopen.h"      // for FileGetName
#include "fileutil.h"      // for FileRead etc
#include "command.h"       // for PrepareMenu
#include "playback.h"      // for PlayingBackLog & LogPositionSystemTime
#include "system.h"
#include "globals.h"
#include "pmemory.h"       // for MemoryFree
#include "status.h"        // for StatusLineReady
#include "pmhelpid.h"

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

// globals used for International Date and Time formats
enum DATE_STYLE
   {
   YEAR_FIRST,       // YYMMDD
   DAY_FIRST,        // DDMMYY
   MONTH_FIRST       // MMDDYY
   } DateStyle ;

TCHAR szInternational[] = TEXT("Intl") ;
TCHAR sz1159[6] ;       // AM String
TCHAR sz2359[6] ;       // PM String
int   iTime ;           // = 0 for 12-hour format,  <> 0 for 24-hour format
int   YearCharCount ;   // = 4 for 1990, = 2 for 90

TCHAR szDateFormat[ResourceStringLen] ;
TCHAR szTimeFormat[ResourceStringLen] ;   // time format including msec
TCHAR szTimeFormat1[ResourceStringLen] ;  // time format without msec

TCHAR LeadingZeroStr [] = TEXT("%02d") ;
TCHAR NoLeadingZeroStr [] = TEXT("%d") ;

TCHAR szDecimal [2] ;
TCHAR szCurrentDecimal [2] ;

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

#define SIZE_OF_BIGGEST_INTEGER  16
// #define SIZE_OF_BIGGEST_INTEGER (16*sizeof(WCHAR))


//==========================================================================//
//                                  Typedefs                                //
//==========================================================================//

BOOL AddObjectToSystem ( PLINE , PPERFSYSTEM );
BOOL GetLogFileComputer (HWND hWndParent, LPTSTR lpComputerName, DWORD BufferSize) ;


HWND PerfmonViewWindow (void)
/*
   Effect:        Return the current data window, i.e. the window currently
                  visible as the client area of Perfmon.  This is either a
                  chart, log, alert, or report window.
*/
   {  // PerfmonDataWindow
   switch (iPerfmonView)
      {  // switch
      case IDM_VIEWLOG:
         return (hWndLog) ;

      case IDM_VIEWALERT:
         return (hWndAlert) ;

      case IDM_VIEWREPORT:
         return (hWndReport) ;

//      case IDM_VIEWCHART:
      default:
         return (hWndGraph) ;
      }  // switch
   }  // PerfmonViewWindow




#define szChooseComputerLibrary     TEXT("ntlanman.dll")
#define szChooseComputerFunction    "I_SystemFocusDialog"


BOOL ChooseComputer (HWND hWndParent, LPTSTR lpszComputer)
/*
   Effect:        Display the choose Domain/Computer dialog provided by
                  network services.  If the user selects a computer,
                  copy the computer name to lpszComputer and return
                  nonnull. If the user cancels, return FALSE.

   Internals:     This dialog and code is currently not an exported
                  routine regularly found on any user's system. Right
                  now, we dynamically load and call the routine.

                  This is definitely temporary code that will be
                  rewritten when NT stabilizes. The callers of this
                  routine, however, will not need to be modified.

                  Also, the Domain/Computer dialog currently allows
                  a domain to be selected, which we cannot use. We
                  therefore loop until the user cancels or selects
                  a computer, putting up a message if the user selects
                  a domain.

   Assert:        lpszComputer is at least MAX_SYSTEM_NAME_LENGTH + 1
                  characters.
*/
   {  // ChooseComputer
   BOOL                     bSuccess ;
   WCHAR                    wszWideComputer[MAX_PATH + 3] ;
   HLIBRARY                 hLibrary ;
   LPFNI_SYSTEMFOCUSDIALOG  lpfnChooseComputer ;
   LONG                     lError ;

   if (!PlayingBackLog())
      {

      // bring up the select network computer dialog
      hLibrary = LoadLibrary (szChooseComputerLibrary) ;
      if (!hLibrary || hLibrary == INVALID_HANDLE_VALUE)
         {
         return (FALSE) ;
         }

      lpfnChooseComputer = (LPFNI_SYSTEMFOCUSDIALOG)
         GetProcAddress (hLibrary, szChooseComputerFunction) ;

      if (!lpfnChooseComputer)
         {
         FreeLibrary (hLibrary) ;
         return (FALSE) ;
         }

      lError = (*lpfnChooseComputer) (hWndParent,
         FOCUSDLG_SERVERS_ONLY | FOCUSDLG_BROWSE_ALL_DOMAINS,
         wszWideComputer,
         sizeof(wszWideComputer) / sizeof(WCHAR),
         &bSuccess,
         pszHelpFile,
         HC_PM_idDlgSelectNetworkComputer) ;

      FreeLibrary (hLibrary) ;
      }
   else
      {
      // bring up the select Log Computer dialog
      bSuccess = GetLogFileComputer (hWndParent,
         wszWideComputer,
         sizeof(wszWideComputer) / sizeof(WCHAR)) ;
      }

   if (bSuccess)
      {
      lstrcpy (lpszComputer, wszWideComputer) ;
      }

   return (bSuccess) ;
   }  // ChooseComputer


void SystemTimeDateString (SYSTEMTIME *pSystemTime,
                           LPTSTR lpszDate)
   {
   int      wYear ;

   wYear = pSystemTime->wYear ;
   if (YearCharCount == 2)
      {
      wYear %= 100 ;
      }

   switch (DateStyle)
      {
      case YEAR_FIRST:
         TSPRINTF (lpszDate, szDateFormat,
             wYear, pSystemTime->wMonth, pSystemTime->wDay) ;
         break ;

      case DAY_FIRST:
         TSPRINTF (lpszDate, szDateFormat,
             pSystemTime->wDay, pSystemTime->wMonth, wYear) ;
         break ;

      case MONTH_FIRST:
      default:
         TSPRINTF (lpszDate, szDateFormat,
             pSystemTime->wMonth, pSystemTime->wDay, wYear) ;
         break ;
      }
   }


void SystemTimeTimeString (SYSTEMTIME *pSystemTime,
                           LPTSTR lpszTime,
                           BOOL   bOutputMsec)
   {
   int            iHour ;
   BOOL           bPM ;

   if (iTime)
      {
      // 24 hor format
      if (bOutputMsec)
         {
         TSPRINTF (lpszTime, szTimeFormat,
                pSystemTime->wHour,
                pSystemTime->wMinute,
                (FLOAT)pSystemTime->wSecond +
                (FLOAT)pSystemTime->wMilliseconds / (FLOAT) 1000.0) ;
         }
      else
         {
         TSPRINTF (lpszTime, szTimeFormat1,
                pSystemTime->wHour,
                pSystemTime->wMinute,
                pSystemTime->wSecond) ;

         }
      }
   else
      {
      // 12 hour format
      iHour = pSystemTime->wHour ;
      bPM = (iHour >= 12) ;

      if (iHour > 12)
         iHour -= 12 ;
      else if (!iHour)
         iHour = 12 ;

      if (bOutputMsec)
         {
         TSPRINTF (lpszTime, szTimeFormat,
                iHour, pSystemTime->wMinute,
                (FLOAT)pSystemTime->wSecond +
                (FLOAT)pSystemTime->wMilliseconds / (FLOAT) 1000.0 ,
                bPM ? sz2359 : sz1159) ;
         }
      else
         {
         TSPRINTF (lpszTime, szTimeFormat1,
                iHour, pSystemTime->wMinute,
                pSystemTime->wSecond,
                bPM ? sz2359 : sz1159) ;
         }
      }
   }

void ShowPerfmonWindowText ()
   {
   LPTSTR   *ppFileName ;
   TCHAR    szApplication [MessageLen] ;

   switch (iPerfmonView)
      {
      case IDM_VIEWCHART:
         ppFileName = &pChartFileName ;
         break ;

      case IDM_VIEWALERT:
         ppFileName = &pAlertFileName ;
         break ;

      case IDM_VIEWREPORT:
         ppFileName = &pReportFileName ;
         break ;

      case IDM_VIEWLOG:
         ppFileName = &pLogFileName ;
         break ;

      default:
         ppFileName = NULL ;
         break ;
      }

   if (ppFileName == NULL)
      {
      ppFileName = &pWorkSpaceFileName ;
      }

   // display the name file name on the Title bar.
   StringLoad (IDS_APPNAME, szApplication) ;

   if (*ppFileName)
      {
      lstrcat (szApplication, TEXT(" - ")) ;
      lstrcat (szApplication, *ppFileName) ;
      }
   SetWindowText (hWndMain, szApplication) ;
   }

void ShowPerfmonMenu (BOOL bMenu)
   {  // ShowPerfmonMenu
   if (!bMenu)
      {
      WindowEnableTitle (hWndMain, FALSE) ;
//      SetMenu(hWndMain, NULL) ;
      }
   else
      {
      WindowEnableTitle (hWndMain, TRUE) ;
      switch (iPerfmonView)
         {  // switch
         case IDM_VIEWCHART:
            SetMenu (hWndMain, hMenuChart) ;
            break ;

         case IDM_VIEWALERT:
            SetMenu (hWndMain, hMenuAlert) ;
            break ;

         case IDM_VIEWLOG:
            SetMenu (hWndMain, hMenuLog) ;
            break ;

         case IDM_VIEWREPORT:
            SetMenu (hWndMain, hMenuReport) ;
            break ;
         }  // switch
      }  // else

   if (bMenu != Options.bMenubar)
      {
      PrepareMenu (GetMenu (hWndMain)) ;
      }

   Options.bMenubar = bMenu ;

   // Show Window Text
   if (bMenu)
      {
      ShowPerfmonWindowText () ;
      }
   }  // ShowPerfmonMenu



void SmallFileSizeString (int iFileSize,
                          LPTSTR lpszFileText)
   {  // SmallFileSizeString
   if (iFileSize < 1000000)
      TSPRINTF (lpszFileText, TEXT(" %1.1fK "), ((FLOAT) iFileSize) / 1000.0f) ;
   else
      TSPRINTF (lpszFileText, TEXT(" %1.1fM "), ((FLOAT) iFileSize) / 1000000.0f) ;
   }  // SmallFileSizeString



BOOL DoWindowDrag (HWND hWnd, LPARAM lParam)
   {
   POINT    lPoint ;

   if (!Options.bMenubar && !IsZoomed (hWndMain))
      {
      // convert lParam from client to screen
      lPoint.x = LOWORD (lParam) ;
      lPoint.y = HIWORD (lParam) ;
      ClientToScreen (hWnd, &lPoint) ;
      lParam = MAKELONG (lPoint.x, lPoint.y) ;
      SendMessage (hWndMain, WM_NCLBUTTONDOWN, HTCAPTION, lParam) ;
      return (TRUE) ;
      }
   else
      return (FALSE) ;
   }



// Filetimes are in 100NS units
#define FILETIMES_PER_SECOND     10000000


int SystemTimeDifference (SYSTEMTIME *pst1, SYSTEMTIME *pst2, BOOL bAbs)
   {
   LARGE_INTEGER  li1, li2 ;
   LARGE_INTEGER  liDifference, liDifferenceSeconds ;
   DWORD          uRemainder ;
   int            RetInteger;
   BOOL           bNegative;

   li1.HighPart = li1.LowPart = 0 ;
   li2.HighPart = li2.LowPart = 0 ;

   SystemTimeToFileTime (pst1, (FILETIME *) &li1) ;
   SystemTimeToFileTime (pst2, (FILETIME *) &li2) ;

   // check for special cases when the time can be 0
   if (li2.HighPart == 0 && li2.LowPart == 0)
      {
      if (li1.HighPart == 0 && li1.LowPart == 0)
         {
         return 0 ;
         }
      else
         {
         return -INT_MAX ;
         }
      }
   else if (li1.HighPart == 0 && li1.LowPart == 0)
      {
      return INT_MAX ;
      }

   liDifference.QuadPart = li2.QuadPart - li1.QuadPart ;
   bNegative = liDifference.QuadPart < 0 ;

   // add the round-off factor before doing the division
   if (bNegative)
      {
      liDifferenceSeconds.QuadPart = (LONGLONG)(- FILETIMES_PER_SECOND / 2) ;
      }
   else
      {
      liDifferenceSeconds.QuadPart = (LONGLONG)(FILETIMES_PER_SECOND / 2) ;
      }


   liDifferenceSeconds.QuadPart = liDifferenceSeconds.QuadPart +
      liDifference.QuadPart ;

   liDifferenceSeconds.QuadPart = liDifferenceSeconds.QuadPart /
      FILETIMES_PER_SECOND;

   RetInteger = liDifferenceSeconds.LowPart;

   if (bNegative && bAbs)
      {
      return (-RetInteger) ;
      }
   else
      {
      return (RetInteger) ;
      }
   }


BOOL InsertLine (PLINE pLine)
{  // InsertLine

    BOOL bReturn = FALSE;

    switch (pLine->iLineType) {  // switch
        case LineTypeChart:
            bReturn = ChartInsertLine (pGraphs, pLine) ;
            break ;

        case LineTypeAlert:
            bReturn = AlertInsertLine (hWndAlert, pLine) ;
            break ;

        case LineTypeReport:
            bReturn = ReportInsertLine (hWndReport, pLine) ;
            break ;

    }  // switch

    return bReturn;

}  // InsertLine


BOOL OpenWorkspace (HANDLE hFile, DWORD dwMajorVersion, DWORD dwMinorVersion)
   {
   DISKWORKSPACE  DiskWorkspace ;

   if (!FileRead (hFile, &DiskWorkspace, sizeof(DiskWorkspace)))
      {
      goto Exit0 ;
      }

   if (DiskWorkspace.ChartOffset == 0 &&
       DiskWorkspace.AlertOffset == 0 &&
       DiskWorkspace.LogOffset == 0 &&
       DiskWorkspace.ReportOffset == 0)
      {
      goto Exit0 ;
      }

   switch (dwMajorVersion)
      {  // switch
      case (1):

         if (dwMinorVersion >= 1)
            {
            // setup the window position and size
            DiskWorkspace.WindowPlacement.length = sizeof(WINDOWPLACEMENT);
            DiskWorkspace.WindowPlacement.flags = WPF_SETMINPOSITION;
            if (!SetWindowPlacement (hWndMain, &(DiskWorkspace.WindowPlacement)))
                {
                goto Exit0 ;
                }
            }

         // change to the view as stored in the workspace file
         SendMessage (hWndMain, WM_COMMAND,
            (LONG)DiskWorkspace.iPerfmonView, 0L) ;
         iPerfmonView = DiskWorkspace.iPerfmonView ;

         if (DiskWorkspace.ChartOffset)
            {
            if (FileSeekBegin(hFile, DiskWorkspace.ChartOffset) == 0xFFFFFFFF)
               {
               goto Exit0 ;
               }

            if (!OpenChart (hWndGraph,
                           hFile,
                           dwMajorVersion,
                           dwMinorVersion,
                           FALSE))
               {
               goto Exit0 ;
               }
            }
         if (DiskWorkspace.AlertOffset)
            {
            if (FileSeekBegin(hFile, DiskWorkspace.AlertOffset) == 0xffffffff)
               {
               goto Exit0 ;
               }
            if (!OpenAlert (hWndAlert,
                       hFile,
                       dwMajorVersion,
                       dwMinorVersion,
                       FALSE))
               {
               goto Exit0 ;
               }
            }
         if (DiskWorkspace.LogOffset)
            {
            if (FileSeekBegin(hFile, DiskWorkspace.LogOffset) == 0xffffffff)
               {
               goto Exit0 ;
               }
            if (!OpenLog (hWndLog,
                          hFile,
                          dwMajorVersion,
                          dwMinorVersion,
                          FALSE))
               {
               goto Exit0 ;
               }
            }
         if (DiskWorkspace.ReportOffset)
            {
            if (FileSeekBegin(hFile, DiskWorkspace.ReportOffset) == 0xffffffff)
               {
               goto Exit0 ;
               }
            if (!OpenReport (hWndReport,
                        hFile,
                        dwMajorVersion,
                        dwMinorVersion,
                        FALSE))
               {
               goto Exit0 ;
               }
            }
         break ;

      default:
         goto Exit0 ;
         break ;
      }

   CloseHandle (hFile) ;
   return (TRUE) ;


Exit0:
   CloseHandle (hFile) ;
   return (FALSE) ;

   }  // OpenWorkspace


BOOL SaveWorkspace (void)
   {
   DISKWORKSPACE  DiskWorkspace ;
   PERFFILEHEADER FileHeader ;
   HANDLE         hFile ;
   long           DiskWorkspacePosition ;
   TCHAR          szFileName[FilePathLen] ;
   BOOL           bWriteErr = TRUE ;

   if (!FileGetName (PerfmonViewWindow(), IDS_WORKSPACEFILE, szFileName))
      {
      return (FALSE) ;
      }

   hFile = FileHandleCreate (szFileName) ;
   if (!hFile || hFile == INVALID_HANDLE_VALUE)
      {
      DlgErrorBox (PerfmonViewWindow (), ERR_CANT_OPEN, szFileName) ;
      return (FALSE) ;
      }

   memset (&FileHeader, 0, sizeof (FileHeader)) ;
   lstrcpy (FileHeader.szSignature, szPerfWorkspaceSignature) ;
   FileHeader.dwMajorVersion = WorkspaceMajorVersion ;
   FileHeader.dwMinorVersion = WorkspaceMinorVersion ;

   if (!FileWrite (hFile, &FileHeader, sizeof (PERFFILEHEADER)))
      {
      goto Exit0 ;
      }

   // reserve space in the file.  We will fill up info
   // and write into this guy later.
   memset (&DiskWorkspace, 0, sizeof(DiskWorkspace)) ;
   DiskWorkspacePosition = FileTell (hFile) ;
   DiskWorkspace.WindowPlacement.length = sizeof(WINDOWPLACEMENT);
   if (!GetWindowPlacement (hWndMain, &(DiskWorkspace.WindowPlacement)))
      {
      goto Exit0 ;
      }

   if (!FileWrite (hFile, &DiskWorkspace, sizeof (DISKWORKSPACE)))
      {
      goto Exit0 ;
      }

   // put in chart data
   DiskWorkspace.ChartOffset = FileTell (hFile) ;
   if (!SaveChart (hWndGraph, hFile, 0))
      {
      goto Exit0 ;
      }

   // put in alert data
   DiskWorkspace.AlertOffset = FileTell (hFile) ;
   if (!SaveAlert (hWndAlert, hFile, 0))
      {
      goto Exit0 ;
      }

   // put in log data
   DiskWorkspace.LogOffset = FileTell (hFile) ;
   if (!SaveLog (hWndLog, hFile, 0))
      {
      goto Exit0 ;
      }

   // put in report data
   DiskWorkspace.ReportOffset = FileTell (hFile) ;
   if (!SaveReport (hWndReport, hFile, 0))
      {
      goto Exit0 ;
      }

   // put in the disk header info
   DiskWorkspace.iPerfmonView = iPerfmonView ;
   FileSeekBegin (hFile, DiskWorkspacePosition) ;
   if (!FileWrite (hFile, &DiskWorkspace, sizeof (DISKWORKSPACE)))
      {
      goto Exit0 ;
      }
   bWriteErr = FALSE ;

Exit0:
   if (bWriteErr)
      {
      DlgErrorBox (PerfmonViewWindow (), ERR_SETTING_FILE, szFileName) ;
      }

   CloseHandle (hFile) ;
   return TRUE;
   }  // SaveWorkspace

void SetPerfmonOptions (OPTIONS *pOptions)
   {
   Options = *pOptions ;
   ShowPerfmonMenu (Options.bMenubar) ;
   SizePerfmonComponents () ;
   WindowSetTopmost (hWndMain, Options.bAlwaysOnTop) ;
   }  // SetPerfmonOptions

void ChangeSaveFileName (LPTSTR szFileName, int iPMView)
   {
   LPTSTR   *ppFullName = NULL;
   LPTSTR   *ppFileName = NULL;
   BOOL     errorInput = FALSE ;
   TCHAR    szApplication [MessageLen] ;


   switch (iPMView)
      {
      case IDM_VIEWCHART:
         ppFileName = &pChartFileName ;
         ppFullName = &pChartFullFileName ;
         break ;

      case IDM_VIEWALERT:
         ppFileName = &pAlertFileName ;
         ppFullName = &pAlertFullFileName ;
         break ;

      case IDM_VIEWREPORT:
         ppFileName = &pReportFileName ;
         ppFullName = &pReportFullFileName ;
         break ;

      case IDM_VIEWLOG:
         ppFileName = &pLogFileName ;
         ppFullName = &pLogFullFileName ;
         break ;

      case IDM_WORKSPACE:
         // not a view but a define
         ppFileName = &pWorkSpaceFileName ;
         ppFullName = &pWorkSpaceFullFileName ;
         break ;

      default:
         errorInput = TRUE ;
         break ;
      }

   if (errorInput)
      {
      return ;
      }

   // release last filename
   if (*ppFullName)
      {
      MemoryFree (*ppFullName) ;
      *ppFileName = NULL ;
      *ppFullName = NULL ;
      }

   // allocate new file name and display it
   if (szFileName && (*ppFullName = StringAllocate (szFileName)))
      {
      *ppFileName = ExtractFileName (*ppFullName) ;
      }

   if (iPerfmonView == iPMView || iPMView == IDM_WORKSPACE)
      {
      StatusLineReady (hWndStatus) ;

      if (Options.bMenubar)
         {
         // display the name file name on the Title bar.
         StringLoad (IDS_APPNAME, szApplication) ;

         if (*ppFileName == NULL)
            {
            ppFileName = &pWorkSpaceFileName ;
            }

         if (*ppFileName)
            {
            lstrcat (szApplication, TEXT(" - ")) ;
            lstrcat (szApplication, *ppFileName) ;
            }
         SetWindowText (hWndMain, szApplication) ;
         }
      }
   }     // ChangeSaveFileName

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPTSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

BOOL
AppendObjectToValueList (
    DWORD   dwObjectId,
    PWSTR   pwszValueList
)
/*++

AppendObjectToValueList

Arguments:

    IN dwNumber
        DWORD number to insert in list

    IN PUNICODE_STRING
        pointer to unicode string structure that contains buffer that is
        Null terminated, Space delimited list of decimal numbers that
        may have this number appended to.

Return Value:

    TRUE:
            dwNumber was added to list

    FALSE:
            dwNumber was not added. (because it's already there or
                an error occured)

--*/
{
    WCHAR           tempString [SIZE_OF_BIGGEST_INTEGER] ;
    DWORD           dwStrLen, dwNewStrLen;
    LPTSTR          szFormatString;

    if (!pwszValueList) {
        return FALSE;
    }

    if (IsNumberInUnicodeList(dwObjectId, pwszValueList)) {
        return FALSE;   // object already in list
    } else {
        // append the new object id the  value list
        // if this is the first string to enter then don't
        // prefix with a space character otherwise do

        szFormatString = (*pwszValueList == 0) ? TEXT("%d") : TEXT(" %d");

        TSPRINTF (tempString, szFormatString, dwObjectId) ;

        // see if string will fit (compare in bytes)

        dwStrLen = MemorySize (pwszValueList) - sizeof (UNICODE_NULL);

        dwNewStrLen = (lstrlen (pwszValueList) + lstrlen (tempString)) *
            sizeof (WCHAR);

        if (dwNewStrLen <= dwStrLen) {
            lstrcat (pwszValueList, tempString);
            return TRUE;
        } else {
            SetLastError (ERROR_OUTOFMEMORY);
            return FALSE;
        }
    }
}

BOOL
AddObjectToSystem (
    PLINE pLine,
    PPERFSYSTEM pFirstSystem
)
{
    PPERFSYSTEM     pSystem;

    if ((ARGUMENT_PRESENT (pLine)) && (ARGUMENT_PRESENT(pFirstSystem))) {
        pSystem = SystemGet (pFirstSystem, pLine->lnSystemName);

        if (pSystem) {
            return AppendObjectToValueList (
                pLine->lnObject.ObjectNameTitleIndex,
                pSystem->lpszValue);
        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

BOOL
RemoveObjectsFromSystem (
    PPERFSYSTEM pSystem
)
{
    DWORD   dwBufferSize = 0;

    if (ARGUMENT_PRESENT (pSystem)) {
        // don't do foreign computers
        if (pSystem->lpszValue && (_wcsnicmp(pSystem->lpszValue, L"Foreign", 7) != 0)){
            dwBufferSize = MemorySize (pSystem->lpszValue);

            memset (pSystem->lpszValue, 0, dwBufferSize);
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }


}

BOOL
BuildValueListForSystems (
    PPERFSYSTEM pSystemListHead,
    PLINE       pLineListHead
)
/*++

BuildValueListForSystem

Abstract:

    Walks down line list and builds the list of objects to query from
    that system containing that line.

Arguments:

    pSystemListHead

        head of system linked list
        each system will have it's "Value Name" list appended

    pLineListHead

        head of line list that will be searched for creating the new
        valuelist.


Return Value:


--*/
{

    PPERFSYSTEM     pSystem;    // system that contains current line
    PLINE           pThisLine;  // current line

    if ((ARGUMENT_PRESENT (pLineListHead)) && (ARGUMENT_PRESENT(pSystemListHead))) {
        // clear system entries:
        for (pSystem = pSystemListHead; pSystem; pSystem = pSystem->pSystemNext) {
            if (pSystem && pSystem->FailureTime == 0) {
                RemoveObjectsFromSystem (pSystem);
            }
        }

        // add new enties

        for (pThisLine = pLineListHead; pThisLine; pThisLine = pThisLine->pLineNext) {

            pSystem = SystemGet (pSystemListHead, pThisLine->lnSystemName);
            if (pSystem && pSystem->FailureTime == 0) {
                AppendObjectToValueList (
                    pThisLine->lnObject.ObjectNameTitleIndex,
                    pSystem->lpszValue);

            }
        }
        return TRUE;
    } else {    // argument(s) missing
        return FALSE;
    }
}

// define in Addline.c
extern   PLINESTRUCT       pLineEdit ;
#define  bEditLine (pLineEdit != NULL)

BOOL
SetSystemValueNameToGlobal (
    PPERFSYSTEM pSystem
)
{

    if (!bEditLine && ARGUMENT_PRESENT(pSystem)) {
        if (pSystem->lpszValue && RemoveObjectsFromSystem(pSystem)) {
            if (pSystem->lpszValue && (_wcsnicmp(pSystem->lpszValue, L"Foreign",7) != 0)){
                // don't change foreign computer strings
                lstrcpy (
                    pSystem->lpszValue,
                    TEXT("Global")) ;
            }
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

BOOL
RemoveUnusedSystems (
    PPERFSYSTEM pSystemHead,
    PLINE       pLineHead
)
/*++

    walks system list and removes systems with no lines from list

--*/
{
    PPERFSYSTEM pSystem;
    PPERFSYSTEM pLastSystem;
    PLINE       pLine;
    BOOL        bSystemFound;

    pLastSystem = NULL;

    if ((ARGUMENT_PRESENT (pLineHead)) && (ARGUMENT_PRESENT(pSystemHead))) {
        for (pSystem = pSystemHead;
             pSystem != NULL;
             pLastSystem = pSystem, pSystem = pSystem->pSystemNext) {

            if (pSystem) {
                bSystemFound = FALSE;
                // walk lines to see if this system has a line
                for (pLine = pLineHead; pLine; pLine = pLine->pLineNext) {
                    // if system in line is this system, then bailout
                    if (strsame (pLine->lnSystemName, pSystem->sysName)) {
                        bSystemFound = TRUE;
                        break;
                    }
                }

                if (!bSystemFound) {    // delete this unused system

                    // fix pointers
                    if (pLastSystem)
                        pLastSystem->pSystemNext = pSystem->pSystemNext;

                    SystemFree (pSystem, TRUE);

                    // set pointer back to a valid structure
                    pSystem = pLastSystem;
                    if (pSystem == NULL)
                        break;
                }
            }
        }
    }
    return TRUE;
}

void CreatePerfmonSystemObjects ()
{
   ColorBtnFace = GetSysColor (COLOR_BTNFACE) ;
   hBrushFace = CreateSolidBrush (ColorBtnFace) ;
   hPenHighlight = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_BTNHIGHLIGHT)) ;
   hPenShadow = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_BTNSHADOW)) ;
   SetClassLongPtr (hWndMain, GCLP_HBRBACKGROUND, (LONG_PTR)hBrushFace);
}

void DeletePerfmonSystemObjects ()
{
   if (hBrushFace)
      {
      DeleteBrush (hBrushFace) ;
      hBrushFace = 0 ;
      }
   if (hPenHighlight)
      {
      DeletePen (hPenHighlight) ;
      hPenHighlight = 0 ;
      }
   if (hPenShadow)
      {
      DeletePen (hPenShadow) ;
      hPenShadow = 0 ;
      }
}

// This routine count the number of the same charatcer in the input string
int  SameCharCount (LPTSTR pInputString)
{
   int      Count = 0 ;
   TCHAR    InputChar = *pInputString ;

   if (InputChar)
      {
      while (InputChar == *pInputString)
         {
         Count ++ ;
         pInputString ++ ;
         }
      }
   return (Count) ;
}

// create the format to be used in SystemTimeDateString()
BOOL CreateDateFormat (LPTSTR pShortDate)
{
   int   iIndex ;
   int   iDayCount ;
   int   iMonthCount ;
   int   DateSeparatorCount ;
   TCHAR szDateSeparator [10] ;
   BOOL  bFirstLeading, bSecondLeading, bThirdLeading ;

   // get the date format based on the first char
   if (*pShortDate == TEXT('M') || *pShortDate == TEXT('m'))
      {
      DateStyle = MONTH_FIRST ;
      }
   else if (*pShortDate == TEXT('D') || *pShortDate == TEXT('d'))
      {
      DateStyle = DAY_FIRST ;
      }
   else if (*pShortDate == TEXT('Y') || *pShortDate == TEXT('y'))
      {
      DateStyle = YEAR_FIRST ;
      }
   else
      {
      // bad format
      return FALSE ;
      }

   bFirstLeading = bSecondLeading = bThirdLeading = FALSE ;

   switch (DateStyle)
      {
      case YEAR_FIRST:
         // YYYY-MM-DD
         YearCharCount = SameCharCount (pShortDate) ;
         pShortDate += YearCharCount ;
         DateSeparatorCount = SameCharCount (pShortDate) ;

         // get the separator string
         for (iIndex = 0; iIndex < DateSeparatorCount; iIndex ++)
            {
            szDateSeparator [iIndex] = *pShortDate++ ;
            }
         szDateSeparator [iIndex] = TEXT('\0') ;

         iMonthCount = SameCharCount (pShortDate) ;
         pShortDate += iMonthCount + DateSeparatorCount ;
         iDayCount = SameCharCount (pShortDate) ;

         if (YearCharCount == 2)
            {
            bFirstLeading = TRUE ;
            }

         if (iMonthCount == 2)
            {
            bSecondLeading = TRUE ;
            }

         if (iDayCount == 2)
            {
            bThirdLeading = TRUE ;
            }

         break ;

      case MONTH_FIRST:
         // MM-DD-YYYY
         iMonthCount = SameCharCount (pShortDate) ;
         pShortDate += iMonthCount ;
         DateSeparatorCount = SameCharCount (pShortDate) ;

         // get the separator string
         for (iIndex = 0; iIndex < DateSeparatorCount; iIndex ++)
            {
            szDateSeparator [iIndex] = *pShortDate++ ;
            }
         szDateSeparator [iIndex] = TEXT('\0') ;

         iDayCount = SameCharCount (pShortDate) ;
         pShortDate += iMonthCount + DateSeparatorCount ;
         YearCharCount = SameCharCount (pShortDate) ;


         if (iMonthCount == 2)
            {
            bFirstLeading = TRUE ;
            }

         if (iDayCount == 2)
            {
            bSecondLeading = TRUE ;
            }

         if (YearCharCount == 2)
            {
            bThirdLeading = TRUE ;
            }

         break ;

      case DAY_FIRST:
         // DD-MM-YYYY
         iDayCount = SameCharCount (pShortDate) ;
         pShortDate += iDayCount ;
         DateSeparatorCount = SameCharCount (pShortDate) ;

         // get the separator string
         for (iIndex = 0; iIndex < DateSeparatorCount; iIndex ++)
            {
            szDateSeparator [iIndex] = *pShortDate++ ;
            }
         szDateSeparator [iIndex] = TEXT('\0') ;

         iMonthCount = SameCharCount (pShortDate) ;
         pShortDate += iMonthCount + DateSeparatorCount ;
         YearCharCount = SameCharCount (pShortDate) ;

         if (iDayCount == 2)
            {
            bFirstLeading = TRUE ;
            }

         if (iMonthCount == 2)
            {
            bSecondLeading = TRUE ;
            }

         if (YearCharCount == 2)
            {
            bThirdLeading = TRUE ;
            }

         break ;
      }

   // now generate the date format
   lstrcpy (szDateFormat, bFirstLeading ? LeadingZeroStr : NoLeadingZeroStr) ;
   lstrcat (szDateFormat, szDateSeparator) ;
   lstrcat (szDateFormat, bSecondLeading ? LeadingZeroStr : NoLeadingZeroStr) ;
   lstrcat (szDateFormat, szDateSeparator) ;
   lstrcat (szDateFormat, bThirdLeading ? LeadingZeroStr : NoLeadingZeroStr) ;

   return TRUE ;
}

BOOL CreateTimeFormat (LPTSTR pTimeSeparator, int iLeadingZero)
{
   // create the format to be used in SystemTimeTimeString
   if (iLeadingZero)
      {
      lstrcpy (szTimeFormat, LeadingZeroStr) ;
      }
   else
      {
      lstrcpy (szTimeFormat, NoLeadingZeroStr) ;
      }

   lstrcat (szTimeFormat, pTimeSeparator) ;
   lstrcat (szTimeFormat, LeadingZeroStr) ;
   lstrcat (szTimeFormat, pTimeSeparator) ;
//   lstrcat (szTimeFormat, LeadingZeroStr) ;

   // Duplicate the format without the msec field (for export use)
   lstrcpy (szTimeFormat1, szTimeFormat) ;

   // for the msec
   lstrcat (szTimeFormat, TEXT("%02.1f")) ;

   // for sec without msec
   lstrcat (szTimeFormat1, TEXT("%02d")) ;

   if (iTime == 0)
      {
      lstrcat (szTimeFormat, TEXT(" %s ")) ;
      lstrcat (szTimeFormat1, TEXT(" %s ")) ;
      }

   return TRUE ;
}  // CreateTimeFormats

BOOL GetInternational()
{
   TCHAR szShortDate[40] ;
   TCHAR szTime[40] ;   // time separator
   DWORD RetCode ;
   int   iTLZero = 0 ;      // = 0 for no leading zero, <> 0 for leading zero
   CHAR  aLanguageStr [2] ;
   LPSTR pRetStr ;
   LPTSTR lpStr ;

   // read the data from the win.ini (which i smapped to registry)
   RetCode = GetProfileString(szInternational,
      TEXT("sShortDate"), szShortDate, szShortDate, sizeof(szShortDate)/sizeof(TCHAR));

   if (RetCode)
      {
      RetCode = GetProfileString(szInternational,
         TEXT("sTime"), szTime, szTime, sizeof(szTime)/sizeof(TCHAR));
      }


   if (RetCode)
      {
      iTime   = GetProfileInt(szInternational, TEXT("iTime"), iTime);
      iTLZero = GetProfileInt(szInternational, TEXT("iTLZero"), iTLZero);

      GetProfileString(szInternational, TEXT("sDecimal"), szDecimal, szDecimal, sizeof(szDecimal)/sizeof(TCHAR));

      if (iTime == 0)
         {
         // get the AM PM strings for 12-hour format.
         // These two strings could be NULL.
         sz1159[0] = sz2359[0] = TEXT('\0') ;
         GetProfileString(szInternational,
            TEXT("s1159"), sz1159, sz1159, sizeof(sz1159)/sizeof(TCHAR));

         GetProfileString(szInternational,
            TEXT("s2359"), sz2359, sz2359, sizeof(sz2359)/sizeof(TCHAR));
         }
      }

   // create the two formats
   if (RetCode)
      {
      RetCode = (DWORD) CreateDateFormat (szShortDate) ;
      }

   if (RetCode)
      {
      RetCode = (DWORD) CreateTimeFormat (szTime, iTLZero) ;
      }

   // use the system default language numeric
   aLanguageStr[0] = '\0' ;
   pRetStr = setlocale(LC_NUMERIC, aLanguageStr);

   // get current decimal point used by C-runtime
   TSPRINTF (szShortDate, TEXT("%f"), (FLOAT)1.0) ;
   lpStr = szShortDate ;

   szCurrentDecimal [0] = TEXT('\0') ;

   while (*lpStr != TEXT('\0'))
      {
      if (*lpStr == TEXT('1'))
         {
         lpStr++ ;
         szCurrentDecimal [0] = *lpStr ;
         break ;
         }
      lpStr++ ;
      }

   if (szCurrentDecimal[0] == TEXT('\0'))
      {
      szCurrentDecimal [0] = TEXT('.') ;
      }

   return (RetCode != 0) ;
}  // GetInternational


// this routine is called to get the date/time formats either
// for the resource or from the registry.
void GetDateTimeFormats ()
{
   PALERT        pAlert ;
   PLOG          pLog ;
   if (!GetInternational())
      {
      // GetInternational failed, then get default formats from resource
      iTime = 0 ;
      DateStyle = MONTH_FIRST ;
      YearCharCount = 4 ;
      StringLoad (IDS_S1159, sz1159) ;
      StringLoad (IDS_S2359, sz2359) ;
      StringLoad (IDS_TIME_FORMAT, szTimeFormat) ;
      StringLoad (IDS_SHORT_DATE_FORMAT, szDateFormat) ;
      }
   WindowInvalidate (PerfmonViewWindow()) ;

   // reset all the field taht may be affected by the
   // language numberic changes

   pAlert = AlertData (hWndMain) ;
   pLog = LogData (hWndMain) ;

   if (pAlert)
      {
      DialogSetInterval (hWndAlert, IDD_ALERTINTERVAL, pAlert->iIntervalMSecs) ;
      }

   if (pLog)
      {
      DialogSetInterval (hWndLog, IDD_LOGINTERVAL, pLog->iIntervalMSecs) ;
      }
}  // GetDateTimeFormats

void ConvertDecimalPoint (LPTSTR lpFloatPointStr)
{
   if (szCurrentDecimal[0] == szDecimal[0])
      {
      // no need to convert anything
      return ;
      }

   while (*lpFloatPointStr)
      {
      if (*lpFloatPointStr == szCurrentDecimal[0])
         {
         *lpFloatPointStr = szDecimal[0] ;
         break ;
         }
      ++lpFloatPointStr ;
      }
}  // ConvertDecimalPoint

void ReconvertDecimalPoint (LPTSTR lpFloatPointStr)
{
   if (szCurrentDecimal[0] == szDecimal[0])
      {
      // no need to convert anything
      return ;
      }

   while (*lpFloatPointStr)
      {
      if (*lpFloatPointStr == szDecimal[0])
         {
         *lpFloatPointStr = szCurrentDecimal[0] ;
         break ;
         }
      ++lpFloatPointStr ;
      }
}  // ReconvertDecimalPoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\perfmon.c ===
/*****************************************************************************
 *
 *  Perfmon.c - This is the WinMain module. It creates the main window and
 *              the threads, and contains the main MainWndProc.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *  Authors -
 *
 *       Russ Blake
 *       Mike Moskowitz
 *       Hon-Wah Chan
 *       Bob Watson
 *
 ****************************************************************************/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//
#undef NOSYSCOMMANDS

// DEFINE_GLOBALS will define all the globals listed in globals.h
#define DEFINE_GLOBALS

#include "perfmon.h"
#include <commctrl.h>   // for tool tip & tool bar definitions
#include <stdio.h>      // just for now
#include "command.h"

#include "graph.h"
#include "log.h"
#include "alert.h"
#include "report.h"     // for CreateReportWindow
#include "legend.h"
#include "init.h"
#include "perfmops.h"
#include "toolbar.h"    // for CreateToolbar
#include "status.h"     // for CreatePMStatusWindow
#include "utils.h"

#include "fileopen.h"   // for FileOpen


#define dwToolbarStyle     (WS_CHILD | WS_VISIBLE | TBS_NOCAPTION)

extern TCHAR szInternational[] ;

//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//

void
static
OnSize (
       HWND hWnd,
       WORD xWidth,
       WORD yHeight
       )
/*
   Effect:        Perform any actions needed when the main window is
                  resized. In particular, size the four data windows,
                  only one of which is visible right now.
*/
{
    SizePerfmonComponents () ;
}

BOOL
static
ShowSysmonNotice (
                  HWND hWnd
                  )
/*
    returns TRUE if perfmon should continue or
    FALSE if perfmon should exit
*/
{
    BOOL    bStatus;
    UINT    nRet;
    DWORD   dwSize;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    WCHAR   szString1[MAX_PATH * 2];
    WCHAR   szString2[MAX_PATH * 2];
    WCHAR   szCmdPath[MAX_PATH * 2];

    dwSize = sizeof(szString1) / sizeof(szString1[0]);
    LoadString (hInstance, SP_NOTICE_TEXT, 
        szString1, dwSize);

    dwSize = sizeof(szString2) / sizeof(szString2[0]);
    LoadString (hInstance, SP_NOTICE_CAPTION, 
        szString2, dwSize);

    nRet = MessageBoxW (
        hWnd,
        szString1,
        szString2,
        MB_OKCANCEL | MB_ICONEXCLAMATION);

    if (nRet == IDOK) {
        // then start the MMC with the sysmon console
        StartupInfo.cb = sizeof(StartupInfo); 
        StartupInfo.lpReserved = NULL; 
        StartupInfo.lpDesktop = NULL; 
        StartupInfo.lpTitle = NULL; 
        StartupInfo.dwX = CW_USEDEFAULT; 
        StartupInfo.dwY = CW_USEDEFAULT; 
        StartupInfo.dwXSize = CW_USEDEFAULT; 
        StartupInfo.dwYSize = CW_USEDEFAULT; 
        StartupInfo.dwXCountChars = 0; 
        StartupInfo.dwYCountChars = 0; 
        StartupInfo.dwFillAttribute = 0; 
        StartupInfo.dwFlags = STARTF_USEPOSITION | STARTF_USESIZE; 
        StartupInfo.wShowWindow = 0; 
        StartupInfo.cbReserved2 = 0; 
        StartupInfo.lpReserved2 = 0; 
        StartupInfo.hStdInput = 0; 
        StartupInfo.hStdOutput = 0; 
        StartupInfo.hStdError = 0; 
    
        memset (&ProcessInformation, 0, sizeof(ProcessInformation));

        dwSize = sizeof(szString1) / sizeof(szString1[0]);
        LoadString (hInstance, SP_SYSMON_CMDLINE, 
            szString1, dwSize);
        
        ExpandEnvironmentStringsW (
            szString1,
            szCmdPath, (sizeof(szCmdPath)/sizeof(szCmdPath[0])));

        bStatus = CreateProcessW (
            NULL, szCmdPath,
            NULL, NULL, FALSE,
            0,
            NULL,
            NULL,  
            &StartupInfo,
            &ProcessInformation );

        // close the handles if they were opened
        if (ProcessInformation.hProcess != NULL) CloseHandle (ProcessInformation.hProcess);
        if (ProcessInformation.hThread  != NULL) CloseHandle (ProcessInformation.hThread);

        if (bStatus) {
            // the process was created so
            return FALSE;   // tell perfmon to exit
        } else {
            LONG    lStatus;
            lStatus = GetLastError();

            dwSize = sizeof(szString2) / sizeof(szString2[0]);
            LoadString (hInstance, SP_SYSMON_CREATE_ERR, 
                szString2, dwSize);

            nRet = MessageBoxW (hWnd,
                szString2,
                NULL,
                MB_OK | MB_ICONEXCLAMATION);

            return TRUE; // keep perfmon 
        }
    } else {
        return TRUE;
    }
}


void
static
OnCreate (
         HWND hWnd
         )
/*
   Effect:        Perform all actions needed when the main window is
                  created. In particular, create the three data windows,
                  and show one of them.

   To Do:         Check for proper creation. If not possible, we will
                  need to abort creation of the program.

   Called By:     MainWndProc only, in response to a WM_CREATE message.
*/
{
    hWndGraph = CreateGraphWindow (hWnd) ;

#ifdef ADVANCED_PERFMON
    hWndLog = CreateLogWindow (hWnd) ;
    hWndAlert = CreateAlertWindow (hWnd) ;
    hWndReport = CreateReportWindow (hWnd) ;
#endif

    hWndStatus = CreatePMStatusWindow (hWnd) ;

    CreateToolbarWnd (hWnd) ;
    MinimumSize += WindowHeight (hWndToolbar) ;

    Options.bMenubar = TRUE ;
    Options.bToolbar = TRUE ;
    Options.bStatusbar = TRUE;
    Options.bAlwaysOnTop = FALSE ;

    // initialize to chart view - HWC
    iPerfmonView = IDM_VIEWCHART;


    ShowWindow (PerfmonViewWindow (), SW_SHOWNORMAL) ;
}



//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

void
MenuBarHit (
           WPARAM wParam
           )
{
    if (wParam == MENUCLOSING) {
        StatusLineReady (hWndStatus) ;
        dwCurrentMenuID = 0 ;
    } else if (HIWORD(wParam) & MF_SYSMENU) {
        WORD   SystemMenuItem = 0 ;
        switch (LOWORD (wParam)) {
            case SC_RESTORE:
                SystemMenuItem = IDM_SYSTEMRESTORE ;
                break ;

            case SC_SIZE:
                SystemMenuItem = IDM_SYSTEMSIZE ;
                break ;

            case SC_MOVE:
                SystemMenuItem = IDM_SYSTEMMOVE ;
                break ;

            case SC_MINIMIZE:
                SystemMenuItem = IDM_SYSTEMMINIMIZE ;
                break ;

            case SC_MAXIMIZE:
                SystemMenuItem = IDM_SYSTEMMAXIMIZE ;
                break ;

            case SC_CLOSE:
                SystemMenuItem = IDM_SYSTEMCLOSE ;
                break ;

            case SC_TASKLIST:
                SystemMenuItem = IDM_SYSTEMSWITCHTO ;
                break ;
        }

        if (SystemMenuItem) {
            StatusLine (hWndStatus, SystemMenuItem) ;
            dwCurrentMenuID = MenuIDToHelpID (SystemMenuItem) ;
        }
    } else {
        StatusLine (hWndStatus, LOWORD (wParam)) ;
    }
}

void
OnDropFile (
           WPARAM wParam
           )
{
    TCHAR FileName [FilePathLen + 1] ;
    LPTSTR         pFileNameStart ;
    HANDLE         hFindFile ;
    WIN32_FIND_DATA FindFileInfo ;
    int            NameOffset ;
    int            NumOfFiles = 0 ;

    NumOfFiles = DragQueryFile ((HDROP) wParam, 0xffffffff, NULL, 0) ;
    if (NumOfFiles > 0) {
        // we only open the first file for now
        DragQueryFile((HDROP) wParam, 0, FileName, FilePathLen) ;

        pFileNameStart = ExtractFileName (FileName) ;
        NameOffset = (int)(pFileNameStart - FileName) ;

        // convert short filename to long NTFS filename if necessary
        hFindFile = FindFirstFile (FileName, &FindFileInfo) ;
        if (hFindFile && hFindFile != INVALID_HANDLE_VALUE) {
            // append the file name back to the path name
            lstrcpy (&FileName[NameOffset], FindFileInfo.cFileName) ;
            FindClose (hFindFile) ;
        }

        FileOpen (hWndMain, (int)0, (LPTSTR)FileName) ;
        PrepareMenu (GetMenu (hWndMain));
    }

    DragFinish ((HDROP) wParam) ;
}

LRESULT
APIENTRY
MainWndProc (
            HWND hWnd,
            UINT message,
            WPARAM wParam,
            LPARAM lParam
            )
{
    LRESULT  lRetCode = 0L ;
    BOOL     bCallDefWinProc = FALSE ;

    switch (LOWORD (message)) {  // switch
        case WM_LBUTTONDBLCLK:
            ShowPerfmonMenu (!Options.bMenubar) ;
            if (Options.bMenubar) {
                PrepareMenu (GetMenu (hWnd)) ;
            }
            break ;

        case WM_COMMAND:
            if (PerfmonCommand (hWnd,wParam,lParam))
                return(0);
            else
                bCallDefWinProc = TRUE ;
            break;

        case WM_MENUSELECT:
            MenuBarHit (wParam) ;
            break ;

        case WM_NCHITTEST:
            /* if we have no title/menu bar, clicking and dragging the client
             * area moves the window. To do this, return HTCAPTION.
             * Note dragging not allowed if window maximized, or if caption
             * bar is present.
             */
            wParam = DefWindowProc(hWnd, message, wParam, lParam);
            if (!Options.bMenubar &&
                (wParam == HTCLIENT) &&
                !IsZoomed (hWndMain))
                return HTCAPTION ;
            else
                return wParam ;
            break ;


        case WM_SHOWWINDOW:
            PrepareMenu (GetMenu (hWnd)) ;
            break ;

        case WM_SIZE:
            OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ;
            break ;

        case WM_GETMINMAXINFO:
            {
                MINMAXINFO   *pMinMax ;

                pMinMax = (MINMAXINFO *) lParam ;
                pMinMax->ptMinTrackSize.x = MinimumSize ;
                pMinMax->ptMinTrackSize.y = MinimumSize ;
            }
            break ;

        case WM_NOTIFY:
            {
                LPTOOLTIPTEXT lpTTT = (LPTOOLTIPTEXT)lParam;

                if (lpTTT->hdr.code == TTN_NEEDTEXT) {
                    LoadString (hInstance, (UINT)lpTTT->hdr.idFrom, lpTTT->szText,
                                sizeof(lpTTT->szText)/sizeof(TCHAR));
                    return TRUE;
                } else {
                    bCallDefWinProc = FALSE ;
                    break;
                }
            }

        case WM_F1DOWN:
            if (dwCurrentDlgID) {
                CallWinHelp (dwCurrentDlgID, hWnd) ;
            } else if (dwCurrentMenuID) {
                CallWinHelp (dwCurrentMenuID, hWnd) ;
                dwCurrentMenuID = 0 ;
            }
            break ;

        case WM_CREATE:
#if 0	// no longer needed for NT5 
            if (ShowSysmonNotice (hWnd)) {
#endif
                OnCreate (hWnd) ;
                ViewChart (hWnd) ;
                PrepareMenu (GetMenu (hWnd)) ;
#if 0	// no longer needed for NT5 
            } else {
                PerfmonClose (hWnd);
            }
#endif
            break ;

        case WM_DESTROY:
            WinHelp (hWndMain, pszHelpFile, HELP_QUIT, 0) ;
            PostQuitMessage (0);
            break ;

        case WM_QUERYENDSESSION:
            // please shut it down
            return (1) ;
            break ;

        case WM_ENDSESSION:
            if (wParam == TRUE) {
                // close any log file before closing down
                PerfmonClose (hWnd) ;
                return (1) ;
            } else
                bCallDefWinProc = TRUE ;
            break ;

        case WM_CLOSE:
            PerfmonClose (hWnd) ;
            break ;

        case WM_ACTIVATE:
            {
                int   fActivate = LOWORD (wParam) ;

                bPerfmonIconic = (BOOL) HIWORD (wParam) ;
                if (bPerfmonIconic == 0 && fActivate != WA_INACTIVE) {
                    // set focus on the Legend window
                    if (iPerfmonView == IDM_VIEWCHART) {
                        SetFocus (hWndGraphLegend) ;
                    } else if (iPerfmonView == IDM_VIEWALERT) {
                        SetFocus (hWndAlertLegend) ;
                    } else if (iPerfmonView == IDM_VIEWLOG) {
                        SetFocus (hWndLogEntries) ;
                    } else if (iPerfmonView == IDM_VIEWREPORT) {
                        SetFocus (hWndReport) ;
                    }
                }
            }
            break ;

        case WM_SYSCOLORCHANGE:
            DeletePerfmonSystemObjects () ;
            CreatePerfmonSystemObjects () ;
            WindowInvalidate (PerfmonViewWindow()) ;
            break ;

        case WM_WININICHANGE:
            if (!lParam || strsamei((LPTSTR)lParam, szInternational)) {
                GetDateTimeFormats () ;
            }
            break ;

        case WM_DROPFILES:
            OnDropFile (wParam) ;
            return (0) ;
            break ;

        default:
            bCallDefWinProc = TRUE ;
            break;

    }

    if (bCallDefWinProc) {
        lRetCode = DefWindowProc (hWnd, message, wParam, lParam) ;
    }
    return (lRetCode);
}


int
WinMain (
        HINSTANCE hCurrentInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpszCmdLine,
        int nCmdShow
        )
{
    MSG      msg;

    if (!PerfmonInitialize (hCurrentInstance, hPrevInstance,
                            lpszCmdLine, nCmdShow))
        return (FALSE) ;

    DragAcceptFiles (hWndMain, TRUE) ;

    while (GetMessage (&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator(hWndMain, hAccelerators, &msg)) {
            TranslateMessage (&msg) ;
            DispatchMessage (&msg) ;
        }
    }

    return((int)msg.wParam);
}

LRESULT
MessageFilterProc (
                  int nCode,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    LPMSG lpMsg = (LPMSG)lParam ;
    extern HHOOK lpMsgFilterProc ;

    if (nCode < 0) {
        return FALSE ;
    }

    if (nCode == MSGF_DIALOGBOX || nCode == MSGF_MENU) {
        if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F1) {
            PostMessage (hWndMain, WM_F1DOWN, nCode, 0L) ;
            return TRUE ;
        }
    }

    return (DefHookProc (nCode, wParam, (LPARAM)lpMsg, &lpMsgFilterProc)) ;
}


void
SizePerfmonComponents (void)
{
    RECT           rectClient ;
    int            xWidth, yHeight ;
    int            yToolbarHeight ;
    int            yStatusHeight ;
    int            yViewHeight ;

    GetClientRect (hWndMain, &rectClient) ;
    xWidth = rectClient.right - rectClient.left ;
    yHeight = rectClient.bottom - rectClient.top ;

    if (Options.bToolbar) {
        SendMessage (hWndToolbar, WM_SIZE, 0, 0L) ;
    }

    yToolbarHeight = Options.bToolbar ? (WindowHeight (hWndToolbar) - 1) : 0 ;
    yStatusHeight = Options.bStatusbar ? StatusHeight (hWndStatus) : 0 ;

    if (Options.bStatusbar) {
        if (yToolbarHeight + yStatusHeight > yHeight) {
            // too small to display both toolbar and status bar
            // just display part of the status bar
            yStatusHeight = yHeight - yToolbarHeight ;
        }

        MoveWindow (hWndStatus,
                    0, yHeight - yStatusHeight, xWidth, yStatusHeight, TRUE) ;
        //WindowInvalidate (hWndStatus) ;
    }
    //WindowInvalidate (hWndMain) ;
    WindowShow (hWndStatus, Options.bStatusbar) ;
    WindowShow (hWndToolbar, Options.bToolbar) ;

    yViewHeight = yHeight - yStatusHeight - yToolbarHeight ;

    MoveWindow (hWndGraph,
                0, yToolbarHeight,
                xWidth, yViewHeight,
                TRUE) ;
    MoveWindow (hWndAlert,
                0, yToolbarHeight,
                xWidth, yViewHeight,
                TRUE) ;
    MoveWindow (hWndLog,
                0, yToolbarHeight,
                xWidth, yViewHeight,
                TRUE) ;
    MoveWindow (hWndReport,
                0, yToolbarHeight,
                xWidth, yViewHeight,
                TRUE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\pmemory.h ===
//LPMEMORY MemoryAllocate (DWORD dwSize) ;
#define MemoryAllocate(s) (LPMEMORY)GlobalAlloc(GPTR, s)

//VOID MemoryFree (LPMEMORY lpMemory) ;
#define MemoryFree(p)   (VOID)(p != 0 ? (VOID)GlobalFree(p) : 0)

//DWORD MemorySize (LPMEMORY lpMemory) ;
#define MemorySize(p)   (DWORD)(p != 0 ? (DWORD)GlobalSize(p) : 0)

//LPMEMORY MemoryResize (LPMEMORY lpMemory,
//                       DWORD dwNewSize) ;
#define MemoryResize(p,s)   (LPMEMORY)(p != 0 ? \
    (LPMEMORY)GlobalReAlloc (p, s, (GMEM_MOVEABLE | GMEM_ZEROINIT)) : NULL)


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\playback.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "perfmon.h"
#include "playback.h"   // external declarations for this module

#include "bookmark.h"   // for BookmarkAppend
#include "grafdata.h"   // for ResetGraph
#include "perfdata.h"   // for UpdateLinesForSystem
#include "perfmops.h"   // for SystemTimeDateString
#include "log.h"
#include "pmemory.h"    // for MemoryAllocate
#include "fileutil.h"
#include "utils.h"
#include "alert.h"      // for ResetAlert
#include "report.h"     // for ResetReport

NTSTATUS
AddNamesToArray (
                LPTSTR pNames,
                DWORD    dwLastID,
                LPWSTR   *lpCounterId
                );


void
PlaybackAddCounterName (
                       PLOGINDEX pIndex
                       );

//==========================================================================//
//                                   Macros                                 //
//==========================================================================//



#define PointerSeek(pBase, lFileOffset)         \
   ((PVOID) ((PBYTE) pBase + lFileOffset))


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


PVOID
PlaybackSeek (
             long lFileOffset
             )
{
    return (PointerSeek (PlaybackLog.pHeader, lFileOffset)) ;
}


PLOGINDEXBLOCK
FirstIndexBlock (
                PLOGHEADER pLogHeader
                )
{
    return ((PLOGINDEXBLOCK) PointerSeek (pLogHeader, pLogHeader->iLength)) ;
}


PLOGINDEX
IndexFromPosition (
                  PLOGPOSITION pLogPosition
                  )
{
    return (&pLogPosition->pIndexBlock->aIndexes [pLogPosition->iIndex]) ;
}


PPERFDATA
DataFromIndex (
              PLOGINDEX pLogIndex,
              LPTSTR lpszSystemName
              )
{
    PPERFDATA pPerfData;
    TCHAR     szLoggedComputerName[MAX_PATH + 3] ;
    int       iNumSystem ;

    // Note: NULL lpszSystemName means return first logged system name
    //       at the specified index.

    pPerfData = PlaybackSeek (pLogIndex->lDataOffset) ;

    for (iNumSystem = 0;
        iNumSystem < pLogIndex->iSystemsLogged;
        iNumSystem++) {
        if ( pPerfData &&
             pPerfData->Signature[0] == (WCHAR)'P' &&
             pPerfData->Signature[1] == (WCHAR)'E' &&
             pPerfData->Signature[2] == (WCHAR)'R' &&
             pPerfData->Signature[3] == (WCHAR)'F' ) {
            GetPerfComputerName(pPerfData, szLoggedComputerName) ;
            if (!lpszSystemName || strsamei(lpszSystemName, szLoggedComputerName)) {
                return pPerfData ;
            }
            pPerfData = (PPERFDATA)((PBYTE) pPerfData +
                                    pPerfData->TotalByteLength) ;
        } else {
            break ;
        }
    }
    return NULL ;
}


PPERFDATA
DataFromIndexPosition (
                      PLOGPOSITION pLogPosition,
                      LPTSTR lpszSystemName
                      )
{
    PLOGINDEX      pLogIndex ;
    //   long           lDataFileOffset ;

    pLogIndex = IndexFromPosition (pLogPosition) ;
    return (DataFromIndex (pLogIndex, lpszSystemName)) ;
}


BOOL
NextLogPosition (
                IN OUT PLOGPOSITION pLogPosition
                )
{
    PLOGINDEXBLOCK pIndexBlock ;

    if (pLogPosition->pIndexBlock->iNumIndexes == 0) {
        // no data in this index block.  This is most likely
        // a corrupted log file caused by system failure...
        return (FALSE) ;
    }

    if (pLogPosition->iIndex == pLogPosition->pIndexBlock->iNumIndexes - 1) {
        if (pLogPosition->pIndexBlock->lNextBlockOffset) {
            pIndexBlock =
            PlaybackSeek (pLogPosition->pIndexBlock->lNextBlockOffset) ;

            if (pIndexBlock->iNumIndexes == 0) {
                // no data in the next index block.  This is most likely
                // a corrupted log file caused by system failure...
                return (FALSE) ;
            } else {
                pLogPosition->pIndexBlock = pIndexBlock ;
                pLogPosition->iIndex = 0 ;
                return (TRUE) ;
            }
        } else
            return (FALSE) ;
    } else {
        pLogPosition->iIndex++ ;
        return (TRUE) ;
    }
}


BOOL
NextIndexPosition (
                  IN OUT PLOGPOSITION pLogPosition,
                  BOOL bCheckForNonDataIndexes
                  )
/*
   Effect:        Set pLogPosition to the next log position from
                  the current position of pLogPosition if there is one.

   Returns:       Whether there was a next log position.
*/
{
    LOGPOSITION    LP ;
    PLOGINDEX      pIndex ;
    PBOOKMARK      pBookmarkDisk, pBookmark ;
    //   LONG           lFilePosition ;

    pIndex = IndexFromPosition (pLogPosition) ;

    LP = *pLogPosition ;
    pBookmark = NULL ;

    while (TRUE) {
        if (!NextLogPosition (&LP))
            return (FALSE) ;
        pIndex = IndexFromPosition (&LP) ;

        if (pIndex && bCheckForNonDataIndexes && IsCounterNameIndex (pIndex)) {
            PlaybackAddCounterName (pIndex) ;
        }

        if (pIndex && bCheckForNonDataIndexes && IsBookmarkIndex (pIndex)) {
            if (pBookmark) {
                // this is the case when several bookmarks are
                // found before any data index...
                pBookmark->iTic = PlaybackLog.iTotalTics ;
                BookmarkAppend (&PlaybackLog.pBookmarkFirst, pBookmark) ;
            }

            pBookmarkDisk = PlaybackSeek (pIndex->lDataOffset) ;
            pBookmark = MemoryAllocate (sizeof (BOOKMARK)) ;
            if (pBookmark) {
                *pBookmark = *pBookmarkDisk;
                pBookmark->pBookmarkNext = NULL ;
            }
            else return (FALSE);
        }

        if (pIndex && IsDataIndex (pIndex)) {
            LP.iPosition++ ;
            *pLogPosition = LP ;
            if (pBookmark) {
                pBookmark->iTic = PlaybackLog.iTotalTics ;
                BookmarkAppend (&PlaybackLog.pBookmarkFirst, pBookmark) ;
            }
            return (TRUE) ;
        }
    }
}


BOOL
NextReLogIndexPosition (
                       IN OUT PLOGPOSITION pLogPosition
                       )
/*
   Effect:        Set pLogPosition to the next log position from
                  the current position of pLogPosition if there is one.
                  Will return bookmarks, counternames, or data.

   Returns:       Whether there was a next relog position.
*/
{
    LOGPOSITION    LP ;
    PLOGINDEX      pIndex ;
    //   LONG           lFilePosition ;

    pIndex = IndexFromPosition (pLogPosition) ;

    LP = *pLogPosition ;

    if (!NextLogPosition (&LP))
        return (FALSE) ;
    pIndex = IndexFromPosition (&LP) ;

    if (pIndex && IsDataIndex (pIndex)) {
        LP.iPosition++ ;
    }
    *pLogPosition = LP ;
    return (TRUE) ;
}


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//
void
PlaybackInitializeInstance (void)
{
    PlaybackLog.iStatus = iPMStatusClosed ;
    PlaybackLog.hFile = NULL ;

    PlaybackLog.szFilePath  = MemoryAllocate (FilePathLen * sizeof (TCHAR)) ;
    if (PlaybackLog.szFilePath) {
        lstrcpy (PlaybackLog.szFilePath,  szDefaultLogFileName) ;
    }
    PlaybackLog.szFileTitle = MemoryAllocate (FilePathLen * sizeof (TCHAR)) ;
    if (PlaybackLog.szFileTitle) {
        lstrcpy (PlaybackLog.szFileTitle, szDefaultLogFileName) ;
    }
}


INT
OpenPlayback (
             LPTSTR lpszFilePath,
             LPTSTR lpszFileTitle
             )
{
    BOOL     bFirstTime = TRUE ;

    lstrcpy  (PlaybackLog.szFilePath, lpszFilePath) ;
    lstrcpy  (PlaybackLog.szFileTitle, lpszFileTitle) ;
    PlaybackLog.hFile = FileHandleReadOnly (lpszFilePath) ;
    if (!PlaybackLog.hFile || PlaybackLog.hFile == INVALID_HANDLE_VALUE) {
        return (ERR_CANT_OPEN) ;
    }

    PlaybackLog.pHeader = (PLOGHEADER) FileMap (PlaybackLog.hFile,
                                                &PlaybackLog.hMapHandle) ;

    if (!PlaybackLog.pHeader) {
        if (PlaybackLog.hMapHandle) {
            CloseHandle (PlaybackLog.hMapHandle) ;
        }

        CloseHandle (PlaybackLog.hFile) ;
        return (ERR_CANT_OPEN) ;
    }

    if (!strsame (PlaybackLog.pHeader->szSignature, LogFileSignature)) {
        FileUnMap((LPVOID)PlaybackLog.pHeader, PlaybackLog.hMapHandle) ;
        CloseHandle (PlaybackLog.hFile) ;
        return (ERR_BAD_LOG_FILE) ;
    }

    PlaybackLog.BeginIndexPos.pIndexBlock = FirstIndexBlock (PlaybackLog.pHeader) ;
    PlaybackLog.BeginIndexPos.iIndex = 0 ;
    PlaybackLog.BeginIndexPos.iPosition = 0 ;
    PlaybackLog.pBookmarkFirst = NULL ;

    PlaybackLog.iTotalTics = 1 ;
    PlaybackLog.EndIndexPos = PlaybackLog.BeginIndexPos ;
    while (NextIndexPosition (&PlaybackLog.EndIndexPos, TRUE)) {
        if (bFirstTime) {
            // set the begin index to the first data index
            bFirstTime = FALSE ;
            PlaybackLog.BeginIndexPos.iIndex =
            PlaybackLog.EndIndexPos.iIndex ;
        } else {
            PlaybackLog.iTotalTics++ ;
        }
    }

    if (PlaybackLog.iTotalTics == 1 ) {
        // no data inside the log file.  It must be a corrupted
        // log file
        FileUnMap((LPVOID)PlaybackLog.pHeader, PlaybackLog.hMapHandle) ;
        CloseHandle (PlaybackLog.hFile) ;
        return (ERR_CORRUPT_LOG) ;
    }

    //   PlaybackLog.StartIndexPos = PlaybackLog.BeginIndexPos ;

    // getthe first data index
    if (!LogPositionN (1, &(PlaybackLog.StartIndexPos))) {
        PlaybackLog.StartIndexPos = PlaybackLog.BeginIndexPos ;
    }

    PlaybackLog.StopIndexPos = PlaybackLog.EndIndexPos ;
    PlaybackLog.StopIndexPos.iPosition =
    min (PlaybackLog.StopIndexPos.iPosition,
         PlaybackLog.iTotalTics - 1 ) ;


    PlaybackLog.iSelectedTics = PlaybackLog.iTotalTics ;

    PlaybackLog.iStatus = iPMStatusPlaying ;
    return (0) ;
}


void
CloseInputLog (
              HWND hWndParent
              )
{
    PBOOKMARK      pBookmark, pNextBookmark ;
    BOOL           retCode, retCode1 ;
    PLOGCOUNTERNAME pLogCounterName, pNextCounterName ;

    UNREFERENCED_PARAMETER (hWndParent) ;

    // free the bookmark list
    for (pBookmark = PlaybackLog.pBookmarkFirst ;
        pBookmark ;
        pBookmark = pNextBookmark ) {
        // save next bookmark and free current bookmark
        pNextBookmark = pBookmark->pBookmarkNext ;
        MemoryFree (pBookmark) ;
    }
    PlaybackLog.pBookmarkFirst = NULL ;

    // free all counter names stuff
    if (PlaybackLog.pBaseCounterNames) {
        MemoryFree (PlaybackLog.pBaseCounterNames) ;
    }
    PlaybackLog.pBaseCounterNames = NULL ;
    PlaybackLog.lBaseCounterNameSize = 0 ;
    PlaybackLog.lBaseCounterNameOffset = 0 ;

    for (pLogCounterName = PlaybackLog.pLogCounterNameFirst ;
        pLogCounterName ;
        pLogCounterName = pNextCounterName) {
        pNextCounterName = pLogCounterName->pCounterNameNext ;
        MemoryFree (pLogCounterName->pRemainNames) ;
        MemoryFree (pLogCounterName) ;
    }

    PlaybackLog.pLogCounterNameFirst = NULL ;

    retCode1 = FileUnMap((LPVOID)PlaybackLog.pHeader, PlaybackLog.hMapHandle) ;
    retCode = CloseHandle (PlaybackLog.hFile) ;
    PlaybackLog.iStatus = iPMStatusClosed ;

    ResetGraphView (hWndGraph) ;
    ResetAlertView (hWndAlert) ;
    ResetLogView (hWndLog) ;
    ResetReportView (hWndReport) ;
}



BOOL
LogPositionN (
             int iIndex,
             PLOGPOSITION pLP
             )
{
    LOGPOSITION    LP ;
    int            i ;

    LP = PlaybackLog.BeginIndexPos ;
    for (i = 0 ;
        i < iIndex ;
        i++) {
        if (!NextIndexPosition (&LP, FALSE))
            return (FALSE) ;
    }

    *pLP = LP ;
    return (TRUE) ;
}


PLOGINDEX
PlaybackIndexN (
               int iIndex
               )
{
    LOGPOSITION    LP ;
    int            i ;

    LP = PlaybackLog.BeginIndexPos ;
    for (i = 0 ;
        i < iIndex ;
        i++) {
        if (!NextIndexPosition (&LP, FALSE))
            return (NULL) ;
    }

    return (IndexFromPosition (&LP)) ;
}


BOOL
PlaybackLines (
              PPERFSYSTEM pSystemFirst,
              PLINE pLineFirst,
              int iLogTic
              )
{
    PLOGINDEX      pLogIndex ;
    PPERFDATA      pPerfData ;
    PPERFSYSTEM       pSystem ;
    BOOL           bAnyFound ;

    pLogIndex = PlaybackIndexN (iLogTic) ;
    if (!pLogIndex)
        return (FALSE) ;

    bAnyFound = FALSE ;
    for (pSystem = pSystemFirst ;
        pSystem ;
        pSystem = pSystem->pSystemNext) {  // for
        pPerfData = DataFromIndex (pLogIndex, pSystem->sysName) ;
        if (pPerfData) {
            UpdateLinesForSystem (pSystem->sysName,
                                  pPerfData,
                                  pLineFirst,
                                  NULL) ;
            bAnyFound = TRUE ;
        } else {
            FailedLinesForSystem (pSystem->sysName,
                                  pPerfData,
                                  pLineFirst) ;
        }
    }
    return (bAnyFound) ;
}


PPERFDATA
LogDataFromPosition (
                    PPERFSYSTEM pSystem,
                    PLOGPOSITION pLogPosition
                    )
{
    PLOGINDEX      pLogIndex ;


    if (!pLogPosition)
        return (NULL) ;

    pLogIndex = IndexFromPosition (pLogPosition) ;
    if (!pLogIndex)
        return (NULL) ;

    return (DataFromIndex (pLogIndex, pSystem->sysName)) ;
}



BOOL
LogPositionSystemTime (
                      PLOGPOSITION pLP,
                      SYSTEMTIME *pSystemTime
                      )
/*
   Effect:        Given a logposition, get the index entry for that position
                  and return the system time stored therein.
*/
{
    PLOGINDEX      pLogIndex ;

    pLogIndex = IndexFromPosition (pLP) ;
    if (!pLogIndex)
        return (FALSE) ;

    *pSystemTime = pLogIndex->SystemTime ;
    return TRUE;
}


int
LogPositionIntervalSeconds (
                           PLOGPOSITION pLPStart,
                           PLOGPOSITION pLPStop
                           )
/*
   Effect:        Return the time difference (in seconds) between the
                  system times of the two specified log positions.
*/
{
    SYSTEMTIME     SystemTimeStart ;
    SYSTEMTIME     SystemTimeStop ;


    if (LogPositionSystemTime (pLPStart, &SystemTimeStart) &&
        LogPositionSystemTime (pLPStop, &SystemTimeStop))
        return (SystemTimeDifference (&SystemTimeStart,
                                      &SystemTimeStop, TRUE)) ;
    else
        return (0) ;
}



int
PlaybackSelectedSeconds (void)
{
    return (LogPositionIntervalSeconds (&PlaybackLog.StartIndexPos,
                                        &PlaybackLog.StopIndexPos)) ;
}

void
BuildLogComputerList (
                     HWND hDlg,
                     int DlgID
                     )
{
    PPERFDATA pPerfData;
    int       iNumSystem ;
    HWND      hListBox = GetDlgItem (hDlg, DlgID) ;
    PLOGINDEX pLogIndex ;
    TCHAR     szLoggedComputerName[MAX_PATH + 3] ;

    pLogIndex = IndexFromPosition (&(PlaybackLog.StartIndexPos)) ;
    pPerfData = PlaybackSeek (pLogIndex->lDataOffset) ;

    for (iNumSystem = 0; iNumSystem < pLogIndex->iSystemsLogged; iNumSystem++) {
        if ( pPerfData &&
             pPerfData->Signature[0] == (WCHAR)'P' &&
             pPerfData->Signature[1] == (WCHAR)'E' &&
             pPerfData->Signature[2] == (WCHAR)'R' &&
             pPerfData->Signature[3] == (WCHAR)'F' ) {
            GetPerfComputerName(pPerfData, szLoggedComputerName) ;
            if (LBFind (hListBox, szLoggedComputerName) != LB_ERR) {
                // computer name already exist, we must have reach the next
                // block of perfdata
                break ;
            }
            LBAdd (hListBox, szLoggedComputerName) ;
            pPerfData = (PPERFDATA)((PBYTE) pPerfData + pPerfData->TotalByteLength) ;
        } else {
            break;
        }
    }
}

void
PlaybackAddCounterName (
                       PLOGINDEX pIndex
                       )
{
    PLOGCOUNTERNAME      pLogCounterName = NULL,
                                           pListCounterName = NULL;
    PLOGFILECOUNTERNAME  pDiskCounterName ;
    PVOID                pCounterData ;
    BOOL                 bExist = FALSE ;

    pDiskCounterName = PlaybackSeek (pIndex->lDataOffset) ;

    // check we have a record for this system
    for (pListCounterName = PlaybackLog.pLogCounterNameFirst ;
        pListCounterName ;
        pListCounterName = pListCounterName->pCounterNameNext) {
        if (strsamei(pDiskCounterName->szComputer,
                     pListCounterName->CounterName.szComputer)) {
            // found!
            pLogCounterName = pListCounterName ;
            bExist = TRUE ;
            break ;
        }
    }

    if (!bExist) {
        // new counter name record
        if (!(pLogCounterName = MemoryAllocate (sizeof(LOGCOUNTERNAME)))) {
            return ;
        }
    } else {
        // free old memory in previous counter name record.
        if (pLogCounterName->pRemainNames) {
            MemoryFree (pLogCounterName->pRemainNames) ;
        }
        pLogCounterName->pRemainNames = NULL ;
    }

    pLogCounterName->CounterName = *pDiskCounterName ;

    if (pDiskCounterName->lBaseCounterNameOffset == 0) {
        // this is the base counter names,
        // get the master copy of the counter names

        if (!(pCounterData =
              MemoryAllocate (pDiskCounterName->lUnmatchCounterNames))) {
            MemoryFree (pLogCounterName) ;
            return ;
        }

        // free the old one if it exists.
        if (PlaybackLog.pBaseCounterNames) {
            MemoryFree (PlaybackLog.pBaseCounterNames) ;
        }

        PlaybackLog.pBaseCounterNames = pCounterData ;

        pCounterData =
        PlaybackSeek (pDiskCounterName->lCurrentCounterNameOffset) ;

        memcpy (PlaybackLog.pBaseCounterNames,
                pCounterData,
                pDiskCounterName->lUnmatchCounterNames) ;

        PlaybackLog.lBaseCounterNameSize =
        pDiskCounterName->lUnmatchCounterNames ;

        PlaybackLog.lBaseCounterNameOffset =
        pDiskCounterName->lBaseCounterNameOffset ;
    } else if (pDiskCounterName->lUnmatchCounterNames) {
        // this is not a based system and it has extra counter names
        // allocate a buffer to hold them
        pLogCounterName->pRemainNames =
        MemoryAllocate (pDiskCounterName->lUnmatchCounterNames) ;

        if (pLogCounterName->pRemainNames) {
            pCounterData =
            PlaybackSeek (pDiskCounterName->lCurrentCounterNameOffset) ;

            memcpy(pLogCounterName->pRemainNames,
                   pCounterData,
                   pDiskCounterName->lUnmatchCounterNames) ;
        }
    }

    if (!bExist) {
        // now add the new counter name record to the linked list
        if (!PlaybackLog.pLogCounterNameFirst) {
            PlaybackLog.pLogCounterNameFirst = pLogCounterName ;
        } else {
            for (pListCounterName = PlaybackLog.pLogCounterNameFirst ;
                pListCounterName->pCounterNameNext ;
                pListCounterName = pListCounterName->pCounterNameNext) {
                // do nothing until we get to the end of the list
                ;
            }
            pListCounterName->pCounterNameNext = pLogCounterName ;
        }
    }

}  // PlaybackAddCounterName


LPWSTR *
LogBuildNameTable (
                  PPERFSYSTEM pSysInfo
                  )
{
    DWORD             dwArraySize ;
    PLOGCOUNTERNAME   pCounterName ;
    LPWSTR            *lpCounterId = NULL ;
    LPWSTR            lpCounterNames ;
    NTSTATUS          Status ;

    for (pCounterName = PlaybackLog.pLogCounterNameFirst ;
        pCounterName ;
        pCounterName = pCounterName->pCounterNameNext) {
        if (strsamei (pSysInfo->sysName, pCounterName->CounterName.szComputer)) {
            // found the right system
            break ;
        }
    }
    if (!pCounterName) {
        goto ERROR_EXIT ;
    }

    dwArraySize = (pCounterName->CounterName.dwLastCounterId + 1)
                  * sizeof (LPWSTR) ;

    lpCounterId = MemoryAllocate (dwArraySize +
                                  pCounterName->CounterName.lMatchLength +
                                  pCounterName->CounterName.lUnmatchCounterNames ) ;

    if (!lpCounterId) {
        goto ERROR_EXIT ;
    }

    // initialize pointers into buffer

    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    if (pCounterName->CounterName.lBaseCounterNameOffset == 0) {
        // this is the base system
        memcpy(lpCounterNames,
               PlaybackLog.pBaseCounterNames,
               PlaybackLog.lBaseCounterNameSize) ;
    } else {
        // copy the matched portion from the base system
        memcpy(lpCounterNames,
               PlaybackLog.pBaseCounterNames,
               pCounterName->CounterName.lMatchLength) ;

        // copy the unmatched portion
        if (pCounterName->CounterName.lUnmatchCounterNames) {
            memcpy(((PBYTE)lpCounterNames +
                    pCounterName->CounterName.lMatchLength),
                   pCounterName->pRemainNames,
                   pCounterName->CounterName.lUnmatchCounterNames) ;
        }
    }

    Status = AddNamesToArray (lpCounterNames,
                              pCounterName->CounterName.dwLastCounterId,
                              lpCounterId) ;

    if (Status != ERROR_SUCCESS) {
        goto ERROR_EXIT ;
    }

    pSysInfo->CounterInfo.dwLastId =
    pCounterName->CounterName.dwLastCounterId ;
    pSysInfo->CounterInfo.dwLangId =
    pCounterName->CounterName.dwLangId ;
    pSysInfo->CounterInfo.dwHelpSize = 0 ;
    pSysInfo->CounterInfo.dwCounterSize =
    pCounterName->CounterName.lMatchLength +
    pCounterName->CounterName.lUnmatchCounterNames ;

    return (lpCounterId) ;

ERROR_EXIT:
    if (lpCounterId) {
        MemoryFree (lpCounterId) ;
    }
    return (NULL) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\pmhelpid.h ===
/*****************************************************************************
 *
 *  PMHelpID.h -  This file contains meun and dialogs ids for context-sensitive
 *                help for Performance Monitor.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992 Microsoft Corporation
 *
 *  Author: Hon-Wah Chan
 *
 *          [5-Oct-1992]
 *
 *
 ****************************************************************************/



//=============================//
// "File" Menu IDs             //
//=============================//


#define HC_PM_MENU_FILENEWCHART            101
#define HC_PM_MENU_FILEOPENCHART           102
#define HC_PM_MENU_FILESAVECHART           103
#define HC_PM_MENU_FILESAVEASCHART         104
#define HC_PM_MENU_FILEEXPORTCHART         105

#define HC_PM_MENU_FILENEWALERT            106
#define HC_PM_MENU_FILEOPENALERT           107
#define HC_PM_MENU_FILESAVEALERT           108
#define HC_PM_MENU_FILESAVEASALERT         109
#define HC_PM_MENU_FILEEXPORTALERT         110

#define HC_PM_MENU_FILENEWLOG              111
#define HC_PM_MENU_FILEOPENLOG             112
#define HC_PM_MENU_FILESAVELOG             113
#define HC_PM_MENU_FILESAVEASLOG           114
#define HC_PM_MENU_FILEEXPORTLOG           115

#define HC_PM_MENU_FILENEWREPORT           116
#define HC_PM_MENU_FILEOPENREPORT          117
#define HC_PM_MENU_FILESAVEREPORT          118
#define HC_PM_MENU_FILESAVEASREPORT        119
#define HC_PM_MENU_FILEEXPORTREPORT        120

#define HC_PM_MENU_FILESAVEWORKSPACE       121
#define HC_PM_MENU_FILEEXIT                127
#define HC_NTPM_MENU_FILEEXIT              128

//=============================//
// "Edit" Menu IDs             //
//=============================//


#define HC_PM_MENU_EDITADDCHART            201
#define HC_PM_MENU_EDITMODIFYCHART         202
#define HC_PM_MENU_EDITCLEARCHART          203
#define HC_PM_MENU_EDITDELETECHART         204

#define HC_PM_MENU_EDITADDALERT            205
#define HC_PM_MENU_EDITMODIFYALERT         206
#define HC_PM_MENU_EDITCLEARALERT          207
#define HC_PM_MENU_EDITDELETEALERT         208

#define HC_PM_MENU_EDITADDLOG              209
#define HC_PM_MENU_EDITCLEARLOG            211
#define HC_PM_MENU_EDITDELETELOG           212

#define HC_PM_MENU_EDITADDREPORT           213
#define HC_PM_MENU_EDITCLEARREPORT         215
#define HC_PM_MENU_EDITDELETEREPORT        216

#define HC_PM_MENU_EDITTIMEWINDOW          217


//=============================//
// "View" Menu IDs             //
//=============================//

#define HC_PM_MENU_VIEWCHART               301
#define HC_PM_MENU_VIEWALERT               302
#define HC_PM_MENU_VIEWLOG                 303
#define HC_PM_MENU_VIEWREPORT              304


//=============================//
// "Options" Menu IDs          //
//=============================//


#define HC_PM_MENU_OPTIONSCHART            401

#define HC_PM_MENU_OPTIONSALERT            403

#define HC_PM_MENU_OPTIONSLOG              405

#define HC_PM_MENU_OPTIONSREPORT           407


#define HC_PM_MENU_OPTIONSDISPLAYMENU      408
#define HC_PM_MENU_OPTIONSDISPLAYTOOLBAR   409
#define HC_PM_MENU_OPTIONSDISPLAYSTATUS    410
#define HC_PM_MENU_OPTIONSDISPLAYONTOP     411

#define HC_PM_MENU_OPTIONSREFRESHNOW       412

#define HC_PM_MENU_OPTIONSBOOKMARK         413


#define HC_PM_MENU_OPTIONSDATASOURCE       415


//=============================//
// "Help" Menu IDs             //
//=============================//


#define HC_PM_MENU_HELPCONTENTS            501
#define HC_PM_MENU_HELPSEARCH              502
#define HC_PM_MENU_HELPHELP                503
#define HC_PM_MENU_HELPABOUT               504
#define HC_NTPM_MENU_HELPABOUT             505

//=============================//
// "System" Menu IDs           //
//=============================//
#define HC_PM_MENU_SYSTEMMENU_RESTORE      910
#define HC_PM_MENU_SYSTEMMENU_MOVE         911
#define HC_PM_MENU_SYSTEMMENU_SIZE         912
#define HC_PM_MENU_SYSTEMMENU_MINIMIZE     913
#define HC_PM_MENU_SYSTEMMENU_MAXMIZE      914
#define HC_PM_MENU_SYSTEMMENU_CLOSE        915
#define HC_PM_MENU_SYSTEMMENU_SWITCHTO     916



//=============================//
// "File" Menu Dialog IDs      //
//=============================//
#define HC_PM_idDlgFileOpen                1000
#define HC_PM_idDlgFileSaveAs              1001
#define HC_PM_idDlgFileSaveWorkSpace       1002
#define HC_PM_idDlgFileExport              1003

//=============================//
// "EditFile" Menu Dialog IDs  //
//=============================//
#define HC_PM_idDlgEditAddToChart          1010
#define HC_PM_idDlgEditAddToAlert          1011
#define HC_PM_idDlgEditAddToLog            1012
#define HC_PM_idDlgEditAddToReport         1013
#define HC_PM_idDlgEditChartLine           1014
#define HC_PM_idDlgEditAlertEntry          1015
#define HC_PM_idDlgEditTimeFrame           1016

//=============================//
// "Option" Menu Dialog IDs    //
//=============================//
#define HC_PM_idDlgOptionChart             1020
#define HC_PM_idDlgOptionAlert             1021
#define HC_PM_idDlgOptionLog               1022
#define HC_PM_idDlgOptionReport            1023
#define HC_PM_idDlgOptionDataFrom          1024
#define HC_PM_idDlgOptionBookMark          1025
#define HC_PM_idDlgOptionOpenLogFile       1026

//==============================//
// "Computer list" Dailog ID    //
// replace NetworkComputerList  //
// when playing back log file   //
//==============================//
#define HC_PM_idDlgLogComputerList         1030
#define HC_PM_idDlgSelectNetworkComputer   1031


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\playback.h ===
#define PlayingBackLog()         \
   (PlaybackLog.iStatus == iPMStatusPlaying)


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


void PlaybackInitializeInstance (void) ;

PLOGINDEXBLOCK FirstIndexBlock (PLOGHEADER pLogHeader) ;

PVOID PlaybackSeek (long lFileOffset) ;

PPERFDATA DataFromIndexPosition (PLOGPOSITION pLogPosition,
                                 LPTSTR lpszSystemName) ;


INT OpenPlayback (LPTSTR lpszFilePath, LPTSTR lpszFileTitle) ;

void CloseInputLog (HWND hWndParent) ;


BOOL OpenInputLog (HWND hWndParent) ;


PLOGINDEX PlaybackIndexN (int iIndex) ;


PLOGINDEX IndexFromPosition (PLOGPOSITION pLogPosition) ;


BOOL LogPositionN (int iIndex, PLOGPOSITION pLP) ;


BOOL NextIndexPosition (IN OUT PLOGPOSITION pLogPosition,
                        BOOL bCheckForNonDataIndexes) ;

BOOL PlaybackLines (PPERFSYSTEM pSystemFirst,
                    PLINE pLineFirst,
                    int iLogTic) ;


PPERFDATA LogDataFromPosition (PPERFSYSTEM pSystem, 
                               PLOGPOSITION pLogPosition) ;


int PlaybackSelectedSeconds (void) ;


BOOL LogPositionSystemTime (PLOGPOSITION pLP, SYSTEMTIME *pSystemTime) ;


int LogPositionIntervalSeconds (PLOGPOSITION pLPStart, 
                                PLOGPOSITION pLPStop) ;

BOOL NextReLogIndexPosition (IN OUT PLOGPOSITION pLogPosition) ;

void BuildLogComputerList (HWND hDlg, int DlgID) ;

LPWSTR *LogBuildNameTable(PPERFSYSTEM pSysInfo) ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\print.h ===
HDC PrintDC (void) ;


BOOL PrintChart (HWND hWndParent,
                 PGRAPHSTRUCT pGraph) ;


BOOL StartJob (HDC hDCPrint,
               LPTSTR lpszJobName) ;



BOOL EndJob (HDC hDCPrint) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\registry.h ===
/*****************************************************************************
 *
 *  Registry.h - This is the include file for the user config code.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *
 ****************************************************************************/

// default values for .INI files

#define DEFAULT_TIMER_INTERVAL	  2000	    // sampling interval

// LINEGRAPH
// first three are general default values. The others are specific
#define DEFAULT_VAL_BOTTOM        0
#define DEFAULT_DVAL_AXISHEIGHT   100
#define DEFAULT_MAX_VALUES        100


// LINEGRAPH DISP
#define DEFAULT_F_DISPLAY_LEGEND  TRUE
#define DEFAULT_F_DISPLAY_CALIBRATION TRUE



//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//



BOOL LoadMainWindowPlacement (HWND hWnd) ;

BOOL SaveMainWindowPlacement (HWND hWnd) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\registry.c ===
/*****************************************************************************
 *
 *  Registry.c - This module handles requests for registry data, and
 *               reading/writing of window placement data
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *
 ****************************************************************************/

#include <stdio.h>

#include "perfmon.h"
#include "registry.h"
#include "utils.h"      
#include "sizes.h"

static TCHAR PerfmonNamesKey[] = TEXT("SOFTWARE\\Microsoft\\PerfMon") ;
static TCHAR WindowKeyName[] = TEXT("WindowPos") ;
static TCHAR TimeOutKeyName[] = TEXT("DataTimeOut") ;
static TCHAR DupInstanceKeyName[] = TEXT("MonitorDuplicateInstances") ;
static TCHAR ReportEventsToEventLog[] = TEXT("ReportEventsToEventLog");
static TCHAR CapPercentsAt100[] = TEXT("CapPercentsAt100");

VOID LoadLineGraphSettings(PGRAPHSTRUCT lgraph)
{
   lgraph->gMaxValues = DEFAULT_MAX_VALUES;
   lgraph->gOptions.bLegendChecked = DEFAULT_F_DISPLAY_LEGEND;
   lgraph->gOptions.bLabelsChecked = DEFAULT_F_DISPLAY_CALIBRATION;

   return;
}

VOID LoadRefreshSettings(PGRAPHSTRUCT lgraph)
{
   lgraph->gInterval = DEF_GRAPH_INTERVAL;
   lgraph->gOptions.eTimeInterval = (FLOAT) lgraph->gInterval / (FLOAT) 1000.0 ;
   return;
}


BOOL LoadMainWindowPlacement (HWND hWnd)
   {
   WINDOWPLACEMENT   WindowPlacement ; 
   TCHAR             szWindowPlacement [TEMP_BUF_LEN] ;
   HKEY              hKeyNames ;
   DWORD             Size;
   DWORD             Type;
   DWORD             Status;
   DWORD             localDataTimeOut;
   DWORD             localFlag;
   STARTUPINFO       StartupInfo ;


   GetStartupInfo (&StartupInfo) ;

   DataTimeOut = DEFAULT_DATA_TIMEOUT ;

   Status = RegOpenKeyEx(HKEY_CURRENT_USER, PerfmonNamesKey,
      0L, KEY_READ | KEY_WRITE, &hKeyNames) ;

   if (Status == ERROR_SUCCESS)
      {
      // get the data timeout  value
      Size = sizeof(localDataTimeOut) ;

      Status = RegQueryValueEx(hKeyNames, TimeOutKeyName, NULL,
         &Type, (LPBYTE)&localDataTimeOut, &Size) ;
      if (Status == ERROR_SUCCESS && Type == REG_DWORD)
         {
         DataTimeOut = localDataTimeOut ;
         }

      // check the duplicate entry value
      Size = sizeof (localFlag);
      Status = RegQueryValueEx (hKeyNames, DupInstanceKeyName, NULL,
        &Type, (LPBYTE)&localFlag, &Size);
      if ((Status == ERROR_SUCCESS) && (Type == REG_DWORD)) {
        bMonitorDuplicateInstances = (BOOL)(localFlag == 1);
      } else {
        // value not found or not correct so set to default value
        bMonitorDuplicateInstances = TRUE;
         // and try to save it back in the registry
         localFlag = 1;
         Status = RegSetValueEx(hKeyNames, DupInstanceKeyName, 0,
            REG_DWORD, (LPBYTE)&localFlag, sizeof(localFlag));
      }

      // check the duplicate entry value
      Size = sizeof (localFlag);
      Status = RegQueryValueEx (hKeyNames, CapPercentsAt100, NULL,
        &Type, (LPBYTE)&localFlag, &Size);
      if ((Status == ERROR_SUCCESS) && (Type == REG_DWORD)) {
        bCapPercentsAt100 = (BOOL)(localFlag == 1);
      } else {
        // value not found or not correct so set to default value
        bCapPercentsAt100 = TRUE;
         // and try to save it back in the registry
         localFlag = 1;
         Status = RegSetValueEx(hKeyNames, CapPercentsAt100, 0,
            REG_DWORD, (LPBYTE)&localFlag, sizeof(localFlag));
      }

      // check the Report To Event Log entry value
      Size = sizeof (localFlag);
      Status = RegQueryValueEx (hKeyNames, ReportEventsToEventLog, NULL,
        &Type, (LPBYTE)&localFlag, &Size);
      if ((Status == ERROR_SUCCESS) && (Type == REG_DWORD)) {
        bReportEvents = (BOOL)(localFlag == 1);
      } else {
        // value not found or not correct so set to default value
        // which is disabled.
        bReportEvents = FALSE;
         // and try to save it back in the registry
         localFlag = 0;
         Status = RegSetValueEx(hKeyNames, ReportEventsToEventLog, 0,
            REG_DWORD, (LPBYTE)&localFlag, sizeof(localFlag));
      }

     
      // get the window placement data
      Size = sizeof(szWindowPlacement) ;

      Status = RegQueryValueEx(hKeyNames, WindowKeyName, NULL,
         &Type, (LPBYTE)szWindowPlacement, &Size) ;
      RegCloseKey (hKeyNames) ;

      if (Status == ERROR_SUCCESS)
         {

         int            iNumScanned ;
   
         iNumScanned = swscanf (szWindowPlacement,
            TEXT("%d %d %d %d %d %d %d %d %d"),
            &WindowPlacement.showCmd,
            &WindowPlacement.ptMinPosition.x,
            &WindowPlacement.ptMinPosition.y,
            &WindowPlacement.ptMaxPosition.x,
            &WindowPlacement.ptMaxPosition.y,
            &WindowPlacement.rcNormalPosition.left,
            &WindowPlacement.rcNormalPosition.top,
            &WindowPlacement.rcNormalPosition.right,
            &WindowPlacement.rcNormalPosition.bottom) ;
         
         if (StartupInfo.dwFlags == STARTF_USESHOWWINDOW)
            {
            WindowPlacement.showCmd = StartupInfo.wShowWindow ;
            }
         WindowPlacement.length = sizeof(WINDOWPLACEMENT);
         WindowPlacement.flags = WPF_SETMINPOSITION;
         if (!SetWindowPlacement (hWnd, &WindowPlacement)) {
            return (FALSE);
         }
         bPerfmonIconic = IsIconic(hWnd) ;
         return (TRUE) ;
         }
      }

   if (Status != ERROR_SUCCESS)
      {
      // open registry failed, use input from startup info or Max as default

      if (StartupInfo.dwFlags == STARTF_USESHOWWINDOW)
         {
         ShowWindow (hWnd, StartupInfo.wShowWindow) ;
         }
      else
         {
         ShowWindow (hWnd, SW_SHOWMAXIMIZED) ;
         }
      return (FALSE) ;
      }
   else
      return TRUE;
   }



BOOL SaveMainWindowPlacement (HWND hWnd)
   {
   WINDOWPLACEMENT   WindowPlacement ;
   TCHAR             ObjectType [2] ;
   TCHAR             szWindowPlacement [TEMP_BUF_LEN] ;
   HKEY              hKeyNames = 0 ;
   DWORD             Size ;
   DWORD             Status ;
   DWORD             dwDisposition ;
 
   ObjectType [0] = TEXT(' ') ;
   ObjectType [1] = TEXT('\0') ;

   WindowPlacement.length = sizeof(WINDOWPLACEMENT);
   if (!GetWindowPlacement (hWnd, &WindowPlacement)) {
      return FALSE;
   }
   TSPRINTF (szWindowPlacement, TEXT("%d %d %d %d %d %d %d %d %d"),
            WindowPlacement.showCmd, 
            WindowPlacement.ptMinPosition.x,
            WindowPlacement.ptMinPosition.y,
            WindowPlacement.ptMaxPosition.x,
            WindowPlacement.ptMaxPosition.y,
            WindowPlacement.rcNormalPosition.left,
            WindowPlacement.rcNormalPosition.top,
            WindowPlacement.rcNormalPosition.right,
            WindowPlacement.rcNormalPosition.bottom) ;

   // try to create it first
   Status = RegCreateKeyEx(HKEY_CURRENT_USER, PerfmonNamesKey, 0L,
      ObjectType, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS | KEY_WRITE,
      NULL, &hKeyNames, &dwDisposition) ;

   // if it has been created before, then open it
   if (dwDisposition == REG_OPENED_EXISTING_KEY)
      {
      Status = RegOpenKeyEx(HKEY_CURRENT_USER, PerfmonNamesKey, 0L,
         KEY_WRITE, &hKeyNames) ;
      }

   // we got the handle, now store the window placement data
   if (Status == ERROR_SUCCESS)
      {
      Size = (lstrlen (szWindowPlacement) + 1) * sizeof (TCHAR) ;

      Status = RegSetValueEx(hKeyNames, WindowKeyName, 0,
         REG_SZ, (LPBYTE)szWindowPlacement, Size) ;

      if (dwDisposition != REG_OPENED_EXISTING_KEY && Status == ERROR_SUCCESS)
         {
         // now add the DataTimeOut key for the first time
         Status = RegSetValueEx(hKeyNames, TimeOutKeyName, 0,
            REG_DWORD, (LPBYTE)&DataTimeOut, sizeof(DataTimeOut)) ;

         }

      RegCloseKey (hKeyNames) ;

      }

   return (Status == ERROR_SUCCESS) ;
   }




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\rptoptns.h ===
BOOL DisplayReportOptions (HWND hWndParent,
                           HWND hWndReport) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\sizes.h ===
#define FilePathLen                256


//==========================================================================//
//                                 Other                                    //
//==========================================================================//


#define ControlStringLen           160
#define MenuStringLen               80
#define MessageLen                 160
#define ProfileValueLen            120
#define ProfileKeyLen               80
#define WindowCaptionLen            40
#define ResourceStringLen           40

#define MiscTextLen                 80
#define ShortTextLen                25
#define LongTextLen                256
#define FileExtLen                   8
#define TEMP_BUF_LEN               256


//==========================================================================//
//                         Perfmon-Related Sizes                            //
//==========================================================================//


#define PerfObjectLen               80

#define MAX_SYSTEM_NAME_LENGTH      128
#define DEFAULT_COUNTER_NAME_SIZE   (2 * 4096)
#define DEFAULT_COUNTER_HELP_SIZE   (24 * 4096)
#define SMALL_BUF_LEN   16  // For numeric strings done in ASCII or whatever
#define STARTING_SYSINFO_SIZE   (48L * 1024L)
#define NM_BUF_SIZE         64

// the min and max of time interval in sec
#define MAX_INTERVALSEC    (FLOAT)2000000.0
#define MIN_INTERVALSEC    (FLOAT)0.0

// the min and max for the Graph Vertical max.
#define MAX_VERTICAL        2000000000
#define MIN_VERTICAL        1


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\report.h ===
//==========================================================================//
//                                  Constants                               //
//==========================================================================//

#define xSystemMargin               (xScrollWidth)
#define xObjectMargin               (2 * xScrollWidth)
#define xCounterMargin              (3 * xScrollWidth)
#define xColumnMargin               (xScrollWidth)

#define RightHandMargin             xObjectMargin
#define ValueMargin(pReport)       \
   (4 * xScrollWidth + pReport->xMaxCounterWidth)



#define iDefaultReportIntervalSecs  5


BOOL ReportInitializeApplication (void) ;


HWND CreateReportWindow (HWND hWndParent) ;


BOOL ReportInsertLine (HWND hWnd, PLINE pLine) ;


void SetReportPositions (HDC hDC, PREPORT pReport) ;

#if 0
PREPORT ReportData (HWND hWndReport) ;
#endif
#define ReportData(hWndReport)      \
   (&Report)

void SetReportTimer (PREPORT pReport) ;


void PlaybackReport (HWND hWndReport) ;


BOOL CurrentReportItem (HWND hWndReport) ;

BOOL AddReport (HWND hWndParent) ;
void UpdateReportData (HWND hWndReport);

void ReportTimer (HWND hWnd, BOOL bForce) ;


BOOL ReportRefresh (HWND hWnd) ;
BOOL ToggleReportRefresh (HWND hWnd) ;

BOOL SaveReport (HWND hWndReport, HANDLE hInputFile, BOOL bGetFileName) ;

BOOL OpenReport (HWND hWndReport, 
                 HANDLE hFile, 
                 DWORD dwMajorVersion,
                 DWORD dwMinorVersion,
                 BOOL bReportFile) ;


BOOL PrintReportDisplay (HDC hDC,
                         PREPORT pReport) ;


void ResetReport (HWND hWndReport) ;
void ResetReportView (HWND hWndReport) ;


void ClearReportDisplay (HWND hWndReport) ;


BOOL ReportDeleteItem (HWND hWnd) ;

BOOL PrintReport (HWND hWndParent,
                  HWND hWndReport) ;

void ExportReport (void) ;

void ReportAddAction (PREPORT pReport) ;

void ReportSystemRect (PREPORT        pReport,
                       PSYSTEMGROUP   pSystemGroup,
                       LPRECT         lpRect) ;

void ReportObjectRect (PREPORT        pReport,
                       POBJECTGROUP   pObjectGroup,
                       LPRECT         lpRect) ;

void ReportCounterRect (PREPORT        pReport,
                        PCOUNTERGROUP  pCounterGroup,
                        LPRECT         lpRect) ;

void ReportColumnRect (PREPORT pReport,
                       PCOLUMNGROUP pColumnGroup,
                       LPRECT  lpRect) ;

void ReportLineValueRect (PREPORT pReport,
                          PLINE pLine,
                          LPRECT lpRect) ;

BOOL  OnReportLButtonDown (HWND hWnd, 
                           WORD xPos,
                           WORD yPos) ;

PCOLUMNGROUP GetColumnGroup (PREPORT pReport,
                          POBJECTGROUP pObjectGroup,
                          PLINE pLine) ;

void DrawReportValue (HDC hDC, PREPORT pReport, PLINE pLine) ;

void ColumnGroupRemove (PCOLUMNGROUP pColumnGroupFirst) ;

BOOL LineCounterRemove (PCOUNTERGROUP pCGroup,
                        PLINE pLineRemove) ;

void ClearReportTimer (PREPORT pReport) ;

PSYSTEMGROUP GetSystemGroup (PREPORT pReport,
                          LPTSTR lpszSystemName) ;

POBJECTGROUP GetObjectGroup (PSYSTEMGROUP pSystemGroup,
                          LPTSTR lpszObjectName) ;

PCOUNTERGROUP GetCounterGroup (POBJECTGROUP pObjectGroup,
                            DWORD dwCounterIndex,
                            BOOL *pbCounterGroupCreated,
                            LPTSTR pCounterName,
                            BOOL    bCreateNewGroup) ;




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\rptoptns.c ===
#include "perfmon.h"

#include "report.h"     // for ReportData
#include "utils.h"
#include "playback.h"   // for PlayingBackLog
#include "pmhelpid.h"   // Help IDs

extern BOOL LocalManualRefresh ;
static DWORD iIntervalMSecs ;


void
static
OnInitDialog (
             HWND hDlg,
             PREPORT pReport
             )
{
    int  i;

    for (i = 0 ;
        i < NumIntervals ;
        i++)
        CBAddInt (DialogControl (hDlg, IDD_REPORTOPTIONSINTERVAL),
                  aiIntervals [i]) ;

    DialogSetInterval (hDlg, IDD_REPORTOPTIONSINTERVAL,
                       pReport->iIntervalMSecs) ;

    LocalManualRefresh = pReport->bManualRefresh ;

    if (LocalManualRefresh && !PlayingBackLog()) {
        DialogEnable (hDlg, IDD_REPORTOPTIONSINTERVAL, FALSE) ;
        DialogEnable (hDlg, IDD_REPORTOPTIONSINTERVALTEXT, FALSE) ;
    }

    CheckRadioButton(hDlg,
                     IDD_REPORTOPTIONSMANUALREFRESH,
                     IDD_REPORTOPTIONSPERIODIC,
                     LocalManualRefresh ? IDD_REPORTOPTIONSMANUALREFRESH :
                     IDD_REPORTOPTIONSPERIODIC) ;

    WindowCenter (hDlg) ;

}


INT_PTR
FAR
WINAPI
ReportOptionsDlgProc (
                     HWND hDlg,
                     UINT iMessage,
                     WPARAM wParam,
                     LPARAM lParam
                     )
{
    BOOL           bHandled ;

    bHandled = TRUE ;
    switch (iMessage) {
        case WM_INITDIALOG:
            dwCurrentDlgID = HC_PM_idDlgOptionReport ;
            OnInitDialog (hDlg, (PREPORT) lParam) ;
            return  (TRUE) ;

        case WM_CLOSE:
            dwCurrentDlgID = 0 ;
            EndDialog (hDlg, 0) ;
            break ;

        case WM_COMMAND:
            switch (wParam) {
                case IDD_OK:
                    {
                        FLOAT    eIntervalMSec ;

                        eIntervalMSec = DialogFloat (hDlg, IDD_REPORTOPTIONSINTERVAL, NULL) ;

                        if (eIntervalMSec > MAX_INTERVALSEC ||
                            eIntervalMSec < MIN_INTERVALSEC) {
                            DlgErrorBox (hDlg, ERR_BADTIMEINTERVAL) ;
                            SetFocus (DialogControl (hDlg, IDD_REPORTOPTIONSINTERVAL)) ;
                            EditSetTextEndPos (hDlg, IDD_REPORTOPTIONSINTERVAL) ;
                            return (FALSE) ;
                            break ;
                        }
                        eIntervalMSec = eIntervalMSec * (FLOAT) 1000.0 +
                                        (FLOAT) 0.5 ;

                        iIntervalMSecs = (DWORD) (eIntervalMSec);
                        dwCurrentDlgID = 0 ;
                        EndDialog (hDlg, 1) ;
                    }
                    break ;

                case IDD_CANCEL:
                    dwCurrentDlgID = 0 ;
                    EndDialog (hDlg, 0) ;
                    break ;

                case IDD_REPORTOPTIONSPERIODIC :
                case IDD_REPORTOPTIONSMANUALREFRESH :

                    // check if the Manual refresh is currently checked.
                    // Then toggle the ManualRefresh button
                    LocalManualRefresh =
                    (wParam == IDD_REPORTOPTIONSMANUALREFRESH) ;

                    CheckRadioButton(hDlg,
                                     IDD_REPORTOPTIONSMANUALREFRESH,
                                     IDD_REPORTOPTIONSPERIODIC,
                                     LocalManualRefresh ? IDD_REPORTOPTIONSMANUALREFRESH :
                                     IDD_REPORTOPTIONSPERIODIC ) ;

                    DialogEnable (hDlg, IDD_REPORTOPTIONSINTERVAL, !LocalManualRefresh) ;
                    DialogEnable (hDlg, IDD_REPORTOPTIONSINTERVALTEXT, !LocalManualRefresh) ;
                    break ;

                case IDD_DISPLAYHELP:
                    CallWinHelp (dwCurrentDlgID, hDlg) ;
                    break ;

                default:
                    bHandled = FALSE ;
                    break;
            }
            break;

        default:
            bHandled = FALSE ;
            break ;
    }

    return (bHandled) ;
}


BOOL
DisplayReportOptions (
                     HWND hWndParent,
                     HWND hWndReport
                     )
{
    PREPORT        pReport ;

    pReport = ReportData (hWndParent) ;

    if (DialogBoxParam (hInstance, idDlgReportOptions, hWndParent, ReportOptionsDlgProc, (LPARAM) pReport)) {
        pReport->iIntervalMSecs = iIntervalMSecs ;
        if (LocalManualRefresh != pReport->bManualRefresh) {
            ToggleReportRefresh (hWndReport) ;
        } else {
            SetReportTimer (pReport) ;
        }
    }

    return (TRUE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\report.c ===
/*****************************************************************************
 *
 *  Report.c - This file contains the report window handler.  Some of the
 *       support routines are in RptFct.c
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *  Author -
 *
 *       Hon-Wah Chan
 *
 ****************************************************************************/

#include "perfmon.h"
#include <stdio.h>      // for sprintf
#include <string.h>     // for strncpy
#include "report.h"     // Exported declarations for this file

#include "addline.h"    // for AddLine, EditLine
#include "perferr.h"    // for PostError
#include "fileutil.h"   // for FileHandleCreate
#include "line.h"       // for LineAppend
#include "pmemory.h"    // for MemoryXXX (mallloc-type) routines
#include "perfdata.h"   // for UpdateLines
#include "perfmops.h"   // for DoWindowDrag
#include "playback.h"   // for PlaybackLines, PlayingBackLog
#include "system.h"     // for SystemGet
#include "utils.h"
#include "menuids.h"    // for IDM_VIEWREPORT
#include "fileopen.h"   // for FileGetName
#include "counters.h"   // for CounterEntry


//==========================================================================//
//                                Local Data                                //
//==========================================================================//

TCHAR          szSystemFormat [ResourceStringLen] ;
TCHAR          szObjectFormat [ResourceStringLen] ;


//=============================//
// Report Class                //
//=============================//

TCHAR   szReportWindowClass[] = TEXT("PerfRpt") ;
#define dwReportClassStyle           (CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS)
#define iReportClassExtra            (0)
#define iReportWindowExtra           (0)
#define dwReportWindowStyle          (WS_CHILD | WS_VSCROLL | WS_HSCROLL)


#define szValuePlaceholder          TEXT("-999999999.999")
#define szValueLargeHexPlaceholder  TEXT(" xBBBBBBBBDDDDDDDD")

#define szHexFormat                 TEXT("x%08lX")
#define szLargeHexFormat            TEXT("x%08lX%08lX")
#define szLargeValueFormat          TEXT("%12.0f")
#define eStatusLargeValueMax        ((FLOAT) 999999999.0)
#define szValueFormat               TEXT("%12.3f")


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


PREPORT
AllocateReportData (
                   HWND hWndReport
                   )
{
    PREPORT        pReport ;

    pReport = ReportData (hWndReport) ;

    pReport->hWnd = hWndReport ;
    pReport->iStatus = iPMStatusClosed ;
    pReport->bManualRefresh = FALSE ;
    pReport->bModified = FALSE ;

    pReport->Visual.iColorIndex = 0 ;
    pReport->Visual.iWidthIndex = -1 ;
    pReport->Visual.iStyleIndex = -1 ;

    pReport->iIntervalMSecs = iDefaultReportIntervalSecs * 1000 ;
    pReport->pSystemFirst = NULL ;
    pReport->pLineFirst = NULL ;
    pReport->pLineLast = NULL ;

    pReport->CurrentItemType = REPORT_TYPE_NOTHING ;
    pReport->CurrentItem.pLine = NULL ;

    return (pReport) ;
}


void FreeReportData (PREPORT pReport) {}

void
ReportLineAppend (
                 PREPORT pReport,
                 PLINE pLineNew
                 )
{
    if (pReport->pLineFirst == NULL) {
        pReport->pLineLast =
        pReport->pLineFirst = pLineNew ;
    } else {
        (pReport->pLineLast)->pLineNext = pLineNew ;
        pReport->pLineLast = pLineNew;
    }
}


BOOL
LineCounterRemove (
                  PCOUNTERGROUP pCGroup,
                  PLINE pLineRemove
                  )
{
    PLINE          pLine ;

    if (pCGroup->pLineFirst == pLineRemove) {
        pCGroup->pLineFirst = (pCGroup->pLineFirst)->pLineCounterNext ;
        return (TRUE) ;
    }

    for (pLine = pCGroup->pLineFirst ;
        pLine->pLineCounterNext ;
        pLine = pLine->pLineCounterNext) {   // for
        if (pLine->pLineCounterNext == pLineRemove) {
            pLine->pLineCounterNext = pLineRemove->pLineCounterNext ;
            if (pLineRemove == pCGroup->pLineLast) {
                pCGroup->pLineLast = pLine;
            }
            return (TRUE) ;
        }
    }

    return (FALSE) ;
}


void
DrawCounter (
            HDC hDC,
            PREPORT pReport,
            PCOUNTERGROUP pCounterGroup
            )
{
    RECT  Rect ;

    if (!pCounterGroup->pLineFirst)
        return ;

    SelectFont (hDC, pReport->hFont) ;
    TextOut (hDC, xCounterMargin, pCounterGroup->yLine,
             pCounterGroup->pLineFirst->lnCounterName,
             lstrlen (pCounterGroup->pLineFirst->lnCounterName)) ;

    if (pCounterGroup == pReport->CurrentItem.pCounter) {
        ReportCounterRect (pReport, pCounterGroup, &Rect) ;
        DrawFocusRect (hDC, &Rect) ;
    }
}


void
DrawObject (
           HDC hDC,
           PREPORT pReport,
           POBJECTGROUP pObjectGroup
           )
{
    TCHAR          szLine [LongTextLen] ;
    PCOUNTERGROUP  pCounterGroup ;
    PCOLUMNGROUP   pColumnGroup ;

    if (!pObjectGroup->pCounterGroupFirst) {
        return ;
    }

    SelectFont (hDC, pReport->hFontHeaders) ;

    SetTextAlign (hDC, TA_RIGHT) ;

    for (pColumnGroup = pObjectGroup->pColumnGroupFirst ;
        pColumnGroup ;
        pColumnGroup = pColumnGroup->pColumnGroupNext) {
        // Draw Parent
        if (pColumnGroup->lpszParentName)
            TextOut (hDC,
                     ValueMargin (pReport) +
                     pColumnGroup->xPos + pColumnGroup->xWidth,
                     pObjectGroup->yFirstLine - pReport->yLineHeight,
                     pColumnGroup->lpszParentName,
                     lstrlen (pColumnGroup->lpszParentName)) ;

        // Draw Instance
        if (pColumnGroup->lpszInstanceName) {
            TextOut (hDC,
                     ValueMargin (pReport) +
                     pColumnGroup->xPos + pColumnGroup->xWidth,
                     pObjectGroup->yFirstLine,
                     pColumnGroup->lpszInstanceName,
                     lstrlen (pColumnGroup->lpszInstanceName)) ;
        }

        if (pColumnGroup == pReport->CurrentItem.pColumn) {
            RECT  Rect ;

            ReportColumnRect (pReport, pColumnGroup, &Rect) ;
            DrawFocusRect (hDC, &Rect) ;
        }

    }
    SetTextAlign (hDC, TA_LEFT) ;

    TSPRINTF (szLine, szObjectFormat, pObjectGroup->lpszObjectName) ;
    TextOut (hDC,
             xObjectMargin, pObjectGroup->yFirstLine,
             szLine, lstrlen (szLine)) ;

    if (pObjectGroup == pReport->CurrentItem.pObject) {
        RECT  Rect ;

        ReportObjectRect (pReport, pObjectGroup, &Rect) ;
        DrawFocusRect (hDC, &Rect) ;
    }

    SelectFont (hDC, pReport->hFont) ;

    for (pCounterGroup = pObjectGroup->pCounterGroupFirst;
        pCounterGroup;
        pCounterGroup = pCounterGroup->pCounterGroupNext) {
        DrawCounter (hDC, pReport, pCounterGroup) ;
    }

}


void
DrawSystem (
           HDC hDC,
           PREPORT pReport,
           PSYSTEMGROUP pSystemGroup
           )
{
    TCHAR          szLine [LongTextLen] ;
    POBJECTGROUP   pObjectGroup ;

    SelectFont (hDC, pReport->hFontHeaders) ;

    if (!pSystemGroup->pObjectGroupFirst)
        return ;

    SetTextAlign (hDC, TA_LEFT) ;
    TSPRINTF (szLine, szSystemFormat, pSystemGroup->lpszSystemName) ;
    TextOut (hDC,
             xSystemMargin, pSystemGroup->yFirstLine,
             szLine, lstrlen (szLine)) ;

    if (pSystemGroup == pReport->CurrentItem.pSystem) {
        RECT  Rect ;

        ReportSystemRect (pReport, pSystemGroup, &Rect) ;
        DrawFocusRect (hDC, &Rect) ;
    }

    for (pObjectGroup = pSystemGroup->pObjectGroupFirst ;
        pObjectGroup ;
        pObjectGroup = pObjectGroup->pObjectGroupNext) {
        DrawObject (hDC, pReport, pObjectGroup) ;
    }
}

void
DrawReportValue (
                HDC hDC,
                PREPORT pReport,
                PLINE pLine
                )
{
    TCHAR          szValue [20] ;
    FLOAT          eValue ;
    RECT           rectValue ;

    // skip until we have collect enough samples for the first data
    if (pLine->bFirstTime == 0) {
        eValue = CounterEntry (pLine) ;
        if (pLine->lnCounterType == PERF_COUNTER_RAWCOUNT_HEX ||
            pLine->lnCounterType == PERF_COUNTER_LARGE_RAWCOUNT_HEX) {
            if (pLine->lnCounterType == PERF_COUNTER_RAWCOUNT_HEX ||
                pLine->lnaCounterValue[0].HighPart == 0) {
                TSPRINTF (szValue,
                          szHexFormat,
                          pLine->lnaCounterValue[0].LowPart) ;
            } else {
                TSPRINTF (szValue,
                          szLargeHexFormat,
                          pLine->lnaCounterValue[0].HighPart,
                          pLine->lnaCounterValue[0].LowPart) ;
            }
        } else {
            TSPRINTF (szValue,
                      (eValue > eStatusLargeValueMax) ?
                      szLargeValueFormat : szValueFormat,
                      eValue) ;
            ConvertDecimalPoint (szValue) ;
        }
    } else {
        // draw "- - - -"
        lstrcpy(szValue, DashLine);
    }

    ReportLineValueRect (pReport, pLine, &rectValue) ;

    ExtTextOut (hDC,
                rectValue.right - 2, rectValue.top,
                ETO_CLIPPED | ETO_OPAQUE,
                &rectValue,
                szValue, lstrlen (szValue), NULL) ;

    if (pReport->CurrentItemType == REPORT_TYPE_LINE &&
        pLine == pReport->CurrentItem.pLine) {
        DrawFocusRect (hDC, &rectValue) ;
    }
}


void
DrawReportValues (
                 HDC hDC,
                 PREPORT pReport
                 )
{
    PSYSTEMGROUP   pSystemGroup ;
    POBJECTGROUP   pObjectGroup ;
    PCOUNTERGROUP  pCounterGroup ;
    PLINE          pLine ;

    SelectFont (hDC, pReport->hFont) ;
    SetTextAlign (hDC, TA_RIGHT) ;

    for (pSystemGroup = pReport->pSystemGroupFirst ;
        pSystemGroup ;
        pSystemGroup = pSystemGroup->pSystemGroupNext) {
        for (pObjectGroup = pSystemGroup->pObjectGroupFirst ;
            pObjectGroup ;
            pObjectGroup = pObjectGroup->pObjectGroupNext) {
            for (pCounterGroup = pObjectGroup->pCounterGroupFirst ;
                pCounterGroup ;
                pCounterGroup = pCounterGroup->pCounterGroupNext) {
                for (pLine = pCounterGroup->pLineFirst ;
                    pLine ;
                    pLine = pLine->pLineCounterNext) {
                    DrawReportValue (hDC, pReport, pLine) ;
                }
            }
        }
    }

}


void
DrawReportHeaders (
                  HDC hDC,
                  PREPORT pReport
                  )
{
    PSYSTEMGROUP   pSystemGroup ;

    for (pSystemGroup = pReport->pSystemGroupFirst ;
        pSystemGroup ;
        pSystemGroup = pSystemGroup->pSystemGroupNext) {
        DrawSystem (hDC, pReport, pSystemGroup) ;
    }
}


void
DrawReport (
           HDC hDC,
           PREPORT pReport
           )
{
    SetBkColor (hDC, GetSysColor(COLOR_WINDOW)) ;
    DrawReportHeaders (hDC, pReport) ;
    //UpdateLines (&(pReport->pSystemFirst), pReport->pLineFirst) ;
    DrawReportValues (hDC, pReport) ;
}



void
SetLinePosition (
                HDC hDC,
                PREPORT pReport,
                POBJECTGROUP pObjectGroup,
                PLINE pLine
                )
{
    PCOLUMNGROUP   pColumnGroup ;

    pColumnGroup = GetColumnGroup (pReport, pObjectGroup, pLine) ;
    if (!pColumnGroup) {
        pLine->xReportPos = 0 ;
        pLine->iReportColumn = -1 ;
    } else {
        pLine->xReportPos = pColumnGroup->xPos ;
        pLine->iReportColumn = pColumnGroup->ColumnNumber ;
    }
}


void
SetCounterPositions (
                    HDC hDC,
                    PREPORT pReport,
                    POBJECTGROUP pObjectGroup,
                    PCOUNTERGROUP pCounterGroup,
                    int yLine
                    )
{
    PLINE          pLine ;
    int            yPos ;


    if (!pCounterGroup->pLineFirst)
        return ;

    yPos = pCounterGroup->yLine ;

    SelectFont (hDC, pReport->hFontHeaders) ;

    for (pLine = pCounterGroup->pLineFirst ;
        pLine ;
        pLine = pLine->pLineCounterNext) {
        SetLinePosition (hDC, pReport, pObjectGroup, pLine) ;
        pLine->yReportPos = yPos ;
    }
}


void
SetColumnPositions (
                   HDC hDC,
                   PREPORT pReport,
                   POBJECTGROUP pObjectGroup
                   )
{
    int            xPos ;
    PCOLUMNGROUP   pColumnGroup ;

    xPos = 0 ;
    for (pColumnGroup = pObjectGroup->pColumnGroupFirst ;
        pColumnGroup ;
        pColumnGroup = pColumnGroup->pColumnGroupNext) {
        pColumnGroup->xWidth = max (max (pColumnGroup->ParentNameTextWidth,
                                         pColumnGroup->InstanceNameTextWidth),
                                    pReport->xValueWidth) ;
        pColumnGroup->xPos = xPos ;
        pColumnGroup->yFirstLine = pObjectGroup->yFirstLine ;
        xPos += (pColumnGroup->xWidth + xColumnMargin) ;
    }
}


void
SetObjectPositions (
                   HDC hDC,
                   PREPORT pReport,
                   POBJECTGROUP pObjectGroup,
                   int yLine
                   )
/*
   Effect:        Determine and set the logical coordinates for the
                  object pObject within the report pReport.

                  For each instance x counter, determine the appropriate
                  column, adding a column description to the object if
                  needed.

   Called By:     SetSystemPositions only.

   See Also:      SetSystemPositions, SetCounterPositions, ColumnGroup.
*/
{
    PCOUNTERGROUP  pCounterGroup ;
    int            yPos ;
    PLINE          pLine ;

    // check if there is parent name for this object type
    // if so, need to add extra space for the parent name
    if (pObjectGroup->pCounterGroupFirst) {
        pCounterGroup = pObjectGroup->pCounterGroupFirst ;
        pLine = pCounterGroup->pLineFirst ;
        if (pLine && LineParentName(pLine)) {
            pObjectGroup->yFirstLine += yLine ;
        }
    }

    SetColumnPositions (hDC, pReport, pObjectGroup) ;

    yPos = pObjectGroup->yFirstLine + yLine ;

    for (pCounterGroup = pObjectGroup->pCounterGroupFirst ;
        pCounterGroup ;
        pCounterGroup = pCounterGroup->pCounterGroupNext) {
        pCounterGroup->yLine = yPos + yLine ;

        SetCounterPositions (hDC, pReport, pObjectGroup, pCounterGroup, yLine) ;

        yPos = pCounterGroup->yLine ;
    }

    pObjectGroup->yLastLine = yPos + yLine ;
}


void
SetSystemPositions (
                   HDC hDC,
                   PREPORT pReport,
                   PSYSTEMGROUP pSystemGroup,
                   int yLine
                   )
{
    POBJECTGROUP   pObjectGroup ;
    int            yPos ;

    yPos = pSystemGroup->yFirstLine ;

    for (pObjectGroup = pSystemGroup->pObjectGroupFirst ;
        pObjectGroup ;
        pObjectGroup = pObjectGroup->pObjectGroupNext) {
        pObjectGroup->yFirstLine = yPos + yLine ;

        SetObjectPositions (hDC, pReport, pObjectGroup, yLine) ;

        yPos = pObjectGroup->yLastLine ;
    }

    pSystemGroup->yLastLine = yPos + yLine ;
}


void
static
SetScrollRanges (
                HWND hWnd
                )
{
    PREPORT        pReport ;
    RECT           rectClient ;
    int            xWidth, yHeight ;

    GetClientRect (hWnd, &rectClient) ;
    xWidth = rectClient.right - rectClient.left ;
    yHeight = rectClient.bottom - rectClient.top ;

    pReport = ReportData (hWnd) ;

    SetScrollRange (hWnd, SB_VERT,
                    0, max (0, pReport->yHeight - yHeight),
                    TRUE) ;
    SetScrollRange (hWnd, SB_HORZ,
                    0, max (0, pReport->xWidth - xWidth),
                    TRUE) ;
}

//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void
static
OnCreate (
         HWND hWnd
         )
{
    HDC            hDC ;
    PREPORT        pReport ;

    pReport = AllocateReportData (hWnd) ;
    if (!pReport)
        return ;

    pReport->hFont = hFontScales ;
    pReport->hFontHeaders = hFontScalesBold ;

    pReport->pLineFirst = NULL ;
    pReport->pSystemFirst = NULL ;

    pReport->pSystemGroupFirst = NULL ;

    hDC = GetDC (hWnd) ;

    SelectFont (hDC, pReport->hFont) ;


    pReport->yLineHeight = FontHeight (hDC, TRUE) ;
    pReport->xValueWidth = TextWidth (hDC, szValuePlaceholder) ;
    ReleaseDC (hWnd, hDC) ;

    pReport->xWidth = 0 ;
    pReport->yHeight = 0 ;

    StringLoad (IDS_SYSTEMFORMAT, szSystemFormat) ;
    StringLoad (IDS_OBJECTFORMAT, szObjectFormat) ;
}


void
static
OnPaint (
        HWND hWnd
        )
{
    HDC            hDC ;
    PAINTSTRUCT    ps ;
    PREPORT        pReport ;



    pReport = ReportData (hWnd) ;

    hDC = BeginPaint (hWnd, &ps) ;
    //hDC = hReportDC ;
    SetWindowOrgEx (hDC,
                    GetScrollPos (hWnd, SB_HORZ),
                    GetScrollPos (hWnd, SB_VERT),
                    NULL) ;

    DrawReport (hDC, pReport) ;

    EndPaint (hWnd, &ps) ;
}


void
static
UpdateReportValues (
                   PREPORT pReport
                   )
/*
   Effect:        Redraw all the visible report values of pReport.
                  Since drawing the values completely covers any
                  previous values, there is no need to erase (or flicker)
                  between updating values.

   Called By:     ReportTimer, OnVScroll, OnHScroll.
*/
{
    HDC            hDC ;

    hDC = GetDC (pReport->hWnd) ;

    if (!hDC)
        return;

    SetBkColor (hDC, GetSysColor(COLOR_WINDOW)) ;
    SetWindowOrgEx (hDC,
                    GetScrollPos (pReport->hWnd, SB_HORZ),
                    GetScrollPos (pReport->hWnd, SB_VERT),
                    NULL) ;

    DrawReportValues (hDC, pReport) ;
    ReleaseDC (pReport->hWnd, hDC) ;

}


void
static
OnHScroll (
          HWND hWnd,
          int iScrollCode,
          int iScrollNewPos
          )
{
    PREPORT        pReport ;
    int            iScrollAmt, iScrollPos, iScrollRange ;
    int            iScrollLo ;
    RECT           rectClient ;
    int            xWidth ;

    pReport = ReportData (hWnd) ;

    GetClientRect (hWnd, &rectClient) ;
    xWidth = rectClient.right - rectClient.left ;

    if (pReport->xWidth <= xWidth) {
        // no horz scroll bar, forget it
        return ;
    }

    iScrollPos = GetScrollPos (hWnd, SB_HORZ) ;

    GetScrollRange (hWnd, SB_HORZ, &iScrollLo, &iScrollRange) ;


    switch (iScrollCode) {
        case SB_LINEUP:
            iScrollAmt = - Report.yLineHeight ;
            break ;

        case SB_LINEDOWN:
            iScrollAmt = Report.yLineHeight ;
            break ;

        case SB_PAGEUP:
            iScrollAmt = - (rectClient.right - rectClient.left) / 2 ;
            break ;

        case SB_PAGEDOWN:
            iScrollAmt = (rectClient.right - rectClient.left) / 2 ;
            break ;

        case SB_THUMBPOSITION:
            iScrollAmt = iScrollNewPos - iScrollPos ;
            break ;

        default:
            iScrollAmt = 0 ;
    }

    iScrollAmt = PinInclusive (iScrollAmt,
                               -iScrollPos,
                               iScrollRange - iScrollPos) ;
    if (iScrollAmt) {
        iScrollPos += iScrollAmt ;
        ScrollWindow (hWnd, -iScrollAmt, 0, NULL, NULL) ;
        SetScrollPos (hWnd, SB_HORZ, iScrollPos, TRUE) ;
        UpdateWindow (hWnd) ;
#if 0
        UpdateReportValues (pReport) ;
#endif
    }
}


void
static
OnVScroll (
          HWND hWnd,
          int iScrollCode,
          int iScrollNewPos
          )
{
    PREPORT        pReport ;
    int            iScrollAmt, iScrollPos, iScrollRange ;
    int            iScrollLo ;
    RECT           rectClient ;

    pReport = ReportData (hWnd) ;

    iScrollPos = GetScrollPos (hWnd, SB_VERT) ;
    GetScrollRange (hWnd, SB_VERT, &iScrollLo, &iScrollRange) ;

    GetClientRect (hWnd, &rectClient) ;

    switch (iScrollCode) {
        case SB_LINEUP:
            iScrollAmt = - Report.yLineHeight ;
            break ;

        case SB_LINEDOWN:
            iScrollAmt = Report.yLineHeight ;
            break ;

        case SB_PAGEUP:
            iScrollAmt = - (rectClient.bottom - rectClient.top) / 2 ;
            break ;

        case SB_PAGEDOWN:
            iScrollAmt = (rectClient.bottom - rectClient.top) / 2 ;
            break ;

        case SB_THUMBPOSITION:
            iScrollAmt = iScrollNewPos - iScrollPos ;
            break ;

        default:
            iScrollAmt = 0 ;
    }

    iScrollAmt = PinInclusive (iScrollAmt,
                               -iScrollPos,
                               iScrollRange - iScrollPos) ;
    if (iScrollAmt) {
        iScrollPos += iScrollAmt ;
        ScrollWindow (hWnd, 0, -iScrollAmt, NULL, NULL) ;
        SetScrollPos (hWnd, SB_VERT, iScrollPos, TRUE) ;

        //        WindowInvalidate (hWnd) ;
        UpdateWindow (hWnd) ;
#if 0
        UpdateReportValues (pReport) ;
#endif
    }
}

void
static
OnKeyDown (
          HWND hWnd,
          WPARAM wParam
          )
{
    switch (wParam) {
        case VK_UP:
            OnVScroll (hWnd, SB_LINEUP, 0) ;
            break ;

        case VK_DOWN:
            OnVScroll (hWnd, SB_LINEDOWN, 0) ;
            break ;

        case VK_LEFT:
            OnHScroll (hWnd, SB_LINEUP, 0) ;
            break ;

        case VK_RIGHT:
            OnHScroll (hWnd, SB_LINEDOWN, 0) ;
            break ;

        case VK_PRIOR:
            OnVScroll (hWnd, SB_PAGEUP, 0) ;
            break ;

        case VK_NEXT:
            OnVScroll (hWnd, SB_PAGEDOWN, 0) ;
            break ;
    }
}


LRESULT
APIENTRY
ReportWndProc (
              HWND hWnd,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    BOOL           bCallDefProc ;
    LRESULT        lReturnValue ;

    bCallDefProc = FALSE ;
    lReturnValue = 0L ;

    switch (wMsg) {
        case WM_CREATE:
            OnCreate (hWnd) ;
            break ;

        case WM_LBUTTONDOWN:

            if (!OnReportLButtonDown (hWnd, LOWORD (lParam), HIWORD (lParam))) {
                // mouse click do not hit on any entries, see if we
                // need to drag Perfmon
                if (!(Options.bMenubar)) {
                    DoWindowDrag (hWnd, lParam) ;
                }
            }
            break ;

        case WM_LBUTTONDBLCLK:
            SendMessage (hWndMain, WM_LBUTTONDBLCLK, wParam, lParam) ;
            break ;

        case WM_PAINT:
            OnPaint (hWnd) ;
            break ;

        case WM_SIZE:
            SetScrollRanges (hWnd) ;
            break ;

        case WM_HSCROLL:
            OnHScroll (hWnd, LOWORD (wParam), HIWORD (wParam)) ;
            break ;

        case WM_VSCROLL:
            OnVScroll (hWnd, LOWORD (wParam), HIWORD (wParam)) ;
            break ;

        case WM_TIMER:
            ReportTimer (hWnd, FALSE) ;
            break ;

        case WM_KEYDOWN:
            OnKeyDown (hWnd, wParam) ;
            break ;

        case WM_DESTROY:
            KillTimer (hWnd, ReportTimerID) ;
            break ;

        default:
            bCallDefProc = TRUE ;
    }


    if (bCallDefProc)
        lReturnValue = DefWindowProc (hWnd, wMsg, wParam, lParam) ;

    return (lReturnValue);
}



//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

void
SetReportTimer (
               PREPORT pReport
               )
{
    if (pReport->iStatus == iPMStatusCollecting)
        KillTimer (pReport->hWnd, ReportTimerID) ;

    SetTimer (pReport->hWnd, ReportTimerID,
              pReport->iIntervalMSecs , NULL) ;
    pReport->iStatus = iPMStatusCollecting ;
}


void
ClearReportTimer (
                 PREPORT pReport
                 )
{
    pReport->iStatus = iPMStatusClosed ;
    KillTimer (pReport->hWnd, ReportTimerID) ;
}


BOOL
ReportInitializeApplication (void)
{
    BOOL           bSuccess ;
    WNDCLASS       wc ;

    //=============================//
    // Register ReportWindow class  //
    //=============================//


    wc.style         = dwReportClassStyle ;
    wc.lpfnWndProc   = ReportWndProc ;
    wc.hInstance     = hInstance ;
    wc.cbClsExtra    = iReportWindowExtra ;
    wc.cbWndExtra    = iReportClassExtra ;
    wc.hIcon         = NULL ;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
    //   wc.hbrBackground = GetStockObject (WHITE_BRUSH) ;
    wc.hbrBackground =   (HBRUSH) (COLOR_WINDOW + 1) ;
    wc.lpszMenuName  = NULL ;
    wc.lpszClassName = szReportWindowClass ;

    bSuccess = RegisterClass (&wc) ;


    //=============================//
    // Register Child classes      //
    //=============================//

    return (bSuccess) ;
}





HWND
CreateReportWindow (
                   HWND hWndParent
                   )
/*
   Effect:        Create the graph window. This window is a child of
                  hWndMain and is a container for the graph data,
                  graph label, graph legend, and graph status windows.

   Note:          We dont worry about the size here, as this window
                  will be resized whenever the main window is resized.

*/
{
    return (CreateWindow (szReportWindowClass,       // window class
                          NULL,                     // caption
                          dwReportWindowStyle,       // style for window
                          0, 0,                     // initial position
                          0, 0,                     // initial size
                          hWndParent,               // parent
                          NULL,                     // menu
                          hInstance,               // program instance
                          NULL)) ;                  // user-supplied data
}



void
SetReportPositions (
                   HDC hDC,
                   PREPORT pReport
                   )
{
    PSYSTEMGROUP   pSystemGroup ;
    int            yLine ;
    int            yPos ;


    //   pReport->xMaxCounterWidth = 0 ;

    yLine = pReport->yLineHeight ;
    yPos = 2 * yLine ;

    for (pSystemGroup = pReport->pSystemGroupFirst ;
        pSystemGroup ;
        pSystemGroup = pSystemGroup->pSystemGroupNext) {
        pSystemGroup->yFirstLine = yPos + yLine ;

        SetSystemPositions (hDC, pReport, pSystemGroup, yLine) ;

        yPos = pSystemGroup->yLastLine ;
    }

    pReport->yHeight = yPos ;

    SetScrollRanges (pReport->hWnd) ;
}



void
PlaybackReport (
               HWND hWndReport
               )
{
    PREPORT        pReport ;

    pReport = ReportData (hWndReport) ;

    PlaybackLines (pReport->pSystemFirst,
                   pReport->pLineFirst,
                   PlaybackLog.StartIndexPos.iPosition) ;
    PlaybackLines (pReport->pSystemFirst,
                   pReport->pLineFirst,
                   PlaybackLog.StopIndexPos.iPosition) ;
}


BOOL
CurrentReportItem (
                  HWND hWndReport
                  )
{
    PREPORT        pReport ;

    pReport = ReportData (hWndReport) ;
    if (!pReport)
        return (FALSE) ;

    return (pReport->CurrentItemType != REPORT_TYPE_NOTHING) ;
}



BOOL
AddReport (
          HWND hWndParent
          )
{
    PREPORT        pReport ;
    LPTSTR         pCurrentSystem ;
    POBJECTGROUP  pParentObject ;

    pReport = ReportData (hWndReport) ;

    if (pReport->CurrentItemType == REPORT_TYPE_LINE) {
        pCurrentSystem = pReport->CurrentItem.pLine->lnSystemName ;
    } else if (pReport->CurrentItemType == REPORT_TYPE_SYSTEM) {
        pCurrentSystem = pReport->CurrentItem.pSystem->lpszSystemName ;
    } else if (pReport->CurrentItemType == REPORT_TYPE_OBJECT) {
        pCurrentSystem = pReport->CurrentItem.pObject->pParentSystem->lpszSystemName ;
    } else if (pReport->CurrentItemType == REPORT_TYPE_COLUMN) {
        pParentObject =  pReport->CurrentItem.pColumn->pParentObject ;
        pCurrentSystem =  pParentObject->pParentSystem->lpszSystemName ;
    } else if (pReport->CurrentItemType == REPORT_TYPE_COUNTER) {
        pParentObject =  pReport->CurrentItem.pCounter->pParentObject ;
        pCurrentSystem =  pParentObject->pParentSystem->lpszSystemName ;
    } else {
        pCurrentSystem = NULL ;
    }


    return (AddLine (hWndParent,
                     &(pReport->pSystemFirst),
                     &(pReport->Visual),
                     pCurrentSystem,
                     LineTypeReport)) ;
}


BOOL
ToggleReportRefresh (
                    HWND hWnd
                    )
{
    PREPORT        pReport ;

    pReport = ReportData (hWnd) ;

    if (pReport->bManualRefresh)
        SetReportTimer (pReport) ;
    else
        ClearReportTimer (pReport) ;

    pReport->bManualRefresh = !pReport->bManualRefresh ;
    return (pReport->bManualRefresh) ;
}

BOOL
ReportRefresh (
              HWND hWnd
              )
{
    PREPORT        pReport ;

    pReport = ReportData (hWnd) ;

    return (pReport->bManualRefresh) ;
}



void
ReportTimer (
            HWND hWnd,
            BOOL bForce
            )
{
    PREPORT        pReport ;

    pReport = ReportData (hWnd) ;

    if (PlayingBackLog () || !pReport) {
        return;
    }

    if (bForce || !pReport->bManualRefresh) {
        UpdateLines (&(pReport->pSystemFirst), pReport->pLineFirst) ;
        if (iPerfmonView == IDM_VIEWREPORT && !bPerfmonIconic) {
            // only need to draw the data when we are viewing it...
            UpdateReportValues (pReport) ;
        }
    }
}

BOOL
SaveReport (
           HWND hWndReport,
           HANDLE hInputFile,
           BOOL bGetFileName
           )
{
    PREPORT        pReport ;
    PLINE          pLine ;
    HANDLE         hFile = NULL;
    DISKREPORT     DiskReport ;
    PERFFILEHEADER FileHeader ;
    TCHAR          szFileName [256] ;
    BOOL           newFileName = FALSE ;

    pReport = ReportData (hWndReport) ;
    if (!pReport) {
        return (FALSE) ;
    }

    if (hInputFile) {
        // use the input file handle if it is available
        // this is the case for saving workspace data
        hFile = hInputFile ;
    } else {
        if (pReportFullFileName) {
            lstrcpy (szFileName, pReportFullFileName) ;
        }
        if (bGetFileName || pReportFullFileName == NULL) {
            if (!FileGetName (hWndReport, IDS_REPORTFILE, szFileName)) {
                return (FALSE) ;
            }
            newFileName = TRUE ;
        }

        hFile = FileHandleCreate (szFileName) ;

        if (hFile && newFileName) {
            ChangeSaveFileName (szFileName, IDM_VIEWREPORT) ;
        } else if (!hFile) {
            DlgErrorBox (hWndReport, ERR_CANT_OPEN, szFileName) ;
        }
    }


    if (!hFile || hFile == INVALID_HANDLE_VALUE)
        return (FALSE) ;


    if (!hInputFile) {
        memset (&FileHeader, 0, sizeof (FileHeader)) ;
        lstrcpy (FileHeader.szSignature, szPerfReportSignature) ;
        FileHeader.dwMajorVersion = ReportMajorVersion ;
        FileHeader.dwMinorVersion = ReportMinorVersion ;

        if (!FileWrite (hFile, &FileHeader, sizeof (PERFFILEHEADER))) {
            goto Exit0 ;
        }
    }

    DiskReport.Visual = pReport->Visual ;
    DiskReport.bManualRefresh = pReport->bManualRefresh ;
    DiskReport.dwIntervalSecs = pReport->iIntervalMSecs ;
    DiskReport.dwNumLines = NumLines (pReport->pLineFirst) ;
    DiskReport.perfmonOptions = Options ;

    if (!FileWrite (hFile, &DiskReport, sizeof (DISKREPORT))) {
        goto Exit0 ;
    }

    for (pLine = pReport->pLineFirst ;
        pLine ;
        pLine = pLine->pLineNext) {
        if (!WriteLine (pLine, hFile)) {
            goto Exit0 ;
        }
    }

    if (!hInputFile) {
        CloseHandle (hFile) ;
    }

    return (TRUE) ;

    Exit0:
    if (!hInputFile) {
        CloseHandle (hFile) ;

        // only need to report error if not workspace
        DlgErrorBox (hWndReport, ERR_SETTING_FILE, szFileName) ;
    }
    return (FALSE) ;
}


void
ReportAddAction (
                PREPORT pReport
                )
{
    HDC      hDC ;

    //=============================//
    // Calculate report positions  //
    //=============================//

    hDC = GetDC (hWndReport) ;
    if (hDC) {
        SetReportPositions (hDC, pReport) ;
        ReleaseDC (hWndReport, hDC) ;
    }

}

void
UpdateReportData (
                 HWND hWndReport
                 )
{
    PREPORT pReport ;

    pReport = ReportData (hWndReport) ;
    if (PlayingBackLog ()) {
        PlaybackReport (hWndReport) ;
    } else if (pReport->iStatus == iPMStatusClosed) {
        SetReportTimer (pReport) ;
    }

    WindowInvalidate (hWndReport) ;
}


BOOL
OpenReportVer1 (
               HANDLE hFile,
               DISKREPORT *pDiskReport,
               PREPORT pReport,
               DWORD dwMinorVersion
               )
{
    HDC   hDC ;

    pReport->Visual = pDiskReport->Visual ;
    pReport->iIntervalMSecs = pDiskReport->dwIntervalSecs ;
    if (dwMinorVersion < 3) {
        // convert this to msec
        pReport->iIntervalMSecs *= 1000 ;
    }
    pReport->bManualRefresh = pDiskReport->bManualRefresh ;

    bDelayAddAction = TRUE ;
    ReadLines (hFile, pDiskReport->dwNumLines,
               &(pReport->pSystemFirst), &(pReport->pLineFirst), IDM_VIEWREPORT) ;

    if (pReport->pLineFirst) {
        // set focus on the first line
        pReport->CurrentItem.pLine = pReport->pLineFirst ;
        pReport->CurrentItemType = REPORT_TYPE_LINE ;
    }
    bDelayAddAction = FALSE ;

    //=============================//
    // Calculate report positions  //
    //=============================//

    hDC = GetDC (hWndReport) ;
    if (hDC) {
        SetReportPositions (hDC, pReport) ;
        ReleaseDC (hWndReport, hDC) ;
    }

    if (PlayingBackLog ()) {
        PlaybackReport (hWndReport) ;
    } else if (pReport->iStatus == iPMStatusClosed) {
        SetReportTimer (pReport) ;
    }

    WindowInvalidate (hWndReport) ;

    return (TRUE) ;
}



BOOL
OpenReport (
           HWND hWndReport,
           HANDLE hFile,
           DWORD dwMajorVersion,
           DWORD dwMinorVersion,
           BOOL bReportFile
           )
{
    PREPORT        pReport ;
    DISKREPORT     DiskReport ;
    BOOL           bSuccess = TRUE ;

    pReport = ReportData (hWndReport) ;
    if (!pReport) {
        bSuccess = FALSE ;
        goto Exit0 ;
    }

    if (!FileRead (hFile, &DiskReport, sizeof (DISKREPORT))) {
        bSuccess = FALSE ;
        goto Exit0 ;
    }


    switch (dwMajorVersion) {
        case (1):

            SetHourglassCursor() ;

            ResetReportView (hWndReport) ;

            OpenReportVer1 (hFile, &DiskReport, pReport, dwMinorVersion) ;

            // change to report view if we are opening a
            // report file
            if (bReportFile && iPerfmonView != IDM_VIEWREPORT) {
                SendMessage (hWndMain, WM_COMMAND, (LONG)IDM_VIEWREPORT, 0L) ;
            }

            if (iPerfmonView == IDM_VIEWREPORT) {
                SetPerfmonOptions (&DiskReport.perfmonOptions) ;
            }

            SetArrowCursor() ;

            break ;
    }

    Exit0:

    if (bReportFile) {
        CloseHandle (hFile) ;
    }

    return (bSuccess) ;
}

void
ResetReportView (
                HWND hWndReport
                )
{
    PREPORT        pReport ;

    pReport = ReportData (hWndReport) ;

    if (!pReport) {
        return ;
    }

    ChangeSaveFileName (NULL, IDM_VIEWREPORT) ;

    if (pReport->pSystemGroupFirst) {
        ResetReport (hWndReport) ;
    }
}


void
ResetReport (
            HWND hWndReport
            )
{
    PREPORT        pReport ;
    PSYSTEMGROUP   pSystemGroup, pSystemGroupDelete ;
    POBJECTGROUP   pObjectGroup, pObjectGroupDelete ;
    PCOUNTERGROUP  pCounterGroup, pCounterGroupDelete ;
    HDC            hDC ;

    pReport = ReportData (hWndReport) ;
    if (!pReport)
        return ;

    ClearReportTimer (pReport) ;

    pSystemGroup = pReport->pSystemGroupFirst ;
    while (pSystemGroup) {
        pObjectGroup = pSystemGroup->pObjectGroupFirst ;
        while (pObjectGroup) {
            pCounterGroup = pObjectGroup->pCounterGroupFirst ;
            while (pCounterGroup) {
                pCounterGroupDelete = pCounterGroup ;
                pCounterGroup = pCounterGroup->pCounterGroupNext ;
                MemoryFree (pCounterGroupDelete) ;
            }

            pObjectGroupDelete = pObjectGroup ;
            pObjectGroup = pObjectGroup->pObjectGroupNext ;
            ColumnGroupRemove (pObjectGroupDelete->pColumnGroupFirst) ;
            MemoryFree (pObjectGroupDelete->lpszObjectName) ;
            MemoryFree (pObjectGroupDelete) ;
        }

        pSystemGroupDelete = pSystemGroup ;
        pSystemGroup = pSystemGroup->pSystemGroupNext ;
        MemoryFree (pSystemGroupDelete->lpszSystemName) ;
        MemoryFree (pSystemGroupDelete) ;
    }

    FreeLines (pReport->pLineFirst) ;
    pReport->pLineFirst = NULL ;

    FreeSystems (pReport->pSystemFirst) ;
    pReport->pSystemFirst = NULL ;

    pReport->pSystemGroupFirst = NULL ;
    pReport->CurrentItemType   = REPORT_TYPE_NOTHING ;
    pReport->CurrentItem.pLine = NULL ;

    // reset scrolling ranges
    pReport->xWidth = 0 ;
    pReport->yHeight = 0 ;
    pReport->xMaxCounterWidth = 0 ;
    hDC = GetDC (hWndReport) ;
    if (hDC) {
        SetReportPositions (hDC, pReport) ;

        SelectFont (hDC, pReport->hFont) ;
        pReport->xValueWidth = TextWidth (hDC, szValuePlaceholder) ;

        ReleaseDC (hWndReport, hDC) ;
    }

    WindowInvalidate (hWndReport) ;
}

void
ClearReportDisplay (
                   HWND hWndReport
                   )
{
    PREPORT        pReport ;
    PLINE          pLine;

    if (PlayingBackLog()) {
        return ;
    }

    pReport = ReportData (hWndReport) ;
    if (!pReport || !pReport->pLineFirst)
        return ;

    for (pLine = pReport->pLineFirst ;
        pLine ;
        pLine = pLine->pLineNext) {
        // reset the new data counts
        pLine->bFirstTime = 2 ;
    }

    // re-draw the values
    UpdateReportValues (pReport) ;

}

//=========================================
// we don't print. we just export
//
// if need printing, define KEEP_PRINT
//=========================================
#ifdef KEEP_PRINT
BOOL
PrintReportDisplay (
                   HDC hDC,
                   PREPORT pReport
                   )
{
    SetReportPositions (hDC, pReport) ;
    DrawReport (hDC, pReport) ;
    return TRUE ;
}



BOOL
PrintReport (
            HWND hWndParent,
            HWND hWndReport
            )
{
    PREPORT        pReport ;
    HDC            hDC ;
    int            xPageWidth ;
    int            yPageHeight ;
    int            xValueWidth ;

    HFONT          hFont, hFontHeaders ;
    int            yLineHeight ;

    pReport = ReportData (hWndReport) ;
    if (!pReport)
        return (FALSE) ;

    hDC = PrintDC () ;
    if (!hDC) {
        PostError () ;
        return (FALSE) ;
    }

    xPageWidth = GetDeviceCaps (hDC, HORZRES) ;
    yPageHeight = GetDeviceCaps (hDC, VERTRES) ;


    StartJob (hDC, TEXT("Performance Monitor Report")) ;
    StartPage (hDC) ;


    hFont = pReport->hFont ;
    hFontHeaders = pReport->hFontHeaders ;
    yLineHeight = pReport->yLineHeight ;
    xValueWidth = pReport->xValueWidth ;

    pReport->hFont = hFontPrinterScales ;
    pReport->hFontHeaders = hFontPrinterScalesBold ;

    SelectFont (hDC, pReport->hFont) ;
    pReport->yLineHeight = FontHeight (hDC, TRUE) ;

    pReport->xValueWidth = TextWidth (hDC, szValuePlaceholder) ;

    PrintReportDisplay (hDC, pReport) ;

    EndPage (hDC) ;
    EndJob (hDC) ;

    DeleteDC (hDC) ;


    pReport->hFont = hFont ;
    pReport->hFontHeaders = hFontHeaders ;
    pReport->yLineHeight = yLineHeight ;

    pReport->xValueWidth = xValueWidth ;

    hDC = GetDC (hWndReport) ;
    SetReportPositions (hDC, pReport) ;
    ReleaseDC (hWndReport, hDC) ;

    return (FALSE) ;
}

// we don't print. we just export
#endif

#if 0
/*
    NOTE:
        this function was attempted as a replacement for the
        FindEquivalentLine function used to locate matching
        report entries. It "Almost" works, but because of how
        the new entries (lines) are added to the list. Since new
        columns aren't added in a timely fashion for this test
        to work, the list of counters still must be searched
        sequentially. To make this indexed search work for "bulk"
        additions, the column updating/addtion must take place
        more "synchronously" with the counter addition.

        -- bobw 2-Jan-97

*/
PLINE
FindEquivalentReportLine (
                         PLINE pLineToFind,
                         PREPORT pReport
                         )
{
    PLINE          pLine = NULL;
    PLINE          pLastEquivLine = NULL;

    BOOL           bNotUsed;

    PSYSTEMGROUP   pSystemGroup = NULL;
    POBJECTGROUP   pObjectGroup = NULL;
    PCOUNTERGROUP  pCounterGroup = NULL;
    PCOLUMNGROUP   pColumnGroup = NULL;
    PCOLUMNGROUP   pMatchingColumn = NULL;
    int            dwColumn;

    // since the report data is organized hierarchically, we'll search
    // that way instead of just looking at each lin

    pSystemGroup = GetSystemGroup (pReport, pLineToFind->lnSystemName);

    if (pSystemGroup != NULL) {
        // found the system that this line belongs to so look up the
        // object
        pObjectGroup = GetObjectGroup (pSystemGroup, pLineToFind->lnObjectName) ;
        if (pObjectGroup != NULL) {
            // find matching instance column
            for (pColumnGroup = pObjectGroup->pColumnGroupFirst;
                pColumnGroup;
                pColumnGroup = pColumnGroup->pColumnGroupNext) {
                if (pstrsame (pLineToFind->lnInstanceName, pColumnGroup->lpszInstanceName) &&
                    pstrsame (pLineToFind->lnPINName, pColumnGroup->lpszParentName)) {
                    // this column has the same name as the one we're
                    // looking for so find the highest matching index value
                    if (pMatchingColumn == NULL) {
                        pMatchingColumn = pColumnGroup;
                    } else {
                        if (pColumnGroup->dwInstanceIndex > pMatchingColumn->dwInstanceIndex) {
                            pMatchingColumn = pColumnGroup;
                        }
                    }
                }
            }
            if (pMatchingColumn == NULL) {
                dwColumn = 0;
            } else {
                dwColumn = (int)pMatchingColumn->ColumnNumber;
            }
            // then try to find the matching counter in this column
            pCounterGroup = GetCounterGroup (pObjectGroup,
                                             pLineToFind->lnCounterDef.CounterNameTitleIndex,
                                             &bNotUsed,
                                             pLineToFind->lnCounterName,
                                             FALSE);

            if (pCounterGroup != NULL) {
                // search the instances of this counter group for a match
                for (pLine = pCounterGroup->pLineFirst ;
                    pLine ;
                    pLine = pLine->pLineNext) {
                    if (pLine->iReportColumn == dwColumn) {
                        // match counter names to confir
                        if (pstrsame(pLine->lnCounterName,
                                     pLineToFind->lnCounterName)) {
                            pLastEquivLine = pLine;
                            break;
                        }
                    }
                }
            }
        }
    }
    return (pLastEquivLine) ;
}
#endif

BOOL
ReportInsertLine (
                 HWND hWnd,
                 PLINE pLine
                 )
/*
   Effect:        Insert the line pLine into the data structures for the
                  Report of window hWnd. The line is added to the list of
                  lines, and also added to the report structure in the
                  appropriate System, Object, and Counter.

   Returns:       Whether the function was successful. If this function
                  returns FALSE, the line was not added.
*/
{
    HDC            hDC ;
    PREPORT        pReport ;
    PSYSTEMGROUP   pSystemGroup ;
    POBJECTGROUP   pObjectGroup ;
    PCOUNTERGROUP  pCounterGroup ;
    PLINE          pLineEquivalent ;
    int            OldCounterWidth ;
    BOOL           bNewCounterGroup ;

    pReport = ReportData (hWnd) ;
    pReport->bModified = TRUE ;

    pLineEquivalent = FindEquivalentLine (pLine, pReport->pLineFirst);
    if (pLineEquivalent) {
        if (bMonitorDuplicateInstances) {
            pLine->dwInstanceIndex = pLineEquivalent->dwInstanceIndex + 1;
        } else {
            return (FALSE) ;
        }
    }
    //=============================//
    // Add line, line's system     //
    //=============================//

    ReportLineAppend (pReport, pLine) ;


    //=============================//
    // Find correct spot; add line //
    //=============================//

    pSystemGroup = GetSystemGroup (pReport, pLine->lnSystemName) ;
    pObjectGroup = GetObjectGroup (pSystemGroup, pLine->lnObjectName) ;
    pCounterGroup = GetCounterGroup (pObjectGroup,
                                     pLine->lnCounterDef.CounterNameTitleIndex,
                                     &bNewCounterGroup,
                                     pLine->lnCounterName,
                                     TRUE);

    if (!pCounterGroup)
        return (FALSE) ;

    LineCounterAppend (pCounterGroup, pLine) ;

    //=============================//
    // Calculate report positions  //
    //=============================//
    hDC = GetDC (hWnd) ;
    SelectFont (hDC, pReport->hFontHeaders) ;

    if (bNewCounterGroup) {
        // re-calc. the max. counter group width
        OldCounterWidth = pReport->xMaxCounterWidth ;
        pReport->xMaxCounterWidth =
        max (pReport->xMaxCounterWidth,
             TextWidth (hDC, pLine->lnCounterName)) ;
        if (OldCounterWidth < pReport->xMaxCounterWidth) {
            // adjust the report width with the new counter width
            pReport->xWidth +=
            (pReport->xMaxCounterWidth - OldCounterWidth);
        }
    }

    if (pLine->lnCounterType == PERF_COUNTER_LARGE_RAWCOUNT_HEX) {
        SelectFont (hDC, pReport->hFont) ;
        pReport->xValueWidth = TextWidth (hDC, szValueLargeHexPlaceholder) ;
    }

    if (!bDelayAddAction) {
        SetReportPositions (hDC, pReport) ;
    }
    ReleaseDC (hWnd, hDC) ;

    pReport->CurrentItem.pLine = pLine ;
    pReport->CurrentItemType = REPORT_TYPE_LINE ;

    if (!bDelayAddAction) {
        if (PlayingBackLog ()) {
            PlaybackReport (hWndReport) ;
        } else if (pReport->iStatus == iPMStatusClosed) {
            SetReportTimer (pReport) ;
        }

        WindowInvalidate (hWnd) ;
    }
    return (TRUE) ;
}


BOOL
ExportComputerName (
                   HANDLE hFile,
                   PSYSTEMGROUP pSystemGroup
                   )
{
    int            StringLen ;
    BOOL           bWriteSuccess = TRUE ;
    CHAR           TempBuff [LongTextLen] ;
    TCHAR          UnicodeBuff [LongTextLen] ;

    // export computer name
    strcpy (TempBuff, LineEndStr) ;
    strcat (TempBuff, LineEndStr) ;
    StringLen = strlen (TempBuff) ;
    TSPRINTF (UnicodeBuff, szSystemFormat, pSystemGroup->lpszSystemName) ;
    ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
    strcat (TempBuff, LineEndStr) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        bWriteSuccess = FALSE ;
    }

    return (bWriteSuccess) ;
}

#define WRITE_FILE_TIME 2
BOOL
ExportObjectName (
                 HANDLE hFile,
                 POBJECTGROUP pObjectGroup,
                 int *pColNum
                 )
{
    int            StringLen ;
    BOOL           bNeedToExport ;
    BOOL           bWriteSuccess = TRUE ;
    PCOLUMNGROUP   pColumnGroup ;
    int            ParentNum, InstanceNum ;
    int            TimeToWrite ;
    CHAR           TempBuff [512] ;
    TCHAR          UnicodeBuff [512] ;

    ParentNum = InstanceNum = 0 ;

    if (pColNum) {
        *pColNum = 0 ;
    }

    // export object name
    strcpy (TempBuff, LineEndStr) ;
    StringLen = strlen (TempBuff) ;
    TSPRINTF (UnicodeBuff, szObjectFormat, pObjectGroup->lpszObjectName) ;
    ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
    strcat (TempBuff, LineEndStr) ;

    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        goto Exit0 ;
    }


    TimeToWrite = 0 ;

    // export column group
    if (pObjectGroup->pColumnGroupFirst) {
        strcpy (TempBuff, pDelimiter) ;
        strcat (TempBuff, pDelimiter) ;
        StringLen = strlen (TempBuff) ;

        bNeedToExport = FALSE ;

        // export Parent Names
        for (pColumnGroup = pObjectGroup->pColumnGroupFirst ;
            pColumnGroup ;
            pColumnGroup = pColumnGroup->pColumnGroupNext) {

            if (pColumnGroup->lpszParentName) {
                ParentNum++ ;
                bNeedToExport = TRUE ;
                ConvertUnicodeStr (&TempBuff[StringLen],
                                   pColumnGroup->lpszParentName) ;
                StringLen = strlen (TempBuff) ;
            }

            strcat (&TempBuff[StringLen], pDelimiter) ;
            StringLen = strlen (TempBuff) ;

            // check if we need to export this line before it is filled up
            TimeToWrite++ ;
            if (TimeToWrite > WRITE_FILE_TIME) {
                if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
                    goto Exit0 ;
                }
                TimeToWrite = 0 ;
                StringLen = 0 ;
                TempBuff[0] = TEXT('\0') ;
            }
        }

        // write the line delimiter
        strcpy (&TempBuff[StringLen], LineEndStr) ;
        if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
            goto Exit0 ;
        }

        if (!bNeedToExport) {
            ParentNum = 0 ;
        }


        // setup to export Instances
        strcpy (TempBuff, pDelimiter) ;
        strcat (TempBuff, pDelimiter) ;
        StringLen = strlen (TempBuff) ;
        bNeedToExport = FALSE ;
        TimeToWrite = 0 ;

        // export Instance Names
        for (pColumnGroup = pObjectGroup->pColumnGroupFirst ;
            pColumnGroup ;
            pColumnGroup = pColumnGroup->pColumnGroupNext) {

            if (pColumnGroup->lpszInstanceName) {
                InstanceNum++ ;
                bNeedToExport = TRUE ;
                ConvertUnicodeStr (&TempBuff[StringLen],
                                   pColumnGroup->lpszInstanceName) ;
                StringLen = strlen (TempBuff) ;
            }

            strcat (&TempBuff[StringLen], pDelimiter) ;
            StringLen = strlen (TempBuff) ;

            // check if we need to export this line before it is filled up
            TimeToWrite++ ;
            if (TimeToWrite > WRITE_FILE_TIME) {
                if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
                    goto Exit0 ;
                }
                TimeToWrite = 0 ;
                StringLen = 0 ;
                TempBuff[0] = TEXT('\0') ;
            }
        }

        // write the line delimiter
        strcpy (&TempBuff[StringLen], LineEndStr) ;
        if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
            goto Exit0 ;
        }

        if (!bNeedToExport) {
            InstanceNum = 0 ;
        }
    }

    if (pColNum) {
        *pColNum = max (ParentNum, InstanceNum) ;
    }

    return (TRUE) ;

    Exit0:
    return (FALSE) ;

}

BOOL
ExportLineName (
               HANDLE hFile,
               PLINE pLine,
               int *pExportCounterName
               )
{
    FLOAT          eValue ;
    int            StringLen ;
    BOOL           bWriteSuccess = TRUE ;
    CHAR           TempBuff [LongTextLen] ;
    TCHAR          UnicodeBuff [LongTextLen] ;


    strcpy (TempBuff, pDelimiter) ;

    if (*pExportCounterName) {
        StringLen = strlen (TempBuff) ;
        ConvertUnicodeStr (&TempBuff[StringLen], pLine->lnCounterName) ;
        strcat (TempBuff, pDelimiter) ;
        *pExportCounterName = FALSE ;
    }
    StringLen = strlen (TempBuff) ;

    if (pLine->bFirstTime == 0) {
        eValue = CounterEntry (pLine) ;

        if (pLine->lnCounterType == PERF_COUNTER_RAWCOUNT_HEX ||
            pLine->lnCounterType == PERF_COUNTER_LARGE_RAWCOUNT_HEX) {
            if (pLine->lnCounterType == PERF_COUNTER_RAWCOUNT_HEX ||
                pLine->lnaCounterValue[0].HighPart == 0) {
                TSPRINTF (UnicodeBuff,
                          szHexFormat,
                          pLine->lnaCounterValue[0].LowPart) ;
            } else {
                TSPRINTF (UnicodeBuff,
                          szLargeHexFormat,
                          pLine->lnaCounterValue[0].HighPart,
                          pLine->lnaCounterValue[0].LowPart) ;
            }
        } else {
            TSPRINTF (UnicodeBuff,
                      (eValue > eStatusLargeValueMax) ?
                      szLargeValueFormat : szValueFormat,
                      eValue) ;
            ConvertDecimalPoint (UnicodeBuff) ;
        }
        ConvertUnicodeStr (&TempBuff[StringLen], UnicodeBuff) ;
    } else {
        // export "----" for unstable values
        strcat (&TempBuff[StringLen], "----");
    }

    // write the line value
    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        goto Exit0 ;
    }

    return (TRUE) ;


    Exit0:
    return (FALSE) ;
}


// This routine is need to insert the line values into its
// column location.  It is needed because not all the instances (columns)
// are available for the same line.
void
SaveColumnLineData (
                   PLINE pLine,
                   LPSTR pColumnLineData
                   )
{
    FLOAT          eValue ;
    LPSTR          pColumnLine ;
    CHAR           TempBuff [LongTextLen] ;
    TCHAR          UnicodeBuff [LongTextLen] ;

    if (!pColumnLineData || pLine->iReportColumn < 0) {
        return ;
    }

    // find the offset into the pColumnLineData buffer for current line
    pColumnLine = pColumnLineData + pLine->iReportColumn * ShortTextLen ;

    if (pLine->bFirstTime == 0) {
        eValue = CounterEntry (pLine) ;


        if (pLine->lnCounterType == PERF_COUNTER_RAWCOUNT_HEX ||
            pLine->lnCounterType == PERF_COUNTER_LARGE_RAWCOUNT_HEX) {
            if (pLine->lnCounterType == PERF_COUNTER_RAWCOUNT_HEX ||
                pLine->lnaCounterValue[0].HighPart == 0) {
                TSPRINTF (UnicodeBuff,
                          szHexFormat,
                          pLine->lnaCounterValue[0].LowPart) ;
            } else {
                TSPRINTF (UnicodeBuff,
                          szLargeHexFormat,
                          pLine->lnaCounterValue[0].HighPart,
                          pLine->lnaCounterValue[0].LowPart) ;
            }
        } else {
            TSPRINTF (UnicodeBuff,
                      (eValue > eStatusLargeValueMax) ?
                      szLargeValueFormat : szValueFormat,
                      eValue) ;
            ConvertDecimalPoint (UnicodeBuff) ;
        }
        ConvertUnicodeStr (TempBuff, UnicodeBuff) ;
        strncpy (pColumnLine, TempBuff, ShortTextLen) ;
        *(pColumnLine + ShortTextLen - 1) = '\0' ;
    } else {
        // export "----" for unstable values
        strcpy (pColumnLine, "----");
    }
}

BOOL
ExportColumnLineData (
                     HANDLE hFile,
                     int ColumnTotal,
                     PCOUNTERGROUP pCounterGroup,
                     LPSTR pColumnLineData
                     )
{
    int            iIndex ;
    int            StringLen ;
    CHAR           TempBuff [LongTextLen] ;
    LPSTR          pCurrentLineData ;

    // export the counter name
    strcpy (TempBuff, pDelimiter) ;
    StringLen = strlen (TempBuff) ;
    ConvertUnicodeStr (&TempBuff[StringLen], pCounterGroup->pLineFirst->lnCounterName) ;
    strcat (TempBuff, pDelimiter) ;
    if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) {
        goto Exit0 ;
    }

    // go thru each column and export the line value if it has been stored
    for (iIndex = 0, pCurrentLineData = pColumnLineData ;
        iIndex < ColumnTotal ;
        iIndex++, pCurrentLineData += ShortTextLen ) {
        if (*pCurrentLineData != 0) {
            // data available for this column
            if (!FileWrite (hFile, pCurrentLineData, strlen(pCurrentLineData))) {
                goto Exit0 ;
            }
        }

        if (!FileWrite (hFile, pDelimiter, strlen(pDelimiter))) {
            goto Exit0 ;
        }
    }

    if (!FileWrite (hFile, LineEndStr, strlen(LineEndStr))) {
        goto Exit0 ;
    }

    return (TRUE) ;


    Exit0:
    return (FALSE) ;

}

void
ExportReport (void)
{
    HANDLE         hFile = 0 ;
    PREPORT        pReport ;
    PSYSTEMGROUP   pSystemGroup ;
    POBJECTGROUP   pObjectGroup ;
    PCOUNTERGROUP  pCounterGroup ;
    PLINE          pLine ;
    BOOL           bExportComputer ;
    BOOL           bExportObject ;
    BOOL           bExportCounterName ;
    int            ColumnTotal = 0 ;
    LPSTR          pColumnLineData = NULL ;
    LPTSTR         pFileName = NULL ;
    INT            ErrCode = 0 ;

    if (!(pReport = ReportData (hWndReport))) {
        return ;
    }

    // see if there is anything to export..
    if (!(pReport->pSystemGroupFirst)) {
        return ;
    }

    SetHourglassCursor() ;

    if (ErrCode = ExportFileOpen (hWndReport, &hFile,
                                  pReport->iIntervalMSecs, &pFileName)) {
        goto Exit0 ;
    }

    if (!pFileName) {
        // the case when user cancel
        goto Exit0 ;
    }

    // export each system group

    for (pSystemGroup = pReport->pSystemGroupFirst ;
        pSystemGroup ;
        pSystemGroup = pSystemGroup->pSystemGroupNext) {

        bExportComputer = TRUE ;

        for (pObjectGroup = pSystemGroup->pObjectGroupFirst ;
            pObjectGroup ;
            pObjectGroup = pObjectGroup->pObjectGroupNext) {

            bExportObject = TRUE ;

            for (pCounterGroup = pObjectGroup->pCounterGroupFirst ;
                pCounterGroup ;
                pCounterGroup = pCounterGroup->pCounterGroupNext) {

                bExportCounterName = TRUE ;

                // Column data buffer has been allocated for this object type,
                // zero out the buffer and prepare for next round.

                if (pColumnLineData) {
                    memset (pColumnLineData, 0, ColumnTotal * ShortTextLen) ;
                }

                for (pLine = pCounterGroup->pLineFirst ;
                    pLine ;
                    pLine = pLine->pLineCounterNext) {

                    if (bExportComputer) {
                        // only need to do this for the first object
                        bExportComputer = FALSE ;
                        if (!ExportComputerName (hFile, pSystemGroup)) {
                            ErrCode = ERR_EXPORT_FILE ;
                            goto Exit0 ;
                        }
                    }

                    if (bExportObject) {
                        // only need to do this for the first counter group
                        bExportObject = FALSE ;
                        if (!ExportObjectName (hFile, pObjectGroup, &ColumnTotal)) {
                            ErrCode = ERR_EXPORT_FILE ;
                            goto Exit0 ;
                        }

                        if (ColumnTotal > 1) {
                            // special case to setup a column array and export
                            // the line values later
                            pColumnLineData = MemoryAllocate (ColumnTotal * ShortTextLen) ;
                            if (!pColumnLineData) {
                                ErrCode = ERR_EXPORT_FILE ;
                                goto Exit0 ;
                            }
                        }
                    }

                    if (ColumnTotal > 1) {
                        // save the line value into its column & export later
                        SaveColumnLineData (pLine, pColumnLineData) ;
                    } else {
                        // simple case, export the line now
                        if (!ExportLineName (hFile, pLine, &bExportCounterName)) {
                            ErrCode = ERR_EXPORT_FILE ;
                            goto Exit0 ;
                        }
                    }
                }

                if (!bExportCounterName) {
                    // export the line end
                    if (!FileWrite (hFile, LineEndStr, strlen(LineEndStr))) {
                        ErrCode = ERR_EXPORT_FILE ;
                        goto Exit0 ;
                    }
                }

                if (pColumnLineData) {
                    // now, do the actual export
                    if (!ExportColumnLineData (hFile,
                                               ColumnTotal,
                                               pCounterGroup,
                                               pColumnLineData)) {
                        ErrCode = ERR_EXPORT_FILE ;
                        goto Exit0 ;
                    }
                }
            }

            // done with the object, done with the buffer
            if (pColumnLineData) {
                MemoryFree (pColumnLineData) ;
                ColumnTotal = 0 ;
                pColumnLineData = NULL ;
            }
        }
    }

    Exit0:

    SetArrowCursor() ;

    if (pColumnLineData) {
        MemoryFree (pColumnLineData) ;
    }

    if (hFile) {
        CloseHandle (hFile) ;
    }

    if (pFileName) {
        if (ErrCode) {
            DlgErrorBox (hWndGraph, ErrCode, pFileName) ;
        }

        MemoryFree (pFileName) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\status.h ===
HWND CreatePMStatusWindow (HWND hWnd) ;


BOOL StatusInitializeApplication (void) ;


int StatusHeight (HWND hWnd) ;


BOOL _cdecl StatusLine (HWND hWnd,
                        WORD wStringID, ...) ;


void StatusLineReady (HWND hWnd) ;


void StatusUpdateIcons (HWND hWndStatus) ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\rptfct.c ===
/*****************************************************************************
 *
 *  RptFct.c - This file contains support routines for the Report view.
 *       They are moved here because Report.c is getting too big.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *  Author -
 *
 *       Hon-Wah Chan
 *
 ****************************************************************************/

#include "perfmon.h"
#include <stdio.h>      // for sprintf
#include "report.h"     // Exported declarations for this file

#include "line.h"       // for LineAppend
#include "pmemory.h"    // for MemoryXXX (mallloc-type) routines
#include "system.h"     // for SystemGet
#include "utils.h"
#include "perfmops.h"   // for BuildValueListForSystems

// extern defined in Report.c

extern TCHAR          szSystemFormat [] ;
extern TCHAR          szObjectFormat [] ;


#define szValuePlaceholder          TEXT("-999999999.999")
#define szLargeValueFormat          TEXT("%12.0f")
#define eStatusLargeValueMax        ((FLOAT) 999999999.0)
#define szValueFormat               TEXT("%12.3f")

//========================
// Local routines prototypes
//========================

void ColumnRemoveOne (PREPORT pReport,
                      POBJECTGROUP pObjectGroup,
                      int iColumnNumber) ;

BOOL CounterGroupRemove (PCOUNTERGROUP *ppCounterGroupFirst,
                        PCOUNTERGROUP pCounterGroupRemove) ;

BOOL ObjectGroupRemove (POBJECTGROUP *ppObjectGroupFirst,
                        POBJECTGROUP pObjectGroupRemove) ;

BOOL SystemGroupRemove (PSYSTEMGROUP *ppSystemGroupFirst,
                        PSYSTEMGROUP pSystemGroupRemove) ;

PCOUNTERGROUP GetNextCounter (PSYSTEMGROUP   pSystemGroup,
                              POBJECTGROUP   pObjectGroup,
                              PCOUNTERGROUP  pCounterGroup) ;

BOOL ReportLineRemove (PREPORT pReport,
                 PLINE pLineRemove)
   {
   PLINE          pLine ;

   if (pReport->pLineFirst == pLineRemove)
      {
      pReport->pLineFirst = (pReport->pLineFirst)->pLineNext ;
      return (TRUE) ;
      }

   for (pLine = pReport->pLineFirst ;
        pLine->pLineNext ;
        pLine = pLine->pLineNext)
      {   // for
      if (pLine->pLineNext == pLineRemove)
         {
         pLine->pLineNext = pLineRemove->pLineNext ;
         if (pLineRemove == pReport->pLineLast) {
            pReport->pLineLast = pLine;
         }
         return (TRUE) ;
         }  // if
      }  // for

   return (FALSE) ;
   }  // ReportLineRemove

// CheckColumnGroupRemove is used to check if the given
// column is empty.  If it is empty, it is removed from
// the column link list
void CheckColumnGroupRemove (PREPORT      pReport,
                             POBJECTGROUP pObjectGroup,
                             int          iReportColumn)
   {
   // check if we need to remove the this column
   PLINE          pCounterLine ;
   PCOUNTERGROUP  pCounterGrp ;
   BOOL           bColumnFound = FALSE ;

   if (iReportColumn < 0 || pObjectGroup->pCounterGroupFirst == NULL)
      {
      // no column for this Counter group, forget it
      return ;
      }


   // go thru each Counter group and check if any line in the
   // group matches the given column number
   for (pCounterGrp = pObjectGroup->pCounterGroupFirst ;
        pCounterGrp ;
        pCounterGrp = pCounterGrp->pCounterGroupNext )
      {
      for (pCounterLine = pCounterGrp->pLineFirst ;
           pCounterLine ;
           pCounterLine = pCounterLine->pLineCounterNext)
         {
         if (pCounterLine->iReportColumn == iReportColumn)
            {
            // found one, this column is not empty
            bColumnFound = TRUE ;
            break ;
            }
         }  // for pCounterLine
      if (bColumnFound)
         {
         break ;
         }
      }  // for pCounterGrp

   if (bColumnFound == FALSE)
      {
      // we have deleted the last column item, remove this column
      ColumnRemoveOne (pReport,
         pObjectGroup,
         iReportColumn) ;
      }
   }  // CheckColumnGroupRemove


//================================
// Line routine
//================================

void ReportLineValueRect (PREPORT pReport,
                          PLINE pLine,
                          LPRECT lpRect)
   {  // ReportLineValueRect
   lpRect->left = ValueMargin (pReport) + pLine->xReportPos ;
   lpRect->top = pLine->yReportPos ;
   lpRect->right = lpRect->left + pReport->xValueWidth ;
   lpRect->bottom = lpRect->top + pReport->yLineHeight ;
   }  // ReportLineValueRect

PLINE LineRemoveItem (PREPORT pReport,
                      enum REPORT_ITEM_TYPE  *pNewItemType)
   {
   PLINE          pLine ;
   PLINE          pNextLine = NULL ;
   PLINE          pReturnLine = NULL ;
   PLINE          pLeftLine = NULL ;
   PSYSTEMGROUP   pSystemGroup ;
   POBJECTGROUP   pObjectGroup ;
   PCOUNTERGROUP  pCounterGroup ;
   PCOUNTERGROUP  pNextCounterGroup ;
   BOOL           bCreatNewCounterGroup ;


   //=============================//
   // Remove line, line's system  //
   //=============================//

   pLine = pReport->CurrentItem.pLine ;
   ReportLineRemove (pReport, pLine) ;

   // no more line, no more timer...
   if (!pReport->pLineFirst)
      {
      pReport->xWidth = 0 ;
      pReport->yHeight = 0 ;
      pReport->xMaxCounterWidth = 0 ;
      ClearReportTimer (pReport) ;
      }

   //=============================//
   // Get correct spot; remove line //
   //=============================//

   pSystemGroup = GetSystemGroup (pReport, pLine->lnSystemName) ;
   pObjectGroup = GetObjectGroup (pSystemGroup, pLine->lnObjectName) ;
   pCounterGroup = GetCounterGroup (pObjectGroup,
      pLine->lnCounterDef.CounterNameTitleIndex,
      &bCreatNewCounterGroup,
      pLine->lnCounterName,
      TRUE) ;

   if (!pCounterGroup)
      return (NULL) ;

   LineCounterRemove (pCounterGroup, pLine) ;

   // check which line to get the focus
   if (pCounterGroup->pLineFirst)
      {
      // simple case, we still have line in the same counter group
      // get the one right after this delete line.
      for (pNextLine = pCounterGroup->pLineFirst ;
           pNextLine ;
           pNextLine = pNextLine->pLineCounterNext)
         {
         if (pNextLine->xReportPos > pLine->xReportPos)
            {
            if (pReturnLine == NULL ||
                pReturnLine->xReportPos > pNextLine->xReportPos)
               {
               pReturnLine = pNextLine ;
               }
            }
         else
            {
            if (pLeftLine == NULL ||
                pLeftLine->xReportPos < pNextLine->xReportPos)
               {
               pLeftLine = pNextLine ;
               }
            }
         }

      if (!pReturnLine && pLeftLine)
         {
         // the delete line is the last column, then use the line
         // to its left
         pReturnLine = pLeftLine ;
         }
      }
   else
      {
      pNextCounterGroup = GetNextCounter (
            pSystemGroup,
            pObjectGroup,
            pCounterGroup) ;

      if (pNextCounterGroup)
         {
         pLeftLine = NULL ;
         for (pNextLine = pNextCounterGroup->pLineFirst ;
              pNextLine ;
              pNextLine = pNextLine->pLineCounterNext)
            {
            // get the line in the first column
            if (pLeftLine == NULL ||
                pNextLine->xReportPos < pLeftLine->xReportPos)
               {
               pLeftLine = pNextLine ;
               }
            }
         pReturnLine = pLeftLine ;
         }

      // remove this counter group if there is no line
      CounterGroupRemove (&pObjectGroup->pCounterGroupFirst, pCounterGroup) ;
      }

   // check if we need to remove any empty column
   CheckColumnGroupRemove (pReport, pObjectGroup, pLine->iReportColumn) ;

   if (!(pObjectGroup->pCounterGroupFirst))
      ObjectGroupRemove (&pSystemGroup->pObjectGroupFirst, pObjectGroup) ;

   if (!(pSystemGroup->pObjectGroupFirst))
      SystemGroupRemove (&pReport->pSystemGroupFirst, pSystemGroup) ;


   LineFree (pLine) ;

   if (pReturnLine && pNewItemType)
      {
      *pNewItemType = REPORT_TYPE_LINE ;
      }

   return (pReturnLine) ;
   }  // LineRemoveItem

//======================================//
// Column Group routines                //
//======================================//

void ReportColumnRect (PREPORT pReport,
                       PCOLUMNGROUP pColumnGroup,
                       LPRECT  lpRect)
   {  // ReportColumnRect
   lpRect->left = ValueMargin (pReport) + pColumnGroup->xPos ;
   lpRect->top = pColumnGroup->yFirstLine ;
   lpRect->right = lpRect->left + pColumnGroup->xWidth ;
   lpRect->bottom = lpRect->top + pReport->yLineHeight ;
   if (pColumnGroup->lpszParentName)
      {
      lpRect->top -= pReport->yLineHeight ;
      }
   }  // ReportColumnRect


BOOL ColumnSame (PCOLUMNGROUP pColumnGroup,
                 LPTSTR lpszParentName,
                 LPTSTR lpszInstanceName,
                 DWORD  dwIndex)
   {  // ColumnSame
    BOOL           bReturn = FALSE;

    if (dwIndex == pColumnGroup->dwInstanceIndex) {
        if ((!lpszParentName && !pColumnGroup->lpszParentName) ||
                 strsame (lpszParentName, pColumnGroup->lpszParentName)) {
            if ((!lpszInstanceName && !pColumnGroup->lpszInstanceName) ||
                 strsame (lpszInstanceName, pColumnGroup->lpszInstanceName)) {
                    bReturn = TRUE;
            }
        }
    }
    return bReturn;
   }  // ColumnSame


PCOLUMNGROUP ColumnGroupCreate (PREPORT pReport,
                                int xPos,
                                LPTSTR lpszParentName,
                                LPTSTR lpszInstanceName,
                                int PreviousColumnNumber,
                                int yFirstLine,
                                DWORD   dwIndex)
   {  // ColumnGroupCreate
   PCOLUMNGROUP   pColumnGroup ;
   HDC            hDC ;

   hDC = GetDC (pReport->hWnd) ;
   if (!hDC)
      return NULL;
   pColumnGroup = MemoryAllocate (sizeof (COLUMNGROUP)) ;

   if (pColumnGroup)
      {
      pColumnGroup->pColumnGroupNext = NULL ;
      pColumnGroup->lpszParentName = StringAllocate (lpszParentName) ;
      pColumnGroup->lpszInstanceName = StringAllocate (lpszInstanceName) ;
      pColumnGroup->ParentNameTextWidth = TextWidth (hDC, lpszParentName) ;
      pColumnGroup->InstanceNameTextWidth = TextWidth (hDC, lpszInstanceName) ;
      pColumnGroup->xPos = xPos ;
      pColumnGroup->yFirstLine = yFirstLine ;
      pColumnGroup->ColumnNumber = PreviousColumnNumber + 1 ;
      pColumnGroup->xWidth = max (max (pColumnGroup->ParentNameTextWidth,
                                       pColumnGroup->InstanceNameTextWidth),
                                  pReport->xValueWidth) ;
      pColumnGroup->dwInstanceIndex = dwIndex;

      pReport->xWidth = max (pReport->xWidth,
                             RightHandMargin +
                             ValueMargin (pReport) +
                             pColumnGroup->xPos + pColumnGroup->xWidth +
                             xColumnMargin) ;
      }  // if

   ReleaseDC (pReport->hWnd, hDC) ;
   return (pColumnGroup) ;
   }  // ColumnGroupCreate

PCOLUMNGROUP GetColumnGroup (PREPORT pReport,
                          POBJECTGROUP pObjectGroup,
                          PLINE pLine)
/*
   Effect:        Return a pointer to the appropriate column group from
                  within the groups of pObject. If the line is a counter
                  without instances, return NULL. Otherwise, determine
                  if the counter's parent/instance pair is already found
                  in an existing column and return a pointer to that column.

                  If a column with the appropriate parent/instance isn't
                  found, add a new column *at the end*, and return that
                  column.

   Note:          This function has multiple return points.
*/
   {  // GetColumnGroup
   PCOLUMNGROUP   pColumnGroup ;
   LPTSTR         lpszParentName ;
   LPTSTR         lpszInstanceName ;
   DWORD          dwIndex;

   if (!LineInstanceName (pLine))
      return (NULL) ;

   lpszParentName = LineParentName (pLine) ;
   lpszInstanceName = LineInstanceName (pLine) ;
   dwIndex = pLine->dwInstanceIndex;

   if (!pObjectGroup->pColumnGroupFirst)
      {
      pObjectGroup->pColumnGroupFirst =
         ColumnGroupCreate (pReport,
            0,
            lpszParentName,
            lpszInstanceName,
            -1,
            pObjectGroup->yFirstLine,
            dwIndex) ;

      if (pObjectGroup->pColumnGroupFirst)
         {
         pObjectGroup->pColumnGroupFirst->pParentObject =
            pObjectGroup ;
         }

      return (pObjectGroup->pColumnGroupFirst) ;
      }

   for (pColumnGroup = pObjectGroup->pColumnGroupFirst ;
        pColumnGroup ;
        pColumnGroup = pColumnGroup->pColumnGroupNext)
      {  // for
      if (ColumnSame (pColumnGroup, lpszParentName, lpszInstanceName, dwIndex))
         return (pColumnGroup) ;

      else if (!pColumnGroup->pColumnGroupNext)
         {  // if
         pColumnGroup->pColumnGroupNext =
            ColumnGroupCreate (pReport,
                               pColumnGroup->xPos + pColumnGroup->xWidth +
                               xColumnMargin,
                               lpszParentName,
                               lpszInstanceName,
                               pColumnGroup->ColumnNumber,
                               pObjectGroup->yFirstLine,
                               dwIndex) ;

         if (pColumnGroup->pColumnGroupNext)
            {
            (pColumnGroup->pColumnGroupNext)->pParentObject =
               pObjectGroup ;

            // build the double link-list
            (pColumnGroup->pColumnGroupNext)->pColumnGroupPrevious =
               pColumnGroup ;
            }

         return (pColumnGroup->pColumnGroupNext) ;
         }  // if
      }  // for

   return (NULL) ;
   }  // GetColumnGroup

// ColumnRemoveOne removes the column with the specified column number
void ColumnRemoveOne (PREPORT pReport,
                      POBJECTGROUP pObjectGroup,
                      int iColumnNumber)
   {
   PCOLUMNGROUP   pColumnGroup ;
   PCOLUMNGROUP   pNextColumnGroup ;

   if (pObjectGroup->pColumnGroupFirst == NULL)
      {
      // no column group, forget it
      return ;
      }

   // Find the head list
   if (pObjectGroup->pColumnGroupFirst->ColumnNumber == iColumnNumber)
      {
      pColumnGroup = pObjectGroup->pColumnGroupFirst ;
      pObjectGroup->pColumnGroupFirst = pColumnGroup->pColumnGroupNext ;
      if (pColumnGroup->pColumnGroupNext)
         {
         // set up head of backward link list
         (pColumnGroup->pColumnGroupNext)->pColumnGroupPrevious = NULL ;
         }

      // free memory for this column group
      MemoryFree (pColumnGroup->lpszParentName) ;
      MemoryFree (pColumnGroup->lpszInstanceName) ;
      MemoryFree (pColumnGroup) ;

      return ;
      }

   // go thru the double link list to look for the right column
   for (pColumnGroup = pObjectGroup->pColumnGroupFirst ;
        pColumnGroup ;
        pColumnGroup = pNextColumnGroup)
      {
      pNextColumnGroup = pColumnGroup->pColumnGroupNext ;

      if (pNextColumnGroup == NULL)
         {
         // forget it if we can't find this column for some reson.
         break ;
         }

      if (pNextColumnGroup->ColumnNumber == iColumnNumber)
         {
         pColumnGroup->pColumnGroupNext = pNextColumnGroup->pColumnGroupNext ;

         // build backward link iff it is not the end of list
         if (pColumnGroup->pColumnGroupNext)
            {
            (pColumnGroup->pColumnGroupNext)->pColumnGroupPrevious =
               pColumnGroup ;
            }

         // free memory for this column group
         MemoryFree (pNextColumnGroup->lpszParentName) ;
         MemoryFree (pNextColumnGroup->lpszInstanceName) ;
         MemoryFree (pNextColumnGroup) ;

         // Done
         break ;
         }
      }
   }  // ColumnRemoveOne

// ColumnGroupRemove removes all the columns for a given column list
void ColumnGroupRemove (PCOLUMNGROUP pColumnGroupFirst)
   {
   PCOLUMNGROUP   pColumnGroup ;
   PCOLUMNGROUP   pNextColumnGroup ;

   for (pColumnGroup = pColumnGroupFirst ;
        pColumnGroup ;
        pColumnGroup = pNextColumnGroup)
      {
      pNextColumnGroup = pColumnGroup->pColumnGroupNext ;

      // free memory for this column group
      MemoryFree (pColumnGroup->lpszParentName) ;
      MemoryFree (pColumnGroup->lpszInstanceName) ;
      MemoryFree (pColumnGroup) ;
      }
   }  // ColumnGroupRemove

// ColumnRemoveItem  is called when user wants to delete a
// selected column.
PCOLUMNGROUP ColumnRemoveItem (PREPORT      pReport,
                               PCOLUMNGROUP pColumnGroup,
                               BOOL         bCleanUpLink,
                               enum REPORT_ITEM_TYPE  *pNewItemType)
   {
   PLINE          pLine, pNextLine ;
   PSYSTEMGROUP   pSystemGroup ;
   POBJECTGROUP   pObjectGroup ;
   PCOUNTERGROUP  pCounterGroup, pNextCounterGroup ;
   BOOL           bColumnFound ;
   PCOLUMNGROUP   pRetColumnGroup = NULL ;

   pObjectGroup = pColumnGroup->pParentObject ;
   pSystemGroup = pObjectGroup->pParentSystem ;

   // first, get rid of all the counter lines with this column number
   // Note - each Counter group has only 1 line (or 0) with this
   // column number
   for (pCounterGroup = pObjectGroup->pCounterGroupFirst ;
        pCounterGroup ;
        pCounterGroup = pNextCounterGroup )
      {
      pNextCounterGroup = pCounterGroup->pCounterGroupNext ;
      bColumnFound = FALSE ;

      for (pLine = pCounterGroup->pLineFirst ;
           pLine ;
           pLine = pNextLine)
         {
         pNextLine = pLine->pLineCounterNext ;
         if (pLine->iReportColumn == pColumnGroup->ColumnNumber)
            {
            bColumnFound = TRUE ;
            // delete this line
            ReportLineRemove (pReport, pLine) ;
            LineCounterRemove (pCounterGroup, pLine) ;
            LineFree (pLine) ;
            break ;
            }
         }

      if (bColumnFound)
         {
         // check if we need delete this counter group
         if (!(pCounterGroup->pLineFirst))
            {
            CounterGroupRemove (&pObjectGroup->pCounterGroupFirst, pCounterGroup) ;
            }
         }
      }


   // determine which column group to go after deleting this
   if (pColumnGroup->pColumnGroupNext)
      {
      // get the Column group after this delete one
      pRetColumnGroup = pColumnGroup->pColumnGroupNext ;
      }
   else
      {
      // get the Counter group before this delete one
      pRetColumnGroup = pColumnGroup->pColumnGroupPrevious ;
      }

   if (pNewItemType)
      {
      if (pRetColumnGroup)
         {
         *pNewItemType = REPORT_TYPE_COLUMN ;
         }
      else
         {
         // get next counter group
         pNextCounterGroup = GetNextCounter (
            pSystemGroup,
            pObjectGroup,
            NULL) ;

         if (pNextCounterGroup)
            {
            // we have to return Counter group, so we have to do the
            // dirty casting..
            *pNewItemType = REPORT_TYPE_COUNTER ;
            pRetColumnGroup = (PCOLUMNGROUP) pNextCounterGroup ;
            }
         }
      }


   // remove this column group
   ColumnRemoveOne (pReport, pObjectGroup, pColumnGroup->ColumnNumber) ;

   // check for further cleanup
   if (bCleanUpLink)
      {
      if (!(pObjectGroup->pCounterGroupFirst))
         ObjectGroupRemove (&pSystemGroup->pObjectGroupFirst, pObjectGroup) ;

      if (!(pSystemGroup->pObjectGroupFirst))
         SystemGroupRemove (&pReport->pSystemGroupFirst, pSystemGroup) ;
      }
   return (pRetColumnGroup) ;
   }  // ColumnRemoveItem


//======================================//
// Counter Group routines               //
//======================================//

void ReportCounterRect (PREPORT        pReport,
                        PCOUNTERGROUP  pCounterGroup,
                        LPRECT         lpRect)
   {  // ReportCounterRect
   lpRect->left = xCounterMargin ;
   lpRect->top = pCounterGroup->yLine ;
   lpRect->right = lpRect->left + pCounterGroup->xWidth + yScrollHeight / 2 ;
   lpRect->bottom = lpRect->top + pReport->yLineHeight ;
   }  // ReportCounterRect


PCOUNTERGROUP CounterGroupCreate (DWORD  dwCounterIndex,
                                  LPTSTR pCounterName)
   {  // CounterGroupCreate
   PCOUNTERGROUP  pCounterGroup ;
   HDC            hDC ;
   PREPORT        pReport ;

   pCounterGroup = MemoryAllocate (sizeof (COUNTERGROUP)) ;

   if (pCounterGroup)
      {
      pCounterGroup->pCounterGroupNext = NULL ;
      pCounterGroup->pLineFirst = NULL ;
      pCounterGroup->dwCounterIndex = dwCounterIndex ;

      if (pCounterName)
         {
         hDC = GetDC (hWndReport) ;
         pReport = ReportData (hWndReport) ;
         if (hDC && pReport) {
             SelectFont (hDC, pReport->hFont) ;
             pCounterGroup->xWidth = TextWidth (hDC, pCounterName) ;
             }
         if (hDC) {
             ReleaseDC (hWndReport, hDC) ;
             }
         }
      }  // if

   return (pCounterGroup) ;
   }  // CounterGroupCreate


PCOUNTERGROUP GetCounterGroup (POBJECTGROUP pObjectGroup,
                            DWORD dwCounterIndex,
                            BOOL *pbCounterGroupCreated,
                            LPTSTR pCounterName,
                            BOOL    bCreateNewGroup)
   {  // GetCounterGroup
   PCOUNTERGROUP   pCounterGroup ;

   *pbCounterGroupCreated = FALSE ;
   if (!pObjectGroup)
      return (FALSE) ;

   if (!pObjectGroup->pCounterGroupFirst) {
        if (bCreateNewGroup) {
            pObjectGroup->pCounterGroupFirst =
                CounterGroupCreate (dwCounterIndex, pCounterName) ;

            if (pObjectGroup->pCounterGroupFirst)
                {
                *pbCounterGroupCreated = TRUE ;
                pObjectGroup->pCounterGroupFirst->pParentObject =
                    pObjectGroup ;
                }

            return (pObjectGroup->pCounterGroupFirst) ;
        }
   } else {

    for (pCounterGroup = pObjectGroup->pCounterGroupFirst ;
            pCounterGroup ;
            pCounterGroup = pCounterGroup->pCounterGroupNext) {  
        if (dwCounterIndex && pCounterGroup->dwCounterIndex == dwCounterIndex)
            {
            return (pCounterGroup) ;
            }
        else if (!dwCounterIndex &&
            pCounterGroup->pLineFirst &&
            pstrsame (pCounterGroup->pLineFirst->lnCounterName, pCounterName))
            {
            return (pCounterGroup) ;
            }
        else if (!pCounterGroup->pCounterGroupNext)
            {  // if
            if (bCreateNewGroup) {
                pCounterGroup->pCounterGroupNext =
                    CounterGroupCreate (dwCounterIndex, pCounterName) ;
                if (pCounterGroup->pCounterGroupNext)
                    {
                    *pbCounterGroupCreated = TRUE ;
                    (pCounterGroup->pCounterGroupNext)->pParentObject =
                    pObjectGroup ;

                    // build backward link
                    (pCounterGroup->pCounterGroupNext)->pCounterGroupPrevious =
                    pCounterGroup ;
                    }
                return (pCounterGroup->pCounterGroupNext) ;

                }
            }  // if
        }  // for
   }

   return (NULL) ;
   }  // GetCounterGroup

BOOL CounterGroupRemove (PCOUNTERGROUP *ppCounterGroupFirst,
                        PCOUNTERGROUP pCounterGroupRemove)
   {
   PCOUNTERGROUP  pCounterGroup ;

   if (*ppCounterGroupFirst == pCounterGroupRemove)
      {
      *ppCounterGroupFirst = (*ppCounterGroupFirst)->pCounterGroupNext ;

      if (*ppCounterGroupFirst)
         {
         // set up head of backward link list
         (*ppCounterGroupFirst)->pCounterGroupPrevious = NULL ;
         }

      MemoryFree (pCounterGroupRemove) ;
      return (TRUE) ;
      }

   for (pCounterGroup = *ppCounterGroupFirst ;
        pCounterGroup->pCounterGroupNext ;
        pCounterGroup = pCounterGroup->pCounterGroupNext)
      {   // for
      if (pCounterGroup->pCounterGroupNext == pCounterGroupRemove)
         {
         pCounterGroup->pCounterGroupNext = pCounterGroupRemove->pCounterGroupNext ;
         if (pCounterGroup->pCounterGroupNext)
            {
            (pCounterGroup->pCounterGroupNext)->pCounterGroupPrevious
               = pCounterGroup ;
            }
         MemoryFree (pCounterGroupRemove) ;
         return (TRUE) ;
         }  // if
      }  // for

   return (FALSE) ;
   }  // CounterGroupRemove


// CounterRemoveItem is called when user wants to delete a
// selected counter (row)
PCOUNTERGROUP CounterRemoveItem (PREPORT        pReport,
                                 PCOUNTERGROUP  pCounterGroup,
                                 BOOL           bCleanUpLink,
                                 enum REPORT_ITEM_TYPE  *pNewItemType)
   {
   PLINE          pLine, pNextLine ;
   POBJECTGROUP   pObjectGroup ;
   PSYSTEMGROUP   pSystemGroup ;
   PCOLUMNGROUP   pColumnGroup ;
   PCOLUMNGROUP   pNextColumnGroup ;
   PCOUNTERGROUP  pRetCounterGroup = NULL ;

   pObjectGroup = pCounterGroup->pParentObject ;
   pSystemGroup = pObjectGroup->pParentSystem ;

   // first, remove all the counter lines from this counter group
   // and from the Report line link-list
   for (pLine = pCounterGroup->pLineFirst ;
        pLine ;
        pLine = pNextLine)
      {
      pNextLine = pLine->pLineCounterNext ;
      ReportLineRemove (pReport, pLine) ;
      LineFree (pLine) ;
      }

   // we only need to delete the counter group iff we are deleting
   // this selected Counter.
   if (bCleanUpLink)
      {
      // determine which counter group to go after deleting this
      pRetCounterGroup = GetNextCounter (
         pSystemGroup ,
         pObjectGroup,
         pCounterGroup) ;

      // remove this counter group from its parent object group
      CounterGroupRemove (&pObjectGroup->pCounterGroupFirst, pCounterGroup) ;

      if (!(pObjectGroup->pCounterGroupFirst))
         ObjectGroupRemove (&pSystemGroup->pObjectGroupFirst, pObjectGroup) ;
      else
         {
         // Object group not empty, check for any empty column
         for (pColumnGroup = pObjectGroup->pColumnGroupFirst ;
            pColumnGroup ;
            pColumnGroup = pNextColumnGroup)
            {
            pNextColumnGroup = pColumnGroup->pColumnGroupNext ;
            CheckColumnGroupRemove (pReport, pObjectGroup, pColumnGroup->ColumnNumber) ;
            }
         }

      if (!(pSystemGroup->pObjectGroupFirst))
         {
         SystemGroupRemove (&pReport->pSystemGroupFirst, pSystemGroup) ;
         }
      }
   else
      {
      // get rid of this counter's memory
      MemoryFree (pCounterGroup) ;
      }

   if (pRetCounterGroup && pNewItemType)
      {
      *pNewItemType = REPORT_TYPE_COUNTER ;
      }
   return (pRetCounterGroup) ;
   }  // CounterRemoveItem


// GetNextCounter is used to get:
// If the current system is not empty, then get the
//    (next object first counter) or
//    (previous object last counter. )
// If the current system is empty, then get the
//    (next system first object first counter) or
//    (previous system last object last counter)
// Note - Any of the input pointers could be NULL pointer.
PCOUNTERGROUP GetNextCounter (PSYSTEMGROUP   pSystemGroup,
                              POBJECTGROUP   pObjectGroup,
                              PCOUNTERGROUP  pCounterGroup)
   {
   PCOUNTERGROUP  pRetCounter = NULL ;
   PCOUNTERGROUP  pCounterGrp ;
   POBJECTGROUP   pObjectGrp ;

   if (pCounterGroup && pCounterGroup->pCounterGroupNext)
      {
      pRetCounter = pCounterGroup->pCounterGroupNext ;
      }
   else if (pCounterGroup && pCounterGroup->pCounterGroupPrevious)
      {
      pRetCounter = pCounterGroup->pCounterGroupPrevious ;
      }
   else if (pObjectGroup && pObjectGroup->pObjectGroupNext)
      {
      // get the next Object first Counter
      pRetCounter = pObjectGroup->pObjectGroupNext->pCounterGroupFirst ;
      }
   else if (pObjectGroup && pObjectGroup->pObjectGroupPrevious)
      {
      // get the previous object last counter
      pCounterGrp = (pObjectGroup->pObjectGroupPrevious)->pCounterGroupFirst ;
      if (pCounterGrp)
         {
         // get the last counter group of this object
         for (;
              pCounterGrp->pCounterGroupNext ;
              pCounterGrp = pCounterGrp->pCounterGroupNext )
            {
            ;
            }
         }
      pRetCounter = pCounterGrp ;

      }
   else if (pSystemGroup && pSystemGroup->pSystemGroupNext)
      {
      // get next system first object first counter
      pObjectGrp = pSystemGroup->pSystemGroupNext->pObjectGroupFirst ;
      pRetCounter = pObjectGrp->pCounterGroupFirst ;
      }
   else if (pSystemGroup && pSystemGroup->pSystemGroupPrevious)
      {
      // get previous system last object last counter
      pObjectGrp = pSystemGroup->pSystemGroupPrevious->pObjectGroupFirst ;
      if (pObjectGrp)
         {
         // get the last object group of this system
         for (;
              pObjectGrp->pObjectGroupNext ;
              pObjectGrp = pObjectGrp->pObjectGroupNext )
            {
            ;
            }
         }

      if (pObjectGrp)
         {
         pCounterGrp = pObjectGrp->pCounterGroupFirst ;
         if (pCounterGrp)
            {
            // get the last counter group of this object
            for (;
                 pCounterGrp->pCounterGroupNext ;
                 pCounterGrp = pCounterGrp->pCounterGroupNext )
               {
               ;
               }
            }
         pRetCounter = pCounterGrp ;
         }
      }

   return (pRetCounter) ;

   }  // GetNextCounter


//======================================//
// Object Group routines                //
//======================================//

void ReportObjectRect (PREPORT        pReport,
                       POBJECTGROUP   pObjectGroup,
                       LPRECT         lpRect)
   {  // ReportObjectRect
   lpRect->left = xObjectMargin ;
   lpRect->top = pObjectGroup->yFirstLine ;
   lpRect->right = lpRect->left + pObjectGroup->xWidth ;
   lpRect->bottom = lpRect->top + pReport->yLineHeight ;
   }  // ReportObjectRect


POBJECTGROUP ObjectGroupCreate (LPTSTR lpszObjectName)
   {  // ObjectGroupCreate
   POBJECTGROUP   pObjectGroup ;
   HDC            hDC ;
   PREPORT        pReport ;
   int            OldCounterWidth ;
   TCHAR          szLine [LongTextLen] ;

   pObjectGroup = MemoryAllocate (sizeof (OBJECTGROUP)) ;

   if (pObjectGroup)
      {
      pObjectGroup->pObjectGroupNext = NULL ;
      pObjectGroup->pCounterGroupFirst = NULL ;
      pObjectGroup->pColumnGroupFirst = NULL ;
      pObjectGroup->lpszObjectName = StringAllocate (lpszObjectName) ;

      hDC = GetDC (hWndReport) ;
      pReport = ReportData (hWndReport) ;
      if (hDC && pReport) {
          SelectFont (hDC, pReport->hFontHeaders) ;

          TSPRINTF (szLine, szObjectFormat, lpszObjectName) ;
          pObjectGroup->xWidth = TextWidth (hDC, szLine) ;

          // re-calc. the max. counter group width
          OldCounterWidth = pReport->xMaxCounterWidth ;
          pReport->xMaxCounterWidth =
                max (pReport->xMaxCounterWidth,
                 pObjectGroup->xWidth + xObjectMargin) ;

          if (OldCounterWidth < pReport->xMaxCounterWidth)
          {
          // adjust the report width with the new counter width
          pReport->xWidth +=
               (pReport->xMaxCounterWidth - OldCounterWidth);
          }

      }  // if
      if (hDC) {
          ReleaseDC (hWndReport, hDC) ;
      }
   }
   return (pObjectGroup) ;
   }  // ObjectGroupCreate



POBJECTGROUP GetObjectGroup (PSYSTEMGROUP pSystemGroup,
                          LPTSTR lpszObjectName)
   {
   POBJECTGROUP   pObjectGroup ;

   if (!pSystemGroup)
      return (FALSE) ;

   if (!pSystemGroup->pObjectGroupFirst)
      {
      pSystemGroup->pObjectGroupFirst = ObjectGroupCreate (lpszObjectName) ;
      if (pSystemGroup->pObjectGroupFirst)
         {
         pSystemGroup->pObjectGroupFirst->pParentSystem =
            pSystemGroup ;
         }
      return (pSystemGroup->pObjectGroupFirst) ;
      }

   for (pObjectGroup = pSystemGroup->pObjectGroupFirst ;
        pObjectGroup ;
        pObjectGroup = pObjectGroup->pObjectGroupNext)
      {  // for
      if (strsame (pObjectGroup->lpszObjectName, lpszObjectName))
         {
         return (pObjectGroup) ;
         }
      else if (!pObjectGroup->pObjectGroupNext)
         {  // if
         pObjectGroup->pObjectGroupNext =
            ObjectGroupCreate (lpszObjectName) ;

         if (pObjectGroup->pObjectGroupNext)
            {
            (pObjectGroup->pObjectGroupNext)->pParentSystem =
               pSystemGroup ;
            (pObjectGroup->pObjectGroupNext)->pObjectGroupPrevious =
               pObjectGroup ;
            }

         return (pObjectGroup->pObjectGroupNext) ;
         }  // if
      }  // for
      // if it falls through (which it shouldn't) at least return a
      // reasonable value
      return (pSystemGroup->pObjectGroupFirst) ;
   }  // GetObjectGroup

// ObjectGroupRemove removes the specified Object group
// from the Object double link list
BOOL ObjectGroupRemove (POBJECTGROUP *ppObjectGroupFirst,
                        POBJECTGROUP pObjectGroupRemove)
   {
   POBJECTGROUP  pObjectGroup ;

   if (*ppObjectGroupFirst == pObjectGroupRemove)
      {
      *ppObjectGroupFirst = (*ppObjectGroupFirst)->pObjectGroupNext ;
      if (*ppObjectGroupFirst)
         {
         // set up head of backward link list
         (*ppObjectGroupFirst)->pObjectGroupPrevious = NULL ;
         }

      // clean up the allocated memory
      ColumnGroupRemove (pObjectGroupRemove->pColumnGroupFirst) ;
      MemoryFree (pObjectGroupRemove->lpszObjectName) ;
      MemoryFree (pObjectGroupRemove) ;
      return (TRUE) ;
      }

   for (pObjectGroup = *ppObjectGroupFirst ;
        pObjectGroup->pObjectGroupNext ;
        pObjectGroup = pObjectGroup->pObjectGroupNext)
      {   // for
      if (pObjectGroup->pObjectGroupNext == pObjectGroupRemove)
         {
         pObjectGroup->pObjectGroupNext = pObjectGroupRemove->pObjectGroupNext ;
         if (pObjectGroup->pObjectGroupNext)
            {
            (pObjectGroup->pObjectGroupNext)->pObjectGroupPrevious =
               pObjectGroup ;
            }

         // clean up this object allocated memory and its column groups
         ColumnGroupRemove (pObjectGroupRemove->pColumnGroupFirst) ;
         MemoryFree (pObjectGroupRemove->lpszObjectName) ;
         MemoryFree (pObjectGroupRemove) ;
         return (TRUE) ;
         }  // if
      }  // for

   return (FALSE) ;
   }  // ObjectGroupRemove


// ObjectRemoveItem is called when user delete the selected object
PCOUNTERGROUP ObjectRemoveItem (PREPORT      pReport,
                                POBJECTGROUP pObjectGroup,
                                BOOL         bCleanUpLink,
                                enum REPORT_ITEM_TYPE  *pNewItemType)
   {
   PCOUNTERGROUP  pCounterGroup, pNextCounterGroup ;
   PSYSTEMGROUP   pSystemGroup ;
   PCOUNTERGROUP  pRetCounterGroup = NULL ;

   pSystemGroup = pObjectGroup->pParentSystem ;

   // remove all counter groups from this object
   for (pCounterGroup = pObjectGroup->pCounterGroupFirst ;
        pCounterGroup ;
        pCounterGroup = pNextCounterGroup )
      {
      pNextCounterGroup = pCounterGroup->pCounterGroupNext ;
      CounterRemoveItem (pReport, pCounterGroup, FALSE, NULL) ;
      }

   // remove all column groups from this group
   ColumnGroupRemove (pObjectGroup->pColumnGroupFirst) ;
   pObjectGroup->pColumnGroupFirst = NULL;

   if (bCleanUpLink)
      {

      // get next counter group to get the focus
      if (pNewItemType)
         {
         pRetCounterGroup = GetNextCounter (
            pSystemGroup,
            pObjectGroup,
            NULL) ;

         if (pRetCounterGroup)
            {
            *pNewItemType = REPORT_TYPE_COUNTER ;
            }
         }


      // remove this object from its parent system group
      ObjectGroupRemove (&pSystemGroup->pObjectGroupFirst, pObjectGroup) ;

      if (!(pSystemGroup->pObjectGroupFirst))
         {
         SystemGroupRemove (&pReport->pSystemGroupFirst, pSystemGroup) ;
         }
      }
   else
      {
      // get rid of this object
      MemoryFree (pObjectGroup->lpszObjectName) ;
      MemoryFree (pObjectGroup) ;
      }

   return (pRetCounterGroup) ;

   }  // ObjectRemoveItem


//======================================//
// System Group routines                //
//======================================//
void ReportSystemRect (PREPORT        pReport,
                       PSYSTEMGROUP   pSystemGroup,
                       LPRECT         lpRect)
   {  // ReportSystemRect
   lpRect->left = xSystemMargin ;
   lpRect->top = pSystemGroup->yFirstLine ;
   lpRect->right = lpRect->left + pSystemGroup->xWidth ;
   lpRect->bottom = lpRect->top + pReport->yLineHeight ;
   }  // ReportSystemRect

PSYSTEMGROUP SystemGroupCreate (LPTSTR lpszSystemName)
   {  // SystemGroupCreate
   PSYSTEMGROUP   pSystemGroup ;
   HDC            hDC ;
   PREPORT        pReport ;
   TCHAR          szLine [LongTextLen] ;

   pSystemGroup = MemoryAllocate (sizeof (SYSTEMGROUP)) ;

   if (pSystemGroup)
      {
      pSystemGroup->pSystemGroupNext = NULL ;
      pSystemGroup->pObjectGroupFirst = NULL ;
      pSystemGroup->lpszSystemName = StringAllocate (lpszSystemName) ;

      // get width of system name
      hDC = GetDC (hWndReport) ;
      if (hDC) {
          pReport = ReportData (hWndReport) ;
          SelectFont (hDC, pReport->hFontHeaders) ;

          TSPRINTF (szLine, szSystemFormat, lpszSystemName) ;
          pSystemGroup->xWidth = TextWidth (hDC, szLine) ;
          ReleaseDC (hWndReport, hDC) ;
          }
      }  // if

   return (pSystemGroup) ;
   }  // SystemGroupCreate

PSYSTEMGROUP GetSystemGroup (PREPORT pReport,
                          LPTSTR lpszSystemName)
/*
   Effect;        Return a pointer to the system group of pReport with
                  a system name of lpszSystemName. If no system group
                  has that name, add a new system group.
*/
   {  // GetSystemGroup
   PSYSTEMGROUP   pSystemGroup ;

   if (!pReport->pSystemGroupFirst)
      {
      // add this system to the global system list
      SystemAdd (&pReport->pSystemFirst, lpszSystemName, pReport->hWnd) ;
      // now add it to the report
      pReport->pSystemGroupFirst = SystemGroupCreate (lpszSystemName) ;
      return (pReport->pSystemGroupFirst) ;
      }

   for (pSystemGroup = pReport->pSystemGroupFirst ;
        pSystemGroup ;
        pSystemGroup = pSystemGroup->pSystemGroupNext)
      {  // for
      if (strsamei (pSystemGroup->lpszSystemName, lpszSystemName))
         return (pSystemGroup) ;
      else if (!pSystemGroup->pSystemGroupNext)
         {  // if
         // add this system to the global system list
         SystemAdd (&pReport->pSystemFirst, lpszSystemName, pReport->hWnd) ;
         // and add it to the report list
         pSystemGroup->pSystemGroupNext =
            SystemGroupCreate (lpszSystemName) ;
         if (pSystemGroup->pSystemGroupNext)
            {
            (pSystemGroup->pSystemGroupNext)->pSystemGroupPrevious =
               pSystemGroup ;
            }
         return (pSystemGroup->pSystemGroupNext) ;
         }  // if
      }  // for
    //if it falls through (which it shouldn't) at least return a 
    // reasonable value
    return (pReport->pSystemGroupFirst) ;
   }  // GetSystemGroup


BOOL SystemGroupRemove (PSYSTEMGROUP *ppSystemGroupFirst,
                        PSYSTEMGROUP pSystemGroupRemove)
   {
   PSYSTEMGROUP  pSystemGroup ;

   if (*ppSystemGroupFirst == pSystemGroupRemove)
      {
      *ppSystemGroupFirst = (*ppSystemGroupFirst)->pSystemGroupNext ;
      if (*ppSystemGroupFirst)
         {
         (*ppSystemGroupFirst)->pSystemGroupPrevious = NULL ;
         }
      MemoryFree (pSystemGroupRemove->lpszSystemName) ;
      MemoryFree (pSystemGroupRemove) ;
      return (TRUE) ;
      }

   for (pSystemGroup = *ppSystemGroupFirst ;
        pSystemGroup->pSystemGroupNext ;
        pSystemGroup = pSystemGroup->pSystemGroupNext)
      {   // for
      if (pSystemGroup->pSystemGroupNext == pSystemGroupRemove)
         {
         pSystemGroup->pSystemGroupNext = pSystemGroupRemove->pSystemGroupNext ;
         if (pSystemGroup->pSystemGroupNext)
            {
            (pSystemGroup->pSystemGroupNext)->pSystemGroupPrevious =
               pSystemGroup ;
            }
         MemoryFree (pSystemGroupRemove->lpszSystemName) ;
         MemoryFree (pSystemGroupRemove) ;
         return (TRUE) ;
         }  // if
      }  // for

   return (FALSE) ;
   }  // SystemGroupRemove


// SystemRemoveItem is called when user deletes the selected System
PCOUNTERGROUP SystemRemoveItem (PREPORT      pReport,
                                PSYSTEMGROUP pSystemGroup,
                                BOOL         bCleanUpLink,
                                enum REPORT_ITEM_TYPE  *pNewItemType)
   {
   POBJECTGROUP   pObjectGroup, pNextObjectGroup ;
   PCOUNTERGROUP  pRetCounterGroup = NULL ;

   // remove all object groups from this system
   for (pObjectGroup = pSystemGroup->pObjectGroupFirst ;
        pObjectGroup ;
        pObjectGroup = pNextObjectGroup )
      {
      pNextObjectGroup = pObjectGroup->pObjectGroupNext ;
      ObjectRemoveItem (pReport, pObjectGroup, FALSE, NULL) ;
      }


   if (bCleanUpLink)
      {
      if (pNewItemType)
         {
         pRetCounterGroup = GetNextCounter (
            pSystemGroup,
            NULL,
            NULL) ;

         if (pRetCounterGroup)
            {
            *pNewItemType = REPORT_TYPE_COUNTER ;
            }
         }

      SystemGroupRemove (&pReport->pSystemGroupFirst, pSystemGroup) ;
      }
   else
      {
      // delete data from this system
      MemoryFree (pSystemGroup->lpszSystemName) ;
      MemoryFree (pSystemGroup) ;
      }

   return (pRetCounterGroup) ;

   }  // SystemRemoveItem


BOOL  ReportChangeFocus (HWND                   hWnd,
                         PREPORT                pReport,
                         REPORT_ITEM            SelectedItem,
                         enum REPORT_ITEM_TYPE  SelectedItemType,
                         int                    xOffset,
                         int                    yOffset,
                         RECT                   *pRect)
   {
   HDC         hDC ;
   BOOL        RetCode = FALSE ; // FALSE ==> same item being hit
   RECT        Rect ;
   REPORT_ITEM            PreviousItem ;
   enum REPORT_ITEM_TYPE  PreviousItemType ;

   if (pReport->CurrentItem.pLine != SelectedItem.pLine)
      {
      // not the same item
      RetCode = TRUE ;

      PreviousItemType = pReport->CurrentItemType ;
      PreviousItem.pLine = pReport->CurrentItem.pLine ;

      pReport->CurrentItemType = SelectedItemType ;
      pReport->CurrentItem.pLine = SelectedItem.pLine ;

      hDC = GetDC (hWnd) ;
      if (!hDC)
        return FALSE;

      if (SelectedItemType == REPORT_TYPE_LINE)
         {
         SetWindowOrgEx (hDC, xOffset, yOffset, NULL) ;
         SelectFont (hDC, pReport->hFont) ;
         SetTextAlign (hDC, TA_RIGHT) ;
         SetBkColor (hDC, GetSysColor(COLOR_WINDOW)) ;
         DrawReportValue (hDC, pReport, SelectedItem.pLine) ;
         SetWindowOrgEx (hDC, -xOffset, -yOffset, NULL) ;
         }
      else
         {
         Rect = *pRect ;
         Rect.top -= yOffset ;
         Rect.bottom -= yOffset ;
         Rect.right -= xOffset ;
         Rect.left -= xOffset ;
         InvalidateRect (hWnd, &Rect, TRUE) ;
         }

      if (PreviousItemType == REPORT_TYPE_LINE)
         {
         SetWindowOrgEx (hDC, xOffset, yOffset, NULL) ;
         SelectFont (hDC, pReport->hFont) ;
         SetTextAlign (hDC, TA_RIGHT) ;
         SetBkColor (hDC, GetSysColor(COLOR_WINDOW)) ;
         DrawReportValue (hDC, pReport, PreviousItem.pLine) ;
         }
      else if (PreviousItemType != REPORT_TYPE_NOTHING)
         {
         if (PreviousItemType == REPORT_TYPE_SYSTEM)
            {
            ReportSystemRect (pReport, PreviousItem.pSystem, &Rect) ;
            }
         else if (PreviousItemType == REPORT_TYPE_OBJECT)
            {
            ReportObjectRect (pReport, PreviousItem.pObject, &Rect) ;
            }
         else if (PreviousItemType == REPORT_TYPE_COUNTER)
            {
            ReportCounterRect (pReport, PreviousItem.pCounter, &Rect) ;
            }
         else if (PreviousItemType == REPORT_TYPE_COLUMN)
            {
            ReportColumnRect (pReport, PreviousItem.pColumn, &Rect) ;
            }
         Rect.top -= yOffset ;
         Rect.bottom -= yOffset ;
         Rect.right -= xOffset ;
         Rect.left -= xOffset ;
         InvalidateRect (hWnd, &Rect, TRUE) ;
         }
      ReleaseDC (hWnd, hDC) ;
      }

   return (RetCode) ;
   }  // ReportChangeFocus


BOOL  OnReportLButtonDown (HWND hWnd,
                           WORD xPos,
                           WORD yPos)
   {
   PREPORT     pReport ;
   PLINE       pLine ;
   REPORT_ITEM PreviousItem ;
   REPORT_ITEM CurrentSelectedItem ;
   enum REPORT_ITEM_TYPE PreviousItemType ;
   RECT        rect ;
   POINT       pt ;
   int         xOffset, yOffset ;
   PSYSTEMGROUP   pSystemGroup ;
   POBJECTGROUP   pObjectGroup ;
   PCOUNTERGROUP  pCounterGroup ;
   PCOLUMNGROUP   pColumnGroup ;


   pReport = ReportData (hWnd) ;
   if (!pReport)
      return (FALSE) ;

   xOffset = GetScrollPos (hWnd, SB_HORZ) ;
   yOffset = GetScrollPos (hWnd, SB_VERT) ;
   pt.x = xPos + xOffset ;
   pt.y = yPos + yOffset ;
   PreviousItem = pReport->CurrentItem ;
   PreviousItemType = pReport->CurrentItemType ;

   for (pLine = pReport->pLineFirst ;
        pLine ;
        pLine = pLine->pLineNext)
      {  // for
      ReportLineValueRect (pReport, pLine, &rect) ;
      if (PtInRect (&rect, pt))
         {
         CurrentSelectedItem.pLine = pLine ;
         return (ReportChangeFocus (
            hWnd,
            pReport,
            CurrentSelectedItem,
            REPORT_TYPE_LINE,
            xOffset,
            yOffset,
            &rect)) ;
         }
      }  // for

   // check on hit on system, object, counter, column (parent+isntance names)
   for (pSystemGroup = pReport->pSystemGroupFirst ;
        pSystemGroup ;
        pSystemGroup = pSystemGroup->pSystemGroupNext)
      {  // for System...

      ReportSystemRect (pReport, pSystemGroup, &rect) ;
      if (PtInRect (&rect, pt))
         {
         CurrentSelectedItem.pSystem = pSystemGroup ;
         return (ReportChangeFocus (
            hWnd,
            pReport,
            CurrentSelectedItem,
            REPORT_TYPE_SYSTEM,
            xOffset,
            yOffset,
            &rect)) ;
         }


      for (pObjectGroup = pSystemGroup->pObjectGroupFirst ;
           pObjectGroup ;
           pObjectGroup = pObjectGroup->pObjectGroupNext)
         {  // for Object...

         ReportObjectRect (pReport, pObjectGroup, &rect) ;
         if (PtInRect (&rect, pt))
            {
            CurrentSelectedItem.pObject = pObjectGroup ;
            return (ReportChangeFocus (
               hWnd,
               pReport,
               CurrentSelectedItem,
               REPORT_TYPE_OBJECT,
               xOffset,
               yOffset,
               &rect)) ;
            }

         for (pColumnGroup = pObjectGroup->pColumnGroupFirst ;
              pColumnGroup ;
              pColumnGroup = pColumnGroup->pColumnGroupNext)
            {  // for Column...
            ReportColumnRect (pReport, pColumnGroup, &rect) ;
            if (PtInRect (&rect, pt))
               {
               CurrentSelectedItem.pColumn = pColumnGroup ;
               return (ReportChangeFocus (
                  hWnd,
                  pReport,
                  CurrentSelectedItem,
                  REPORT_TYPE_COLUMN,
                  xOffset,
                  yOffset,
                  &rect)) ;
               }
            }  // for Column

         for (pCounterGroup = pObjectGroup->pCounterGroupFirst ;
              pCounterGroup ;
              pCounterGroup = pCounterGroup->pCounterGroupNext)
            {  // for Counter...
            ReportCounterRect (pReport, pCounterGroup, &rect) ;
            if (PtInRect (&rect, pt))
               {
               CurrentSelectedItem.pCounter = pCounterGroup ;
               return (ReportChangeFocus (
                  hWnd,
                  pReport,
                  CurrentSelectedItem,
                  REPORT_TYPE_COUNTER,
                  xOffset,
                  yOffset,
                  &rect)) ;

               }
            }  // for Counter...
         }  // for Object...
      }  // for System...

   // nothing hit
   return (FALSE) ;
   }  // OnReportLButtonDown

BOOL ReportDeleteItem (HWND hWnd)
/*
   Effect:        Delete the current selected item.

*/
   {  // ReportDeleteItem

   HDC                     hDC ;
   PREPORT                 pReport ;
   REPORT_ITEM             NextItem ;
   enum  REPORT_ITEM_TYPE  NextItemType ;

   NextItemType = REPORT_TYPE_NOTHING ;
   NextItem.pLine = NULL ;

   pReport = ReportData (hWnd) ;
   if (pReport->CurrentItemType == REPORT_TYPE_NOTHING)
      {
      // nothing to delete...
      return (TRUE) ;
      }
   else if (pReport->CurrentItemType == REPORT_TYPE_LINE)
      {
      NextItem.pLine = LineRemoveItem (pReport, &NextItemType) ;
      }
   else if (pReport->CurrentItemType == REPORT_TYPE_SYSTEM)
      {
      NextItem.pCounter = SystemRemoveItem (
            pReport,
            pReport->CurrentItem.pSystem,
            TRUE,
            &NextItemType) ;
      }
   else if (pReport->CurrentItemType == REPORT_TYPE_OBJECT)
      {
      NextItem.pCounter = ObjectRemoveItem (
            pReport,
            pReport->CurrentItem.pObject,
            TRUE,
            &NextItemType) ;
      }
   else if (pReport->CurrentItemType == REPORT_TYPE_COUNTER)
      {
      NextItem.pCounter = CounterRemoveItem (
            pReport,
            pReport->CurrentItem.pCounter,
            TRUE,
            &NextItemType) ;
      }
   else if (pReport->CurrentItemType == REPORT_TYPE_COLUMN)
      {
      NextItem.pColumn = ColumnRemoveItem (
            pReport,
            pReport->CurrentItem.pColumn,
            TRUE,
            &NextItemType) ;
      }

   if (NextItemType != REPORT_TYPE_NOTHING)
      {
      pReport->CurrentItem.pLine = NextItem.pLine ;
      pReport->CurrentItemType = NextItemType ;
      }
   else
      {
      pReport->CurrentItem.pLine = pReport->pLineFirst ;
      pReport->CurrentItemType = REPORT_TYPE_LINE ;
      }

   if (pReport->pLineFirst)
      {
      BuildValueListForSystems (
         pReport->pSystemFirst,
         pReport->pLineFirst) ;
      }
   else
      {
      // no more line, no more timer...
      pReport->xWidth = 0 ;
      pReport->yHeight = 0 ;
      pReport->xMaxCounterWidth = 0 ;
      ClearReportTimer (pReport) ;

      FreeSystems (pReport->pSystemFirst) ;
      pReport->pSystemFirst = NULL ;
      pReport->pSystemGroupFirst = NULL ;
      pReport->CurrentItemType = REPORT_TYPE_NOTHING ;
      pReport->CurrentItem.pLine = NULL ;

      }

   //=============================//
   // Calculate report positions  //
   //=============================//

   hDC = GetDC (hWnd) ;
   if (hDC) {
       SetReportPositions (hDC, pReport) ;

       if (!pReport->pLineFirst)
          {
          SelectFont (hDC, pReport->hFont) ;
          pReport->xValueWidth = TextWidth (hDC, szValuePlaceholder) ;
          }

       ReleaseDC (hWnd, hDC) ;
   }
   WindowInvalidate (hWnd) ;

   return (TRUE) ;
   }  // ReportDeleteItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\status.c ===
#include "perfmon.h"
#include "status.h"  // External declarations for this file
#include <stdio.h>   // for sprintf.
#include <stdarg.h>  // For ANSI variable args. Dont use UNIX <varargs.h>

#include "log.h"        // for LogCollecting
#include "perfmops.h"   // for SmallFileSizeString
#include "playback.h"   // for PlayingBackLog
#include "utils.h"

//================================//
// Options for PaintStatusBar     //
//================================//
#define     PaintText         1
#define     PaintIcons        2
#define     PaintBoundary     4
#define     PaintAll          (PaintText + PaintIcons + PaintBoundary)

//==========================================================================//
//                                  Constants                               //
//==========================================================================//

#define szStatusClass          TEXT("PerfmonStatusClass")
#define dwStatusClassStyle     (CS_HREDRAW | CS_VREDRAW | CS_OWNDC)
#define iStatusClassExtra      (0)
#define iStatusWindowExtra     (0)
#define dwStatusWindowStyle    (WS_CHILD | WS_VISIBLE)


#define szAlertMax            TEXT(" 99 ")
#define szAlertFormat         TEXT(" %2d ")
#define szAlertOverflow       TEXT(" ++")

#define szLogMax              TEXT(" 9,999.9M ")

//==========================================================================//
//                                Local Data                                //
//==========================================================================//


HDC            hStatusDC ;                   // for OWN_DC

HDC            hLogBitmapDC ;
int            xLogBitmapWidth ;
int            yLogBitmapHeight ;

HDC            hAlertBitmapDC ;
int            xAlertBitmapWidth ;
int            yAlertBitmapHeight ;

int            yStatusHeight ;
int            xStatusAlertWidth ;           // of alert bm and num alerts
int            xStatusLogWidth ;             // of log bitmap and file size

int            szStatusLineLen ;             // no. of char. in szStatusLine
TCHAR          szStatusLine [MessageLen+ResourceStringLen] ;
TCHAR          szCurrentActivity [ResourceStringLen] ;
TCHAR          szStatusFormat  [ResourceStringLen] ;
TCHAR          szStatusFormat2 [ResourceStringLen] ;

HBITMAP        hBitmapAlertStatus ;
HBITMAP        hBitmapLogStatus ;


//==========================================================================//
//                                   Macros                                 //
//==========================================================================//

#define StatusTopMargin()     (2)
#define StatusLeftMargin()    (2)

//==========================================================================//
//                              Local Functions                             //
//==========================================================================//

void
DrawAlerts (
           HDC hDC,
           LPRECT lpRect
           )
{
    TCHAR          szText [10] ;
    RECT           rectText ;
    int            yBitmapTop ;

    if (!iUnviewedAlerts)
        return ;

    yBitmapTop = lpRect->top +
                 (lpRect->bottom -
                  lpRect->top -
                  yAlertBitmapHeight) / 2 ;

    SetTextColor (hDC, crLastUnviewedAlert) ;

    BitBlt (hDC,                           // DC for Destination surface
            lpRect->right - xStatusAlertWidth,  // x pos for Destination surface
            yBitmapTop,                         // y for Destination surface
            xAlertBitmapWidth,                  // width of bitmap
            yAlertBitmapHeight,                 // height of bitmap
            hAlertBitmapDC,                     // DC for source surface
            0, 0,                               // location in source surface
            SRCCOPY) ;                          // ROP code

    SetTextColor (hDC, crBlack) ;

    if (iUnviewedAlerts > 99)
        lstrcpy (szText, szAlertOverflow) ;
    else
        TSPRINTF (szText, szAlertFormat, iUnviewedAlerts) ;

    rectText.left = lpRect->right - xStatusAlertWidth + xAlertBitmapWidth ;
    rectText.top = lpRect->top + 1 ;
    rectText.right = lpRect->right - 1 ;
    rectText.bottom = lpRect->bottom - 1 ;

    ExtTextOut (hDC, rectText.left, rectText.top, ETO_CLIPPED | ETO_OPAQUE,
                &rectText, szText, lstrlen (szText), NULL) ;

    lpRect->right -= (xStatusAlertWidth + (xAlertBitmapWidth >> 2)) ;
}


void
DrawLog (
        HDC hDC,
        LPRECT lpRect
        )
{
    TCHAR          szText [10] ;
    RECT           rectText ;
    int            yBitmapTop ;

    if (!LogCollecting (hWndLog))
        return ;

    yBitmapTop = lpRect->top +
                 (lpRect->bottom -
                  lpRect->top -
                  yLogBitmapHeight) / 2 ;
    BitBlt (hDC,                           // DC for Destination surface
            lpRect->right - xStatusLogWidth,    // x pos for Destination surface
            yBitmapTop,                         // y for Destination surface
            xLogBitmapWidth,                    // width of bitmap
            yLogBitmapHeight,                   // height of bitmap
            hLogBitmapDC,                       // DC for source surface
            0, 0,                               // location in source surface
            SRCCOPY) ;                          // ROP code


    SmallFileSizeString (LogFileSize (hWndLog), szText) ;

    rectText.left = lpRect->right - xStatusLogWidth +
                    xLogBitmapWidth + 1 ;
    rectText.top = lpRect->top + 1 ;
    rectText.right = lpRect->right - 1 ;
    rectText.bottom = lpRect->bottom - 1 ;

    ExtTextOut (hDC, rectText.left, rectText.top, ETO_CLIPPED | ETO_OPAQUE,
                &rectText, szText, lstrlen (szText), NULL) ;

    lpRect->right -= xStatusLogWidth ;
}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void
static
OnCreate (
         HWND hWnd
         )
/*
   Effect:        Perform any actions needed when a status window is created.
                  In particular, set the instance data to initial values,
                  determine the size and placement of the various elements
                  of the status display.

   Called By:     StatusWndProc only, in response to a WM_CREATE message.
*/
{
    HDC            hDC ;


    hBitmapAlertStatus = LoadBitmap (hInstance, idBitmapAlertStatus) ;
    hBitmapLogStatus = LoadBitmap (hInstance, idBitmapLogStatus) ;

    hDC = hStatusDC = GetDC (hWnd) ;
    SelectFont (hDC, hFontScales) ;
    SetBkColor (hDC, ColorBtnFace) ;
    SetTextAlign (hDC, TA_LEFT) ;
    SetBkMode (hDC, OPAQUE) ;

    yStatusHeight = 2 * StatusTopMargin () +
                    FontHeight (hDC, TRUE) +
                    2 * ThreeDPad ;

    BitmapDimemsion (hBitmapLogStatus, &yLogBitmapHeight, &xLogBitmapWidth) ;
    BitmapDimemsion (hBitmapAlertStatus, &yAlertBitmapHeight, &xAlertBitmapWidth) ;

    // pre-load the log and alert bitmaps for perfmormance

    hLogBitmapDC = CreateCompatibleDC (hDC) ;
    SelectObject (hLogBitmapDC, hBitmapLogStatus) ;

    hAlertBitmapDC = CreateCompatibleDC (hDC) ;
    SelectObject (hAlertBitmapDC, hBitmapAlertStatus) ;


    xStatusAlertWidth = xAlertBitmapWidth + 1 +
                        TextWidth (hDC, szAlertMax) ;
    xStatusLogWidth = xLogBitmapWidth +
                      TextWidth (hDC, szLogMax) ;


    StringLoad (IDS_CURRENTACTIVITY, szCurrentActivity) ;
    StringLoad (IDS_STATUSFORMAT, szStatusFormat) ;
    StringLoad (IDS_STATUSFORMAT2, szStatusFormat2) ;

    StatusLineReady (hWnd) ;
}

void
static
OnDestroy (
          HWND hWnd
          )
{
    if (hBitmapAlertStatus) {
        DeleteObject (hBitmapAlertStatus) ;
        hBitmapAlertStatus = 0 ;
    }

    if (hBitmapLogStatus) {
        DeleteObject (hBitmapLogStatus) ;
        hBitmapLogStatus = 0 ;
    }
    ReleaseDC (hWnd, hStatusDC) ;
}

void
static
PaintStatusBar (
               HWND hWnd,
               HDC hDC,
               int PaintOptions
               )
/*
   Effect:        Paint the invalid surface of hWnd. Draw each label, each
                  recessed value box, and each value.

   Called By:     StatusWndProc only, in response to a WM_PAINT message.
*/
{
    RECT           rectClient ;

    if (bPerfmonIconic) {
        // no need to draw anything if iconic
        return ;
    }

    GetClientRect (hWnd, &rectClient) ;

    RectContract (&rectClient, StatusTopMargin (), StatusLeftMargin ()) ;

    if (PaintOptions == PaintAll) {
        ThreeDConcave1 (hDC,
                        rectClient.left, rectClient.top,
                        rectClient.right, rectClient.bottom) ;
    }

    rectClient.left += StatusLeftMargin () ;

    // Always draw the icons and need to draw log before Alerts!
    DrawLog (hDC, &rectClient) ;
    DrawAlerts (hDC, &rectClient) ;

    if (PaintOptions & PaintText) {
        rectClient.left += 1 ;
        rectClient.top += 1 ;
        rectClient.right -= 1 ;
        rectClient.bottom -= 1 ;
        ExtTextOut (hDC, rectClient.left, rectClient.top, ETO_CLIPPED | ETO_OPAQUE,
                    &rectClient, szStatusLine, szStatusLineLen, NULL) ;
    }
}


LRESULT
APIENTRY
StatusWndProc (
              HWND hWnd,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    BOOL           bCallDefProc ;
    LRESULT        lReturnValue ;
    HDC            hDC ;
    PAINTSTRUCT    ps ;

    bCallDefProc = FALSE ;
    lReturnValue = 0L ;

    switch (wMsg) {
        case WM_PAINT:
            hDC = BeginPaint (hWnd, &ps) ;
            PaintStatusBar (hWnd, hDC, PaintAll) ;
            EndPaint (hWnd, &ps) ;
            break ;

        case WM_CREATE:
            OnCreate (hWnd) ;
            break ;

        case WM_DESTROY:
            OnDestroy (hWnd) ;
            break ;

        default:
            bCallDefProc = TRUE ;
    }

    if (bCallDefProc)
        lReturnValue = DefWindowProc (hWnd, wMsg, wParam, lParam) ;

    return (lReturnValue);
}


int
StatusHeight (
             HWND hWnd
             )
/*
   Effect:        A status window has a preferred height, based on the font
                  used in its display. Return the preferred height, determined
                  when the window was created.

   Assert:        OnCreate has already been called, and it set
                  StatusData.yHeight.
*/
{
    return (yStatusHeight) ;
}


HWND
CreatePMStatusWindow (
                     HWND hWnd
                     )
{
    return (CreateWindow (szStatusClass,       // class
                          NULL,                // caption
                          dwStatusWindowStyle, // window style
                          0, 0,                // position
                          0, 0,                // size
                          hWnd,                // parent window
                          NULL,                // menu
                          hInstance,           // program instance
                          NULL)) ;             // user-supplied data
}


BOOL
StatusInitializeApplication (void)
/*
   Called By:     InitializeApplication only
*/
{
    WNDCLASS       wc ;

    wc.style          = dwStatusClassStyle ;
    wc.lpfnWndProc    = StatusWndProc ;
    wc.hInstance      = hInstance ;
    wc.cbClsExtra     = iStatusClassExtra ;
    wc.cbWndExtra     = iStatusWindowExtra ;
    wc.hIcon          = NULL ;
    wc.hCursor        = LoadCursor (NULL, IDC_ARROW) ;
    //   wc.hbrBackground  = hbLightGray ;
    wc.hbrBackground  = hBrushFace ;
    wc.lpszMenuName   = NULL ;
    wc.lpszClassName  = szStatusClass ;

    return (RegisterClass (&wc)) ;
}

BOOL
_cdecl
StatusLine (
           HWND hWnd,
           WORD wStringID,
           ...
           )
{
    TCHAR          szFormat [MessageLen] ;
    va_list        vaList ;

    if (wStringID == 0) {
        return (TRUE) ;
    }

    strclr (szStatusLine) ;

    if (LoadString (hInstance, wStringID, szFormat, MessageLen)) {
        va_start (vaList, wStringID) ;
        TSPRINTF (szStatusLine, szFormat, vaList) ;
        //      wvsprintf (szStatusLine, szFormat, vaList) ;
        va_end (vaList) ;
        dwCurrentMenuID = MenuIDToHelpID (wStringID) ;
        szStatusLineLen = lstrlen (szStatusLine) ;
    } else {
        dwCurrentMenuID = 0 ;
        szStatusLineLen = 0 ;
    }
    PaintStatusBar (hWndStatus, hStatusDC, PaintText + PaintIcons) ;

    return (TRUE) ;
}



void
StatusLineReady (
                HWND hWnd
                )
{
    int         stringLen ;
    LPTSTR      pFileName = NULL ;

    TSPRINTF (szStatusLine, szStatusFormat,
              PlayingBackLog () ?
              PlaybackLog.szFileTitle : szCurrentActivity) ;

    switch (iPerfmonView) {
        case IDM_VIEWCHART:
            pFileName = pChartFileName ;
            break ;

        case IDM_VIEWALERT:
            pFileName = pAlertFileName ;
            break ;

        case IDM_VIEWLOG:
            pFileName = pLogFileName ;
            break ;

        case IDM_VIEWREPORT:
            pFileName = pReportFileName ;
            break ;
    }

    if (pFileName) {
        stringLen = lstrlen (szStatusLine) ;
        TSPRINTF (&szStatusLine[stringLen], szStatusFormat2, pFileName) ;
    }

    szStatusLineLen = lstrlen (szStatusLine) ;

    PaintStatusBar (hWndStatus, hStatusDC, PaintText + PaintIcons) ;
}


void
StatusUpdateIcons (
                  HWND hWndStatus
                  )
{
    PaintStatusBar (hWndStatus, hStatusDC, PaintIcons) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\timefrm.h ===
BOOL SetTimeframe (HWND hWndParent) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\timefrm.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <stdio.h>

#include "perfmon.h"          // included by all source
#include "timefrm.h"          // external declarations for this file

#include "alert.h"            // for PlaybackAlert
#include "grafdata.h"         // for PlaybackChart
#include "perfmops.h"         // for PerfmonViewWindow
#include "playback.h"         // for PlaybackIndexN
#include "report.h"           // for PlaybackReport
#include "timeline.h"         // for TL_INTERVAL
#include "utils.h"
#include "pmhelpid.h"         // for Help IDs

//==========================================================================//
//                                Local Data                                //
//==========================================================================//

static RECT    TFrameRectWindow ;

//==========================================================================//
//                              Local Functions                             //
//==========================================================================//
void
ClearSystemTime (
                SYSTEMTIME *pSystemTime
                )
{
    pSystemTime->wYear = 0 ;
    pSystemTime->wMonth = 0 ;
    pSystemTime->wDayOfWeek = 0 ;
    pSystemTime->wDay = 0 ;
    pSystemTime->wHour = 0 ;
    pSystemTime->wMinute = 0 ;
    pSystemTime->wSecond = 0 ;
    pSystemTime->wMilliseconds = 0 ;
}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//

void
static
OnInitDialog (
             HDLG hDlg
             )
{
    PBOOKMARK      pBookmark ;
    int            iIndex ;
    TCHAR          szText [20+20+BookmarkCommentLen] ;
    TCHAR          szDate [20] ;
    TCHAR          szTime [20] ;
    int            iBookmarksNum ;
    HWND           hWndTLine ;
    HWND           hWndBookmarks ;
    int            currentTextExtent = 0 ;
    int            maxTextExtent = 0 ;
    HDC            hDC = 0 ;
    HFONT          hFont ;

    hWndTLine = DialogControl (hDlg, IDD_TIMEFRAMETIMELINE) ;
    hWndBookmarks = DialogControl (hDlg, IDD_TIMEFRAMEBOOKMARKS) ;
    SetFont (hWndBookmarks, hFontScales) ;
    LBSetHorzExtent (hWndBookmarks, 0) ;

    TLineSetRange (hWndTLine, 0, PlaybackLog.iTotalTics - 1) ;
    TLineSetStart (hWndTLine, PlaybackLog.StartIndexPos.iPosition) ;
    TLineSetStop (hWndTLine, PlaybackLog.StopIndexPos.iPosition) ;

    iBookmarksNum = 0 ;
    pBookmark = PlaybackLog.pBookmarkFirst ;

    if (pBookmark) {
        hDC = GetDC (hWndBookmarks) ;
        if (hDC) {
            hFont = (HFONT)SendMessage(hWndBookmarks, WM_GETFONT, 0, 0L);
            if (hFont)
                SelectObject(hDC, hFont);
        }

        while (pBookmark) {
            SystemTimeDateString (&(pBookmark->SystemTime), szDate) ;
            SystemTimeTimeString (&(pBookmark->SystemTime), szTime, TRUE) ;
            TSPRINTF (szText, TEXT(" %s  %s  %s"),
                      szDate, szTime,
                      pBookmark->szComment) ;
            LBSetData (hWndBookmarks, LBAdd (hWndBookmarks, szText), pBookmark->iTic) ;

            // get the biggest text width
            if (hDC) {
                currentTextExtent = TextWidth (hDC, szText) + xScrollWidth / 2 ;
                if (currentTextExtent > maxTextExtent) {
                    maxTextExtent = currentTextExtent ;
                }
            }

            pBookmark = pBookmark->pBookmarkNext ;
        }

        LBSetSelection (hWndBookmarks, 0) ;

        iBookmarksNum = LBNumItems (hWndBookmarks) ;
    }

    if (iBookmarksNum == 0) {
        DialogEnable (hDlg, IDD_TIMEFRAMEBOOKMARKS, FALSE) ;
        DialogEnable (hDlg, IDD_TIMEFRAMEBOOKMARKGRP, FALSE) ;
        DialogEnable (hDlg, IDD_TIMEFRAMESETSTART, FALSE) ;
        DialogEnable (hDlg, IDD_TIMEFRAMESETSTOP, FALSE) ;
    } else {
        LBSetHorzExtent (hWndBookmarks, maxTextExtent) ;
    }

    if (hDC) {
        ReleaseDC (hWndBookmarks, hDC) ;
    }

    if (TFrameRectWindow.right == TFrameRectWindow.left) {
        // we have not initialize this data yet.
        // will get init. after the first time frame window invoke
        WindowCenter (hDlg) ;
    } else {
        // show it in its previous position
        MoveWindow (hDlg,
                    TFrameRectWindow.left,
                    TFrameRectWindow.top,
                    TFrameRectWindow.right - TFrameRectWindow.left,
                    TFrameRectWindow.bottom - TFrameRectWindow.top,
                    TRUE) ;
    }

    dwCurrentDlgID = HC_PM_idDlgEditTimeFrame ;

}


void
static
OnTLineInterval (
                HDLG hDlg,
                int iInterval,
                SYSTEMTIME *pSystemTime
                )
{
    PLOGINDEX      pIndex ;


    pIndex = PlaybackIndexN (iInterval) ;

    if (pIndex)
        *pSystemTime = pIndex->SystemTime ;
    else
        ClearSystemTime (pSystemTime) ;
}


void
static
OnOK (
     HDLG hDlg
     )
{
    LOGPOSITION    lp ;
    int            iIndex ;
    HWND           hWndTLine = DialogControl (hDlg, IDD_TIMEFRAMETIMELINE) ;

    iIndex = TLineStart (hWndTLine) ;
    if (LogPositionN (iIndex, &lp))
        PlaybackLog.StartIndexPos = lp ;

    iIndex = TLineStop (hWndTLine) ;
    if (LogPositionN (iIndex, &lp))
        PlaybackLog.StopIndexPos = lp ;


    PlaybackLog.iSelectedTics =
    PlaybackLog.StopIndexPos.iPosition -
    PlaybackLog.StartIndexPos.iPosition + 1 ;

    PlaybackChart (hWndGraph) ;
    PlaybackAlert (hWndAlert, 0) ;
    PlaybackReport (hWndReport) ;

    WindowInvalidate (PerfmonViewWindow ()) ;

    GetWindowRect (hDlg, &TFrameRectWindow) ;

    dwCurrentDlgID = 0 ;
}

void
static
OnCancel (
         HWND hWnd
         )
{
    HDC            hGraphDC ;
    PGRAPHSTRUCT   pGraph ;

    hGraphDC = GetDC (hWndGraph) ;
    if (!hGraphDC)
        return;
    pGraph = GraphData (hWndGraph) ;
    if (!pGraph) {
        ReleaseDC(hWndGraph, hGraphDC);
        return ;
    }

    TLineRedraw (hGraphDC, pGraph) ;

    GetWindowRect (hWnd, &TFrameRectWindow) ;

    dwCurrentDlgID = 0 ;
}


void
OnSetStartStop (
               HWND hDlg,
               BOOL bSetStart
               )
{
    int        iTic ;
    int        iStopTic ;
    int        iStartTic ;
    HWND       hWndTLine = DialogControl (hDlg, IDD_TIMEFRAMETIMELINE) ;
    HWND       hWndBookmarks = DialogControl (hDlg, IDD_TIMEFRAMEBOOKMARKS) ;

    iStartTic = TLineStart (hWndTLine) ;
    iStopTic = TLineStop (hWndTLine) ;

    iTic = (int)LBData (hWndBookmarks, LBSelection (hWndBookmarks)) ;
    if ((bSetStart && iStopTic <= iTic) ||
        (!bSetStart && iStartTic >= iTic)) {
        DlgErrorBox (hDlg, ERR_STOPBEFORESTART) ;
    } else {
        if (bSetStart) {
            TLineSetStart (hWndTLine, iTic) ;
        } else {
            TLineSetStop (hWndTLine, iTic) ;
        }
        WindowInvalidate (hWndTLine) ;
    }
}


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


INT_PTR
TimeframeDlgProc (
                 HWND hDlg,
                 UINT iMessage,
                 WPARAM wParam,
                 LPARAM lParam
                 )
{
    BOOL           bHandled ;

    bHandled = TRUE ;
    switch (iMessage) {
        case TL_INTERVAL:
            OnTLineInterval (hDlg, (int)wParam, (SYSTEMTIME *) lParam) ;
            break ;

        case WM_INITDIALOG:
            OnInitDialog (hDlg) ;
            return  (TRUE) ;

        case WM_CLOSE:
            OnCancel (hDlg) ;
            EndDialog (hDlg, 0) ;
            break ;

        case WM_COMMAND:
            switch (wParam) {
                case IDD_OK:
                    SetHourglassCursor() ;
                    OnOK (hDlg) ;
                    SetArrowCursor() ;
                    EndDialog (hDlg, 1) ;
                    break ;

                case IDD_TIMEFRAMESETSTART:
                case IDD_TIMEFRAMESETSTOP:
                    OnSetStartStop (hDlg, wParam == IDD_TIMEFRAMESETSTART) ;
                    break ;

                case IDD_CANCEL:
                    OnCancel (hDlg) ;
                    GetWindowRect (hDlg, &TFrameRectWindow) ;
                    EndDialog (hDlg, 0) ;
                    break ;

                case IDD_TIMEFRAMEHELP:
                    CallWinHelp (dwCurrentDlgID, hDlg) ;
                    break ;

                default:
                    bHandled = FALSE ;
                    break;
            }
            break;


        default:
            bHandled = FALSE ;
            break ;
    }

    return (bHandled) ;
}

BOOL
SetTimeframe (
             HWND hWndParent
             )
{
    if (DialogBox (hInstance, idDlgTimeframe, hWndParent, TimeframeDlgProc)) {
        return (TRUE) ;
    }
    return (FALSE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\system.h ===
void SystemFree (PPERFSYSTEM pSystem, BOOL bDeleteTheSystem);


void FreeSystems (PPERFSYSTEM pSystemFirst) ;

void DeleteUnusedSystems (PPPERFSYSTEM ppSystemFirst, int iNoUsedSystem) ;

PPERFSYSTEM SystemGet (PPERFSYSTEM pSystemFirst,
                       LPCTSTR lpszSystemName) ;


PPERFSYSTEM  SystemAdd (PPPERFSYSTEM ppSystemFirst,
                        LPCTSTR lpszSystemName,
                        HWND    hDlg) ;


DWORD SystemCount (PPERFSYSTEM pSystemFirst) ;


PPERFSYSTEM GetComputer (HDLG hDlg,
                         WORD wControlID,
                         BOOL bWarn,
                         PPERFDATA *pPerfData,
                         PPERFSYSTEM *ppSystemFirst) ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\strids.h ===
// File open related strings
#define IDS_CHARTFILE        700
#define IDS_CHARTFILEEXT     701
#define IDS_DEF_CHART_EXT    702

#define IDS_ALERTFILE        710
#define IDS_ALERTFILEEXT     711
#define IDS_DEF_ALERT_EXT    712

#define IDS_LOGFILE          720
#define IDS_LOGFILEEXT       721
#define IDS_DEF_LOG_EXT      722

#define IDS_REPORTFILE       730
#define IDS_REPORTFILEEXT    731
#define IDS_DEF_REPORT_EXT   732

#define IDS_ALLFILES         740
#define IDS_ALLFILESEXT      741
#define IDS_DEF_ALLFILE_EXT  742

#define IDS_SAVELOGFILE      750
#define IDS_SAVELOGFILEEXT   751
#define IDS_DEF_LOGFILE_EXT  752

#define IDS_WORKSPACEFILE    760
#define IDS_WORKSPACEFILEEXT 761
#define IDS_DEF_WORKSPACE_EXT 762

#define IDS_EXPORTFILE       770
#define IDS_EXPORTFILECSVEXT 771
#define IDS_DEF_EXPORT_CSV   772

#define IDS_EXPORTFILETSV    780
#define IDS_EXPORTFILETSVEXT 781
#define IDS_DEF_EXPORT_TSV   782

#define IDS_FILEOPEN_TITLE   799
/*	STRING ID'S                */

#define IDS_APPNAME	       800
#define IDS_NONAME          801
#define IDS_LEGENDNAME      803
#define IDS_SYSNAME         804
#define IDS_OBJNAME         805
#define IDS_COUNTERNAME     806
#define IDS_INSTNAME        807
#define IDS_SCALENAME       808
#define IDS_PARENT          809
#define IDS_CURRENT         810
#define IDS_SYSTEM_PROBLEM  811

// ERROR MESSAGES
#define IDS_NONNUMERIC	     817     // number input is nonnumeric
#define IDS_MANYCLOCKS	     818     // too many clocks
#define IDS_CANTDOTIMER      819     // can't allocate timer
#define IDS_BADTIMERMSG      820     // window receives bad mesage
#define IDS_BADERROR         821     // bad error message
#define IDS_NO_MEMORY        822     // out of memory
#define IDS_BADHMOD          823     // received bad module handle
#define IDS_BADBRUSH         824     // NULL brush created
#define IDS_CANT_REALLOC     825     // can't realloc graph
#define IDS_COUNTER_NOT_IMP  826     // counter not implemented yet
#define IDS_SAVEAS_TITLE     827
#define IDS_SAVEASW_TITLE    828
#define IDS_GRAPH_FNAME      829
#define IDS_LOG_FNAME        830
#define IDS_ALERT_FNAME      831
#define IDS_REPORT_FNAME     832
#define IDS_WORK_FNAME       833
#define IDS_EXPORTAS_TITLE   834

#define IDS_FILE_ERROR       850     // file error

#define IDS_STATUSTIME       901 
#define IDS_STATUSLAST       902
#define IDS_STATUSAVG        903
#define IDS_STATUSMIN        904
#define IDS_STATUSMAX        905


#define IDS_LABELCOLOR       906
#define IDS_LABELSCALE       907
#define IDS_LABELCOUNTER     908
#define IDS_LABELINSTANCE    909
#define IDS_LABELPARENT      910
#define IDS_LABELOBJECT      911
#define IDS_LABELSYSTEM      912

#define IDS_CLOSED           913
#define IDS_PAUSED           914
#define IDS_COLLECTING       915

#define IDS_LOGOPTIONS       916

#define IDS_STOP             917
#define IDS_RESUME           918

#define IDS_EDIT             919
#define IDS_OPTIONS          920


#define IDS_START            921
#define IDS_PAUSE            922
#define IDS_DONE             923

#define IDS_OPENLOG          925
#define IDS_NEEDALERTVALUE   926

#define IDS_LABELVALUE       927

#define IDS_ADDTOCHART       928
#define IDS_ADDTOALERT       929
#define IDS_ADDTOREPORT      930

#define IDS_SYSTEMFORMAT     931
#define IDS_OBJECTFORMAT     932

#define IDS_STATUSFORMAT     934
#define IDS_CURRENTACTIVITY  935


#define IDS_EDITCHART        936
#define IDS_EDITALERT        937
#define IDS_EDITREPORT       938

#define IDS_OK               939
#define IDS_SAVECHART        940
#define IDS_MODIFIEDCHART    941

#define IDS_COMPUTERNOTFOUND 942
#define IDS_ALLOBJECTS       943
#define IDS_DEFAULTPATH      944
#define IDS_CREATELOGFILE    945

#define IDS_SAVEREPORT       946
#define IDS_MODIFIEDREPORT   947

#define IDS_STOPBEFORESTART  948
#define IDS_TIMEFRAME        949
#define IDS_STATUSFORMAT2    950

// the folowing strings are used by Export***
#define IDS_REPORT_HEADER    970
#define IDS_REPORT_LOGFILE   971
#define IDS_INTERVAL_FORMAT  972
#define IDS_CHARTINT_FORMAT  973

#define IDS_START_TEXT       974
#define IDS_STOP_TEXT        975
#define IDS_ALERT_TRIGGER    976
#define IDS_EXPORT_DATE      977
#define IDS_EXPORT_TIME      978

#define IDS_HELPFILE_NAME    979
#define IDS_NEWDATA_BOOKMARK 980


// default strings used in Date/Time
#define IDS_SHORT_DATE_FORMAT 1101
#define IDS_TIME_FORMAT       1102
#define IDS_S1159             1103
#define IDS_S2359             1104

// string id for default scale factor
#define IDS_DEFAULT           1120

// string id for Alert msg when system down
#define IDS_SYSTEM_DOWN       1121
#define IDS_SYSTEM_UP         1122


// the following are error strings
// error relating to files
#define ERR_LOG_FILE          2000
#define ERR_EXPORT_FILE       2001
#define ERR_SETTING_FILE      2002
#define ERR_BAD_LOG_FILE      2003
#define ERR_BAD_SETTING_FILE  2004
#define ERR_CORRUPT_LOG       2005
#define ERR_CANT_OPEN         2006
#define ERR_CANT_RELOG_DATA   2007

// system errors
#define ERR_NO_MEMORY         2100

// error relating to dialogs
#define ERR_COUNTER_NOT_IMP   2200
#define ERR_NEEDALERTVALUE    2201
#define ERR_STOPBEFORESTART   2202
#define ERR_COMPUTERNOTFOUND  2203
#define ERR_BADVERTMAX        2204
#define ERR_BADTIMEINTERVAL   2205

// error in computer name specified on command line
#define ERR_BADCOMPUTERNAME	2300
// unable to access perf data
#define ERR_ACCESS_DENIED   2301    // due to insufficient permissions
#define ERR_UNABLE_CONNECT  2302    // due to some other reason
#define ERR_HELP_NOT_AVAILABLE  2303    // help file not found on system

// strings for the sysmon interface
#define SP_NOTICE_CAPTION       2401
#define SP_NOTICE_TEXT          2402
#define SP_SYSMON_CMDLINE       2403
#define SP_SYSMON_CREATE_ERR    2404



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\system.c ===
//
//  Foreign computer support needs more work (a-robw)
//
#ifdef FOREIGN_COMPUTER_SUPPORT
#undef FOREIGN_COMPUTER_SUPPORT
#endif

#include "perfmon.h"
#include "system.h"     // external declarations for this file

#include "perfdata.h"
#include "perfmops.h"
#include "playback.h"   // for PlayingBackLog
#include "pmemory.h"
#include "utils.h"      // for strsame, et al
#include "sizes.h"


DWORD
SystemCount(
    PPERFSYSTEM pSystemFirst
)
{
    PPERFSYSTEM       pSystem ;
    DWORD           iNumSystems ;

    iNumSystems = 0 ;

    for (pSystem = pSystemFirst ;
         pSystem ;
         pSystem = pSystem->pSystemNext) {
        iNumSystems++ ;
    }

    return iNumSystems ;
}


BOOL
SystemSetupThread (PPERFSYSTEM pSystem)
{
    DWORD           dwThreadID ;
    HANDLE          hThread ;
    HANDLE          hStateDataMutex ;
    HANDLE          hPerfDataEvent ;
    SECURITY_ATTRIBUTES  SecAttr ;
    PPERFDATA       pSystemPerfData ;


    SecAttr.nLength = sizeof (SecAttr) ;
    SecAttr.bInheritHandle = TRUE ;
    SecAttr.lpSecurityDescriptor = NULL ;

    hThread = CreateThread (&SecAttr, 1024L,
        (LPTHREAD_START_ROUTINE)PerfDataThread, (LPVOID)(pSystem), 0L, &dwThreadID);

    if (!hThread) {
        SystemFree (pSystem, TRUE);
        return (FALSE) ;
    }

    // create a State Data Lock mutex
    hStateDataMutex = CreateMutex (&SecAttr, FALSE, NULL);
    if (!hStateDataMutex) {
        CloseHandle (hThread) ;
        SystemFree (pSystem, TRUE);
        return (FALSE);
    }
    hPerfDataEvent = CreateEvent (&SecAttr, TRUE, 0L, NULL) ;
    if (!hPerfDataEvent) {
        CloseHandle (hStateDataMutex) ;
        CloseHandle (hThread) ;
        SystemFree (pSystem, TRUE);
        return (FALSE);
    }

    // allocate Perfdata
    pSystemPerfData = (PPERFDATA) MemoryAllocate (4096L) ;
    if (!pSystemPerfData) {
        CloseHandle (hPerfDataEvent) ;
        CloseHandle (hStateDataMutex) ;
        CloseHandle (hThread) ;
        SystemFree (pSystem, TRUE);
        return (FALSE);
    }
    // now setup the pSystem..
    pSystem->dwThreadID = dwThreadID ;
    pSystem->hThread = hThread ;
    pSystem->hPerfDataEvent = hPerfDataEvent ;
    pSystem->pSystemPerfData = pSystemPerfData ;
    pSystem->hStateDataMutex = hStateDataMutex ;

    return (TRUE) ;
}

PPERFSYSTEM
SystemCreate (
    LPCTSTR lpszSystemName
)
{
    PPERFSYSTEM     pSystem ;
    PPERFDATA       pLocalPerfData = NULL;
    DWORD           Status ;
    DWORD           dwMemSize;
    TCHAR           GlobalValueBuffer[] = L"Global" ;
    TCHAR           ForeignValueBuffer[8+MAX_SYSTEM_NAME_LENGTH+1] =
                    L"Foreign " ;

    // attempt to allocate system data structure

    pSystem = MemoryAllocate (sizeof (PERFSYSTEM)) ;
    if (!pSystem) {
        SetLastError (ERROR_OUTOFMEMORY) ;
        return (NULL) ;
    }

    // initialize name and help table pointers

    pSystem->CounterInfo.pNextTable = NULL;
    pSystem->CounterInfo.dwLangId = 0;
    pSystem->CounterInfo.dwLastId = 0;
    pSystem->CounterInfo.TextString = NULL;

    lstrcpy (pSystem->sysName, lpszSystemName) ;

    // try to open key to registry, error code is in GetLastError()

    pSystem->sysDataKey = OpenSystemPerfData(lpszSystemName);

    // if a Null Key was returned then:
    //  a) there's no such computer
    //  b) the system is a foreign computer
    //
    //  before giving up, then see if it's a foreign computer

    if (!pSystem->sysDataKey) {

        // build foreign computer string

        lstrcat(ForeignValueBuffer, lpszSystemName) ;

        // assign System value name pointer to the local variable for trial

        pSystem->lpszValue = ForeignValueBuffer;

        // try to get data from the computer to see if it's for real
        // otherwise, give up and return NULL

        pLocalPerfData = MemoryAllocate (STARTING_SYSINFO_SIZE);
        if (pLocalPerfData == NULL) { // no mem so give up
            pSystem->lpszValue = NULL;
            SystemFree (pSystem, TRUE);
            SetLastError (ERROR_OUTOFMEMORY);
            return (NULL);
        } else {
            pSystem->sysDataKey = HKEY_PERFORMANCE_DATA; // local machine
            bCloseLocalMachine = TRUE ;

            dwMemSize = STARTING_SYSINFO_SIZE;
            Status = GetSystemPerfData (
                    pSystem->sysDataKey,
                    pSystem->lpszValue,
                    pLocalPerfData,
                    &dwMemSize);

            // success means a valid buffer came back
            // more data means someone tried (so it's probably good (?)

            if ((Status == ERROR_MORE_DATA) || (Status == ERROR_SUCCESS)) {
                if (Status == ERROR_SUCCESS) {
                    // see if a perf buffer was returned
                    if ((dwMemSize > 0) &&
                        pLocalPerfData->Signature[0] == (WCHAR)'P' &&
                        pLocalPerfData->Signature[1] == (WCHAR)'E' &&
                        pLocalPerfData->Signature[2] == (WCHAR)'R' &&
                        pLocalPerfData->Signature[3] == (WCHAR)'F' ) {
                        // valid buffer so continue
                    } else {
                        // invalid so unable to connect to that machine
                        pSystem->lpszValue = NULL;
                        SystemFree (pSystem, TRUE);
                        SetLastError (ERROR_BAD_NET_NAME); // unable to find name
                        return (NULL);
                    }
                } else {
                    // assume that if MORE_DATA is returned that SOME
                    // data was attempted so the buffer must be valid
                    // (we hope)
                }
                MemoryFree ((LPMEMORY)pLocalPerfData) ;
                pLocalPerfData = NULL;

                // if we are reading from a setting file, let this pass thru'
                if (bDelayAddAction == TRUE) {
                   pSystem->sysDataKey = NULL ;
                   pSystem->FailureTime = GetTickCount();
                   pSystem->dwSystemState = SYSTEM_DOWN;

                   // Free any memory that may have created
                   SystemFree (pSystem, FALSE) ;

                   pSystem->lpszValue = MemoryAllocate (TEMP_BUF_LEN*sizeof(WCHAR));

                   if (!pSystem->lpszValue) {
                      // unable to allocate memory
                      SystemFree (pSystem, TRUE);
                      SetLastError (ERROR_OUTOFMEMORY);
                      return (NULL) ;
                   } else {
                      lstrcpy (pSystem->lpszValue, GlobalValueBuffer);
                   }

                   // Setup the thread's stuff
                   if (SystemSetupThread (pSystem))
                      return (pSystem) ;
                   else
                      return NULL;
                }
            } else {
                // some other error was returned so pack up and leave
                pSystem->lpszValue = NULL;
                SystemFree (pSystem, TRUE);
                SetLastError (ERROR_BAD_NET_NAME); // unable to find name
                return (NULL);
            }
            
            if (pLocalPerfData != NULL) {
                MemoryFree ((LPMEMORY)pLocalPerfData);    // don't really need anything from it
            }

            // ok, so we've established that a foreign data provider
            // exists, now to finish the initialization.

            // change system name in structure to get counter names

            lstrcpy (pSystem->sysName, LocalComputerName);

            Status = GetSystemNames(pSystem);   // get counter names & explain text
            if (Status != ERROR_SUCCESS) {
                // unable to get names so bail out
                pSystem->lpszValue = NULL;
                SystemFree (pSystem, TRUE);
                SetLastError (Status);
                return (NULL) ;
            }

            // restore computer name for displays, etc.

            lstrcpy (pSystem->sysName, lpszSystemName);

            // allocate value string buffer
            pSystem->lpszValue = MemoryAllocate (TEMP_BUF_LEN*sizeof(WCHAR));
            if (!pSystem->lpszValue) {
                // unable to allocate memory
                SystemFree (pSystem, TRUE);
                SetLastError (ERROR_OUTOFMEMORY);
                return (NULL) ;
            } else {
                lstrcpy (pSystem->lpszValue, ForeignValueBuffer);
            }
        }
    } else {
        // if here, then a connection to the system's registry was established
        // so continue with the system data structure initialization

        // get counter names & explain text from local computer

        Status = GetSystemNames(pSystem);
        if (Status != ERROR_SUCCESS) {
            // unable to get names so bail out
            SystemFree (pSystem, TRUE);
            SetLastError (Status);
            return (NULL) ;
        }

        // allocate value string buffer
        pSystem->lpszValue = MemoryAllocate(TEMP_BUF_LEN*sizeof(WCHAR));

        if (!pSystem->lpszValue) {
            // unable to allocate memory
            SystemFree (pSystem, TRUE);
            SetLastError (ERROR_OUTOFMEMORY);
            return (NULL) ;
        } else {
            SetSystemValueNameToGlobal (pSystem);
        }
    }

    // initialize remaining system pointers

    pSystem->pSystemNext = NULL ;
    pSystem->FailureTime = 0;

    // setup data for thread data collection
    if (!PlayingBackLog()) {
        // create a thread for data collection
        if (!SystemSetupThread (pSystem))
           return (NULL) ;
    }

    SetLastError (ERROR_SUCCESS);

    return (pSystem) ;
}  // SystemCreate

PPERFSYSTEM
SystemGet (
    PPERFSYSTEM pSystemFirst,
    LPCTSTR lpszSystemName
)
{
    PPERFSYSTEM       pSystem ;

    if (!pSystemFirst) {
        return (NULL) ;
    }

    for (pSystem = pSystemFirst ;
         pSystem ;
         pSystem = pSystem->pSystemNext) {
        if (strsamei (pSystem->sysName, lpszSystemName)) {
            return (pSystem) ;
        }
    }  // for

    return (NULL) ;
}

PPERFSYSTEM
SystemAdd (
    PPPERFSYSTEM ppSystemFirst,
    LPCTSTR lpszSystemName,
    HWND    hDlg                    // owner window for error messages
)
{
    PPERFSYSTEM       pSystem ;
    PPERFSYSTEM       pSystemPrev = NULL;
    TCHAR             szMessage[256];
    DWORD             dwLastError;

    if (!*ppSystemFirst) {
        *ppSystemFirst = SystemCreate (lpszSystemName) ;
        dwLastError = GetLastError();
        // save return value
        pSystem = *ppSystemFirst;

    } else {
        for (pSystem = *ppSystemFirst ;
            pSystem ;
            pSystem = pSystem->pSystemNext) {
            pSystemPrev = pSystem ;
            if (strsamei (pSystem->sysName, lpszSystemName)) {
                return (pSystem) ;
            }
        }  // for

        pSystemPrev->pSystemNext = SystemCreate (lpszSystemName) ;
        // save return value
        pSystem = pSystemPrev->pSystemNext;
    }

    // display message box here if an error occured trying to add
    // this system

    if (pSystem == NULL) {
        dwLastError = GetLastError();
        if (dwLastError == ERROR_ACCESS_DENIED) {
            DlgErrorBox (hDlg, ERR_ACCESS_DENIED);
        } else {
            DlgErrorBox (hDlg, ERR_UNABLE_CONNECT);
        }
        SetLastError (dwLastError); // to propogate up to caller
    }

    return (pSystem);
}

void
SystemFree (
    PPERFSYSTEM pSystem,
    BOOL        bDeleteTheSystem
)
{  // SystemFree

    PCOUNTERTEXT pCounter, pNextCounter;

    if (!pSystem) {
        // can't proceed
        return ;
    }

    if (pSystem->sysDataKey && pSystem->sysDataKey != HKEY_PERFORMANCE_DATA) {
        // close the remote computer key
        RegCloseKey (pSystem->sysDataKey);
        pSystem->sysDataKey = 0 ;
    }

    for (pCounter = pSystem->CounterInfo.pNextTable, pNextCounter = NULL;
         pCounter;
         pCounter = pNextCounter) {
        pNextCounter = pCounter->pNextTable;
        MemoryFree (pCounter);
    }
    pSystem->CounterInfo.pNextTable = NULL ;

    if (pSystem->CounterInfo.TextString) {
        MemoryFree (pSystem->CounterInfo.TextString);
        pSystem->CounterInfo.TextString = NULL ;
    }

    if (pSystem->CounterInfo.HelpTextString) {
        MemoryFree (pSystem->CounterInfo.HelpTextString);
        pSystem->CounterInfo.HelpTextString = NULL ;
    }
    pSystem->CounterInfo.dwLastId = 0 ;
    pSystem->CounterInfo.dwHelpSize = 0 ;
    pSystem->CounterInfo.dwCounterSize = 0 ;

    if (bDeleteTheSystem) {
#if 0
        // cleanup all the data collection variables
        if (pSystem->hPerfDataEvent)
            CloseHandle (pSystem->hPerfDataEvent) ;

        if (pSystem->hStateDataMutex)
            CloseHandle (pSystem->hStateDataMutex) ;

        if (pSystem->hThread)
            CloseHandle (pSystem->hThread) ;

        if (pSystem->pSystemPerfData)
            MemoryFree (pSystem->pSystemPerfData);

        if (pSystem->lpszValue) {
            MemoryFree (pSystem->lpszValue);
            pSystem->lpszValue = NULL ;
        }
        MemoryFree (pSystem) ;
#endif
        if (pSystem->hThread) {
            // let the thread clean up memory
            PostThreadMessage (
               pSystem->dwThreadID,
               WM_FREE_SYSTEM,
               (WPARAM)0,
               (LPARAM)0) ;
        } else {
            // if no thread, clean up memory here.
            // Should not happen.
            if (pSystem->pSystemPerfData)
                MemoryFree ((LPMEMORY)pSystem->pSystemPerfData);

            if (pSystem->lpszValue) {
                MemoryFree (pSystem->lpszValue);
                pSystem->lpszValue = NULL ;
            }
            MemoryFree (pSystem) ;
        }
    }
}

void
DeleteUnusedSystems (
    PPPERFSYSTEM  ppSystemFirst ,
    int           iNoUseSystems
)
{
    PPERFSYSTEM   pPrevSys, pCurrentSys, pNextSys ;

    // delete all the marked system from the list header until
    // we hit one that is not marked
    while ((*ppSystemFirst)->bSystemNoLongerNeeded) {
       // delect from the list header
       pCurrentSys = *ppSystemFirst ;
       *ppSystemFirst = pCurrentSys->pSystemNext ;
       SystemFree (pCurrentSys, TRUE) ;
       iNoUseSystems-- ;
       if (iNoUseSystems <= 0 || !(*ppSystemFirst)) {
          // done
          break ;
       }
    }

    if (iNoUseSystems <= 0 || !(*ppSystemFirst)) {
       return ;
    }

    // now walk the list and delete each marked system
    for (pPrevSys = *ppSystemFirst, pCurrentSys = pPrevSys->pSystemNext ;
         pCurrentSys && iNoUseSystems > 0 ;
         pCurrentSys = pNextSys) {

       if (pCurrentSys->bSystemNoLongerNeeded) {
          // the current system is marked, updated the list and free
          // this system.  No need to change pPrevSys here
          pNextSys = pPrevSys->pSystemNext = pCurrentSys->pSystemNext ;
          SystemFree (pCurrentSys, TRUE) ;
          iNoUseSystems-- ;
       } else {
          // pCurrentSys is OK, update the 2 list pointers and
          // carry on looping
          pPrevSys = pCurrentSys ;
          pNextSys = pCurrentSys->pSystemNext ;
       }
    }
}

void
FreeSystems (
    PPERFSYSTEM pSystemFirst
)
{
    PPERFSYSTEM    pSystem, pSystemNext ;


    for (pSystem = pSystemFirst;
         pSystem;
         pSystem = pSystemNext) {
        pSystemNext = pSystem->pSystemNext ;
        SystemFree (pSystem, TRUE) ;
    }
}  // FreeSystems

PPERFSYSTEM
GetComputer (
    HDLG hDlg,
    WORD wControlID,
    BOOL bWarn,
    PPERFDATA *ppPerfData,
    PPERFSYSTEM *ppSystemFirst
)
/*
   Effect:        Attempt to set the current computer to the one in the
                  hWndComputers dialog edit box. If this computer system
                  can be found, load the objects, etc. for the computer
                  and set pSystem and ppPerfdata to the values for this
                  system.
*/
{  // GetComputer
    TCHAR          szComputer [MAX_SYSTEM_NAME_LENGTH + 1] ;
    PPERFSYSTEM    pSystem;
    TCHAR          tempBuffer [LongTextLen] ;
    DWORD          dwBufferSize = 0;
    LPTSTR         pBuffer = NULL ;
    DWORD          dwLastError;

    DialogText (hDlg, wControlID, szComputer) ;

    // If necessary, add the system to the lists for this view.
    pSystem = SystemGet (*ppSystemFirst, szComputer) ;
    if (!pSystem) {
        pSystem = SystemAdd (ppSystemFirst, szComputer, hDlg) ;
    }

    if (!pSystem && bWarn) {
        dwLastError = GetLastError();

        EditSetModified (GetDlgItem(hDlg, wControlID), FALSE) ;

        // unable to get specified computer so set to:
        //  the first computer in the system list if present 
        //      -- or --
        //  set he local machine if not.

        pSystem = *ppSystemFirst;   // set to first in list

        if (pSystem == NULL) {
            // this would mean the user can't access the local
            // system since normally that would be the first one
            // so the machine name will be restored to the 
            // local machine (for lack of a better one) but the
            // system won't be added unless they want to explicitly

            DialogSetString (hDlg, wControlID, LocalComputerName) ;
        } else {
            // set to name in system structure 
            DialogSetString (hDlg, wControlID, pSystem->sysName);
        }
        
        if (dwLastError != ERROR_ACCESS_DENIED) {
            DlgErrorBox (hDlg, ERR_COMPUTERNOTFOUND) ;
        } else {
            // the appropriate error message has already been displayed
        }

        SetFocus (DialogControl(hDlg, wControlID)) ;
    }

    if (pSystem) {
        if (PlayingBackLog ()) {
            *ppPerfData =
            LogDataFromPosition (pSystem, &(PlaybackLog.StartIndexPos)) ;
        } else {
            if (pSystem->lpszValue) {
               // save the previous lpszValue string before
               // SetSystemValueNameToGlobal mess it up
               dwBufferSize = MemorySize (pSystem->lpszValue) ;
               if (dwBufferSize <= sizeof(tempBuffer)) {
                  pBuffer = tempBuffer ;
               } else {
                  pBuffer = MemoryAllocate (dwBufferSize) ;
               }
               memcpy (pBuffer, pSystem->lpszValue, dwBufferSize) ;
            }

            SetSystemValueNameToGlobal (pSystem);
            UpdateSystemData (pSystem, ppPerfData) ;

            if (pSystem->lpszValue) {
               // retore the previous lpszValue string
               memcpy (pSystem->lpszValue, pBuffer, dwBufferSize) ;
               if (pBuffer != tempBuffer) {
                  MemoryFree (pBuffer) ;
               }
            }
        }
    }
    return (pSystem) ;

}  // GetComputer

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\timeline.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "perfmon.h"
#include "intrline.h"
#include "pmemory.h"        // for MemoryXXX (mallloc-type) routines
#include "timeline.h"
#include "perfmops.h"       // for SystemTimeDateString, et al.
#include "utils.h"
#include "grafdata.h"       // for GraphData

//==========================================================================//
//                                  Typedefs                                //
//==========================================================================//

typedef struct CHARTDATAPOINTSTRUCT
   {
   int         iLogIndex ;
   int         xDispDataPoint ;
   } CHARTDATAPOINT, *PCHARTDATAPOINT ;

typedef struct TLINESTRUCT
   {  // TLINE
   HWND              hWndILine ;
   HFONT             hFont ;

   SYSTEMTIME        SystemTimeBegin ;
   SYSTEMTIME        SystemTimeEnd ;

   int               yFontHeight ;
   int               xMaxTimeWidth ;
   int               xBegin ;
   int               xEnd ;

   RECT              rectStartDate ;
   RECT              rectStartTime ;
   RECT              rectStopDate ;
   RECT              rectStopTime ;

   PCHARTDATAPOINT   pChartDataPoint ;
   int               iCurrentStartPos ;
   int               iCurrentStopPos ;
   } TLINE ;

typedef TLINE *PTLINE ;

void PlaybackChartDataPoint (PCHARTDATAPOINT pChartDataPoint) ;

// IntrLineFocus is defined and set/clear in Intrline.c
extern BOOL  IntrLineFocus ;

//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define dwTLineClassStyle     (CS_HREDRAW | CS_VREDRAW)
#define iTLineClassExtra      (0)
#define iTLineWindowExtra     (sizeof (PTLINE))
#define dwTLineWindowStyle    (WS_CHILD | WS_VISIBLE)

HWND  hTLineWnd ;
BOOL  TLineWindowUp ;



PTLINE TLData (HWND hWndTL)
   {
   return ((PTLINE) GetWindowLongPtr (hWndTL, 0)) ;
   }


PTLINE AllocateTLData (HWND hWndTL)
   {
   PTLINE         pTLine ;
   PGRAPHSTRUCT   pGraph ;

   pGraph = GraphData (hWndGraph) ;

   pTLine = MemoryAllocate (sizeof (TLINE)) ;
   if (!pTLine)
      return NULL;


   // see if we have to draw the timeline
   if (pGraph &&
      iPerfmonView == IDM_VIEWCHART &&
      pGraph->pLineFirst &&
      pGraph->gOptions.iGraphOrHistogram == LINE_GRAPH)
      {
      pTLine->pChartDataPoint =
         MemoryAllocate (sizeof(CHARTDATAPOINT) *
         (pGraph->gTimeLine.iValidValues+1)) ;


      if (pTLine->pChartDataPoint != NULL)
         {
         PlaybackChartDataPoint (pTLine->pChartDataPoint) ;
         }
      }

   SetWindowLongPtr (hWndTL, 0, (LONG_PTR) pTLine) ;

   return (pTLine) ;
   }


int MaxTimeWidth (HDC hDC,
                  PTLINE pTLine)
/*
   Effect:        Return a reasonable maximum number of pixels to hold
                  expected time and date strings.

   To Do:         When we use the alleged local-date and local-time display
                  functions, we will modify this routine to use them.
*/
   {  // MaxTimeWidth
   return (max (TextWidth (hDC, TEXT(" 99 XXX 99 ")),
                TextWidth (hDC, TEXT(" 99:99:99.9 PM ")))) ;
   }  // MaxTimeWidth


void TLGetSystemTimeN (HWND hWnd,
                       int iInterval,
                       SYSTEMTIME *pSystemTime)
   {  // TLGetSystemTimeN
   SendMessage (WindowParent (hWnd),
                TL_INTERVAL,
                iInterval, (LPARAM) pSystemTime) ;
   }  // TLGetSystemTimeN



void static TLDrawBeginEnd (HDC hDC,
                            PTLINE pTLine)
   {
   TCHAR         szDate [20] ;
   TCHAR         szTime [20] ;

   SetTextAlign (hDC, TA_TOP) ;
   SelectFont (hDC, pTLine->hFont) ;

   // Draw the begin time

   SystemTimeDateString (&(pTLine->SystemTimeBegin), szDate) ;
   SystemTimeTimeString (&(pTLine->SystemTimeBegin), szTime, TRUE) ;

   SetTextAlign (hDC, TA_RIGHT) ;
   TextOut (hDC, pTLine->xBegin, 0,
            szDate, lstrlen (szDate)) ;
   TextOut (hDC, pTLine->xBegin, pTLine->yFontHeight,
            szTime, lstrlen (szTime)) ;

   // Draw The end time

   SystemTimeDateString (&(pTLine->SystemTimeEnd), szDate) ;
   SystemTimeTimeString (&(pTLine->SystemTimeEnd), szTime, TRUE) ;

   SetTextAlign (hDC, TA_LEFT) ;
   TextOut (hDC, pTLine->xEnd, 0,
            szDate, lstrlen (szDate)) ;
   TextOut (hDC,
            pTLine->xEnd,
            pTLine->yFontHeight,
            szTime, lstrlen (szTime)) ;
   }

void TLineRedraw (HDC hGraphDC, PGRAPHSTRUCT pGraph)
   {
   PTLINE         pTLine ;

   if (!hTLineWnd)
      {
      return ;
      }

   pTLine = TLData (hTLineWnd) ;
   if (pTLine == NULL)
      {
      return ;
      }

   if (pTLine->iCurrentStartPos)
      {
      // redraw start line
      PatBlt (hGraphDC, pTLine->iCurrentStartPos, pGraph->rectData.top,
         1, pGraph->rectData.bottom - pGraph->rectData.top + 1,
         DSTINVERT) ;
      }

   if (pTLine->iCurrentStopPos)
      {
      // redraw stop line
      PatBlt (hGraphDC, pTLine->iCurrentStopPos, pGraph->rectData.top,
         1, pGraph->rectData.bottom - pGraph->rectData.top+ 1,
         DSTINVERT) ;
      }
   }  // TLineRedraw

void DrawOneTimeIndicator (PTLINE pTLine,
                           PGRAPHSTRUCT pGraph,
                           HDC hGraphDC,
                           int iPos,
                           int *pCurrentPos)
   {
   int               xPos ;
   PCHARTDATAPOINT   pDataPoint ;

   // check if it is within current selected range
   if (iPos >= PlaybackLog.StartIndexPos.iPosition &&
      iPos <= PlaybackLog.StopIndexPos.iPosition)
      {

      xPos = 0 ;
      pDataPoint = pTLine->pChartDataPoint ;

      // check for the x position of this Log Index
      while (pDataPoint->iLogIndex != 0)
         {
         if (iPos >= pDataPoint->iLogIndex)
            {
            if ((pDataPoint+1)->iLogIndex == 0)
               {
               // we have reached the end
               xPos = pDataPoint->xDispDataPoint ;
               break ;
               }
            else if (iPos <= (pDataPoint+1)->iLogIndex)
               {
               // we have found the Log index
               xPos = (pDataPoint+1)->xDispDataPoint ;
               break ;
               }
            }
         else
            {
            // no need to continue if iPos is smaller than the
            // first Log index on the chart
            break ;
            }

         pDataPoint++ ;
         }

      if (xPos != *pCurrentPos)
         {
         if (*pCurrentPos)
            {
            // erase the old line
            PatBlt (hGraphDC, *pCurrentPos, pGraph->rectData.top,
               1, pGraph->rectData.bottom - pGraph->rectData.top + 1,
               DSTINVERT) ;
            }

         // draw the new line
         *pCurrentPos = xPos ;

         if (xPos > 0)
            {
            PatBlt (hGraphDC, xPos, pGraph->rectData.top,
               1, pGraph->rectData.bottom - pGraph->rectData.top + 1,
               DSTINVERT) ;
            }
         }
      }
   else
      {
      if (*pCurrentPos)
         {
         // erase the old line
         PatBlt (hGraphDC, *pCurrentPos, pGraph->rectData.top,
            1, pGraph->rectData.bottom - pGraph->rectData.top + 1,
            DSTINVERT) ;
         }

      *pCurrentPos = 0 ;
      }
   }  // DrawOneTimeIndicator

void DrawTimeIndicators (PTLINE pTLine, int iStart, int iStop)
   {

   HDC            hGraphDC ;
   PGRAPHSTRUCT   pGraph ;

   hGraphDC = GetDC (hWndGraph) ;
   if (!hGraphDC)
        return;
   pGraph = GraphData (hWndGraph) ;
   if (!pGraph)
      {
      ReleaseDC(hWndGraph, hGraphDC);
      return ;
      }

   DrawOneTimeIndicator (pTLine, pGraph, hGraphDC, iStart, &pTLine->iCurrentStartPos) ;
   DrawOneTimeIndicator (pTLine, pGraph, hGraphDC, iStop, &pTLine->iCurrentStopPos) ;

   ReleaseDC (hWndGraph, hGraphDC) ;
   }

void static TLDrawStartStop (HWND hWnd,
                             HDC hDC,
                             PTLINE pTLine)
/*
   Effect:        Draw the start and stop date/times on the bottom of the
                  timeline. Draw the start date/time right justified at the
                  outer edge of the start point and the stop date/time left
                  justified with the outer edge of the stop point.

                  Erase previous start and stop date/times in the process.
*/
   {  // TLDrawStartStop
   RECT           rectDate ;
   RECT           rectTime ;
   RECT           rectOpaque ;

   TCHAR          szDate [30] ;
   TCHAR          szTime [30] ;

   int            xStart ;
   int            xStop ;

   int            iStart ;
   int            iStop ;

   SYSTEMTIME     SystemTimeStart ;
   SYSTEMTIME     SystemTimeStop ;

   int            xDateTimeWidth ;


   SelectFont (hDC, pTLine->hFont) ;
   SetTextAlign (hDC, TA_TOP) ;

   //=============================//
   // Get Start Information       //
   //=============================//

   xStart = pTLine->xBegin + ILineXStart (pTLine->hWndILine) ;

   iStart = ILineStart (pTLine->hWndILine) ;
   TLGetSystemTimeN (hWnd, iStart, &SystemTimeStart) ;
   SystemTimeDateString (&SystemTimeStart, szDate) ;
   SystemTimeTimeString (&SystemTimeStart, szTime, TRUE) ;

   xDateTimeWidth = max (TextWidth (hDC, szDate),
                         TextWidth (hDC, szTime)) ;

   //=============================//
   // Write Start Date            //
   //=============================//

   rectDate.left = xStart - xDateTimeWidth ;
   rectDate.top = pTLine->rectStartDate.top ;
   rectDate.right = xStart ;
   rectDate.bottom = pTLine->rectStartDate.bottom ;

   SetTextAlign (hDC, TA_RIGHT) ;
   UnionRect (&rectOpaque, &pTLine->rectStartDate, &rectDate) ;

   ExtTextOut (hDC,
               rectDate.right, rectDate.top,
               ETO_OPAQUE,
               &rectOpaque,
               szDate, lstrlen (szDate),
               NULL) ;
   pTLine->rectStartDate = rectDate ;

   //=============================//
   // Write Start Time            //
   //=============================//

   rectTime.left = rectDate.left ;
   rectTime.top = pTLine->rectStartTime.top ;
   rectTime.right = rectDate.right ;
   rectTime.bottom = pTLine->rectStartTime.bottom ;

   UnionRect (&rectOpaque, &pTLine->rectStartTime, &rectTime) ;

   ExtTextOut (hDC,
               rectTime.right, rectTime.top,
               ETO_OPAQUE,
               &rectOpaque,
               szTime, lstrlen (szTime),
               NULL) ;
   pTLine->rectStartTime = rectTime ;

   if (IntrLineFocus)
      {
      UnionRect (&rectOpaque, &rectDate, &rectTime) ;
      DrawFocusRect (hDC, &rectOpaque) ;
      }

   //=============================//
   // Get Stop Information        //
   //=============================//

   xStop = pTLine->xBegin + ILineXStop (pTLine->hWndILine) ;

   iStop = ILineStop (pTLine->hWndILine) ;
   TLGetSystemTimeN (hWnd, iStop, &SystemTimeStop) ;
   SystemTimeDateString (&SystemTimeStop, szDate) ;
   SystemTimeTimeString (&SystemTimeStop, szTime, TRUE) ;

   xDateTimeWidth = max (TextWidth (hDC, szDate),
                         TextWidth (hDC, szTime)) ;

   //=============================//
   // Write Stop Date             //
   //=============================//

   rectDate.left = xStop ;
   rectDate.top = pTLine->rectStopDate.top ;
   rectDate.right = xStop + xDateTimeWidth ;
   rectDate.bottom = pTLine->rectStopDate.bottom ;

   SetTextAlign (hDC, TA_LEFT) ;
   UnionRect (&rectOpaque, &pTLine->rectStopDate, &rectDate) ;

   ExtTextOut (hDC,
               rectDate.left, rectDate.top,
               ETO_OPAQUE,
               &rectOpaque,
               szDate, lstrlen (szDate),
               NULL) ;
   pTLine->rectStopDate = rectDate ;

   //=============================//
   // Write Stop Time             //
   //=============================//

   rectTime.left = rectDate.left ;
   rectTime.top = pTLine->rectStopTime.top ;
   rectTime.right = rectDate.right ;
   rectTime.bottom = pTLine->rectStopTime.bottom ;

   UnionRect (&rectOpaque, &pTLine->rectStopTime, &rectTime) ;

   ExtTextOut (hDC,
               rectTime.left, rectTime.top,
               ETO_OPAQUE,
               &rectOpaque,
               szTime, lstrlen (szTime),
               NULL) ;
   pTLine->rectStopTime = rectTime ;

   if (IntrLineFocus)
      {
      UnionRect (&rectOpaque, &rectDate, &rectTime) ;
      DrawFocusRect (hDC, &rectOpaque) ;
      }

   if (pTLine->pChartDataPoint)
      {
      DrawTimeIndicators (pTLine, iStart, iStop) ;
      }
   }  // TLDrawStartStop



//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//



void static OnCreate (HWND hWnd)
   {  // OnCreate
   PTLINE         pTLine ;
   HDC            hDC ;

   pTLine = AllocateTLData (hWnd) ;

   pTLine->hFont = hFontScales ;

   hDC = GetDC (hWnd) ;
   SelectFont (hDC, hFontScales) ;

   pTLine->yFontHeight = FontHeight (hDC, TRUE) ;
   pTLine->xMaxTimeWidth = MaxTimeWidth (hDC, pTLine) ;

   ReleaseDC (hWnd, hDC) ;

   hTLineWnd = hWnd ;
   TLineWindowUp = TRUE ;

   pTLine->hWndILine =
      CreateWindow (szILineClass,                  // class
                    NULL,                          // caption
                    (WS_VISIBLE | WS_CHILD | WS_TABSTOP ),       // window style
                    0, 0,                          // position
                    0, 0,                          // size
                    hWnd,                          // parent window
                    NULL,                          // menu
                    hInstance,                     // program instance
                    NULL) ;                        // user-supplied data
   }  // OnCreate


void static OnDestroy (HWND hWnd)
   {
   PTLINE         pTLine ;

   pTLine = TLData (hWnd) ;

   if (pTLine->pChartDataPoint)
      {
      MemoryFree (pTLine->pChartDataPoint) ;
      }

   MemoryFree (pTLine) ;

   hTLineWnd = 0 ;
   TLineWindowUp = FALSE ;

   }


void static OnSize (HWND hWnd,
                    int xWidth,
                    int yHeight)
/*
   Effect:        Perform all actions needed when the size of the timeline
                  hWnd has changed. In particular, determine the appropriate
                  size for the ILine window and set the rectangles for the
                  top and bottom displays.
*/
   {  // OnSize
   PTLINE         pTLine ;
   int            yLine ;
   int            yDate, yTime ;
   int            xEnd ;

   pTLine = TLData (hWnd) ;

   xEnd = xWidth - pTLine->xMaxTimeWidth ;
   yLine = pTLine->yFontHeight ;
   yDate = yHeight - 2 * yLine ;
   yTime = yHeight - yLine ;


   SetRect (&pTLine->rectStartDate,
            0, yDate, 0, yDate + yLine) ;

   SetRect (&pTLine->rectStartTime,
            0, yTime, 0, yTime + yLine) ;

   SetRect (&pTLine->rectStopDate,
            xEnd, yDate, xEnd, yDate + yLine) ;

   SetRect (&pTLine->rectStopTime,
            xEnd, yTime, xEnd, yTime + yLine) ;

   MoveWindow (pTLine->hWndILine,
               pTLine->xMaxTimeWidth, 2 * pTLine->yFontHeight,
               xWidth - 2 * pTLine->xMaxTimeWidth,
               yHeight - 4 * pTLine->yFontHeight,
               FALSE) ;

   pTLine->xBegin = pTLine->xMaxTimeWidth ;
   pTLine->xEnd = xWidth - pTLine->xMaxTimeWidth ;
   }  // OnSize


void static OnPaint (HWND hWnd)
   {
   HDC            hDC ;
   PAINTSTRUCT    ps ;
   PTLINE         pTLine ;

   hDC = BeginPaint (hWnd, &ps) ;

   pTLine = TLData (hWnd) ;
   TLDrawBeginEnd (hDC, pTLine) ;
   TLDrawStartStop (hWnd, hDC, pTLine) ;

   EndPaint (hWnd, &ps) ;
   }


void static OnILineChanged (HWND hWnd)
   {
   HDC            hDC ;
   PTLINE         pTLine ;

   pTLine = TLData (hWnd) ;

   hDC = GetDC (hWnd) ;
   if (hDC) {
       TLDrawStartStop (hWnd, hDC, pTLine) ;
       ReleaseDC (hWnd, hDC) ;
   }
}


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


LRESULT
FAR
PASCAL
TLineWndProc (
              HWND hWnd,
              unsigned msg,
              WPARAM wParam,
              LPARAM lParam
              )
/*
   Note:          This function must be declared in the application's
                  linker-definition file, perfmon.def file.
*/
   {  // TLineWndProc
   BOOL           bCallDefWindowProc ;
   LRESULT        lReturnValue ;

   bCallDefWindowProc = FALSE ;
   lReturnValue = 0L ;

   switch (msg)
      {  // switch
      case WM_SETFOCUS:
         {
         PTLINE         pTLine ;

         pTLine = TLData (hWnd) ;
         SetFocus (pTLine->hWndILine) ;
         }
         return 0 ;

      case WM_KILLFOCUS:
         return 0 ;

      case WM_COMMAND:
         OnILineChanged (hWnd) ;
         break ;

      case WM_CREATE:
         OnCreate (hWnd) ;
         break ;

      case WM_DESTROY:
         OnDestroy (hWnd) ;
         break ;

      case WM_PAINT:
         OnPaint (hWnd) ;
         break ;

      case WM_SIZE:
         OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ;
         break ;

      default:
         bCallDefWindowProc = TRUE ;
      }  // switch

   if (bCallDefWindowProc)
      lReturnValue = DefWindowProc (hWnd, msg, wParam, lParam) ;

   return (lReturnValue) ;
   }  // TLineWndProc



BOOL TLineInitializeApplication (void)
/*
   Effect:        Perform all initializations required before an application
                  can create an IntervalLine. In particular, register the
                  IntervalLine window class.

   Called By:     The application, in its InitializeApplication routine.

   Returns:       Whether the class could be registered.
*/
   {  // TLineInitializeApplication
   WNDCLASS       wc ;

   wc.style =           dwTLineClassStyle ;
   wc.lpfnWndProc =     TLineWndProc ;
   wc.cbClsExtra =      iTLineClassExtra ;
   wc.cbWndExtra =      iTLineWindowExtra ;
   wc.hInstance =       hInstance ;
   wc.hIcon =           NULL ;
   wc.hCursor =         LoadCursor (NULL, IDC_ARROW) ;
   wc.hbrBackground =   (HBRUSH) (COLOR_WINDOW + 1) ;
   wc.lpszMenuName =    NULL ;
   wc.lpszClassName =   szTLineClass ;

   return (RegisterClass (&wc)) ;
   }  // TLineInitializeApplication


void TLineSetRange (HWND hWnd,
                    int iBegin,
                    int iEnd)
   {
   PTLINE         pTLine ;

   pTLine = TLData (hWnd) ;

   ILineSetRange (pTLine->hWndILine, iBegin, iEnd) ;
   TLGetSystemTimeN (hWnd, iBegin, &pTLine->SystemTimeBegin) ;
   TLGetSystemTimeN (hWnd, iEnd, &pTLine->SystemTimeEnd) ;
   }


void TLineSetStart (HWND hWnd,
                    int iStart)
   {
   PTLINE         pTLine ;

   pTLine = TLData (hWnd) ;
   ILineSetStart (pTLine->hWndILine, iStart) ;
   }


void TLineSetStop (HWND hWnd,
                   int iStop)
   {
   PTLINE         pTLine ;

   pTLine = TLData (hWnd) ;
   ILineSetStop (pTLine->hWndILine, iStop) ;
   }


int TLineStart (HWND hWnd)
   {
   PTLINE         pTLine ;

   pTLine = TLData (hWnd) ;

   return (ILineStart (pTLine->hWndILine)) ;
   }


int TLineStop (HWND hWnd)
   {
   PTLINE         pTLine ;

   pTLine = TLData (hWnd) ;

   return (ILineStop (pTLine->hWndILine)) ;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\timeline.h ===
//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define szTLineClass          TEXT("PerfTLine")
#define szTLineClassA         "PerfTLine"

#define TL_INTERVAL           (WM_USER + 0x301)


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


BOOL TLineInitializeApplication (void) ;


void TLineSetRange (HWND hWnd, 
                    int iBegin, 
                    int iEnd) ;


void TLineSetStart (HWND hWnd,
                    int iStart) ;


void TLineSetStop (HWND hWnd,
                   int iStop) ;


int TLineStart (HWND) ;


int TLineStop (HWND) ;

void TLineRedraw (HDC hDC, PGRAPHSTRUCT pGraph) ;

extern BOOL TLineWindowUp ;
#define IsTLineWindowUp() (TLineWindowUp)


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\toolbar.h ===
//
//                            Exported Functions                            
//

BOOL CreateToolbarWnd (HWND hWnd) ;

void ToolbarEnableButton (HWND hWndTB,
                          int iButtonNum,
                          BOOL bEnable) ;


void ToolbarDepressButton (HWND hWndTB,
                           int iButtonNum,
                           BOOL bDepress) ;

void OnToolbarHit (WPARAM wParam, 
                   LPARAM lParam) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\toolbar.c ===
//
//                                 Includes                                 
//


#include "perfmon.h"
#include <commctrl.h>
#include "toolbar.h"
#include "status.h"     // for StatusLine & StatusLineReady

#ifdef ADVANCED_PERFMON
TBBUTTON tbButtons[] = {
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,        0 },
   { 0, IDM_VIEWCHART,        TBSTATE_ENABLED,   TBSTYLE_CHECKGROUP, 0 },
   { 1, IDM_VIEWALERT,        TBSTATE_ENABLED,   TBSTYLE_CHECKGROUP, 0 },
   { 2, IDM_VIEWLOG,          TBSTATE_ENABLED,   TBSTYLE_CHECKGROUP, 0 },
   { 3, IDM_VIEWREPORT,       TBSTATE_ENABLED,   TBSTYLE_CHECKGROUP, 0 },
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,        0 },
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,        0 },
   { 4, IDM_TOOLBARADD,       TBSTATE_ENABLED,   TBSTYLE_BUTTON,     0 },
   { 5, IDM_TOOLBARMODIFY,    TBSTATE_ENABLED,   TBSTYLE_BUTTON,     0 },
   { 6, IDM_TOOLBARDELETE,    TBSTATE_ENABLED,   TBSTYLE_BUTTON,     0 },
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,        0 },
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,        0 },
   { 7, IDM_TOOLBARREFRESH,   TBSTATE_ENABLED,   TBSTYLE_BUTTON,     0 },
   { 8, IDM_OPTIONSBOOKMARK,  TBSTATE_ENABLED,   TBSTYLE_BUTTON,     0 },
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,        0 },
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,        0 },
   { 9, IDM_TOOLBAROPTIONS,   TBSTATE_ENABLED,   TBSTYLE_BUTTON,     0 },
} ;
#else
TBBUTTON tbButtons[] = {
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,      0 },
   { 4, IDM_TOOLBARADD,       TBSTATE_ENABLED,   TBSTYLE_BUTTON,   0 },
   { 5, IDM_TOOLBARMODIFY,    TBSTATE_ENABLED,   TBSTYLE_BUTTON,   0 },
   { 6, IDM_TOOLBARDELETE,    TBSTATE_ENABLED,   TBSTYLE_BUTTON,   0 },
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,      0 },
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,      0 },
   { 7, IDM_TOOLBARREFRESH,   TBSTATE_ENABLED,   TBSTYLE_BUTTON,   0 },
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,      0 },
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,      0 },
   { 9, IDM_TOOLBAROPTIONS,   TBSTATE_ENABLED,   TBSTYLE_BUTTON,   0 },
} ;
#endif

#define TB_ENTRIES sizeof(tbButtons)/sizeof(tbButtons[0])

BOOL CreateToolbarWnd (HWND hWnd)
{

   hWndToolbar = CreateToolbarEx (hWnd,
      WS_CHILD | WS_BORDER | WS_VISIBLE | TBSTYLE_TOOLTIPS,
      IDM_TOOLBARID,
      10,                  // number of tools inside the bitmap
      hInstance,
      idBitmapToolbar,     // bitmap resource ID (can't use MAKEINTRESOURCE)
      tbButtons,
      TB_ENTRIES,0,0,0,0,sizeof(TBBUTTON)) ;

   return (hWndToolbar ? TRUE : FALSE) ;

}  // ToolbarInitializeApplication

void ToolbarEnableButton (HWND hWndTB, int iButtonNum, BOOL bEnable)
{
   SendMessage (hWndTB, TB_ENABLEBUTTON, iButtonNum, (LONG)bEnable) ;
}  // ToolbarEnableButton

void ToolbarDepressButton (HWND hWndTB, int iButtonNum, BOOL bDepress)
{
   if (iButtonNum >= IDM_TOOLBARADD && iButtonNum <= IDM_TOOLBARBOOKMARK)
      {
      // these buttons are push button and will not stay down after
      // each hit
      SendMessage (hWndTB, TB_PRESSBUTTON, iButtonNum, (LONG)bDepress) ;
      }
   else
      {
      // for the four view buttons, have to use CHECKBUTTON so they
      // will stay down after selected.
      SendMessage (hWndTB, TB_CHECKBUTTON, iButtonNum, (LONG)bDepress) ;
      }
}  // ToolbarDepressButton

void OnToolbarHit (WPARAM wParam, LPARAM lParam)
{

   WORD  ToolbarHit ;

   if (HIWORD(wParam) == TBN_ENDDRAG)
      {
      StatusLineReady (hWndStatus) ;
      }
   else if (HIWORD(wParam) == TBN_BEGINDRAG)
      {
      ToolbarHit = LOWORD (lParam) ;

      if (ToolbarHit >= IDM_TOOLBARADD &&
          ToolbarHit <= IDM_TOOLBARDELETE)
         {
         ToolbarHit -= IDM_TOOLBARADD ;

         switch (iPerfmonView)
            {
            case IDM_VIEWALERT:
               ToolbarHit += IDM_EDITADDALERT ;
               break ;

            case IDM_VIEWLOG:
               ToolbarHit += IDM_EDITADDLOG ;
               break ;

            case IDM_VIEWREPORT:
               ToolbarHit += IDM_EDITADDREPORT ;
               break ;

            case IDM_VIEWCHART:
            default:
               ToolbarHit += IDM_EDITADDCHART ;
               break ;
            }
         }
      else if (ToolbarHit == IDM_TOOLBARBOOKMARK)
         {
         ToolbarHit = IDM_OPTIONSBOOKMARK ;
         }
      else if (ToolbarHit == IDM_TOOLBARREFRESH)
         {
         switch (iPerfmonView)
            {
            case IDM_VIEWALERT:
               ToolbarHit = IDM_OPTIONSREFRESHNOWALERT ;
               break ;

            case IDM_VIEWLOG:
               ToolbarHit = IDM_OPTIONSREFRESHNOWLOG ;
               break ;

            case IDM_VIEWREPORT:
               ToolbarHit = IDM_OPTIONSREFRESHNOWREPORT ;
               break ;

            case IDM_VIEWCHART:
            default:
               ToolbarHit = IDM_OPTIONSREFRESHNOWCHART ;
               break ;
            }
         }
      else if (ToolbarHit == IDM_TOOLBAROPTIONS)
         {
         switch (iPerfmonView)
            {
            case IDM_VIEWALERT:
               ToolbarHit = IDM_OPTIONSALERT ;
               break ;

            case IDM_VIEWLOG:
               ToolbarHit = IDM_OPTIONSLOG ;
               break ;

            case IDM_VIEWREPORT:
               ToolbarHit = IDM_OPTIONSREPORT ;
               break ;

            case IDM_VIEWCHART:
            default:
               ToolbarHit = IDM_OPTIONSCHART ;
               break ;
            }
         }

      StatusLine (hWndStatus, ToolbarHit) ;
      }
}  // OnToolBarHit




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\typedefs.h ===
//======================================//
// Options Data Type                    //
//======================================//


typedef struct OPTIONSSTRUCT
   {  
   BOOL           bMenubar ;
   BOOL           bToolbar ;
   BOOL           bStatusbar ;
   BOOL           bAlwaysOnTop ;
   } OPTIONS ;


//======================================//
// Basic "Derived" Types                //
//======================================//


typedef HANDLE HLIBRARY ;
typedef HANDLE HMEMORY ;
typedef HWND HDLG ;
typedef HWND HCONTROL ;
typedef VOID *LPMEMORY ;


//======================================//
// Perfmon-Specific Types               //
//======================================//


typedef PERF_DATA_BLOCK UNALIGNED *PPERFDATA ;
typedef PERF_OBJECT_TYPE UNALIGNED *PPERFOBJECT ;
typedef PERF_COUNTER_DEFINITION UNALIGNED *PPERFCOUNTERDEF ;
typedef PERF_INSTANCE_DEFINITION UNALIGNED *PPERFINSTANCEDEF ;





    // This structure links together the Performance data for multiple
    // systems, each of which has some counter instance which the user
    // is interested in.

typedef struct _COUNTERTEXT {
    struct  _COUNTERTEXT  *pNextTable;
    DWORD   dwLangId;
    DWORD   dwLastId;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    LPWSTR  *TextString;
    LPWSTR  HelpTextString;
} COUNTERTEXT;

typedef COUNTERTEXT *PCOUNTERTEXT;

// System states used mainly by Alert view to report system up/down
#define  SYSTEM_OK               0
#define  SYSTEM_DOWN             1
#define  SYSTEM_DOWN_RPT         2
#define  SYSTEM_RECONNECT        3
#define  SYSTEM_RECONNECT_RPT    4

typedef struct PERFSYSTEMSTRUCT
   {
   struct  PERFSYSTEMSTRUCT *pSystemNext;
   TCHAR   sysName[MAX_SYSTEM_NAME_LENGTH+1];
   HKEY    sysDataKey;
   COUNTERTEXT CounterInfo;
   DWORD   FailureTime;
   LPTSTR  lpszValue;
   BOOL    bSystemNoLongerNeeded;
   BOOL    bSystemCounterNameSaved;

   // the following used by perf data thread
   DWORD           dwThreadID ;
   HANDLE          hThread ;
   DWORD           StateData ;
   HANDLE          hStateDataMutex ;
   HANDLE          hPerfDataEvent ;
   PPERFDATA       pSystemPerfData ;

   // mainly used by Alert to report system up/down   
   DWORD           dwSystemState ;

   // system version
   DWORD           SysVersion ;

   } PERFSYSTEM, *PPERFSYSTEM, **PPPERFSYSTEM ;


typedef struct _graph_options {
    BOOL    bLegendChecked ;
    BOOL    bMenuChecked ;
    BOOL    bLabelsChecked;
    BOOL    bVertGridChecked ;
    BOOL    bHorzGridChecked ;
    BOOL    bStatusBarChecked ;
    INT     iVertMax ;
    FLOAT   eTimeInterval ;
    INT     iGraphOrHistogram ;
    INT     GraphVGrid,
            GraphHGrid,
            HistVGrid,
            HistHGrid ;

} GRAPH_OPTIONS ;



//======================================//
// Line Data Type                       //
//======================================//


#define LineTypeChart            1
#define LineTypeAlert            2
#define LineTypeReport           3



typedef struct LINEVISUALSTRUCT
   {
   COLORREF       crColor ;
   int            iColorIndex ;    
   
   int            iStyle ;
   int            iStyleIndex ;

   int            iWidth ;
   int            iWidthIndex ;
   } LINEVISUAL ;

typedef LINEVISUAL *PLINEVISUAL ;


typedef struct _LINESTRUCT
   {
   struct  _LINESTRUCT             *pLineNext;
   int                             bFirstTime;
   int                             iLineType ;
   LPTSTR                          lnSystemName;

   struct _PERF_OBJECT_TYPE        lnObject;
   LPTSTR                          lnObjectName;

   struct _PERF_COUNTER_DEFINITION lnCounterDef;
   LPTSTR                          lnCounterName;

   struct _PERF_INSTANCE_DEFINITION lnInstanceDef;
   LPTSTR                          lnInstanceName;
   DWORD                           dwInstanceIndex;

   LPTSTR                          lnPINName;
   LPTSTR                          lnParentObjName;
   DWORD                           lnUniqueID;     // Of instance, if any

   LARGE_INTEGER                   lnNewTime;
   LARGE_INTEGER                   lnOldTime;

   LARGE_INTEGER                   lnOldTime100Ns ;
   LARGE_INTEGER                   lnNewTime100Ns ;

   LARGE_INTEGER                   lnaCounterValue[2];
   LARGE_INTEGER                   lnaOldCounterValue[2];

   DWORD                           lnCounterType;
   DWORD                           lnCounterLength;
   LARGE_INTEGER                   lnPerfFreq ;

   LINEVISUAL                      Visual ;


   //=============================//
   // Chart-related fields        //
   //=============================//

   HPEN                            hPen ;
   int                             iScaleIndex ; 
   FLOAT	                          eScale;
   FLOAT                           FAR *lnValues;
   int                             *aiLogIndexes ;
   FLOAT                           lnMaxValue ;
   FLOAT                           lnMinValue ;
   FLOAT                           lnAveValue ;
   INT                             lnValidValues;

   //=============================//
   // Alert-related fields        //
   //=============================//

   HBRUSH                  hBrush ;
   BOOL                    bAlertOver ;         // over or under?
   FLOAT                   eAlertValue ;        // value to compare
   LPTSTR                  lpszAlertProgram ;   // program to run
   BOOL                    bEveryTime ;         // run every time or once?
   BOOL                    bAlerted ;           // alert happened on line?


   //=============================//
   // Report-related fields       //
   //=============================//
   int                     iReportColumn ;
   struct  _LINESTRUCT    *pLineCounterNext;
   int                     xReportPos ;
   int                     yReportPos ;
   }LINESTRUCT ;


typedef LINESTRUCT *PLINESTRUCT ;
typedef PLINESTRUCT PLINE ;
typedef PLINE *PPLINE ;


//======================================//
// DISKLINE data type                   //
//======================================//

#define dwLineSignature    (MAKELONG ('L', 'i'))

typedef struct DISKSTRINGSTRUCT
   {  
   DWORD          dwLength ;
   DWORD          dwOffset ;
   } DISKSTRING ;
typedef DISKSTRING *PDISKSTRING ;


typedef struct DISKLINESTRUCT
   {
   int            iLineType ;
   DISKSTRING     dsSystemName ;
   DISKSTRING     dsObjectName ;
   DISKSTRING     dsCounterName ;
   DISKSTRING     dsInstanceName ;
   DISKSTRING     dsPINName ;
   DISKSTRING     dsParentObjName ;
   DWORD          dwUniqueID ;
   LINEVISUAL     Visual ;
   int            iScaleIndex ;
   FLOAT          eScale ;
   BOOL           bAlertOver ;
   FLOAT          eAlertValue ;
   DISKSTRING     dsAlertProgram ;
   BOOL           bEveryTime ;
   } DISKLINE ;

typedef DISKLINE *PDISKLINE ;



typedef FLOAT DFN (PLINESTRUCT);
typedef DFN   *PDFN;

typedef struct _TIMELINESTRUCT
{
    INT ppd ;                           // Pixels Per DataPoint
    INT rppd ;                          // Remaining Pixels Per DataPoint
    INT xLastTime ;                     // X coordinate of last time line.
    INT iValidValues ;                  // High water mark for valid data.
}TIMELINESTRUCT;




//======================================//
// Graph Data Type                      //
//======================================//


#define iGraphMaxTics   26



// This structure describes the characteristics of one visual
// graph. It is linked for the day when multiple graphs are
// displayed within one instance of the application.

typedef struct _GRAPHSTRUCT
   {
   BOOL           bManualRefresh ;
   HWND           hWnd ;
   BOOL           bModified ;

   PPERFSYSTEM       pSystemFirst;
   PLINESTRUCT    pLineFirst;

   int            xNumTics ;
   int            yNumTics ;
   int            axTics [iGraphMaxTics] ;
   int            ayTics [iGraphMaxTics] ;

   RECT           rectHorzScale ;
   RECT           rectVertScale ;
   RECT           rectData ;
   HRGN           hGraphRgn ;

   INT            gMaxValues;
   INT            gKnownValue;

   LINEVISUAL     Visual ;

   DWORD          gInterval;
   GRAPH_OPTIONS  gOptions;
   TIMELINESTRUCT gTimeLine;

   PPOINT         pptDataPoints ;
   SYSTEMTIME     *pDataTime ;

   HPEN           hGridPen ;
   HANDLE         hbRed ;
   BOOL           HighLightOnOff ;
   } GRAPHSTRUCT ;
typedef GRAPHSTRUCT *PGRAPHSTRUCT;
// minor version 3 to support alert, report, log intervals in msec
#define ChartMajorVersion    1
#define ChartMinorVersion    3


typedef struct DISKCHARTSTRUCT
   {
   DWORD          dwNumLines ;
   INT            gMaxValues;
   LINEVISUAL     Visual ;
   GRAPH_OPTIONS  gOptions ;
   BOOL           bManualRefresh ;
   OPTIONS        perfmonOptions ;
   } DISKCHART ;


typedef struct _SAVESTRUCT
{
    INT version;
    INT type;
    INT iPerfmonView ;
    INT graph_offset;
    INT alert_offset;
    INT log_offset;
}SAVESTRUCT;
typedef SAVESTRUCT *PSAVESTRUCT;

typedef struct _GRAPH_COUNTERS
{
    INT sys_name_len;
    INT sys_name_offset;
    INT obj_name_len;
    INT obj_name_offset;
    INT cnt_name_len;
    INT cnt_name_offset;
    INT inst_name_len;
    INT inst_name_offset;
    INT PIN_name_len;
    INT PIN_name_offset;
    INT POB_name_len;
    INT POB_name_offset;
    DWORD inst_unique_id;
    DWORD counter_type;
    DWORD counter_length;
    int   iScaleIndex ;
    FLOAT eScale;
    LINEVISUAL    Visual ;
    INT updated;
}GRAPH_COUNTERS;

typedef struct _SAVGRAFSTRUCT
{
    INT preference;
    INT MaxValues;
    RECT GraphArea;
    GRAPH_OPTIONS options;
    INT num_counters;
    GRAPH_COUNTERS counters[1];
}SAVGRAFSTRUCT;
typedef SAVGRAFSTRUCT *PSAVGRAFSTRUCT;


typedef struct _SAVLOGSTRUCT
{
    DWORD	logInterval;
    BOOL    logActive;
    LPTSTR	logFileName;
    DWORD	logFileSize;
}SAVLOGSTRUCT;
typedef SAVLOGSTRUCT *PSAVLOGSTRUCT;


#define DEF_GRAPH_INTERVAL  1000        // milliseconds
#define LINE_GRAPH          1
#define BAR_GRAPH           2
#define DEF_GRAPH_VMAX      100
#define SUCCESS             0
#define MIN_TIMER_INTERVAL 50
#define GRAPH_TIMER_ID      1


#define NO_VALUES_YET            -1
        // initial value for index to known and drawn values
#define MIN_NMAXVALUES           10
        // minimum number of values that a graph needs to be displayed ( >1 )
#define DX_CALIBRATION_LEFT      1
        // space between calibration value and left window edge
#define DX_LEGEND_RIGHT          1
        // space between right window edge and legend
#define DY_AXIS_TOP              0
        // space to allow at top of graph
#define DY_AXIS_BOTTOM           0
        // space to allow at bottom of graph
#define LG_TO_CALIBRATION_RATIO  5
        // width of calibration values * this number can't exceed screen width
#define LG_TO_LEGEND_RATIO       2
        // width of legend * this number can't exceed screen width


// LINEGRAPH
#define DEFAULT_VAL_BOTTOM        0
#define DEFAULT_DVAL_AXISHEIGHT   100
#define DEFAULT_MAX_VALUES        100
#define GRAPH_INWARD_EDGE           5
#define GRAPH_LEFT_PAD              5
#define GRAPH_DOWNWARD_EDGE         5
#define ROOM_FOR_LEGEND            40

// LINEGRAPH DISP
#define DEFAULT_F_DISPLAY_LEGEND  TRUE
#define DEFAULT_F_DISPLAY_CALIBRATION TRUE

#define NONE_LEN            MAX_SYSTEM_NAME_LENGTH + 1



//======================================//
// Log/Playback/Alert Status IDs        //
//======================================//


#define iPMStatusClosed      100
#define iPMStatusPaused      200
#define iPMStatusCollecting  300
#define iPMStatusPlaying     400


//======================================//
// Log Data Type                        //
//======================================//


typedef struct _LOGENTRYSTRUCT
   {
   DWORD          ObjectTitleIndex ;
   TCHAR          szComputer [MAX_SYSTEM_NAME_LENGTH + 1] ;
   TCHAR          szObject [PerfObjectLen + 1] ;
   BOOL           bSaveCurrentName ;
   struct  _LOGENTRYSTRUCT *pNextLogEntry ;
   } LOGENTRY ;

typedef LOGENTRY *PLOGENTRY ;


typedef struct LOGSTRUCT
   {
   int            iStatus ;
   BOOL           bManualRefresh ;
   BOOL           bModified ;

   PPERFSYSTEM    pSystemFirst;
   TCHAR          szFilePath [FilePathLen + 1] ;
   HANDLE         hFile ;
   long           lIndexBlockOffset ;
   int            iIndex ;
   PPERFDATA      pLogData ;
   DWORD          dwDetailLevel ;
   long           lFileSize ;
   DWORD          iIntervalMSecs ;
   int            xCol1Width ;
   PLOGENTRY      pLogEntryFirst ;

   // the following is used for saving system counter names into a 
   // log file.  They are reset every the user changes log files.
   BOOL           bSaveCounterName ;
   LPTSTR         pBaseCounterName ;
   long           lBaseCounterNameSize ;
   long           lBaseCounterNameOffset ;

   // this is used for checking system time when re-logging.
   // this is to avoid log data not in chronological order.
   SYSTEMTIME     LastLogTime ;

   // the following is used for wait for data event handles
   HANDLE            *lpHandles ;
   int               NumberOfHandles ;

//==========================================================================//
//                                   Macros                                 //
//==========================================================================//



   } LOG ;

typedef LOG *PLOG ;


//======================================//
// Log File Data Types                  //
//======================================//


#define LogFileSignatureLen      6
#define LogFileBlockMaxIndexes   100


#define LogFileSignature         TEXT("Loges")
#define LogFileVersion           2
#define LogFileRevision          0


#define LogFileIndexData         0x01
#define LogFileIndexBookmark     0x02
#define LogFileIndexNextBlock    0x04
#define LogFileIndexEOF          0x08
#define LogFileIndexCounterName  0x010


typedef struct LOGHEADERSTRUCT
   {  // LOGHEADER
   TCHAR          szSignature [LogFileSignatureLen] ;
   int            iLength ;
   WORD           wVersion ;
   WORD           wRevision ;
   long           lBaseCounterNameOffset ;
   }  LOGHEADER ;

typedef LOGHEADER *PLOGHEADER ;


typedef struct LOGINDEXSTRUCT
   {  // LOGINDEX
   UINT           uFlags ;
   SYSTEMTIME     SystemTime ;
   long           lDataOffset ;
   int            iSystemsLogged ;
   } LOGINDEX ;

typedef LOGINDEX *PLOGINDEX ;


#define LogIndexSignatureLen  7
#define LogIndexSignature     TEXT("Index ")
#define LogIndexSignature1    "Perfmon Index"

typedef struct LOGFILEINDEXBLOCKSTRUCT
   {
   TCHAR          szSignature [LogIndexSignatureLen] ;
   int            iNumIndexes ;
   LOGINDEX       aIndexes [LogFileBlockMaxIndexes] ;
   DWORD          lNextBlockOffset ;
   } LOGINDEXBLOCK ;

typedef LOGINDEXBLOCK *PLOGINDEXBLOCK ;


typedef struct LOGPOSITIONSTRUCT
   {
   PLOGINDEXBLOCK pIndexBlock ;
   int            iIndex ;
   int            iPosition ;
   } LOGPOSITION ;

typedef LOGPOSITION *PLOGPOSITION ;


//======================================//
// Bookmark Data Type                   //
//======================================//


#define BookmarkCommentLen    256

typedef struct BOOKMARKSTRUCT
   {
   struct BOOKMARKSTRUCT *pBookmarkNext;
   SYSTEMTIME     SystemTime ;
   TCHAR          szComment [BookmarkCommentLen] ;
   int            iTic ;
   } BOOKMARK, *PBOOKMARK, **PPBOOKMARK ;

typedef struct _LOGFILECOUNTERNAME
   {
   TCHAR          szComputer [MAX_SYSTEM_NAME_LENGTH] ;
   DWORD          dwLastCounterId ;
   DWORD          dwLangId;
   long           lBaseCounterNameOffset ;
   long           lCurrentCounterNameOffset ;
   long           lMatchLength ;
   long           lUnmatchCounterNames ;
   } LOGFILECOUNTERNAME, *PLOGFILECOUNTERNAME, **PPLOGFILECOUNTERNAME ;

typedef struct COUNTERNAMESTRUCT
   {
   struct COUNTERNAMESTRUCT *pCounterNameNext ;
   LOGFILECOUNTERNAME       CounterName ;
   LPTSTR                   pRemainNames ;
   } LOGCOUNTERNAME, *PLOGCOUNTERNAME ;

typedef struct PLAYBACKLOGSTRUCT
   {
   LPTSTR         szFilePath ;
   LPTSTR         szFileTitle ;
//   TCHAR          szFilePath [FilePathLen + 1] ;
//   TCHAR          szFileTitle [FilePathLen + 1] ;
   int            iStatus ;
   HANDLE         hFile ;
   PLOGHEADER     pHeader ;
   HANDLE         hMapHandle ;
   int            iTotalTics ;
   int            iSelectedTics ;
   LOGPOSITION    BeginIndexPos ;
   LOGPOSITION    EndIndexPos ;
   LOGPOSITION    StartIndexPos ;
   LOGPOSITION    StopIndexPos ;
   PBOOKMARK      pBookmarkFirst ;
   LPTSTR         pBaseCounterNames ;
   long           lBaseCounterNameSize ;
   long           lBaseCounterNameOffset ;
   PLOGCOUNTERNAME   pLogCounterNameFirst ;
   } PLAYBACKLOG ;

//=====================================//
// Log File Counter Name data type     //
//=====================================//


// minor version 3 to support alert, report, log intervals in msec
// minor version 5 to support storing Log file name in setting
//  and start logging after reading the file.
#define LogMajorVersion    1
#define LogMinorVersion    5


typedef struct DISKLOGSTRUCT
   {
   DWORD          dwNumLines ;
   DWORD          dwIntervalSecs ;
   BOOL           bManualRefresh ;
   OPTIONS        perfmonOptions ;
   TCHAR          LogFileName[260] ;
   } DISKLOG ;




//======================================//
// Alert Data Type                      //
//======================================//


typedef struct ALERTSTRUCT
   {
   HWND           hWnd ;
   HWND           hAlertListBox ;
   int            iStatus ;
   BOOL           bManualRefresh ;
   BOOL           bModified ;


   PPERFSYSTEM    pSystemFirst ;
   PLINESTRUCT    pLineFirst ;

   DWORD          iIntervalMSecs ;

   LINEVISUAL     Visual ;

   HFONT          hFontItems ;
   int            yItemHeight ;

   int            xColorWidth ;
   int            xDateWidth ;
   int            xTimeWidth ;
   int            xNumberWidth ;
   int            xConditionWidth ;

   // used in controlling the horz scrollbar
   int            xTextExtent ;     
   
   BOOL           bSwitchToAlert ;
   BOOL           bNetworkAlert ;
   BOOL           bEventLog ;
   TCHAR          MessageName [16] ;

   // used for the network alert thread
   HANDLE         hNetAlertThread ;
   DWORD          dwNetAlertThreadID ;

   // option to turn alert legend on/off
   BOOL           bLegendOn ;
   } ALERT ;

typedef ALERT *PALERT ;



#define AlertMajorVersion    1

// minor version 2 to support Alert msg name
// minor version 3 to support alert, report, log intervals in msec
// minor version 4 to support alert event logging
// minor version 6 to support alert misc options
#define AlertMinorVersion    6


typedef struct DISKALERTSTRUCT
   {
   LINEVISUAL     Visual ;
   DWORD          dwNumLines ;
   DWORD          dwIntervalSecs ;
   BOOL           bManualRefresh ;
   BOOL           bSwitchToAlert ;
   BOOL           bNetworkAlert ;
   TCHAR          MessageName [16] ;
   OPTIONS        perfmonOptions ;
   DWORD          MiscOptions ;
   } DISKALERT ;


//======================================//
// Report Data Type                     //
//======================================//


typedef struct COLUMNGROUPSTRUCT
   {
   struct COLUMNGROUPSTRUCT  *pColumnGroupNext ;
   struct COLUMNGROUPSTRUCT  *pColumnGroupPrevious ;
   struct OBJECTGROUPSTRUCT  *pParentObject ;
   LPTSTR         lpszParentName ;
   LPTSTR         lpszInstanceName ;
   int            ParentNameTextWidth ;
   int            InstanceNameTextWidth ;
   int            xPos ;
   int            xWidth ;
   int            yFirstLine ;
   int            ColumnNumber ;  // start from 0
   DWORD          dwInstanceIndex;
   } COLUMNGROUP ;


typedef COLUMNGROUP *PCOLUMNGROUP ;


typedef struct COUNTERGROUPSTRUCT
   {
   struct COUNTERGROUPSTRUCT *pCounterGroupNext ;
   struct COUNTERGROUPSTRUCT *pCounterGroupPrevious ;
   struct OBJECTGROUPSTRUCT  *pParentObject ;
   DWORD          dwCounterIndex ;
   PLINE          pLineFirst ;
   PLINE          pLineLast;
   int            yLine ;
   int            xWidth ;
   } COUNTERGROUP ;

typedef COUNTERGROUP *PCOUNTERGROUP ;


typedef struct OBJECTGROUPSTRUCT
   {
   struct OBJECTGROUPSTRUCT  *pObjectGroupNext ;
   struct OBJECTGROUPSTRUCT  *pObjectGroupPrevious ;
   struct SYSTEMGROUPSTRUCT  *pParentSystem ;
   LPTSTR         lpszObjectName ;
   PCOUNTERGROUP  pCounterGroupFirst ;
   PCOLUMNGROUP   pColumnGroupFirst ;
   int            yFirstLine ;
   int            yLastLine ;
   int            xWidth ;
   } OBJECTGROUP ;

typedef OBJECTGROUP *POBJECTGROUP ;


typedef struct SYSTEMGROUPSTRUCT
   {  // SystemGroup
   struct SYSTEMGROUPSTRUCT *pSystemGroupNext ;
   struct SYSTEMGROUPSTRUCT *pSystemGroupPrevious ;
   LPTSTR         lpszSystemName ;
   POBJECTGROUP   pObjectGroupFirst ;
   int            yFirstLine ;
   int            yLastLine ;
   int            xWidth ;
   } SYSTEMGROUP ;

typedef  SYSTEMGROUP   *PSYSTEMGROUP ;

enum REPORT_ITEM_TYPE
   { 
   REPORT_TYPE_NOTHING, 
   REPORT_TYPE_SYSTEM,
   REPORT_TYPE_OBJECT,
   REPORT_TYPE_COLUMN,
   REPORT_TYPE_COUNTER,
   REPORT_TYPE_LINE
   } ;

typedef union REPORT_ITEM_TAG
   {
   PSYSTEMGROUP   pSystem ;
   POBJECTGROUP   pObject ;
   PCOLUMNGROUP   pColumn ;
   PCOUNTERGROUP  pCounter ;
   PLINE          pLine ;
   } REPORT_ITEM ;


typedef struct REPORTSTRUCT
   {  // REPORT
   HWND           hWnd ;
   int            iStatus ;
   BOOL           bManualRefresh ;
   BOOL           bModified ;

   TCHAR          szTitle [120] ;
   SYSTEMTIME     SystemTime ;

   PPERFSYSTEM    pSystemFirst ;
   PLINE          pLineFirst ;
   PLINE          pLineLast;

   PSYSTEMGROUP   pSystemGroupFirst ;

   REPORT_ITEM       CurrentItem ;
   enum  REPORT_ITEM_TYPE  CurrentItemType ;

   LINEVISUAL     Visual ;


   DWORD          iIntervalMSecs ;
   FLOAT          eTimeInterval ;
   HFONT          hFont ;
   HFONT          hFontHeaders ;
   int            yLineHeight ;

   int            xMaxCounterWidth ;
   int            xValueWidth ;

   int            xWidth ;
   int            yHeight ;
   } REPORT ;

typedef REPORT *PREPORT ; 

// minor version 3 to support alert, report, log intervals in msec
#define ReportMajorVersion    1
#define ReportMinorVersion    3


typedef struct DISKREPORTSTRUCT
   {
   LINEVISUAL     Visual ;
   DWORD          dwNumLines ;
   DWORD          dwIntervalSecs ;
   BOOL           bManualRefresh ;
   OPTIONS        perfmonOptions ;
   } DISKREPORT ;


//======================================//
// File Header Type                     //
//======================================//


#define PerfSignatureLen  20

#define szPerfChartSignature     TEXT("PERF CHART")
#define szPerfAlertSignature     TEXT("PERF ALERT")
#define szPerfLogSignature       TEXT("PERF LOG")
#define szPerfReportSignature    TEXT("PERF REPORT")
#define szPerfWorkspaceSignature TEXT("PERF WORKSPACE")


typedef struct PERFFILEHEADERSTRUCT
   {  // PERFFILEHEADER
   TCHAR          szSignature [PerfSignatureLen] ;
   DWORD          dwMajorVersion ;
   DWORD          dwMinorVersion ;
   BYTE           abyUnused [100] ;
   } PERFFILEHEADER ;

#define WorkspaceMajorVersion    1

// minor version 1 to support window placement data
// minor version 2 to support alert msg name
// minor version 3 to support alert, report, log intervals in msec
// minor version 4 to support alert eventlog
// minor version 5 to support log file name in log setting
// minor version 6 to support alert misc options
#define WorkspaceMinorVersion    6

typedef struct DISKWORKSPACESTRUCT
   {
   INT               iPerfmonView ;
   DWORD             ChartOffset ;
   DWORD             AlertOffset ;
   DWORD             LogOffset ;
   DWORD             ReportOffset ;
   WINDOWPLACEMENT   WindowPlacement ;   
   } DISKWORKSPACE ;




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\utils.c ===
/*
==============================================================================

  Application:

            Microsoft Windows NT (TM) Performance Monitor

  File:
            utils.c -- miscellaneous utility routines.

            This file contains miscellaneous utiltity routines, mostly
            low-level windows helpers. These routines are not specific
            to the perfmon utillity.

  Copyright 1992, Microsoft Corporation. All Rights Reserved.
  Microsoft Confidential.
==============================================================================
*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <stdarg.h>  // For ANSI variable args. Dont use UNIX <varargs.h>
#include <stdlib.h>  // For itoa
#include <stdio.h>   // for vsprintf.
#include <string.h>  // for strtok
#include <wchar.h>   // for swscanf

#include "perfmon.h"
#include "pmemory.h"        // for MemoryXXX (mallloc-type) routines
#include "utils.h"
#include "pmhelpid.h"       // IDs for WinHelp
#include "perfmops.h"       // for ConvertDecimalPoint() & ReconvertDecimalPoint()
#include "sizes.h"

//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define DOS_FILES                0x0000   // Ordinary files
#define DOS_READONLY             0x0001   // Read-only files
#define DOS_HIDDEN               0x0002   // Hidden files
#define DOS_SYSTEM               0x0004   // System files
#define DOS_SUBDIRECTORIES       0x0010   // Subdirectories
#define DOS_ARCHIVES             0x0020   // Archives
#define DOS_LIB_DIR              0x2000   // LB_DIR flag
#define DOS_DRIVES               0x4000   // Drives
#define DOS_EXCLUSIVE            0x8000   // Exclusive bit
#define DOS_DRIVES_DIRECTORIES   0xC010   // Find drives and directories only


#define WILD_ONE                 '?'
#define WILD_ANY                 '*'


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//

void
ClientRectToScreen (
                   HWND hWnd,
                   LPRECT lpRect
                   )
/*
   Effect:        Remaps lpRect from client coordinates to screen
                  coordinates. Analogous to ClientToScreen for rectangles.

   Note:          To convert a rectangle from the client coordinates of
                  Wnd1 to the client coordinates of Wnd2, call:

                        ClientRectToScreen (hWnd1, &rect) ;
                        ScreenRectToClient (hWnd2, &rect) ;

   See Also:      ClientToScreen (windows), ScreenRectToClient.

   Internals:     Since a rectangle is really only two points, let
                  windows do the work with ClientToScreen.
*/
{
    POINT    pt1, pt2 ;

    pt1.x = lpRect->left ;
    pt1.y = lpRect->top ;

    pt2.x = lpRect->right ;
    pt2.y = lpRect->bottom ;

    ClientToScreen (hWnd, &pt1) ;
    ClientToScreen (hWnd, &pt2) ;

    lpRect->left = pt1.x ;
    lpRect->top = pt1.y ;

    lpRect->right = pt2.x ;
    lpRect->bottom = pt2.y ;
}


void
ScreenRectToClient (
                   HWND hWnd,
                   LPRECT lpRect
                   )
/*
   Effect:        Remaps lpRect from screen coordinates to client
                  coordinates. Analogous to ScreenToClient for rectangles.

   Note:          To convert a rectangle from the client coordinates of
                  Wnd1 to the client coordinates of Wnd2, call:

                        ClientRectToScreen (hWnd1, &rect) ;
                        ScreenRectToClient (hWnd2, &rect) ;

   See Also:      ScreenToClient (windows), ClientRectToScreen.

   Internals:     Since a rectangle is really only two points, let
                  windows do the work with ScreenToClient.
*/
{
    POINT    pt1, pt2 ;

    pt1.x = lpRect->left ;
    pt1.y = lpRect->top ;

    pt2.x = lpRect->right ;
    pt2.y = lpRect->bottom ;

    ScreenToClient (hWnd, &pt1) ;
    ScreenToClient (hWnd, &pt2) ;

    lpRect->left = pt1.x ;
    lpRect->top = pt1.y ;

    lpRect->right = pt2.x ;
    lpRect->bottom = pt2.y ;
}  // ScreenRectToClient


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


void
Line (
     HDC hDC,
     HPEN hPen,
     int x1,
     int y1,
     int x2,
     int y2
     )
{
    HPEN           hPenPrevious = NULL;

    if (hPen)
        hPenPrevious = SelectPen (hDC, hPen) ;
    MoveToEx (hDC, x1, y1, NULL) ;
    LineTo (hDC, x2, y2) ;
    if (hPen)
        SelectObject (hDC, hPenPrevious) ;
}

#ifdef  KEEP_UTIL
void
Fill (
     HDC hDC,
     DWORD rgbColor,
     LPRECT lpRect
     )
{
    HBRUSH         hBrush ;

    hBrush = CreateSolidBrush (rgbColor) ;

    FillRect (hDC, lpRect, hBrush) ;

    DeleteBrush (hBrush) ;
}

void
ThreeDConvex (
             HDC hDC,
             int x1,
             int y1,
             int x2,
             int y2
             )
{
    HBRUSH         hBrushPrevious ;
    POINT          aPoints [8] ;
    DWORD          aCounts [2] ;
    HPEN           hPenPrevious ;


    //
    // Draw Face                  
    //

    hBrushPrevious = SelectBrush (hDC, hBrushFace) ;
    PatBlt (hDC,
            x1 + ThreeDPad, y1 + ThreeDPad,
            x2 - x1 - ThreeDPad, y2 - y1 - ThreeDPad,
            PATCOPY) ;
    SelectBrush (hDC, hBrushPrevious) ;

    //
    // Draw Highlight             
    //

    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenHighlight) ;

    aPoints [0].x = x1 ;
    aPoints [0].y = y2 - 1 ;   // this works slightly diff. than Line ??
    aPoints [1].x = x1 ;
    aPoints [1].y = y1 ;
    aPoints [2].x = x2 ;
    aPoints [2].y = y1 ;

    aPoints [3].x = x1 + 1 ;
    aPoints [3].y = y2 - 1 ;
    aPoints [4].x = x1 + 1 ;
    aPoints [4].y = y1 + 1 ;
    aPoints [5].x = x2 - 1 ;
    aPoints [5].y = y1 + 1 ;

    aCounts [0] = 3 ;
    aCounts [1] = 3 ;

    PolyPolyline (hDC, aPoints, aCounts, 2) ;


    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;

    //   HLine (hDC, hPenHighlight, x1, x2, y1) ;              // outside top line
    //   HLine (hDC, hPenHighlight, x1 + 1, x2 - 1, y1 + 1) ;  // inside top line
    //   VLine (hDC, hPenHighlight, x1, y1, y2) ;              // outside left line
    //   VLine (hDC, hPenHighlight, x1 + 1, y1 + 1, y2 - 1) ;  // inside left line

    //
    // Draw Shadow                
    //

    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenShadow) ;

    aPoints [0].x = x1 + 1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x2 ;
    aPoints [1].y = y2 - 1 ;
    aPoints [2].x = x2 ;
    aPoints [2].y = y2 - 2 ;
    aPoints [3].x = x1 + 2 ;
    aPoints [3].y = y2 - 2 ;

    aPoints [4].x = x2 - 1 ;
    aPoints [4].y = y1 ;
    aPoints [5].x = x2 - 1 ;
    aPoints [5].y = y2 - 1;
    aPoints [6].x = x2 - 2 ;
    aPoints [6].y = y2 - 1 ;
    aPoints [7].x = x2 - 2 ;
    aPoints [7].y = y1 ;

    aCounts [0] = 4 ;
    aCounts [1] = 4 ;

    PolyPolyline (hDC, aPoints, aCounts, 2) ;


    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;

    //   HLine (hDC, hPenShadow, x1 + 1, x2, y2 - 1) ;   // outside bottom line
    //   HLine (hDC, hPenShadow, x1 + 2, x2, y2 - 2) ;   // inside bottom line
    //   VLine (hDC, hPenShadow, x2 - 1, y1 + 1, y2) ;   // outside right line
    //   VLine (hDC, hPenShadow, x2 - 2, y1 + 2, y2) ;   // inside right line

}



void
ThreeDConcave (
              HDC hDC,
              int x1,
              int y1,
              int x2,
              int y2,
              BOOL bFace
              )
{
    HBRUSH         hBrushPrevious ;
    POINT          aPoints [6] ;
    DWORD          aCounts [2] ;
    HPEN           hPenPrevious ;


    //
    // Draw Face                  
    //

    if (bFace) {
        hBrushPrevious = SelectBrush (hDC, hBrushFace) ;
        PatBlt (hDC,
                x1 + ThreeDPad, y1 + ThreeDPad,
                x2 - x1 - ThreeDPad, y2 - y1 - ThreeDPad,
                PATCOPY) ;
        SelectBrush (hDC, hBrushPrevious) ;
    }

    //
    // Draw Shadow                
    //

#if 1
    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenShadow) ;

    aPoints [0].x = x1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x1 ;
    aPoints [1].y = y1 ;
    aPoints [2].x = x2 ;
    aPoints [2].y = y1 ;

    aPoints [3].x = x1 + 1 ;
    aPoints [3].y = y2 - 1 ;
    aPoints [4].x = x1 + 1 ;
    aPoints [4].y = y1 + 1 ;
    aPoints [5].x = x2 - 1 ;
    aPoints [5].y = y1 + 1 ;

    aCounts [0] = 3 ;
    aCounts [1] = 3 ;

    PolyPolyline (hDC, aPoints, aCounts, 2) ;

    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;

#else
    HLine (hDC, hPenShadow, x1, x2, y1) ;              // outside top line
    HLine (hDC, hPenShadow, x1 + 1, x2 - 1, y1 + 1) ;  // inside top line
    VLine (hDC, hPenShadow, x1, y1, y2) ;              // outside left line
    VLine (hDC, hPenShadow, x1 + 1, y1 + 1, y2 - 1) ;  // inside left line
#endif

    //
    // Draw Highlight             
    //

#if 1
    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenHighlight) ;

    aPoints [0].x = x1 + 1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x2 ;
    aPoints [1].y = y2 - 1 ;

    aPoints [2].x = x2 - 1 ;
    aPoints [2].y = y2 - 1 ;
    aPoints [3].x = x2 - 1 ;
    aPoints [3].y = y1 ;

    aCounts [0] = 2 ;
    aCounts [1] = 2 ;

    PolyPolyline (hDC, aPoints, aCounts, 2) ;

    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;

#else
    HLine (hDC, hPenHighlight, x1 + 1, x2, y2 - 1) ;   // outside bottom line
    VLine (hDC, hPenHighlight, x2 - 1, y1 + 1, y2) ;   // outside right line
#endif
}
#endif // KEEP_UTIL


void
ThreeDConvex1 (
              HDC hDC,
              int x1,
              int y1,
              int x2,
              int y2
              )
{
    HBRUSH         hBrushPrevious ;
    POINT          aPoints [6] ;
    DWORD          aCounts [2] ;
    HPEN           hPenPrevious = NULL;


    //
    // Draw Face                  
    //
#if 1
    hBrushPrevious = SelectBrush (hDC, hBrushFace) ;
    PatBlt (hDC,
            x1 + 1, y1 + 1,
            x2 - x1 - 1, y2 - y1 - 1,
            PATCOPY) ;
    SelectBrush (hDC, hBrushPrevious) ;

    //
    // Draw Highlight             
    //

    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenHighlight) ;

    aPoints [0].x = x1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x1 ;
    aPoints [1].y = y1 ;
    aPoints [2].x = x2 ;
    aPoints [2].y = y1 ;

    Polyline (hDC, aPoints, 3) ;

    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;

#else
    HLine (hDC, hPenHighlight, x1, x2, y1) ;              // outside top line
    VLine (hDC, hPenHighlight, x1, y1, y2) ;              // outside left line
#endif

    //
    // Draw Shadow                
    //

#if 1
    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenShadow) ;

    aPoints [0].x = x1 + 1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x2 ;
    aPoints [1].y = y2 - 1 ;

    aPoints [2].x = x2 - 1 ;
    aPoints [2].y = y2 - 1 ;
    aPoints [3].x = x2 - 1 ;
    aPoints [3].y = y1 ;

    aCounts [0] = 2 ;
    aCounts [1] = 2 ;

    PolyPolyline (hDC, aPoints, aCounts, 2) ;

    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;
#else
    HLine (hDC, hPenShadow, x1 + 1, x2, y2 - 1) ;   // outside bottom line
    VLine (hDC, hPenShadow, x2 - 1, y1 + 1, y2) ;   // outside right line
#endif

}



void
ThreeDConcave1 (
               HDC hDC,
               int x1,
               int y1,
               int x2,
               int y2
               )
{
    HBRUSH         hBrushPrevious ;
    POINT          aPoints [6] ;
    DWORD          aCounts [2] ;
    HPEN           hPenPrevious = NULL;


    //
    // Draw Face                  
    //

    hBrushPrevious = SelectBrush (hDC, hBrushFace) ;
    PatBlt (hDC,
            x1 + 1, y1 + 1,
            x2 - x1 - 1, y2 - y1 - 1,
            PATCOPY) ;
    SelectBrush (hDC, hBrushPrevious) ;

    //
    // Draw Shadow                
    //

#if 1
    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenShadow) ;

    aPoints [0].x = x1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x1 ;
    aPoints [1].y = y1 ;
    aPoints [2].x = x2 ;
    aPoints [2].y = y1 ;

    Polyline (hDC, aPoints, 3) ;

    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;
#else
    HLine (hDC, hPenShadow, x1, x2, y1) ;              // outside top line
    VLine (hDC, hPenShadow, x1, y1, y2) ;              // outside left line
#endif

    //
    // Draw Highlight             
    //
#if 1
    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenHighlight) ;

    aPoints [0].x = x1 + 1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x2 ;
    aPoints [1].y = y2 - 1 ;

    aPoints [2].x = x2 - 1 ;
    aPoints [2].y = y2 - 2 ;
    aPoints [3].x = x2 - 1 ;
    aPoints [3].y = y1 ;

    aCounts [0] = 2 ;
    aCounts [1] = 2 ;

    PolyPolyline (hDC, aPoints, aCounts, 2) ;

    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;
#else
    HLine (hDC, hPenHighlight, x1 + 1, x2, y2 - 1) ;   // outside bottom line
    VLine (hDC, hPenHighlight, x2 - 1, y1 + 1, y2) ;   // outside right line
#endif

}


int
TextWidth (
          HDC hDC,
          LPTSTR lpszText
          )
{
    SIZE           size ;

    if (!lpszText)
        return (0) ;

    GetTextExtentPoint (hDC, lpszText, lstrlen (lpszText), &size) ;
    return  (size.cx) ;
}


int
_cdecl
DlgErrorBox (
            HWND hDlg,
            UINT id,
            ...
            )
{
    TCHAR          szMessageFmt [FilePathLen + 1] ;
    TCHAR          szBuffer [FilePathLen * 2] ;
    va_list        vaList ;
    int            NumOfChar ;
    TCHAR          szApplication [WindowCaptionLen] ;

    NumOfChar = StringLoad (id, szMessageFmt) ;

    if (NumOfChar) {
        va_start (vaList, id) ;
        TSPRINTF (szBuffer, szMessageFmt, va_arg(vaList, LPTSTR)) ;
        va_end (vaList) ;

        StringLoad (IDS_APPNAME, szApplication) ;

        MessageBox (hDlg, szBuffer, szApplication,
                    MB_OK | MB_ICONSTOP | MB_TASKMODAL) ;
    }

    return (0) ;
}


int
FontHeight (
           HDC hDC,
           BOOL bIncludeLeading
           )
{
    TEXTMETRIC     tm ;

    GetTextMetrics (hDC, &tm) ;
    if (bIncludeLeading)
        return (tm.tmHeight + tm.tmExternalLeading) ;
    else
        return (tm.tmHeight) ;
}


int
TextAvgWidth (
             HDC hDC,
             int iNumChars
             )
{
    TEXTMETRIC     tm ;
    int            xAvgWidth ;

    GetTextMetrics (hDC, &tm) ;

    xAvgWidth = iNumChars * tm.tmAveCharWidth ;

    // add 10% slop
    return (MulDiv (xAvgWidth, 11, 10)) ;
}


void
WindowCenter (
             HWND hWnd
             )
/*
   Effect:        Center the window hWnd in the center of the screen.
                  Physically update the windows appearance as well.

   Globals:       xScreenWidth, yScreenHeight.
*/
{
    RECT           rectWindow ;
    int            xWindowWidth, yWindowHeight ;

    GetWindowRect (hWnd, &rectWindow) ;
    xWindowWidth = rectWindow.right - rectWindow.left ;
    yWindowHeight = rectWindow.bottom - rectWindow.top ;

    MoveWindow (hWnd,
                (xScreenWidth - xWindowWidth) / 2,
                (yScreenHeight - yWindowHeight) / 2,
                xWindowWidth,
                yWindowHeight,
                TRUE) ;
}

BOOL
DialogMove (
           HDLG hDlg,
           WORD wControlID,
           int xPos,
           int yPos,
           int xWidth,
           int yHeight
           )
/*
   Effect:        Move the control identified by wControlID in the dialog
                  hDlg to the new position (xPos, yPos), and resize to
                  (xWidth, yHeight). If any of these values are NOCHANGE, retain
                  the current value.

   Examples:      DialogMove (hDlg, IDD_FOO, 10, 20, NOCHANGE, NOCHANGE)
                     moves control but does not resize it

                  DialogMove (hDlg, IDD_FOO, NOCHANGE, NOCHANGE, 100, NOCHANGE)
                     sets width of control to 100
*/
{
    HWND        hWndControl ;
    RECT        rectControl ;

    hWndControl = DialogControl (hDlg, wControlID) ;
    if (!hWndControl)
        return (FALSE) ;
    GetWindowRect (hWndControl, &rectControl) ;
    ScreenRectToClient (hDlg, &rectControl) ;

    MoveWindow (hWndControl,
                (xPos == NOCHANGE) ? rectControl.left : xPos,
                (yPos == NOCHANGE) ? rectControl.top : yPos,
                (xWidth == NOCHANGE) ? rectControl.right - rectControl.left : xWidth,
                (yHeight == NOCHANGE) ? rectControl.bottom - rectControl.top : yHeight,
                TRUE) ;

    return (TRUE) ;
}


int
DialogWidth (
            HDLG hDlg,
            WORD wControlID
            )
{
    HWND           hWndControl ;
    RECT           rectControl ;

    hWndControl = DialogControl (hDlg, wControlID) ;
    if (!hWndControl)
        return (0) ;

    GetWindowRect (hWndControl, &rectControl) ;
    return (rectControl.right - rectControl.left) ;
}


int
DialogHeight (
             HDLG hDlg,
             WORD wControlID
             )
{
    HWND           hWndControl ;
    RECT           rectControl ;

    hWndControl = DialogControl (hDlg, wControlID) ;
    if (!hWndControl)
        return (0) ;

    GetWindowRect (hWndControl, &rectControl) ;
    return (rectControl.bottom - rectControl.top) ;
}


int
DialogXPos (
           HDLG hDlg,
           WORD wControlID
           )
{
    HWND           hWndControl ;
    RECT           rectControl ;

    hWndControl = DialogControl (hDlg, wControlID) ;
    if (!hWndControl)
        return (0) ;

    GetWindowRect (hWndControl, &rectControl) ;
    ScreenRectToClient (hDlg, &rectControl) ;

    return  (rectControl.left) ;
}


int
DialogYPos (
           HDLG hDlg,
           WORD wControlID
           )
{
    HWND           hWndControl ;
    RECT           rectControl ;

    hWndControl = DialogControl (hDlg, wControlID) ;
    if (!hWndControl)
        return (0) ;

    GetWindowRect (hWndControl, &rectControl) ;
    ScreenRectToClient (hDlg, &rectControl) ;

    return  (rectControl.top) ;
}


void
DialogEnable (
             HDLG hDlg,
             WORD wID,
             BOOL bEnable
             )
/*
   Effect:        Enable or disable (based on bEnable) the control
                  identified by wID in dialog hDlg.

   See Also:      DialogShow.
*/
{
    HCONTROL       hControl ;

    hControl = GetDlgItem (hDlg, wID) ;
    if (hControl)
        EnableWindow (hControl, bEnable) ;
}


void
DialogShow (
           HDLG hDlg,
           WORD wID,
           BOOL bShow
           )
{
    HCONTROL       hControl ;

    hControl = GetDlgItem (hDlg, wID) ;
    if (hControl)
        ShowWindow (hControl, bShow ? SW_SHOW : SW_HIDE) ;
}


BOOL
_cdecl
DialogSetText (
              HDLG hDlg,
              WORD wControlID,
              WORD wStringID,
              ...
              )
{
    TCHAR           szFormat [ControlStringLen] ;
    TCHAR           szText [ControlStringLen] ;
    va_list         vaList ;

    if (LoadString (hInstance, wStringID,
                    szFormat, ControlStringLen - 1)) {
        va_start (vaList, wStringID) ;
        TSPRINTF (szText, szFormat, va_arg(vaList, LPTSTR)) ;
        va_end (vaList) ;

        SetDlgItemText (hDlg, wControlID, szText) ;
        return (TRUE) ;
    } else {
        return (FALSE) ;
    }
}


// Bug - lpszFormat could contain % in it
#if 0
BOOL
_cdecl
DialogSetString (
                HDLG hDlg,
                WORD wControlID,
                LPTSTR lpszFormat,
                ...
                )
{
    TCHAR          szText [ControlStringLen] ;
    va_list        vaList ;

    va_start (vaList, lpszFormat) ;
    TSPRINTF (szText, lpszFormat, va_arg(vaList, LPTSTR)) ;
    va_end (vaList) ;

    SetDlgItemText (hDlg, wControlID, szText) ;
    return (TRUE) ;
}
#endif


LPTSTR
LongToCommaString (
                  LONG lNumber,
                  LPTSTR lpszText
                  )
{
    BOOL           bNegative ;
    TCHAR          szTemp1 [40] ;
    TCHAR          szTemp2 [40] ;
    LPTSTR         lpsz1 ;
    LPTSTR         lpsz2 ;
    int            i ;
    int            iDigit ;

    // 1. Convert the number to a reversed string.
    lpsz1 = szTemp1 ;
    bNegative = (lNumber < 0) ;
    lNumber = labs (lNumber) ;

    if (lNumber)
        while (lNumber) {
            iDigit = (int) (lNumber % 10L) ;
            lNumber /= 10L ;
            *lpsz1++ = (TCHAR) (TEXT('0') + iDigit) ;
        } else
        *lpsz1++ = TEXT('0') ;
    *lpsz1++ = TEXT('\0') ;


    // 2. reverse the string and add commas
    lpsz1 = szTemp1 + lstrlen (szTemp1) - 1 ;
    lpsz2 = szTemp2 ;

    if (bNegative)
        *lpsz2++ = TEXT('-') ;

    for (i = lstrlen (szTemp1) - 1; i >= 0; i--) {
        *lpsz2++ = *lpsz1-- ;
        if (i && !(i % 3))
            *lpsz2++ = TEXT(',') ;
    }
    *lpsz2++ = TEXT('\0') ;

    return (lstrcpy (lpszText, szTemp2)) ;
}



BOOL
MenuSetPopup (
             HWND hWnd,
             int iPosition,
             WORD  wControlID,
             LPTSTR lpszResourceID
             )
{
    HMENU          hMenuMain ;
    HMENU          hMenuPopup ;
    TCHAR          szTopChoice [MenuStringLen + 1] ;

    hMenuMain = GetMenu (hWnd) ;
    if (!hMenuMain)
        return (FALSE);
    hMenuPopup = LoadMenu (hInstance, lpszResourceID) ;

    if (!hMenuPopup) {
        DestroyMenu(hMenuMain);
        return (FALSE) ;
    }

    StringLoad (wControlID, szTopChoice) ;
    return (ModifyMenu (hMenuMain, iPosition, MF_BYPOSITION | MF_POPUP,
                        (UINT_PTR) hMenuPopup, szTopChoice)) ;
}



LPTSTR
FileCombine (
            LPTSTR lpszFileSpec,
            LPTSTR lpszFileDirectory,
            LPTSTR lpszFileName
            )
{
    int      stringLen ;
    TCHAR    DIRECTORY_DELIMITER[2] ;

    DIRECTORY_DELIMITER[0] = TEXT('\\') ;
    DIRECTORY_DELIMITER[1] = TEXT('\0') ;

    lstrcpy (lpszFileSpec, lpszFileDirectory) ;

    stringLen = lstrlen (lpszFileSpec) ;
    if (stringLen > 0 &&
        lpszFileSpec [stringLen - 1] != DIRECTORY_DELIMITER [0])
        lstrcat (lpszFileSpec, DIRECTORY_DELIMITER) ;

    lstrcat (lpszFileSpec, lpszFileName) ;

    return (lpszFileSpec) ;
}

// This routine extract the filename portion from a given full-path filename
LPTSTR
ExtractFileName (
                LPTSTR pFileSpec
                )
{
    LPTSTR   pFileName = NULL ;
    TCHAR    DIRECTORY_DELIMITER1 = TEXT('\\') ;
    TCHAR    DIRECTORY_DELIMITER2 = TEXT(':') ;

    if (pFileSpec) {
        pFileName = pFileSpec + lstrlen (pFileSpec) ;

        while (*pFileName != DIRECTORY_DELIMITER1 &&
               *pFileName != DIRECTORY_DELIMITER2) {
            if (pFileName == pFileSpec) {
                // done when no directory delimiter is found
                break ;
            }
            pFileName-- ;
        }

        if (*pFileName == DIRECTORY_DELIMITER1 ||
            *pFileName == DIRECTORY_DELIMITER2) {
            // directory delimiter found, point the
            // filename right after it
            pFileName++ ;
        }
    }
    return pFileName ;
}

int
CBAddInt (
         HWND hWndCB,
         int iValue
         )
{
    TCHAR       szValue [ShortTextLen + 1] ;
    CHAR        szCharValue [ShortTextLen + 1] ;

    _itoa (iValue, (LPSTR)szCharValue, 10) ;
#ifdef UNICODE
    mbstowcs (szValue, (LPSTR)szCharValue, strlen((LPSTR)szCharValue)+1) ;
    return (CBAdd (hWndCB, szValue)) ;
#else
    return (CBAdd (hWndCB, szCharValue)) ;
#endif

}

void
DialogSetInterval (
                  HDLG hDlg,
                  WORD wControlID,
                  int  IntervalMSec
                  )
{
    TCHAR          szValue [MiscTextLen] ;

    TSPRINTF (szValue, TEXT("%3.3f"),
              (FLOAT)(IntervalMSec / 1000)) ;
    ConvertDecimalPoint (szValue) ;
    SetDlgItemText (hDlg, wControlID, szValue) ;
}

void
DialogSetFloat (
               HDLG hDlg,
               WORD wControlID,
               FLOAT eValue
               )
{
    TCHAR          szValue [40] ;
    FLOAT          tempValue = eValue ;

    if (tempValue < (FLOAT) 0.0) {
        tempValue = - tempValue ;
    }

    if (tempValue < (FLOAT) 1.0E+8) {
        TSPRINTF (szValue, TEXT("%1.4f"), eValue) ;
    } else {
        TSPRINTF (szValue, TEXT("%14.6e"), eValue) ;
    }
    ConvertDecimalPoint (szValue) ;

    SetDlgItemText (hDlg, wControlID, szValue) ;
}


FLOAT
DialogFloat (
            HDLG hDlg,
            WORD wControlID,
            BOOL *pbOK
            )
/*
   Effect:        Return a floating point representation of the string
                  value found in the control wControlID of hDlg.

   Internals:     We use sscanf instead of atof becuase atof returns a
                  double. This may or may not be the right thing to do.
*/
{
    TCHAR          szValue [ShortTextLen+1] ;
    FLOAT          eValue ;
    int            iNumScanned ;

    DialogText (hDlg, wControlID, szValue) ;
    ReconvertDecimalPoint (szValue) ;
    iNumScanned = swscanf (szValue, TEXT("%e"), &eValue) ;

    if (pbOK)
        *pbOK = (iNumScanned == 1) ;

    return (eValue) ;
}



LPTSTR
StringAllocate (
               LPTSTR lpszText1
               )
{
    LPTSTR         lpszText2 = NULL;
    DWORD          dwStrLen;

    if (lpszText1 != NULL) {
        if (*lpszText1 != 0) {
            dwStrLen = (lstrlen (lpszText1)+1) * sizeof (TCHAR);
            lpszText2 = MemoryAllocate (dwStrLen) ;
            if (lpszText2 != NULL) {
                lstrcpy (lpszText2, lpszText1) ;
            }
        }
    }
    return  (lpszText2) ;
}



int
DivRound (
         int iNumerator,
         int iDenominator
         )
/*
   Effect:        Return the quotient (iNumerator / iDenominator).
                  Round the quotient to the nearest integer.
                  This function is similar to normal integer division (/),
                  but normal division always rounds down.

   Note:          Surely there must already be a runtime version of this,
                  but I couldn't find it.

   Note:          This function originally used the runtime div function
                  instead of (/ and %), but the div runtime function is
                  now broken (build 265).
*/
{
    int            iQuotient ;
    int            iRemainder ;


    iQuotient = iNumerator / iDenominator ;
    iRemainder = iNumerator % iDenominator ;

    if (iRemainder >= (iDenominator / 2))
        iQuotient++ ;

    return (iQuotient) ;
}


BOOL
MenuEnableItem (
               HMENU hMenu,
               WORD wID,
               BOOL bEnable
               )
/*
   Effect:        Enable or disable, depending on bEnable, the menu item
                  associated with id wID in the menu hMenu.

                  Any disabled menu items are displayed grayed out.

   See Also:      EnableMenuItem (windows).
*/
{
    return (EnableMenuItem (hMenu, wID,
                            bEnable ?
                            (MF_ENABLED | MF_BYCOMMAND) :
                            (MF_GRAYED | MF_BYCOMMAND))) ;
}

void
BitmapDimemsion (
                HBITMAP hBitmap,
                int *pHeight,
                int *pWidth
                )
{
    BITMAP  bm ;

    GetObject (hBitmap, sizeof (BITMAP), (LPSTR) &bm) ;
    if (pHeight)
        *pHeight = bm.bmHeight ;
    if (pWidth)
        *pWidth = bm.bmWidth ;
}


int
WindowHeight (
             HWND hWnd
             )
{
    RECT           rectWindow ;

    GetWindowRect (hWnd, &rectWindow) ;
    return (rectWindow.bottom - rectWindow.top) ;
}


#ifdef KEEP_UTIL
int
WindowWidth (
            HWND hWnd
            )
{
    RECT           rectWindow ;

    GetWindowRect (hWnd, &rectWindow) ;
    return (rectWindow.right - rectWindow.left) ;
}


void
WindowResize (
             HWND hWnd,
             int xWidth,
             int yHeight
             )
/*
   Effect:        Change the size of the window hWnd, leaving the
                  starting position intact.  Redraw the window.

                  If either xWidth or yHeight is NULL, keep the
                  corresponding dimension unchanged.

   Internals:     Since hWnd may be a child of another parent, we need
                  to scale the MoveWindow arguments to be in the client
                  coordinates of the parent.

*/
{
    RECT           rectWindow ;
    HWND           hWndParent ;

    GetWindowRect (hWnd, &rectWindow) ;
    hWndParent = WindowParent (hWnd) ;

    if (hWndParent)
        ScreenRectToClient (hWndParent, &rectWindow) ;

    MoveWindow (hWnd,
                rectWindow.left,
                rectWindow.top,
                xWidth ? xWidth : rectWindow.right - rectWindow.left,
                yHeight ? yHeight : rectWindow.bottom - rectWindow.top,
                TRUE) ;
}
#endif




void
WindowSetTopmost (
                 HWND hWnd,
                 BOOL bTopmost
                 )
/*
   Effect:        Set or clear the "topmost" attribute of hWnd. If a window
                  is "topmost", it remains ontop of other windows, even ones
                  that have the focus.
*/
{
    SetWindowPos (hWnd, bTopmost ? HWND_TOPMOST : HWND_NOTOPMOST,
                  0, 0, 0, 0,
                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE) ;
}


void
WindowEnableTitle (
                  HWND hWnd,
                  BOOL bTitle
                  )
{
    DWORD          dwStyle ;


    dwStyle = WindowStyle (hWnd) ;

    if (bTitle)
        dwStyle = WS_TILEDWINDOW | dwStyle ;
    else
        dwStyle =
        dwStyle &
        ~ (WS_DLGFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX) ;

    if (!bTitle)
        SetMenu (hWnd, NULL) ;

    WindowSetStyle (hWnd, dwStyle) ;
    SetWindowPos (hWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE |
                  SWP_NOZORDER | SWP_FRAMECHANGED );
}

#ifdef PERFMON_DEBUG

#define MikeBufferSize         256


int
_cdecl
mike (
     TCHAR *szFormat,
     ...
     )
/*
   Note:          This function returns a value so that it can more easily
                  be used in conditional expressions.
*/
{
    TCHAR          szBuffer [MikeBufferSize] ;
    va_list        vaList ;

    va_start (vaList, szFormat) ;
    TSPRINTF (szBuffer, szFormat, va_arg(vaList, LPTSTR)) ;
    va_end (vaList) ;

    MessageBox (NULL, szBuffer, TEXT("Debug"), MB_OK | MB_TASKMODAL) ;
    return (0) ;
}



int
_cdecl
mike1 (
      TCHAR *szFormat,
      ...
      )
/*
   Note:          This function returns a value so that it can more easily
                  be used in conditional expressions.
*/
{
    TCHAR           szBuffer [MikeBufferSize] ;
    va_list        vaList ;
    HDC            hDC ;
    RECT           rect ;

    va_start (vaList, szFormat) ;
    TSPRINTF (szBuffer, szFormat, va_arg(vaList, LPTSTR)) ;
    va_end (vaList) ;

    rect.left = 0 ;
    rect.right = xScreenWidth ;
    rect.top = 0 ;
    rect.bottom = 20 ;

    hDC = CreateScreenDC () ;
    ExtTextOut (hDC, 0, 0, ETO_OPAQUE, &rect,
                szBuffer, lstrlen (szBuffer), NULL) ;
    DeleteDC (hDC) ;

    return (0) ;
}

int
_cdecl
mike2 (
      TCHAR *szFormat,
      ...
      )
/*
   Note:          This function returns a value so that it can more easily
                  be used in conditional expressions.
*/
{
    TCHAR           szBuffer [MikeBufferSize] ;
    va_list        vaList ;

    va_start (vaList, szFormat) ;
    TSPRINTF (szBuffer, szFormat, va_arg(vaList, LPTSTR)) ;
    va_end (vaList) ;

    OutputDebugString (szBuffer) ;

    return (0) ;
}
#endif      // PERFMON_DEBUG


#ifdef KEEP_UTIL
int
inttok (
       LPSTR lpszText,
       LPSTR lpszDelimiters
       )
{

    // Inttok only works with LPSTRs because of the atoi & strtok

    LPSTR   lpszToken ;

    lpszToken = strtok (lpszText, lpszDelimiters) ;

    if (lpszToken)
        return (atoi (lpszToken)) ;
    else
        return (0) ;
}


void
WindowPlacementToString (
                        PWINDOWPLACEMENT pWP,
                        LPTSTR lpszText
                        )
{
    TSPRINTF (lpszText, TEXT("%d %d %d %d %d %d %d %d %d"),
              pWP->showCmd,
              pWP->ptMinPosition.x,
              pWP->ptMinPosition.y,
              pWP->ptMaxPosition.x,
              pWP->ptMaxPosition.y,
              pWP->rcNormalPosition.left,
              pWP->rcNormalPosition.top,
              pWP->rcNormalPosition.right,
              pWP->rcNormalPosition.bottom) ;
}


void
StringToWindowPlacement (
                        LPTSTR lpszText,
                        PWINDOWPLACEMENT pWP
                        )
{
    int            iNumScanned ;

    iNumScanned = swscanf (lpszText, TEXT("%d %d %d %d %d %d %d %d %d"),
                           &pWP->showCmd,
                           &pWP->ptMinPosition.x,
                           &pWP->ptMinPosition.y,
                           &pWP->ptMaxPosition.x,
                           &pWP->ptMaxPosition.y,
                           &pWP->rcNormalPosition.left,
                           &pWP->rcNormalPosition.top,
                           &pWP->rcNormalPosition.right,
                           &pWP->rcNormalPosition.bottom) ;
}
#endif  // KEEP_UTIL



int
LogFontHeight (
              HDC hDC,
              int iPointSize
              )
/*
   Effect:        Return the appropriate pixel height for the lfHeight
                  field of the LOGFONT structure for the requested point
                  size. This size depends on the number of pixels per
                  logical inch of the current display context, hDC.

   Called By:     Any function which wants to create a particular
                  point-height font.
*/
{
    return (-MulDiv (iPointSize, GetDeviceCaps (hDC, LOGPIXELSY), 72)) ;
}


// this routine converts the input menu id into help id.
DWORD
MenuIDToHelpID (
               DWORD MenuID
               )
{
    DWORD HelpID = 0 ;

    if (MenuID >= IDM_FIRSTMENUID && MenuID <= IDM_LASTMENUID) {
        // only special cases...
        if (MenuID >= IDM_OPTIONSREFRESHNOWCHART &&
            MenuID <= IDM_OPTIONSREFRESHNOWREPORT) {
            HelpID = HC_PM_MENU_OPTIONSREFRESHNOW ;
        } else {
            HelpID = MenuID - MENUIDTOHELPID ;
        }
#ifndef ADVANCED_PERFMON
        // need to convert these 2 IDs for Perf. Meter
        if (HelpID == HC_PM_MENU_HELPABOUT) {
            HelpID = HC_NTPM_MENU_HELPABOUT ;
        } else if (HelpID == HC_PM_MENU_FILEEXIT) {
            HelpID = HC_NTPM_MENU_FILEEXIT ;
        }
#endif
    }

    return (HelpID) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\utils.h ===
//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define ThreeDPad          2
#define NOCHANGE           -1

#define MENUCLOSING        (0xFFFF0000)

#define WM_DLGSETFOCUS     (WM_USER + 0x201)
#define WM_DLGKILLFOCUS    (WM_USER + 0x202)



//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define PinInclusive(x, lo, hi)                       \
   (max (lo, min (x, hi)))


#define PinExclusive(x, lo, hi)                       \
   (max ((lo) + 1, min (x, (hi) - 1)))


#define BoolEqual(a, b)                               \
   ((a == 0) == (b == 0))


//=============================//
// Window Instance Accessors   //
//=============================//

#define WindowParent(hWnd)                            \
   ((HWND) GetWindowLongPtr (hWnd, GWLP_HWNDPARENT))

#define WindowID(hWnd)                                \
   GetWindowLong (hWnd, GWL_ID)

#define WindowInstance(hWnd)                          \
   GetWindowWord (hWnd, GWW_HINSTANCE)

#define WindowStyle(hWnd)                             \
   GetWindowLong (hWnd, GWL_STYLE)

#define WindowSetStyle(hWnd, lStyle)                  \
   SetWindowLong (hWnd, GWL_STYLE, lStyle)

#define WindowExStyle(hWnd)                           \
   GetWindowLong (hWnd, GWL_EXSTYLE)

#define WindowSetID(hWnd, wID)                        \
   SetWindowLong (hWnd, GWL_ID, wID)


// All modeless dialogs need to be dispatched separately in the WinMain
// message loop, but only if the dialog exists.


#define ModelessDispatch(hDlg, lpMsg)                 \
   (hDlg ? IsDialogMessage (hDlg, lpMsg) : FALSE)


#define strclr(szString)                              \
   (szString [0] = TEXT('\0'))


#define strempty(lpszString)                          \
   (!(lpszString) || !(lpszString[0]))

#define pstrsame(lpsz1, lpsz2)                        \
   ((!lpsz1 && !lpsz2) || (lpsz1 && lpsz2 && strsame (lpsz1, lpsz2)))

#define pstrsamei(lpsz1, lpsz2)                        \
   ((!lpsz1 && !lpsz2) || (lpsz1 && lpsz2 && strsamei (lpsz1, lpsz2)))

#define StringLoad(wID, szText)                       \
   (LoadString (hInstance, wID,                       \
    szText, (sizeof (szText) / sizeof(TCHAR)) - 1))


#define WindowInvalidate(hWnd)                        \
   (InvalidateRect (hWnd, NULL, TRUE))


#define WindowShow(hWnd, bShow)                       \
   (ShowWindow (hWnd, (bShow) ? SW_SHOW : SW_HIDE))


#define MenuCheck(hMenu, wID, bCheck)                 \
   (CheckMenuItem (hMenu, wID, (bCheck) ?             \
     (MF_BYCOMMAND | MF_CHECKED) : (MF_BYCOMMAND | MF_UNCHECKED)))

#define DeleteFont(hFont)                             \
   (DeleteObject (hFont))

#define DeleteBitmap(hBitmap)                         \
   (DeleteObject (hBitmap))

#define DialogControl(hDlg, wControlID)               \
   GetDlgItem (hDlg, wControlID)


#define DialogSetInt(hDlg, wControlID, iValue)        \
   (SetDlgItemInt (hDlg, wControlID, iValue, TRUE))


#define DialogText(hDlg, wControlID, szText)          \
   (GetDlgItemText (hDlg, wControlID, szText, sizeof (szText) / sizeof(TCHAR) - 1))

#define DialogInt(hDlg, wControlID)                   \
   (GetDlgItemInt (hDlg, wControlID, NULL, TRUE))

#define strsame(szText1, szText2)                     \
   (!lstrcmp (szText1, szText2))

#define strsamei(szText1, szText2)                     \
   (!lstrcmpi (szText1, szText2))

#define strnsame(szText1, szText2, iLen)              \
   (!lstrncmp (szText1, szText2, iLen))


#define CreateScreenDC()                              \
   CreateDC (TEXT("DISPLAY"), NULL, NULL, NULL)



#define RectContract(lpRect, xAmt, yAmt)              \
   {                                                  \
   (lpRect)->left += (xAmt) ;                         \
   (lpRect)->top += (yAmt) ;                          \
   (lpRect)->right -= (xAmt) ;                        \
   (lpRect)->bottom -= (yAmt) ;                       \
   }

#define IsBW(hDC)                                     \
   (DeviceNumColors (hDC) <= 2)

#ifdef KEEP_PRINT
#define IsPrinterDC(hDC)                              \
   (GetDeviceCaps (hDC, TECHNOLOGY) != DT_RASDISPLAY)
#else
#define IsPrinterDC(hDC)                              \
   (FALSE)
#endif

#define VertInchPixels(hDC, iNumerator, iDenominator) \
   ((iNumerator * GetDeviceCaps (hDC, LOGPIXELSY)) / iDenominator)


#define HorzInchPixels(hDC, iNumerator, iDenominator) \
   ((iNumerator * GetDeviceCaps (hDC, LOGPIXELSX)) / iDenominator)


#define VertPointPixels(hDC, iPoints)                 \
   ((iPoints * GetDeviceCaps (hDC, LOGPIXELSY)) / 72)



#define SimulateButtonPush(hDlg, wControlID)          \
   (PostMessage (hDlg, WM_COMMAND,                    \
                 (WPARAM) MAKELONG (wControlID, BN_CLICKED),  \
                 (LPARAM) DialogControl (hDlg, wControlID)))


// convert an unicode string to OEM string
#define ConvertUnicodeStr(pOemStr, pUnicodeStr)   \
   CharToOemBuff(pUnicodeStr, pOemStr, lstrlen(pUnicodeStr) + 1)

#define CallWinHelp(ContextID, WND)   \
    if (*pszHelpFile != 0) {                                        \
        WinHelp(hWndMain, pszHelpFile, HELP_CONTEXT, ContextID);    \
    } else {                                                        \
        DlgErrorBox (WND, ERR_HELP_NOT_AVAILABLE);                 \
    }

   

//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

void Fill (HDC hDC,
           DWORD rgbColor,
           LPRECT lpRect) ;

void ScreenRectToClient (HWND hWnd,
                         LPRECT lpRect) ;

int TextWidth (HDC hDC, LPTSTR lpszText) ;


void ThreeDConcave (HDC hDC,
                    int x1, int y1,
                    int x2, int y2,
                    BOOL bFace) ;


void ThreeDConvex (HDC hDC,
                   int x1, int y1,
                   int x2, int y2) ;


void ThreeDConcave1 (HDC hDC,
                     int x1, int y1,
                     int x2, int y2) ;


void ThreeDConvex1 (HDC hDC,
                   int x1, int y1,
                   int x2, int y2) ;


int _cdecl mike (TCHAR *szFormat, ...) ;

int _cdecl DlgErrorBox (HWND hDlg, UINT id, ...) ;

int _cdecl mike1 (TCHAR *szFormat, ...) ;
int _cdecl mike2 (TCHAR *szFormat, ...) ;

int FontHeight (HDC hDC,
                 BOOL bIncludeLeading) ;


int TextAvgWidth (HDC hDC,
                  int iNumChars) ;



void WindowCenter (HWND hWnd) ;



BOOL DialogMove (HDLG hDlg,
                 WORD wControlID,
                 int xPos,
                 int yPos,
                 int xWidth,
                 int yHeight) ;


int DialogWidth (HDLG hDlg,
                 WORD wControlID) ;


int DialogXPos (HDLG hDlg,
                WORD wControlID) ;

int DialogYPos (HDLG hDlg,
                WORD wControlID) ;


void DialogShow (HDLG hDlg,
                 WORD wID,
                 BOOL bShow) ;


BOOL _cdecl DialogSetText (HDLG hDlg,
                           WORD wControlID,
                           WORD wStringID,
                           ...) ;
#if 0
BOOL _cdecl DialogSetString (HDLG hDlg,
                             WORD wControlID,
                             LPTSTR lpszFormat,
                             ...) ;
#endif
#define DialogSetString(hDlg, wControlID, lpszFormat)  \
   SetDlgItemText (hDlg, wControlID, lpszFormat)

LPTSTR LongToCommaString (LONG lNumber,
                         LPTSTR lpszText) ;


BOOL MenuSetPopup (HWND hWnd,
                   int iPosition,
                   WORD  wControlID,
                   LPTSTR lpszResourceID) ;

void DialogEnable (HDLG hDlg,
                   WORD wID,
                   BOOL bEnable) ;


LPTSTR FileCombine (LPTSTR lpszFileSpec,
                   LPTSTR lpszFileDirectory,
                   LPTSTR lpszFileName) ;

LPTSTR ExtractFileName (LPTSTR pFileSpec) ;

int CBAddInt (HWND hWndCB,
              int iValue) ;

FLOAT DialogFloat (HDLG hDlg,
                   WORD wControlID,
                   BOOL *pbOK) ;


LPTSTR StringAllocate (LPTSTR lpszText1) ;


int DivRound (int iNumerator, int iDenominator) ;



BOOL MenuEnableItem (HMENU hMenu,
                     WORD wID,
                     BOOL bEnable) ;



void DrawBitmap (HDC hDC,
                 HBITMAP hBitmap,
                 int xPos,
                 int yPos,
                 LONG  lROPCode) ;

void BitmapDimemsion (HBITMAP hBitmap, int *pHeight, int *pWidth) ;


void WindowResize (HWND hWnd,
                   int xWidth,
                   int yHeight) ;


int WindowHeight (HWND hWnd) ;



void WindowSetTopmost (HWND hWnd, BOOL bTopmost) ;


void WindowEnableTitle (HWND hWnd, BOOL bTitle) ;


void Line (HDC hDC,
           HPEN hPen,
           int x1, int y1,
           int x2, int y2) ;



#define HLine(hDC, hPen, x1, x2, y)          \
   Line (hDC, hPen, x1, y, x2, y) ;


#define VLine(hDC, hPen, x, y1, y2)          \
   Line (hDC, hPen, x, y1, x, y2) ;


int DialogHeight (HDLG hDlg,
                  WORD wControlID) ;



void DialogSetFloat (HDLG hDlg,
                     WORD wControlID,
                     FLOAT eValue) ;

void DialogSetInterval (HDLG hDlg,
                        WORD wControlID,
                        int  IntervalMSec ) ;

int MessageBoxResource (HWND hWndParent,
                        WORD wTextID,
                        WORD wTitleID,
                        UINT uiStyle) ;

void WindowPlacementToString (PWINDOWPLACEMENT pWP,
                              LPTSTR lpszText) ;

void StringToWindowPlacement (LPTSTR lpszText,
                              PWINDOWPLACEMENT pWP) ;

DWORD MenuIDToHelpID (DWORD MenuID) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\valuebar.h ===
HWND
CreateGraphStatusWindow (
                         HWND hWndGraph
                         );

BOOL
GraphStatusInitializeApplication (
                                  void
                                  );

LRESULT
APIENTRY
GraphStatusWndProc (
                    HWND hWnd,
                    UINT wMsg,
                    WPARAM wParam,
                    LPARAM lParam
                    );

void
StatusDrawAvg (
               HDC hDC,
               PLINESTRUCT pLine,
               BOOL bForceRedraw
               );

void
StatusDrawMax (
               HDC hDC,
               PLINESTRUCT pLine,
               BOOL bForceRedraw
               );

void
StatusDrawMin (
               HDC hDC,
               PLINESTRUCT pLine,
               BOOL bForceRedraw
               );

void
StatusDrawLast (
                HDC hDC,
                PLINESTRUCT pLine,
                BOOL bForceRedraw
                );

void
StatusDrawTime (
                HDC hDC,
                BOOL bForceRedraw
                );

int
ValuebarHeight (
                HWND hWnd
                );

void
StatusTimer (
             HWND hWnd,
             BOOL bForecRedraw
             );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\valuebar.c ===
/*
==============================================================================

  Application:

            Microsoft Windows NT (TM) Performance Monitor

  File:
            status.c - Status window procedure and supporting routines.

            This file contains code creating the status window, which is
            a child of the legend window. The status window shows the
            time duration of the chart, and the last, avg, min and max
            of the currently-selected chart line.


  Copyright 1992, Microsoft Corporation. All Rights Reserved.
==============================================================================
*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <stdio.h>
#include <stdlib.h>   // for mbstowcs

#include "perfmon.h"
#include "perfmops.h"      // for ConvertDecimalPoint
#include "valuebar.h"

#include "grafdata.h"      // for CurrentGraphLine
#include "graph.h"
#include "playback.h"      // for PlayingBackLog
#include "legend.h"
#include "utils.h"

//==========================================================================//
//                                  Constants                               //
//==========================================================================//
HDC   hVBarDC ;

#define szGraphStatusClass          TEXT("PerfmonGraphStatusClass")
#define dwGraphStatusClassStyle     (CS_HREDRAW | CS_VREDRAW | CS_OWNDC)
#define iGraphStatusClassExtra      (0)
#define iGraphStatusWindowExtra     (0)
#define dwGraphStatusWindowStyle    (WS_CHILD | WS_VISIBLE)


#define szStatusValueFormat         TEXT("%10.3f")
#define szStatusMediumnValueFormat  TEXT("%10.0f")
#define szStatusLargeValueFormat    TEXT("%10.4e")
#define eStatusValueTooLarge        ((FLOAT) 1.0E+20)
#define eStatusValueMax             ((FLOAT) 999999.999)
#define eStatusLargeValueMax        ((FLOAT) 9999999999.0)


#define szValueTooHigh              TEXT("+ + + +")
#define szValueTooLow               TEXT("- - - -")

#define StatusLastElt               0
#define StatusAvgElt                1
#define StatusMinElt                2
#define StatusMaxElt                3
#define StatusTimeElt               4

#define StatusNumElts               5

#define StatusDrawAvg(hDC, eValue, bForceRedraw)   \
   DrawStatusValue (hDC, StatusAvgElt, eValue, bForceRedraw)

#define StatusDrawMax(hDC, eValue, bForceRedraw)   \
   DrawStatusValue (hDC, StatusMaxElt, eValue, bForceRedraw)

#define StatusDrawMin(hDC, eValue, bForceRedraw)   \
   DrawStatusValue (hDC, StatusMinElt, eValue, bForceRedraw)

//==========================================================================//
//                                  Typedefs                                //
//==========================================================================//


typedef struct StatusEltStruct {
    TCHAR          szText [20] ;
    int            xTextPos ;
    int            xValuePos ;
    FLOAT          eValue ;
} StatusEltType ;


// This structure represents the "instance data" for a StatusWindow. The
// information is collected in a structure to ease the conversion of this
// code when later adding multiple graph windows. For now, one copy of this
// struct is defined as local data to this file.
typedef struct StatusDataStruct {
    StatusEltType  aElts [StatusNumElts] ;
    SIZE           sizeValue ;
    int            yHeight ;
} StatusDataType ;



//==========================================================================//
//                                Local Data                                //
//==========================================================================//


StatusDataType    StatusData ;


//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define StatusTopMargin()     (2)
#define StatusBottomMargin()  (4)

#define StatusLeftMargin()    (3)
#define StatusTextMargin()    (5 + ThreeDPad)
#define StatusValueMargin()   (3 + ThreeDPad)


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


void
DrawStatusValue (
                HDC hDC,
                int iEltOffset,
                FLOAT eValue,
                BOOL bForceRedraw
                )
/*
   Called By:     StatusDrawTime, StatusDrawLast, StatusDrawAvg,
                  StatusDrawMin, StatusDrawMax.
*/
{
    RECT           rectValue ;
    TCHAR          szValue [20] ;

    if (!bForceRedraw && eValue == StatusData.aElts[iEltOffset].eValue)
        return ;
    StatusData.aElts[iEltOffset].eValue = eValue ;

    rectValue.left = StatusData.aElts[iEltOffset].xValuePos ;
    rectValue.top = StatusTopMargin () + ThreeDPad + 1;
    rectValue.right = rectValue.left + StatusData.sizeValue.cx ;
    rectValue.bottom = rectValue.top + StatusData.sizeValue.cy ;


    if (eValue > eStatusValueMax) {
        if (eValue > eStatusValueTooLarge) {
            lstrcpy (szValue, szValueTooHigh) ;
        } else {
            TSPRINTF (szValue,
                      (eValue > eStatusLargeValueMax) ? szStatusLargeValueFormat :
                      szStatusMediumnValueFormat,
                      eValue) ;
            ConvertDecimalPoint (szValue) ;
        }
    } else if (eValue < -eStatusValueMax)
        lstrcpy (szValue, szValueTooLow) ;
    else {
        TSPRINTF (szValue, szStatusValueFormat, eValue) ;
        ConvertDecimalPoint (szValue) ;
    }

    ExtTextOut (hDC, rectValue.right, rectValue.top, ETO_OPAQUE, &rectValue,
                szValue, lstrlen (szValue), NULL) ;
}  // DrawStatusValue


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


//void static OnCreate (HWND hWnd)
void
OnVBarCreate (
             HWND hWnd
             )
/*
   Effect:        Perform any actions needed when a status window is created.
                  In particular, set the instance data to initial values,
                  determine the size and placement of the various elements
                  of the status display.

   Called By:     GraphStatusWndProc only, in response to a WM_CREATE message.
*/
{
    TCHAR          szValue [20] ;
    HDC            hDC ;
    int            iLen ;
    int            i ;

    hDC = hVBarDC = GetDC (hWnd) ;
    if (!hDC)
        return;
    SelectFont (hDC, hFontScales) ;
    SetBkColor (hDC, ColorBtnFace) ;
    SetTextAlign (hDC, TA_RIGHT | TA_TOP) ;

    //=============================//
    // Load Text Labels            //
    //=============================//

    StringLoad (IDS_STATUSLAST, StatusData.aElts[StatusLastElt].szText) ;
    StringLoad (IDS_STATUSAVG, StatusData.aElts[StatusAvgElt].szText) ;
    StringLoad (IDS_STATUSMIN, StatusData.aElts[StatusMinElt].szText) ;
    StringLoad (IDS_STATUSMAX, StatusData.aElts[StatusMaxElt].szText) ;
    StringLoad (IDS_STATUSTIME, StatusData.aElts[StatusTimeElt].szText) ;

    //=============================//
    // Determine Status Height     //
    //=============================//

    StatusData.yHeight = StatusTopMargin () +
                         StatusBottomMargin () +
                         FontHeight (hDC, TRUE) +
                         2 * ThreeDPad ;

    //=============================//
    // Set position/size of elts   //
    //=============================//

    // Determine the bounding box for each status value by using a max value.
    iLen = TSPRINTF (szValue, szStatusLargeValueFormat, -eStatusValueMax) ;

    GetTextExtentPoint (hDC, szValue, lstrlen(szValue), &StatusData.sizeValue) ;
    for (i = 0 ; i < StatusNumElts ; i++) {
        StatusData.aElts[i].eValue = (FLOAT) 0.0 ;

        if (i)
            StatusData.aElts[i].xTextPos = StatusTextMargin () +
                                           StatusData.aElts[i - 1].xValuePos +
                                           StatusData.sizeValue.cx ;
        else
            StatusData.aElts[i].xTextPos = StatusLeftMargin () ;
        StatusData.aElts[i].xValuePos = StatusData.aElts[i].xTextPos +
                                        StatusValueMargin () +
                                        TextWidth (hDC, StatusData.aElts[i].szText) ;
    }
}



void
static
OnPaint (
        HWND hWnd,
        BOOL bEraseBackground
        )
/*
   Effect:        Paint the invalid surface of hWnd. Draw each label, each
                  recessed value box, and each value.

   Called By:     GraphStatusWndProc only, in response to a WM_PAINT message.
*/
{
    HDC            hDC ;
    PAINTSTRUCT    ps ;
    RECT           rectClient ;
    int            i ;
    PLINESTRUCT    pLine;

    hDC = BeginPaint (hWnd, &ps) ;
    SetBkMode (hDC, (bEraseBackground ? OPAQUE : TRANSPARENT)) ;
    SetBkColor (hDC, ColorBtnFace) ;

    GetClientRect (hWnd, &rectClient) ;
    HLine (hDC, GetStockObject (BLACK_PEN),
           rectClient.left, rectClient.right,
           rectClient.bottom - 1) ;

    if ((pGraphs->gOptions.bStatusBarChecked) && (pGraphs->gOptions.bLegendChecked)) {
        UINT  hPrevTextAlign = SetTextAlign (hDC, TA_LEFT | TA_TOP) ;

        for (i = 0; i < StatusNumElts; i++) {
            // Draw the label
            TextOut (hDC, StatusData.aElts[i].xTextPos, StatusTopMargin () + ThreeDPad,
                     StatusData.aElts[i].szText,
                     lstrlen (StatusData.aElts[i].szText)) ;

            // Draw the recesed value box
            ThreeDConcave1 (hDC,
                            StatusData.aElts[i].xValuePos - ThreeDPad,
                            StatusTopMargin (),
                            StatusData.aElts[i].xValuePos + StatusData.sizeValue.cx + ThreeDPad,
                            StatusTopMargin () + StatusData.sizeValue.cy + 2 * ThreeDPad ) ;
        }

        // restore TextAlign for drawing values
        SetTextAlign (hDC, hPrevTextAlign) ;

        // Draw the values themselves

        pLine = CurrentGraphLine (hWndGraph) ;
        StatusDrawTime (hDC, TRUE) ;

        StatusDrawLast (hDC, pLine, TRUE) ;

        if (pLine) {
            StatusDrawAvg (hDC, pLine->lnAveValue, TRUE) ;
            StatusDrawMin (hDC, pLine->lnMinValue, TRUE) ;
            StatusDrawMax (hDC, pLine->lnMaxValue, TRUE) ;
        } else {
            StatusDrawAvg (hVBarDC,  (FLOAT)0.0, TRUE) ;
            StatusDrawMax (hVBarDC,  (FLOAT)0.0, TRUE) ;
            StatusDrawMin (hVBarDC,  (FLOAT)0.0, TRUE) ;
        }
    }

    EndPaint (hWnd, &ps) ;
}


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//



void
StatusDrawTime (
               HDC hDC,
               BOOL bForceRedraw
               )
/*
   Called By:     StatusTimer, StatusPaint.
*/
{
    FLOAT          eTimeSeconds ;

    if (PlayingBackLog ())
        eTimeSeconds = (FLOAT) PlaybackSelectedSeconds () ;
    else
        eTimeSeconds = pGraphs->gOptions.eTimeInterval *
                       (FLOAT) pGraphs->gMaxValues;

    DrawStatusValue (hDC, StatusTimeElt, eTimeSeconds, bForceRedraw) ;
}


void
StatusDrawLast (
               HDC hDC,
               PLINESTRUCT pLine,
               BOOL bForceRedraw
               )
/*
   Called By:     StatusTimer, StatusPaint.
*/
{
    INT            iKnownValue ;
    int            iMaxValues ;
    FLOAT          eValue ;

    if (!pLine || pGraphs->gKnownValue == -1)
        eValue = (FLOAT) 0.0 ;
    else {
        iKnownValue = pGraphs->gKnownValue ;
        iMaxValues  = pGraphs->gMaxValues ;
        eValue = pLine->lnValues [iKnownValue % iMaxValues] ;
    }

    DrawStatusValue (hDC, StatusLastElt, eValue, bForceRedraw) ;
}

LRESULT
APIENTRY
GraphStatusWndProc (
                   HWND hWnd,
                   UINT wMsg,
                   WPARAM wParam,
                   LPARAM lParam
                   )
{
    BOOL           bCallDefProc ;
    LRESULT        lReturnValue ;

    bCallDefProc = FALSE ;
    lReturnValue = 0L ;

    switch (wMsg) {
        case WM_CREATE:
            //OnCreate (hWnd) ;
            OnVBarCreate (hWnd) ;
            break ;


        case WM_PAINT:
            OnPaint (hWnd, TRUE) ;
            break ;

        case WM_DESTROY:
            ReleaseDC (hWnd, hVBarDC) ;
            break ;

        default:
            bCallDefProc = TRUE ;
    }

    if (bCallDefProc)
        lReturnValue = DefWindowProc (hWnd, wMsg, wParam, lParam) ;

    return (lReturnValue);
}


int
ValuebarHeight (
               HWND hWnd
               )
/*
   Effect:        A status window has a preferred height, based on the font
                  used in its display. Return the preferred height, determined
                  when the window was created.

   Assert:        OnCreate has already been called, and it set
                  StatusData.yHeight.
*/
{
    return (StatusData.yHeight) ;
}


void
StatusTimer (
            HWND hWnd,
            BOOL bForceRedraw
            )
/*
   Effect:        Perform any status-window actions necessary when a timer
                  tick has been received. In particular, update (redraw)
                  any of the changed values in the status bar.

   Internals:     Each of these called functions compares the value to be
                  displayed with the previous value and doesn't draw if the
                  values are equal.
*/
{
    PLINESTRUCT pLine;

    pLine = CurrentGraphLine (hWndGraph) ;

    StatusDrawLast (hVBarDC, pLine, bForceRedraw) ;

    if (pLine) {
        StatusDrawAvg (hVBarDC, pLine->lnAveValue, bForceRedraw) ;
        StatusDrawMin (hVBarDC, pLine->lnMinValue, bForceRedraw) ;
        StatusDrawMax (hVBarDC, pLine->lnMaxValue, bForceRedraw) ;
    } else {
        StatusDrawAvg (hVBarDC,  (FLOAT)0.0, bForceRedraw) ;
        StatusDrawMax (hVBarDC,  (FLOAT)0.0, bForceRedraw) ;
        StatusDrawMin (hVBarDC,  (FLOAT)0.0, bForceRedraw) ;
    }
}



HWND
CreateGraphStatusWindow (
                        HWND hWndGraph
                        )
{
    return (CreateWindow (szGraphStatusClass,       // class
                          NULL,                     // caption
                          dwGraphStatusWindowStyle, // window style
                          0, 0,                     // position
                          0, 0,                     // size
                          hWndGraph,                // parent window
                          NULL,                     // menu
                          hInstance,               // program instance
                          NULL)) ;                  // user-supplied data
}


BOOL
GraphStatusInitializeApplication (void)
/*
   Called By:     GraphInitializeApplication only
*/
{
    WNDCLASS       wc ;

    wc.style          = dwGraphStatusClassStyle ;
    wc.lpfnWndProc    = GraphStatusWndProc ;
    wc.hInstance      = hInstance ;
    wc.cbClsExtra     = iGraphStatusClassExtra ;
    wc.cbWndExtra     = iGraphStatusWindowExtra ;
    wc.hIcon          = NULL ;
    wc.hCursor        = LoadCursor (NULL, IDC_ARROW) ;
    //   wc.hbrBackground  = hbLightGray ;
    wc.hbrBackground  = hBrushFace;
    wc.lpszMenuName   = NULL ;
    wc.lpszClassName  = szGraphStatusClass ;

    return (RegisterClass (&wc)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmon\winhelpr.h ===
/*
==============================================================================

  Application:

            Microsoft Windows NT (TM) Performance Monitor

  File:
            wincrack.h - Windows helper macros.

            This file contains macros for more easily dealing with windows
            messages and objects. Think of it as an extension to windows.h.

   Written by:

            Mike Moskowitz 8 Apr 92.

  Copyright 1992, Microsoft Corporation. All Rights Reserved.
==============================================================================
*/



//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define SetFont(hWnd, hFont)                          \
   (SendMessage ((hWnd), WM_SETFONT, (WPARAM) hFont, 0))


//======================================//
// Object-differentiation routines      //
//======================================//


// Windows APIs deal with all GDI objects the same. There's a SelectObject,
// no SelectBitmap, SelectFont, etc. We use these instead to make the code
// easier to read. Also, you can redefine one of these to check the
// validity of a particular GDI object type.


#define SelectBitmap(hDC, hBitmap)                    \
   (SelectObject (hDC, hBitmap))

#define SelectFont(hDC, hFont)                        \
   (SelectObject (hDC, hFont))

#define SelectBrush(hDC, hBrush)                      \
   (SelectObject (hDC, hBrush))

#define DeleteBrush(hBrush)                           \
   (DeleteObject (hBrush))

#define SelectPen(hDC, hPen)                          \
   (SelectObject (hDC, hPen))

#define DeletePen(hPen)                               \
   (DeleteObject (hPen))


//======================================//
//                                      //
//======================================//


#define CBData(hWndCB, iIndex)                        \
   (SendMessage (hWndCB, CB_GETITEMDATA, iIndex, 0L))


#define CBSetData(hWndCB, iIndex, lData)              \
   (SendMessage (hWndCB, CB_SETITEMDATA, iIndex, (LPARAM) lData))


#define CBAdd(hWndCB, lpszText)                       \
   ((int)(DWORD)SendMessage((hWndCB), CB_ADDSTRING,   \
    0, (LPARAM)(LPCSTR)(lpszText)))


#define CBFind(hWndCB, lpszText)                      \
   (SendMessage (hWndCB, CB_FINDSTRING, 0xFFFFFFFF, (LPARAM) lpszText))


#define CBInsert(hWndCB, iIndex, lpszText)            \
   (SendMessage (hWndCB, CB_INSERTSTRING, (WPARAM) iIndex, (LPARAM) lpszText))


#define CBReset(hWndCB)                               \
   ((int)(DWORD)SendMessage((hWndCB), CB_RESETCONTENT,\
    0, (LPARAM)0))


#define CBSelection(hWndCB)                           \
   (SendMessage (hWndCB, CB_GETCURSEL, 0, 0L))


#define CBSetSelection(hWndCB, iIndex)                \
   (SendMessage (hWndCB, CB_SETCURSEL, iIndex, 0L))


#define CBString(hWndCB, iIndex, lpszText)            \
   (SendMessage (hWndCB, CB_GETLBTEXT, iIndex, (LPARAM) lpszText))


#define CBStringLen(hWndCB, iIndex)                   \
   (SendMessage (hWndCB, CB_GETLBTEXTLEN, iIndex, 0L))



//======================================//
// Listbox helpers                      //
//======================================//


#define LBAdd(hWndLB, lpszText)                       \
   (SendMessage (hWndLB, LB_ADDSTRING, 0, (LPARAM) lpszText))


#define LBData(hWndLB, iIndex)                        \
   (SendMessage (hWndLB, LB_GETITEMDATA, iIndex, 0L))


#define LBDelete(hWndLB, iIndex)                      \
   (SendMessage (hWndLB, LB_DELETESTRING, iIndex, 0L))


#define LBFind(hWndLB, lpszText)                      \
   (SendMessage (hWndLB, LB_FINDSTRING, (WPARAM) -1, (LPARAM) lpszText))


#define LBFocus(hWndLB)                               \
   (SendMessage (hWndLB, LB_GETCARETINDEX, 0, 0))


#define LBInsert(hWndLB, iIndex, lpszText)            \
   (SendMessage (hWndLB, LB_INSERTSTRING, (WPARAM) iIndex, (LPARAM) lpszText))


#define LBNumItems(hWndLB)                            \
   ((int) SendMessage (hWndLB, LB_GETCOUNT, 0, 0))


#define LBReset(hWndLB)                               \
   ((int)(DWORD)SendMessage((hWndLB), LB_RESETCONTENT,\
    0, (LPARAM)0))


#define LBSelected(hwndLB, index)                     \
   ((int)(DWORD)SendMessage((hwndLB), LB_GETSEL,      \
    (WPARAM)(int)(index), 0L))


#define LBSelection(hWndLB)                           \
   (SendMessage (hWndLB, LB_GETCURSEL, 0, 0L))


#define LBSetData(hWndLB, iIndex, lData)              \
   (SendMessage (hWndLB, LB_SETITEMDATA, iIndex, (LPARAM) lData))


#define LBSetSelection(hWndLB, iIndex)                \
   (SendMessage (hWndLB, LB_SETCURSEL, iIndex, 0L))


#define LBString(hwndLB, iIndex, lpszText)            \
   ((int)(DWORD)SendMessage((hwndLB), LB_GETTEXT,     \
    (WPARAM)(int)(iIndex), (LPARAM)(LPCSTR)(lpszText)))


#define MLBSetSelection(hWndMLB, iIndex, bSet)        \
   (SendMessage (hWndMLB, LB_SETSEL, (WPARAM) bSet, (LPARAM) iIndex))

#define LBSetVisible(hWndLB, iIndex)                  \
   (SendMessage (hWndLB, LB_SETCARETINDEX, (WPARAM) iIndex, 0L))


#define LBSetRedraw(hWndLB, bDrawOnOff)               \
   (SendMessage (hWndLB, WM_SETREDRAW, (WPARAM) bDrawOnOff, 0L))


#define LBSetHorzExtent(hWndLB, wExtent)              \
   (SendMessage (hWndLB, LB_SETHORIZONTALEXTENT, (WPARAM)wExtent, 0L))

//======================================//
// Edit helpers                         //
//======================================//


#define EditModified(hWndEdit)                        \
   (SendMessage ((hWndEdit), EM_GETMODIFY, (WPARAM) 0, (LPARAM) 0))


#define EditSetModified(hWndEdit, bModified)                     \
   (SendMessage ((hWndEdit), EM_SETMODIFY, (WPARAM) bModified, 0))


#define EditSetLimit(hWndEdit, iLimit)                \
   (SendMessage ((hWndEdit), EM_LIMITTEXT, (WPARAM) iLimit, 0))
#define EditSetTextPos(hWnd, idControl, iStartPos, iEndPos)    \
   (SendMessage (GetDlgItem(hWnd, idControl), EM_SETSEL, (WPARAM) iStartPos, (LPARAM) iEndPos))

#define EditSetTextEndPos(hWnd, idControl)    \
   EditSetTextPos(hWnd, idControl, 0, 32767)

//======================================//
// Cursor helpers                       //
//======================================//

#define SetHourglassCursor() \
    (SetCursor(LoadCursor(NULL, IDC_WAIT)))

#define SetArrowCursor() \
    (SetCursor(LoadCursor(NULL, IDC_ARROW)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmtr\lookmon.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    lookmon.c

Abstract:

    This module contains the NT/Win32 Lookaside List Monitor

Author:

    David N. Cutler (davec) 8-Jun-1996

Revision History:

--*/

#include "perfmtrp.h"
#include <search.h>
#include <malloc.h>
#include <limits.h>
#include <stdlib.h>

//
// Define lookaside query information buffer size and buffers.
//

#define BUFFER_SIZE (64 * 1024 / sizeof(ULONG))

ULONG LargeBuffer1[BUFFER_SIZE];
ULONG LargeBuffer2[BUFFER_SIZE];

//
// Define lookaside output structure and lookaside output information buffer.
//

typedef struct _LOOKASIDE_OUTPUT {
    USHORT CurrentDepth;
    USHORT MaximumDepth;
    ULONG Allocates;
    ULONG AllocateRate;
    ULONG AllocateHits;
    ULONG AllocateMisses;
    ULONG Frees;
    ULONG FreeRate;
    ULONG Type;
    ULONG Tag;
    ULONG Size;
    LOGICAL Changed;
} LOOKASIDE_OUTPUT, *PLOOKASIDE_OUTPUT;

LOOKASIDE_OUTPUT OutputBuffer[1000];

//
// Define sort types and default sort type.
//

#define TOTAL_ALLOCATES 0
#define ALLOCATE_HITS 1
#define ALLOCATE_MISSES 2
#define CURRENT_DEPTH 3
#define MAXIMUM_DEPTH 4
#define RATE 5
#define TAG 6

ULONG SortBy = TAG;

//
// Define pool types to include and default pool type.
//

#define NONPAGED 0
#define PAGED 1
#define BOTH 2

UCHAR *PoolType[] = {
    "Nonp",
    "Page"
};

ULONG DisplayType = BOTH;

//
// Define miscellaneous values.
//

ULONG DelayTimeMsec = 5000;
ULONG NumberOfInputRecords;
INPUT_RECORD InputRecord;
HANDLE InputHandle;
HANDLE OutputHandle;
DWORD OriginalInputMode;
WORD NormalAttribute;
WORD HighlightAttribute;
ULONG NumberOfCols;
ULONG NumberOfRows;
SIZE_T FirstDetailLine = 0;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;
ULONG NoHighlight;

//
// Define filter structure and filter data.
//

#define MAX_FILTER 64

typedef struct _FILTER {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    BOOLEAN Exclude;
} FILTER, *PFILTER;

FILTER Filter[MAX_FILTER];
ULONG FilterCount = 0;

VOID
ShowHelpPopup(
    VOID
    );

int
__cdecl
ulcomp(
    const void *e1,
    const void *e2
    );

int
__cdecl
ulcomp(
    const void *E1,
    const void *E2
    )

/*++

Routine Description:

    This function compares two lookaside entries and returns the comparison
    value based on the comparison type.

Arguments:

    E1 - Supplies a pointer to a lookaside output entry.

    E2 - Supplies a pointer to a lookaside output entry.

Return Value:

    A negative value is returned if the first lookaside entry compares less
    than the second lookaside entry. A zero value is returned if the two
    lookaside entries compare equal. A positive nonzero value is returned if
    the first lookaside entry is greater than the second lookaside entry.

--*/

{

    PUCHAR C1;
    PUCHAR C2;
    PLOOKASIDE_OUTPUT L1 = (PLOOKASIDE_OUTPUT)E1;
    PLOOKASIDE_OUTPUT L2 = (PLOOKASIDE_OUTPUT)E2;
    LONG U1;

    C1 = (PUCHAR)&L1->Tag;
    C2 = (PUCHAR)&L2->Tag;
    switch (SortBy) {

        //
        // Sort by number of allocations in descending order.
        //

    case TOTAL_ALLOCATES:
        return L2->Allocates - L1->Allocates;
        break;

        //
        // Sort by number of allocate hits in descending order.
        //

    case ALLOCATE_HITS:
        return L2->AllocateHits - L1->AllocateHits;
        break;

        //
        // Sort by number of allocate misses in descending order.
        //

    case ALLOCATE_MISSES:
        return L2->AllocateMisses - L1->AllocateMisses;
        break;

        //
        // Sort by current depth in descending order.
        //

    case CURRENT_DEPTH:
        return L2->CurrentDepth - L1->CurrentDepth;
        break;

        //
        // Sort by maximum depth in descending order.
        //

    case MAXIMUM_DEPTH:
        return L2->MaximumDepth - L1->MaximumDepth;
        break;

        //
        // Sort by allocation rate in descending order.
        //

    case RATE:
        return L2->AllocateRate - L1->AllocateRate;
        break;

        //
        // Sort by tag, type, and size.
        //

    case TAG:
        U1 = *C1++ - *C2++;
        if (U1 == 0) {
            U1 = *C1++ - *C2++;
            if (U1 == 0) {
                U1 = *C1++ - *C2++;
                if (U1 == 0) {
                    U1 = *C1 - *C2;
                    if (U1 == 0) {
                        U1 = L1->Type - L2->Type;
                        if (U1 == 0) {
                            U1 = L1->Size - L2->Size;
                        }
                    }
                }
            }
        }

        return U1;
        break;
    }

    return 0;
}

LOGICAL
CheckSingleFilter (
    PUCHAR Tag,
    PUCHAR Filter
    )

{
    UCHAR Fc;
    ULONG Index;
    UCHAR Tc;

    //
    // Check if tag matches filter.
    //

    for (Index = 0; Index < 4; Index += 1) {
        Fc = *Filter++;
        Tc = *Tag++;
        if (Fc == '*') {
             return TRUE;

        } else if (Fc == '?') {
            continue;

        } else if (Fc != Tc) {
            return FALSE;
        }
    }

    return TRUE;
}

LOGICAL
CheckFilters (
    PUCHAR Tag
    )

{

    ULONG Index;
    LOGICAL Pass;

    //
    // If there are no filters, then all tags pass. Otherwise, tags pass or
    // do not pass based on whether they are included or excluded.
    //

    Pass = TRUE;
    if (FilterCount != 0) {

        //
        // If the first filter excludes tags, then any tag not explicitly
        // specified passes. If the first filter includes tags, then any
        // tag not explicitly specified fails.
        //

        Pass = Filter[0].Exclude;
        for (Index = 0; Index < FilterCount; Index += 1) {
            if (CheckSingleFilter(Tag, (PUCHAR)&Filter[Index].Tag) != FALSE) {
                Pass = !Filter[Index].Exclude;
                break;
            }
        }
    }

    return Pass;
}

VOID
AddFilter (
    BOOLEAN Exclude,
    PCHAR FilterString
    )

{

    PFILTER f;
    ULONG i;
    PCHAR p;

    if (FilterCount == MAX_FILTER) {
        printf("Too many filters specified.  Limit is %d\n", MAX_FILTER);
        return;
    }

    f = &Filter[FilterCount];
    p = f->Tag;

    for (i = 0; i < 4; i++) {
        if (*FilterString == 0) {
            break;
        }

        *p++ = *FilterString++;
    }

    for (; i < 4; i++) {
        *p++ = ' ';
    }

    f->Exclude = Exclude;
    FilterCount += 1;
    return;
}

VOID
ParseArgs (
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    This function parses the input arguments and sets global state variables.

Arguments:

    argc - Supplies the number of argument strings.

    argv - Supplies a pointer to an array of pointers to argument strings.

Return Value:

    None.

--*/

{

    char *p;
    BOOLEAN exclude;

    argc -= 1;
    argv += 1;
    while (argc-- > 0) {
        p  = *argv++;
        if (*p == '-' || *p == '/') {
            p++;
            exclude = TRUE;
            switch (tolower(*p)) {
            case 'i':
                exclude = FALSE;
            case 'x':
                p++;
                if (strlen(p) == 0) {
                    printf("missing filter string\n");
                    ExitProcess(1);

                } else if (strlen(p) > sizeof(ULONG)) {
                    printf("filter string too long: %s\n", p);
                    ExitProcess(1);
                }

                AddFilter(exclude, p);
                break;

            default:
                printf("unknown switch: %s\n", p);
                ExitProcess(2);
            }

        } else {
            printf("unknown switch: %s\n", p);
            ExitProcess(2);
        }
    }

    return;
}

LOGICAL
WriteConsoleLine(
    HANDLE OutputHandle,
    WORD LineNumber,
    LPSTR Text,
    LOGICAL Highlight
    )

{

    COORD WriteCoord;
    DWORD NumberWritten;
    DWORD TextLength;

    WriteCoord.X = 0;
    WriteCoord.Y = LineNumber;
    if (!FillConsoleOutputCharacter(OutputHandle,
                                    ' ',
                                    NumberOfCols,
                                    WriteCoord,
                                    &NumberWritten)) {
        return FALSE;
    }

    if (!FillConsoleOutputAttribute(OutputHandle,
                                    (WORD)((Highlight && !NoHighlight) ? HighlightAttribute : NormalAttribute),
                                    NumberOfCols,
                                    WriteCoord,
                                    &NumberWritten)) {
        return FALSE;
    }


    if (Text == NULL || (TextLength = strlen(Text)) == 0) {
        return TRUE;

    } else {
        return WriteConsoleOutputCharacter(OutputHandle,
                                           Text,
                                           TextLength,
                                           WriteCoord,
                                           &NumberWritten);
    }
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    This function is the main program entry.

Arguments:

    argc - Supplies the number of argument strings.

    argv - Supplies a pointer to an array of pointers to argument strings.

Return Value:

    Final execution status.

--*/

{

    SIZE_T ActiveNumber;
    CHAR Buffer[512];
    SYSTEM_BASIC_INFORMATION BasicInfo;
    PULONG CurrentBuffer;
    ULONG GeneralNonpagedTotal;
    ULONG GeneralPagedTotal;
    SIZE_T Index;
    BOOLEAN Interactive;
    ULONG Length;
    ULONG LinesInHeader;
    PSYSTEM_LOOKASIDE_INFORMATION LookasideNew;
    PSYSTEM_LOOKASIDE_INFORMATION LookasideOld;
    HANDLE OriginalOutputHandle;
    PLOOKASIDE_OUTPUT Output;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    ULONG PoolNonpagedTotal;
    ULONG PoolPagedTotal;
    PULONG PreviousBuffer;
    NTSTATUS Status;
    PULONG TempBuffer;
    BOOLEAN DoHelp;
    BOOLEAN DoQuit;
    UCHAR LastKey;
    LONG ScrollDelta;
    WORD DisplayLine;
    UCHAR T1;
    UCHAR T2;
    UCHAR T3;
    UCHAR T4;

    //
    // Parse command line arguments.
    //

    DoHelp = FALSE;
    DoQuit = FALSE;
    Interactive = TRUE;
    ParseArgs(argc, argv);

    //
    // Get input and output handles.
    //

    InputHandle = GetStdHandle(STD_INPUT_HANDLE);
    OriginalOutputHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    if (InputHandle == NULL ||
        OriginalOutputHandle == NULL ||
        !GetConsoleMode(InputHandle, &OriginalInputMode)) {
        Interactive = FALSE;

    } else {
        OutputHandle = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                                 FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                 NULL,
                                                 CONSOLE_TEXTMODE_BUFFER,
                                                 NULL);

        if (OutputHandle == NULL ||
            !GetConsoleScreenBufferInfo(OriginalOutputHandle, &OriginalConsoleInfo) ||
            !SetConsoleScreenBufferSize(OutputHandle, OriginalConsoleInfo.dwSize) ||
            !SetConsoleActiveScreenBuffer(OutputHandle) ||
            !SetConsoleMode(InputHandle, 0)) {
            if (OutputHandle != NULL) {
                CloseHandle(OutputHandle);
                OutputHandle = NULL;
            }

            Interactive = FALSE;

        } else {
            NormalAttribute = 0x1F;
            HighlightAttribute = 0x71;
            NumberOfCols = OriginalConsoleInfo.dwSize.X;
            NumberOfRows = OriginalConsoleInfo.dwSize.Y;
        }
    }

    NtQuerySystemInformation(SystemBasicInformation,
                             &BasicInfo,
                             sizeof(BasicInfo),
                             NULL);

    //
    // If the priority class on the current process is normal, then raise
    // the priority class to high.
    //

    if (GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
        SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
    }

    //
    // Continuously display the lookaside information until an exit signal
    // is received.
    //

    CurrentBuffer = &LargeBuffer1[0];
    PreviousBuffer = &LargeBuffer2[0];
    while(TRUE) {
        Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                          &PerfInfo,
                                          sizeof(PerfInfo),
                                          NULL);

        if (!NT_SUCCESS(Status)) {
            printf("Query performance information failed %lx\n", Status);
            break;
        }


        //
        // Query system lookaside information.
        //

        Status = NtQuerySystemInformation(SystemLookasideInformation,
                                          CurrentBuffer,
                                          BUFFER_SIZE,
                                          &Length);

        if (!NT_SUCCESS(Status)) {
            printf("Query lookaside information failed %lx\n", Status);
            break;
        }

        //
        // Compute total memory allocated to paged and nonpaged lookaside
        // lists.
        //

        Length /= sizeof(SYSTEM_LOOKASIDE_INFORMATION);
        LookasideNew = (PSYSTEM_LOOKASIDE_INFORMATION)CurrentBuffer;
        GeneralNonpagedTotal = 0;
        GeneralPagedTotal = 0;
        PoolNonpagedTotal = 0;
        PoolPagedTotal = 0;
        for (Index = 0; Index < Length; Index += 1) {
            if ((LookasideNew->Tag == 'looP') ||
                (LookasideNew->Tag == 'LooP')) {
                if (LookasideNew->Type == NONPAGED) {
                    PoolNonpagedTotal +=
                        (LookasideNew->CurrentDepth * LookasideNew->Size);

                } else {
                    PoolPagedTotal +=
                        (LookasideNew->CurrentDepth * LookasideNew->Size);
                }

            } else {
                if (LookasideNew->Type == NONPAGED) {
                    GeneralNonpagedTotal +=
                        (LookasideNew->CurrentDepth * LookasideNew->Size);

                } else {
                    GeneralPagedTotal +=
                        (LookasideNew->CurrentDepth * LookasideNew->Size);
                }
            }

            LookasideNew += 1;
        }

        //
        // Output total memory and available memory in kbytes.
        //

        DisplayLine = 0;
        sprintf(Buffer,
                " Total Memory: %ldkb Available Memory: %ldkb",
                BasicInfo.NumberOfPhysicalPages * (BasicInfo.PageSize / 1024),
                PerfInfo.AvailablePages * (BasicInfo.PageSize / 1024));

        WriteConsoleLine(OutputHandle,
                         DisplayLine++,
                         Buffer,
                         FALSE);

        //
        // Output total memory reserved for nonpaged and paged pool.
        //

        sprintf(Buffer,
                " Pool    Memory - Nonpaged: %ldkb Paged: %ldkb",
                PerfInfo.NonPagedPoolPages * (BasicInfo.PageSize / 1024),
                PerfInfo.PagedPoolPages * (BasicInfo.PageSize / 1024));

        WriteConsoleLine(OutputHandle,
                         DisplayLine++,
                         Buffer,
                         FALSE);

        //
        // Output total memory allocated for nonpaged and paged lookaside
        // lists.
        //

        sprintf(Buffer,
                " Pool    Lookaside - Nonpaged: %ldkb Paged: %ldkb",
                PoolNonpagedTotal / 1024,
                PoolPagedTotal / 1024);

        WriteConsoleLine(OutputHandle,
                         DisplayLine++,
                         Buffer,
                         FALSE);

        sprintf(Buffer,
                " General Lookaside - Nonpaged: %ldkb Paged: %ldkb",
                GeneralNonpagedTotal / 1024,
                GeneralPagedTotal / 1024);

        WriteConsoleLine(OutputHandle,
                         DisplayLine++,
                         Buffer,
                         FALSE);

        //
        // Output report headings.
        //

        WriteConsoleLine(OutputHandle,
                         DisplayLine++,
                         " Tag  Type Size CurDp MaxDp Allocates Rate   Frees   Rate  A-Hits A-Misses",
                         FALSE);

        WriteConsoleLine(OutputHandle,
                         DisplayLine++,
                         NULL,
                         FALSE);

        //
        // Extract the specified lookaside information.
        //

        LinesInHeader = DisplayLine;
        LookasideNew = (PSYSTEM_LOOKASIDE_INFORMATION)CurrentBuffer;
        LookasideOld = (PSYSTEM_LOOKASIDE_INFORMATION)PreviousBuffer;
        Output = &OutputBuffer[0];
        for (Index = 0; Index < Length; Index += 1) {

            //
            // Check if the tag should be extracted.
            //

            if (!CheckFilters((PUCHAR)&LookasideNew[Index].Tag)) {
                continue;
            }

            //
            // Check if the lookaside information should be extracted.
            //

            if ((DisplayType == BOTH) ||
                ((LookasideNew[Index].Type == 0) && (DisplayType == NONPAGED)) ||
                ((LookasideNew[Index].Type != 0) && (DisplayType == PAGED))) {
                Output->CurrentDepth = LookasideNew[Index].CurrentDepth;
                Output->MaximumDepth = LookasideNew[Index].MaximumDepth;
                Output->Allocates = LookasideNew[Index].TotalAllocates;
                Output->AllocateRate = Output->Allocates - LookasideNew[Index].AllocateMisses;
                if (Output->Allocates != 0) {
                    Output->AllocateRate = (Output->AllocateRate * 100) / Output->Allocates;
                }

                Output->Frees = LookasideNew[Index].TotalFrees;
                Output->FreeRate = Output->Frees - LookasideNew[Index].FreeMisses;
                if (Output->Frees != 0) {
                    Output->FreeRate = (Output->FreeRate * 100) / Output->Frees;
                }

                Output->Tag = LookasideNew[Index].Tag;
                Output->Type = LookasideNew[Index].Type;
                Output->Size = LookasideNew[Index].Size;
                if (LookasideNew[Index].Tag == LookasideOld[Index].Tag) {
                    Output->Changed =
                        LookasideNew[Index].CurrentDepth != LookasideOld[Index].CurrentDepth;

                    Output->AllocateMisses =
                        LookasideNew[Index].AllocateMisses - LookasideOld[Index].AllocateMisses;

                    Output->AllocateHits =
                        LookasideNew[Index].TotalAllocates - LookasideOld[Index].TotalAllocates - Output->AllocateMisses;

                } else {
                    Output->Changed = FALSE;
                    Output->AllocateHits = 0;
                    Output->AllocateMisses = 0;
                }

                Output += 1;
            }
        }

        //
        // Sort the extracted lookaside information.
        //

        ActiveNumber = Output - &OutputBuffer[0];
        qsort((void *)&OutputBuffer,
              (size_t)ActiveNumber,
              (size_t)sizeof(LOOKASIDE_OUTPUT),
              ulcomp);

        //
        // Display the selected information.
        //

        for (Index = FirstDetailLine; Index < ActiveNumber; Index += 1) {
            if (DisplayLine >= NumberOfRows) {
                break;
            }

            //
            // Check to make sure the tag is displayable.
            //

            if ((OutputBuffer[Index].Tag == 0) ||
                (OutputBuffer[Index].Tag == '    ')) {
                OutputBuffer[Index].Tag = 'nknU';
            }

            T1 = (UCHAR)(OutputBuffer[Index].Tag & 0xff);
            T2 = (UCHAR)((OutputBuffer[Index].Tag >> 8) & 0xff);
            T3 = (UCHAR)((OutputBuffer[Index].Tag >> 16) & 0xff);
            T4 = (UCHAR)((OutputBuffer[Index].Tag >> 24) & 0xff);
            if (T1 == 0) {
                T1 = ' ';
            }

            if (T2 == 0) {
                T2 = ' ';
            }

            if (T3 == 0) {
                T3 = ' ';
            }

            if (T4 == 0) {
                T4 = ' ';
            }

            if ((!isalpha(T1) && (T1 != ' ')) ||
                (!isalpha(T2) && (T2 != ' ')) ||
                (!isalpha(T3) && (T3 != ' ')) ||
                (!isalpha(T4) && (T4 != ' '))) {

                OutputBuffer[Index].Tag = 'nknU';
            }

            sprintf(Buffer,
                    " %c%c%c%c %4s %4ld %5ld %5ld %9ld %3ld%% %9ld %3ld%%  %6ld  %6ld",
                    T1,
                    T2,
                    T3,
                    T4,
                    PoolType[OutputBuffer[Index].Type],
                    OutputBuffer[Index].Size,
                    OutputBuffer[Index].CurrentDepth,
                    OutputBuffer[Index].MaximumDepth,
                    OutputBuffer[Index].Allocates,
                    OutputBuffer[Index].AllocateRate,
                    OutputBuffer[Index].Frees,
                    OutputBuffer[Index].FreeRate,
                    OutputBuffer[Index].AllocateHits,
                    OutputBuffer[Index].AllocateMisses);

            WriteConsoleLine(OutputHandle,
                             DisplayLine++,
                             Buffer,
                             OutputBuffer[Index].Changed);
        }

        //
        // If the entire screen is not filled by the selected information,
        // then fill the rest of the screen with blank lines.
        //

        while (DisplayLine < NumberOfRows) {
            WriteConsoleLine(OutputHandle,
                             DisplayLine++,
                             "",
                             FALSE);
        }

        //
        // Wait for input or timeout.
        //

        TempBuffer = PreviousBuffer;
        PreviousBuffer = CurrentBuffer;
        CurrentBuffer = TempBuffer;
        while (WaitForSingleObject(InputHandle, DelayTimeMsec) == STATUS_WAIT_0) {

            //
            // Check for input record
            //

            if (ReadConsoleInput(InputHandle, &InputRecord, 1, &NumberOfInputRecords) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown) {
                LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;
                if (LastKey<' ') {
                    ScrollDelta = 0;
                    if (LastKey == 'C'-'A' + 1) {
                        DoQuit = TRUE;

                    } else switch (InputRecord.Event.KeyEvent.wVirtualKeyCode) {
                        case VK_ESCAPE:
                            DoQuit = TRUE;
                            break;

                        case VK_PRIOR:
                            ScrollDelta = -(LONG)(InputRecord.Event.KeyEvent.wRepeatCount * NumberOfRows);
                            break;

                        case VK_NEXT:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount * NumberOfRows;
                            break;

                        case VK_UP:
                            ScrollDelta = -InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_DOWN:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_HOME:
                            FirstDetailLine = 0;
                            break;

                        case VK_END:
                            if (ActiveNumber <= (NumberOfRows - LinesInHeader)) {
                                FirstDetailLine = 0;

                            } else {
                                FirstDetailLine = ActiveNumber - NumberOfRows + LinesInHeader;
                            }

                            break;
                    }

                    if (ScrollDelta != 0) {
                        if (ScrollDelta < 0) {
                            if (FirstDetailLine <= (ULONG)-ScrollDelta) {
                                FirstDetailLine = 0;

                            } else {
                                FirstDetailLine += ScrollDelta;
                            }

                        } else {
                            if ((ActiveNumber + LinesInHeader) > NumberOfRows) {
                                FirstDetailLine += ScrollDelta;
                                if (FirstDetailLine >= (ActiveNumber - NumberOfRows + LinesInHeader)) {
                                    FirstDetailLine = ActiveNumber - NumberOfRows + LinesInHeader;
                                }
                            }
                        }
                    }

                } else {
                    switch (toupper( LastKey )) {
                    case 'Q':
                        DoQuit = TRUE;
                        break;

                    case 'A':
                        SortBy = TOTAL_ALLOCATES;
                        FirstDetailLine = 0;
                        break;

                    case 'C':
                        SortBy = CURRENT_DEPTH;
                        FirstDetailLine = 0;
                        break;

                    case 'H':
                    case '?':
                        DoHelp = TRUE;
                        break;

                    case 'L':
                        NoHighlight = 1 - NoHighlight;
                        break;

                    case 'M':
                        SortBy = MAXIMUM_DEPTH;
                        FirstDetailLine = 0;
                        break;

                    case 'P':
                        DisplayType += 1;
                        if (DisplayType > BOTH) {
                            DisplayType = NONPAGED;
                        }
                        FirstDetailLine = 0;
                        break;

                    case 'R':
                        SortBy = RATE;
                        FirstDetailLine = 0;
                        break;

                    case 'S':
                        SortBy = ALLOCATE_MISSES;
                        FirstDetailLine = 0;
                        break;

                    case 'T':
                        SortBy = TAG;
                        FirstDetailLine = 0;
                        break;

                    case 'X':
                        SortBy = ALLOCATE_HITS;
                        FirstDetailLine = 0;
                        break;
                    }
                }

                break;
            }
        }

        if (DoQuit) {
            break;
        }

        if (DoHelp) {
            DoHelp = FALSE;
            ShowHelpPopup();
        }
    }

    if (Interactive) {
        SetConsoleActiveScreenBuffer(OriginalOutputHandle);
        SetConsoleMode(InputHandle, OriginalInputMode);
        CloseHandle(OutputHandle);
    }

    ExitProcess(0);
    return 0;
}


VOID
ShowHelpPopup(
    VOID
    )

{

    HANDLE PopupHandle;
    WORD n;

    PopupHandle = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                            FILE_SHARE_WRITE | FILE_SHARE_READ,
                                            NULL,
                                            CONSOLE_TEXTMODE_BUFFER,
                                            NULL);
    if (PopupHandle == NULL) {
        return;
    }

    SetConsoleActiveScreenBuffer( PopupHandle );

    n = 0;

    WriteConsoleLine(PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine(PopupHandle, n++, "                        Lookaside Monitor Help", FALSE);
    WriteConsoleLine(PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine(PopupHandle, n++, " columns:", FALSE );
    WriteConsoleLine(PopupHandle, n++, "   Tag is the four character name of the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   Type is page(d) or nonp(aged)", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   Size is size of the pool allocation in bytes", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   CurDp is the current depth of the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   MaxDp is the maximum depth of the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   Allocates is the total number of allocations from the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   Rate is the percent of allocates that hit in the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   Frees is the total number of frees to the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   Rate is the percent of frees that hit in the lookaside list", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   A-Hits is the number of allocation hits within the display period", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   A-Misses is the number of allocation misses within the display period", FALSE);
    WriteConsoleLine(PopupHandle, n++, NULL, FALSE);
    WriteConsoleLine(PopupHandle, n++, " switches:", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   ? or h - gives this help", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   l - toggles highlighting of changed lines on and off", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   q - quits", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   p - toggles default pool display between both, page(d), and nonp(aged)", FALSE);
    WriteConsoleLine(PopupHandle, n++, NULL, FALSE);
    WriteConsoleLine(PopupHandle, n++, " sorting switches:", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   a - sort by total allocations", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   c - sort by current depth", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   m - sort by maximum depth", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   r - sort by allocation hit rate", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   s - sort by allocate misses", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   t - sort by tag, type, and size", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   x - sort by allocate hits", FALSE);
    WriteConsoleLine(PopupHandle, n++, NULL, FALSE);
    WriteConsoleLine(PopupHandle, n++, " command line switches", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   -i<tag> - list only matching tags", FALSE);
    WriteConsoleLine(PopupHandle, n++, "   -x<tag> - list everything except matching tags", FALSE);
    WriteConsoleLine(PopupHandle, n++, "           <tag> can include * and ?", FALSE);
    WriteConsoleLine(PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine(PopupHandle, n++, NULL, FALSE );

    while (TRUE) {
        if (WaitForSingleObject(InputHandle, DelayTimeMsec) == STATUS_WAIT_0 &&
            ReadConsoleInput(InputHandle, &InputRecord, 1, &NumberOfInputRecords) &&
            InputRecord.EventType == KEY_EVENT &&
            InputRecord.Event.KeyEvent.bKeyDown &&
            InputRecord.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE
           ) {
            break;
        }
    }

    SetConsoleActiveScreenBuffer(OutputHandle);
    CloseHandle(PopupHandle);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmtr\drivers.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   kernprof.c

Abstract:

    This module contains a dumper of the drivers loaded in the current system.

Usage:

    drivers

Author:

    Mark Lucovsky (markl) 15-Mar-1993

Envirnoment:



Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

typedef struct _MODULE_DATA {
    ULONG CodeSize;
    ULONG DataSize;
    ULONG BssSize;
    ULONG RoDataSize;
    ULONG ImportDataSize;
    ULONG ExportDataSize;
    ULONG ResourceDataSize;
    ULONG PagedSize;
    ULONG InitSize;
    ULONG CheckSum;
    ULONG TimeDateStamp;
} MODULE_DATA, *PMODULE_DATA;

typedef struct _LOADED_IMAGE {
    PUCHAR MappedAddress;
    PIMAGE_NT_HEADERS FileHeader;
    PIMAGE_SECTION_HEADER LastRvaSection;
    int NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
} LOADED_IMAGE, *PLOADED_IMAGE;


VOID
SumModuleData(
    PMODULE_DATA Sum,
    PMODULE_DATA Current
    )
{
    Sum->CodeSize           += Current->CodeSize;
    Sum->DataSize           += Current->DataSize;
    Sum->BssSize            += Current->BssSize;
    Sum->RoDataSize         += Current->RoDataSize;
    Sum->ImportDataSize     += Current->ImportDataSize;
    Sum->ExportDataSize     += Current->ExportDataSize;
    Sum->ResourceDataSize   += Current->ResourceDataSize;
    Sum->PagedSize          += Current->PagedSize;
    Sum->InitSize           += Current->InitSize;
}
VOID
PrintModuleSeperator(
    VOID
    )
{
    printf("------------------------------------------------------------------------------\n");
}

VOID
PrintModuleHeader(
    VOID
    )
{
    printf("  ModuleName    Code    Data     Bss   Paged    Init          LinkDate\n");
    PrintModuleSeperator();
}

VOID
PrintModuleLine(
    LPSTR ModuleName,
    PMODULE_DATA Current
    )
{
    printf("%12s %7d %7d %7d %7d %7d  %s",
        ModuleName,
        Current->CodeSize,
        Current->DataSize,
        Current->BssSize,
        Current->PagedSize,
        Current->InitSize,
        Current->TimeDateStamp ? ctime((time_t *)&Current->TimeDateStamp) : "\n"
        );
}

VOID
GetModuleData(
    HANDLE hFile,
    PMODULE_DATA Mod
    )
{
    HANDLE hMappedFile;
    PIMAGE_DOS_HEADER DosHeader;
    LOADED_IMAGE LoadedImage;
    ULONG SectionAlignment;
    PIMAGE_SECTION_HEADER Section;
    int i;
    ULONG Size;

    hMappedFile = CreateFileMapping(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        return;
    }

    LoadedImage.MappedAddress = MapViewOfFile(
                                    hMappedFile,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    0
                                    );
    CloseHandle(hMappedFile);

    if ( !LoadedImage.MappedAddress ) {
        return;
    }

    //
    // Everything is mapped. Now check the image and find nt image headers
    //

    DosHeader = (PIMAGE_DOS_HEADER)LoadedImage.MappedAddress;

    if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE ) {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return;
    }

    LoadedImage.FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

    if ( LoadedImage.FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return;
    }

    LoadedImage.NumberOfSections = LoadedImage.FileHeader->FileHeader.NumberOfSections;
    LoadedImage.Sections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)LoadedImage.FileHeader + sizeof(IMAGE_NT_HEADERS));
    LoadedImage.LastRvaSection = LoadedImage.Sections;

    //
    // Walk through the sections and tally the dater
    //

    SectionAlignment = LoadedImage.FileHeader->OptionalHeader.SectionAlignment;

    for(Section = LoadedImage.Sections,i=0; i<LoadedImage.NumberOfSections; i++,Section++) {
        Size = Section->Misc.VirtualSize;

        if (Size == 0) {
            Size = Section->SizeOfRawData;
        }

        Size = (Size + SectionAlignment - 1) & ~(SectionAlignment - 1);

        if (!_strnicmp(Section->Name,"PAGE", 4 )) {
            Mod->PagedSize += Size;
        }
        else if (!_stricmp(Section->Name,"INIT" )) {
            Mod->InitSize += Size;
        }
        else if (!_stricmp(Section->Name,".bss" )) {
            Mod->BssSize = Size;
        }
        else if (!_stricmp(Section->Name,".edata" )) {
            Mod->ExportDataSize = Size;
        }
        else if (!_stricmp(Section->Name,".idata" )) {
            Mod->ImportDataSize = Size;
        }
        else if (!_stricmp(Section->Name,".rsrc" )) {
            Mod->ResourceDataSize = Size;
        }
        else if (Section->Characteristics & IMAGE_SCN_MEM_EXECUTE) {
            Mod->CodeSize += Size;
        }
        else if (Section->Characteristics & IMAGE_SCN_MEM_WRITE) {
            Mod->DataSize += Size;
        }
        else if (Section->Characteristics & IMAGE_SCN_MEM_READ) {
            Mod->RoDataSize += Size;
        }
        else {
            Mod->DataSize += Size;
        }
    }

    Mod->CheckSum = LoadedImage.FileHeader->OptionalHeader.CheckSum;
    Mod->TimeDateStamp = LoadedImage.FileHeader->FileHeader.TimeDateStamp;

    UnmapViewOfFile(LoadedImage.MappedAddress);
    return;

}

LONGLONG ModuleInfo[16384];

__cdecl main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    UINT BytesRequired;
    ULONG i;
    PCHAR s;
    HANDLE FileHandle;
    CHAR KernelPath[MAX_PATH];
    CHAR DriversPath[MAX_PATH];
    ULONG ReturnedLength;
    PRTL_PROCESS_MODULES Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;
    NTSTATUS Status;
    MODULE_DATA Sum;
    MODULE_DATA Current;

    //
    // Locate system drivers.
    //

    Status = NtQuerySystemInformation (
                    SystemModuleInformation,
                    ModuleInfo,
                    sizeof( ModuleInfo ),
                    &ReturnedLength);

    if (!NT_SUCCESS(Status)) {
        printf("query system info failed status - %lx\n",Status);
        return(Status);
    }

    BytesRequired = GetSystemDirectory(KernelPath,sizeof(KernelPath));
    if ((BytesRequired == 0) || (BytesRequired > MAX_PATH - sizeof(WCHAR))) {
        return STATUS_NAME_TOO_LONG;
    }

    strcpy(DriversPath,KernelPath);
    strcat(DriversPath,"\\Drivers");
    ZeroMemory(&Sum,sizeof(Sum));
    PrintModuleHeader();

    Modules = (PRTL_PROCESS_MODULES)ModuleInfo;
    Module = &Modules->Modules[ 0 ];
    for (i=0; i<Modules->NumberOfModules; i++) {

        ZeroMemory(&Current,sizeof(Current));
        s = &Module->FullPathName[ Module->OffsetToFileName ];

        //
        // try to open the file
        //

        SetCurrentDirectory(KernelPath);

        FileHandle = CreateFile(
                        s,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

        if ( FileHandle == INVALID_HANDLE_VALUE ) {
            SetCurrentDirectory(DriversPath);

            FileHandle = CreateFile(
                            s,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL
                            );

            if ( ( FileHandle == INVALID_HANDLE_VALUE ) && ( argc > 1 ) ) {
                SetCurrentDirectory( argv[1] );

                FileHandle = CreateFile(
                                s,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL
                                );

            }
        }

        if ( FileHandle != INVALID_HANDLE_VALUE ) {
            GetModuleData(FileHandle,&Current);
            CloseHandle(FileHandle);
        }

        SumModuleData(&Sum,&Current);
        PrintModuleLine(s,&Current);
        Module++;
    }
    PrintModuleSeperator();
    PrintModuleLine("Total",&Sum);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmtr\mminfo.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mminfo.c

Abstract:

    This module monitor the system hard page fault.

Author:

    Stephen Hsiao (shsiao) 4-8-96

Environment:

    User Mode

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define NTMMPERF 1
#if NTMMPERF
typedef enum _KTHREAD_STATE {
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition
    } KTHREAD_STATE;

char *ThreadState[] = {
    "Initialized",
    "Ready",
    "Running",
    "Standby",
    "Terminated",
    "Waiting",
    "Transition",
    };

char *WaitReason[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "WrExecutive",
    "WrFreePage",
    "WrPageIn",
    "WrPoolAllocation",
    "WrDelayExecution",
    "WrSuspended",
    "WrUserRequest",
    "WrEventPair",
    "WrQueue",
    "WrLpcReceive",
    "WrLpcReply",
    "WrVirtualMemory",
    "WrPageOut",
    "WrRendezvous",
    "Spare2",
    "Spare3",
    "Spare4",
    "Spare5",
    "Spare6",
    "WrKernel",
    "MaximumWaitReason"
    };

PSZ PoolTypeNames[7] = {
    "NonPagedPool",
    "PagedPool   ",
    "NonPagedMS  ",
    "NotUsed     ",
    "NonPagedCaAl",
    "PagedCaAl   ",
    "NonPCaAlMS  "
    };

#define CM_KEY_NODE_SIGNATURE     0x6b6e      // "kn"
#define CM_LINK_NODE_SIGNATURE    0x6b6c      // "kl"
#define CM_KEY_VALUE_SIGNATURE    0x6b76      // "kv"
#define CM_KEY_SECURITY_SIGNATURE 0x6b73      // "ks"
#define CM_KEY_FAST_LEAF          0x666c      // "fl"

#define MAX_TASKS           256
#define TableSize 4096
#define PAGE_SIZE 4096

#define PROTECTED_POOL 0x80000000

CHAR        Mark[MAX_MMINFO_MARK_SIZE];
DWORD       pid;
CHAR        pname[MAX_PATH];
CHAR        *MmInfoBuffer;
SYSTEM_MMINFO_FILENAME_INFORMATION        ImageHash[TableSize];
SYSTEM_MMINFO_PROCESS_INFORMATION         ProcessHash[TableSize];
LONG ThreadHash[TableSize] = {-1};
LONG       BufferLength;
BOOLEAN     Debug=FALSE;
ULONG       MmInfoOnFlag=0;
ULONG       DefaultOnFlag=(MMINFO_LOG_MEMORY | 
                           MMINFO_LOG_WORKINGSET | 
                           MMINFO_LOG_HARDFAULT |
                           MMINFO_LOG_PROCESS | 
                           MMINFO_LOG_THREAD);
ULONG       DefaultDetailedOnFlag=(MMINFO_LOG_MEMORY | 
                                   MMINFO_LOG_WORKINGSET | 
                                   MMINFO_LOG_HARDFAULT |
                                   MMINFO_LOG_SOFTFAULT |
                                   MMINFO_LOG_PROCESS | 
                                   MMINFO_LOG_THREAD |
                                   MMINFO_LOG_CSWITCH |
                                   MMINFO_LOG_POOL |
                                   MMINFO_LOG_CHANGELIST);

#ifdef WS_INSTRUMENTATION
char * WsInfoHeaderFormat =
"    WsInfo,                 Process,  WorkSet,    Claim,   Access,     Age0,     Age1,     Age2,     Age3,   Shared,      Mod,   Faults,  RecentF,     Repl,    URepl,   Boosts,     Prio\n";

char * WsInfoDataFormat =
"    WsInfo, %24s, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d\n";

char * TrimHeaderFormat =
"      Trim,                 Process,  WorkSet,    Claim,      Try,      Got,   Faults,  RecentF,     Repl,    URepl,   Boosts,     Prio\n";

char * TrimDataFormat =
"      Trim, %24s, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %8d\n";

char * WsManagerHeaderFormat =
" WsManager,       Time,    Avail,    Claim,   Faults,   LastPF,  Counter, DesReduc,   DesFree, Action\n";

char * WsManagerDataFormat =
" WsManager, %10I64d, %8d, %8d, %8d, %8d, %8d, %8d, %8d, %s\n";

#else
char * WsInfoHeaderFormat =
"    WsInfo,                 Process,  WorkSet,   Faults,     Prio\n";

char * WsInfoDataFormat =
"    WsInfo, %24s, %8d, %8d, %8d\n";

char * TrimHeaderFormat =
"      Trim,                 Process,  WorkSet,   Faults,     Prio\n";

char * TrimDataFormat =
"      Trim, %24s, %8d, %8d, %8d\n";

char * WsManagerHeaderFormat =
" WsManager,       Time,    Avail,   Faults,   LastPF,  Counter, DesReduc,   DesFree, Action\n";

char * WsManagerDataFormat =
" WsManager, %10I64d, %8d, %8d, %8d, %8d, %8d, %8d, %s\n";

#endif // WS_INSTRUMENTATION
char * ImageLoadHeaderFormat =
" ImageLoad, BaseAddr,  EndAddr,  SectNum, Process, Name\n";

char * ImageLoadDataFormat =
" ImageLoad, %08x, %08x, %-8x, %s, %S\n";

char * SampleProfileHeaderFormat =
" SampledProfile,      EIP,  Count\n";

char * SampledProfileDataFormat =
" SampledProfile, %08x, %-8d\n";

char * GeneralHeaderFormat = "%12s,%10s,%22s,%12s,%12s,%8s,%30s,%12s,%10s,%10s,%10s\n";

ULONG       ToTurnOn=0;
ULONG       ToTurnOff=0;

CHAR System[] = "System";

#define MODE_NONE   0
#define MODE_SLASH  1
#define MODE_PLUS   2
#define MODE_MINUS  3


typedef struct Api_Address_St {
  ULONG Address;
  CHAR  *ApiName;
} Api_Address_t, *PApi_Address_t;

typedef struct Dll_Address_St {
  ULONG StartingAddress;
  ULONG EndingAddress;
  CHAR *DllName;
} Dll_Address_t, *PDll_Address_t;

PApi_Address_t GlobalApiInfo;
PDll_Address_t GlobalDllInfo;
int NumGlobalApis=0;
int NumGlobalDlls=0;
int NumAllocatedGlobalApis=0;
int NumAllocatedGlobalDlls=0;
#define AllocationIncrement 1000

VOID InsertDll(ULONG StartingAddress, ULONG EndingAddress, CHAR *DllName){

  if (NumGlobalDlls == NumAllocatedGlobalDlls ){
    if (NumGlobalDlls == 0 ){
      NumAllocatedGlobalDlls = AllocationIncrement;
      GlobalDllInfo = (PDll_Address_t)
        malloc( sizeof(Dll_Address_t) * NumAllocatedGlobalDlls);
    } else {
      NumAllocatedGlobalDlls += AllocationIncrement;
      GlobalDllInfo = (PDll_Address_t)
        realloc( GlobalDllInfo, sizeof(Dll_Address_t) * NumAllocatedGlobalDlls);
    }
  }
  if (GlobalDllInfo == NULL ){
    return;
  }
  GlobalDllInfo[ NumGlobalDlls ].StartingAddress = StartingAddress;
  GlobalDllInfo[ NumGlobalDlls ].EndingAddress   = EndingAddress;
  GlobalDllInfo[ NumGlobalDlls ].DllName         = DllName;
  NumGlobalDlls ++;
}

VOID InsertApi(ULONG Address, CHAR *ApiName){
  if (NumGlobalApis == NumAllocatedGlobalApis ){
    if (NumGlobalApis == 0 ){
      NumAllocatedGlobalApis = AllocationIncrement;
      GlobalApiInfo = (PApi_Address_t)
        malloc( sizeof(Api_Address_t) * NumAllocatedGlobalApis);
    } else {
      NumAllocatedGlobalApis += AllocationIncrement;
      GlobalApiInfo = (PApi_Address_t)
        realloc( GlobalApiInfo, sizeof(Api_Address_t) * NumAllocatedGlobalApis);
    }
  }
  if (GlobalApiInfo == NULL ){
    return;
  }
  GlobalApiInfo[ NumGlobalApis ].Address = Address;
  GlobalApiInfo[ NumGlobalApis ].ApiName = ApiName;
  NumGlobalApis ++;
}
CHAR *DllContainingAddress(ULONG Address){
  int i;
  for(i=0; i < NumGlobalDlls; i++){
    if ( GlobalDllInfo[ i ].StartingAddress <= Address &&
         Address <= GlobalDllInfo[ i ].EndingAddress){
      return   GlobalDllInfo[ i ].DllName;
    }
  }
  return "DllNotFound";
}
CHAR *ApiAtAddress(ULONG Address){
  int i;
  for(i=0; i < NumGlobalApis; i++){
    if ( GlobalApiInfo[ i ].Address == Address ){
      return   GlobalApiInfo[ i ].ApiName;
    }
  }
  return "ApiNotFound";
}


VOID
ParseArgs (
    int argc,
    char *argv[]
    )
{
    ULONG   Mode=MODE_NONE;
    char *p;
    char *Usage="\
        Usage: mminfo -Option \n\
    /c      Turn OFF hard fault clustering\n\
    /i      Initialize MmInfo (Allocate buffer)\n\
    /u      Uninitialize MmInfo (Free buffer) \n\
    /d      Turn on debugging\n\
    /f      Turn off monitoring (Keep log for later processing) \n\
    /F      Set a Mark with workingsetflush now \n\
    /M      Set a Mark now \n\
    /o      Turn on default monitoring (h,m,t, and w)\n\
    /O      Turn on detailed monitoring (plus a, l, p, and S)\n\
    +/- a   Turn on/off context switch monitor\n\
    +/- e   Turn on/off EmptyQ on every Mark\n\
    +/- E   Turn on/off EmptyQDetail (Per Process footprint) on every Mark\n\
    +/- h   Turn on/off hard fault monitor\n\
    +/- l   Turn on/off memory list monitor\n\
    +/- m   Turn on/off memory monitor\n\
    +/- p   Turn on/off pool monitor\n\
    +/- P   Turn on/off sampled profiling\n\
    +/- r   Turn on/off registry monitor\n\
    +/- R   Turn on/off registry Relocation\n\
    +/- s   Turn on/off initial snap shot of memory\n\
    +/- S   Turn on/off Soft (Demand zero and Trainsition) fault monitor\n\
    +/- t   Turn on/off thread & process monitor\n\
    +/- T   Turn on/off detailed trimming monitor\n\
    +/- w   Turn on/off working set monitor\n\
    +/- z   Turn on/off detailed working set info\n\
    +/- Z   Turn on/off dumping working set entries\n\
    Default Dump bata (Also turn off monitoring)\n\
        ";
    NTSTATUS status;
    int i;

    argc--;
    *argv++;
    while ( argc-- > 0 ) {
        p  = *argv++;

        switch (*p) {
            case '/':
                Mode = MODE_SLASH;
                break;
            case '+':
                Mode = MODE_PLUS;
                break;
            case '-':
                Mode = MODE_MINUS;
                break;
            default:
                fprintf(stderr,"%s\n", Usage);
                ExitProcess(1);
        }
        p++;

        while(*p != '\0') {
            if (Mode == MODE_SLASH) {
                switch (*p) {
                case 'c':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_NO_CLUSTERING;
                    break;
                case 'd':
                    Debug=TRUE;
                    break;
                case 'f':
                    status = NtSetSystemInformation (
                                  SystemMmInfoLogOffInformation,
                                  NULL,
                                  0);
                    if (!NT_SUCCESS (status)) {
                        fprintf(stderr,"Set system information failed %lx\n",status);
                    }else{
                        fprintf(stderr,"Monitor Off\n");
                    }
                    ExitProcess(0);
                case 'i':
                    status = NtSetSystemInformation (
                                  SystemMmInfoInitializeInformation,
                                  NULL,
                                  0);
                    if (!NT_SUCCESS (status)) {
                        fprintf(stderr, "Set system information failed %lx\n",status);
                    }else{
                        fprintf(stderr,"buffer allocated\n");
                    }
                    ExitProcess(0);
                case 'F':
                case 'M':
                {
                    BOOLEAN Flush = (*p == 'F') ? TRUE : FALSE;
                    p++;
                    while(*p == '\0') {
                        p++;
                    }

                    i=-1;

                    if (*p == '/' || *p == '+' || *p == '-') {
                        // Nothing in the Mark
                        fprintf(stderr, "Mark not set!\n");
                        fprintf(stderr,"%s\n", Usage);
                        ExitProcess(0);
                    } else if (*p == '"') {
                        p++;
                        while(*p != '"') {
                            if (i < MAX_MMINFO_MARK_SIZE) {
                                i++;
                                Mark[i] = *p;
                            }
                            p++;
                        }
                    } else {
                        while (*p != '\0') {
                            if (i < MAX_MMINFO_MARK_SIZE) {
                                i++;
                                Mark[i] = *p;
                            }
                            p++;
                        }
                    }
                    
                    status = NtSetSystemInformation (
                                Flush ? SystemMmInfoMarkWithFlush
                                      : SystemMmInfoMark,
                                Mark,
                                MAX_MMINFO_MARK_SIZE);

                    if (!NT_SUCCESS (status)) {
                        fprintf(stderr, "Set system information failed %lx\n",status);
                    }else{
                        fprintf(stderr, "Mark set: %s\n", Mark);
                    }
                    ExitProcess(0);
                }
                case 'o':
                    MmInfoOnFlag = DefaultOnFlag;
                    break;
                case 'O':
                    MmInfoOnFlag = DefaultDetailedOnFlag;
                    break;
                case 'u':
                    status = NtSetSystemInformation (
                                  SystemMmInfoUnInitializeInformation,
                                  NULL,
                                  0);
                    if (!NT_SUCCESS (status)) {
                        fprintf(stderr,"Set system information failed %lx\n",status);
                    }else{
                        fprintf(stderr,"Unitialized\n");
                    }
                    ExitProcess(0);
                default:
                    fprintf(stderr,"%s\n", Usage);
                    ExitProcess(1);
                }
            } else if (Mode == MODE_PLUS) {
                switch (*p) {
                case 'a':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_PROCESS |
                                    MMINFO_LOG_THREAD | MMINFO_LOG_CSWITCH;
                    break;
                case 'e':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_MEMORY | MMINFO_LOG_EMPTYQ | MMINFO_LOG_PROCESS;
                    break;
                case 'E':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_MEMORY | MMINFO_LOG_EMPTYQ
                                        | MMINFO_LOG_EMPTYQDETAIL | MMINFO_LOG_PROCESS;
                    break;
                case 'm':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_MEMORY | MMINFO_LOG_PROCESS;
                    break;
                case 'p':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_POOL;
                    break;
                case 'w':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_WORKINGSET | MMINFO_LOG_PROCESS; 
                    break;
                case 't':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_PROCESS | MMINFO_LOG_THREAD;
                    break;
                case 'T':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_WSCHANGE | 
                               MMINFO_LOG_MEMORY | MMINFO_LOG_PROCESS; 
                    break;
                case 'h':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_HARDFAULT | MMINFO_LOG_PROCESS;
                    break;
                case 'l':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_CHANGELIST | MMINFO_LOG_MEMORY;
                    break;
                case 'r':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_REGISTRY;
                    break;
                case 'R':
                    status = NtSetSystemInformation (
                                  SystemRelocateCMCellOn,
                                  NULL,
                                  0);
                    if (!NT_SUCCESS (status)) {
                        fprintf(stderr,"Set system information failed %lx\n",status);
                    }else{
                        fprintf(stderr,"Registry Relocation on\n");
                    }
                    ExitProcess(0);
                case 's':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_INIT_MEMSNAP;
                    break;
                case 'S':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_SOFTFAULT | 
                               MMINFO_LOG_PROCESS | MMINFO_LOG_MEMORY;
                    break;
                case 'z':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_WSDETAILS;
                    break;
                case 'Z':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_WSENTRIES;
                    break;
                case 'P':
                    ToTurnOn = ToTurnOn | MMINFO_LOG_PROFILE;
                    break;
                default:
                    fprintf(stderr,"%s\n", Usage);
                    ExitProcess(1);
                }
            } else if (Mode == MODE_MINUS) {
                switch (*p) {
                case 'a':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_CSWITCH ;
                    break;
                case 'e':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_EMPTYQ;
                    break;
                case 'E':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_EMPTYQDETAIL;
                    break;
                case 'm':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_MEMORY ;
                    break;
                case 'p':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_POOL;
                    break;
                case 'w':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_WORKINGSET;
                    break;
                case 't':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_PROCESS |
                                        MMINFO_LOG_THREAD | MMINFO_LOG_CSWITCH;
                    break;
                case 'T':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_WSCHANGE;
                    break;
                case 'h':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_HARDFAULT;
                    break;
                case 'l':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_CHANGELIST;
                    break;
                case 'r':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_REGISTRY;
                    break;
                case 'R':
                    status = NtSetSystemInformation (
                                  SystemRelocateCMCellOff,
                                  NULL,
                                  0);
                    if (!NT_SUCCESS (status)) {
                        fprintf(stderr,"Set system information failed %lx\n",status);
                    }else{
                        fprintf(stderr,"Registry Relocation off\n");
                    }
                    ExitProcess(0);
                case 's':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_INIT_MEMSNAP;
                    break;
                case 'S':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_SOFTFAULT;
                    break;
                case 'z':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_WSDETAILS;
                    break;
                case 'Z':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_WSENTRIES;
                    break;
                case 'P':
                    ToTurnOff = ToTurnOff | MMINFO_LOG_PROFILE;
                    break;
                default:
                    fprintf(stderr,"%s\n", Usage);
                    ExitProcess(1);
                }
            }
            p++;
        }
    }
}
#endif //NTMMPERF

int _cdecl
main(
    int argc,
    char *argv[]
    )
{
#if NTMMPERF
    LPSTR          p;
    NTSTATUS status;
    ULONG ImageStart, ImageEnd;
    ULONG ProcessStart, ProcessEnd;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    ULONG TotalPageTable;
    ULONG TotalModified;
    ULONG TotalTransition;
    SYSTEMTIME Time;
    ULONG PageKb;
    ULONG LogSize;
    
    ULONG  LogType;
    _int64 *TmpPint64;
    _int64 PerfCounter, PerfCounterStart;
    _int64 PerfFrequency;

    PerfHook_t *Hook, *NextHook;
    TimeStamp_t TS;
    PerfSize_t  Size;
    PerfTag_t   Tag;
    PerfData_t  *Info;
    ULONG i;

    //
    // First parse the arguments and see what to do.
    //
    ParseArgs( argc, argv );

    if (ToTurnOn & ToTurnOff) {
        fprintf(stderr,"Cannot turn on and off the same flag, make up your mind !!!\n");
    }else{
        MmInfoOnFlag=((MmInfoOnFlag | ToTurnOn) & ~ToTurnOff);
    }

    //
    // If there is a flag to turn on. Do it.
    //

    if (MmInfoOnFlag) {
        status = NtSetSystemInformation (
                  SystemMmInfoLogOnInformation,
                  &MmInfoOnFlag,
                  sizeof(ULONG));
        if (!NT_SUCCESS (status)) {
            fprintf(stderr,"Set system information failed ON %lx\n",status);
            return 1;
        }else{
            fprintf(stderr,"Monitor On\n");
            return 0;
        }
    }

    //
    // If we reach this point, we are do dump the log.
    // First turn off monitor.
    //

    status = NtSetSystemInformation (SystemMmInfoLogOffInformation,
                                     NULL,
                                     0);
    if (!NT_SUCCESS (status)) {
        fprintf(stderr,"Set system information failed %lx\n",status);
        return 1;
    }

    //
    // HACK FIXFIX when doing MP stuff
    //
    ThreadHash[0] = 0;
    ProcessHash[0].ProcessID = 0;
    RtlCopyMemory(ProcessHash[0].ImageFileName, "Idle", 16);

    status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if (!NT_SUCCESS (status)) {
        fprintf(stderr,"query system basic information failed %lx\n",status);
        return 1;
    }

    PageKb = BasicInfo.PageSize / 1024;

    // 
    // print the Headers
    //

    printf(WsManagerHeaderFormat);
    printf(WsInfoHeaderFormat);
    printf(TrimHeaderFormat );
    printf(ImageLoadHeaderFormat);
    printf(SampleProfileHeaderFormat);


    //
    // Mow dump the buffer.
    //
    NextHook = PerfNextHook();
    Hook     = PerfFirstHook();

    LogSize = (ULONG) NextHook  - (ULONG) Hook;
    // fprintf(stderr, "Size in Pages %8d\n", PerfQueryBufferSize4KPages());
    // fprintf(stderr, "Size in Bytes %8d\n", PerfQueryBufferSizeBytes());
    // fprintf(stderr, "Size in KBs   %8d\n", PerfQueryBufferSizeKB());
  
    // fprintf(stderr, "Size in Bytes %8d (%8x - %8x) \n", NextHook - Hook, Hook, NextHook);

    while( Hook < NextHook ){
        ULONG LogType;
        Hook = (PerfHook_t *)PerfGetHook(Hook, &Tag, &TS, &Size, &Info );
        LogType = Tag.u.Bits.HookId;
        // LogType = Tag.u.Value;

        // PerfCounter = 0xffffffffffffffff;
        PerfCounter = TS;

        if (Debug) {
            // fprintf(stdout, "%8x: LogType %4d, Size:%4d, Time: %I64u\n",Hook, LogType, Size, PerfCounter);
        }

        switch(LogType) {
          printf ("LogType=%08x\n", LogType);
        case PERF_APIMON_DLL_ADDRESS:
          {
            PPerf_Apimon_Dll_Address_t DllInfo;
            DllInfo = (PPerf_Apimon_Dll_Address_t) Info;
            InsertDll(DllInfo->StartingAddress,
                      DllInfo->EndingAddress,
                      DllInfo->DllName);
            printf ("DllAddressName %08x %08x %s\n", 
                    DllInfo->StartingAddress,
                    DllInfo->EndingAddress,
                    DllInfo->DllName);
          }
        break;
        case PERF_APIMON_API_ADDRESS:
          {
            PPerf_Apimon_Api_Address_t ApiInfo;
            ApiInfo = (PPerf_Apimon_Api_Address_t) Info;
            InsertApi(ApiInfo->Address,
                      ApiInfo->ApiName);
            printf ("ApiAddressName %08x %s\n", 
                    ApiInfo->Address,
                    ApiInfo->ApiName);
          }
        break;
        case PERF_APIMON_ENTER:
          {
            PPerf_Apimon_Enter_t PEnter;
            PEnter = (PPerf_Apimon_Api_Address_t) Info;
            printf ("ApiEnter %08x %s %s\n", 
                    PEnter->Address, 
                    DllContainingAddress(PEnter->Address), 
                    ApiAtAddress(PEnter->Address));
          }
        break;
        case PERF_APIMON_EXIT:
          {
            PPerf_Apimon_Enter_t PExit;
            PExit = (PPerf_Apimon_Api_Address_t) Info;
            printf ("ApiExit  %08x %s %s\n", 
                    PExit->Address,
                    DllContainingAddress(PExit->Address), 
                    ApiAtAddress(PExit->Address));
          }
        break;

            case MMINFO_LOG_TYPE_VERSION:
            {
                PSYSTEM_MMINFO_VERSION_INFORMATION TmpPMmInfoVersion;
                
                TmpPMmInfoVersion = (PSYSTEM_MMINFO_VERSION_INFORMATION) Info;

                if (TmpPMmInfoVersion->Version  != MMINFO_VERSION) {
                    fprintf(stderr, "Kernel Version:%4d mismatch with User Version:%d\n",
                            TmpPMmInfoVersion->Version,
                            MMINFO_VERSION
                    );
                    ExitProcess(1);
                } else {
                    fprintf(stderr, "Version: %4d, BufferSize = %6d KB\n", 
                            MMINFO_VERSION, 
                            LogSize/1024);
                    fprintf(stdout, "Version, %4d, BufferSize, %6d KB\n", 
                            MMINFO_VERSION, 
                            LogSize/1024);
                }
            }
            break;

            case MMINFO_LOG_TYPE_PERFFREQUENCY:
            {
                PMMINFO_TIME_FREQUENCY TimeFreq;

                TimeFreq = (PMMINFO_TIME_FREQUENCY) Info;

                PerfFrequency = TimeFreq->Frequency;
                
                PerfCounterStart = TimeFreq->Time;

                printf("Log start at (Performance Counter), %I64d\n",
                            PerfCounterStart*1000000/PerfFrequency);
            }
            break;

            case MMINFO_LOG_TYPE_FILENAMEBUFFER:
            {
                PSYSTEM_MMINFO_FILENAME_INFORMATION TmpPImage;

                TmpPImage = (PSYSTEM_MMINFO_FILENAME_INFORMATION) Info;

                while (TmpPImage->ImageKey) {
                    i=TmpPImage->ImageKey%TableSize;

                    while(ImageHash[i].ImageKey != 0) {
                        if (ImageHash[i].ImageKey == TmpPImage->ImageKey) {
                            break;
                        }else{
                            i = (i+1)%TableSize;
                        }
                    }

                    ImageHash[i].ImageKey =TmpPImage->ImageKey;
                    ImageHash[i].ImageName.Length =TmpPImage->ImageName.Length;
                    ImageHash[i].ImageName.Buffer =TmpPImage->ImageBuffer;
                    if (Debug) {
                        printf("%12s,", "S-Created");
                    }

                    if (Debug) {
                        printf("%10s,%22s,%12s,%12x,%8s,%30S,%12s,%10s,%10s\n",
                            "",
                            "",
                            "",
                            ImageHash[i].ImageKey,
                            "",
                            ImageHash[i].ImageName.Buffer,
                            "",
                            "",
                            "");
                    }
                    TmpPImage++;
                }
            }
            break;
            case MMINFO_LOG_TYPE_PAGEFAULT:
                {
                    PSYSTEM_HARDPAGEFAULT_INFORMATION TmpPMmInfoLog;

                    TmpPMmInfoLog=(PSYSTEM_HARDPAGEFAULT_INFORMATION) Info;

                    printf("%12s,","HardFault");
                    printf("%10I64d,",
                            (PerfCounter - PerfCounterStart)*1000000/PerfFrequency);
                    
                    if (TmpPMmInfoLog->ProcessID == 0) {
                        printf("%22s,","System (  0)");
                    } else{
                        ULONG i;

                        i = TmpPMmInfoLog->ProcessID;

                        if (ProcessHash[i].ProcessID == TmpPMmInfoLog->ProcessID) {
                            printf("%16s ",ProcessHash[i].ImageFileName);
                            printf("(%3d),",ProcessHash[i].ProcessID);
                        }else{
                            printf("Process %13u,",TmpPMmInfoLog->ProcessID);
                        }
                    }
                    printf("%12u,",TmpPMmInfoLog->ThreadID);
                    printf("%12x,",TmpPMmInfoLog->Va);
                    printf("%8u,",TmpPMmInfoLog->Pfn);
                    {
                        ULONG i;

                        i=TmpPMmInfoLog->ImageKey%TableSize;

                        while(ImageHash[i].ImageKey != 0) {
                            if (ImageHash[i].ImageKey == TmpPMmInfoLog->ImageKey) {
                                printf("%30S,",ImageHash[i].ImageName.Buffer);
                                break;
                            }else{
                                i = (i+1)%TableSize;
                            }
                        }
                        if (ImageHash[i].ImageKey == 0) {
                            if (TmpPMmInfoLog->Va >= 0x8000000) {
                                printf("%30s,","pagefile.sys");
                            } else { 
                                printf("%19s (%8x),","Image", TmpPMmInfoLog->ImageKey);
                            }
                        }
                    }
                    printf("%12I64d,",TmpPMmInfoLog->ReadOffset);
                    printf("%10u,",TmpPMmInfoLog->ByteCount);
                    if (TmpPMmInfoLog->FaultType == 3) {
                        printf("%10s,","Read");
                    } else if (TmpPMmInfoLog->FaultType == 2) {
                        printf("%10s,","Code");
                    } else if (TmpPMmInfoLog->FaultType == 1) {
                        printf("%10s,","Data");
                    } else {
                        printf("%10s,","NA");
                    }

                    printf("%10I64d",
                            (TmpPMmInfoLog->IoCompleteTime-PerfCounter)
                            *1000000/PerfFrequency);
        
                    printf("\n");

                    // printf("Got Page Fault Log\n");

                    break;
                }
            case MMINFO_LOG_TYPE_TRANSITIONFAULT:
            case MMINFO_LOG_TYPE_DEMANDZEROFAULT:
            case MMINFO_LOG_TYPE_ADDVALIDPAGETOWS:
            case MMINFO_LOG_TYPE_PROTOPTEFAULT:
            case MMINFO_LOG_TYPE_ADDTOWS:
                {
                    PSYSTEM_MMINFO_SOFTFAULT_INFORMATION TmpPMmInfoLog;

                    TmpPMmInfoLog=(PSYSTEM_MMINFO_SOFTFAULT_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_TRANSITIONFAULT) {
                        printf("%12s,","TransFault");
                    } else if (LogType == MMINFO_LOG_TYPE_DEMANDZEROFAULT) {
                        printf("%12s,","DeZeroFault");
                    } else if (LogType == MMINFO_LOG_TYPE_ADDVALIDPAGETOWS) {
                        printf("%12s,","AddValidToWS");
                    } else if (LogType == MMINFO_LOG_TYPE_PROTOPTEFAULT) {
                        printf("%12s,","ProtoFault");
                    } else if (LogType == MMINFO_LOG_TYPE_ADDTOWS) {
                        printf("%12s,","AddToWS");
                    } else {
                        printf("%12s,","Unknown");
                    }

                    printf("%10s,", "");
                    
                    if (TmpPMmInfoLog->ProcessID == -1) {
                        printf("%22s,","SystemCache");
                    } else{
                        ULONG i;

                        i = TmpPMmInfoLog->ProcessID;

                        if (ProcessHash[i].ProcessID == TmpPMmInfoLog->ProcessID) {
                            printf("%16s ",ProcessHash[i].ImageFileName);
                            printf("(%3d),",ProcessHash[i].ProcessID);
                        }else{
                            printf("Process %13u,",TmpPMmInfoLog->ProcessID);
                        }
                    }
                    printf("%12u,",TmpPMmInfoLog->ThreadID);
                    printf("%12x,",TmpPMmInfoLog->Va);
                    printf("%8u",TmpPMmInfoLog->Pfn);
        
                    printf("\n");

                    break;
                }
            case MMINFO_LOG_TYPE_WORKINGSETSNAP:
                {
                    PSYSTEM_MMINFO_WSENTRY_INFORMATION TmpPWs;
                    PMMINFO_WSENTRY TmpPWsEntry;
                    ULONG   Size;
                    ULONG   ii;
                    UCHAR   Process[22];

                    TmpPWs = (PSYSTEM_MMINFO_WSENTRY_INFORMATION) Info;

                    Size = TmpPWs->WsSize;
                    TmpPWsEntry = TmpPWs->Ws;

                    if (TmpPWs->ProcessID == -1) {
                        sprintf(Process,"%22s","SystemCache");
                    } else {
                        ULONG i;
                        i = TmpPWs->ProcessID;
                        if (ProcessHash[i].ProcessID == TmpPWs->ProcessID) {
                            sprintf(Process, "%16s (%3d)", 
                                    ProcessHash[i].ImageFileName,
                                    ProcessHash[i].ProcessID);
                        }else{
                            sprintf(Process,"Process %13u",TmpPWs->ProcessID);
                        }
                    }

                    for (ii = 1; ii <= Size; ii++) {
                        printf("%12s,%10s,%22s,%12u,%12x,%8u,%s,%s",
                                    "WsSnap",
                                    "",
                                    Process,
                                    ii,
                                    TmpPWsEntry->Va.Page << 12,
                                    TmpPWsEntry->Pa.Page,
                                    TmpPWsEntry->Pa.Accessed ?
                                        "Accessed" : "NotAccessed",
                                    TmpPWsEntry->Pa.Modified ?
                                        "Modified" : "NotModified",
                                    TmpPWsEntry->Pa.Shared ?
                                        "Shared" : "NotShared"
                                    );
#ifdef WS_INSTRUMENTATION_ACCESS_BIT
                        printf(",%s",
                                    TmpPWsEntry->Pa.RecentlyUsed ?
                                        "RecentlyUsed" : "NotRecentlyUsed"
                                    );
#endif // WS_INSTRUMENTATION_ACCESS_BIT
                        printf("\n");
                        TmpPWsEntry++;
                    }

                    // printf("Size = %d\n", Size);

                    break;
                }
            case MMINFO_LOG_TYPE_OUTWS_REPLACEUSED:
            case MMINFO_LOG_TYPE_OUTWS_REPLACEUNUSED:
            case MMINFO_LOG_TYPE_OUTWS_VOLUNTRIM:
            case MMINFO_LOG_TYPE_OUTWS_FORCETRIM:
            case MMINFO_LOG_TYPE_OUTWS_ADJUSTWS:
            case MMINFO_LOG_TYPE_OUTWS_EMPTYQ:
                {
                    PSYSTEM_MMINFO_WSCHANGE_INFORMATION TmpPMmInfoLog;

                    TmpPMmInfoLog=(PSYSTEM_MMINFO_WSCHANGE_INFORMATION) Info;

                    printf("%12s,","Out_Of_WS");

                    if (LogType == MMINFO_LOG_TYPE_OUTWS_REPLACEUSED) {
                        printf("%10s,","RepUsed");
                    } else if (LogType == MMINFO_LOG_TYPE_OUTWS_REPLACEUNUSED) {
                        printf("%10s,","RepUnUsed");
                    } else if (LogType == MMINFO_LOG_TYPE_OUTWS_VOLUNTRIM) {
                        printf("%10s,","VolunTrim");
                    } else if (LogType == MMINFO_LOG_TYPE_OUTWS_FORCETRIM) {
                        printf("%10s,","ForceTrim");
                    } else if (LogType == MMINFO_LOG_TYPE_OUTWS_ADJUSTWS) {
                        printf("%10s,","AdjustWs");
                    } else if (LogType == MMINFO_LOG_TYPE_OUTWS_EMPTYQ) {
                        printf("%10s,","EmptyQ");
                    } else {
                        printf("%10s,","Unknown");
                    }

                    if (TmpPMmInfoLog->ProcessID == 0) {
                        printf("%22s,","SystemCache");
                    } else{
                        ULONG i;

                        i = TmpPMmInfoLog->ProcessID;

                        if (ProcessHash[i].ProcessID == TmpPMmInfoLog->ProcessID) {
                            printf("%16s ",ProcessHash[i].ImageFileName);
                            printf("(%3d),",ProcessHash[i].ProcessID);
                        }else{
                            printf("Process %13u,",TmpPMmInfoLog->ProcessID);
                        }
                    }
                    printf("%12s,","");
                    printf("%12x,",TmpPMmInfoLog->Entry.Va.Page << 12);
                    printf("%8u",TmpPMmInfoLog->Entry.Pa.Page);
        
                    printf("\n");

                    break;
                }
            case MMINFO_LOG_TYPE_WSINFOCACHE:
            case MMINFO_LOG_TYPE_TRIMCACHE:
            case MMINFO_LOG_TYPE_WSINFOPROCESS:
            case MMINFO_LOG_TYPE_TRIMPROCESS:
                {
                    PSYSTEM_MMINFO_TRIMPROCESS_INFORMATION TmpPMmInfoTrimProcess;
                    
                    TmpPMmInfoTrimProcess = (PSYSTEM_MMINFO_TRIMPROCESS_INFORMATION) Info;

                    if ((LogType == MMINFO_LOG_TYPE_WSINFOPROCESS) ||
                        (LogType == MMINFO_LOG_TYPE_WSINFOCACHE)) {
                        printf("%12s,","WsInfo");
                    } else {
                        printf("%12s,","Triming");
                    }
                    printf("WS:%7d,", TmpPMmInfoTrimProcess->ProcessWorkingSet);

                    if ((LogType == MMINFO_LOG_TYPE_TRIMCACHE) ||
                        (LogType == MMINFO_LOG_TYPE_WSINFOCACHE)) {
                            printf("%22s,","SystemCache");
                    } else{
                        if (TmpPMmInfoTrimProcess->ProcessID == 0) {
                            printf("%30s,","System (  0)");
                        } else {
                            ULONG i;
                        
                            i = TmpPMmInfoTrimProcess->ProcessID;
                        
                            if (ProcessHash[i].ProcessID == TmpPMmInfoTrimProcess->ProcessID) {
                                printf("%16s ",ProcessHash[i].ImageFileName);
                                printf("(%3d),",ProcessHash[i].ProcessID);
                            }else{
                                printf("Process %13u,",TmpPMmInfoTrimProcess->ProcessID);
                            }
                        }
                    }
                    printf("Need:%7d,", TmpPMmInfoTrimProcess->ToTrim);
                    printf("Got:%8d,", TmpPMmInfoTrimProcess->ActualTrim);
                    printf("Pri:%4d,", TmpPMmInfoTrimProcess->ProcessMemoryPriority);
                    printf("PageFaults:%8d,", 
                            TmpPMmInfoTrimProcess->ProcessPageFaultCount-
                            TmpPMmInfoTrimProcess->ProcessLastPageFaultCount);
                    if ((LogType == MMINFO_LOG_TYPE_WSINFOPROCESS) ||
                        (LogType == MMINFO_LOG_TYPE_WSINFOCACHE)) {
                        printf("Acc:%4d,",
                                TmpPMmInfoTrimProcess->ProcessAccessedCount);
                        printf("Mod:%4d,",
                                TmpPMmInfoTrimProcess->ProcessModifiedCount);
                        printf("Shd:%4d,",
                                TmpPMmInfoTrimProcess->ProcessSharedCount);
#ifdef WS_INSTRUMENTATION_ACCESS_BIT
                        printf("RUsed:%4d,",
                                TmpPMmInfoTrimProcess->ProcessRecentlyUsedCount);
#endif // WS_INSTRUMENTATION_ACCESS_BIT
                    }
#ifdef WS_INSTRUMENTATION
                    printf("Replacments:%5d,",
                            TmpPMmInfoTrimProcess->ProcessReplacementCount);

                    printf("QuotaBoosts:%5d,",
                            TmpPMmInfoTrimProcess->ProcessQuotaBoostCount);
                    printf("UsedRepls:%5d,",
                            TmpPMmInfoTrimProcess->ProcessSparecount3);
                    printf("FaultsSinceQInc:%5d,",
                            TmpPMmInfoTrimProcess->ProcessPageFaultCount-
                            TmpPMmInfoTrimProcess->ProcessLastGrowthFaultCount);
                    printf("FaultSinceFGTrim:%5d,",
                            TmpPMmInfoTrimProcess->ProcessPageFaultCount -
                            TmpPMmInfoTrimProcess->
                                    ProcessLastForegroundTrimFaultCount);
                    printf("Spare4:%5d,",
                            TmpPMmInfoTrimProcess->ProcessSparecount4);
                    printf("Spare5:%2d,",
                            TmpPMmInfoTrimProcess->ProcessSparecount5);
#endif // WS_INSTRUMENTATION
                    printf("\n");
                    
                    break;
                }
            case MMINFO_LOG_TYPE_POOLSTAT:
            case MMINFO_LOG_TYPE_ADDPOOLPAGE:
            case MMINFO_LOG_TYPE_FREEPOOLPAGE:
                {
                    PSYSTEM_MMINFO_POOL_INFORMATION TmpPMmInfoPool;
                    
                    TmpPMmInfoPool = (PSYSTEM_MMINFO_POOL_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_ADDPOOLPAGE) {
                        printf("%12s,","AddPoolPage");
                    } else if (LogType == MMINFO_LOG_TYPE_FREEPOOLPAGE) {
                        printf("%12s,","FreePoolPage");
                    } else{
                        printf("%12s,","PoolSummary");
                    }

                    printf("%10s,%22d,%12s,%12x,%8d,%8d,%8d,%12d,%12d\n",
                        "",
                        (int) TmpPMmInfoPool->Pool /100,
                        PoolTypeNames[(TmpPMmInfoPool->Pool%100) & 7],
                        TmpPMmInfoPool->Entry,
                        TmpPMmInfoPool->Alloc,
                        TmpPMmInfoPool->DeAlloc,
                        TmpPMmInfoPool->TotalPages,
                        TmpPMmInfoPool->TotalBytes,
                        // TmpPMmInfoPool->TotalBytes*100/4096/TmpPMmInfoPool->TotalPages,
                        // TmpPMmInfoPool->TotalBigBytes,
                        TmpPMmInfoPool->TotalBigPages
                        // TmpPMmInfoPool->TotalBigBytes*100/4096/TmpPMmInfoPool->TotalBigPages
                    );
            
                    break;
                }
            case MMINFO_LOG_TYPE_WORKINGSETMANAGER:
                {
                    PSYSTEM_WORKINGSETMANAGER_INFORMATION  TmpPWorkingSetManager;
                    char *ActionString;

                    TmpPWorkingSetManager = (PSYSTEM_WORKINGSETMANAGER_INFORMATION) Info;

                    switch(TmpPWorkingSetManager->Action) {
                        case WS_ACTION_RESET_COUNTER:
                            ActionString = "Reset Counter";
                        break;
                        case WS_ACTION_NOTHING:
                            ActionString = "Nothing";
                        break;
                        case WS_ACTION_INCREMENT_COUNTER:
                            ActionString = "Increment Counter";
                        break;
                        case WS_ACTION_WILL_TRIM:
                            ActionString = "Start Trimming";
                        break;
                        case WS_ACTION_FORCE_TRIMMING_PROCESS:
                            ActionString = "Force Trim";
                        break;
                        case WS_ACTION_WAIT_FOR_WRITER:
                            ActionString = "Wait writter";
                        break;
                        case WS_ACTION_EXAMINED_ALL_PROCESS:
                            ActionString = "All Process Examed";
                        break;
                        case WS_ACTION_AMPLE_PAGES_EXIST:
                            ActionString = "Ample Pages Exist";
                        break;
                        case WS_ACTION_END_WALK_ENTRIES:
                            ActionString = "Finished Walking WsEntries";
                        break;
                        default:
                            ActionString = "Unknown Action";
                        break;
                    }

                    printf(WsManagerDataFormat,
                            (PerfCounter - PerfCounterStart) *1000000/PerfFrequency,
                            TmpPWorkingSetManager->Available,
                            TmpPWorkingSetManager->PageFaultCount,
                            TmpPWorkingSetManager->LastPageFaultCount,
                            TmpPWorkingSetManager->MiCheckCounter,
                            TmpPWorkingSetManager->DesiredReductionGoal,
                            TmpPWorkingSetManager->DesiredFreeGoal,
                            ActionString
                            );
                    
                    break;
                }
            case MMINFO_LOG_TYPE_REMOVEPAGEFROMLIST:
            case MMINFO_LOG_TYPE_REMOVEPAGEBYCOLOR:
            case MMINFO_LOG_TYPE_PAGEINMEMORY:
            case MMINFO_LOG_TYPE_MEMORYSNAP:
            case MMINFO_LOG_TYPE_SETPFNDELETED:
            case MMINFO_LOG_TYPE_DELETEKERNELSTACK:
                {
                    PSYSTEM_REMOVEDPAGE_INFORMATION TmpPRemovedPage;

                    TmpPRemovedPage=(PSYSTEM_REMOVEDPAGE_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_PAGEINMEMORY) {
                        printf("%12s,","InMemory");
                    }else if (LogType == MMINFO_LOG_TYPE_MEMORYSNAP) {
                        printf("%12s,","MemSnap");
                    }else if (LogType == MMINFO_LOG_TYPE_SETPFNDELETED) {
                        printf("%12s,","PfnDeleted");
                    }else if (LogType == MMINFO_LOG_TYPE_DELETEKERNELSTACK) {
                        printf("%12s,","DeleteStack");
                    }else {
                        printf("%12s,","PageRemoved");
                    }

                    printf("%10I64d,",
                            (PerfCounter - PerfCounterStart)
                            *1000000/PerfFrequency);

                    printf("%22s,","");
                    printf("%12x,",TmpPRemovedPage->Pte);
                    // printf("%30S,",.ImageName.Buffer);
                    switch(TmpPRemovedPage->UsedFor) {
                        case MMINFO_PAGE_USED_FOR_PAGEDPOOL:
                            printf("%12x,",TmpPRemovedPage->Pte<<10);
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Paged Pool");
                            printf("%12s,%10s,%10s,","","","PagedPool");
                        break;
                        case MMINFO_PAGE_USED_FOR_NONPAGEDPOOL:
                            printf("%12x,",TmpPRemovedPage->Pte<<10);
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","NonPaged Pool");
                            printf("%12s,%10s,%10s,","","","NonPagedP");
                        break;
                        case MMINFO_PAGE_USED_FOR_KERNELSTACK:
                            printf("%12x,",TmpPRemovedPage->Pte<<10);
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Kernel Stack");
                            printf("%12s,%10s,%10s,","","","K-Stack");
                        break;
                        case MMINFO_PAGE_USED_FOR_FREEPAGE:
                            printf("%12s,","");
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Free Page");
                            printf("%12s,%10s,%10s,","","","Free");
                        break;
                        case MMINFO_PAGE_USED_FOR_ZEROPAGE:
                            printf("%12s,","");
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Zero Page");
                            printf("%12s,%10s,%10s,","","","Zero");
                        break;
                        case MMINFO_PAGE_USED_FOR_BADPAGE:
                            printf("%12s,","");
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Bad Page");
                            printf("%12s,%10s,%10s,","","","Bad");
                        break;
                        case MMINFO_PAGE_USED_FOR_UNKNOWN:
                            printf("%12s,","");
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Unknown");
                            printf("%12s,%10s,%10s,","","","Unknown");
                        break;
                        case MMINFO_PAGE_USED_FOR_METAFILE:
                            printf("%12s,","");
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Meta File");
                            printf("%12s,%10s,%10s,","","","Meta");
                        break;
                        case MMINFO_PAGE_USED_FOR_NONAME:
                            printf("%12s,","");
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","No Name");
                            printf("%12s,%10s,%10s,","","","Image");
                        break;
                        case MMINFO_PAGE_USED_FOR_PAGEFILEMAPPED:
                            printf("%12x,",TmpPRemovedPage->Pte<<10);
                            printf("%8u,",TmpPRemovedPage->Pfn);
                            printf("%30s,","Page File Mapped");
                            printf("%12s,%10s,%10s,","","","PFMapped");
                        break;
                        case MMINFO_PAGE_USED_FOR_FILE:
                        case MMINFO_PAGE_USED_FOR_KERNMAP:
                        {
                            ULONG i,j;

                            if (TmpPRemovedPage->UsedFor != MMINFO_PAGE_USED_FOR_KERNMAP) {
                                printf("%12s,","");
                            } else {
                                printf("%12x,",TmpPRemovedPage->Pte << 10);
                            }
                            printf("%8u,",TmpPRemovedPage->Pfn);

                            i=TmpPRemovedPage->ImageKey%TableSize;
    
                            while(ImageHash[i].ImageKey != 0) {
                                if (ImageHash[i].ImageKey == TmpPRemovedPage->ImageKey) {
                                    printf("%30S,",ImageHash[i].ImageName.Buffer);
                                    break;
                                }else{
                                    i = (i+1)%TableSize;
                                }
                            }

                            if (Debug) {
                                // printf("(%4d   %22x)",i,TmpPRemovedPage->ImageKey);
                            }
                            
                            if (ImageHash[i].ImageKey == 0) {
                                if (TmpPRemovedPage->UsedFor != MMINFO_PAGE_USED_FOR_KERNMAP) {
                                    printf("%19s (%8x),","Image", TmpPRemovedPage->ImageKey);
                                    printf("%12I64d,",TmpPRemovedPage->Offset);
                                    printf("%10s,","");
                                    printf("%10s,","FILE");
                                }else{
                                    printf("%19s (%8x),","KernMap", TmpPRemovedPage->ImageKey);
                                    printf("%12s,%10s,","","");
                                    printf("%10s,","Driver");
                                }
                            }else{
                                if (TmpPRemovedPage->UsedFor == MMINFO_PAGE_USED_FOR_KERNMAP) {
                                    printf("%12I64d,",TmpPRemovedPage->Offset);
                                    printf("%10s,","");
                                    printf("%10s,","Driver");
                                }else if (TmpPRemovedPage->UsedFor == MMINFO_PAGE_USED_FOR_FILE) {
                                    printf("%12I64d,",TmpPRemovedPage->Offset);
                                    printf("%10s,","");
                                    printf("%10s,","FILE");
                                }else{    
                                    printf("%12s,%10s,","","");
                                    printf("%10s,","Unknown");
                                }
                            }
                        }
                        break;
                        case MMINFO_PAGE_USED_FOR_PROCESS:
                        case MMINFO_PAGE_USED_FOR_PAGETABLE:
                        {
                            ULONG i;
                    
                            // Bug! Bug! The way to get VA can be wrong in the future.

                            if (TmpPRemovedPage->UsedFor == MMINFO_PAGE_USED_FOR_PAGETABLE) {
                                printf("%12x,",TmpPRemovedPage->Pte<<10);
                                printf("%8u,",TmpPRemovedPage->Pfn);
                                printf("(PT)");
                            }else{
                                printf("%12x,",TmpPRemovedPage->Pte<<10);
                                printf("%8u,",TmpPRemovedPage->Pfn);
                                printf("    ");
                            }
                            if (TmpPRemovedPage->ImageKey == 0) {
                                printf("%26s,","System (  0)");
                            }else{

                                i = TmpPRemovedPage->ImageKey;

                                if (ProcessHash[i].ProcessID == TmpPRemovedPage->ImageKey) {
                                    printf("%20s ",ProcessHash[i].ImageFileName);
                                    printf("(%3d),",ProcessHash[i].ProcessID);
                                }else{
                                    printf("Process %18u,",TmpPRemovedPage->ImageKey);
                                }
                            }
                            if (TmpPRemovedPage->UsedFor == MMINFO_PAGE_USED_FOR_PAGETABLE) {
                                // printf("%12I64d,",TmpPRemovedPage->Offset);
                                printf("%12s,%10s,%10s,","","","PageTable");
                            }else{
                                printf("%12s,%10s,%10s,","","","Process");
                                // printf("%30s,","Page Table");
                            }
                        }
                        break;
                        default:
                            printf("Error2 %22u,",TmpPRemovedPage->ImageKey);
                        break;
                    }
                    switch(TmpPRemovedPage->List) {
                        case MMINFO_PAGE_IN_LIST_FREEPAGE:
                             printf("%10s","Free List");
                             break;
                        case MMINFO_PAGE_IN_LIST_ZEROPAGE:
                             printf("%10s","Zero List");
                             break;
                        case MMINFO_PAGE_IN_LIST_BADPAGE:
                             printf("%10s","Bad List");
                             break;
                        case MMINFO_PAGE_IN_LIST_STANDBY:
                             printf("%10s","Standby");
                             break;
                        case MMINFO_PAGE_IN_LIST_TRANSITION:
                             printf("%10s","Transition");
                             break;
                        case MMINFO_PAGE_IN_LIST_MODIFIED:
                             printf("%10s","Modified");
                             break;
                        case MMINFO_PAGE_IN_LIST_MODIFIEDNOWRITE:
                             printf("%10s","ModNoWrite");
                             break;
                        case MMINFO_PAGE_IN_LIST_ACTIVEANDVALID:
                             printf("%10s","Valid");
                             break;
                        case MMINFO_PAGE_IN_LIST_VALIDANDPINNED:
                             printf("%10s","Valid_Pin");
                             break;
                        case MMINFO_PAGE_IN_LIST_UNKNOWN:
                             printf("%10s","Unknown");
                             break;
                        default:
                             // must be page table
                             printf("%10s","");
                             break;
                    }
                    printf("\n");
                    
                    // printf("Got Removed Page Log\n");
                    break;
                }
            case MMINFO_LOG_TYPE_ZEROSHARECOUNT:
            case MMINFO_LOG_TYPE_ZEROREFCOUNT:
            case MMINFO_LOG_TYPE_DECREFCNT:
            case MMINFO_LOG_TYPE_DECSHARCNT:
                {
                    PSYSTEM_MMINFO_PFN_INFORMATION TmpPPfn;

                    TmpPPfn = (PSYSTEM_MMINFO_PFN_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_DECSHARCNT) {
                        printf("%12s,", "DecShareCnt");
                    } else if (LogType == MMINFO_LOG_TYPE_ZEROSHARECOUNT) {
                        printf("%12s,", "ZeroShareCnt");
                    } else if (LogType == MMINFO_LOG_TYPE_DECREFCNT) {
                        printf("%12s,", "DecRefCnt");
                    } else if (LogType == MMINFO_LOG_TYPE_ZEROREFCOUNT) {
                        printf("%12s,", "ZeroRefCnt");
                    } else {
                        printf("%12s,", "UNKNOWN");
                    }

                    printf("%10s,","");

                    printf("%22s,","");
                    printf("%12s,","");
                    printf("%12s,","");
                    printf("%8u\n",TmpPPfn->Pfn);
                    break;
                }
            case MMINFO_LOG_TYPE_INSERTINLIST:
            case MMINFO_LOG_TYPE_INSERTATFRONT:
            case MMINFO_LOG_TYPE_UNLINKFROMSTANDBY:
            case MMINFO_LOG_TYPE_UNLINKFFREEORZERO:
                {
                    PSYSTEM_MMINFO_STATE_INFORMATION TmpPMmInfoState;

                    TmpPMmInfoState=(PSYSTEM_MMINFO_STATE_INFORMATION) Info;
            
                    if (LogType == MMINFO_LOG_TYPE_INSERTINLIST) {
                        printf("%12s,%10s,","Insert-List", "");
                    }else if (LogType == MMINFO_LOG_TYPE_INSERTATFRONT) {
                        printf("%12s,%10s,","Insert-Front", "");
                    }else if (LogType == MMINFO_LOG_TYPE_UNLINKFROMSTANDBY) {
                        printf("%12s,%10s,","Unlink-From", "");
                    }else if (LogType == MMINFO_LOG_TYPE_UNLINKFFREEORZERO) {
                        printf("%12s,%10s,","Unlink-From", "");
                    }

                    printf("%22s,","");
                    printf("%12s,","");
                    printf("%12s,","");
                    printf("%8u,",TmpPMmInfoState->Pfn);
                    printf("%30s,","");
                    printf("%12s,%10s,%10s,","","","");
                    switch(TmpPMmInfoState->List) {
                        case MMINFO_PAGE_IN_LIST_FREEPAGE:
                             printf("%10s","Free List");
                             break;
                        case MMINFO_PAGE_IN_LIST_ZEROPAGE:
                             printf("%10s","Zero List");
                             break;
                        case MMINFO_PAGE_IN_LIST_BADPAGE:
                             printf("%10s","Bad List");
                             break;
                        case MMINFO_PAGE_IN_LIST_STANDBY:
                             printf("%10s","Standby");
                             break;
                        case MMINFO_PAGE_IN_LIST_TRANSITION:
                             printf("%10s","Transition");
                             break;
                        case MMINFO_PAGE_IN_LIST_MODIFIED:
                             printf("%10s","Modified");
                             break;
                        case MMINFO_PAGE_IN_LIST_MODIFIEDNOWRITE:
                             printf("%10s","ModNoWrite");
                             break;
                        case MMINFO_PAGE_IN_LIST_ACTIVEANDVALID:
                             printf("%10s","Valid");
                             break;
                        case MMINFO_PAGE_IN_LIST_VALIDANDPINNED:
                             printf("%10s","Valid_Pin");
                             break;
                        case MMINFO_PAGE_IN_LIST_UNKNOWN:
                             printf("%10s","Unknown");
                             break;
                        default:
                             // must be page table
                             printf("%10s","");
                             break;
                    }
                    printf("\n");
                    
                    // printf("Got Removed Page Log\n");
                    break;
                }
            case MMINFO_LOG_TYPE_IMAGENAME:
            case MMINFO_LOG_TYPE_SECTIONREMOVED:
                {
                    PSYSTEM_MMINFO_FILENAME_INFORMATION TmpPImage;
                    ULONG i;

                    TmpPImage=(PSYSTEM_MMINFO_FILENAME_INFORMATION) Info;
                    // printf("Got Image Log\n");

                    i=TmpPImage->ImageKey%TableSize;
    
                    while(ImageHash[i].ImageKey != 0) {
                        if (ImageHash[i].ImageKey == TmpPImage->ImageKey) {
                            break;
                        }else{
                            i = (i+1)%TableSize;
                        }
                    }

                    if (LogType == MMINFO_LOG_TYPE_IMAGENAME) {
                        ImageHash[i].ImageKey
                            =TmpPImage->ImageKey;
                        ImageHash[i].ImageName.Length
                            =TmpPImage->ImageName.Length;
                        ImageHash[i].ImageName.Buffer
                            =TmpPImage->ImageBuffer;
                        if (Debug) {
                            printf("%12s,", "S-Created");
                        }
                    }else{
                        if (Debug) {
                            printf("%12s,", "S-Deleted");
                        }

                    }
                    if (Debug) {
                        printf("%10s,%22s,%12s,%12x,%8s,%30S,%12s,%10s,%10s\n",
                            "",
                            "",
                            "",
                            ImageHash[i].ImageKey,
                            "",
                            ImageHash[i].ImageName.Buffer,
                            "",
                            "",
                            "");
                    }

                    break;
                }
            case MMINFO_LOG_TYPE_PROCESSNAME:
            case MMINFO_LOG_TYPE_DIEDPROCESS:
                {
                    PSYSTEM_MMINFO_PROCESS_INFORMATION TmpPProcess;
                    ULONG i;

                    TmpPProcess=(PSYSTEM_MMINFO_PROCESS_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_PROCESSNAME) {
                        i = TmpPProcess->ProcessID;

                        ProcessHash[i].ProcessID
                            =TmpPProcess->ProcessID;
                        RtlCopyMemory(ProcessHash[i].ImageFileName, 
                                      TmpPProcess->ImageFileName, 16);

                        printf("%12s,", "P-Created");
                    }else{
                        printf("%12s,", "P-Deleted");
                    }
                    printf("%10s,%16s (%3d)\n",
                                "",
                                ProcessHash[TmpPProcess->ProcessID].ImageFileName,
                                ProcessHash[TmpPProcess->ProcessID].ProcessID);

                    // printf("Got Process Log\n");
                    break;
                }
            case MMINFO_LOG_TYPE_OUTSWAPPROCESS:
            case MMINFO_LOG_TYPE_INSWAPPROCESS:
                {
                    PSYSTEM_MMINFO_SWAPPROCESS_INFORMATION TmpPProc;
                    ULONG i;

                    TmpPProc=(PSYSTEM_MMINFO_SWAPPROCESS_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_OUTSWAPPROCESS) {
                        printf("%12s,", "P-OutSwap");
                    }else{
                        printf("%12s,", "P-InSwap");
                    }

                    if (PerfCounter) {
                        printf("%10I64d,", ((PerfCounter - PerfCounterStart) * 1000000) / PerfFrequency);
                    } else {
                        printf("%10s,", "");
                    }

                    printf("%16s (%3d)",
                                ProcessHash[TmpPProc->ProcessID].ImageFileName,
                                ProcessHash[TmpPProc->ProcessID].ProcessID);

                    printf("\n");
                    break;
                }
            case MMINFO_LOG_TYPE_OUTSWAPSTACK:
            case MMINFO_LOG_TYPE_INSWAPSTACK:
                {
                    PSYSTEM_MMINFO_SWAPTHREAD_INFORMATION TmpPThread;
                    ULONG i;

                    TmpPThread=(PSYSTEM_MMINFO_SWAPTHREAD_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_OUTSWAPSTACK) {
                        printf("%12s,", "KS-OutSwap");
                    }else{
                        printf("%12s,", "KS-InSwap");
                    }

                    printf("%10d,%16s (%3d)",
                                TmpPThread->ThreadID,
                                ProcessHash[TmpPThread->ProcessID].ImageFileName,
                                ProcessHash[TmpPThread->ProcessID].ProcessID);

                    if (PerfCounter) {
                        printf(",%12I64d", ((PerfCounter - PerfCounterStart) * 1000000) / PerfFrequency);
                    }
                    printf("\n");
                    break;
                }
            case MMINFO_LOG_TYPE_CREATETHREAD:
            case MMINFO_LOG_TYPE_GROWKERNELSTACK:
            case MMINFO_LOG_TYPE_TERMINATETHREAD:
            case MMINFO_LOG_TYPE_CONVERTTOGUITHREAD:
                {
                    PSYSTEM_MMINFO_THREAD_INFORMATION TmpPThread;
                    ULONG i;

                    TmpPThread=(PSYSTEM_MMINFO_THREAD_INFORMATION) Info;

                    if (LogType == MMINFO_LOG_TYPE_CREATETHREAD) {
                        printf("%12s,", "T-Created");
                        ThreadHash[TmpPThread->ThreadID] = TmpPThread->ProcessID;
                    }else if (LogType == MMINFO_LOG_TYPE_GROWKERNELSTACK) {
                        printf("%12s,", "GrowStack");
                    }else if (LogType == MMINFO_LOG_TYPE_CONVERTTOGUITHREAD) {
                        printf("%12s,", "T-GUI");
                    }else{
                        printf("%12s,", "T-Deleted");
                        //
                        // Threads are sometimes set as deleted while still
                        // running.  If we mark them as dead here we have
                        // a problem when they are cswitched out.
                        //
                        //ThreadHash[TmpPThread->ThreadID] = -1;
                    }

                    printf("%10d,%16s (%3d)",
                                TmpPThread->ThreadID,
                                ProcessHash[TmpPThread->ProcessID].ImageFileName,
                                ProcessHash[TmpPThread->ProcessID].ProcessID);

                    // printf("Got Process Log\n");
                    if (LogType != MMINFO_LOG_TYPE_TERMINATETHREAD) {
                        printf(",%12x",TmpPThread->StackBase);
                        printf(",%12x",TmpPThread->StackLimit);

                        if (TmpPThread->UserStackBase) {
                            printf(",%12x",TmpPThread->UserStackBase);
                            printf(",%12x",TmpPThread->UserStackLimit);
                        } else {
                            printf(",%12s","");
                            printf(",%12s","");
                        }

                        if (TmpPThread->WaitMode >= 0) {
                            if (TmpPThread->WaitMode) {
                                printf(",%8s", "Swapable");
                            } else {
                                printf(",%8s", "NonSwap");
                            }
                        }
                    }
                    printf("\n");
                    break;
                }
            case MMINFO_LOG_TYPE_CSWITCH:
            {
                PSYSTEM_MMINFO_CSWITCH_INFORMATION TmpPMmInfo;
                ULONG OldProcessId;
                ULONG NewProcessId;

                TmpPMmInfo = (PSYSTEM_MMINFO_CSWITCH_INFORMATION) Info;

                OldProcessId = ThreadHash[TmpPMmInfo->OldThreadId];
                NewProcessId = ThreadHash[TmpPMmInfo->NewThreadId];
                if ((OldProcessId == -1) || (NewProcessId == -1)) {
                    printf("Error: Bad thread value %d or %d\n",
                            TmpPMmInfo->OldThreadId,
                            TmpPMmInfo->NewThreadId
                            );
                    break;
                }
                printf("%12s,%10I64d,%11s,%16s,%10d,%16s (%3d), %10d,%16s (%3d),%4d,%4d,%8s\n",
                        "CSwitch",
                        ((PerfCounter - PerfCounterStart) *
                                1000000) / PerfFrequency,
                        ThreadState[TmpPMmInfo->OldState],
                        (TmpPMmInfo->OldState == Waiting) ?
                                WaitReason[TmpPMmInfo->WaitReason] :
                                "",
                        TmpPMmInfo->OldThreadId,
                        ProcessHash[OldProcessId].ImageFileName,
                        OldProcessId,
                        TmpPMmInfo->NewThreadId,
                        ProcessHash[NewProcessId].ImageFileName,
                        NewProcessId,
                        TmpPMmInfo->OldThreadPri,
                        TmpPMmInfo->NewThreadPri,
                        (TmpPMmInfo->OldWaitMode) ? "Swapable" : "NonSwap"
                        );
                break;
            }
            case MMINFO_LOG_TYPE_POOLSNAP:
                {
                    #define PROTECTED_POOL 0x80000000
                    ULONG   PoolTag[2]={0,0};
                    PMMINFO_POOL_TRACKER_TABLE TmpPMmInfopoolTrackTable;

                    TmpPMmInfopoolTrackTable=(PMMINFO_POOL_TRACKER_TABLE) Info;

                    PoolTag[0]=TmpPMmInfopoolTrackTable->Tag & ~PROTECTED_POOL;

                    // Data for Paged Pool
                    if (TmpPMmInfopoolTrackTable->PagedAllocs) {
                        printf("%12s,","PoolSnap");
                        printf("%10s,", PoolTag);
                        printf("%22s,","");
                        printf("%12s,%12s,","PagedPool","");
    
                        printf("%8u,%8u,%8u\n",
                            TmpPMmInfopoolTrackTable->PagedBytes,
                            TmpPMmInfopoolTrackTable->PagedAllocs,
                            TmpPMmInfopoolTrackTable->PagedFrees);
                    }

                    // Data for NonPaged Pool
                    if (TmpPMmInfopoolTrackTable->NonPagedAllocs) {
                        printf("%12s,","PoolSnap");
                        printf("%10s,", PoolTag);
                        printf("%22s,","");
                        printf("%12s,%12s,","NonPagedPool","");
    
                        printf("%8u,%8u,%8u\n",
                            TmpPMmInfopoolTrackTable->NonPagedBytes,
                            TmpPMmInfopoolTrackTable->NonPagedAllocs,
                            TmpPMmInfopoolTrackTable->NonPagedFrees);
                    }
                    break;
                }
            case MMINFO_LOG_TYPE_ALLOCATEPOOL:
            case MMINFO_LOG_TYPE_BIGPOOLPAGE:
                {
                    #define PROTECTED_POOL 0x80000000
                    ULONG   PoolTag[2]={0,0};
                    PSYSTEM_MMINFO_ALLOCATEPOOL_INFORMATION TmpPMmInfoAllocatePool;

                    TmpPMmInfoAllocatePool=(PSYSTEM_MMINFO_ALLOCATEPOOL_INFORMATION) Info;
                    PoolTag[0]=TmpPMmInfoAllocatePool->PoolTag & ~PROTECTED_POOL;

                    if (LogType == MMINFO_LOG_TYPE_ALLOCATEPOOL) {
                        printf("%12s,", "Pool_Alloc");
                        printf("%10s,", PoolTag);
                        if (TmpPMmInfoAllocatePool->ProcessID == 0) {
                            printf("%22s,","System (  0)");
                        } else{
                            ULONG i;
    
                            i = TmpPMmInfoAllocatePool->ProcessID;
    
                            if (ProcessHash[i].ProcessID == TmpPMmInfoAllocatePool->ProcessID) {
                                printf("%16s ",ProcessHash[i].ImageFileName);
                                printf("(%3d),",ProcessHash[i].ProcessID);
                            }else{
                                printf("Process %13u,",TmpPMmInfoAllocatePool->ProcessID);
                            }
                        }
                    }else{
                        printf("%12s,","BigPoolPage");
                        printf("%10s,", PoolTag);
                        printf("%22s,","");
                    }

                    printf("%12s,%12x,%8u\n",
                            PoolTypeNames[TmpPMmInfoAllocatePool->PoolType & 7],
                            TmpPMmInfoAllocatePool->Entry,
                            TmpPMmInfoAllocatePool->Size);
                    break;
                }
            case MMINFO_LOG_TYPE_FREEPOOL:
                {

                    PSYSTEM_MMINFO_FREEPOOL_INFORMATION TmpPMmInfoFreePool;

                    TmpPMmInfoFreePool=(PSYSTEM_MMINFO_FREEPOOL_INFORMATION) Info;

                    printf("%12s,%10s,%22s,%12s,%12x\n",
                            "Pool_Free",
                            "",
                            "",
                            "",
                            TmpPMmInfoFreePool->Entry);
                    break;
                }
            case MMINFO_LOG_TYPE_ASYNCMARK:
            case MMINFO_LOG_TYPE_MARK:
                {
                    PSYSTEM_MMINFO_MARK_INFORMATION TmpPMmInfo;
    
                    TmpPMmInfo = (PSYSTEM_MMINFO_MARK_INFORMATION) Info;
    
                    printf("%12s,%10I64d, %-s\n",
                            (LogType == MMINFO_LOG_TYPE_ASYNCMARK) ?
                                "AsyncMark" : "Mark",
                            ((PerfCounter - PerfCounterStart) *
                                    1000000) / PerfFrequency,
                            TmpPMmInfo->Name);
                    break;
                }
            case MMINFO_LOG_TYPE_CMCELLREFERRED:
                {
                    PSYSTEM_MMINFO_CMCELL_INFORMATION TmpPMmInfoCmCell;
                    TmpPMmInfoCmCell=(PSYSTEM_MMINFO_CMCELL_INFORMATION) Info;

                    printf("%12s,%10s,","Cell_Used","");
                    switch(TmpPMmInfoCmCell->Signature) {
                        case CM_KEY_NODE_SIGNATURE:
                            printf("%22s,%12s","Key_Node","");
                            break;
                        case CM_LINK_NODE_SIGNATURE:
                            printf("%22s,%12s","Link_Node","");
                            break;
                        case CM_KEY_VALUE_SIGNATURE:
                            printf("%22s,%12s","Key_Value","");
                            break;
                        case CM_KEY_FAST_LEAF:
                            printf("%22s,%12s","Index_Leaf","");
                            break;
                        case CM_KEY_SECURITY_SIGNATURE:
                            printf("%22s,%12s","Key_Security","");
                            break;
                        default:
                            printf("%22s,%12s","Unknown","");
                            break;
                    }
                        
                    printf(",%12x,%8d\n", TmpPMmInfoCmCell->Va, TmpPMmInfoCmCell->Size*-1);

                    break;
                }
            case MMINFO_LOG_TYPE_IMAGELOAD:
                {
                    PMMINFO_IMAGELOAD_INFORMATION TmpPMmInfo;
                    char WsNameBuf[30];
                    char * WsName = &WsNameBuf[0];

                    TmpPMmInfo = (PMMINFO_IMAGELOAD_INFORMATION) Info;
                    Info = TmpPMmInfo + 1;

                    if (TmpPMmInfo->ProcessId == 0) {
                        WsName = "System (  0)";
                    } else {
                        ULONG i;

                        i = TmpPMmInfo->ProcessId;

                        if (ProcessHash[i].ProcessID == TmpPMmInfo->ProcessId) {
                            sprintf(WsName, "%16s (%3d)",
                                                    ProcessHash[i].ImageFileName,
                                                    ProcessHash[i].ProcessID);
                        }else{
                            sprintf(WsName, "Process %13u", TmpPMmInfo->ProcessId);
                        }
                    }

                    printf(ImageLoadDataFormat,
                        TmpPMmInfo->ImageBase,
                        (ULONG)TmpPMmInfo->ImageBase + TmpPMmInfo->ImageSize,
                        TmpPMmInfo->ImageSectionNumber,
                        WsName,
                        TmpPMmInfo->ImageName
                        );

                    break;
                }
            case MMINFO_LOG_TYPE_SAMPLED_PROFILE:
                {
                    PMMINFO_SAMPLED_PROFILE_INFORMATION TmpPMmInfo;
                    TmpPMmInfo = (PMMINFO_SAMPLED_PROFILE_INFORMATION) Info;
                    Info = TmpPMmInfo + 1;

                    printf(SampledProfileDataFormat,
                        TmpPMmInfo->InstructionPointer,
                        TmpPMmInfo->Count                        
                        );

                    break;
                }

            default:
                // fprintf(stderr, "Tag Value %8d\n", Tag.u.Value);
                // fprintf(stderr, "TimeStamp       %8x %8x\n", TS.upper, TS.lower);
            break;
        }
    }
#else //NTMMPERF
    printf("Sorry but this is an internal tool!!!\n");
#endif //NTMMPERF
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmtr\perfmtrp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    perfmtrp.h

Abstract:

    This module contains NT/Win32 Perfmtr private data and types

Author:

    Mark Lucovsky (markl) 28-Mar-1991

Revision History:

--*/

#ifndef _PERFMTRP_
#define _PERFMTRP_

#define DOT_BUFF_LEN 10
#define DOT_CHAR '*'

char DotBuff[DOT_BUFF_LEN+2];

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <srvfsctl.h>

#endif // _PERFMTRP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmtr\memmon.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    MEMMON.c

Abstract:

    This module contains the NT/Win32 Pool Monitor

Author:

    Lou Perazzoli (loup) 13-Sep-1993

Revision History:

--*/

#include "perfmtrp.h"
#include <search.h>
#include <malloc.h>
#include <limits.h>
#include <stdlib.h>

#define BUFFER_SIZE 64*1024
#define MAX_BUFFER_SIZE 10*1024*1024

PCHAR       buffer;
ULONG CurrentBufferSize = BUFFER_SIZE;

#define CPU_USAGE 0
#define QUOTAS 1

#define TAG 0
#define ALLOC 1
#define FREE 2
#define DIFF 3
#define BYTES 4
#define EACH 5
#define LIGHT 6


#define NONPAGED 0
#define PAGED 1
#define BOTH 2

CHAR *PoolType[] = {
    "Nonp ",
    "Paged" };

CHAR LargeBuffer1[BUFFER_SIZE];
CHAR LargeBuffer2[BUFFER_SIZE];

#define NONAME_STRING_SIZE  14
CHAR NoName[] = {"No Name Found\0"};
ULONG TotalNoNameFound;

#define NOFILE_STRING_SIZE  13
CHAR NoFileName[] = {"No File Name\0"};
ULONG TotalNoFileFound;

#define META_FILE_STRING_SIZE 13
CHAR MetaFile[] = {"Fs Meta File\0"};
ULONG TotalFsMetaFile;

#define OUT_STRING_SIZE 60

typedef struct _MEMMON_OUT {
    ULONG Valid;
    ULONG Standby;
    ULONG Modified;
    ULONG PageTable;
    CHAR String[OUT_STRING_SIZE];
    WCHAR Null;
} MEMMON_OUT, *PMEMMON_OUT;

MEMMON_OUT OutBuffer[2000];

ULONG DisplayType = BOTH;
ULONG SortBy = TAG;
ULONG Paren;

ULONG DelayTimeMsec = 5000;

BOOLEAN Interactive;
ULONG NumberOfInputRecords;
INPUT_RECORD InputRecord;
HANDLE InputHandle;
HANDLE OriginalOutputHandle;
HANDLE OutputHandle;
DWORD OriginalInputMode;
WORD NormalAttribute;
WORD HighlightAttribute;
ULONG NumberOfCols;
ULONG NumberOfRows;
ULONG NumberOfDetailLines;
ULONG FirstDetailLine;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;
ULONG NoHighlight;

BOOLEAN DisplayTotals = FALSE;
MEMMON_OUT Totals[2];

typedef struct _FILTER {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    BOOLEAN Exclude;
} FILTER, *PFILTER;

#define MAX_FILTER 64
FILTER Filter[MAX_FILTER];
ULONG FilterCount = 0;

VOID
ShowHelpPopup( VOID );

int __cdecl
ulcomp(const void *e1,const void *e2);

int __cdecl
ulcomp(const void *e1,const void *e2)
{
    ULONG u1;

    switch (SortBy) {
        case TAG:

            u1 = (strcmp (((PMEMMON_OUT)e1)->String,
                          ((PMEMMON_OUT)e2)->String));
            return u1;
            break;

        case ALLOC:
            u1 = ((PMEMMON_OUT)e2)->Valid - ((PMEMMON_OUT)e1)->Valid;
            return (u1);
            break;

        case FREE:
            u1 = ((PMEMMON_OUT)e2)->Standby - ((PMEMMON_OUT)e1)->Standby;
            return (u1);
            break;

        case BYTES:
            u1 = ((PMEMMON_OUT)e2)->Modified - ((PMEMMON_OUT)e1)->Modified;
            return (u1);
            break;

        case DIFF:
            u1 = ((PMEMMON_OUT)e2)->PageTable - ((PMEMMON_OUT)e1)->PageTable;
            return (u1);
            break;

        case EACH:
            return (0);
            break;

        default:
            return(0);
            break;
    }
}

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    )
{
    ULONG i;
    CHAR tc;
    CHAR fc;

    for ( i = 0; i < 4; i++ ) {
        tc = *Tag++;
        fc = *Filter++;
        if ( fc == '*' ) return TRUE;
        if ( fc == '?' ) continue;
        if ( tc != fc ) return FALSE;
    }
    return TRUE;
}

BOOLEAN
CheckFilters (
    PSYSTEM_POOLTAG TagInfo
    )
{
    BOOLEAN pass;
    ULONG i;
    PCHAR tag;

    //
    // If there are no filters, all tags pass.
    //

    if ( FilterCount == 0 ) {
        return TRUE;
    }

    //
    // There are filters.  If the first filter excludes tags, then any
    // tag not explicitly mentioned passes.  If the first filter includes
    // tags, then any tag not explicitly mentioned fails.
    //

    if ( Filter[0].Exclude ) {
        pass = TRUE;
    } else {
        pass = FALSE;
    }

    tag = TagInfo->Tag;
    for ( i = 0; i < FilterCount; i++ ) {
        if ( CheckSingleFilter( tag, (PCHAR)&Filter[i].Tag ) ) {
            pass = !Filter[i].Exclude;
        }
    }

    return pass;
}

VOID
AddFilter (
    BOOLEAN Exclude,
    PCHAR FilterString
    )
{
    PFILTER f;
    PCHAR p;
    ULONG i;

    if ( FilterCount == MAX_FILTER ) {
        printf( "Too many filters specified.  Limit is %d\n", MAX_FILTER );
        return;
    }

    f = &Filter[FilterCount];
    p = f->Tag;

    for ( i = 0; i < 4; i++ ) {
        if ( *FilterString == 0 ) break;
        *p++ = *FilterString++;
    }
    for ( ; i < 4; i++ ) {
        *p++ = ' ';
    }

    f->Exclude = Exclude;
    FilterCount++;

    return;
}

VOID
ParseArgs (
    int argc,
    char *argv[]
    )
{
    char *p;
    BOOLEAN exclude;

    argc--;
    argv++;

    while ( argc-- > 0 ) {
        p  = *argv++;
        if ( *p == '-' || *p == '/' ) {
            p++;
            exclude = TRUE;
            switch ( tolower(*p) ) {
            case 'i':
                exclude = FALSE;
            case 'x':
                p++;
                if ( strlen(p) == 0 ) {
                    printf( "missing filter string\n" );
                    ExitProcess( 1 );
                } else if ( strlen(p) <= sizeof(ULONG) ) {
                    AddFilter( exclude, p );
                } else {
                    printf( "filter string too long: %s\n", p );
                    ExitProcess( 1 );
                }
                break;
            case 'e':
                DisplayTotals = TRUE;
                break;
            case 't':
                SortBy = TAG;
                break;
            case 'a':
                SortBy = ALLOC;
                break;
            case 'u':
            case 'b':
                SortBy = BYTES;
                break;
            case 'f':
                SortBy = FREE;
                break;
            case 'd':
                SortBy = DIFF;
                break;
            case 'm':
                SortBy = EACH;

            case 'l':
                NoHighlight = 1 - NoHighlight;
                break;

            case 'p':
                DisplayType += 1;
                if (DisplayType > BOTH) {
                    DisplayType = NONPAGED;
                }
                break;
            case '(':
            case ')':
                Paren += 1;
                break;
            default:
                printf( "unknown switch: %s\n", p );
                ExitProcess( 2 );
            }
        } else {
            printf( "unknown switch: %s\n", p );
            ExitProcess( 2 );
        }
    }

    return;
}

BOOL
WriteConsoleLine(
    HANDLE OutputHandle,
    WORD LineNumber,
    LPSTR Text,
    BOOL Highlight
    )
{
    COORD WriteCoord;
    DWORD NumberWritten;
    DWORD TextLength;

    WriteCoord.X = 0;
    WriteCoord.Y = LineNumber;
    if (!FillConsoleOutputCharacter( OutputHandle,
                                     ' ',
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       ) {
        return FALSE;
        }

    if (!FillConsoleOutputAttribute( OutputHandle,
                                     (WORD)((Highlight && !NoHighlight) ? HighlightAttribute : NormalAttribute),
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       ) {
        return FALSE;
        }


    if (Text == NULL || (TextLength = strlen( Text )) == 0) {
        return TRUE;
        }
    else {
        return WriteConsoleOutputCharacter( OutputHandle,
                                            Text,
                                            TextLength,
                                            WriteCoord,
                                            &NumberWritten
                                          );
        }
}

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    NTSTATUS Status;
    ULONG LastCount = 0;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    PSYSTEM_POOLTAG_INFORMATION PoolInfo;
    PSYSTEM_POOLTAG_INFORMATION PoolInfoOld;
    PUCHAR PreviousBuffer;
    PUCHAR CurrentBuffer;
    PUCHAR TempBuffer;
    BOOLEAN DoHelp;
    BOOLEAN DoQuit;
    int NumberOfPoolTags;
    int i;
    UCHAR LastKey;
    PMEMMON_OUT Out;
    LONG ScrollDelta;
    WORD DisplayLine, LastDetailRow;
    CHAR OutputBuffer[ 512 ];

    NTSTATUS status;
    PSYSTEM_MEMORY_INFORMATION MemInfo;
    PSYSTEM_MEMORY_INFO Info;
    PSYSTEM_MEMORY_INFO InfoEnd;
    PUCHAR String;
    ULONG TotalValid;
    ULONG TotalPageTable;
    ULONG TotalModified;
    ULONG TotalStandby;
    SYSTEMTIME Time;
    ULONG PageKb;

    DoHelp = FALSE;
    DoQuit = FALSE;
    Interactive = TRUE;

    buffer = VirtualAlloc (NULL,
                           MAX_BUFFER_SIZE,
                           MEM_RESERVE,
                           PAGE_READWRITE);

    if (buffer == NULL) {
        printf("Memory allocation failed\n");
        return 0;
    }

    buffer = VirtualAlloc (buffer,
                           BUFFER_SIZE,
                           MEM_COMMIT,
                           PAGE_READWRITE);

    if (buffer == NULL) {
        printf("Memory commit failed\n");
        return 0;
    }

    CurrentBufferSize = BUFFER_SIZE;
    ParseArgs( argc, argv );

    InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    OriginalOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    if (Interactive) {
        if (InputHandle == NULL ||
            OriginalOutputHandle == NULL ||
            !GetConsoleMode( InputHandle, &OriginalInputMode )
           ) {
            Interactive = FALSE;
        } else {
            OutputHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                                      FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                      NULL,
                                                      CONSOLE_TEXTMODE_BUFFER,
                                                      NULL
                                                    );
            if (OutputHandle == NULL ||
                !GetConsoleScreenBufferInfo( OriginalOutputHandle, &OriginalConsoleInfo ) ||
                !SetConsoleScreenBufferSize( OutputHandle, OriginalConsoleInfo.dwSize ) ||
                !SetConsoleActiveScreenBuffer( OutputHandle ) ||
                !SetConsoleMode( InputHandle, 0 )
               ) {
                if (OutputHandle != NULL) {
                    CloseHandle( OutputHandle );
                    OutputHandle = NULL;
                }

                Interactive = FALSE;
            } else {
                NormalAttribute = 0x1F;
                HighlightAttribute = 0x71;
                NumberOfCols = OriginalConsoleInfo.dwSize.X;
                NumberOfRows = OriginalConsoleInfo.dwSize.Y;
                NumberOfDetailLines = NumberOfRows;
            }
        }
    }

    NtQuerySystemInformation( SystemBasicInformation,
                              &BasicInfo,
                              sizeof(BasicInfo),
                              NULL
                            );

    if (GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
        SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
    }

    PageKb = BasicInfo.PageSize / 1024;

    PreviousBuffer = NULL;
    CurrentBuffer = LargeBuffer1;

    while(TRUE) {

        Status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &PerfInfo,
                    sizeof(PerfInfo),
                    NULL
                    );

        if ( !NT_SUCCESS(Status) ) {
            printf("Query perf Failed %lx\n",Status);
            break;
        }

retry01:
        status = NtQuerySystemInformation (SystemFullMemoryInformation,
                                           buffer,
                                           CurrentBufferSize,
                                           NULL);

        if ((status == STATUS_INFO_LENGTH_MISMATCH) ||
            (status == STATUS_DATA_OVERRUN)) {

            //
            // Increase buffer size.
            //

            CurrentBufferSize += 8192;

            buffer = VirtualAlloc (buffer,
                                   CurrentBufferSize,
                                   MEM_COMMIT,
                                   PAGE_READWRITE);
            if (buffer == NULL) {
                printf("Memory commit failed\n");
                ExitProcess(0);
            }
            goto retry01;
        }
        if (!NT_SUCCESS (status)) {
            printf("query system information failed %lx\n",status);
            return 1;
        }

        TotalValid = 0;
        TotalPageTable = 0;
        TotalStandby = 0;
        TotalModified = 0;
        MemInfo = (PSYSTEM_MEMORY_INFORMATION)buffer;
        Info = &MemInfo->Memory[0];
        InfoEnd = (PSYSTEM_MEMORY_INFO)MemInfo->StringStart;

        //
        // Calculate pool tags and display information.
        //

        PoolInfo = (PSYSTEM_POOLTAG_INFORMATION)CurrentBuffer;
        i = PoolInfo->Count;
        PoolInfoOld = (PSYSTEM_POOLTAG_INFORMATION)PreviousBuffer;

        DisplayLine = 0;
        sprintf( OutputBuffer,
                 " Memory:%8ldK Avail:%8ldK  PageFlts:%6ld   InRam Krnl:%5ldK P:%5ldK",
                 BasicInfo.NumberOfPhysicalPages*(BasicInfo.PageSize/1024),
                 PerfInfo.AvailablePages*(BasicInfo.PageSize/1024),
                 PerfInfo.PageFaultCount - LastCount,
                 (PerfInfo.ResidentSystemCodePage + PerfInfo.ResidentSystemDriverPage)*(BasicInfo.PageSize/1024),
                 (PerfInfo.ResidentPagedPoolPage)*(BasicInfo.PageSize/1024)
               );
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          OutputBuffer,
                          FALSE
                        );

        LastCount = PerfInfo.PageFaultCount;
        sprintf( OutputBuffer,
                 " Commit:%7ldK Limit:%7ldK Peak:%7ldK            Pool N:%5ldK P:%5ldK",
                 PerfInfo.CommittedPages*(BasicInfo.PageSize/1024),
                 PerfInfo.CommitLimit*(BasicInfo.PageSize/1024),
                 PerfInfo.PeakCommitment*(BasicInfo.PageSize/1024),
                 PerfInfo.NonPagedPoolPages*(BasicInfo.PageSize/1024),
                 PerfInfo.PagedPoolPages*(BasicInfo.PageSize/1024)
               );
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          OutputBuffer,
                          FALSE
                        );

        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          " Valid   Transition  Modified   PageTables   Name                            ",
                          FALSE
                        );
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          NULL,
                          FALSE
                        );

        Out = &OutBuffer[3];
        if (DisplayTotals) {
            RtlZeroMemory( Totals, sizeof(MEMMON_OUT)*2 );
        }

        TotalNoNameFound = 0;
        TotalFsMetaFile = 0;
        Out[0].Valid = 0;
        Out[0].PageTable = 0;
        Out[0].Standby = 0;
        Out[0].Modified = 0;
        RtlCopyMemory (Out[0].String, NoName, NONAME_STRING_SIZE);
        Out[1].Valid = 0;
        Out[1].PageTable = 0;
        Out[1].Standby = 0;
        Out[1].Modified = 0;
        RtlCopyMemory (Out[1].String, MetaFile, META_FILE_STRING_SIZE);
        Out[2].Valid = 0;
        Out[2].PageTable = 0;
        Out[2].Standby = 0;
        Out[2].Modified = 0;
        RtlCopyMemory (Out[2].String, NoFileName, NOFILE_STRING_SIZE);

        while (Info < InfoEnd) {

//            if ( !CheckFilters(&PoolInfo->TagInfo[i]) ) {
//                continue;
//            }

            Out->Valid = Info->ValidCount*PageKb * PageKb;
            Out->Modified = Info->PageTableCount*PageKb;
            Out->Standby = Info->TransitionCount*PageKb;
            Out->PageTable = Info->ModifiedCount*PageKb;

            TotalValid += Info->ValidCount;
            TotalPageTable += Info->PageTableCount;
            TotalStandby += Info->TransitionCount;
            TotalModified += Info->ModifiedCount;

            RtlZeroMemory (Out->String, OUT_STRING_SIZE);
            if (Info->StringOffset != 0) {
                if (*(PUCHAR)(Info->StringOffset + 1) == 0) {
                   WideCharToMultiByte (CP_ACP,
                                        0,
                                        (LPCWSTR)Info->StringOffset,
                                        -1,
                                        (LPSTR)Out->String,
                                        OUT_STRING_SIZE,
                                        NULL,
                                        NULL);
                } else {

                    if (!strncmp (Info->StringOffset, MetaFile, META_FILE_STRING_SIZE)) {
                        TotalNoNameFound += 1;
                        Out[1].Valid += Info->ValidCount*PageKb * PageKb;
                        Out[1].PageTable += Info->PageTableCount*PageKb;
                        Out[1].Standby += Info->TransitionCount*PageKb;
                        Out[1].Modified += Info->ModifiedCount*PageKb;
                        Out -= 1;
                    } else if (!strncmp (Info->StringOffset, NoFileName, NOFILE_STRING_SIZE)) {
                        TotalNoNameFound += 1;
                        Out[2].Valid += Info->ValidCount*PageKb * PageKb;
                        Out[2].PageTable += Info->PageTableCount*PageKb;
                        Out[2].Standby += Info->TransitionCount*PageKb;
                        Out[2].Modified += Info->ModifiedCount*PageKb;
                        Out -= 1;
                    } else {
                        RtlCopyMemory (Out->String, Info->StringOffset, OUT_STRING_SIZE);
                    }
                }
             } else {
                 TotalNoNameFound += 1;
                 Out[0].Valid += Info->ValidCount*PageKb * PageKb;
                 Out[0].PageTable += Info->PageTableCount*PageKb;
                 Out[0].Standby += Info->TransitionCount*PageKb;
                 Out[0].Modified += Info->ModifiedCount*PageKb;
                 Out -= 1;
             }
            Out += 1;
            Info += 1;
            i++;
        } //end for

        //
        // Sort the running working set buffer
        //

        NumberOfPoolTags = Out - &OutBuffer[0];
        qsort((void *)&OutBuffer,
              (size_t)NumberOfPoolTags,
              (size_t)sizeof(MEMMON_OUT),
              ulcomp);

        LastDetailRow = (WORD)(NumberOfRows - (DisplayTotals ? (DisplayType == BOTH ? 3 : 2) : 0));
        for (i = FirstDetailLine; i < NumberOfPoolTags; i++) {
            if (DisplayLine >= LastDetailRow) {
                break;
            }

            sprintf( OutputBuffer,
                     " %8ld %8ld %8ld %8ld %s",
                     OutBuffer[i].Valid,
                     OutBuffer[i].Standby,
                     OutBuffer[i].Modified,
                     OutBuffer[i].PageTable,
                     OutBuffer[i].String
                   );
            WriteConsoleLine( OutputHandle,
                              DisplayLine++,
                              OutputBuffer,
                              FALSE
                            );
        }

        if (DisplayTotals) {
            WriteConsoleLine( OutputHandle,
                              DisplayLine++,
                              NULL,
                              FALSE
                            );
            for (i = 0; i < 2; i++) {
                if ( (int)DisplayType == i || DisplayType == BOTH ) {
                    sprintf( OutputBuffer,
                             "Total %9ld %9ld %8ld %7ld",
                             TotalValid,
                             TotalStandby,
                             TotalModified,
                             TotalPageTable
                           );
                    WriteConsoleLine( OutputHandle,
                                      DisplayLine++,
                                      OutputBuffer,
                                      FALSE
                                    );
                }
            }
        }

        if (PreviousBuffer == NULL) {
            PreviousBuffer = LargeBuffer2;
        }
        TempBuffer = PreviousBuffer;
        PreviousBuffer = CurrentBuffer;
        CurrentBuffer = TempBuffer;

        while (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0) {
            //
            // Check for input record
            //
            if (ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown
               ) {
                LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;
                if (LastKey < ' ') {
                    ScrollDelta = 0;
                    if (LastKey == 'C'-'A'+1) {
                        DoQuit = TRUE;
                    } else switch (InputRecord.Event.KeyEvent.wVirtualKeyCode) {
                        case VK_ESCAPE:
                            DoQuit = TRUE;
                            break;

                        case VK_PRIOR:
                            ScrollDelta = -(LONG)(InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines);
                            break;

                        case VK_NEXT:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines;
                            break;

                        case VK_UP:
                            ScrollDelta = -InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_DOWN:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_HOME:
                            FirstDetailLine = 0;
                            break;

                        case VK_END:
                            FirstDetailLine = NumberOfPoolTags - NumberOfDetailLines;
                            break;
                    }

                    if (ScrollDelta != 0) {
                        if (ScrollDelta < 0) {
                            if (FirstDetailLine <= (ULONG)-ScrollDelta) {
                                FirstDetailLine = 0;
                            } else {
                                FirstDetailLine += ScrollDelta;
                            }
                        } else {
                            FirstDetailLine += ScrollDelta;
                            if (FirstDetailLine >= (NumberOfPoolTags - NumberOfDetailLines)) {
                                FirstDetailLine = NumberOfPoolTags - NumberOfDetailLines;
                            }
                        }
                    }
                } else {
                    switch (toupper( LastKey )) {
                        case 'Q':
                            //
                            //  Go to the bottom of the current screen when
                            //  we quit.
                            //
                            DoQuit = TRUE;
                            break;

                        case 'T':
                            SortBy = TAG;
                            FirstDetailLine = 0;
                            break;

                        case 'A':
                            SortBy = ALLOC;
                            FirstDetailLine = 0;
                            break;

                        case 'U':
                        case 'B':
                            SortBy = BYTES;
                            FirstDetailLine = 0;
                            break;

                        case 'F':
                            SortBy = FREE;
                            FirstDetailLine = 0;
                            break;

                        case 'D':
                            SortBy = DIFF;
                            FirstDetailLine = 0;
                            break;

                        case 'M':
                            SortBy = EACH;
                            FirstDetailLine = 0;
                            break;

                        case 'L':

                            NoHighlight = 1 - NoHighlight;
                            break;

                        case 'P':
                            DisplayType += 1;
                            if (DisplayType > BOTH) {
                                DisplayType = NONPAGED;
                            }
                            FirstDetailLine = 0;
                            break;

                        case 'X':
                        case '(':
                        case ')':

                            Paren += 1;
                            break;

                        case 'E':
                            DisplayTotals = !DisplayTotals;
                            FirstDetailLine = 0;
                            break;

                        case 'H':
                        case '?':
                            DoHelp = TRUE;
                            break;

                    }
                }

                break;
            }
        }

        if (DoQuit) {
            break;
        }

        if (DoHelp) {
            DoHelp = FALSE;
            ShowHelpPopup();
        }
    }

    if (Interactive) {
        SetConsoleActiveScreenBuffer( OriginalOutputHandle );
        SetConsoleMode( InputHandle, OriginalInputMode );
        CloseHandle( OutputHandle );
        }

    ExitProcess( 0 );
    return 0;
}


VOID
ShowHelpPopup( VOID )
{
    HANDLE PopupHandle;
    WORD n;

    PopupHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                             FILE_SHARE_WRITE | FILE_SHARE_READ,
                                             NULL,
                                             CONSOLE_TEXTMODE_BUFFER,
                                             NULL
                                           );
    if (PopupHandle == NULL) {
        return;
        }

    SetConsoleActiveScreenBuffer( PopupHandle );

    n = 0;

    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "                Poolmon Help", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " columns:", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Tag is the 4 byte tag given to the pool allocation", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Type is paged or nonp(aged)", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Allocs is count of all alloctions", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) is difference in Allocs column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Frees is count of all frees", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) difference in Frees column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Diff is (Allocs - Frees)", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Bytes is the total bytes consumed in pool", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) difference in Bytes column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Per Alloc is (Bytes / Diff)", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " switches:                                                                     ", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   ? or h - gives this help", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   q - quits", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   p - toggles default pool display between both, paged, and nonpaged", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   e - toggles totals lines on and off", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   l - toggles highlighting of changed lines on and off", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " sorting switches:", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   t - tag    a - allocations", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   f - frees  d - difference", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   b - bytes  m - per alloc", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (u is the same as b)", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "   ) - toggles sort between primary tag and value in (  )", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " command line switches", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -i<tag> - list only matching tags", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -x<tag> - list everything except matching tags", FALSE );
    WriteConsoleLine( PopupHandle, n++, "           <tag> can include * and ?", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -peltafdbum) - as listed above", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );

    while (TRUE) {
        if (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0 &&
            ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
            InputRecord.EventType == KEY_EVENT &&
            InputRecord.Event.KeyEvent.bKeyDown &&
            InputRecord.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE
           ) {
            break;
        }
    }

    SetConsoleActiveScreenBuffer( OutputHandle );
    CloseHandle( PopupHandle );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmtr\perfmtr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    perfmtr.c

Abstract:

    This module contains the NT/Win32 Performance Meter

Author:

    Mark Lucovsky (markl) 28-Mar-1991

Revision History:

--*/

#include "perfmtrp.h"

#define CPU_USAGE 0
#define VM_USAGE 1
#define POOL_USAGE 2
#define IO_USAGE 3
#define SRV_USAGE 4
#define CACHE_READS 5
#define VDM_USAGE 6
#define FILE_CACHE 7
#define RESIDENT_MEM 8

//
// Hi-Tech macro to figure out how much a field has changed by.
//

#define delta(FLD) (PerfInfo.FLD - PreviousPerfInfo.FLD)

#define vdelta(FLD) (VdmInfo.FLD - PreviousVdmInfo.FLD)

//
// Delta combining Wait and NoWait cases.
//

#define deltac(FLD) (delta(FLD##Wait) + delta(FLD##NoWait))

//
// Hit Rate Macro (includes a rare trip to MulDivia...)
//

#define hitrate(FLD) (((Changes = delta(FLD)) == 0) ? 0 :                                         \
                      ((Changes < (Misses = delta(FLD##Miss))) ? 0 :                              \
                      ((Changes - Misses) * 100 / Changes)))

//
// Hit Rate Macro combining Wait and NoWait cases
//

#define hitratec(FLD) (((Changes = deltac(FLD)) == 0) ? 0 :                                        \
                       ((Changes < (Misses = delta(FLD##WaitMiss) + delta(FLD##NoWaitMiss))) ? 0 : \
                       ((Changes - Misses) * 100 / Changes)))

//
// Arbitrary percent calculation.
//

#define percent(PART,TOTAL) (((TOTAL) == 0) ? 0 : ((PART) * 100 / (TOTAL)))

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_PERFORMANCE_INFORMATION PreviousPerfInfo;

#ifdef i386
    SYSTEM_VDM_INSTEMUL_INFO VdmInfo;
    SYSTEM_VDM_INSTEMUL_INFO PreviousVdmInfo;
#endif

    LARGE_INTEGER EndTime, BeginTime, ElapsedTime;
    ULONG DelayTimeMsec;
    ULONG DelayTimeTicks;
    ULONG PercentIdle;
    ULONG IdleDots;
    ULONG ProcessCount, ThreadCount, FileCount;
    ULONG Changes, Misses;
    POBJECT_TYPE_INFORMATION ObjectInfo;
    WCHAR Buffer[ 256 ];
    SYSTEM_FILECACHE_INFORMATION FileCacheInfo;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    ULONG PreviousFileCacheFaultCount;
    BOOLEAN PrintHelp = TRUE;
    BOOLEAN PrintHeader = TRUE;
    ULONG DisplayType = CPU_USAGE;
    INPUT_RECORD InputRecord;
    HANDLE ScreenHandle;
    UCHAR LastKey;
    ULONG NumberOfInputRecords;

    SRV_STATISTICS ServerInfo;
    SRV_STATISTICS PreviousServerInfo;
    HANDLE ServerDeviceHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    BOOLEAN ZeroServerStats;
    STRING DeviceName;
    UNICODE_STRING DeviceNameU;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE NullDeviceHandle = NULL;

    DelayTimeMsec = 2500;
    DelayTimeTicks = DelayTimeMsec * 10000;


    RtlInitString( &DeviceName, "\\Device\\Null" );
    RtlAnsiStringToUnicodeString(&DeviceNameU, &DeviceName, TRUE);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceNameU,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                 &NullDeviceHandle,
                 SYNCHRONIZE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 0,
                 FILE_SYNCHRONOUS_IO_NONALERT
                 );

    RtlFreeUnicodeString(&DeviceNameU);

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }
    if (!NT_SUCCESS(Status)) {
        printf(  "NtOpenFile (NULL device object) failed: %X\n", Status );
        return 0;
    }

    ScreenHandle = GetStdHandle (STD_INPUT_HANDLE);
    if (ScreenHandle == NULL) {
        printf("Error obtaining screen handle, error was: 0x%lx\n",
                GetLastError());
        return 0;
    }

    Status = NtQuerySystemInformation(
        SystemBasicInformation,
        &BasicInfo,
        sizeof(BasicInfo),
        NULL
        );

    if (NT_ERROR(Status)) {
        printf("Basic info failed x%lx\n",Status);
        return 0;
    }

    NtQuerySystemInformation(
        SystemPerformanceInformation,
        &PerfInfo,
        sizeof(PerfInfo),
        NULL
        );

    PreviousPerfInfo = PerfInfo;
#ifdef i386
    NtQuerySystemInformation(
        SystemVdmInstemulInformation,
        &VdmInfo,
        sizeof(VdmInfo),
        NULL
        );
    PreviousVdmInfo = VdmInfo;
#endif

    if ( argc > 1 ) {
        if ( argv[1][0] == '-' || argv[1][0] == '/') {
            switch ( argv[1][1] ) {
                case 'C':
                case 'c':
                    DisplayType = CPU_USAGE;
                    PrintHelp = FALSE;
                    break;

                case 'F':
                case 'f':
                    DisplayType = FILE_CACHE;
                    PrintHelp = FALSE;
                    PreviousFileCacheFaultCount = 0;
                    break;

                case 'v':
                case 'V':
                    DisplayType = VM_USAGE;
                    PrintHelp = FALSE;
                    break;

                case 'P':
                case 'p':
                    DisplayType = POOL_USAGE;
                    PrintHelp = FALSE;
                    break;

                case 'I':
                case 'i':
                    DisplayType = IO_USAGE;
                    PrintHelp = FALSE;
                    break;

#ifdef i386
                case 'X':
                case 'x':
                    DisplayType = VDM_USAGE;
                    PrintHelp = FALSE;
                    break;
#endif

                case 'S':
                case 's':
                    DisplayType = SRV_USAGE;
                    PrintHelp = FALSE;
                    ZeroServerStats = TRUE;
                    break;

                case 'R':
                case 'r':
                    DisplayType = CACHE_READS;
                    PrintHelp = FALSE;
                    break;

                case '?':
                default:
                    PrintHelp = FALSE;
                    printf("\nType :\n"
                           "\t'C'  for CPU usage\n"
                           "\t'V'  for VM usage\n"
                           "\t'F'  for File Cache usage\n"
                           "\t'R'  for Cache Manager reads and writes\n"
                           "\t'P'  for POOL usage\n"
                           "\t'I'  for I/O usage\n"
#ifdef i386
                           "\t'X'  for x86 Vdm Stats\n"
#endif
                           "\t'S'  for Server Stats\n"
                           "\t'H'  for header\n"
                           "\t'Q'  to quit\n\n");
            }
        }
    }

    while(TRUE) {

        while (WaitForSingleObject( ScreenHandle, DelayTimeMsec ) == STATUS_WAIT_0) {

            //
            // Check for input record
            //

            if (ReadConsoleInput( ScreenHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown
               ) {
                LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;


                //
                // Ignore control characters.
                //

                if (LastKey >= ' ') {

                    switch (toupper( LastKey )) {

                        case 'C':
                            DisplayType = CPU_USAGE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            break;

                        case 'F':
                            DisplayType = FILE_CACHE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            PreviousFileCacheFaultCount = 0;
                            break;

                        case 'H':
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            break;

                        case 'V':
                            DisplayType = VM_USAGE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            PreviousPerfInfo = PerfInfo;
                            break;

                        case 'P':
                            DisplayType = POOL_USAGE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            break;

                        case 'I':
                            DisplayType = IO_USAGE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            break;

#ifdef i386
                        case 'X':
                            DisplayType = VDM_USAGE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            break;
#endif

                        case 'S':
                            DisplayType = SRV_USAGE;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            ZeroServerStats = TRUE;
                            break;

                        case 'R':
                            DisplayType = CACHE_READS;
                            PrintHeader = TRUE;
                            PrintHelp = FALSE;
                            break;

                        case 'Q':
                            if (ServerDeviceHandle != NULL) {
                                NtClose(ServerDeviceHandle);
                            }
                            ExitProcess(0);

                        default:
                            break;
                    }
                }
            }
        }
        if (PrintHelp) {
            printf("\nType :\n"
                   "\t'C'  for CPU usage\n"
                   "\t'V'  for VM usage\n"
                   "\t'F'  for File Cache usage\n"
                   "\t'R'  for Cache Manager reads and writes\n"
                   "\t'P'  for POOL usage\n"
                   "\t'I'  for I/O usage\n"
#ifdef i386
                   "\t'X'  for x86 Vdm Stats\n"
#endif
                   "\t'S'  for Server Stats\n"
                   "\t'H'  for header\n"
                   "\t'Q'  to quit\n\n");
            PrintHelp = FALSE;
        }

        NtQuerySystemInformation(
            SystemPerformanceInformation,
            &PerfInfo,
            sizeof(PerfInfo),
            NULL
            );
#ifdef i386
        NtQuerySystemInformation(
            SystemVdmInstemulInformation,
            &VdmInfo,
            sizeof(VdmInfo),
            NULL
            );
#endif

        ObjectInfo = (POBJECT_TYPE_INFORMATION)Buffer;
        NtQueryObject( NtCurrentProcess(),
                       ObjectTypeInformation,
                       ObjectInfo,
                       sizeof( Buffer ),
                       NULL
                     );
        ProcessCount = ObjectInfo->TotalNumberOfObjects;

        NtQueryObject( NtCurrentThread(),
                       ObjectTypeInformation,
                       ObjectInfo,
                       sizeof( Buffer ),
                       NULL
                     );
        ThreadCount = ObjectInfo->TotalNumberOfObjects;

        NtQueryObject( NullDeviceHandle,
                       ObjectTypeInformation,
                       ObjectInfo,
                       sizeof( Buffer ),
                       NULL
                     );
        FileCount = ObjectInfo->TotalNumberOfObjects;

        switch (DisplayType) {

        case CPU_USAGE:

            EndTime = *(PLARGE_INTEGER)&PerfInfo.IdleProcessTime;
            BeginTime = *(PLARGE_INTEGER)&PreviousPerfInfo.IdleProcessTime;

            ElapsedTime.QuadPart = EndTime.QuadPart - BeginTime.QuadPart;
            PercentIdle = ((ElapsedTime.LowPart/BasicInfo.NumberOfProcessors)*100) / DelayTimeTicks;

            //
            //  Sometimes it takes significantly longer than 2.5 seconds
            //  to make a round trip.
            //

            if ( PercentIdle > 100 ) {

                PercentIdle = 100;
            }

            IdleDots = DOT_BUFF_LEN - (PercentIdle / 10 );

            memset(DotBuff,' ',DOT_BUFF_LEN);
            DotBuff[DOT_BUFF_LEN] = '|';
            DotBuff[DOT_BUFF_LEN+1] = '\0';
            memset(DotBuff,DOT_CHAR,IdleDots);

            if (PrintHeader) {
                printf("CPU Usage  Page Page Page InCore NonP Pgd  Incore Pgd  Incore Incore Proc Thd\n");
                printf("           Flts Aval Pool PgPool Pool Krnl  Krnl  Drvr  Drvr  Cache  Cnt  Cnt\n");
                PrintHeader = FALSE;
            }

            printf( "%s", DotBuff );
            printf( "%4ld %4ld %4ld (%4ld) %4ld %4ld (%4ld) %4ld (%4ld) (%4ld) %3ld %4ld\n",
                    PerfInfo.PageFaultCount - PreviousPerfInfo.PageFaultCount,
                    PerfInfo.AvailablePages,
                    PerfInfo.PagedPoolPages,
                    PerfInfo.ResidentPagedPoolPage,
                    PerfInfo.NonPagedPoolPages,
                    PerfInfo.TotalSystemCodePages,
                    PerfInfo.ResidentSystemCodePage,
                    PerfInfo.TotalSystemDriverPages,
                    PerfInfo.ResidentSystemDriverPage,
                    PerfInfo.ResidentSystemCachePage,
                    ProcessCount,
                    ThreadCount
                  );
            break;

        case VM_USAGE:

            if (PrintHeader) {
                printf("avail  page   COW  Tran  Cache Demd Read  Read Cache Cache Page Write Map   Map\n");
                printf("pages faults             Tran  zero flts  I/Os  flts  I/Os writ I/Os  write I/O\n");
                PrintHeader = FALSE;
            }

            printf( "%5ld %5ld %4ld %5ld %5ld %5ld %5ld %5ld %5ld%5ld%5ld%5ld%6ld%5ld\n",
                    PerfInfo.AvailablePages,
                    PerfInfo.PageFaultCount - PreviousPerfInfo.PageFaultCount,
                    PerfInfo.CopyOnWriteCount - PreviousPerfInfo.CopyOnWriteCount,
                    PerfInfo.TransitionCount - PreviousPerfInfo.TransitionCount,
                    PerfInfo.CacheTransitionCount - PreviousPerfInfo.CacheTransitionCount,
                    PerfInfo.DemandZeroCount - PreviousPerfInfo.DemandZeroCount,
                    PerfInfo.PageReadCount - PreviousPerfInfo.PageReadCount,
                    PerfInfo.PageReadIoCount - PreviousPerfInfo.PageReadIoCount,
                    PerfInfo.CacheReadCount - PreviousPerfInfo.CacheReadCount,
                    PerfInfo.CacheIoCount - PreviousPerfInfo.CacheIoCount,
                    PerfInfo.DirtyPagesWriteCount - PreviousPerfInfo.DirtyPagesWriteCount,
                    PerfInfo.DirtyWriteIoCount - PreviousPerfInfo.DirtyWriteIoCount,
                    PerfInfo.MappedPagesWriteCount - PreviousPerfInfo.MappedPagesWriteCount,
                    PerfInfo.MappedWriteIoCount - PreviousPerfInfo.MappedWriteIoCount
                 );


            break;

        case CACHE_READS:

            if (PrintHeader) {
                PrintHeader = FALSE;
                printf("    Map    Cnv     Pin       Copy        Mdl     Read Fast  Fast Fast Lazy Lazy\n");
                printf("    Read   To      Read      Read        Read    Ahed Read  Read Read Wrts Wrt\n");
                printf("      Hit  Pin        Hit        Hit        Hit  I/Os Calls Resc Not  I/Os Pgs\n");
                printf("Count Rate Rate Count Rate Count Rate Count Rate            Miss Poss         \n");
            }

            printf("%05ld %4ld %4ld %05ld %4ld %05ld %4ld %05ld %4ld %4ld %5ld %4ld %4ld %4ld %4ld\n",
                   deltac(CcMapData),
                   hitratec(CcMapData),
                   percent(delta(CcPinMappedDataCount),deltac(CcMapData)),
                   deltac(CcPinRead),
                   hitratec(CcPinRead),
                   deltac(CcCopyRead),
                   hitratec(CcCopyRead),
                   deltac(CcMdlRead),
                   hitratec(CcMdlRead),
                   delta(CcReadAheadIos),
                   deltac(CcFastRead),
                   delta(CcFastReadResourceMiss),
                   delta(CcFastReadNotPossible),
                   delta(CcLazyWriteIos),
                   delta(CcLazyWritePages));
            break;
#ifdef i386
        case VDM_USAGE:

            if (PrintHeader) {
                PrintHeader = FALSE;
                printf("PUSHF  POPF  IRET   HLT   CLI   STI   BOP SEGNOTP\n");
            }

            printf("%5d %5d %5d %5d %5d %5d %5d %7d\n",
                   vdelta(OpcodePUSHF),
                   vdelta(OpcodePOPF),
                   vdelta(OpcodeIRET),
                   vdelta(OpcodeHLT),
                   vdelta(OpcodeCLI),
                   vdelta(OpcodeSTI),
                   vdelta(BopCount),
                   vdelta(SegmentNotPresent)
                  );
            break;
#endif
        case POOL_USAGE:

            if (PrintHeader) {
                printf("Paged Paged Paged  Non   Non    Non    Page Paged Non    Commit  Commit SysPte\n");
                printf("Alloc Freed   A-F  Alloc Freed  A-F    Aval Pages Pages  Pages   Limit   Free\n");
                PrintHeader = FALSE;
            }

            printf( "%5ld %5ld %5ld %5ld %5ld %5ld   %5ld %5ld %5ld %6ld %6ld %7ld\n",
                    PerfInfo.PagedPoolAllocs - PreviousPerfInfo.PagedPoolAllocs,
                    PerfInfo.PagedPoolFrees - PreviousPerfInfo.PagedPoolFrees,
                    PerfInfo.PagedPoolAllocs - PerfInfo.PagedPoolFrees,
                    PerfInfo.NonPagedPoolAllocs - PreviousPerfInfo.NonPagedPoolAllocs,
                    PerfInfo.NonPagedPoolFrees - PreviousPerfInfo.NonPagedPoolFrees,
                    PerfInfo.NonPagedPoolAllocs - PerfInfo.NonPagedPoolFrees,
                    PerfInfo.AvailablePages,
                    PerfInfo.PagedPoolPages,
                    PerfInfo.NonPagedPoolPages,
                    PerfInfo.CommittedPages,
                    PerfInfo.CommitLimit,
                    PerfInfo.FreeSystemPtes
                 );


            break;

        case IO_USAGE:

            if (PrintHeader) {
                printf(" Read Write Other     Read    Write    Other     File       File\n");
                printf(" I/Os  I/Os  I/Os     Xfer     Xfer     Xfer    Objects    Handles\n");
                PrintHeader = FALSE;
            }

            printf( "%5ld %5ld %5ld %8ld %8ld %8ld %8ld   %8ld\n",
                    PerfInfo.IoReadOperationCount - PreviousPerfInfo.IoReadOperationCount,
                    PerfInfo.IoWriteOperationCount - PreviousPerfInfo.IoWriteOperationCount,
                    PerfInfo.IoOtherOperationCount - PreviousPerfInfo.IoOtherOperationCount,
                        PerfInfo.IoReadTransferCount.QuadPart -
                        PreviousPerfInfo.IoReadTransferCount.QuadPart,
                        PerfInfo.IoWriteTransferCount.QuadPart -
                        PreviousPerfInfo.IoWriteTransferCount.QuadPart,
                        PerfInfo.IoOtherTransferCount.QuadPart -
                        PreviousPerfInfo.IoOtherTransferCount.QuadPart,
                    FileCount,
                    ObjectInfo->TotalNumberOfHandles
                 );


            break;

        case SRV_USAGE:

            if (ServerDeviceHandle == NULL) {
                RtlInitString( &DeviceName, SERVER_DEVICE_NAME );
                RtlAnsiStringToUnicodeString(&DeviceNameU, &DeviceName, TRUE);
                InitializeObjectAttributes(
                    &ObjectAttributes,
                    &DeviceNameU,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );


                Status = NtOpenFile(
                             &ServerDeviceHandle,
                             SYNCHRONIZE,
                             &ObjectAttributes,
                             &IoStatusBlock,
                             0,
                             FILE_SYNCHRONOUS_IO_NONALERT
                             );

                RtlFreeUnicodeString(&DeviceNameU);

                if (NT_SUCCESS(Status)) {
                    Status = IoStatusBlock.Status;
                }
                if (!NT_SUCCESS(Status)) {
                    printf(  "NtOpenFile (server device object) failed: %X\n", Status );
                    break;
                }

            }

            Status = NtFsControlFile(
                         ServerDeviceHandle,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         FSCTL_SRV_GET_STATISTICS,
                         NULL, 0,
                         &ServerInfo, sizeof(ServerInfo)
                         );
            if (NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
            }
            if (!NT_SUCCESS(Status)) {
                printf(  "NtFsControlFile failed: %X\n", Status );
                ServerDeviceHandle = NULL;
                break;
            }

            if (PrintHeader) {
                printf( "  Bytes   Bytes    Paged NonPaged                Logn WItm\n");
                printf( "   Rcvd    Sent     Pool     Pool Sess File Srch Errs Shtg\n");
                PrintHeader = FALSE;
            }

            if (ZeroServerStats) {
                PreviousServerInfo = ServerInfo;
                ZeroServerStats = FALSE;
            }

            {
                LARGE_INTEGER BytesReceived, BytesSent;

                BytesReceived.QuadPart =
                                    ServerInfo.TotalBytesReceived.QuadPart -
                                PreviousServerInfo.TotalBytesReceived.QuadPart;
                BytesSent.QuadPart =
                                ServerInfo.TotalBytesSent.QuadPart -
                                PreviousServerInfo.TotalBytesSent.QuadPart;

                printf( "%7ld %7ld %8ld %8ld %4ld %4ld %4ld %4ld %4ld\n",
                            BytesReceived.LowPart,
                            BytesSent.LowPart,
                            ServerInfo.CurrentPagedPoolUsage,
                            ServerInfo.CurrentNonPagedPoolUsage,
                            ServerInfo.CurrentNumberOfSessions,
                            ServerInfo.CurrentNumberOfOpenFiles,
                            ServerInfo.CurrentNumberOfOpenSearches,
                            ServerInfo.LogonErrors,
                            ServerInfo.WorkItemShortages
                            );
            }

            PreviousServerInfo = ServerInfo;
            break;

        case FILE_CACHE:

            if (PrintHeader) {
                printf("Avail  Page   Current  Peak    Fault    Fault\n");
                printf("Pages Faults  Size Kb  Size    Total    Count\n");
                PrintHeader = FALSE;
            }

            NtQuerySystemInformation(
                SystemFileCacheInformation,
                &FileCacheInfo,
                sizeof(FileCacheInfo),
                NULL
                );

            printf( "%5ld %5ld %7ld %7ld %8ld %8ld\n",
                    PerfInfo.AvailablePages,
                    PerfInfo.PageFaultCount - PreviousPerfInfo.PageFaultCount,
                    FileCacheInfo.CurrentSize / 1024,
                    FileCacheInfo.PeakSize / 1024,
                    FileCacheInfo.PageFaultCount,
                    FileCacheInfo.PageFaultCount - PreviousFileCacheFaultCount
                 );

            PreviousFileCacheFaultCount = FileCacheInfo.PageFaultCount;
            break;

        }
        PreviousPerfInfo = PerfInfo;
#ifdef i386
        PreviousVdmInfo = VdmInfo;
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmtr\poolmon.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    poolmon.c

Abstract:

    This module contains the NT/Win32 Pool Monitor

Author:

    Lou Perazzoli (loup) 13-Sep-1993

Revision History:

--*/

#include "perfmtrp.h"
#include <search.h>
#include <malloc.h>
#include <limits.h>
#include <stdlib.h>

//
// the amount of memory to increase the size
// of the buffer for NtQuerySystemInformation at each step
//

#define BUFFER_SIZE_STEP    65536

#define CPU_USAGE 0
#define QUOTAS 1

#define TAG 0
#define ALLOC 1
#define FREE 2
#define DIFF 3
#define BYTES 4
#define EACH 5
#define LIGHT 6


#define NONPAGED 0
#define PAGED 1
#define BOTH 2

UCHAR *PoolType[] = {
    "Nonp ",
    "Paged" };

PUCHAR LargeBuffer1 = NULL;
PUCHAR LargeBuffer2 = NULL;

size_t LargeBuffer1Size = 0;
size_t LargeBuffer2Size = 0;

typedef struct _POOLMON_OUT {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    UCHAR NullByte;
    BOOLEAN Changed;
    ULONG Type;
    SIZE_T Allocs;
    SIZE_T AllocsDiff;
    SIZE_T Frees;
    SIZE_T FreesDiff;
    SIZE_T Allocs_Frees;
    SIZE_T Used;
    SIZE_T UsedDiff;
    SIZE_T Each;
} POOLMON_OUT, *PPOOLMON_OUT;

POOLMON_OUT OutBuffer[2000];

ULONG DisplayType = BOTH;
ULONG SortBy = TAG;
ULONG Paren;

ULONG DelayTimeMsec = 5000;

BOOLEAN Interactive;
ULONG NumberOfInputRecords;
INPUT_RECORD InputRecord;
HANDLE InputHandle;
HANDLE OriginalOutputHandle;
HANDLE OutputHandle;
DWORD OriginalInputMode;
WORD NormalAttribute;
WORD HighlightAttribute;
ULONG NumberOfCols;
ULONG NumberOfRows;
ULONG NumberOfDetailLines;
SIZE_T FirstDetailLine;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;
ULONG NoHighlight;

BOOLEAN DisplayTotals = FALSE;
POOLMON_OUT Totals[2];

typedef struct _FILTER {
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
    BOOLEAN Exclude;
} FILTER, *PFILTER;

#define MAX_FILTER 64
FILTER Filter[MAX_FILTER];
ULONG FilterCount = 0;

VOID
ShowHelpPopup( VOID );

int __cdecl
ulcomp(const void *e1,const void *e2);

int __cdecl
ulcomp(const void *e1,const void *e2)
{
    LONG_PTR u1;

    switch (SortBy) {
        case TAG:

            u1 = ((PUCHAR)e1)[0] - ((PUCHAR)e2)[0];
            if (u1 != 0) {
                return u1 > 0 ? 1 : -1;
            }
            u1 = ((PUCHAR)e1)[1] - ((PUCHAR)e2)[1];
            if (u1 != 0) {
                return u1 > 0 ? 1 : -1;
            }
            u1 = ((PUCHAR)e1)[2] - ((PUCHAR)e2)[2];
            if (u1 != 0) {
                return u1 > 0 ? 1 : -1;
            }
            u1 = ((PUCHAR)e1)[3] - ((PUCHAR)e2)[3];
            if (u1 == 0) {
                return 0;
            } else {
                return u1 > 0 ? 1 : -1;
            }
            break;

        case ALLOC:
            if (Paren & 1) {
                u1 = ((PPOOLMON_OUT)e2)->AllocsDiff -
                        ((PPOOLMON_OUT)e1)->AllocsDiff;
            } else {
                u1 = ((PPOOLMON_OUT)e2)->Allocs -
                        ((PPOOLMON_OUT)e1)->Allocs;
            }
            if (u1 == 0) {
                return 0;
            } else {
                return u1 > 0 ? 1 : -1;
            }
            break;

        case FREE:
            if (Paren & 1) {
                u1 = ((PPOOLMON_OUT)e2)->FreesDiff -
                        ((PPOOLMON_OUT)e1)->FreesDiff;
            } else {
                u1 = ((PPOOLMON_OUT)e2)->Frees -
                        ((PPOOLMON_OUT)e1)->Frees;
            }
            if (u1 == 0) {
                return 0;
            } else {
                return u1 > 0 ? 1 : -1;
            }
            break;

        case BYTES:
            if (Paren & 1) {
                u1 = ((PPOOLMON_OUT)e2)->UsedDiff -
                        ((PPOOLMON_OUT)e1)->UsedDiff;
            } else {
                u1 = ((PPOOLMON_OUT)e2)->Used -
                        ((PPOOLMON_OUT)e1)->Used;
            }
            if (u1 == 0) {
                return 0;
            } else {
                return u1 > 0 ? 1 : -1;
            }
            break;

        case DIFF:
            u1 = ((PPOOLMON_OUT)e2)->Allocs_Frees -
                    ((PPOOLMON_OUT)e1)->Allocs_Frees;
            if (u1 == 0) {
                return 0;
            } else {
                return u1 > 0 ? 1 : -1;
            }
            break;

        case EACH:
            u1 = ((PPOOLMON_OUT)e2)->Each -
                    ((PPOOLMON_OUT)e1)->Each;
            if (u1 == 0) {
                return 0;
            } else {
                return u1 > 0 ? 1 : -1;
            }
            break;

        default:
            return(0);
            break;
    }
}

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    )
{
    ULONG i;
    CHAR tc;
    CHAR fc;

    for ( i = 0; i < 4; i++ ) {
        tc = *Tag++;
        fc = *Filter++;
        if ( fc == '*' ) return TRUE;
        if ( fc == '?' ) continue;
        if ( tc != fc ) return FALSE;
    }
    return TRUE;
}

BOOLEAN
CheckFilters (
    PSYSTEM_POOLTAG TagInfo
    )
{
    BOOLEAN pass;
    ULONG i;
    PCHAR tag;

    //
    // If there are no filters, all tags pass.
    //

    if ( FilterCount == 0 ) {
        return TRUE;
    }

    //
    // There are filters.  If the first filter excludes tags, then any
    // tag not explicitly mentioned passes.  If the first filter includes
    // tags, then any tag not explicitly mentioned fails.
    //

    if ( Filter[0].Exclude ) {
        pass = TRUE;
    } else {
        pass = FALSE;
    }

    tag = TagInfo->Tag;
    for ( i = 0; i < FilterCount; i++ ) {
        if ( CheckSingleFilter( tag, (PCHAR)&Filter[i].Tag ) ) {
            pass = !Filter[i].Exclude;
        }
    }

    return pass;
}

VOID
AddFilter (
    BOOLEAN Exclude,
    PCHAR FilterString
    )
{
    PFILTER f;
    PCHAR p;
    ULONG i;

    if ( FilterCount == MAX_FILTER ) {
        printf( "Too many filters specified.  Limit is %d\n", MAX_FILTER );
        return;
    }

    f = &Filter[FilterCount];
    p = f->Tag;

    for ( i = 0; i < 4; i++ ) {
        if ( *FilterString == 0 ) break;
        *p++ = *FilterString++;
    }
    for ( ; i < 4; i++ ) {
        *p++ = ' ';
    }

    f->Exclude = Exclude;
    FilterCount++;

    return;
}

VOID
ParseArgs (
    int argc,
    char *argv[]
    )
{
    char *p;
    BOOLEAN exclude;

    argc--;
    argv++;

    while ( argc-- > 0 ) {
        p  = *argv++;
        if ( *p == '-' || *p == '/' ) {
            p++;
            exclude = TRUE;
            switch ( tolower(*p) ) {
            case 'i':
                exclude = FALSE;
            case 'x':
                p++;
                if ( strlen(p) == 0 ) {
                    printf( "missing filter string\n" );
                    ExitProcess( 1 );
                } else if ( strlen(p) <= sizeof(ULONG) ) {
                    AddFilter( exclude, p );
                } else {
                    printf( "filter string too long: %s\n", p );
                    ExitProcess( 1 );
                }
                break;
            case 'e':
                DisplayTotals = TRUE;
                break;
            case 't':
                SortBy = TAG;
                break;
            case 'a':
                SortBy = ALLOC;
                break;
            case 'u':
            case 'b':
                SortBy = BYTES;
                break;
            case 'f':
                SortBy = FREE;
                break;
            case 'd':
                SortBy = DIFF;
                break;
            case 'm':
                SortBy = EACH;

            case 'l':
                NoHighlight = 1 - NoHighlight;
                break;

            case 'p':
                DisplayType += 1;
                if (DisplayType > BOTH) {
                    DisplayType = NONPAGED;
                }
                break;
            case '(':
            case ')':
                Paren += 1;
                break;
            default:
                printf( "unknown switch: %s\n", p );
                ExitProcess( 2 );
            }
        } else {
            printf( "unknown switch: %s\n", p );
            ExitProcess( 2 );
        }
    }

    return;
}

BOOL
WriteConsoleLine(
    HANDLE OutputHandle,
    WORD LineNumber,
    LPSTR Text,
    BOOL Highlight
    )
{
    COORD WriteCoord;
    DWORD NumberWritten;
    DWORD TextLength;

    WriteCoord.X = 0;
    WriteCoord.Y = LineNumber;
    if (!FillConsoleOutputCharacter( OutputHandle,
                                     ' ',
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       ) {
        return FALSE;
        }

    if (!FillConsoleOutputAttribute( OutputHandle,
                                     (WORD)((Highlight && !NoHighlight) ? HighlightAttribute : NormalAttribute),
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       ) {
        return FALSE;
        }


    if (Text == NULL || (TextLength = strlen( Text )) == 0) {
        return TRUE;
        }
    else {
        return WriteConsoleOutputCharacter( OutputHandle,
                                            Text,
                                            TextLength,
                                            WriteCoord,
                                            &NumberWritten
                                          );
        }
}


NTSTATUS
QueryPoolTagInformationIterative(
    PUCHAR *CurrentBuffer,
    size_t *CurrentBufferSize
    )
{
    size_t NewBufferSize;
    NTSTATUS ReturnedStatus = STATUS_SUCCESS;

    if( CurrentBuffer == NULL || CurrentBufferSize == NULL ) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // there is no buffer allocated yet
    //

    if( *CurrentBufferSize == 0 || *CurrentBuffer == NULL ) {

        NewBufferSize = sizeof( UCHAR ) * BUFFER_SIZE_STEP;

        *CurrentBuffer = (PUCHAR) malloc( NewBufferSize );

        if( *CurrentBuffer != NULL ) {

            *CurrentBufferSize = NewBufferSize;
        
        } else {

            //
            // insufficient memory
            //

            ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // iterate by buffer's size
    //

    while( *CurrentBuffer != NULL ) {

        ReturnedStatus = NtQuerySystemInformation (
            SystemPoolTagInformation,
            *CurrentBuffer,
            (ULONG)*CurrentBufferSize,
            NULL );

        if( ! NT_SUCCESS(ReturnedStatus) ) {

            //
            // free the current buffer
            //

            free( *CurrentBuffer );
            
            *CurrentBuffer = NULL;

            if (ReturnedStatus == STATUS_INFO_LENGTH_MISMATCH) {

                //
                // try with a greater buffer size
                //

                NewBufferSize = *CurrentBufferSize + BUFFER_SIZE_STEP;

                *CurrentBuffer = (PUCHAR) malloc( NewBufferSize );

                if( *CurrentBuffer != NULL ) {

                    //
                    // allocated new buffer
                    //

                    *CurrentBufferSize = NewBufferSize;

                } else {

                    //
                    // insufficient memory
                    //

                    ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

                    *CurrentBufferSize = 0;

                }

            } else {

                *CurrentBufferSize = 0;

            }

        } else  {

            //
            // NtQuerySystemInformation returned success
            //

            break;

        }
    }

    return ReturnedStatus;
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{

    NTSTATUS Status;
    ULONG LastCount = 0;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    PSYSTEM_POOLTAG_INFORMATION PoolInfo;
    PSYSTEM_POOLTAG_INFORMATION PoolInfoOld;
    PUCHAR *PreviousBuffer;
    PUCHAR *CurrentBuffer;
    PUCHAR *TempBuffer;
    size_t *PreviousBufferSize;
    size_t *CurrentBufferSize;
    size_t *TempBufferSize;
    BOOLEAN DoHelp;
    BOOLEAN DoQuit;
    SIZE_T NumberOfPoolTags;
    SIZE_T i;
    UCHAR LastKey;
    PPOOLMON_OUT Out;
    LONG ScrollDelta;
    WORD DisplayLine, LastDetailRow;
    CHAR OutputBuffer[ 512 ];

    DoHelp = FALSE;
    DoQuit = FALSE;
    Interactive = TRUE;

    ParseArgs( argc, argv );

    InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    OriginalOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    if (Interactive) {
        if (InputHandle == NULL ||
            OriginalOutputHandle == NULL ||
            !GetConsoleMode( InputHandle, &OriginalInputMode )
           ) {
            Interactive = FALSE;
        } else {
            OutputHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                                      FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                      NULL,
                                                      CONSOLE_TEXTMODE_BUFFER,
                                                      NULL
                                                    );
            if (OutputHandle == NULL ||
                !GetConsoleScreenBufferInfo( OriginalOutputHandle, &OriginalConsoleInfo ) ||
                !SetConsoleScreenBufferSize( OutputHandle, OriginalConsoleInfo.dwSize ) ||
                !SetConsoleActiveScreenBuffer( OutputHandle ) ||
                !SetConsoleMode( InputHandle, 0 )
               ) {
                if (OutputHandle != NULL) {
                    CloseHandle( OutputHandle );
                    OutputHandle = NULL;
                }

                Interactive = FALSE;
            } else {
                NormalAttribute = 0x1F;
                HighlightAttribute = 0x71;
                NumberOfCols = OriginalConsoleInfo.dwSize.X;
                NumberOfRows = OriginalConsoleInfo.dwSize.Y;
                NumberOfDetailLines = NumberOfRows;
            }
        }
    }

    NtQuerySystemInformation( SystemBasicInformation,
                              &BasicInfo,
                              sizeof(BasicInfo),
                              NULL
                            );

    if (GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
        SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
    }

    PreviousBuffer = &LargeBuffer2;             // NULL at this point
    PreviousBufferSize = &LargeBuffer2Size;     // 0 at this point
    
    CurrentBuffer = &LargeBuffer1;              // NULL at this point
    CurrentBufferSize = &LargeBuffer1Size;      // 0 at this point

    while(TRUE) {
        Status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &PerfInfo,
                    sizeof(PerfInfo),
                    NULL
                    );

        if ( !NT_SUCCESS(Status) ) {
            printf("Query perf Failed (returned: %lx)\n",
						 Status);
            break;
        }


        Status = QueryPoolTagInformationIterative(
                    CurrentBuffer,
                    CurrentBufferSize
                    );

        if ( !NT_SUCCESS(Status) ) {
            printf("Query pooltags failed (returned: %lx)\n"
						 "Did you remember to enable pool tagging with gflags.exe and reboot?\n",
						 Status);
            break;
        }

        //
        // Calculate pool tags and display information.
        //
        //

        PoolInfo = (PSYSTEM_POOLTAG_INFORMATION)( *CurrentBuffer );
        i = PoolInfo->Count;
        PoolInfoOld = (PSYSTEM_POOLTAG_INFORMATION)( *PreviousBuffer );

        DisplayLine = 0;
        sprintf( OutputBuffer,
                 " Memory:%8ldK Avail:%8ldK  PageFlts:%6ld   InRam Krnl:%5ldK P:%5ldK",
                 BasicInfo.NumberOfPhysicalPages*(BasicInfo.PageSize/1024),
                 PerfInfo.AvailablePages*(BasicInfo.PageSize/1024),
                 PerfInfo.PageFaultCount - LastCount,
                 (PerfInfo.ResidentSystemCodePage + PerfInfo.ResidentSystemDriverPage)*(BasicInfo.PageSize/1024),
                 (PerfInfo.ResidentPagedPoolPage)*(BasicInfo.PageSize/1024)
               );
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          OutputBuffer,
                          FALSE
                        );

        LastCount = PerfInfo.PageFaultCount;
        sprintf( OutputBuffer,
                 " Commit:%7ldK Limit:%7ldK Peak:%7ldK            Pool N:%5ldK P:%5ldK",
                 PerfInfo.CommittedPages*(BasicInfo.PageSize/1024),
                 PerfInfo.CommitLimit*(BasicInfo.PageSize/1024),
                 PerfInfo.PeakCommitment*(BasicInfo.PageSize/1024),
                 PerfInfo.NonPagedPoolPages*(BasicInfo.PageSize/1024),
                 PerfInfo.PagedPoolPages*(BasicInfo.PageSize/1024)
               );
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          OutputBuffer,
                          FALSE
                        );

        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          " Tag  Type     Allocs            Frees            Diff   Bytes      Per Alloc",
                          FALSE
                        );
        WriteConsoleLine( OutputHandle,
                          DisplayLine++,
                          NULL,
                          FALSE
                        );

        Out = &OutBuffer[0];
        if (DisplayTotals) {
            RtlZeroMemory( Totals, sizeof(POOLMON_OUT)*2 );
        }

        for (i = 0; i < (int)PoolInfo->Count; i++) {

            if ( !CheckFilters(&PoolInfo->TagInfo[i]) ) {
                continue;
            }

            if ((PoolInfo->TagInfo[i].NonPagedAllocs != 0) &&
                 (DisplayType != PAGED)) {

                Out->Allocs = PoolInfo->TagInfo[i].NonPagedAllocs;
                Out->Frees = PoolInfo->TagInfo[i].NonPagedFrees;
                Out->Used = PoolInfo->TagInfo[i].NonPagedUsed;
                Out->Allocs_Frees = PoolInfo->TagInfo[i].NonPagedAllocs -
                                PoolInfo->TagInfo[i].NonPagedFrees;
                Out->TagUlong = PoolInfo->TagInfo[i].TagUlong;
                Out->Type = NONPAGED;
                Out->Changed = FALSE;
                Out->NullByte = '\0';

                if (PoolInfoOld != NULL &&
                    PoolInfoOld->Count > i && 
                    PoolInfoOld->TagInfo[i].TagUlong == PoolInfo->TagInfo[i].TagUlong
                   ) {
                    Out->AllocsDiff = PoolInfo->TagInfo[i].NonPagedAllocs - PoolInfoOld->TagInfo[i].NonPagedAllocs;
                    Out->FreesDiff = PoolInfo->TagInfo[i].NonPagedFrees - PoolInfoOld->TagInfo[i].NonPagedFrees;
                    Out->UsedDiff = PoolInfo->TagInfo[i].NonPagedUsed - PoolInfoOld->TagInfo[i].NonPagedUsed;
                    if (Out->AllocsDiff != 0 ||
                        Out->FreesDiff != 0 ||
                        Out->UsedDiff != 0
                       ) {
                        Out->Changed = TRUE;
                    }
                } else {
                    Out->AllocsDiff = 0;
                    Out->UsedDiff = 0;
                    Out->FreesDiff = 0;
                }
                Out->Each =  Out->Used / (Out->Allocs_Frees?Out->Allocs_Frees:1);
                if (DisplayTotals) {
                    Totals[NONPAGED].Allocs += Out->Allocs;
                    Totals[NONPAGED].AllocsDiff += Out->AllocsDiff;
                    Totals[NONPAGED].Frees += Out->Frees;
                    Totals[NONPAGED].FreesDiff += Out->FreesDiff;
                    Totals[NONPAGED].Allocs_Frees += Out->Allocs_Frees;
                    Totals[NONPAGED].Used += Out->Used;
                    Totals[NONPAGED].UsedDiff += Out->UsedDiff;
                }
                Out += 1;
            }

            if ((PoolInfo->TagInfo[i].PagedAllocs != 0) &&
                 (DisplayType != NONPAGED)) {

                Out->Allocs = PoolInfo->TagInfo[i].PagedAllocs;
                Out->Frees = PoolInfo->TagInfo[i].PagedFrees;
                Out->Used = PoolInfo->TagInfo[i].PagedUsed;
                Out->Allocs_Frees = PoolInfo->TagInfo[i].PagedAllocs -
                                PoolInfo->TagInfo[i].PagedFrees;
                Out->TagUlong = PoolInfo->TagInfo[i].TagUlong;
                Out->Type = PAGED;
                Out->Changed = FALSE;
                Out->NullByte = '\0';

                if (PoolInfoOld != NULL &&
                    PoolInfoOld->Count > i && 
                    PoolInfoOld->TagInfo[i].TagUlong == PoolInfo->TagInfo[i].TagUlong
                   ) {
                    Out->AllocsDiff = PoolInfo->TagInfo[i].PagedAllocs - PoolInfoOld->TagInfo[i].PagedAllocs;
                    Out->FreesDiff = PoolInfo->TagInfo[i].PagedFrees - PoolInfoOld->TagInfo[i].PagedFrees;
                    Out->UsedDiff = PoolInfo->TagInfo[i].PagedUsed - PoolInfoOld->TagInfo[i].PagedUsed;
                    if (Out->AllocsDiff != 0 ||
                        Out->FreesDiff != 0 ||
                        Out->UsedDiff != 0
                       ) {
                        Out->Changed = TRUE;
                    }
                } else {
                    Out->AllocsDiff = 0;
                    Out->UsedDiff = 0;
                    Out->FreesDiff = 0;
                }
                Out->Each =  Out->Used / (Out->Allocs_Frees?Out->Allocs_Frees:1);
                if (DisplayTotals) {
                    Totals[PAGED].Allocs += Out->Allocs;
                    Totals[PAGED].AllocsDiff += Out->AllocsDiff;
                    Totals[PAGED].Frees += Out->Frees;
                    Totals[PAGED].FreesDiff += Out->FreesDiff;
                    Totals[PAGED].Allocs_Frees += Out->Allocs_Frees;
                    Totals[PAGED].Used += Out->Used;
                    Totals[PAGED].UsedDiff += Out->UsedDiff;
                }
                Out += 1;
            }
        } //end for

        //
        // Sort the running working set buffer
        //

        NumberOfPoolTags = Out - &OutBuffer[0];
        qsort((void *)&OutBuffer,
              (size_t)NumberOfPoolTags,
              (size_t)sizeof(POOLMON_OUT),
              ulcomp);

        LastDetailRow = (WORD)(NumberOfRows - (DisplayTotals ? (DisplayType == BOTH ? 3 : 2) : 0));
        for (i = FirstDetailLine; i < NumberOfPoolTags; i++) {
            if (DisplayLine >= LastDetailRow) {
                break;
            }

            sprintf( OutputBuffer,
                     " %4s %5s %9ld (%4ld) %9ld (%4ld) %8ld %7ld (%6ld) %6ld",
                     OutBuffer[i].Tag,
                     PoolType[OutBuffer[i].Type],
                     OutBuffer[i].Allocs,
                     OutBuffer[i].AllocsDiff,
                     OutBuffer[i].Frees,
                     OutBuffer[i].FreesDiff,
                     OutBuffer[i].Allocs_Frees,
                     OutBuffer[i].Used,
                     OutBuffer[i].UsedDiff,
                     OutBuffer[i].Each
                   );
            WriteConsoleLine( OutputHandle,
                              DisplayLine++,
                              OutputBuffer,
                              OutBuffer[i].Changed
                            );
            OutBuffer[i].Changed = FALSE;
        }

        if (DisplayTotals) {
            WriteConsoleLine( OutputHandle,
                              DisplayLine++,
                              NULL,
                              FALSE
                            );
            for (i = 0; i < 2; i++) {
                if ( (int)DisplayType == i || DisplayType == BOTH ) {
                    sprintf( OutputBuffer,
                             "Total %5s %9ld (%4ld) %9ld (%4ld) %8ld %7ld (%6ld) %6ld",
                             PoolType[i],
                             Totals[i].Allocs,
                             Totals[i].AllocsDiff,
                             Totals[i].Frees,
                             Totals[i].FreesDiff,
                             Totals[i].Allocs_Frees,
                             Totals[i].Used,
                             Totals[i].UsedDiff,
                             Totals[i].Each
                           );
                    WriteConsoleLine( OutputHandle,
                                      DisplayLine++,
                                      OutputBuffer,
                                      FALSE
                                    );
                }
            }
        }

        TempBuffer = PreviousBuffer;
        TempBufferSize = PreviousBufferSize;

        PreviousBuffer = CurrentBuffer;
        PreviousBufferSize = CurrentBufferSize;

        CurrentBuffer = TempBuffer;
        CurrentBufferSize = TempBufferSize;

        while (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0) {
            //
            // Check for input record
            //
            if (ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown
               ) {
                LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;
                if (LastKey < ' ') {
                    ScrollDelta = 0;
                    if (LastKey == 'C'-'A'+1) {
                        DoQuit = TRUE;
                    } else switch (InputRecord.Event.KeyEvent.wVirtualKeyCode) {
                        case VK_ESCAPE:
                            DoQuit = TRUE;
                            break;

                        case VK_PRIOR:
                            ScrollDelta = -(LONG)(InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines);
                            break;

                        case VK_NEXT:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines;
                            break;

                        case VK_UP:
                            ScrollDelta = -InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_DOWN:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_HOME:
                            FirstDetailLine = 0;
                            break;

                        case VK_END:
                            FirstDetailLine = NumberOfPoolTags - NumberOfDetailLines;
                            break;
                    }

                    if (ScrollDelta != 0) {
                        if (ScrollDelta < 0) {
                            if (FirstDetailLine <= (ULONG)-ScrollDelta) {
                                FirstDetailLine = 0;
                            } else {
                                FirstDetailLine += ScrollDelta;
                            }
                        } else {
                            FirstDetailLine += ScrollDelta;
                            if (FirstDetailLine >= (NumberOfPoolTags - NumberOfDetailLines)) {
                                FirstDetailLine = NumberOfPoolTags - NumberOfDetailLines;
                            }
                        }
                    }
                } else {
                    switch (toupper( LastKey )) {
                        case 'Q':
                            //
                            //  Go to the bottom of the current screen when
                            //  we quit.
                            //
                            DoQuit = TRUE;
                            break;

                        case 'T':
                            SortBy = TAG;
                            FirstDetailLine = 0;
                            break;

                        case 'A':
                            SortBy = ALLOC;
                            FirstDetailLine = 0;
                            break;

                        case 'U':
                        case 'B':
                            SortBy = BYTES;
                            FirstDetailLine = 0;
                            break;

                        case 'F':
                            SortBy = FREE;
                            FirstDetailLine = 0;
                            break;

                        case 'D':
                            SortBy = DIFF;
                            FirstDetailLine = 0;
                            break;

                        case 'M':
                            SortBy = EACH;
                            FirstDetailLine = 0;
                            break;

                        case 'L':

                            NoHighlight = 1 - NoHighlight;
                            break;

                        case 'P':
                            DisplayType += 1;
                            if (DisplayType > BOTH) {
                                DisplayType = NONPAGED;
                            }
                            FirstDetailLine = 0;
                            break;

                        case 'X':
                        case '(':
                        case ')':

                            Paren += 1;
                            break;

                        case 'E':
                            DisplayTotals = !DisplayTotals;
                            FirstDetailLine = 0;
                            break;

                        case 'H':
                        case '?':
                            DoHelp = TRUE;
                            break;

                    }
                }

                break;
            }
        }

        if (DoQuit) {
            break;
        }

        if (DoHelp) {
            DoHelp = FALSE;
            ShowHelpPopup();
        }
    }

    if (Interactive) {
        SetConsoleActiveScreenBuffer( OriginalOutputHandle );
        SetConsoleMode( InputHandle, OriginalInputMode );
        CloseHandle( OutputHandle );
        }

    ExitProcess( 0 );
    return 0;
}


VOID
ShowHelpPopup( VOID )
{
    HANDLE PopupHandle;
    WORD n;

    PopupHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                             FILE_SHARE_WRITE | FILE_SHARE_READ,
                                             NULL,
                                             CONSOLE_TEXTMODE_BUFFER,
                                             NULL
                                           );
    if (PopupHandle == NULL) {
        return;
        }

    SetConsoleActiveScreenBuffer( PopupHandle );

    n = 0;

    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "                Poolmon Help", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " columns:", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Tag is the 4 byte tag given to the pool allocation", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Type is paged or nonp(aged)", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Allocs is count of all alloctions", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) is difference in Allocs column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Frees is count of all frees", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) difference in Frees column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Diff is (Allocs - Frees)", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Bytes is the total bytes consumed in pool", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (   ) difference in Bytes column from last update", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   Per Alloc is (Bytes / Diff)", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " switches:                                                                     ", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   ? or h - gives this help", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   q - quits", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   p - toggles default pool display between both, paged, and nonpaged", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   e - toggles totals lines on and off", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   l - toggles highlighting of changed lines on and off", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " sorting switches:", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   t - tag    a - allocations", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   f - frees  d - difference", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   b - bytes  m - per alloc", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   (u is the same as b)", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, "   ) - toggles sort between primary tag and value in (  )", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, " command line switches", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -i<tag> - list only matching tags", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -x<tag> - list everything except matching tags", FALSE );
    WriteConsoleLine( PopupHandle, n++, "           <tag> can include * and ?", FALSE );
    WriteConsoleLine( PopupHandle, n++, "   -peltafdbum) - as listed above", FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
    WriteConsoleLine( PopupHandle, n++, NULL, FALSE );

    while (TRUE) {
        if (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0 &&
            ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
            InputRecord.EventType == KEY_EVENT &&
            InputRecord.Event.KeyEvent.bKeyDown &&
            InputRecord.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE
           ) {
            break;
        }
    }

    SetConsoleActiveScreenBuffer( OutputHandle );
    CloseHandle( PopupHandle );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perftool\inc\fastctrs.h ===
/* * * * * * * * * *   I N C L U D E   F I L E S * * * * * * * * * * * * */


#ifndef NT_INCLUDED //Include definitions for other developers

#define IN 
#define OUT 

#define TIME LARGE_INTEGER
#define _TIME _LARGE_INTEGER
#define PTIME PLARGE_INTEGER
#define LowTime LowPart
#define HighTime HighPart 


// begin_winnt begin_ntminiport begin_ntndis

//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#if (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;


typedef LONGLONG USN;
typedef char *PSZ ;
typedef unsigned char  UCHAR ;
typedef unsigned short USHORT ;
typedef unsigned long  ULONG  ;
typedef char  CCHAR ;
typedef char *PCHAR ;
typedef ULONG KAFFINITY ;


typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,
    SystemProcessorInformation,             // obsolete...delete
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation,
    SystemLocksInformation,
    SystemStackTraceInformation,
    SystemPagedPoolInformation,
    SystemNonPagedPoolInformation,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPageFileInformation,
    SystemVdmInstemulInformation,
    SystemVdmBopInformation,
    SystemFileCacheInformation,
    SystemPoolTagInformation,
    SystemInterruptInformation,
    SystemDpcBehaviorInformation,
    SystemSpare3Information,
    SystemLoadGdiDriverInformation,
    SystemUnloadGdiDriverInformation,
    SystemTimeAdjustmentInformation,
    SystemSpare6Information,
    SystemNextEventIdInformation,
    SystemEventIdsInformation,
    SystemCrashDumpInformation,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemExtendServiceTableInformation,
    SystemPrioritySeperation,
    SystemPlugPlayBusInformation,
    SystemDockInformation,
    SystemPowerInformation,
    SystemProcessorSpeedInformation
} SYSTEM_INFORMATION_CLASS;

//
// System Information Structures.
//


typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG MinimumUserModeAddress;
    ULONG MaximumUserModeAddress;
    KAFFINITY ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_INFORMATION {
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;
    USHORT Reserved;
    ULONG ProcessorFeatureBits;
} SYSTEM_PROCESSOR_INFORMATION, *PSYSTEM_PROCESSOR_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
    LARGE_INTEGER IdleTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER DpcTime;          // DEVL only
    LARGE_INTEGER InterruptTime;    // DEVL only
    ULONG InterruptCount;
} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;


typedef struct _SYSTEM_PERFORMANCE_INFORMATION {
    LARGE_INTEGER IdleProcessTime;
    LARGE_INTEGER IoReadTransferCount;
    LARGE_INTEGER IoWriteTransferCount;
    LARGE_INTEGER IoOtherTransferCount;
    ULONG IoReadOperationCount;
    ULONG IoWriteOperationCount;
    ULONG IoOtherOperationCount;
    ULONG AvailablePages;
    ULONG CommittedPages;
    ULONG CommitLimit;
    ULONG PeakCommitment;
    ULONG PageFaultCount;
    ULONG CopyOnWriteCount;
    ULONG TransitionCount;
    ULONG CacheTransitionCount;
    ULONG DemandZeroCount;
    ULONG PageReadCount;
    ULONG PageReadIoCount;
    ULONG CacheReadCount;
    ULONG CacheIoCount;
    ULONG DirtyPagesWriteCount;
    ULONG DirtyWriteIoCount;
    ULONG MappedPagesWriteCount;
    ULONG MappedWriteIoCount;
    ULONG PagedPoolPages;
    ULONG NonPagedPoolPages;
    ULONG PagedPoolAllocs;
    ULONG PagedPoolFrees;
    ULONG NonPagedPoolAllocs;
    ULONG NonPagedPoolFrees;
    ULONG FreeSystemPtes;
    ULONG ResidentSystemCodePage;
    ULONG TotalSystemDriverPages;
    ULONG TotalSystemCodePages;
    ULONG Spare0Count;
    ULONG Spare1Count;
    ULONG Spare3Count;
    ULONG ResidentSystemCachePage;
    ULONG ResidentPagedPoolPage;
    ULONG ResidentSystemDriverPage;
    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadResourceMiss;
    ULONG CcFastReadNotPossible;
    ULONG CcFastMdlReadNoWait;
    ULONG CcFastMdlReadWait;
    ULONG CcFastMdlReadResourceMiss;
    ULONG CcFastMdlReadNotPossible;
    ULONG CcMapDataNoWait;
    ULONG CcMapDataWait;
    ULONG CcMapDataNoWaitMiss;
    ULONG CcMapDataWaitMiss;
    ULONG CcPinMappedDataCount;
    ULONG CcPinReadNoWait;
    ULONG CcPinReadWait;
    ULONG CcPinReadNoWaitMiss;
    ULONG CcPinReadWaitMiss;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;
    ULONG CcCopyReadWaitMiss;
    ULONG CcMdlReadNoWait;
    ULONG CcMdlReadWait;
    ULONG CcMdlReadNoWaitMiss;
    ULONG CcMdlReadWaitMiss;
    ULONG CcReadAheadIos;
    ULONG CcLazyWriteIos;
    ULONG CcLazyWritePages;
    ULONG CcDataFlushes;
    ULONG CcDataPages;
    ULONG ContextSwitches;
    ULONG FirstLevelTbFills;
    ULONG SecondLevelTbFills;
    ULONG SystemCalls;
} SYSTEM_PERFORMANCE_INFORMATION, *PSYSTEM_PERFORMANCE_INFORMATION;

#endif // NT_INCLUDED 

typedef struct _PERFINFO {
    SYSTEM_PERFORMANCE_INFORMATION SysPerfInfo;
	 //
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION SysProcPerfInfo;
	 //
    SYSTEM_PROCESSOR_INFORMATION SysProcInfo;
	 //
    SYSTEM_BASIC_INFORMATION SysBasicInfo;
	 //
    // Other info.
	 //
    PCHAR Title;
    ULONG Iterations;
    short hTimer;
} PERFINFO;
typedef PERFINFO *PPERFINFO;

VOID
FinishBenchmark (
	IN PPERFINFO PerfInfo
);

VOID
StartBenchmark (
	IN PCHAR Title,
	IN ULONG Iterations,
	IN PPERFINFO PerfInfo,
	IN PSZ p5Cntr1,			// 1st Pentium counter - See comments below
	IN PSZ p5Cntr2				// 2nd Pentium counter - See comments below
);
//
// P5Counters:
//		Use the name in the first column when calling StartBenchmark
//
//    "rdata",        "Data Read",                        0x00,
//    "wdata",        "Data Write",                       0x01,
//    "dtlbmiss",     "Data TLB miss",                    0x02,
//    "rdmiss",       "Data Read miss",                   0x03,
//    "wdmiss",       "Data Write miss",                  0x04,
//    "meline",       "Write hit to M/E line",            0x05,
//    "dwb",          "Data cache line WB",               0x06,
//    "dsnoop",       "Data cache snoops",                0x07,
//    "dsnoophit",    "Data cache snoop hits",            0x08,
//    "mempipe",      "Memory accesses in pipes",         0x09,
//    "bankconf",     "Bank conflicts",                   0x0a,
//    "misalign",     "Misadligned data ref",             0x0b,
//    "iread",        "Code Read",                        0x0c,
//    "itldmiss",     "Code TLB miss",                    0x0d,
//    "imiss",        "Code cache miss",                  0x0e,
//    "segloads",     "Segment loads",                    0x0f,
//    "segcache",     "Segment cache accesses",           0x10,
//    "segcachehit",  "Segment cache hits",               0x11,
//    "branch",       "Branches",                         0x12,
//    "btbhit",       "BTB hits",                         0x13,
//    "takenbranck",  "Taken branch or BTB hits",         0x14,
//    "pipeflush",    "Pipeline flushes",                 0x15,
//    "iexec",        "Instructions executed",            0x16,
//    "iexecv",       "Inst exec in vpipe",               0x17,
//    "busutil",      "Bus utilization (clks)",           0x18,
//    "wpipestall",   "Pipe stalled write (clks)",        0x19,
//    "rpipestall",   "Pipe stalled read (clks)",         0x1a,
//    "stallEWBE",    "Stalled while EWBE#",              0x1b,
//    "lock",         "Locked bus cycle",                 0x1c,
//    "io",           "IO r/w cycle",                     0x1d,
//    "noncachemem",  "non-cached memory ref",            0x1e,
//    "agi",          "Pipe stalled AGI",                 0x1f,
//    "flops",        "FLOPs",                            0x22,
//    "dr0",          "Debug Register 0",                 0x23,
//    "dr1",          "Debug Register 1",                 0x24,
//    "dr2",          "Debug Register 2",                 0x25,
//    "dr3",          "Debug Register 3",                 0x26,
//    "int",          "Interrupts",                       0x27,
//    "rwdata",       "Data R/W",                         0x28,
//    "rwdatamiss",   "Data R/W miss",                    0x29,
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmtr\pmon.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    pmon.c

Abstract:

    This module contains the NT/Win32 Process Monitor

Author:

    Lou Perazzoli (loup) 1-Jan-1993

Revision History:

--*/

#include "perfmtrp.h"
#include <search.h>
#include <malloc.h>
#include <limits.h>
#include <stdlib.h>

#define BUFFER_SIZE 64*1024
#define MAX_BUFFER_SIZE 10*1024*1024

ULONG CurrentBufferSize;
PUCHAR PreviousBuffer;
PUCHAR CurrentBuffer;
PUCHAR TempBuffer;


#define CPU_USAGE 0
#define QUOTAS 1

USHORT *NoNameFound = L"Unknown";
USHORT *IdleProcess = L"Idle Process";

UCHAR *StateTable[] = {
    "Initialized",
    "Ready",
    "Running",
    "Standby",
    "Terminated",
    "Wait:",
    "Transition",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown"
};

BOOLEAN Interactive;
ULONG NumberOfInputRecords;
INPUT_RECORD InputRecord;
HANDLE InputHandle;
HANDLE OriginalOutputHandle;
HANDLE OutputHandle;
DWORD OriginalInputMode;
WORD NormalAttribute;
WORD HighlightAttribute;
ULONG NumberOfCols;
ULONG NumberOfRows;
ULONG NumberOfDetailLines;
ULONG FirstDetailLine;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;

UCHAR *WaitTable[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "EventPairHigh",
    "EventPairLow",
    "LpcReceive",
    "LpcReply",
    "Spare1",
    "Spare2",
    "Spare3",
    "Spare4",
    "Spare5",
    "Spare6",
    "Spare7",
    "Spare8",
    "Spare9",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *Empty = " ";


PSYSTEM_PROCESS_INFORMATION
FindMatchedProcess (
    IN PSYSTEM_PROCESS_INFORMATION ProcessToMatch,
    IN PUCHAR SystemInfoBuffer,
    IN PULONG Hint
    );

PSYSTEM_THREAD_INFORMATION
FindMatchedThread (
    IN PSYSTEM_THREAD_INFORMATION ThreadToMatch,
    IN PSYSTEM_PROCESS_INFORMATION MatchedProcess
    );

typedef struct _TOPCPU {
    LARGE_INTEGER TotalTime;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_PROCESS_INFORMATION MatchedProcess;
    ULONG Value;
    LONG PageFaultDiff;
    SIZE_T WorkingSetDiff;
} TOPCPU, *PTOPCPU;

// TOPCPU TopCpu[1000];
// Required for Terminal Services
PTOPCPU TopCpu;
ULONG TopCpuSize;
#define TOPCPU_BUFFER_SIZE (((300*sizeof(TOPCPU))/4096+1)*4096)
#define TOPCPU_MAX_BUFFER_SIZE (50*TOPCPU_BUFFER_SIZE)


BOOL
WriteConsoleLine(
    HANDLE OutputHandle,
    WORD LineNumber,
    LPSTR Text,
    BOOL Highlight
    )
{
    COORD WriteCoord;
    DWORD NumberWritten;
    DWORD TextLength;

    WriteCoord.X = 0;
    WriteCoord.Y = LineNumber;
    if (!FillConsoleOutputCharacter( OutputHandle,
                                     ' ',
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       ) {
        return FALSE;
        }

    if (Text == NULL || (TextLength = strlen( Text )) == 0) {
        return TRUE;
        }
    else {
        return WriteConsoleOutputCharacter( OutputHandle,
                                            Text,
                                            TextLength,
                                            WriteCoord,
                                            &NumberWritten
                                          );
        }
}

NTSTATUS
GetProcessInfo (
    IN PUCHAR p
    )

{
    NTSTATUS Status;

retry01:

    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                p,
                CurrentBufferSize,
                NULL
                );

    if (Status == STATUS_INFO_LENGTH_MISMATCH) {

        //
        // Increase buffer size.
        //

        CurrentBufferSize += 8192;

        TempBuffer = VirtualAlloc (CurrentBuffer,
                                   CurrentBufferSize,
                                   MEM_COMMIT,
                                   PAGE_READWRITE);
        if (TempBuffer == NULL) {
            printf("Memory commit failed\n");
            ExitProcess(0);
        }
        TempBuffer = VirtualAlloc (PreviousBuffer,
                                   CurrentBufferSize,
                                   MEM_COMMIT,
                                   PAGE_READWRITE);
        if (TempBuffer == NULL) {
            printf("Memory commit failed\n");
            ExitProcess(0);
        }
        goto retry01;
    }
    return Status;
}

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    NTSTATUS Status;
    int i;
    ULONG DelayTimeMsec;
    ULONG DelayTimeTicks;
    ULONG LastCount;
    COORD cp;
    BOOLEAN Active;
    PSYSTEM_THREAD_INFORMATION Thread;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_FILECACHE_INFORMATION FileCache;
    SYSTEM_FILECACHE_INFORMATION PrevFileCache;

    CHAR OutputBuffer[ 512 ];
    UCHAR LastKey;
    LONG ScrollDelta;
    WORD DisplayLine, LastDetailRow;
    BOOLEAN DoQuit = FALSE;

    ULONG SkipLine;
    ULONG Hint;
    ULONG Offset1;
    SIZE_T SumCommit;
    int num;
    int lastnum;
    PSYSTEM_PROCESS_INFORMATION CurProcessInfo;
    PSYSTEM_PROCESS_INFORMATION MatchedProcess;
    LARGE_INTEGER LARGE_ZERO={0,0};
    LARGE_INTEGER Ktime;
    LARGE_INTEGER Utime;
    LARGE_INTEGER TotalTime;
    TIME_FIELDS TimeOut;
    PTOPCPU PTopCpu;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    ULONG DisplayType = CPU_USAGE;
    INPUT_RECORD InputRecord;
    DWORD NumRead;
    ULONG Cpu;
    ULONG NoScreenChanges = FALSE;

    if ( GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS) {
        SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
        }

    InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    OriginalOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    Interactive = TRUE;
    if (Interactive) {
        if (InputHandle == NULL ||
            OriginalOutputHandle == NULL ||
            !GetConsoleMode( InputHandle, &OriginalInputMode )
           ) {
            Interactive = FALSE;
        } else {
            OutputHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                                      FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                      NULL,
                                                      CONSOLE_TEXTMODE_BUFFER,
                                                      NULL
                                                    );
            if (OutputHandle == NULL ||
                !GetConsoleScreenBufferInfo( OriginalOutputHandle, &OriginalConsoleInfo ) ||
                !SetConsoleScreenBufferSize( OutputHandle, OriginalConsoleInfo.dwSize ) ||
                !SetConsoleActiveScreenBuffer( OutputHandle ) ||
                !SetConsoleMode( InputHandle, 0 )
               ) {
                if (OutputHandle != NULL) {
                    CloseHandle( OutputHandle );
                    OutputHandle = NULL;
                }

                Interactive = FALSE;
            } else {
                NormalAttribute = 0x1F;
                HighlightAttribute = 0x71;
                NumberOfCols = OriginalConsoleInfo.dwSize.X;
                NumberOfRows = OriginalConsoleInfo.dwSize.Y;
                NumberOfDetailLines = NumberOfRows - 7;
            }
        }
    }

    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );

    DelayTimeMsec = 10;
    DelayTimeTicks = DelayTimeMsec * 10000;

    PreviousBuffer = VirtualAlloc (NULL,
                                   MAX_BUFFER_SIZE,
                                   MEM_RESERVE,
                                   PAGE_READWRITE);
    if (PreviousBuffer == NULL) {
        printf("Memory allocation failed\n");
        return 0;
    }

    TempBuffer = VirtualAlloc (PreviousBuffer,
                               BUFFER_SIZE,
                               MEM_COMMIT,
                               PAGE_READWRITE);

    if (TempBuffer == NULL) {
        printf("Memory commit failed\n");
        return 0;
    }

    CurrentBuffer = VirtualAlloc (NULL,
                                  MAX_BUFFER_SIZE,
                                  MEM_RESERVE,
                                  PAGE_READWRITE);
    if (CurrentBuffer == NULL) {
        printf("Memory allocation failed\n");
        return 0;
    }

    TempBuffer = VirtualAlloc (CurrentBuffer,
                               BUFFER_SIZE,
                               MEM_COMMIT,
                               PAGE_READWRITE);
    if (TempBuffer == NULL) {
        printf("Memory commit failed\n");
        return 0;
    }

	// TS 

	TopCpu = VirtualAlloc (NULL,
                           TOPCPU_MAX_BUFFER_SIZE,
                           MEM_RESERVE,
                           PAGE_READWRITE);
	if(TopCpu == NULL)
	{
		printf("Memory allocation failed\n");
		
		return 0;
	}
	
	TempBuffer = VirtualAlloc( TopCpu,
                               TOPCPU_BUFFER_SIZE,
                               MEM_COMMIT,
                               PAGE_READWRITE);
	
	if( TempBuffer == NULL )
	{
		printf("Memory commit failed\n");
		return 0;
	}
 
    num = 0;

	TopCpuSize = TOPCPU_BUFFER_SIZE;
    
	CurrentBufferSize = BUFFER_SIZE;

    TempBuffer = NULL;

	Status = GetProcessInfo (PreviousBuffer);

	if( !NT_SUCCESS( Status ) )
	{
        printf("Get process information failed %lx\n", Status);
        
		return (0);
    }

    DelayTimeMsec = 5000;
    DelayTimeTicks = DelayTimeMsec * 10000;

    Status = GetProcessInfo (CurrentBuffer);

	if( !NT_SUCCESS( Status ) )
	{
		printf("Get process information failed %lx\n", Status);
		
		return (0);
		
	}

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );
    LastCount = PerfInfo.PageFaultCount;

    if ( !NT_SUCCESS(Status) ) {
        printf("Query perf Failed %lx\n",Status);
        return 0;
    }

    Status = NtQuerySystemInformation(
                SystemFileCacheInformation,
                &FileCache,
                sizeof(FileCache),
                NULL
                );
    PrevFileCache = FileCache;

    if ( !NT_SUCCESS(Status) ) {
        printf("Query file cache Failed %lx\n",Status);
        return 0;
    }

    Active = TRUE;

    while(TRUE) {
		
		Status = GetProcessInfo (CurrentBuffer);

		if( !NT_SUCCESS( Status ) )
		{
			printf("Get process information failed %lx\n", Status);
		
			return (0);
		}

        Status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &PerfInfo,
                    sizeof(PerfInfo),
                    NULL
                    );

        if ( !NT_SUCCESS(Status) ) {
            printf("Query perf Failed %lx\n",Status);
            return 0;
        }
        Status = NtQuerySystemInformation(
                    SystemFileCacheInformation,
                    &FileCache,
                    sizeof(FileCache),
                    NULL
                    );

        if ( !NT_SUCCESS(Status) ) {
            printf("Query file cache Failed %lx\n",Status);
            return 0;
        }

        //
        // Calculate top CPU users and display information.
        //

        //
        // Cross check previous process/thread info against current
        // process/thread info.
        //

        Offset1 = 0;
        lastnum = num;
        num = 0;
        Hint = 0;
        TotalTime = LARGE_ZERO;
        SumCommit = 0;
        while (TRUE) {
            CurProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CurrentBuffer[Offset1];

            //
            // Find the corresponding process in the previous array.
            //

            MatchedProcess = FindMatchedProcess (CurProcessInfo,
                                                 PreviousBuffer,
                                                 &Hint);

			if( num >= (int)( TopCpuSize / sizeof( TOPCPU ) ) )
			{
                TopCpuSize += 4096;

                if( VirtualAlloc( TopCpu, TopCpuSize, MEM_COMMIT, PAGE_READWRITE ) == NULL )
				{
                    printf("Memory commit failed\n");
                    return 0;
                }
            }

            if (MatchedProcess == NULL) {
                TopCpu[num].TotalTime = CurProcessInfo->KernelTime;
                TopCpu[num].TotalTime.QuadPart =
                                            TopCpu[num].TotalTime.QuadPart +
                                            CurProcessInfo->UserTime.QuadPart;
                TotalTime.QuadPart = TotalTime.QuadPart +
                                                TopCpu[num].TotalTime.QuadPart;
                TopCpu[num].ProcessInfo = CurProcessInfo;
                TopCpu[num].MatchedProcess = NULL;
                num += 1;
            } else {
                Ktime.QuadPart = CurProcessInfo->KernelTime.QuadPart -
                                                  MatchedProcess->KernelTime.QuadPart;
                Utime.QuadPart = CurProcessInfo->UserTime.QuadPart -
                                                  MatchedProcess->UserTime.QuadPart;

                TopCpu[num].TotalTime.QuadPart =
                                            Ktime.QuadPart +
                                            Utime.QuadPart;
                TotalTime.QuadPart = TotalTime.QuadPart +
                                                TopCpu[num].TotalTime.QuadPart;
                TopCpu[num].ProcessInfo = CurProcessInfo;
                TopCpu[num].MatchedProcess = MatchedProcess;
                TopCpu[num].PageFaultDiff =
                    CurProcessInfo->PageFaultCount - MatchedProcess->PageFaultCount;
                                            ;
                TopCpu[num].WorkingSetDiff =
                    CurProcessInfo->WorkingSetSize - MatchedProcess->WorkingSetSize;
                num += 1;
            }
            SumCommit += CurProcessInfo->PrivatePageCount / 1024;

            if (CurProcessInfo->NextEntryOffset == 0) {

                DisplayLine = 0;

                sprintf (OutputBuffer,
                     " Memory:%8ldK Avail:%7ldK  PageFlts:%6ld InRam Kernel:%5ldK P:%5ldK",
                                          BasicInfo.NumberOfPhysicalPages*(BasicInfo.PageSize/1024),
                                          PerfInfo.AvailablePages*(BasicInfo.PageSize/1024),
                                          PerfInfo.PageFaultCount - LastCount,
                                          (PerfInfo.ResidentSystemCodePage + PerfInfo.ResidentSystemDriverPage)*(BasicInfo.PageSize/1024),
                                          (PerfInfo.ResidentPagedPoolPage)*(BasicInfo.PageSize/1024)
                                          );
                LastCount = PerfInfo.PageFaultCount;
                WriteConsoleLine( OutputHandle,
                                  DisplayLine++,
                                  OutputBuffer,
                                  FALSE
                                );
                sprintf(OutputBuffer,
                     " Commit:%7ldK/%7ldK Limit:%7ldK Peak:%7ldK  Pool N:%5ldK P:%5ldK",
                                          PerfInfo.CommittedPages*(BasicInfo.PageSize/1024),
                                          SumCommit,
                                          PerfInfo.CommitLimit*(BasicInfo.PageSize/1024),
                                          PerfInfo.PeakCommitment*(BasicInfo.PageSize/1024),
                                          PerfInfo.NonPagedPoolPages*(BasicInfo.PageSize/1024),
                                          PerfInfo.PagedPoolPages*(BasicInfo.PageSize/1024)
                                          );
                WriteConsoleLine( OutputHandle,
                                  DisplayLine++,
                                  OutputBuffer,
                                  FALSE
                                );

                DisplayLine += 1;

                if (NoScreenChanges) {
                    DisplayLine += 2;
                } else {
                    WriteConsoleLine( OutputHandle,
                                      DisplayLine++,
                        "                Mem  Mem   Page   Flts Commit  Usage   Pri  Hnd Thd  Image  ",
                                      FALSE
                                    );

                    WriteConsoleLine( OutputHandle,
                                      DisplayLine++,
                        "CPU  CpuTime  Usage Diff   Faults Diff Charge NonP Page     Cnt Cnt  Name      ",
                                      FALSE
                                    );
                }

                DisplayLine += 1;

                sprintf(OutputBuffer,
                    "             %6ld%5ld%9ld %4ld                             File Cache ",
                       FileCache.CurrentSize/1024,
                       ((LONG)FileCache.CurrentSize - (LONG)PrevFileCache.CurrentSize)/1024,
                       FileCache.PageFaultCount,
                       (LONG)FileCache.PageFaultCount - (LONG)PrevFileCache.PageFaultCount
                     );
                WriteConsoleLine( OutputHandle,
                                  DisplayLine++,
                                  OutputBuffer,
                                  FALSE
                                );
                                PrevFileCache = FileCache;

                LastDetailRow = (WORD)NumberOfRows;
                for (i = FirstDetailLine; i < num; i++) {
                    if (DisplayLine >= LastDetailRow) {
                        break;
                    }

                    PTopCpu = &TopCpu[i];
                    Ktime.QuadPart =
                                PTopCpu->ProcessInfo->KernelTime.QuadPart +
                                PTopCpu->ProcessInfo->UserTime.QuadPart;
                    RtlTimeToElapsedTimeFields ( &Ktime, &TimeOut);
                    TimeOut.Hour += TimeOut.Day*24;
                    if (PTopCpu->ProcessInfo->ImageName.Buffer == NULL) {
                        if (PTopCpu->ProcessInfo->UniqueProcessId == (HANDLE)0) {
                            PTopCpu->ProcessInfo->ImageName.Buffer = (PWSTR)IdleProcess;
                        } else {
                            PTopCpu->ProcessInfo->ImageName.Buffer = (PWSTR)NoNameFound;
                        }
                    } else {
                        if (PTopCpu->ProcessInfo->ImageName.Length > 24) {
                            PTopCpu->ProcessInfo->ImageName.Buffer +=
                              ((PTopCpu->ProcessInfo->ImageName.Length) - 24);
                        }
                    }

                    Cpu = PTopCpu->TotalTime.LowPart / ((TotalTime.LowPart / 100) ? (TotalTime.LowPart / 100) : 1);
                    if ( Cpu == 100 ) {
                        Cpu = 99;
                    }

                    //
                    //  See if nothing has changed.
                    //

                    SkipLine = FALSE;
                    if  ((PTopCpu->MatchedProcess != NULL) &&
                        (Cpu == 0) &&
                        (PTopCpu->WorkingSetDiff == 0) &&
                        (PTopCpu->PageFaultDiff == 0) &&
                        (PTopCpu->MatchedProcess->NumberOfThreads ==
                         PTopCpu->ProcessInfo->NumberOfThreads) &&
                        (PTopCpu->MatchedProcess->HandleCount ==
                         PTopCpu->ProcessInfo->HandleCount) &&
                        (PTopCpu->MatchedProcess->PrivatePageCount ==
                         PTopCpu->ProcessInfo->PrivatePageCount)) {

                        PTopCpu->ProcessInfo->PeakPagefileUsage = 0xffffffff;
                        PTopCpu->ProcessInfo->PeakWorkingSetSize = DisplayLine;

                        if ((PTopCpu->MatchedProcess->PeakPagefileUsage == 0xffffffff) &&
                           (PTopCpu->MatchedProcess->PeakWorkingSetSize == DisplayLine) &&

                           (NoScreenChanges)) {
                            SkipLine = TRUE;
                        }
                    }

                    if (SkipLine) {

                        //
                        // The line on the screen has not changed, just skip
                        // writing this one.
                        //

                        DisplayLine += 1;
                    } else {

                        sprintf(OutputBuffer,
                            "%2ld%4ld:%02ld:%02ld%7ld%5ld%9ld%5ld%7ld%5ld%5ld %2ld%5ld%3ld %ws",
                            Cpu,
                            TimeOut.Hour,
                            TimeOut.Minute,
                            TimeOut.Second,
                            PTopCpu->ProcessInfo->WorkingSetSize / 1024,
                            (ULONG)(PTopCpu->WorkingSetDiff / 1024),
                            PTopCpu->ProcessInfo->PageFaultCount,
                            PTopCpu->PageFaultDiff,
                            PTopCpu->ProcessInfo->PrivatePageCount / 1024,
                            PTopCpu->ProcessInfo->QuotaNonPagedPoolUsage / 1024,
                            PTopCpu->ProcessInfo->QuotaPagedPoolUsage / 1024,
                            PTopCpu->ProcessInfo->BasePriority,
                            PTopCpu->ProcessInfo->HandleCount,
                            PTopCpu->ProcessInfo->NumberOfThreads,
                            PTopCpu->ProcessInfo->ImageName.Buffer
                            );

                        WriteConsoleLine( OutputHandle,
                                      DisplayLine++,
                                      OutputBuffer,
                                      FALSE
                                    );

                    }
                    Thread = (PSYSTEM_THREAD_INFORMATION)(TopCpu[i].ProcessInfo + 1);
                }
                while (lastnum > num) {
                    WriteConsoleLine( OutputHandle,
                                      DisplayLine++,
                                      " ",
                                      FALSE);
                    lastnum -= 1;
                }
            }

            if (CurProcessInfo->NextEntryOffset == 0) {
                break;
            }
            Offset1 += CurProcessInfo->NextEntryOffset;

        } //end while

        TempBuffer = PreviousBuffer;
        PreviousBuffer = CurrentBuffer;
        CurrentBuffer = TempBuffer;

        NoScreenChanges = TRUE;
        while (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0) {

            //
            // Check for input record
            //

            if (ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown
               ) {
                LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;
                if (LastKey < ' ') {
                    ScrollDelta = 0;
                    if (LastKey == 'C'-'A'+1) {
                        DoQuit = TRUE;
                    } else switch (InputRecord.Event.KeyEvent.wVirtualKeyCode) {
                        case VK_ESCAPE:
                            DoQuit = TRUE;
                            break;

                        case VK_PRIOR:
                            ScrollDelta = -(LONG)(InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines);
                            break;

                        case VK_NEXT:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines;
                            break;

                        case VK_UP:
                            ScrollDelta = -InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_DOWN:
                            ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount;
                            break;

                        case VK_HOME:
                            FirstDetailLine = 0;
                            break;

                        case VK_END:

                            if ((ULONG)num > NumberOfDetailLines) {
                                FirstDetailLine = num - NumberOfDetailLines;
                                NoScreenChanges = FALSE;
                            }
                            break;
                    }

                    if (ScrollDelta != 0) {
                        if (ScrollDelta < 0) {
                            if (FirstDetailLine <= (ULONG)-ScrollDelta) {
                                FirstDetailLine = 0;
                                NoScreenChanges = FALSE;
                            } else {
                                FirstDetailLine += ScrollDelta;
                                NoScreenChanges = FALSE;
                            }
                        } else {
                            FirstDetailLine += ScrollDelta;
                            NoScreenChanges = FALSE;
                            if (FirstDetailLine >= (num - NumberOfDetailLines)) {
                                FirstDetailLine = num - NumberOfDetailLines;
                            }
                        }
                    }
                } else {

                    switch (toupper( LastKey )) {
                        case 'C':
                        case 'c':
                            DisplayType = CPU_USAGE;
                            break;

                        case 'P':
                        case 'p':
                            DisplayType = QUOTAS;
                            break;


                        case 'q':
                        case 'Q':
                            DoQuit = TRUE;
                            break;

                        default:
                            break;
                    }
                }
                break;
            }
        }
        if (DoQuit) {
            if (Interactive) {
                SetConsoleActiveScreenBuffer( OriginalOutputHandle );
                SetConsoleMode( InputHandle, OriginalInputMode );
                CloseHandle( OutputHandle );
            }
            return 0;
        }
    }
    return 0;
}
PSYSTEM_PROCESS_INFORMATION
FindMatchedProcess (
    IN PSYSTEM_PROCESS_INFORMATION ProcessToMatch,
    IN PUCHAR SystemInfoBuffer,
    IN OUT PULONG Hint
    )

/*++

Routine Description:

    This procedure finds the process which corresponds to the ProcessToMatch.
    It returns the address of the matching Process, or NULL if no
    matching process was found.

Arguments:

    ProcessToMatch - Supplies a pointer to the target thread to match.

    SystemInfoBuffer - Supples a pointer to the system information
                     buffer in which to locate the process.

    Hint - Supplies and returns a hint for optimizing the searches.

Return Value:

    Address of the corresponding Process or NULL.

--*/

{
    PSYSTEM_PROCESS_INFORMATION Process;
    ULONG Offset2;

    Offset2 = *Hint;

    while (TRUE) {
        Process = (PSYSTEM_PROCESS_INFORMATION)&SystemInfoBuffer[Offset2];
        if ((Process->UniqueProcessId ==
                ProcessToMatch->UniqueProcessId) &&
            (Process->CreateTime.QuadPart ==
                                  ProcessToMatch->CreateTime.QuadPart)) {
            *Hint = Offset2 + Process->NextEntryOffset;
            return(Process);
        }
        Offset2 += Process->NextEntryOffset;
        if (Offset2 == *Hint) {
            *Hint = 0;
            return(NULL);
        }
        if (Process->NextEntryOffset == 0) {
            if (*Hint == 0) {
                return(NULL);
            }
            Offset2 = 0;
        }
    }
}

PSYSTEM_THREAD_INFORMATION
FindMatchedThread (
    IN PSYSTEM_THREAD_INFORMATION ThreadToMatch,
    IN PSYSTEM_PROCESS_INFORMATION MatchedProcess
    )

/*++

Routine Description:

    This procedure finds thread which corresponds to the ThreadToMatch.
    It returns the address of the matching thread, or NULL if no
    matching thread was found.

Arguments:

    ThreadToMatch - Supplies a pointer to the target thread to match.

    MatchedProcess - Supples a pointer to the process which contains
                     the target thread.  The thread information
                     must follow this process, i.e., this block was
                     obtain from a NtQuerySystemInformation specifying
                     PROCESS_INFORMATION.

Return Value:

    Address of the corresponding thread from MatchedProcess or NULL.

--*/

{
    PSYSTEM_THREAD_INFORMATION Thread;
    ULONG i;

    Thread = (PSYSTEM_THREAD_INFORMATION)(MatchedProcess + 1);
    for (i = 0; i < MatchedProcess->NumberOfThreads; i++) {
        if ((Thread->ClientId.UniqueThread ==
                ThreadToMatch->ClientId.UniqueThread) &&
            (Thread->CreateTime.QuadPart ==
                                  ThreadToMatch->CreateTime.QuadPart)) {

            return(Thread);
        }
        Thread += 1;
    }
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perftool\inc\teststat.h ===
/***************************************

This is the header file for the statistics package

***************************************/

#if (defined (NTNAT) || defined (OS2SS))
#define FAR
#define PASCAL
#define far
#define double ULONG	     /* this needs to be changed when flt support
                               becomes available under NT */
#define BOOL BOOLEAN
#endif

#if (defined (WIN16) || defined (WIN32) || defined (MIPS) || defined (DOS))
    #define SHORT short
    #define ULONG DWORD
    #define USHORT WORD
    #define PSHORT short *
    #define PSZ	  LPSTR
    #define PUSHORT USHORT far *
    #define PULONG ULONG far *
    #define FAR far
#endif

#if (defined (WIN16))
    #define PLONG LPSTR
#endif

#ifdef OS2386
    #define far
#endif

#define STAT_ERROR_ILLEGAL_MIN_ITER   1
#define STAT_ERROR_ILLEGAL_MAX_ITER   2
#define STAT_ERROR_ALLOC_FAILED       3
#define STAT_ERROR_ILLEGAL_BOUNDS     4

#define DEFAULT_OUTLIER_FACTOR        4

USHORT FAR PASCAL TestStatOpen     (USHORT, USHORT);
VOID   FAR PASCAL TestStatInit     (VOID);
BOOL   FAR PASCAL TestStatConverge (ULONG);
VOID   FAR PASCAL TestStatValues   (PSZ, USHORT, PULONG far *, PUSHORT, 
                                       PUSHORT); 
VOID   FAR PASCAL TestStatClose    (VOID);
ULONG  FAR PASCAL TestStatRand     (ULONG, ULONG);
double FAR PASCAL TestStatUniRand  (VOID);
USHORT  FAR PASCAL TestStatShortRand  (VOID);
LONG   FAR PASCAL TestStatNormDist (ULONG, USHORT);
LONG   FAR PASCAL TestStatOldDist (ULONG, USHORT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perfmtr\top.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    top.c

Abstract:

    This module contains the NT/Win32 Top threads Meter

Author:

    Another Mark Lucovsky (markl) / Lou Perazzoli (loup) production 5-Aug-1991

Revision History:

--*/

#include "perfmtrp.h"
#include <stdlib.h>

#define BUFFER_SIZE 64*1024

#define CPU_THREAD 0
#define CPU_PROCESS 1
#define FAULTS 2
#define WORKING_SET 3
#define CONTEXT_SWITCHES 4
#define SYSTEM_CALLS 5

PUCHAR g_pLargeBuffer1 = NULL;
PUCHAR g_pLargeBuffer2 = NULL;
DWORD g_dwBufSize1;
DWORD g_dwBufSize2;

WCHAR *NoNameFound = L"No Name Found";

UCHAR *StateTable[] = {
    "Initialized",
    "Ready",
    "Running",
    "Standby",
    "Terminated",
    "Wait:",
    "Transition",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *WaitTable[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "EventPairHigh",
    "EventPairLow",
    "LpcReceive",
    "LpcReply",
    "Spare1",
    "Spare2",
    "Spare3",
    "Spare4",
    "Spare5",
    "Spare6",
    "Spare7",
    "Spare8",
    "Spare9",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *Empty = " ";


PSYSTEM_PROCESS_INFORMATION
FindMatchedProcess (
    IN PSYSTEM_PROCESS_INFORMATION ProcessToMatch,
    IN PUCHAR SystemInfoBuffer,
    IN PULONG Hint
    );

PSYSTEM_THREAD_INFORMATION
FindMatchedThread (
    IN PSYSTEM_THREAD_INFORMATION ThreadToMatch,
    IN PSYSTEM_PROCESS_INFORMATION MatchedProcess
    );

typedef struct _TOPCPU {
    LARGE_INTEGER TotalTime;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_PROCESS_INFORMATION MatchedProcess;
    ULONG Value;
} TOPCPU, *PTOPCPU;

TOPCPU TopCpu[1000];

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    NTSTATUS Status;
    int i,j;
    ULONG DelayTimeMsec;
    ULONG DelayTimeTicks;
    COORD dest,cp;
    SMALL_RECT Sm;
    CHAR_INFO ci;
    CONSOLE_SCREEN_BUFFER_INFO sbi;
    KPRIORITY SetBasePriority;
    INPUT_RECORD InputRecord;
    HANDLE ScreenHandle;
    BOOLEAN Active;
    DWORD NumRead;
    SMALL_RECT Window;
    PSYSTEM_THREAD_INFORMATION Thread;
    PSYSTEM_THREAD_INFORMATION MatchedThread;

    PUCHAR PreviousBuffer;
    PUCHAR CurrentBuffer;
    PUCHAR TempBuffer;
    ULONG Hint;
    ULONG Offset1;
    int num;
    int Type;
    ULONG ContextSwitches;
    PSYSTEM_PROCESS_INFORMATION CurProcessInfo;
    PSYSTEM_PROCESS_INFORMATION MatchedProcess;
    LARGE_INTEGER LARGE_ZERO={0,0};
    LARGE_INTEGER Ktime;
    LARGE_INTEGER Utime;
    LARGE_INTEGER TotalTime;
    TIME_FIELDS TimeOut;
    PTOPCPU PTopCpu;

    BOOLEAN bToggle = TRUE;
    PDWORD pdwBufSize = NULL;

    SetBasePriority = (KPRIORITY) 12;

    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &SetBasePriority,
        sizeof(SetBasePriority)
        );

    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE),&sbi);

    DelayTimeMsec = 2500;
    DelayTimeTicks = DelayTimeMsec * 10000;

    Window.Left = 0;
    Window.Top = 0;
    Window.Right = 79;
    Window.Bottom = 23;

    dest.X = 0;
    dest.Y = 23;

    ci.Char.AsciiChar = ' ';
    ci.Attributes = sbi.wAttributes;

    SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                         TRUE,
                         &Window
                        );

    cp.X = 0;
    cp.Y = 0;

    Sm.Left      = 0;
    Sm.Top       = 0;
    Sm.Right     = 79;
    Sm.Bottom    = 22;

    ScrollConsoleScreenBuffer(
        GetStdHandle(STD_OUTPUT_HANDLE),
        &Sm,
        NULL,
        dest,
        &ci
        );

    SetConsoleCursorPosition(
        GetStdHandle(STD_OUTPUT_HANDLE),
        cp
        );


    printf( "  %%   Pid  Tid  Pri      Key    Start Address  ImageName\n");
    printf( "___________________________________________________________________\n");

    cp.X = 0;
    cp.Y = 2;

    Sm.Left      = 0;
    Sm.Top       = 2;
    Sm.Right     = 79;
    Sm.Bottom    = 22;

    ScreenHandle = GetStdHandle (STD_INPUT_HANDLE);

    // allocate space for the buffer
    
    g_dwBufSize1 = BUFFER_SIZE;
    g_dwBufSize2 = BUFFER_SIZE;

    g_pLargeBuffer1 = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize1 );

    if( g_pLargeBuffer1 == NULL )
    {
        return 0;
    }

    g_pLargeBuffer2 = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize2 );

    if( g_pLargeBuffer2 == NULL )
    {
        return 0;
    }




retry0:


    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                g_pLargeBuffer1,
                g_dwBufSize1,
                NULL
                );

    if( Status == STATUS_INFO_LENGTH_MISMATCH )
    {
        g_dwBufSize1 *= 2;

        if( g_pLargeBuffer1 != NULL )
        {
            free( g_pLargeBuffer1 );
        }

        g_pLargeBuffer1 = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize1 );

        if( g_pLargeBuffer1 == NULL )
        {
            return 0;
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        printf("Query Failed %lx\n",Status);
        goto retry0;
    }

    Sleep(DelayTimeMsec);

retry01:

    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &SetBasePriority,
        sizeof(SetBasePriority)
        );

    Status = NtQuerySystemInformation(
                SystemProcessInformation,
                g_pLargeBuffer2,
                g_dwBufSize2,
                NULL
                );
    
    if( Status == STATUS_INFO_LENGTH_MISMATCH )
    {
        g_dwBufSize2 *= 2;

        if( g_pLargeBuffer2 != NULL )
        {
            free( g_pLargeBuffer2 );
        }

        g_pLargeBuffer2 = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize2 );

        if( g_pLargeBuffer2 == NULL )
        {
            if( g_pLargeBuffer1 != NULL )
            {
                free( g_pLargeBuffer1 );
            }

            return 0;
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        printf("Query Failed %lx\n",Status);
        goto retry01;
    }

    PreviousBuffer = &g_pLargeBuffer1[0];
    CurrentBuffer = &g_pLargeBuffer2[0];

    Active = TRUE;
    Type = CPU_PROCESS;

    while(TRUE) {
waitkey:
        while (PeekConsoleInput (ScreenHandle, &InputRecord, 1, &NumRead) && NumRead != 0) {
            if (!ReadConsoleInput (ScreenHandle, &InputRecord, 1, &NumRead)) {
                break;
            }
            if (InputRecord.EventType == KEY_EVENT) {

                switch (InputRecord.Event.KeyEvent.uChar.AsciiChar) {

                    case 'q':
                    case 'Q':
                        {
                            if( CurrentBuffer != NULL )
                            {
                                free( CurrentBuffer );
                            }

                            if( PreviousBuffer != NULL )
                            {
                                free( PreviousBuffer );
                            }
    
                            ExitProcess(0);
                        }
                        break;

                    case 'p':
                    case 'P':
                        Active = FALSE;
                        break;

                    case 'c':
                    case 'C':
                        Type = CPU_PROCESS;
                        break;

                    case 'f':
                    case 'F':
                        Type = FAULTS;
                        break;

                    case 's':
                    case 'S':
                        Type = CONTEXT_SWITCHES;
                        break;

                    case 't':
                    case 'T':
                        Type = CPU_THREAD;
                        break;

                    case 'w':
                    case 'W':
                        Type = WORKING_SET;
                        break;

                    default:
                        Active = TRUE;
                        break;
                    }
                }
            }
        if ( !Active ) {
            goto waitkey;
            }
        ScrollConsoleScreenBuffer(
            GetStdHandle(STD_OUTPUT_HANDLE),
            &Sm,
            NULL,
            dest,
            &ci
            );

        SetConsoleCursorPosition(
            GetStdHandle(STD_OUTPUT_HANDLE),
            cp
            );


        //
        // Calculate top CPU users and display information.
        //

        //
        // Cross check previous process/thread info against current
        // process/thread info.
        //

        Offset1 = 0;
        num = 0;
        Hint = 0;
        TotalTime = LARGE_ZERO;

        while (TRUE) {
            CurProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CurrentBuffer[Offset1];

            //
            // Find the corresponding process in the previous array.
            //

            MatchedProcess = FindMatchedProcess (CurProcessInfo,
                                                 PreviousBuffer,
                                                 &Hint);
            switch (Type) {
                case CPU_PROCESS:
                case CPU_THREAD:

                    if (MatchedProcess == NULL) {
                        TopCpu[num].TotalTime = Ktime;
                        TopCpu[num].TotalTime.QuadPart =
                                            TopCpu[num].TotalTime.QuadPart +
                                                    Utime.QuadPart;
                        TotalTime.QuadPart = TotalTime.QuadPart +
                                                 TopCpu[num].TotalTime.QuadPart;
                        TopCpu[num].ProcessInfo = CurProcessInfo;
                        TopCpu[num].MatchedProcess = NULL;
                        num += 1;
                    } else {
                        Ktime.QuadPart = CurProcessInfo->KernelTime.QuadPart -
                                              MatchedProcess->KernelTime.QuadPart;
                        Utime.QuadPart = CurProcessInfo->UserTime.QuadPart -
                                                          MatchedProcess->UserTime.QuadPart;

                        if ((Ktime.QuadPart != 0) ||
                            (Utime.QuadPart != 0)) {
                            TopCpu[num].TotalTime = Ktime;
                            TopCpu[num].TotalTime.QuadPart =
                                                        TopCpu[num].TotalTime.QuadPart +
                                                        Utime.QuadPart;
                            TotalTime.QuadPart = TotalTime.QuadPart +
                                                            TopCpu[num].TotalTime.QuadPart;
                            TopCpu[num].ProcessInfo = CurProcessInfo;
                            TopCpu[num].MatchedProcess = MatchedProcess;
                            num += 1;
                        }
                    }
                    if (CurProcessInfo->NextEntryOffset == 0) {

                        for (i=0;i<num;i++) {
                            PTopCpu = &TopCpu[i];
                            Ktime.QuadPart =
                                        PTopCpu->ProcessInfo->KernelTime.QuadPart +
                                        PTopCpu->ProcessInfo->UserTime.QuadPart;
                            RtlTimeToTimeFields ( &Ktime, &TimeOut);
                            printf( "%4ld%% %p %7ld %7ld %7ld %3ld:%02ld:%02ld.%03ld %ws\n",
                                (PTopCpu->TotalTime.LowPart*100)/TotalTime.LowPart,
                                PTopCpu->ProcessInfo->UniqueProcessId,
                                PTopCpu->ProcessInfo->PageFaultCount,
                                PTopCpu->ProcessInfo->WorkingSetSize,
                                PTopCpu->ProcessInfo->PrivatePageCount,
                                TimeOut.Hour,
                                TimeOut.Minute,
                                TimeOut.Second,
                                TimeOut.Milliseconds,
                                (PTopCpu->ProcessInfo->ImageName.Buffer != NULL) ?
                                    PTopCpu->ProcessInfo->ImageName.Buffer :
                                    NoNameFound);


                            Thread = (PSYSTEM_THREAD_INFORMATION)(TopCpu[i].ProcessInfo + 1);
                            if (Type == CPU_THREAD) {
                                for (j = 0;
                                     j < (int)TopCpu[i].ProcessInfo->NumberOfThreads;
                                     j++) {

                                    if (TopCpu[i].MatchedProcess == NULL) {
                                        MatchedThread = NULL;
                                    } else {
                                        MatchedThread = FindMatchedThread (
                                                            Thread,
                                                            TopCpu[i].MatchedProcess
                                                            );
                                    }
                                    if (MatchedThread == NULL) {
                                        Ktime.QuadPart =
                                                    Thread->KernelTime.QuadPart +
                                                    Thread->UserTime.QuadPart;
                                    } else {
                                        Ktime.QuadPart =
                                                    Thread->KernelTime.QuadPart -
                                                    MatchedThread->KernelTime.QuadPart;
                                        Utime.QuadPart =
                                                    Thread->UserTime.QuadPart -
                                                    MatchedThread->UserTime.QuadPart;
                                        Ktime.QuadPart =
                                                    Ktime.QuadPart +
                                                    Utime.QuadPart;
                                    }
                                    if (Ktime.LowPart != 0) {
                                        printf("  %4ld%% TID%p Cs %5ld\n",
                                            (Ktime.LowPart*100)/TotalTime.LowPart,
                                            Thread->ClientId.UniqueThread,
                                            Thread->ContextSwitches);
                                    }
                                    Thread += 1;
                                }
                            }
                        }
                    }
                    break;

                case FAULTS:

                    if (MatchedProcess == NULL) {
                        TopCpu[num].Value = CurProcessInfo->PageFaultCount;
                        TopCpu[num].ProcessInfo = CurProcessInfo;
                        num += 1;
                    } else {
                        TopCpu[num].Value = CurProcessInfo->PageFaultCount -
                                    MatchedProcess->PageFaultCount;
                        if (TopCpu[num].Value != 0) {
                            TopCpu[num].ProcessInfo = CurProcessInfo;
                            num += 1;
                        }
                    }
                    if (CurProcessInfo->NextEntryOffset == 0) {
                        for (i=0;i<num;i++) {
                            PTopCpu = &TopCpu[i];
                            Ktime.QuadPart =
                                        PTopCpu->ProcessInfo->KernelTime.QuadPart +
                                        PTopCpu->ProcessInfo->UserTime.QuadPart;
                            RtlTimeToTimeFields ( &Ktime, &TimeOut);
                            printf( "Pf: %4ld %p %7ld %7ld %7ld %3ld:%02ld:%02ld.%03ld %ws\n",
                                PTopCpu->Value,
                                PTopCpu->ProcessInfo->UniqueProcessId,
                                PTopCpu->ProcessInfo->PageFaultCount,
                                PTopCpu->ProcessInfo->WorkingSetSize,
                                PTopCpu->ProcessInfo->PrivatePageCount,
                                TimeOut.Hour,
                                TimeOut.Minute,
                                TimeOut.Second,
                                TimeOut.Milliseconds,
                                (PTopCpu->ProcessInfo->ImageName.Buffer != NULL) ?
                                    PTopCpu->ProcessInfo->ImageName.Buffer :
                                    NoNameFound);
                        }
                    }
                    break;

                case WORKING_SET:

                    if (MatchedProcess == NULL) {
                        TopCpu[num].Value = CurProcessInfo->PageFaultCount;
                        TopCpu[num].ProcessInfo = CurProcessInfo;
                        num += 1;
                    } else {
                        if (CurProcessInfo->WorkingSetSize !=
                            MatchedProcess->WorkingSetSize) {
                            TopCpu[num].Value =
                                (ULONG)(CurProcessInfo->WorkingSetSize - MatchedProcess->WorkingSetSize);
                            TopCpu[num].ProcessInfo = CurProcessInfo;
                            num += 1;
                        }
                    }
                    if (CurProcessInfo->NextEntryOffset == 0) {
                        for (i=0;i<num;i++) {
                            PTopCpu = &TopCpu[i];
                            Ktime.QuadPart =
                                        PTopCpu->ProcessInfo->KernelTime.QuadPart +
                                        PTopCpu->ProcessInfo->UserTime.QuadPart;
                            RtlTimeToTimeFields ( &Ktime, &TimeOut);
                            printf( "Ws: %4ld %p %7ld %7ld %7ld %3ld:%02ld:%02ld.%03ld %ws\n",
                                PTopCpu->Value,
                                PTopCpu->ProcessInfo->UniqueProcessId,
                                PTopCpu->ProcessInfo->PageFaultCount,
                                PTopCpu->ProcessInfo->WorkingSetSize,
                                PTopCpu->ProcessInfo->PrivatePageCount,
                                TimeOut.Hour,
                                TimeOut.Minute,
                                TimeOut.Second,
                                TimeOut.Milliseconds,
                                (PTopCpu->ProcessInfo->ImageName.Buffer != NULL) ?
                                    PTopCpu->ProcessInfo->ImageName.Buffer :
                                    NoNameFound);
                        }
                    }
                    break;

                case CONTEXT_SWITCHES:


                    Thread = (PSYSTEM_THREAD_INFORMATION)(CurProcessInfo + 1);
                    TopCpu[num].Value = 0;
                    if (MatchedProcess == NULL) {

                        for (j = 0; j < (int)CurProcessInfo->NumberOfThreads; j++ ) {
                            TopCpu[num].Value += Thread->ContextSwitches;
                            Thread += 1;
                        }

                        if (TopCpu[num].Value != 0) {
                            TopCpu[num].ProcessInfo = CurProcessInfo;
                            TopCpu[num].MatchedProcess = NULL;
                            num += 1;
                        }
                    } else {

                        for (j = 0; j < (int)CurProcessInfo->NumberOfThreads; j++ ) {
                            MatchedThread = FindMatchedThread (
                                                Thread,
                                                MatchedProcess
                                                );

                            if (MatchedThread == NULL) {
                                TopCpu[num].Value += Thread->ContextSwitches;

                            } else {
                                TopCpu[num].Value +=
                                    Thread->ContextSwitches - MatchedThread->ContextSwitches;
                            }
                            Thread += 1;
                        }

                        if (TopCpu[num].Value != 0) {
                            TopCpu[num].ProcessInfo = CurProcessInfo;
                            TopCpu[num].MatchedProcess = MatchedProcess;
                            num += 1;
                        }
                    }

                    if (CurProcessInfo->NextEntryOffset == 0) {

                        for (i=0;i<num;i++) {

                            PTopCpu = &TopCpu[i];
                            Ktime.QuadPart =
                                        PTopCpu->ProcessInfo->KernelTime.QuadPart +
                                        PTopCpu->ProcessInfo->UserTime.QuadPart;
                            RtlTimeToTimeFields ( &Ktime, &TimeOut);
                            printf( "Cs: %4ld %p %7ld %7ld %7ld %3ld:%02ld:%02ld.%03ld %ws\n",
                                PTopCpu->Value,
                                PTopCpu->ProcessInfo->UniqueProcessId,
                                PTopCpu->ProcessInfo->PageFaultCount,
                                PTopCpu->ProcessInfo->WorkingSetSize,
                                PTopCpu->ProcessInfo->PrivatePageCount,
                                TimeOut.Hour,
                                TimeOut.Minute,
                                TimeOut.Second,
                                TimeOut.Milliseconds,
                                (PTopCpu->ProcessInfo->ImageName.Buffer != NULL) ?
                                    PTopCpu->ProcessInfo->ImageName.Buffer :
                                    NoNameFound);

                            Thread = (PSYSTEM_THREAD_INFORMATION)(TopCpu[i].ProcessInfo + 1);

                            for (j = 0;
                                 j < (int)TopCpu[i].ProcessInfo->NumberOfThreads;
                                 j++) {

                                ContextSwitches = 0;
                                if (TopCpu[i].MatchedProcess == NULL) {
                                    MatchedThread = NULL;
                                } else {
                                    MatchedThread = FindMatchedThread (
                                                        Thread,
                                                        TopCpu[i].MatchedProcess
                                                        );
                                }
                                if (MatchedThread == NULL) {
                                    ContextSwitches = Thread->ContextSwitches;
                                } else {
                                    ContextSwitches =
                                        Thread->ContextSwitches -
                                                MatchedThread->ContextSwitches;

                                }
                                if (ContextSwitches != 0) {
                                    printf("\t     TID%p Cs %5ld%+3ld\n",
                                        Thread->ClientId.UniqueThread,
                                        Thread->ContextSwitches,
                                        ContextSwitches);
                                }
                                Thread += 1;
                            }
                        }
                    }
                    break;

                default:
                    break;

            } //end switch

            if (CurProcessInfo->NextEntryOffset == 0) {
                break;
            }
            Offset1 += CurProcessInfo->NextEntryOffset;

        } //end while

        /*
        
          two snapshot buffers are maintained and swapped around
          since these buffers are now dynamic keep the bufsize in
          sync
          */

        TempBuffer = PreviousBuffer;
        PreviousBuffer = CurrentBuffer;
        CurrentBuffer = TempBuffer;

        pdwBufSize = bToggle ? &g_dwBufSize1 : &g_dwBufSize2;

        bToggle = !bToggle;


retry1:
        Sleep(DelayTimeMsec);

        NtSetInformationProcess(
            NtCurrentProcess(),
            ProcessBasePriority,
            (PVOID) &SetBasePriority,
            sizeof(SetBasePriority)
            );
        

        Status = NtQuerySystemInformation(
                    SystemProcessInformation,
                    ( PVOID)CurrentBuffer,
                    *pdwBufSize,
                    NULL
                    );

        if( Status == STATUS_INFO_LENGTH_MISMATCH )
        {
            *pdwBufSize *= 2;

            if( CurrentBuffer != NULL )
            {
                free( CurrentBuffer );
            }

            CurrentBuffer = ( PUCHAR )malloc( sizeof( UCHAR ) * ( *pdwBufSize ) );

            if( CurrentBuffer == NULL )
            {
                if( PreviousBuffer != NULL )
                {
                    free( PreviousBuffer );
                }

                return 0;
            }
        }

        if ( !NT_SUCCESS(Status) ) {
            printf("Query Failed %lx\n",Status);
            goto retry1;
        }        
    }
   
    return(0);
}


PSYSTEM_PROCESS_INFORMATION
FindMatchedProcess (
    IN PSYSTEM_PROCESS_INFORMATION ProcessToMatch,
    IN PUCHAR SystemInfoBuffer,
    IN OUT PULONG Hint
    )

/*++

Routine Description:

    This procedure finds the process which corresponds to the ProcessToMatch.
    It returns the address of the matching Process, or NULL if no
    matching process was found.

Arguments:

    ProcessToMatch - Supplies a pointer to the target thread to match.

    SystemInfoBuffer - Supples a pointer to the system information
                     buffer in which to locate the process.

    Hint - Supplies and returns a hint for optimizing the searches.

Return Value:

    Address of the corresponding Process or NULL.

--*/

{
    PSYSTEM_PROCESS_INFORMATION Process;
    ULONG Offset2;

    Offset2 = *Hint;

    while (TRUE) {
        Process = (PSYSTEM_PROCESS_INFORMATION)&SystemInfoBuffer[Offset2];
        if ((Process->UniqueProcessId ==
                ProcessToMatch->UniqueProcessId) &&
            ((Process->CreateTime.QuadPart ==
                                  ProcessToMatch->CreateTime.QuadPart))) {
            *Hint = Offset2 + Process->NextEntryOffset;
            return(Process);
        }
        Offset2 += Process->NextEntryOffset;
        if (Offset2 == *Hint) {
            *Hint = 0;
            return(NULL);
        }
        if (Process->NextEntryOffset == 0) {
            if (*Hint == 0) {
                return(NULL);
            }
            Offset2 = 0;
        }
    }
}

PSYSTEM_THREAD_INFORMATION
FindMatchedThread (
    IN PSYSTEM_THREAD_INFORMATION ThreadToMatch,
    IN PSYSTEM_PROCESS_INFORMATION MatchedProcess
    )

/*++

Routine Description:

    This procedure finds thread which corresponds to the ThreadToMatch.
    It returns the address of the matching thread, or NULL if no
    matching thread was found.

Arguments:

    ThreadToMatch - Supplies a pointer to the target thread to match.

    MatchedProcess - Supples a pointer to the process which contains
                     the target thread.  The thread information
                     must follow this process, i.e., this block was
                     obtain from a NtQuerySystemInformation specifying
                     PROCESS_INFORMATION.

Return Value:

    Address of the corresponding thread from MatchedProcess or NULL.

--*/

{
    PSYSTEM_THREAD_INFORMATION Thread;
    ULONG i;

    Thread = (PSYSTEM_THREAD_INFORMATION)(MatchedProcess + 1);
    for (i = 0; i < MatchedProcess->NumberOfThreads; i++) {
        if ((Thread->ClientId.UniqueThread ==
                ThreadToMatch->ClientId.UniqueThread) &&
            ((Thread->CreateTime.QuadPart ==
                                  ThreadToMatch->CreateTime.QuadPart))) {

            return(Thread);
        }
        Thread += 1;
    }
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perftool\stat\i386\87ftol.asm ===
page	,132
	title	87ftol	 - truncate TOS to 32-bit integer
;*** 
;87ftol.asm - truncate TOS to 32-bit integer
;
;	Copyright (c) 1985-88, Microsoft Corporation
;
;Purpose:
;
;Revision History:
;
;   07/16/85	Greg Whitten
;		save BX and CX for sloppy code generator
;   10/15/86	Greg Whitten
;		in-line instructions rather than call _fpmath
;   08/24/87	Barry McCord
;		expand the functionality of _ftol to handle
;		unsigned long by using "fistp qword ptr"
;   11/24/87	Barry McCord
;		added _loadds under ifdef DLL
;
;   08/26/88	Bill Johnston
;		386 version
;
;*******************************************************************************


.xlist
;	 include cruntime.inc
;	 include mrt386.inc
;	 include os2supp.inc
.list

;	 CODESEG
	.386
	.387
	.model small,C
	.code


public _fltused
_fltused equ	9876h

_ftol	proc

	local	oldcw:word
	local	newcw:word
	local	intval:qword

	fstcw	[oldcw] 		; get control word
	fwait				; synchronize

	mov	ax, [oldcw]		; round mode saved
	or	ah, 0ch 		; set chop rounding mode
	mov	[newcw], ax		; back to memory

	fldcw	[newcw] 		; reset rounding
	fistp	qword ptr [intval]	; store chopped integer
	fldcw	[oldcw] 		; restore rounding

;	 mov	 rax, IWORD ptr [intval]
;	 mov	 rdx, IWORD ptr [intval+ISIZE]

	mov	eax, dword ptr [intval]
	mov	edx, dword ptr [intval+4]

	ret
_ftol	endp




sqrt	proc	x:qword

	fld	[x]
	fsqrt

	ret
sqrt	endp

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perftool\stat\stat.c ===
/*
*      Stat.c        -    Source file for a statistical
*                         dll package that exports eleven
*                         entry points:
*                         a) TestStatOpen
*                         b) TestStatInit
*                         c) TestStatConverge
*                         d) TestStatValues
*                         e) TestStatClose
*                         f) TestStatRand
*                         g) TestStatUniRand
*                         h) TestStatNormDist
*                         i) TestStatShortRand
*                         j) TestStatFindFirstMode
*                         k) TestStatFindNextMode
*
*                         Entry point a) is an allocating routine
*                         that is called by an application program
*                         that desires to automatically compute
*                         convergence.
*
*                         Entry point b) initializes all variables that
*                         are used by entry points c) and d) in computing
*                         convergence and statistical information.
*
*                         Entry point c) automatically computes the
*                         the number of passes that the application has to
*                         go through for a 95% confidence data.
*                         This routine has to be called by the application
*                         after each pass.
*
*                         Entry point d) automatically computes the
*                         various statistical values eg. mean, SD etc.
*                         This function has to be called only after the
*                         application has called c) several times and has
*                         either converged or reached the iteration limit.
*
*                         Entry point e) deallocates all instance data
*                         data structures that were allocated by entry
*                         point a).
*
*                         Entry point f) returns a Random Number in a
*                         given range.
*
*                         Entry point g) returns a uniformly distributed
*                         number in the range 0 - 1.
*
*                         Entry point h) returns a normally distributed
*                         set of numbers, with repeated calls, whose
*                         mean and standard deviation are approximately
*                         equal to those that are passed in.
*
*                         Entry point i) is the same as g) except that
*                         the range is 0 - 65535.
*
*                         The following should be the rules of calling
*                         the entry points:
*
*                         Entry a) should be called before any of the others.
*                         Entry c) should be preceded by at least one call
*                         to entry b) for meaningful results.  Entry d)
*                         should be preceded by several calls to entry c).
*                         A call to b) and c) after a call to e) should
*                         preceded by a call to a) again.
*
*      Created         -  Paramesh Vaidyanathan  (vaidy)
*      Initial Version -  October 29, '90
*/

/*********************************************************************
*
*      Formula Used in Computing 95 % confidence level is derived here:
*
*
*        Any reference to (A) would imply "Experimental Design
*        in Psychological Research", by Allan Edwards.
*
*        Any reference to (B) would imply "Statistical Methods"
*        by Allan Edwards.
*
*        Assumptions - TYPE I Error  -  5% (B)
*                      TYPE II Error - 16% -do-
*
*        Area under the curve for Type I  - 1.96
*        Area under the curve for Type II - 1.00
*
*        For a 5% deviation, number of runs,
*
*                     2              2
*            n = 2 (c)  (1.96 + 1.00)
*                ------                      .....Eqn (1)
*                     2
*                 (d)
*
*            where c is the Std. Dev. and d is the absolute
*            difference bet. means [(B) Page 91].
*
*                    d = 5% X'               .....Eqn (2)
*
*            where X' is the mean of samples
*                         _
*                and  =  >_ X
*                        -----               .....Eqn (3)
*                         n
*                          0
*
*            When the number of iterations -> infinity,
*
*                     2     2
*                    S ->  c                 .....Eqn (4)
*
*
*                   2
*            where S is the estimate of the common population
*            variance (Eqn. 4 is a big assumption)
*
*        From (B) page 59, we have,
*
*             2     _  2       _   2
*            S  =  >_ X   - ( >_ X)
*                            -----
*                              n
*                               0
*                  -----------------         .....Eqn (5)
*                        n - 1
*                         0
*
*    Substituting Eqn (2), (3), (4) and (5) in (1), we get:
*                          _                     _
*                      2  |   _  2         _   2  |
*        n  = 7008  (n  ) |( >_ X  ) -  ( >_ X)   |
*                     0   |             --------  |
*                         |                n      |
*                         |_                0    _|
*                 ---------------------------------------
*                                        _    2
*                           (n  - 1)  ( >_ X )
*                             0
*
*    It should be mentioned that n  is the iteration pass number.
*                                 0
*********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <math.h>

#include "teststat.h"

#define SQR(A) ( (A) * (A) )        /* macro for squaring */
#define SUCCESS_OK          0       /* weird, but OK */
#define MIN_ITER            3       /* MIN. ITERATIONS */
#define MAX_ITER        65535       /* max. iterations */
#define REPEATS            14       /* repeat count for Norm. Dist. Fn. */
/**********************************************************************/
USHORT  usMinIter;              /* global min iter */
USHORT  usMaxIter;              /* global max iter */
ULONG  *pulDataArray;           /* a pointer to the data array for this
                                       package.  Will be as large as the
                                       maximum iterations */
double  dSumOfData;             /* sum of data during each pass */
double  dSumOfDataSqr;          /* sum of sqr. of each data point */
ULONG   ulTotalIterCount;       /* No. of iters returned by the interna;
                                   routine */
USHORT  cusCurrentPass;         /* count of the current iteration pass */
BOOL    bDataConverged = FALSE; /* TRUE will return a precision of 5% */
BOOL    bMemoryAllocated=FALSE; /* TRUE will allow alloced mem to free */
BOOL    bPowerComputed = FALSE; /* compute 10 exp. 9 for random no. gen */

BOOL   *pbIndexOfOutlier;       /* to keep track of values in
                                       pulDataArray, that were thrown out */

HANDLE hMemHandle = NULL;       /* handle to mem. allocated */
HANDLE hMemOutlierFlag;         /* handle to outlier flag memory */
/**********************************************************************/
ULONG TestStatRepeatIterations (double, double);
VOID TestStatStatistics (PSZ, PULONG far *, USHORT,
                                    PUSHORT, PUSHORT);
void DbgDummy (double, double);
ULONG   ulDataArrayAddress;         /* call to mem alloc routine returns
                                       base address of alloced. mem. */
BOOL    bOutlierDataIndex;          /* for allocating memory for outliers'
                                       index in data set */

/*********************************************************************/
/*
*    Function - TestStatOpen          (EXPORTED)
*
*    Arguments -
*                a) USHORT - usMinIterations
*                b) USHORT - usMaxIterations
*
*    Returns -
*                0 if the call was successful
*
*                An error code if the call failed.  The error code
*                may be one of:
*
*                   STAT_ERROR_ILLEGAL_MIN_ITER
*                   STAT_ERROR_ILLEGAL_MAX_ITER
*                   STAT_ERROR_ALLOC_FAILED
*
*
*    Instance data is allocated for the statistical package.  This
*    call should precede any other calls in this dll.  This function
*    should also be called after a call to TestStatClose, if convergence
*    is required on a new set of data.  An error code is returned if
*    argument a) is zero or a) is greater than b).  An error code is
*    also returned of one of the allocations failed.
*
*/

USHORT
TestStatOpen (
             USHORT usMinIterations,
             USHORT usMaxIterations
             )
{

    /* check for invalid args to this function */
    if (!usMinIterations)
        return (STAT_ERROR_ILLEGAL_MIN_ITER);
    if ((usMinIterations > usMaxIterations) || (usMaxIterations > MAX_ITER))
        return (STAT_ERROR_ILLEGAL_MAX_ITER);
    /* any other parameter is allowed */
    usMinIter = usMinIterations;      /* set global vars */
    usMaxIter = usMaxIterations;      /*    -do -        */

    // change made based on request from JeffSt/Somase/JonLe

    if (hMemHandle != NULL)
        return (STAT_ERROR_ALLOC_FAILED);

    hMemHandle = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, usMaxIter *
                              sizeof(ULONG));
    if (hMemHandle == NULL)
        return (STAT_ERROR_ALLOC_FAILED);

    pulDataArray = (ULONG *) GlobalLock (hMemHandle);
    if (pulDataArray == NULL)
        return (STAT_ERROR_ALLOC_FAILED);

    bMemoryAllocated = TRUE;  /* A call to TestStatClose will
                                 now free the mem */
    return (SUCCESS_OK);
}

/*
*    Function - TestStatClose          (EXPORTED)
*
*    Arguments - None
*
*    Returns -   Nothing
*
*    Instance data allocated for the statistical package by TestStatOpen
*    is freed.  Any call to entry points b) and c) following a call to
*    this function, should be preceded by a call to a).
*
*/
VOID
TestStatClose (VOID)
{
    if (bMemoryAllocated) {   /* free only if memory allocated */
        GlobalUnlock (hMemHandle);
        GlobalFree (hMemHandle);
        hMemHandle = NULL; /* Indicate released (t-WayneR/JohnOw) */
    }  /* end of if (bMemoryAllocated) */
    bMemoryAllocated = FALSE;  /* further calls to TestStatClose should be
                                  preceded by a memory allocation */
    return;
}

/*
*    Function - TestStatInit          (EXPORTED)
*
*    Arguments - None
*
*    Returns -   Nothing
*
*    Initializes all the data arrays/variables for use by the convergence
*    and statistics routines.  This call should precede the first call
*    to TestStatConverge for each set of data.
*
*/

VOID
TestStatInit (VOID)
{
    USHORT usTempCtr;

    /* initialize all counters, variables and the data array itself */
    for (usTempCtr = 0; usTempCtr < usMaxIter; usTempCtr++) {
        pulDataArray [usTempCtr] = 0L;
    }
    dSumOfData = 0.0;
    dSumOfDataSqr = 0.0;
    ulTotalIterCount = 0L;
    cusCurrentPass = 0;
    bDataConverged = FALSE;
    return;
}

/*
*    Function - TestStatConverge          (EXPORTED)
*
*    Arguments -
*                a) ULONG - ulNewData
*    Returns -
*                TRUE if data set converged or limit on max. iters reached
*
*                FALSE if more iterations required for converged.
*
*    Computes the number of iterations required for a 95% confidence
*    in the data received (please see teststat.txt under \ntdocs on
*    \\jupiter\perftool for an explanation of the confidence.
*    If the current iteration count is larger than the maximum specified
*    with the call to TestStatOpen, or if the data set has converged
*    this function returns a TRUE.  The calling application should test
*    for the return value.
*/

BOOL
TestStatConverge (
                 ULONG ulNewData
                 )
{
    dSumOfData += (double)ulNewData;   /* sum of all data points in the set */
    dSumOfDataSqr += SQR ((double) ulNewData);
    /* sqr of data needed for the computation */
    if (cusCurrentPass < (USHORT) (usMinIter-(USHORT)1)) { /* do nothing if current iter
                                           < min specified value */
        ulTotalIterCount = (ULONG)usMaxIter + 1;  /* bogus value */
        pulDataArray [cusCurrentPass++] = ulNewData;
        /* register this data into the array and return FALSE */
        return (FALSE);
    }
    if ((cusCurrentPass == usMaxIter) ||
        (cusCurrentPass >= (USHORT) ulTotalIterCount)) {
        /* either the limit on the max. iters. specified has been reached
           or, the data has converged during the last iter; return TRUE */

        if (cusCurrentPass >= (USHORT) ulTotalIterCount)
            bDataConverged = TRUE;  /* set to determine if precision
                                       should be computed */
        return (TRUE);
    }
    if ((usMinIter < MIN_ITER) &&
        (usMinIter == usMaxIter) && ((USHORT)(cusCurrentPass+(USHORT)1) >= usMaxIter))
        /* don't call convergence algorithm, just return a TRUE */
        /* It does not make any sense in calling the convergence
           algorithm if less than 3 iterations are specifed for the
           minimum */
        return (TRUE);
    pulDataArray [cusCurrentPass++] = ulNewData; /* register this data into
                                                    the array */
    if (dSumOfData == 0.0) { /* possible if data points are all zeros */
        bDataConverged = TRUE;
        return (TRUE);
    }
    ulTotalIterCount = TestStatRepeatIterations (dSumOfData,
                                                 dSumOfDataSqr);

    if (ulTotalIterCount <= cusCurrentPass)
        return (TRUE);

    return (FALSE);
}

/*
*    Function - TestStatValues          (EXPORTED)
*
*    Arguments -
*               a) PSZ - pszOutputString
*               b) USHORT - usOutlierFactor
*               c) PULONG - *pulData
*               d) PUSHORT - pcusElementsInArray
*               e) PUSHORT - pcusDiscardedElements
*
*    Returns -
*               Nothing
*
*    Computes useful statistical values and returns them in the string
*    whose address is passed to this function.  The returned string
*    has the following format :
*        ("%4u %10lu  %10lu  %10lu  %6u %5u  %10lu %4u  %2u")
*    and the arg. list will be in the order: mode number, mean,
*    minimum, maximum, number of iterations, precision,
*    standard deviation, number of outliers in the data set and the
*    outlier count.  (Please refer to \ntdocs\teststat.txt for
*    a description of precision. This is on \\jupiter\perftool.
*
*/
VOID
TestStatValues(
              PSZ     pszOutputString,
              USHORT  usOutlierFactor,
              PULONG  *pulFinalData,
              PUSHORT pcusElementsInArray,
              PUSHORT pcusDiscardedElements
              )
{
    ULONG far * pulArray = NULL;
    USHORT Count =0;
    /* Call the low-level routine to do the statistics computation */
    /* doing this ,'cos, there is a possibility that the low-level
       routine may be used for some apps, within the perf. group.  This
       may not be fair, but that is the way life is */
    TestStatStatistics (pszOutputString, &pulArray,
                        usOutlierFactor, pcusElementsInArray,
                        pcusDiscardedElements);
    *pulFinalData = pulArray;
    return;

}

/***********************************************************************
                ROUTINES NOT EXPORTED, BEGIN
***********************************************************************/
/*
*     Function  - TestStatRepeatIterations  (NOT EXPORTED)
*     Arguments -
*               (a) double - Sum of Individual Data Points thus far
*               (b) double - Sum of Squares of Indiv. data points
*
*     Returns  - ULONG  - value of no. of iterations required for 95%
*                         confidence,
*
*     Computes the number of iterations required of the calling program
*     before a 95% confidence level can be reached.  This will return
*     a zero if the application calls this routine before 3 passes
*     are complete.  The function normally returns the total number of
*     iterations that the application has to pass through before
*     offering a 95% confidence on the data.
*/

ULONG
TestStatRepeatIterations(
                        double dSumOfIndiv,
                        double dSumOfSqrIndiv
                        )
{
    double dSqrSumOfIndiv = 0;
    ULONG  ulRepeatsNeeded = 0L;

    /* dSqrSumOfIndiv. stands for the square of the Sum of Indiv. data
       points,
       dSumOfSqrIndiv stands for the sum of the square of each entry point,
       dSumOfIndiv. stands for the sum of each data point in the set, and
       uIter is the iteration pass count
    */
    if (cusCurrentPass < MIN_ITER)
        /* not enough passes to compute convergence count */
        return (MAX_ITER);
    dSqrSumOfIndiv = SQR (dSumOfIndiv);
    /* use the formula derived at the beginning of this file to
       compute the no. of iterations required */

    ulRepeatsNeeded = (ULONG) (7008 *
                               (dSumOfSqrIndiv - dSqrSumOfIndiv/cusCurrentPass)
                               * SQR (cusCurrentPass) /
                               ((cusCurrentPass - 1) * dSqrSumOfIndiv));

    return (ulRepeatsNeeded);
}
/***************************************************************************/
/*
*     Function  - TestStatStatistics
*     Arguments -
*                 a) PSZ - pszOutputString
*                 b) PULONG far * - pulFinalData
*                 c) USHORT - usOutlierFactor
*                 d) PUSHORT - pcusElementsInArray
*                 e) PUSHORT - pcusDiscardedValues
*
*     Returns  -  Nothing
*
*     Computes the max, min, mean, and std. dev. of a given
*     data set.  The calling program should convert the values obtained
*     from this routine from a "ULONG" to the desired data type.  The
*     outlier factor decides how many data points of the data set are
*     within acceptable limits.  Data is returned to the buffer whose
*     address is the first argument to this call.
*
*/

VOID
TestStatStatistics (
                   PSZ     pszOutputString,
                   PULONG  *pulFinalData,
                   USHORT  usOutlierFactor,
                   PUSHORT pcusElementsInArray,
                   PUSHORT pcusDiscardedValues
                   )
{
    static USHORT   uArrayCount = 0;  /* local variable that may be reused */
    USHORT uTempCt = 0;  /* local variable that may be reused */
    double dSqrOfSDev = 0;       /* sqr of the std. deviation */
    double dSumOfSamples = 0;    /* sum of all data points */
    double dSumOfSquares = 0;    /* sum of squares of data points */
    ULONG  ulMean = 0L;
    ULONG  ulStdDev = 0L;
    ULONG  ulDiffMean = 0L;           /* to store the diff. of mean and SD,
                                         outlier factor */
    BOOL   bAcceptableSDev = TRUE ;   /* flag to determine if SDev. is
                                         acceptable */
    ULONG  ulMax = 0L;                /* pilot value */
    ULONG  ulMin = 0xffffffff;        /* largest possible ULONG */
    USHORT usPrecision = 0;           /* to obtain precision */
    USHORT uModeNumber = 0;           /* DUMMY VALUE until this is
                                         supported */

    /* compute mean by adding up all values and dividing by the no.
       of elements in data set - might need to recompute the
       mean if outlier factor is selected.  However, the min. and max. will
       be selected from the entire set */

    USHORT Count = 0;

    *pcusDiscardedValues = 0;       /* init. this variable */

    if (cusCurrentPass == 0)
        return;   /* get out without doing anything - this is a weird
                         case when the user calls this routine without
                         calling a converge routine */

    *pcusElementsInArray = cusCurrentPass;

    /* every iteration produces one data point */
    uArrayCount = 0;
    while (uArrayCount < *pcusElementsInArray) {
        if (pulDataArray[uArrayCount] > ulMax)
            ulMax = pulDataArray[uArrayCount];     /* new Max. value */
        if (pulDataArray[uArrayCount] < ulMin)
            ulMin = pulDataArray[uArrayCount];     /* new min. value */

        ulMean += pulDataArray [uArrayCount++];
    }
    if (*pcusElementsInArray)
        ulMean /= *pcusElementsInArray;   /* this is the mean */
    else
        ulMean = 0;
    /* the standard deviation needs to be computed */

    for (uArrayCount = 0; uArrayCount < *pcusElementsInArray; uArrayCount++) {
        dSumOfSamples += (double) pulDataArray [uArrayCount];
        dSumOfSquares += SQR ((double) pulDataArray [uArrayCount]);
    }

    if (*pcusElementsInArray) {
        dSqrOfSDev = ((*pcusElementsInArray * dSumOfSquares) -
                      SQR (dSumOfSamples)) /
                     (*pcusElementsInArray * (*pcusElementsInArray - 1));
    }
    ulStdDev = (ULONG) sqrt (dSqrOfSDev);

    /* the standard deviation has been computed for the first pass */
    /* Use the outlier factor and the S.D to find out if any of
       individual data points are abnormal.  If so, throw them out and
        increment the discard value counter */
    if (usOutlierFactor) { /* if outlier factor is zero, do not go
                          through with the following */
        /*** here is what we do....
           allocate space for an array of BOOLs.  Each of these is a flag
           corresponding to a data point.  Initially, these flags will be
           all set to FALSE.  We then go thru each data point.  If a data
           point does not satisfy the condition for throwing out outliers,
           we set the flag corresponding to that data point to TRUE.  That
           point is not used to recompute the mean and SDev.  We recompute
           the mean and SDev after each round of outlier elimination.  When
           we reach a stage where no points were discarded during a round,
           we get out of the while loop and compute the statistics for the
           new data set ****/

        hMemOutlierFlag = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT,
                                       *pcusElementsInArray * sizeof(BOOL));
        pbIndexOfOutlier = (BOOL FAR *) GlobalLock (hMemOutlierFlag);
        if (!pbIndexOfOutlier) {
            return;
        }

        for (uArrayCount = 0; uArrayCount < *pcusElementsInArray;
            uArrayCount ++)
            pbIndexOfOutlier [uArrayCount] = FALSE;

        while (1) { /* begin the data inspection round */
            bAcceptableSDev = TRUE; /* set this flag to TRUE.  If we
                                       hit an outlier, this flag will
                                       be reset */
            for (uArrayCount = 0; uArrayCount < cusCurrentPass;
                uArrayCount++) {
                /*** check the individual data points ***/
                if (ulMean < (ulStdDev * usOutlierFactor))
                    /* just make sure that we are not comparing with a
                       negative number */
                    ulDiffMean = 0L;
                else
                    ulDiffMean = (ulMean - (ulStdDev * usOutlierFactor));
                if (!pbIndexOfOutlier [uArrayCount]) {
                    if ((pulDataArray [uArrayCount] < ulDiffMean)
                        || (pulDataArray [uArrayCount] >
                            (ulMean + (ulStdDev * usOutlierFactor)))) {
                        /* set the flag of this data point to TRUE to
                           indicate that this data point should not be
                           considered in the mean and SDev computation */
                        pbIndexOfOutlier [uArrayCount] = TRUE;
                        /*** increment the discarded qty ***/
                        (*pcusDiscardedValues)++;
                        /*** decrement the count of good data points ***/

                        // uncomment next line if outliers should be part of mean - vaidy

                        //                        (*pcusElementsInArray)--;
                        bAcceptableSDev = FALSE;
                    }  /*** end of if statement ***/
                }   /*** end of if !pbIndexOfOutlier ***/
            }  /*** end of for loop ***/
            if (!bAcceptableSDev) {  /*** there were some bad data points ;
                                        recompute S.Dev ***/
                // Starting at next statement, uncomment all lines until you see
                // "STOP UNCOMMENT FOR OUTLIERS IN MEAN", if you want outliers to be
                // part of mean.  vaidy Aug. 1991.

                //                dSumOfSamples = 0.0; /* init these two guys */
                //                dSumOfSquares = 0.0;
                //                for (uArrayCount = 0;
                //                     uArrayCount < cusCurrentPass;
                //                     /* check all elements in the data array */
                //                     uArrayCount++) {
                //                    /* consider only those data points that do not have the
                //                       pbIndexOfOutlier flag set */

                //                    if (!pbIndexOfOutlier [uArrayCount]) {
                //                        dSumOfSamples += (double) pulDataArray [uArrayCount];
                //                        dSumOfSquares += SQR ((double)pulDataArray
                //                                                      [uArrayCount]);
                //                    }
                //                }
                //                if (*pcusElementsInArray > 1)
                //                    /* compute StdDev. only if there are atleast 2 elements */
                //                    dSqrOfSDev = ((*pcusElementsInArray * dSumOfSquares) -
                //                               SQR (dSumOfSamples)) /
                //                              (*pcusElementsInArray *
                //                              (*pcusElementsInArray - 1));
                //                ulStdDev = (ULONG) sqrt (dSqrOfSDev);
                //                /* since some data points were discarded, the mean has to be
                //                   recomputed */
                //                uArrayCount = 0;
                //                ulMean = 0;
                //                while (uArrayCount < cusCurrentPass) {
                //                    /* consider only those data points that do not have the
                //                       bIndexOfOutlier flag set */
                //                    if (!pbIndexOfOutlier [uArrayCount++])
                //                        ulMean += pulDataArray [uArrayCount - 1];
                //                }
                //                if (*pcusElementsInArray > 0)  /* only then compute mean */
                //                    ulMean /= *pcusElementsInArray; /* this is the new mean */
                //                else
                //                    ulMean = 0L;
                // "STOP UNCOMMENT FOR OUTLIERS IN MEAN"
            } /*** end of if (!bAcceptableSDev) ***/
            else       /*** if the for loop completed without
                            a single bad data point ***/
                break;
        } /* end of while */
        /****  free the memory for the bIndexOfOutiler flag */
        GlobalUnlock (hMemOutlierFlag);
        GlobalFree (hMemOutlierFlag);
    }  /* end of if (iOutlierFactor) */
    /* so, now an acceptable Standard deviation and mean have been obtained */

    if ((!bDataConverged) &&
        (usMaxIter < MIN_ITER)) {
        /* set precision to 0% if max iters chosen is less than 3 */
        usPrecision = 0;
    } else { /* need to compute precision */
        /* using eqn. 1. above, it can be shown that the precision, p,
           can be written as:
                                      1
                 _                 _   /
                |        2       2  |   2
                |  2 * SD  * 2.96   |
            p = | ----------------- |
                |             2     |
                |     n * Mean      |
                |_                 _|
        *************************************************************/
        if (ulMean > 0 && *pcusElementsInArray) {
            usPrecision = (USHORT) (sqrt((double) ((2 *
                                                    SQR ((double)ulStdDev) *
                                                    SQR (2.96) /(*pcusElementsInArray *
                                                                 SQR ((double) ulMean))))) * 100.0
                                    + 0.5);

        } else
            usPrecision = (USHORT)~0;
    }  /* end of else need to compute precision */
    sprintf (pszOutputString,
             "%4u %10lu %10lu %10lu %6u %5u %10lu %4u %2u ",
             uModeNumber, ulMean, ulMin, ulMax, cusCurrentPass,
             usPrecision, ulStdDev, *pcusDiscardedValues,
             usOutlierFactor);

    *pcusElementsInArray = cusCurrentPass;
    *pulFinalData = pulDataArray;
    return;
}


/*
*        The following is the source for generating random numbers.
*        Two procs are provided:  TestStatRand and TestStatUniRand.
*
*   a)   TestStatRand is called as follows: TestStatRand (Low, High)
*            The result is a number returned in the range Low - High (both
*            inclusive.
*
*        A given intial value of Seed will yield a set of repeatable
*        results.  The first call to TestStatRand should be with an odd seed
*        in the range of 1 - 67108863, both inclusive.  The following
*        9 seeds have been tested with good results:
*
*        32347753, 52142147, 52142123, 53214215, 23521425, 42321479,
*        20302541, 32524125, 42152159.
*
*        The result should never be equal to the seed since this would
*        eliminate the theoretical basis for the claim for uniform
*        randomeness.
*
*   b)   TestStatUniRand is called as follows:
*                 NormFrac = TestStatUniRand ();
*            NormFrac is uniformaly distributed between 0 and 1 with
*            a scale of 9 (values range bet. 0 and 0.999999999).
*
*        The basis for this algorithm is the multiplicative congruential
*        method found in Knuth (Vol.2 , Chap.3).  Constants were selected
*        by Pike, M.C and Hill, I.D; Sullivans, W.L. provides the
*        the list of tested seeds.
*
*        The code here has been adapted from Russ Blake's work.
*
*        Created  :   vaidy   - Nov. 29, 90
*/

#define MODULUS     67108864      /* modulus for computing random no */
#define SQRTMODULUS 8192          /* sqrt of MODULUS */
#define MULTIPLIER  3125
#define MAX_UPPER   67108863
#define MAX_SEEDS   8           /* 8 good starting seeds */
#define SCALE       65535

ULONG aulSeedTable [] = {     /* lookup table for good seeds */
    32347753, 52142147, 52142123, 53214215, 23521425, 42321479,
    20302541, 32524125, 42152159};

USHORT uSeedIndex;            /* index to lookup table */
ULONG  ulSeed = 32347753;     /* the seed chosen from table (hardcoded here)
                                 and recomputed */

/*********************************************************************/
/*
*    Function - TestStatRand          (EXPORTED)
*
*    Arguments -
*                a) ULONG  - ulLower
*                b) ULONG  - ulUpper
*
*    Returns -
*                a random number in the range ulLower to ulUpper
*
*                An error code if the call failed.  The error code
*                will be:
*
*                   STAT_ERROR_ILLEGAL_BOUNDS
*
*
*   Calls TestStatUniRand and returns a random number in the range passed
*   in (both inclusive).  The limits for the lower and upper bounds
*   are 1 and 67108863.  The start seed index looks up into the array
*   of seeds to select a good, tested starting seed value.  The returned
*   values will be uniformaly distributed within the boundary.  A start
*   seed has been hardcoded into this dll.
*
*/

ULONG
TestStatRand (
             ULONG ulLower,
             ULONG ulUpper
             )
{
    double dTemp;
    double dNormRand;
    LONG   lTestForLowBounds = (LONG) ulLower;

    /* check args */
    if ((lTestForLowBounds < 1L) ||
        (ulUpper > MAX_UPPER) || (ulUpper < ulLower))
        return (STAT_ERROR_ILLEGAL_BOUNDS);
    dNormRand = TestStatUniRand ();  /* call TestStatUniRand */
    dTemp = (double) ((ulUpper - ulLower) * dNormRand); /* scale value */
    return (ulLower + (ULONG) dTemp);
}

/*
*
*   Function - TestStatUniRand ()          EXPORTED
*
*   Accepts -  nothing
*
*   Returns a uniformaly distrib. normalized number in the range 0 - 0.9999999
*   (both inclusive).  Modifies the seed to the next value.
*
*/

double
TestStatUniRand (VOID)
{
    ULONG  ulModul = MODULUS;   /* use the modulus for getting remainder
                                   and dividing the current value */
    double dMult   = MULTIPLIER;
    double dTemp   = 0.0;       /* a temp variable */
    double dTemp2  = 0.0;       /* a temp variable */
    ULONG  ulDivForMod;         /* used for obtaining the remainder of
                                   the present seed / MODULUS */

    /* the following long-winded approach has to be adopted to
       obtain the remainder.  % operator does not work on floats */

    /* use a temp variable.  Makes the code easier to follow */

    dTemp = dMult * (double) ulSeed;  /* store product in temp var. */
    DbgDummy (dTemp, dMult); // NT screws up bigtime for no reason
                             // if this is not used - possible compiler
                             // bug
    dTemp2 = (double) ulModul; // more compiler problems reported
                               // on Build 259 by JosephH.
                               // April 13, 1992.
    ulDivForMod = (ULONG) (dTemp / dTemp2);

    //    ulDivForMod = (ULONG) (dTemp / ulModul); /* store quotient of present
    //                                                seed divided by MODULUS */
    dTemp -= ((double)ulDivForMod * (double)ulModul);
    /* dTemp will contain the remainder of present seed / MODULUS */

    ulSeed = (ULONG) dTemp;   /* seed for next iteration obtained */
    /* return value */
    return ((dTemp)/(double)ulModul);
}

/*
*
*   Function - TestStatNormDist ()          EXPORTED
*
*   Accepts -
*              a) ULONG  - ulMean
*              b) USHORT - usStdDev
*
*   Returns -  LONG - A LONG that allows the mean of the generated
*              points to be approximately ulMean and the SD of the
*              set to be ulStdDev.
*
*   Formula used here is:            REPEATS
*                                    _
*   Return Value = ulMean + (-7 + [ >_ TestStatUniRandRand ()] * ulStdDev
*                                   i = i
*
*   This formula is based on 'Random Number Generation and Testing',
*   IBM Data Processing Techniques, C20-8011.
*/

LONG
TestStatNormDist (
                 ULONG ulMean,
                 USHORT usSDev
                 )
{
    LONG   lSumOfRands = 0L;  /* store the sum of the REPEATS calls here */
    USHORT cuNorm;            /* a counter */
    LONG   lMidSum = 0L;
    LONG   lRemainder = 0L;

    for (cuNorm = 0; cuNorm < REPEATS; cuNorm++)
        lSumOfRands += (LONG) TestStatShortRand ();

    /* we now do a lot of simple but ugly mathematics to obtain the
       correct result.  What we do is as follows:

       Divide the lSumOfRands by the scale factor.
       Since we are dealing with short and long integers, we are
       likely to lose precision.  So, we get the remainder of this
       division and multiply each of the values by the standard division.

       Eg. if lSumOfRands = 65534 and std.dev is 10,
       lQuotient = 0, lRemainder = 65534.

       lMidSum = (-7 * 10) + (0 * 10) + (65534 * 10/65535) = -61,
       which is pretty accurate.  We then add the mean and return.
       Actually, we do not return right away.  To be more precise,
       we need to find out if the third element in the above term
       yields a remainder of < 0.5.  If so, we do not do anything.
       Else, we add 1 to the result to round off and then return.
       In the above example, the remainder = 0.99.  So we add 1 to
       -61.  The result is -60 and this is accurate. */

    lRemainder = (lSumOfRands * usSDev) % SCALE;
    /* the above remainder is the one to determine the rounding off */

    lMidSum =  ((-7 + (lSumOfRands / SCALE)) * usSDev) +
               ((lSumOfRands % SCALE) * usSDev / SCALE);

    if (lRemainder >= (SCALE / 2L))  /* need to roundup ? */
        lMidSum += 1L;

    return (lMidSum + ulMean);
}

/*
*
*   Function - TestStatShortRand ()          EXPORTED
*
*   Accepts -  nothing
*
*   Returns a normalized number in the range 0 - 65535
*   (both inclusive).  Modifies the seed to the next value.
*
*/

USHORT
TestStatShortRand (VOID)
{
    ULONG  ulTemp = SCALE / SQRTMODULUS;

    ulSeed =  (MULTIPLIER * ulSeed) % MODULUS;
    /* seed for next iteration obtained */

    /* note: the return value should be (ulSeed * SCALE / MODULUS).
       However, the product of the elements in the numerator, far exceeds
       4 Billion.  So, the math is done in two stages.  The value of
       MODULUS is a perfect square (of 8192).  So, the SCALE is first
       divided by the SQRT of the MODULUS, the product of ulSeed and the
       result of the division is divided by the SQRT of the MODULUS again */

    /* return scale value - add one to ulTemp for correction */
    return ((USHORT) ((ulSeed * (ulTemp + 1)) / SQRTMODULUS));
}

/*
*
*   Function - TestStatFindFirstMode ()          EXPORTED
*
*   Accepts -  a) PSZ     - pszOutputString
*              b) USHORT  - usOutlierFactor
*              c) PULONG  - *pulData
*              d) PUSHORT - pcusElementsInArray
*              e) PUSHORT - pcusDiscardedElements
*
*    Returns -
*               Nothing
*
*    Computes useful statistical values and returns them in the string
*    whose address is passed to this function.  The returned string
*    has the following format :
*        ("%10lu  %10lu  %10lu  %10lu %5u  %10lu %4u  %2u")
*    and the arg. list will be in the order: mean,
*    minimum, maximum, number of iterations, precision,
*    standard deviation, number of outliers in the data set and the
*    outlier count.  (Please refer to \ntdocs\teststat.txt for
*    a description of precision. This is on \\jupiter\perftool.
*
*   Returns
*                TO BE COMPLETED.....
*
*/

/*++
  Had to call this routine in TestStatUniRand - compiler screws up
--*/
void
DbgDummy (
         double dTemp,
         double dLocal
         )
{
    dTemp = 0.0;
    dLocal = 0.0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perftool\inc\timing.h ===
/* Header file for timer.dll.  Use with timer.c for making the
   dll 
*/

typedef enum {
    KILOSECONDS,
    SECONDS,
    MILLISECONDS,
    MICROSECONDS,
    TENTHMICROSECS,
    NANOSECONDS,
    TIMER_FREE
} _TimerUnits;

#if (defined (WIN16) || defined (WIN32) || defined (NTWIN))
    #define SHORT short
    #define ULONG DWORD
    #define USHORT WORD
    #define PSHORT short *
    #define PSZ	  LPSTR
#endif

#if (defined (WIN16))
    #define PLONG LPSTR
    typedef struct _QWORD {	       
	ULONG	ulLo;
	ULONG	ulHi;
    } QWORD;

    typedef QWORD FAR *PQWORD;
#endif

#if (defined (WIN32) || defined (NTWIN))
#ifdef W32S
    typedef struct _QWORD {
	ULONG	ulLo;
	ULONG	ulHi;
    } QWORD;
#define PQWORD QWORD *
#else
#define PQWORD PLARGE_INTEGER
#endif
#endif

#if (!defined (WIN32) && !defined (NTWIN))
#define OPTIONAL
#endif

#if (defined (OS2SS) || defined (NTNAT) || defined (WIN32) || defined (NTWIN))
#define far
#if (!defined (WIN32) && !defined (NTWIN))
#define FAR
#endif
#endif

#ifdef NTNAT
#define BOOL BOOLEAN
#endif

#ifdef OS2386
#define far
#endif

SHORT FAR PASCAL TimerOpen (SHORT far *, _TimerUnits);
SHORT FAR PASCAL TimerInit (SHORT);
ULONG FAR PASCAL TimerRead (SHORT);
SHORT FAR PASCAL TimerClose (SHORT);
BOOL  FAR PASCAL TimerReport (PSZ, SHORT);
VOID  FAR PASCAL TimerQueryPerformanceCounter (PQWORD, PQWORD);
ULONG FAR PASCAL TimerConvertTicsToUSec (ULONG, ULONG);

#define TIMERERR_NOT_AVAILABLE 1
#define TIMERERR_NO_MORE_HANDLES 2
#define TIMERERR_INVALID_UNITS 3
#define TIMERERR_INVALID_HANDLE 4
#define TIMERERR_OVERFLOW 0xffffffff

typedef struct {
    ULONG ulLo;
    ULONG ulHi;
    _TimerUnits TUnits;
} Timer;

#ifdef WIN16
    #define MAX_TIMERS 500
#else                              
    #define MAX_TIMERS 5000
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perftool\timer\timer.c ===
/*  OS/2 Version
*      Timer.c       -    Source file for a statistical
*                         dll package that exports four
*                         entry points:
*                         a) TimerOpen
*                         b) TimerInit
*                         c) TimerRead
*                         d) TimerClose
*                         e) TimerReport
*                         f) TimerQueryPerformanceCounter
*                         g) TimerConvertTicsToUSec
*
*                         Entry point a) opens a timer object
*                         and returns a handle to the timer. This
*                         handle is an index into an array of timer
*                         objects (structs) that are allocated at
*                         the time of the initialization of the dll.
*                         This ensures that allocation is done once only.
*                         Each application program will call this
*                         this function so that it has its own set
*                         of timers to use with TimerInit and TimerRead.
*                         The units of the time returned by TimerRead
*                         is also made available as a parameter to
*                         this call.
*
*                         Entry point b) is called by the application
*                         before commencing a timing operation.  This
*                         function is called with a handle to a timer
*                         object that was opened.  This function has to
*                         to be called before a call to TimerRead. The
*                         current time is stored in the timer object.
*
*                         Entry point c) is called each time the time
*                         since the previous call to TimerInit is
*                         desired.  This call also uses the handle to
*                         a timer that has been previosly opened. The
*                         current time is obtained form the lowlevel
*                         timer and this and the time at TimerInit time
*                         are used, along with the clock frequency and
*                         the return time units and the elapsed time
*                         is obtained and returned as a ULONG.
*
*                         Entry point d) is called whenever an opened
*                         timer is not needed any longer.  This call
*                         resets the timer and makes this timer as
*                         available to future calls to TimerOpen.
*
*                         Entry point e) returns the time obtained during
*                         the last call to TimerInit, TimerRead and the
*                         last returned time.
*
*                         Entry point f) accepts pointers to 2 64 bit
*                         vars.  Upon return, the first will contain the
*                         the current timer tic count and the second,
*                         if not NULL, will point to the timer freq.
*
*                         Entry point g) accepts Elapsed Tics as ULONG,
*                         Frequency as a ULONG and returns the time in
*                         microsecs. as  a ULONG.
*
*                         The dll initialization routine does the
*                         following:
*                             a) Obtains the timer overhead for calibration
*                                purposes.
*                             b) Allocates memory for a large number of
*                                timer objects (this will be system dep).
*                             c) Initializes each timer objects "Units'
*                                element to a "TIMER_FREE" indicator.
*                             d) Determines the lowlevel timer's frequency.
*
*                         TimerRead uses an external asm routine to perform
*                         its computation for elapsed time.
*
*     Created         -   Paramesh Vaidyanathan  (vaidy)
*     Initial Version -              October 18, '90
*
*     Modified to include f).  -     Feb. 14, 1992. (vaidy).
*/

char *COPYRIGHT = "Copyright Microsoft Corporation, 1991-1998";

#ifdef SLOOP
    #define INCL_DOSINFOSEG
    #define INCL_DOSDEVICES
    #define INCL_DOSPROCESS
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "timing.h"
/*****************************END OF INCLUDES*************************/
#define ITER_FOR_OVERHEAD   250
#define SUCCESS_OK            0
#define ONE_MILLION     1000000L
#define MICROSEC_FACTOR 1000000
#define TIMER_FREQ   1193167L  /* clock frequency - Hz */
/*********************************************************************/
Timer pTimer [MAX_TIMERS];       /* array of timer struct */

BOOL  bTimerInit = FALSE;        /* TRUE indicates low level timer exists */
ULONG ulTimerOverhead = 50000L;  /* timer overhead stored here */
BOOL  bCalibrated = FALSE;       /* TRUE subtracts overhead also */
ULONG ulFreq;                    /* timer frequency */
LONG aScaleValues[] = {1000000000L, 1000000L, 1000L, 1L, 10L, 1000L};
/* this is the table for scaling the units */
ULONG ulElapsedTime = 0L;
/********************* internal unexported routines ***************/
ULONG  CalibrateTimerForOverhead (VOID);
/*****************DEFINE VARIBLES AND PROTOTYPE FNS. FOR PLATFORMS*****/
NTSYSAPI
NTSTATUS
NTAPI
NtQueryPerformanceCounter (
                          OUT PLARGE_INTEGER PerformanceCount,
                          OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
                          );

LARGE_INTEGER      PerfFreq;
LARGE_INTEGER      CountCurrent;

SHORT  GetTimerFreq (VOID);

/****************** internal unexported routines end***************/

/*
*     Function  - TimerOpen            (EXPORTED)
*     Arguments -
*               (a) SHORT far * -     address to which to return handle of
*                                the timer object.
*               (b) TimerUnits - units in which to return time from
*                                TimerRead.  It is one of the enum
*                                types defined in the header file.
*
*     Returns  -    SHORT  -     0 if handle was returned successfully
*                                Else, an error code which may be one of:
*
*                                    TIMERERR_NOT_AVAILABLE
*                                    TIMERERR_NO_MORE_HANDLES
*                                    TIMERERR_INVALID_UNITS
*
*     Obtains the handle to a timer object after opening it.
*     Should precede any calls to timer manipulation.  Checks
*     for validity of timer units.
*/

SHORT
TimerOpen (
          SHORT *  phTimerHandle,
          _TimerUnits TimerUnits
          )
{
    SHORT csTemp;

    if ((TimerUnits < KILOSECONDS)
        || (TimerUnits > NANOSECONDS)) /* out of the enum range */
        return (TIMERERR_INVALID_UNITS);

    if (!bTimerInit)  /* set during dll initialization */
        return (TIMERERR_NOT_AVAILABLE);

    /* else check if any timers are not in use and return the first
       available timer handle....actually the index into the
       timer object array */
    for (csTemp = 0; csTemp < MAX_TIMERS; csTemp++) {
        if (pTimer [csTemp].TUnits == TIMER_FREE) {
            *phTimerHandle =  csTemp;  /* found a free timer.  Return
                                          the handle */
            pTimer [csTemp].ulHi = pTimer[csTemp].ulLo = 0L;
            pTimer [csTemp].TUnits =
            TimerUnits;  /* set the units for timer */
            return (SUCCESS_OK);
        }
    }
    /* if exec reached here, all timers are being used */
    return (TIMERERR_NO_MORE_HANDLES);
}

/*
*     Function  - TimerInit       (EXPORTED)
*     Arguments -
*               (a) SHORT - hTimerHandle
*
*     Returns  - SHORT - 0 if call successful
*                        Else, an error code if handle invalid:
*
*                            TIMERERR_INVALID_HANDLE
*
*     Calls the low-level timer and sets the ulHi and ulLo of the
*     chosen timer to the time returned by the timer.  Should be
*     called after opening the timer with TimerOpen.
*/

SHORT
TimerInit (
          SHORT hTimerHandle
          )
{

    NTSTATUS NtStatus;

    if ((hTimerHandle > MAX_TIMERS - 1) ||
        (pTimer [hTimerHandle].TUnits == TIMER_FREE))
        /* this timer has not been opened or does not exist. Return error */
        return (TIMERERR_INVALID_HANDLE);

    /* otherwise get the time from the low-level timer into
       the structure */

    NtStatus = NtQueryPerformanceCounter (&CountCurrent, NULL);
    pTimer [hTimerHandle].ulLo = CountCurrent.LowPart;
    pTimer [hTimerHandle].ulHi = CountCurrent.HighPart;
    /* this timer structure has all the information needed to compute
       the elapsed time.  So return success, if there was no problem */

    return (SUCCESS_OK);
}

/*
*     Function  - TimerRead       (EXPORTED)
*     Arguments -
*               (a) SHORT - hTimerHandle
*
*     Returns  - ULONG - elapsed time since last call to TimerInit
*                         if call successful.
*
*                        Else, an error code if handle invalid or output
*                         overflow.  The error code will be the same:
*
*                            TIMERERR_OVERFLOW (max possible ULONG)
*
*     Calls the low-level timer.  Uses the ulLo and ulHi from the
*     timer's structure and subtracts the current time from the
*     saved time.  Uses ReturnElapsedTime (an external ASM proc)
*     to return the elapsed time taking into account the clock
*     frequency and the units for this timer.  Each call to this
*     returns the time from the previous TimerInit.
*
*     The user should interpret the return value sensibly to check
*     if the result is an error or a real value.
*/

ULONG
TimerRead (
          SHORT hTimerHandle
          )
{
    NTSTATUS NtStatus;
    LARGE_INTEGER  ElapsedTime, CountPrev, LargeOverhead;

    if ((hTimerHandle > MAX_TIMERS - 1)
        || (pTimer [hTimerHandle].TUnits == TIMER_FREE))
        /* this timer has not been opened or does not exist.
           Return TIMERERR_OVERFLOW ie. 0xffffffff, the max. possible
           ULONG.  The user should interpret such a result sensibly */
        return (TIMERERR_OVERFLOW);

    NtStatus = NtQueryPerformanceCounter (&CountCurrent, NULL);
    CountPrev.LowPart  = pTimer [hTimerHandle].ulLo;
    CountPrev.HighPart = (LONG) pTimer [hTimerHandle].ulHi;
    ElapsedTime.LowPart = CountCurrent.LowPart;
    ElapsedTime.HighPart = (LONG) CountCurrent.HighPart;
    /* everything is just fine, convert to double, subtract the times,
       divide by the frequency, convert to MICROSECONDS and return
       the elapsed time as a ULONG */
    /* convert to us., divide the count by the clock frequency that
       has already been obtained */

    ElapsedTime = RtlLargeIntegerSubtract (ElapsedTime, CountPrev);

    ElapsedTime = RtlExtendedIntegerMultiply (ElapsedTime, MICROSEC_FACTOR);

    ElapsedTime = RtlExtendedLargeIntegerDivide (ElapsedTime,
                                                 PerfFreq.LowPart,
                                                 NULL);

    // if the timer is not calibrated, set ulElapsedTime to be the
    // low part of ElapsedTime.  This is because, we do not have to
    // do to any arithmetic to this before returning the value.

    if (!bCalibrated)
        ulElapsedTime = ElapsedTime.LowPart;

    /* this code is common for all platforms but OS2386.  For Win3.x
       if VTD.386 has been installed, the code below should not matter,
       since we should have returned the time by now.

       The elapsed time will be scaled, overhead subtracted
       and the time returned */

    /* we have ulElapsedTime.  Scale it and do the needful */
    /* divide or multiply by the scale factor */

    if (bCalibrated) {
        // Applications like the PROBE call TimerRead repeatedly
        // without calling TimerInit, for more than 70 minutes.  This
        // screws up things.  So treat everything as 64 bit numbers
        // until the very end.

        if ((ElapsedTime.LowPart < ulTimerOverhead) &&
            (!ElapsedTime.HighPart)) { // low part is lower than overhead
                                       // and high part is zero..then make
                                       // elapsed time 0.  We don't want
                                       // negative numbers.
            ElapsedTime.HighPart = 0L;
            ElapsedTime.LowPart = 0L;
        }

        else { // subtract the overhead in tics before converting
               // to time units
            LargeOverhead.HighPart = 0L;
            LargeOverhead.LowPart = ulTimerOverhead;

            ElapsedTime = RtlLargeIntegerSubtract (ElapsedTime,
                                                   LargeOverhead);
        }


        if (pTimer [hTimerHandle].TUnits <= MICROSECONDS) {

            ElapsedTime = RtlExtendedLargeIntegerDivide (
                                                        ElapsedTime,
                                                        aScaleValues [pTimer [hTimerHandle].TUnits],
                                                        NULL
                                                        );
        } else {
            ElapsedTime = RtlExtendedIntegerMultiply (
                                                     ElapsedTime,
                                                     aScaleValues [pTimer [hTimerHandle].TUnits]
                                                     );
        }

        // scaling is done.  Now get the time back into 32 bits.  This
        // should fit.

        ulElapsedTime = ElapsedTime.LowPart;
    }

    if ((LONG) ulElapsedTime < 0L) /* if this guy is -ve, return a 0 */
        return (0L);

    return (ulElapsedTime);
}

/*
*     Function  - TimerClose       (EXPORTED)
*     Arguments -
*               (a) SHORT - hTimerHandle
*
*     Returns  - SHORT - 0 if call successful
*                        Else, an error code if handle invalid:
*
*                            TIMERERR_INVALID_HANDLE
*
*     Releases the timer for use by future TimerOpen calls.
*     Resets the elements of the timer structure, setting the
*     Timer's Units element to TIMER_FREE.
*/

SHORT
TimerClose (
           SHORT hTimerHandle
           )
{
    if ((hTimerHandle > MAX_TIMERS - 1) ||
        (pTimer [hTimerHandle].TUnits == TIMER_FREE))
        /* error condition, wrong handle */
        return (TIMERERR_INVALID_HANDLE);

    /* otherwise, set the TimerUnits of this timer to TIMER_FREE,
       reset the other elements to zero and return */

    pTimer [hTimerHandle].TUnits = TIMER_FREE;
    pTimer [hTimerHandle].ulLo = 0L;
    pTimer [hTimerHandle].ulHi = 0L;
    return (SUCCESS_OK);
}

/*******************************************************************

     Added this routine TimerReport to report individual
     times.  Bob Day requested that such a routine be
     created.  It just maintains the time from the last
     TimerInit and TimerRead and also the last time returned.
     This routine copies this to a user specified buffer.

     Accepts - PSZ   - a pointer to a buffer to print the data out
               SHORT - timer handle

     Returns - TRUE if Timer exists and is open
             - FALSE if Timer not opened

*******************************************************************/

BOOL
FAR
PASCAL
TimerReport (
            PSZ pszReportString,
            SHORT hTimerHandle
            )
{
    if (pTimer [hTimerHandle].TUnits == TIMER_FREE)
        return (FALSE);

    /* stored value is in pTimer[hTimerHandle].ulLo and .ulHi */
    /*
    wsprintf (pszReportString,
        "Init Count (tics) %lu:%lu Current Count (tics) %lu:%lu Returned Time %lu ",
            pTimer [hTimerHandle].ulHi,
            pTimer [hTimerHandle].ulLo, CountCurrent.HighPart,
            CountCurrent.LowPart,
            ulElapsedTime);
    */
    return (TRUE);
}

/*******************************************************************

     Added this routine TimerQueryPerformanceCounter to report
     current tic count at behest of NT GDI folks.


     Accepts - PQWORD   - a pointer to a 64 bit struct. that will
                          contain tic count on return.

               PQWORD [OPTIONAL) - a pointer to a 64 bit struct. that will
                          contain frequency on return.

     Returns - None.

*******************************************************************/

VOID
FAR
PASCAL
TimerQueryPerformanceCounter 